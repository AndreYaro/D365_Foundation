<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalEngine</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LedgerJournalEngine</c> class supports the ledger journal forms with a variety of features.
/// </summary>
/// <remarks>
///  The features can be grouped into the following main areas:
///  <list type="bullet">
///   <item>
///   <description>Field and button management (enable/disable)</description>
///   </item>
///   <item>
///   <description>Caching</description>
///   </item>
///   <item>
///   <description>Voucher and journal totals</description>
///   </item>
///   <item>
///   <description>Approval functionality</description>
///   </item>
///   <item>
///   <description>Housekeeping on CRUD operations</description>
///   </item>
///   <item>
///   <description>Value defaulting</description>
///   </item>
///   <item>
///   <description>Calculation of cash discount and tax</description>
///   </item>
///   <item>
///   <description>Voucher number assignment</description>
///   </item>
///   <item>
///   <description>Error logging</description>
///   </item>
///  </list>
///
///  Some field and button management has been moved to the
///  <c>
///  LedgerJournalFormTable
///  </c>
///   and
///  <c>
///  LedgerJournalFormTrans
///  </c>
///   classes of the
///  <c>
///  JournalForm
///  </c>
///   class hierarchy. Journal locking is handled by the
///  <c>
///  LedgerJournalFormTable
///  </c>
///   class.
/// </remarks>
public class LedgerJournalEngine
{
    LedgerJournalTrans                  ledgerJournalTransOrig;
    FormDataSource                      ledgerJournalTrans_ds;
    LedgerJournalEngine_Server          ledgerJournalEngine_Server;
    LedgerJournalCheckPostResults       postingResults_Server;
    LedgerJournalCashDiscService        ledgerJournalCashDiscService;
    LedgerMethodResultCache             methodResultCache; // Stores a reference to the class that helps manage method caching.
    LedgerJournalTrans_Project          ledgerJournalTrans_Project;

    NumberSeqFormHandlerLedgerJournal   numberSeqFormHandlerJournal;

    Voucher                             oldVoucher;
    LedgerAccount                       oldAccountNum;
    Voucher                             curVoucher;
    boolean                             newVoucherNum;
    boolean                             writeInsert;
    Voucher                             voucherFetched;
    LedgerJournalId                     voucherFetchedInJournalNum;
    LedgerJournalTable                  ledgerJournalTable;
    LedgerJournalName                   ledgerJournalName;
    boolean                             voucherAmountBalances;
    boolean                             journalHasLines;    //  true: verified at least one line exists
    // false: have not verified
    RecId                               currentRecId;
    TransDate                           oldTransDate;
    TransDate                           oldRevDate;
    PostReleaseDate                     oldReleaseDate;
    boolean                             oldRevEntry;
    TransactionTextLarge                oldTransTxt;
    CurrencyCode                        oldCurrencyCode;
    Voucher                             activeVoucher;

    RecordSortedList                    voucherBalance;
    container                           voucherDateCorrect;

    AmountCur                           journalTotalOffsetBalance;
    AmountMST                           journalTotalBalance;
    AmountMSTSecondary                  journalTotalBalanceReportingCurrency;

     TaxAmountCur                        actualTaxAmount;

    [FormObservable]
    AmountMST                           journalTotalCredit;

    [FormObservable]
    AmountMST                           journalTotalDebit;

    [FormObservable]
    AmountMSTSecondary                  journalTotalCreditReportingCurrency;

    [FormObservable]
    AmountMSTSecondary                  journalTotalDebitReportingCurrency;

    Counter                             noOfRecords;

    AmountMST                           voucherTotalBalance;
    AmountCur                           voucherTotalBalanceCur;

    AmountMSTSecondary                  voucherTotalBalanceReportingCurrency;

    [FormObservable]
    AmountMST                           voucherTotalCredit;

    [FormObservable]
    AmountMST                           voucherTotalDebit;

    [FormObservable]
    AmountMSTSecondary                  voucherTotalCreditReportingCurrency;

    [FormObservable]
    AmountMSTSecondary                  voucherTotalDebitReportingCurrency;

    CurrencyCode                        companyCurrency;

    RecordSortedList                    assetTableList;
    RecordSortedList                    vendTableList;
    RecordSortedList                    custTableList;
    RecordSortedList                    paymentList;
    RecordSortedList                    bankAccountTableList;
    RecordSortedList                    ledgerJournalTxtList;
    RecordSortedList                    projTableList;
    Map                                 exchangeRateTexts; // [[company, currency, date, euro triangulation], exchange rate text]
    RecordSortedList                    custVendCashDiscList;
    Map                                 cashDiscList;

    VendTable                           vendTable;
    CustTable                           custTable;
    MainAccount                         mainAccount;
    PaymTerm                            payment;
    CashDisc                            cashDisc;
    LedgerJournalTrans                  cashDiscLedgerJournalTrans;
    BankAccountTable                    bankAccountTable;
    LedgerJournalTxt                    ledgerJournalTxt;
    ProjTable                           projTable;
    AssetTable                          assetTable;

    LedgerJournalTransTxt               ledgerJournalTransTxt[,10];
    SysTmpRecIdMap                      taxAmountDisplay;
    SysTmpRecIdMap                      taxAmountDisplayCalc;

    [FormObservable]
    TaxAmount                           taxAmountCurrentLine;

    [FormObservable]
    boolean                             taxAmountCurrentLineDisplay;
    SysTmpRecIdMap                      correctedTaxAmount;
    SysTmpRecIdMap                      correctedTaxAmountDisplay;

    [FormObservable]
    TaxAmountCur                        correctedTaxAmountCurrentLine;

    SysTmpRecIdMap                      cashDiscDirty;

    DataAreaId                          currentCompany;
    LedgerInterCompany                  ledgerInterCompany;
    TmpTaxTotals                        tmpTaxTotals;

    Description                         exchRateTxt;

    boolean                             initValueCalled;
    boolean                             locked;

    boolean                             paymentFeeExist;       // Does the active journal trans have payment fees?
    AmountMST                           saveVoucherTotalDebit;
    AmountMST                           saveVoucherTotalCredit;
    AmountMSTSecondary                  saveVoucherTotalDebitReportingCurrency;
    AmountMSTSecondary                  saveVoucherTotalCreditReportingCurrency;

    SalesPrice                          salesPrice;

    boolean                             isOffsetAcctSetByUserSinceLastDataEvent;    // State flag that indicates whether or not a user has
    // set the offset account on a transaction since the
    // record was selected to be edited.
    // <GEERU>
    RCashTable                          rCashTable;
    RecordSortedList                    rCashTableList;
    RAssetTable                         rAssetTable;
    RecordSortedList                    rAssetTableList;
    RDeferralsTable                     rDeferralsTable;
    RecordSortedList                    rDeferralsTableList;
    Map                                 childFormsMap_W;
    // </GEERU>

    // <GIN>
    LedgerJournalAC                     newAccountNum;
    LedgerJournalAC                     prevAccountNum;
    // </GIN>

    // Used to store budget check results per voucher.
    // Key: Voucher number (String)
    // Value: Budget check result (Enum)
    Map voucherBudgetCheckResults;

    // <GCN>
    boolean                             isSimpleMethod;
    LedgerVoucherTypeRefRecId_CN        ledgerVoucherTypeRecId;
    TransDate                           oldVoucherDate;
    Counter                             oldAttachment;
    Voucher_CN                          oldVoucher_CN;
    // </GCN>

    #ISOCountryRegionCodes

    boolean vatDataModified_PL;
    boolean vatDataModified;

    protected LedgerJournalTrans_RAsset ledgerJournalTrans_RAsset;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmLedgerJournalTransRAsset</Name>
				<Source><![CDATA[
    public LedgerJournalTrans_RAsset parmLedgerJournalTransRAsset(LedgerJournalTrans_RAsset _ledgerJournalTrans_RAsset = ledgerJournalTrans_RAsset)
    {
        ledgerJournalTrans_RAsset = _ledgerJournalTrans_RAsset;
        return ledgerJournalTrans_RAsset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDebCredProposalByAssetTransTypeJournalDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for determining the debit/credit proposal based on the <c>AssetTransTypeJournal</c> enumeration value.
    /// </summary>
    /// <param name = "_assetTransTypeJournal">The <c>AssetTransTypeJournal</c> on which to base the determination.</param>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide the result.</param>
    static delegate void getDebCredProposalByAssetTransTypeJournalDelegate(AssetTransTypeJournal _assetTransTypeJournal, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>callGetDebCredProposalByAssetTransTypeJournalDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Public method for accessing the <c>getDebCredProposalByAssetTransTypeJournalDelegate</c> delegate.
    /// </summary>
    /// <param name = "_assetTransTypeJournal">The <c>AssetTransTypeJournal</c> on which to base the determination.</param>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide the result.</param>
    public static void callGetDebCredProposalByAssetTransTypeJournalDelegate(AssetTransTypeJournal _assetTransTypeJournal, EventHandlerResult _result)
    {
        LedgerJournalEngine::getDebCredProposalByAssetTransTypeJournalDelegate(_assetTransTypeJournal, _result);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDebCredProposalByAssetTransTypeJournal</Name>
				<Source><![CDATA[
    private DebCredProposal getDebCredProposalByAssetTransTypeJournal(AssetTransTypeJournal _transType)
    {
        DebCredProposal ret;
        switch (_transType)
        {
            // Determine what credit category this proposal falls into.
            case AssetTransTypeJournal::Acquisition, AssetTransTypeJournal::AcquisitionAdj, AssetTransTypeJournal::WriteUpAdj,
                AssetTransTypeJournal::DisposalSale, AssetTransTypeJournal::DisposalScrap, AssetTransTypeJournal::DerogatoryDecrease:
                ret = DebCredProposal::Debit;
                break;

            case AssetTransTypeJournal::Depreciation,
                AssetTransTypeJournal::DepreciationAdj:
                ret = DebCredProposal::Credit;
                break;

            case AssetTransTypeJournal::WriteDownAdj,
                AssetTransTypeJournal::DerogatoryIncrease:
                ret = DebCredProposal::Credit;
                break;

            case AssetTransTypeJournal::Revaluation:
            default:
                ret = DebCredProposal::None;
                break;
        }

        var eventHandlerResult = new EventHandlerResult();
        LedgerJournalEngine::getDebCredProposalByAssetTransTypeJournalDelegate(_transType, eventHandlerResult);

        if (eventHandlerResult.hasResult())
        {
            return eventHandlerResult.result();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustInitializeLedgerJournalTransDefaultDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the default dimensions for the journal line record should be initialized.
    /// </summary>
    /// <returns>true if the default dimension should be initialized; false, otherwise.</returns>
    protected boolean mustInitializeLedgerJournalTransDefaultDimensions()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountModified</Name>
				<Source><![CDATA[
    public DebCredProposal accountModified(
        LedgerJournalTrans          _ledgerJournalTrans,
        LedgerJournalTrans_Project  _ledgerJournalTrans_Project = null,
        LedgerJournalTrans_Asset    _ledgerJournalTrans_Asset = null,
        Tax1099BoxDetail            _tax1099Detail = null
        ,LedgerJournalTrans_RAsset    _ledgerJournalTrans_RAsset     = null,
        LedgerJournalTrans_RDeferrals _ledgerJournalTrans_RDeferrals = null
        )
    {
        DebCredProposal             debCredProposal     = DebCredProposal::None;
        CompanyId                   companyId;
        // <GEERU>
        boolean                     countryRegion_RU    = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        // <GEERU><GEEU>
        boolean                     isCashModuleEnabled = RCashParameters::isCashModuleEnabled();
        // </GEERU></GEEU>
        // <GIN>
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtensionIN = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
        // </GIN>
        // <GTH>
        LedgerJournalTransExtensionTH    ledgerJournalTransExtensionTH;
        // </GTH>

        // Indicate that we've entered the usable scope of the cache.
        methodResultCache.enterScope(funcName());

        try
        {
            // Prepare change of company if the company exists and is different from the current company
            if (xDataArea::exist(_ledgerJournalTrans.Company))
            {
                companyId = _ledgerJournalTrans.Company;
                if (_ledgerJournalTrans.Company != currentCompany)
                {
                    ledgerInterCompany = LedgerInterCompany::findCompanyPair(currentCompany, _ledgerJournalTrans.Company);
                }
            }
            else
            {
                companyId = curext();
            }

            changecompany(companyId)
            {
                if (this.mustInitializeLedgerJournalTransDefaultDimensions())
                {
                    this.initDefaultDimension(_ledgerJournalTrans);
                    this.initOffsetDefaultDimension(_ledgerJournalTrans);
                }

                // --------------------------------------------------------------
                // Perform initialization and defaulting specific to account type.
                // --------------------------------------------------------------
                switch (_ledgerJournalTrans.AccountType)
                {
                    case LedgerJournalACType::Ledger:
                        // Using a primary account of type ledger.
                        mainAccount = _ledgerJournalTrans.findMainAccount();
                        this.initFromMainAccount(_ledgerJournalTrans);
                        if (mainAccount.DebitCreditCheck)
                        {
                            debCredProposal = mainAccount.DebitCreditCheck;
                        }
                        else
                        {
                            if (mainAccount.DebitCreditProposal)
                            {
                                debCredProposal = mainAccount.DebitCreditProposal;
                            }
                            else
                            {
                                switch (mainAccount.Type)
                                {
                                    case DimensionLedgerAccountType::Expense:
                                    case DimensionLedgerAccountType::Asset:
                                        debCredProposal = DebCredProposal::Debit;
                                        break;

                                    case DimensionLedgerAccountType::Revenue:
                                    case DimensionLedgerAccountType::Liability:
                                        debCredProposal = DebCredProposal::Credit;
                                        break;

                                    default:
                                        debCredProposal = DebCredProposal::None;
                                }
                            }
                        }
                        break;

                    case LedgerJournalACType::Cust:
                        // Using a primary account of type customer.

                        // This block performs initialization and defaults fields like offset account.
                        custTable = this.findCustTable(_ledgerJournalTrans);
                        this.initFromCustTable(_ledgerJournalTrans);
                        this.initFromCompanyInfo(_ledgerJournalTrans);
                        debCredProposal  = DebCredProposal::Debit;
                        // <GTH>
                        if (TaxThaiGovCertificationFeatureChecker::isTaxBranchParamMarked())
                        {
                            // Initiate default values for customer's tax branch.
                            ledgerJournalTransExtensionTH = _ledgerJournalTrans.ledgerJournalTransExtensionTH();
                            ledgerJournalTransExtensionTH.updateTaxBranchFromCustVendTable(custTable);
                            _ledgerJournalTrans.packExtensionTable(ledgerJournalTransExtensionTH);
                        }
                        // </GTH>
                        break;

                    case LedgerJournalACType::Vend:
                        // Using a primary account of type vendor.
                        vendTable = _ledgerJournalTrans.findVendTable();

                        if (!vendTable.RecId)
                        {
                            return DebCredProposal::None;
                        }
                        //  Determine if Invoice and Document data should be re-used on new Vendor.
                        this.initInvoiceAndDocumentForVend(_ledgerJournalTrans);

                        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                        {
                            this.initFromVendTable(_ledgerJournalTrans, _tax1099Detail);
                        }
                        else
                        {
                            this.initFromVendTable(_ledgerJournalTrans);
                        }
                        this.initFromCompanyInfo(_ledgerJournalTrans);
                        debCredProposal  = DebCredProposal::Credit;

                        // <GTH>
                        if (TaxThaiGovCertificationFeatureChecker::isTaxBranchParamMarked())
                        {
                            // Initiate default values for vendor's tax branch.
                            ledgerJournalTransExtensionTH = _ledgerJournalTrans.ledgerJournalTransExtensionTH();
                            ledgerJournalTransExtensionTH.updateTaxBranchFromCustVendTable(vendTable);
                            _ledgerJournalTrans.packExtensionTable(ledgerJournalTransExtensionTH);
                        }
                        // </GTH>
                        break;

                    case  LedgerJournalACType::FixedAssets:
                        // <GIN>
                        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
                            && AssetParameters::find().DepreciationIncomeTaxAct_IN)
                        {
                            if (newAccountNum != prevAccountNum)
                            {
                                this.initAssetBookid(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
                                prevAccountNum = newAccountNum;
                            }
                        }
                        else
                        {
                            // </GIN>
                            // Using a primary account of type fixed assets.
                            this.initAssetBookid(_ledgerJournalTrans, _ledgerJournalTrans_Asset);

                            // <GIN>
                        }
                        // </GIN>
                        this.initFromAssetTable(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
                        debCredProposal = this.getDebCredProposalByAssetTransTypeJournal(_ledgerJournalTrans_Asset.TransType);
                        break;

                    case  LedgerJournalACType::Bank:
                        // Using a primary account of type bank.
                        bankAccountTable = this.findBankAccountTable(_ledgerJournalTrans);
                        this.initFromBankTable(_ledgerJournalTrans);
                        break;

                    case  LedgerJournalACType::Project:
                        // Using a primary account of type project.
                        this.initFromProjTable(_ledgerJournalTrans, _ledgerJournalTrans_Project);
                        this.setProjDefaultOffsetAccount(_ledgerJournalTrans, _ledgerJournalTrans_Project);
                        this.setProjTransDate(_ledgerJournalTrans, _ledgerJournalTrans_Project);
                        LedgerJournalEngine::setProjCostSalesPrice(_ledgerJournalTrans, _ledgerJournalTrans_Project, this.parmSalesPrice(), false, true);
                        break;

                    // <GEERU>
                    case  LedgerJournalACType::FixedAssets_RU:
                        if (countryRegion_RU)
                        {
                            rAssetTable = this.findRAssetTable_RU(_ledgerJournalTrans);
                            this.initFromAssetTable_RU(_ledgerJournalTrans, _ledgerJournalTrans_RAsset);
                            boolean validate;
                            [validate, debCredProposal] = this.getDebCredProposalByRAssetTransType(_ledgerJournalTrans_RAsset.TransType);

                            if (!validate)
                            {
                                throw error(strFmt("@SYS73815", _ledgerJournalTrans_RAsset.TransType));
                            }
                        }
                        break;

                    case  LedgerJournalACType::RDeferrals:
                        if (countryRegion_RU)
                        {
                            rDeferralsTable = this.findRDeferralsTable_RU(_ledgerJournalTrans);
                            this.initFromRDeferralsBook_RU(_ledgerJournalTrans, _ledgerJournalTrans_RDeferrals);
                            debCredProposal  = DebCredProposal::Debit;
                        }
                        break;

                    case  LedgerJournalACType::Employee_RU:
                        if (countryRegion_RU)
                        {
                            this.initFromWorker_RU(_ledgerJournalTrans);
                            debCredProposal  = DebCredProposal::Credit;
                        }
                        break;
                    // </GEERU>

                    // <GEERU><GEEU>
                    case  LedgerJournalACType::RCash:
                        if (isCashModuleEnabled)
                        {
                            rCashTable = this.findRCashTable_RU(_ledgerJournalTrans);
                            this.initFromRCashTable_RU(_ledgerJournalTrans);
                            debCredProposal  = DebCredProposal::None;
                        }
                        break;
                    // </GEERU></GEEU>
                    // End of account type switch block.
                }

                // --------------------------------------------------------------
                // Perform general initialization and defaulting.
                // --------------------------------------------------------------
                // <GEERU>
                if (countryRegion_RU)
                {
                    // Attempt to default the offset account.
                    this.defaultOffsetAcctForAccountModifiedEvent(_ledgerJournalTrans,
                                                                  _ledgerJournalTrans_Project,
                                                                  _ledgerJournalTrans_Asset,
                                                                  _ledgerJournalTrans_RAsset,
                                                                  _ledgerJournalTrans_RDeferrals
                                                                  );
                }
                else
                {
                    // </GEERU>
                    // Attempt to default the offset account.
                    this.defaultOffsetAcctForAccountModifiedEvent(_ledgerJournalTrans, _ledgerJournalTrans_Project, _ledgerJournalTrans_Asset);
                    // <GEERU>
                }
                // </GEERU>

                if (_ledgerJournalTrans.RecId != 0)
                {
                    SpecTransManager::newFromSpec(_ledgerJournalTrans).deleteAll();
                }

                this.initTaxGroup(_ledgerJournalTrans);
                this.initTaxItemGroup(_ledgerJournalTrans,  _ledgerJournalTrans_Project);
                this.initOverrideSalesTax(_ledgerJournalTrans);

                // End of company change block.
            }

            if (ledgerJournalTable.JournalType != LedgerJournalType::Approval)
            {
                this.currencyModified(_ledgerJournalTrans);
            }

            this.cashDiscCodeModified(_ledgerJournalTrans);

            // Indicate that we've left the usable scope of the cache.
            methodResultCache.leaveScope(funcName());

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
            {
                this.populateOpTypeDependingOnAccType_MX(_ledgerJournalTrans);
            }

            this.setCashRegisterTerminal_W(_ledgerJournalTrans);
        }
        catch
        {
            // Indicate that we've left the usable scope of the cache.
            methodResultCache.leaveScope(funcName());

            // Chain the exception forward to mimic a finally block.
            throw Exception::Error;
        }

        return debCredProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDebCredProposalByRAssetTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates and gets debit/credit proposal by assset trans type .
    /// </summary>
    /// <param name = "_assetTransType">An asset trans type.</param>
    /// <returns>Container with validation and the debit/credit proposal.</returns>
    protected container getDebCredProposalByRAssetTransType(RAssetTransType _assetTransType)
    {
        DebCredProposal debCredProposal;
        boolean ret = true;

        switch (_assetTransType)
        {
            case RAssetTransType::Depreciation:
                debCredProposal = DebCredProposal::Debit;
                break;
            case RAssetTransType::DepreciationAdj:
                debCredProposal = DebCredProposal::Debit;
                break;
            case RAssetTransType::Revaluation:
                debCredProposal = DebCredProposal::None;
                break;
            case RAssetTransType::Acquisition:
                debCredProposal = DebCredProposal::Debit;
                break;
            case RAssetTransType::AcquisitionAdj:
                debCredProposal = DebCredProposal::Debit;
                break;
            case RAssetTransType::DisposalSale:
                debCredProposal = DebCredProposal::Debit;
                break;
            case RAssetTransType::DisposalScrap:
                debCredProposal = DebCredProposal::Debit;
                break;
            case RAssetTransType::WriteUpAdj:
                debCredProposal = DebCredProposal::Debit;
                break;
            case RAssetTransType::WriteDownAdj:
                debCredProposal = DebCredProposal::Debit;
                break;
            default:
                ret = false;
                break;
        }

        return [ret, debCredProposal];
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountModifiedTAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs general initialization and defaulting when debit/credit ledger dimension is changed.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// Ledger journal transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Project">
    /// Ledger journal transaction for project.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    /// Ledger journal transaction for fixed assets.
    /// </param>
    /// <remarks>
    /// Reference from this class, accountModified
    /// </remarks>
    public void accountModifiedTAccount(
        LedgerJournalTrans          _ledgerJournalTrans,
        LedgerJournalTrans_Project  _ledgerJournalTrans_Project = null,
        LedgerJournalTrans_Asset    _ledgerJournalTrans_Asset = null)
    {
        DebCredProposal             debCredProposal     = DebCredProposal::None;
        CompanyId                   companyId;

        // Indicate that we've entered the usable scope of the cache.
        methodResultCache.enterScope(funcName());

        try
        {
            ledgerJournalEngine_Server = LedgerJournalEngine_Server::construct();

            // Prepare change of company if the company exists and is different from the current company
            if (xDataArea::exist(_ledgerJournalTrans.Company))
            {
                companyId = _ledgerJournalTrans.Company;
                if (_ledgerJournalTrans.Company != currentCompany)
                {
                    ledgerInterCompany = LedgerInterCompany::findCompanyPair(currentCompany, _ledgerJournalTrans.Company);
                }
            }
            else
            {
                companyId = curext();
            }

            changecompany(companyId)
            {
                // --------------------------------------------------------------
                // Perform initialization and defaulting specific to account type.
                // --------------------------------------------------------------
                switch (_ledgerJournalTrans.AccountType)
                {
                    case LedgerJournalACType::Ledger:
                        // Using a primary account of type ledger.
                        mainAccount = _ledgerJournalTrans.findMainAccount();
                        this.initFromMainAccount(_ledgerJournalTrans);
                        if (mainAccount.DebitCreditCheck)
                        {
                            debCredProposal = mainAccount.DebitCreditCheck;
                        }
                        else
                        {
                            if (mainAccount.DebitCreditProposal)
                            {
                                debCredProposal = mainAccount.DebitCreditProposal;
                            }
                            else
                            {
                                switch (mainAccount.Type)
                                {
                                    case DimensionLedgerAccountType::Expense:
                                    case DimensionLedgerAccountType::Asset:
                                        debCredProposal = DebCredProposal::Debit;
                                        break;
                                    case DimensionLedgerAccountType::Revenue:
                                    case DimensionLedgerAccountType::Liability:
                                        debCredProposal = DebCredProposal::Credit;
                                        break;

                                    default:
                                        debCredProposal = DebCredProposal::None;
                                }
                            }
                        }
                        break;

                    case LedgerJournalACType::Cust:
                        // Using a primary account of type customer.

                        // This block performs initialization and defaults fields like offset account.
                        custTable = this.findCustTable(_ledgerJournalTrans);
                        this.initFromCustTable(_ledgerJournalTrans);
                        this.initFromCompanyInfo(_ledgerJournalTrans);
                        debCredProposal  = DebCredProposal::Debit;
                        break;

                    case LedgerJournalACType::Vend:
                        // Using a primary account of type vendor.
                        vendTable = _ledgerJournalTrans.findVendTable();

                        //  Determine if Invoice and Document data should be re-used on new Vendor.
                        this.initInvoiceAndDocumentForVend(_ledgerJournalTrans);

                        this.initFromVendTable(_ledgerJournalTrans);
                        this.initFromCompanyInfo(_ledgerJournalTrans);
                        debCredProposal  = DebCredProposal::Credit;
                        break;

                    case  LedgerJournalACType::FixedAssets:
                        // Using a primary account of type fixed assets.
                        this.initFromAssetTable(_ledgerJournalTrans, _ledgerJournalTrans_Asset);

                        switch (_ledgerJournalTrans_Asset.TransType)
                        {
                            // Determine what credit category this proposal falls into.
                            case AssetTransTypeJournal::Acquisition, AssetTransTypeJournal::AcquisitionAdj, AssetTransTypeJournal::WriteUpAdj,
                                 AssetTransTypeJournal::DisposalSale, AssetTransTypeJournal::DisposalScrap, AssetTransTypeJournal::DerogatoryDecrease:
                                debCredProposal  = DebCredProposal::Debit;
                                break;

                            case AssetTransTypeJournal::Depreciation, AssetTransTypeJournal::DepreciationAdj, AssetTransTypeJournal::WriteDownAdj,
                                 AssetTransTypeJournal::DerogatoryIncrease:
                                debCredProposal  = DebCredProposal::Credit;
                                break;

                            case AssetTransTypeJournal::Revaluation:
                                debCredProposal  = DebCredProposal::None;
                                break;
                        }
                        break;

                    case  LedgerJournalACType::Bank:
                        // Using a primary account of type bank.
                        bankAccountTable = this.findBankAccountTable(_ledgerJournalTrans);
                        this.initFromBankTable(_ledgerJournalTrans);
                        break;

                    case  LedgerJournalACType::Project:
                        // Using a primary account of type project.
                        this.initFromProjTable(_ledgerJournalTrans, _ledgerJournalTrans_Project);
                        this.setProjDefaultOffsetAccount(_ledgerJournalTrans, _ledgerJournalTrans_Project);
                        break;

                    // End of account type switch block.
                }

                // --------------------------------------------------------------
                // Perform general initialization and defaulting.
                // --------------------------------------------------------------

                if (_ledgerJournalTrans.RecId != 0)
                {
                    SpecTransManager::newFromSpec(_ledgerJournalTrans).deleteAll();
                }

                this.initTaxGroup(_ledgerJournalTrans);
                this.initTaxItemGroup(_ledgerJournalTrans,  _ledgerJournalTrans_Project);
                this.initOverrideSalesTax(_ledgerJournalTrans);

                // End of company change block.
            }

            if (ledgerJournalTable.JournalType != LedgerJournalType::Approval)
            {
                this.currencyModified(_ledgerJournalTrans);
            }

            this.cashDiscCodeModified(_ledgerJournalTrans);

            LedgerJournalEngine::setProjCostSalesPrice(_ledgerJournalTrans, _ledgerJournalTrans_Project, this.parmSalesPrice());

            // Indicate that we've left the usable scope of the cache.
            methodResultCache.leaveScope(funcName());

            this.setCashRegisterTerminal_W(_ledgerJournalTrans);
        }
        catch
        {
            // Indicate that we've left the usable scope of the cache.
            methodResultCache.leaveScope(funcName());

            // Chain the exception forward to mimic a finally block.
            throw Exception::Error;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountNumCheckUseCustomLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether the primary account uses a custom lookup.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_offsetAccountType">
    /// The offset account type; optional.
    /// </param>
    /// <returns>
    /// A value that indicates whether the primary account uses a custom lookup.
    /// </returns>
    /// <remarks>
    /// The return value of this method must be consistent with the return value of the
    /// <c>accountNumLookUp</c> method.
    /// </remarks>
    public boolean accountNumCheckUseCustomLookup(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalACType _offsetAccountType = _ledgerJournalTrans.OffsetAccountType)
    {
        // When the offset account type is vendor and the primary account type is non-ledger,
        // we need to look up default vendor accounts for the chosen primary account type.
        boolean useCustomLookup = (_offsetAccountType == LedgerJournalACType::Vend)
            && (_ledgerJournalTrans.AccountType != LedgerJournalACType::Ledger)
            && (VendDefaultAccounts::existDefaultForType(_ledgerJournalTrans.parmOffsetAccount(), _ledgerJournalTrans.AccountType, _ledgerJournalTrans.Company));

        if (!useCustomLookup)
        {
            useCustomLookup = _ledgerJournalTrans.AccountType == LedgerJournalACType::Bank
                || _ledgerJournalTrans.AccountType == LedgerJournalACType::Cust
                || _ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets
                || _ledgerJournalTrans.AccountType == LedgerJournalACType::Project
                // <GEERU>
                || _ledgerJournalTrans.AccountType == LedgerJournalACType::Employee_RU
                || _ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets_RU
                || _ledgerJournalTrans.AccountType == LedgerJournalACType::RCash
                || _ledgerJournalTrans.AccountType == LedgerJournalACType::RDeferrals
                // </GEERU>
                || _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend;
        }

        return useCustomLookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountNumLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the custom lookup for the primary account.
    /// </summary>
    /// <param name = "_formControl">
    /// The form control.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_offsetAccountType">
    /// The offset account type; optional.
    /// </param>
    /// <param name = "_offsetAccount">
    /// The offset account; optional.
    /// </param>
    /// <param name = "_ledgerJournalTrans_Asset">
    /// The <c>LedgerJournalTrans_Asset</c> record; optional.
    /// </param>
    /// <param name = "_ledgerJournalTrans_RAsset">The <c>LedgerJournalTrans_RAsset</c> record.</param>
    /// <returns>
    /// A value that indicates whether the primary account uses a custom lookup.
    /// </returns>
    /// <remarks>
    /// The return value of this method must be consistent with the return value of the
    /// <c>accountNumCheckUseCustomLookup</c> method.
    /// </remarks>
    public boolean accountNumLookup(
        FormControl         _formControl,
        LedgerJournalTrans  _ledgerJournalTrans,
        LedgerJournalACType _offsetAccountType = _ledgerJournalTrans.OffsetAccountType,
        LedgerJournalAC     _offsetAccount = _ledgerJournalTrans.parmOffsetAccount()
        , LedgerJournalTrans_Asset  _ledgerJournalTrans_Asset  = null
        , LedgerJournalTrans_RAsset _ledgerJournalTrans_RAsset = null
        )
    {
        boolean useCustomLookup = true;

        // When the offset account type is vendor and the primary account type is non-ledger,
        // we need to look up default vendor accounts for the chosen primary account type.
        if  ((_offsetAccountType == LedgerJournalACType::Vend)
            && (_ledgerJournalTrans.AccountType != LedgerJournalACType::Ledger)
            && VendDefaultAccounts::existDefaultForType(_ledgerJournalTrans.parmOffsetAccount(), _ledgerJournalTrans.AccountType, _ledgerJournalTrans.Company))
        {
            VendTable::lookupNonLedgerDefaultAccountNum(
                _formControl,
                _ledgerJournalTrans.AccountType,
                _ledgerJournalTrans.Company,
                _ledgerJournalTrans.parmOffsetAccount());
        }
        else
        {
            useCustomLookup = false;
        }

        if (!useCustomLookup)
        {
            useCustomLookup = true;

            switch (_ledgerJournalTrans.AccountType)
            {
                case LedgerJournalACType::Bank:
                    BankAccountTable::lookupBankAccount(_formControl, _ledgerJournalTrans.Company);
                    break;

                case LedgerJournalACType::Cust:
                    CustTable::lookupCustomer(_formControl, _ledgerJournalTrans.Company);
                    break;

                case LedgerJournalACType::FixedAssets:
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
                    {
                        // IF permission to sell is enabled for the Polish sale disposal,
                        // assets not marked for sale need to be filtered. asset that are not
                        // lookupAccountNum method needs the TransType value
                        // to filter appropriately the assets.
                        AssetTable::lookupAccountNum(
                            _formControl,
                            _ledgerJournalTrans.Company,
                            AssetBookType::ValueModel,
                            _ledgerJournalTrans_Asset.TransType);
                    }
                    else
                    {
                        AssetTable::lookupAccountNum(_formControl, _ledgerJournalTrans.Company);
                    }
                    break;

                case LedgerJournalACType::Project:
                    ProjTable::lookupProjId(_formControl, _ledgerJournalTrans);
                    break;

                // <GEERU>
                case LedgerJournalACType::Employee_RU:
                    EmployeeTable_RU::lookupAdvHolder(_formControl, _ledgerJournalTrans.Company);
                    break;

                case LedgerJournalACType::FixedAssets_RU:
                    RAssetTable::lookupAccountNum(_formControl, _ledgerJournalTrans.Company, _ledgerJournalTrans_RAsset.TransType);
                    break;

                case LedgerJournalACType::RCash:
                    RCashTable::lookupAccountNum(_formControl, _ledgerJournalTrans.Company);
                    break;

                case LedgerJournalACType::RDeferrals:
                    RDeferralsTable::lookupDeferrals(
                        _formControl,
                        _ledgerJournalTrans.TransDate ? _ledgerJournalTrans.TransDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                        _ledgerJournalTrans.Company);
                    break;
                // </GEERU>

                case LedgerJournalACType::Vend:
                    VendTable::lookupVendor(_formControl, _ledgerJournalTrans.Company);
                    break;

                default:
                    useCustomLookup = false;
                    break;
            }
        }

        return useCustomLookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountNumModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts the <c>LedgerJournalTrans</c> table record and optionally <c>LedgerJournalTrans_Project</c>
    ///    fields in response to a change in the <c>AccountNumber</c> value.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table record being modified.
    /// </param>
    /// <param name="_ledgerJournalTransProj">
    ///    The optional <c>LedgerJournalTrans_Project</c> table record being modified; optional.
    /// </param>
    public void accountNumModified(LedgerJournalTrans _ledgerJournalTrans,
                                    LedgerJournalTrans_Project _ledgerJournalTransProj = null)
    {
        // <GIN>
        TransTaxInformation                 transTaxInformation;
        LedgerJournalTransTaxExtensionIN    ledgerJournalTransTaxExt;
        TaxInformationVendTable_IN taxInformationVendTable_IN;
        TaxInformationCustTable_IN taxInformationCustTable_IN;
        // </GIN>
        
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
        {
            _ledgerJournalTrans.setDefaultAccount(false, _ledgerJournalTrans.parmAccount());
            _ledgerJournalTrans.RemittanceLocation = VendTable::getDefaultRemittanceLocation(_ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.Company);
            _ledgerJournalTrans.RemittanceAddress = LogisticsPostalAddress::addressRecIdFromLocationRecId(_ledgerJournalTrans.RemittanceLocation);
            this.clearCashDiscount(_ledgerJournalTrans);
            _ledgerJournalTrans.validateW9Received(false, AccountOffsetaccount::Account);

            // <GTH>
            if (TaxThaiGovCertificationFeatureChecker::isTaxWithholdEnabled())
            {
                _ledgerJournalTrans.TaxWithholdCalculate_TH = VendTable::find(_ledgerJournalTrans.parmAccount()).TaxWithholdCalculate;
            }
            // </GTH>
            // <GIN>
            if (TaxWithholdParameters_IN::checkTaxParameters())
            {
                transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_ledgerJournalTrans, true);
                if (transTaxInformation)
                {
                    taxInformationVendTable_IN = VendTable::find(_ledgerJournalTrans.parmAccount()).getTaxInformationVendTable_IN();
                    ttsbegin;
                    transTaxInformation.ApplyGSTTDS = taxInformationVendTable_IN.ApplyGSTTDS;
                    transTaxInformation.ApplyGSTTCS = taxInformationVendTable_IN.ApplyGSTTCS;
                    transTaxInformation.TaxWithholdSoftwareDeclReceived      = NoYes::No;
                    transTaxInformation.update();
                    ttscommit;
                }
            }
            // </GIN>
        }
        else
        {
            //This is when Accounttype is modified. See if this should be done in AccountTypeModified event.
            _ledgerJournalTrans.RemittanceLocation = 0;
            _ledgerJournalTrans.RemittanceAddress = 0;
            // <GTH>
            if (TaxThaiGovCertificationFeatureChecker::isTaxWithholdEnabled())
            {
                _ledgerJournalTrans.TaxWithholdCalculate_TH = CustTable::find(_ledgerJournalTrans.parmAccount()).TaxWithholdCalculate_TH;
            }
            // </GTH>
        }

        // <GIN>
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust && TaxWithholdParameters_IN::checkTaxParameters())
        {
            transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_ledgerJournalTrans, true);
            if (transTaxInformation)
            {
                taxInformationCustTable_IN = CustTable::find(_ledgerJournalTrans.parmAccount()).getTaxInformationCustTable_IN();
                if (taxInformationCustTable_IN.CustomerType == CustomerType_IN::GovtCompanyOrOtherAgencies)
                {
                    transTaxInformation.ApplyGSTTDS = NoYes::Yes;
                    transTaxInformation.ApplyGSTTCS = NoYes::No;
                }
                else if (taxInformationCustTable_IN.CustomerType == CustomerType_IN::ECommerceOperator)
                {
                    transTaxInformation.ApplyGSTTDS = NoYes::No;
                    transTaxInformation.ApplyGSTTCS = NoYes::Yes;
                }
                else
                {
                    transTaxInformation.ApplyGSTTDS = NoYes::No;
                    transTaxInformation.ApplyGSTTCS = NoYes::No;
                }
                ttsbegin;
                transTaxInformation.update();
                ttscommit;
            }
        }
        // </GIN>

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project)
        {
            Qty origQty = _ledgerJournalTransProj.Qty;
            CostPrice origCostPrice = _ledgerJournalTransProj.CostPrice;
            AmountCurCredit origCredit = _ledgerJournalTrans.AmountCurCredit;
            AmountCurDebit origDebit = _ledgerJournalTrans.AmountCurDebit;

            this.setProjAmount(_ledgerJournalTrans, _ledgerJournalTransProj);

            // This was done as part of bug #371280. setProjAmount() call cannot be removed due to backward compatibility hence resetting the values after the call.
            _ledgerJournalTransProj.Qty = origQty;
            _ledgerJournalTransProj.CostPrice = origCostPrice;
            _ledgerJournalTrans.AmountCurCredit = origCredit;
            _ledgerJournalTrans.AmountCurDebit = origDebit;

            this.setDefaultValuesForProjTrans(_ledgerJournalTrans, _ledgerJournalTransProj);
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)) && _ledgerJournalTrans.isProjectTransaction())
        {
            _ledgerJournalTransProj.setPayWhenPaid(_ledgerJournalTrans);
        }

        _ledgerJournalTrans.setSettleVoucher();

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            _ledgerJournalTrans.setAgreementEmptyValues_RU();
        }
        // </GEERU>
        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
        }

        if (TaxWithholdParameters_IN::checkTaxParameters()
            && ledgerJournalTransTaxExt.TaxWithholdCode != ''
            && _ledgerJournalTrans.orig().LedgerDimension != _ledgerJournalTrans.LedgerDimension)
        {
            ledgerJournalTransTaxExt.TaxWithholdCode = '';
        }
        // </GIN>

        this.setCashRegisterTerminal_W(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountTypeModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts a <c>LedgerJournalTrans</c> table record and optionally <c>LedgerJournalTrans_Project</c>
    ///    fields in response to a change in the <c>AccountType</c> value.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table record being modified.
    /// </param>
    /// <param name="_ledgerJournalTrans_Project">
    ///    The <c>LedgerJournalTrans_Project</c> table record being modified; optional.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table record being modified; optional.
    /// </param>
    /// <param name="_ledgerJournalTrans_RCash">
    ///    The <c>LedgerJournalTrans_RCash</c> table record being modified; optional.
    /// </param>
    public void accountTypeModified(LedgerJournalTrans _ledgerJournalTrans,
                                    LedgerJournalTrans_Project _ledgerJournalTrans_Project = null,
                                    LedgerJournalTrans_Asset _ledgerJournalTrans_Asset = null,
                                    LedgerJournalTrans_RCash _ledgerJournalTrans_RCash = null)
    {
        // <GEERU>
        boolean    countryRegion_RU    = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        // <GEEU><GEERU>
        boolean    isCashModuleEnabled = RCashParameters::isCashModuleEnabled();
        // </GEEU></GEERU>
        // <GEEPL>
        LedgerJournalTrans  ledgerJournalTransMain;
        // </GEEPL>
        // <GIN>
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt;
        // </GIN>

        _ledgerJournalTrans.parmLedgerDimension(0);
        _ledgerJournalTrans.CashDiscBaseDate = dateNull();
        _ledgerJournalTrans.CashDiscBaseDays = 0;

        if (_ledgerJournalTrans.AccountType != LedgerJournalACType::Cust &&
            _ledgerJournalTrans.AccountType != LedgerJournalACType::Vend)
        {
            // <GEEPL>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
            {
                ledgerJournalTransMain = LedgerJournalTrans::mainAccount(_ledgerJournalTrans.JournalNum,
                                                                            _ledgerJournalTrans.Voucher);

                if (ledgerJournalTransMain.AccountType != LedgerJournalACType::Cust &&
                    ledgerJournalTransMain.AccountType != LedgerJournalACType::Vend)
                {
                    // </GEEPL>
                    _ledgerJournalTrans.vatNumJournal = '';
                    LedgerJournalTransTaxExtension taxExtension = _ledgerJournalTrans.ledgerJournalTransTaxExtension();
                    taxExtension.VATNumRecId = 0;
                    taxExtension.VATNumTableType = TaxExemptNumberSourceType::None;
                    _ledgerJournalTrans.packExtensionTable(taxExtension);
                    // <GEEPL>
                }
            }
            else if (LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalType != LedgerJournalType::Approval)
            {
                _ledgerJournalTrans.vatNumJournal = '';
                LedgerJournalTransTaxExtension taxExtension = _ledgerJournalTrans.ledgerJournalTransTaxExtension();
                taxExtension.VATNumRecId = 0;
                taxExtension.VATNumTableType = TaxExemptNumberSourceType::None;
                _ledgerJournalTrans.packExtensionTable(taxExtension);
            }
            // </GEEPL>
        }

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project)
        {
            this.setProjTransDate(_ledgerJournalTrans, _ledgerJournalTrans_Project);
            this.setProjAmount(_ledgerJournalTrans, _ledgerJournalTrans_Project);
        }

        if (_ledgerJournalTrans.isFixedAssetsTransaction())
        {
            // This is a fixed assets transaction so synchronize the asset id, and company id; default the
            // book id if necessary.
            _ledgerJournalTrans_Asset.AssetId = _ledgerJournalTrans.getAssetId();
            _ledgerJournalTrans_Asset.Company = _ledgerJournalTrans.getAssetCompany();
            this.defaultBookIdForFATransaction(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
        }
        else
        {
            // This is not a fixed assets transaction so clear out the company, asset id and book id fields.
            _ledgerJournalTrans_Asset.AssetId = '';
            _ledgerJournalTrans_Asset.Company = '';
            _ledgerJournalTrans_Asset.BookId  = '';
        }

        _ledgerJournalTrans.setSettleVoucher();
        this.clearCashDiscount(_ledgerJournalTrans);
        // <GEERU><GEEU>
        if (isCashModuleEnabled)
        {
            this.setRCashDocType_RU(_ledgerJournalTrans, _ledgerJournalTrans_RCash);
        }
        if (countryRegion_RU)
        {
            _ledgerJournalTrans.setAgreementEmptyValues_RU();
            this.setFactureAutoCreate(_ledgerJournalTrans, AccountOffsetaccount::Account);
        }
        // </GEERU></GEEU>

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
        }

        if (TaxWithholdParameters_IN::checkTaxParameters()
            && ledgerJournalTransTaxExt.TaxWithholdCode != '')
        {
            ledgerJournalTransTaxExt.TaxWithholdCode = '';
        }
        // </GIN>

        this.setCashRegisterTerminal_W(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>active</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when a <c>LedgerJournalTrans</c> record has changed on a datasource.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    void active(LedgerJournalTrans _ledgerJournalTrans)
    {
        Counter     pos;
        NoYes       voucherDateCorrected;
        boolean     custVend;
        boolean     allowEdit;
        boolean     readagain;

        // Reset the state flag that indicates that the offset account has been set since the
        // last data event.
        isOffsetAcctSetByUserSinceLastDataEvent = false;

        this.voucherTotals(_ledgerJournalTrans);

        pos                     = conFind(voucherDateCorrect, _ledgerJournalTrans.Voucher);
        voucherDateCorrected    = conPeek(voucherDateCorrect, pos+1);                               // Has the date of the voucher been changed?
        custVend                = _ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
                                  _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend;

        readagain               = this.rereadWhenDirty(_ledgerJournalTrans, voucherDateCorrected == NoYes::Yes);
        allowEdit               = this.allowEditTrans(_ledgerJournalTrans);
        voucherAmountBalances   = this.voucherAmountBalances(_ledgerJournalTrans.CurrencyCode);

        if (ledgerJournalTrans_ds)  // work around for callback from form.close() to LedgerJournalTable.active()
        {
            ledgerJournalTrans_ds.allowEdit(allowEdit);
            ledgerJournalTrans_ds.allowDelete(allowEdit);

            // when the journal requires approval disable create for approved journals
            if (ledgerJournalTable.ledgerJournalName().ApproveActive)
            {
                ledgerJournalTrans_ds.allowCreate(!ledgerJournalTable.Approver);
            }
        }
        oldTransDate = _ledgerJournalTrans.TransDate;
        oldRevDate   = _ledgerJournalTrans.ReverseDate;
        oldRevEntry  = _ledgerJournalTrans.ReverseEntry;
        oldReleaseDate = _ledgerJournalTrans.ReleaseDate;

        if (activeVoucher != _ledgerJournalTrans.Voucher)
        {
            this.taxAmountOrig();
        }

        cashDiscLedgerJournalTrans.data(_ledgerJournalTrans);

        if (allowEdit && ((activeVoucher != _ledgerJournalTrans.Voucher) || (custVend && readagain)|| !_ledgerJournalTrans.Voucher))
        {
            ledgerJournalCashDiscService = new LedgerJournalCashDiscService(_ledgerJournalTrans.JournalNum,
                                                                            _ledgerJournalTrans.Voucher,
                                                                            _ledgerJournalTrans);
        }
        activeVoucher = _ledgerJournalTrans.Voucher;
        // <GCN>
        if (LedgerParameters::isChineseVoucher_CN()
            && _ledgerJournalTrans.RecId)
        {
            oldVoucherDate          = _ledgerJournalTrans.TransDate;
            oldAttachment           = _ledgerJournalTrans.Attachments_CN;
            ledgerVoucherTypeRecId  = _ledgerJournalTrans.LedgerVoucherType_CN;
        }
        // </GCN>

        if (custVend)
        {
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                custTable = this.findCustTable(_ledgerJournalTrans);
            }
            else
            {
                vendTable = _ledgerJournalTrans.findVendTable();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBudgetCheckResultToCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the budget check result for the specified voucher to the budget check results cache.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher for the budget check result.
    /// </param>
    /// <param name="_budgetCheckResult">
    /// The new budget check result.
    /// </param>
    /// <returns>
    /// true if the budget check result is added to the cache; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Existing budget check result for the specified voucher in the cache is replaced with the new budget
    /// check result.
    /// </remarks>
    public boolean addBudgetCheckResultToCache(Voucher _voucher, BudgetCheckResult _budgetCheckResult)
    {
        return voucherBudgetCheckResults.insert(_voucher, _budgetCheckResult);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMainAccountDimensionValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the dimension values that are associated to the main account and the first collection of dimensions.
    /// </summary>
    /// <param name = "_mainAccountId">
    /// The ID of the main account.
    /// </param>
    /// <param name = "_preceedingDimensionSpecifiers">
    /// The previous collection of dimension specifiers.
    /// </param>
    /// <param name = "_segmentedEntryControl">
    /// The segmented entry control.
    /// </param>
    /// <param name = "_dimensionControlSegment">
    /// The segment that was changed.
    /// </param>
    /// <param name = "_currentMainAccountId">
    /// The record ID of the current main account.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The ID of the new main account.
    /// </returns>
    [Hookable(true)]
    protected final Map addMainAccountDimensionValues(
        RecId _mainAccountId,
        Map _preceedingDimensionSpecifiers,
        SegmentedEntryControl _segmentedEntryControl,
        DimensionControlSegment _dimensionControlSegment,
        RecId _currentMainAccountId,
        LedgerJournalTrans _ledgerJournalTrans)
    {
        MainAccountLegalEntity          mainAccountLegalEntity;
        Map                             dimensionSpecifiers;
        Map                             mainAccountDimensionSpecifiers;

        mainAccountLegalEntity = MainAccountLegalEntity::findByMainAccountLegalEntity(_mainAccountId, CompanyInfo::current());
        if (mainAccountLegalEntity.DefaultDimension)
        {
            mainAccountDimensionSpecifiers = LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(mainAccountLegalEntity.DefaultDimension);
            if (_preceedingDimensionSpecifiers)
            {
                dimensionSpecifiers = LedgerDimensionDefaultingEngine::addDimensionSpecifiers(_preceedingDimensionSpecifiers, mainAccountDimensionSpecifiers);
            }
            else
            {
                dimensionSpecifiers = mainAccountDimensionSpecifiers;
            }
        }
        else
        {
            dimensionSpecifiers = _preceedingDimensionSpecifiers;
        }

        return dimensionSpecifiers;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustDueDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the due date so that it falls on a business day per specified calendar source.
    /// </summary>
    /// <param name="_dueDate">
    /// The original due date.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaction table buffer that specifies the calendar source.
    /// </param>
    /// <returns>
    /// The adjusted due date.
    /// </returns>
    /// <remarks>
    /// If no adjustment is needed, the original date is returned.
    /// </remarks>
    protected DueDate adjustDueDate(DueDate _dueDate, LedgerJournalTrans _ledgerJournalTrans)
    {
        PaymentDueDateUpdatePolicy updatePolicy;
        DueDate adjustedDate;

        adjustedDate = _dueDate;

        switch (_ledgerJournalTrans.AccountType)
        {
            case LedgerJournalACType::Cust:
                updatePolicy = payment.CustomerUpdateDueDate;
                break;

            case LedgerJournalACType::Vend:
                updatePolicy = payment.VendorUpdateDueDate;
                break;

            default:
                updatePolicy = PaymentDueDateUpdatePolicy::NoUpdate;
                break;
        }

        if (updatePolicy != PaymentDueDateUpdatePolicy::NoUpdate)
        {
            adjustedDate = PaymCalendarSourceLedgerJournalTrans::adjustDate(_dueDate, updatePolicy, _ledgerJournalTrans);
        }

        return adjustedDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustDueDateAddressChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the due date in the <c>LedgerJournalTrans</c> record to a valid business day if a
    /// third-party rule exists.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The record to validate the due date for.
    /// </param>
    /// <param name="_paymCalendarModuleType">
    /// The module type to restrict the calendar rule by.
    /// </param>
    /// <remarks>
    /// The method is run when the address for a document changes.
    /// </remarks>
    public void adjustDueDateAddressChange(LedgerJournalTrans _ledgerJournalTrans, PaymCalendarModuleType _paymCalendarModuleType)
    {
        PaymCalendarAdjustedDate paymCalendarAdjustedDate;

        paymCalendarAdjustedDate = PaymCalendarSourceLedgerJournalTrans::getAdjustedDateForAddressChange(_ledgerJournalTrans, _paymCalendarModuleType);

        if (_ledgerJournalTrans.Due != paymCalendarAdjustedDate.parmAdjustedDueDate())
        {
            _ledgerJournalTrans.Due = paymCalendarAdjustedDate.parmAdjustedDueDate();

            this.refreshDataSource(_ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustDueDateOnPaymentMethodChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the due date in the <c>LedgerJournalTrans</c> record to a valid business day if a calendar
    /// rule restricted to the payment method exists.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The record to validate the due date for.
    /// </param>
    /// <param name="_paymCalendarModuleType">
    /// The module type to restrict the calendar rule by.
    /// </param>
    /// <remarks>
    /// The method is run when the payment method for a document changes.
    /// </remarks>
    public void adjustDueDateOnPaymentMethodChange(LedgerJournalTrans _ledgerJournalTrans, PaymCalendarModuleType _paymCalendarModuleType)
    {
        PaymCalendarAdjustedDate paymCalendarAdjustedDate;

        paymCalendarAdjustedDate = PaymCalendarSourceLedgerJournalTrans::getAdjustedDateForPaymentMethodChange(_ledgerJournalTrans, _paymCalendarModuleType);

        if (_ledgerJournalTrans.Due != paymCalendarAdjustedDate.parmAdjustedDueDate())
        {
            _ledgerJournalTrans.Due = paymCalendarAdjustedDate.parmAdjustedDueDate();

            this.refreshDataSource(_ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when the journal line has been written.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    protected void adjustLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        Counter pos;

        if (oldTransDate != _ledgerJournalTrans.TransDate)
        {
            if (LedgerParameters::find().CheckVoucher == ReuseVoucher::AcceptDuplicate &&
                ledgerJournalTable.ledgerJournalName().NewVoucher == NewVoucher::OneVoucher)
            {
                oldTransDate = _ledgerJournalTrans.TransDate;
                return;
            }

            if (LedgerJournalEngine_Server::adjustDate(_ledgerJournalTrans, this))
            {
                // Record that the voucher date has been changed
                pos = conFind(voucherDateCorrect, _ledgerJournalTrans.Voucher);
                if (pos)
                {
                    voucherDateCorrect = conPoke(voucherDateCorrect, pos+1, NoYes::Yes);
                }
            }
            oldTransDate = _ledgerJournalTrans.TransDate;
        }

        if (oldRevEntry != _ledgerJournalTrans.ReverseEntry)
        {
            LedgerJournalEngine_Server::adjustRevDate(_ledgerJournalTrans);
            pos = conFind(voucherDateCorrect,_ledgerJournalTrans.Voucher);
            if (pos)
            {
                voucherDateCorrect = conPoke(voucherDateCorrect,pos+1,NoYes::Yes);
            }

            oldRevEntry = _ledgerJournalTrans.ReverseEntry;
            //the following line prevents the next 'if' from unnecessarily running the same code again in the case where both fields changed
            oldRevDate = _ledgerJournalTrans.ReverseDate;
        }

        if (oldRevDate != _ledgerJournalTrans.ReverseDate)
        {
            LedgerJournalEngine_Server::adjustRevDate(_ledgerJournalTrans);
            pos = conFind(voucherDateCorrect,_ledgerJournalTrans.Voucher);
            if (pos)
            {
                voucherDateCorrect = conPoke(voucherDateCorrect,pos+1,NoYes::Yes);
            }

            oldRevDate = _ledgerJournalTrans.ReverseDate;
        }

        if (oldReleaseDate != _ledgerJournalTrans.ReleaseDate)
        {
            LedgerJournalEngine_Server::adjustReleaseDate(_ledgerJournalTrans);
            oldReleaseDate = _ledgerJournalTrans.ReleaseDate;
            pos = conFind(voucherDateCorrect,_ledgerJournalTrans.Voucher);
            if (pos)
            {
                voucherDateCorrect = conPoke(voucherDateCorrect,pos+1,NoYes::Yes);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>agreementJumpRef_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the agreement form for the <c>LedgerJournalTrans</c> record depending on account type.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_accountOffsetaccount">
    /// Account type, account or offset account; optional.
    /// </param>
    public void agreementJumpRef_RU(LedgerJournalTrans   _ledgerJournalTrans,
                                    AccountOffsetaccount _accountOffsetaccount = AccountOffsetaccount::Account)
    {
        LedgerJournalACType ledgerJournalACType;
        AgreementHeaderExtRecId_RU agreementHeaderExtRecId;
        DataAreaId agreementCompany;

        ledgerJournalACType = _accountOffsetaccount == AccountOffsetaccount::Account ? _ledgerJournalTrans.AccountType : _ledgerJournalTrans.OffsetAccountType;

        if (ledgerJournalACType != LedgerJournalACType::Cust &&
            ledgerJournalACType != LedgerJournalACType::Vend    )
        {
            return;
        }

        agreementHeaderExtRecId = this.findAgreementHeaderExt_RU(_ledgerJournalTrans, _accountOffsetaccount).RecId;
        if (_accountOffsetaccount == AccountOffsetaccount::Account)
        {
            agreementCompany = _ledgerJournalTrans.AgreementCompany_RU ? _ledgerJournalTrans.AgreementCompany_RU : curext();
        }
        else
        {
            agreementCompany = _ledgerJournalTrans.OffsetAgreementCompany_RU ? _ledgerJournalTrans.OffsetAgreementCompany_RU : curext();
        }

        if (ledgerJournalACType == LedgerJournalACType::Cust)
        {
            SalesAgreementHeaderExt_RU::salesAgreementJumpRef(agreementHeaderExtRecId, agreementCompany);
        }
        else
        {
            PurchAgreementHeaderExt_RU::purchAgreementJumpRef(agreementHeaderExtRecId, agreementCompany);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>agreementLookup_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Lookups the agreement for the <c>LedgerJournalTrans</c> record depending on account type.
    /// </summary>
    /// <param name="_callingControl">
    /// The calling control.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_filterStr">
    /// Filter for agreement; optional.
    /// </param>
    /// <param name="_accountOffsetaccount">
    /// Account type, account or offset account; optional.
    /// </param>
    public void agreementLookup_RU(FormStringControl    _callingControl,
                                   LedgerJournalTrans   _ledgerJournalTrans,
                                   str                  _filterStr = '',
                                   AccountOffsetaccount _accountOffsetaccount = AccountOffsetaccount::Account)
    {
        LedgerJournalACType   ledgerJournalACType;
        CustVendAC            agreementPartnerCode;
        DataAreaId            agreementCompany, company;
        SalesTable            salesTable;
        PurchTable            purchTable;
        RecId                 partyId;

        void lookupAgreement()
        {
            if (ledgerJournalACType == LedgerJournalACType::Cust)
            {
                salesTable.CustAccount = agreementPartnerCode;
                salesTable.ShippingDateRequested = _ledgerJournalTrans.TransDate;

                SalesAgreementHeader::salesAgreementLookup(_callingControl, salesTable, _filterStr);
            }
            else
            if (ledgerJournalACType == LedgerJournalACType::Vend)
            {
                purchTable.OrderAccount = agreementPartnerCode;
                purchTable.DeliveryDate = _ledgerJournalTrans.TransDate;

                PurchAgreementHeader::purchAgreementLookup(_callingControl, purchTable, _filterStr);
            }
        }

        ledgerJournalACType = _accountOffsetaccount == AccountOffsetaccount::Account ? _ledgerJournalTrans.AccountType : _ledgerJournalTrans.OffsetAccountType;

        if (ledgerJournalACType != LedgerJournalACType::Cust &&
            ledgerJournalACType != LedgerJournalACType::Vend    )
        {
            return;
        }

        if (_accountOffsetaccount == AccountOffsetaccount::Account)
        {
            agreementPartnerCode = _ledgerJournalTrans.parmAccount();
            agreementCompany     = _ledgerJournalTrans.AgreementCompany_RU ? _ledgerJournalTrans.AgreementCompany_RU : curext();
            company              = _ledgerJournalTrans.Company ? _ledgerJournalTrans.Company : curext();
        }
        else
        {
            agreementPartnerCode = _ledgerJournalTrans.parmOffsetAccount();
            agreementCompany     = _ledgerJournalTrans.OffsetAgreementCompany_RU ? _ledgerJournalTrans.OffsetAgreementCompany_RU :curext();
            company              = _ledgerJournalTrans.OffsetCompany ?  _ledgerJournalTrans.OffsetCompany : curext();
        }

        if (agreementCompany != company)
        {
            if (ledgerJournalACType == LedgerJournalACType::Cust)
            {
                partyId = CustTable::findByCompany(company, agreementPartnerCode).Party;
                changecompany(agreementCompany)
                {
                    agreementPartnerCode = CustTable::findByPartyRecId(partyId).AccountNum;
                }
            }
            else
            if (ledgerJournalACType == LedgerJournalACType::Vend)
            {
                partyId = VendTable::findByCompany(company, agreementPartnerCode).Party;
                changecompany(agreementCompany)
                {
                    agreementPartnerCode = VendTable::findByPartyRecId(partyId).AccountNum;
                }
            }
        }

        if (agreementCompany != curext())
        {
            changecompany(agreementCompany)
            {
                lookupAgreement();
            }
        }
        else
        {
            lookupAgreement();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEdit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the journal should be editable.
    /// </summary>
    /// <returns>
    /// true if the journal should be editable; otherwise, false.
    /// </returns>
    protected boolean allowEdit()
    {
        if (ledgerJournalTable.Posted || ledgerJournalTable.Approver)
        {
            return false;
        }

        if (ledgerJournalTable.UserBlockId != curUserId() && ledgerJournalTable.UserBlockId)
        {
            return false;
        }

        if (ledgerJournalTable.GroupBlockId && ! UserInfoHelp::userInUserGroup(curUserId(), ledgerJournalTable.GroupBlockId))
        {
            return false;
        }

        if (ledgerJournalTable.SystemBlocked)
        {
            return false;
        }

        if (ledgerJournalTable.ReportedAsReadyBy&&
            !ledgerJournalTable.RejectedBy &&
            !UserInfoHelp::userInUserGroup(curUserId(), ledgerJournalName.ApproveGroupId))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if editing of the <c>ledgerJournalTrans</c> buffer should be allowed.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>ledgerJournalTrans</c> buffer to be checked.
    /// </param>
    /// <returns>
    /// true, if editing of the <c>ledgerJournalTrans</c> buffer is allowed; otherwise, false.
    /// </returns>
    protected boolean allowEditTrans(LedgerJournalTrans   _ledgerJournalTrans)
    {
        boolean ret;
        ;

        ret = !locked;
        ret = ret && this.allowEdit();
        ret = ret && !_ledgerJournalTrans.NoEdit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditVatRegister_PL</Name>
				<Source><![CDATA[
    public void allowEditVatRegister_PL(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean allowEdit = _ledgerJournalTrans.CustVendAccount_PL ? false : true;
        FormDataSource ledgerJournalTransLoc = FormDataUtil::getFormDataSource(_ledgerJournalTrans);

        if (ledgerJournalTransLoc)
        {
            ledgerJournalTransLoc.object(fieldNum(LedgerJournalTrans, vatNumJournal)).allowEdit(allowEdit);
            ledgerJournalTransLoc.object(fieldNum(LedgerJournalTrans, Addressing_PL)).allowEdit(allowEdit);
            ledgerJournalTransLoc.object(fieldNum(LedgerJournalTrans, CustVendName_PL)).allowEdit(allowEdit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountCurCreditModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts a <c>LedgerJournalTrans</c> table record and optionally <c>LedgerJournalTrans_Project</c>
    ///    fields in response to a change in the <c>AmountCurCredit</c> field.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table record being modified.
    /// </param>
    /// <param name="_ledgerJournalTransProj">
    ///    The <c>LedgerJournalTrans_Project</c> table record being modified; optional.
    /// </param>
    /// <param name="_ledgerJournalTrans_RCash">
    /// The optional <c>LedgerJournalTrans_RCash</c> table record being modified.
    /// </param>
    public void amountCurCreditModified(LedgerJournalTrans         _ledgerJournalTrans,
                                        LedgerJournalTrans_Project _ledgerJournalTransProj   = null,
                                        LedgerJournalTrans_RCash   _ledgerJournalTrans_RCash = null)
    {
        _ledgerJournalTrans.AmountCurCredit = CurrencyExchange::round(_ledgerJournalTrans.AmountCurCredit, _ledgerJournalTrans.CurrencyCode);

        if (_ledgerJournalTrans.AmountCurCredit)
        {
            _ledgerJournalTrans.AmountCurDebit = 0;
        }

        if ((_ledgerJournalTrans.AccountType == LedgerJournalACType::Project) ||
            (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project &&
             _ledgerJournalTrans.parmOffsetLedgerDimension()))
        {
            this.setProjAmount(_ledgerJournalTrans, _ledgerJournalTransProj);
        }
        // <GEERU><GEEU>
        if (RCashParameters::isCashModuleEnabled())
        {
            this.setRCashDocType_RU(_ledgerJournalTrans, _ledgerJournalTrans_RCash);
        }
        // </GEERU></GEEU>

        // <GIN>
        if (TaxParameters::checkTaxParameters_IN())
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtension = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
            ledgerJournalTransTaxExtension.AssessableValueTransactionCurrency = _ledgerJournalTrans.AmountCurDebit ? _ledgerJournalTrans.AmountCurDebit : _ledgerJournalTrans.AmountCurCredit;
            if (FormDataUtil::isFormDataSource(ledgerJournalTransTaxExtension))
            {
                ledgerJournalTransTaxExtension.Update();
            }
            else
            {
                _ledgerJournalTrans.packExtensionTable(ledgerJournalTransTaxExtension);
            }

            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled()
                && LedgerJournalTrans::isCustomerPaymentWithTDSCalculation_IN(_ledgerJournalTrans)
                && ledgerJournalTransTaxExtension.ExcludedGSTAmountCur > _ledgerJournalTrans.AmountCurCredit)
            {
                throw Error("@TaxGST:CheckExcludedGSTAmount");
            }
        }
        if (this.isGSTTDS_IN(_ledgerJournalTrans))
        {
            this.updateGSTTDSAmountWhenJournalAmountNotMatch_IN(_ledgerJournalTrans);
        }
        // </GIN>

        this.setCashRegisterTerminal_W(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountCurDebitModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts a <c>LedgerJournalTrans</c> table record and optionally <c>LedgerJournalTrans_Project</c>
    ///    fields in response to a change in the <c>AmountCurDebit</c> value.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table record being modified.
    /// </param>
    /// <param name="_ledgerJournalTransProj">
    ///    The <c>LedgerJournalTrans_Project</c> table record being modified; optional.
    /// </param>
    /// <param name="_ledgerJournalTrans_RCash">
    /// The optional <c>LedgerJournalTrans_RCash</c> table record being modified.
    /// </param>
    public void amountCurDebitModified(LedgerJournalTrans _ledgerJournalTrans,
                                        LedgerJournalTrans_Project _ledgerJournalTransProj   = null,
                                        LedgerJournalTrans_RCash   _ledgerJournalTrans_RCash = null)
    {
        _ledgerJournalTrans.AmountCurDebit = CurrencyExchange::round(_ledgerJournalTrans.AmountCurDebit, _ledgerJournalTrans.CurrencyCode);

        if (_ledgerJournalTrans.AmountCurDebit)
        {
            _ledgerJournalTrans.AmountCurCredit = 0;
        }

        if ((_ledgerJournalTrans.AccountType == LedgerJournalACType::Project) ||
            (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project &&
             _ledgerJournalTrans.parmOffsetLedgerDimension()))
        {
            this.setProjAmount(_ledgerJournalTrans, _ledgerJournalTransProj);
        }

        // <GEERU><GEEU>
        if (RCashParameters::isCashModuleEnabled())
        {
            this.setRCashDocType_RU(_ledgerJournalTrans, _ledgerJournalTrans_RCash);
        }
        // </GEERU></GEEU>

        if (TaxParameters::checkTaxParameters_IN())
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtension = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
            ledgerJournalTransTaxExtension.AssessableValueTransactionCurrency = _ledgerJournalTrans.AmountCurDebit ? _ledgerJournalTrans.AmountCurDebit : _ledgerJournalTrans.AmountCurCredit;
            if (FormDataUtil::isFormDataSource(ledgerJournalTransTaxExtension))
            {
                ledgerJournalTransTaxExtension.Update();
            }
            else
            {
                _ledgerJournalTrans.packExtensionTable(ledgerJournalTransTaxExtension);
            }

            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled()
                    && LedgerJournalTrans::isVendorPaymentWithTDSCalculation_IN(_ledgerJournalTrans)
                    && ledgerJournalTransTaxExtension.ExcludedGSTAmountCur > _ledgerJournalTrans.AmountCurDebit)
            {
                throw Error("@TaxGST:CheckExcludedGSTAmount");
            }
        }
        if (this.isGSTTDS_IN(_ledgerJournalTrans))
        {
            this.updateGSTTDSAmountWhenJournalAmountNotMatch_IN(_ledgerJournalTrans);
        }

        this.setCashRegisterTerminal_W(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>approveActive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the ApproveActive field from the <c>LedgerJournalName</c> record.
    /// </summary>
    /// <returns>
    /// The ApproveActive field from the <c>LedgerJournalName</c> record.
    /// </returns>
    public boolean approveActive()
    {
        return ledgerJournalName.ApproveActive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>approved</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the journal is approved.
    /// </summary>
    /// <returns>
    /// true if the journal is approved; otherwise, false.
    /// </returns>
    public boolean approved()
    {
        return (ledgerJournalTable.Approver || !ledgerJournalName.ApproveActive);
    }

]]></Source>
			</Method>
			<Method>
				<Name>approvedBy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the approver of the journal.
    /// </summary>
    /// <returns>
    /// The personnel number of the approver of the journal.
    /// </returns>
    public ApprovedByPersonnelNumber approvedBy()
    {
        return HcmWorker::find(ledgerJournalTable.Approver).PersonnelNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetBookIdModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reinitializes transaction data when the asset book of the transaction is changed.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer that stores part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table buffer that stores part of the transaction.
    /// </param>
    public void assetBookIdModified (LedgerJournalTrans       _ledgerJournalTrans,
                                     LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        ;

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
        {
            // This is a fixed assets transaction because the primary account is of type
            // fixed assets.

            // Initialize the posting profile and attempt to default the offset account.
            this.initAssetPostingProfile(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
            this.defaultOffsetAccountForFATransaction(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetLedgerDimension_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger account to post a transaction with an account of fixed assets.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <param name="_ledgerJournalTrans_RAsset">
    /// A <c>LedgerJournalTrans_RAsset</c> table buffer.
    /// </param>
    /// <returns>
    /// The ledger account to post a transaction with an account of fixed assets.
    /// </returns>
    public LedgerDimensionDefaultAccount assetLedgerDimension_RU(LedgerJournalTrans       _ledgerJournalTrans,
                                                                 LedgerJournalTrans_RAsset _ledgerJournalTrans_RAsset)
    {
        RAssetStandards rAssetStandards = RAssetStandards::find(_ledgerJournalTrans.parmAccount(), _ledgerJournalTrans_RAsset.StandardId);
        return rAssetStandards.assetLedgerDimension(_ledgerJournalTrans_RAsset.StandardId,
            _ledgerJournalTrans.PostingProfile,
            _ledgerJournalTrans_RAsset.TransType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetOffsetLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the ledger account to post a transaction with an offset account of fixed assets.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> table buffer with the posting profile defined.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    A <c>LedgerJournalTrans_Asset</c> table buffer with both the transaction type and the depreciation
    ///    book defined.
    /// </param>
    /// <returns>
    ///    The ledger account to post a transaction with an offset account of fixed assets.
    /// </returns>
    public LedgerDimensionDefaultAccount assetOffsetLedgerDimension(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount;

        if (_ledgerJournalTrans_Asset.assetBookPostsToGeneralLedger())
        {
            ledgerDimensionDefaultAccount = _ledgerJournalTrans.findAssetTable().assetOffsetLedgerDimension(
                _ledgerJournalTrans.PostingProfile,
                AssetPost::assetTransTypeJournal2AssetTransType(_ledgerJournalTrans_Asset.TransType
                    // <GJP>
                    , _ledgerJournalTrans_Asset.DocumentType_JP
                    // </GJP>
                    ),
                _ledgerJournalTrans_Asset.BookId
                // <GJP>
                , false
                , _ledgerJournalTrans_Asset.DocumentType_JP
                // </GJP>
                );
        }

        return ledgerDimensionDefaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetOffsetLedgerDimension_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger account to post a transaction with an offset account of fixed assets.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <param name="_ledgerJournalTrans_RAsset">
    /// A <c>LedgerJournalTrans_RAsset</c> table buffer.
    /// </param>
    /// <returns>
    /// The ledger account to post a transaction with an offset account of fixed assets.
    /// </returns>
    public LedgerDimensionDefaultAccount assetOffsetLedgerDimension_RU(LedgerJournalTrans       _ledgerJournalTrans,
                                                                       LedgerJournalTrans_RAsset _ledgerJournalTrans_RAsset)
    {
        RAssetStandards rAssetStandards = RAssetStandards::find(_ledgerJournalTrans_RAsset.AssetId, _ledgerJournalTrans_RAsset.StandardId);
        return rAssetStandards.assetOffsetLedgerDimension(_ledgerJournalTrans_RAsset.StandardId,
            _ledgerJournalTrans.PostingProfile,
            _ledgerJournalTrans_RAsset.TransType,
            _ledgerJournalTrans.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetTransTypeModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reinitializes transaction data when the transaction type is changed.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer that stores part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table buffer that stores part of the transaction.
    /// </param>
    public void assetTransTypeModified(LedgerJournalTrans       _ledgerJournalTrans,
                                       LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
        {
            this.initAssetPostingProfile(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
            this.defaultOffsetAccountForFATransaction(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankAccountIdModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Resets the offset account type and number according to the selected bank account.
    /// </summary>
    /// <param name="ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record buffer being modified.
    /// </param>
    public void bankAccountIdModified(LedgerJournalTrans ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankCentralBankPurposeCodeModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Resets the purpose text that is used for reporting to the central bank when the purpose code is changed.
    /// </summary>
    /// <param name="ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record buffer to modify.
    /// </param>
    public void bankCentralBankPurposeCodeModified(LedgerJournalTrans ledgerJournalTrans)
    {
        BankCentralBankPurpose  bankCentralBankPurpose;

        select firstonly Text
                        // <GEERU>
                        ,TransTypeCur_RU
                        // </GEERU>
                        from bankCentralBankPurpose
            where bankCentralBankPurpose.Code == ledgerJournalTrans.BankCentralBankPurposeCode;

        ledgerJournalTrans.BankCentralBankPurposeText = bankCentralBankPurpose.Text;

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            ledgerJournalTrans.BankCentralBankTransTypeCur_RU = bankCentralBankPurpose.TransTypeCur_RU;
        }
        // </GEERU>

        this.refreshDataSource(ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankDepositVoucherModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts a <c>LedgerJournalTrans</c> table record and optionally <c>LedgerJournalTrans_Project</c>
    ///    fields in response to a change in the <c>BankDepositVoucher</c> value.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table record being modified.
    /// </param>
    /// <param name="_ledgerJournalTransProj">
    ///    The <c>LedgerJournalTrans_Project</c> table record being modified; optional.
    /// </param>
    public void bankDepositVoucherModified(LedgerJournalTrans _ledgerJournalTrans,
                                            LedgerJournalTrans_Project _ledgerJournalTransProj = null)
    {
        if (_ledgerJournalTrans.BankDepositVoucher && _ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Bank)
        {
            _ledgerJournalTrans.OffsetAccountType = LedgerJournalACType::Bank;
            _ledgerJournalTrans.parmOffsetLedgerDimension(0);
            this.initTaxItemGroup(_ledgerJournalTrans, _ledgerJournalTransProj);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankRemittanceTypeModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Resets offset account type and number according to the selected bank remittance type.
    /// </summary>
    /// <param name="ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record buffer to modify.
    /// </param>
    void bankRemittanceTypeModified(LedgerJournalTrans ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankTransTypeModified_RU</Name>
				<Source><![CDATA[
    public void bankTransTypeModified_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAndUpdateInterestAndFine_BR</Name>
				<Source><![CDATA[
    private void calcAndUpdateInterestAndFine_BR(LedgerJournalTrans _ledgerJournalTrans)
    {
        SpecTrans                       specTransCur;
        CustVendTransOpen               custVendTransOpenCur;
        LedgerJournalType               journalType;
        CustVendOpenTransManager        openTransManager;
        boolean                         updateSettleAmount = false;

        journalType = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalType;

        if (journalType == LedgerJournalType::Payment ||
            journalType == LedgerJournalType::CustPayment)
        {
            boolean updateDiscountWhenPaymentDateChangedFeature = UpdateDiscountWhenPaymentDateChangedFeature::isEnabled();

            if (updateDiscountWhenPaymentDateChangedFeature)
            {
                openTransManager = CustVendOpenTransManager_BR::construct(_ledgerJournalTrans);
            }
            else
            {
                openTransManager = CustVendOpenTransManager::construct(_ledgerJournalTrans);
            }

            boolean isCustFineInterestCalculated, isVendFineInterestCalculated;
            while select crosscompany RefCompany, RefRecId, RefTableId, CashDiscToTake from specTransCur
                where specTransCur.SpecCompany == _ledgerJournalTrans.Company &&
                    specTransCur.SpecTableId == _ledgerJournalTrans.TableId &&
                    specTransCur.SpecRecId == _ledgerJournalTrans.RecId
            {
                changecompany(specTransCur.RefCompany)
                {
                    if (specTransCur.RefTableId == tableNum(CustTransOpen))
                    {
                        custVendTransOpenCur = CustTransOpen::find(specTransCur.RefRecId, true);
                    }
                    else
                    {
                        custVendTransOpenCur = VendTransOpen::find(specTransCur.RefRecId, true);
                    }

                    openTransManager.calcAndUpdateInterestAndFine_BR(
                        specTransCur.RefCompany,
                        custVendTransOpenCur,
                        _ledgerJournalTrans.TransDate,
                        specTransCur.CashDiscToTake);

                    custVendTransOpenCur.update();

                    if (CustVendTransOpenCur.FineAmount_BR || custVendTransOpenCur.InterestAmount_BR)
                    {
                        updateSettleAmount = true;
                        if (!isCustFineInterestCalculated && custVendTransOpenCur.TableId == tableNum(CustTransOpen))
                        {
                            isCustFineInterestCalculated = true;
                        }
                        if (!isVendFineInterestCalculated && custVendTransOpenCur.TableId == tableNum(VendTransOpen))
                        {
                            isVendFineInterestCalculated = true;
                        }
                    }
                }
            }

            if (updateSettleAmount)
            {
                this.findSettledAmount(_ledgerJournalTrans);
                if (isCustFineInterestCalculated)
                {
                    GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceBR00066, funcName());
                }
                else if (isVendFineInterestCalculated)
                {
                    GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceBR00065, funcName());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the cash discount.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTrans_Asset">
    /// The <c>LedgerJournalTrans_Asset</c> record; optional.
    /// </param>
    /// <param name = "_updateDetail">
    /// Determines if detail should be updated; optional.
    /// </param>
    protected void calcCashDisc(LedgerJournalTrans       _ledgerJournalTrans,
                                LedgerJournalTrans_Asset _ledgerJournalTrans_Asset = null,
                                boolean                  _updateDetail = false)
    {
        if (_ledgerJournalTrans.Invoice && ledgerJournalCashDiscService.cashDiscCode() ||
           (_ledgerJournalTrans.CashDiscPercent && ledgerJournalCashDiscService.invoiceId() && !ledgerJournalCashDiscService.cashDiscCode()))
        {
            if (_ledgerJournalTrans.RecId)
            {
                LedgerJournalEngine_Server::calcCashDisc(_ledgerJournalTrans,
                                                        this.taxAmountPerLine(_ledgerJournalTrans),
                                                        _updateDetail);

                this.custVendCashDiscCache(true, _ledgerJournalTrans);
            }
            else
            {
                this.calcVirtualCashDisc(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
            }

            this.refreshDataSource(_ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPaymentFee</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the payment fees that might apply to a journal line and updates the journal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record buffer to calculate fees for.
    /// </param>
    public void calcPaymentFee(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_ledgerJournalTrans.RecId &&
            (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
             _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend))
        {
            if (FormDataUtil::getFormDataSource(_ledgerJournalTrans) &&
                (_ledgerJournalTrans.orig().parmOffsetLedgerDimension()     != _ledgerJournalTrans.parmOffsetLedgerDimension() ||
                 _ledgerJournalTrans.orig().OffsetAccountType != _ledgerJournalTrans.OffsetAccountType))
            {
                this.dataSourceWrite(_ledgerJournalTrans);
            }

            this.saveVoucherBalance(_ledgerJournalTrans);

            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                if (_ledgerJournalTrans.PaymMode &&
                    !CustPaymModeTable::find(_ledgerJournalTrans.PaymMode).FurtherPosting)
                {
                    CustVendPaymJournalFee::createJournalFeeCust(_ledgerJournalTrans);
                }
                else
                {
                    if (CustVendPaymJournalFee::shouldDeleteJournalFee(_ledgerJournalTrans))
                    {
                        CustVendPaymJournalFee::deleteJournalFee(_ledgerJournalTrans);
                    }
                }
            }
            else
            {
                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                {
                    if (_ledgerJournalTrans.PaymMode &&
                        !VendPaymModeTable::find(_ledgerJournalTrans.PaymMode).FurtherPosting)
                    {
                        CustVendPaymJournalFee::createJournalFeeVend(_ledgerJournalTrans);
                    }
                    else
                    {
                        if (CustVendPaymJournalFee::shouldDeleteJournalFee(_ledgerJournalTrans))
                        {
                            CustVendPaymJournalFee::deleteJournalFee(_ledgerJournalTrans);
                        }
                    }
                }
            }
            // Ensure correct balances in the journal.
            this.recalcVoucherBalance(_ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the cash discount.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    void calculateCashDisc(LedgerJournalTrans _ledgerJournalTrans)
    {
        CashDiscCode    cashDiscCode;

        // <GEERU>
        boolean countryRegion_RU    = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        // <GEERU>
        if (countryRegion_RU
            && _ledgerJournalTrans.AccountAgreementId_RU)
        {
            cashDiscCode = AgreementHeaderDefault::findAgreementHeader(
                AgreementHeaderExt_RU::findByAgreementId(_ledgerJournalTrans.AccountAgreementId_RU).AgreementHeader).CashDiscountCode;
        }
        else
        {
            // </GEERU>
            switch (_ledgerJournalTrans.AccountType)
            {
                case LedgerJournalACType::Cust:
                    cashDiscCode = custTable.CashDisc;
                    break;

                case LedgerJournalACType::Vend:
                    cashDiscCode = vendTable.CashDisc;
                    break;
            }

            // <GEERU>
        }

        // </GEERU>
        if (!cashDiscCode)
        {
            if (!ledgerJournalCashDiscService)
            {
                ledgerJournalCashDiscService = new LedgerJournalCashDiscService(_ledgerJournalTrans.JournalNum,
                                                                                _ledgerJournalTrans.Voucher,
                                                                                _ledgerJournalTrans);
            }
            cashDiscCode = ledgerJournalCashDiscService.cashDiscCode();
        }

        if (cashDiscCode || _ledgerJournalTrans.CashDiscCode)
        {
            // Lookup the cache disc record buffer in the internal cache
            this.findCashDisc(_ledgerJournalTrans.Company, cashDiscCode ? cashDiscCode : _ledgerJournalTrans.CashDiscCode);

            if (_ledgerJournalTrans.amount())
            {
                if (!_ledgerJournalTrans.CashDiscCode)
                {
                    _ledgerJournalTrans.CashDiscCode = cashDiscCode;
                    this.calcCashDisc(_ledgerJournalTrans);
                    _ledgerJournalTrans.CashDiscCode = '';
                }
                else
                {
                    this.calcCashDisc(_ledgerJournalTrans);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTaxForCompleteJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates tax totals for all of the journal.
    /// </summary>
    /// <remarks>
    ///    The tax total is stored in an instance of the temporary <c>TmpTaxTotals</c>. The instance is in scope for the lifetime of the <c>ledgerJournalEngine</c> object.
    /// </remarks>
    public void calculateTaxForCompleteJournal()
    {
        container           packedTaxTotalsDef;
        container           packedTaxTotals;
        container           packedTaxDisplayCache;

        SysRecordSortedList taxTotals;
        boolean             moreTaxTotals;
        TmpTaxTotals        tmpTaxTotalsLocal;

        [packedTaxTotalsDef, packedTaxTotals, packedTaxDisplayCache] = LedgerJournalEngine_Server::calculateTaxForCompleteJournal(ledgerJournalTable.JournalNum);

        taxTotals = SysRecordSortedList::constructFromPacked(packedTaxTotalsDef, packedTaxTotals);

        tmpTaxTotals = null;
        moreTaxTotals = taxTotals.first(tmpTaxTotalsLocal);
        while (moreTaxTotals)
        {
            tmpTaxTotals.clear();

            tmpTaxTotals = this.initTmpTaxTotals(tmpTaxTotalsLocal);

            tmpTaxTotals.insert();
            moreTaxTotals = taxTotals.next(tmpTaxTotalsLocal);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTmpTaxTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes temporary Tax totals for the journal.
    /// </summary>
    /// <param name = "_tmpTaxTotalsLocal">
    /// The <c>TmpTaxTotals</c> record.
    /// </param>
    /// <returns>
    /// The initialized <c>TmpTaxTotals</c> buffer.
    /// </returns>
    protected TmpTaxTotals initTmpTaxTotals(TmpTaxTotals _tmpTaxTotalsLocal)
    {
        tmpTaxTotals.JournalNum                 = ledgerJournalTable.JournalNum;
        tmpTaxTotals.Name                       = ledgerJournalTable.Name;
        tmpTaxTotals.TaxCode                    = _tmpTaxTotalsLocal.TaxCode;
        tmpTaxTotals.TaxDirection               = _tmpTaxTotalsLocal.TaxDirection;
        tmpTaxTotals.CurrencyCode               = _tmpTaxTotalsLocal.CurrencyCode;
        tmpTaxTotals.TaxAmountCur               = _tmpTaxTotalsLocal.TaxAmountCur;
        tmpTaxTotals.TaxAmountCurRegulated      = _tmpTaxTotalsLocal.TaxAmountCurRegulated;
        tmpTaxTotals.TaxAmountCurCorrect        = _tmpTaxTotalsLocal.TaxAmountCurCorrect;

        return tmpTaxTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcVirtualCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the virtual cash discount.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTrans_Asset">
    /// The <c>LedgerJournalTrans_Asset</c> record; optional.
    /// </param>
    public void calcVirtualCashDisc(LedgerJournalTrans       _ledgerJournalTrans,
                                    LedgerJournalTrans_Asset _ledgerJournalTrans_Asset = null)
    {
        using (TaxIntegrationTaxCalculationNoDelayContext taxCalculationNoDelayContext = TaxIntegrationTaxCalculationNoDelayContext::getInstance())
        {
            if (TaxParameters::find().CashDiscOnInvoice)
            {
                [_ledgerJournalTrans.DateCashDisc, _ledgerJournalTrans.CashDiscAmount, _ledgerJournalTrans.CashDiscPercent] =
                    LedgerJournalEngine_Server::calcVirtualCashDiscOnInvoice(
                        _ledgerJournalTrans,
                        this.correctedTaxAmount(_ledgerJournalTrans));
            }
            else
            {
                [_ledgerJournalTrans.DateCashDisc, _ledgerJournalTrans.CashDiscAmount] =
                    LedgerJournalEngine_Server::calcVirtualCashDisc(
                        _ledgerJournalTrans,
                        _ledgerJournalTrans_Asset,
                        this.taxAmountJournal(_ledgerJournalTrans),
                        this.correctedTaxAmount(_ledgerJournalTrans));
            }
        }
        this.custVendCashDiscCache(true, _ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDefaultOffsetAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the offset account should apply the default for a fixed assets transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> lines of the transaction.
    /// </param>
    /// <returns>
    ///    true if the offset account can be applied by default; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method should be used for cases like book or transaction type modification, which might try to
    ///    reapply a default offset account from the matching posting profile.
    /// </remarks>
    protected boolean canDefaultOffsetAccount(LedgerJournalTrans _ledgerJournalTrans)
    {
        ;

        if (_ledgerJournalTrans.RecId)
        {
            // The record has been saved.

            if (!_ledgerJournalTrans.parmOffsetLedgerDimension())
            {
                // The offset account hasn't been set, so it's okay to default in
                // a value.
                return true;
            }
        }
        else
        {
            // The record hasn't been saved.

            if (!isOffsetAcctSetByUserSinceLastDataEvent)
            {
                // The user hasn't set the value since the record has been created,
                // so it's okay to default in a value (can default over a default).
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the value of the cash discount of the line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <returns>
    ///    The <c>cashDiscAmount</c> from the <c>LedgerJournalTrans</c> record buffer.
    /// </returns>
    AmountCur cashDiscAmount(LedgerJournalTrans _ledgerJournalTrans)
    {
        return _ledgerJournalTrans.CashDiscAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscBaseDateModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when the payment terms base date is modified.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    public void cashDiscBaseDateModified(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_ledgerJournalTrans.CashDiscCode)
        {
            this.calculateCashDisc(_ledgerJournalTrans);
        }

        this.paymentModified(_ledgerJournalTrans);

        this.refreshDataSource(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscCodeLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Opens the customer cash discount code lookup form for the current ledger line.
    /// </summary>
    /// <param name="_formStringControl">
    ///    The form control the lookup is to return the value to.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    ///    The ledger line that contains the company to display currencies for.
    /// </param>
    public void cashDiscCodeLookup(
        FormStringControl      _formStringControl,
        LedgerJournalTrans     _ledgerJournalTrans)
    {
        CashDisc::lookupCashDiscCode(_formStringControl,
                                     _ledgerJournalTrans.Company);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscCodeModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when the cash discount code is modified.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTrans_Asset">
    /// The <c>LedgerJournalTrans_Asset</c> record; optional.
    /// </param>
    /// <param name = "_updateCashDisc">
    /// Determines if the cash discount amount should be updated; optional.
    /// </param>
    public void cashDiscCodeModified(LedgerJournalTrans       _ledgerJournalTrans,
                                     LedgerJournalTrans_Asset _ledgerJournalTrans_Asset = null,
                                     boolean                  _updateCashDisc = false)
    {
        TaxParameters taxParameters = TaxParameters::find();
        boolean shouldUpdateCashDiscount = _updateCashDisc;

        if (taxParameters.CashDiscOnInvoice)
        {
            _ledgerJournalTrans.CashDiscPercent = CashDisc::find(_ledgerJournalTrans.CashDiscCode).Percent;
            _ledgerJournalTrans.CashDiscAmount  = 0;
        }

        if (!ledgerJournalCashDiscService)
        {
            if (_ledgerJournalTrans.isTaxIntegrationEnabled())
            {
                ledgerJournalCashDiscService = new LedgerJournalCashDiscService(
                    _ledgerJournalTrans.JournalNum,
                    _ledgerJournalTrans.Voucher,
                    _ledgerJournalTrans);
            }
            else
            {
                ledgerJournalCashDiscService = new LedgerJournalCashDiscService(
                    _ledgerJournalTrans.JournalNum,
                    _ledgerJournalTrans.Voucher);
            }
            activeVoucher = _ledgerJournalTrans.Voucher;
        }

        ledgerJournalCashDiscService.setCashDiscParameters(
            _ledgerJournalTrans.Company,
            _ledgerJournalTrans.CashDiscCode,
            _ledgerJournalTrans.Invoice,
            _ledgerJournalTrans.AccountType);

        boolean isCashDiscDeductedBeforeTaxCalculation = TaxIntegrationTaxJurisdictionParameters::shouldCashDiscDeductedBeforeTaxCalc(_ledgerJournalTrans, taxParameters);
        if (isCashDiscDeductedBeforeTaxCalculation
            && (_ledgerJournalTrans.CashDiscCode != cashDiscLedgerJournalTrans.CashDiscCode
                  || _ledgerJournalTrans.CashDiscPercent != cashDiscLedgerJournalTrans.CashDiscPercent
                  || _ledgerJournalTrans.CashDiscAmount != cashDiscLedgerJournalTrans.CashDiscAmount
                  || _ledgerJournalTrans.DateCashDisc != cashDiscLedgerJournalTrans.DateCashDisc))
        {
            this.clearTaxAmountCache(_ledgerJournalTrans);
        }

        if (ledgerJournalCashDiscService.invoiceId() && ledgerJournalCashDiscService.cashDiscCode())
        {
            this.findCashDisc(ledgerJournalCashDiscService.getCompany(), ledgerJournalCashDiscService.cashDiscCode());

            //
            // When calculating tax less discount we always need to zero the discount and remove
            // any manual adjustments so the tax will be calculated properly since the
            // previous discount amount is based on the old percentage.
            //
            if (isCashDiscDeductedBeforeTaxCalculation)
            {
                this.deleteCashDisc(_ledgerJournalTrans);
                if (!_updateCashDisc)
                {
                    _ledgerJournalTrans.CashDiscAmount = 0;
                }
            }

            //
            // When a value in LedgerJournalTrans is changed, a new VendTransCashDisc record is
            // updated depending on the given cash discount boolean parameter. If this paramater is
            // false, a check should be performed to determine if any manual cash discounts exist.
            // If so, the cash discount will be updated accordingly.
            //
            if (!shouldUpdateCashDiscount)
            {
                VendTransCashDisc vendTransCashDisc;

                select firstonly vendTransCashDisc where
                                    vendTransCashDisc.RefTableId == _ledgerJournalTrans.TableId &&
                                    vendTransCashDisc.RefRecId   == _ledgerJournalTrans.RecId   &&
                                    vendTransCashDisc.Manual;
                
                if (vendTransCashDisc)
                {
                    shouldUpdateCashDiscount = true;
                }
            }
                    
            this.calcCashDisc(_ledgerJournalTrans, _ledgerJournalTrans_Asset, shouldUpdateCashDiscount);
        }
        else
        {
            this.deleteCashDisc(_ledgerJournalTrans);
            _ledgerJournalTrans.CashDiscAmount = 0;
            _ledgerJournalTrans.CashDiscPercent = 0;
            _ledgerJournalTrans.DateCashDisc   = dateNull();
        }

        cashDiscLedgerJournalTrans.data(_ledgerJournalTrans);

        this.refreshDataSource(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscPercent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the cash discount percentage of the current cash discount code, if cash discount is applicable.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A LedgerJournalTrans record buffer.
    /// </param>
    /// <returns>
    ///    The cash discount percentage.
    /// </returns>
    public Percent cashDiscPercent(LedgerJournalTrans _ledgerJournalTrans)
    {
        if ((_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
            _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend) &&
            !_ledgerJournalTrans.Invoice)
        {
            return 0;
        }

        return CashDisc::find(_ledgerJournalTrans.CashDiscCode).Percent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscPercentModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when the cash discount percentage is modified.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_updateCashDisc">
    /// Determines if the cash discount amount should be updated; optional.
    /// </param>
    void cashDiscPercentModified(LedgerJournalTrans _ledgerJournalTrans,
                                 boolean            _updateCashDisc = false)
    {
        if (!ledgerJournalCashDiscService)
        {
            ledgerJournalCashDiscService = new LedgerJournalCashDiscService(_ledgerJournalTrans.JournalNum,
                                                                            _ledgerJournalTrans.Voucher);
            activeVoucher = _ledgerJournalTrans.Voucher;
        }

        ledgerJournalCashDiscService.setCashDiscParameters(
            _ledgerJournalTrans.Company,
            _ledgerJournalTrans.CashDiscCode,
            _ledgerJournalTrans.Invoice,
            _ledgerJournalTrans.AccountType,
            _ledgerJournalTrans.CashDiscPercent);

        if (ledgerJournalCashDiscService.invoiceId() && ledgerJournalCashDiscService.cashDiscPercent())
        {
            this.calcCashDisc(_ledgerJournalTrans, null, _updateCashDisc);
        }
        else
        {
            this.deleteCashDisc(_ledgerJournalTrans);
            _ledgerJournalTrans.CashDiscAmount = 0;
            _ledgerJournalTrans.CashDiscPercent = 0;
            _ledgerJournalTrans.DateCashDisc   = dateNull();
        }

        if (TaxIntegrationTaxJurisdictionParameters::shouldCashDiscDeductedBeforeTaxCalc(_ledgerJournalTrans))
        {
            this.clearTaxAmountCache(_ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDateinPeriod_CN</Name>
				<Source><![CDATA[
    private boolean checkDateinPeriod_CN(
        LedgerJournalTrans  _ledgerJournalTrans,
        TransDate           _oldDate)
    {
        FiscalCalendarPeriod         oldPeriod;
        FiscalCalendarPeriod         newPeriod;
        FiscalCalendarRecId          fiscalCalendarRecId = CompanyInfoHelper::fiscalCalendarRecId();
        LedgerFiscalCalendarPeriod   ledgerFiscalCalendarPeriod;

        if (!LedgerFiscalCalendar::findYearEndClosingPeriodByDate(fiscalCalendarRecId, _ledgerJournalTrans.TransDate).RecId)
        {
            // The transaction date is not in a valid period.
            return checkFailed("@GLS54501");
        }

        oldPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(fiscalCalendarRecId, _oldDate);
        newPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(fiscalCalendarRecId, _ledgerJournalTrans.TransDate);

        if (!newPeriod.RecId)
        {
            // The transaction date is not in a valid period.
            return checkFailed("@GLS54501");
        }

        select firstonly Status from ledgerFiscalCalendarPeriod
            where ledgerFiscalCalendarPeriod.FiscalCalendarPeriod == newPeriod.RecId
                && ledgerFiscalCalendarPeriod.Ledger == Ledger::current();

        if (ledgerFiscalCalendarPeriod.Status == FiscalPeriodStatus::Open)
        {
            if (!isSimpleMethod
                && newPeriod.StartDate != oldPeriod.StartDate)
            {
                // The transaction date is in different period. Do you wish to continue?
                if (Box::yesNo("@GLS54500", DialogButton::Yes) == DialogButton::Yes)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            return true;
        }
        else
        {
            // The period of this date is closed or stopped
            return checkFailed("@GLS54751");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxBookSection_IT</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Italian functionality of VAT books and VAT book sections.
    /// </summary>
    protected void checkTaxBookSection_IT()
    {
        #ISOCountryRegionCodes

        if (MultipleTaxIdReportingHelper::isLegalEntityOrAddressInCountryRegion([#isoIT], MultipleTaxIdScope::VATDeclaration) &&
            ledgerJournalName.TaxBookTypeJournal != TaxBookTypeJournal::Empty)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIT00028, funcName());
            if (! TaxBookSection::checkTaxBookSection(
                                ledgerJournalName.NumberSequenceTable,
                                oldTransDate))
            {
                throw error("@SYS71652");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVoucher_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the voucher type.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaction.
    /// </param>
    /// <returns>
    /// If 'True', the voucher check is succeed.
    /// </returns>
    public boolean checkVoucher_CN(LedgerJournalTrans _ledgerJournalTrans)
    {
        RefRecId    numberSequenceTableRecId;

        if (!_ledgerJournalTrans.LedgerVoucherType_CN)
        {
            // Voucher type must be selected first
            return checkFailed("@GLS60256");
        }

        numberSequenceTableRecId = LedgerVoucherType_CN::find(_ledgerJournalTrans.LedgerVoucherType_CN).NumberSequenceTable;

        if (!NumberSeq::numCheckFormat(_ledgerJournalTrans.Voucher_CN, NumberSequenceTable::find(numberSequenceTableRecId)))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCashDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the cash discount information for a journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    public void clearCashDiscount(LedgerJournalTrans _ledgerJournalTrans)
    {
        VendTransCashDisc vendTransCashDisc;

        //Initialize the CashDisc fields value when accountType or accountNum has modified.
        _ledgerJournalTrans.CashDiscCode    = '';
        _ledgerJournalTrans.CashDiscAmount  = 0;
        _ledgerJournalTrans.CashDiscPercent = 0;
        _ledgerJournalTrans.DateCashDisc    = dateNull();

        //Delete corresponding VendTransCashDisc table record when accountType or accountNum has modified.
        if (_ledgerJournalTrans.RecId != 0)
        {
            delete_from vendTransCashDisc
                where vendTransCashDisc.RefRecId   == _ledgerJournalTrans.RecId &&
                      vendTransCashDisc.RefTableId == _ledgerJournalTrans.TableId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCorrectedTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the internal cache that holds the corrected tax amount.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    public void clearCorrectedTaxAmount(LedgerJournalTrans _ledgerJournalTrans)
    {
        // clear the entire cache because if taxes are based on invoice total then
        // all lines tax amounts could change.
        correctedTaxAmount        = SysTmpRecIdMap::construct(Types::Real);
        correctedTaxAmountDisplay = SysTmpRecIdMap::construct(Types::Integer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPostingResults_Server</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new local instance of the <c>LedgerJournalCheckPostResults</c> class.
    /// </summary>
    public void clearPostingResults_Server()
    {
        postingResults_Server = LedgerJournalCheckPostResults::newServer();
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTaxAmountCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the internal caches for tax amounts.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <param name="_clearTaxUncommitted">
    /// A Boolean value that indicates whether the <c>TaxUncommitted</c> record will get cleared for this
    /// voucher and invoice; optional.
    /// </param>
    public void clearTaxAmountCache(LedgerJournalTrans _ledgerJournalTrans, boolean _clearTaxUncommitted = true)
    {
        LedgerJournalTrans origLedgerJournalTrans;

        // clear the entire cache because if taxes are based on invoice total then
        // all lines tax amounts could change.
        taxAmountDisplay          = SysTmpRecIdMap::construct(Types::Real);
        taxAmountDisplayCalc      = SysTmpRecIdMap::construct(Types::Integer);

        if (_ledgerJournalTrans.RecId)
        {
            if (_clearTaxUncommitted)
            {
                origLedgerJournalTrans = _ledgerJournalTrans.orig();

                if (origLedgerJournalTrans.Invoice == _ledgerJournalTrans.Invoice)
                {
                    if (TaxUncommitted::existByDocumentAndInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice))
                    {
                        TaxUncommitted::deleteForInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice);
                    }

                    // <GIN>
                    if (TaxWithholdParameters_IN::checkTaxParameters())
                    {
                        if (TaxWithholdUncommitted_IN::existByDocumentAndInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice))
                        {
                            TaxWithholdUncommitted_IN::deleteForInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice);
                        }
                    }
                    // </GIN>
                }
                else
                {
                    if (TaxUncommitted::existByDocumentAndInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, origLedgerJournalTrans.Invoice))
                    {
                        TaxUncommitted::deleteForInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, origLedgerJournalTrans.Invoice);
                    }

                    // <GIN>
                    if (TaxWithholdParameters_IN::checkTaxParameters())
                    {
                        if (TaxWithholdUncommitted_IN::existByDocumentAndInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice))
                        {
                            TaxWithholdUncommitted_IN::deleteForInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice);
                        }
                    }
                    // </GIN>
                }
            }
            this.clearCorrectedTaxAmount(_ledgerJournalTrans);
        }
        taxAmountCurrentLine = 0;
        taxAmountCurrentLineDisplay = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTaxAmountCacheVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the internal cache for tax amounts on a specified voucher.
    /// </summary>
    /// <param name="_voucher">
    ///    A voucher number.
    /// </param>
    /// <param name="_clearTaxUncommitted">
    ///    A boolean indicating if TaxUncommitted will get cleared for this voucher and invoice; optional.
    /// </param>
    public void clearTaxAmountCacheVoucher(Voucher _voucher, boolean _clearTaxUncommitted = true)
    {
        LedgerJournalTrans  ledgerJournalTransVoucher;

        while select ledgerJournalTransVoucher
        where ledgerJournalTransVoucher.JournalNum == ledgerJournalTable.JournalNum &&
              ledgerJournalTransVoucher.Voucher    == _voucher
        {
            this.clearTaxAmountCache(ledgerJournalTransVoucher, _clearTaxUncommitted);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the voucher.
    /// </summary>
    public void clearVoucher()
    {
        this.formMethodDataSourceDeletePre();
    }

]]></Source>
			</Method>
			<Method>
				<Name>close</Name>
				<Source><![CDATA[
    /// <summary>
    /// Dispose of the instance.
    /// </summary>
    public void close()
    {
        // <GCN>
        if (LedgerParameters::isChineseVoucher_CN()
            && ledgerJournalTrans_ds.cursor().RecId == 0)
        {
            this.formMethodDataSourceDeletePre_CN(ledgerJournalTrans_ds.cursor());
        }
        // </GCN>
        ledgerJournalTrans_ds = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>companyModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles form modified events for the <c>LedgerJournalTrans.Company</c> field.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The active <c>LedgerJournalTrans</c> buffer of the form.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The active <c>LedgerJournalTrans_Asset</c> buffer of the form.
    /// </param>
    public void companyModified(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        this.handleCompanyChangeForFixedAssets(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
        this.handleCompanyChangeForFinTag(_ledgerJournalTrans, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctedTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Records a manually entered tax regulation to a specific journal line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <param name="includeUseTax">
    ///    A value that indicates whether to include the use tax; optional.
    /// </param>
    /// <returns>
    ///    The tax amount in the currency of the journal
    /// </returns>
    public TaxAmountJournal correctedTaxAmount(LedgerJournalTrans _ledgerJournalTrans, boolean includeUseTax = true)
    {
        TaxAmountCur    actualTax, calculatedTax;

        if (_ledgerJournalTrans.RecId != 0)
        {
            if (!correctedTaxAmountDisplay.lookup(_ledgerJournalTrans.RecId))
            {
                if (!ledgerJournalTable.Posted && _ledgerJournalTrans.isTaxable())
                {
                    if (TaxParameters::find().CashDiscOnInvoice)
                    {
                        if (ledgerJournalTable.JournalType == LedgerJournalType::PurchaseLedger)
                        {
                            _ledgerJournalTrans.CashDiscPercent = 0;
                            _ledgerJournalTrans.CashDiscAmount  = 0;
                            _ledgerJournalTrans.CashDiscCode    = '';
                        }
                    }
                }
                [actualTax, calculatedTax] = this.getTaxAmounts(_ledgerJournalTrans, includeUseTax);
            }
            else
            {
                actualTax = correctedTaxAmount.lookup(_ledgerJournalTrans.RecId);
            }
        }
        else
        {
            actualTax = correctedTaxAmountCurrentLine;
        }
        return actualTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Correct the tax amount.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_taxAmountCur">
    /// The tax amount.
    /// </param>
    /// <param name = "_update">
    /// Determines if tax transactions should be updated; optional.
    /// </param>
    /// <param name = "_clearTaxesOnly">
    /// Determines if taxes should be generated or just cleared; optional.
    /// </param>
    /// <returns>
    /// The tax amount.
    /// </returns>
    public TaxAmountCur correctTaxAmount(LedgerJournalTrans _ledgerJournalTrans,
                                         TaxAmountCur       _taxAmountCur,
                                         boolean            _update = true,
                                         boolean            _clearTaxesOnly = true)
    {
        if (_ledgerJournalTrans.RecId)
        {
            if (_update)
            {
                if (!_taxAmountCur)
                {
                    TaxWorkRegulation::clearRegulation(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId);
                }
                if (!_clearTaxesOnly)
                {
                    LedgerJournalEngine_Server::correctTaxAmount(_ledgerJournalTrans, _taxAmountCur);
                }
            }

            correctedTaxAmount.insert(_ledgerJournalTrans.RecId, _taxAmountCur);
            correctedTaxAmountDisplay.insert(_ledgerJournalTrans.RecId, true);
        }
        else
        {
            correctedTaxAmountCurrentLine = _taxAmountCur;
        }
        return _taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the journal line when the currency code is modified.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_selectTriangulation">
    /// Determines if triangulation is required; optional.
    /// </param>
    void currencyModified(LedgerJournalTrans _ledgerJournalTrans,
                          boolean            _selectTriangulation = true)
    {
        CompanyId companyId;

        // Prepare change of company if the company exists and is different from the current company
        if (xDataArea::exist(_ledgerJournalTrans.Company))
        {
            companyId = _ledgerJournalTrans.Company;
        }
        else
        {
            companyId = curext();
        }

        CurrencyCode currentCompanyAccountingCurrency = Ledger::accountingCurrency();
        CurrencyCode currentCompanyReportingCurrency = Ledger::reportingCurrency();

        changecompany(companyId)
        {
            this.updateLedgerJournalTransOnCurrencyModified(
                _ledgerJournalTrans,
                _selectTriangulation,
                currentCompanyAccountingCurrency,
                currentCompanyReportingCurrency);

            this.refreshFormDataSource(_ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerJournalTransOnCurrencyModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the journal line when the currency code is modified.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_selectTriangulation">
    /// Determines if triangulation is required.
    /// </param>
    /// <param name = "_currentCompanyAccountingCurrency">
    /// Accounting currency code.
    /// </param>
    /// <param name = "_currentCompanyReportingCurrency">
    /// Reporting currency code.
    /// </param>
    [Wrappable(true)]
    protected final void updateLedgerJournalTransOnCurrencyModified(
        LedgerJournalTrans _ledgerJournalTrans,
        boolean _selectTriangulation,
        CurrencyCode _currentCompanyAccountingCurrency,
        CurrencyCode _currentCompanyReportingCurrency)
    {
        UnknownNoYes triangulationResult;
        ExchRateSecondTxt exchRateSecondTxt, exchRateSecondReportingTxt;
        CurrencyCode accountCompanyAccountingCurrency = Ledger::accountingCurrency();
        CurrencyCode accountCompanyReportingCurrency = Ledger::reportingCurrency();

        if (ledgerJournalTable.FixedExchRate &&
                ledgerJournalTable.CurrencyCode == _ledgerJournalTrans.CurrencyCode &&
                accountCompanyAccountingCurrency == _currentCompanyAccountingCurrency)
        {
            _ledgerJournalTrans.ExchRate          = ledgerJournalTable.ExchRate;
            _ledgerJournalTrans.ExchRateSecond    = ledgerJournalTable.ExchrateSecondary;
            _ledgerJournalTrans.Triangulation     = ledgerJournalTable.euroTriangulation;
        }
        else
        {
            [triangulationResult,
                _ledgerJournalTrans.ExchRate,
                _ledgerJournalTrans.ExchRateSecond,
                exchRateSecondTxt] = LedgerJournalEngine_Server::currencyModified(_ledgerJournalTrans, _selectTriangulation);
            _ledgerJournalTrans.Triangulation = Currency::unknownNoYes2Noyes(triangulationResult);
        }

        if (accountCompanyReportingCurrency && _currentCompanyReportingCurrency)
        {
            if (ledgerJournalTable.ReportingCurrencyFixedExchRate &&
                    ledgerJournalTable.CurrencyCode == _ledgerJournalTrans.CurrencyCode &&
                    accountCompanyReportingCurrency == _currentCompanyReportingCurrency)
            {
                _ledgerJournalTrans.ReportingCurrencyExchRate           = ledgerJournalTable.ReportingCurrencyExchRate;
                _ledgerJournalTrans.ReportingCurrencyExchRateSecondary  = ledgerJournalTable.ReportingCurrencyExchRateSecondary;
            }
            else
            {
                [_ledgerJournalTrans.ReportingCurrencyExchRate,
                    _ledgerJournalTrans.ReportingCurrencyExchRateSecondary,
                    exchRateSecondReportingTxt] = LedgerJournalEngine_Server::reportingCurrencyModified(_ledgerJournalTrans);
            }
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.calcAndUpdateInterestAndFine_BR(_ledgerJournalTrans);
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshFormDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes the data source of the <c>LedgerJournalTrans</c> buffer.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    [Wrappable(true)]
    protected final void refreshFormDataSource(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (ledgerJournalTrans_ds)
        {
            ledgerJournalTrans_ds.allowEdit(this.allowEditTrans(_ledgerJournalTrans));
            ledgerJournalTrans_ds.refresh();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendCashDiscCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Maintains an internal cache of cash discount dates and amounts.
    /// </summary>
    /// <param name="_set">
    ///    A flag to indicate of cash discount should be recalculated.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <returns>
    ///    A container with a cash discount date and cash discount amount.
    /// </returns>
    public container custVendCashDiscCache(boolean _set, LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean             set = _set;
        CustVendTransOpen   custVendTransOpen;

        if (_ledgerJournalTrans.RecId &&
           (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
            _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend))
        {
            custVendTransOpen.RefRecId = _ledgerJournalTrans.RecId;
            if (!custVendCashDiscList)
            {
                custVendCashDiscList = new RecordSortedList(tableNum(CustVendTransOpen));
            }
            if (!custVendCashDiscList.find(custVendTransOpen))
            {
                if (!_set)
                {
                    using (TaxIntegrationTaxCalculationNoDelayContext taxCalculationNoDelayContext = TaxIntegrationTaxCalculationNoDelayContext::getInstance())
                    {
                        [custVendTransOpen.CashDiscDate, custVendTransOpen.PossibleCashDisc] =
                            LedgerJournalEngine_Server::calcVirtualCashDisc(_ledgerJournalTrans,
                                                                            null,
                                                                            this.taxAmountJournal(_ledgerJournalTrans),
                                                                            this.correctedTaxAmount(_ledgerJournalTrans));
                    }
                    set = true;
                }
            }
            if (set)
            {
                custVendTransOpen.CashDiscDate = _ledgerJournalTrans.DateCashDisc;
                custVendTransOpen.PossibleCashDisc = _ledgerJournalTrans.CashDiscAmount;
                custVendCashDiscList.ins(custVendTransOpen, true);
            }
        }
        return [custVendTransOpen.CashDiscDate, custVendTransOpen.PossibleCashDisc];
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceWrite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes the datasouce for the <c>LedgerJournalTrans</c> table.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    void dataSourceWrite(LedgerJournalTrans _ledgerJournalTrans)
    {
        this.preWrite(_ledgerJournalTrans);
        this.formMethodDataSourceWritePre();

        // The ledgerJournalTrans formDataSource write below will make ledgerJournalTransTaxExtension.orig() change without persist to DB.
        // Then the ledgerJournalTransTaxExtension.update() later will not perform the actual update operation to DB.
        // Don't know why, so persist ledgerJournalTransTaxExtension first.
        // Insert do not have this issue, only handle update here.
        if (_ledgerJournalTrans && _ledgerJournalTrans.isTaxIntegrationEnabled())
        {
            _ledgerJournalTrans.ledgerJournalTransTaxExtension().save(_ledgerJournalTrans);
        }

        FormDataUtil::getFormDataSource(_ledgerJournalTrans).write();
        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            if (FormDataUtil::getFormDataSource(_ledgerJournalTrans.getPaymentExtension_BR()))
            {
                FormDataUtil::getFormDataSource(_ledgerJournalTrans.getPaymentExtension_BR()).write();
            }
        }
        // </GBR>
        this.write(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultBookIdForFATransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Applies a default book ID value for a fixed assets transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> part of the transaction.
    /// </param>
    protected void defaultBookIdForFATransaction(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        AssetBookId bookIdDefault;
        AssetBook assetBook;

        // <GEEU>
        AssetBookTable assetBookTable;
        // </GEEU>

        // <GIN>
        boolean     assetParameters = AssetParameters::checkAssetParameters_IN();
        // </GIN>

        // Clear the book if the asset and book combination do not exist in the new company.
        changecompany(_ledgerJournalTrans_Asset.Company)
        {
            if (!(AssetBook::exist(_ledgerJournalTrans_Asset.AssetId, _ledgerJournalTrans_Asset.BookId) &&
                  AssetBookTable::find(_ledgerJournalTrans_Asset.BookId).CurrentOperationsTax == ledgerJournalTable.CurrentOperationsTax))
            {
                // <GEEU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoLV])
                 && _ledgerJournalTrans_Asset.BookId)
                {
                    select firstonly RecId from assetBook
                        order by Status
                        where assetBook.AssetId == _ledgerJournalTrans_Asset.AssetId &&
                              assetBook.BookId  == _ledgerJournalTrans_Asset.BookId  &&
                              (assetBook.Status == AssetStatus::NoAcquisition        ||
                               assetBook.Status == AssetStatus::Acquired_CZ          ||
                               assetBook.Status == AssetStatus::Open                 ||
                               assetBook.Status == AssetStatus::Closed)
                    join assetBookTable
                        where assetBookTable.BookId               == assetBook.BookId &&
                              assetBookTable.CurrentOperationsTax == ledgerJournalTable.CurrentOperationsTax;

                    if (assetBook.RecId)
                    {
                        return;
                    }
                }
                // </GEEU>
                // The asset and book combination do not exist in the company; default in the appropriate value from.
                // If a book doesn't exist for this asset, the field will be empty.

                // Clear out the book id.
                _ledgerJournalTrans_Asset.BookId = "";

                // Lookup the default in the asset parameters table.
                bookIdDefault = AssetParameters::find().BookIdDefault;

                if (bookIdDefault)
                {
                    // There's a default specified in asset parameters. See if that book is associated with this asset.
                    assetBook = AssetBook::find(_ledgerJournalTrans_Asset.AssetId, bookIdDefault);
                    assetBookTable = assetBook.assetBookTable();

                    if (assetBook
                        && assetBookTable.CurrentOperationsTax == ledgerJournalTable.CurrentOperationsTax
                        && (assetBook.Status == AssetStatus::NoAcquisition
                            || // <GEEU>
                                assetBook.Status == AssetStatus::Acquired_CZ
                            || // </GEEU>
                                assetBook.Status == AssetStatus::Open)
                        && (ledgerJournalTable.JournalType == LedgerJournalType::Assets
                            || (ledgerJournalTable.JournalType != LedgerJournalType::Assets
                                && assetBookTable.postToGeneralLedger() == NoYes::Yes)))
                    {
                        // The book is associated with the asset and has the correct status, so use it.
                        _ledgerJournalTrans_Asset.BookId = bookIdDefault;

                        // <GIN>
                        if (assetParameters)
                        {
                            _ledgerJournalTrans_Asset.AssetGroup_IN = assetBook.AssetGroup;
                        }
                        // </GIN>
                    }
                }

                if (!_ledgerJournalTrans_Asset.BookId)
                {
                    // There as no appropriate default defined in the asset parameters table, so get the best book
                    // from the AssetBook table.
                    _ledgerJournalTrans_Asset.BookId = _ledgerJournalTrans_Asset.getTopDefaultBookIdForFATransaction(ledgerJournalTable.CurrentOperationsTax);

                    // <GIN>
                    if (assetParameters)
                    {
                        _ledgerJournalTrans_Asset.AssetGroup_IN = AssetBook::find(_ledgerJournalTrans_Asset.AssetId, _ledgerJournalTrans_Asset.BookId).AssetGroup;
                    }
                    // </GIN>
                }
            }
        }

        _ledgerJournalTrans_Asset.assetBook().hasHalfYearDepreciation_CZ(_ledgerJournalTrans_Asset.TransType, _ledgerJournalTrans.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultBookIdForFATransaction_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies a default book ID value for a fixed assets transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    /// The <c>LedgerJournalTrans_Asset</c> portion of the transaction.
    /// </param>
    protected void defaultBookIdForFATransaction_PL(LedgerJournalTrans _ledgerJournalTrans,
                                                    LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        AssetBookId     bookIdDefault;
        AssetBook       assetBook;
        AssetBookTable  assetBookTable;

        // Clear the book if the asset and book combination do not exist in the new company.
        changecompany(_ledgerJournalTrans_Asset.Company)
        {
            if (!AssetBook::exist(_ledgerJournalTrans_Asset.AssetId, _ledgerJournalTrans_Asset.BookId))
            {
                // The asset and book combination do not exist in the company; default in the appropriate value from.
                // Asset Parameters table. If a book doesn't exist for this asset, the field will be empty.

                // Clear out the book id.
                _ledgerJournalTrans_Asset.BookId = '';

                // Lookup the default in the asset parameters table.
                bookIdDefault = AssetParameters::find().BookIdDefault;

                if (bookIdDefault)
                {
                    // There's a default specified in asset parameters. See if that book is associated with this asset.
                    assetBook       = AssetBook::find(_ledgerJournalTrans_Asset.AssetId, bookIdDefault);
                    assetBookTable  = assetBook.assetBookTable();

                    if (assetBook
                        && AssetBookTable::find(bookIdDefault).CurrentOperationsTax == ledgerJournalTable.CurrentOperationsTax
                        && (assetBook.Status == AssetStatus::NoAcquisition
                        || assetBook.Status == AssetStatus::Open
                        || (_ledgerJournalTrans_Asset.TransType == AssetTransTypeJournal::DisposalSale
                        || _ledgerJournalTrans_Asset.TransType == AssetTransTypeJournal::DisposalScrap
                        && (!AssetParameters::find().AssetAllowSale_PL
                        || (AssetParameters::find().AssetAllowSale_PL
                        && AssetTable::find(_ledgerJournalTrans_Asset.AssetId).AllowSale_PL))
                        && assetBook.Status == AssetStatus::Closed))
                        && (ledgerJournalTable.JournalType == LedgerJournalType::Assets
                            || (ledgerJournalTable.JournalType != LedgerJournalType::Assets
                                && assetBookTable.postToGeneralLedger() == NoYes::Yes)))
                    {
                        // The book is associated with the asset and has the correct status, so use it.
                        _ledgerJournalTrans_Asset.BookId = bookIdDefault;
                    }
                }

                if (!_ledgerJournalTrans_Asset.BookId)
                {
                    assetBook = AssetBook::find(
                        _ledgerJournalTrans_Asset.AssetId,
                        _ledgerJournalTrans_Asset.getTopDefaultBookIdForFATransaction(ledgerJournalTable.CurrentOperationsTax));

                    if (assetBook)
                    {
                        if (assetBook.Status == AssetStatus::Closed)
                        {
                            if (_ledgerJournalTrans_Asset.TransType == AssetTransTypeJournal::DisposalSale  ||
                                _ledgerJournalTrans_Asset.TransType == AssetTransTypeJournal::DisposalScrap &&
                                (!AssetParameters::find().AssetAllowSale_PL                                 ||
                                (AssetParameters::find().AssetAllowSale_PL                                  &&
                                AssetTable::find(_ledgerJournalTrans_Asset.AssetId).AllowSale_PL)))
                            {
                                _ledgerJournalTrans_Asset.BookId = assetBook.BookId;
                            }
                        }
                        else
                        {
                            _ledgerJournalTrans_Asset.BookId = assetBook.BookId;
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultOffsetAccountForFATransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Applies a default offset account value for a fixed assets transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The buffer that stores the <c>LedgerJournalTrans</c> part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The buffer that stores the <c>LedgerJournalTrans_Asset</c> part of the transaction.
    /// </param>
    protected void defaultOffsetAccountForFATransaction(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        if (this.canDefaultOffsetAccount(_ledgerJournalTrans)
            && ledgerJournalTable.FixedOffsetAccount == NoYes::No
            && _ledgerJournalTrans_Asset.assetBookPostsToGeneralLedger())
        {
            // Default in the ledger offset account.
            _ledgerJournalTrans.OffsetAccountType = LedgerJournalACType::Ledger;
            _ledgerJournalTrans.parmOffsetLedgerDimension(this.findOffsetLedgerDimension(_ledgerJournalTrans, _ledgerJournalTrans_Asset));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultOffsetAcctForAccountModifiedEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies a default offset account value to a ledger account that is specified by account properties,
    /// posting profiles, and module parameters.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A buffer that stores the <c>LedgerJournalTrans</c> part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Project">
    /// A buffer that stores the <c>LedgerJournalTrans_Project</c> part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    /// A buffer that stores the <c>LedgerJournalTrans_Asset</c> part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_RAsset">
    /// The buffer storing the <c>LedgerJournalTrans_RAsset</c> portion of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_RDeferrals">
    /// The buffer storing the <c>LedgerJournalTrans_RDeferrals</c> portion of the transaction.
    /// </param>
    /// <remarks>
    /// This method is used by the <c>accountModified</c> method to default in an offset account.
    /// </remarks>
    protected void defaultOffsetAcctForAccountModifiedEvent(LedgerJournalTrans _ledgerJournalTrans,
                                                            LedgerJournalTrans_Project _ledgerJournalTrans_Project,
                                                            LedgerJournalTrans_Asset _ledgerJournalTrans_Asset
                                                            ,LedgerJournalTrans_RAsset      _ledgerJournalTrans_RAsset     = null,
                                                            LedgerJournalTrans_RDeferrals   _ledgerJournalTrans_RDeferrals = null
                                                            )

    {
        LedgerDimensionAccount ledgerDimension;

        if ( (this.canDefaultOffsetAccount(_ledgerJournalTrans) ||
            ledgerJournalTable.JournalType == LedgerJournalType::PurchaseLedger))
        {
            ledgerDimension = this.findOffsetLedgerDimension(_ledgerJournalTrans, _ledgerJournalTrans_Asset);

            if (ledgerDimension != 0)
            {
                // Only overwrite the existing value if a ledger account is found. This is because defaulting can occur in above code
                // or an account could have been specified earlier and there's no justification for clearing that value.
                _ledgerJournalTrans.OffsetAccountType = LedgerJournalACType::Ledger;
                _ledgerJournalTrans.parmOffsetLedgerDimension(ledgerDimension);
            }

            if (!_ledgerJournalTrans.parmOffsetLedgerDimension()
                && _ledgerJournalTrans.getOffsetCompany() == ledgerJournalTable.company())
            {
                // There is no default ledger account defined for the account; use the one
                // defined on the journal instead.
                _ledgerJournalTrans.OffsetAccountType = ledgerJournalTable.OffsetAccountType;
                if (ledgerJournalTable.OffsetAccountType == LedgerJournalACType::Ledger)
                {
                    // if type is ledger need to create ledger account structure by merging the main
                    // account and the dimensions for the main account
                    _ledgerJournalTrans.parmOffsetLedgerDimension(
                        _ledgerJournalTrans.getOffsetLedgerDimensionForLedgerType(
                            ledgerJournalTable.parmOffsetLedgerDimension(),
                            _ledgerJournalTrans.getOffsetCompany()));
                }
                else
                {
                    // if type isn't ledger can just copy the ledgerDimension value
                    _ledgerJournalTrans.parmOffsetLedgerDimension(ledgerJournalTable.parmOffsetLedgerDimension());
                }
            }

            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                this.initFromOffsetAccount(_ledgerJournalTrans,
                                           _ledgerJournalTrans_Project,
                                           _ledgerJournalTrans_Asset
                                           ,_ledgerJournalTrans_RAsset,
                                           _ledgerJournalTrans_RDeferrals
                                           );
            }
            else
            {
                // </GEERU>
                this.initFromOffsetAccount(_ledgerJournalTrans, _ledgerJournalTrans_Project, _ledgerJournalTrans_Asset);
                // <GEERU>
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultVendAccountForSubcontractor_SA</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies a default vendor account number for a subcontractor.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTransZakat">
    /// The <c>LedgerJournalTransZakat_SA</c> part of the transaction.
    /// </param>
    public void defaultVendAccountForSubcontractor_SA(
        LedgerJournalTrans          _ledgerJournalTrans,
        LedgerJournalTransZakat_SA  _ledgerJournalTransZakat)
    {
        VendInfoZakat_SA            vendInfoZakat;
        VendInfoZakat_SA            vendInfoZakatOffset;

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
            && _ledgerJournalTrans.LedgerDimension)
        {
            vendInfoZakat = VendInfoZakat_SA::findByVendAccount(VendTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension).AccountNum);
        }
        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend
            && _ledgerJournalTrans.OffsetLedgerDimension)
        {
            vendInfoZakatOffset =  VendInfoZakat_SA::findByVendAccount(VendTable::findByLedgerDimension(_ledgerJournalTrans.OffsetLedgerDimension).AccountNum);
        }

        if (vendInfoZakat.IsSubcontractor && vendInfoZakatOffset.IsSubcontractor)
        {
            _ledgerJournalTransZakat.Subcontractor = (_ledgerJournalTrans.LedgerDimension == _ledgerJournalTrans.OffsetLedgerDimension)
                                                      ? vendInfoZakat.RecId : 0;
        }
        else if (vendInfoZakat.IsSubcontractor)
        {
            _ledgerJournalTransZakat.Subcontractor = vendInfoZakat.RecId;
        }
        else if (vendInfoZakatOffset.IsSubcontractor)
        {
            _ledgerJournalTransZakat.Subcontractor = vendInfoZakatOffset.RecId;
        }
        else
        {
            _ledgerJournalTransZakat.Subcontractor = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete(LedgerJournalTrans   _ledgerJournalTrans,
                       boolean              _refresh = true,
                       boolean              _removeBudgetForAllVoucherLines = false
                       ,LedgerJournalTrans_RCash   _ledgerJournalTrans_RCash = null
                       )
    {
        // <GEERU><GEEU>
        if (RCashParameters::isCashModuleEnabled())
        {
            this.reduceInternalContainers(ledgerJournalTransOrig, _ledgerJournalTrans_RCash);
            this.updateInternalContainers(_ledgerJournalTrans, true, _ledgerJournalTrans_RCash);
        }
        else
        {
            // </GEERU></GEEU>
            this.reduceInternalContainers(ledgerJournalTransOrig);
            this.updateInternalContainers(_ledgerJournalTrans, true);
            // <GEERU><GEEU>
        }
        // </GEERU></GEEU>

        this.voucherTotals(_ledgerJournalTrans);
        this.updateCashDisc(_ledgerJournalTrans);
        this.deleteReasonCode(_ledgerJournalTrans);

        if (_removeBudgetForAllVoucherLines)
        {
            // Remove the budget for all the journal lines associated to the voucher of the specified journal line.
            _ledgerJournalTrans.removeBudgetForVoucher();
        }
        else
        {
            // Remove the budget for the journal line.
            _ledgerJournalTrans.removeBudget();
        }

        // The journal line budget amounts are removed.
        // Remove its voucher budget check result from the cache.
        this.removeBudgetCheckResultFromCache(_ledgerJournalTrans.Voucher);

        if (_refresh)
        {
            this.ledgerJournalTableUpdateTotals(ledgerJournalTable, _refresh);
            if (ledgerJournalTrans_ds)
            {
                ledgerJournalTrans_ds.refresh();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the cash discount records for a journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    public void deleteCashDisc(LedgerJournalTrans _ledgerJournalTrans)
    {
        CustTransCashDisc   custTransCashDisc;
        VendTransCashDisc   vendTransCashDisc;

        if (_ledgerJournalTrans.RecId != 0)
        {
            switch (_ledgerJournalTrans.AccountType)
            {
                case LedgerJournalACType::Cust:
                    delete_from custTransCashDisc
                        where custTransCashDisc.RefRecId   == _ledgerJournalTrans.RecId &&
                              custTransCashDisc.RefTableId == _ledgerJournalTrans.TableId;
                    break;

                case LedgerJournalACType::Vend:
                    delete_from vendTransCashDisc
                        where vendTransCashDisc.RefRecId   == _ledgerJournalTrans.RecId &&
                              vendTransCashDisc.RefTableId == _ledgerJournalTrans.TableId;
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForLedgerJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the current object after the caller deletes the
    /// <c>LedgerJournalTrans</c> records associated with the current
    /// <c>LedgerJournalTable</c> record.
    /// </summary>
    /// <remarks>
    /// This method follows the pattern of the <c>delete</c> method and expects
    /// the caller to delete most of the records.
    /// </remarks>
    public void deleteForLedgerJournalTable()
    {
        voucherBalance = new RecordSortedList(tableNum(TmpVoucherSum));
        voucherBalance.sortOrder(fieldNum(TmpVoucherSum, Voucher));

        journalTotalDebit = 0;
        journalTotalCredit = 0;
        journalTotalBalance = 0;
        journalTotalOffsetBalance = 0;

        voucherTotalDebit = 0;
        voucherTotalCredit = 0;
        voucherTotalBalance = 0;
        voucherTotalBalanceCur = 0;

        voucherTotalDebitReportingCurrency = 0;
        voucherTotalCreditReportingCurrency = 0;
        voucherTotalBalanceReportingCurrency = 0;

        journalTotalDebitReportingCurrency = 0;
        journalTotalCreditReportingCurrency = 0;
        journalTotalBalanceReportingCurrency = 0;

        custVendCashDiscList = new RecordSortedList(tableNum(CustVendTransOpen));
        custVendCashDiscList.sortOrder(fieldNum(CustVendTransOpen, RefRecId));

        cashDiscDirty = SysTmpRecIdMap::construct(Types::Integer);

        voucherBudgetCheckResults = new Map(Types::String, Types::Integer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteReasonCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the <c>ReasonTableRef</c> record referenced by the <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The record that stores the <c>LedgerJournalTrans</c> record of the transaction.
    /// </param>
    /// <remarks>
    /// This method is used to delete the <c>ReasonCode</c> record when the <c>LedgerJournalTrans</c>
    /// record is deleted before it is committed to the database.
    /// </remarks>
    protected void deleteReasonCode(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_ledgerJournalTrans.ReasonRefRecID != 0 && this.ledgerJournalTable().Posted == NoYes::No)
        {
            ReasonTableRef::deleteByReference(_ledgerJournalTrans.ReasonRefRecID);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryDateModified_ES</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the current object based on the delivery date.
    /// </summary>
    /// <param name="ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record to be modified.
    /// </param>
    public void deliveryDateModified_ES(LedgerJournalTrans ledgerJournalTrans)
    {
        PaymTerm            paymTerm;
        PaymDueDateLimit_ES dueDateLimit;

        paymTerm = PaymTerm::find(ledgerJournalTrans.Payment);
        ledgerJournalTrans.Due = this.getDueDateBaseDate(ledgerJournalTrans);
        dueDateLimit = this.getDueDateLimit(ledgerJournalTrans);

        if (ledgerJournalTrans.Payment && ledgerJournalTrans.Invoice)
        {
            if (ledgerJournalTrans.Due || !paymTerm.UseDeliveryDateForDueDate_ES)
            {
                ledgerJournalTrans.Due = paymTerm.due(ledgerJournalTrans.Due, this.paymDayId(ledgerJournalTrans), false, dueDateLimit);
            }
        }

        this.refreshDataSource(ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayRemittanceAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the remittance address associated with the selected record in the <c>LedgerJournalTrans</c> table.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The record that stores the <c>LedgerJournalTrans</c> record of the transaction.</param>
    /// <returns>The remittance address.</returns>
    /// <remarks>
    /// The remittance address on the trans date is returned if the journal is posted.
    /// The current date effective remittance address is returned for an unposted journal.
    /// </remarks>
    RemittanceAddressing displayRemittanceAddress(LedgerJournalTrans _ledgerJournalTrans)
    {
        LogisticsPostalAddress  logisticsPostalAddress;

        //Show the historical address saved on the record for sent or confirmed records that cannot change
        if (this.useHistoricalRemittanceAddress(_ledgerJournalTrans))
        {
            return LogisticsPostalAddress::addressFromRecId(_ledgerJournalTrans.RemittanceAddress);
        }

        //Update the address to current
        logisticsPostalAddress = LogisticsLocationEntity::location2PostalAddress(_ledgerJournalTrans.RemittanceLocation, DateTimeUtil::getSystemDateTime(), true);
        _ledgerJournalTrans.RemittanceAddress = logisticsPostalAddress.RecId;

        //Show the current address for the location
        return logisticsPostalAddress.Address;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentDateModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when the document date is modified.
    /// </summary>
    /// <param name = "ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    void documentDateModified(LedgerJournalTrans ledgerJournalTrans)
    {
        TransDate transDate;
        PaymTerm            paymTerm;
        PaymDueDateLimit_ES dueDateLimit;

        // <GEEU>
        #EECountryRegionCodes
        // </GEEU>

        transDate = ledgerJournalTrans.DocumentDate ? ledgerJournalTrans.DocumentDate : ledgerJournalTrans.TransDate;

        paymTerm = PaymTerm::find(ledgerJournalTrans.Payment);
        transDate = this.getDueDateBaseDate(ledgerJournalTrans);

        if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust && ledgerJournalTrans.CashDiscBaseDays)
        {
            ledgerJournalTrans.CashDiscBaseDate = transDate + ledgerJournalTrans.CashDiscBaseDays;
            ledgerJournalTrans.Due = ledgerJournalTrans.CashDiscBaseDate;
        }
        else
        {
            // <GBR>
            if (!BrazilParameters::isEnabled() || !ledgerJournalTrans.hasCustVendTransOpen_BR())
            {
                // </GBR>
                ledgerJournalTrans.Due = transDate;
                // <GBR>
            }
            // </GBR>
            ledgerJournalTrans.CashDiscBaseDate = dateNull();
        }

        if (ledgerJournalTrans.Payment && ledgerJournalTrans.Invoice)
        {
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
            {
                if (ledgerJournalTrans.Due || !paymTerm.UseDeliveryDateForDueDate_ES)
                {
                    dueDateLimit = this.getDueDateLimit(ledgerJournalTrans);
                    ledgerJournalTrans.Due = paymTerm.due(ledgerJournalTrans.Due, this.paymDayId(ledgerJournalTrans), false, dueDateLimit);
                }
            }
            else
            {
                ledgerJournalTrans.Due = PaymCalendarSourceLedgerJournalTrans::getUpdatedDueDate(ledgerJournalTrans, this.paymDayId(ledgerJournalTrans));
            }
        }

        if (VendInvoicePostingDateAutoAdjustmentV2Flight::instance().isEnabled())
        {
            LedgerJournalType journalType = ledgerJournalTrans.ledgerJournalTable().JournalType;
            if (journalType == LedgerJournalType::VendInvoiceRegister
                || journalType == LedgerJournalType::Approval
                || journalType == LedgerJournalType::PurchaseLedger)
            {
                this.currencyModified(ledgerJournalTrans);
            }
        }

        // <GEEU>
        if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            ledgerJournalTrans.modifyVatDueDate_W();
        }
        // </GEEU>

        if (ledgerJournalTrans.CashDiscCode)
        {
            this.calculateCashDisc(ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentModified_JP</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reinitializes transaction data when the document of the transaction is changed.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer that stores part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table buffer that stores part of the transaction.
    /// </param>
    public void documentModified_JP (LedgerJournalTrans       _ledgerJournalTrans,
                                     LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
        {
            this.initAssetPostingProfile(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
            this.defaultOffsetAccountForFATransaction(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableCashRegister_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Identifyes if cash register terminal need to be updated.
    /// </summary>
    /// <returns>
    /// True if cash register terminal need to be updated; false, otherwise.
    /// </returns>
    protected boolean enableCashRegister_W()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateTxt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Caches the <c>exchRateTxt</c> display method of the <c>LedgerJournalTrans</c> record buffers in the journal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <returns>
    ///    A string that holds the calculation method of the currency.
    /// </returns>
    public ExchRateSecondTxt exchRateTxt(LedgerJournalTrans _ledgerJournalTrans)
    {
        TmpExchRateTxt tmpExchRateTxt;
        ExchRateSecondTxt exchangeRateText;

        #macro.FieldList
        _ledgerJournalTrans.Company,
            tmpExchRateTxt.CurrencyCode,
            tmpExchRateTxt.TransDate,
            tmpExchRateTxt.EUROTriangulation
        #endmacro

        tmpExchRateTxt.initFromLedgerJournalTrans(_ledgerJournalTrans);

        if (exchangeRateTexts.exists([#FieldList]))
        {
            exchangeRateText = exchangeRateTexts.lookup([#FieldList]);
        }
        else
        {
            exchangeRateText = _ledgerJournalTrans.exchRateTxt();
            exchangeRateTexts.insert([#FieldList], exchangeRateText);
        }

        return exchangeRateText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAgreementHeaderExt_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>AgreementHeaderExt_RU</c> record for the <c>LedgerJournalTrans</c> record depending on account type.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_accountOffsetaccount">
    /// Account type, account or offset account; optional.
    /// </param>
    /// <returns>
    /// The <c>AgreementHeaderExt_RU</c> record.
    /// </returns>
    public AgreementHeaderExt_RU findAgreementHeaderExt_RU(LedgerJournalTrans _ledgerJournalTrans, AccountOffsetaccount _accountOffsetaccount = AccountOffsetaccount::Account)
    {
        AgreementId_RU        agreementId;
        CompanyId             companyId;
        LedgerJournalACType   ledgerJournalACType;
        AgreementHeaderExt_RU agreementHeaderExt;

        ledgerJournalACType = _accountOffsetaccount == AccountOffsetaccount::Account ? _ledgerJournalTrans.AccountType : _ledgerJournalTrans.OffsetAccountType;

        if (ledgerJournalACType != LedgerJournalACType::Cust &&
            ledgerJournalACType != LedgerJournalACType::Vend)
        {
            return null;
        }

        if (_accountOffsetaccount == AccountOffsetaccount::Account)
        {
            agreementId = _ledgerJournalTrans.AccountAgreementId_RU;
            companyId = _ledgerJournalTrans.AgreementCompany_RU ? _ledgerJournalTrans.AgreementCompany_RU : curext();
        }
        else
        {
            agreementId = _ledgerJournalTrans.OffsetAccountAgreementId_RU;
            companyId = _ledgerJournalTrans.OffsetAgreementCompany_RU ? _ledgerJournalTrans.OffsetAgreementCompany_RU : curext();
        }

        if (agreementId)
        {
            if (!xDataArea::exist(companyId))
            {
                throw error(strFmt("@SYS10666", companyId));
            }

            changecompany(companyId)
            {
                agreementHeaderExt = AgreementHeaderExt_RU::findByAgreementId(agreementId);
            }
        }

        return agreementHeaderExt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBankAccountTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the bank account for a journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The <c>BankAccountTable</c> record for a journal line.
    /// </returns>
    public BankAccountTable findBankAccountTable(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (!_ledgerJournalTrans.isCompanyIntercompany(currentCompany))
        {
            bankAccountTable.AccountID = _ledgerJournalTrans.parmAccount();
            if (!bankAccountTableList.find(bankAccountTable))
            {
                bankAccountTable = BankAccountTable::findByLedgerDimension(_ledgerJournalTrans.parmLedgerDimension());
                bankAccountTableList.ins(bankAccountTable);
            }
        }
        else
        {
            if (!xDataArea::exist(_ledgerJournalTrans.Company))
            {
                throw error(strFmt("@SYS10666", _ledgerJournalTrans.Company));
            }

            changecompany(_ledgerJournalTrans.Company)
            {
                bankAccountTable = BankAccountTable::findByLedgerDimension(_ledgerJournalTrans.parmLedgerDimension());
            }
        }
        return bankAccountTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds or creates the cash discount.
    /// </summary>
    /// <param name = "_company">
    /// The company ID.
    /// </param>
    /// <param name = "_cashDiscCode">
    /// The cash discount code.
    /// </param>
    public void findCashDisc(CompanyId _company, CashDiscCode _cashDiscCode)
    {
        RecordSortedList companyList;

        if (cashDiscList.exists(_company))
        {
            companyList = cashDiscList.lookup(_company);
        }
        else
        {
            companyList = new RecordSortedList(tableNum(CashDisc));
            companyList.sortOrder(fieldNum(CashDisc, CashDiscCode));

            cashDiscList.insert(_company, companyList);
        }

        cashDisc.CashDiscCode = _cashDiscCode;
        if (!companyList.find(cashDisc))
        {
            cashDisc = CashDisc::findByCompany(_company, _cashDiscCode);
            companyList.ins(cashDisc);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Looks up a <c>CustTable</c> record buffer, based on the company and account number fields of a specific <c>LedgerJournalTrans</c> record buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <returns>
    ///    A <c>CustTable</c> buffer with the given account number, looked up in the given company account.
    /// </returns>
    /// <remarks>
    ///    The method maintains an internal cache of <c>CustTable</c> record buffers.
    /// </remarks>
    public CustTable findCustTable(LedgerJournalTrans  _ledgerJournalTrans)
    {
        if (!_ledgerJournalTrans.isCompanyIntercompany(currentCompany))
        {
            custTable.AccountNum = _ledgerJournalTrans.parmAccount();
            if (! custTableList.find(custTable))
            {
                custTable = CustTable::findByLedgerDimension(_ledgerJournalTrans.parmLedgerDimension());
                custTableList.ins(custTable);
            }
        }
        else
        {
            if (!xDataArea::exist(_ledgerJournalTrans.Company))
            {
                throw error(strFmt("@SYS10666", _ledgerJournalTrans.Company));
            }

            changecompany(_ledgerJournalTrans.Company)
            {
                custTable = CustTable::findByLedgerDimension(_ledgerJournalTrans.parmLedgerDimension());
            }
        }
        return custTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOffsetAssetTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the asset for the offset account for a journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The <c>AssetTable</c> record for the journal line.
    /// </returns>
    public AssetTable findOffsetAssetTable(LedgerJournalTrans _ledgerJournalTrans)
    {
        AssetTable ret;

        if (!_ledgerJournalTrans.isOffsetCompanyIntercompany(currentCompany))
        {
            ret.AssetId = _ledgerJournalTrans.parmOffsetAccount();
            if (!assetTableList.find(ret))
            {
                ret = AssetTable::find(_ledgerJournalTrans.parmOffsetAccount());
                assetTableList.ins(ret);
            }
        }
        else
        {
            if (!xDataArea::exist(_ledgerJournalTrans.OffsetCompany))
            {
                throw error(strFmt("@SYS10666", _ledgerJournalTrans.OffsetCompany));
            }

            changecompany(_ledgerJournalTrans.OffsetCompany)
            {
                ret = AssetTable::find(_ledgerJournalTrans.parmOffsetAccount());
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOffsetBankAccountTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the bank account for the offset account for a journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The <c>BankAccountTable</c> record for the journal line.
    /// </returns>
    public BankAccountTable findOffsetBankAccountTable(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (!_ledgerJournalTrans.isOffsetCompanyIntercompany(currentCompany))
        {
            bankAccountTable.AccountID = _ledgerJournalTrans.parmOffsetAccount();
            if (!bankAccountTableList.find(bankAccountTable))
            {
                bankAccountTable = BankAccountTable::findByLedgerDimension(_ledgerJournalTrans.parmOffsetLedgerDimension());
                bankAccountTableList.ins(bankAccountTable);
            }
        }
        else
        {
            if (!xDataArea::exist(_ledgerJournalTrans.OffsetCompany))
            {
                throw error(strFmt("@SYS10666", _ledgerJournalTrans.OffsetCompany));
            }

            changecompany(_ledgerJournalTrans.OffsetCompany)
            {
                bankAccountTable = BankAccountTable::findByLedgerDimension(_ledgerJournalTrans.parmOffsetLedgerDimension());
            }
        }

        return bankAccountTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOffsetCustTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the customer for the offset account for a journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The <c>CustTable</c> record for the journal line.
    /// </returns>
    public CustTable findOffsetCustTable(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (!_ledgerJournalTrans.isOffsetCompanyIntercompany(currentCompany))
        {
            custTable.AccountNum = _ledgerJournalTrans.parmOffsetAccount();
            if (! custTableList.find(custTable))
            {
                custTable = CustTable::findByLedgerDimension(_ledgerJournalTrans.parmOffsetLedgerDimension());
                custTableList.ins(custTable);
            }
        }
        else
        {
            if (!xDataArea::exist(_ledgerJournalTrans.OffsetCompany))
            {
                throw error(strFmt("@SYS10666", _ledgerJournalTrans.OffsetCompany));
            }

            changecompany(_ledgerJournalTrans.OffsetCompany)
            {
                custTable = CustTable::findByLedgerDimension(_ledgerJournalTrans.parmOffsetLedgerDimension());
            }
        }

        return custTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOffsetLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the ledger dimension account to post a transaction with an offset account.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer that stores the part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table buffer that stores a part of the transaction. This is an
    ///    optional parameter that will only be used if the primary account is of type fixed assets.
    /// </param>
    /// <returns>
    ///    The ledger dimension account to post a transaction with a ledger offset account.
    /// </returns>
    /// <remarks>
    ///    If the transaction is intercompany, a no ledger dimension account is returned; some journal types
    ///    also return a blank account.
    /// </remarks>
    public LedgerDimensionAccount findOffsetLedgerDimension(
        LedgerJournalTrans       _ledgerJournalTrans,
        LedgerJournalTrans_Asset _ledgerJournalTrans_Asset = null)
    {
        MainAccount             mainAccountLedger;
        LedgerDimensionAccount  mergedLedgerDimension;

        if ( _ledgerJournalTrans.isCompanyIntercompany(currentCompany))
        {
            return 0;
        }

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
        {
            // Check if there is an offset account on the Main account table and use that
            mainAccountLedger = LedgerDimensionFacade::getMainAccountFromLedgerDimension(_ledgerJournalTrans.parmLedgerDimension());

            if (mainAccountLedger.OffsetLedgerDimension != 0)
            {
                mergedLedgerDimension = _ledgerJournalTrans.getOffsetLedgerDimensionForLedgerType(
                    mainAccountLedger.OffsetLedgerDimension,
                    _ledgerJournalTrans.getOffsetCompany());
            }
            else if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                // No offset on main account, so use current offset ledger dimension
                mergedLedgerDimension = _ledgerJournalTrans.parmOffsetLedgerDimension();

                // If offset company and account company is same then merge the ledger dimension
                if (_ledgerJournalTrans.getOffsetCompany() == _ledgerJournalTrans.Company)
                {
                    // If fixed account is used, the offset account should be defaulted immediately since the
                    // main account can not be edited
                    if (ledgerJournalTable.FixedOffsetAccount && _ledgerJournalTrans.OffsetLedgerDimension && _ledgerJournalTrans.LedgerDimension)
                    {
                        mergedLedgerDimension = LedgerDimensionFacade::serviceMergeLedgerDimensions(mergedLedgerDimension, _ledgerJournalTrans.LedgerDimension);
                    }
                }
            }
            return mergedLedgerDimension;
        }

        switch (_ledgerJournalTrans.ledgerJournalTable().JournalType)
        {
            case LedgerJournalType::PurchaseLedger :
                // Get default dimensions when non-ledger as they are needed now to default the offset values
                if ((_ledgerJournalTrans.AccountType != LedgerJournalACType::Ledger) && (_ledgerJournalTrans.DefaultDimension == 0))
                {
                    this.initDefaultDimension(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
                }

                mergedLedgerDimension = _ledgerJournalTrans.getOffsetLedgerDimensionForLedgerType(
                    _ledgerJournalTrans.purchOffsetLedgerDimension(),
                    _ledgerJournalTrans.getOffsetCompany());
                break;
            // Restore back to SYS
            case LedgerJournalType::Daily, LedgerJournalType::Payment, LedgerJournalType::CustPayment, LedgerJournalType::Netting,
                 LedgerJournalType::PayrollDisbursement,
                 LedgerJournalType::Assets, LedgerJournalType::AssetBudgets :
                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
                {
                    // Get default dimensions when non-ledger as they are needed now to default the offset values
                    if (_ledgerJournalTrans.DefaultDimension == 0)
                    {
                        this.initDefaultDimension(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
                    }

                    if (ledgerJournalTable.FixedOffsetAccount == NoYes::Yes)
                    {
                        // If journal has Fixed offset account = yes, do not lookup offset account from posting profile
                        mergedLedgerDimension = _ledgerJournalTrans.getOffsetLedgerDimensionForLedgerType(
                            _ledgerJournalTrans.OffsetLedgerDimension,
                            _ledgerJournalTrans.getOffsetCompany());
                    }
                    else
                    {
                        // Look up the ledger account from the asset's posting profile
                        mergedLedgerDimension = _ledgerJournalTrans.getOffsetLedgerDimensionForLedgerType(
                            this.assetOffsetLedgerDimension(
                                _ledgerJournalTrans,
                                _ledgerJournalTrans_Asset),
                                _ledgerJournalTrans.getOffsetCompany());
                    }
                }
                else if (ledgerJournalTable.FixedOffsetAccount && _ledgerJournalTrans.OffsetLedgerDimension && _ledgerJournalTrans.LedgerDimension)
                {
                    // If fixed account is used, the offset account should be defaulted immediately since the
                    // main account can not be edited
                    mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerJournalTrans.OffsetLedgerDimension, _ledgerJournalTrans.DefaultDimension);
                }
                break;

            default:
                // If fixed account is used, the offset account should be defaulted immediately since the
                // main account can not be edited
                if (ledgerJournalTable.FixedOffsetAccount && _ledgerJournalTrans.OffsetLedgerDimension && _ledgerJournalTrans.LedgerDimension)
                {
                    mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerJournalTrans.OffsetLedgerDimension, _ledgerJournalTrans.DefaultDimension);
                }
                else
                {
                    mergedLedgerDimension = 0;
                }
        }

        return mergedLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOffsetRAssetTable_RU</Name>
				<Source><![CDATA[
    protected RAssetTable findOffsetRAssetTable_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (! _ledgerJournalTrans.isOffsetCompanyIntercompany(currentCompany))
        {
            rAssetTable.AccountNum = _ledgerJournalTrans.parmOffsetAccount();
            if (! rAssetTableList.find(rAssetTable))
            {
                rAssetTable = RAssetTable::find(_ledgerJournalTrans.parmOffsetAccount());
                rAssetTableList.ins(rAssetTable);
            }
        }
        else
        {
            if (!xDataArea::exist(_ledgerJournalTrans.OffsetCompany))
            {
                throw error(strFmt("@SYS10666", _ledgerJournalTrans.OffsetCompany));
            }
            changecompany(_ledgerJournalTrans.OffsetCompany)
            {
                rAssetTable = RAssetTable::find(_ledgerJournalTrans.parmOffsetAccount());
            }
        }
        return rAssetTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOffsetRCashTable_RU</Name>
				<Source><![CDATA[
    protected RCashTable findOffsetRCashTable_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (!_ledgerJournalTrans.isOffsetCompanyIntercompany(currentCompany))
        {
            rCashTable.AccountNum = _ledgerJournalTrans.parmOffsetAccount();
            if (! rCashTableList.find(rCashTable))
            {
                rCashTable = RCashTable::find(_ledgerJournalTrans.parmOffsetAccount());
                rCashTableList.ins(rCashTable);
            }
        }
        else
        {
            if (!xDataArea::exist(_ledgerJournalTrans.OffsetCompany))
            {
                throw error(strFmt("@SYS10666",_ledgerJournalTrans.OffsetCompany));
            }
            changecompany(_ledgerJournalTrans.OffsetCompany)
            {
                rCashTable = RCashTable::find(_ledgerJournalTrans.parmOffsetAccount());
            }
        }
        return  rCashTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOffsetRDeferralsTable_RU</Name>
				<Source><![CDATA[
    protected RDeferralsTable findOffsetRDeferralsTable_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (!_ledgerJournalTrans.isOffsetCompanyIntercompany(currentCompany))
        {
            rDeferralsTable.DeferralsId = _ledgerJournalTrans.parmOffsetAccount();
            if (! rDeferralsTableList.find(rDeferralsTable))
            {
                rDeferralsTable = RDeferralsTable::find(_ledgerJournalTrans.parmOffsetAccount());
                rDeferralsTableList.ins(rDeferralsTable);
            }
        }
        else
        {
            if (!xDataArea::exist(_ledgerJournalTrans.OffsetCompany))
            {
                throw error(strFmt("@SYS10666", _ledgerJournalTrans.OffsetCompany));
            }
            changecompany(_ledgerJournalTrans.OffsetCompany)
            {
                rDeferralsTable = RDeferralsTable::find(_ledgerJournalTrans.parmOffsetAccount());
            }
        }
        return  rDeferralsTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOffsetVendTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the vendor for the offset account for a journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The <c>VendTable</c> record for the journal line.
    /// </returns>
    public VendTable findOffsetVendTable(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (!_ledgerJournalTrans.isOffsetCompanyIntercompany(currentCompany))
        {
            vendTable.AccountNum = _ledgerJournalTrans.parmOffsetAccount();
            if (!vendTableList.find(vendTable))
            {
                vendTable = VendTable::findByLedgerDimension(_ledgerJournalTrans.parmOffsetLedgerDimension());
                vendTableList.ins(vendTable);
            }
        }
        else
        {
            if (!xDataArea::exist(_ledgerJournalTrans.OffsetCompany))
            {
                throw error(strFmt("@SYS10666", _ledgerJournalTrans.OffsetCompany));
            }

            changecompany(_ledgerJournalTrans.OffsetCompany)
            {
                vendTable = VendTable::findByLedgerDimension(_ledgerJournalTrans.parmOffsetLedgerDimension());
            }
        }

        return vendTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the terms of payment.
    /// </summary>
    /// <param name = "_paymTermId">
    /// The terms of payment.
    /// </param>
    public void findPayment(PaymTermId _paymTermId)
    {
        payment.PaymTermId = _paymTermId;

        if (!paymentList.find(payment))
        {
            payment = PaymTerm::find(_paymTermId);
            paymentList.ins(payment);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAssetTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the asset for a journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The <c>AssetTable</c> record for a journal line.
    /// </returns>
    protected AssetTable findAssetTable(LedgerJournalTrans _ledgerJournalTrans)
    {
        AssetTable assetTableLocal;
        if (!_ledgerJournalTrans.isCompanyIntercompany(currentCompany))
        {
            assetTableLocal.AssetId = _ledgerJournalTrans.parmAccount();
            if (! assetTableList.find(assetTableLocal))
            {
                assetTableLocal = AssetTable::find(_ledgerJournalTrans.parmAccount());
                assetTableList.ins(assetTableLocal);
            }
        }
        else
        {
            if (!xDataArea::exist(_ledgerJournalTrans.Company))
            {
                throw error(strFmt("@SYS10666", _ledgerJournalTrans.Company));
            }
            changecompany(_ledgerJournalTrans.Company)
            {
                assetTableLocal = AssetTable::find(_ledgerJournalTrans.parmAccount());
            }
        }

        return assetTableLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRAssetTable_RU</Name>
				<Source><![CDATA[
    protected RAssetTable findRAssetTable_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        RAssetTable assetTableLocal;
        if (!_ledgerJournalTrans.isCompanyIntercompany(currentCompany))
        {
            assetTableLocal.AccountNum = _ledgerJournalTrans.parmAccount();
            if (! rAssetTableList.find(assetTableLocal))
            {
                assetTableLocal = RAssetTable::find(_ledgerJournalTrans.parmAccount());
                rAssetTableList.ins(rAssetTable);
            }
        }
        else
        {
            if (!xDataArea::exist(_ledgerJournalTrans.Company))
            {
                throw error(strFmt("@SYS10666", _ledgerJournalTrans.Company));
            }
            changecompany(_ledgerJournalTrans.Company)
            {
                assetTableLocal = RAssetTable::find(_ledgerJournalTrans.parmAccount());
            }
        }
        return assetTableLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRCashTable_RU</Name>
				<Source><![CDATA[
    protected RCashTable findRCashTable_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (!_ledgerJournalTrans.isCompanyIntercompany(currentCompany))
        {
            rCashTable.AccountNum = _ledgerJournalTrans.parmAccount();
            if (!rCashTableList.find(rCashTable))
            {
                rCashTable = RCashTable::find(_ledgerJournalTrans.parmAccount());
                rCashTableList.ins(rCashTable);
            }
        }
        else
        {
            if (!xDataArea::exist(_ledgerJournalTrans.Company))
            {
                throw error(strFmt("@SYS10666",_ledgerJournalTrans.Company));
            }
            changecompany(_ledgerJournalTrans.Company)
            {
                rCashTable = RCashTable::find(_ledgerJournalTrans.parmAccount());
            }
        }

        return rCashTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRDeferralsTable_RU</Name>
				<Source><![CDATA[
    protected RDeferralsTable findRDeferralsTable_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (! _ledgerJournalTrans.isCompanyIntercompany(currentCompany))
        {
            rDeferralsTable.DeferralsId = _ledgerJournalTrans.parmAccount();
            if (! rDeferralsTableList.find(rDeferralsTable))
            {
                rDeferralsTable = RDeferralsTable::find(_ledgerJournalTrans.parmAccount());
                rDeferralsTableList.ins(rDeferralsTable);
            }
        }
        else
        {
            if (!xDataArea::exist(_ledgerJournalTrans.Company))
            {
                throw error(strFmt("@SYS10666", _ledgerJournalTrans.Company));
            }
            changecompany(_ledgerJournalTrans.Company)
            {
                rDeferralsTable = RDeferralsTable::find(_ledgerJournalTrans.parmAccount());
            }
        }

        return rDeferralsTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldFindSettledAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the findSettledAmount() logic should be executed or not.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The current <c>LedgerJournalTrans</c> table buffer.</param>
    /// <returns>true if the findSettledAmount() method logic should be executed; otherwise, false.</returns>
    protected boolean shouldFindSettledAmount(LedgerJournalTrans _ledgerJournalTrans)
    {
        return !(ledgerJournalTable.Posted ||
            ((_ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::Sent || _ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::Confirmed) &&
            !SpecTrans::findBySpec(_ledgerJournalTrans.company(), _ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldOverwriteAmountWithSettledAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the settled amounts should be transferred to the journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true if the settled amounts should be transferred to the journal line; otherwise, false.
    /// </returns>
    protected boolean shouldOverwriteAmountWithSettledAmount(LedgerJournalTrans _ledgerJournalTrans)
    {
        NoYes amountOverwrite = NoYes::Yes;

        if (_ledgerJournalTrans.BankChequeNum)
        {
            Box::info("@SYS66114");
            amountOverwrite = NoYes::No;
        }
        else
        {
            if (_ledgerJournalTrans.amount())
            {
                LedgerJournalType ledgerJournalType = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalType;
                if (
                    // <GBR>
                    !BrazilParameters::isEnabled() && (
                    // </GBR>
                    ledgerJournalType == LedgerJournalType::CustBillOfExchangeProtest ||
                    ledgerJournalType == LedgerJournalType::CustPaymRemittance ||
                    ledgerJournalType == LedgerJournalType::VendPaymRemittance)
                    // <GBR>
                    )
                    // </GBR>
                {
                    amountOverwrite = NoYes::Yes;
                }
                else
                {
                    if (this.shouldPromptUserForSettledOverwriteAmount(_ledgerJournalTrans))
                    {
                        amountOverwrite = (Box::yesNo(
                                               "@SYS58110",
                                               DialogButton::Yes,
                                               "@SYS8801",
                                               "@SYS29050") == DialogButton::Yes);
                    }
                }
            }
        }

        return amountOverwrite;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPromptUserForSettledOverwriteAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the user should be prompted to decide if settled amounts should be transferred to the journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true.
    /// </returns>
    protected boolean shouldPromptUserForSettledOverwriteAmount(LedgerJournalTrans _ledgerJournalTrans)
    {
        // This method is used for extensibility.
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSpecAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total of the associated records in the <c>LedgerJournalTrans</c> table in the specified currency.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <returns>
    /// The total amount of associated records in the <c>LedgerJournalTrans</c> table.
    /// </returns>
    protected Amount getSpecAmount(LedgerJournalTrans _ledgerJournalTrans)
    {
        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(_ledgerJournalTrans.Company).RecId), _ledgerJournalTrans.CurrencyCode);

        return SpecTransManager::getTotalSettleAmountForSpecReference(
            _ledgerJournalTrans.company(),
            _ledgerJournalTrans.TableId,
            _ledgerJournalTrans.RecId,
            _ledgerJournalTrans.CurrencyCode,
            _ledgerJournalTrans.Company,
            _ledgerJournalTrans.TransDate,
            exchangeRateHelper.prepareExchangeRateForStorage(_ledgerJournalTrans.crossrate()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSettledAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the settled amount for a journal.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    public void findSettledAmount(LedgerJournalTrans _ledgerJournalTrans)
    {
        SpecTransManager            specTransManager;
        Amount                      specAmount;
        // <GBR>
        SpecTrans                       specTransCur;
        CustVendTransOpen               custVendTransOpenCur;
        AmountCur                       finInterestAmountCur;
        AmountCur                       fineAmountCur;
        LedgerJournalType               journalType;
        LedgerJournalTransPayment_BR    payment_BR;
        // </GBR>

        if (!this.shouldFindSettledAmount(_ledgerJournalTrans))
        {
            return;
        }

        specTransManager = SpecTransManager::newFromSpec(_ledgerJournalTrans);

        specAmount = this.getSpecAmount(_ledgerJournalTrans);

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            journalType = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalType;

            if (journalType == LedgerJournalType::Payment ||
                journalType == LedgerJournalType::CustPayment)
            {
                while select crosscompany RefCompany, RefRecId, RefTableId from specTransCur
                    where   specTransCur.SpecCompany == _ledgerJournalTrans.Company &&
                            specTransCur.SpecTableId == _ledgerJournalTrans.TableId &&
                            specTransCur.SpecRecId == _ledgerJournalTrans.RecId
                {
                    changecompany(specTransCur.RefCompany)
                    {
                        switch (specTransCur.RefTableId)
                        {
                            case tableNum(CustTransOpen):
                                custVendTransOpenCur = CustTransOpen::find(specTransCur.RefRecId);
                                break;

                            case tableNum(VendTransOpen):
                                custVendTransOpenCur = VendTransOpen::find(specTransCur.RefRecId);
                                break;

                            default:
                                Debug::assert(false);
                                break;
                        }

                        finInterestAmountCur   += custVendTransOpenCur.InterestAmountPaymCur_BR;
                        fineAmountCur          += custVendTransOpenCur.FineAmountPaymCur_BR;
                        _ledgerJournalTrans.Due = custVendTransOpenCur.DueDate;
                    }
                }
            }
        }
        // </GBR>

        if (specAmount != - _ledgerJournalTrans.amount())
        {
            NoYes amountOverwrite = this.shouldOverwriteAmountWithSettledAmount(_ledgerJournalTrans);

            if (amountOverwrite)
            {
                _ledgerJournalTrans = this.setAmountCurrency(_ledgerJournalTrans, specAmount);

                //<GIN>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                {
                    LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtension = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
                    ledgerJournalTransTaxExtension.AssessableValueTransactionCurrency = abs(specAmount);
                    if (FormDataUtil::isFormDataSource(ledgerJournalTransTaxExtension))
                    {
                        ledgerJournalTransTaxExtension.Update();
                    }
                    else
                    {
                        _ledgerJournalTrans.packExtensionTable(ledgerJournalTransTaxExtension);
                    }
                }
                //</GIN>

                // <GBR>
                if (BrazilParameters::isEnabled())
                {
                    if (journalType == LedgerJournalType::CustPayment ||
                        journalType == LedgerJournalType::Payment)
                    {
                        payment_BR = _ledgerJournalTrans.getPaymentExtension_BR();
                        payment_BR.FinInterestAmountCur_BR = abs(finInterestAmountCur);
                        payment_BR.FineAmountCur_BR = abs(fineAmountCur);
                        if (FormDataUtil::isFormDataSource(payment_BR))
                        {
                            payment_BR.update();
                        }
                        else
                        {
                            _ledgerJournalTrans.packExtensionTable(payment_BR);
                        }
                    }
                }
                // </GBR>

                if (ledgerJournalTrans_ds)
                {
                    ledgerJournalTrans_ds.refresh();
                }
            }
        }

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtension = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

            //Update excluded GST Amount for GTE when the journal is vendor or customer payment for TDS calculation.
            if (LedgerJournalTrans::isVendorPaymentWithTDSCalculation_IN(_ledgerJournalTrans)
                || LedgerJournalTrans::isCustomerPaymentWithTDSCalculation_IN(_ledgerJournalTrans))
            {
                ledgerJournalTransTaxExtension.ExcludedGSTAmountCur = ledgerJournalTransTaxExtension.getCustVendTransExcludedGSTAmountforGTE_IN(_ledgerJournalTrans);

                if (FormDataUtil::isFormDataSource(ledgerJournalTransTaxExtension))
                {
                    ledgerJournalTransTaxExtension.Update();
                }
                else
                {
                    _ledgerJournalTrans.packExtensionTable(ledgerJournalTransTaxExtension);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAmountCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initiliazes the <c>LedgerJournalTrans</c> record with the specified amount.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_specAmount">
    /// The specified Amount.
    /// </param>
    /// <returns>
    /// The initialized <c>LedgerJournalTrans</c> record.
    /// </returns>
    protected LedgerJournalTrans setAmountCurrency(LedgerJournalTrans _ledgerJournalTrans, Amount _specAmount)
    {
        if (_specAmount < 0)
        {
            _ledgerJournalTrans.AmountCurDebit  = abs(_specAmount);
            _ledgerJournalTrans.AmountCurCredit = 0;
        }
        else
        {
            _ledgerJournalTrans.AmountCurCredit = abs(_specAmount);
            _ledgerJournalTrans.AmountCurDebit  = 0;
        }

        return _ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>forceNewVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// A new voucher is forced if the voucher parameter is found to be free.
    /// </summary>
    /// <param name="_voucherToCheck">
    /// The voucher number to be forced.
    /// </param>
    public void forceNewVoucher(Num _voucherToCheck)
    {
        NumberSequenceTable numberSequenceTableLocal;
        NumberSequenceList  numberSequenceListLocal;
        Num                 voucherListVoucher;

        numberSequenceTableLocal = NumberSequenceTable::find(ledgerJournalName.NumberSequenceTable);

        while select NextRec, Status from numberSequenceListLocal
            where  numberSequenceListLocal.NumberSequenceId == numberSequenceTableLocal.RecId
                && numberSequenceListLocal.Status == NumStatus::Free
        {
            voucherListVoucher = NumberSeq::numInsertFormat(numberSequenceListLocal.NextRec, numberSequenceTableLocal.Format);
            if (_voucherToCheck == voucherListVoucher)
            {
                this.numberSeqFormHandlerJournal().formMethodDataSourceCreate(true);
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodClosePre</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>NumberSeqFormHandler</c> object.
    /// </summary>
    /// <remarks>
    /// This method must be called from the <c>close</c> method of the journal line form, before
    /// <c>super</c> method.
    /// </remarks>
    public void formMethodClosePre()
    {
        if (numberSeqFormHandlerJournal)
        {
            numberSeqFormHandlerJournal.formMethodClose();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceCreatePost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>NumberSeqFormHandler</c> object.
    /// </summary>
    /// <remarks>
    /// This method must be called from the <c>LedgerJournalTrans</c> data source of the journal form
    /// method <c>initValue</c> after <c>super</c> method.
    /// </remarks>
    public void formMethodDataSourceCreatePost()
    {
        if (this.takeNewVoucher())
        {
            this.checkTaxBookSection_IT();
        }

        this.numberSeqFormHandlerJournal().formMethodDataSourceCreate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceDeletePre</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>NumberSeqFormHandler</c> object.
    /// </summary>
    /// <remarks>
    /// This method must be called from the <c>LedgerJournalTrans</c> data source of the journal method
    /// <c>delete</c> before the <c>super</c> method.
    /// </remarks>
    public void formMethodDataSourceDeletePre()
    {
        this.numberSeqFormHandlerJournal().formMethodDataSourceDelete();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceDeletePre_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Forms method before data source delete.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaction.
    /// </param>
    public void formMethodDataSourceDeletePre_CN(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans  ledgerJournalTransLocal;

        ledgerJournalTransLocal = ledgerJournalTable.ledgerJournalName().NewVoucher == NewVoucher::Manually
            && ledgerJournalTable.VoucherAllocatedAtPosting == NoYes::No
            && isSimpleMethod == NoYes::No
            ? _ledgerJournalTrans.orig()
            : _ledgerJournalTrans;

        if (ledgerJournalTable.ledgerJournalName().NewVoucher == NewVoucher::Manually
            && ledgerJournalTable.VoucherAllocatedAtPosting == NoYes::No
            && isSimpleMethod == NoYes::No
            && LedgerJournalTrans_CN_Extension::checkVoucherNotUsed_CN(ledgerJournalTransLocal))
        {
            NumberSeq_Voucher_CN::release(
                LedgerVoucherType_CN::find(ledgerJournalTransLocal.LedgerVoucherType_CN).NumberSequenceTable,
                ledgerJournalTransLocal.Voucher_CN,
                ledgerJournalTransLocal.TransDate);
        }
        else if (ledgerJournalTransLocal.LedgerVoucherType_CN
            && ledgerJournalTransLocal.Voucher_CN
            && LedgerJournalTrans_CN_Extension::checkVoucherNotUsed_CN(ledgerJournalTransLocal))
        {
            NumberSeq_Voucher_CN::release(
                LedgerVoucherType_CN::find(ledgerJournalTransLocal.LedgerVoucherType_CN).NumberSequenceTable,
                ledgerJournalTransLocal.Voucher_CN,
                ledgerJournalTransLocal.TransDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceFixedAssetsCreate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the form create events for the <c>LedgerJournalTrans_Asset</c> data source.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The active <c>LedgerJournalTrans</c> buffer of the form.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The active <c>LedgerJournalTrans_Asset</c> buffer of the form.
    /// </param>
    public void formMethodDataSourceFixedAssetsCreate(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        if (_ledgerJournalTrans.isFixedAssetsTransaction())
        {
            // Synchronize the fixed assets fields and performing defaulting.
            _ledgerJournalTrans_Asset.AssetId = _ledgerJournalTrans.getAssetId();
            _ledgerJournalTrans_Asset.Company = _ledgerJournalTrans.getAssetCompany();
            this.defaultBookIdForFATransaction(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceLinkActivePre</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>NumberSeqFormHandler</c> object.
    /// </summary>
    /// <remarks>
    /// This method must be called from the <c>LedgerJournalTrans</c> data source of the journal form
    /// method <c>linkActive</c> before the <c>super</c> method.
    /// </remarks>
    public void formMethodDataSourceLinkActivePre()
    {
        if (numberSeqFormHandlerJournal)
        {
            this.numberSeqFormHandlerJournal().formMethodDataSourceLinkActive();
            numberSeqFormHandlerJournal = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceValidateWritePost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>NumberSeqFormHandler</c> object.
    /// </summary>
    /// <returns>
    /// true if the validation is successful; otherwise, false.
    /// </returns>
    public boolean formMethodDataSourceValidateWritePost()
    {
        return this.numberSeqFormHandlerJournal().formMethodDataSourceValidateWrite();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceVoucherModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>NumberSeqFormHandler</c> object.
    /// </summary>
    /// <remarks>
    /// This method must be called from the <c>LedgerJournalTrans</c> data source of the journal form
    /// method <c>modified</c> of the field <c>Voucher</c> after the <c>super</c> method.
    /// </remarks>
    public void formMethodDataSourceVoucherModified()
    {
        this.numberSeqFormHandlerJournal().formMethodDataSourceVoucherModified();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceWritePre</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>NumberSeqFormHandler</c> object.
    /// </summary>
    /// <remarks>
    /// This method must be called from the <c>LedgerJournalTrans</c> data source of the journal form
    /// method <c>write</c> before the <c>super</c> method.
    /// </remarks>
    public void formMethodDataSourceWritePre()
    {
        this.numberSeqFormHandlerJournal().formMethodDataSourceWrite();

        // <GCN>
        if (LedgerParameters::isChineseVoucher_CN())
        {
            this.formMethodDataSourceWritePre_CN(ledgerJournalTrans_ds.cursor());
        }
        // </GCN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceWritePre_CN</Name>
				<Source><![CDATA[
    private void formMethodDataSourceWritePre_CN(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans  ledgerJournalTransLocal;
        Voucher             voucher;
        RefRecId            numberSequenceTableRecId;
        boolean             restart;
        FiscalCalendarRecId fiscalCalendarRecId = CompanyInfoHelper::fiscalCalendarRecId();

        if (!_ledgerJournalTrans.Voucher_CN
            || ledgerJournalTable.VoucherAllocatedAtPosting
            || ledgerJournalTable.ledgerJournalName().NewVoucher != NewVoucher::Manually
            || isSimpleMethod)
        {
            return;
        }

        GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceCN00009, funcName());

        ledgerJournalTransOrig.data(_ledgerJournalTrans.orig());

        if (!_ledgerJournalTrans.Voucher)
        {
            _ledgerJournalTrans.Voucher = NumberSeq::newGetVoucherFromId(ledgerJournalTable.NumberSequenceTable).voucher();
            NumberSeq_Voucher_CN::isUsed(
                LedgerVoucherType_CN::find(_ledgerJournalTrans.LedgerVoucherType_CN).NumberSequenceTable,
                _ledgerJournalTrans.Voucher_CN,
                _ledgerJournalTrans.TransDate);

            return;
        }

        if (_ledgerJournalTrans.Voucher_CN != ledgerJournalTransOrig.Voucher_CN
             || (_ledgerJournalTrans.Voucher_CN == ledgerJournalTransOrig.Voucher_CN
                 && LedgerFiscalCalendar::findPeriodStartDateByDateWithIndex(fiscalCalendarRecId, ledgerJournalTransOrig.TransDate)
                 != LedgerFiscalCalendar::findPeriodStartDateByDateWithIndex(fiscalCalendarRecId, _ledgerJournalTrans.TransDate)))
        {
            numberSequenceTableRecId = LedgerVoucherType_CN::find(_ledgerJournalTrans.LedgerVoucherType_CN).NumberSequenceTable;
            restart = NumberSequenceTable_CN::findByNumberSequenceTable(numberSequenceTableRecId).RestartNum;

            while select ledgerJournalTransLocal
                where ledgerJournalTransLocal.JournalNum == _ledgerJournalTrans.JournalNum
                && ledgerJournalTransLocal.Voucher_CN == _ledgerJournalTrans.Voucher_CN
                && ledgerJournalTransLocal.RecId      != _ledgerJournalTrans.RecId
            {
                if (!restart
                    && !voucher)
                {
                    voucher = ledgerJournalTransLocal.Voucher;
                }
                else if (restart
                    && !voucher)
                {
                    if (LedgerFiscalCalendar::findPeriodStartDateByDateWithIndex(fiscalCalendarRecId, ledgerJournalTransLocal.TransDate)
                        == LedgerFiscalCalendar::findPeriodStartDateByDateWithIndex(fiscalCalendarRecId, _ledgerJournalTrans.TransDate))
                    {
                        voucher = ledgerJournalTransLocal.Voucher;
                    }
                }
            }

            if (!voucher)
            {
                select firstonly ledgerJournalTransLocal
                    where ledgerJournalTransLocal.JournalNum == _ledgerJournalTrans.JournalNum
                        && ledgerJournalTransLocal.Voucher    == _ledgerJournalTrans.Voucher
                        && ledgerJournalTransLocal.RecId      != _ledgerJournalTrans.RecId;

                if (ledgerJournalTransLocal)
                {
                    _ledgerJournalTrans.Voucher = NumberSeq::newGetVoucherFromId(ledgerJournalTable.NumberSequenceTable).voucher();
                }
            }

            if (ledgerJournalTransOrig.Voucher != _ledgerJournalTrans.Voucher)
            {
                _ledgerJournalTrans.deleteVoucher(ledgerJournalTransOrig.Voucher);
            }

            NumberSeq_Voucher_CN::isUsed(
                LedgerVoucherType_CN::find(_ledgerJournalTrans.LedgerVoucherType_CN).NumberSequenceTable,
                _ledgerJournalTrans.Voucher_CN,
                _ledgerJournalTrans.TransDate);

            if (ledgerJournalTransOrig.Voucher_CN)
            {
                select firstonly RecId from ledgerJournalTransLocal
                    where ledgerJournalTransLocal.JournalNum == ledgerJournalTransOrig.JournalNum
                        && ledgerJournalTransLocal.Voucher    == ledgerJournalTransOrig.Voucher
                        && ledgerJournalTransLocal.Voucher_CN == ledgerJournalTransOrig.Voucher_CN
                        && ledgerJournalTransLocal.RecId      != _ledgerJournalTrans.RecId;

                if (ledgerJournalTransLocal.RecId == 0)
                {
                    NumberSeq_Voucher_CN::release(
                        LedgerVoucherType_CN::find(ledgerJournalTransOrig.LedgerVoucherType_CN).NumberSequenceTable,
                        ledgerJournalTransOrig.Voucher_CN,
                        ledgerJournalTransOrig.TransDate);
                }
            }

            if (ledgerJournalTransOrig.Voucher != _ledgerJournalTrans.Voucher)
            {
                this.reduceInternalContainers(_ledgerJournalTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createArgsForSettlementForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>Args</c> object for the settlement form.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The ledger journal transaction table record.
    /// </param>
    /// <returns>
    /// An instance of the <c>Args</c> object.
    /// </returns>
    protected Args createArgsForSettlementForm(LedgerJournalTrans _ledgerJournalTrans)
    {
        Args args = new Args();
        args.record(_ledgerJournalTrans);
        return args;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the settlement form for a journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// A <c>FormRun</c> instance.
    /// </returns>
    protected FormRun formSettlement(LedgerJournalTrans _ledgerJournalTrans)
    {
        FormRun settlementFormRun;


        // <GEERU>
        LedgerJournalTrans ledgerJournalTransSaveTmp; // use tmp record insted of using swapAccountOffsetaccount() twice before and after
        // because after second call swapAccountOffsetaccount() may not get initial record
        // </GEERU>
        // <GEERU><GEEU>
        boolean isCashModuleEnabled = RCashParameters::isCashModuleEnabled();
        // </GEERU></GEEU>

        if (!_ledgerJournalTrans.parmLedgerDimension()
            // <GEERU><GEEU>
            || (isCashModuleEnabled
             && _ledgerJournalTrans.AccountType == LedgerJournalACType::RCash
             && ! _ledgerJournalTrans.parmOffsetLedgerDimension())
            // </GEERU></GEEU>
            )
        {
            throw error("@SYS25989");
        }

        // <GEERU><GEEU>
        if (isCashModuleEnabled && _ledgerJournalTrans.AccountType == LedgerJournalACType::RCash)
        {
            ledgerJournalTransSaveTmp.data(_ledgerJournalTrans);
            _ledgerJournalTrans.swapAccountOffsetAccount();
        }
        // </GEERU></GEEU>

        Args args = this.createArgsForSettlementForm(_ledgerJournalTrans);

        switch (_ledgerJournalTrans.AccountType)
        {
            case LedgerJournalACType::Cust :
                settlementFormRun = new MenuFunction(menuitemDisplayStr(CustOpenTrans), MenuItemType::Display).create(args);
                break;

            case LedgerJournalACType::Vend :
                settlementFormRun = new MenuFunction(menuitemDisplayStr(VendOpenTrans), MenuItemType::Display).create(args);
                break;
        }

        if (settlementFormRun)
        {
            settlementFormRun.run();

            // <GEERU><GEEU>
            if (isCashModuleEnabled)
            {
                childFormsMap_W.insert(settlementFormRun.hWnd(), settlementFormRun);
            }
            // </GEERU></GEEU>

            settlementFormRun.wait();

            // <GEERU><GEEU>
            if (isCashModuleEnabled)
            {
                childFormsMap_W.remove(settlementFormRun.hWnd());
            }
            // </GEERU></GEEU>
        }

        // <GEERU><GEEU>
        if (isCashModuleEnabled && ledgerJournalTransSaveTmp && settlementFormRun)
        {
            ledgerJournalTransSaveTmp.SettleVoucher = _ledgerJournalTrans.SettleVoucher;
            buf2Buf(ledgerJournalTransSaveTmp, _ledgerJournalTrans);
        }
        // </GEERU></GEEU>

        return settlementFormRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetCheckResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the budget check result for the specified <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The budget check result for the specified <c>LedgerJournalTrans</c> record.
    /// </returns>
    public BudgetCheckResult getBudgetCheckResult(LedgerJournalTrans _ledgerJournalTrans)
    {
        BudgetCheckResult budgetCheckResult;
        ProjBudgetCheckResult projBudgetCheckResult;
        ProjBudgetStatus    projBudgetStatus;

        if (voucherBudgetCheckResults.exists(_ledgerJournalTrans.Voucher))
        {
            budgetCheckResult = voucherBudgetCheckResults.lookup(_ledgerJournalTrans.Voucher);
        }
        else
        {
            budgetCheckResult = _ledgerJournalTrans.getBudgetCheckResult();
            this.addBudgetCheckResultToCache(
                _ledgerJournalTrans.Voucher,
                budgetCheckResult);
        }

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project ||
           _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
        {
            select maxof(BudgetCheckResult) from projBudgetStatus where projBudgetStatus.SourceDocumentLine == _ledgerJournalTrans.RecId;

            projBudgetCheckResult   = projBudgetStatus ? projBudgetStatus.BudgetCheckResult : ProjBudgetCheckResult::NoCheck;
            if (projBudgetCheckResult == ProjBudgetCheckResult::Failed)
            {
                this.addBudgetCheckResultToCache(
                    _ledgerJournalTrans.Voucher,
                    BudgetCheckResult::Failed);
            }
        }

        //adding projBudgetCheckResult + 1, since this base enum value starts from 0
        if (enum2int(budgetCheckResult) >= enum2int(projBudgetCheckResult) + 1)
        {
            budgetCheckResult = budgetCheckResult;
        }
        else
        {
            budgetCheckResult = enum2int(projBudgetCheckResult) + 1;
        }

        return budgetCheckResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChildFormsMap_W</Name>
				<Source><![CDATA[
    public Map getChildFormsMap_W()
    {
        return childFormsMap_W;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCorrectedTaxAmountCurrentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the corrected tax amount for the current line.
    /// </summary>
    /// <returns>
    /// The corrected tax amount for the current line.
    /// </returns>
    public TaxAmountJournal getCorrectedTaxAmountCurrentLine()
    {
        return correctedTaxAmountCurrentLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDueDateBaseDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the basis the due date.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record contianing the dates.
    /// </param>
    /// <returns>
    /// The basis of the due date.
    /// </returns>
    public TransDate getDueDateBaseDate(LedgerJournalTrans _ledgerJournalTrans)
    {
        TransDate dueDateBase;

        if (_ledgerJournalTrans.CashDiscBaseDate)
        {
            dueDateBase = _ledgerJournalTrans.CashDiscBaseDate;
        }
        else if (_ledgerJournalTrans.DocumentDate)
        {
            dueDateBase = _ledgerJournalTrans.DocumentDate;
        }
        else
        {
            dueDateBase = _ledgerJournalTrans.TransDate;
        }

        return dueDateBase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDueDateLimit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the <c>PaymDueDateLimit_ES</c> record specified for the payment term.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record containing the payment term reference.
    /// </param>
    /// <returns>
    /// The <c>PaymDueDateLimit_ES</c> record.
    /// </returns>
    /// <remarks>
    /// The method is not supported on this subclass so no record is returend.
    /// </remarks>
    public PaymDueDateLimit_ES getDueDateLimit(LedgerJournalTrans _ledgerJournalTrans)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostingResults</Name>
				<Source><![CDATA[
    /// <summary>
    /// The an object which contains results when posting occurs.
    /// </summary>
    /// <returns>
    /// The <c>LedgerJournalCheckPostResults</c> object.
    /// </returns>
    public LedgerJournalCheckPostResults getPostingResults()
    {
        if (postingResults_Server == null)
        {
            postingResults_Server = LedgerJournalCheckPostResults::construct();
        }

        return postingResults_Server;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostingResults_Client</Name>
				<Source><![CDATA[
    [SysObsolete('Use getPostingResults instead.', false, 31\01\2016)]
    public LedgerJournalCheckPostResults getPostingResults_Client()
    {
        LedgerJournalCheckPostResults postingResults_Client;
        container packedClass;

        if (postingResults_Server == null)
        {
            postingResults_Client = LedgerJournalCheckPostResults::construct();
        }
        else
        {
            packedClass = postingResults_Server.pack();
            postingResults_Client = LedgerJournalCheckPostResults::createClient(packedClass);
        }

        return postingResults_Client;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getShowTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a tax object to use for displaying the temporary tax transactions for a single journal line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <returns>
    ///    A tax object.
    /// </returns>
    public Tax getShowTax(LedgerJournalTrans    _ledgerJournalTrans)
    {
        TaxCalculation taxCalculation;

        taxCalculation = LedgerJournalTrans::getTaxInstance(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice, true
                            // <GIN>
                            , null, false, _ledgerJournalTrans.TransDate
                            // </GIN>
                            );
        taxCalculation.sourceSingleLine(true, false);
        return taxCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getShowWithholdTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a withhold tax calculation object to use for displaying the temporary withhold tax transactions for a single journal line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <returns>
    ///    A withhold tax calculation object.
    /// </returns>
    public TaxWithholdCalculation_IN getShowWithholdTax_IN(LedgerJournalTrans    _ledgerJournalTrans)
    {
        TaxWithholdCalculation_IN  taxWithholdCalculation;
        LedgerJournalTrans::getTaxInstance(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.getWHTUsingInvoiceId_IN(), true, null, false, _ledgerJournalTrans.TransDate);

        if (TaxWithholdCustPaymDeleteInBatchPreventReDelTax_INFlight::instance().isEnabled())
        {
            taxWithholdCalculation = LedgerJournalTrans_IN_Extension::getTaxWithholdInstance_IN(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice, true);
        }
        else
        {
            taxWithholdCalculation = LedgerJournalTrans_IN_Extension::getTaxWithholdInstance_IN(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.getWHTUsingInvoiceId_IN(), true);
        }

        return taxWithholdCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total actual and calculated tax amount for the specified <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// An instance of <c>LedgerJournalTrans</c>.
    /// </param>
    /// <param name="_includeUseTax">
    /// A value that indicates whether the use tax is included in the tax amount; optional.
    /// </param>
    /// <returns>
    /// The actual and calculated tax amount for the current line.
    /// </returns>
    private container getTaxAmounts(LedgerJournalTrans _ledgerJournalTrans, boolean _includeUseTax)
    {
        TaxAmountCur actualTax, calculatedTax;
        boolean shouldCacheTax;

        if (ledgerJournalTable.Posted)
        {
            actualTax = Tax::taxAmountCorrectedPerLine(_ledgerJournalTrans.Voucher,
                                                                  _ledgerJournalTrans.TransDate,
                                                                  _ledgerJournalTrans.RecId);
            calculatedTax = abs(Tax::taxTotalVoucherDateRecId(_ledgerJournalTrans.Voucher,
                                                                 _ledgerJournalTrans.TransDate,
                                                                 _ledgerJournalTrans.RecId));
            shouldCacheTax = true;
        }
        else if (_ledgerJournalTrans.isTaxable())
        {
            [actualTax, calculatedTax] = _ledgerJournalTrans.getActualAndCalculatedTaxForSingleLine(_includeUseTax);

            shouldCacheTax = ledgerJournalTable.isTaxIntegrationEnabled()
                ? TaxUncommitted::existByDocumentAndInvoice(tableNum(LedgerJournalTable), ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice) 
                    : true;
        }

        this.parmActualTax(actualTax);

        if (calculatedTax < 0 && actualTax > 0)
        {
            actualTax = -actualTax;
        }
        else
        {
            actualTax = abs(actualTax);
        }

        if (shouldCacheTax)
        {
            correctedTaxAmount.insert(_ledgerJournalTrans.RecId, actualTax);
            correctedTaxAmountDisplay.insert(_ledgerJournalTrans.RecId, true);

            taxAmountDisplay.insert(_ledgerJournalTrans.RecId, abs(calculatedTax));
            taxAmountDisplayCalc.insert(_ledgerJournalTrans.RecId, true);
        }
        return [actualTax, abs(calculatedTax)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCompanyChangeForFixedAssets</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles both the company and offset company modified events for fixed assets.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> part of the transaction.
    /// </param>
    protected void handleCompanyChangeForFixedAssets(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        ;

        if (_ledgerJournalTrans.isFixedAssetsTransaction())
        {
            // This is a fixed assets transaction.

            // The company and account fields can be changed by the code that uses this method
            // so make sure the fields are synchronized.

            // Synchronize companies between records if.
            _ledgerJournalTrans_Asset.Company = _ledgerJournalTrans.getAssetCompany();

            // Synchronize the asset id on a company change.
            _ledgerJournalTrans_Asset.AssetId = _ledgerJournalTrans.getAssetId();

            // Default the book id.
            this.defaultBookIdForFATransaction(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAssetBookid</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>AssetId</c> and <c>BookId</c> fields of the specified transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer that stores part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table buffer that stores part of the transaction.
    /// </param>
    /// <remarks>
    ///    If neither the primary nor offset account is of type fixed assets, the <c>AssetBookId</c> field is
    ///    set blank.
    /// </remarks>
    public void initAssetBookid(LedgerJournalTrans       _ledgerJournalTrans,
                                LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        if (_ledgerJournalTrans.isFixedAssetsTransaction())
        {
            // Synchronize the asset id.
            _ledgerJournalTrans_Asset.AssetId = _ledgerJournalTrans.getAssetId();

            // Synchronize the company.
            _ledgerJournalTrans_Asset.Company = _ledgerJournalTrans.getAssetCompany();

            // Attempt to re-default the book.
            // <GEEPL>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
            {
                this.defaultBookIdForFATransaction_PL(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
            }
            else
            {
                // </GEEPL>
                this.defaultBookIdForFATransaction(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
                // <GEEPL>
            }
            // </GEEPL>
        }
        else
        {
            // Neither account is fixed assets, so blank out company, asset id and book id.
            _ledgerJournalTrans_Asset.AssetId = "";
            _ledgerJournalTrans_Asset.Company = "";
            _ledgerJournalTrans_Asset.BookId  = "";

            // <GIN>
            if (AssetParameters::isDepreciationIncomeTaxActEnable_IN())
            {
                _ledgerJournalTrans_Asset.AssetGroup_IN = "";
            }
            // </GIN>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAssetPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the posting profile of the transaction if it has a primary account of type
    ///    <c>LedgerJournalACType</c>::<c>FixedAssets</c>.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer that stores part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table buffer that stores part of the transaction.
    /// </param>
    /// <remarks>
    ///    If both the primary account and the asset book are specified by the transaction, the posting
    ///    profile will come from the asset book. Otherwise, the posting profile will come from the default
    ///    specified in the <c>AssetParameters</c> table.
    /// </remarks>
    public void initAssetPostingProfile(LedgerJournalTrans       _ledgerJournalTrans,
                                        LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
        {
            if (_ledgerJournalTrans.parmAccount() && _ledgerJournalTrans_Asset.BookId)
            {
                _ledgerJournalTrans.PostingProfile = AssetBook::find(_ledgerJournalTrans.parmAccount(), _ledgerJournalTrans_Asset.BookId).PostingProfile;
            }
            else
            {
                _ledgerJournalTrans.PostingProfile = AssetParameters::find().postingProfile();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCurrencyFromCustVendTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the currency field of the line based on the customer or vendor currency.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <param name="_custVendCurrency">
    /// The currency of the customer or vendor.
    /// </param>
    /// <remarks>
    /// If the customer or vendor currency does not exist a warning message is added to the infolog.
    /// </remarks>
    protected void initCurrencyFromCustVendTable(
        LedgerJournalTrans _ledgerJournalTrans,
        CurrencyCode _custVendCurrency)
    {
        if (_ledgerJournalTrans.isCompanyIntercompany(currentCompany) &&
            _custVendCurrency != '')
        {
            // Validate currency exists in the current company of the transaction
            if (Currency::exist(_custVendCurrency))
            {
                _ledgerJournalTrans.CurrencyCode = _custVendCurrency;
            }
            else
            {
                warning(strFmt("@SYS117888", _custVendCurrency));
            }
        }
        else
        {
            _ledgerJournalTrans.CurrencyCode = _custVendCurrency;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the posting profile field of the line if the account type of the line is "Customer".
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    public void initCustPostingProfile(LedgerJournalTrans _ledgerJournalTrans)
    {
        // <GEERU>
        SalesAgreementHeaderExt_RU salesAgreementHeaderExt;

        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU
           // <GEEU>
           , #isoPL, #isoCZ, #isoHU, #isoLT, #isoLV, #isoEE
           // </GEEU>
           ]))
        {
            // </GEERU>
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                if (_ledgerJournalTrans.Prepayment)
                {
                    _ledgerJournalTrans.PostingProfile = CustParameters::find().PrepaymentPostingProfile;
                    if (!_ledgerJournalTrans.PostingProfile)
                    {
                        _ledgerJournalTrans.PostingProfile = CustParameters::find().PostingProfile;
                    }
                }
                else
                {
                    _ledgerJournalTrans.PostingProfile = CustParameters::find().PostingProfile;
                }
                this.refreshDataSource(_ledgerJournalTrans);
            }
            // <GEERU>
        }
        else
        {
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                salesAgreementHeaderExt = this.findAgreementHeaderExt_RU(_ledgerJournalTrans) as SalesAgreementHeaderExt_RU;

                if (_ledgerJournalTrans.Prepayment)
                {
                    if (salesAgreementHeaderExt.CustPrepaymentPostingProfile)
                    {
                        _ledgerJournalTrans.PostingProfile = salesAgreementHeaderExt.CustPrepaymentPostingProfile;
                    }
                    else
                    {
                        _ledgerJournalTrans.PostingProfile = CustParameters::find().PrepaymentPostingProfile;
                    }

                    _ledgerJournalTrans.TaxGroup     = CustParameters::find().TaxGroup_RU;
                    _ledgerJournalTrans.TaxItemGroup = CustParameters::find().TaxItemGroup_RU;
                }
                if (! _ledgerJournalTrans.Prepayment || ! _ledgerJournalTrans.PostingProfile)
                {
                    if (salesAgreementHeaderExt.CustPostingProfile)
                    {
                        _ledgerJournalTrans.PostingProfile = salesAgreementHeaderExt.CustPostingProfile;
                    }
                    else
                    {
                        _ledgerJournalTrans.PostingProfile = CustParameters::find().PostingProfile;
                    }
                }
            }

            this.initCustOffsetPostingProfile(_ledgerJournalTrans);

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
                (_ledgerJournalTrans.AccountType      == LedgerJournalACType::Cust  ||
                _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)  &&
                    _ledgerJournalTrans.SettleVoucher != SettlementType::SelectedTransact)
            {
                if (_ledgerJournalTrans.Prepayment)
                {
                    _ledgerJournalTrans.SettleVoucher = SettlementType::None;
                }
                else
                {
                    _ledgerJournalTrans.SettleVoucher = CustParameters::find().AutoSettle ?
                                                        SettlementType::OpenTransact :
                                                        SettlementType::None;
                }
            }

            if (_ledgerJournalTrans.AccountType != LedgerJournalACType::Cust    &&
                _ledgerJournalTrans.AccountType != LedgerJournalACType::Vend    &&
                _ledgerJournalTrans.AccountType != LedgerJournalACType::RCash   &&
                _ledgerJournalTrans.AccountType != LedgerJournalACType::Employee_RU)
            {
                _ledgerJournalTrans.PostingProfile = '';
            }

            this.refreshDataSource(_ledgerJournalTrans);
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustOffsetPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the offset posting profile field of the line if the offset account type of the line is "Customer".
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    private void initCustOffsetPostingProfile(LedgerJournalTrans _ledgerJournalTrans)
    {
        SalesAgreementHeaderExt_RU salesAgreementHeaderExt;

        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
        {
            salesAgreementHeaderExt = this.findAgreementHeaderExt_RU(_ledgerJournalTrans, AccountOffsetaccount::OffsetAccount) as SalesAgreementHeaderExt_RU;

            if (_ledgerJournalTrans.Prepayment)
            {
                if (salesAgreementHeaderExt.CustPrepaymentPostingProfile)
                {
                    _ledgerJournalTrans.OffsetPostingProfile_RU = salesAgreementHeaderExt.CustPrepaymentPostingProfile;
                }
                else
                {
                    _ledgerJournalTrans.OffsetPostingProfile_RU = CustParameters::find().PrepaymentPostingProfile;
                }

                _ledgerJournalTrans.TaxGroup     = CustParameters::find().TaxGroup_RU;
                _ledgerJournalTrans.TaxItemGroup = CustParameters::find().TaxItemGroup_RU;
            }
            if (! _ledgerJournalTrans.Prepayment || ! _ledgerJournalTrans.OffsetPostingProfile_RU)
            {
                if (salesAgreementHeaderExt.CustPostingProfile)
                {
                    _ledgerJournalTrans.OffsetPostingProfile_RU = salesAgreementHeaderExt.CustPostingProfile;
                }
                else
                {
                    _ledgerJournalTrans.OffsetPostingProfile_RU = CustParameters::find().PostingProfile;
                }
            }
        }

        if (_ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Cust      &&
                _ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Vend      &&
                _ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::RCash     &&
                _ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Employee_RU)

        {
            _ledgerJournalTrans.OffsetPostingProfile_RU = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>DefaultDimension</c> field of the specified transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer that stores part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table buffer that stores part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_RAsset">
    ///    The <c>LedgerJournalTrans_RAsset</c> table buffer that stores part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_RDeferrals">
    ///    The <c>LedgerJournalTrans_RDeferrals</c> table buffer that stores part of the transaction.
    /// </param>
    public void initDefaultDimension(
        LedgerJournalTrans        _ledgerJournalTrans,
        LedgerJournalTrans_Asset      _ledgerJournalTrans_Asset      = null,
        LedgerJournalTrans_RAsset     _ledgerJournalTrans_RAsset     = null,
        LedgerJournalTrans_RDeferrals _ledgerJournalTrans_RDeferrals = null
        )
    {
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            _ledgerJournalTrans.DefaultDimension = LedgerJournalEngine::initDefaultDimensionServer(_ledgerJournalTrans,
                                                                                                   _ledgerJournalTrans_Asset,
                                                                                                   _ledgerJournalTrans_RAsset,
                                                                                                   _ledgerJournalTrans_RDeferrals);
        }
        else
        {
            // </GEERU>
            _ledgerJournalTrans.DefaultDimension = LedgerJournalEngine::initDefaultDimensionServer(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
            this.mergeResourceDimensionDefault(_ledgerJournalTrans);
            // <GEERU>
        }
        // </GEERU>
        
        if (LedgerJournalEngine::canInitializePrimaryDefaultDimensions(_ledgerJournalTrans) && _ledgerJournalTrans.parmAccount())
        {
            // Only initialize if the account is set since this method can also be called when the account is cleared.
            this.performFinTagDefaulting(_ledgerJournalTrans, AccountOffsetaccount::Account);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initEmplPostingProfile_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Init posting profile from Advance holder setup.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// Record to apply the posting profile to.
    /// </param>
    public void initEmplPostingProfile_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Employee_RU)
        {
            _ledgerJournalTrans.PostingProfile = EmplParameters_RU::find().PostingProfile;
        }

        this.initEmplOffsetPostingProfile_RU(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initEmplOffsetPostingProfile_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Init offset posting profile from Advance holder setup.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// Record to apply the offset posting profile to.
    /// </param>
    private void initEmplOffsetPostingProfile_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Employee_RU)
        {
            _ledgerJournalTrans.OffsetPostingProfile_RU = EmplParameters_RU::find().PostingProfile;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromAgreementHeader_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initiates a <c>LedgerJournalTrans</c> record with values based on <c>AgreementHeader</c> record depending on account type.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_agreementHeader">
    /// The <c>AgreementHeader</c> record.
    /// </param>
    /// <param name="_accountOffsetaccount">
    /// Account type, account or offset account; optional.
    /// </param>
    protected void initFromAgreementHeader_RU(LedgerJournalTrans _ledgerJournalTrans,
        AgreementHeader _agreementHeader,
        AccountOffsetaccount _accountOffsetaccount = AccountOffsetaccount::Account)
    {
        AgreementHeaderDefault agreementHeaderDefault = _agreementHeader.agreementHeaderDefault();
        SalesAgreementHeaderDefault salesAgreementHeaderDefault;
        PurchAgreementHeaderDefault purchAgreementHeaderDefault;
        PaymMode paymMode;
        PaymSpec paymSpec;

        _ledgerJournalTrans.CurrencyCode = _agreementHeader.Currency;
        this.currencyModified(_ledgerJournalTrans);

        if (agreementHeaderDefault.PaymentTerms)
        {
            _ledgerJournalTrans.Payment = agreementHeaderDefault.PaymentTerms;
            this.paymentModified(_ledgerJournalTrans);
        }

        _ledgerJournalTrans.CashDiscCode = agreementHeaderDefault.CashDiscountCode;
        this.cashDiscCodeModified(_ledgerJournalTrans);

        if (_agreementHeader is SalesAgreementHeader)
        {
            salesAgreementHeaderDefault = SalesAgreementHeaderDefault::findSalesAgreementHeader(_agreementHeader.RecId);
            paymMode = salesAgreementHeaderDefault.CustomerMethodOfPayment;
            paymSpec = salesAgreementHeaderDefault.CustomerPaymentSpec;
        }
        else
        if (_agreementHeader is PurchAgreementHeader)
        {
            purchAgreementHeaderDefault = PurchAgreementHeaderDefault::findPurchAgreementHeader(_agreementHeader.RecId);
            paymMode = purchAgreementHeaderDefault.MethodOfPayment;
            paymSpec = purchAgreementHeaderDefault.PaymentSpecification;
        }

        if (paymMode)
        {
            _ledgerJournalTrans.PaymMode = paymMode;
            _ledgerJournalTrans.setAgreementEmptyValues_RU(_accountOffsetaccount == AccountOffsetaccount::Account
                                                         ? AccountOffsetaccount::OffsetAccount
                                                         : AccountOffsetaccount::Account);
            _ledgerJournalTrans.paymModeModified();
        }

        if (paymSpec)
        {
            _ledgerJournalTrans.PaymSpec = paymSpec;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromAssetTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes local asset information.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTrans_Asset">
    /// The <c>LedgerJournalTrans_Asset</c> record.
    /// </param>
    public void initFromAssetTable(LedgerJournalTrans       _ledgerJournalTrans,
                                   LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        assetTable = this.findAssetTable(_ledgerJournalTrans);

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
        {
            this.initDefaultDimension(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
        }

        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets)
        {
            this.initOffsetDefaultDimension(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
        }

        this.initAssetPostingProfile(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromAssetTable_RU</Name>
				<Source><![CDATA[
    protected void initFromAssetTable_RU(LedgerJournalTrans        _ledgerJournalTrans,
                                         LedgerJournalTrans_RAsset _ledgerJournalTrans_RAsset)
    {
        LedgerDimensionDefaultAccount offsetDefaultAccount;
        rAssetTable     = this.findRAssetTable_RU(_ledgerJournalTrans);
        RAssetStandards rAssetStandards = RAssetStandards::find(rassetTable.AccountNum, _ledgerJournalTrans_RAsset.StandardId);
        this.initDefaultDimension(_ledgerJournalTrans, null, _ledgerJournalTrans_RAsset);
        if (rassetTable.AccountNum)
        {
            if (rAssetStandards.AssetStandardId == RAssetParameters::find().StandardIdDefault)
            {
                _ledgerJournalTrans.CurrencyCode = (RAssetJournal::currencyBase() ? CompanyInfoHelper::standardCurrency() : rAssetStandards.CurrencyCode);
            }
            else
            {
                _ledgerJournalTrans.CurrencyCode = rAssetStandards.CurrencyCode;
            }
            _ledgerJournalTrans_RAsset.AssetId            = rAssetTable.AccountNum;
            _ledgerJournalTrans.PostingProfile            = rAssetStandards.postingProfile(_ledgerJournalTrans.TransDate);
            _ledgerJournalTrans.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(rAssetStandards.defaultDimension(_ledgerJournalTrans.TransDate), ledgerJournalTable.DefaultDimension);
            offsetDefaultAccount = this.assetOffsetLedgerDimension_RU(_ledgerJournalTrans, _ledgerJournalTrans_RAsset);

            if (offsetDefaultAccount)
            {
                _ledgerJournalTrans.parmOffsetLedgerDimension(LedgerDimensionFacade::serviceCreateLedgerDimension(offsetDefaultAccount, _ledgerJournalTrans.DefaultDimension));
            }
            _ledgerJournalTrans_RAsset.DebLedgerDimension = this.assetLedgerDimension_RU(_ledgerJournalTrans, _ledgerJournalTrans_RAsset);
        }
        else
        {
            _ledgerJournalTrans.CurrencyCode             = CompanyInfoHelper::standardCurrency();
            _ledgerJournalTrans_RAsset.DebLedgerDimension = 0;
            _ledgerJournalTrans.PostingProfile           = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromBankTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the journal line with information from the bank account.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    protected void initFromBankTable(LedgerJournalTrans _ledgerJournalTrans)
    {
        _ledgerJournalTrans.CurrencyCode = bankAccountTable.CurrencyCode ? bankAccountTable.CurrencyCode : _ledgerJournalTrans.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCompanyInfo</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the journal line based on <c>CompanyInfo</c> data.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    protected void initFromCompanyInfo(LedgerJournalTrans _ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCustTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the journal line with information from the customer.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    protected void initFromCustTable(LedgerJournalTrans _ledgerJournalTrans)
    {
        TransDate transDate;
        #ISOCountryRegionCodes
        // <GEEU>
        #EECountryRegionCodes
        // </GEEU>

        DueDate dueDate;
        // <GIN>
        boolean countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        TaxInformationCustTable_IN  taxInformationCustTableLoc;
        // </GIN>

        ledgerJournalCashDiscService = new LedgerJournalCashDiscService(_ledgerJournalTrans.JournalNum,
                                                                        _ledgerJournalTrans.Voucher);

        _ledgerJournalTrans.Payment = custTable.PaymTermId;     // getUpdatedDueDate needs this value

        transDate = _ledgerJournalTrans.TransDate;

        if (custTable.CashDiscBaseDays)
        {
            _ledgerJournalTrans.CashDiscBaseDays = custTable.CashDiscBaseDays;
            _ledgerJournalTrans.CashDiscBaseDate = _ledgerJournalTrans.TransDate + _ledgerJournalTrans.CashDiscBaseDays;
            transDate = _ledgerJournalTrans.CashDiscBaseDate;
        }
        else
        {
            _ledgerJournalTrans.CashDiscBaseDays = 0;
            _ledgerJournalTrans.CashDiscBaseDate = dateNull();
        }

        if (custTable.PaymTermId && _ledgerJournalTrans.Invoice)
        {
            this.findPayment(custTable.PaymTermId);
            dueDate = payment.due(transDate, this.paymDayId(_ledgerJournalTrans));

            if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
            {
                dueDate = this.adjustDueDate(dueDate, _ledgerJournalTrans);
            }

            _ledgerJournalTrans.Due = dueDate;
        }
        else
        {
            _ledgerJournalTrans.Due = transDate;
        }

        // <GEEU>
        if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            _ledgerJournalTrans.modifyVatDueDate_W();
        }
        // </GEEU>

        if (custTable.CashDisc)
        {
            this.findCashDisc(custTable.company(), custTable.CashDisc);

            if (_ledgerJournalTrans.amount())
            {
                this.calcCashDisc(_ledgerJournalTrans);
            }
        }
        else
        {
            _ledgerJournalTrans.CashDiscAmount = 0;
            _ledgerJournalTrans.DateCashDisc   = dateNull();
        }

        _ledgerJournalTrans.CurrencyCode = custTable.Currency ? custTable.Currency : _ledgerJournalTrans.CurrencyCode;

        _ledgerJournalTrans.TaxGroup                = '';
        this.initCustPostingProfile(_ledgerJournalTrans);
        _ledgerJournalTrans.CustVendBankAccountId   = custTable.BankAccount;
        _ledgerJournalTrans.PaymMode                = custTable.PaymMode;
        _ledgerJournalTrans.PaymSpec                = custTable.PaymSpec;
        _ledgerJournalTrans.BankTransType           = CustPaymModeTable::find(custTable.PaymMode).BankTransType;
        _ledgerJournalTrans.CashDiscCode            = custTable.CashDisc;
        _ledgerJournalTrans.SettleVoucher           = CustParameters::find().AutoSettle ? SettlementType::OpenTransact : SettlementType::None;

        if (TaxIntegrationUtils::isTaxIntegrationEnabledForJournalType(_ledgerJournalTrans.ledgerJournalTable().JournalType))
        {
            custTable.copyPrimaryRegistrationNumberToVATMap(_ledgerJournalTrans, transDate);
        }
        else
        {
            _ledgerJournalTrans.vatNumJournal = custTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, transDate);
        }

        _ledgerJournalTrans.EnterpriseNumber        = custTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::UID, transDate);
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]))
        {
            _ledgerJournalTrans.BankCentralBankPurposeCode = custTable.BankCentralBankPurposeCode;
            _ledgerJournalTrans.BankCentralBankPurposeText = custTable.BankCentralBankPurposeText;
        }

        // <GIN>
        if (countryRegion_IN)
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
            taxInformationCustTableLoc = custTable.getTaxInformationCustTable_IN();
            if (TaxWithholdParameters_IN::find().tdsActivate
                || TaxWithholdParameters_IN::find().tcsActivate)
            {
                if (TaxWithholdParameters_IN::find().tdsActivate)
                {
                    ledgerJournalTransTaxExt.TDSGroup         = taxInformationCustTableLoc.tdsGroup;
                }

                if (TaxWithholdParameters_IN::find().tcsActivate)
                {
                    ledgerJournalTransTaxExt.tcsGroup         = taxInformationCustTableLoc.tcsGroup;
                }
            }
            ledgerJournalTransTaxExt.WithIGSTPayment = TaxGSTEPZCodeHelper::construct(custTable).isEPZCodeNotNone();
            ledgerJournalTransTaxExt.WouldYouClaimRefund = ledgerJournalTransTaxExt.WithIGSTPayment;
        }
        // </GIN>

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoTH]))
        {
            if (TaxThaiGovCertificationFeatureChecker::isTaxWithholdEnabled())
            {
                _ledgerJournalTrans.TaxWithholdCalculate_TH = custTable.TaxWithholdCalculate_TH;
                _ledgerJournalTrans.TaxWithholdGroup  = custTable.getTaxWithholdGroup();
            }
        }

        this.initFromOffsetAccount(_ledgerJournalTrans);

        ledgerJournalCashDiscService.setCashDiscParameters(
            _ledgerJournalTrans.Company,
            _ledgerJournalTrans.CashDiscCode,
            _ledgerJournalTrans.Invoice,
            _ledgerJournalTrans.AccountType);

        // <GEEPL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            this.initVatRegData_PL(_ledgerJournalTrans, custTable);
        }
        // </GEEPL>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCustVendVatRegNums_PL</Name>
				<Source><![CDATA[
    public void initFromCustVendVatRegNums_PL(LedgerJournalTrans _ledgerJournalTrans)
    {
        _ledgerJournalTrans.TaxPeriodPaymentCode_PL = "";
        _ledgerJournalTrans.initFromCustVendVatRegNums_PL();

        this.allowEditVatRegister_PL(_ledgerJournalTrans);

        this.refreshDataSource(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromEmplTable_RU</Name>
				<Source><![CDATA[
    protected void initFromEmplTable_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        _ledgerJournalTrans.Due          = _ledgerJournalTrans.TransDate;
        _ledgerJournalTrans.CurrencyCode = mainAccount.CurrencyCode ? mainAccount.CurrencyCode : _ledgerJournalTrans.CurrencyCode;

        this.initDefaultDimension(_ledgerJournalTrans);

        this.initEmplPostingProfile_RU(_ledgerJournalTrans);

        _ledgerJournalTrans.TaxGroup      = '';
        _ledgerJournalTrans.Tax1099Fields = 0;
        _ledgerJournalTrans.BankTransType = '';
        _ledgerJournalTrans.PaymSpec      = '';
        _ledgerJournalTrans.Payment       = '';
        _ledgerJournalTrans.PaymId        = '';
        _ledgerJournalTrans.CashDiscCode  = '';
        _ledgerJournalTrans.SettleVoucher = SettlementType::None;

        _ledgerJournalTrans.vatNumJournal = '';
        LedgerJournalTransTaxExtension taxExtension = _ledgerJournalTrans.ledgerJournalTransTaxExtension();
        taxExtension.VATNumRecId = 0;
        taxExtension.VATNumTableType = TaxExemptNumberSourceType::None;
        _ledgerJournalTrans.packExtensionTable(taxExtension);

        this.initFromOffsetAccount(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromMainAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the journal line with information from the Main account.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    protected void initFromMainAccount(LedgerJournalTrans _ledgerJournalTrans)
    {
        MainAccount mainAccountLedger;

        mainAccountLedger = MainAccount::findByMainAccountId(
            LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(_ledgerJournalTrans.parmLedgerDimension()));

        _ledgerJournalTrans.CurrencyCode = mainAccountLedger.CurrencyCode ? mainAccountLedger.CurrencyCode : _ledgerJournalTrans.CurrencyCode;

        if (_ledgerJournalTrans.isCompanyIntercompany(currentCompany) == NoYes::No &&
            ledgerJournalTable.FixedOffsetAccount == NoYes::No)
        {
            if (mainAccountLedger.OffsetLedgerDimension)
            {
                _ledgerJournalTrans.OffsetAccountType = LedgerJournalACType::Ledger;
                _ledgerJournalTrans.parmOffsetLedgerDimension(
                    _ledgerJournalTrans.getOffsetLedgerDimensionForLedgerType(
                        mainAccountLedger.OffsetLedgerDimension,
                        _ledgerJournalTrans.getOffsetCompany()));
            }
        }

        if (ledgerJournalTable.JournalType == LedgerJournalType::CustPaymRemittance ||
            ledgerJournalTable.JournalType == LedgerJournalType::VendPaymRemittance)
        {
            _ledgerJournalTrans.BankRemittanceType  = ledgerJournalTable.BankRemittanceType;
            _ledgerJournalTrans.BankAccountId       = ledgerJournalTable.BankAccountId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromOffsetAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes with information from the offset account.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTrans_Project">
    /// The <c>LedgerJournalTrans_Project</c> record; optional.
    /// </param>
    /// <param name = "_ledgerJournalTrans_Asset">
    /// The <c>LedgerJournalTrans_Asset</c> record; optional.
    /// </param>
    /// <param name = "_ledgerJournalTrans_RAsset">
    /// The <c>LedgerJournalTrans_RAsset</c> record; optional.
    /// </param>
    /// <param name = "_ledgerJournalTrans_RDeferrals">
    /// The <c>LedgerJournalTrans_RDeferrals</c> record; optional.
    /// </param>
    public void initFromOffsetAccount(
        LedgerJournalTrans          _ledgerJournalTrans,
        LedgerJournalTrans_Project  _ledgerJournalTrans_Project = null,
        LedgerJournalTrans_Asset    _ledgerJournalTrans_Asset = null
        ,LedgerJournalTrans_RAsset    _ledgerJournalTrans_RAsset     = null,
        LedgerJournalTrans_RDeferrals _ledgerJournalTrans_RDeferrals = null
        )
    {
        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        this.initTaxGroup(_ledgerJournalTrans);
        this.initTaxItemGroup(_ledgerJournalTrans, _ledgerJournalTrans_Project);
        this.initOverrideSalesTax(_ledgerJournalTrans);

        if (_ledgerJournalTrans.parmOffsetLedgerDimension())
        {
            if ((ledgerJournalTable.JournalType == LedgerJournalType::Daily
                || ledgerJournalTable.JournalType == LedgerJournalType::Approval
                || ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister
                || ledgerJournalTable.JournalType == LedgerJournalType::Cost
                || (RCashInitFromOffsetAccountProjFlight::instance().isEnabled()
                    && ledgerJournalTable.JournalType == LedgerJournalType::RCash))
                && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
            {
                this.initFromProjTable(_ledgerJournalTrans, _ledgerJournalTrans_Project);
            }

            if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets)
            {
                _ledgerJournalTrans_Asset.AssetId = _ledgerJournalTrans.getAssetId();
                _ledgerJournalTrans_Asset.Company = _ledgerJournalTrans.getAssetCompany();
                this.defaultBookIdForFATransaction(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
            }

            // <GEERU>
            if (countryRegion_RU)
            {
                this.initOffsetDefaultDimension(_ledgerJournalTrans, _ledgerJournalTrans_Asset, _ledgerJournalTrans_RAsset, _ledgerJournalTrans_RDeferrals);
            }
            else
            {
                // </GEERU>
                this.initOffsetDefaultDimension(_ledgerJournalTrans,_ledgerJournalTrans_Asset);
                // <GEERU>
            }

            switch (_ledgerJournalTrans.OffsetAccountType)
            {
                case LedgerJournalACType::Cust :
                    if (countryRegion_RU)
                    {
                        this.initCustPostingProfile(_ledgerJournalTrans);
                    }
                    break;

                case LedgerJournalACType::Vend :
                    if (countryRegion_RU)
                    {
                        this.initVendPostingProfile(_ledgerJournalTrans);
                    }
                    break;

                case LedgerJournalACType::RCash :
                    if (RCashParameters::isCashModuleEnabled())
                    {
                        this.initRCashPostingProfile_RU(_ledgerJournalTrans);
                    }
                    break;

                case LedgerJournalACType::Employee_RU :
                    this.initEmplPostingProfile_RU(_ledgerJournalTrans);
                    break;
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromProjTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes project information.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTrans_Project">
    /// The <c>LedgerJournalTrans_Project</c> record.
    /// </param>
    void initFromProjTable(
        LedgerJournalTrans          _ledgerJournalTrans,
        LedgerJournalTrans_Project  _ledgerJournalTrans_Project)
    {
        if (!_ledgerJournalTrans.CurrencyCode)
        {
            _ledgerJournalTrans.CurrencyCode = CompanyInfoHelper::standardCurrency();
        }

        projTable = _ledgerJournalTrans.findProjTable();
        ProjInvoiceTable ProjInvoiceTableLocal = ProjInvoiceTable::find(projTable.ProjInvoiceProjId);
 
        if (ProjInvoiceTableLocal)
        {
            _ledgerJournalTrans_Project.SalesCurrencyId = ProjInvoiceTableLocal.CurrencyId;
            _ledgerJournalTrans_Project.ProjPriceGroupID = ProjInvoiceTableLocal.ProjPriceGroup;
        }

        if (!_ledgerJournalTrans_Project.SalesCurrencyId)
        {
            if (projTable.CustAccount)
            {
                _ledgerJournalTrans_Project.SalesCurrencyId = CustTable::find(projTable.CustAccount).Currency;
            }
            else
            {
                _ledgerJournalTrans_Project.SalesCurrencyId = CompanyInfoHelper::standardCurrency();
            }
        }

        if (!ProjValProjCategorySetUp::checkProjCategory(_ledgerJournalTrans.parmAccount(), _ledgerJournalTrans_Project.CategoryId))
        {
            _ledgerJournalTrans_Project.CategoryId = '';
        }
        else
        {
            _ledgerJournalTrans_Project.CategoryId = (_ledgerJournalTrans_Project.CategoryId ? _ledgerJournalTrans_Project.CategoryId : ProjParameters::find().CostCategory);
            this.setProjTaxItemGroup(_ledgerJournalTrans, _ledgerJournalTrans_Project);
        }

        _ledgerJournalTrans_Project.LinePropertyId = ProjLinePropertySetup::findLinePropertyId(projTable.ProjId, _ledgerJournalTrans_Project.CategoryId);

        this.projCategoryModified(_ledgerJournalTrans, _ledgerJournalTrans_Project);

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project)
        {
            _ledgerJournalTrans_Project.ProjId = _ledgerJournalTrans.parmAccount();
            _ledgerJournalTrans_Project.TaxGroupSales = ProjParameters::taxGroupInvoice(_ledgerJournalTrans.parmAccount());
            this.parmLedgerJournalTrans_Project(_ledgerJournalTrans_Project);
            this.initDefaultDimension(_ledgerJournalTrans);
        }
        else if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
        {
            _ledgerJournalTrans_Project.ProjId = _ledgerJournalTrans.parmOffsetAccount();
            _ledgerJournalTrans_Project.TaxGroupSales = ProjParameters::taxGroupInvoice(_ledgerJournalTrans.parmOffsetAccount());
            this.parmLedgerJournalTrans_Project(_ledgerJournalTrans_Project);
            this.initOffsetDefaultDimension(_ledgerJournalTrans);
        }

        _ledgerJournalTrans_Project.TaxItemGroupSales = ProjCategory::find(_ledgerJournalTrans_Project.CategoryId).TaxItemGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromRCashTable_RU</Name>
				<Source><![CDATA[
    protected void initFromRCashTable_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        _ledgerJournalTrans.Due          = _ledgerJournalTrans.TransDate;
        _ledgerJournalTrans.CurrencyCode = rCashTable.CurrencyCode ?
                                           rCashTable.CurrencyCode :
                                           _ledgerJournalTrans.CurrencyCode;

        this.initDefaultDimension(_ledgerJournalTrans);

        this.initRCashPostingProfile_RU(_ledgerJournalTrans);

        _ledgerJournalTrans.TaxGroup      = '';
        _ledgerJournalTrans.Tax1099Fields    = 0;
        _ledgerJournalTrans.BankTransType = '';
        _ledgerJournalTrans.PaymSpec      = '';
        _ledgerJournalTrans.Payment       = '';
        _ledgerJournalTrans.PaymId        = '';
        _ledgerJournalTrans.CashDiscCode  = '';
        _ledgerJournalTrans.SettleVoucher = SettlementType::None;

        _ledgerJournalTrans.vatNumJournal = '';
        LedgerJournalTransTaxExtension taxExtension = _ledgerJournalTrans.ledgerJournalTransTaxExtension();
        taxExtension.VATNumRecId = 0;
        taxExtension.VATNumTableType = TaxExemptNumberSourceType::None;
        _ledgerJournalTrans.packExtensionTable(taxExtension);

        this.initFromOffsetAccount(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromRDeferralsBook_RU</Name>
				<Source><![CDATA[
    protected void initFromRDeferralsBook_RU(LedgerJournalTrans            _ledgerJournalTrans,
                                             LedgerJournalTrans_RDeferrals _ledgerJournalTrans_RDeferrals)
    {
        RDeferralsBook rDeferralsBook;

        rDeferralsBook = RDeferralsBook::find(this.findRDeferralsTable_RU(_ledgerJournalTrans).DeferralsId,
                                              _ledgerJournalTrans_RDeferrals.BookId);

        if (rDeferralsBook.DeferralsId)
        {
            _ledgerJournalTrans_RDeferrals.DeferralsId     = rDeferralsBook.DeferralsId;
            _ledgerJournalTrans.PostingProfile             = rDeferralsBook.PostingProfile;
            _ledgerJournalTrans_RDeferrals.LedgerDimension = RDeferralsLedgerAccounts::deferralsLedgerDim(_ledgerJournalTrans_RDeferrals.DeferralsId,
                                                                                                          _ledgerJournalTrans_RDeferrals.TransType,
                                                                                                          _ledgerJournalTrans_RDeferrals.BookId,
                                                                                                          _ledgerJournalTrans.PostingProfile);

            _ledgerJournalTrans.parmOffsetLedgerDimension(RDeferralsLedgerAccounts::deferralsOffsetLedgerDim(_ledgerJournalTrans_RDeferrals.DeferralsId,
                                                                                                             _ledgerJournalTrans_RDeferrals.TransType,
                                                                                                             _ledgerJournalTrans_RDeferrals.BookId,
                                                                                                             _ledgerJournalTrans.PostingProfile));
        }
        else
        {
            _ledgerJournalTrans_RDeferrals.DeferralsId = '';
        }

        this.initDefaultDimension(_ledgerJournalTrans, null, null, _ledgerJournalTrans_RDeferrals);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromVendTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a journal line with vendor-related information.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_tax1099Detail">
    /// The <c>Tax1099BoxDetail</c> record; optional.
    /// </param>
    protected void initFromVendTable(LedgerJournalTrans _ledgerJournalTrans, Tax1099BoxDetail _tax1099Detail = null)
    {
        #ISOCountryRegionCodes

        // <GEEU>
        #EECountryRegionCodes
        // </GEEU>

        DueDate     dueDate;
        // <GIN>
        boolean                     countryRegion_IN    = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        TaxInformationVendTable_IN  taxInformationVendTableLoc;
        // </GIN>

        ledgerJournalCashDiscService = new LedgerJournalCashDiscService(_ledgerJournalTrans.JournalNum,
                                                                        _ledgerJournalTrans.Voucher);

        _ledgerJournalTrans.Payment = vendTable.PaymTermId;     // getUpdatedDueDate needs this value
        if (vendTable.PaymTermId && _ledgerJournalTrans.Invoice)
        {
            this.findPayment(vendTable.PaymTermId);
            //
            //  If an Invoice number and Document date exist use the Document date to determine the Due date
            //  otherwise use the Transaction date.
            //
            dueDate = payment.due((_ledgerJournalTrans.Invoice && _ledgerJournalTrans.DocumentDate) ?
                            _ledgerJournalTrans.DocumentDate : _ledgerJournalTrans.TransDate,
                            this.paymDayId(_ledgerJournalTrans));

            if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
            {
                dueDate = this.adjustDueDate(dueDate, _ledgerJournalTrans);
            }

            _ledgerJournalTrans.Due = dueDate;
        }
        else
        {
            _ledgerJournalTrans.Due = _ledgerJournalTrans.TransDate;
        }

        // <GEEU>
        if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            _ledgerJournalTrans.modifyVatDueDate_W();
        }
        // </GEEU>

        if (vendTable.CashDisc)
        {
            // Lookup the Cash Disc record buffer from the internal cache
            this.findCashDisc(vendTable.company(), vendTable.CashDisc);

            if (_ledgerJournalTrans.amount())
            {
                this.calcCashDisc(_ledgerJournalTrans);
            }
        }
        else
        {
            _ledgerJournalTrans.CashDiscAmount = 0;
            _ledgerJournalTrans.DateCashDisc   = dateNull();
        }

        _ledgerJournalTrans.CurrencyCode = vendTable.Currency ? vendTable.Currency : _ledgerJournalTrans.CurrencyCode;

        this.initVendPostingProfile(_ledgerJournalTrans);

        _ledgerJournalTrans.TaxGroup                = '';
        _ledgerJournalTrans.Tax1099Fields           = vendTable.Tax1099Fields;
        _ledgerJournalTrans.ledgerJournalTransTaxExtension().AccrueSalesTaxType = vendTable.AccrueSalesTaxType;

        if (TaxIntegrationUtils::isTaxIntegrationEnabledForJournalType(_ledgerJournalTrans.ledgerJournalTable().JournalType))
        {
            vendTable.copyPrimaryRegistrationNumberToVATMap(_ledgerJournalTrans, _ledgerJournalTrans.TransDate);
        }
        else
        {
            _ledgerJournalTrans.vatNumJournal = vendTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, _ledgerJournalTrans.TransDate);
        }

        _ledgerJournalTrans.EnterpriseNumber        = vendTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::UID, _ledgerJournalTrans.TransDate);

        _ledgerJournalTrans.CustVendBankAccountId   = vendTable.BankAccount;
        _ledgerJournalTrans.BankTransType           = VendPaymModeTable::find(vendTable.PaymMode).BankTransType;
        _ledgerJournalTrans.PaymMode                = vendTable.PaymMode;
        _ledgerJournalTrans.PaymSpec                = vendTable.PaymSpec;
        _ledgerJournalTrans.PaymId                  = vendTable.PaymId;
        _ledgerJournalTrans.CashDiscCode            = vendTable.CashDisc;

        _ledgerJournalTrans.SettleVoucher           = VendParameters::find().AutoSettle ? SettlementType::OpenTransact : SettlementType::None;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]))
        {
            _ledgerJournalTrans.BankCentralBankPurposeCode = vendTable.BankCentralBankPurposeCode;
            _ledgerJournalTrans.BankCentralBankPurposeText = vendTable.BankCentralBankPurposeText;
        }

        // <GIN>
        if (countryRegion_IN)
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
            taxInformationVendTableLoc = vendTable.getTaxInformationVendTable_IN();
            if  (TaxWithholdParameters_IN::find().tdsActivate
                || TaxWithholdParameters_IN::find().tcsActivate)
            {
                if (TaxWithholdParameters_IN::find().tdsActivate)
                {
                    ledgerJournalTransTaxExt.tdsGroup         = taxInformationVendTableLoc.tdsGroup;
                }
                if (TaxWithholdParameters_IN::find().tcsActivate
                    && !( _ledgerJournalTrans.AccountType == LedgerJournalACType::Project && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend))
                {
                    ledgerJournalTransTaxExt.tcsGroup         = taxInformationVendTableLoc.tcsGroup;
                }
            }

            if (TaxWithholdParameters_IN::checkTaxParameters()
                && _ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Daily)
            {
                _ledgerJournalTrans.TaxWithholdGroup    = vendTable.TaxWithholdGroup;
            }
            ledgerJournalTransTaxExt.WithIGSTPayment = TaxGSTEPZCodeHelper::construct(vendTable).isEPZCodeNotNone();
        }
        // </GIN>

        this.initFromOffsetAccount(_ledgerJournalTrans);

        if (vendTable.CashDisc)
        {
            this.calculateCashDisc(_ledgerJournalTrans);

            ledgerJournalCashDiscService.setCashDiscParameters(
                _ledgerJournalTrans.Company,
                _ledgerJournalTrans.CashDiscCode,
                _ledgerJournalTrans.Invoice,
                _ledgerJournalTrans.AccountType);
        }

        // <GEEPL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            this.initVatRegData_PL(_ledgerJournalTrans, vendTable);
        }
        // </GEEPL>

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIS]))
        {
            _ledgerJournalTrans.VendInvoiceDeclaration_IS = vendTable.VendInvoiceDeclaration_IS;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
        {
            _ledgerJournalTrans.OperationType_MX = vendTable.OperationType_MX;

            LedgerJournalTrans_W ledgerJournalTrans_W = _ledgerJournalTrans.ledgerJournalTrans_W();
            ledgerJournalTrans_W.WithholdingTypeCode_MX = vendTable.WithholdingTypeCode_MX;
            _ledgerJournalTrans.packLedgerJournalTrans_W(ledgerJournalTrans_W);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromWorker_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initiates a <c>LedgerJournalTrans</c> record with values based on employee account.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    protected void initFromWorker_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        _ledgerJournalTrans.Due          = _ledgerJournalTrans.TransDate;
        _ledgerJournalTrans.CurrencyCode = mainAccount.CurrencyCode ? mainAccount.CurrencyCode : _ledgerJournalTrans.CurrencyCode;

        this.initDefaultDimension(_ledgerJournalTrans);

        this.initEmplPostingProfile_RU(_ledgerJournalTrans);

        _ledgerJournalTrans.TaxGroup      = '';
        _ledgerJournalTrans.Tax1099Fields = 0;
        _ledgerJournalTrans.BankTransType = '';
        _ledgerJournalTrans.PaymSpec      = '';
        _ledgerJournalTrans.Payment       = '';
        _ledgerJournalTrans.PaymId        = '';
        _ledgerJournalTrans.CashDiscCode  = '';
        _ledgerJournalTrans.SettleVoucher = SettlementType::None;

        _ledgerJournalTrans.vatNumJournal = '';
        LedgerJournalTransTaxExtension taxExtension = _ledgerJournalTrans.ledgerJournalTransTaxExtension();
        taxExtension.VATNumRecId = 0;
        taxExtension.VATNumTableType = TaxExemptNumberSourceType::None;
        _ledgerJournalTrans.packExtensionTable(taxExtension);

        this.initFromOffsetAccount(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInvoiceAndDocumentForVend</Name>
				<Source><![CDATA[
    //
    //  This method is used only if the Vendor (LedgerJournalTrans.AccountNum) is changed
    //  and an Invoice number and Document date value exist on the transaction line.
    //  A dialog will ask the user if the Invoice number, Document number, and Document date values
    //  should be kept and used for the new Vendor. If the user choose not to re-use the information
    //  the data fields holding these values will be emptied.
    //
    private void initInvoiceAndDocumentForVend(LedgerJournalTrans _ledgerJournalTrans)
    {
        DialogButton    defaultButton = DialogButton::Yes;

        //  Does this transaction have an Invoice number and a Document date.
        if (ledgerJournalTrans_ds && _ledgerJournalTrans.Invoice && _ledgerJournalTrans.DocumentDate && _ledgerJournalTrans.parmLedgerDimension())
        {
            //
            //  Ask the user if they want to re-use Inoice and Document data for the new Vendor.
            //
            defaultButton = Box::yesNo(strFmt("@SYS101211",
                                                _ledgerJournalTrans.Invoice,
                                                _ledgerJournalTrans.DocumentNum,
                                                _ledgerJournalTrans.DocumentDate),
                                              defaultButton);
            switch (defaultButton)
            {
                case DialogButton::Yes:
                    break;
                default:
                    //  The user has selected not to re-use the data.
                    _ledgerJournalTrans.Invoice = "";
                    _ledgerJournalTrans.DocumentNum = "";
                    _ledgerJournalTrans.DocumentDate = dateNull();
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOffsetDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>OffsetDefaultDimension</c> field of the specified transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer that stores part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table buffer that stores part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_RAsset">
    /// The <c>LedgerJournalTrans_RAsset</c> table buffer storing part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_RDeferrals">
    /// The <c>LedgerJournalTrans_RDeferrals</c> table buffer storing part of the transaction.
    /// </param>
    public void initOffsetDefaultDimension(
        LedgerJournalTrans        _ledgerJournalTrans,
        LedgerJournalTrans_Asset  _ledgerJournalTrans_Asset = null,
        LedgerJournalTrans_RAsset _ledgerJournalTrans_RAsset = null,
        LedgerJournalTrans_RDeferrals _ledgerJournalTrans_RDeferrals = null
        )
    {
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            _ledgerJournalTrans.OffsetDefaultDimension = LedgerJournalEngine::initOffsetDefaultDimensionServer(_ledgerJournalTrans, _ledgerJournalTrans_Asset, _ledgerJournalTrans_RAsset, _ledgerJournalTrans_RDeferrals);
        }
        else
        {
            // </GEERU>
            _ledgerJournalTrans.OffsetDefaultDimension = LedgerJournalEngine::initOffsetDefaultDimensionServer(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
            this.mergeResourceDimensionDefault(_ledgerJournalTrans);
            // <GEERU>
        }
        // </GEERU>

        if (LedgerJournalEngine::canInitializeOffsetDefaultDimensions(_ledgerJournalTrans))
        {
            this.performFinTagDefaulting(_ledgerJournalTrans, AccountOffsetaccount::OffsetAccount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOffsetFromLedgerJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes offset information on the journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    protected void initOffsetFromLedgerJournalTable(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTable localLedgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();

        if (ledgerJournalTable.company() == _ledgerJournalTrans.getOffsetCompany())
        {
            // init the offset account and type from the ledger journal table
            _ledgerJournalTrans.OffsetAccountType = localLedgerJournalTable.OffsetAccountType;

            if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                // if type is ledger need to create ledger account structure by merging the main
                // account and the dimensions for the main account
                _ledgerJournalTrans.parmOffsetLedgerDimension(
                    _ledgerJournalTrans.getOffsetLedgerDimensionForLedgerType(
                        localLedgerJournalTable.parmOffsetLedgerDimension(),
                        _ledgerJournalTrans.getOffsetCompany()));
            }
            else
            {
                _ledgerJournalTrans.parmOffsetLedgerDimension(localLedgerJournalTable.parmOffsetLedgerDimension());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPaymentFeeDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>DefaultDimension</c> field of the specified transaction.
    /// </summary>
    /// <param name="_custVendPaymJournalFee">
    ///    The <c>CustVendPaymJournalFee</c> table buffer that stores the transaction.
    /// </param>
    public void initPaymentFeeDefaultDimension(CustVendPaymJournalFee _custVendPaymJournalFee)
    {
        DimensionDefault defaultDimension;
        List dimensionSources;
        LedgerJournalTrans ledgerJournalTrans;

        if (_custVendPaymJournalFee.LedgerJournalACType == LedgerJournalACType::Ledger)
        {
            _custVendPaymJournalFee.DefaultDimension = 0;
            return;
        }

        dimensionSources = new List(Types::Class);

        // The payment fee is created in the current company
        Debug::assert(_custVendPaymJournalFee.company() == curext());

        // Get the LedgerJournalTrans record for the payment fee
        select firstonly Company, JournalNum from ledgerJournalTrans
            where ledgerJournalTrans.RecId == _custVendPaymJournalFee.RefRecId;
        if (ledgerJournalTrans)
        {
            dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(ledgerJournalTrans.ledgerJournalTable().DefaultDimension));
        }

        // dimension based on account number
        dimensionSources.addEnd(
            LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(LedgerJournalEngine::getAccountDefaultDimension(_custVendPaymJournalFee.parmCustVendAccount(), _custVendPaymJournalFee.company(), _custVendPaymJournalFee.LedgerJournalACType)));

        defaultDimension = LedgerDimensionDefaultingEngine::getDefaultDimension(dimensionSources);
        _custVendPaymJournalFee.DefaultDimension = defaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRCashPostingProfile_RU</Name>
				<Source><![CDATA[
    public void initRCashPostingProfile_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::RCash)
        {
            _ledgerJournalTrans.PostingProfile = RCashParameters::find().PostingProfile;
        }
        
        this.initRCashOffsetPostingProfile_RU(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRCashOffsetPostingProfile_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the offset posting profile based on vendor parameters.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    private void initRCashOffsetPostingProfile_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::RCash)
        {
            _ledgerJournalTrans.OffsetPostingProfile_RU = RCashParameters::find().PostingProfile;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the tax group on the journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    protected void initTaxGroup(LedgerJournalTrans _ledgerJournalTrans)
    {
        //------------------------------------------------------------
        // Attempt to use the cached version of the method.
        //------------------------------------------------------------
        if (methodResultCache.contains(
            funcName(),
            // this list of inputs occurs twice in this method
            this.getCachedVersionFromLedgerJournalTrans(_ledgerJournalTrans)))
        {
            // this list of outputs occurs twice in this method
            [_ledgerJournalTrans.TaxGroup] = methodResultCache.get(funcName());

            return;
        }

        //------------------------------------------------------------
        // The result is not cached. Perform all calculations.
        //------------------------------------------------------------

        _ledgerJournalTrans.TaxGroup = '';

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
        {
            _ledgerJournalTrans.TaxGroup = this.initTaxGroupCust(_ledgerJournalTrans);
        }
        else if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
        {
            _ledgerJournalTrans.TaxGroup = this.initTaxGroupVend(_ledgerJournalTrans);
        }
        else if (_ledgerJournalTrans.isTransIntercompany(currentCompany))
        {
            /*Intercompany accounting*/
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
            {
                _ledgerJournalTrans.TaxGroup =
                    MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccount().RecId, CompanyInfo::current()).TaxGroup;

                if (!TaxGroupHeading::exist(_ledgerJournalTrans.TaxGroup))
                {
                    // We did not find the same tax group so it is blanked out.
                    _ledgerJournalTrans.TaxGroup = '';
                }
            }
        }
        else if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
        {
            _ledgerJournalTrans.TaxGroup = this.findOffsetCustTable(_ledgerJournalTrans).TaxGroup;
        }
        else if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
        {
            _ledgerJournalTrans.TaxGroup = this.findOffsetVendTable(_ledgerJournalTrans).TaxGroup;
        }
        else
        {
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
            {
                _ledgerJournalTrans.TaxGroup =
                    MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccount().RecId, CompanyInfo::current()).TaxGroup;

                if (!_ledgerJournalTrans.TaxGroup &&
                    _ledgerJournalTrans.parmOffsetLedgerDimension() &&
                    _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
                {
                    _ledgerJournalTrans.TaxGroup =
                        MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccountForOffset().RecId, CompanyInfo::current()).TaxGroup;
                }
            }
            else if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                _ledgerJournalTrans.TaxGroup =
                    MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccountForOffset().RecId, CompanyInfo::current()).TaxGroup;
            }

            if (!TaxGroupHeading::exist(_ledgerJournalTrans.TaxGroup))
            {
                // We did not find the same tax group so it is blanked out.
                _ledgerJournalTrans.TaxGroup = '';
            }
        }

        // Verify that a tax code is derived for the given Tax Group and Tax Item Group.
        if (_ledgerJournalTrans.TaxGroup && _ledgerJournalTrans.TaxItemGroup)
        {
            if (CheckTaxGroups::Error == Tax::isValidTaxGroupIntersectionV2(
                                            _ledgerJournalTrans.TaxGroup,
                                            _ledgerJournalTrans.TaxItemGroup,
                                            _ledgerJournalTrans.isTaxIntegrationEnabled()))
            {
                // In this scenario there are no dervied tax codes and the user has asked that we flag this condition as an error.
                // Due to how the journal forms display taxes through display methods it is best to not allow this field to be set to a Tax Group
                // with no over lapping Tax Codes.  The error message will let the user know what Tax Group was trying to default.
                error (strFmt("@SYS4009766", _ledgerJournalTrans.TaxGroup,_ledgerJournalTrans.TaxItemGroup));
                _ledgerJournalTrans.TaxGroup = '';
            }
        }

        if (this.shouldUpdateTaxGroup(_ledgerJournalTrans))
        {
            /*Possible that there is more than one line in the voucher*/
            if (LedgerJournalEngine_Server::updateTaxGroup(_ledgerJournalTrans))
            {
                changecompany(_ledgerJournalTrans.company())
                {
                    _ledgerJournalTrans.write();
                }

                if (ledgerJournalTrans_ds)
                {
                    ledgerJournalTrans_ds.research(true);
                }
            }
        }

        //------------------------------------------------------------
        // Attempt to cache the results.
        //------------------------------------------------------------
        if (methodResultCache.isInScope())
        {
            methodResultCache.add(
                funcName(),
                // this list of inputs occurs twice in this method
                this.getCachedVersionFromLedgerJournalTrans(_ledgerJournalTrans),
                // this list of outputs occurs twice in this method
                [_ledgerJournalTrans.TaxGroup]);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the tax group can be updated.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true if the tax group can be updated; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean shouldUpdateTaxGroup(LedgerJournalTrans _ledgerJournalTrans)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxGroupCust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes TaxGroup from customer related information.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The TaxGroup value of the customer.
    /// </returns>
    protected TaxGroup initTaxGroupCust(LedgerJournalTrans _ledgerJournalTrans)
    {
        return this.findCustTable(_ledgerJournalTrans).TaxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxGroupVend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes TaxGroup from vendor related information.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The TaxGroup value of the vendor.
    /// </returns>
    protected TaxGroup initTaxGroupVend(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxGroup localTaxGroup = _ledgerJournalTrans.findVendTable().TaxGroup;
        _ledgerJournalTrans.TaxGroup = localTaxGroup;

        //If we have a taxgroup verify it for IC transactions.
        if (localTaxGroup && _ledgerJournalTrans.isCompanyIntercompany(currentCompany))
        {
            //requirement is that the tax group found on the vendor must also exist in the current company.
            changecompany(currentCompany)
            {
                if (!TaxGroupHeading::exist(localTaxGroup))
                {
                    // We did not find the same tax group so it is blanked out.
                    _ledgerJournalTrans.TaxGroup = "";
                    warning(strFmt("@SYS344548", localTaxGroup, _ledgerJournalTrans.findVendTable().AccountNum));
                }
            }
        }

        return _ledgerJournalTrans.TaxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultEmptyTaxItemGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defaults an empty item tax group value for the given <c>LedgerJournalTrans</c> table buffer.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> table buffer.</param>
    /// <param name = "_intercompany">Value indicating whether or not the transaction is intercompany.</param>
    /// <param name = "_oldTaxItemGroup">The old item tax group value.</param>
    protected void defaultEmptyTaxItemGroup(LedgerJournalTrans _ledgerJournalTrans, boolean _intercompany, TaxGroupJournal _oldTaxItemGroup)
    {
        if (_intercompany)
        {
            /*Intercompany accounting*/
            changecompany(_ledgerJournalTrans.Company)
            {
                _ledgerJournalTrans.TaxItemGroup = TaxParameters::find().TaxItemGroup;
            }
        }
        else
        {
            _ledgerJournalTrans.TaxItemGroup = _oldTaxItemGroup ? _oldTaxItemGroup : TaxParameters::find().TaxItemGroup;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultTaxItemGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defaults the item tax group for the given <c>LedgerJournalTrans</c> table buffer.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> table buffer.</param>
    /// <param name = "_intercompany">Value indicating whether or not the transaction is intercompany.</param>
    /// <param name = "_oldTaxItemGroup">The old item tax group value.</param>
    protected void defaultTaxItemGroup(LedgerJournalTrans _ledgerJournalTrans, boolean _intercompany, TaxGroupJournal _oldTaxItemGroup)
    {
        if (_ledgerJournalTrans.TaxItemGroup &&
                (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger) &&
                !TaxItemGroupHeading::exist(_ledgerJournalTrans.TaxItemGroup))
        {
            // We did not find the same tax group so it is blanked out.
            _ledgerJournalTrans.TaxItemGroup = '';
        }

        if (!_ledgerJournalTrans.TaxItemGroup)
        {
            this.defaultEmptyTaxItemGroup(_ledgerJournalTrans, _intercompany, _oldTaxItemGroup);
        }

        // Verify that a tax code is derived for the given Tax Group and Tax Item Group.
        if (_ledgerJournalTrans.TaxGroup && _ledgerJournalTrans.TaxItemGroup)
        {
             if (CheckTaxGroups::Error == Tax::isValidTaxGroupIntersectionV2(
                                            _ledgerJournalTrans.TaxGroup,
                                            _ledgerJournalTrans.TaxItemGroup,
                                            _ledgerJournalTrans.isTaxIntegrationEnabled()))
            {
                // In this scenario there are no derived tax codes and the user has asked that we flag this condition as an error.
                // Due to how the journal forms display taxes through display methods it is best to not allow this field to be set to a Tax Item Group
                // with no over lapping Tax Codes.  The error message will let the user know what Tax Item Group was trying to default.
                error (strFmt("@SYS4009766",_ledgerJournalTrans.TaxGroup,_ledgerJournalTrans.TaxItemGroup));
                _ledgerJournalTrans.TaxItemGroup = '';
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxItemGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the tax item group on the journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTrans_Project">
    /// The <c>LedgerJournalTrans_Project</c> record; optional.
    /// </param>
    public void initTaxItemGroup(
        LedgerJournalTrans          _ledgerJournalTrans,
        LedgerJournalTrans_Project  _ledgerJournalTrans_Project = null)
    {
        boolean         interCompany = _ledgerJournalTrans.isTransIntercompany();
        TaxGroupJournal oldTaxItemGroup;
        RecId           legalEntityRecId = CompanyInfo::current();
        
        void removeAccruals()
        {
            if (_ledgerJournalTrans.modifiedFieldRemovesAccruals(fieldNum(LedgerJournalTrans, TaxItemGroup)))
            {
                _ledgerJournalTrans.removeAccruals();
            }
        }

        #localmacro.methodResults
            // A list of results generated by the method.
            _ledgerJournalTrans.TaxItemGroup
        #endmacro

        //------------------------------------------------------------
        // Attempt to use the cached version of the method.
        //------------------------------------------------------------
        if (methodResultCache.contains(funcName(), this.getCachedVersionFromLedgerJournalTrans(_ledgerJournalTrans)))
        {
            // The pertinent inputs have not changed, therfore we can skip the execution of this method.
            [#methodResults] = methodResultCache.get(funcName());

            removeAccruals();

            return;
        }

        //------------------------------------------------------------
        // The method is not cached. Perform all calculations.
        //------------------------------------------------------------

        oldTaxItemGroup = _ledgerJournalTrans.TaxItemGroup;
        _ledgerJournalTrans.TaxItemGroup = '';

        if (_ledgerJournalTrans.Prepayment)
        {
            /*If the prepayment field is marked, then is it also requeried that the
              custparameter "tax on prepayment" is marked.*/

              // <GEERU>

              if (CustParameters::find().TaxOnPrepayment
                || (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
                && VendParameters::find().TaxOnPrepayment))
                // </GEERU>
            {
                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
                {
                    _ledgerJournalTrans.TaxItemGroup = MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccount().RecId,
                                                                                                            legalEntityRecId).TaxItemGroup;
                }
                else if (_ledgerJournalTrans.parmOffsetLedgerDimension() &&
                         _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger && !interCompany)
                {
                    _ledgerJournalTrans.TaxItemGroup = MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccountForOffset().RecId,
                                                                                                            legalEntityRecId).TaxItemGroup;
                }
                this.defaultTaxItemGroup(_ledgerJournalTrans, interCompany, oldTaxItemGroup);
            }
        }
        else if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
                 _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend ||
                 (_ledgerJournalTrans.parmOffsetLedgerDimension() &&
                  (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust ||
                   _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)))
        {
            /*If there is a Customer or a Vendor on the journalline then must there also be an invoicenumber
            on the line to get the taxitemgroup automatic filled in.*/
            if (_ledgerJournalTrans.Invoice)
            {
                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger &&
                    !MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccount().RecId, legalEntityRecId).TaxFree)
                {
                    _ledgerJournalTrans.TaxItemGroup = MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccount().RecId,
                                                                                                            legalEntityRecId).TaxItemGroup;
                    this.defaultTaxItemGroup(_ledgerJournalTrans, interCompany, oldTaxItemGroup);
                }
                else if (_ledgerJournalTrans.parmOffsetLedgerDimension() &&
                         _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger &&
                         !MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccountForOffset().RecId, legalEntityRecId).TaxFree)
                {
                    if (!interCompany)
                    {
                        _ledgerJournalTrans.TaxItemGroup = MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccountForOffset().RecId,
                                                                                                                legalEntityRecId).TaxItemGroup;
                    }
                    this.defaultTaxItemGroup(_ledgerJournalTrans, interCompany, oldTaxItemGroup);
                }
                else if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project ||
                         _ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets ||
                        (_ledgerJournalTrans.parmOffsetLedgerDimension() && (
                         _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets ||
                         _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)))
                {
                    this.defaultTaxItemGroup(_ledgerJournalTrans, interCompany, oldTaxItemGroup);
                }
            }
            else
            {
                if ((_ledgerJournalTrans.AccountType == LedgerJournalACType::Project) ||
                    (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project))

                {
                    this.defaultTaxItemGroup(_ledgerJournalTrans, interCompany, oldTaxItemGroup);
                }
            }
        }
        else if (_ledgerJournalTrans.parmLedgerDimension() &&
                 _ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger )
        {
            if (!MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccount().RecId, legalEntityRecId).TaxFree)
            {
                _ledgerJournalTrans.TaxItemGroup = MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccount().RecId,
                                                                                                        legalEntityRecId).TaxItemGroup;

                if (!_ledgerJournalTrans.TaxItemGroup &&
                    _ledgerJournalTrans.parmOffsetLedgerDimension() &&
                    _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
                {
                    if (!MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccountForOffset().RecId, legalEntityRecId).TaxFree)
                    {
                        if (!interCompany)
                        {
                            _ledgerJournalTrans.TaxItemGroup = MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccountForOffset().RecId,
                                                                                                                    legalEntityRecId).TaxItemGroup;
                        }
                        this.defaultTaxItemGroup(_ledgerJournalTrans, interCompany, oldTaxItemGroup);
                    }
                }
                else
                {
                    this.defaultTaxItemGroup(_ledgerJournalTrans, interCompany, oldTaxItemGroup);
                }
            }
        }
        else if (_ledgerJournalTrans.parmOffsetLedgerDimension() &&
                 _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
        {
            if (!MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccountForOffset().RecId, legalEntityRecId).TaxFree)
            {
                if (!interCompany)
                {
                    _ledgerJournalTrans.TaxItemGroup = MainAccountLegalEntity::findByMainAccountLegalEntity(_ledgerJournalTrans.findMainAccountForOffset().RecId,
                                                                                                            legalEntityRecId).TaxItemGroup;
                }
                this.defaultTaxItemGroup(_ledgerJournalTrans, interCompany, oldTaxItemGroup);
            }
        }
        else if (_ledgerJournalTrans.AccountType         == LedgerJournalACType::Project ||
                 _ledgerJournalTrans.AccountType         == LedgerJournalACType::FixedAssets ||
                (_ledgerJournalTrans.parmOffsetLedgerDimension() && (
                 _ledgerJournalTrans.OffsetAccountType   == LedgerJournalACType::FixedAssets ||
                 _ledgerJournalTrans.OffsetAccountType   == LedgerJournalACType::Project)))
        {
            this.defaultTaxItemGroup(_ledgerJournalTrans, interCompany, oldTaxItemGroup);
        }

        removeAccruals();

        //------------------------------------------------------------
        // Attempt to cache the method.
        //------------------------------------------------------------
        if (methodResultCache.isInScope())
        {
            methodResultCache.add(funcName(),
                                  this.getCachedVersionFromLedgerJournalTrans(_ledgerJournalTrans),
                                  [#methodResults]);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTrans_Asset">
    /// The <c>LedgerJournalTrans_Asset</c> record; optional.
    /// </param>
    public void initValue(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans_Asset _ledgerJournalTrans_Asset = null)
    {
        UnknownNoYes      triangulationResult;
        ExchRateSecondTxt exchRateSecondTxt,reportingExchRateSecondTxt;
        LedgerJournalTransTaxExtension ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtension();

        if (!ledgerJournalName)
        {
            ledgerJournalName  =  LedgerJournalName::find(ledgerJournalTable.JournalName);
        }

        if (!ledgerJournalTable)
        {
            throw error("@SYS26538");
        }
        else
        {
            if (!ledgerJournalTable.Posted && !ledgerJournalTable.Approver)
            {
                _ledgerJournalTrans.JournalNum = ledgerJournalTable.JournalNum;
                ledgerJournalTransTaxExt.OverrideSalesTax = ledgerJournalTable.OverrideSalesTax;

                // <GEELT>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLT]))
                {
                    _ledgerJournalTrans.initFromLedgerJournalTable_LT(ledgerJournalTable);
                }
                // </GEELT>

                if (this.newVoucher(_ledgerJournalTrans))
                {
                    voucherTotalDebit   = 0;
                    voucherTotalCredit  = 0;
                    voucherTotalBalance = 0;

                    voucherTotalDebitReportingCurrency   = 0;
                    voucherTotalCreditReportingCurrency  = 0;
                    voucherTotalBalanceReportingCurrency = 0;

                    _ledgerJournalTrans.ReverseEntry = ledgerJournalTable.ReverseEntry;
                    _ledgerJournalTrans.ReverseDate = ledgerJournalTable.ReverseDate;

                    if (!initValueCalled)
                    {
                        if (ledgerJournalName.VoucherAllocatedAtPosting == NoYes::No &&
                            ledgerJournalName.NumberSequenceTable       != ledgerJournalTable.NumberSequenceTable)
                        {
                            error("@SYS59006");
                        }
                        else
                        {
                            _ledgerJournalTrans.TransDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                            newVoucherNum               = true;
                            curVoucher                  = _ledgerJournalTrans.Voucher;
                            voucherFetched              = curVoucher;
                            voucherFetchedInJournalNum  = ledgerJournalTable.JournalNum;
                        }
                    }
                    else
                    {
                        _ledgerJournalTrans.Voucher    = voucherFetched;
                        _ledgerJournalTrans.TransDate  = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    }

                    // <GEERU>
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                    {
                        if (oldTransDate)
                        {
                            _ledgerJournalTrans.TransDate = oldTransDate;
                        }
                        this.setTransDate_RU(_ledgerJournalTrans);
                    }
                    // </GEERU>
                }
                else
                {
                    if (ledgerJournalName.NewVoucher != NewVoucher::Manually)
                    {
                        _ledgerJournalTrans.Voucher         = oldVoucher;
                        _ledgerJournalTrans.TransDate       = oldTransDate ? oldTransDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                        _ledgerJournalTrans.ReverseDate     = oldRevDate;
                        _ledgerJournalTrans.ReverseEntry    = oldRevEntry;
                        _ledgerJournalTrans.Txt             = oldTransTxt;

                        if (oldCurrencyCode)
                        {
                            _ledgerJournalTrans.CurrencyCode = oldCurrencyCode;
                        }

                        if (oldReleaseDate != utcDateTimeNull())
                        {
                            _ledgerJournalTrans.ReleaseDate = oldReleaseDate;
                        }
                    }
                    else
                    {
                        _ledgerJournalTrans.TransDate  = oldTransDate  ? oldTransDate  : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

                        if (oldVoucher)
                        {
                            _ledgerJournalTrans.Voucher = oldVoucher;
                        }

                        if (oldCurrencyCode)
                        {
                            _ledgerJournalTrans.CurrencyCode = oldCurrencyCode;
                        }

                        if (oldTransTxt)
                        {
                            _ledgerJournalTrans.Txt = oldTransTxt;
                        }

                        if (oldReleaseDate != utcDateTimeNull())
                        {
                            _ledgerJournalTrans.ReleaseDate = oldReleaseDate;
                        }
                    }
                }

                // <GEERU>
                if (oldTransDate && !SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                // </GEERU>
                {
                    _ledgerJournalTrans.TransDate = oldTransDate;
                }
                if (oldReleaseDate != utcDateTimeNull())
                {
                    _ledgerJournalTrans.ReleaseDate = oldReleaseDate;
                }

                this.initValueSetOldValues(_ledgerJournalTrans);

                if (ledgerJournalTable.JournalType  == LedgerJournalType::Daily                     ||
                    ledgerJournalTable.JournalType  == LedgerJournalType::Payment                   ||
                    ledgerJournalTable.JournalType  == LedgerJournalType::PayrollDisbursement       ||
                    ledgerJournalTable.JournalType  == LedgerJournalType::CustPayment               ||
                    ledgerJournalTable.JournalType  == LedgerJournalType::Netting                   ||
                    ledgerJournalTable.JournalType  == LedgerJournalType::Periodic                  ||
                    LedgerJournalName::isNegotiableInstrumentJournal(ledgerJournalTable.JournalType))
                {
                    _ledgerJournalTrans.markAsApprovedByCurrentUser();
                }

                _ledgerJournalTrans.setOffsetLedgerDimension(ledgerJournalTable,
                     _ledgerJournalTrans.OffsetAccountType,
                     _ledgerJournalTrans.parmOffsetLedgerDimension());

                _ledgerJournalTrans.DocumentNum = ledgerJournalTable.DocumentNum;

                if (ledgerJournalTable.CurrencyCode)
                {
                    _ledgerJournalTrans.CurrencyCode  = ledgerJournalTable.CurrencyCode;
                }

                if (ledgerJournalTable.CurrencyCode && ledgerJournalTable.FixedExchRate)
                {
                    _ledgerJournalTrans.ExchRate        = ledgerJournalTable.ExchRate;
                    _ledgerJournalTrans.ExchRateSecond  = ledgerJournalTable.ExchrateSecondary;
                    _ledgerJournalTrans.Triangulation   = ledgerJournalTable.euroTriangulation;
                }
                else
                {
                    [triangulationResult,
                    _ledgerJournalTrans.ExchRate,
                    _ledgerJournalTrans.ExchRateSecond,
                    exchRateSecondTxt] = LedgerJournalEngine_Server::currencyModified(_ledgerJournalTrans);
                    _ledgerJournalTrans.Triangulation = Currency::unknownNoYes2Noyes(triangulationResult);
                }

                if (ledgerJournalTable.CurrencyCode && ledgerJournalTable.ReportingCurrencyFixedExchRate)
                {
                    _ledgerJournalTrans.ReportingCurrencyExchRate = ledgerJournalTable.ReportingCurrencyExchRate;
                    _ledgerJournalTrans.ReportingCurrencyExchRateSecondary  = ledgerJournalTable.ReportingCurrencyExchRateSecondary;
                }
                else
                {
                    [_ledgerJournalTrans.ReportingCurrencyExchRate,
                    _ledgerJournalTrans.ReportingCurrencyExchRateSecondary,
                        reportingExchRateSecondTxt] = LedgerJournalEngine_Server::reportingCurrencyModified(_ledgerJournalTrans);
                }

                _ledgerJournalTrans_Asset.TransType = AssetTransTypeJournal::Acquisition;
                _ledgerJournalTrans.setSettleVoucher();
                _ledgerJournalTrans.AcknowledgementDate = _ledgerJournalTrans.TransDate;

                // <GEEU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
                {
                    _ledgerJournalTrans.vatData_copyLine_PL();
                }
                // </GEEU>

                if (postingResults_Server != null)
                {
                    postingResults_Server.clearErrorLog();
                }

                _ledgerJournalTrans.packExtensionTable(ledgerJournalTransTaxExt);
            }

            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                this.setFactureAutoCreate(_ledgerJournalTrans, AccountOffsetaccount::Account);
                this.setFactureAutoCreate(_ledgerJournalTrans, AccountOffsetaccount::OffsetAccount);
            }
            // </GEERU>
            // <GCN>
            if (LedgerParameters::isChineseVoucher_CN())
            {
                if (LedgerJournalTrans::existVoucher(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher))
                {
                    _ledgerJournalTrans.LedgerVoucherType_CN = ledgerVoucherTypeRecId;
                    _ledgerJournalTrans.Voucher_CN = oldVoucher_CN;

                    if (ledgerJournalTable.JournalType == LedgerJournalType::Daily
                    && oldAttachment)
                    {
                        _ledgerJournalTrans.Attachments_CN = oldAttachment;
                    }
                }
                else
                {
                    _ledgerJournalTrans.LedgerVoucherType_CN = ledgerVoucherTypeRecId;
                    this.voucherTypeUpdate_CN(_ledgerJournalTrans);
                    if (ledgerJournalTable.JournalType == LedgerJournalType::Daily
                    && oldAttachment)
                    {
                        _ledgerJournalTrans.Attachments_CN = oldAttachment;
                    }
                }
            }
            // </GCN>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValueSetOldValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the old value of Transaction date, Reversing date, Reversing entry, Release date from <c>LedgerJournalTrans</c> table buffer.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    protected void initValueSetOldValues(LedgerJournalTrans _ledgerJournalTrans)
    {
        oldTransDate = _ledgerJournalTrans.TransDate;
        oldRevDate   = _ledgerJournalTrans.ReverseDate;
        oldRevEntry  = _ledgerJournalTrans.ReverseEntry;
        oldReleaseDate = _ledgerJournalTrans.ReleaseDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValueAsset</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the default values of the specified transaction for fixed asset fields when a record is
    ///    created
    /// </summary>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table buffer that stores part of the transaction.
    /// </param>
    public void initValueAsset(LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#IsoHU, #IsoCZ])
            && AssetParameters::find().AllowPreAcquisition_CZ != AssetAllowPreAcquisition_CZ::No)
        {
            _ledgerJournalTrans_Asset.TransType = AssetTransTypeJournal::Preacquisition_CZ;
        }
        else
        {
            _ledgerJournalTrans_Asset.TransType = AssetTransTypeJournal::Acquisition;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVatRegData_PL</Name>
				<Source><![CDATA[
    protected void initVatRegData_PL(LedgerJournalTrans _ledgerJournalTrans, CustVendTable _custVendTable)
    {
        _ledgerJournalTrans.TaxPeriodPaymentCode_PL = _custVendTable.TaxPeriodPaymentCode_PL;
        _ledgerJournalTrans.vatNumJournal           = _custVendTable.CustVendTable::getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, _ledgerJournalTrans.TransDate);
        _custVendTable.CustVendTable::copyPrimaryRegistrationNumberToVATMap(_ledgerJournalTrans, _ledgerJournalTrans.TransDate);
        _ledgerJournalTrans.Addressing_PL           = DirParty::getAddress(_custVendTable.Party);
        _ledgerJournalTrans.CustVendName_PL         = _custVendTable.name();
        _ledgerJournalTrans.CustVendAccount_PL      = '';

        this.allowEditVatRegister_PL(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVendPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the posting profile based on vendor parameters.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    public void initVendPostingProfile(LedgerJournalTrans _ledgerJournalTrans)
    {
        // <GEERU>
        PurchAgreementHeaderExt_RU purchAgreementHeaderExt;

        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU
           // <GEEU>
           , #isoPL, #isoCZ, #isoHU, #isoLT, #isoLV, #isoEE
           // </GEEU>
           ]))
        {
            // </GEERU>
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                if (_ledgerJournalTrans.Prepayment)
                {
                    _ledgerJournalTrans.PostingProfile = VendParameters::find().PrepaymentPostingProfile;
                    if (!_ledgerJournalTrans.PostingProfile)
                    {
                        _ledgerJournalTrans.PostingProfile = VendParameters::find().PostingProfile;
                    }
                }
                else
                {
                    _ledgerJournalTrans.PostingProfile = VendParameters::find().PostingProfile;
                }
            }
            // <GEERU>
        }
        else
        {
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                purchAgreementHeaderExt = this.findAgreementHeaderExt_RU(_ledgerJournalTrans) as PurchAgreementHeaderExt_RU;

                if (_ledgerJournalTrans.Prepayment)
                {
                    if (purchAgreementHeaderExt.VendPrepaymentPostingProfile)
                    {
                        _ledgerJournalTrans.PostingProfile = purchAgreementHeaderExt.VendPrepaymentPostingProfile;
                    }
                    else
                    {
                        _ledgerJournalTrans.PostingProfile = VendParameters::find().PrepaymentPostingProfile;
                    }

                    _ledgerJournalTrans.TaxGroup     = VendParameters::find().TaxGroup_W;
                    _ledgerJournalTrans.TaxItemGroup = VendParameters::find().TaxItemGroup_W;
                }

                if (! _ledgerJournalTrans.Prepayment || ! _ledgerJournalTrans.PostingProfile)
                {
                    if (purchAgreementHeaderExt.VendPostingProfile)
                    {
                        _ledgerJournalTrans.PostingProfile = purchAgreementHeaderExt.VendPostingProfile;
                    }
                    else
                    {
                        _ledgerJournalTrans.PostingProfile = VendParameters::find().PostingProfile;
                    }
                }
            }

            this.initVendOffsetPostingProfile(_ledgerJournalTrans);

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
                (_ledgerJournalTrans.AccountType      == LedgerJournalACType::Vend ||
                _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)  &&
                    _ledgerJournalTrans.SettleVoucher != SettlementType::SelectedTransact)
            {
                if (_ledgerJournalTrans.Prepayment)
                {
                    _ledgerJournalTrans.SettleVoucher = SettlementType::None;
                }
                else
                {
                    _ledgerJournalTrans.SettleVoucher = VendParameters::find().AutoSettle ?
                                                        SettlementType::OpenTransact :
                                                        SettlementType::None;
                }
            }

            if (_ledgerJournalTrans.AccountType != LedgerJournalACType::Cust    &&
                _ledgerJournalTrans.AccountType != LedgerJournalACType::Vend    &&
                _ledgerJournalTrans.AccountType != LedgerJournalACType::RCash   &&
                _ledgerJournalTrans.AccountType != LedgerJournalACType::Employee_RU)
            {
                _ledgerJournalTrans.PostingProfile = '';
            }

            this.refreshDataSource(_ledgerJournalTrans);
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVendOffsetPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the offset posting profile based on vendor parameters.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    private void initVendOffsetPostingProfile(LedgerJournalTrans _ledgerJournalTrans)
    {
        PurchAgreementHeaderExt_RU purchAgreementHeaderExt;

        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
        {
            purchAgreementHeaderExt = this.findAgreementHeaderExt_RU(_ledgerJournalTrans, AccountOffsetaccount::OffsetAccount) as PurchAgreementHeaderExt_RU;

            if (_ledgerJournalTrans.Prepayment)
            {
                if (purchAgreementHeaderExt.VendPrepaymentPostingProfile)
                {
                    _ledgerJournalTrans.OffsetPostingProfile_RU = purchAgreementHeaderExt.VendPrepaymentPostingProfile;
                }
                else
                {
                    _ledgerJournalTrans.OffsetPostingProfile_RU = VendParameters::find().PrepaymentPostingProfile;
                }
            }
            if (! _ledgerJournalTrans.Prepayment || ! _ledgerJournalTrans.OffsetPostingProfile_RU)
            {
                if (purchAgreementHeaderExt.VendPostingProfile)
                {
                    _ledgerJournalTrans.OffsetPostingProfile_RU = purchAgreementHeaderExt.VendPostingProfile;
                }
                else
                {
                    _ledgerJournalTrans.OffsetPostingProfile_RU = VendParameters::find().PostingProfile;
                }
            }
        }

        if (_ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Cust      &&
                    _ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Vend      &&
                    _ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::RCash     &&
                    _ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Employee_RU)

        {
            _ledgerJournalTrans.OffsetPostingProfile_RU = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts a <c>LedgerJournalTrans</c> table records and optionally <c>LedgerJournalTrans_Project</c>
    ///    fields in response to a change in the <c>LedgerJournalTrans</c> Invoice value.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table record being modified.
    /// </param>
    /// <param name="_ledgerJournalTransProj">
    ///    The <c>LedgerJournalTrans_Project</c> table record being modified; optional.
    /// </param>
    public void invoiceModified(LedgerJournalTrans _ledgerJournalTrans,
                                LedgerJournalTrans_Project _ledgerJournalTransProj = null)
    {
        // <GIN>
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt;
        // </GIN>

        if (_ledgerJournalTrans.RecId)
        {
            if (_ledgerJournalTrans.orig().Invoice == '')
            {
                this.initTaxItemGroup(_ledgerJournalTrans, _ledgerJournalTransProj);
            }
        }
        else
        {
            if (!_ledgerJournalTrans.TaxItemGroup)
            {
                this.initTaxItemGroup(_ledgerJournalTrans, _ledgerJournalTransProj);
            }
        }
        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
        }

        if (TaxWithholdParameters_IN::checkTaxParameters()
            && ledgerJournalTransTaxExt.TaxWithholdCode)
        {
            ledgerJournalTransTaxExt.TaxWithholdCode = '';
        }
        // </GIN>

        this.setCashRegisterTerminal_W(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalBalanceMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the journal balance amounts.
    /// </summary>
    /// <returns>
    /// A container with the journal balance amounts.
    /// </returns>
    public container journalBalanceMST()
    {
        return [journalTotalDebit, journalTotalCredit, journalTotalOffsetBalance];
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalCredit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the total amount of the journals credit column.
    /// </summary>
    /// <returns>
    ///    The total credit amount of the journal credit column.
    /// </returns>
    public AmountMST journalCredit()
    {
        return journalTotalCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalDebit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the total amount of the journal debit column.
    /// </summary>
    /// <returns>
    ///    The total amount of the journal debit column.
    /// </returns>
    public AmountMST journalDebit()
    {
        return journalTotalDebit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalCreditReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total amount of the journals credit column in reporting currency.
    /// </summary>
    /// <returns>
    /// The total credit amount of the journal credit column in reporting currency.
    /// </returns>
    public AmountMSTSecondary journalCreditReportingCurrency()
    {
        return journalTotalCreditReportingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalDebitReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total amount of the journal debit column in reporting currency.
    /// </summary>
    /// <returns>
    /// The total amount of the journal debit column in reporting currency.
    /// </returns>
    public AmountMSTSecondary journalDebitReportingCurrency()
    {
        return journalTotalDebitReportingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalOffsetBalance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the balance of this account for the current journal if the journal has a fixed offset account.
    /// </summary>
    /// <returns>
    ///    The balance amount in MST or currency.
    /// </returns>
    public AmountCur journalOffsetBalance()
    {
        return journalTotalOffsetBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the internal buffer for the <c>LedgerJournalTable</c>. Also sets the internal record buffer for <c>LedgerJournalName</c>.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    ///    A <c>LedgerJournalTable</c> record buffer.
    /// </param>
    /// <returns>
    ///    The internal <c>LedgerJournalTable</c> record buffer.
    /// </returns>
    public LedgerJournalTable ledgerJournalTable(LedgerJournalTable _ledgerJournalTable = ledgerJournalTable)
    {
        ledgerJournalTable = _ledgerJournalTable;
        ledgerJournalName  =  LedgerJournalName::find(ledgerJournalTable.JournalName);
        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalTableUpdateTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the journal balance amounts.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    /// <param name = "_recalc">
    /// Determines if balances should be updated; optional.
    /// </param>
    public void ledgerJournalTableUpdateTotals(LedgerJournalTable _ledgerJournalTable,
                                               boolean            _recalc = true)
    {
        if (_recalc)
        {
            [journalTotalDebit,
             journalTotalCredit,
             journalTotalOffsetBalance,
             journalTotalDebitReportingCurrency,
             journalTotalCreditReportingCurrency] = ledgerJournalEngine_Server.initBalances(_ledgerJournalTable.JournalNum, true);
        }

        if (ledgerJournalTable)
        {
            ledgerJournalTable.reread();

            ttsbegin;

            ledgerJournalTable.selectForUpdate(true);
            ledgerJournalTable.JournalTotalDebit            = journalTotalDebit;
            ledgerJournalTable.JournalTotalCredit           = journalTotalCredit;
            ledgerJournalTable.JournalTotalOffsetBalance    = journalTotalOffsetBalance;
            ledgerJournalTable.update();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lock</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the locked variable to true.
    /// </summary>
    public void lock()
    {
        locked = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markApproved</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the journal as approved.
    /// </summary>
    public void markApproved()
    {
        LedgerJournalTable  ledgerJournalTableCopy;
        boolean             approved;

        // <GCN>
        if ((ledgerJournalTable.JournalType == LedgerJournalType::Daily
            || ledgerJournalTable.JournalType == LedgerJournalType::Assets)
            && LedgerParameters::isJournalApproval_CN())
        {
            ledgerJournalTable.markApproved();
        }
        else
        {
            // </GCN>
            ttsbegin;

            select firstonly forupdate ledgerJournalTableCopy
                where ledgerJournalTableCopy.JournalNum == ledgerJournalTable.JournalNum;

            approved = ledgerJournalTableCopy.markApproved();

            if (approved)
            {
                ledgerJournalTableCopy.update();
                ledgerJournalTable.markApproved();
            }
            ttscommit;

            //<GCN>
        }
        //</GCN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>markRejected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the journal as rejected.
    /// </summary>
    public void markRejected()
    {
        LedgerJournalTable  ledgerJournalTableCopy;

        ttsbegin;

        select firstonly forupdate ledgerJournalTableCopy
            where ledgerJournalTableCopy.JournalNum == ledgerJournalTable.JournalNum;

        ledgerJournalTableCopy.markRejected();
        ledgerJournalTableCopy.update();
        ledgerJournalTable.markRejected();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markReportAsReady</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the journal as ready.
    /// </summary>
    public void markReportAsReady()
    {
        LedgerJournalTable  ledgerJournalTableCopy;

        ttsbegin;

        select firstonly forupdate ledgerJournalTableCopy
            where ledgerJournalTableCopy.JournalNum == ledgerJournalTable.JournalNum;

        ledgerJournalTableCopy.markReportAsReady();
        ledgerJournalTableCopy.update();
        ledgerJournalTable.markReportAsReady();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupCodeLookup_RU</Name>
				<Source><![CDATA[
    public boolean markupCodeLookup_RU(FormStringControl _formStringControl)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupCodeModified_RU</Name>
				<Source><![CDATA[
    public void markupCodeModified_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>maximumRoundingDifferenceInAccountingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the maximum rounding difference amount in accounting currency.
    /// </summary>
    /// <param name = "_ledgerParameters">The <c>LedgerParameters</c> table record to determine the default value.</param>
    /// <param name = "_ledgerJournalId">The journal number to provide journal level override; optional.</param>
    /// <returns>The maximum rounding difference amount threshold for accounting currency.</returns>
    /// <remarks>
    /// Extension point for chain of command.
    /// </remarks>
    protected AmountMST maximumRoundingDifferenceInAccountingCurrency(LedgerParameters _ledgerParameters, LedgerJournalId _ledgerJournalId = '')
    {
        return _ledgerParameters.MaxRoundingDifferenceMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayCurrencyBeModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the exchange rate of the journal line may be modified.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <returns>
    ///    true if the exchange rate may be modified; otherwise, false.
    /// </returns>
    public boolean mayCurrencyBeModified(LedgerJournalTrans _ledgerJournalTrans)
    {
        return ExchangeRateHelper::isExchangeRate1Editable_Static(
            Ledger::primaryLedger(CompanyInfo::findDataArea(_ledgerJournalTrans.Company).RecId),
            _ledgerJournalTrans.CurrencyCode,
            _ledgerJournalTrans.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>maySecondaryCurrencyBeModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the secondary exchange rate of the journal line may be modified.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <returns>
    /// true if the secondary exchange rate may be modified; otherwise, false.
    /// </returns>
    public boolean maySecondaryCurrencyBeModified(LedgerJournalTrans _ledgerJournalTrans)
    {
        return ExchangeRateHelper::isExchangeRate2Editable_Static(
            Ledger::primaryLedger(CompanyInfo::findDataArea(_ledgerJournalTrans.Company).RecId),
            _ledgerJournalTrans.CurrencyCode,
            _ledgerJournalTrans.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeResourceDimensionDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Merges the default dimension for the journal line with resource default dimension.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>ledgerJournalTrans</c> table that contains <c>DefaultDimension</c> property.
    /// </param>
    private void mergeResourceDimensionDefault(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (ledgerJournalTrans_Project.Resource)
        {
            _ledgerJournalTrans.DefaultDimension
                = _ledgerJournalTrans.mergeDimension(ResourceFacade::getDefaultDimension(ledgerJournalTrans_Project.Resource));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveCachedBudgetCheckResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves the cached budget check result associated with the old voucher to the new voucher.
    /// </summary>
    /// <param name="_oldVoucher">
    /// The old voucher for budget check result in the cache.
    /// </param>
    /// <param name="_newVoucher">
    /// The new voucher for budget check result in the cache.
    /// </param>
    /// <returns>
    /// true if the budget check result for the specified old voucher is found in the cache and moved to
    /// the new voucher; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Nothing is performed if the old voucher is not found in the cache.
    /// </remarks>
    protected boolean moveCachedBudgetCheckResult(Voucher _oldVoucher, Voucher _newVoucher)
    {
        boolean isVoucherMoved = false;
        BudgetCheckResult voucherBudgetCheckResult;

        if (voucherBudgetCheckResults.exists(_oldVoucher))
        {
            voucherBudgetCheckResult = voucherBudgetCheckResults.lookup(_oldVoucher);
            voucherBudgetCheckResults.remove(_oldVoucher);
            voucherBudgetCheckResults.insert(_newVoucher, voucherBudgetCheckResult);
            isVoucherMoved = true;
        }

        return isVoucherMoved;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needInitCashRegisterTerminal_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the necessity of initialization of cash register terminal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The buffer of the <c>LedgerJournalTrans</c> table.
    /// </param>
    /// <returns>
    /// True if terminal need to be initialized; false, otherwise.
    /// </returns>
    public boolean needInitCashRegisterTerminal_W(LedgerJournalTrans _ledgerJournalTrans)
    {
        return CashRegisterProcessingBase::isEnabledLedgerJournal(_ledgerJournalTrans)
            || (PaymTerm::isCashAccount(_ledgerJournalTrans.Payment)
            && CashRegisterPaymMode_W::existsPaymMode(_ledgerJournalTrans.PaymMode));
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsolete for public use and has been replaced with the static construct method.', false, 31\01\2016)]
    void new(FormRun _formRun = null)
    {
        // <GEERU>
        boolean countryRegion_RU    = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        // <GEERU><GEEU>
        boolean isCashModuleEnabled = RCashParameters::isCashModuleEnabled();
        // </GEERU></GEEU>

        if (_formRun)
        {
            ledgerJournalTrans_ds = _formRun.dataSource();
        }

        voucherBudgetCheckResults = new Map(Types::String, Types::Integer);
        postingResults_Server = LedgerJournalCheckPostResults::newServer();

        voucherBudgetCheckResults = new Map(Types::String, Types::Integer);

        methodResultCache = LedgerMethodResultCache::construct();

        vendTableList            = new RecordSortedList(vendTable.TableId);
        custTableList            = new RecordSortedList(custTable.TableId);
        paymentList              = new RecordSortedList(payment.TableId);
        bankAccountTableList     = new RecordSortedList(bankAccountTable.TableId);
        ledgerJournalTxtList     = new RecordSortedList(ledgerJournalTxt.TableId);
        projTableList            = new RecordSortedList(projTable.TableId);
        assetTableList           = new RecordSortedList(assetTable.TableId);

        // support multi-company
        cashDiscList = new Map(Types::String, Types::Class);
        exchangeRateTexts = new Map(Types::Container, Types::String);

        taxAmountDisplay          = SysTmpRecIdMap::construct(Types::Real);
        taxAmountDisplayCalc      = SysTmpRecIdMap::construct(Types::Integer);
        correctedTaxAmount        = SysTmpRecIdMap::construct(Types::Real);
        correctedTaxAmountDisplay = SysTmpRecIdMap::construct(Types::Integer);
        cashDiscDirty             = SysTmpRecIdMap::construct(Types::Integer);

        // <GEERU>
        if (countryRegion_RU)
        {
            rDeferralsTableList      = new RecordSortedList(rDeferralsTable.TableId);
        }
        // </GEERU>
        // <GEERU><GEEU>
        if (isCashModuleEnabled)
        {
            rAssetTableList          = new RecordSortedList(rAssetTable.TableId);
            rCashTableList           = new RecordSortedList(rCashTable.TableId);
        }
        // </GEERU></GEEU>

        vendTableList.sortOrder(fieldNum(VendTable, AccountNum));
        custTableList.sortOrder(fieldNum(CustTable, AccountNum));
        paymentList.sortOrder(fieldNum(PaymTerm, PaymTermId));
        bankAccountTableList.sortOrder(fieldNum(BankAccountTable, AccountID));
        ledgerJournalTxtList.sortOrder(fieldNum(LedgerJournalTxt, Id));
        projTableList.sortOrder(fieldNum(ProjTable, ProjId));
        assetTableList.sortOrder(fieldNum(AssetTable, AssetId));

        // <GEERU>
        if (countryRegion_RU)
        {
            rDeferralsTableList.sortOrder(fieldNum(RDeferralsTable, DeferralsId));
        }
        // </GEERU>
        // <GEERU><GEEU>
        if (isCashModuleEnabled)
        {
            rAssetTableList.sortOrder(fieldNum(RAssetTable, AccountNum));
            rCashTableList.sortOrder(fieldNum(RCashTable, AccountNum));
        }
        // </GEERU></GEEU>

        currentCompany  =  curext();
        companyCurrency = CompanyInfoHelper::standardCurrency();

        // <GEERU><GEEU>
        if (isCashModuleEnabled)
        {
            childFormsMap_W = new Map(Types::Integer, Types::Class);
        }
        // </GEERU></GEEU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>newJournalActive</Name>
				<Source><![CDATA[
    /// <summary>
    /// A new journal is the active record.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    /// <param name = "_recalc">
    /// Determines if balances and totals should be updated; optional.
    /// </param>
    void newJournalActive(LedgerJournalTable _ledgerJournalTable, boolean _recalc = false)
    {
        boolean allowEdit;

        ledgerJournalTable  = _ledgerJournalTable;
        ledgerJournalName   =  LedgerJournalName::find(ledgerJournalTable.JournalName);

        voucherBalance = new RecordSortedList(tableNum(TmpVoucherSum));
        voucherBalance.sortOrder(fieldNum(TmpVoucherSum, Voucher));

        custVendCashDiscList = new RecordSortedList(tableNum(CustVendTransOpen));
        custVendCashDiscList.sortOrder(fieldNum(CustVendTransOpen, RefRecId));

        voucherDateCorrect  = ['@@',NoYes::No];

        ledgerJournalEngine_Server = LedgerJournalEngine_Server::construct();

        boolean recalculateJournalTotals = _recalc;

        // If the journal is unposted and the LedgerJournalTable fields JournalTotalDebit or JournalTotalCredit
        // have been populated, force recalculation of the journal totals.
        if (!ledgerJournalTable.Posted &&
            (ledgerJournalTable.JournalTotalDebit || ledgerJournalTable.JournalTotalCredit))
        {
            recalculateJournalTotals = true;
        }

        if (!recalculateJournalTotals &&
            (ledgerJournalTable.JournalTotalDebit || ledgerJournalTable.JournalTotalCredit))
        {
            [journalTotalDebit,
             journalTotalCredit,
             journalTotalOffsetBalance,
             journalTotalDebitReportingCurrency,
             journalTotalCreditReportingCurrency] = ledgerJournalEngine_Server.initBalances(_ledgerJournalTable.JournalNum, false);
                
            journalTotalDebit   = ledgerJournalTable.JournalTotalDebit;
            journalTotalCredit  = ledgerJournalTable.JournalTotalCredit;
            journalTotalBalance = journalTotalDebit - journalTotalCredit;
            journalTotalDebitReportingCurrency   = ledgerJournalTable.JournalTotalDebitReportingCurrency;
            journalTotalCreditReportingCurrency  = ledgerJournalTable.JournalTotalCreditReportingCurrency;
            journalTotalBalanceReportingCurrency = journalTotalDebitReportingCurrency - journalTotalCreditReportingCurrency;
        }
        else
        {
            [journalTotalDebit,
             journalTotalCredit,
             journalTotalOffsetBalance,
             journalTotalDebitReportingCurrency,
             journalTotalCreditReportingCurrency] = ledgerJournalEngine_Server.initBalances(_ledgerJournalTable.JournalNum, true);
        }

        if (postingResults_Server != null)
        {
            postingResults_Server.clearErrorLog();
        }

        if (ledgerJournalTrans_ds)  // work around for callback from form.close() to LedgerJournalTable.active()
        {
            allowEdit = this.allowEdit();
            ledgerJournalTrans_ds.allowCreate(allowEdit);   // This must be placed here as creation of records are purely determined by the journal status
            if (allowEdit)
            {
                allowEdit = this.allowEditTrans(ledgerJournalTrans_ds.cursor());
            }
            ledgerJournalTrans_ds.allowEdit(allowEdit);     // This must be placed here as edition of the record is a combined check of the journal and the journal line itself
            ledgerJournalTrans_ds.allowDelete(allowEdit);   // This must be placed here as edition of the record is a combined check of the journal and the journal line itself
            oldVoucher = '';
            oldAccountNum = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newVoucher</Name>
				<Source><![CDATA[
    protected boolean newVoucher(LedgerJournalTrans   _ledgerJournalTrans)
    {
        boolean newVoucher;

        if (ledgerJournalTrans_ds)
        {
            newVoucher = this.numberSeqFormHandlerJournal().newVoucher();
        }
        else
        {
            newVoucher = this.takeNewVoucher();
            if (newVoucher)
            {
                _ledgerJournalTrans.Voucher = new JournalVoucherNum(JournalTableData::newTable(ledgerJournalTable)).getNew(false);
            }
        }

        return newVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSeqFormHandlerJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the <c>NumberSeqFormhandlerObject</c> of the <c>LedgerJournalEngine</c> object.
    /// </summary>
    /// <returns>
    ///    A <c>NumberSeqFormHandler</c> object.
    /// </returns>
    /// <remarks>
    ///    If not already initialized, the <c>NumberSeqFormHandler</c> object is initialized by this method.
    /// </remarks>
    public NumberSeqFormHandlerLedgerJournal numberSeqFormHandlerJournal()
    {
        if (!numberSeqFormHandlerJournal)
        {
            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                numberSeqFormHandlerJournal = NumberSeqFormHandler::newForm(ledgerJournalTable.NumberSequenceTable,
                                                                            ledgerJournalTrans_ds ? ledgerJournalTrans_ds.formRun() : null, // system bug correction
                                                                            ledgerJournalTrans_ds,
                                                                            fieldNum(LedgerJournalTrans, Voucher));
            }
            else
            {
                // </GEERU>
                numberSeqFormHandlerJournal = NumberSeqFormHandler::newForm(ledgerJournalTable.NumberSequenceTable,
                                                                        ledgerJournalTrans_ds.formRun(),
                                                                        ledgerJournalTrans_ds,
                                                                        fieldNum(LedgerJournalTrans, Voucher));
                // <GEERU>
            }
            // </GEERU>

            numberSeqFormHandlerJournal.parmLedgerJournalEngine(this);
        }
        return numberSeqFormHandlerJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccountModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts <c>LedgerJournalTrans</c> and optionally <c>LedgerJournalTrans_Project</c> fields in
    ///    response to a change in the <c>LedgerJournalTrans</c><c>OffsetAccount</c> value.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table record being modified.
    /// </param>
    /// <param name="_ledgerJournalTrans_Project">
    ///    The <c>LedgerJournalTrans_Project</c> table record being modified; optional.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table record being modified; optional.
    /// </param>
    /// <param name="_ledgerJournalTrans_RAsset">
    /// The optional <c>LedgerJournalTrans_RAsset</c> table record being modified;.
    /// </param>
    /// <param name="_ledgerJournalTrans_RDeferrals">
    /// The optional <c>LedgerJournalTrans_RDeferrals</c> table record being modified.
    /// </param>
    /// <remarks>
    ///    This method should be called from the <c>modified</c> method in the <c>OffsetAccount</c> field of
    ///    the <c>LedgerJournalTrans</c> form data source. If there is no <c>LedgerJournalTrans_Project</c> or
    ///    <c>LedgerJournalTrans_Asset</c> data source on the form, null may be passed in.
    /// </remarks>
    public void offsetAccountModified(LedgerJournalTrans _ledgerJournalTrans,
                                      LedgerJournalTrans_Project _ledgerJournalTrans_Project = null,
                                      LedgerJournalTrans_Asset _ledgerJournalTrans_Asset = null,
                                      LedgerJournalTrans_RAsset _ledgerJournalTrans_RAsset = null,
                                      LedgerJournalTrans_RDeferrals _ledgerJournalTrans_RDeferrals = null
                                      )
    {
        // <GIN>
        TransTaxInformation transTaxInformation;
        TaxInformationVendTable_IN taxInformationVendTable_IN;
        TaxInformationCustTable_IN taxInformationCustTable_IN;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtensionIN;
        // </GIN>
        // Store the fact that the user has set the offset account on the currently selected record.
        isOffsetAcctSetByUserSinceLastDataEvent = true;

        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
        {
            _ledgerJournalTrans.setDefaultAccount(true, _ledgerJournalTrans.parmOffsetAccount());
            _ledgerJournalTrans.validateW9Received(false, AccountOffsetaccount::OffsetAccount);

            if (_ledgerJournalTrans.AccountType != LedgerJournalACType::Vend && _ledgerJournalTrans.TransactionType != LedgerTransType::Payment)
            {
                _ledgerJournalTrans.Tax1099Fields = this.findOffsetVendTable(_ledgerJournalTrans).Tax1099Fields;
            }

            // <GIN>
            if (TaxWithholdParameters_IN::checkTaxParameters())
            {
                transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_ledgerJournalTrans);
                if (transTaxInformation)
                {
                    taxInformationVendTable_IN = VendTable::find(_ledgerJournalTrans.parmOffsetAccount()).getTaxInformationVendTable_IN();
                    ttsbegin;
                    transTaxInformation.selectForUpdate(true);
                    transTaxInformation.ApplyGSTTDS = taxInformationVendTable_IN.ApplyGSTTDS;
                    transTaxInformation.ApplyGSTTCS = taxInformationVendTable_IN.ApplyGSTTCS;
                    transTaxInformation.TaxWithholdSoftwareDeclReceived = NoYes::No;
                    transTaxInformation.update();
                    ttscommit;
                }
            }
            // </GIN>
        }

        // <GIN>
        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust && TaxWithholdParameters_IN::checkTaxParameters())
        {
            transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_ledgerJournalTrans, true);
            if (transTaxInformation)
            {
                taxInformationCustTable_IN = CustTable::find(_ledgerJournalTrans.parmOffsetAccount()).getTaxInformationCustTable_IN();
                if (taxInformationCustTable_IN.CustomerType == CustomerType_IN::GovtCompanyOrOtherAgencies)
                {
                    transTaxInformation.ApplyGSTTDS = NoYes::Yes;
                    transTaxInformation.ApplyGSTTCS = NoYes::No;
                }
                else if (taxInformationCustTable_IN.CustomerType == CustomerType_IN::ECommerceOperator)
                {
                    transTaxInformation.ApplyGSTTDS = NoYes::No;
                    transTaxInformation.ApplyGSTTCS = NoYes::Yes;
                }
                else
                {
                    transTaxInformation.ApplyGSTTDS = NoYes::No;
                    transTaxInformation.ApplyGSTTCS = NoYes::No;
                }
                ttsbegin;
                transTaxInformation.update();
                ttscommit;
            }
        }
        // </GIN>

        if (_ledgerJournalTrans.isFixedAssetsTransaction())
        {
            // This is a fixed assets transaction so synchronize the asset id, and company id; default the
            // book id if necessary.
            _ledgerJournalTrans_Asset.AssetId = _ledgerJournalTrans.getAssetId();
            _ledgerJournalTrans_Asset.Company = _ledgerJournalTrans.getAssetCompany();
            this.defaultBookIdForFATransaction(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
        }
        else
        {
            // This is not a fixed assets transaction so clear out the company, asset id and book id fields.
            _ledgerJournalTrans_Asset.AssetId = "";
            _ledgerJournalTrans_Asset.Company = "";
            _ledgerJournalTrans_Asset.BookId  = "";
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.initOffsetDefaultDimension(_ledgerJournalTrans, _ledgerJournalTrans_Asset, _ledgerJournalTrans_RAsset, _ledgerJournalTrans_RDeferrals);
        }
        else
        {
            // </GEERU>
            this.initOffsetDefaultDimension(_ledgerJournalTrans,_ledgerJournalTrans_Asset);
            // <GEERU>
        }
        // </GEERU>

        this.initTaxItemGroup(_ledgerJournalTrans, _ledgerJournalTrans_Project);
        _ledgerJournalTrans.setSettleVoucher();

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)) && _ledgerJournalTrans.isProjectTransaction())
        {
            _ledgerJournalTrans_Project.setPayWhenPaid(_ledgerJournalTrans);
            this.setProjTransDate(_ledgerJournalTrans, _ledgerJournalTrans_Project);

            // This code is added to set the default values for the _ledgerJournalTrans_Project
            this.setDefaultValuesForProjTrans(_ledgerJournalTrans, _ledgerJournalTrans_Project);
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
        {
            if (_ledgerJournalTrans.AccountType != LedgerJournalACType::Vend)
            {
                this.populateOpTypeDependingOnAccType_MX(_ledgerJournalTrans);
            }
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            _ledgerJournalTrans.setAgreementEmptyValues_RU(AccountOffsetaccount::OffsetAccount);
        }
        // </GEERU>

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoPL, #isoCZ, #isoHU, #isoLT, #isoLV, #isoEE]))
        {
            switch (_ledgerJournalTrans.OffsetAccountType)
            {
                case LedgerJournalACType::Cust :
                    this.initCustOffsetPostingProfile(_ledgerJournalTrans);
                    break;

                case LedgerJournalACType::Vend :
                    this.initVendOffsetPostingProfile(_ledgerJournalTrans);
                    break;

                case LedgerJournalACType::RCash :
                    this.initRCashOffsetPostingProfile_RU(_ledgerJournalTrans);
                    break;

                case LedgerJournalACType::Employee_RU :
                    this.initEmplOffsetPostingProfile_RU(_ledgerJournalTrans);
                    break;
                default :
                    _ledgerJournalTrans.OffsetPostingProfile_RU = '';
                    break;
            }
        }

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            switch (_ledgerJournalTrans.OffsetAccountType)
            {
                case LedgerJournalACType::Cust :
                    taxInformationCustTable_IN = CustTable::find(_ledgerJournalTrans.parmOffsetAccount()).getTaxInformationCustTable_IN();
                    ledgerJournalTransTaxExtensionIN = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
                    ledgerJournalTransTaxExtensionIN.TDSGroup = taxInformationCustTable_IN.TDSGroup;
                    ledgerJournalTransTaxExtensionIN.TCSGroup = taxInformationCustTable_IN.TCSGroup;
                    _ledgerJournalTrans.packExtensionTable(ledgerJournalTransTaxExtensionIN);
                    break;

                case LedgerJournalACType::Vend :
                    taxInformationVendTable_IN = VendTable::find(_ledgerJournalTrans.parmOffsetAccount()).getTaxInformationVendTable_IN();
                    ledgerJournalTransTaxExtensionIN = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
                    ledgerJournalTransTaxExtensionIN.TDSGroup = taxInformationVendTable_IN.TDSGroup;
                    ledgerJournalTransTaxExtensionIN.TCSGroup = taxInformationVendTable_IN.TCSGroup;
                    _ledgerJournalTrans.packExtensionTable(ledgerJournalTransTaxExtensionIN);
                    break;
                default :
                    break;
            }
        }
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            switch (_ledgerJournalTrans.OffsetAccountType)
            {
                case LedgerJournalACType::Cust :
                    ledgerJournalTransTaxExtensionIN = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
                    ledgerJournalTransTaxExtensionIN.WithIGSTPayment = TaxGSTEPZCodeHelper::construct(_ledgerJournalTrans.findCustForOffset()).isEPZCodeNotNone();
                    ledgerJournalTransTaxExtensionIN.WouldYouClaimRefund = ledgerJournalTransTaxExtensionIN.WithIGSTPayment;
                    _ledgerJournalTrans.packExtensionTable(ledgerJournalTransTaxExtensionIN);
                    break;

                case LedgerJournalACType::Vend :
                    ledgerJournalTransTaxExtensionIN = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
                    ledgerJournalTransTaxExtensionIN.WithIGSTPayment = TaxGSTEPZCodeHelper::construct(_ledgerJournalTrans.findVendForOffset()).isEPZCodeNotNone();
                    _ledgerJournalTrans.packExtensionTable(ledgerJournalTransTaxExtensionIN);
                    break;
                default :
                    break;
            }
        }
        // </GIN>
        this.setCashRegisterTerminal_W(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccountNumCheckUseCustomLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether the offset account uses a custom lookup.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_accountType">
    /// The primary account type; optional.
    /// </param>
    /// <returns>
    /// A value that indicates whether the offset account uses a custom lookup.
    /// </returns>
    /// <remarks>
    /// The return value of this method must be consistent with the return value of the
    /// <c>offsetAccountNumLookUp</c> method.
    /// </remarks>
    public boolean offsetAccountNumCheckUseCustomLookup(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalACType _accountType = _ledgerJournalTrans.AccountType)
    {
        // When the primary account type is vendor and the offset account type is non-ledger,
        // we need to look up default vendor accounts for the chosen offset account type.
        boolean useCustomLookup = (_accountType == LedgerJournalACType::Vend)
            && (_ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Ledger)
            && (VendDefaultAccounts::existDefaultForType(_ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.OffsetAccountType, _ledgerJournalTrans.OffsetCompany));

        if (!useCustomLookup)
        {
            useCustomLookup = _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank
                || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust
                || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets
                || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project
                // <GEERU>
                || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Employee_RU
                || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets_RU
                || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::RCash
                || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::RDeferrals
                // </GEERU>
                || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend;
        }

        return useCustomLookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccountNumLookUp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the custom lookup for the offset account.
    /// </summary>
    /// <param name = "_formControl">
    /// The control with the lookup.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_accountType">
    /// The primary account type; optional.
    /// </param>
    /// <returns>
    /// A value that indicates whether the offset account uses a custom lookup.
    /// </returns>
    /// <remarks>
    /// The return value of this method must be consistent with the return value of the
    /// <c>offsetAccountNumCheckUseCustomLookup</c> method.
    /// </remarks>
    public boolean offsetAccountNumLookUp(
        FormControl           _formControl,
        LedgerJournalTrans    _ledgerJournalTrans,
        LedgerJournalACType   _accountType = _ledgerJournalTrans.AccountType)
    {
        boolean useCustomLookup = true;

        // When the primary account type is vendor and the offset account type is non-ledger,
        // we need to look up default vendor accounts for the chosen offset account type.
        if ((_accountType == LedgerJournalACType::Vend)
            && (_ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Ledger)
            && VendDefaultAccounts::existDefaultForType(_ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.OffsetAccountType, _ledgerJournalTrans.OffsetCompany))
        {
            VendTable::lookupNonLedgerDefaultAccountNum(
                _formControl,
                _ledgerJournalTrans.OffsetAccountType,
                _ledgerJournalTrans.OffsetCompany,
                _ledgerJournalTrans.parmAccount());
        }
        else
        {
            useCustomLookup = false;
        }

        if (!useCustomLookup)
        {
            useCustomLookup = true;

            switch (_ledgerJournalTrans.OffsetAccountType)
            {
                case LedgerJournalACType::Bank:
                    BankAccountTable::lookupBankAccount(_formControl, _ledgerJournalTrans.OffsetCompany);
                    break;

                case LedgerJournalACType::Cust:
                    CustTable::lookupCustomer(_formControl, _ledgerJournalTrans.OffsetCompany);
                    break;

                case LedgerJournalACType::FixedAssets:
                    AssetTable::lookupAccountNum(_formControl, _ledgerJournalTrans.OffsetCompany);
                    break;

                case LedgerJournalACType::Project:
                    ProjTable::lookupProjId(_formControl, _ledgerJournalTrans);
                    break;

                // <GEERU>
                case LedgerJournalACType::Employee_RU:
                    EmployeeTable_RU::lookupAdvHolder(_formControl, _ledgerJournalTrans.OffsetCompany);
                    break;

                case LedgerJournalACType::FixedAssets_RU:
                    RAssetTable::lookupAccountNum(_formControl,_ledgerJournalTrans.OffsetCompany);
                    break;

                case LedgerJournalACType::RCash :
                    RCashTable::lookupAccountNum(_formControl, _ledgerJournalTrans.OffsetCompany);
                    break;

                case LedgerJournalACType::RDeferrals:
                    RDeferralsTable::lookupDeferrals(
                        _formControl,
                        _ledgerJournalTrans.TransDate ? _ledgerJournalTrans.TransDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                        _ledgerJournalTrans.OffsetCompany);
                    break;
                // </GEERU>

                case LedgerJournalACType::Vend:
                    VendTable::lookupVendor(_formControl, _ledgerJournalTrans.OffsetCompany);
                    break;

                default:
                    useCustomLookup = false;
                    break;
            }
        }

        return useCustomLookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccountTypeModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts a <c>LedgerJournalTrans</c> table record and optionally <c>LedgerJournalTrans_Project</c>
    ///    fields in response to a change in the <c>OffsetAccountType</c> value.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table record being modified.
    /// </param>
    /// <param name="_ledgerJournalTrans_Project">
    ///    The <c>LedgerJournalTrans_Project</c> table record being modified; optional.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The optional <c>LedgerJournalTrans_Asset</c> table record being modified; optional.
    /// </param>
    /// <param name="_ledgerJournalTrans_RCash">
    /// The optional <c>LedgerJournalTrans_RCash</c> table record being modified.
    /// </param>
    /// <remarks>
    ///    This method should be called from the <c>modified</c> method in the <c>OffsetAccountType</c> field
    ///    of the <c>LedgerJournalTrans</c> form data source. If there is no <c>LedgerJournalTrans_Project</c>
    ///    or <c>LedgerJournalTrans_Asset</c> data source on the form, null may be passed in.
    /// </remarks>
    public void offsetAccountTypeModified(LedgerJournalTrans _ledgerJournalTrans,
                                            LedgerJournalTrans_Project _ledgerJournalTrans_Project = null,
                                            LedgerJournalTrans_Asset _ledgerJournalTrans_Asset = null
                                            ,LedgerJournalTrans_RCash _ledgerJournalTrans_RCash = null
                                            )
    {
        _ledgerJournalTrans.parmOffsetLedgerDimension(0);

        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
        {
            this.setProjTransDate(_ledgerJournalTrans, _ledgerJournalTrans_Project);
            this.setProjAmount(_ledgerJournalTrans, _ledgerJournalTrans_Project);
        }
        else if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
        {
            _ledgerJournalTrans.BankDepositVoucher = false;
        }

        if (_ledgerJournalTrans.isFixedAssetsTransaction())
        {
            // This is a fixed assets transaction so synchronize the asset id, and company id; default the
            // book id if necessary.
            _ledgerJournalTrans_Asset.AssetId = _ledgerJournalTrans.getAssetId();
            _ledgerJournalTrans_Asset.Company = _ledgerJournalTrans.getAssetCompany();
            this.defaultBookIdForFATransaction(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
        }
        else
        {
            // This is not a fixed assets transaction so clear out the asset and book id fields.
            _ledgerJournalTrans_Asset.AssetId = "";
            _ledgerJournalTrans_Asset.BookId  = "";
        }

        _ledgerJournalTrans.setSettleVoucher();
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            _ledgerJournalTrans.setAgreementEmptyValues_RU(AccountOffsetaccount::OffsetAccount);
            this.setFactureAutoCreate(_ledgerJournalTrans, AccountOffsetaccount::OffsetAccount);
        }
        // </GEERU>
        // <GEERU><GEEU>
        if (RCashParameters::isCashModuleEnabled())
        {
            this.setRCashDocType_RU(_ledgerJournalTrans, _ledgerJournalTrans_RCash);
        }
        // </GEERU></GEEU>

        this.setCashRegisterTerminal_W(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetCompanyModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles form modified events for the <c>LedgerJournalTrans.OffsetCompany</c> field.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The active <c>LedgerJournalTrans</c> buffer of the form.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The active <c>LedgerJournalTrans_Asset</c> buffer of the form.
    /// </param>
    public void offsetCompanyModified(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        this.handleCompanyChangeForFixedAssets(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
        this.handleCompanyChangeForFinTag(_ledgerJournalTrans, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>onSegmentChangedForOffsetAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs updates when the offset account is changed.
    /// </summary>
    /// <param name="_offsetSegmentedEntryControl">
    /// The segmented entry control.
    /// </param>
    /// <param name="_dimensionControlSegment">
    /// The segment that was changed.
    /// </param>
    /// <param name="_currentMainAccountId">
    /// The record ID of the current main account.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The record ID of the new main account.
    /// </returns>
    /// <remarks>
    /// This method performs defaulting for ledger account types and is a no-op for non-ledger
    /// account types.
    /// The defaulting for non-ledger account types is handled by the field modified method in the
    /// data source because this method is only invoked when typing into the segmented entry
    /// control for non-ledger account types which means it would not handle all cases, including
    /// the lookup case.
    /// </remarks>
    public RecId onSegmentChangedForOffsetAccount(
        SegmentedEntryControl           _offsetSegmentedEntryControl,
        DimensionControlSegment         _dimensionControlSegment,
        MainAccountRecId                _currentMainAccountId,
        LedgerJournalTrans              _ledgerJournalTrans)
    {
        MainAccountRecId updatedMainAccountId = _currentMainAccountId;

        changecompany(_offsetSegmentedEntryControl.parmDataAreaId())
        {
            // note: everything in this method is done in the context of the offset company
            if (_dimensionControlSegment.parmDimensionAttribute().RecId == DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount))
            {
                MainAccountRecId mainAccountId = _dimensionControlSegment.parmDimensionAttributeValue().EntityInstance;
                if ((mainAccountId != 0) && (_currentMainAccountId != mainAccountId))
                {
                    updatedMainAccountId = mainAccountId;
                    Map primaryDimensionSpecifiers = null;
                    boolean isInterCompany = _ledgerJournalTrans.Company != _ledgerJournalTrans.OffsetCompany;

                    if (isInterCompany)
                    {
                        boolean useDimFromInterCompanyJournalName = false;

                        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
                        {
                            useDimFromInterCompanyJournalName = true;
                        }
                        else
                        {
                            if (_ledgerJournalTrans.OffsetCompany == _ledgerJournalTrans.company())
                            {
                                if (_ledgerJournalTrans.ledgerJournalTable().DefaultDimension)
                                {
                                    // Use the header default dimensions because the offset is the header company
                                    primaryDimensionSpecifiers = LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(_ledgerJournalTrans.ledgerJournalTable().DefaultDimension);
                                }
                            }
                            else
                            {
                                useDimFromInterCompanyJournalName = true;
                            }
                        }

                        if (useDimFromInterCompanyJournalName)
                        {
                            // The offset is in a different company, so get the defaults defined in the intercompany posting for that company
                            // We are already working in the context of the data area defined in the control
                            LedgerInterCompany ledgerInterCompanyRecord = LedgerInterCompany::findCompanyPair(curExt(), _ledgerJournalTrans.Company);
                            DimensionDefault journalHeaderDefaultDimensions = LedgerJournalName::find(ledgerInterCompanyRecord.JournalName).DefaultDimension;
                            primaryDimensionSpecifiers = LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(journalHeaderDefaultDimensions);
                        }
                    }
                    else
                    {
                        // Do a direct transfer of the dimension values because the primary and offset companies are the same
                        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger && _ledgerJournalTrans.LedgerDimension != 0)
                        {
                            primaryDimensionSpecifiers = LedgerDimensionDefaultingEngine::getLedgerDimensionSpecifiers(_ledgerJournalTrans.LedgerDimension, true);
                        }
                        else if (_ledgerJournalTrans.DefaultDimension != 0)
                        {
                            primaryDimensionSpecifiers = LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(_ledgerJournalTrans.DefaultDimension);
                        }
                    }

                    //Merge with defaults defined in on the MainAccount for the current company
                    Map dimensionSpecifiers = this.addMainAccountDimensionValues(mainAccountId, primaryDimensionSpecifiers, _offsetSegmentedEntryControl,
                                        _dimensionControlSegment, _currentMainAccountId, _ledgerJournalTrans);
                    if (this.doesDimensionSpecifiersExist(dimensionSpecifiers, _offsetSegmentedEntryControl,
                                        _dimensionControlSegment, _currentMainAccountId, _ledgerJournalTrans))
                    {
                        this.setDimensionSpecifiers(dimensionSpecifiers, _offsetSegmentedEntryControl,
                                            _dimensionControlSegment, _currentMainAccountId, _ledgerJournalTrans, false);
                    }

                    this.performFinTagDefaulting(_ledgerJournalTrans, AccountOffsetaccount::OffsetAccount);
                }
                else if (mainAccountId == 0)
                {
                    updatedMainAccountId = 0;
                }
            }
        }

        return updatedMainAccountId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultOffsetFinTagFromPrimaryAccount</Name>
				<Source><![CDATA[
    private void defaultOffsetFinTagFromPrimaryAccount(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_ledgerJournalTrans.Company == _ledgerJournalTrans.OffsetCompany && !_ledgerJournalTrans.OffsetFinTag)
        {
            _ledgerJournalTrans.OffsetFinTag = _ledgerJournalTrans.FinTag;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultPrimaryFinTagFromJournalHeader</Name>
				<Source><![CDATA[
    private void defaultPrimaryFinTagFromJournalHeader(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTable ledgerJournalTableLocal = _ledgerJournalTrans.ledgerJournalTable();
        if (_ledgerJournalTrans.Company == ledgerJournalTableLocal.company() && !_ledgerJournalTrans.FinTag)
        {
            _ledgerJournalTrans.FinTag = ledgerJournalTableLocal.FinTag;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>performFinTagDefaulting</Name>
				<Source><![CDATA[
    internal void performFinTagDefaulting(LedgerJournalTrans _ledgerJournalTrans, AccountOffsetAccount _accountOffsetAccount)
    {
        if (_accountOffsetAccount == AccountOffsetAccount::Account)
        {
            if (FinTagConfiguration::isFinTagConfigurationSet(_ledgerJournalTrans.Company))
            {
                this.defaultPrimaryFinTagFromJournalHeader(_ledgerJournalTrans);
            }
        }
        else if (_accountOffsetAccount == AccountOffsetAccount::OffsetAccount)
        {
            if (FinTagConfiguration::isFinTagConfigurationSet(_ledgerJournalTrans.getOffsetCompany()))
            {
                LedgerJournalTable ledgerJournalTableLocal = _ledgerJournalTrans.ledgerJournalTable();
                boolean isPrimaryCompanySameAsTable = _ledgerJournalTrans.Company == ledgerJournalTableLocal.company();
                boolean isOffsetCompanySameAsTable = _ledgerJournalTrans.OffsetCompany == ledgerJournalTableLocal.company();

                if (!isPrimaryCompanySameAsTable && isOffsetCompanySameAsTable)
                {
                    // Only default the offset from the table in the very specific scenario
                    // when the primary company is not the same as the table, but the offset company is the same.
                    if (!_ledgerJournalTrans.OffsetFinTag)
                    {
                        _ledgerJournalTrans.OffsetFinTag = ledgerJournalTableLocal.FinTag;
                    }
                }
                else
                {
                    this.defaultOffsetFinTagFromPrimaryAccount(_ledgerJournalTrans);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesDimensionSpecifiersExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the dimension specifier exists or not.
    /// </summary>
    /// <param name = "_dimensionSpecifiers">
    /// The map containing dimension specifiers value.
    /// </param>
    /// <param name = "_offsetSegmentedEntryControl">
    /// The segmented entry control.
    /// </param>
    /// <param name = "_dimensionControlSegment">
    /// The segment that was changed.
    /// </param>
    /// <param name = "_currentMainAccountId">
    /// The record ID of the current main account.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// Returns true if the dimension specifier exist; otherwise, false.
    /// </returns>
    [Hookable(true)]
    protected final boolean doesDimensionSpecifiersExist(
        Map _dimensionSpecifiers,
        SegmentedEntryControl _offsetSegmentedEntryControl,
        DimensionControlSegment _dimensionControlSegment,
        MainAccountRecId _currentMainAccountId,
        LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_dimensionSpecifiers == null)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDimensionSpecifiers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the current dimension values depending on the specified values.
    /// </summary>
    /// <param name = "_dimensionSpecifiers">
    /// The collection of dimension specifiers that represent the values.
    /// </param>
    /// <param name = "_overwriteValues">
    /// A boolean value that indicates whether to overwrite existing non-empty values; optional.
    /// </param>
    /// <param name = "_offsetSegmentedEntryControl">
    /// The segmented entry control.
    /// </param>
    /// <param name = "_dimensionControlSegment">
    /// The segment that was changed.
    /// </param>
    /// <param name = "_currentMainAccountId">
    /// The record ID of the current main account.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    [Hookable(true)]
    protected final void setDimensionSpecifiers(
        Map _dimensionSpecifiers,
        SegmentedEntryControl _offsetSegmentedEntryControl,
        DimensionControlSegment _dimensionControlSegment,
        MainAccountRecId _currentMainAccountId,
        LedgerJournalTrans _ledgerJournalTrans,
        boolean _overwriteValues = false)
    {
        _offsetSegmentedEntryControl.setDimensionSpecifiers(_dimensionSpecifiers, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>onSegmentChangedForPrimaryAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs updates when the primary account is changed.
    /// </summary>
    /// <param name="_segmentedEntryControl">
    /// The segmented entry control.
    /// </param>
    /// <param name="_dimensionControlSegment">
    /// The segment that was changed.
    /// </param>
    /// <param name="_currentMainAccountId">
    /// The record ID of the current main account.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The record ID of the new main account.
    /// </returns>
    /// <remarks>
    /// This method performs defaulting for ledger account types and is a no-op for non-ledger
    /// account types.
    /// The defaulting for non-ledger account types is handled by the field modified method in the
    /// data source because this method is only invoked when typing into the segmented entry
    /// control for non-ledger account types which means it would not handle all cases, including
    /// the lookup case.
    /// </remarks>
    public RecId onSegmentChangedForPrimaryAccount(
        SegmentedEntryControl           _segmentedEntryControl,
        DimensionControlSegment         _dimensionControlSegment,
        RecId                           _currentMainAccountId,
        LedgerJournalTrans              _ledgerJournalTrans)
    {
        RecId                           updatedMainAccountId;
        RecId                           mainAccountId;
        LedgerJournalTable              ledgerJournalTableLocal;
        Map                             headerDimensionSpecifiers;
        Map                             dimensionSpecifiers;

        updatedMainAccountId = _currentMainAccountId;
        changecompany(_segmentedEntryControl.parmDataAreaId())
        {
            if (_dimensionControlSegment.parmDimensionAttribute().RecId == DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount))
            {
                mainAccountId = _dimensionControlSegment.parmDimensionAttributeValue().EntityInstance;
                if ((mainAccountId != 0) && (_currentMainAccountId != mainAccountId))
                {
                    updatedMainAccountId = mainAccountId;
                    headerDimensionSpecifiers = null;

                    ledgerJournalTableLocal = _ledgerJournalTrans.ledgerJournalTable();
                    if (_ledgerJournalTrans.Company == ledgerJournalTableLocal.company())
                    {
                        if (ledgerJournalTableLocal.DefaultDimension != 0)
                        {
                            headerDimensionSpecifiers = LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(ledgerJournalTableLocal.DefaultDimension);
                        }

                        this.performFinTagDefaulting(_ledgerJournalTrans, AccountOffsetaccount::Account);
                    }
                    else if (_ledgerJournalTrans.Company != ledgerJournalTableLocal.company())
                    {
                        LedgerInterCompany ledgerInterCompanyRecord = LedgerInterCompany::findCompanyPair(_ledgerJournalTrans.Company, ledgerJournalTableLocal.Company());
                        DimensionDefault journalHeaderDefaultDimensions = ledgerJournalName::find(ledgerInterCompanyRecord.JournalName).DefaultDimension;
                        headerDimensionSpecifiers = LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(journalHeaderDefaultDimensions);
                    }

                    dimensionSpecifiers = this.addMainAccountDimensionValues(mainAccountId, headerDimensionSpecifiers, _segmentedEntryControl,
                                        _dimensionControlSegment, _currentMainAccountId, _ledgerJournalTrans);
                    if (this.doesDimensionSpecifiersExist(dimensionSpecifiers, _segmentedEntryControl,
                                        _dimensionControlSegment, _currentMainAccountId, _ledgerJournalTrans))
                    {
                        this.setDimensionSpecifiers(dimensionSpecifiers, _segmentedEntryControl,
                                            _dimensionControlSegment, _currentMainAccountId, _ledgerJournalTrans, false);
                    }
                }
                else if (mainAccountId == 0)
                {
                    updatedMainAccountId = 0;
                }
            }
        }

        return updatedMainAccountId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openAccountFinancialDimensionForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the specified menu item with the journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "menuItemType">
    /// The <c>MenuItemType</c> enumeration value.
    /// </param>
    /// <param name = "displayMenuItemStr">
    /// The name of the menu item.
    /// </param>
    public void openAccountFinancialDimensionForm(LedgerJournalTrans _ledgerJournalTrans, MenuItemType menuItemType, str displayMenuItemStr)
    {
        FormRun formRun;
        MenuFunction menuFunction;
        Args args;

        // Launch the Dimension form modally, this form will change the default dimension field on the record
        menuFunction = new MenuFunction(displayMenuItemStr, menuItemType);
        args = new Args();
        args.record(_ledgerJournalTrans);
        formRun = menuFunction.create(args);
        formRun.run();
        formRun.wait(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>openOffsetAccountFinancialDimensionForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the specified menu item with the journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "menuItemType">
    /// The <c>MenuItemType</c> enumeration value.
    /// </param>
    /// <param name = "displayMenuItemStr">
    /// The name of the menu item.
    /// </param>
    public void openOffsetAccountFinancialDimensionForm(LedgerJournalTrans _ledgerJournalTrans, MenuItemType menuItemType, str displayMenuItemStr)
    {
        FormRun formRun;
        MenuFunction menuFunction;
        Args args;

        // Launch the Dimension form modally
        menuFunction = new MenuFunction(displayMenuItemStr, menuItemType);
        args = new Args();
        args.record(_ledgerJournalTrans);
        formRun = menuFunction.create(args);
        formRun.run();
        formRun.wait(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>openPaymFeeAccountFinancialDimensionForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the specified menu item with the <c>_custVendPaymJournalFee</c> record.
    /// </summary>
    /// <param name = "_custVendPaymJournalFee">
    /// The <c>CustVendPaymJournalFee</c> record.
    /// </param>
    /// <param name = "menuItemType">
    /// The <c>MenuItemType</c> enumeration value.
    /// </param>
    /// <param name = "displayMenuItemStr">
    /// The name of the menu item.
    /// </param>
    public void openPaymFeeAccountFinancialDimensionForm(CustVendPaymJournalFee _custVendPaymJournalFee, MenuItemType menuItemType, str displayMenuItemStr)
    {
        FormRun formRun;
        MenuFunction menuFunction;
        Args args;

        // Launch the Dimension form modally
        menuFunction = new MenuFunction(displayMenuItemStr, menuItemType);
        args = new Args();
        args.record(_custVendPaymJournalFee);
        formRun = menuFunction.create(args);
        formRun.run();
        formRun.wait(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymJournalFeeOpenLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the custom lookup for the payment journal fee account.
    /// </summary>
    /// <param name = "_formControl">
    /// The form control.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_custVendPaymJournalFee">
    /// The <c>CustVendPaymJournalFee</c> record.
    /// </param>
    /// <returns>
    /// A value that indicates whether the payment journal fee account uses a custom lookup.
    /// </returns>
    /// <remarks>
    /// The return value of this method must be consistent with the return value of the
    /// <c>paymJournalFeeCheckUseCustomLookup</c> method.
    /// </remarks>
    public boolean paymJournalFeeOpenLookup(FormControl _formControl, LedgerJournalTrans _ledgerJournalTrans, CustVendPaymJournalFee _custVendPaymJournalFee)
    {
        boolean useCustomLookup = true;

        if (_custVendPaymJournalFee.Module == ModuleCustVend::Cust
            && _custVendPaymJournalFee.LedgerJournalACType == LedgerJournalACType::Cust)
        {
            CustTable::lookupCustomer(_formControl, _ledgerJournalTrans.Company);
        }
        else if (_custVendPaymJournalFee.Module == ModuleCustVend::Vend
            && _custVendPaymJournalFee.LedgerJournalACType == LedgerJournalACType::Vend)
        {
            VendTable::lookupVendor(_formControl, _ledgerJournalTrans.Company);
        }
        else
        {
            useCustomLookup = false;
        }

        Debug::assert(useCustomLookup == this.paymJournalFeeCheckUseCustomLookup(_custVendPaymJournalFee));

        return useCustomLookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymJournalFeeCheckUseCustomLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether the payment journal fee account uses a custom lookup.
    /// </summary>
    /// <param name = "_custVendPaymJournalFee">
    /// The <c>CustVendPaymJournalFee</c> record.
    /// </param>
    /// <returns>
    /// A value that indicates whether the payment journal fee account uses a custom lookup.
    /// </returns>
    /// <remarks>
    /// The return value of this method must be consistent with the return value of the
    /// <c>paymJournalFeeOpenLookup</c> method.
    /// </remarks>
    public boolean paymJournalFeeCheckUseCustomLookup(CustVendPaymJournalFee _custVendPaymJournalFee)
    {
        boolean useCustomLookup = (_custVendPaymJournalFee.Module == ModuleCustVend::Cust
            && _custVendPaymJournalFee.LedgerJournalACType == LedgerJournalACType::Cust)
            || (_custVendPaymJournalFee.Module == ModuleCustVend::Vend
            && _custVendPaymJournalFee.LedgerJournalACType == LedgerJournalACType::Vend);

        return useCustomLookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsSimpleMethod</Name>
				<Source><![CDATA[
    public boolean parmIsSimpleMethod(boolean _isSimpleMethod = isSimpleMethod)
    {
        isSimpleMethod = _isSimpleMethod;
        return isSimpleMethod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTable</Name>
				<Source><![CDATA[
    public LedgerJournalTable parmLedgerJournalTable()
    {
        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTrans_Project</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Parm method to set LedgerJournalTrans_Project.
    /// </summary>
    /// <param name="_ledgerJournalTrans_Project">
    ///    The <c>ledgerJournalTrans_Project</c> table buffer to set.
    /// </param>
    /// <returns>
    ///    The <c>ledgerJournalTrans_Project</c> table buffer.
    /// </returns>
    public LedgerJournalTrans_Project parmLedgerJournalTrans_Project(LedgerJournalTrans_Project _ledgerJournalTrans_Project = ledgerJournalTrans_Project)
    {
        ledgerJournalTrans_Project = _ledgerJournalTrans_Project;
        return ledgerJournalTrans_Project;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNewAccountNum_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parm method to set accountnum.
    /// </summary>
    /// <param name="_accountNum">
    /// The accountNum to set.
    /// </param>
    public void parmNewAccountNum_IN(LedgerJournalAC    _accountNum)
    {
        newAccountNum = _accountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOldVoucherDate_CN</Name>
				<Source><![CDATA[
    public TransDate parmOldVoucherDate_CN(TransDate _oldVoucherDate = oldVoucherDate)
    {
        oldVoucherDate = _oldVoucherDate;
        return oldVoucherDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingResults_Server</Name>
				<Source><![CDATA[
    public LedgerJournalCheckPostResults parmPostingResults_Server(LedgerJournalCheckPostResults _postingResults_Server = postingResults_Server)
    {
        postingResults_Server = _postingResults_Server;

        return postingResults_Server;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrevAccountNum_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parm method to set previous accountnum.
    /// </summary>
    /// <param name="_accountNum">
    /// The accountNum to set.
    /// </param>
    public void parmPrevAccountNum_IN(LedgerJournalAC   _accountNum)
    {
        prevAccountNum = _accountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesPrice</Name>
				<Source><![CDATA[
    public SalesPrice parmSalesPrice(SalesPrice _salesPrice = salesPrice)
    {
        ;
        salesPrice = _salesPrice;
        return salesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymDayId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the <c>PaymDayId</c> of either the <c>CustTable</c> table or the <c>VendTable</c> table according to the account type and account number of the journal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <returns>
    ///    A <c>PamDayId</c> value.
    /// </returns>
    protected PaymDayId paymDayId(LedgerJournalTrans _ledgerJournalTrans)
    {
        PaymDayId   paymDayId;
        CompanyId   companyId;
        ;

        if (xDataArea::exist(_ledgerJournalTrans.Company))
        {
            companyId =_ledgerJournalTrans.Company;
        }
        else
        {
            companyId = curext();
        }

        changecompany(companyId)
        {
            switch (_ledgerJournalTrans.AccountType)
            {
                case LedgerJournalACType::Cust :
                    paymDayId = this.findCustTable(_ledgerJournalTrans).PaymDayId;
                    break;

                case LedgerJournalACType::Vend :
                    paymDayId = _ledgerJournalTrans.findVendTable().PaymDayId;
                    break;

                default :
                    paymDayId = '';
            }
        }
        return paymDayId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymentModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when the payment is modified.
    /// </summary>
    /// <param name = "ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    void paymentModified(LedgerJournalTrans ledgerJournalTrans)
    {
        // <GEEU>
        #EECountryRegionCodes
        // </GEEU>

        PaymTerm        paymTerm;
        PaymDueDateLimit_ES dueDateLimit;

        if (ledgerJournalTrans.parmLedgerDimension())
        {
            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust && ledgerJournalTrans.CashDiscBaseDate)
            {
                ledgerJournalTrans.Due = ledgerJournalTrans.CashDiscBaseDate;
            }
            else
            {
                // <GBR>
                if (!BrazilParameters::isEnabled() || !ledgerJournalTrans.hasCustVendTransOpen_BR())
                {
                    // </GBR>
                    ledgerJournalTrans.Due = this.getDueDateBaseDate(ledgerJournalTrans);
                    // <GBR>
                }
                // </GBR>
            }

            if (ledgerJournalCashDiscService)
            {
                ledgerJournalCashDiscService.setCashDiscParameters(
                    ledgerJournalTrans.Company,
                    ledgerJournalTrans.CashDiscCode,
                    ledgerJournalTrans.Invoice,
                    ledgerJournalTrans.AccountType);
            }

            if (ledgerJournalTrans.Payment
                || ledgerJournalTrans.Invoice)
            {
                paymTerm = PaymTerm::find(ledgerJournalTrans.Payment);
            }

            if (paymTerm
                && ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister
                && InvoiceJournalPaymentScheduleFeature::isEnabled())
            {
                ledgerJournalTrans.PaymSched = paymTerm.PaymSched;
            }
                 

            // <GEERU>
            if ((SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])   &&
                 ledgerJournalTrans.Payment)                                       ||
                (! SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
                 ledgerJournalTrans.Invoice))
                 // </GEERU>
            {
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
                {
                    if (ledgerJournalTrans.Due || !paymTerm.UseDeliveryDateForDueDate_ES)
                    {
                        dueDateLimit = this.getDueDateLimit(ledgerJournalTrans);
                        ledgerJournalTrans.Due = paymTerm.due(ledgerJournalTrans.Due, this.paymDayId(ledgerJournalTrans), false, dueDateLimit);
                    }
                }
                else
                {
                    ledgerJournalTrans.Due = PaymCalendarSourceLedgerJournalTrans::getUpdatedDueDate(ledgerJournalTrans, this.paymDayId(ledgerJournalTrans));
                }
            }

            // <GEEU>
            if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
            {
                ledgerJournalTrans.modifyVatDueDate_W();
            }
            // </GEEU>
        }

        this.setCashRegisterTerminal_W(ledgerJournalTrans);

        this.refreshDataSource(ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymModeModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts the <c>LedgerJournalTrans</c> table record
    ///    fields in response to a change in the <c>AccountNumber</c> value.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table record being modified.
    /// </param>
    public void paymModeModified(LedgerJournalTrans _ledgerJournalTrans)
    {
        this.setCashRegisterTerminal_W(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateOpTypeDependingOnAccType_MX</Name>
				<Source><![CDATA[
    private void populateOpTypeDependingOnAccType_MX(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
        {
            _ledgerJournalTrans.OperationType_MX = _ledgerJournalTrans.findVendTable().OperationType_MX;
        }
        else if (_ledgerJournalTrans.OffsetAccountType ==  LedgerJournalACType::Vend)
        {
            _ledgerJournalTrans.OperationType_MX = _ledgerJournalTrans.findVendForOffset().OperationType_MX;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>posted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns if the journal is posted.
    /// </summary>
    /// <returns>
    /// If the journal is posted.
    /// </returns>
    public NoYes posted()
    {
        return ledgerJournalTable.Posted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postedDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the journal posted datetime.
    /// </summary>
    /// <returns>
    /// The journal posted datetime.
    /// </returns>
    public JournalPostedDateTime postedDateTime()
    {
        return ledgerJournalTable.PostedDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Resets the <c>LedgerJournalEngine</c> state following a call to the <c>write</c> method.
    /// </summary>
    public void postWrite()
    {
        writeInsert = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preCreate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called before a journal line is created.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    public void preCreate(LedgerJournalTrans _ledgerJournalTrans)
    {
        this.voucherTotals(_ledgerJournalTrans);

        if (!journalHasLines && !LedgerJournalTrans_CN_Extension::existJournalNum_CN(ledgerJournalTable.JournalNum))
        {
            // An empty or new journal should not have any existing data in these fields.
            _ledgerJournalTrans.parmLedgerDimension(0);
            _ledgerJournalTrans.Voucher = '';
            _ledgerJournalTrans.Txt = '';

            // <GCN>
            ledgerVoucherTypeRecId = 0;
            // </GCN>
        }
        // <GCN>
        else
        {
            journalHasLines = true;

            if (LedgerParameters::isChineseVoucher_CN())
            {
                oldAttachment  = _ledgerJournalTrans.Attachments_CN;
                oldVoucher_CN  = _ledgerJournalTrans.Voucher_CN;
                oldVoucherDate = _ledgerJournalTrans.TransDate;
                ledgerVoucherTypeRecId = _ledgerJournalTrans.LedgerVoucherType_CN;
                if (oldVoucherDate)
                {
                    oldTransDate = oldVoucherDate;
                }
                else
                {
                    oldTransDate = LedgerJournalEngine::getLastDate_CN();
                }
            }
        }
        // </GCN>
        oldAccountNum               =  _ledgerJournalTrans.parmAccount();
        oldVoucher                  = _ledgerJournalTrans.Voucher;

        oldTransTxt                 = _ledgerJournalTrans.Txt;
        oldCurrencyCode             = _ledgerJournalTrans.CurrencyCode;
        voucherAmountBalances       = this.voucherAmountBalances(_ledgerJournalTrans.CurrencyCode);
        curVoucher                  = _ledgerJournalTrans.Voucher;
        currentRecId                = _ledgerJournalTrans.RecId;
        taxAmountCurrentLineDisplay = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDeleteForPaymentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the payment status prior to allowing delete on the current <c>LedgerJournalTrans</c> table buffer.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true if delete should not be allowed; otherwise, false.
    /// </returns>
    protected boolean canDeleteForPaymentStatus(LedgerJournalTrans _ledgerJournalTrans)
    {
        return (_ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::None || _ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::Rejected);
    }

]]></Source>
			</Method>
			<Method>
				<Name>preDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called before a journal line is deleted.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    public void preDelete(LedgerJournalTrans _ledgerJournalTrans)
    {
        journalHasLines = false;

        ledgerJournalTransOrig.data(_ledgerJournalTrans.orig());

        if (!this.canDeleteForPaymentStatus(_ledgerJournalTrans))
        {
            throw error(this.canDeleteJournalLineErrorMessage());
        }

        // <GCN>
        if (LedgerParameters::isChineseVoucher_CN())
        {
            this.formMethodDataSourceDeletePre_CN(_ledgerJournalTrans);
        }
        // </GCN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDeleteJournalLineErrorMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the error message for when a journal line can't be deleted due to payment status.
    /// </summary>
    /// <returns>
    /// A string with the error message.
    /// </returns>
    protected str canDeleteJournalLineErrorMessage()
    {
        return strFmt("@SYS68189", CustVendPaymStatus::None, CustVendPaymStatus::Rejected);
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepaymentModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts <c>LedgerJournalTrans</c> and optionally <c>LedgerJournalTrans_Project</c> fields in
    ///    response to a change in the <c>LedgerJournalTrans</c> Prepayment value.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table record being modified.
    /// </param>
    /// <param name="_ledgerJournalTransProj">
    ///    The <c>LedgerJournalTrans_Project</c> table record being modified; optional.
    /// </param>
    public void prepaymentModified(LedgerJournalTrans _ledgerJournalTrans,
                                    LedgerJournalTrans_Project _ledgerJournalTransProj = null)
    {
        // <GIN>
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt;
        // </GIN>

        if (!_ledgerJournalTrans.TaxItemGroup)
        {
            this.initTaxItemGroup(_ledgerJournalTrans, _ledgerJournalTransProj);
        }
        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            ledgerJournalTransTaxExt =  _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
        }

        if (TaxWithholdParameters_IN::checkTaxParameters()
            && ledgerJournalTransTaxExt.TaxWithholdCode)
        {
            ledgerJournalTransTaxExt.TaxWithholdCode = '';
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>preWrite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called before a journal line is written.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTrans_Project">
    /// The <c>LedgerJournalTrans_Project</c> record; optional.
    /// </param>
    /// <param name = "_ledgerJournalTrans_RCash">
    /// The <c>LedgerJournalTrans_RCash</c> record; optional.
    /// </param>
    public void preWrite(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTrans_Project _ledgerJournalTrans_Project = null
        ,LedgerJournalTrans_RCash   _ledgerJournalTrans_RCash = null
        )
    {
        if (_ledgerJournalTrans.RecId)
        {
            writeInsert = false;
            ledgerJournalTransOrig.data(_ledgerJournalTrans.orig());
        }
        else
        {
            writeInsert = true;
        }

        if (writeInsert ||
            ledgerJournalTransOrig.Voucher          != _ledgerJournalTrans.Voucher          ||
            ledgerJournalTransOrig.ReverseDate      != _ledgerJournalTrans.ReverseDate      ||
            ledgerJournalTransOrig.ReverseEntry     != _ledgerJournalTrans.ReverseEntry     ||
            ledgerJournalTransOrig.TransDate        != _ledgerJournalTrans.TransDate        ||
            ledgerJournalTransOrig.CurrencyCode     != _ledgerJournalTrans.CurrencyCode     ||
            ledgerJournalTransOrig.Triangulation    != _ledgerJournalTrans.Triangulation    ||
            ledgerJournalTransOrig.ExchRate         != _ledgerJournalTrans.ExchRate         ||
            ledgerJournalTransOrig.ExchRateSecond   != _ledgerJournalTrans.ExchRateSecond   ||
            ledgerJournalTransOrig.ReportingCurrencyExchRate != _ledgerJournalTrans.ReportingCurrencyExchRate ||
            ledgerJournalTransOrig.ReportingCurrencyExchRateSecondary != _ledgerJournalTrans.ReportingCurrencyExchRateSecondary ||
            ledgerJournalTransOrig.parmOffsetLedgerDimension()  != _ledgerJournalTrans.parmOffsetLedgerDimension()    ||
            ledgerJournalTransOrig.AmountCurCredit  != _ledgerJournalTrans.AmountCurCredit  ||
            ledgerJournalTransOrig.AmountCurDebit   != _ledgerJournalTrans.AmountCurDebit   ||
            this.taxChanged(_ledgerJournalTrans))
        {
            // <GEERU><GEEU>
            if (RCashParameters::isCashModuleEnabled())
            {
                this.reduceInternalContainers(_ledgerJournalTrans, _ledgerJournalTrans_RCash);
            }
            else
            {
                // </GEERU></GEEU>
                this.reduceInternalContainers(_ledgerJournalTrans);
                // <GEERU><GEEU>
            }
            // </GEERU></GEEU>
        }

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project ||
             (_ledgerJournalTrans.OffsetAccountType  == LedgerJournalACType::Project && _ledgerJournalTrans.parmOffsetLedgerDimension()))
        {
            ProjTable projTableLocal = ProjTable::find(_ledgerJournalTrans_Project.ProjId);

            boolean isTMTrans = ProjMultipleContractLinesForProjectFeatureHelper::isTimeMaterialBillingMethod(projTableLocal, ProjTransType::Cost);

            if (isTMTrans &&
                !_ledgerJournalTrans_Project.SalesPrice &&
                ProjLineProperty::find(_ledgerJournalTrans_Project.LinePropertyId).ToBeInvoiced)
            {
                info("@SYS57384");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preWriteUpdateDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called before a journal line is written. Handles the default dimension values.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTrans_Asset">
    /// The <c>LedgerJournalTrans_Asset</c> record; optional.
    /// </param>
    /// <param name = "_ledgerJournalTrans_RAsset">
    /// The <c>LedgerJournalTrans_RAsset</c> record; optional.
    /// </param>
    public void preWriteUpdateDefaultDimension(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTrans_Asset  _ledgerJournalTrans_Asset  = null,
        LedgerJournalTrans_RAsset _ledgerJournalTrans_RAsset = null
        )
    {
        // this method should be called after the preWrite method, so writeInsert and ledgerJournalTransOrig is set
        if (writeInsert ||
            ledgerJournalTransOrig.Company != _ledgerJournalTrans.Company ||
            ledgerJournalTransOrig.parmLedgerDimension() != _ledgerJournalTrans.parmLedgerDimension() ||
            ledgerJournalTransOrig.AccountType != _ledgerJournalTrans.AccountType)
        {
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                this.initDefaultDimension(_ledgerJournalTrans, _ledgerJournalTrans_Asset, _ledgerJournalTrans_RAsset);
            }
            else
            {
                this.initDefaultDimension(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
            }
        }

        if (writeInsert ||
            ledgerJournalTransOrig.getOffsetCompany() != _ledgerJournalTrans.getOffsetCompany() ||
            ledgerJournalTransOrig.parmOffsetLedgerDimension() != _ledgerJournalTrans.parmOffsetLedgerDimension() ||
            ledgerJournalTransOrig.OffsetAccountType != _ledgerJournalTrans.OffsetAccountType)
        {
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                this.initOffsetDefaultDimension(_ledgerJournalTrans, _ledgerJournalTrans_Asset, _ledgerJournalTrans_RAsset);
            }
            else
            {
                this.initOffsetDefaultDimension(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preWriteUpdateDefaultDimensionPaymFee</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called before a journal line is written. Handles the cust\vend payment journal fee.
    /// </summary>
    /// <param name = "_custVendPaymJournalFee">
    /// The <c>CustVendPaymJournalFee</c> record.
    /// </param>
    public void preWriteUpdateDefaultDimensionPaymFee(
        CustVendPaymJournalFee _custVendPaymJournalFee)
    {
        CustVendPaymJournalFee paymJournalFeeOrig;

        if (_custVendPaymJournalFee.RecId == 0 ||
            paymJournalFeeOrig.parmLedgerDimension() != _custVendPaymJournalFee.parmLedgerDimension() ||
            paymJournalFeeOrig.LedgerJournalACType != _custVendPaymJournalFee.LedgerJournalACType)
        {
            this.initPaymentFeeDefaultDimension(_custVendPaymJournalFee);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>projCategoryModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the journal line and project line for a project category change.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The journal line being changed.
    /// </param>
    /// <param name="_ledgerJournalTrans_Project">
    ///    The project line associated with the journal line.
    /// </param>
    public void projCategoryModified(
        LedgerJournalTrans          _ledgerJournalTrans,
        LedgerJournalTrans_Project  _ledgerJournalTrans_Project)
    {
        _ledgerJournalTrans_Project.TaxItemGroupSales = ProjCategory::find(_ledgerJournalTrans_Project.CategoryId).TaxItemGroupId;
        _ledgerJournalTrans_Project.LinePropertyId = ProjLinePropertySetup::findLinePropertyId(
                                                            _ledgerJournalTrans.findProjTable().ProjId,
                                                            _ledgerJournalTrans_Project.CategoryId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>projCostPriceModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the project quantity and journal line credit/debit amounts when the project cost price is
    ///    changed.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The journal line being changed.
    /// </param>
    /// <param name="_ledgerJournalTrans_Project">
    ///    The project line associated to the journal line.
    /// </param>
    public void projCostPriceModified(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans_Project _ledgerJournalTrans_Project)
    {
        int     offsetFactor;
        ;

        // We have separate functions for the Proj Expense Journal and other Expense Journals
        if (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Cost)
        {
            // Project Expense Journal

            this.projRecalcAmountCurDebitCredit(_ledgerJournalTrans, _ledgerJournalTrans_Project);
        }
        else
        {
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project
                 || (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project
                        && _ledgerJournalTrans.parmOffsetLedgerDimension()))
            {
                // For non-Project Expense journals, the Debit/Credit has higher priority and is not updated

                // This switch handles the normal(default) case and 2 other special cases
                switch (true)
                {
                    case _ledgerJournalTrans_Project.CostPrice == 0:
                        _ledgerJournalTrans.AmountCurCredit = 0;
                        _ledgerJournalTrans.AmountCurDebit = 0;
                        break;

                    // If Credit/Debit Amounts are both 0, the Proj Qty would be incorrectly set to 0 in the normal case
                    // Handle this case separately
                    case !_ledgerJournalTrans.AmountCurDebit && !_ledgerJournalTrans.AmountCurCredit && _ledgerJournalTrans_Project.Qty:
                        this.projRecalcAmountCurDebitCredit(_ledgerJournalTrans, _ledgerJournalTrans_Project);
                        break;

                    default:
                        // this.amount gets the debit amount or the negative credit amount
                        offsetFactor = this.projOffsetFactor(_ledgerJournalTrans, _ledgerJournalTrans_Project);
                        _ledgerJournalTrans_Project.Qty = decRound((offsetFactor * abs(_ledgerJournalTrans.amount()))/_ledgerJournalTrans_Project.CostPrice, 2);
                        // Qty has changed, recalc debit and credit amounts to avoid rounding diff
                        this.projRecalcAmountCurDebitCredit(_ledgerJournalTrans, _ledgerJournalTrans_Project);
                        break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGLQtySign</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the quantity with the correct sign based on the account type, credit and debit amounts on the journal line.
    /// </summary>
    /// <param name="_accountType">
    ///    The account type specified on the journal line.
    /// </param>
    /// <param name="_offsetAccountType">
    ///    The offset account type specified on the journal line.
    /// </param>
    /// <param name="_amountCurCredit">
    ///    The credit amount specified on the journal line.
    /// </param>
    /// <param name="_amountCurDebit">
    ///    The debit amount specified on the journal line.
    /// </param>
    /// <returns>
    ///    1 or -1 for the quantity based on the account type and amounts.
    /// </returns>
    public static int getGLQtySign(LedgerJournalACType _accountType, LedgerJournalACType _offsetAccountType, AmountCurCredit _amountCurCredit, AmountCurDebit _amountCurDebit)
    {
        int     offsetFactor = 1;
        /*
        Case:  AccType != Proj and OffsetAccType = Proj
        If debit != 0, debit and qty should be of opposite sign
        If debit == 0 and credit != 0, credit and qty should be of same signs
        */
        if (_accountType != LedgerJournalACType::Project &&
            _offsetAccountType == LedgerJournalACType::Project)
        {
            if (_amountCurDebit != 0)
            {
                // debit and qty should be of opposite sign
                offsetFactor = (_amountCurDebit > 0) ? -1 : 1;
            }
            else if (_amountCurCredit != 0)
            {
                // credit and qty should be of same signs
                offsetFactor = (_amountCurCredit > 0) ? 1 : -1;
            }
        }
        /*
        Case:  AccType == Proj and OffsetAccType != Proj
        If debit != 0, debit and qty should be of same sign
        If debit == 0 and credit != 0, credit and qty should be of opposite signs
        */
        else if (_accountType == LedgerJournalACType::Project &&
                 _offsetAccountType != LedgerJournalACType::Project)
        {
            if (_amountCurDebit != 0)
            {
                // debit and qty should be of same sign
                offsetFactor = (_amountCurDebit > 0) ? 1 : -1;
            }
            else if (_amountCurCredit != 0)
            {
                // credit and qty should be of opposite signs
                offsetFactor = (_amountCurCredit > 0) ? -1 : 1;
            }
        }

        return offsetFactor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projOffsetFactor</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the project offset factor.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The journal line being read.
    /// </param>
    /// <param name="_ledgerJournalTrans_Project">
    ///    The project line that is associated to the journal line.
    /// </param>
    /// <returns>
    ///    1 if project is the account type and debit amount is positive or credit amount is negative;
    ///   -1 if project is the offset account type and debit amount is negative or credit amount is positive
    /// </returns>
    int projOffsetFactor(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans_Project _ledgerJournalTrans_Project)
    {
        return LedgerJournalEngine::getGLQtySign(_ledgerJournalTrans.AccountType, _ledgerJournalTrans.OffsetAccountType, _ledgerJournalTrans.AmountCurCredit, _ledgerJournalTrans.AmountCurDebit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>projQtyModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the project <c>CostPrice</c> value when the project quantity is changed.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The journal line being changed.
    /// </param>
    /// <param name="_ledgerJournalTrans_Project">
    ///    The project line associated to the journal line.
    /// </param>
    public void projQtyModified(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans_Project _ledgerJournalTrans_Project)
    {
        int     offsetFactor;
        ;

        if (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Cost)
        {
            // Project Expense Journal

            this.projRecalcAmountCurDebitCredit(_ledgerJournalTrans, _ledgerJournalTrans_Project);
        }
        else
        {
            // When Account Type is Project and sign of quantity is changed, we need to set the appropriate sign for DR/CR amounts
            // Qty = positive, DR = positive, CR = 0
            // Qty = negative, DR = negative, CR = 0
            // Qty = negative, DR = 0, CR = positive
            // Qty = positive, DR = 0, CR = negative
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project)
            {
                _ledgerJournalTrans.AmountCurDebit = sign(_ledgerJournalTrans_Project.Qty) * abs(_ledgerJournalTrans.AmountCurDebit);
                _ledgerJournalTrans.AmountCurCredit = -sign(_ledgerJournalTrans_Project.Qty) * abs(_ledgerJournalTrans.AmountCurCredit);
            }
            // When Offset Account Type is Project and sign of quantity is changed, we need to set the appropriate sign for DR/CR amounts
            // Qty = negative, DR = positive, CR = 0
            // Qty = positive, DR = negative, CR = 0
            // Qty = positive, DR = 0, CR = positive
            // Qty = negative, DR = 0, CR = negative
            else if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
            {
                _ledgerJournalTrans.AmountCurDebit = -sign(_ledgerJournalTrans_Project.Qty) * abs(_ledgerJournalTrans.AmountCurDebit);
                _ledgerJournalTrans.AmountCurCredit = sign(_ledgerJournalTrans_Project.Qty) * abs(_ledgerJournalTrans.AmountCurCredit);
            }

            // For non-Project Expense journals, the Debit/Credit has higher priority and is not updated

            // This switch handles the normal(default) case and 2 other special cases
            switch (true)
            {
                case _ledgerJournalTrans_Project.Qty == 0:
                    _ledgerJournalTrans.AmountCurCredit = 0;
                    _ledgerJournalTrans.AmountCurDebit = 0;
                    break;

                // If Credit/Debit Amounts are both 0, the Cost Price would be incorrectly set to 0 in the normal case
                // Handle this case separately
                case !_ledgerJournalTrans.AmountCurDebit && !_ledgerJournalTrans.AmountCurCredit && _ledgerJournalTrans_Project.CostPrice:
                    this.projRecalcAmountCurDebitCredit(_ledgerJournalTrans, _ledgerJournalTrans_Project);
                    break;

                default:
                    // this.amount gets the debit amount or the negative credit amount
                    offsetFactor = this.projOffsetFactor(_ledgerJournalTrans, _ledgerJournalTrans_Project);
                    _ledgerJournalTrans_Project.CostPrice = CurrencyExchangeHelper::price(offsetFactor * _ledgerJournalTrans.amount() / _ledgerJournalTrans_Project.Qty);

                    // Cost Price should always be positive
                    if (_ledgerJournalTrans_Project.CostPrice < 0)
                    {
                        _ledgerJournalTrans_Project.CostPrice = -_ledgerJournalTrans_Project.CostPrice;
                    }

                    // Cost Price have changed, recalc debit and credit amounts to avoid rounding diff
                    this.projRecalcAmountCurDebitCredit(_ledgerJournalTrans, _ledgerJournalTrans_Project);
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>projRecalcAmountCurDebitCredit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculates the debit and credit amounts.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The journal line being changed.
    /// </param>
    /// <param name="_ledgerJournalTrans_Project">
    /// The project line associated to the journal line.
    /// </param>
    void projRecalcAmountCurDebitCredit(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans_Project _ledgerJournalTrans_Project)
    {
        // We have separate functions for the Proj Expense Journal and other Expense Journals
        if (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Cost)
        {
            if (_ledgerJournalTrans_Project.Qty > 0)
            {
                _ledgerJournalTrans.AmountCurDebit  = CurrencyExchangeHelper::amount(abs(_ledgerJournalTrans_Project.Qty) * _ledgerJournalTrans_Project.CostPrice);
                _ledgerJournalTrans.AmountCurCredit = 0;
            }
            else
            {
                _ledgerJournalTrans.AmountCurDebit = 0;
                _ledgerJournalTrans.AmountCurCredit = CurrencyExchangeHelper::amount(abs(_ledgerJournalTrans_Project.Qty) * _ledgerJournalTrans_Project.CostPrice);
            }

            // <GIN>
            if (TaxParameters::checkTaxParameters_IN())
            {
                LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtensionIN = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
                ledgerJournalTransTaxExtensionIN.AssessableValueTransactionCurrency = _ledgerJournalTrans.AmountCurDebit ? _ledgerJournalTrans.AmountCurDebit : _ledgerJournalTrans.AmountCurCredit;
                LedgerJournalTrans_IN_Extension::packledgerJournalTransTaxExtensionIN(_ledgerJournalTrans, ledgerJournalTransTaxExtensionIN);
            }
            // </GIN>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaSetOld</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets old values.
    /// </summary>
    /// <param name = "_sVoucher">
    /// The voucher string.
    /// </param>
    /// <param name = "_dTransDate">
    /// The transaction date.
    /// </param>
    /// <param name = "_sAccount">
    /// The ledger account.
    /// </param>
    public void psaSetOld(Voucher _sVoucher, TransDate _dTransDate, LedgerAccount _sAccount)
    {
        oldVoucher      = _sVoucher;
        oldTransDate    = _dTransDate;
        oldAccountNum   = _sAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalcVoucherBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates voucher totals.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    void recalcVoucherBalance(LedgerJournalTrans _ledgerJournalTrans)
    {
        // To be used together with saveVoucherBalance
        // This one is called post-manipulation time.

        this.voucherTotals(_ledgerJournalTrans, true);

        journalTotalDebit   += (voucherTotalDebit   - saveVoucherTotalDebit);
        journalTotalCredit  += (voucherTotalCredit  - saveVoucherTotalCredit);
        journalTotalBalance += (voucherTotalDebit   - saveVoucherTotalDebit)
                             - (voucherTotalCredit  - saveVoucherTotalCredit);

        journalTotalDebitReportingCurrency   += (voucherTotalDebitReportingCurrency   - saveVoucherTotalDebitReportingCurrency);
        journalTotalCreditReportingCurrency  += (voucherTotalCreditReportingCurrency  - saveVoucherTotalCreditReportingCurrency);
        journalTotalBalanceReportingCurrency += (voucherTotalDebitReportingCurrency   - saveVoucherTotalDebitReportingCurrency)
                             - (voucherTotalCreditReportingCurrency  - saveVoucherTotalCreditReportingCurrency);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reduceInternalContainers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates internal total amounts.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTrans_RCash">
    /// The <c>LedgerJournalTrans_RCash</c> record; optional.
    /// </param>
    void reduceInternalContainers(
        LedgerJournalTrans        _ledgerJournalTrans
        ,LedgerJournalTrans_RCash _ledgerJournalTrans_RCash = null
        )
    {
        TmpVoucherSum   tmpVoucherSum;
        AmountMST       debit;
        AmountMST       credit;
        AmountCur       sumCur;
        AmountMSTSecondary  debitReportingCurrency;
        AmountMSTSecondary  creditReportingCurrency;

        if (!_ledgerJournalTrans.RecId)
        {
            return;
        }

        tmpVoucherSum.Voucher = _ledgerJournalTrans.orig().Voucher;
        if (voucherBalance.find(tmpVoucherSum))
        {
            [debit, credit] = this.taxDiffDebitCredit();
            [debitReportingCurrency, creditReportingCurrency] = this.taxDiffDebitCredit();

            debit   = -debit;
            credit  = -credit;

            debitReportingCurrency   = -debitReportingCurrency;
            creditReportingCurrency  = -creditReportingCurrency;

            if (_ledgerJournalTrans.orig().AmountCurDebit)
            {
                debit  += _ledgerJournalTrans.orig().calcDebitMST();
                debitReportingCurrency  += _ledgerJournalTrans.orig().calcDebitReportingCurrency();
            }

            if (_ledgerJournalTrans.orig().AmountCurCredit)
            {
                credit += _ledgerJournalTrans.orig().calcCreditMST();
                creditReportingCurrency += _ledgerJournalTrans.orig().calcCreditReportingCurrency();
            }

            if (_ledgerJournalTrans.orig().parmOffsetLedgerDimension())
            {
                if (_ledgerJournalTrans.orig().AmountCurDebit)
                {
                    credit += _ledgerJournalTrans.orig().calcDebitMST();
                    creditReportingCurrency += _ledgerJournalTrans.orig().calcDebitReportingCurrency();
                }

                if (_ledgerJournalTrans.orig().AmountCurCredit)
                {
                    debit  += _ledgerJournalTrans.orig().calcCreditMST();
                    debitReportingCurrency  += _ledgerJournalTrans.orig().calcCreditReportingCurrency();
                }
            }
            else
            {
                sumCur = _ledgerJournalTrans.orig().AmountCurDebit - _ledgerJournalTrans.orig().AmountCurCredit;
            }

            journalTotalDebit        = journalTotalDebit - debit;
            journalTotalCredit       = journalTotalCredit - credit;
            journalTotalBalance      = journalTotalDebit - journalTotalCredit;

            journalTotalDebitReportingCurrency        = journalTotalDebitReportingCurrency - debitReportingCurrency;
            journalTotalCreditReportingCurrency       = journalTotalCreditReportingCurrency - creditReportingCurrency;
            journalTotalBalanceReportingCurrency      = journalTotalDebitReportingCurrency - journalTotalCreditReportingCurrency;

            tmpVoucherSum.Debit     -= debit;
            tmpVoucherSum.Credit    -= credit;
            tmpVoucherSum.SumCur    -= sumCur;
            tmpVoucherSum.DebitReportingCurrency     -= debitReportingCurrency;
            tmpVoucherSum.CreditReportingCurrency    -= creditReportingCurrency;

            voucherBalance.ins(tmpVoucherSum, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Refreshes the data source object of the supplied <c>LedgerJournalTrans</c> record buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    protected void refreshDataSource(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (FormDataUtil::getFormDataSource(_ledgerJournalTrans))
        {
            FormDataUtil::getFormDataSource(_ledgerJournalTrans).refresh();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshWhenPosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes the journal line datasource.
    /// </summary>
    public void refreshWhenPosted()
    {
        boolean allowEdit;

        ledgerJournalTable = LedgerJournalTable::find(ledgerJournalTable.JournalNum);

        if (ledgerJournalTrans_ds)
        {
            allowEdit = this.allowEdit();
            ledgerJournalTrans_ds.allowEdit(allowEdit);
            ledgerJournalTrans_ds.allowDelete(allowEdit);
            ledgerJournalTrans_ds.allowCreate(allowEdit);

            ledgerJournalTrans_ds.research();

            if (ledgerJournalTrans_ds.formRun() &&
                ledgerJournalTrans_ds.formRun().selectedControl())
            {
                // The post button control is no longer enabled and not focusable after a successful post.
                // Set focus on the selected control that is still enabled to ensure accessibility is maintained.
                ledgerJournalTrans_ds.formRun().selectedControl().setFocus();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>rejected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns if the journal has been rejected.
    /// </summary>
    /// <returns>
    /// true if the journal has been rejected; otherwise, false.
    /// </returns>
    public boolean rejected()
    {
        return (ledgerJournalTable.RejectedBy != '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>rejectedBy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the user that reject the journal.
    /// </summary>
    /// <returns>
    /// The user that rejected the journal.
    /// </returns>
    public UserId rejectedBy()
    {
        return ledgerJournalTable.RejectedBy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseDateModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Displays a warning if the entered release date is in the past.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record to use as a basis to compare the release date.
    /// </param>
    public void releaseDateModified(LedgerJournalTrans _ledgerJournalTrans)
    {
        if ((_ledgerJournalTrans.ReleaseDate != utcDateTimeNull()) &&
             (DateTimeUtil::addDays(_ledgerJournalTrans.ReleaseDate, 1) < DateTimeUtil::utcNow()))
        {
            warning("@SYS114595");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeBudgetCheckResultFromCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the budget check result for the specified voucher from the budget check results cache.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher for the budget check result to be removed from the cache.
    /// </param>
    /// <returns>
    /// true if the budget check result for the specified voucher is found and removed; otherwise, false.
    /// </returns>
    public boolean removeBudgetCheckResultFromCache(Voucher _voucher)
    {
        return voucherBudgetCheckResults.remove(_voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportedAsReady</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the journal is reported as ready.
    /// </summary>
    /// <returns>
    /// true if the journal is reported as ready; otherwise, false.
    /// </returns>
    public boolean reportedAsReady()
    {
        // <GCN>
        if (ledgerJournalTable.JournalType == LedgerJournalType::Daily
            && LedgerParameters::isJournalApproval_CN())
        {
            return (ledgerJournalTable.ReportedAsReadyBy
                || !ledgerJournalName.ApproveActive);
        }
        else
        {
            // </GCN>
            return (ledgerJournalTable.ReportedAsReadyBy && !this.rejected());
            // <GCN>
        }
        // </GCN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportedAsReadyBy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the user that reported the journal as ready.
    /// </summary>
    /// <returns>
    /// The user that reported the journal as ready.
    /// </returns>
    public UserId reportedAsReadyBy()
    {
        return ledgerJournalTable.ReportedAsReadyBy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rereadWhenDirty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls refresh and reRead on the data source of the supplied <c>LedgerJournalTrans</c> record buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer
    /// </param>
    /// <param name="_force">
    ///    A flag indicating if <c>reRead</c> must always be executed, despite cash discount criteria; optional.
    /// </param>
    /// <returns>
    ///    true if a reRead was performed; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method calls refresh and reRead if the cash discount has been changed for the specific journal line. They are also called if the method is called with the force argument set to true.
    /// </remarks>
    public boolean rereadWhenDirty(LedgerJournalTrans   _ledgerJournalTrans,
                                   boolean              _force = false)
    {
        if (_force || (_ledgerJournalTrans.RecId && cashDiscDirty.lookup(_ledgerJournalTrans.RecId)))
        {
            this.clearTaxAmountCache(_ledgerJournalTrans, false);
            if (ledgerJournalTrans_ds)
            {
                ledgerJournalTrans_ds.reread();
                ledgerJournalTrans_ds.refresh();
            }

            cashDiscDirty.insert(_ledgerJournalTrans.RecId, false);

            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetBudgetCheckResultsCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the budget check results cache.
    /// </summary>
    public void resetBudgetCheckResultsCache()
    {
        voucherBudgetCheckResults = new Map(Types::String, Types::Integer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveVoucherBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the voucher totals.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    void saveVoucherBalance(LedgerJournalTrans _ledgerJournalTrans)
    {
        // To be used together with recalcVoucherBalance
        // This one is called pre-manipulation time.

        this.voucherTotals(_ledgerJournalTrans);

        saveVoucherTotalDebit   = voucherTotalDebit;
        saveVoucherTotalCredit  = voucherTotalCredit;

        saveVoucherTotalDebitReportingCurrency   = voucherTotalDebitReportingCurrency;
        saveVoucherTotalCreditReportingCurrency  = voucherTotalCreditReportingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectSettledNegInstTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Starts the form for selecting settled negotiable instrument (Bill of exchange / Promissory note) transactions.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    public void selectSettledNegInstTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean end  = false;

        if (!_ledgerJournalTrans.Voucher)
        {
            throw error("@SYS57812");
        }

        if (_ledgerJournalTrans.isCompanyIntercompany())
        {
            throw error("@SYS67318");
        }
        else
        {
            end = _ledgerJournalTrans.formSelectSettledNegInst(this);

            if (!end)
            {
                this.findSettledAmount(_ledgerJournalTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAgreement_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>LedgerJournalTrans</c> record after any of agreement related field is modified.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_accountOffsetaccount">
    /// Account type, account or offset account; optional.
    /// </param>
    public void setAgreement_RU(LedgerJournalTrans _ledgerJournalTrans, AccountOffsetaccount _accountOffsetaccount = AccountOffsetaccount::Account)
    {
        AgreementHeaderExt_RU agreementHeaderExt = this.findAgreementHeaderExt_RU(_ledgerJournalTrans, _accountOffsetaccount);

        if (agreementHeaderExt)
        {
            this.initFromAgreementHeader_RU(_ledgerJournalTrans,
                AgreementHeader::find(agreementHeaderExt.AgreementHeader),
                _accountOffsetaccount);

            _ledgerJournalTrans.initAgreementDimension_RU(agreementHeaderExt, _accountOffsetaccount);

            this.initVendPostingProfile(_ledgerJournalTrans);
            this.initCustPostingProfile(_ledgerJournalTrans);
        }
        else
        {
            _ledgerJournalTrans.clearAgreementDimension_RU(_accountOffsetaccount);
        }

        FormDataSource formDS = FormDataUtil::getFormDataSource(_ledgerJournalTrans);
        if (formDS)
        {
            if (_accountOffsetaccount == AccountOffsetaccount::Account)
            {
                formDS.cacheCalculateMethod(tablemethodstr(LedgerJournalTrans, accountAgreementDocumentTitle_RU));
            }
            else
            {
                formDS.cacheCalculateMethod(tablemethodstr(LedgerJournalTrans, offsetAccountAgreementDocumentTitle_RU));
            }
        }
        this.refreshDataSource(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAssetDepStartDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the asset depreciation start date for the primary account and offset account of asset book
    ///    changes.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer that stores part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table buffer that stores part of the transaction.
    /// </param>
    /// <param name="_forceSet">
    ///    A Boolean value that forces the depreciation start date to be set; optional.
    /// </param>
    /// <remarks>
    ///    The <paramref name="_forceSet" /> parameter causes this method to ignore whether any field values
    ///    have changed and set the <c>DepreciationStartDate</c> field on the specified
    ///    <c>LedgerJournalTrans_Asset</c> table buffer passed in as a parameter.
    /// </remarks>
    public void setAssetDepStartDate(LedgerJournalTrans       _ledgerJournalTrans,
                                     LedgerJournalTrans_Asset _ledgerJournalTrans_Asset,
                                     boolean                  _forceSet = false)
    {
        if ((_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets &&
            _ledgerJournalTrans.parmLedgerDimension() != _ledgerJournalTrans.orig().parmLedgerDimension()) ||
            (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets &&
            _ledgerJournalTrans.parmOffsetLedgerDimension() != _ledgerJournalTrans.orig().parmOffsetLedgerDimension()) ||
            _ledgerJournalTrans_Asset.BookId != _ledgerJournalTrans_Asset.orig().BookId || _forceSet)
        {
            _ledgerJournalTrans_Asset.DepreciationStartDate = AssetBook::getDepreciationStartDate(_ledgerJournalTrans.getAssetId(), _ledgerJournalTrans_Asset.BookId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCashRegisterTerminal_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the cash register terminal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The buffer of the <c>LedgerJournalTrans</c> table.
    /// </param>
    public void setCashRegisterTerminal_W(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (CashRegisterProcessingBase::isEnabledForCurrentUser()
            && LedgerJournalTrans_W::isLegalEntityInCountryRegion()
            && this.enableCashRegister_W())
        {
            LedgerJournalTrans_W  ledgerJournalTrans_W = _ledgerJournalTrans.ledgerJournalTrans_W();

            if (this.needInitCashRegisterTerminal_W(_ledgerJournalTrans))
            {
                ledgerJournalTrans_W.initCashRegisterTerminal();
            }
            else
            {
                ledgerJournalTrans_W.clearCashRegisterTerminal();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setChildDataSourceAccess</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the data source entry access level for a data source to match the data source of the supplied <c>LedgerJournalTrans</c> record buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTransRecord</c> buffer.
    /// </param>
    /// <param name="_common">
    ///    A <c>Common</c> record buffer, being the child.
    /// </param>
    /// <remarks>
    ///    Currently used by the journal payment fee system. This method is useful to align the level of access for data sources that act as children to the journal line data source.
    /// </remarks>
    void setChildDataSourceAccess(LedgerJournalTrans _ledgerJournalTrans,
                                  Common             _common)
    {
        boolean         allowEdit;
        FormDataSource  formDataSource;

        if (FormDataUtil::getFormDataSource(_common))
        {
            formDataSource = FormDataUtil::getFormDataSource(_common);

            allowEdit = this.allowEditTrans(_ledgerJournalTrans);

            formDataSource.allowCreate( allowEdit);
            formDataSource.allowEdit(   allowEdit);
            formDataSource.allowDelete( allowEdit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDeprBonusAmount_RU</Name>
				<Source><![CDATA[
    public void setDeprBonusAmount_RU(LedgerJournalTrans _ledgerJournalTrans,
                                      DebCredProposal    _debCredProposal,
                                      RAssetDeprBonusId  _deprBonusId = '')
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFactureAutoCreate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the value of field facture auto create if one of account types is customer depending on
    /// settings in the parameters.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The record to be modified.
    /// </param>
    /// <param name="_accountOffsetaccount">
    /// Which account type should be checked for value customer.
    /// </param>
    /// <remarks>
    /// Works only for general ledger journal.
    /// </remarks>
    public void setFactureAutoCreate(LedgerJournalTrans _ledgerJournalTrans, AccountOffsetaccount _accountOffsetaccount)
    {
        boolean accountCust = (
            _ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
            _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust);

        if (! ledgerJournalTable || ledgerJournalTable.JournalNum != _ledgerJournalTrans.JournalNum)
        {
            ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();
        }

        if (ledgerJournalTable.JournalType != LedgerJournalType::Daily)
        {
            return;
        }

        if ((_accountOffsetaccount == AccountOffsetaccount::Account         &&
             _ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)  ||
            (_accountOffsetaccount == AccountOffsetaccount::OffsetAccount   &&
             _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
            )
        {
            _ledgerJournalTrans.CustFactureAutoCreate_RU = CustParameters::find().PrepaymentFactureAutoCreate_RU;
        }

        if (!accountCust)
        {
            _ledgerJournalTrans.CustFactureAutoCreate_RU = NoYes::No;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the project cost price and quantity values if the journal line has changed and is
    ///    associated with a project.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table record being modified.
    /// </param>
    /// <param name="_ledgerJournalTrans_Project">
    ///    The <c>LedgerJournalTrans_Project</c> table record being modified.
    /// </param>
    /// <remarks>
    ///    This method is used when journal line fields that affect project information are changed. These
    ///    included account type or number, offset account type or number, and credit or debit amounts. The
    ///    journal line does not have to be associated with a project for this method to be called.
    /// </remarks>
    public void setProjAmount(LedgerJournalTrans _ledgerJournalTrans,
                                LedgerJournalTrans_Project _ledgerJournalTrans_Project)
    {
        int     offsetFactor = 1;

        // Either the Account type or the Offset Account type should be Project
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project ||
            _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
        {
            offsetFactor = this.projOffsetFactor(_ledgerJournalTrans, _ledgerJournalTrans_Project);

            this.setProjAmountWithOffsetFactor(_ledgerJournalTrans, _ledgerJournalTrans_Project, offsetFactor);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjAmountWithOffsetFactor</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the project cost price and quantity values with the given offset factor
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table record being modified.
    /// </param>
    /// <param name="_ledgerJournalTrans_Project">
    ///    The <c>LedgerJournalTrans_Project</c> table record being modified.
    /// </param>
    /// <param name="_offsetFactor">
    ///    Offset factor used to update CostPrice and Qty on _ledgerJournalTrans_Project.
    /// </param>
    private void setProjAmountWithOffsetFactor(LedgerJournalTrans _ledgerJournalTrans,
                                LedgerJournalTrans_Project _ledgerJournalTrans_Project, int _offsetFactor)
    {
        // Either the Account type or the Offset Account type should be Project
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project ||
            _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
        {
            // If qty has not been set by user, initialize it to 1
            if (_ledgerJournalTrans_Project.Qty == 0)
            {
                _ledgerJournalTrans_Project.Qty = 1;
            }

            // this.amount gets the debit amount or the negative credit amount
            _ledgerJournalTrans_Project.CostPrice = CurrencyExchangeHelper::price(_offsetFactor * _ledgerJournalTrans.amount() / _ledgerJournalTrans_Project.Qty);

            // Cost Price should always be positive; To keep equation balanced, negate the Proj Qty
            if (_ledgerJournalTrans_Project.CostPrice < 0)
            {
                _ledgerJournalTrans_Project.CostPrice = - _ledgerJournalTrans_Project.CostPrice;
            }

            // Sign of quantity should follow offsetfactor
            _ledgerJournalTrans_Project.Qty = _offsetFactor * abs(_ledgerJournalTrans_Project.Qty);

            // Cost Price have changed, recalc debit and credit amounts to avoid rounding diff
            this.projRecalcAmountCurDebitCredit(_ledgerJournalTrans, _ledgerJournalTrans_Project);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDefaultValuesForProjTrans</Name>
				<Source><![CDATA[
    private void setDefaultValuesForProjTrans(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans_Project _ledgerJournalTrans_Project)
    {
        // Either the Account type or the Offset Account type should be Project
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project ||
            _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
        {
            // If qty has not been set by user, initialize it to 1
            if (_ledgerJournalTrans_Project.Qty == 0)
            {
                _ledgerJournalTrans_Project.Qty = 1;
            }

            // this.amount gets the debit amount or the negative credit amount
            _ledgerJournalTrans_Project.CostPrice = CurrencyExchangeHelper::price(_ledgerJournalTrans.amount() / _ledgerJournalTrans_Project.Qty);

            // Cost Price should always be positive;
            if (_ledgerJournalTrans_Project.CostPrice < 0)
            {
                _ledgerJournalTrans_Project.CostPrice = - _ledgerJournalTrans_Project.CostPrice;
            }

            // Cost Price have changed, recalc debit and credit amounts to avoid rounding diff
            this.projRecalcAmountCurDebitCredit(_ledgerJournalTrans, _ledgerJournalTrans_Project);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjDefaultOffsetAccount</Name>
				<Source><![CDATA[
    public void setProjDefaultOffsetAccount(
        LedgerJournalTrans          _ledgerJournalTrans,
        LedgerJournalTrans_Project  _ledgerJournalTrans_Project)
    {
        /*
         * Get default offset account for project ledger journal.
         *
         * The default offset account will only be set, if an offset account
         * has not been set for the active ledger journal.
         */

         ProjDefaultOffsetSetup  projDefaultOffsetSetup;
        ResourceRecId           resource;

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project)
        {
            // Check if offset account set for ledger journal.
            if (this.parmLedgerJournalTable().JournalType != LedgerJournalType::Approval &&
                !this.parmLedgerJournalTable().parmOffsetLedgerDimension())
            {
                resource = _ledgerJournalTrans_Project.Resource;
                projDefaultOffsetSetup = ProjDefaultOffsetSetup::findDefaultOffsetAccount(
                                            _ledgerJournalTrans.parmAccount(),
                                            _ledgerJournalTrans_Project.CategoryId,
                                            resource);
                if (projDefaultOffsetSetup)
                {
                    _ledgerJournalTrans.OffsetAccountType = projDefaultOffsetSetup.getLedgerOffsetType();
                    if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
                    {
                        _ledgerJournalTrans.parmOffsetLedgerDimension(
                            _ledgerJournalTrans.getOffsetLedgerDimensionForLedgerType(
                                projDefaultOffsetSetup.parmLedgerDimension(),
                                _ledgerJournalTrans.getOffsetCompany()));
                    }
                    else
                    {
                        _ledgerJournalTrans.parmOffsetLedgerDimension(projDefaultOffsetSetup.parmLedgerDimension());
                    }

                    if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust ||
                        _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
                    {
                        _ledgerJournalTrans.Approved             = NoYes::Yes;
                        _ledgerJournalTrans.Approver             = HcmWorker::userId2Worker(curUserId());
                    }

                    this.initTaxGroup(_ledgerJournalTrans);
                    this.initTaxItemGroup(_ledgerJournalTrans, _ledgerJournalTrans_Project);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjTaxItemGroup</Name>
				<Source><![CDATA[
    protected void setProjTaxItemGroup(
        LedgerJournalTrans          _ledgerJournalTrans,
        LedgerJournalTrans_Project  _ledgerJournalTrans_Project)
    {
        _ledgerJournalTrans_Project.TaxItemGroupSales    = ProjCategory::find(_ledgerJournalTrans_Project.CategoryId).TaxItemGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRCashDocType_RU</Name>
				<Source><![CDATA[
    private void setRCashDocType_RU(LedgerJournalTrans       _ledgerJournalTrans,
                                    LedgerJournalTrans_RCash _ledgerJournalTrans_RCash)
    {
        if ((_ledgerJournalTrans.AccountType       == LedgerJournalACType::RCash ||
             _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::RCash) &&
             FormDataUtil::getFormDataSource(_ledgerJournalTrans_RCash)
           )
        {
            _ledgerJournalTrans_RCash.DocType = RCashVoucher::docType(_ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleTrans</Name>
				<Source><![CDATA[
    void settleTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        xFormRun settlementForm;

        if (!_ledgerJournalTrans.Voucher)
        {
            throw error("@SYS57812");
        }

        if (_ledgerJournalTrans.isCompanyIntercompany() &&
            isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) == false)
        {
            throw error("@SYS67318");
        }

        settlementForm = this.formSettlement(_ledgerJournalTrans);

        if (settlementForm != null)
        {
            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                _ledgerJournalTrans.updateEPRemitInfo_BR();

                LedgerJournalTrans_BR_Extension::populateIncomeCodeFromSettledInvoice(_ledgerJournalTrans);
            }
            // </GBR>

            this.findSettledAmount(_ledgerJournalTrans);
            this.settleTransUpdate(_ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleTransUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates settlement data for the journal line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <remarks>
    ///    This method is used by the split payment feature.
    /// </remarks>
    void settleTransUpdate(LedgerJournalTrans _ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setToOpenValue_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets ledger journal engine to open value.
    /// </summary>
    public void setToOpenValue_CN()
    {
        LedgerJournalTable ledgerJournalTableCopy;

        ttsbegin;

        select firstonly forupdate ledgerJournalTableCopy
            where ledgerJournalTableCopy.JournalNum == ledgerJournalTable.JournalNum;

        ledgerJournalTableCopy.setToOpenValue_CN();
        ledgerJournalTableCopy.update();
        ledgerJournalTable.setToOpenValue_CN();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransDate_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes _ledgerJournalTrans.TransDate
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// Record to be initialized
    /// </param>
    public void setTransDate_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans tmpLedgerJournalTrans;

        if (ledgerJournalName.MandatoryDate_RU)
        {
            tmpLedgerJournalTrans = ledgerJournalTable.getAnyLine_RU();
        }

        if (tmpLedgerJournalTrans)
        {
            _ledgerJournalTrans.TransDate = tmpLedgerJournalTrans.TransDate;
        }
        else
        {
            switch (ledgerJournalName.DateInitType_RU)
            {
                case LedgerJournalDateInitType_RU::NullDate:
                    _ledgerJournalTrans.TransDate = dateNull();
                    break;

                case LedgerJournalDateInitType_RU::CurrentDate:
                    _ledgerJournalTrans.TransDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    break;

                default:
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>takeNewVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a new voucher is needed.
    /// </summary>
    /// <returns>
    /// true if a new voucher is needed; otherwise, false.
    /// </returns>
    public boolean takeNewVoucher()
    {
        TmpVoucherSum   tmpVoucherSum;
        boolean         ret = false;

        switch (ledgerJournalName.NewVoucher)
        {
            case NewVoucher::BalanceSheet:
                if (!oldAccountNum && !oldVoucher)
                {
                    ret = true;
                }
                else if (!voucherBalance.first(tmpVoucherSum))
                {
                    ret = true;
                }
                else if (ledgerJournalName.CurrentOperationsTax == CurrentOperationsTax::None)
                {
                    // 'None' posting layer does not post to ledger and have no Offset accounts.
                    ret = true;
                }
                else if (!oldAccountNum && oldVoucher)
                {
                    ret = false;
                }
                else if (voucherAmountBalances)
                {
                    ret = true;
                }
                break;
            case NewVoucher::OneVoucher:
                if (!oldVoucher)
                {
                    ret = true;
                }
                break;
        }

        // <GCN>
        if (ledgerJournalTable.JournalType == LedgerJournalType::Daily
            && isSimpleMethod
            && LedgerParameters::isChineseVoucher_CN())
        {
            if (oldVoucher)
            {
                ret = false;
            }
            else
            {
                ret = true;
            }
        }
        // </GCN>
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the tax amount in currency for a specific journal line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer
    /// </param>
    /// <param name="includeUseTax">
    ///    Set to true to include Use tax amounts in the tax amount.  False to exclude Use tax amounts.
    /// </param>
    /// <returns>
    ///    The tax amount in the currency of the journal line.
    /// </returns>
    public TaxAmountJournal taxAmountJournal(LedgerJournalTrans _ledgerJournalTrans, boolean includeUseTax = true)
    {
        TaxAmountCur    actualTax, calculatedTax;

        if (_ledgerJournalTrans.RecId != 0)
        {
            if (!taxAmountDisplayCalc.lookup(_ledgerJournalTrans.RecId))
            {
                if (!ledgerJournalTable.Posted && _ledgerJournalTrans.isTaxable())
                {
                    if (TaxParameters::find().CashDiscOnInvoice)
                    {
                        if (ledgerJournalTable.JournalType == LedgerJournalType::PurchaseLedger)
                        {
                            _ledgerJournalTrans.CashDiscPercent = 0;
                            _ledgerJournalTrans.CashDiscAmount  = 0;
                            _ledgerJournalTrans.CashDiscCode    = '';
                        }
                    }
                }

                [actualTax, calculatedTax] = this.getTaxAmounts(_ledgerJournalTrans, includeUseTax);
            }
            else
            {
                calculatedTax = taxAmountDisplay.lookup(_ledgerJournalTrans.RecId);
            }
        }
        else
        {
            if (taxAmountCurrentLineDisplay)
            {
                calculatedTax = taxAmountCurrentLine;
            }
            else
            {
                if (TaxParameters::find().CashDiscOnInvoice)
                {
                    calculatedTax = abs(_ledgerJournalTrans.totalTaxAmountSingleLine(false, includeUseTax, true));
                }
                else
                {
                    if (_ledgerJournalTrans.isTaxable())
                    {
                        calculatedTax = abs(_ledgerJournalTrans.totalTaxAmountSingleLine(false, includeUseTax, true));
                    }
                }

                taxAmountCurrentLine        = calculatedTax;
                taxAmountCurrentLineDisplay = true;
            }
        }
        return calculatedTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountOrig</Name>
				<Source><![CDATA[
    /// <summary>
    /// The originating amount to calculate taxes.
    /// </summary>
    void taxAmountOrig()
    {
        // Overload id approval journal
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountPerLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the amount of tax for a single journal line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <returns>
    ///    The tax amount in currency.
    /// </returns>
    AmountCur taxAmountPerLine(LedgerJournalTrans _ledgerJournalTrans)
    {
        AmountCur taxCalculated;
        AmountCur taxCorrected;

        taxCorrected = this.correctedTaxAmount(_ledgerJournalTrans);
        if (taxCorrected)
        {
            return taxCorrected;
        }

        taxCalculated = this.taxAmountJournal(_ledgerJournalTrans);
        return taxCalculated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxChanged</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates if a tax field has changed.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <returns>
    ///    true if tax fields have changed; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method returns false, except for the implementation in LedgerJournalEngine_VendApprove, where it returns true if one of the following fields is changed: TaxCode, TaxGroup, TaxItemGroup.
    /// </remarks>
    protected boolean taxChanged(LedgerJournalTrans _ledgerJournalTrans)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxDiffDebitCredit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container with two amounts.
    /// </summary>
    /// <returns>
    /// A container with two zero amounts.
    /// </returns>
    protected container taxDiffDebitCredit()
    {
        AmountMST amountMST;
        return [amountMST, amountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxDocumentCreateButton_CZ</Name>
				<Source><![CDATA[
    public boolean taxDocumentCreateButton_CZ(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ret = (ledgerJournalTable.Posted      &&
                       _ledgerJournalTrans.Prepayment &&
                       (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
                       _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend));

        return ret && !CzTaxDocumentTable::exist(_ledgerJournalTrans.Voucher, _ledgerJournalTrans.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpTaxTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the current instance of the temporary table <c>TmpTaxTotals</c>.
    /// </summary>
    /// <returns>
    /// The current instance of the temporary table <c>TmpTaxTotals.</c>
    /// </returns>
    /// <remarks>
    /// Tax totals are calculated by calling the <c>calculateTaxForCompleteJournal</c> method.
    /// </remarks>
    public TmpTaxTotals tmpTaxTotals()
    {
        return tmpTaxTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDateModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when the transaction date is modified.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    public void transDateModified(LedgerJournalTrans _ledgerJournalTrans)
    {
        TransDate transDate;

        this.clearTaxAmountCache(_ledgerJournalTrans);

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust && _ledgerJournalTrans.CashDiscBaseDays)
        {
            transDate = this.getDueDateBaseDate(_ledgerJournalTrans);
            _ledgerJournalTrans.CashDiscBaseDate = transDate + _ledgerJournalTrans.CashDiscBaseDays;
        }
        else
        {
            _ledgerJournalTrans.CashDiscBaseDate = dateNull();
        }

        this.currencyModified(_ledgerJournalTrans);

        if (_ledgerJournalTrans.CashDiscCode)
        {
            this.calculateCashDisc(_ledgerJournalTrans);
        }

        this.paymentModified(_ledgerJournalTrans);

        this.refreshDataSource(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDateUpdate_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates transaction date.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaction.
    /// </param>
    public void transDateUpdate_CN(LedgerJournalTrans _ledgerJournalTrans)
    {
        NumberSeq               numberSeq;
        RefRecId                numberSequenceTableRecId;
        FiscalCalendarPeriod    oldPeriod;
        FiscalCalendarPeriod    newPeriod;
        FiscalCalendarRecId     fiscalCalendarRecId = CompanyInfoHelper::fiscalCalendarRecId();

        if (_ledgerJournalTrans.TransDate == oldVoucherDate)
        {
            return;
        }

        if (!this.checkDateinPeriod_CN(_ledgerJournalTrans, oldVoucherDate))
        {
            _ledgerJournalTrans.TransDate = oldVoucherDate;
            ledgerJournalTrans_ds.refresh();
            return;
        }

        if (ledgerJournalTable.VoucherAllocatedAtPosting
            || (LedgerJournalName::find(ledgerJournalTable.JournalName).NewVoucher == NewVoucher::Manually && !isSimpleMethod))
        {
            oldVoucherDate = _ledgerJournalTrans.TransDate;
            return;
        }

        oldPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(fiscalCalendarRecId, oldVoucherDate);
        newPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(fiscalCalendarRecId, _ledgerJournalTrans.TransDate);

        if (oldPeriod != newPeriod && _ledgerJournalTrans.LedgerVoucherType_CN)
        {
            numberSequenceTableRecId = LedgerVoucherType_CN::find(_ledgerJournalTrans.LedgerVoucherType_CN).NumberSequenceTable;
            if (NumberSequenceTable_CN::findByNumberSequenceTable(numberSequenceTableRecId).RestartNum)
            {
                NumberSeq_Voucher_CN::release(numberSequenceTableRecId, _ledgerJournalTrans.Voucher_CN, oldVoucherDate);
                numberSeq = NumberSeq_Voucher_CN::newGetVoucherFromCode(numberSequenceTableRecId, _ledgerJournalTrans.TransDate, true);
                _ledgerJournalTrans.Voucher_CN = numberSeq.voucher();
            }
        }
        oldVoucherDate = _ledgerJournalTrans.TransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>triangulationModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates exchange rates and updates that data in the source journal line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <remarks>
    ///    This method must be called when the triangulation field of the journal line is changed.
    /// </remarks>
    void triangulationModified(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_ledgerJournalTrans.Triangulation)
        {
            this.currencyModified(_ledgerJournalTrans,false);
        }
        else
        {
            if (_ledgerJournalTrans.ExchRateSecond)
            {
                _ledgerJournalTrans.ExchRate        = _ledgerJournalTrans.crossrate();
                _ledgerJournalTrans.ExchRateSecond = 0;
            }
        }

        this.refreshDataSource(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unlock</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets locked to false.
    /// </summary>
    public void unlock()
    {
        locked = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Recalculates the cash discount for the voucher of the journal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer
    /// </param>
    /// <param name="_updateCashDisc">
    ///    A Boolean value that determines whether the cash discount should be recalculated; optional.
    /// </param>
    /// <remarks>
    ///    This method also maintains an internal cache of the journal lines that have their cash discounts modified.
    /// </remarks>
    public void updateCashDisc(LedgerJournalTrans   _ledgerJournalTrans,
                                boolean             _updateCashDisc = false)
    {
        container   recordDirty;
        Counter     counter;
        Counter     numOfRecords;
        RecId       recordDirtyRecId;

        recordDirty = LedgerJournalEngine_Server::updateCashDisc(_ledgerJournalTrans, _updateCashDisc);
        numOfRecords = conLen(recordDirty);

        for (counter = 1; counter <= numOfRecords; counter++)
        {
            recordDirtyRecId = conPeek(recordDirty, counter);

            cashDiscDirty.insert(recordDirtyRecId, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDiscDetail</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>CustTransCashDisc</c> and <c>VendTransCashDisc</c> tables with cash discount information from the journal line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A LedgerJournalTrans record buffer.
    /// </param>
    /// <param name="_manual">
    ///    A Boolean flag that determines whether the cash discount should be recorded to the Cust/VendTransCashDisc tables as a manual entry; optional.
    /// </param>
    /// <remarks>
    ///    This method must be called when the <c>CashDiscAmount</c>, <c>CashDiscCode</c> and <c>DateCashDisc</c> fields of the journal line is changed.
    /// </remarks>
    void updateCashDiscDetail(LedgerJournalTrans _ledgerJournalTrans,
                              boolean            _manual = true)
    {
        LedgerJournalEngine_Server::updateCashDiscDetail(_ledgerJournalTrans, _manual);

        this.refreshDataSource(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFeeLedgerTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates fee <c>LedgerJournalTrans</c> records when the journal line has experienced some changes.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    public void updateFeeLedgerTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        CustVendPaymJournalFee custVendPaymJournalFee;
        LedgerJournalTrans     ledgerJournalTransFee;

        if (ledgerJournalTransOrig.OffsetDefaultDimension != _ledgerJournalTrans.OffsetDefaultDimension)
        {
            select firstonly RecId from ledgerJournalTransFee
                exists join RecId from custVendPaymJournalFee
                    where custVendPaymJournalFee.RefRecId == _ledgerJournalTrans.RecId
                       && ledgerJournalTransFee.RecId     == custVendPaymJournalFee.FeeTransRecId;

            if (ledgerJournalTransFee)
            {
                ttsbegin;
                while select forupdate ledgerJournalTransFee
                    exists join custVendPaymJournalFee
                        where custVendPaymJournalFee.RefRecId == _ledgerJournalTrans.RecId
                           && ledgerJournalTransFee.RecId     == custVendPaymJournalFee.FeeTransRecId
                {
                    ledgerJournalTransFee.OffsetDefaultDimension = _ledgerJournalTrans.OffsetDefaultDimension;
                    ledgerJournalTransFee.update();
                }
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInternalContainers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates internal amounts.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_deleteTrans">
    /// Determines if the internal amounts are updated; optional.
    /// </param>
    /// <param name = "_ledgerJournalTrans_RCash">
    /// The <c>LedgerJournalTrans_RCash</c> record; optional.
    /// </param>
    void updateInternalContainers(
        LedgerJournalTrans       _ledgerJournalTrans
        ,boolean                 _deleteTrans       = false,
        LedgerJournalTrans_RCash _ledgerJournalTrans_RCash = null
        )
    {
        AmountMST       debit;
        AmountMST       credit;
        Counter         pos;
        TmpVoucherSum   tmpVoucherSum;
        AmountMSTSecondary  debitReportingCurrency;
        AmountMSTSecondary  creditReportingCurrency;

        if (ledgerJournalTable.FixedOffsetAccount && ledgerJournalTable.parmOffsetLedgerDimension())
        {
            journalTotalOffsetBalance = LedgerJournalEngine_Server::createJournalOffsetBalance(ledgerJournalTable);
        }

        this.custVendCashDiscCache(true, _ledgerJournalTrans);

        if (_deleteTrans)
        {
            return;
        }

        [debit, credit] = this.taxDiffDebitCredit();
        [debitReportingCurrency, creditReportingCurrency] = this.taxDiffDebitCredit();

        tmpVoucherSum.Voucher = _ledgerJournalTrans.Voucher;
        if (!voucherBalance.find(tmpVoucherSum))
        {
            tmpVoucherSum = LedgerJournalEngine_Server::createVoucherBalance(_ledgerJournalTrans.Voucher,
                                                                             ledgerJournalTable.JournalNum);
            debit += tmpVoucherSum.Debit;
            credit += tmpVoucherSum.Credit;

            debitReportingCurrency += tmpVoucherSum.DebitReportingCurrency;
            creditReportingCurrency += tmpVoucherSum.CreditReportingCurrency;
        }
        else
        {
            if (_ledgerJournalTrans.AmountCurDebit)
            {
                debit  += _ledgerJournalTrans.calcDebitMST(true, ledgerJournalTable);
                debitReportingCurrency  += _ledgerJournalTrans.calcDebitReportingCurrency(true, ledgerJournalTable);
            }

            if (_ledgerJournalTrans.AmountCurCredit)
            {
                credit += _ledgerJournalTrans.calcCreditMST(true, ledgerJournalTable);
                creditReportingCurrency += _ledgerJournalTrans.calcCreditReportingCurrency(true, ledgerJournalTable);
            }

            if (_ledgerJournalTrans.parmOffsetLedgerDimension())
            {
                if (_ledgerJournalTrans.AmountCurDebit)
                {
                    credit += _ledgerJournalTrans.calcDebitMST(true, ledgerJournalTable);
                    creditReportingCurrency += _ledgerJournalTrans.calcDebitReportingCurrency(true, ledgerJournalTable);
                }

                if (_ledgerJournalTrans.AmountCurCredit)
                {
                    debit  += _ledgerJournalTrans.calcCreditMST(true, ledgerJournalTable);
                    debitReportingCurrency  += _ledgerJournalTrans.calcCreditReportingCurrency(true, ledgerJournalTable);
                }
            }
            else
            {
                tmpVoucherSum.SumCur += _ledgerJournalTrans.AmountCurDebit - _ledgerJournalTrans.AmountCurCredit;
            }

            tmpVoucherSum.Debit  += debit;
            tmpVoucherSum.Credit += credit;
            tmpVoucherSum.DebitReportingCurrency  += debitReportingCurrency;
            tmpVoucherSum.CreditReportingCurrency += creditReportingCurrency;
        }

        voucherBalance.ins(tmpVoucherSum, true);

        journalTotalDebit   = journalTotalDebit  + debit;
        journalTotalCredit  = journalTotalCredit + credit;
        journalTotalBalance = journalTotalDebit  - journalTotalCredit;

        journalTotalDebitReportingCurrency   = journalTotalDebitReportingCurrency  + debitReportingCurrency;
        journalTotalCreditReportingCurrency  = journalTotalCredit + creditReportingCurrency;
        journalTotalBalanceReportingCurrency = journalTotalDebitReportingCurrency  - journalTotalCreditReportingCurrency;
        // Reset information about adjustment of the voucher date
        pos = conFind(voucherDateCorrect,_ledgerJournalTrans.Voucher);
        if (!pos)
        {
            voucherDateCorrect += [_ledgerJournalTrans.Voucher, NoYes::No];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePaymentFee</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates payment fees and calls research on the data source of the payment fee line data source.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <param name="_custVendPaymJournalFee">
    ///    A <c>CustVendPaymJournalFee</c> record buffer.
    /// </param>
    public void updatePaymentFee(LedgerJournalTrans     _ledgerJournalTrans,
                                 CustVendPaymJournalFee _custVendPaymJournalFee)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>useHistoricalRemittanceAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the remittance address stored in the table should be used or the current date
    /// effective value of the address should be used for this ledger journal transaction type.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true when the remittance A resource record ID on the table should be used; false when the current
    /// date effective should be used.
    /// </returns>
    /// <remarks>
    /// This method is called from the display remittance address on this class.
    /// </remarks>
    protected boolean useHistoricalRemittanceAddress(LedgerJournalTrans _ledgerJournalTrans)
    {
        //If the status of the journal is posted use the historical address
        return LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).Posted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatData_updateVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the date of VAT register for the rest voucher lines.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record.
    /// </param>
    [SysObsolete('This method is replaced by method vatData_updateVoucher_PL and vatData_updateVoucher_NonPL', false, 02\06\2022)]
    public void vatData_updateVoucher(LedgerJournalTrans _ledgerJournalTrans)
    {
        this.vatData_updateVoucher_PL(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatData_updateVoucher_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the date of VAT register for the rest voucher lines for PL based on user's decision.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record.
    /// </param>
    public void vatData_updateVoucher_PL(LedgerJournalTrans _ledgerJournalTrans)
    {
        #ISOCountryRegionCodes

        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            return;
        }

        if (this.existsVATDataChange_PL(_ledgerJournalTrans)
            && Box::yesNo("@GLS110093", DialogButton::Yes, "@GLS110094") == DialogButton::Yes)
        {
            this.updateVATDataInJournal(_ledgerJournalTrans);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>existsVATDataChange_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether there is any VAT data change for the <c>LedgerJournalTrans</c> record for Poland.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true if there is VAT data change; otherwise, false.
    /// </returns>
    private boolean existsVATDataChange_PL(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean existsVATDataChange_PL;
        vatDataModified_PL = (_ledgerJournalTrans.orig().Invoice != _ledgerJournalTrans.Invoice
            || _ledgerJournalTrans.orig().DocumentDate != _ledgerJournalTrans.DocumentDate
            || _ledgerJournalTrans.orig().VatDueDate_W != _ledgerJournalTrans.VatDueDate_W
            || _ledgerJournalTrans.orig().vatNumJournal != _ledgerJournalTrans.vatNumJournal
            || _ledgerJournalTrans.orig().CustVendName_PL != _ledgerJournalTrans.CustVendName_PL
            || _ledgerJournalTrans.orig().Addressing_PL != _ledgerJournalTrans.Addressing_PL
            || _ledgerJournalTrans.orig().TaxPeriodPaymentCode_PL != _ledgerJournalTrans.TaxPeriodPaymentCode_PL);
        vatDataModified = vatDataModified_PL;

        if (vatDataModified && !this.isJournalWithLineForTax(_ledgerJournalTrans))
        {
            vatDataModified = false;
            vatDataModified_PL = false;
        }

        existsVATDataChange_PL = vatDataModified && _ledgerJournalTrans.linesQty_PL();
        return existsVATDataChange_PL;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatData_updateVoucher_NonPL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the date of VAT register for the rest voucher lines for Non-PL based on user's decision.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_origLedgerJournalTrans">
    /// The original version of <c>LedgerJournalTrans</c> record.
    /// </param>
    public void vatData_updateVoucher_NonPL(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans _origLedgerJournalTrans)
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            return;
        }

        if (this.existsVATDataChange_NonPL(_ledgerJournalTrans, _origLedgerJournalTrans)
            && Box::yesNo(strFmt("@TaxVATDueDate:UpdateVATDueDateInJournal", _ledgerJournalTrans.VatDueDate_W), DialogButton::Yes, "@GLS110094") == DialogButton::Yes)
        {
            this.updateVATDataInJournal(_ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsVATDataChange_NonPL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether there is any VAT data change for the <c>LedgerJournalTrans</c> record for countries except Poland.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_origLedgerJournalTrans">
    /// The origin version of <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true if there is VAT data change; otherwise, false.
    /// </returns>
    private boolean existsVATDataChange_NonPL(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans _origLedgerJournalTrans)
    {
        boolean existsVATDataChange_NonPL;
        boolean isLineWithTax = (_ledgerJournalTrans.TaxGroup && _ledgerJournalTrans.TaxItemGroup) || (_ledgerJournalTrans.TaxCode);
        vatDataModified = (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
            && TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled()
            && isLineWithTax
            && ((_origLedgerJournalTrans.VatDueDate_W != _ledgerJournalTrans.VatDueDate_W)
                || (_origLedgerJournalTrans.TaxGroup != _ledgerJournalTrans.TaxGroup)
                || (_origLedgerJournalTrans.TaxItemGroup != _ledgerJournalTrans.TaxItemGroup)
                || (_origLedgerJournalTrans.TaxCode != _ledgerJournalTrans.TaxCode))
            && _ledgerJournalTrans.existsVATDueDateDiffInJournal();

        if (vatDataModified && !this.isJournalWithLineForTax(_ledgerJournalTrans))
        {
            vatDataModified = false;
        }

        existsVATDataChange_NonPL = vatDataModified && _ledgerJournalTrans.linesQty_PL();
        return existsVATDataChange_NonPL;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isJournalWithLineForTax</Name>
				<Source><![CDATA[
    private boolean isJournalWithLineForTax(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans tmpTrans;
        select firstonly RecId from tmpTrans
            where tmpTrans.JournalNum == _ledgerJournalTrans.JournalNum
                && tmpTrans.Voucher == _ledgerJournalTrans.Voucher
                && (tmpTrans.TaxCode || (tmpTrans.TaxGroup && tmpTrans.TaxItemGroup));
        return (tmpTrans.RecId > 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVATDataInJournal</Name>
				<Source><![CDATA[
    private void updateVATDataInJournal(LedgerJournalTrans _ledgerJournalTrans)
    {
        ttsbegin;
        LedgerJournalTrans tmpTrans;
        LedgerJournalTransTaxExtension taxExtension = _ledgerJournalTrans.ledgerJournalTransTaxExtension();

        while select forupdate reverse tmpTrans
            where tmpTrans.JournalNum == _ledgerJournalTrans.JournalNum
                && tmpTrans.Voucher == _ledgerJournalTrans.Voucher
                && tmpTrans.LineNum != _ledgerJournalTrans.LineNum
        {
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
            {
                if (_ledgerJournalTrans.orig().VatDueDate_W != _ledgerJournalTrans.VatDueDate_W)
                {
                    tmpTrans.VatDueDate_W = _ledgerJournalTrans.VatDueDate_W;
                }

                if (_ledgerJournalTrans.orig().Invoice != _ledgerJournalTrans.Invoice)
                {
                    tmpTrans.Invoice = _ledgerJournalTrans.Invoice;
                }

                if (_ledgerJournalTrans.orig().DocumentDate != _ledgerJournalTrans.DocumentDate)
                {
                    tmpTrans.DocumentDate = _ledgerJournalTrans.DocumentDate;
                }

                if (_ledgerJournalTrans.orig().vatNumJournal != _ledgerJournalTrans.vatNumJournal)
                {
                    LedgerJournalTransTaxExtension tmpLedgerJournalTransTaxExtension = tmpTrans.ledgerJournalTransTaxExtension();
                    tmpTrans.vatNumJournal = _ledgerJournalTrans.vatNumJournal;
                    tmpLedgerJournalTransTaxExtension.VATNumRecId = taxExtension.VATNumRecId;
                    tmpLedgerJournalTransTaxExtension.VATNumTableType = taxExtension.VATNumTableType;
                    tmpTrans.packExtensionTable(tmpLedgerJournalTransTaxExtension);
                }

                if (_ledgerJournalTrans.orig().CustVendName_PL != _ledgerJournalTrans.CustVendName_PL)
                {
                    tmpTrans.CustVendAccount_PL = _ledgerJournalTrans.CustVendAccount_PL;
                }

                if (_ledgerJournalTrans.orig().CustVendName_PL != _ledgerJournalTrans.CustVendName_PL)
                {
                    tmpTrans.CustVendName_PL = _ledgerJournalTrans.CustVendName_PL;
                }

                if (_ledgerJournalTrans.orig().Addressing_PL != _ledgerJournalTrans.Addressing_PL)
                {
                    tmpTrans.Addressing_PL = _ledgerJournalTrans.Addressing_PL;
                }

                if (_ledgerJournalTrans.orig().TaxPeriodPaymentCode_PL != _ledgerJournalTrans.TaxPeriodPaymentCode_PL)
                {
                    tmpTrans.TaxPeriodPaymentCode_PL = _ledgerJournalTrans.TaxPeriodPaymentCode_PL;
                }
            }
            else
            {
                tmpTrans.VatDueDate_W = _ledgerJournalTrans.VatDueDate_W;
            }

            tmpTrans.update();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voucherAmountBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the voucher totals balance.
    /// </summary>
    /// <param name="_currencyCode">
    /// A currency code. If it differs from company currency, the method examines the maximum enabled
    /// rounding difference.
    /// </param>
    /// <returns>
    /// true if the voucher total balances; otherwise, false.
    /// </returns>
    boolean voucherAmountBalances(CurrencyCode _currencyCode)
    {
        if (_currencyCode && _currencyCode != companyCurrency)
        {
            AmountMST maxRoundingDifferenceAccountingCurrency = this.maximumRoundingDifferenceInAccountingCurrency(
                LedgerParameters::find(),
                this.parmLedgerJournalTable().JournalNum);

            return LedgerJournalEngine::isVoucherAmountsInBalanceForMultiCurrency(maxRoundingDifferenceAccountingCurrency, voucherTotalBalance, voucherTotalDebit, voucherTotalCredit);
        }
        else
        {
            return LedgerJournalEngine::isVoucherAmountsInBalance(0, voucherTotalBalance, voucherTotalDebit, voucherTotalCredit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>voucherCredit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the total credit MST amount for the voucher of the supplied <c>LedgerJournalTrans</c> record buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer
    /// </param>
    /// <returns>
    ///    The total credit MST amount of the voucher.
    /// </returns>
    public AmountMST voucherCredit(LedgerJournalTrans _ledgerJournalTrans)
    {
        this.voucherTotals(_ledgerJournalTrans);
        return voucherTotalCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voucherDebit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the total debit MST amount for the voucher of the supplied <c>LedgerJournalTrans</c> record buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <returns>
    ///    The total debit MST amount of the voucher.
    /// </returns>
    public AmountMST voucherDebit(LedgerJournalTrans _ledgerJournalTrans)
    {
        this.voucherTotals(_ledgerJournalTrans);
        return voucherTotalDebit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voucherCreditReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total credit reporting currency amount for the voucher of the supplied <c>LedgerJournalTrans</c> record buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record buffer
    /// </param>
    /// <returns>
    /// The total credit reporting currency amount of the voucher.
    /// </returns>
    public AmountMSTSecondary voucherCreditReportingCurrency(LedgerJournalTrans _ledgerJournalTrans)
    {
        this.voucherTotals(_ledgerJournalTrans);
        return voucherTotalCreditReportingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voucherDebitReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total debit reporting currency amount for the voucher of the supplied <c>LedgerJournalTrans</c> record buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <returns>
    /// The total debit reporting currency amount of the voucher.
    /// </returns>
    public AmountMSTSecondary voucherDebitReportingCurrency(LedgerJournalTrans _ledgerJournalTrans)
    {
        this.voucherTotals(_ledgerJournalTrans);
        return voucherTotalDebitReportingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateVoucherTotalsFromTmpVoucherSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the voucher totals based on totals by voucher.
    /// </summary>
    /// <param name = "_tmpVoucherSum">
    /// Totals by voucher table record.
    /// </param>
    protected void populateVoucherTotalsFromTmpVoucherSum(TmpVoucherSum _tmpVoucherSum)
    {
        voucherTotalDebit       = _tmpVoucherSum.Debit;
        voucherTotalCredit      = _tmpVoucherSum.Credit;
        voucherTotalBalance     = voucherTotalDebit - voucherTotalCredit;
        voucherTotalBalanceCur  = _tmpVoucherSum.SumCur;

        voucherTotalDebitReportingCurrency   = _tmpVoucherSum.DebitReportingCurrency;
        voucherTotalCreditReportingCurrency  = _tmpVoucherSum.CreditReportingCurrency;
        voucherTotalBalanceReportingCurrency = voucherTotalDebitReportingCurrency - voucherTotalCreditReportingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voucherTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the voucher totals and the journal totals.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_reread">
    /// Determines if the voucher balances should be refreshed; optional.
    /// </param>
    /// <returns>
    /// true if the voucher balances are refreshed; otherwise, false.
    /// </returns>
    public boolean voucherTotals(LedgerJournalTrans _ledgerJournalTrans, boolean _reread = false)
    {
        boolean         reread;
        TmpVoucherSum   tmpVoucherSum;

        if (_ledgerJournalTrans.RecId == 0 || (_ledgerJournalTrans.JournalNum != ledgerJournalTable.JournalNum))
        {
            return false;
        }

        tmpVoucherSum.Voucher = _ledgerJournalTrans.Voucher;

        if (!voucherBalance.find(tmpVoucherSum) || _reread)
        {
            reread          = true;
            tmpVoucherSum   = LedgerJournalEngine_Server::createVoucherBalance(_ledgerJournalTrans.Voucher,
                                                                              ledgerJournalTable.JournalNum);

            voucherBalance.ins(tmpVoucherSum, true);
        }

        this.populateVoucherTotalsFromTmpVoucherSum(tmpVoucherSum);

        // If the journal is unposted and the LedgerJournalTable fields JournalTotalDebit or JournalTotalCredit
        // have been populated, force recalculation of the journal totals.
        if (!ledgerJournalTable.Posted &&
           (ledgerJournalTable.JournalTotalDebit || ledgerJournalTable.JournalTotalCredit) &&
           (ledgerJournalTable.JournalTotalCredit != this.journalTotalCredit ||
            ledgerJournalTable.JournalTotalDebit != this.journalTotalDebit ||
            ledgerJournalTable.journalTotalOffsetBalance != this.journalTotalOffsetBalance))
        {
            this.ledgerJournalTableUpdateTotals(ledgerJournalTable, true);
        }

        return reread;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voucherTypeUpdate_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates voucher type.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaction.
    /// </param>
    public void voucherTypeUpdate_CN(LedgerJournalTrans _ledgerJournalTrans)
    {
        RefRecId        numberSequenceTableRecId;
        RefRecId        oldNumberSequenceTableRecId;
        NumberSeq       numberSeq;
        Voucher_CN      existingVoucher_CN = _ledgerJournalTrans.Voucher_CN;

        if (_ledgerJournalTrans.LedgerVoucherType_CN == ledgerVoucherTypeRecId
            && _ledgerJournalTrans.Voucher_CN)
        {
            return;
        }

        if (ledgerJournalTable.VoucherAllocatedAtPosting)
        {
            ledgerVoucherTypeRecId = _ledgerJournalTrans.LedgerVoucherType_CN;
            return;
        }

        if (LedgerJournalName::find(ledgerJournalTable.JournalName).NewVoucher == NewVoucher::Manually && !isSimpleMethod)
        {
            if (_ledgerJournalTrans.LedgerVoucherType_CN != ledgerVoucherTypeRecId && _ledgerJournalTrans.Voucher_CN)
            {
                _ledgerJournalTrans.Voucher_CN = '';
                ledgerJournalTrans_ds.refresh();
            }
            ledgerVoucherTypeRecId = _ledgerJournalTrans.LedgerVoucherType_CN;
            return;
        }

        if (_ledgerJournalTrans.LedgerVoucherType_CN)
        {
            ttsbegin;
            numberSequenceTableRecId = LedgerVoucherType_CN::find(_ledgerJournalTrans.LedgerVoucherType_CN).NumberSequenceTable;

            if (numberSequenceTableRecId != 0)
            {
                numberSeq = NumberSeq_Voucher_CN::newGetVoucherFromCode(numberSequenceTableRecId, _ledgerJournalTrans.TransDate);
            }

            if (numberSeq)
            {
                _ledgerJournalTrans.Voucher_CN = numberSeq.voucher();
            }
            ttscommit;
        }
        else
        {
            _ledgerJournalTrans.Voucher_CN = '';
        }

        if (ledgerVoucherTypeRecId && existingVoucher_CN)
        {
            oldNumberSequenceTableRecId = LedgerVoucherType_CN::find(ledgerVoucherTypeRecId).NumberSequenceTable;
            NumberSeq_Voucher_CN::release(oldNumberSequenceTableRecId, existingVoucher_CN, _ledgerJournalTrans.TransDate);
        }

        ledgerVoucherTypeRecId = _ledgerJournalTrans.LedgerVoucherType_CN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>write</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the internal caches for journal and voucher tables and refreshes the data source of the supplied <c>LedgerJournalTrans</c> record buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer
    /// </param>
    /// <param name="_updateCashDisc">
    ///    A Boolean flag that determines whether the cash discount of the journal line was manually entered; optional.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">A <c>LedgerJournalTrans_Asset</c> record buffer.</param>
    /// <param name="_ledgerJournalTrans_RDeferrals">
    ///    A <c>LedgerJournalTrans_RDeferrals</c> record buffer
    /// </param>
    /// <param name="_ledgerJournalTrans_RCash">
    ///    A <c>LedgerJournalTrans_RCash</c> record buffer
    /// </param>
    /// <remarks>
    ///    This method must be called from the <c>LedgerJournalTrans</c> data source of the journal form method <c>write()</c> after <c>super().</c>
    /// </remarks>
    public void write(LedgerJournalTrans            _ledgerJournalTrans,
                      boolean                       _updateCashDisc                 = false,
                      LedgerJournalTrans_Asset      _ledgerJournalTrans_Asset       = null,
                      LedgerJournalTrans_RDeferrals _ledgerJournalTrans_RDeferrals  = null,
                      LedgerJournalTrans_RCash      _ledgerJournalTrans_RCash       = null)
    {
        // <GEEU>
        LedgerJournalTrans ledgerJournalTransLocal;
        // </GEEU>

        initValueCalled = false;

        if (writeInsert ||
            ledgerJournalTransOrig.Voucher          != _ledgerJournalTrans.Voucher          ||
            ledgerJournalTransOrig.TransDate        != _ledgerJournalTrans.TransDate        ||
            ledgerJournalTransOrig.ReverseDate      != _ledgerJournalTrans.ReverseDate      ||
            ledgerJournalTransOrig.ReverseEntry     != _ledgerJournalTrans.ReverseEntry     ||
            ledgerJournalTransOrig.CurrencyCode     != _ledgerJournalTrans.CurrencyCode     ||
            ledgerJournalTransOrig.Triangulation    != _ledgerJournalTrans.Triangulation    ||
            ledgerJournalTransOrig.ExchRate         != _ledgerJournalTrans.ExchRate         ||
            ledgerJournalTransOrig.ExchRateSecond   != _ledgerJournalTrans.ExchRateSecond   ||
            ledgerJournalTransOrig.ReportingCurrencyExchRate != _ledgerJournalTrans.ReportingCurrencyExchRate ||
            ledgerJournalTransOrig.ReportingCurrencyExchRateSecondary != _ledgerJournalTrans.ReportingCurrencyExchRateSecondary ||
            ledgerJournalTransOrig.parmOffsetLedgerDimension()    != _ledgerJournalTrans.parmOffsetLedgerDimension()    ||
            ledgerJournalTransOrig.AmountCurCredit  != _ledgerJournalTrans.AmountCurCredit  ||
            ledgerJournalTransOrig.AmountCurDebit   != _ledgerJournalTrans.AmountCurDebit   ||
            this.taxChanged(_ledgerJournalTrans))
        {
            // <GEERU><GEEU>
            if (RCashParameters::isCashModuleEnabled())
            {
                this.updateInternalContainers(_ledgerJournalTrans, false, _ledgerJournalTrans_RCash);
            }
            else
            {
                // </GEERU></GEEU>
                this.updateInternalContainers(_ledgerJournalTrans);
                // <GEERU><GEEU>
            }
            // </GEERU></GEEU>
        }

        if (ledgerJournalCashDiscService
            && ledgerJournalCashDiscService.invoiceId()
            && _ledgerJournalTrans.haveTaxesChanged(ledgerJournalTransOrig))
        {
            this.updateCashDisc(_ledgerJournalTrans, _updateCashDisc);
        }

        if (!ledgerJournalTable)
        {
            ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();
        }

        boolean isCashDiscDeductedBeforeTaxCalculation = TaxIntegrationTaxJurisdictionParameters::shouldCashDiscDeductedBeforeTaxCalc(_ledgerJournalTrans);
        if (_updateCashDisc && isCashDiscDeductedBeforeTaxCalculation &&
            !TaxUncommitted::existByDocumentAndInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice))
        {
            // calculate taxes because they were deleted when the cash discount was modified
            LedgerJournalTrans::getTaxInstance(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice, true, null, false, _ledgerJournalTrans.TransDate);
        }
        else if (ledgerJournalTransOrig.Invoice != _ledgerJournalTrans.Invoice
            && LedgerJournalTrans::existForVoucherInvoice(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher, ledgerJournalTransOrig.Invoice))
        {
            // calculate taxes for the original invoice ID because it is still used and all taxes were removed
            LedgerJournalTrans::getTaxInstance(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher, ledgerJournalTransOrig.Invoice, true, null, false, _ledgerJournalTrans.TransDate);
        }

        this.adjustLedgerJournalTrans(_ledgerJournalTrans);
        this.voucherTotals(_ledgerJournalTrans, true);
        this.updateFeeLedgerTrans(_ledgerJournalTrans);

        oldAccountNum         = _ledgerJournalTrans.parmAccount();
        oldVoucher            = _ledgerJournalTrans.Voucher;
        voucherAmountBalances = this.voucherAmountBalances(_ledgerJournalTrans.CurrencyCode);
        curVoucher            = _ledgerJournalTrans.Voucher;
        currentRecId          = _ledgerJournalTrans.RecId;

        this.ledgerJournalTableUpdateTotals(ledgerJournalTable, true);
        correctedTaxAmountCurrentLine = 0;

        if (voucherAmountBalances)
        {
            LedgerJournalTrans ledgerJournalTransCompanyCheck;

            select firstonly RecId from ledgerJournalTransCompanyCheck
                where ledgerJournalTransCompanyCheck.JournalNum == _ledgerJournalTrans.JournalNum
                    && ledgerJournalTransCompanyCheck.Voucher == _ledgerJournalTrans.Voucher
                    && (ledgerJournalTransCompanyCheck.Company == curExt()
                    || (ledgerJournalTransCompanyCheck.OffsetLedgerDimension && ledgerJournalTransCompanyCheck.OffsetCompany == curExt()));

            if (!ledgerJournalTransCompanyCheck)
            {
                warning(strFmt("@GeneralLedger:UnableToPostVoucherNoCurrentCompanyWithVoucher", _ledgerJournalTrans.Voucher));
            }
        }

        if (writeInsert || _ledgerJournalTrans.isBudgetCheckRequiredForUpdate(ledgerJournalTransOrig))
        {
            // Since budget checking can take place with line entry disabled, an existing budget source might have already been created.
            if (_ledgerJournalTrans.isNewBudgetSourceRequired(ledgerJournalTransOrig))
            {
                ledgerJournalTransOrig.removeBudget();
            }

            if (LedgerJournalTableType::isBudgetCheckRequiredAtLineItemEntry(
                    ledgerJournalTable.JournalType,
                    _ledgerJournalTrans.company()))
            {
                // Checks budget funds availability for the new journal line ledger accounts and amounts.
                _ledgerJournalTrans.checkBudget();
            }
        }

        if (ledgerJournalTrans_ds && !this.rereadWhenDirty(_ledgerJournalTrans))
        {
            // When the check budget at line is enabled for daily journals, need to run ledgerJournalTrans_ds research
            // method in order to avoild update conflict error.
            if (BudgetCheckLineEntryLedgerJournalResearchFlight::instance().isEnabled() &&
                LedgerJournalTableType::isBudgetCheckRequiredAtLineItemEntry(ledgerJournalTable.JournalType, _ledgerJournalTrans.company()))
            {
                ledgerJournalTrans_ds.research(true);
            }
            else
            {
                // This reread and refresh is a part of existing flow and should not be removed as a part of BudgetCheckLineEntryLedgerJournalEditFlight removal.
                ledgerJournalTrans_ds.reread();
                ledgerJournalTrans_ds.refresh();
            }
        }

        if (vatDataModified)
        {
            ledgerJournalTransLocal.data(_ledgerJournalTrans);
            ledgerJournalTrans_ds.executeQuery();
            vatDataModified = false;
            vatDataModified_PL = false;
        }

        // <GCN>
        if (ledgerJournalTrans_ds
            && LedgerParameters::isChineseVoucher_CN())
        {
            ledgerJournalTrans_ds.research(true);
        }
        // </GCN>

        // Removes the original budget check result from the cache for the voucher to allow the cache update after budget check occurs.
        // This must be done after the form_ds has refreshed since the budget check will not happen until the outermost tts commits.
        this.removeBudgetCheckResultFromCache(_ledgerJournalTrans.Voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountTypeValid</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the account type and offset account type based on the journal type.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table record being referenced.
    /// </param>
    /// <param name="_ledgerJournalTable">
    ///    The <c>LedgerJournalTable</c> table record being referenced.
    /// </param>
    /// <returns>
    ///    true if the account type is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method is called from the <c>validateField</c> method on the <c>LedgerJournalTrans</c> table.
    ///    It determines whether the account type is valid for the passed in journal type, offset account type
    ///    and account type.
    /// </remarks>
    public static boolean accountTypeValid(LedgerJournalTrans _ledgerJournalTrans,
                                           LedgerJournalTable _ledgerJournalTable)
    {
        boolean isValid = true;

        switch (_ledgerJournalTable.JournalType)
        {
            case LedgerJournalType::Cost:
                // The account type and offset account type cannot be be FixedAssets for
                // these Journal Types.
                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets ||
                   _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets)
                {
                    isValid = false;
                }
                break;

            // <GEERU>
            case LedgerJournalType::Assets_RU:
            case LedgerJournalType::AssetBudgets_RU:
            case LedgerJournalType::RDeferrals:
                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project
                    || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
                {
                    isValid = false;
                }
                break;
            // </GEERU>
            case LedgerJournalType::Assets,
                LedgerJournalType::AssetBudgets,
                LedgerJournalType::Netting:
                // The account type and offset account type cannot be be Project for
                // these Journal Types.
                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project ||
                   _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
                {
                    isValid = false;
                }
                break;

            case LedgerJournalType::CustPayment:
                if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
                {
                    isValid = false;
                }
                if (isValid &&
                    FeatureStateProvider::isFeatureEnabled(PaymentJournalAccountTypeValidateFeature::instance()) &&
                    (_ledgerJournalTrans.AccountType != LedgerJournalACType::Cust ||
                    _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust))
                {
                    isValid = false;
                }
                break;

            case LedgerJournalType::Payment:
                if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
                {
                    isValid = false;
                }
                if (isValid &&
                    FeatureStateProvider::isFeatureEnabled(PaymentJournalAccountTypeValidateFeature::instance()))
                {
                    if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
                    {
                        isValid = false;
                    }
                    else if (_ledgerJournalTrans.AccountType != LedgerJournalACType::Vend)
                    {
                        if (!_ledgerJournalTrans.supportsGenerateBankOrLedgerCheck(_ledgerJournalTable) ||
                            (_ledgerJournalTrans.AccountType != LedgerJournalACType::Ledger &&
                             _ledgerJournalTrans.AccountType != LedgerJournalACType::Bank))
                        {
                            isValid = false;
                        }
                    }
                }
                break;

            case LedgerJournalType::PayrollDisbursement:
                if (_ledgerJournalTrans.AccountType != LedgerJournalACType::Vend ||
                   _ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Bank )
                {
                    isValid = false;
                }
                break;

            case LedgerJournalType::VendPromissoryNoteDraw,
                LedgerJournalType::VendPromissoryNoteRedraw,
                LedgerJournalType::VendPromissoryNoteSettle,
                LedgerJournalType::VendPaymRemittance,
                LedgerJournalType::CustBillOfExchangeAccept,
                LedgerJournalType::CustBillOfExchangeDraw,
                LedgerJournalType::CustBillOfExchangeProtest,
                LedgerJournalType::CustBillOfExchangeRedraw,
                LedgerJournalType::CustBillOfExchangeSettle:
                // The account type and offset account type cannot be be FixedAssets or Project for
                // these Journal Types.
                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project ||
                   _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project ||
                   _ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets ||
                   _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets)
                {
                    isValid = false;
                }
                break;

            default:
                break;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static LedgerJournalEngine construct(LedgerJournalType   _ledgerJournalType = LedgerJournalType::None,
                                                FormRun             _formRun = null)
    {
        LedgerJournalEngine     ledgerJournalEngine;

        switch (_ledgerJournalType)
        {
            case LedgerJournalType::Allocation :
                ledgerJournalEngine = new LedgerJournalEngine_Allocation(_formRun);
                break;

            case LedgerJournalType::Approval :
                ledgerJournalEngine = new LedgerJournalEngine_VendApprove(_formRun);
                break;

            case LedgerJournalType::AssetBudgets :
                ledgerJournalEngine = new LedgerJournalEngine_AssetBudgets(_formRun);
                break;

            case LedgerJournalType::Assets :
                ledgerJournalEngine = new LedgerJournalEngine_AssetDepreciation(_formRun);
                break;

            case LedgerJournalType::Cost :
                ledgerJournalEngine = new LedgerJournalEngine_ProjectCost(_formRun);
                break;

            case LedgerJournalType::CustBillOfExchangeDraw,
                 LedgerJournalType::CustBillOfExchangeProtest,
                 LedgerJournalType::CustBillOfExchangeRedraw,
                 LedgerJournalType::CustPaymRemittance,
                 LedgerJournalType::CustBillOfExchangeSettle :
                ledgerJournalEngine = LedgerJournalEngine_CustBillOfExchange::construct(_formRun, _ledgerJournalType);
                break;

            case LedgerJournalType::CustPayment :
                ledgerJournalEngine = new LedgerJournalEngine_CustPayment(_formRun);
                break;

            case LedgerJournalType::Daily :
                ledgerJournalEngine = LedgerJournalEngine_Daily::construct(_formRun);
                break;

            case LedgerJournalType::Elimination :
                ledgerJournalEngine = new LedgerJournalEngine_Elimination(_formRun);
                break;

            case LedgerJournalType::Payment :
                ledgerJournalEngine = new LedgerJournalEngine_VendPayment(_formRun);
                break;

            case LedgerJournalType::PurchaseLedger :
                ledgerJournalEngine = new LedgerJournalEngine_VendInvoiceRegister(_formRun);
                break;

            case LedgerJournalType::VendInvoice :
                ledgerJournalEngine = new LedgerJournalEngine_VendInvoice(_formRun);
                break;

            case LedgerJournalType::VendPromissoryNoteDraw :
            case LedgerJournalType::VendPromissoryNoteRedraw :
            case LedgerJournalType::VendPaymRemittance :
            case LedgerJournalType::VendPromissoryNoteSettle :
                ledgerJournalEngine = LedgerJournalEngine_VendPromissoryNote::construct(_formRun, _ledgerJournalType);
                break;

            // <GEERU>
            case LedgerJournalType::Assets_RU :
                ledgerJournalEngine = new LedgerJournalEngine_AssetDepreciation_ru(_formRun);
                break;
            case LedgerJournalType::AssetBudgets_RU :
                ledgerJournalEngine = new LedgerJournalEngine_AssetBudgets_ru(_formRun);
                break;
            
            case LedgerJournalType::RCash :
                ledgerJournalEngine = new LedgerJournalEngine_RCash(_formRun);
                break;
            // </GEERU>

            case LedgerJournalType::PayrollDisbursement :
                ledgerJournalEngine = new LedgerJournalEngine_PayrollDisbursement(_formRun);
                break;

            case LedgerJournalType::Netting :
                ledgerJournalEngine = new LedgerJournalEngine_Netting(_formRun);
                break;

            case LedgerJournalType::ReportingCurrencyAdjustment :
                ledgerJournalEngine = new LedgerJournalEngine_ReportingCurrencyAdjustment(_formRun);
                break;

            case LedgerJournalType::None :
            // fall through to default

            default :
                ledgerJournalEngine = new LedgerJournalEngine(_formRun);
        }

        return ledgerJournalEngine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDefsForAssetBookTableDerivedJourn</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the initial derived journal records for the given transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer that defines part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table buffer that defines part of the transaction.
    /// </param>
    /// <remarks>
    ///    Deletes existing derived journal records that would overlap with the journal records that are to be
    ///    created.
    /// </remarks>
    public static void createDefsForAssetBookTableDerivedJourn(LedgerJournalTrans       _ledgerJournalTrans,
                                                               LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        AssetBook                       assetBook;
        AssetBookTableDerived           assetBookTableDerivedFieldList;
        AssetBookTableDerivedJournal    assetBookTableDerivedJournal;
        Amount                          amount;
        Amount                          amountReporting;
        AssetTransType                  assetTransType = AssetPost::assetTransTypeJournal2AssetTransType(_ledgerJournalTrans_Asset.TransType
                                                            // <GJP>
                                                            , _ledgerJournalTrans_Asset.DocumentType_JP
                                                            // </GJP>
                                                            );
        container                       assetCompany;

        // <GEELT>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLT])
            && _ledgerJournalTrans.ledgerJournalTable().AssetTransferType_LT == LtAssetTransferType::TransferJour)
        {
            return;
        }
        // </GEELT>

        if (_ledgerJournalTrans.Company != '')
        {
            assetCompany += _ledgerJournalTrans.Company;
        }

        // As Posting calls this method we need to make sure we check the primary account type first.
        // The reason for this is that posting shifts the offset field values into the primary fields
        // when posting the offset account.  But it does not clear the offset account type field and
        // this caused problems when posting a transactions with Fixed Assets as an offset.

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
        {
            amount  = _ledgerJournalTrans.amount();
        }
        else
        {
            amount  = - _ledgerJournalTrans.amount();
        }

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets
            && (_ledgerJournalTrans_Asset.isDepreciationTransactionType()
                || (FeatureStateProvider::isFeatureEnabled(AssetSplitReportingCurrencyFeature::instance())
                    && _ledgerJournalTrans_Asset.isSplitTransaction())))
        {
            amountReporting = _ledgerJournalTrans_Asset.amountReportingCurrency();
        }
        else
        {
            amountReporting = - _ledgerJournalTrans_Asset.amountReportingCurrency();
        }
        // Delete existing derived journal records.
        delete_from assetBookTableDerivedJournal
            where assetBookTableDerivedJournal.RefRecId == _ledgerJournalTrans.RecId;

        while select crosscompany:assetCompany BookIdDerived from assetBookTableDerivedFieldList
            where assetBookTableDerivedFieldList.BookId         == _ledgerJournalTrans_Asset.BookId
               && assetBookTableDerivedFieldList.AssetTransType == assetTransType
            join AcquisitionPrice from assetBook
            where assetBook.AssetId == _ledgerJournalTrans_Asset.AssetId
               && assetBook.BookId  == assetBookTableDerivedFieldList.BookIdDerived
        {
            assetBookTableDerivedJournal.AssetBookId    = assetBookTableDerivedFieldList.BookIdDerived;
            assetBookTableDerivedJournal.RefRecId       = _ledgerJournalTrans.RecId;
            assetBookTableDerivedJournal.AmountCur      = amount;
            assetBookTableDerivedJournal.ReportingCurrencyAmount = amountReporting;
            assetBookTableDerivedJournal.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillAssetBookTableDerivedJournal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fill <c>AssetDepBookTableDerivedJour</c> from <c>LedgerJournalTrans</c> buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> buffer.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    /// A <c>LedgerJournalTrans_Asset</c> buffer.
    /// </param>
    /// <param name="_assetBookId">
    /// The asset book id of the asset.
    /// </param>
    public static void fillAssetBookTableDerivedJournal_IN(LedgerJournalTrans        _ledgerJournalTrans,
                                                                  LedgerJournalTrans_Asset  _ledgerJournalTrans_Asset,
                                                                  AssetBookId               _assetBookId = "")
    {
        AssetBook                       assetBook;
        AssetBookTableDerived           assetBookTableDerivedFieldList;
        AssetBookTableDerivedJournal    assetBookTableDerivedJournal;
        Amount                          amount;
        AssetTransType                  assetTransType = AssetPost::assetTransTypeJournal2AssetTransType(_ledgerJournalTrans_Asset.TransType);

        // As Posting calls this method we need to make sure we check the primary account type first.
        // The reason for this is that posting shifts the offset field values into the primary fields
        // when posting the offset account.  But it does not clear the offset account type field and
        // this caused problems when posting a transactions with Fixed Assets as an offset.
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
        {
            amount  = _ledgerJournalTrans.amount();
        }
        else
        {
            amount  = - _ledgerJournalTrans.amount();
        }

        // Delete existing derived journal records.
        delete_from assetBookTableDerivedJournal
            where assetBookTableDerivedJournal.RefRecId == _ledgerJournalTrans.RecId;

        while select BookIdDerived from assetBookTableDerivedFieldList
            where assetBookTableDerivedFieldList.BookId         == _ledgerJournalTrans_Asset.BookId
               && assetBookTableDerivedFieldList.AssetTransType == assetTransType
        exists join assetBook
            where assetBook.AssetId == _ledgerJournalTrans_Asset.AssetId
               && assetBook.BookId  == _assetBookId
        {
            assetBookTableDerivedJournal.AssetBookId    = assetBookTableDerivedFieldList.BookIdDerived;
            assetBookTableDerivedJournal.RefRecId       = _ledgerJournalTrans.RecId;
            assetBookTableDerivedJournal.AmountCur      = amount;
            assetBookTableDerivedJournal.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillAssetGroupBookTableDerivedJournal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the initial derived journal records for the given transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> table buffer defining part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    /// The <c>LedgerJournalTrans_Asset</c> table buffer defining part of the transaction.
    /// </param>
    public static void fillAssetGroupBookTableDerivedJournal_IN(LedgerJournalTrans       _ledgerJournalTrans,
                                                                       LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        AssetBook                       assetBook;
        AssetBookTableDerived           assetBookTableDerivedFieldList;
        AssetBookTableDerivedJournal    assetBookTableDerivedJournal;
        Amount                          amount;
        AssetTransType                  assetTransType = AssetPost::assetTransTypeJournal2AssetTransType(_ledgerJournalTrans_Asset.TransType);

        // As Posting calls this method we need to make sure we check the primary account type first.
        // The reason for this is that posting shifts the offset field values into the primary fields
        // when posting the offset account.  But it does not clear the offset account type field and
        // this caused problems when posting a transactions with Fixed Assets as an offset.
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
        {
            amount  = _ledgerJournalTrans.amount();
        }
        else
        {
            amount  = - _ledgerJournalTrans.amount();
        }

        // Delete existing derived journal records.
        delete_from assetBookTableDerivedJournal
            where assetBookTableDerivedJournal.RefRecId == _ledgerJournalTrans.RecId;

        while select BookIdDerived from assetBookTableDerivedFieldList
            where assetBookTableDerivedFieldList.BookId         == _ledgerJournalTrans_Asset.BookId
               && assetBookTableDerivedFieldList.AssetTransType == assetTransType
            exists join assetBook
                where assetBook.AssetGroup                  == _ledgerJournalTrans_Asset.AssetGroup_IN
                   && assetBook.BookId                      == assetBookTableDerivedFieldList.BookIdDerived
                   && assetBook.AssetGroupDepreciation_IN   == NoYes::Yes
        {
            assetBookTableDerivedJournal.AssetBookId    = assetBookTableDerivedFieldList.BookIdDerived;
            assetBookTableDerivedJournal.RefRecId       = _ledgerJournalTrans.RecId;
            assetBookTableDerivedJournal.AmountCur      = amount;
            assetBookTableDerivedJournal.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the default dimension that is based on the account number and the account type of the
    ///    transaction.
    /// </summary>
    /// <param name="_accountNum">
    ///    The account number on the transaction.
    /// </param>
    /// <param name="_accountCompany">
    ///    The company of the transaction.
    /// </param>
    /// <param name="_accountType">
    ///    The account type of the transaction.
    /// </param>
    /// <param name="_assetBookId">
    /// The Asset book ID of the transaction.
    /// </param>
    /// <param name="_rAssetStandardId">
    /// The Asset standard ID of the transaction.
    /// </param>
    /// <param name="_transDate">
    /// The date of the transaction.
    /// </param>
    /// <param name="_rDeferralsBookId">
    /// The defferal book id  of the transaction.
    /// </param>
    /// <returns>
    /// A default dimension for the account number.
    /// </returns>
    public static DimensionDefault getAccountDefaultDimension(
        LedgerJournalAC     _accountNum,
        CompanyId           _accountCompany,
        LedgerJournalACType _accountType,
        AssetBookIdPurchSalesInvent _assetBookId = '',
        RAssetStandardId            _rAssetStandardId = '',
        TransDate                   _transDate = dateNull(),
        RDeferralsBookId            _rDeferralsBookId = ''
        )
    {
        DimensionDefault defaultDimension;
        EmployeeTable_RU employeeTable_RU;

        if (_accountNum == '')
        {
            return defaultDimension;
        }

        changecompany(_accountCompany)
        {
            switch (_accountType)
            {
                case LedgerJournalACType::Bank :
                    defaultDimension = BankAccountTable::find(_accountNum).DefaultDimension;
                    break;

                case LedgerJournalACType::Cust :
                    defaultDimension = CustTable::find(_accountNum).DefaultDimension;
                    break;

                case LedgerJournalACType::Vend :
                    defaultDimension = VendTable::find(_accountNum).DefaultDimension;
                    break;

                case LedgerJournalACType::FixedAssets :
                    defaultDimension = AssetTable::find(_accountNum).defaultDimension(_assetBookId);
                    break;

                case LedgerJournalACType::Project :
                    defaultDimension = ProjTable::find(_accountNum).DefaultDimension;
                    break;

                // <GEERU>
                case LedgerJournalACType::FixedAssets_RU :
                    defaultDimension = RAssetStandards::find(_accountNum, _rAssetStandardId).defaultDimension(_transDate);
                    break;
                case LedgerJournalACType::RDeferrals :
                    defaultDimension = RDeferralsBook::find(_accountNum, _rDeferralsBookId).DefaultDimension;
                    break;
                case LedgerJournalACType::Employee_RU :
                    employeeTable_RU = EmployeeTable_RU::findByEmployeeId(_accountNum);
                    defaultDimension = HcmEmployment::find(employeeTable_RU.HcmEmployment).DefaultDimension;
                    break;
                // </GEERU>
            }
        }

        return defaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultAccount</Name>
				<Source><![CDATA[
    public static LedgerDimensionDefaultAccount getDefaultAccount(
        LedgerJournalTrans          _ledgerJournalTrans,
        LedgerJournalTrans_Asset      _ledgerJournalTrans_Asset,
        LedgerJournalTrans_RAsset     _ledgerJournalTrans_RAsset     = null,
        LedgerJournalTrans_RDeferrals _ledgerJournalTrans_RDeferrals = null
        )
    {
        ProjTable                       projTable;
        LedgerDimensionDefaultAccount   defaultAccount;
        MainAccountRecId                mainAccountId;

        switch (_ledgerJournalTrans.AccountType)
        {
            case LedgerJournalACType::Ledger :
                mainAccountId = LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(_ledgerJournalTrans.LedgerDimension);
                defaultAccount = LedgerDefaultAccountHelper::getDefaultAccountFromMainAccountRecId(mainAccountId);
                break;

            case LedgerJournalACType::Project :
                projTable = ProjTable::findByLedgerDimension(_ledgerJournalTrans.parmLedgerDimension());
                if (ProjRevRecHelper::getCostLedgerStatus(projTable) == ProjLedgerStatus::Operations)
                {
                    defaultAccount = ProjTrans::newLedgerJournalTrans(_ledgerJournalTrans).costAccountLedgerDimension(0, false);
                }
                else
                {
                    defaultAccount = ProjTrans::newLedgerJournalTrans(_ledgerJournalTrans).statusAccountLedgerDimension(0);
                }
                break;

            case LedgerJournalACType::FixedAssets :
                // The asset defined by _ledgerJournalTrans.AccountNum exists in the company defined by _ledgerJournalTrans.Company so perform
                // a change company before doing the account lookup.
                changecompany (_ledgerJournalTrans.Company)
                {
                    defaultAccount = AssetTable::findByLedgerDimension(_ledgerJournalTrans.parmLedgerDimension()).assetLedgerDimension(_ledgerJournalTrans.PostingProfile,
                                    AssetPost::assetTransTypeJournal2AssetTransType(_ledgerJournalTrans_Asset.TransType
                                        // <GJP>
                                        , _ledgerJournalTrans_Asset.DocumentType_JP
                                        // </GJP>
                                        ),_ledgerJournalTrans_Asset.BookId);
                }
                break;
            // <GEERU>
            case LedgerJournalACType::FixedAssets_RU:
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                {
                    defaultAccount = RAssetStandards::find(_ledgerJournalTrans.parmAccount(), _ledgerJournalTrans_RAsset.StandardId)
                        .assetLedgerDimension(_ledgerJournalTrans_RAsset.StandardId, _ledgerJournalTrans.PostingProfile, _ledgerJournalTrans_RAsset.TransType);
                }
                break;
            case LedgerJournalACType::RDeferrals:
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                {
                    defaultAccount = RDeferralsLedgerAccounts::deferralsLedgerDim(_ledgerJournalTrans.parmAccount(),
                                                                 _ledgerJournalTrans_RDeferrals.TransType,
                                                                 _ledgerJournalTrans_RDeferrals.BookId,
                                                                 _ledgerJournalTrans.PostingProfile);
                }
                break;
            // </GEERU>
            default :
                defaultAccount = 0;
        }

        return defaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastDate_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets last date of the ledger journal transaction.
    /// </summary>
    /// <returns>
    /// The end date.
    /// </returns>
    public static EndDate getLastDate_CN()
    {
        LedgerJournalTrans ledgerJournalTrans;

        select firstonly maxof(TransDate)
            from ledgerJournalTrans;

        return ledgerJournalTrans.TransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDefaultDimensionServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs a <c>DimensionDefault</c> record for the <c>DefaultDimension</c> field of the specified
    ///    transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer to store a part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table buffer to store a part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_RAsset">
    /// The <c>LedgerJournalTrans_RAsset</c> table buffer storing part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_RDeferrals">
    /// The <c>LedgerJournalTrans_RDeferrals</c> table buffer storing part of the transaction.
    /// </param>
    /// <returns>
    ///    The <c>DimensionDefault</c> value for the default dimension field of the specified transaction.
    /// </returns>
    public static DimensionDefault initDefaultDimensionServer(
        LedgerJournalTrans        _ledgerJournalTrans,
        LedgerJournalTrans_Asset      _ledgerJournalTrans_Asset      = null,
        LedgerJournalTrans_RAsset     _ledgerJournalTrans_RAsset     = null,
        LedgerJournalTrans_RDeferrals _ledgerJournalTrans_RDeferrals = null)
    {
        LedgerJournalTable  ledgerJournalTableLocal;
        DimensionDefault    journalHeaderDefaultDimension;
        DimensionDefault    accountDefaultDimension;

        if (!LedgerJournalEngine::canInitializePrimaryDefaultDimensions(_ledgerJournalTrans))
        {
            return 0;
        }

        changecompany(_ledgerJournalTrans.Company)
        {
            // Get dimensions from journal header
            ledgerJournalTableLocal = _ledgerJournalTrans.ledgerJournalTable();
            if (_ledgerJournalTrans.Company == ledgerJournalTableLocal.company())
            {
                journalHeaderDefaultDimension = ledgerJournalTableLocal.DefaultDimension;
            }
            else
            {
                LedgerInterCompany ledgerInterCompany = LedgerInterCompany::findCompanyPair(_ledgerJournalTrans.Company, ledgerJournalTableLocal.company());
                journalHeaderDefaultDimension = LedgerJournalName::find(ledgerInterCompany.JournalName).DefaultDimension;
            }

            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
                && _ledgerJournalTrans.AccountAgreementId_RU)
            {
                accountDefaultDimension = _ledgerJournalTrans.DefaultDimension;
            }
            else
            {
                // </GEERU>
                // Get dimensions based on account number
                accountDefaultDimension = LedgerJournalEngine::getAccountDefaultDimension(_ledgerJournalTrans.parmAccount(),
                        _ledgerJournalTrans.Company,
                        _ledgerJournalTrans.AccountType,
                        _ledgerJournalTrans_Asset.BookId,
                        _ledgerJournalTrans_RAsset.StandardId,
                        _ledgerJournalTrans.TransDate,
                        _ledgerJournalTrans_RDeferrals.BookId);
            }

            // Merge default dimensions
            if (journalHeaderDefaultDimension && accountDefaultDimension)
            {
                return LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(journalHeaderDefaultDimension, accountDefaultDimension);
            }
            else
            {
                return journalHeaderDefaultDimension ? journalHeaderDefaultDimension : accountDefaultDimension;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOffsetDefaultDimensionServer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a <c>DimensionDefault</c> value for the <c>OffsetDefaultDimension</c> field of the
    /// specified transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> table buffer to store a part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    /// The <c>LedgerJournalTrans_Asset</c> table buffer to store a part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_RAsset">
    /// The <c>LedgerJournalTrans_RAsset</c> table buffer that stores a part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_RDeferrals">
    /// The <c>LedgerJournalTrans_RDeferrals</c> table buffer that stores a part of the transaction.
    /// </param>
    /// <returns>
    /// The <c>DimensionDefault</c> value for the offset default dimension field of the specified
    /// transaction.
    /// </returns>
    private static DimensionDefault initOffsetDefaultDimensionServer(
        LedgerJournalTrans        _ledgerJournalTrans,
        LedgerJournalTrans_Asset  _ledgerJournalTrans_Asset = null,
        LedgerJournalTrans_RAsset _ledgerJournalTrans_RAsset = null,
        LedgerJournalTrans_RDeferrals _ledgerJournalTrans_RDeferrals = null
        )
    {
        DimensionDefault    defaultDimension;
        List                dimensionSources;
        // <GEERU>
        Map                 dimSpec;
        RecId               dimAttrRecId;
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        if (!LedgerJournalEngine::canInitializeOffsetDefaultDimensions(_ledgerJournalTrans))
        {
            return 0;
        }

        CompanyId offsetCompanyId = _ledgerJournalTrans.getOffsetCompany();
        changecompany(offsetCompanyId)
        {
            DimensionDefault journalHeaderDefaultDimension;
            LedgerJournalTable ledgerJournalTableLocal = _ledgerJournalTrans.ledgerJournalTable();

            if (_ledgerJournalTrans.OffsetCompany == ledgerJournalTableLocal.company())
            {
                journalHeaderDefaultDimension = ledgerJournalTableLocal.DefaultDimension;
            }
            else
            {
                LedgerInterCompany ledgerInterCompany = LedgerInterCompany::findCompanyPair(_ledgerJournalTrans.OffsetCompany, ledgerJournalTableLocal.company());
                journalHeaderDefaultDimension = LedgerJournalName::find(ledgerInterCompany.JournalName).DefaultDimension;
            }

            // Get dimensions from primary account
            dimensionSources = new List(Types::Class);
            if (_ledgerJournalTrans.Company == offsetCompanyId)
            {
                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
                {
                    // <GEERU>
                    if (countryRegion_RU
                        && (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust
                            || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend
                            || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project))
                    {
                        dimSpec = LedgerDimensionDefaultingEngine::getLedgerDimensionSpecifiers(_ledgerJournalTrans.LedgerDimension, true);
                        dimAttrRecId = AgreementHeaderExt_RU::getAgreementDimensionAttribute();
                        if (dimAttrRecId)
                        {
                            dimSpec.remove(dimAttrRecId);
                        }
                        dimensionSources.addEnd(dimSpec);
                    }
                    else
                    {
                        // </GEERU>
                        dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getLedgerDimensionSpecifiers(_ledgerJournalTrans.LedgerDimension, true));
                        // <GEERU>
                    }
                    // </GEERU>
                }
                else
                {
                    // <GEERU>
                    if (countryRegion_RU
                        && (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust
                            || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend
                            || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project))
                    {
                        dimSpec = LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(_ledgerJournalTrans.DefaultDimension);
                        dimAttrRecId = AgreementHeaderExt_RU::getAgreementDimensionAttribute();
                        if (dimAttrRecId)
                        {
                            dimSpec.remove(dimAttrRecId);
                        }
                        dimensionSources.addEnd(dimSpec);
                    }
                    else
                    {
                        // </GEERU>
                        dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(_ledgerJournalTrans.DefaultDimension));
                        // <GEERU>
                    }
                    // </GEERU>
                }
            }

            // <GEERU>
            if (countryRegion_RU)
            {
                // dimension based on account number
                dimensionSources.addEnd(
                    LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(_ledgerJournalTrans.OffsetAccountAgreementId_RU ? _ledgerJournalTrans.OffsetDefaultDimension : LedgerJournalEngine::getAccountDefaultDimension(_ledgerJournalTrans.parmOffsetAccount(), offsetCompanyId, _ledgerJournalTrans.OffsetAccountType, _ledgerJournalTrans_Asset.BookId, _ledgerJournalTrans_RAsset.StandardId, _ledgerJournalTrans.TransDate, _ledgerJournalTrans_RDeferrals.BookId)));
            }
            else
            {
                // </GEERU>
                // Get dimensions based on account number
                dimensionSources.addEnd(
                    LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(LedgerJournalEngine::getAccountDefaultDimension(_ledgerJournalTrans.parmOffsetAccount(), offsetCompanyId, _ledgerJournalTrans.OffsetAccountType, _ledgerJournalTrans_Asset.BookId)));
                // <GEERU>
            }
            // </GEERU>

            defaultDimension = LedgerDimensionDefaultingEngine::getDefaultDimension(dimensionSources);

            if (journalHeaderDefaultDimension && defaultDimension)
            {
                defaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(journalHeaderDefaultDimension, defaultDimension);
            }
            else
            {
                defaultDimension = journalHeaderDefaultDimension ? journalHeaderDefaultDimension : defaultDimension;
            }

            return defaultDimension;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInitializeOffsetDefaultDimensions</Name>
				<Source><![CDATA[
    private static boolean canInitializeOffsetDefaultDimensions(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ret = true;

       if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger
            || !_ledgerJournalTrans.parmOffsetAccount())
       {
           ret = false; 
       }

       return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInitializePrimaryDefaultDimensions</Name>
				<Source><![CDATA[
    private static boolean canInitializePrimaryDefaultDimensions(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ret = true;

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupPostingProfileForAccountType</Name>
				<Source><![CDATA[
    public static void lookupPostingProfileForAccountType(FormStringControl _stringControl, str _filterStr, LedgerJournalTrans _ledgerJournalTrans)
    {
        switch (_ledgerJournalTrans.AccountType)
        {
            case LedgerJournalACType::Cust:
                CustLedger::lookupPostingProfile(_stringControl, _filterStr, _ledgerJournalTrans.Company);
                break;

            case LedgerJournalACType::FixedAssets:
                AssetLedger::lookupPostingProfile(_stringControl, _filterStr, _ledgerJournalTrans.Company);
                break;

            case LedgerJournalACType::Vend:
                VendLedger::lookupPostingProfile(_stringControl, _filterStr, _ledgerJournalTrans.Company);
                break;

            // <GEERU>
            case LedgerJournalACType::Employee_RU:
                EmplLedger_RU::lookupPostingProfile(_stringControl, _filterStr, _ledgerJournalTrans.Company);
                break;

            case LedgerJournalACType::RCash:
                RCashLedger::lookupProfile(_stringControl, _ledgerJournalTrans.Company);
                break;
            // </GEERU>
            default:
                // not supported, do nothing
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupPostingProfileForAccTypeOffset_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays lookup for offset posting profile.
    /// </summary>
    /// <param name="_stringControl">
    /// Caller string control.
    /// </param>
    /// <param name="_filterStr">
    /// Filter string.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// Current ledger journal line.
    /// </param>
    public static void lookupPostingProfileForAccTypeOffset_RU(
        FormStringControl   _stringControl,
        str                 _filterStr,
        LedgerJournalTrans  _ledgerJournalTrans)
    {
        LedgerJournalTrans offsetLedgerJournalTrans;

        offsetLedgerJournalTrans.AccountType = _ledgerJournalTrans.OffsetAccountType;
        offsetLedgerJournalTrans.Company     = _ledgerJournalTrans.OffsetCompany;

        LedgerJournalEngine::lookupPostingProfileForAccountType(_stringControl, _filterStr, offsetLedgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetLedgerDimension_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// gets the offset ledger dimension of journal line
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> table record
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    /// The <c>LedgerJournalTrans_Asset</c> table record
    /// </param>
    /// <param name="_ledgerJournalTrans_RAsset">
    /// The <c>LedgerJournalTrans_RAsset</c> table buffer storing part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_RDeferrals">
    /// The <c>LedgerJournalTrans_RDeferrals</c> table buffer storing part of the transaction.
    /// </param>
    /// <returns>
    /// the offset ledger dimension
    /// </returns>
    public static LedgerDimensionDefaultAccount offsetLedgerDimension_RU(
        LedgerJournalTrans            _ledgerJournalTrans,
        LedgerJournalTrans_Asset      _ledgerJournalTrans_Asset,
        LedgerJournalTrans_RAsset     _ledgerJournalTrans_RAsset,
        LedgerJournalTrans_RDeferrals _ledgerJournalTrans_RDeferrals)
    {
        LedgerDimensionDefaultAccount   ledgerDimension;
        LedgerJournalTrans              ledgerJournalTrans;

        switch (_ledgerJournalTrans.OffsetAccountType)
        {
            case LedgerJournalACType::Ledger :
                ledgerDimension = _ledgerJournalTrans.parmOffsetLedgerDimension();
                break;
            case LedgerJournalACType::Project :
                ledgerJournalTrans            = _ledgerJournalTrans.data();

                ledgerJournalTrans.parmAccount(ledgerJournalTrans.parmOffsetAccount(), ledgerJournalTrans.OffsetAccountType);

                if (ProjRevRecHelper::getCostLedgerStatus(ProjTable::findByLedgerDimension(_ledgerJournalTrans.parmOffsetLedgerDimension())) == ProjLedgerStatus::Operations)
                {
                    ledgerDimension = ProjTrans::newLedgerJournalTrans(_ledgerJournalTrans).costAccountLedgerDimension(0, false);
                }
                else
                {
                    ledgerDimension = ProjTrans::newLedgerJournalTrans(_ledgerJournalTrans).statusAccountLedgerDimension(0);
                }
                break;
            case LedgerJournalACType::FixedAssets :
                ledgerDimension = AssetTable::findByLedgerDimension(_ledgerJournalTrans.parmOffsetLedgerDimension()).assetLedgerDimension(_ledgerJournalTrans.PostingProfile,
                                    AssetPost::assetTransTypeJournal2AssetTransType(_ledgerJournalTrans_Asset.TransType),_ledgerJournalTrans_Asset.BookId);
                break;
            case LedgerJournalACType::FixedAssets_RU :
                ledgerDimension = RAssetStandards::find(_ledgerJournalTrans.parmOffsetAccount(),
                    _ledgerJournalTrans_RAsset.StandardId).assetLedgerDimension(_ledgerJournalTrans_RAsset.StandardId, _ledgerJournalTrans.PostingProfile, _ledgerJournalTrans_RAsset.TransType);
                break;
            case LedgerJournalACType::RDeferrals:
                ledgerDimension = RDeferralsLedgerAccounts::deferralsLedgerDim(_ledgerJournalTrans.parmOffsetAccount(),
                                                                 _ledgerJournalTrans_RDeferrals.TransType,
                                                                 _ledgerJournalTrans_RDeferrals.BookId,
                                                                 _ledgerJournalTrans.PostingProfile);

                break;
            default :
                ledgerDimension = 0;
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjCostSalesPrice</Name>
				<Source><![CDATA[
    public static void setProjCostSalesPrice(
            LedgerJournalTrans          _ledgerJournalTrans,
            LedgerJournalTrans_Project  _ledgerJournalTrans_Project,
            SalesPrice                  _salesPrice,
            boolean                     _getDefaultCost = false,
            boolean                     _getDefaultSales = false)
    {
        CostPrice                                   costPriceMST;
        ProjId                                      projId;
        boolean                                     priceFound;
        ProjBudgetTransaction                       projBudgetTransaction;
        ProjBudgetTransactionManager                projBudgetTransactionManager;
        ProjBudgetTransactionLine_ExpenseJournal    projBudgetTransactionLine;
        AmountCur                                   totalTaxAmount;
        AmountCur                                   useTaxAmountInTotalTax;

        if ((_ledgerJournalTrans.AccountType == LedgerJournalACType::Project ||
            (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project && _ledgerJournalTrans.parmOffsetLedgerDimension())))
        {
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project)
            {
                projId = _ledgerJournalTrans.parmAccount();
            }
            else
            {
                projId = _ledgerJournalTrans.parmOffsetAccount();
            }

            costPriceMST = ProjCostSalesPrice::costPrice(_ledgerJournalTrans, _ledgerJournalTrans_Project, _getDefaultCost);

            totalTaxAmount = LedgerJournalTrans_Project::findTotalTaxAmount(_ledgerJournalTrans);

            if (totalTaxAmount)
            {
                useTaxAmountInTotalTax = totalTaxAmount - _ledgerJournalTrans.totalTaxAmountSingleLine(false, false, true);
                costPriceMST += useTaxAmountInTotalTax;
            }

            // Find the sales price
            // If cost price is reset via getDefaultCost == TRUE, then reset sales price as well. Also when getDefaultSales == TRUE
            if (_getDefaultCost || _getDefaultSales)
            {
                SalesPrice originalSalesPrice = _ledgerJournalTrans_Project.SalesPrice;

                if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                {
                    ProjPriceParameters priceParams = ProjCostSalesPrice::constructPriceParametersForFindCostSalesPrice(
                        projId,
                        _ledgerJournalTrans_Project.Resource,
                        _ledgerJournalTrans_Project.CategoryId,
                        costPriceMST,
                        CompanyInfoHelper::standardCurrency(),
                        _ledgerJournalTrans_Project.SalesCurrencyId,
                        _ledgerJournalTrans_Project.ProjTransDate,
                        _ledgerJournalTrans_Project.ProjPriceGroupID);
                    [_ledgerJournalTrans_Project.SalesPrice, priceFound] = ProjCostSalesPrice::findCostSalesPriceByPriceParameters(priceParams, false);
                }
                else
                {
                    ProjPriceParameters priceParams = ProjCostSalesPrice::constructPriceParametersForFindCostSalesPrice(
                        projId,
                        _ledgerJournalTrans_Project.Resource,
                        _ledgerJournalTrans_Project.CategoryId,
                        costPriceMST,
                        CompanyInfoHelper::standardCurrency(),
                        _ledgerJournalTrans_Project.SalesCurrencyId,
                        _ledgerJournalTrans_Project.ProjTransDate);
                    [_ledgerJournalTrans_Project.SalesPrice, priceFound] = ProjCostSalesPrice::findCostSalesPriceByPriceParameters(priceParams);
                }

                if (!priceFound && _salesPrice)
                {
                    // If no combination found for the given category in cost price hour Table then the previous sales price is restored
                    _ledgerJournalTrans_Project.SalesPrice = _salesPrice;
                }

                if (_ledgerJournalTrans_Project.SalesPrice != originalSalesPrice)
                {
                    _ledgerJournalTrans_Project.updateAssessableValue_IN();
                }
            }

            if (ProjParameters::find().EnableBudgetCheckOnLineSave && _ledgerJournalTrans_Project.ProjId && _ledgerJournalTrans_Project.CategoryId)
            {
                projBudgetTransaction = new ProjBudgetTransaction();
                projBudgetTransactionLine = new ProjBudgetTransactionLine_ExpenseJournal(_ledgerJournalTrans_Project);
                projBudgetTransactionLine.parmLedgerJournalTrans(_ledgerJournalTrans);
                projBudgetTransaction.addBudgetTransactionLine(projBudgetTransactionLine);
                projBudgetTransactionManager = ProjBudgetTransactionManager::newProjBudgetTransactionManager(projBudgetTransaction);
                projBudgetTransactionManager.parmTrackBudgetStatus(true);
                projBudgetTransactionManager.parmSupressMessages(false);

                projBudgetTransactionManager.validateBudget();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTotalTaxes</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Displays the TaxTotals form.
    /// </summary>
    /// <param name="_ledgerJournalEngine">
    ///    A <c>LedgerJournalEngine</c> object.
    /// </param>
    public static void showTotalTaxes(LedgerJournalEngine _ledgerJournalEngine)
    {
        Args   args;

        args = new Args();
        args.caller(_ledgerJournalEngine);

        new MenuFunction(menuitemDisplayStr(TaxTotals), MenuItemType::Display).run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetBookTableDerivedJournals</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the derived journals when the amount on the ledger journal trans asset is entered/changed.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer that defines part of the transaction.
    /// </param>
    /// <remarks>
    ///    Updates the derived valuemodels journals.
    ///    created.
    /// </remarks>
    public static void updateAssetBookTableDerivedJournals(LedgerJournalTrans       _ledgerJournalTrans)
    {
        AssetBookTableDerivedJournal    assetBookTableDerivedJournal;
        Amount                          amount;

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
        {
            amount  = _ledgerJournalTrans.amount();
        }
        else
        {
            amount  = - _ledgerJournalTrans.amount();
        }

        update_recordset assetBookTableDerivedJournal
        setting AmountCur = amount
        where assetBookTableDerivedJournal.RefRecId == _ledgerJournalTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetBookTableDerivedJournalsReporting</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the derived journals when the amount on the ledger journal trans asset is entered/changed on reporting currency amount.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer that defines part of the transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table buffer that defines part of the transaction.
    /// </param>
    /// <remarks>
    ///    Updates the derived valuemodels journals.
    ///    created.
    /// </remarks>
    public static void updateAssetBookTableDerivedJournalsReporting(LedgerJournalTrans       _ledgerJournalTrans,
                                                             LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        AssetBookTableDerivedJournal    assetBookTableDerivedJournal;
        Amount                          amountReporting;

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets && _ledgerJournalTrans_Asset.isDepreciationTransactionType())
        {
            amountReporting = _ledgerJournalTrans_Asset.amountReportingCurrency();
        }
        else
        {
            amountReporting = - _ledgerJournalTrans_Asset.amountReportingCurrency();
        }

        update_recordset assetBookTableDerivedJournal
        setting ReportingCurrencyAmount = amountReporting
        where assetBookTableDerivedJournal.RefRecId == _ledgerJournalTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSegmentedEntryForFixedOffsetAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the segmented entry control for a fixed offset account.
    /// </summary>
    /// <param name = "_segmentedEntryControl">
    /// The segmented entry control.
    /// </param>
    /// <param name = "_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    public static void updateSegmentedEntryForFixedOffsetAccount(
        SegmentedEntryControl _segmentedEntryControl,
        LedgerJournalTable _ledgerJournalTable,
        LedgerJournalTrans _ledgerJournalTrans)
    {
        // The lock Main account segment logic only applies to account types of Ledger,
        // and should only be invoked for this account type.
        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
        {
            _segmentedEntryControl.parmLockMainAccountSegment(_ledgerJournalTable.FixedOffsetAccount);
        }

        _segmentedEntryControl.allowEdit(
            (_ledgerJournalTable.FixedOffsetAccount && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
            || !_ledgerJournalTable.FixedOffsetAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSegmentedEntryContext</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the context of the segmented entry control.
    /// </summary>
    /// <param name = "_segmentedEntryControl">
    /// The segmented entry control.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    public static void updateSegmentedEntryContext(
        SegmentedEntryControl _segmentedEntryControl,
        LedgerJournalTrans _ledgerJournalTrans)
    {
        _segmentedEntryControl.parmDataAreaId(_ledgerJournalTrans.Company);
        _segmentedEntryControl.parmControlDate(_ledgerJournalTrans.TransDate);
        _segmentedEntryControl.parmCurrency(_ledgerJournalTrans.CurrencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSegmentedEntryContextForOffset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the context of the offset segmented entry control.
    /// </summary>
    /// <param name = "_segmentedEntryControl">
    /// The segmented entry control.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    public static void updateSegmentedEntryContextForOffset(
        SegmentedEntryControl _segmentedEntryControl,
        LedgerJournalTrans _ledgerJournalTrans)
    {
        _segmentedEntryControl.parmDataAreaId(_ledgerJournalTrans.OffsetCompany);
        _segmentedEntryControl.parmControlDate(_ledgerJournalTrans.TransDate);
        _segmentedEntryControl.parmCurrency(_ledgerJournalTrans.CurrencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the ProjTransDate value with the TransDate value.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The buffer of <c>LedgerJournalTrans</c> table.
    /// </param>
    /// <param name="_ledgerJournalTrans_Project">
    /// The buffer of <c>LedgerJournalTrans_Project</c> table.
    /// </param>
    public void setProjTransDate(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans_Project _ledgerJournalTrans_Project)
    {
        if (_ledgerJournalTrans.TransDate != _ledgerJournalTrans_Project.ProjTransDate)
        {
            _ledgerJournalTrans_Project.ProjTransDate = _ledgerJournalTrans.TransDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineCashDiscountForEntities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the cash discount for entities.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTransUpdateOriginal">
    /// The original <c>LedgerJournalTrans</c> record that is used for update optimizations
    /// </param>
    public static void determineCashDiscountForEntities(LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTrans _ledgerJournalTransUpdateOriginal = null)
    {
        if (_ledgerJournalTransUpdateOriginal)
        {
            //update optimization check
            if (_ledgerJournalTrans.CashDiscCode == _ledgerJournalTransUpdateOriginal.CashDiscCode
                && _ledgerJournalTrans.CashDiscAmount == _ledgerJournalTransUpdateOriginal.CashDiscAmount
                && _ledgerJournalTrans.DateCashDisc == _ledgerJournalTransUpdateOriginal.DateCashDisc
               )
            {
                return;
            }
        }
        else
        {
            //insert optimization check
            if (!_ledgerJournalTrans.CashDiscCode
                && !_ledgerJournalTrans.CashDiscAmount
                && !_ledgerJournalTrans.DateCashDisc)
            {
                return;
            }
        }

        boolean isManualCashDiscDate;
        TransDate manualCashDiscDate;
        if (_ledgerJournalTrans.DateCashDisc)
        {
            manualCashDiscDate = _ledgerJournalTrans.DateCashDisc;
            isManualCashDiscDate = true;
        }

        boolean isManualCashDiscAmount;
        DiscAmount manualCashDiscAmount;
        if (_ledgerJournalTrans.CashDiscAmount)
        {
            manualCashDiscAmount = _ledgerJournalTrans.CashDiscAmount;
            isManualCashDiscAmount = true;
        }

        _ledgerJournalTrans.selectForUpdate(true);
        ttsbegin;

        LedgerJournalEngine_Server::calcCashDisc(_ledgerJournalTrans, 0, false);
        if (isManualCashDiscDate)
        {
            _ledgerJournalTrans.DateCashDisc = manualCashDiscDate;
        }

        if (isManualCashDiscAmount)
        {
            _ledgerJournalTrans.CashDiscAmount = manualCashDiscAmount;
        }

        _ledgerJournalTrans.update();

        if (isManualCashDiscAmount || isManualCashDiscDate)
        {
            LedgerJournalEngine_Server::updateCashDiscDetail(_ledgerJournalTrans, false);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVoucherAmountsInBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if voucher amount is blanced.
    /// </summary>
    /// <param name = "_maxRoundingDifference"> The maximum difference allowed in balance consideration </param>
    /// <param name = "_voucherTotalBalance"> The voucher amount based on voucher total credit and debit </param>
    /// <param name = "_voucherTotalDebit"> The amount of voucher debit </param>
    /// <param name = "_voucherTotalCredit"> The amount of voucher credit </param>
    /// <returns>True, if voucher is considered balanced; false, othewise. </returns>
    public static boolean isVoucherAmountsInBalance(
        AmountMST _maxRoundingDifference,
        AmountMST _voucherTotalBalance,
        AmountMST _voucherTotalDebit,
        AmountMST _voucherTotalCredit)
    {
        return abs(_voucherTotalBalance) <= _maxRoundingDifference && (_voucherTotalCredit != 0 || _voucherTotalDebit  != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVoucherAmountsInBalanceForMultiCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if voucher amount is balanced for when the currency code and accounting currency are different.
    /// </summary>
    /// <param name = "_maxRoundingDifference"> The maximum difference allowed in balance consideration. </param>
    /// <param name = "_voucherTotalBalance"> The voucher amount based on voucher total credit and debit. </param>
    /// <param name = "_voucherTotalDebit"> The amount of voucher debit. </param>
    /// <param name = "_voucherTotalCredit"> The amount of voucher credit. </param>
    /// <returns>True, if voucher is considered balanced; false, othewise. </returns>
    public static boolean isVoucherAmountsInBalanceForMultiCurrency(
        AmountMST _maxRoundingDifference,
        AmountMST _voucherTotalBalance,
        AmountMST _voucherTotalDebit,
        AmountMST _voucherTotalCredit)
    {
        return abs(_voucherTotalBalance) <= _maxRoundingDifference && (_voucherTotalCredit != 0 && _voucherTotalDebit != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxGroupModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Force recalculation of line amounts and cash discount since the tax amounts may not exist before the tax group buffer is written.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> table record being modified.
    /// </param>
    public void taxGroupModified(LedgerJournalTrans _ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateModified</Name>
				<Source><![CDATA[
    internal void exchRateModified(LedgerJournalTrans _ledgerJournalTrans)
    {
        switch (_ledgerJournalTrans.ledgerJournalTable().JournalType)
        {
            case LedgerJournalType::Payment,
                LedgerJournalType::CustPayment:
                this.updateCustVendPaymJournalFeeExchRate(_ledgerJournalTrans);
                break;
            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPaymentOrderBudgetTrans</Name>
				<Source><![CDATA[
    public static void initPaymentOrderBudgetTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        CFMAgreementPaymentOrder agreementPaymentOrder;

        changeCompany(_ledgerJournalTrans.Company)
        {
            switch (_ledgerJournalTrans.AccountType)
            {
                case LedgerJournalACType::Cust:
                    agreementPaymentOrder = CFMAgreementPaymentOrder::findByAgreement(SalesAgreementHeader::findAgreementId(_ledgerJournalTrans.AccountAgreementId_RU).RecId, SalesPurch::Sales);
                    break;

                case LedgerJournalACType::Vend:
                    agreementPaymentOrder = CFMAgreementPaymentOrder::findByAgreement(PurchAgreementHeader::findAgreementId(_ledgerJournalTrans.AccountAgreementId_RU).RecId, SalesPurch::Purch);
                    break;

                default:
                    throw error(Error::wrongUseOfFunction(funcName()));
            }
        }

        ttsBegin;

        PaymentOrderBudgetTrans_RU paymentOrderBudgetTrans = PaymentOrderBudgetTrans_RU::find(_ledgerJournalTrans.JournalNum,
            _ledgerJournalTrans.LineNum,
            _ledgerJournalTrans.Voucher,
            _ledgerJournalTrans.AccountType,
            _ledgerJournalTrans.TransDate, 
            true);

        if (paymentOrderBudgetTrans)
        {
            paymentOrderBudgetTrans.initFromAgreementPaymentOrder(agreementPaymentOrder);
            paymentOrderBudgetTrans.update();
        }
        else
        {
            paymentOrderBudgetTrans.JournalNum = _ledgerJournalTrans.JournalNum;
            paymentOrderBudgetTrans.JournalTransDate = _ledgerJournalTrans.TransDate;
            paymentOrderBudgetTrans.LedgerJournalACType = _ledgerJournalTrans.AccountType;
            paymentOrderBudgetTrans.Voucher = _ledgerJournalTrans.Voucher;
            paymentOrderBudgetTrans.LineNum = _ledgerJournalTrans.LineNum;
            paymentOrderBudgetTrans.initFromAgreementPaymentOrder(agreementPaymentOrder);
            paymentOrderBudgetTrans.insert();
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOverrideSalesTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the override sales tax on the journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> record.</param>
    protected void initOverrideSalesTax(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTransTaxExtension ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtension();

        //------------------------------------------------------------
        // Attempt to use the cached version of the method.
        //------------------------------------------------------------
        if (methodResultCache.contains(
            funcName(),
            this.getCachedVersionFromLedgerJournalTrans(_ledgerJournalTrans)))
        {
            [ledgerJournalTransTaxExt.OverrideSalesTax] = methodResultCache.get(funcName());

            return;
        }

        //------------------------------------------------------------
        // The result is not cached. Perform all calculations.
        //------------------------------------------------------------

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
        {
            ledgerJournalTransTaxExt.OverrideSalesTax =
                ledgerJournalTransTaxExt.OverrideSalesTax || this.findCustTable(_ledgerJournalTrans).OverrideSalesTax;
        }
        else if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
        {
            ledgerJournalTransTaxExt.OverrideSalesTax =
                ledgerJournalTransTaxExt.OverrideSalesTax || _ledgerJournalTrans.findVendTable().OverrideSalesTax;
        }
        else if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
        {
            ledgerJournalTransTaxExt.OverrideSalesTax =
                ledgerJournalTransTaxExt.OverrideSalesTax || this.findOffsetCustTable(_ledgerJournalTrans).OverrideSalesTax;
        }
        else if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
        {
            ledgerJournalTransTaxExt.OverrideSalesTax =
                ledgerJournalTransTaxExt.OverrideSalesTax || this.findOffsetVendTable(_ledgerJournalTrans).OverrideSalesTax;
        }

        //------------------------------------------------------------
        // Attempt to cache the results.
        //------------------------------------------------------------
        if (methodResultCache.isInScope())
        {
            methodResultCache.add(
                funcName(),
                this.getCachedVersionFromLedgerJournalTrans(_ledgerJournalTrans),
                [ledgerJournalTransTaxExt.OverrideSalesTax]);
        }

        _ledgerJournalTrans.packExtensionTable(ledgerJournalTransTaxExt);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCachedVersionFromLedgerJournalTrans</Name>
				<Source><![CDATA[
    private container getCachedVersionFromLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        return [_ledgerJournalTrans.AccountType,
            _ledgerJournalTrans.OffsetAccountType,
            _ledgerJournalTrans.LedgerDimension,
            _ledgerJournalTrans.OffsetLedgerDimension,
            _ledgerJournalTrans.Company,
            _ledgerJournalTrans.OffsetCompany,
            curext()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmActualTax</Name>
				<Source><![CDATA[
    public TaxAmountCur parmActualTax(TaxAmountCur _actualTaxAmount = actualTaxAmount)
    {
        actualTaxAmount = _actualTaxAmount;
        return actualTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustVendPaymJournalFeeExchRate</Name>
				<Source><![CDATA[
    private void updateCustVendPaymJournalFeeExchRate(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (CustVendPaymJournalFee::existRefRecId(_ledgerJournalTrans.RecId))
        {
            List paymFeeListToUpdate = CustVendPaymJournalFee::getPaymFeeListToUpdate(_ledgerJournalTrans.RecId, _ledgerJournalTrans.CurrencyCode);
            ListEnumerator enumerator = paymFeeListToUpdate.getEnumerator();
            while (enumerator.moveNext())
            {
                RefRecId refRecId = enumerator.current();
                LedgerJournalTrans ledgerJournalTransToUpdate = LedgerJournalTrans::findByRefAndDataArea(_ledgerJournalTrans.DataAreaId, refRecId, true);
                ledgerJournalTransToUpdate.ExchRate = _ledgerJournalTrans.ExchRate;
                ledgerJournalTransToUpdate.ExchRateSecond = _ledgerJournalTrans.ExchRateSecond;
                ledgerJournalTransToUpdate.ReportingCurrencyExchRate = _ledgerJournalTrans.ReportingCurrencyExchRate;
                ledgerJournalTransToUpdate.ReportingCurrencyExchRateSecondary = _ledgerJournalTrans.ReportingCurrencyExchRateSecondary;
                ttsbegin;
                ledgerJournalTransToUpdate.doUpdate();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCompanyChangeForFinTag</Name>
				<Source><![CDATA[
    private void handleCompanyChangeForFinTag(LedgerJournalTrans _ledgerJournalTrans, boolean _isOffset)
    {
        const FinTagRecId clearedFinTag = 0;

        if (_isOffset)
        {
            _ledgerJournalTrans.OffsetFinTag = clearedFinTag;
        }
        else
        {
            _ledgerJournalTrans.FinTag = clearedFinTag;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>