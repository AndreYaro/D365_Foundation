<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxIntgrExportDocumentSplitCalc_CN</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Interface for different calculation method of split. The split calculation will update
/// tmp results passed in.
/// </summary>
public class TaxIntgrExportDocumentSplitCalc_CN
{
    // this serves as copy of key data in source so there is no need to
    // query source data again after initialization
    // TaxIntgrExportDocumentSource_CN is used to store RecID of source line which should be noted
    // when used to create export document
    TaxIntgrExportDocTmp_CN     exportDocSourceCopy;
    Map                         exportDocSourceLineCopyMap;

    // store number of lines in the source
    int totalNumOfLines;
    // the number is unique id of the split document
    int numbering;

    // export document to be created
    TaxIntgrExportDocTmp_CN     exportDoc;
    TaxIntgrExportDocTmp_CN     newCreatedExportDoc;
    Map                         exportDocMap;
    TaxIntgrExportDocLineTmp_CN exportDocLine;
    Map                         exportDocLineMap;

    // used to store accumulated qty, amount, percent
    TaxIntgrExportDocTmp_CN     accumulatedExportDoc;
    Map                         accumulatedExportDocSourceLineCopyMap;

    // RefRecId export doc source.
    refRecId exportDocSourceId;

    // Whether amount of split document will be verified against the amount limit.
    boolean isCheckAmountLimit;

    // amount limit of the tax code
    real amountLimit;

    #define.CurrentVersion(2)
    #localmacro.CurrentList
        exportDocSourceId,
        isCheckAmountLimit,
        amountLimit
    #endmacro
    #define.PercentBase(100)
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkExportDocumentAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the export document amount.
    /// </summary>
    /// <param name="_amountCur">
    /// The amount of currency.
    /// </param>
    /// <returns>
    /// True if it passes the validation; otherwise, false.
    /// </returns>
    protected boolean checkExportDocumentAmount(AmountCur _amountCur)
    {
        boolean result = true;

        if (isCheckAmountLimit
            && this.isOverAmountLimit(_amountCur))
        {
            result = checkFailed("@SYS4002257");
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findExportDocByRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get reference of reference of tmp export document
    /// </summary>
    /// <param name="_recId">
    /// The tmp export document record id.
    /// </param>
    /// <returns>
    /// reference of tmp export document
    /// </returns>
    public TaxIntgrExportDocTmp_CN findExportDocByRecId(RefRecId _recId)
    {
        TaxIntgrExportDocTmp_CN exportDocLocal;

        exportDocLocal.setTmpData(exportDoc);
        select firstOnly exportDocLocal
            where exportDocLocal.RecId == _recId;

        return exportDocLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccumlatedExpDocSrcLineCopyMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a map with accumulated line records.
    /// </summary>
    /// <returns>
    /// A map with accumulated line records.
    /// </returns>
    public Map getAccumlatedExpDocSrcLineCopyMap()
    {
        return accumulatedExportDocSourceLineCopyMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAmountOfSplitByQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the amount split by the quantity.
    /// </summary>
    /// <param name="_splitLine">
    /// The split line.
    /// </param>
    /// <returns>
    /// a container with net amount and tax amount.
    /// </returns>
    public container getAmountOfSplitByQty(TaxIntgrExportDocLineTmp_CN _splitLine)
    {
        TaxIntgrExportDocLineTmp_CN     accumulatedExportDocLine;
        TaxIntgrExportDocLineTmp_CN     exportDocSourceLineCopy;
        AmountCur                       transactionCurrencyNetAmount;
        AmountCur                       transactionCurrencyTaxAmount;
        AmountCur transactionCurrencyMiscChargesNetAmount;
        AmountCur transactionCurrencyMiscChargesTaxAmount;

        accumulatedExportDocLine = accumulatedExportDocSourceLineCopyMap.lookup(_splitLine.TaxIntgrExportDocumentSourceLine_CN);
        exportDocSourceLineCopy = exportDocSourceLineCopyMap.lookup(_splitLine.TaxIntgrExportDocumentSourceLine_CN);
        if (_splitLine.Qty)
        {
            accumulatedExportDocLine.Qty += _splitLine.Qty;

            transactionCurrencyNetAmount = TaxIntgrUtility_CN::roundAmount(
                exportDocSourceLineCopy.TransactionCurrencyNetAmount / exportDocSourceLineCopy.Qty * accumulatedExportDocLine.Qty -
                accumulatedExportDocLine.TransactionCurrencyNetAmount);

            transactionCurrencyTaxAmount = TaxIntgrUtility_CN::roundAmount(
                exportDocSourceLineCopy.TransactionCurrencyTaxAmount / exportDocSourceLineCopy.Qty * accumulatedExportDocLine.Qty -
                accumulatedExportDocLine.TransactionCurrencyTaxAmount);

            transactionCurrencyMiscChargesNetAmount = TaxIntgrUtility_CN::roundAmount(
                exportDocSourceLineCopy.TransactionCurrencyMiscChargesNetAmount / exportDocSourceLineCopy.Qty * accumulatedExportDocLine.Qty -
                accumulatedExportDocLine.TransactionCurrencyMiscChargesNetAmount);
    
            transactionCurrencyMiscChargesTaxAmount = TaxIntgrUtility_CN::roundAmount(
                exportDocSourceLineCopy.TransactionCurrencyMiscChargesTaxAmount / exportDocSourceLineCopy.Qty * accumulatedExportDocLine.Qty -
                accumulatedExportDocLine.TransactionCurrencyMiscChargesTaxAmount);
        }

        return [transactionCurrencyNetAmount, transactionCurrencyTaxAmount, transactionCurrencyMiscChargesNetAmount, transactionCurrencyMiscChargesTaxAmount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingChargesNetAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the remaining charges net amount.
    /// </summary>
    /// <returns>
    /// The remaining charges net amount.
    /// </returns>
    /// <remarks>
    /// If there is no charges net amount left, 0 is returned.
    /// </remarks>
    public AmountCur getRemainingChargesNetAmount()
    {
        AmountCur result;
    
        if (abs(exportDocSourceCopy.MiscChargesNetAmount)
            > abs(accumulatedExportDoc.MiscChargesNetAmount))
        {
            result = exportDocSourceCopy.MiscChargesNetAmount
                - accumulatedExportDoc.MiscChargesNetAmount;
        }
    
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingChargesTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the remaining charges tax amount.
    /// </summary>
    /// <returns>
    /// The remaining charges tax amount.
    /// </returns>
    /// <remarks>
    /// If there is no charges tax amount left, 0 is returned.
    /// </remarks>
    public AmountCur getRemainingChargesTaxAmount()
    {
        AmountCur result;
    
        if (abs(exportDocSourceCopy.MiscChargesTaxAmount)
            > abs(accumulatedExportDoc.MiscChargesTaxAmount))
        {
            result = exportDocSourceCopy.MiscChargesTaxAmount
                - accumulatedExportDoc.MiscChargesTaxAmount;
        
        }
    
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExportDoc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get reference of reference of tmp export document
    /// </summary>
    /// <returns>
    /// reference of tmp export document
    /// </returns>
    public TaxIntgrExportDocTmp_CN getExportDoc()
    {
        return exportDoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExportDocMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets map with all the export document header and lines.
    /// </summary>
    /// <returns>
    /// A map with all the export document header and lines.
    /// </returns>
    public Map getExportDocMap()
    {
        return exportDocMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExportDocSourceCopy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the copy of the source.
    /// </summary>
    /// <returns>
    /// A tmp copy of source with essetial data for the split.
    /// </returns>
    protected TaxIntgrExportDocTmp_CN getExportDocSourceCopy()
    {
        return exportDocSourceCopy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExportDocSourceLineCopyMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a map with all original lines.
    /// </summary>
    /// <returns>
    /// A map with all original lines.
    /// </returns>
    public Map getExportDocSourceLineCopyMap()
    {
        return exportDocSourceLineCopyMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewCreatedExportDoc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets newly created export document data.
    /// </summary>
    /// <returns>
    /// The newly created export document data.
    /// </returns>
    public TaxIntgrExportDocTmp_CN getNewCreatedExportDoc()
    {
        return newCreatedExportDoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets next line number.
    /// </summary>
    /// <returns>
    /// The line number.
    /// </returns>
    private int getNextNumber()
    {
        numbering += 1;
        return numbering;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the remaining amount.
    /// </summary>
    /// <returns>
    /// The remaining amount.
    /// </returns>
    /// <remarks>
    /// If there is no amount left, 0 is returned.
    /// </remarks>
    public AmountCur getRemainingAmount()
    {
        AmountCur result;

        if (abs(exportDocSourceCopy.TransactionCurrencyAmount)
            > abs(accumulatedExportDoc.TransactionCurrencyAmount))
        {
            result = exportDocSourceCopy.TransactionCurrencyAmount
                        - accumulatedExportDoc.TransactionCurrencyAmount;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingPercent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the remaining percent.
    /// </summary>
    /// <returns>
    /// The remaining percent.
    /// </returns>
    public Percent getRemainingPercent()
    {
        Percent result;

        if (#PercentBase > accumulatedExportDoc.Percent)
        {
            result = #PercentBase - accumulatedExportDoc.Percent;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalNumOfLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets total number of lines in the invoice.
    /// </summary>
    /// <returns>
    /// total number of lines in the invoice
    /// </returns>
    public int getTotalNumOfLines()
    {
        return totalNumOfLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the instance.
    /// </summary>
    protected void initialize()
    {
        // document source
        TaxIntgrExportDocumentSource_CN     exportDocSource;
        TaxIntgrExportDocumentSourceLine_CN exportSourceLine;
        AmountCur                           curAccumulateAmountCur;
        AmountCur                           curAccumulateAmountCurRaw;
        TaxIntgrExportDocLineTmp_CN         exportDocSourceLineCopy;

        // only one source document is expected
        exportDocSource = TaxIntgrExportDocumentSource_CN::find(exportDocSourceId);

        // the amount on source is not rounded
        exportDocSourceCopy.clear();
        exportDocSourceCopy.TransactionCurrencyAmount =
            exportDocSource.getExportDocTransactionCurrencyAmount();
        exportDocSourceCopy.MiscChargesTaxAmount = exportDocSource.MiscChargesTaxAmount;
        exportDocSourceCopy.MiscChargesNetAmount = exportDocSource.MiscChargesNetAmount;
        exportDocSourceCopy.TaxIntgrExportDocumentSource_CN = exportDocSource.RecId;
        exportDocSourceCopy.insert();

        while select Qty, TransactionCurrencyNetAmount, TransactionCurrencyTaxAmount, TransactionCurrencyMiscChargesTaxAmount,
            TransactionCurrencyMiscChargesNetAmount, RecId from exportSourceLine
            where exportSourceLine.TaxIntgrExportDocumentSource_CN == exportDocSource.RecId
        {
            exportDocSourceLineCopy.clear();
            exportDocSourceLineCopy.Qty = exportSourceLine.Qty;

            curAccumulateAmountCurRaw += exportSourceLine.TransactionCurrencyNetAmount;
            exportDocSourceLineCopy.TransactionCurrencyNetAmount =
                TaxIntgrUtility_CN::roundAmount(curAccumulateAmountCurRaw) - curAccumulateAmountCur;
            curAccumulateAmountCur += exportDocSourceLineCopy.TransactionCurrencyNetAmount;

            curAccumulateAmountCurRaw += exportSourceLine.TransactionCurrencyTaxAmount;
            exportDocSourceLineCopy.TransactionCurrencyTaxAmount =
                TaxIntgrUtility_CN::roundAmount(curAccumulateAmountCurRaw) - curAccumulateAmountCur;
            curAccumulateAmountCur += exportDocSourceLineCopy.TransactionCurrencyTaxAmount;

            exportDocSourceLineCopy.TransactionCurrencyMiscChargesNetAmount = exportSourceLine.TransactionCurrencyMiscChargesNetAmount;
            exportDocSourceLineCopy.TransactionCurrencyMiscChargesTaxAmount = exportSourceLine.TransactionCurrencyMiscChargesTaxAmount;
            exportDocSourceLineCopy.TaxIntgrExportDocumentSourceLine_CN = exportSourceLine.RecId;
            exportDocSourceLineCopy.TaxIntgrExportDocTmp_CN = exportDocSourceCopy.RecId;

            exportDocSourceLineCopyMap.insert(
                exportDocSourceLineCopy.TaxIntgrExportDocumentSourceLine_CN,
                exportDocSourceLineCopy);

            totalNumOfLines++;
        }

        numbering = 0;

        this.initializeAccumulated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeAccumulated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize accumulated data.
    /// </summary>
    protected void initializeAccumulated()
    {
        MapEnumerator                       mapEnumerator;
        TaxIntgrExportDocLineTmp_CN         exportDocSourceLineCopy;
        TaxIntgrExportDocLineTmp_CN         accumulatedExportDocLine;

        accumulatedExportDoc.clear();
        accumulatedExportDoc.TransactionCurrencyAmount = 0;
        accumulatedExportDoc.Percent = 0;
        accumulatedExportDoc.MiscChargesNetAmount = 0;
        accumulatedExportDoc.MiscChargesTaxAmount = 0;
        accumulatedExportDoc.TaxIntgrExportDocumentSource_CN = exportDocSourceCopy.TaxIntgrExportDocumentSource_CN;
        accumulatedExportDoc.insert();

        mapEnumerator = exportDocSourceLineCopyMap.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            exportDocSourceLineCopy = mapEnumerator.currentValue();
            accumulatedExportDocLine.clear();
            accumulatedExportDocLine.Qty = 0;
            accumulatedExportDocLine.TransactionCurrencyNetAmount = 0;
            accumulatedExportDocLine.TransactionCurrencyTaxAmount = 0;
            accumulatedExportDocLine.TransactionCurrencyMiscChargesNetAmount = 0;
            accumulatedExportDocLine.TransactionCurrencyMiscChargesTaxAmount = 0;
            accumulatedExportDocLine.TaxIntgrExportDocumentSourceLine_CN =
                exportDocSourceLineCopy.TaxIntgrExportDocumentSourceLine_CN;
            accumulatedExportDocLine.TaxIntgrExportDocTmp_CN = accumulatedExportDoc.RecId;

            accumulatedExportDocSourceLineCopyMap.insert(
                accumulatedExportDocLine.TaxIntgrExportDocumentSourceLine_CN,
                accumulatedExportDocLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeFromInstance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize from instance.
    /// </summary>
    /// <param name="_existingInstance">
    /// The existing instance of calculation.
    /// </param>
    protected void initializeFromInstance(TaxIntgrExportDocumentSplitCalc_CN _existingInstance)
    {
        Version     version;

        [version, #CurrentList] = _existingInstance.pack();
        exportDocSourceCopy = _existingInstance.getExportDocSourceCopy();
        exportDocSourceLineCopyMap = _existingInstance.getExportDocSourceLineCopyMap();
        totalNumOfLines = _existingInstance.getTotalNumOfLines();
        numbering = 0;

        this.initializeAccumulated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertOrUpdateExportDoc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts or updates the new export document record.
    /// </summary>
    /// <param name="_exportDoc">
    /// The exportd ocument record.
    /// </param>
    /// <param name="_lineMap">
    /// A line map with lines.
    /// </param>
    protected void insertOrUpdateExportDoc(
        TaxIntgrExportDocTmp_CN _exportDoc,
        Map                     _lineMap = null)
    {
        select firstOnly exportDocSourceCopy;

        _exportDoc.IsOverAmountLimit = this.isOverAmountLimit(exportDoc.TransactionCurrencyAmount);
        _exportDoc.TaxIntgrExportDocumentSource_CN = exportDocSourceCopy.TaxIntgrExportDocumentSource_CN;
        _exportDoc.Number = this.getNextNumber();
        _exportDoc.write();

        if (_lineMap)
        {
            exportDocMap.insert(_exportDoc, _lineMap);
        }
        else
        {
            exportDocMap.insert(_exportDoc, new Map(Types::Int64, Types::Record));
        }

        newCreatedExportDoc.data(_exportDoc);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOverAmountLimit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether it is over amount limit.
    /// </summary>
    /// <param name="_amountCur">
    /// The amount.
    /// </param>
    /// <returns>
    /// True if it is over amount limit; otherwise, false.
    /// </returns>
    protected boolean isOverAmountLimit(AmountCur _amountCur)
    {
        return abs(_amountCur) > amountLimit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        exportDocSourceLineCopyMap = new Map(Types::Int64, Types::Record);
        accumulatedExportDocSourceLineCopyMap = new Map(Types::Int64, Types::Record);
        exportDocLineMap = new Map(Types::Int64, Types::Record);
        exportDocMap = new Map(Types::Record, Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>packCalculatedDataMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs calculated data map.
    /// </summary>
    /// <returns>
    /// The calculated data map.
    /// </returns>
    public container packCalculatedDataMap()
    {
        return exportDocMap.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAmountLimit</Name>
				<Source><![CDATA[
    public AmountCur parmAmountLimit(AmountCur _amountLimit = amountLimit)
    {
        amountLimit = _amountLimit;
        return amountLimit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExportDocSourceId</Name>
				<Source><![CDATA[
    public RefRecId parmExportDocSourceId(
        RefRecId _exportDocSourceId = exportDocSourceId)
    {
        exportDocSourceId = _exportDocSourceId;
        return exportDocSourceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCheckAmountLimit</Name>
				<Source><![CDATA[
    protected boolean parmIsCheckAmountLimit(boolean _isCheckAmountLimit = isCheckAmountLimit)
    {
        isCheckAmountLimit = _isCheckAmountLimit;
        return isCheckAmountLimit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ratioToOriginalAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the ratio to original amount.
    /// </summary>
    /// <param name="_amount">
    /// The original amount.
    /// </param>
    /// <returns>
    /// The ratio.
    /// </returns>
    private real ratioToOriginalAmount(AmountCur _amount)
    {
        real result;

        if (exportDocSourceCopy.TransactionCurrencyAmount == 0)
        {
            result = 1;
        }
        else
        {
            result = _amount / exportDocSourceCopy.TransactionCurrencyAmount;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseExportDoc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverse the export document.
    /// </summary>
    /// <param name="_recId">
    /// The export document rec id.
    /// </param>
    /// <param name="_splitType">
    /// The split type.
    /// </param>
    public void reverseExportDoc(
        RefRecId                            _recId,
        TaxIntgrExportDocumentSplitType_CN  _splitType)
    {
        TaxIntgrExportDocTmp_CN         exportDocLocal;
        TaxIntgrExportDocTmp_CN         exportDocRemoved;
        TaxIntgrExportDocLineTmp_CN     exportDocLineLocal;
        TaxIntgrExportDocLineTmp_CN     exportDocLineInMap;
        MapEnumerator                   mapEnum;
        Map                             lineMap;

        exportDocLocal = this.findExportDocByRecId(_recId);

        switch (_splitType)
        {
            case TaxIntgrExportDocumentSplitType_CN::ByAmount:
            case TaxIntgrExportDocumentSplitType_CN::ByPercent:
                this.splitByAmount(
                    -exportDocLocal.TransactionCurrencyAmount,
                    -exportDocLocal.Percent,
                    -exportDocLocal.MiscChargesNetAmount,
                    -exportDocLocal.MiscChargesTaxAmount);
                break;

            case TaxIntgrExportDocumentSplitType_CN::ByQuantity:
                //populate the line.
                lineMap = exportDocMap.lookup(exportDocLocal);
                mapEnum = lineMap.getEnumerator();

                while (mapEnum.moveNext())
                {
                    exportDocLineInMap = mapEnum.currentValue();
                    exportDocLineLocal.data(exportDocLineInMap);
                    exportDocLineLocal.Qty = -exportDocLineLocal.Qty;
                    exportDocLineLocal.TaxIntgrExportDocTmp_CN = 0;
                    exportDocLineLocal.insert();
                }

                this.splitByQuantity(
                    0,
                    exportDocLineLocal);
                break;
        }

        //remove the reversed
        exportDocRemoved = this.findExportDocByRecId(exportDocLocal.RecId);
        exportDocRemoved.delete();
        exportDocRemoved = this.findExportDocByRecId(newCreatedExportDoc.RecId);
        exportDocRemoved.delete();
        exportDocMap.remove(exportDocLocal);
        exportDocMap.remove(newCreatedExportDoc);
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundAmountByStrategy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds amount by strategy.
    /// </summary>
    /// <param name="_amountToRound">
    /// Amount to be round.
    /// </param>
    /// <param name="_roundingDifference">
    /// The rounding difference so far.
    /// </param>
    /// <returns>
    /// The rounding amount.
    /// </returns>
    protected AmountCur roundAmountByStrategy(AmountCur _amountToRound, AmountCur _roundingDifference)
    {
        AmountCur roundedAmount;
        #define.roundingAccAmoutHalf(0.005)

        if (_roundingDifference >= #roundingAccAmoutHalf)
        {
            roundedAmount = TaxIntgrUtility_CN::roundDownAmount(_amountToRound);
        }
        else if (_roundingDifference <= -#roundingAccAmoutHalf)
        {
            roundedAmount = TaxIntgrUtility_CN::roundUpAmount(_amountToRound);
        }
        else
        {
            roundedAmount = TaxIntgrUtility_CN::roundAmount(_amountToRound);
        }

        return roundedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitAuto</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs automatically spit.
    /// </summary>
    /// <returns>
    /// True if the split is successful; otherwise, false.
    /// </returns>
    public boolean splitAuto()
    {
        int numberOfInvoices;
        int i;
        AmountCur invoiceAmount;
        AmountCur chargesNetAmount;
        AmountCur chargesTaxAmount;
        AmountCur accumulateInvoiceAmount;
        AmountCur accumulateChargesNetAmt;
        AmountCur accumulateChargesTaxAmt;
        boolean result = true;
        #avifiles

        SysOperationProgress            progressLocal;

        Debug::assert(amountLimit > 0);

        numberOfInvoices = any2int(roundUpDec(abs(exportDocSourceCopy.TransactionCurrencyAmount) / amountLimit, 0));
        progressLocal = SysOperationProgress::newGeneral(#AviFormLetter, "@SYS10133", numberOfInvoices);
        for (i = 0; i < numberOfInvoices; i++)
        {
            if (i == numberOfInvoices - 1)
            {
                invoiceAmount = exportDocSourceCopy.TransactionCurrencyAmount - accumulateInvoiceAmount;
                chargesNetAmount = exportDocSourceCopy.MiscChargesNetAmount - accumulateChargesNetAmt;
                chargesTaxAmount = exportDocSourceCopy.MiscChargesTaxAmount - accumulateChargesTaxAmt;
            }
            else
            {
                invoiceAmount = TaxIntgrUtility_CN::roundUpAmount(abs(exportDocSourceCopy.TransactionCurrencyAmount) / numberOfInvoices) * sign(exportDocSourceCopy.TransactionCurrencyAmount);
                chargesNetAmount = TaxIntgrUtility_CN::roundUpAmount(abs(exportDocSourceCopy.MiscChargesNetAmount) / numberOfInvoices) * sign(exportDocSourceCopy.MiscChargesNetAmount);
                chargesTaxAmount = TaxIntgrUtility_CN::roundUpAmount(abs(exportDocSourceCopy.MiscChargesTaxAmount) / numberOfInvoices) * sign(exportDocSourceCopy.MiscChargesTaxAmount);
            }
            result = result && this.splitByAmount(invoiceAmount, 0, chargesNetAmount, chargesTaxAmount);
            accumulateInvoiceAmount += invoiceAmount;
            accumulateChargesNetAmt += chargesNetAmount;
            accumulateChargesTaxAmt += chargesTaxAmount;

            progressLocal.incCount();
        }

        if (progressLocal)
        {
            progressLocal.reset();
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitByAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Split given amount from document source into a new export document.
    /// </summary>
    /// <param name="_amountToSplit">
    /// Amount to split.
    /// </param>
    /// <param name="_splitPercent">
    /// Percent to split.
    /// </param>
    /// <param name="_chargesNetAmountToSplit">
    /// Charges net amount to split.
    /// </param>
    /// <param name="_chargesTaxAmountToSplit">
    /// Charges tax amount to split.
    /// </param>
    /// <returns>
    /// True if the split is successful; otherwise, false.
    /// </returns>
    public boolean splitByAmount(
        AmountCur   _amountToSplit,
        Percent     _splitPercent = 0,
        AmountCur   _chargesNetAmountToSplit = 0,
        AmountCur   _chargesTaxAmountToSplit = 0)
    {
        Percent accumulatedPercent;
        boolean result = true;
        AmountCur documentAmount = TaxIntgrUtility_CN::roundAmount(_amountToSplit);
        AmountCur documentMiscChargesNetAmt = TaxIntgrUtility_CN::roundAmount(_chargesNetAmountToSplit);
        AmountCur documentMiscChargesTaxAmt = TaxIntgrUtility_CN::roundAmount(_chargesTaxAmountToSplit);

        result = this.checkExportDocumentAmount(documentAmount);

        if (result)
        {
            accumulatedPercent = TaxIntgrUtility_CN::roundDownPercent(this.ratioToOriginalAmount(accumulatedExportDoc.TransactionCurrencyAmount +  documentAmount) * #PercentBase);

            exportDoc.clear();
            exportDoc.TransactionCurrencyAmount = documentAmount;
            exportDoc.MiscChargesNetAmount = documentMiscChargesNetAmt;
            exportDoc.MiscChargesTaxAmount = documentMiscChargesTaxAmt;
            if (_splitPercent)
            {
                exportDoc.Percent = _splitPercent;
            }
            else
            {
                exportDoc.Percent = accumulatedPercent - accumulatedExportDoc.Percent;
            }
            this.insertOrUpdateExportDoc(
                exportDoc,
                null);

            select forupdate accumulatedExportDoc;
            accumulatedExportDoc.TransactionCurrencyAmount += documentAmount;
            accumulatedExportDoc.MiscChargesNetAmount += documentMiscChargesNetAmt;
            accumulatedExportDoc.MiscChargesTaxAmount += documentMiscChargesTaxAmt;
            if (_splitPercent)
            {
                accumulatedExportDoc.Percent += _splitPercent;
            }
            else
            {
                accumulatedExportDoc.Percent = accumulatedPercent;
            }
            accumulatedExportDoc.update();

            this.splitByAmountInLine(documentAmount, documentMiscChargesNetAmt, documentMiscChargesTaxAmt);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitByAmountInLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the line to split the specified amount.
    /// </summary>
    /// <param name="_documentAmount">
    /// The document amount.
    /// </param>
    /// <param name="_documentMiscChargesNetAmt">
    /// The document charges net amount.
    /// </param>
    /// <param name="_documentMiscChargesTaxAmt">
    /// The document charges tax amount.
    /// </param>
    protected void splitByAmountInLine(
        AmountCur   _documentAmount,
        AmountCur   _documentMiscChargesNetAmt = 0,
        AmountCur   _documentMiscChargesTaxAmt = 0)
    {
        TaxIntgrExportDocLineTmp_CN exportDocSourceLineCopy;
        TaxIntgrExportDocLineTmp_CN accumulatedExportDocLine;
        MapEnumerator mapEnumerator;
        real accumulatedPercentRaw;
        int number;
        AmountCur roundingAllowance;
        AmountCur accumulatedAmount;
        AmountCur accumulatedAmountRaw;
        AmountCur accumulatedAmountChargesLine;
        AmountCur accumulatedAmountChargesLineRaw;
        Map lineMap;

        accumulatedPercentRaw = this.ratioToOriginalAmount(accumulatedExportDoc.TransactionCurrencyAmount);

        mapEnumerator = exportDocSourceLineCopyMap.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            exportDocSourceLineCopy = mapEnumerator.currentValue();
            accumulatedExportDocLine = accumulatedExportDocSourceLineCopyMap.lookup(exportDocSourceLineCopy.TaxIntgrExportDocumentSourceLine_CN);

            number++;

            exportDocLine.Qty = TaxIntgrUtility_CN::roundQuantity(
                exportDocSourceLineCopy.Qty * accumulatedPercentRaw - accumulatedExportDocLine.Qty);
            accumulatedExportDocLine.Qty += exportDocLine.Qty;

            exportDocLine.TransactionCurrencyTaxAmount = this.roundAmountByStrategy(
                exportDocSourceLineCopy.TransactionCurrencyTaxAmount * accumulatedPercentRaw -
                    accumulatedExportDocLine.TransactionCurrencyTaxAmount,
                roundingAllowance);
            accumulatedExportDocLine.TransactionCurrencyTaxAmount +=
                exportDocLine.TransactionCurrencyTaxAmount;
            accumulatedAmount += exportDocLine.TransactionCurrencyTaxAmount;
            accumulatedAmountRaw += exportDocSourceLineCopy.TransactionCurrencyTaxAmount;

            exportDocLine.TaxIntgrExportDocumentSourceLine_CN =
                exportDocSourceLineCopy.TaxIntgrExportDocumentSourceLine_CN;

            exportDocLine.TaxIntgrExportDocTmp_CN = exportDoc.RecId;
            exportDocLine.TransactionCurrencyMiscChargesTaxAmount = this.roundAmountByStrategy(
                exportDocSourceLineCopy.TransactionCurrencyMiscChargesTaxAmount * accumulatedPercentRaw -
                accumulatedExportDocLine.TransactionCurrencyMiscChargesTaxAmount,
                roundingAllowance);
            accumulatedExportDocLine.TransactionCurrencyMiscChargesTaxAmount +=
                exportDocLine.TransactionCurrencyMiscChargesTaxAmount;
            accumulatedAmountChargesLine    += exportDocLine.TransactionCurrencyMiscChargesTaxAmount;
            accumulatedAmountChargesLineRaw += exportDocSourceLineCopy.TransactionCurrencyMiscChargesTaxAmount;
        
            exportDocLine.TransactionCurrencyMiscChargesNetAmount = this.roundAmountByStrategy(
                exportDocSourceLineCopy.TransactionCurrencyMiscChargesNetAmount * accumulatedPercentRaw -
                accumulatedExportDocLine.TransactionCurrencyMiscChargesNetAmount,
                roundingAllowance);
            accumulatedExportDocLine.TransactionCurrencyMiscChargesNetAmount +=
                exportDocLine.TransactionCurrencyMiscChargesNetAmount;
            accumulatedAmountChargesLine += exportDocLine.TransactionCurrencyMiscChargesNetAmount;
            accumulatedAmountChargesLineRaw += exportDocSourceLineCopy.TransactionCurrencyMiscChargesNetAmount;

            if (number < totalNumOfLines)
            {
                exportDocLine.TransactionCurrencyNetAmount = this.roundAmountByStrategy(
                    exportDocSourceLineCopy.TransactionCurrencyNetAmount * accumulatedPercentRaw -
                        accumulatedExportDocLine.TransactionCurrencyNetAmount,
                    roundingAllowance);
                accumulatedExportDocLine.TransactionCurrencyNetAmount +=
                    exportDocLine.TransactionCurrencyNetAmount;
                accumulatedAmount += exportDocLine.TransactionCurrencyNetAmount;
                accumulatedAmountRaw += exportDocSourceLineCopy.TransactionCurrencyNetAmount;
            }
            else
            {
                // amount on the last line shall be what remains.
                exportDocLine.TransactionCurrencyNetAmount = TaxIntgrUtility_CN::roundAmount(
                    _documentAmount - accumulatedAmount - accumulatedAmountChargesLine - _documentMiscChargesNetAmt - _documentMiscChargesTaxAmt);
                accumulatedExportDocLine.TransactionCurrencyNetAmount +=
                    exportDocLine.TransactionCurrencyNetAmount;
            }

            //update rounding allowance
            roundingAllowance = (accumulatedAmount + accumulatedAmountChargesLine) - (accumulatedAmountRaw + accumulatedAmountChargesLineRaw) * this.ratioToOriginalAmount(_documentAmount);

            accumulatedExportDocSourceLineCopyMap.insert(
                accumulatedExportDocLine.TaxIntgrExportDocumentSourceLine_CN,
                accumulatedExportDocLine);

            lineMap = exportDocMap.lookup(exportDoc);
            lineMap.insert(exportDocLine.TaxIntgrExportDocumentSourceLine_CN, exportDocLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitByPercent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits given percent of amount from document source into a new export document.
    /// </summary>
    /// <param name="_percentToSplit">
    /// Percent to split.
    /// </param>
    /// <returns>
    /// True if the split is successful; otherwise, false.
    /// </returns>
    public boolean splitByPercent(
        percent     _percentToSplit)
    {
        Percent percentToSplit = TaxIntgrUtility_CN::roundDownPercent(_percentToSplit);
        AmountCur documentAmount;

        documentAmount = TaxIntgrUtility_CN::roundAmount(exportDocSourceCopy.TransactionCurrencyAmount * (accumulatedExportDoc.Percent + percentToSplit) / #PercentBase)
                            - accumulatedExportDoc.TransactionCurrencyAmount;

        AmountCur documentMiscChargesNetAmt = TaxIntgrUtility_CN::roundAmount(exportDocSourceCopy.MiscChargesNetAmount * (accumulatedExportDoc.Percent + percentToSplit) / #PercentBase)
            - accumulatedExportDoc.MiscChargesNetAmount;
    
        AmountCur documentMiscChargesTaxAmt = TaxIntgrUtility_CN::roundAmount(exportDocSourceCopy.MiscChargesTaxAmount * (accumulatedExportDoc.Percent + percentToSplit) / #PercentBase)
            - accumulatedExportDoc.MiscChargesTaxAmount;
    
        return this.splitByAmount(documentAmount, percentToSplit, documentMiscChargesNetAmt, documentMiscChargesTaxAmt);
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitByQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Split the given quantity on each line into a new export document.
    /// </summary>
    /// <param name="_currentDocId">
    /// rec Id of the tmp doc whose lines will be used for split.
    /// </param>
    /// <param name="_splitLine">
    /// quantity to split for each line
    /// </param>
    /// <returns>
    /// whether the split is successful
    /// </returns>
    public boolean splitByQuantity(RefRecId _currentDocId, TaxIntgrExportDocLineTmp_CN _splitLine)
    {
        real                        accumulatedAmount = 0;
        boolean                     result = true;
        Percent                     accumulatedPercent;
        TaxIntgrExportDocLineTmp_CN accumulatedExportDocLine;
        TaxIntgrExportDocLineTmp_CN exportDocSourceLineCopy;
        Qty totalSplitqty;
        Qty totalQty;
        Map lineMap = new Map(Types::Int64, Types::Record);

        select firstOnly exportDocSourceCopy;
        select forupdate accumulatedExportDoc;

        ttsBegin;

        exportDoc.clear();
        exportDoc.TaxIntgrExportDocumentSource_CN = exportDocSourceCopy.TaxIntgrExportDocumentSource_CN;
        exportDoc.insert();

        while select _splitLine
            where _splitLine.TaxIntgrExportDocTmp_CN == _currentDocId
        {
            accumulatedExportDocLine = accumulatedExportDocSourceLineCopyMap.lookup(_splitLine.TaxIntgrExportDocumentSourceLine_CN);
            exportDocSourceLineCopy = exportDocSourceLineCopyMap.lookup(_splitLine.TaxIntgrExportDocumentSourceLine_CN);
            totalQty += exportDocSourceLineCopy.Qty;
            if (_splitLine.Qty)
            {
                exportDocLine.clear();
                exportDocLine.Qty = _splitLine.Qty;
                accumulatedExportDocLine.Qty += exportDocLine.Qty;
                totalSplitqty += exportDocLine.Qty;

                [exportDocLine.TransactionCurrencyNetAmount, exportDocLine.TransactionCurrencyTaxAmount,
                    exportDocLine.TransactionCurrencyMiscChargesNetAmount, exportDocLine.TransactionCurrencyMiscChargesTaxAmount]
                    = this.getAmountOfSplitByQty(_splitLine);

                accumulatedExportDocLine.TransactionCurrencyNetAmount +=
                    exportDocLine.TransactionCurrencyNetAmount;
                accumulatedAmount += exportDocLine.TransactionCurrencyNetAmount;

                accumulatedExportDocLine.TransactionCurrencyTaxAmount +=
                    exportDocLine.TransactionCurrencyTaxAmount;
                accumulatedAmount += exportDocLine.TransactionCurrencyTaxAmount;

                accumulatedExportDocLine.TransactionCurrencyMiscChargesNetAmount +=
                    exportDocLine.TransactionCurrencyMiscChargesNetAmount;
                accumulatedAmount += exportDocLine.TransactionCurrencyMiscChargesNetAmount;
    
                accumulatedExportDocLine.TransactionCurrencyMiscChargesTaxAmount +=
                    exportDocLine.TransactionCurrencyMiscChargesTaxAmount;
                accumulatedAmount += exportDocLine.TransactionCurrencyMiscChargesTaxAmount;

                exportDocLine.TaxIntgrExportDocumentSourceLine_CN =
                    exportDocSourceLineCopy.TaxIntgrExportDocumentSourceLine_CN;

                exportDocLine.TaxIntgrExportDocTmp_CN = exportDoc.RecId;

                accumulatedExportDocSourceLineCopyMap.insert(
                    accumulatedExportDocLine.TaxIntgrExportDocumentSourceLine_CN,
                    accumulatedExportDocLine);

                lineMap.insert(exportDocLine.TaxIntgrExportDocumentSourceLine_CN, exportDocLine);
            }
        }

        if (!this.checkExportDocumentAmount(accumulatedAmount))
        {
            result = false;
            ttsAbort;
        }

        if (result)
        {
            exportDoc.MiscChargesNetAmount = TaxIntgrUtility_CN::roundAmount(exportDocSourceCopy.MiscChargesNetAmount * totalSplitqty / totalQty);
            accumulatedAmount += exportDoc.MiscChargesNetAmount;
    
            exportDoc.MiscChargesTaxAmount = TaxIntgrUtility_CN::roundAmount(exportDocSourceCopy.MiscChargesTaxAmount * totalSplitqty / totalQty);
            accumulatedAmount += exportDoc.MiscChargesTaxAmount;

            accumulatedPercent = TaxIntgrUtility_CN::roundDownPercent(this.ratioToOriginalAmount(accumulatedExportDoc.TransactionCurrencyAmount +  accumulatedAmount) * #PercentBase);
            exportDoc.TransactionCurrencyAmount = accumulatedAmount;
            exportDoc.Percent = accumulatedPercent - accumulatedExportDoc.Percent;
            this.insertOrUpdateExportDoc(exportDoc, lineMap);

            accumulatedExportDoc.Percent = accumulatedPercent;
            accumulatedExportDoc.TransactionCurrencyAmount += exportDoc.TransactionCurrencyAmount;
            accumulatedExportDoc.MiscChargesNetAmount += exportDoc.MiscChargesNetAmount;
            accumulatedExportDoc.MiscChargesTaxAmount += exportDoc.MiscChargesTaxAmount;
            accumulatedExportDoc.update();

            ttsCommit;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = _packedClass;
                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackCalculatedDataMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unpack the calculated result from the pack.
    /// </summary>
    /// <param name="_pack">
    /// The result pack.
    /// </param>
    public void unpackCalculatedDataMap(container _pack)
    {
        exportDocMap = Map::create(_pack);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the amount is valid or not.
    /// </summary>
    /// <returns>
    /// Returns true if valid, otherwise false.
    /// </returns>
    public boolean validate()
    {
        boolean ret = true;

        // there should no document with amount over limit
        while select exportDoc
        {
            if (exportDoc.IsOverAmountLimit)
            {
                ret = ret && checkFailed("@SYS4002257");
                break;
            }
        }

        // the total amount hall be consistent with that of source copy
        // header level
        select sum(TransactionCurrencyAmount) from exportDoc;
        if (exportDoc.TransactionCurrencyAmount != exportDocSourceCopy.TransactionCurrencyAmount)
        {
            ret = ret && checkFailed("@SYS4002254");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Construct a new instance of TaxIntgrExportDocumentSplitCalc_CN.
    /// </summary>
    /// <param name="_exportDocSourceId">
    /// RecId of source of the export documents to be split.
    /// </param>
    /// <param name="_isCheckAmountLimit">
    /// whether to check amount limit. default is yes.
    /// </param>
    /// <returns>
    /// a new instance of TaxIntgrExportDocumentSplitCalc_CN.
    /// </returns>
    public static TaxIntgrExportDocumentSplitCalc_CN construct(
        RefRecId _exportDocSourceId,
        boolean _isCheckAmountLimit = true)
    {
        TaxIntgrExportDocumentSplitCalc_CN newInstance =
            new TaxIntgrExportDocumentSplitCalc_CN();
        newInstance.parmExportDocSourceId(_exportDocSourceId);
        newInstance.parmIsCheckAmountLimit(_isCheckAmountLimit);
        newInstance.parmAmountLimit(TaxIntgrUtility_CN::getAmountLimit(_exportDocSourceId));
        newInstance.initialize();

        return newInstance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFromContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs instance from pack.
    /// </summary>
    /// <param name="_packedClassWithData">
    /// The pack of instance.
    /// </param>
    /// <returns>
    /// The instance of calculation.
    /// </returns>
    public static TaxIntgrExportDocumentSplitCalc_CN constructFromContainer(
        container _packedClassWithData)
    {
        container pack;
        container dataPack;
        TaxIntgrExportDocumentSplitCalc_CN newInstance;

        [pack, dataPack] = _packedClassWithData;
        newInstance = new TaxIntgrExportDocumentSplitCalc_CN();
        newInstance.unpack(pack);
        newInstance.unpackCalculatedDataMap(dataPack);
        return newInstance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFromInstance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Construct a new instance from an existing instance.
    /// </summary>
    /// <param name="_existingInstance">
    /// existing instance
    /// </param>
    /// <returns>
    /// a new instance of TaxIntgrExportDocumentSplitCalc_CN.
    /// </returns>
    public static TaxIntgrExportDocumentSplitCalc_CN constructFromInstance(
        TaxIntgrExportDocumentSplitCalc_CN _existingInstance)
    {
        TaxIntgrExportDocumentSplitCalc_CN newInstance =
            new TaxIntgrExportDocumentSplitCalc_CN();
        newInstance.initializeFromInstance(_existingInstance);

        return newInstance;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>