<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailCDXDownloadService</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Application.Instrumentation;
using Microsoft.DynamicsOnline.Infrastructure.Components.SharedServiceUnitStorage;

/// <summary>
///    The <c>RetailCDXDownloadService</c> class is a support class for the <c>CDXRealTimeService</c> class.
/// </summary>
/// <remarks>
///    This class is used for CDX download service APIs.
/// </remarks>
// This is a framework class. Customizing this class may cause problems Real-Time Service in channels.
public class RetailCDXDownloadService
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>GetDownloadSessions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get download sessions for passed data store.
    /// </summary>
    /// <param name = "dataStoreName">Data store name.</param>
    /// <returns>List of download sessions.</returns>
    public static List GetDownloadSessions(str dataStoreName)
    {
        RetailCDXDownloadSessionResultSetting resultSetting = new  RetailCDXDownloadSessionResultSetting();

        if (RetailCdxFeatureControl::isDownloadSessionDependencyEnforcementEnabled())
        {
            // only older version clients call this API, since older clients do not stop processing when one of the session in the list fails to be applied enforce one session at a time processing.
            resultSetting.SessionListPageSize(1);
        }
        else
        {
            resultSetting.SessionListPageSize(RetailCDXFeatureControl::getDownloadSessionsMaxResultSize());
        }

        return RetailCDXDownloadService::GetDownloadSessionList(dataStoreName, resultSetting);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildRetailCDXDownloadSessionWhereClause</Name>
				<Source><![CDATA[
    private static SysDaQueryExpression buildRetailCDXDownloadSessionWhereClause(RetailCDXDownloadSession _downloadSession, RetailCDXDownloadSessionDataStore _downloadSessionDataStore1, RefRecId _dbProfileRecId, RefRecId _channelSchema)
    {
        return new SysDaAndExpression(
					new SysDaEqualsExpression(
						new SysDaFieldExpression(_downloadSession, fieldStr(RetailCDXDownloadSession, RecId)),
						new SysDaFieldExpression(_downloadSessionDataStore1, fieldStr(RetailCDXDownloadSessionDataStore, Session))),
					new SysDaAndExpression(
						new SysDaEqualsExpression(
							new SysDaFieldExpression(_downloadSessionDataStore1, fieldStr(RetailCDXDownloadSessionDataStore, DataStore)),
							new SysDaValueExpression(_dbProfileRecId)),
						RetailCDXDownloadService::buildRetailCDXDownloadSessionStatusWhereClause(_downloadSessionDataStore1, _channelSchema)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildRetailCDXDownloadSessionStatusWhereClause</Name>
				<Source><![CDATA[
	[Wrappable(true)]
    internal static SysDaQueryExpression buildRetailCDXDownloadSessionStatusWhereClause(RetailCDXDownloadSessionDataStore _downloadSessionDataStore1, RefRecId _channelSchema)
    {
        return new SysDaAndExpression(
					new SysDaAndExpression(
						new SysDaNotEqualsExpression(
							new SysDaFieldExpression(_downloadSessionDataStore1, fieldStr(RetailCDXDownloadSessionDataStore, Status)),
							new SysDaValueExpression(RetailCDXDownloadSessionStatus::Applied)),
						new SysDaNotEqualsExpression(
							new SysDaFieldExpression(_downloadSessionDataStore1, fieldStr(RetailCDXDownloadSessionDataStore, Status)),
							new SysDaValueExpression(RetailCDXDownloadSessionStatus::Canceled))),
					new SysDaNotEqualsExpression(
						new SysDaFieldExpression(_downloadSessionDataStore1, fieldStr(RetailCDXDownloadSessionDataStore, Status)),
						new SysDaValueExpression(RetailCDXDownloadSessionStatus::Suspended)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDownloadSessionList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get download sessions for passed data store.
    /// </summary>
    /// <param name = "dataStoreName">Data store name.</param>
    /// <param name = "sessionResultSetting">The session result setting.</param>
    /// <returns>List of download sessions.</returns>
    internal static List GetDownloadSessionList(str dataStoreName, RetailCDXDownloadSessionResultSetting sessionResultSetting = new RetailCDXDownloadSessionResultSetting())
    {
        RetailConnSchedulerJobTable connSchedulerjob;
        RetailCDXDownloadSession downloadSession;
        RetailCDXDownloadSessionDataStore downloadSessionDataStore1, downloadSessionDataStore2;

        List clientSessions = new List(Types::Class);

        RetailConnDatabaseProfile dbProfile = RetailConnDatabaseProfile::find(dataStoreName);

        if (!dbProfile)
        {
            throw Global::error(strfmt("@Retail:CDXDataStoreNotExistError", dataStoreName));
        }

        if (dbProfile.isDataStoreSynchronizationPaused())
        {
            ApplicationEventSource::EventWriteCDXDataStoreDataSyncPausedByUser(dataStoreName, newGuid());
            return clientSessions;
        }

        boolean isDownloadSessionDependencyEnforcementEnabled = RetailCDXFeatureControl::isDownloadSessionDependencyEnforcementEnabled();

        // Get the DownloadSessions max result size using the feature control flag.
        int downloadSessionsMaxResultSize = RetailCDXFeatureControl::getDownloadSessionsMaxResultSize();

        if (sessionResultSetting.SessionListPageSize() <= 0 || sessionResultSetting.SessionListPageSize() > downloadSessionsMaxResultSize)
        {
            // set page size to max allowed by the back end if its not set or is greater than the maximum allowed.
            sessionResultSetting.SessionListPageSize(downloadSessionsMaxResultSize);
        }

        Set blockedDownloadJobSet = new Set(Types::String);

		RetailCDXDataGroup dataGroup = RetailCDXDataGroup::find(dbProfile.DataGroup);

		
        if (isDownloadSessionDependencyEnforcementEnabled)
        {
            while select jobId from connSchedulerjob
                where connSchedulerjob.IsUpload == NoYes::No
                && connSchedulerjob.RetailConnChannelSchema == dataGroup.ChannelSchema
            {
                RetailCDXDownloadSession blockingSession = RetailConnDatabaseProfile::getBlockingDownloadSession(dbProfile.RecId, connSchedulerjob.jobId);

                if (blockingSession.RecId != 0)
                {
                    blockedDownloadJobSet.add(connSchedulerjob.jobId);

                    // if a job is blocked, prevent other jobs sharing same subjobs from proceeding
                    SetEnumerator dependentJobIdsEnumerator = RetailConnSchedulerJobTable::getDependentJobIdEnumerator(connSchedulerjob.jobId);
                    while (dependentJobIdsEnumerator.moveNext())
                    {
                        blockedDownloadJobSet.add(dependentJobIdsEnumerator.current());
                    }

                    ApplicationEventSource::EventWriteCDXDataStoreDownloadSessionProcessingBlocked(dataStoreName, blockingSession.Session, blockingSession.JobID);
                }
            }
        }

        boolean isPauseDuringStoreHoursEnabled;
        int maxNumberOfRecordsAllowed;

        if (RetailCdxPauseSyncDuringStoreHoursFlight::instance().isEnabled())
        {
            isPauseDuringStoreHoursEnabled = dataGroup.PauseSyncDuringStoreHours && RetailConnDatabaseProfile::isInsideStoreHours(dbProfile.RecId);

            if (isPauseDuringStoreHoursEnabled)
            {
                maxNumberOfRecordsAllowed = dataGroup.GetMaxNumberOfRecordsAllowed();
                ApplicationEventSource::EventWriteCDXDataStoreDataSyncPauseInsideStoreHoursEnabled(dataStoreName, maxNumberOfRecordsAllowed);
            }
        }

        var qeRetailCDXDownloadSession = new SysDaQueryObject(downloadSession);
        var qeRetailCDXDownloadSessionDataStore = new SysDaQueryObject(downloadSessionDataStore1);
        qeRetailCDXDownloadSession.JoinClause(SysDaJoinKind::InnerJoin, qeRetailCDXDownloadSessionDataStore);
        qeRetailCDXDownloadSessionDataStore.WhereClause(RetailCDXDownloadService::buildRetailCDXDownloadSessionWhereClause(downloadSession, downloadSessionDataStore1, dbProfile.RecId, dataGroup.ChannelSchema));
        qeRetailCDXDownloadSession.orderByClause().add(fieldStr(RetailCDXDownloadSession, Session));

        var searchObject = new SysDaSearchObject(qeRetailCDXDownloadSession);
        var searchStatement = new SysDaSearchStatement();
        

        while (searchStatement.nextRecord(searchObject))
        {
            if (downloadSession.RecId)
            {
                if (isPauseDuringStoreHoursEnabled)
                {

                    if (downloadSession.RowsAffected > maxNumberOfRecordsAllowed)
                    {
                        blockedDownloadJobSet.add(downloadSession.jobId);
                        ApplicationEventSource::EventWriteCDXDataStoreDownloadSessionProcessingTooLarge(dataStoreName, downloadSession.Session, downloadSession.JobID, downloadSession.RowsAffected, maxNumberOfRecordsAllowed);
                    }
                }

                // blockedDownloadJobSet will have elements only if either isDownloadSessionDependencyEnforcementEnabled or isPauseDuringStoreHoursEnabled are set
                if (blockedDownloadJobSet.in(downloadSession.JobID))
                {
                    continue;
                }

                RetailAsyncClientDownloadSession clientSession;
                System.Exception ex;
                SharedServiceUnitNotFoundException sharedServiceUnitNotFoundException;

                try
                {
                    clientSession = RetailCDXDownloadService::createAsyncClientDownloadSession(downloadSession);

                    RetailCDXFilePathOrGuid downloadUri = RetailCDXDownloadService::getDownloadUriWithTokenTimeOut(downloadSession);

                    // downloadUri will be empty if failed to get package link, and the client will handle empty URI and update RetailCDXDownloadSessionDataStore table
                    clientSession.DownloadLink(downloadUri);
                }
                catch (sharedServiceUnitNotFoundException)
                {
                    RetailCDXDownloadService::UpdateDownloadSessionStatusWithParameters(dataStoreName, downloadSession.RecId, RetailCDXDownloadSessionStatus::DownloadFailed, DateTimeUtil::minValue(), 0, "@Retail:DownloadURlFailedError");
                    ApplicationEventSource::EventWriteRetailCdxGetDownloadSessionPackageUriFailureWarning(downloadSession.Session, downloadSession.JobID, sharedServiceUnitNotFoundException.ToString());
                }
                catch (ex)
                {
                    RetailCDXDownloadService::UpdateDownloadSessionStatusWithParameters(dataStoreName, downloadSession.RecId, RetailCDXDownloadSessionStatus::DownloadFailed, DateTimeUtil::minValue(), 0, ex.ToString());
                    ApplicationEventSource::EventWriteRetailCdxGetDownloadSessionPackageUriFailureWarning(downloadSession.Session, downloadSession.JobID, ex.ToString());
                }

                clientSessions.addEnd(clientSession);

                ttsbegin;

                select forupdate downloadSessionDataStore2
                    where downloadSessionDataStore2.DataStore == dbProfile.RecId
                        && downloadSessionDataStore2.Session == downloadSession.RecId;

                if (downloadSessionDataStore2)
                {
                    downloadSessionDataStore2.DateRequested = DateTimeUtil::utcNow();

                    if (downloadSessionDataStore2.TryCount > 0)
                    {
                        downloadSessionDataStore2.Message = strFmt("@Retail:RetailCDXReAttemptDownloadSession",
                                                                    downloadSessionDataStore2.TryCount,
                                                                    downloadSessionDataStore2.DateRequested,
                                                                    downloadSessionDataStore2.Message);
                    }

                    downloadSessionDataStore2.update();
                }
                else
                {
                    ApplicationEventSource::EventWriteCDXDataStoreDownloadSessionProcessingNotFound(dataStoreName, downloadSession.RecId, downloadSession.JobID);
                }

                ttscommit;

                if (clientSessions.elements() >= sessionResultSetting.SessionListPageSize())
                {
                    break;
                }
            }
            else
            {
                ApplicationEventSource::EventWriteCDXDataStoreDownloadSessionProcessingNotFound(dataStoreName, downloadSession.RecId, downloadSession.JobID);
            }
        }

        return clientSessions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDataDownloadParametersForTransformationFromSessionIds</Name>
				<Source><![CDATA[
	/// <summary>
    /// Gets the list of download sessions for passed data groups and session IDs. 
    /// </summary>
    /// <param name = "retailCdxDataGroup">The <c>RetailCDXDataGroup</c> object.</param>
    /// <param name = "sessionIds">The list of session IDs.</param>
    /// <param name = "sessionResultSetting">The <c>RetailCDXDownloadSessionResultSetting</c> object.</param>
    /// <returns>List of download sessions.</returns>
    private static List GetDataDownloadParametersForTransformationFromSessionIds(RetailCDXDataGroup retailCdxDataGroup, List sessionIds, RetailCDXDownloadSessionResultSetting sessionResultSetting = new RetailCDXDownloadSessionResultSetting())
    {
        // Get the DownloadSessions max result size using the feature control flag.
        int downloadSessionsMaxResultSize = RetailCDXFeatureControl::GetDownloadSessionsMaxResultSize();

        if (sessionResultSetting.SessionListPageSize() <= 0 || sessionResultSetting.SessionListPageSize() > downloadSessionsMaxResultSize)
        {
            // set page size to max allowed by the back end if its not set or is greater than the maximum allowed.
            sessionResultSetting.SessionListPageSize(downloadSessionsMaxResultSize);
        }

        RetailTmpRecId session;
        ListIterator iterator = new ListIterator(sessionIds);

        while (iterator.more())
        {
            session.ReferenceRecId = iterator.value();
            session.doInsert();
            
			iterator.next();
        }

        RetailCDXFilePathOrGuid downloadUri;        
        List clientSessions = new List(Types::Class);
        RetailCDXDownloadSession downloadSession;

        while select RecId, JobID, FileSize, CheckSum, DataFileOutputPath, Session, DataGroup from downloadSession
            join session
            order by downloadSession.Session
            where downloadSession.Session == session.ReferenceRecId
            && downloadSession.DataGroup == retailCdxDataGroup.RecId
        {
            // Get all datastore
            List dataStores = RetailCDXDownloadSession::GetAllDataStores(downloadSession.RecId);
            RetailCDXDataStoreGroup dataStoreGroup = new RetailCDXDataStoreGroup(retailCdxDataGroup.Name, retailCdxDataGroup.RecId, dataStores);
            RetailAsyncClientDownloadSession clientSession = RetailCDXDownloadService::createAsyncClientDownloadSession(downloadSession);

            System.Exception ex;

            try
            {
                downloadUri = RetailCDXDownloadService::getDownloadUriWithTokenTimeOut(downloadSession);
            }
            catch(ex)
            {
                ApplicationEventSource::EventWriteRetailCdxGetDownloadSessionPackageUriFailureWarning(downloadSession.Session, downloadSession.JobID, ex.ToString());
            }

            // downloadUri will be empty if failed to get package link, and the client will handle empty URI and update RetailCDXDownloadSessionDataStore table
            clientSession.DownloadLink(downloadUri);

            clientSession.DataStoreGroup(dataStoreGroup);
            clientSessions.addEnd(clientSession);

            if (clientSessions.elements() >= sessionResultSetting.SessionListPageSize())
            {
                break;
            }
        }

        return clientSessions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDataDownloadParametersForTransformationFromDataGroups</Name>
				<Source><![CDATA[
	/// <summary>
    /// Gets the list of download sessions for passed data groups.
    /// </summary>
    /// <param name = "retailCdxDataGroup">The <c>RetailCDXDataGroup</c> object.</param>
    /// <param name = "sessionResultSetting">The <c>RetailCDXDownloadSessionResultSetting</c> object.</param>
    /// <returns>List of download sessions.</returns>
    private static List GetDataDownloadParametersForTransformationFromDataGroups(RetailCDXDataGroup retailCdxDataGroup, RetailCDXDownloadSessionResultSetting sessionResultSetting = new RetailCDXDownloadSessionResultSetting())
    {
        // Get the DownloadSessions max result size using the feature control flag.
        int downloadSessionsMaxResultSize = RetailCDXFeatureControl::getDownloadSessionsMaxResultSize();

        if (sessionResultSetting.SessionListPageSize() <= 0 || sessionResultSetting.SessionListPageSize() > downloadSessionsMaxResultSize)
        {
            // set page size to max allowed by the back end if its not set or is greater than the maximum allowed.
            sessionResultSetting.SessionListPageSize(downloadSessionsMaxResultSize);
        }

        RetailCDXDownloadSession downloadSession;
        RetailTmpRecId acknowledgedRecId;
        List clientSessions = new List(Types::Class);

        while select RecId, JobID, FileSize, CheckSum, DataFileOutputPath, Session, DataGroup from downloadSession
            order by downloadSession.Session
            where downloadSession.DataGroup == retailCdxDataGroup.RecId
            && downloadSession.AcknowledgedForTransformation == NoYes::No
        {
            // Get all datastore
            List dataStores = RetailCDXDownloadSession::GetAllDataStores(downloadSession.RecId);
            RetailCDXDataStoreGroup dataStoreGroup = new RetailCDXDataStoreGroup(retailCdxDataGroup.Name, retailCdxDataGroup.RecId, dataStores);
            RetailAsyncClientDownloadSession clientSession = RetailCDXDownloadService::createAsyncClientDownloadSession(downloadSession);

            RetailCDXFilePathOrGuid downloadUri;
            System.Exception ex;

            try
            {
                downloadUri = RetailCDXDownloadService::getDownloadUriWithTokenTimeOut(downloadSession);
            }
            catch(ex)
            {
                ApplicationEventSource::EventWriteRetailCdxGetDownloadSessionPackageUriFailureWarning(downloadSession.Session, downloadSession.JobID, ex.ToString());
            }

            // downloadUri will be empty if failed to get package link, and the client will handle empty URI and update RetailCDXDownloadSessionDataStore table
            clientSession.DownloadLink(downloadUri);
            clientSession.DataStoreGroup(dataStoreGroup);
            clientSessions.addEnd(clientSession);

            acknowledgedRecId.ReferenceRecId = downloadSession.RecId;
            acknowledgedRecId.doInsert();

            if (clientSessions.elements() >= sessionResultSetting.SessionListPageSize())
            {
                break;
            }
        }

        RetailCDXDownloadSession downloadSession2;
        
        ttsbegin;

		update_recordset downloadSession2
			setting
			AcknowledgedForTransformation = NoYes::Yes
			join acknowledgedRecId
			where downloadSession2.RecId == acknowledgedRecId.ReferenceRecId;

        ttscommit;
        
        return clientSessions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDownloadUriWithTokenTimeOut</Name>
				<Source><![CDATA[
    private static RetailCDXFilePathOrGuid getDownloadUriWithTokenTimeOut(RetailCDXDownloadSession downloadSession)
    {
        RetailCDXFilePathOrGuid downloadUri;

        RetailConnParameters schedulerParameter = RetailConnParameters::find();
        RetailCDXPackageLinkValidDuration sasTokenTimeout = schedulerParameter.getSasTokenTimeout();

        downloadUri = RetailCDXPackageStore::getPackageLink(downloadSession.DataGroup,
                                                                RetailCDXDownloadUpload::Download,
                                                                downloadSession.DataFileOutputPath,
                                                                sasTokenTimeout);

        return downloadUri;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAsyncClientDownloadSession</Name>
				<Source><![CDATA[
	/// <summary>
    /// Get the download session in the RetailAsyncClientDownloadSession object format.
    /// </summary>
    /// <param name = "downloadSession">The <c>RetailCDXDownloadSession</c> object.</param>
    /// <returns>The <c>RetailAsyncClientDownloadSession</c> object.</returns>
    private static RetailAsyncClientDownloadSession createAsyncClientDownloadSession(RetailCDXDownloadSession downloadSession)
    {
        RetailAsyncClientDownloadSession clientSession = new RetailAsyncClientDownloadSession();
        clientSession.Id(downloadSession.RecId);
        clientSession.SessionId(downloadSession.Session);
        clientSession.JobId(downloadSession.JobID);
        clientSession.FileSize(downloadSession.FileSize);
        clientSession.CheckSum(downloadSession.CheckSum);

        RetailConnSchedulerJobTable connSchedulerjob;

        select firstonly description
                from connSchedulerjob
                where connSchedulerjob.jobId == downloadSession.JobID;

        clientSession.JobDescription(connSchedulerjob.translatedDescription());

        return clientSession;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataStoreNameList2str</Name>
				<Source><![CDATA[
    /// <summary>
    /// Concatenates RetailCDXDataStore list elements name into a string.
    /// </summary>
    /// <param name="_dataStoreNames">
    /// A list of <c>RetailCDXDataStore</c> objects.
    /// </param>
    /// <returns>
    /// A string created from a list.
    /// </returns>
    private static str dataStoreNameList2str(List _dataStoreNames)
    {
        str				dataStoreName;
        str				_delimiter = ', ';
        ListIterator    listIterator = new ListIterator(_dataStoreNames);

        while (listIterator.more())
        {
            RetailCDXDataStore cdxDataStore = listIterator.value();

            dataStoreName += cdxDataStore.Name();
            listIterator.next();
            
			if (listIterator.more())
            {
                dataStoreName += _delimiter;
            }
        }

        return dataStoreName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetInitialDownloadSessionsList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get initialization download sessions for the specified data store.
    /// </summary>
    /// <param name = "dataStoreName">Data store name.</param>
    /// <param name = "hasBeenInitializedBefore">Bypass full sync check later in the code.</param>
    /// <returns>List of download sessions created for initializing the data store.</returns>
    internal static List GetInitialDownloadSessionsList(str dataStoreName, boolean hasBeenInitializedBefore)
    {
        List clientSessions = new List(Types::Class);

        int initialDownloadSessionCount = RetailCDXDownloadService::createInitialDownloadSessions(dataStoreName, hasBeenInitializedBefore);

        if (initialDownloadSessionCount > 0)
        {
            clientSessions = RetailCDXDownloadService::GetDownloadSessions(dataStoreName);
        }

        return clientSessions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInitialDownloadSessions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the set of initial download sessions required to fully initialize the specifed data store.
    /// This is done by including the last existing full sync download session for each of the jobs tied to the datastore and all subsequent incremental download sessions.
    /// By relying on existing download sessions the need for generating a full sync session package is avoided. Instead we use last existing full sync package plus all of its subesquent incremental sync which in effect is equivalent a fresh full sync.
    /// </summary>
    /// <param name = "dataStoreName">The data store name.</param>
    /// <param name = "hasBeenInitializedBefore">Indicates if the data store has been initialized before.</param>
    /// <returns>The count of created initial download sessions.</returns>
    /// <remarks>
    /// Note:
    ///     The data store reinitialization can be overriden by 'RetailTerminalTable.isRunFullSyncOnTerminalUpgradeEnabled' column of the terminal using the specified data store.
    ///     If that column is set to false then the set of intial download sessions required to re-initialize the data store wont be created as reinitialization behavior is being overridden.
    ///     If an existing full sync session is not found for any of the jobs feeding the datastore then NO new initial download sessions will be created as re-initialization using combination of existing
    ///     full and subsequent delta sync sessions are not avaialble.
    /// </remarks>
    private static int createInitialDownloadSessions(str dataStoreName, boolean hasBeenInitializedBefore = false)
    {
        RetailConnDatabaseProfile dataStore;

        select dataStore where dataStore.Name == dataStoreName;

        if (!dataStore)
        {
            throw Global::error(strfmt("@Retail:CDXDataStoreNotExistError", dataStoreName));
        }

        if (!dataStore.DataGroup)
        {
            throw Global::error(strfmt("@Retail:CdxDataGroupNotSetError", dataStoreName));
        }
        
        // If the delayed offline session is not enabled, follow the previous implementation
        if (!RetailCdxFeatureControl::isDelayedOfflineDownloadSessionCreationEnabled())
        {
            // If run full sync on terminal upgrade is not enabled, abort the creation of initial download sessions
            if (!RetailCDXDownloadService::isRunFullSyncOnTerminalUpgradeEnabled(dataStore.RecId))
            {
                return 0;
            }
        }
        // If the delayed offline session creation is enabled...
        else
        {
            // ...and if database has been initialized before or it has already download sessions(*)...
            // (* dataStore.hasAnyDownloadSession() is for backward compatibility when client is not updated and not setting 
            // hasBeenInitializedBefore and hasBeenInitializedBefore value is defaulted to false)
            if (hasBeenInitializedBefore || dataStore.hasAnyDownloadSession())
            {
                // ...abort the creation of initial download sessions, unless the run full sync on terminal upgrade is enabled.
                if (!RetailCDXDownloadService::isRunFullSyncOnTerminalUpgradeEnabled(dataStore.RecId))
                {
                    return 0;
                }
            }
        }


        int downloadSessionsCount;
        container skippedJobs;

        ttsbegin;

        [skippedJobs, downloadSessionsCount] = RetailTerminalTable::initializeDatabaseDownloadSessions(dataStore);
        
        // If for any of the jobs used by this datastore we cannot find a last full sync session that can be reused to re-initialize the datastore then
        // its not possibly to fully re-initialize(populate) the datastore so abort the intial download session creation.
        // Still some jobs do not have corresponding full package available
        // throw error, suggest manual full sync
        if (conLen(skippedJobs) > 0)
        {
            ttsabort;

            throw Global::error(strFmt("@Retail:CdxFullPackageMissingError", con2Str(skippedJobs)));
        }
        else
        {
            ttscommit;
        }

        return downloadSessionsCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDownloadSessionsAX63</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get list of download sessions in XML for all AX 2012 R3 channels.
    /// </summary>
    /// <returns>List of download sessions in XML for all AX 2012 R3 channels</returns>
    public static List GetDownloadSessionsAX63()
    {
        RetailConnSchedulerJobTable connSchedulerjob;
        RetailCDXDownloadSession downloadSession;
        RetailCDXDownloadSessionDataStore downloadSessionDataStore1, downloadSessionDataStore2;
        RetailCDXDataGroup dataGroup;
        RetailConnChannelSchema channelSchema;
        Microsoft.Dynamics.Retail.SynchLibrary.Metadata.DownloadSession downloadSessionObj;

        List clientSessions = new List(Types::String);
        select firstonly RecId from channelSchema where channelSchema.SchemaName == RetailCDXConstants::AX2012R3SchemaName;

        // all AX63 download sessions that has any DownloadSessionDataStore records in the following status
        //   Available, Requested, DownloadFailed
        while select RecId, JobID, FileSize, CheckSum, DataGroup from downloadSession
          order by downloadSession.Session
          where downloadSession.Status == RetailCDXDownloadSessionStatus::Available
          exists join downloadSessionDataStore1
            where downloadSession.RecId == downloadSessionDataStore1.Session
               && (
                      downloadSessionDataStore1.Status == RetailCDXDownloadSessionStatus::Available
                   || downloadSessionDataStore1.Status == RetailCDXDownloadSessionStatus::DownloadFailed
                  )
            exists join dataGroup
              where downloadSession.DataGroup == dataGroup.RecId
                 && dataGroup.ChannelSchema == channelSchema.RecId
        {
            downloadSessionObj = new Microsoft.Dynamics.Retail.SynchLibrary.Metadata.DownloadSession(
                downloadSession.RecId,
                downloadSession.JobID,
                downloadSession.FileSize,
                downloadSession.CheckSum,
                downloadSession.DataGroup);
            
            while select forupdate downloadSessionDataStore2
                where downloadSessionDataStore2.Session == downloadSession.RecId
                   && (
                          downloadSessionDataStore2.Status == RetailCDXDownloadSessionStatus::Available
                       || downloadSessionDataStore2.Status == RetailCDXDownloadSessionStatus::DownloadFailed
                      )
            {
                if (downloadSessionDataStore2)
                {
                    downloadSessionObj.AddSessionDataStore(downloadSessionDataStore2.RecId, downloadSessionDataStore2.DataStore);
                }
            }

            clientSessions.addEnd(downloadSessionObj.GetDownloadSessionXml());
        }

        return clientSessions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDownloadUriOnly</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get download uri for download session.
    /// </summary>
    /// <param name = "downloadSessionId">The download session id.</param>
    /// <returns>The download session Azure Blob Uri.</returns>
    public static str GetDownloadUriOnly(int64 downloadSessionId)
    {
        RetailCDXDownloadSession downloadSession;
        RetailConnParameters schedulerParameter;

        schedulerParameter = RetailConnParameters::find();

        select firstonly DataFileOutputPath, DataGroup
            from downloadSession
            where downloadSession.RecId == downloadSessionId;

        try
        {
            RetailCDXFilePathOrGuid url = RetailCDXPackageStore::getPackageLink(
                downloadSession.DataGroup,
                RetailCDXDownloadUpload::Download,
                downloadSession.DataFileOutputPath,
                schedulerParameter.getSasTokenTimeout()
            );

            return url;
        }
        catch (Exception::CLRError)
        {
            throw Global::error(strfmt("@Retail:CDXGetDownloadLinkError", downloadSessionId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDownloadUri</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get download uri for download session.
    /// </summary>
    /// <param name = "dataStoreName">Data store name.</param>
    /// <param name = "downloadSessionId">Download session id.</param>
    /// <returns>The download session Azure Blob Uri.</returns>
    public static str GetDownloadUri(str dataStoreName, int64 downloadSessionId)
    {
        RetailCDXFilePathOrGuid uri;

        try
        {
            RetailConnParameters schedulerParameter = RetailConnParameters::find();

            RetailCDXDownloadSession downloadSession;
            select firstonly DataFileOutputPath, DataGroup
             from downloadSession
              where downloadSession.RecId == downloadSessionId;

            uri = RetailCDXPackageStore::getPackageLink(
            downloadSession.DataGroup,
            RetailCDXDownloadUpload::Download,
            downloadSession.DataFileOutputPath,
            schedulerParameter.getSasTokenTimeout()
            );
        }
        catch (Exception::CLRError)
        {
            System.Exception ex = RetailUtilities::getLatestClrException();
            str errorMsg = ex != null ? ex.ToString() : '';
            RetailCDXDownloadService::UpdateDownloadSessionStatusWithParameters(dataStoreName, downloadSessionId, RetailCDXDownloadSessionStatus::DownloadFailed, DateTimeUtil::minValue(), 0, errorMsg);
            // Set uri to emtpy if there is exception.
            uri = "";
        }

        return uri;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDownloadInterval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get download interval for data store.
    /// </summary>
    /// <param name = "dataStoreName">Data store name</param>
    /// <returns>Download interval</returns>
    public static int GetDownloadInterval(str dataStoreName)
    {
        RetailConnDatabaseProfile dbProfile;
        RetailCDXSchedulerInterval schedulerInterval;

        select firstonly dbProfile where dbProfile.Name == dataStoreName;

        if (dbProfile)
        {
            RetailCDXDataStoreHeartbeatLog::LogAccess(dbProfile.RecId);
        }

        select firstonly schedulerInterval join dbProfile
            where dbProfile.SchedulerInterval == schedulerInterval.RecId
            && dbProfile.Name == dataStoreName;

        return schedulerInterval.DownloadInterval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetTerminalDataStoreName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get data store name for terminal.
    /// </summary>
    /// <param name = "terminalId">Terminal id</param>
    /// <returns>Data store name.</returns>
    public static str GetTerminalDataStoreName(str terminalId)
    {
        RetailConnDatabaseProfile dbProfile = RetailConnDatabaseProfile::findByTerminalId(terminalId);

        if (dbProfile)
        {
            RetailCDXDataStoreHeartbeatLog::LogAccess(dbProfile.RecId);
        }

        return dbProfile.Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDataDownloadParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the data download parameters object that contain the information required for applying a download session on a target database.
    /// </summary>
    /// <param name = "dataStoreName">The datastore name.</param>
    /// <param name = "wasChannelUpgraded">Do we require data initialization?</param>
    /// <param name = "hasBeenInitializedBefore">Bypass full sync check later in the code.</param>
    /// <param name = "sessionResultSetting">The download session result setting.</param>
    /// <returns>The <c>RetailCDXDataDownloadParameters</c> object.</returns>
    internal static RetailCDXDataDownloadParameters GetDataDownloadParameters(str dataStoreName, boolean wasChannelUpgraded, boolean hasBeenInitializedBefore, RetailCDXDownloadSessionResultSetting sessionResultSetting = new RetailCDXDownloadSessionResultSetting())
    {
        RetailConnDatabaseProfile dbProfile = RetailConnDatabaseProfile::find(dataStoreName);

        RetailCDXDataStore cdxDataStore = new RetailCDXDataStore(dbProfile.Name, dbProfile.RecId);

        List downloadSessions = new List(Types::Class);
        RetailCDXSchedulerInterval schedulerInterval;

        if (dbProfile)
        {
            RetailCDXDataStoreHeartbeatLog::LogAccess(dbProfile.RecId);

            select firstonly DownloadInterval from schedulerInterval
            where schedulerInterval.RecId == dbProfile.SchedulerInterval;

			if (wasChannelUpgraded)
            {
                downloadSessions = RetailCDXDownloadService::GetInitialDownloadSessionsList(dataStoreName, hasBeenInitializedBefore);
            }
            else
            {
                downloadSessions = RetailCDXDownloadService::GetDownloadSessionList(dataStoreName, sessionResultSetting);
            }
        }

        List cdxFeatureControlList  = RetailCdxFeatureControl::getFeatureControlList();

        // populate the info required by the data download paramer object.
        return  RetailCDXDataDownloadParameters::create(cdxDataStore, schedulerInterval.DownloadInterval, downloadSessions, cdxFeatureControlList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDataDownloadParametersForTransformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the data download parameters object that contain the information required to transform a download session.
    /// </summary>
    /// <param name = "dataStoreNames">The list of datastore names.</param>
    /// <param name = "sessionIds"> The list of session IDs to be retrieved is explicitly provided
    /// then the GetDataDownloadParametersForTransformation will ignore other parameters and return only details of the specified session IDs.</param>
    /// <param name = "sessionResultSetting">The download session result setting.</param>
    /// <returns>The <c>RetailCDXDataDownloadParameters</c> object.</returns>
    internal static RetailCDXDataDownloadParameters GetDataDownloadParametersForTransformation(List dataStoreNames, List sessionIds = null, RetailCDXDownloadSessionResultSetting sessionResultSetting = new RetailCDXDownloadSessionResultSetting())
    {
        RetailCDXDataGroup retailCdxDataGroup;
        RetailTmpRecId distinctDataGroupIds = RetailConnDatabaseProfile::getDistinctDataGroupRecIds(dataStoreNames);

        List downloadSessions = new List(Types::Class);

        while select Name, RecId from retailCdxDataGroup
            join distinctDataGroupIds
            where retailCdxDataGroup.RecId == distinctDataGroupIds.ReferenceRecId
        {
            List resultDownloadSessions = new List(Types::Class);

            if (sessionIds != null && sessionIds.elements() > 0)
            {
                resultDownloadSessions = RetailCDXDownloadService::GetDataDownloadParametersForTransformationFromSessionIds(retailCdxDataGroup, sessionIds, sessionResultSetting);
            }
            else
            {
                resultDownloadSessions = RetailCDXDownloadService::GetDataDownloadParametersForTransformationFromDataGroups(retailCdxDataGroup, sessionResultSetting);
            }

            downloadSessions.appendList(resultDownloadSessions);
        }

        List cdxFeatureControlList  = RetailCdxFeatureControl::getFeatureControlList();

        // populate the info required by the data download paramer object.
        return  RetailCDXDataDownloadParameters::create(/*RetailCDXDataStore*/ null, /*DownloadInterval*/ 0, downloadSessions, cdxFeatureControlList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>UpdateDownloadSessionStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update download session status for download sessions.
    /// </summary>
    /// <param name = "downloadSession">The download session.</param>
    public static void UpdateDownloadSessionStatus(RetailAsyncClientDownloadSessionUpdateStatus downloadSession)
    {
        utcdatetime dateDownloaded;

        if (downloadSession.paramDateDownloaded() != null)
        {
            dateDownloaded = str2Datetime(downloadSession.paramDateDownloaded(), 321);
        }
        else
        {
            dateDownloaded = DateTimeUtil::minValue();
        }

        RetailCDXDownloadService::UpdateDownloadSessionStatusWithParameters(downloadSession.paramDataStoreName(), downloadSession.paramId(), downloadSession.paramStatus(), dateDownloaded, downloadSession.paramRowsAffected(), downloadSession.paramMessage());
    }

]]></Source>
			</Method>
			<Method>
				<Name>UpdateDownloadSessionStatusWithParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update download session status.
    /// </summary>
    /// <param name = "dataStoreName">Data store name.</param>
    /// <param name = "downloadSessionId">Download session.</param>
    /// <param name = "status">Download session status</param>
    /// <param name = "dateDownloaded">Time when downloading the file.</param>
    /// <param name = "rowsAffected">The number of rows affected</param>
    /// <param name = "message">Message</param>
    public static void UpdateDownloadSessionStatusWithParameters(str dataStoreName, int64 downloadSessionId, RetailCDXDownloadSessionStatus status, utcdatetime dateDownloaded, int rowsAffected, str message)
    {
        RetailCDXDownloadSessionDataStore downloadSessionDataStore;
        RetailConnDatabaseProfile dbProfile;

        select firstonly RecId from dbProfile where dbProfile.Name == dataStoreName;

        if (!dbProfile)
        {
            throw Global::error(strfmt("@Retail:CDXDataStoreNotExistError", dataStoreName));
        }

        ttsbegin;

        // Note ForUpdate will use optimistic locking set on the RetailCDXDownloadSessionDataStore table
        // We need pessimistic lock which will enforce one update at a time and will remove the conflict exceptions
        select firstonly1 pessimisticLock downloadSessionDataStore
            where downloadSessionDataStore.DataStore == dbProfile.RecId
               && downloadSessionDataStore.Session == downloadSessionId;

        // If the status is already Canceled, then we will not allow the status to be updated from the client
        if (downloadSessionDataStore && downloadSessionDataStore.Status != RetailCDXDownloadSessionStatus::Canceled)
        {
            downloadSessionDataStore.DateDownloaded = dateDownloaded;

            if (status == RetailCDXDownloadSessionStatus::Applied)
            {
                downloadSessionDataStore.DateApplied = DateTimeUtil::utcNow();
            }

            downloadSessionDataStore.Status = status;
            downloadSessionDataStore.Message = message;
            downloadSessionDataStore.RowsAffected += rowsAffected;

            if (status == RetailCDXDownloadSessionStatus::ApplyFailed || status == RetailCDXDownloadSessionStatus::DownloadFailed)
            {
                downloadSessionDataStore.TryCount += 1;

                if (downloadSessionDataStore.TryCount >= RetailConnParameters::GetCDXTryCount())
                {
                    if (RetailCdxFeatureControl::isDownloadSessionDependencyEnforcementEnabled())
                    {
                        downloadSessionDataStore.Status = RetailCDXDownloadSessionStatus::Suspended;
                    }
                    else
                    {
                        downloadSessionDataStore.Status = RetailCDXDownloadSessionStatus::Canceled;
                    }
                }
            }

            downloadSessionDataStore.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>MarkFileDownloaded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Mark if the data package file has been successfully downloaded for AX 2012 R3 clients.
    /// </summary>
    /// <param name = "downloadSessionId">Download session Id.</param>
    /// <param name = "isDownloadSuccessful">True if data package file is downloaded successfully, otherwise, false.</param>
    /// <param name = "message">Error message, when the data package file is not downloaded successfully.</param>
    public static void MarkFileDownloaded(RetailCDXDownloadSessionRefRecId downloadSessionId, boolean isDownloadSuccessful, RetailCDXMonDataSyncMessage message)
    {
        RetailCDXDownloadSessionDataStore downloadSessionDataStore;
        RetailCDXDownloadSessionStatus downloaded;
        utcdatetime downloadDateTime = DateTimeUtil::utcNow();
        
        if (isDownloadSuccessful)
        {
            downloaded = RetailCDXDownloadSessionStatus::Downloaded;
        }
        else
        {
            downloaded = RetailCDXDownloadSessionStatus::DownloadFailed;
        }

        // N-1. update the status for all downloadSessionDataStore records with the specified download session Id.
        // Called when the data package file is downloaded. By setting status to Downloaded, the file won't be downloaded again.
        update_recordset downloadSessionDataStore
            setting DateRequested = downloadDateTime, DateDownloaded = downloadDateTime, Status = downloaded, Message = message, TryCount = downloadSessionDataStore.TryCount + 1
            where downloadSessionDataStore.Session == downloadSessionId
               && downloadSessionDataStore.Status != RetailCDXDownloadSessionStatus::Canceled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ValidateDataStore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate data store.
    /// </summary>
    /// <param name = "dataStoreName">Data store name</param>
    /// <returns>If data store is valid.</returns>
    public static boolean ValidateDataStore(str dataStoreName, str userName)
    {
        RetailConnDatabaseProfile dbProfile;
        if (strlen(dataStoreName) == 0)
        {
            return false;
        }

        //Check if data store name exists in database.
        select firstonly dbProfile
            where dbProfile.Name == dataStoreName
            && dbProfile.UserName == userName;

        if (!dbProfile)
        {
            return false;
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDownloadSessionsString</Name>
				<Source><![CDATA[
    /// <summary>
    /// This is a workaround method to get download session in a string.
    /// </summary>
    /// <param name = "dataStoreName"></param>
    /// <returns></returns>
    public static str GetDownloadSessionsString(str dataStoreName)
    {
        List sessions = RetailCDXDownloadService::GetDownloadSessions(dataStoreName);
        ListIterator   literator;
        str returnSessionString = '';
        str sessionString = '';
        literator = new ListIterator(sessions);

        while (literator.more())
        {
            RetailAsyncClientDownloadSession currentSession = literator.value();
            sessionString = 'Id=' + int642str(currentSession.Id()) + ';JobId=' + currentSession.JobId() + ';FileSize=' + int642str(currentSession.FileSize()) + 'Checksum=' + currentSession.CheckSum();
            returnSessionString += sessionString + '|';
            literator.next();
        }

        return returnSessionString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>UploadDownloadSessionStatusAX63</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update download session status for AX 2012 R3 clients.
    /// </summary>
    /// <param name = "downloadSessionStatusCollection">The collection of download session status details.</param>
    public static void UploadDownloadSessionStatusAX63(List downloadSessionStatusCollection)
    {
        RetailCDXDownloadSessionDataStore downloadSessionDataStore;
        ListEnumerator statusEnumerator = downloadSessionStatusCollection.getEnumerator();

        ttsbegin;

        while (statusEnumerator.moveNext())
        {
            RetailAsyncClientDownloadSessionUpdateStatus status = statusEnumerator.current();
            
            select firstonly forupdate downloadSessionDataStore
                where downloadSessionDataStore.RecId == status.paramId()
                   && downloadSessionDataStore.Status != RetailCDXDownloadSessionStatus::Canceled;

            if (downloadSessionDataStore)
            {
                downloadSessionDataStore.Status = status.paramStatus();
                downloadSessionDataStore.DateApplied = str2Datetime(status.paramDateDownloaded(), 321);

                // When the session is cancelled after retrying maxtrycount times the async connector service 
                // sends a generic 'maxtrycount is reached' error message instead of the actual underling error. 
                // Hence append the message to the original actual error message instead of overwriting it with a generic error.
                if (status.paramStatus() == RetailCDXDownloadSessionStatus::Canceled)
                {
                    downloadSessionDataStore.Message = strFmt('%1%2%3',downloadSessionDataStore.Message, ' ',  status.paramMessage());
                }
                else
                {
                    downloadSessionDataStore.Message = status.paramMessage();
                }

                downloadSessionDataStore.TryCount = downloadSessionDataStore.TryCount + 1;
                downloadSessionDataStore.update();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRunFullSyncOnTerminalUpgradeEnabled</Name>
				<Source><![CDATA[
    private static boolean isRunFullSyncOnTerminalUpgradeEnabled(RefRecId dataStoreRecId)
    {
        RetailTerminalTable terminal;

        select firstonly RunFullSyncOnTerminalUpgrade from terminal
            where terminal.OfflineDatabaseProfile == dataStoreRecId;

        return (terminal && terminal.RunFullSyncOnTerminalUpgrade == NoYes::Yes);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>