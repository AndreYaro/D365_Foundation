<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailStatementPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Post the Retail statement.
/// </summary>
/// <remarks>
/// Post the statement amount and related tax amounts, discounts and payment transactions accordingly.
/// </remarks>
[SysObsolete('This class is obsolete. Use RetailEodStatementPostBatchScheduler instead.', true, 30\11\2019)]
[SysOperationJournaledParameters(false)]
class RetailStatementPost extends RunBaseBatch implements BatchRetryable
{
    RetailStatementTable   statementTable;
    RetailStoreTable       storeTable;
    RetailParameters       parameters;

    CustTable   custTable;

    Object callerObject;

    LedgerVoucher               ledgerVoucher;
    LedgerVoucherObject         ledgerVoucherObject;
    LedgerVoucherTransObject    ledgerVoucherTransObject;

    Map                         voucherList;

    NumberSeq                   numberSeq ;

    SysOperationProgress    operationProgress;

    RetailStatementId  statementId;

    // <GEERU>
    boolean                     countryRegion_W;
    boolean                     countryRegion_RU;
    // </GEERU>

    // <GBR>
    boolean                     countryRegion_BR;
    // </GBR>

    RetailStatementPaymentJournal transactionStatementPaymentJournal;

    #define.CurrentVersion(1)

    #localmacro.CurrentList
        statementId
    #endmacro

    #define.LessThan('..')
    #define.SalesVoucher(0)
    #define.PaymentVoucher(1)
    #define.MaxTaxDifference(0.005)

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountPeriodicDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the ledger account for periodic discount for the periodic discount type, discount amount, item and customer account passed as parameter.
    /// </summary>
    /// <param name="_offerId">
    /// The current value for the <c>RetailPeriodicOfferId</c>.
    /// </param>
    /// <param name="_periodicDiscAmount">
    /// The current value for the periodic discount amount.
    /// </param>
    /// <param name="_itemId">
    /// The current value of item ID.
    /// </param>
    /// <param name="_itemGroupId">
    /// The current value of Item group ID.
    /// </param>
    /// <param name="_custAccount">
    /// The current value of customer account.
    /// </param>
    /// <returns>
    /// The ledger account to which periodic discount is posted.
    /// </returns>
    /// <remarks>
    /// The ledger account returned is based on whether it is discount offer, mix and match or multibuy.
    /// </remarks>
    LedgerDimensionDefaultAccount accountPeriodicDisc(RetailDiscountOfferId _offerId, DiscAmount _periodicDiscAmount, ItemId _itemId, RetailItemGroupId _itemGroupId, CustAccount _custAccount)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        LedgerDimensionDefaultAccount   ret;
        RetailPeriodicDiscount          periodicDiscount;
        RetailParameters                retailParameters;

        retailParameters = RetailParameters::find();
        
        switch (retailParameters.LedgerAccountType)
        {
            case    RetailBookingLedgerAccountTypeBase::Periodic   :
                periodicDiscount = RetailPeriodicDiscount::findByOfferId(_offerId);
                
                if (periodicDiscount.DiscountLedgerDimension)
                {
                    ret = periodicDiscount.DiscountLedgerDimension;
                }
                else
                {
                    ret = this.getLedgerDimensionByDiscountType(periodicDiscount.PeriodicDiscountType, retailParameters);
                }
                
                break;
            case    RetailBookingLedgerAccountTypeBase::Standard   :
                ret = this.accountSalesDisc(_itemId, _itemGroupId, _custAccount);
                
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionByDiscountType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return ledger dimension according to the discount type.
    /// </summary>
    /// <param name = "_discountType">Discount type.</param>
    /// <param name = "_retailParameters">Retail parameters.</param>
    /// <returns>Ledger dimension.</returns>
    private LedgerDimensionDefaultAccount getLedgerDimensionByDiscountType(RetailDiscountOfferTypeBase _discountType, RetailParameters _retailParameters)
    {
        LedgerDimensionDefaultAccount ret;

        switch (_discountType)
        {
            case RetailDiscountOfferTypeBase::DiscountOffer:
            case RetailDiscountOfferTypeBase::DiscountOfferLineQuantityLimit:
                ret = _retailParameters.OfferLedgerDimension;
                break;
            case RetailDiscountOfferTypeBase::MixAndMatch:
            case RetailDiscountOfferTypeBase::LeastExpensiveFavorRetailer:
                ret = _retailParameters.MixMatchLedgerDimension;
                break;
            case RetailDiscountOfferTypeBase::Multibuy:
                ret = _retailParameters.MultiBuyLedgerDimension;
                break;
            case RetailDiscountOfferTypeBase::Threshold:
                ret = _retailParameters.ThresholdLedgerDimension;
                break;
            default:
                EventHandlerResult result = new EventHandlerResult();

                this.getLedgerDimensionByDiscountTypeDelegate(_discountType, _retailParameters, result);

                if (result.hasResult())
                {
                    ret = result.result();
                }

                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionByDiscountTypeDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for retrieving the correct ledger dimension by discount type.
    /// </summary>
    /// <param name = "_discountType">Discount type.</param>
    /// <param name = "_retailParameters">Retail parameters.</param>
    /// <param name = "_result">Subscribes need to update the result with the correct ledger dimension related to the customized discount type.</param>
    delegate void getLedgerDimensionByDiscountTypeDelegate(RetailDiscountOfferTypeBase _discountType, 
        RetailParameters _retailParameters,
        EventHandlerResult _result)
    {
        // Subscriber will provide proper implementation to this method
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountSales</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the ledger account for sales revenue for the item and customer account passed as parameter.
    /// </summary>
    /// <param name="_itemId">
    /// The current value of item ID.
    /// </param>
    /// <param name="_itemGroupId">
    /// The current value of Item group ID.
    /// </param>
    /// <param name="_custAccount">
    /// The current value of customer account.
    /// </param>
    /// <returns>
    /// The ledger account to which sales revenue is posted.
    /// </returns>
    /// <remarks>
    /// Calls the method <c>accountItemLedgerDimension</c> to find the ledger account.
    /// </remarks>
    LedgerDimensionDefaultAccount accountSales(ItemId _itemId, RetailItemGroupId _itemGroupId, CustAccount _custAccount)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());
        
        return InventPosting::accountItemLedgerDimensionFromParameters(
            this.buildAccountItemLedgerDimensionParameter(
                InventAccountType::SalesRevenue,
                _itemId,
                _itemGroupId,
                _custAccount,
                CustTable::find(_custAccount).CustGroup,
                CustTable::find(_custAccount).TaxGroup));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildAccountItemLedgerDimensionParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a parameter for searching an inventory posting account ledger dimension for an item.
    /// </summary>
    /// <param name="_inventAccountType">An inventory account type.</param>
    /// <param name="_itemId">An item Id.</param>
    /// <param name="_itemGroupId">An item group Id.</param>
    /// <param name="_custAccount">A customer account.</param>
    /// <param name="_accountGroup">An account group.</param>
    /// <param name="_taxGroup">A sales tax group.</param>
    /// <returns>The built parameter instance.</returns>
    protected InventPostingAccountItemLedgerDimensionParameters buildAccountItemLedgerDimensionParameter(
        InventAccountType _inventAccountType,
        ItemId _itemId,
        ItemGroupId _itemGroupId,
        CustAccount _custAccount,
        CustVendGroupId _accountGroup,
        TaxGroup _taxGroup)
    {
        return InventPostingAccountItemLedgerDimensionParameters::newFromParameters(
            _inventAccountType,
            _itemId,
            _itemGroupId,
            0,
            _custAccount,
            _accountGroup,
            _taxGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountSalesDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the ledger account for sales discount for the item and customer account passed as parameter.
    /// </summary>
    /// <param name="_itemId">
    /// The current value of item ID.
    /// </param>
    /// <param name="_itemGroupId">
    /// The current value of Item group ID.
    /// </param>
    /// <param name="_custAccount">
    /// The current value of customer account.
    /// </param>
    /// <returns>
    /// The ledger account to which sales discount is posted.
    /// </returns>
    /// <remarks>
    /// Calls the method <c>accountItemLedgerDimension</c> to find the ledger account.
    /// </remarks>
    LedgerDimensionDefaultAccount accountSalesDisc(ItemId _itemId, RetailItemGroupId _itemGroupId, CustAccount _custAccount)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        return InventPosting::accountItemLedgerDimensionFromParameters(
             this.buildAccountItemLedgerDimensionParameter(
                InventAccountType::SalesDisc,
                _itemId,
                _itemGroupId,
                _custAccount,
                CustTable::find(_custAccount).CustGroup,
                CustTable::find(_custAccount).TaxGroup));
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountTotalDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the ledger account for total discount for the discount amount passed as parameter.
    /// </summary>
    /// <param name="_custAccount">
    /// The current value of customer account.
    /// </param>
    /// <param name="_totalDiscAmount">
    /// The current value of the total discount amount.
    /// </param>
    /// <returns>
    /// The ledger account to which total discount is posted.
    /// </returns>
    /// <remarks>
    /// If the ledger account is not found the posting will be cancelled.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// End the operation if the ledger account to which the total discount is to be posted is not found.
    /// </exception>
    LedgerDimensionDefaultAccount accountTotalDisc(CustAccount _custAccount, DiscAmount _totalDiscAmount)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        LedgerDimensionDefaultAccount   ret;
        str             transType;
        ;
        if (_custAccount)
        {
            transType = "@SYS21195";

            ret =  LedgerSystemAccounts::find(LedgerPostingType::CustInvoiceDisc).LedgerDimension;
        }
        else
        {
            transType = "@SYS6465";

            if (RetailParameters::find().TotalDiscountLedgerDimension)
            {
                ret = RetailParameters::find().TotalDiscountLedgerDimension;
            }
        }

        if (!ret && _totalDiscAmount)
        {
            checkFailed(strfmt("@SYS24816",transType));
            error("@SYS21533");
            error("@SYS93289");
            throw error("@SYS78886");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>concatTransTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Concatenate both the texts passed as the parameter.
    /// </summary>
    /// <param name="_firstTxt">
    /// The first text to which it should concatenated.
    /// </param>
    /// <param name="_secondTxt">
    /// The second text to which it should be concatenated.
    /// </param>
    /// <returns>
    /// The concatenated text.
    /// </returns>
    private TransactionTextLarge concatTransTxt(TransactionTextLarge _firstTxt, TransactionTextLarge _secondTxt)
    {
        TransactionTextLarge concatTxt = (_firstTxt == '') ? '' : ' - ';

        return _firstTxt + concatTxt + _secondTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>concludePost_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Mark fiscal receipts as posted.
    /// </summary>
    /// <param name = "_statementTable">The current instance of <c>RetailStatementTable</c> table.</param>
    protected void concludePost_BR(RetailStatementTable _statementTable)
    {
        RetailFiscalReceipt_BR  fiscalReceipt;
        RetailTransactionTable  transactionTable;

        // Voided fiscal receipts are not processed in the statement
        update_recordSet fiscalReceipt
            setting IsStatementPosted   = NoYes::Yes,
                    Voucher             = ''
            where   fiscalReceipt.StoreId   == _statementTable.storeId
                &&  fiscalReceipt.Status    == FiscalDocumentStatus_BR::Cancelled
            join transactionTable
            where   transactionTable.Transactionid  == fiscalReceipt.Transactionid
                &&  transactionTable.terminal       == fiscalReceipt.TerminalId
                &&  transactionTable.store          == fiscalReceipt.StoreId
                &&  transactionTable.statementId    == "";
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentLedgerTrans</Name>
				<Source><![CDATA[
    private void createPaymentLedgerTrans(RetailAccountType _accountType,
                                  LedgerPostingType _ledgerPostingType,
                                  LedgerDimensionDefaultAccount _ledgerAccount,
                                  CurrencyCode _currencyCode,
                                  AmountCur _amountCur,
                                  TableId _tableId,
                                  RecId _recId,
                                  TransDate _transDate,
                                  str _transTxt,
                                  str _documentNumber,
                                  int _voucherType = #PaymentVoucher
                                  )
    {
        BankAccountTable                        bankAccountTable;
        LedgerTransTxt                          transTxtType = LedgerTransTxt::LedgerClosing;
        BankAccountID                           bankAccountID;
        BankVoucher                             bankVoucher;
        ;

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepStart(0, 'createPaymentLedgerTrans');

        if (_amountCur)
        {
            this.initVoucher(_transDate, _voucherType);
            bankAccountID                      = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_ledgerAccount);

            switch (_accountType)
            {
                case RetailLedgerBank::Ledger:
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucherObject,
                                                                                                     _ledgerPostingType,
                                                                                                     LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerAccount, statementTable.DefaultDimension),
                                                                                                     _currencyCode,
                                                                                                     _amountCur,
                                                                                                     CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate()));
                    ledgerVoucherTransObject.parmSourceTableId(_tableId);
                    ledgerVoucherTransObject.parmSourceRecId(_recId);
                    ledgerVoucherTransObject.parmSkipBlockedForManualEntryCheck(true);

                    if (_ledgerPostingType == LedgerPostingType::SalesCash)
                    {
                        transTxtType = LedgerTransTxt::CustCashPayment;
                    }
                    else if (_ledgerPostingType == LedgerPostingType::MSTDiff)
                    {
                        transTxtType = LedgerTransTxt::LedgerMSTDiff;
                    }
                    this.setLVTOTransTxt(ledgerVoucherTransObject, transTxtType, _transTxt);
                    ledgerVoucher.addTrans(ledgerVoucherTransObject);

                    break;
                case RetailLedgerBank::Bank:
                    bankAccountTable = BankAccountTable::find(bankAccountID);
                    bankVoucher = BankVoucher::newBankVoucher(_amountCur,
                                                         _currencyCode,
                                                         bankAccountID,
                                                         '',
                                                         '',
                                                         '',
                                                         _transTxt,
                                                         LedgerPostingType::Bank,
                                                         statementTable.DefaultDimension,
                                                         bankAccountTable.LedgerDimension,
                                                         '',
                                                         ExchangeRateHelper::exchRate(_currencyCode, _transDate));
                    bankVoucher.parmSourceTableId(_tableId);
                    bankVoucher.parmSourceRecId(_recId);

                    bankVoucher.post(ledgerVoucher);

                    break;
            }
        }

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepEnd(0, 'createPaymentLedgerTrans');
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the statement from the <c>RetailStatementTable</c>, <c>RetailStatementLine</c> and <c>RetailCashDecalaration</c>.
    /// </summary>
    /// <param name="_statementTable">
    /// The record os the statement to be deleted
    /// </param>
    void deleteStatement(RetailStatementTable _statementTable)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        RetailStatementLine    statementLine;
        RetailCashDeclaration  cashDeclaration;
        ;

        _statementTable.reread();

        delete_from statementLine
            where statementLine.StatementId == _statementTable.StatementId;

        delete_from cashDeclaration
            where cashDeclaration.StatementId == _statementTable.StatementId;

        _statementTable.doDelete();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the exchange rate for the given currency or for the given store.
    /// </summary>
    /// <param name="_date">
    /// The date for which the exchage rate is claculated
    /// </param>
    /// <param name="_currency">
    /// The currency for which the exchange rate is calculated
    /// </param>
    /// <param name="_store">
    /// The store for which the exchange rate is calculated.
    /// </param>
    /// <returns>
    /// Exchange rateof the currency.
    /// </returns>
    exchRate getExchRate(date _date, CurrencyCode _currency, RetailStoreId _store)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        ExchRate                    exchRate = 0;
        ExchangeRate                exchRates;
        ExchangeRateCurrencyPair    currencyPair;
        RefRecId                    exchangeRateType;
        RetailSharedParameters      retailSharedParameters;
        CurrencyCode                currencyCode = !_currency ? RetailStoreTable::find(_store).Currency : _currency;
        ;

        exchRate = ExchangeRateHelper::getExchangeRate1_Static(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                        currencyCode,
                        _date);

        retailSharedParameters = retailSharedParameters::find(false);

        exchangeRateType = retailSharedParameters.ExchangeRateType;

        select validtimestate(_date) exchRates
            join RecId, FromCurrencyCode, ToCurrencyCode, ExchangeRateType from currencyPair
            where exchRates.ExchangeRateCurrencyPair == currencyPair.RecId
            && currencyPair.FromCurrencyCode == currencyCode && currencyPair.ToCurrencyCode == _currency
            && currencyPair.ExchangeRateType == exchangeRateType;

        if (exchRates != null)
        {
            exchRate = exchRates.ExchangeRate;
        }

        return exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFiscalDocumentPost_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a class to post Fiscal documents based on a Fiscal document model 2 record.
    /// </summary>
    /// <param name="_fiscalDocumentModel2">
    /// A record of <c>RetailFiscalDocumentModel2_BR</c>.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// An optional <c>Voucher</c> that the Fiscal document will be linked to.
    /// </param>
    /// <returns>
    /// An instance of <c>FiscalDocumentPost_BR</c>.
    /// </returns>
    public FiscalDocumentPost_BR getFiscalDocumentPost_BR(RetailFiscalDocumentModel2_BR _fiscalDocumentModel2,
                                                          Voucher                       _ledgerVoucher)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        return new FiscalDocumentPost_BR(
            FiscalDocumentParmDataCreator_BR::fromFiscalDocumentModel2(
                _fiscalDocumentModel2,
                _ledgerVoucher));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromArgs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize <c>RetailStatementTable</c> with the caller record.
    /// </summary>
    /// <param name="_args">
    /// Details of the caller datasource.
    /// </param>
    /// <remarks>
    /// Calls the <c>StatementTable</c> method to initialize the table.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// The caller dataset is not <c>RetailStatementTable</c> table.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Must be called with parameter.
    /// </exception>
    void initFromArgs(Args _args)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        if (_args && _args.dataset())
        {
            switch (_args.dataset())
            {
                case tablenum(RetailStatementTable) :
                    this.statementTable(_args.record());
                    break;
                default :
                    throw error ("@RET4156");
            }
            callerObject = _args.caller();
        }
        else
        {
            throw error ("@RET4156");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>statementTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns the current record of the <c>RetailStatementTable</c> table to the variable statementTable.
    /// </summary>
    /// <param name="_statementTable">
    /// The current record of the <c>RetailStatementTable</c> table
    /// </param>
    /// <returns>
    /// Returns the variable statementTable after assigning the current record of <c>RetailStatementTable</c> table.
    /// </returns>
    public RetailStatementTable statementTable(RetailStatementTable _statementTable = statementTable)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        statementTable = _statementTable;

        this.parmStatementId(statementTable.statementId);

        return statementTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate the voucher from the voucher series based on the last voucher.
    /// </summary>
    /// <param name="_transDate">
    /// The posting date of the statement.
    /// </param>
    /// <param name="_ledgerVoucherTag">
    /// The current value of voucher.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Statement voucher number sequence is not specified.
    /// </exception>
    void initVoucher(TransDate  _transDate = statementTable.postingDate, int _ledgerVoucherTag = #SalesVoucher)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        NumberSequenceTable numberSequence;
        Voucher             voucher;
        RefRecId            voucherNumSeqId;

        if (voucherList.exists([_transDate, _ledgerVoucherTag]))
        {
            voucher = voucherList.lookup([_transDate, _ledgerVoucherTag]);
        }

        if (!ledgerVoucher || (voucher != ledgerVoucher.lastVoucher()))
        {
            storeTable = RetailStoreTable::find(statementTable.StoreId);
            voucherNumSeqId = RetailStatementVoucher::numberSequenceId(statementTable.storeId);

            if (voucherNumSeqId == 0)
            {
                throw error(strfmt("@RET4157", storeTable.StoreNumber));
            }

            numberSequence = NumberSequenceTable::find(voucherNumSeqId);
            if (!ledgerVoucher)
            {
                ledgerVoucher = LedgerVoucher::newLedgerPost(RetailParameters::find().DetailSummary, SysModule::Retail, numberSequence.NumberSequence);
            }

            if (!voucher)
            {
                voucher = NumberSeq::newGetNumFromId(voucherNumSeqId).num();

                ledgerVoucherObject = LedgerVoucherObject::newVoucher(voucher, _transDate, SysModule::Retail, LedgerTransType::Sales, NoYes::No);
                ledgerVoucher.addVoucher(ledgerVoucherObject);

                voucherList.insert([_transDate, _ledgerVoucherTag], voucher);
            }

            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject(voucher, _transDate);

            ledgerVoucher.lastTransDate(ledgerVoucherObject.parmTransDate());
            ledgerVoucher.lastVoucher(ledgerVoucherObject.parmVoucher());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertStatementJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the record in the <c>RetailStatementJour</c> and <c>RetailStatementTrans</c> after the posting of statement.
    /// </summary>
    /// <param name="_statementTable">
    /// The current instance of Statement table.
    /// </param>
    /// <remarks>
    /// Finds the voucher value after posting and inserts to the <c>RetailStatementVoucher</c> table.
    /// </remarks>
    void insertStatementJour(RetailStatementTable _statementTable)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        RetailStatementJour        statementJour;
        RetailStatementTrans       statementTrans;

        MapIterator             voucherIterator;
        TransDate               transDate;
        int                     ledgerVoucherTag;
        Voucher                 voucher;
        RetailStatementVoucher     statementVoucher;

        RetailStatementLine        statementLine;
        LedgerVoucherObject     lvObj;
        ;

        statementJour = RetailStatementJour::find(_statementTable.StatementId, true);

        statementJour.initFromStatementTable(_statementTable);

        statementJour.NumberOfItemsBarcodesNotOnFile = _statementTable.itemsOrBarcodeNotOnFile();
        statementJour.NumberOfWrongShiftTransactions = _statementTable.transactionOnWrongShift();
        statementJour.SalesAmount = _statementTable.salesAmount();
        statementJour.TaxAmount = _statementTable.taxAmount();
        statementJour.TotalDiscAmount = _statementTable.totalDiscount();
        statementJour.LineDiscAmount = _statementTable.lineDiscount();
        statementJour.IncomeAmount = _statementTable.income();
        statementJour.ExpensesAmount = _statementTable.expenses();
        statementJour.NumberOfBlockedItems = _statementTable.numberOfBlockedItems();
        statementJour.NumberOfBlockedCustomers = _statementTable.numberOfBlockedCustomers();
        statementJour.NumberOfSalesPaymentDifferenceTrans = _statementTable.transactionsWithSaleOrPaymentDifference();
        statementJour.DefaultDimension = _statementTable.DefaultDimension;
        statementJour.PostedDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        statementJour.PostedTime = DateTimeUtil::getTimeNow(DateTimeUtil::getUserPreferredTimeZone());

        // <GEERU>
        if (countryRegion_RU)
        {
            statementJour.LoyaltyDiscAmount_RU = _statementTable.loyaltyDiscount_RU();
        }
        // </GEERU>

        if (statementJour)
        {
            statementJour.update();
        }
        else
        {
            statementJour.insert();
        }

        RetailTracer::Info('Posting', 'RetailStatementPost::insertStatementJour()',
                           'Displaying field values of statement header. Statement Id = %1, StatementDate = %2, StoreId = %3, ClosingMethod = %4, NumberOfItemsBarcodesNotOnFile = %5, NumberOfWrongShiftTransactions = %6, SalesAmount = %7, TaxAmount = %8,TotalDiscAmount = %9',
                            statementJour.statementId, statementJour.statementDate, statementJour.storeId, statementJour.closingMethod, statementJour.numberOfItemsBarcodesNotOnFile, statementJour.numberOfWrongShiftTransactions, statementJour.salesAmount, statementJour.taxAmount, statementJour.totalDiscAmount);
        RetailTracer::Info('Posting', 'RetailStatementPost::insertStatementJour()',
                           '--> Part 2: LineDiscAmount = %1, IncomeAmount = %2,ExpensesAmount = %3,NumberOfBlockedItems = %4, NumberOfSalesPaymentDifferenceTrans= %5, DefaultDimension= %6',
                           statementJour.lineDiscAmount, statementJour.incomeAmount, statementJour.expensesAmount, statementJour.numberOfBlockedItems, statementJour.numberOfSalesPaymentDifferenceTrans, statementJour.DefaultDimension);

        while select statementLine
            where statementLine.StatementId == _statementTable.StatementId
        {
            statementTrans = RetailStatementTrans::find(statementLine.StatementId, statementLine.LineNum, true);
            statementTrans.initFromStatementLine(statementLine);

            statementTrans.insert();
        }

        RetailTracer::Info('Posting', 'RetailStatementPost::insertStatementJour()',
                           'Displaying field values of statement trans. Statement Id = %1, LineNum = %2, StatementCode = %3, StaffId = %4, TerminalId = %5, CardTypeId = %6, Currency = %7, CountedAmount = %8, CountedAmountMST = %9, TenderTypeId = %10',
                            statementTrans.statementId, statementTrans.lineNum, statementTrans.statementCode, statementTrans.staffId, statementTrans.terminalId, statementTrans.cardTypeId, statementTrans.currency, statementTrans.countedAmountMST, statementTrans.tenderTypeId);
        RetailTracer::Info('Posting', 'RetailStatementPost::insertStatementJour()',
                           ' ---> PART 2: TransAmount = %11, DifferenceAmount = %13,DifferenceAmountMST = %14, OrderInvoiceAmount= %15, TransAmountStore = %16, BankedAmountStore = %17, CountedAmountStore = %18, DifferenceAmountStore=%19, SafeAmount= %20',
                            statementTrans.transAmount, statementTrans.differenceAmount, statementTrans.differenceAmountMST, statementTrans.orderInvoiceAmount, statementTrans.transAmountStore, statementTrans.bankedAmountStore, statementTrans.countedAmountStore, statementTrans.differenceAmountStore, statementTrans.safeAmount);
        RetailTracer::Info('Posting', 'RetailStatementPost::insertStatementJour()',
                           '---> PART 3: CardFeeAmount = %21',
                            statementTrans.cardFeeAmount);

        voucherIterator = new MapIterator(voucherList);

        while (voucherIterator.more())
        {
            [transDate, ledgerVoucherTag]  = voucherIterator.key();
            voucher = voucherIterator.value();

            lvObj = ledgerVoucher.findLedgerVoucherObject(voucher);
            if (lvObj && lvObj.transElements())
            {
                statementVoucher.statementId = _statementTable.statementId;
                statementVoucher.voucher = voucher;
                statementVoucher.voucherDate = transDate;

                statementVoucher.insert();
            }

            voucherIterator.next();
        }

        RetailTracer::Info('Posting', 'RetailStatementPost::insertStatementJour()',
                           'Displaying field values of statement voucher. Statement Id = %1, Voucher = %2, VoucherDate = %3',
                           statementVoucher.statementId, statementVoucher.voucher, statementVoucher.voucherDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>linkSalesOrderVouchersToStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the record in the <c>RetailStatementVoucher</c> for the posted sales order with the statment ID passed.
    /// </summary>
    /// <remarks>
    /// Links the tables <c>RetailStatementVoucher</c> table and <c>CustInvoiceJour</c> table through Statement ID.
    /// </remarks>
    void linkSalesOrderVouchersToStatement()
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        RetailStatementVoucher  statementVoucher;
        CustInvoiceJour         custInvoiceJour;
        RetailTransactionTable  transactionTable;
        RetailStatementId       currentStatementId;

        currentStatementId = statementTable.statementId;

        insert_recordset statementVoucher(statementId, voucher, voucherDate)
        select currentStatementId, ledgerVoucher, invoiceDate
        from custInvoiceJour
            group by custInvoiceJour.ledgerVoucher, custInvoiceJour.invoiceDate
        exists join transactionTable
            where   custInvoiceJour.InvoiceId       == transactionTable.invoiceId
                &&  transactionTable.store          == statementTable.storeId
                &&  transactionTable.statementId    == currentStatementId
                &&  transactionTable.invoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status as 'Posted' in all the posting tables after the Retail statement posting.
    /// </summary>
    /// <param name="_statementTable">
    /// The current instance of <c>RetailStatementTable</c> table.
    /// </param>
    void markTransactions(RetailStatementTable _statementTable)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        RetailTransactionTable                 transactionTable;
        RetailTransactionBankedTenderTrans     transactionBankedTenderTrans;
        RetailTransactionIncomeExpenseTrans    transactionIncomeExpenseTrans;
        RetailTransactionOrderInvoiceTrans     transactionOrderInvoiceTrans;
        RetailTransactionPaymentTrans          transactionPaymentTrans;
        RetailTransactionSafeTenderTrans       transactionSafeTenderTrans;
        RetailTransactionSalesTrans            transactionSalesTrans;

        int numberOfTransactions;
        int numberOfSalesTrans;
        int numberOfPaymentTrans;
        int numberOfSafeTenderTrans;
        int numberOfBankedTenderTrans;

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepStart(0, 'markTransactions');

        /*
        * Update sales transactions with backwards compatibility: If the new way to find inventTransId
        * for returns is in place, then we can set inventTransId to blank in sales transactions. Otherwise,
        * for backwards compatibility, we need to keep inventTransId value in sales transaction.
        */
        if (RetailStatementCompatibilityHelper::applyNewAggregationCriteria())
        {
            update_recordset transactionSalesTrans
                setting
                    InventStatusSales = RetailInventStatusSales::Posted,
                    TransactionStatus = RetailEntryStatus::Posted,
                    // This is the only difference between this update statement and the one from "else" condition below.
                    inventTransId     = ''
                where
                    transactionSalesTrans.TransactionStatus == RetailEntryStatus::None
                join transactionTable
                    where   transactionTable.TransactionId  == transactionSalesTrans.TransactionId
                        &&  transactionTable.Store          == transactionSalesTrans.Store
                        &&  transactionTable.Terminal       == transactionSalesTrans.TerminalId
                        &&  transactionTable.statementId    == _statementTable.statementId
                        &&  transactionTable.type           != RetailTransactionType::PhysicalInventory;
        }
        else
        {
            update_recordset transactionSalesTrans
                setting
                    InventStatusSales = RetailInventStatusSales::Posted,
                    TransactionStatus = RetailEntryStatus::Posted
                where
                    transactionSalesTrans.TransactionStatus == RetailEntryStatus::None
                join transactionTable
                    where   transactionTable.TransactionId  == transactionSalesTrans.TransactionId
                        &&  transactionTable.Store          == transactionSalesTrans.Store
                        &&  transactionTable.Terminal       == transactionSalesTrans.TerminalId
                        &&  transactionTable.statementId    == _statementTable.statementId
                        &&  transactionTable.type           != RetailTransactionType::PhysicalInventory;
        }

        numberOfSalesTrans = any2int(transactionSalesTrans.rowCount());

        /*
        * Update payment transactions table.
        */
        update_recordset transactionPaymentTrans
            setting TransactionStatus = RetailEntryStatus::Posted
                where transactionPaymentTrans.TransactionStatus == RetailEntryStatus::None
            join transactionTable
                where   transactionTable.TransactionId  == transactionPaymentTrans.TransactionId
                    &&  transactionTable.Store          == transactionPaymentTrans.Store
                    &&  transactionTable.Terminal       == transactionPaymentTrans.terminal
                    &&  transactionTable.statementId    == _statementTable.statementId
                    &&  transactionTable.type           != RetailTransactionType::PhysicalInventory;

        numberOfPaymentTrans = any2int(transactionPaymentTrans.rowCount());

        /*
        * Update banked tender transactions.
        */
        update_recordset transactionBankedTenderTrans
            setting TransactionStatus = RetailEntryStatus::Posted
                where transactionBankedTenderTrans.TransactionStatus == RetailEntryStatus::None
            join transactionTable
                where   transactionTable.TransactionId  == transactionBankedTenderTrans.TransactionId
                    &&  transactionTable.Store          == transactionBankedTenderTrans.Store
                    &&  transactionTable.Terminal       == transactionBankedTenderTrans.Terminal
                    &&  transactionTable.statementId    == _statementTable.statementId
                    &&  transactionTable.type           != RetailTransactionType::PhysicalInventory;

        numberOfBankedTenderTrans = any2int(transactionBankedTenderTrans.rowCount());

        /*
        *    Update safe tender transactions.
        */
        update_recordset transactionSafeTenderTrans
            setting TransactionStatus = RetailEntryStatus::Posted
                where transactionSafeTenderTrans.TransactionStatus == RetailEntryStatus::None
            join transactionTable
                where   transactionTable.TransactionId  == transactionSafeTenderTrans.TransactionId
                    &&  transactionTable.Store          == transactionSafeTenderTrans.Store
                    &&  transactionTable.Terminal       == transactionSafeTenderTrans.Terminal
                    &&  transactionTable.statementId    == _statementTable.statementId
                    &&  transactionTable.type           != RetailTransactionType::PhysicalInventory;

        numberOfSafeTenderTrans = any2int(transactionSafeTenderTrans.rowCount());

        /*
        *    Update income expense transactions.
        */
        update_recordset transactionIncomeExpenseTrans
            setting TransactionStatus = RetailEntryStatus::Posted
                where transactionIncomeExpenseTrans.TransactionStatus  == RetailEntryStatus::None
            join transactionTable
                where   transactionTable.TransactionId  == transactionIncomeExpenseTrans.TransactionId
                    &&  transactionTable.Store          == transactionIncomeExpenseTrans.Store
                    &&  transactionTable.Terminal       == transactionIncomeExpenseTrans.terminal
                    &&  transactionTable.statementId    == _statementTable.statementId
                    &&  transactionTable.type           != RetailTransactionType::PhysicalInventory;

        /*
        *    Update transaction order invoice table.
        */
        update_recordset transactionOrderInvoiceTrans
            setting TransactionStatus = RetailEntryStatus::Posted
                where   transactionOrderInvoiceTrans.TransactionStatus  == RetailEntryStatus::None
            join transactionTable
                where   transactionTable.TransactionId  == transactionOrderInvoiceTrans.TransactionId
                    &&  transactionTable.Store          == transactionOrderInvoiceTrans.storeId
                    &&  transactionTable.Terminal       == transactionOrderInvoiceTrans.TerminalId
                    &&  transactionTable.statementId    == _statementTable.statementId
                    &&  transactionTable.type           != RetailTransactionType::PhysicalInventory;

        /*
        *    Lastly, update the transaction table.
        */
        update_recordset transactionTable
            setting EntryStatus = RetailEntryStatus::Posted
                where   transactionTable.store          == _statementTable.storeId
                    &&  transactionTable.StatementId    == _statementTable.StatementId
                    &&  transactionTable.Type           != RetailTransactionType::PhysicalInventory;

        numberOfTransactions = any2int(transactionTable.rowCount());

        /*
        *   Cycle through manually entered RetailTransactionBankedTenderTrans.
        *   These transactions do not have a transaction header and are deleted if the statement is cleared.
        */
        update_recordSet transactionBankedTenderTrans
            setting TransactionStatus = RetailEntryStatus::Posted
                where   transactionBankedTenderTrans.Store              == statementTable.storeId
                    &&  transactionBankedTenderTrans.StatementId        == statementTable.StatementId
                    &&  transactionBankedTenderTrans.TransactionStatus  == RetailEntryStatus::None
                    &&  transactionBankedTenderTrans.StatusType         == RetailBankedStatusTypeBase::Manual;

		numberOfBankedTenderTrans = any2int(transactionBankedTenderTrans.rowCount());

        /*
        *   Cycle through manually entered RetailTransactionSafeTenderTrans.
        *   These transactions do not have a transaction header and are deleted if the statement is cleared.
        */
        update_recordSet transactionSafeTenderTrans
            setting TransactionStatus = RetailEntryStatus::Posted
                where   transactionSafeTenderTrans.Store                == statementTable.storeId
                    &&  transactionSafeTenderTrans.StatementId          == statementTable.StatementId
                    &&  transactionSafeTenderTrans.TransactionStatus    == RetailEntryStatus::None
                    &&  transactionSafeTenderTrans.StatusType           == RetailSafeStatusTypeBase::Manual;

        numberOfSafeTenderTrans = any2int(transactionSafeTenderTrans.rowCount());

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepEnd(0, 'markTransactions');
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        super();

        // <GEERU>
        #EECountryRegionCodes
        #ISOCountryRegionCodes

        countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // <GEERU>

        // <GBR>
        countryRegion_BR = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR]);
        // </GBR>

        voucherList = new Map(Types::Container,Types::String);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStatementId</Name>
				<Source><![CDATA[
    public RetailStatementId parmStatementId(RetailStatementId _statementId = statementId)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        if (statementId != _statementId)
        {
            statementId = _statementId;
            statementTable = RetailStatementTable::find(statementId);
        }

        return statementId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAggregatedDiscounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post aggregated discounts.
    /// </summary>
    /// <remarks>
    /// calls the method <c>PostDiscounts</c> to post the discounted amount for each record of <c>RetailTransactionSalesTrans</c> table.
    /// </remarks>
    void postAggregatedDiscounts()
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        void postAggregatedDiscountsPriv(boolean _forSales)
        {
            QueryRun                    aggregateQueryRun;
            Query                       aggregateQuery;
            RetailTransactionSalesTrans    transactionSalesTrans;
            RetailTransactionDiscountTrans transactionDiscountTrans;
            str                         documentNumber;

            aggregateQueryRun = new QueryRun(querystr(RetailAggregatedSalesForDiscounts));
            aggregateQuery = aggregateQueryRun.query();

            // Filter for current store
            aggregateQuery.dataSourceTable(tablenum(RetailTransactionSalesTrans)).addRange(fieldnum(RetailTransactionSalesTrans, store)).value(statementTable.storeId);

            // Filter for current statement
            aggregateQuery.dataSourceTable(tablenum(RetailTransactionSalesTrans)).addRange(fieldnum(RetailTransactionSalesTrans, StatementId)).value(statementTable.StatementId);

            // Filter for Retail Transaction Type Sales
            //     Included (Not yet processed):
            //         - Cash & Carry to consumer. (Sales)
            //         - Cash & Carry to Loyalty customer. (Sales)
            //     Excluded (Already processed from other retail flows)
            //         - RTS real time Customer Orders (CustomerOrder)
            //         - Online Orders (PendingSalesOrder)
            //         - Asynchronous Customer Quotes (AsyncCustomerQuote)
            //         - Asynchronous Customer Orders (AsyncCustomerOrder)
            //     The periodic discounts for the Excluded orders, if any, were already captured by other flows:
            //         - Customer Orders:
            //             - RetailTransactionSericeOrders.createCustomerOrder() flow
            //         - Online Orders, Asynchronous Customer Quotes, Asynchronous Customer Orders:
            //             - RetailOnlineOrderSynchronizer.CreateOrder() flow
            aggregateQuery.dataSourceTable(tablenum(RetailTransactionTable)).addRange(fieldnum(RetailTransactionTable, type)).value(queryValue(RetailTransactionType::Sales));

            // Filter for periodic discount
            aggregateQuery.dataSourceTable(tableNum(RetailTransactionDiscountTrans)).addRange(fieldNum(RetailTransactionDiscountTrans, DiscountOriginType)).value(queryValue(RetailDiscountOriginType::Periodic));
            if ( _forSales)
            {
                aggregateQuery.dataSourceTable(tablenum(RetailTransactionSalesTrans)).addRange(fieldnum(RetailTransactionSalesTrans, qty)).value(#LessThan + queryValue(0));
            }
            else
            {
                aggregateQuery.dataSourceTable(tablenum(RetailTransactionSalesTrans)).addRange(fieldnum(RetailTransactionSalesTrans, qty)).value(queryValue(0) + #LessThan);
            }

            // Run through the aggregated sales posting vouchers.
            while (aggregateQueryRun.next())
            {
                transactionSalesTrans = aggregateQueryRun.get(tablenum(RetailTransactionSalesTrans));
                transactionDiscountTrans = aggregateQueryRun.get(tablenum(RetailTransactionDiscountTrans));
                documentNumber = statementTable.StatementId;

                RetailTracer::Info('Posting', 'RetailStatementPost::postAggregatedDiscounts()',
                                   'Displaying field values of RetailTransactionSalesTrans. ItemId = %1, Store = %2,  Terminal = %3, taxGroup = %4, TaxItemGroup = %5, DefaultDimension = %6, TransactionId = %7',
                                    transactionSalesTrans.itemId, transactionSalesTrans.store, transactionSalesTrans.terminalId, transactionSalesTrans.taxGroup, transactionSalesTrans.TaxItemGroup, transactionSalesTrans.DefaultDimension, transactionSalesTrans.transactionId);

                RetailTracer::Info('Posting', 'RetailStatementPost::postAggregatedDiscounts()',
                                   'Displaying field values of RetailTransactionDiscountTrans. PeriodicDiscountOfferId = %1, DiscountCost = %2,  TransactionId = %3',
                                   transactionDiscountTrans.PeriodicDiscountOfferId, transactionDiscountTrans.DiscountCost, transactionDiscountTrans.TransactionId);

                this.postDiscounts(documentNumber, transactionSalesTrans, transactionDiscountTrans, transactionSalesTrans.Currency, transactionSalesTrans.CustAccount);
            }
        }

        ;
        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepStart(0, 'postAggregatedDiscounts');

        postAggregatedDiscountsPriv(true);
        postAggregatedDiscountsPriv(false);

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepEnd(0, 'postAggregatedDiscounts');
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCrossCompanyGiftcard</Name>
				<Source><![CDATA[
    private void postCrossCompanyGiftcard()
    {
        RetailTransactionSalesTrans     giftcardSalesTrans;
        RetailTransactionPaymentTrans   giftcardPaymentTrans;
        LedgerJournalName               journalName;
        NumberSeq                       journalNumSeq;
        LedgerJournalTable              ledgerJournal;
        LedgerJournalTrans              ledgerJournalTrans;
        RetailStoreTenderTypeTable      storeTenderTypeTable;
        DataAreaId                      giftcardCompany;
        RetailStatementVoucher          statementVoucher;

        void createPaymentLedgerTrans(
                    LedgerDimensionAccount _accountNum,
                    LedgerDimensionAccount _offsetAccountNum,
                    CurrencyCode           _currency,
                    AmountCur              _Amount,
                    TransDate              _date)
        {
            LedgerJournalTrans ledgerJournalLine;

            if (!_Amount)
            {
                return;
            }

            if (!_accountNum || !_offsetAccountNum)
            {
                // Account number or offset account number is not correctly set up, intercompany gift card posting can't proceed.
                throw error("@REX4040024");
            }

            ledgerJournalLine.initValue();

            ledgerJournalLine.JournalNum = ledgerJournal.JournalNum;
            ledgerJournalLine.AccountType = LedgerJournalACType::Ledger;
            ledgerJournalLine.Company = curext();
            ledgerJournalLine.LedgerDimension = _accountNum;

            ledgerJournalLine.OffsetCompany = RetailGiftCardPostingParameters::getGiftCardCompany();
            ledgerJournalLine.OffsetLedgerDimension = _offsetAccountNum;
            ledgerJournalLine.OffsetAccountType = LedgerJournalACType::Ledger;

            ledgerJournalLine.CurrencyCode = _currency;
            ledgerJournalLine.TransDate = _date;

            ledgerJournalLine.DocumentNum = statementTable.statementId;
            ledgerJournalLine.TransactionType = LedgerTransType::Transfer;

            if (_Amount < 0)
            {
                ledgerJournalLine.AmountCurDebit = abs(_Amount);
            }
            else
            {
                ledgerJournalLine.AmountCurCredit = _Amount;
            }

            ledgerJournalLine.defaultRow();

            ledgerJournalLine.insert();
        }

        giftcardCompany = RetailGiftCardPostingParameters::getGiftCardCompany();
        if (!giftcardCompany || giftcardCompany == curext())
        {
            // No intercompany giftcard posting is needed.
            return;
        }

        // <GEERU>
        if (RetailParameters::find().ProcessGiftCardsAsPrepayments_RU)
        {
            // Standard intercompany giftcard posting should be skipped.
            return;
        }
        // </GEERU>

        select journalName from journalName where journalName.JournalName == RetailGiftCardPostingParameters::getGiftCardLedgerJournalName();

        if (!journalName)
        {
            // Journal name is not correctly set up, intercompany gift card posting can't proceed.
            throw error("@REX4040023");
        }

        // Get the number sequence for slip journal document
        journalNumSeq = NumberSeq::newGetNum(LedgerParameters::numRefJournalNum());

        // Create ledger journal

        ledgerJournal.JournalName = journalName.JournalName;
        ledgerJournal.JournalType = journalName.JournalType;
        ledgerJournal.JournalNum = journalNumSeq.num();
        ledgerJournal.NumberSequenceTable = journalName.NumberSequenceTable;
        ledgerJournal.RetailStatementId = statementTable.statementId;

        ledgerJournal.insert();

        // Create ledger journal lines.
        while select sum(netAmount) from giftcardSalesTrans
        group by statementId, businessDate, currency
        where   giftcardSalesTrans.store                == statementTable.storeId
            &&  giftcardSalesTrans.statementId          == statementTable.statementId
            &&  (   giftcardSalesTrans.itemId           == RetailParameters::find().GiftcardItem
                    ||  giftcardSalesTrans.giftcard     == NoYes::Yes)
            &&  giftcardSalesTrans.transactionStatus    != RetailEntryStatus::Voided
        {
            if (giftcardSalesTrans.netAmount)
            {
                createPaymentLedgerTrans(
                            RetailGiftCardPostingParameters::getSalesOrderAccountNumber(curext(), statementTable.DefaultDimension),
                            RetailGiftCardPostingParameters::getSalesOrderAccountNumber(RetailGiftCardPostingParameters::getGiftCardCompany(), statementTable.DefaultDimension),
                            giftcardSalesTrans.currency,
                            giftcardSalesTrans.netAmount,
                            giftcardSalesTrans.businessDate);
            }
        }

        storeTenderTypeTable = RetailGiftCardPostingParameters::getStoreGiftcardTenderType(statementTable.storeId);

        while select sum(amountCur) from giftcardPaymentTrans
        group by statementId, businessDate, currency
        where   giftcardPaymentTrans.store              == statementTable.storeId
            &&  giftcardPaymentTrans.statementId        == statementTable.statementId
            &&  giftcardPaymentTrans.tenderType         == storeTenderTypeTable.tenderTypeId
            &&  giftcardPaymentTrans.transactionStatus  != RetailEntryStatus::Voided
        {
            if (giftcardPaymentTrans.amountCur)
            {
                createPaymentLedgerTrans(
                            LedgerDimensionFacade::serviceCreateLedgerDimension(RetailGiftCardPostingParameters::getGiftcardPaymentAccount(statementTable.storeId), statementTable.DefaultDimension),
                            RetailGiftCardPostingParameters::getInterCompanySalesPostingAccount(RetailGiftCardPostingParameters::getGiftCardCompany(), statementTable.storeId, statementTable.DefaultDimension),
                            giftcardPaymentTrans.currency,
                            giftcardPaymentTrans.amountCur,
                            giftcardPaymentTrans.businessDate);
            }
        }

        // Post the journal
        select firstonly RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == ledgerJournal.JournalNum;

        if (ledgerJournalTrans.RecId)
        {
            LedgerJournalPost::postJournal(ledgerJournal, NoYes::No, false, true);

            // Link voucher to statement
            RetailStatementId currentStatementId = statementTable.statementId;

            insert_recordset statementVoucher (voucher, voucherDate, statementId)
                select Voucher, TransDate, currentStatementId from ledgerJournalTrans
                    group by ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate
                    where ledgerJournalTrans.JournalNum == ledgerJournal.JournalNum;
        }
        else
        {
            ledgerJournal.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postDiscounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post the discounted amount.
    /// </summary>
    /// <param name="_documentNumber">
    /// The statement ID of the <c>RetailTransactionSalesTrans</c> table.
    /// </param>
    /// <param name="_transactionSalesTrans">
    /// The current instance of <c>RetailTransactionSalesTrans</c> table.
    /// </param>
    /// <param name="_transactionDiscountTrans">
    /// The current instance of <c>RetailTransactionDiscountTrans</c> table.
    /// </param>
    /// <param name="_currencyCode">
    /// The curreny code of the record <c>RetailTransactionSalesTrans</c> table.
    /// </param>
    /// <param name="_custAccount">
    /// The customer account of the record <c>RetailTransactionSalesTrans</c> table.
    /// </param>
    void postDiscounts(
        str _documentNumber,
        RetailTransactionSalesTrans _transactionSalesTrans,
        RetailTransactionDiscountTrans _transactionDiscountTrans,
        CurrencyCode _currencyCode,
        CustAccount _custAccount)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        CurrencyCode        currencyCode;
        LedgerPostingType   ledgerPostingType;
        DiscAmount          periodicDiscount;
        LedgerDimensionDefaultAccount       accountPeriodicDisc, accountDisc;
        ExchRate            exchRate;
        DimensionDefault    defaultDimensionMerged;

        ;
        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepStart(0, 'postDiscounts');

        RetailTracer::Info('Posting', 'RetailStatementPost::postDiscounts()', 'Post discount parameters: postPeriodicDisc=%1, ledgerAccountType=%2', parameters.postPeriodicDisc, parameters.ledgerAccountType);

        if (parameters.postPeriodicDisc && (parameters.ledgerAccountType == RetailBookingLedgerAccountTypeBase::Periodic)
            && (_transactionDiscountTrans.DiscountOriginType == RetailDiscountOriginType::Periodic)
        )
        {
            accountPeriodicDisc = this.accountPeriodicDisc(
                    _transactionDiscountTrans.PeriodicDiscountOfferId,
                    _transactionDiscountTrans.DiscountCost,
                    _transactionSalesTrans.ItemId,
                    '' /*_transactionSalesTrans.ItemGroupId*/,
                    _custAccount);
            accountDisc = InventPosting::accountItemLedgerDimensionFromParameters(
                this.buildAccountItemLedgerDimensionParameter(
                    InventAccountType::SalesDisc,
                    _transactionSalesTrans.ItemId,
                    '',
                    _custAccount,
                    _transactionSalesTrans.taxGroup,
                    _transactionSalesTrans.TaxItemGroup));

            RetailTracer::Info('Posting', 'RetailStatementPost::postDiscounts()',
                               'Post discount accounts: PeriodicDiscountOfferId=%1, accountPeriodicDisc=%2',
                               _transactionDiscountTrans.PeriodicDiscountOfferId, accountPeriodicDisc);

            if (accountPeriodicDisc && accountDisc && (accountPeriodicDisc != accountDisc))
            {
                this.initVoucher(_transactionSalesTrans.businessDate);

                currencyCode = _currencyCode;

                if (!currencyCode)
                {
                    currencyCode = storeTable.Currency;
                }

                ledgerPostingType   = _custAccount ? LedgerPostingType::CustInvoiceDisc : LedgerPostingType::SalesDisc;

                exchRate = this.getExchRate(_transactionSalesTrans.businessDate, _currencyCode, _transactionSalesTrans.Store);

                periodicDiscount    = accountPeriodicDisc && parameters.PostPeriodicDisc ? _transactionDiscountTrans.DiscountCost : 0;

                defaultDimensionMerged = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(_transactionSalesTrans.DefaultDimension,
                                                                                                    InventTable::find(_transactionSalesTrans.itemId).DefaultDimension);

                if (accountDisc && periodicDiscount)
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucherObject,
                                                                                            LedgerPostingType::SalesDisc,
                                                                                            LedgerDimensionFacade::serviceCreateLedgerDimension(
                                                                                                accountDisc,
                                                                                                defaultDimensionMerged),
                                                                                            currencyCode,
                                                                                            -periodicDiscount,
                                                                                            CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate()));

                    ledgerVoucherTransObject.parmSourceTableId(_transactionDiscountTrans.TableId);
                    ledgerVoucherTransObject.parmSourceRecId(_transactionDiscountTrans.RecId);
                    ledgerVoucherTransObject.parmSkipBlockedForManualEntryCheck(true);
                    this.setLVTOTransTxt(ledgerVoucherTransObject, LedgerTransTxt::SalesEndDisc,
                            "@RET4320" + " - " +
                            "@RET4443"      + _transactionSalesTrans.TransactionId +
                            "@RET4444"      + _transactionSalesTrans.Store +
                            "@RET4445"      + _transactionSalesTrans.TerminalId);
                    ledgerVoucher.addTrans(ledgerVoucherTransObject);
                }

                if (parameters.PostPeriodicDisc && _transactionDiscountTrans.DiscountCost && accountPeriodicDisc)
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucherObject,
                                                                                    LedgerPostingType::SalesDisc,
                                                                                    LedgerDimensionFacade::serviceCreateLedgerDimension(
                                                                                        accountPeriodicDisc,
                                                                                        defaultDimensionMerged),
                                                                                    currencyCode,
                                                                                    _transactionDiscountTrans.DiscountCost,
                                                                                    CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate()));

                    ledgerVoucherTransObject.parmSourceTableId(_transactionDiscountTrans.TableId);
                    ledgerVoucherTransObject.parmSourceRecId(_transactionDiscountTrans.RecId);
                    ledgerVoucherTransObject.parmSkipBlockedForManualEntryCheck(true);
                    this.setLVTOTransTxt(ledgerVoucherTransObject, LedgerTransTxt::SalesEndDisc,
                        "@RET3071" + " - " + _transactionDiscountTrans.PeriodicDiscountOfferId);
                    ledgerVoucher.addTrans(ledgerVoucherTransObject);
                }

                //Posting of the inventory transaction

                ledgerVoucherObject.lastTransTxt(
                    this.concatTransTxt(ledgerVoucherObject.lastTransTxt(),
                    "@RET4319" + " - " +
                    "@RET4443"      + _transactionSalesTrans.TransactionId +
                    "@RET4444"      + _transactionSalesTrans.Store +
                    "@RET4445"      + _transactionSalesTrans.TerminalId));

                ledgerVoucherObject.parmDocument(_transactionSalesTrans.businessDate, _documentNumber);
            }
            else
            {
                warning("@RET260885");
                RetailTracer::Warning('Posting', 'RetailStatementPost::postDiscounts()', "@RET260885");
            }
        }
        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepEnd(0, 'postDiscounts');
    }

]]></Source>
			</Method>
			<Method>
				<Name>postFiscalDocumentModel2_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes a Fiscal document model 02 created at the POS.
    /// </summary>
    /// <param name="_transactionTable">
    /// The Retail sales transaction related to the Fiscal receipt.
    /// </param>
    /// <returns>
    /// True if a Fiscal document model 02 was found related to the Sales transaction; otherwise, false.
    /// </returns>
    protected boolean postFiscalDocumentModel2_BR(RetailTransactionTable _transactionTable)
    {
        boolean                         documentFound = false;
        CustInvoiceJour                 custInvoiceJour;
        FiscalDocumentPost_BR           fiscalDocumentPost;
        RetailFiscalDocumentModel2_BR   fiscalDocumentModel2;

        // Retrieve the fiscal document model 2 associated to the retail transaction
        fiscalDocumentModel2 = RetailFiscalDocumentModel2_BR::find(_transactionTable.transactionId,
                                                                   _transactionTable.Store,
                                                                   _transactionTable.terminal);

        if (fiscalDocumentModel2)
        {
            // Get the voucher
            select ledgerVoucher from custInvoiceJour
                where   custInvoiceJour.InvoiceId   == _transactionTable.invoiceId
                    &&  custInvoiceJour.InvoiceDate == _transactionTable.businessDate;

            // Post the fiscal document model 2
            fiscalDocumentPost = this.getFiscalDocumentPost_BR(fiscalDocumentModel2, custInvoiceJour.ledgerVoucher);
            fiscalDocumentPost.run();

            documentFound = true;
        }

        return documentFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postFiscalReceipt_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes a Fiscal receipt originally created at the POS.
    /// </summary>
    /// <param name="_transactionTable">
    /// The Retail sales transaction related to the Fiscal receipt.
    /// </param>
    /// <returns>
    /// true if a Fiscal receipt was found related to the Sales transaction; otherwise, false.
    /// </returns>
    protected boolean postFiscalReceipt_BR(RetailTransactionTable _transactionTable)
    {
        boolean                 documentFound;
        CustInvoiceJour         custInvoiceJour;
        RetailFiscalReceipt_BR  fiscalReceipt;

        // Get the voucher
        select ledgerVoucher from custInvoiceJour
            where   custInvoiceJour.InvoiceId   == _transactionTable.invoiceId
                &&  custInvoiceJour.InvoiceDate == _transactionTable.businessDate;

        // Update "is posted" flag, voucher and fiscal establishment fields
        update_recordSet fiscalReceipt
            setting IsStatementPosted     = NoYes::Yes,
                    Voucher               = custInvoiceJour.ledgerVoucher
            where   fiscalReceipt.StoreId       == _transactionTable.Store
                &&  fiscalReceipt.TerminalId    == _transactionTable.terminal
                &&  fiscalReceipt.TransactionId == _transactionTable.transactionId;

        documentFound = (fiscalReceipt.RowCount() > 0);

        if (documentFound)
        {
            // The fiscal receipt might have a fiscal document model 02 linked to it
            this.postFiscalDocumentModel2_BR(_transactionTable);
        }

        return documentFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postFiscalReceiptVoided_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Voids a Fiscal receipt if there is a related sales return.
    /// </summary>
    /// <param name="_transactionTable">
    /// The Retail transaction that might be a sales return.
    /// </param>
    /// <returns>
    /// true if it is a sales return and a related fiscal receipt was found; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This covers only fiscal receipts voided after they are concluded, which are handled as sales return.
    /// For fiscal receipts voided before they are concluded, the Retail statament skips them,
    /// so they are handled at postConcludePost_BR.
    /// </remarks>
    protected boolean postFiscalReceiptVoided_BR(RetailTransactionTable _transactionTable)
    {
        RetailTransactionTable  originalTransactionTable;
        RetailFiscalReceipt_BR  fiscalReceipt;

        if (_transactionTable.saleIsReturnSale)
        {
            // The fiscal printer only allows voiding the last fiscal receipt,
            // so the original sales transaction will be the previous one at that terminal
            // and currently this is the only scenario a sales return is supported.
            select firstOnly Store, Terminal, TransactionId from originalTransactionTable
                order by originalTransactionTable.TransactionId desc
                where   originalTransactionTable.Type          == RetailTransactionType::Sales
                    &&  originalTransactionTable.Store         == _transactionTable.Store
                    &&  originalTransactionTable.Terminal      == _transactionTable.Terminal
                    &&  originalTransactionTable.transactionId <  _transactionTable.TransactionId;

            // A single fiscal receipt is expected to be found and it might be already voided or not.
            update_recordSet fiscalReceipt
                setting Status              = FiscalDocumentStatus_BR::Cancelled,
                        IsStatementPosted   = NoYes::Yes
                where   fiscalReceipt.StoreId       == originalTransactionTable.Store
                    &&  fiscalReceipt.TerminalId    == originalTransactionTable.Terminal
                    &&  fiscalReceipt.transactionId == originalTransactionTable.TransactionId;
        }

        return (fiscalReceipt.RowCount() > 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postIETax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post the tax amount based on the statement ID passed as parameter.
    /// </summary>
    /// <param name="_documentNumber">
    /// The current value of Statement ID.
    /// </param>
    /// <param name="_transactionIncomeExpenseTrans">
    /// The current instance of <c>RetailTransactionIncomeExpenseTrans</c> table.
    /// </param>
    /// <param name="_taxGroup">
    /// The current value of tax group.
    /// </param>
    /// <param name="_taxItemGroup">
    /// The current value of tax item group.
    /// </param>
    /// <param name="_amount">
    /// The tax amount to be posted.
    /// </param>
    /// <param name="_currencyCode">
    /// The current value of the Currncy code.
    /// </param>
    /// <remarks>
    /// Based on the module type, tax will be initialized.
    /// </remarks>
    void postIETax(str                              _documentNumber,
                   RetailTransactionIncomeExpenseTrans _transactionIncomeExpenseTrans,
                   TaxGroup                         _taxGroup,
                   TaxItemGroup                     _taxItemGroup,
                   Amount                           _amount,
                   CurrencyCode                     _currencyCode)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        Tax                             tax;
        TaxAmountCur                    taxAmountCur;
        ;
        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepStart(0, 'postIETax');

        switch (_transactionIncomeExpenseTrans.taxModuleType())
        {
            case TaxModuleType::Sales   :
                tax = new RetailTaxSales(_transactionIncomeExpenseTrans.transactionTable(),
                                      _taxGroup,
                                      _taxItemGroup,
                                      "",
                                      _transactionIncomeExpenseTrans.incomeExpenseAccountTable().Name,
                                      statementTable.DefaultDimension,
                                      NoYes::Yes,
                                      ledgerVoucher);
                break;
            case TaxModuleType::Purch   :
                tax = new RetailTaxPurch(_transactionIncomeExpenseTrans.transactionTable(),
                                      _taxGroup,
                                      _taxItemGroup,
                                      "",
                                      _transactionIncomeExpenseTrans.incomeExpenseAccountTable().Name,
                                      statementTable.DefaultDimension,
                                      true,
                                      ledgerVoucher);
                break;
        }

        this.initVoucher(_transactionIncomeExpenseTrans.businessDate);

        taxAmountCur = tax.taxCalcWithoutSource(_taxGroup,
                                                _taxItemGroup,
                                                _transactionIncomeExpenseTrans.businessDate,
                                                _currencyCode,
                                                _amount,
                                                _transactionIncomeExpenseTrans.taxModuleType());

        RetailTracer::Info('RetailStatementPost', 'postIETax',
                           'Post Income/Expense tax: Module type= %1, amount=%2, currencyCode=%3',
                           _transactionIncomeExpenseTrans.taxModuleType(), _amount,  _currencyCode);
        tax.saveAndPost(LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher));

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepEnd(0, 'postIETax');
    }

]]></Source>
			</Method>
			<Method>
				<Name>postIncomeExpenseLine</Name>
				<Source><![CDATA[
    private void postIncomeExpenseLine(RetailTransactionTable _transactionTable)
    {
        RetailTransactionIncomeExpenseTrans     transactionIncomeExpenseTrans;
        RetailIncomeExpenseAccountTable         incomeExpenseAccountTable;
        RetailTransactionPaymentTrans           payTransTable;

        MainAccountLegalEntity                  mainAccountLegalEntity;
        Amount                                  amount;
        Amount                                  amountUnrounded;

        TaxGroup                                taxGroup;
        TaxItemGroup                            taxItemGroup;
        CurrencyCode                            currencyCode;
        boolean                                 purchTaxOnOperation;

        LedgerDimensionAccount                  ledgerAccount;
        LedgerJournalACType                     accountType;

        str                                     documentNumber;
        Amount                                  roundingDiffAmount;

        #Retail

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepStart(0, 'postIncomeExpenseLine');

        documentNumber = #T + strrem(_transactionTable.TransactionId, ",.");

        currencyCode = _transactionTable.currency;

        if (!currencyCode)
        {
            currencyCode = storeTable.Currency;
        }

        while select transactionIncomeExpenseTrans
        index transactionLineIdx
        where transactionIncomeExpenseTrans.TransactionId  == _transactionTable.TransactionId
            && transactionIncomeExpenseTrans.store == _transactionTable.store
            && transactionIncomeExpenseTrans.terminal == _transactionTable.terminal
            && transactionIncomeExpenseTrans.TransactionStatus == RetailEntryStatus::None
        {
            incomeExpenseAccountTable  = RetailIncomeExpenseAccountTable::find(transactionIncomeExpenseTrans.store, transactionIncomeExpenseTrans.IncomeExepenseAccount);

            mainAccountLegalEntity  = MainAccountLegalEntity::findByMainAccountLegalEntity(LedgerDimensionFacade::getMainAccountFromLedgerDimension(incomeExpenseAccountTable.LedgerDimension).RecId, CompanyInfo::current());

            taxGroup = mainAccountLegalEntity.TaxGroup;
            taxItemGroup = mainAccountLegalEntity.TaxItemGroup;
            purchTaxOnOperation = TaxParameters::find().PurchTaxOnOperations;

            // TaxParameters::find().PurchTaxOnOperations - Use The US Tax System. (Income Expense does not support US tax calculations)
            if (purchTaxOnOperation)
            {
                amount = transactionIncomeExpenseTrans.Amount;
            }
            else
            {
                amount = Tax::baseAmountExclTax(taxGroup,
                                            taxItemGroup,
                                            transactionIncomeExpenseTrans.businessDate,
                                            currencyCode,
                                            transactionIncomeExpenseTrans.Amount,
                                            transactionIncomeExpenseTrans.taxModuleType());
            }

            RetailTracer::Info('Posting',
                                'RetailStatementPost::postIncomeExpenseLine()',
                                'Post Income/Expense line: Account=%1, Amount=%2',
                                ledgerAccount, amount);

            this.createPaymentLedgerTrans(RetailLedgerBank::Ledger,
                                        LedgerPostingType::LedgerJournal,
                                        incomeExpenseAccountTable.LedgerDimension,
                                        currencyCode,
                                        amount,
                                        transactionIncomeExpenseTrans.TableId,
                                        transactionIncomeExpenseTrans.RecId,
                                        transactionIncomeExpenseTrans.businessDate,
                                        "@RET4319"    + " - " +
                                        "@RET4443"      + transactionIncomeExpenseTrans.TransactionId +
                                        "@RET4444"      + transactionIncomeExpenseTrans.Store +
                                        "@RET4445"      + transactionIncomeExpenseTrans.Terminal,
                                        documentNumber,
                                        #SalesVoucher);

            roundingDiffAmount = -(transactionIncomeExpenseTrans.amount + _transactionTable.paymentAmount);

            if (roundingDiffAmount != 0)
            {
                this.createPaymentLedgerTrans(RetailLedgerBank::Ledger,
                                            LedgerPostingType::MSTDiff,
                                            LedgerDimensionFacade::serviceCreateLedgerDimension(LedgerSystemAccounts::defaultAccount(LedgerPostingType::MSTDiff), incomeExpenseAccountTable.LedgerDimension),
                                            currencyCode,
                                            roundingDiffAmount,
                                            transactionIncomeExpenseTrans.TableId,
                                            transactionIncomeExpenseTrans.RecId,
                                            transactionIncomeExpenseTrans.transDate,
                                            "@RET4319"    + " - " +
                                            "@RET4443"      + transactionIncomeExpenseTrans.TransactionId +
                                            "@RET4444"      + transactionIncomeExpenseTrans.Store +
                                            "@RET4445"      + transactionIncomeExpenseTrans.Terminal,
                                            documentNumber,
                                            #SalesVoucher);
            }

            if (!purchTaxOnOperation)
            {
                amountUnrounded = Tax::baseAmountExclTaxRaw(taxGroup,
                                            taxItemGroup,
                                            transactionIncomeExpenseTrans.businessDate,
                                            currencyCode,
                                            transactionIncomeExpenseTrans.Amount,
                                            transactionIncomeExpenseTrans.taxModuleType());
                this.postIETax(documentNumber, transactionIncomeExpenseTrans, taxGroup, taxItemGroup, amountUnrounded, currencyCode);
            }
        }

        while select sum(amountCur) from payTransTable
            group by tenderType, currency, exchRate, cardTypeId, DefaultDimension
            where  payTransTable.store == _transactionTable.store
               &&  payTransTable.terminal == _transactionTable.terminal
               &&  payTransTable.transactionId == _transactionTable.transactionId
               &&  payTransTable.transactionStatus == RetailEntryStatus::None
        {
            [accountType, ledgerAccount] = this.getLedgerOffsetAccount(
                                                   statementTable.storeId,
                                                   payTransTable.tenderType,
                                                   payTransTable.cardTypeId,
                                                   payTransTable.DefaultDimension);

            this.createPaymentLedgerTrans((accountType == LedgerJournalACType::Ledger) ? RetailLedgerBank::Ledger : RetailLedgerBank::Bank,
                                        (accountType == LedgerJournalACType::Ledger) ? LedgerPostingType::LedgerJournal : LedgerPostingType::Bank,
                                        ledgerAccount,
                                        payTransTable.currency,
                                        payTransTable.amountCur,
                                        payTransTable.TableId,
                                        payTransTable.RecId,
                                        _transactionTable.businessDate,
                                        "@RET4319"    + " - " +
                                        "@RET4443"      + payTransTable.TransactionId +
                                        "@RET4444"      + payTransTable.Store +
                                        "@RET4445"      + payTransTable.Terminal,
                                        documentNumber,
                                        #SalesVoucher);
        }

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepEnd(0, 'postIncomeExpenseLine');
    }

]]></Source>
			</Method>
			<Method>
				<Name>postIncomeExpenseLine_W</Name>
				<Source><![CDATA[
    private void postIncomeExpenseLine_W(RetailTransactionTable _transactionTable)
    {
        RetailTransactionIncomeExpenseTrans     transactionIncomeExpenseTrans;
        RetailIncomeExpenseAccountTable         incomeExpenseAccountTable;
        RetailTransactionPaymentTrans           payTransTable;
        LedgerDimensionAccount                  ledgerAccount;
        LedgerJournalACType                     accountType;

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepStart(0, 'postIncomeExpenseLine');

        this.createTransactionStatementPaymentJournal_W();

        // there is only one expense/income in one transaction
        select firstOnly IncomeExepenseAccount from transactionIncomeExpenseTrans
            index transactionLineIdx
            where transactionIncomeExpenseTrans.TransactionId  == _transactionTable.TransactionId
                && transactionIncomeExpenseTrans.store == _transactionTable.store
                && transactionIncomeExpenseTrans.terminal == _transactionTable.terminal
                && transactionIncomeExpenseTrans.TransactionStatus == RetailEntryStatus::None;

        incomeExpenseAccountTable = RetailIncomeExpenseAccountTable::find(_transactionTable.store, transactionIncomeExpenseTrans.IncomeExepenseAccount);

        while select sum(amountCur) from payTransTable
            group by tenderType, currency, cardTypeId, DefaultDimension
            where  payTransTable.store == _transactionTable.store
               &&  payTransTable.terminal == _transactionTable.terminal
               &&  payTransTable.transactionId == _transactionTable.transactionId
               &&  payTransTable.transactionStatus == RetailEntryStatus::None
        {
            [accountType, ledgerAccount] = RetailStatementLedgerJournalHelper::getStoreTenderTypeAccount(
                                                   _transactionTable.store,
                                                   payTransTable.tenderType,
                                                   payTransTable.cardTypeId);

            transactionStatementPaymentJournal.createPaymentLedgerTrans(
                RetailStatementLedgerJournalHelper::ledgerJournalACType2LedgerBank(accountType),
                ledgerAccount,
                RetailLedgerBank::Ledger,
                incomeExpenseAccountTable.LedgerDimension,
                payTransTable.currency,
                -payTransTable.amountCur,
                _transactionTable.businessDate,
                "@RET4319"    + ' - ' +
                    "@RET4443"      + _transactionTable.transactionId +
                    "@RET4444"      + _transactionTable.store +
                    "@RET4445"      + _transactionTable.terminal,
                statementTable.StatementId,
                payTransTable.tenderType,
                payTransTable.DefaultDimension);
        }

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepEnd(0, 'postIncomeExpenseLine');
    }

]]></Source>
			</Method>
			<Method>
				<Name>postIncomeExpenseLine_Aggregated_W</Name>
				<Source><![CDATA[
    private void postIncomeExpenseLine_Aggregated_W(RetailStatementPaymentJournal _expenseStatementPaymentJournal)
    {
        RetailTransactionPaymentTrans       transactionPaymentTrans;
        RetailTransactionIncomeExpenseTrans transactionIncomeExpenseTrans;
        RetailIncomeExpenseAccountTable     incomeExpenseAccountTable;
        LedgerJournalACType                 accountType;
        LedgerDimensionAccount              ledgerAccount;
        DimensionDefault                    defaultDimension;

        while select businessDate, TenderType, Currency, sum(amountCur) from transactionPaymentTrans
            group by store, businessDate, TenderType, Currency, cardTypeId, DefaultDimension
            where transactionPaymentTrans.statementId        == statementTable.statementId
                && transactionPaymentTrans.transactionStatus == RetailEntryStatus::None
                join IncomeExepenseAccount from transactionIncomeExpenseTrans
                group by IncomeExepenseAccount
                    where transactionIncomeExpenseTrans.TransactionId  == transactionPaymentTrans.TransactionId
                        && transactionIncomeExpenseTrans.store == transactionPaymentTrans.store
                        && transactionIncomeExpenseTrans.terminal == transactionPaymentTrans.terminal
                        && transactionIncomeExpenseTrans.TransactionStatus == RetailEntryStatus::None
        {
            if (!transactionPaymentTrans.amountCur)
            {
                continue;
            }

            incomeExpenseAccountTable = RetailIncomeExpenseAccountTable::find(transactionPaymentTrans.store, transactionIncomeExpenseTrans.IncomeExepenseAccount);

            [accountType, ledgerAccount] = RetailStatementLedgerJournalHelper::getStoreTenderTypeAccount(
                                                   transactionPaymentTrans.store,
                                                   transactionPaymentTrans.tenderType,
                                                   transactionPaymentTrans.cardTypeId);

            _expenseStatementPaymentJournal.createPaymentLedgerTrans(
                RetailStatementLedgerJournalHelper::ledgerJournalACType2LedgerBank(accountType),
                ledgerAccount,
                RetailLedgerBank::Ledger,
                incomeExpenseAccountTable.LedgerDimension,
                transactionPaymentTrans.currency,
                -transactionPaymentTrans.amountCur,
                transactionPaymentTrans.businessDate,
                "@RET4319" + ' - ' + incomeExpenseAccountTable.AccountNum,
                statementTable.StatementId,
                transactionPaymentTrans.tenderType,
                transactionPaymentTrans.DefaultDimension);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post the payment transactions.
    /// </summary>
    /// <remarks>
    /// Post the difference amount, bank drop, safe drop, card Fee and Tenders.
    /// </remarks>
    void postPayment()
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        #define.TotalPayment(0)
        #define.BankdropPayment(1)
        #define.SafeDropPayment(2)
        #define.TenderDeclaration(3)
        #define.CardFeePayment(4)
        #define.EmptyCardTypeId("")

        Map                             paymentTransMap;
        Map                             lastTransDateMap;
        Map                             differencePerTenderTypeMap;
        RetailStatementPaymentJournal   rboStatementPaymentJournal;

        #Retail

        LedgerDimensionAccount getOffsetLedgerAccount(RetailLedgerBank _accountType, LedgerDimensionDefaultAccount _ledgerDimension, DimensionDefault _defaultDimension)
        {
            LedgerDimensionAccount ledgerDimension = _ledgerdimension;
            ;

            switch (_accountType)
            {
                case RetailLedgerBank::Ledger:
                    ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerDimension, _defaultDimension);
                    break;
                case RetailLedgerBank::Bank:
                    ledgerDimension = _ledgerDimension;
                    break;
                    // <GEERU>
                case RetailLedgerBank::RCash:
                    ledgerDimension = _ledgerdimension;
                    break;
                    // <GEERU>
            }

            return ledgerDimension;
        }

        void updateTenderInfo(container _key, AmountCur _amount)
        {
            AmountCur           amountCur;
            ;

            if (_amount)
            {
                if (paymentTransMap.exists(_key))
                {
                    amountCur = paymentTransMap.lookup(_key);
                    paymentTransMap.remove(_key);
                }
                amountCur += _amount;
                paymentTransMap.insert(_key, amountCur);
            }
        }

        void insertLastTransDate(container _key, TransDate _transDate)
        {
            TransDate           lastTransDate;
            AmountCur           amountCur;
            ;

            if (lastTransDateMap.exists(_key))
            {
                [lastTransDate, amountCur] = lastTransDateMap.lookup(_key);
                if (lastTransDate < _transDate)
                {
                    lastTransDateMap.remove(_key);
                    lastTransDateMap.insert(_key, [_transDate, 0]);
                }
            }
            else
            {
                lastTransDateMap.insert(_key, [_transDate, 0]);
            }
        }

        void postPaymentLedgerTrans(RetailTenderTypeId _tenderType,
                                    RetailCardTypeId _cardTypeId,
                                    CurrencyCode _currencyCode,
                                    TransDate _transDate)
        {
            RetailStoreTenderTypeTable              storeTenderTypeTable;
            RetailStoreTenderTypeCardTable          storeTenderTypeCardTable;
            RetailStatementLine                     statementLine;
            RetailTransactionBankedTenderTrans      transactionBankedTenderTrans;
            RetailTransactionSafeTenderTrans        transactionSafeTenderTrans;
            RetailParameters                        retailParameters = RetailParameters::find();
            DimensionDefault                        differenceAccount;
            RetailAccountType                       accountType;
            DimensionDynamicDefaultAccount          ledgerDimension;
            AmountCur                               totalPayment, bankDropAmountCur, safeDropAmountCur, countedAmountCur, differenceAmountCur, accumulatedTenderDeclaration, currentDifferenceAmount;
            Boolean                                 countingRequired;
            TransDate                               lastTransDate, currentTransDate;
            // <GEERU>
            amountCur                               tenderFlowAmountCur;
            str                                     paymReferenceTxt, paymDescription;
            // </GEERU>
            ;

            Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostInfo(0, 'postPaymentLedgerTrans');

            storeTenderTypeTable = RetailStoreTenderTypeTable::find(RetailStoreTable::find(storeTable.StoreNumber).RecId, _tenderType);

            if (storeTenderTypeTable.Function != RetailTenderFunction::Customer)
            {
                if (paymentTransMap.exists([_tenderType, _currencyCode, _transDate, _cardTypeId, #TotalPayment]))
                {
                    totalPayment = any2real(paymentTransMap.lookup([_tenderType, _currencyCode, _transDate, _cardTypeId, #TotalPayment]));
                }
                else
                {
                    totalPayment = 0;
                }

                if (!_cardTypeId && paymentTransMap.exists([_tenderType, _currencyCode, _transDate, #EmptyCardTypeId, #BankdropPayment]))
                {
                    bankDropAmountCur = any2real(paymentTransMap.lookup([_tenderType, _currencyCode, _transDate, #EmptyCardTypeId, #BankdropPayment]));
                }
                else
                {
                    bankDropAmountCur = 0;
                }

                if (!_cardTypeId && paymentTransMap.exists([_tenderType, _currencyCode, _transDate, #EmptyCardTypeId, #SafedropPayment]))
                {
                    safeDropAmountCur = any2real(paymentTransMap.lookup([_tenderType, _currencyCode, _transDate, #EmptyCardTypeId, #SafedropPayment]));
                }
                else
                {
                    safeDropAmountCur = 0;
                }

                // Get the flag counting required is disabled or not from retail parameters.
                countingRequired = !retailParameters.DisableCountingRequired;

                // Calculate the flag counting required onthis card type only if it is not disabled in RetailParameters.
                if (countingRequired)
                {
                    if (_cardTypeId)
                    {
                        storeTenderTypeCardTable = RetailStoreTenderTypeCardTable::find(RetailStoreTable::find(storeTable.StoreNumber).RecId, _tenderType, _cardTypeId);
                        if (storeTenderTypeCardTable)
                        {
                            // If counting required is not disabled in the RetailParameters, override this flag value from the tender type table.
                            countingRequired = storeTenderTypeCardTable.countingRequired;
                        }
                        else
                        {
                            // If the store tender type is not found, set the counting required to false.
                            countingRequired = false;
                        }
                    }
                    else
                    {
                        if (storeTenderTypeTable)
                        {
                            // If counting required is not disabled in the RetailParameters, override this flag value from the tender type table.
                            countingRequired = storeTenderTypeTable.countingRequired;
                        }
                        else
                        {
                            // If the store tender type is not found, set the counting required to false.
                            countingRequired = false;
                        }
                    }
                }

                if (countingRequired)
                {
                    if (!_cardTypeId && paymentTransMap.exists([_tenderType, _currencyCode, _transDate, #EmptyCardTypeId, #TenderDeclaration]))
                    {
                        countedAmountCur = any2real(paymentTransMap.lookup([_tenderType, _currencyCode, _transDate, #EmptyCardTypeId, #TenderDeclaration]));
                    }
                    else
                    {
                        countedAmountCur = 0;
                    }

                    if (lastTransDateMap.exists([_tenderType, _cardTypeId, _currencyCode]))
                    {
                        [lastTransDate, accumulatedTenderDeclaration] = lastTransDateMap.lookup([_tenderType, _cardTypeId, _currencyCode]);
                        if (lastTransDate == _transDate)
                        {
                            select sum(countedAmount) from statementLine
                                where statementLine.StatementId == statementTable.StatementId
                                   && statementLine.TenderTypeId == _tenderType
                                   && statementLine.cardTypeId  ==  _cardTypeId
                                   && statementLine.currency == _currencyCode;

                            countedAmountCur = statementLine.countedAmount - accumulatedTenderDeclaration;
                        }
                        else if (countedAmountCur)
                        {
                            accumulatedTenderDeclaration += countedAmountCur;
                            lastTransDateMap.remove([_tenderType, _cardTypeId, _currencyCode]);
                            lastTransDateMap.insert([_tenderType, _cardTypeId, _currencyCode], [lastTransDate, accumulatedTenderDeclaration]);
                        }
                    }

                    differenceAmountCur = totalPayment - (bankDropAmountCur + safeDropAmountCur + countedAmountCur);
                }
                else
                {
                    countedAmountCur = totalPayment - (bankDropAmountCur + safeDropAmountCur);
                    differenceAmountCur = 0;
                }

                // Post payment difference
                if (differenceAmountCur)
                {
                    // Accumulate the difference per tender type, currency code and cart type id,
                    // so that it takes into account statements with more than one date.
                    // Therefore, only one difference transaction is posted with the sum from all dates (on the last business date).

                    if (differencePerTenderTypeMap.exists([_tenderType, _currencyCode, _cardTypeId]))
                    {
                        [currentTransDate, currentDifferenceAmount] = differencePerTenderTypeMap.lookup([_tenderType, _currencyCode, _cardTypeId]);

                        if (currentTransDate < _transDate)
                        {
                            currentTransDate = _transDate;
                        }
                    }
                    else
                    {
                        currentTransDate = _transDate;
                    }

                    currentDifferenceAmount += differenceAmountCur;

                    if (!currentDifferenceAmount)
                    {
                        differencePerTenderTypeMap.remove([_tenderType, _currencyCode, _cardTypeId]);
                    }
                    else
                    {
                        differencePerTenderTypeMap.insert([_tenderType, _currencyCode, _cardTypeId], [currentTransDate, currentDifferenceAmount]);
                    }
                }

                // Post bank drop
                if (bankDropAmountCur
                    && storeTenderTypeTable.LedgerDimension != storeTenderTypeTable.BankBagLedgerDimension
                    && storeTenderTypeTable.ActiveAccount
                    )
                {
                    paymReferenceTxt = strFmt("@Retail:PaymentReferenceTxt", storeTable.StoreNumber);

                    if (parameters.PostBankedSum)
                    {
                        paymDescription = "@Retail:PaymentDescBankDrop" + RetailStatementPaymentJournal::getTenderTypeName(storeTable, _tenderType, _cardTypeId, _currencyCode) + '. ' + storeTable.StoreNumber;

                        rboStatementPaymentJournal.createPaymentLedgerTrans(
                                                    storeTenderTypeTable.accountType,
                                                    getOffsetLedgerAccount(storeTenderTypeTable.accountType, storeTenderTypeTable.LedgerDimension, storeTenderTypeTable.DefaultDimension),
                                                    storeTenderTypeTable.BankBagAccountType,
                                                    getOffsetLedgerAccount(storeTenderTypeTable.BankBagAccountType, storeTenderTypeTable.BankBagLedgerDimension, storeTenderTypeTable.DefaultDimension),
                                                    _currencyCode,
                                                    bankDropAmountCur,
                                                    _transDate,
                                                    paymDescription,
                                                    statementTable.StatementId,
                                                    _tenderType,
                                                    0,
                                                    paymReferenceTxt,
                                                    storeTenderTypeTable.bankTransactionType
                                                    );
                    }
                    else
                    {
                        while select AmountCur, BankBagNo from transactionBankedTenderTrans
                            where transactionBankedTenderTrans.statementId == statementTable.statementId
                                && transactionBankedTenderTrans.transactionStatus == RetailEntryStatus::None
                                && transactionBankedTenderTrans.Currency == _currencyCode
                                && transactionBankedTenderTrans.TransDate == _transDate
                                && transactionBankedTenderTrans.TenderType == _tenderType
                        {
                            bankDropAmountCur = transactionBankedTenderTrans.AmountCur;

                            paymDescription = strFmt("@Retail:PaymentDescBankDropAggregationOn", transactionBankedTenderTrans.BankBagNo) + RetailStatementPaymentJournal::getTenderTypeName(storeTable, _tenderType, _cardTypeId, _currencyCode) + '. ' + storeTable.StoreNumber;

                            rboStatementPaymentJournal.createPaymentLedgerTrans(
                                                storeTenderTypeTable.accountType,
                                                getOffsetLedgerAccount(storeTenderTypeTable.accountType, storeTenderTypeTable.LedgerDimension, storeTenderTypeTable.DefaultDimension),
                                                storeTenderTypeTable.BankBagAccountType,
                                                getOffsetLedgerAccount(storeTenderTypeTable.BankBagAccountType, storeTenderTypeTable.BankBagLedgerDimension, storeTenderTypeTable.DefaultDimension),
                                                _currencyCode,
                                                bankDropAmountCur,
                                                _transDate,
                                                paymDescription,
                                                statementTable.StatementId,
                                                _tenderType,
                                                0,
                                                paymReferenceTxt,
                                                storeTenderTypeTable.bankTransactionType
                                                );
                        }
                    }
                }

                // Post safe drop
                if (safeDropAmountCur
                    && (storeTenderTypeTable.SafeAccLedgerDimension !=  storeTenderTypeTable.LedgerDimension)
                    && storeTenderTypeTable.SafeActiveAccount
                    )
                {
                    if (storeTenderTypeTable.safeAccountType == RetailLedgerBank::Bank)
                    {
                        paymReferenceTxt = strFmt("@Retail:PaymentReferenceTxt", storeTable.StoreNumber);
                    }

                    paymDescription = "@Retail:PaymentDescSafeDrop" + RetailStatementPaymentJournal::getTenderTypeName(storeTable, _tenderType, _cardTypeId, _currencyCode) + '. ' + storeTable.StoreNumber;

                    if (parameters.PostSafeSum)
                    {
                        rboStatementPaymentJournal.createPaymentLedgerTrans(
                                                    storeTenderTypeTable.accountType,
                                                    getOffsetLedgerAccount(storeTenderTypeTable.accountType , storeTenderTypeTable.LedgerDimension, storeTenderTypeTable.DefaultDimension),
                                                    storeTenderTypeTable.safeAccountType,
                                                    getOffsetLedgerAccount(storeTenderTypeTable.safeAccountType, storeTenderTypeTable.SafeAccLedgerDimension, storeTenderTypeTable.DefaultDimension),
                                                    _currencyCode,
                                                    safeDropAmountCur,
                                                    _transDate,
                                                    paymDescription,
                                                    statementTable.StatementId,
                                                    _tenderType,
                                                    0,
                                                    paymReferenceTxt
                                                    );
                    }
                    else
                    {
                        while select AmountCur from transactionSafeTenderTrans
                            where   transactionSafeTenderTrans.store                == statementTable.storeId
                                &&  transactionSafeTenderTrans.statementId          == statementTable.statementId
                                &&  transactionSafeTenderTrans.transactionStatus    == RetailEntryStatus::None
                                &&  transactionSafeTenderTrans.Currency             == _currencyCode
                                &&  transactionSafeTenderTrans.TransDate            == _transDate
                                &&  transactionSafeTenderTrans.TenderType           == _tenderType
                        {
                            safeDropAmountCur = transactionSafeTenderTrans.AmountCur;

                            rboStatementPaymentJournal.createPaymentLedgerTrans(
                                                    storeTenderTypeTable.accountType,
                                                    getOffsetLedgerAccount(storeTenderTypeTable.accountType , storeTenderTypeTable.LedgerDimension, storeTenderTypeTable.DefaultDimension),
                                                    storeTenderTypeTable.safeAccountType,
                                                    getOffsetLedgerAccount(storeTenderTypeTable.safeAccountType, storeTenderTypeTable.SafeAccLedgerDimension, storeTenderTypeTable.DefaultDimension),
                                                    _currencyCode,
                                                    safeDropAmountCur,
                                                    _transDate,
                                                    paymDescription,
                                                    statementTable.StatementId,
                                                    _tenderType,
                                                    0,
                                                    paymReferenceTxt
                                                    );
                        }
                    }
                }

                rboStatementPaymentJournal.postLedgerJournal();
                // <GEERU>
                if (countryRegion_W)
                {
                    rboStatementPaymentJournal.postLedgerJournal(LedgerJournalType::RCash);
                }
                // </GEERU>
            }
        }

        void postCardFee(RetailTenderTypeId _tenderType,
                         RetailCardTypeId _cardTypeId,
                         CurrencyCode _currencyCode,
                         TransDate _transDate,
                         AmountCur _amountCur)
        {
            RetailStoreTenderTypeTable                 storeTenderTypeTable;
            RetailStoreTenderTypeCardTable             storeTenderTypeCardTable;
            DimensionDefault                           ledgerAccount, offsetAccount;
            ;

            Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostInfo(0, 'postCardFee');

            storeTenderTypeTable = RetailStoreTenderTypeTable::find(RetailStoreTable::find(storeTable.StoreNumber).RecId, _tenderType);

            if (_amountCur && storeTenderTypeTable.Function == RetailTenderFunction::Card)
            {
                storeTenderTypeCardTable = RetailStoreTenderTypeCardTable::find(RetailStoreTable::find(storeTable.StoreNumber).RecId, _tenderType, _cardTypeId);

                if (storeTenderTypeCardTable)
                {
                    ledgerAccount = storeTenderTypeCardTable.CardFeeLedgerDimension;
                    offsetAccount = storeTenderTypeCardTable.CardFeeOffsetLedgerDimension;

                    if (ledgerAccount && offsetAccount && ledgerAccount != offsetAccount)
                    {
                        rboStatementPaymentJournal.createPaymentLedgerTrans(
                                                            storeTenderTypeCardTable.cardFeeAccountType,
                                                            getOffsetLedgerAccount(
                                                                storeTenderTypeCardTable.cardFeeAccountType,
                                                                ledgerAccount,
                                                                storeTenderTypeTable.DefaultDimension),
                                                            storeTenderTypeCardTable.cardFeeOffsetAccountType,
                                                            getOffsetLedgerAccount(
                                                                storeTenderTypeCardTable.cardFeeOffsetAccountType,
                                                                offsetAccount,
                                                                storeTenderTypeTable.DefaultDimension),
                                                            _currencyCode,
                                                            _amountCur,
                                                            _transDate,
                                                            "@RET4331"+" - "+storeTenderTypeCardTable.tenderTypeId,
                                                            statementTable.StatementId,
                                                            _tenderType);

                        rboStatementPaymentJournal.postLedgerJournal();
                    }
                }
            }
        }

        void postTenders()
        {
            RetailStatementLine                        statementLine;
            CurrencyCode                            currencyCode;
            LedgerAccount                           differenceAccount;
            RetailStoreTenderTypeCardTable             storeTenderTypeCardTable;

            MapIterator                             paymentsIterator;
            TransDate                               transDate, lastTransDate;
            RetailCardTypeId                           cardTypeId;
            AmountCur                               totalPayment, cardFeeAmount;
            RetailTenderTypeId                         tenderType;
            AmountCur                               totalTenderDeclaration;
            int                                     paymentType;

            MapIterator                             lastTransDateIterator;
            ;

            Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostInfo(0, 'postTenders');

            paymentsIterator = new MapIterator(paymentTransMap);

            while (paymentsIterator.more())
            {
                [tenderType, currencyCode, transDate, cardTypeId, paymentType] = paymentsIterator.key();

                if (paymentType == #TotalPayment)
                {
                    if (lastTransDateMap.exists([tenderType, cardTypeId, currencyCode]))
                    {
                        [lastTransDate, totalTenderDeclaration] = lastTransDateMap.lookup([tenderType, cardTypeId, currencyCode]);
                        if (lastTransDate != transDate)
                        {
                            postPaymentLedgerTrans(tenderType,
                                                   cardTypeId,
                                                   currencyCode,
                                                   transDate);
                        }
                    }
                }
                else if (paymentType == #CardFeePayment)
                {
                    cardFeeAmount = paymentsIterator.value();
                    postCardFee(tenderType, cardTypeId, currencyCode, transDate, cardFeeAmount);
                }

                paymentsIterator.next();
            }

            // Post payment of the last trans date in the statement,
            lastTransDateIterator = new MapIterator(lastTransDateMap);
            while (lastTransDateIterator.more())
            {
                [tenderType, cardTypeId, currencyCode] = lastTransDateIterator.key();
                [lastTransDate, totalTenderDeclaration] = lastTransDateMap.lookup([tenderType, cardTypeId, currencyCode]);
                postPaymentLedgerTrans(tenderType,
                                       cardTypeId,
                                       currencyCode,
                                       lastTransDate);

                lastTransDateIterator.next();
            }
        }

        // Posts Safe Tender drop to the ledger/bank
        void prepareSafeTenderDropInfo()
        {
            RetailTransactionSafeTenderTrans   transactionSafeTenderTrans;
            RetailStoreTenderTypeTable         storeTenderTypeTable;

            AmountCur                       amountCur;

            CurrencyCode                    currencyCode;
            ;

            Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostInfo(0, 'prepareSafeTenderDropInfo');

            while select sum(AmountCur), sum(AmountTendered), sum(AmountMST), TenderType, Currency, businessDate from transactionSafeTenderTrans
            group by TenderType, Currency, businessDate
            where transactionSafeTenderTrans.statementId == statementTable.statementId
                && transactionSafeTenderTrans.transactionStatus == RetailEntryStatus::None
            {
                storeTenderTypeTable = RetailStoreTenderTypeTable::find(RetailStoreTable::find(storeTable.StoreNumber).RecId, transactionSafeTenderTrans.TenderType);

                currencyCode = transactionSafeTenderTrans.Currency ? transactionSafeTenderTrans.Currency : storeTable.Currency;

                updateTenderInfo([transactionSafeTenderTrans.TenderType, transactionSafeTenderTrans.Currency, transactionSafeTenderTrans.businessDate, #EmptyCardTypeId, #SafeDropPayment],
                                    transactionSafeTenderTrans.AmountCur);

                insertLastTransDate([transactionSafeTenderTrans.TenderType, #EmptyCardTypeId, transactionSafeTenderTrans.Currency],
                                    transactionSafeTenderTrans.businessDate);
            }
        }

        void prepareBankTenderDropInfo()
        {
            RetailTransactionBankedTenderTrans transactionBankedTenderTrans;
            RetailStoreTenderTypeTable         storeTenderTypeTable;

            AmountCur                       amountCur;

            CurrencyCode                    currencyCode;
            ;

            Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostInfo(0, 'prepareBankTenderDropInfo');

            while select sum(AmountCur),sum(AmountTendered),sum(AmountMST), Currency, businessDate from transactionBankedTenderTrans
                group by TenderType, Currency, businessDate
                where transactionBankedTenderTrans.statementId == statementTable.statementId
                    && transactionBankedTenderTrans.transactionStatus == RetailEntryStatus::None
            {
                storeTenderTypeTable = RetailStoreTenderTypeTable::find(RetailStoreTable::find(storeTable.StoreNumber).RecId, transactionBankedTenderTrans.TenderType);

                currencyCode = transactionBankedTenderTrans.Currency ? transactionBankedTenderTrans.Currency : storeTable.Currency;

                updateTenderInfo([transactionBankedTenderTrans.TenderType, transactionBankedTenderTrans.Currency, transactionBankedTenderTrans.businessDate, #EmptyCardTypeId, #BankDropPayment],
                                    transactionBankedTenderTrans.AmountCur);

                insertLastTransDate([transactionBankedTenderTrans.TenderType, #EmptyCardTypeId, transactionBankedTenderTrans.Currency],
                                    transactionBankedTenderTrans.businessDate);
            }
        }

        void preparePaymentInfo()
        {
            RetailTransactionPaymentTrans   transactionPaymentTrans;
            RetailStoreTenderTypeTable      storeTenderTypeTable;
            TransDate                       lastTransDate;
            AmountCur                       amountCur;
            ;

            Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostInfo(0, 'preparePaymentInfo');

            while select businessDate, tenderType, cardTypeId, currency, sum(amountMST), sum(amountTendered), sum(amountCur)
                from transactionPaymentTrans
                index hint statementTenderCardCurIdx
                group by store, businessDate, tenderType, cardTypeId, currency
                where   transactionPaymentTrans.store               == statementTable.storeId
                    &&  transactionPaymentTrans.statementId         == statementTable.statementId
                    &&  transactionPaymentTrans.transactionStatus   == RetailEntryStatus::None
            {
                storeTenderTypeTable = RetailStoreTenderTypeTable::find(RetailStoreTable::find(transactionPaymentTrans.store).RecId, transactionPaymentTrans.tenderType);

                if (storeTenderTypeTable.Function != RetailTenderFunction::Customer)
                {
                    updateTenderInfo([transactionPaymentTrans.TenderType, transactionPaymentTrans.Currency, transactionPaymentTrans.businessDate, transactionPaymentTrans.CardTypeId, #TotalPayment],
                                     transactionPaymentTrans.AmountCur);

                    insertLastTransDate([transactionPaymentTrans.TenderType, transactionPaymentTrans.cardTypeId, transactionPaymentTrans.Currency],
                                        transactionPaymentTrans.businessDate);

                    updateTenderInfo([transactionPaymentTrans.TenderType, transactionPaymentTrans.Currency, transactionPaymentTrans.businessDate, transactionPaymentTrans.cardTypeId, #CardFeePayment],
                                     transactionPaymentTrans.calcCardFeeAmount());
                }
            }
        }

        void prepareTenderDeclarationInfo()
        {
            RetailStoreTenderTypeTable                 storeTenderTypeTable;
            RetailTransactionTenderDeclarationTrans    tenderDeclarationTrans;

            AmountCur                               amountCur;
            ;

            Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostInfo(0, 'prepareTenderDeclarationInfo');

            while select businessDate, tenderType, cardId, currency, sum(amountMST), sum(amountTendered), sum(amountCur)
                from tenderDeclarationTrans
                group by businessDate, tenderType, cardId, currency
                where   tenderDeclarationTrans.store                == statementTable.storeId
                    &&  tenderDeclarationTrans.statementId          == statementTable.statementId
                    &&  tenderDeclarationTrans.transactionStatus    == RetailEntryStatus::None
            {
                storeTenderTypeTable = RetailStoreTenderTypeTable::find(RetailStoreTable::find(statementTable.storeId).RecId, tenderDeclarationTrans.tenderType);

                if (storeTenderTypeTable.Function != RetailTenderFunction::Customer)
                {
                    updateTenderInfo([tenderDeclarationTrans.TenderType, tenderDeclarationTrans.Currency, tenderDeclarationTrans.businessDate, tenderDeclarationTrans.cardId, #TenderDeclaration],
                                     tenderDeclarationTrans.AmountCur);
                    insertLastTransDate([tenderDeclarationTrans.TenderType, tenderDeclarationTrans.cardId, tenderDeclarationTrans.Currency], tenderDeclarationTrans.businessDate);
                }
            }
        }

        void postDifferencesOnLastBusinessDate()
        {
            CurrencyCode                            currencyCode;
            LedgerDimensionDefaultAccount           differenceAccount;
            RetailStoreTenderTypeTable              storeTenderTypeTable;
            RetailStoreTenderTypeCardTable          storeTenderTypeCardTable;

            RetailCardTypeId                        cardTypeId;
            RetailTenderTypeId                      tenderType;
            RetailAccountType                       accountType;
            DimensionDynamicDefaultAccount          ledgerDimension;
            MapIterator                             differenceIterator;
            AmountCur                               differenceAmountCur;
            str                                     paymReferenceTxt, paymDescription;
            TransDate                               currentTransDate;
            DimensionDefault                        defaultDimension;

            differenceIterator = new MapIterator(differencePerTenderTypeMap);

            while (differenceIterator.more())
            {
                [tenderType, currencyCode, cardTypeId] = differenceIterator.key();
                [currentTransDate, differenceAmountCur] = differenceIterator.value();

                storeTenderTypeTable = RetailStoreTenderTypeTable::find(RetailStoreTable::find(storeTable.StoreNumber).RecId, tenderType);

                if (cardTypeId)
                {
                    storeTenderTypeCardTable = RetailStoreTenderTypeCardTable::find(RetailStoreTable::find(storeTable.StoreNumber).RecId, tenderType, cardTypeId);

                    differenceAccount = abs(differenceAmountCur) > storeTenderTypeCardTable.MaxNormalDifferenceAmount
                                                ? storeTenderTypeCardTable.DiffAccBigDiffLedgerDimension
                                                : storeTenderTypeCardTable.DifferenceAccLedgerDimension;
                    accountType = storeTenderTypeCardTable.accountType;
                    ledgerDimension = storeTenderTypeCardTable.LedgerDimension;
                }
                else
                {
                    differenceAccount = abs(differenceAmountCur) > storeTenderTypeTable.MaxNormalDifferenceAmount
                                                ? storeTenderTypeTable.DiffAccBigDiffLedgerDimension
                                                : storeTenderTypeTable.DifferenceAccLedgerDimension;
                    accountType = storeTenderTypeTable.accountType;
                    ledgerDimension = storeTenderTypeTable.LedgerDimension;
                }

                paymDescription = strfmt("@RET4163", storeTenderTypeTable.TenderTypeId);

                if (accountType == RetailLedgerBank::Bank)
                {
                    paymReferenceTxt = strFmt("@Retail:PaymentReferenceTxt", storeTable.StoreNumber);
                    paymDescription += '. ' + RetailStatementPaymentJournal::getTenderTypeName(storeTable, tenderType, cardTypeId, currencyCode) + '. ' + storeTable.StoreNumber;
                }

                rboStatementPaymentJournal.createPaymentLedgerTrans(accountType,
                                                                    getOffsetLedgerAccount(accountType, ledgerDimension,
                                                                        LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(storeTable.DefaultDimension, storeTenderTypeTable.DefaultDimension)),
                                                                    RetailLedgerBank::Ledger,
                                                                    LedgerDimensionFacade::serviceCreateLedgerDimension(differenceAccount, LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(storeTable.DefaultDimension, storeTenderTypeTable.DefaultDimension)),
                                                                    currencyCode,
                                                                    differenceAmountCur,
                                                                    currentTransDate,
                                                                    paymDescription,
                                                                    statementTable.StatementId,
                                                                    tenderType,
                                                                    0,
                                                                    paymReferenceTxt
                                                                    );

                differenceIterator.next();
            }
            rboStatementPaymentJournal.postLedgerJournal();

            // <GEERU>
            if (countryRegion_W)
            {
                rboStatementPaymentJournal.postLedgerJournal(LedgerJournalType::RCash);
            }
            // </GEERU>
        }
        ;

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepStart(0, 'postPayment');

        rboStatementPaymentJournal = new RetailStatementPaymentJournal(statementTable);
        rboStatementPaymentJournal.postPaymentJournal();

        // <GEERU>
        if (countryRegion_W)
        {
            rboStatementPaymentJournal = new RetailStatementPaymentJournal(statementTable, LedgerJournalType::Daily);
        }
        // </GEERU>

        // Begin of main body of postPayment method.

        paymentTransMap = new Map(Types::Container, Types::Real);
        lastTransDateMap = new Map(Types::Container, Types::Container);
        differencePerTenderTypeMap = new Map(Types::Container, Types::Container);

        // prepare total payment information by reading from RetailTransactionPaymentTrans table,
        // it saves #TotalPayment and #CardFeePayment information in the paymentTransMap.
        preparePaymentInfo();

        // prepare tender declaration information by reading RBOTenderDeclarationTrans table, saved in paymentTransMap as #TenderDeclaration items.
        // upon posting, the information is used as counted amount if the tender declaration isn't made on the posting date and counting is required.
        prepareTenderDeclarationInfo();

        // prepare bank drop information, post a ledger trans if bank drop aggregation isn't configured. and calculates sum of bank drop information saved in paymentTransMap
        // as #BankDropPayment entries.
        prepareBankTenderDropInfo();

        // prepare bank drop information, post a ledger trans if safe drop aggregation isn't configured. and calculates sum of safe drop information saved in paymentTransMap
        // as #SafeDropPayment entries.
        prepareSafeTenderDropInfo();

        // <GEERU>
        if (countryRegion_W)
        {
            this.postWSpecificAggregate_W(rboStatementPaymentJournal);
        }
        // </GEERU>

        // iterate each item in paymentTransMap and post the payment ledger trans. and accumulate counted amount for each trans date except the last trans date in the statement.
        // post the last trans date payment trans after the counted amount is calculated for all trans date and calculate counted amount of the last day based on the manager input.
        postTenders();

        // Iterate each accumulated difference in differencePerTenderTypeMap and post the payment ledger trans for the differences.
        postDifferencesOnLastBusinessDate();

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepEnd(0, 'postPayment');
    }

]]></Source>
			</Method>
			<Method>
				<Name>postRetailSpecific</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post the sales trans.
    /// </summary>
    /// <remarks>
    /// Posts the payment transactions, discounts. Mark the transactions for post and inserts the record in the StatementJour and StatementLines.
    /// </remarks>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// Cannot update if any other user is trying update simultaneously. The update conflict cannot be recovered.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// Update conflict as any other user is trying to update the record at the same time.
    /// </exception>
    public void postRetailSpecific()
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        #OccRetryCount
        RetailTransactionTable                 transactionTable;
        RetailTransactionSalesTrans            transactionSalesTrans;
        RetailTransactionDiscountTrans         transactionDiscountTrans;
        int                                 irecordCounter = 1;
        str                                 documentNumber;
        #Retail

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepStart(0, 'postRetailSpecific');

        RetailTracer::Info('Posting', 'RetailStatementPost::postRetailSpecific()', 'Posting retail specific data %1 start', statementTable.statementId);

        if (this.parmStatementId())
        {
            // Running inside a batch framework task, so initialize the statementTable record buffer.
            statementTable = RetailStatementTable::find(this.parmStatementId(), true);
        }

        parameters = RetailParameters::find();

        storeTable = RetailStoreTable::find(statementTable.StoreId);

        #AVIFiles

        operationProgress = SysOperationProgress::newMultiBar(3, #AviTransfer, "@RET4266");

        operationProgress.setTotal(statementTable.CalculatedLines);
        operationProgress.setText("@RET4266");

        try
        {
            ttsbegin;
            irecordCounter = 1;
            ledgerVoucher = null;
            voucherList = new Map(Types::Container,Types::String);

            statementTable.reread();

            if (statementTable.PaymentStatus != RetailStatementPaymentPostingStatus::PostingPayment)
            {
                statementTable.selectForUpdate(true);

                // Fetch dimension from store if not set in statement.
                if (!statementTable.DefaultDimension)
                {
                    statementTable.DefaultDimension = storeTable.DefaultDimension;
                }
                
                statementTable.PaymentStatus = RetailStatementPaymentPostingStatus::PostingPayment;
                statementTable.update();

                if (parameters.aggregateBeforePosting)
                {
                    this.postAggregatedDiscounts();
                }

                //Run through all the transactions in this statement
                while select forupdate transactionTable
                index hint statementIdx
                where transactionTable.StatementId == statementTable.StatementId &&
                        transactionTable.type != RetailTransactionType::Logon &&
                        transactionTable.type != RetailTransactionType::Logoff
                        && transactionTable.type != RetailTransactionType::KitDisassembly

                {
                    irecordCounter++;
                    operationProgress.setCount(irecordCounter, 1);

                    if (! transactionTable.Currency)
                        transactionTable.Currency = CompanyInfoHelper::standardCurrency();

                    documentNumber = #T + strrem(transactionTable.TransactionId, ",.");

                    // The discount transactions below are calculated only for transactions of type "Sales".
                    //
                    // Note:
                    //     Included (Not yet processed):
                    //
                    //         - Cash & Carry to consumer
                    //         - Cash & Carry to Loyalty customer
                    //
                    //     Excluded (Already processed from other retail flows)
                    //
                    //         - RTS real time Customer Orders (CustomerOrder)
                    //         - Online Orders (PendingSalesOrder)
                    //         - Asynchronous Customer Quotes (AsyncCustomerQuote)
                    //         - Asynchronous Customer Orders (AsyncCustomerOrder)
                    //
                    //         Note: The periodic discounts for the Excluded orders, if any, were already captured in real time by the following methods:
                    //
                    //             - Customer Orders:
                    //                 - RetailTransactionSericeOrders.createCustomerOrder() flow
                    //
                    //             - Online Orders, Asynchronous Customer Quotes, Asynchronous Customer Orders:
                    //                 - RetailOnlineOrderSynchronizer.CreateOrder() flow
                    //
                    if (!parameters.aggregateBeforePosting 
                        && transactionTable.type == RetailTransactionType::Sales)
                    {
                        while select forupdate transactionSalesTrans
                        where transactionSalesTrans.Store             == transactionTable.Store
                        &&    transactionSalesTrans.TerminalId        == transactionTable.Terminal
                        &&    transactionSalesTrans.TransactionId     == transactionTable.TransactionId
                        &&    transactionSalesTrans.TransactionStatus == RetailEntryStatus::None
                            join transactionDiscountTrans
                            where transactionDiscountTrans.StoreId           == transactionSalesTrans.Store
                            &&    transactionDiscountTrans.TerminalId        == transactionSalesTrans.TerminalId
                            &&    transactionDiscountTrans.TransactionId     == transactionSalesTrans.TransactionId
                            &&    transactionDiscountTrans.SaleLineNum       == transactionSalesTrans.lineNum
                        {
                            RetailTracer::Info('Posting', 'RetailStatementPost::postRetailSpecific()',
                                               'Displaying field values of RetailTransactionSalesTrans. ItemId = %1, Store = %2,  Terminal = %3, taxGroup = %4, TaxItemGroup = %5, DefaultDimension = %6, TransactionId = %7',
                                               transactionSalesTrans.itemId, transactionSalesTrans.store, transactionSalesTrans.terminalId, transactionSalesTrans.taxGroup, transactionSalesTrans.TaxItemGroup, transactionSalesTrans.DefaultDimension, transactionSalesTrans.transactionId);

                            RetailTracer::Info('Posting', 'RetailStatementPost::postRetailSpecific()',
                                               'Displaying field values of RetailTransactionDiscountTrans. PeriodicDiscountOfferId = %1, DiscountCost = %2,  TransactionId = %3',
                                               transactionDiscountTrans.PeriodicDiscountOfferId, transactionDiscountTrans.DiscountCost, transactionDiscountTrans.TransactionId);

                            this.postDiscounts(documentNumber, transactionSalesTrans, transactionDiscountTrans, transactionTable.Currency, transactionTable.CustAccount);
                        }
                    }

                    // Post income expense line.
                    if (transactionTable.incomeExpenseAmount && !countryRegion_W)
                    {
                        this.postIncomeExpenseLine(transactionTable);
                    }
                    // Post countryRegion_W Specific
                    if (countryRegion_W)
                    {
                        this.postWSpecific_W(transactionTable);
                    }

                    // <GBR>
                    if (countryRegion_BR)
                    {
                        this.postBrazilSpecific_BR(transactionTable);
                    }
                    // </GBR>
                }

                // <GEERU>
                if (transactionStatementPaymentJournal)
                {
                    transactionStatementPaymentJournal.postLedgerJournal();
                    transactionStatementPaymentJournal.postLedgerJournal(LedgerJournalType::RCash);
                }
                // </GEERU>

                this.linkSalesOrderVouchersToStatement();

                this.postPayment();

                if (ledgerVoucher)
                {
                    ledgerVoucher.end();
                }

                this.markTransactions(statementTable);

                RetailPosBatchTable::markAsPosted(statementTable.statementId);

                // If Retail Parameter Tax on Gift Card is set and price includesSalesTax is set then run Posting on Gift Card Sales Tax provisioning to Holding account.
                if (parameters.TaxOnGiftCards && RetailStoreTable::find(statementTable.storeId).PriceIncludesSalesTax)
                {
                   this.postGiftCardForSalesTaxProvision();
                }

                this.postCrossCompanyGiftcard();

                this.insertStatementJour(statementTable);

                // <GBR>
                if (countryRegion_BR)
                {
                    this.concludePost_BR(statementTable);
                }
                // </GBR>

                this.deleteStatement(statementTable);
            }
            else
            {
                // If the statement's payments are already in the posting status, throw an error.
                RetailStatementPostingLogger::Error(
                    funcName(),
                    #linenumber,
                    strFmt('This statement %1 payment lines are already getting processed in another process.', this.parmStatementId()));
                throw error(strFmt("@Ret_HF_216013:RetailEodStatementPaymentGettingProcessedError", this.parmStatementId()));
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            info("@SYS65063"); // Deadlock detected
            RetailStatementPostingLogger::Error(
                funcName(),
                #linenumber,
            strFmt('Deadlock exception occurred in statement posting - retry count is %1.', int2Str(xSession::currentRetryCount())));

            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                RetailStatementPostingLogger::Error(
                    funcName(),
                    #linenumber,
                strFmt('UpdateConflict exception occurred in statement posting. Maximum retry count is reached. Retry count is %1.', int2Str(xSession::currentRetryCount())));

                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                info("@SYS107548"); // Update conflicts
                RetailStatementPostingLogger::Error(
                    funcName(),
                    #linenumber,
                strFmt('UpdateConflict exception occurred in statement posting - retry count is %1.', int2Str(xSession::currentRetryCount())));

                retry;
            }
        }

        RetailTracer::Info('Posting', 'RetailStatementPost::postRetailSpecific()', 'Posting retail specific data %1 end', statementTable.statementId);

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepEnd(0, 'postRetailSpecific');
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTenderFlowLine_Agregated_W</Name>
				<Source><![CDATA[
    private void postTenderFlowLine_Agregated_W(RetailStatementPaymentJournal _tenderFlowStatementJournal)
    {
        RetailTransactionPaymentTrans transactionPaymentTrans;
        RetailTransactionTable        transactionTable;
        RetailStoreTenderTypeTable    storeTenderTypeTable;

        while select sum(AmountCur) from transactionPaymentTrans
            group by store, businessDate, TenderType, Currency, DefaultDimension
            where transactionPaymentTrans.statementId        == statementTable.statementId
                && transactionPaymentTrans.transactionStatus == RetailEntryStatus::None
                exists join transactionTable
                where transactionTable.transactionId == transactionPaymentTrans.transactionId &&
                    transactionTable.store           == transactionPaymentTrans.store         &&
                    transactionTable.terminal        == transactionPaymentTrans.terminal      &&
                    (transactionTable.type == RetailTransactionType::StartingAmount ||
                     transactionTable.type == RetailTransactionType::RemoveTender   ||
                     transactionTable.type == RetailTransactionType::FloatEntry)
        {
            if (!transactionPaymentTrans.AmountCur)
            {
                continue;
            }

            storeTenderTypeTable = RetailStoreTenderTypeTable::find(RetailStoreTable::find(transactionPaymentTrans.store).RecId, transactionPaymentTrans.tenderType);

            if (!storeTenderTypeTable.TenderFlowLedgerDimension_RU)
            {
                throw error(strFmt("@SYS4002014", transactionPaymentTrans.tenderType));
            }

            _tenderFlowStatementJournal.createPaymentLedgerTrans(
                storeTenderTypeTable.accountType,
                storeTenderTypeTable.LedgerDimension,
                RetailLedgerBank::Ledger,
                storeTenderTypeTable.TenderFlowLedgerDimension_RU,
                transactionPaymentTrans.currency,
                -transactionPaymentTrans.AmountCur,
                transactionPaymentTrans.businessDate,
                "@RET3021" + ' - ' + "@RET4514" + storeTenderTypeTable.tenderTypeId,
                statementTable.StatementId,
                transactionPaymentTrans.TenderType,
                transactionPaymentTrans.DefaultDimension);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTenderFlowLine_W</Name>
				<Source><![CDATA[
    private void postTenderFlowLine_W(RetailTransactionTable _transactionTable)
    {
        RetailTransactionPaymentTrans transactionPaymentTrans;
        RetailStoreTenderTypeTable    storeTenderTypeTable;

        this.createTransactionStatementPaymentJournal_W();

        while select sum(AmountCur) from transactionPaymentTrans
            group by tenderType, currency, DefaultDimension
            where  transactionPaymentTrans.Store             == _transactionTable.store
                && transactionPaymentTrans.Terminal          == _transactionTable.terminal
                && transactionPaymentTrans.TransactionId     == _transactionTable.transactionId
                && transactionPaymentTrans.TransactionStatus == RetailEntryStatus::None
        {
            storeTenderTypeTable = RetailStoreTenderTypeTable::find(RetailStoreTable::find(_transactionTable.store).RecId, transactionPaymentTrans.tenderType);

            if (!storeTenderTypeTable.TenderFlowLedgerDimension_RU)
            {
                throw error(strFmt("@SYS4002014", transactionPaymentTrans.tenderType));
            }

            transactionStatementPaymentJournal.createPaymentLedgerTrans(
                storeTenderTypeTable.accountType,
                storeTenderTypeTable.LedgerDimension,
                RetailLedgerBank::Ledger,
                storeTenderTypeTable.TenderFlowLedgerDimension_RU,
                transactionPaymentTrans.currency,
                -transactionPaymentTrans.AmountCur,
                _transactionTable.businessDate,
                "@RET3021"    + ' - ' +
                    "@RET4443"      + _transactionTable.TransactionId +
                    "@RET4444"      + _transactionTable.Store +
                    "@RET4445"      + _transactionTable.Terminal,
                statementTable.StatementId,
                transactionPaymentTrans.TenderType,
                transactionPaymentTrans.DefaultDimension
                );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postWSpecific_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts CountryRegion_W specific.
    /// </summary>
    /// <param name = "_transactionTable">The transaction table.</param>
    private void postWSpecific_W(RetailTransactionTable _transactionTable)
    {
        if (!countryRegion_W)
        {
            return;
        }

        if (!parameters.AggregateIncomeExpense_RU &&
            _transactionTable.type == RetailTransactionType::IncomeExpense)
        {
            this.postIncomeExpenseLine_W(_transactionTable);
        }

        if (!parameters.AggregateTenderFlow_RU &&
            (_transactionTable.type == RetailTransactionType::StartingAmount ||
            _transactionTable.type == RetailTransactionType::RemoveTender   ||
            _transactionTable.type == RetailTransactionType::FloatEntry))
        {
            this.postTenderFlowLine_W(_transactionTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postWSpecificAggregate_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts CountryRegion_W specific aggregation.
    /// </summary>
    /// <param name = "_aggregateStatementPaymentJournal">The payment journal.</param>
    private void postWSpecificAggregate_W(RetailStatementPaymentJournal _aggregateStatementPaymentJournal)
    {
        if (!countryRegion_W)
        {
            return;
        }

        if (parameters.AggregateIncomeExpense_RU)
        {
            this.postIncomeExpenseLine_Aggregated_W(_aggregateStatementPaymentJournal);
        }

        if (parameters.AggregateTenderFlow_RU)
        {
            this.postTenderFlowLine_Agregated_W(_aggregateStatementPaymentJournal);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>CheckStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the statement before posting.
    /// </summary>
    /// <param name = "_statementId">Statement id.</param>
    /// <remarks>
    /// Calls the class <c>RetailStatementPostChecker</c> to validate the statement.
    /// </remarks>
    public static void CheckStatement(RetailStatementId _statementId)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        RetailStatementPostChecker statementChecker;

        statementChecker = new RetailStatementPostChecker();
        statementChecker.parmStatementId(_statementId);
        statementChecker.parmInBatch(false);

        statementChecker.runOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates and post the Retail statement.
    /// </summary>
    /// <remarks>
    /// Also posts the discounts, payment, Income expense amount and sales orders.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// If the statement is incorrect, posting is cancelled and the status of batch framework task changes to error.
    /// </exception>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// Cannot update if any other user is trying update simultaneously. The update conflict cannot be recovered.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// Update conflict as any other user is trying to update the record at the same time.
    /// </exception>
    public void run()
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        #OccRetryCount
        InfoLogData infoLogData;
        RetailTransactionTable transTable;

        #Retail
        ;

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStart(0, "");
        RetailTracer::Info('Posting', 'RetailStatementPost::run()', 'Financial posting start');

        try
        {
            // In a rare condition, there might be multiple batch jobs which are posting the same
            // statement at the same time. In that case, we abort payment journal posting if there
            // are sales orders which have not been invoiced yet, and let the last batch job to take
            // payment journal posting.
            RetailTransactionSalesTrans salesLine;

            select count(RecId) from transTable
                join salesLine
                where transTable.StatementId == this.parmStatementId() &&
                        transTable.type == RetailTransactionType::Sales &&
                        !transTable.invoiceId &&
                        salesLine.Channel == transTable.Channel &&
                        salesLine.TransactionId == transTable.transactionId;

            if (transTable.RecId)
            {
                throw error(strFmt("@Retail:StatementSalesOrderNotInvoiced", this.parmStatementId()));
            }

            this.postRetailSpecific();
        }
        catch
        {
            if (this.parmStatementId())
            {
                // Running inside a batch framework task, so initialize the statementTable record buffer.
                statementTable = RetailStatementTable::find(this.parmStatementId(), true);
                if (statementTable.RecId)
                {
                    ttsbegin;
                    infoLogData = InfoLog.export();
                    statementTable.selectForUpdate(true);
                    statementTable.stmtPostInfoLog = infoLogData;
                    statementTable.doUpdate();
                    ttscommit;
                }
            }
            throw Exception::Error;
        }

        // Show the info dialog only if not running inside a batch framework task.
        if (!this.isInBatch())
        {
            if (operationProgress)
            {
                operationprogress.reset();
            }
            if (callerObject)
            {
                callerObject.activate(true);
            }

            Box::info("@RET4164");
        }

        RetailTracer::Info('Posting', 'RetailStatementPost::run()', 'Financial posting end');
        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostEnd(0, "");
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLVTOTransTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the ledger voucher transaction text.
    /// </summary>
    /// <param name="_transObject">
    /// The current instance of <c>LedgerVoucherTransObject</c> class.
    /// </param>
    /// <param name="_transTxtType">
    /// The current value of Transaction text type.
    /// </param>
    /// <param name="_additionalTxt">
    /// The additional text to be added to original text.
    /// </param>
    /// <returns>
    /// The whole text after concatenating original text to additional text.
    /// </returns>
    private TransactionTextLarge setLVTOTransTxt(LedgerVoucherTransObject _transObject,
                                     LedgerTransTxt           _transTxtType,
                                     TransactionTextLarge                 _additionalTxt)
    {
        TransactionTextLarge wholeTxt, originalTxt;
        TransactionTxt transTxt;

        transTxt = TransactionTxt::construct(_transTxtType);

        originalTxt = transTxt.txt();

        wholeTxt = this.concatTransTxt(originalTxt, _additionalTxt);

        _transObject.parmTransTxt(wholeTxt);

        return wholeTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>stampSOInvoiceIdsOnHeaders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates <c>RetailTransactionTable</c> after posting with the Invoice ID.
    /// </summary>
    void stampSOInvoiceIdsOnHeaders()
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        RetailTransactionTable  rboHeaders;
        CustInvoiceJour         custInvoiceJour;
        ;
        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepStart(0, 'stampSOInvoiceIdsOnHeaders');

        update_recordset rboHeaders
            setting InvoiceId = custInvoiceJour.InvoiceId
            join custInvoiceJour
            where   custInvoiceJour.SalesId == rboHeaders.salesOrderId
                &&  rboHeaders.store        == statementTable.storeId
                &&  rboHeaders.statementId  == statementTable.statementId
                &&  rboHeaders.salesOrderId
                &&  (! rboHeaders.invoiceId);

        RetailTracer::Info('Posting', 'RetailStatementPost::stampSOInvoiceIdsOnHeaders()', 'Updated %1 transactions with sales order ID', rboHeaders.RowCount());

        Microsoft.Dynamics.Retail.Tracing.RetailAXTraceProvider::EventWriteRAXStatementPostStepEnd(0, 'stampSOInvoiceIdsOnHeaders');
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        Integer         version        = conpeek(_packedClass,1);
        ;

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = _packedClass;
                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateShift</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status in the <c>RetailStoreWorkShiftTable</c> and <c>RetailStoreWorkShiftTrans</c> after posting.
    /// </summary>
    /// <param name="_statementTable">
    /// The current instance of statment table.
    /// </param>
    void updateShift(RetailStatementTable _statementTable)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        RetailStoreWorkShiftTable   workShiftTable;
        RetailStoreWorkShiftTrans   workShiftTrans;

        if (_statementTable.ClosingMethod == RetailClosingMethodType::PosBatch)
        {
            select firstonly forupdate workShiftTable
                where workShiftTable.StoreRecId == RetailStoreTable::find(_statementTable.storeId).RecId
                   && workShiftTable.ShiftDate == _statementTable.ShiftDate
                   && workShiftTable.ShiftId == _statementTable.ShiftId;

            if (workShiftTable)
            {
                workShiftTable.WorkShiftStatus = RetailWorkShiftStatus::Posted;
                workShiftTable.doUpdate();

                while select forupdate workShiftTrans
                    where workShiftTrans.StoreRecId == workShiftTable.StoreRecId
                       && workShiftTrans.ShiftDate == workShiftTable.ShiftDate
                       && workShiftTrans.ShiftId == workShiftTable.ShiftId
                {
                    workShiftTrans.Status = RetailWorkShiftStatus::Posted;
                    workShiftTrans.doUpdate();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        if (RetailEodStatementFeatureHelper::isNewEodEnabled())
        {
            str dictMenuLabel = "@Retail:RetailEodRetailStatementsLabel";

            // Your system is configured to use the new statement posting process. Please use the form "Open statement" to execute using the new process.
            throw error (strFmt("@Retail:RetailEodKeyEnabledFormError", dictMenuLabel));
        }

        if (_args && _args.dataset())
        {
            switch (_args.dataset())
            {
                case tablenum(RetailStatementTable) :
                    RetailStatementTable statementTable = _args.record();

                    RetailStatementPost::CheckStatement(statementTable.statementId);
                    RetailStoreOrderSynchronizer::CreateStoreSalesorders(statementTable.statementId, true);

                    FormDataSource formDS = FormDataUtil::getFormDataSource(statementTable);
                    if (formDS)
                    {
                        formDS.research();
                    }
                    break;
                default :
                    throw error ("@RET4156");
            }
        }
        else
        {
            throw error ("@RET4156");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingController_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a ledger posting controller to be used at the Z report posting.
    /// </summary>
    /// <returns>
    /// An instance of <c>LedgerPostingController</c>.
    /// </returns>
    public LedgerPostingController getLedgerPostingController_BR()
    {
        RetailStatementFeatureControl::checkAndThrowIfLegacyObsoleteErrorsEnabled(funcName());

        return LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailFiscalDocumentPost_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a class to post a fiscal document based on a consumer retail fiscal document (model 65) record.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The <c>CustInvoiceJour</c> record generated by the Retail statement.
    /// </param>
    /// <returns>
    /// An instance of <c>RetailFiscalDocumentPost_BR</c>.
    /// </returns>
    protected RetailFiscalDocumentPost_BR getRetailFiscalDocumentPost_BR(CustInvoiceJour    _custInvoiceJour)
    {
        return new RetailFiscalDocumentPost_BR(_custInvoiceJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailZReportValidation_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a class to validate a Z report.
    /// </summary>
    /// <param name="_retailZReport">
    /// A record of <c>RetailZReport_BR</c>.
    /// </param>
    /// <returns>
    /// An instance of <c>RetailZReportValidation_BR</c>.
    /// </returns>
    protected RetailZReportValidation_BR getRetailZReportValidation_BR(RetailZReport_BR  _retailZReport)
    {
        return new RetailZReportValidation_BR(_retailZReport);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxRetailZReport_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a tax class to handle the ledger post of a Z report.
    /// </summary>
    /// <param name="_retailZReport">
    /// A record of <c>RetailZReport_BR</c>.
    /// </param>
    /// <returns>
    /// An instance of <c>TaxRetailZReport_BR</c>.
    /// </returns>
    protected TaxRetailZReport_BR getTaxRetailZReport_BR(RetailZReport_BR  _retailZReport)
    {
        return new TaxRetailZReport_BR(_retailZReport);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionText_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the transaction text to be used at the Z report posting.
    /// </summary>
    /// <param name="_retailZReport">
    /// The given Z report.
    /// </param>
    /// <returns>
    /// The transaction text.
    /// </returns>
    protected TransTxt getTransactionText_BR(RetailZReport_BR   _retailZReport)
    {
        return strFmt("@SYP4930014",
                      _retailZReport.ZReportNumber,
                      _retailZReport.FiscalPrinterSerialNumber,
                      _retailZReport.StoreId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postBrazilSpecific_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts all Brazilian specific data
    /// </summary>
    /// <param name="_transactionTable">
    /// The <c>RetailTransactionTable</c> currently being posted.
    /// </param>
    /// <remarks>
    /// Each retail transaction may have multiple Retail Brazilian records associated to.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// Thrown if no Brazilan records are found associated to the Retail transaction.
    /// </exception>
    protected void postBrazilSpecific_BR(RetailTransactionTable _transactionTable)
    {
        boolean documentFound;

        switch (_transactionTable.type)
        {
            case RetailTransactionType::Sales:

                documentFound = this.postRetailFiscalDocument_BR(_transactionTable);

                if (!documentFound)
                {
                    documentFound = this.postRetailFiscalDocumentCanceled_BR(_transactionTable);
                }

                if (!documentFound)
                {
                    documentFound = this.postFiscalReceipt_BR(_transactionTable);
                }

                if (!documentFound)
                {
                    documentFound = this.postFiscalReceiptVoided_BR(_transactionTable);
                }

                if (!documentFound)
                {
                    documentFound = this.postFiscalDocumentModel2_BR(_transactionTable);
                }
                break;

            case RetailTransactionType::PrintZ:
                this.postZReport_BR(_transactionTable);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postRetailFiscalDocument_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts a consumer retail fiscal document (model 65) originally created at the POS.
    /// </summary>
    /// <param name="_transactionTable">
    /// A <c>RetailTransactionTable</c> record being processed by the statement.
    /// </param>
    /// <returns>
    /// true if a fiscal document was found related to the Sales transaction; otherwise, false.
    /// </returns>
    protected boolean postRetailFiscalDocument_BR(RetailTransactionTable _transactionTable)
    {
        boolean                         documentFound = false;
        CustInvoiceJour                 custInvoiceJour;
        RetailTransactionTable          transactionTableCancel;
        RetailFiscalDocumentPost_BR     retailFiscalDocumentPost;
        RetailFiscalDocument_BR         retailFiscalDocument;
        RetailFiscalDocumentCancel_BR   retailFiscalDocumentCancel;

        retailFiscalDocument = RetailFiscalDocument_BR::findByRetailTransaction(_transactionTable);

        if (retailFiscalDocument)
        {
            select custInvoiceJour
                where   custInvoiceJour.InvoiceId   == _transactionTable.invoiceId
                    &&  custInvoiceJour.InvoiceDate == _transactionTable.businessDate;

            retailFiscalDocumentPost = this.getRetailFiscalDocumentPost_BR(custInvoiceJour);
            retailFiscalDocumentPost.run(retailFiscalDocument);

            // If exists a NFC-e cancelling at the same statement, then cancel it.
            // (the actual cancelling might have already happened, but no NFC-e existed to be canceled)
            select transactionTableCancel
                exists join retailFiscalDocumentCancel
                    where   transactionTableCancel.transactionId    == retailFiscalDocumentCancel.transactionId
                        &&  transactionTableCancel.store            == retailFiscalDocumentCancel.store
                        &&  transactionTableCancel.terminal         == retailFiscalDocumentCancel.terminal
                        &&  transactionTableCancel.statementId      == _transactionTable.statementId
                        &&  retailFiscalDocumentCancel.AccessKey    == retailFiscalDocument.AccessKey;

            if (transactionTableCancel)
            {
                this.postRetailFiscalDocumentCanceled_BR(transactionTableCancel);
            }

            documentFound = true;
        }

        return documentFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postRetailFiscalDocumentCanceled_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the canceling of a consumer retail fiscal document (model 65) originally created at the POS.
    /// </summary>
    /// <param name="_transactionTable">
    /// A <c>RetailTransactionTable</c> record being processed by the statement.
    /// </param>
    /// <returns>
    /// true if a fiscal document was found related to the Sales transaction; otherwise, false.
    /// </returns>
    /// <remarks>
    /// It could happen that this cancel method is called before the NFC-e is posted.
    /// </remarks>
    protected boolean postRetailFiscalDocumentCanceled_BR(RetailTransactionTable _transactionTable)
    {
        boolean                         documentFound = false;
        CustInvoiceJour                 custInvoiceJour;
        RetailFiscalDocumentPost_BR     retailFiscalDocumentPost;
        RetailFiscalDocumentCancel_BR   retailFiscalDocumentCancel;
        FiscalDocument_BR               fiscalDocument;

        retailFiscalDocumentCancel = RetailFiscalDocumentCancel_BR::findByRetailTransaction(_transactionTable);
        if (retailFiscalDocumentCancel)
        {
            fiscalDocument = FiscalDocument_BR::findByAccessKey(retailFiscalDocumentCancel.AccessKey);
            if (fiscalDocument)
            {
                if (fiscalDocument.Status == FiscalDocumentStatus_BR::Approved)
                {
                    // If there is a NFC-e and it's not canceled (posted at another statement), then we proceed with cancelling it.

                    select custInvoiceJour
                        where   custInvoiceJour.InvoiceId   == _transactionTable.invoiceId
                            &&  custInvoiceJour.InvoiceDate == _transactionTable.businessDate;

                    retailFiscalDocumentPost = this.getRetailFiscalDocumentPost_BR(custInvoiceJour);
                    retailFiscalDocumentPost.cancel(retailFiscalDocumentCancel);
                }
                // Else the NFC-e was already canceled during its own posting.
            }
            // Else the NFC-e will yet be posted (guaranteed by our validations during the calculate)

            documentFound = true;
        }

        return documentFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postZReport_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes a Z report issued by the fiscal printer.
    /// </summary>
    /// <param name="_transactionTable">
    /// The Retail sales transaction related to the Z report.
    /// </param>
    protected void postZReport_BR(RetailTransactionTable _transactionTable)
    {
        boolean                             ok = true;
        RetailZReport_BR                    retailZReport;
        TaxRetailZReport_BR                 taxRetailZReport;

        select forUpdate retailZReport
            where   retailZReport.StoreId       == _transactionTable.Store
                &&  retailZReport.TerminalId    == _transactionTable.terminal
                &&  retailZReport.TransactionId == _transactionTable.transactionId;

        if (retailZReport)
        {
            // Post the Z report
            this.initVoucher(retailZReport.AccountingDate);
            ledgerVoucherObject.lastTransTxt(this.getTransactionText_BR(retailZReport));

            taxRetailZReport = this.getTaxRetailZReport_BR(retailZReport);
            taxRetailZReport.calcAndPost(this.getLedgerPostingController_BR());

            retailZReport.IsStatementPosted = NoYes::Yes;
            retailZReport.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransactionStatementPaymentJournal_W</Name>
				<Source><![CDATA[
    private void createTransactionStatementPaymentJournal_W()
    {
        if (countryRegion_W && !transactionStatementPaymentJournal)
        {
            transactionStatementPaymentJournal = new RetailStatementPaymentJournal(statementTable, LedgerJournalType::Daily);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerOffsetAccount</Name>
				<Source><![CDATA[
    private container getLedgerOffsetAccount(
                    RetailStoreId _storeId,
                    RetailTenderTypeId _tenderTypeId,
                    RetailCardTypeId _cardTypeId,
                    DimensionDefault _paymentDimension)
    {
        LedgerJournalACType             offsetAccountType;
        DimensionDefault                offsetAccountDefaultDimension;
        LedgerDimensionDefaultAccount   offsetAccountNum;

        RetailStoreTenderTypeTable         storeTenderTypeTable;
        RetailStoreTenderTypeCardTable     storeTenderTypeCardTable;

        storeTenderTypeTable = RetailStoreTenderTypeTable::find(RetailStoreTable::find(_storeId).RecId, _tenderTypeId);

        switch (storeTenderTypeTable.function)
        {
            case RetailTenderFunction::Card:
                if (_cardTypeId)
                {
                    storeTenderTypeCardTable = RetailStoreTenderTypeCardTable::find(RetailStoreTable::find(_storeId).RecId, _tenderTypeId, _cardTypeId);
                    if (storeTenderTypeCardTable && storeTenderTypeCardTable.LedgerDimension)
                    {
                        offsetAccountType = (storeTenderTypeCardTable.accountType == RetailLedgerBank::Ledger) ? LedgerJournalACType::Ledger : LedgerJournalACType::Bank;
                        offsetAccountNum  = storeTenderTypeCardTable.LedgerDimension;
                        break;
                    }
                }
                // this code must match that in the default clause below.
                offsetAccountType = RetailStatementLedgerJournalHelper::ledgerBank2LedgerJournalACType(storeTenderTypeTable.accountType);
                offsetAccountNum  = storeTenderTypeTable.LedgerDimension;
                offsetAccountDefaultDimension = storeTenderTypeTable.DefaultDimension;
                break;

            case RetailTenderFunction::Customer:
                break;

            default:
                offsetAccountType = RetailStatementLedgerJournalHelper::ledgerBank2LedgerJournalACType(storeTenderTypeTable.accountType);
                offsetAccountNum  = storeTenderTypeTable.LedgerDimension;
                offsetAccountDefaultDimension = storeTenderTypeTable.DefaultDimension;
                break;
        }

        if (offsetAccountType == LedgerJournalACType::Ledger)
        {
            offsetAccountNum = LedgerDimensionFacade::serviceCreateLedgerDimension(offsetAccountNum, LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(_paymentDimension, offsetAccountDefaultDimension));
        }

        return [offsetAccountType, offsetAccountNum, offsetAccountDefaultDimension];
    }

]]></Source>
			</Method>
			<Method>
				<Name>postGiftCardForSalesTaxProvision</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post Issue Gift Card and Add to Gift Card transactions for Sales Tax provision to holding account.
    /// </summary>
    private void postGiftCardForSalesTaxProvision()
    {
        RetailTransactionSalesTrans     giftcardSalesTrans;
        RetailTransactionPaymentTrans   giftcardPaymentTrans;
        RetailStoreTenderTypeTable      storeTenderTypeTable;
        NumberSequenceTable             numberSequenceTable;
        LedgerJournalTrans              ledgerJournalTrans;
        NumberSeq                       journalNumSeq;
        NumberSeq                       voucherNumSeq;
        LedgerJournalTable              ledgerJournal;
        LedgerJournalName               gcJournalName;
        RetailStatementVoucher          statementVoucher;
        TaxAmount                       taxAmount;
        LedgerDimensionAccount          payableAccount;
        LedgerDimensionAccount          holdingAccount;
        TaxCode                         taxCode;
        container                       payableAndHoldingAccountWithTax;
        int                             containerLength;
        int                             counter;
        LineNum                         lineNum;
        Voucher                         giftCardVoucher;

        const int                       PayableAccountItem = 1;
        const int                       HoldingAcount = 2;
        const int                       TaxCodeItem = 3;
        const int                       TaxPercent = 4;

        void createLedgerTrans(
                LedgerDimensionAccount _accountNum,
                CurrencyCode           _currency,
                TaxCode                _taxCode,
                AmountCur              _Amount,
                LineNum                _lineNum,
                TransDate              _date)
        {
            LedgerJournalTrans                      ledgerJournalLine;

            if (!_Amount)
            {
                return;
            }

            if (!_accountNum)
            {
                // Account number or offset account number is not correctly set up, gift card sales tax provision posting can't proceed.
                throw error("@Retail:PostGiftCardForSalesTaxProvisionAccountNumErrMsg");
            }

            ledgerJournalLine.initValue();

            ledgerJournalLine.JournalNum = ledgerjournal.JournalNum;
            ledgerJournalLine.AccountType = LedgerJournalACType::Ledger;
            ledgerJournalLine.Company = curext();
            ledgerJournalLine.LedgerDimension = _accountNum;

            ledgerJournalLine.DefaultDimension = LedgerJournal.DefaultDimension;
            ledgerJournalLine.TaxCode = _taxCode;

            ledgerJournalLine.CurrencyCode = _currency;
            ledgerJournalLine.TransDate = _date;

            ledgerJournalLine.DocumentNum = statementTable.statementId;
            ledgerJournalLine.TransactionType = LedgerTransType::GeneralJournal;
            ledgerJournalLine.Approved = NoYes::Yes;
            ledgerJournalLine.LineNum = _lineNum;
            ledgerJournalLine.Voucher = giftCardVoucher;

            if (_Amount < 0)
            {
                ledgerJournalLine.AmountCurDebit = abs(_Amount);
            }
            else
            {
                ledgerJournalLine.AmountCurCredit = _Amount;
            }

            ledgerJournalLine.defaultRow();

            ledgerJournalLine.insert();
        }

        TaxAmount getTaxAmountForPricesInclusiveofTax(RetailNetAmount amountInclusiveTax, TaxValue taxRate, CurrencyCode currency)
        {
            TaxAmount tax;

            tax = amountInclusiveTax * (taxRate / (100 + taxRate));

            tax = CurrencyExchange::round(tax, currency);

            return tax;
        }

        select journalName from gcJournalName where gcJournalName.JournalName == RetailGiftCardPostingParameters::getGiftCardLedgerJournalName();

        if (!gcJournalName)
        {
            // Journal name is not correctly set up, gift card Tax withholding secondary posting can't proceed.
            throw error("@Retail:PostGiftCardForSalesTaxProvisionJournalNameErrMsg");
        }

        journalNumSeq = NumberSeq::newGetNum(LedgerParameters::numRefJournalNum());

        // Create ledger journal

        ledgerJournal.JournalName = gcJournalName.JournalName;
        ledgerJournal.JournalType = gcJournalName.JournalType;
        ledgerJournal.JournalNum = journalNumSeq.num();
        ledgerJournal.NumberSequenceTable = gcJournalName.NumberSequenceTable;
        ledgerJournal.DefaultDimension = statementTable.DefaultDimension;
        ledgerJournal.RetailStatementId = statementTable.statementId;

        ledgerJournal.insert();

        select firstOnly numberSequenceTable
        where numberSequenceTable.RecId == gcJournalName.NumberSequenceTable;

        voucherNumSeq = NumberSeq::newGetVoucherFromCode(numberSequenceTable.NumberSequence, NumberSeqScopeFactory::createDefaultScope(), false, true);
        giftCardVoucher = voucherNumSeq.voucher();

        // Get container with payable account (TaxOutgoingLedgerDimension), holding account (TaxReportLedgerDimension) and Tax Percentage (TaxValue)
        payableAndHoldingAccountWithTax = RetailGiftCardPostingParameters::getGiftcardTaxWithPayableAndHoldingAccount(curext(), statementTable.storeId);
        containerLength = conLen(payableAndHoldingAccountWithTax);

        lineNum = 0;
        // For Issue Gift Card and Add To Gift Card Lines, hold tax on GiftCard Amount.
        while select sum(netAmountInclTax), businessDate, currency  from giftcardSalesTrans
            group by statementId, businessDate, currency
            where   giftcardSalesTrans.statementId          == statementTable.statementId 
                &&  giftcardSalesTrans.store                == statementTable.storeId
                &&  (   giftcardSalesTrans.itemId           == RetailParameters::find().GiftcardItem
                    ||  giftcardSalesTrans.giftcard         == NoYes::Yes)
                &&  giftcardSalesTrans.transactionStatus    != RetailEntryStatus::Voided
        {
            if (giftcardSalesTrans.netAmountInclTax)
            {
                // Create Journal line for Payable accounts from each Tax Code and Debit TaxAmount and Holding accont from each tax code and Credit TaxAmount.
                for (counter = 1; counter <= containerLength; counter++)
                {
                    taxCode = conPeek(conPeek(payableAndHoldingAccountWithTax, counter), TaxCodeItem);
                    taxAmount = getTaxAmountForPricesInclusiveofTax(abs(giftcardSalesTrans.netAmountInclTax), conPeek(conPeek(payableAndHoldingAccountWithTax, counter), TaxPercent), giftcardSalesTrans.currency);
                    payableAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(conPeek(conPeek(payableAndHoldingAccountWithTax, counter), PayableAccountItem), statementTable.DefaultDimension);
                    holdingAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(conPeek(conPeek(payableAndHoldingAccountWithTax, counter), HoldingAcount), statementTable.DefaultDimension);

                    lineNum = lineNum + 1;
                    // Create ledger journal lines for account payable.
                    createLedgerTrans(
                        payableAccount,
                        giftcardSalesTrans.currency,
                        taxCode,
                        taxAmount,
                        lineNum,
                        giftcardSalesTrans.businessDate);

                    lineNum = lineNum + 1;
                    // Create ledger journal lines for holding account
                    createLedgerTrans(
                        holdingAccount,
                        giftcardSalesTrans.currency,
                        taxCode,
                        -taxAmount,
                        lineNum,
                        giftcardSalesTrans.businessDate);
                }
            }
        }

        storeTenderTypeTable = RetailGiftCardPostingParameters::getStoreGiftcardTenderType(statementTable.storeId);

        while select sum(amountCur), businessDate, currency from giftcardPaymentTrans
            group by statementId, businessDate, currency
            where   giftcardPaymentTrans.statementId        == statementTable.statementId 
                &&  giftcardPaymentTrans.store              == statementTable.storeId
                &&  giftcardPaymentTrans.tenderType         == storeTenderTypeTable.tenderTypeId
                &&  giftcardPaymentTrans.transactionStatus  != RetailEntryStatus::Voided
        {
            if (giftcardPaymentTrans.amountCur)
            {
                // Create Journal line for Payable accounts from each Tax Code and credit TaxAmount
                for (counter = 1; counter <= containerLength; counter++)
                {
                    taxCode = conPeek(conPeek(payableAndHoldingAccountWithTax, counter), TaxCodeItem);
                    taxAmount = getTaxAmountForPricesInclusiveofTax(abs(giftcardPaymentTrans.amountCur), conPeek(conPeek(payableAndHoldingAccountWithTax, counter), TaxPercent), giftcardPaymentTrans.currency);
                    payableAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(conPeek(conPeek(payableAndHoldingAccountWithTax, counter), PayableAccountItem), statementTable.DefaultDimension);
                    holdingAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(conPeek(conPeek(payableAndHoldingAccountWithTax, counter), HoldingAcount), statementTable.DefaultDimension);

                    lineNum = lineNum + 1;
                    // Create ledger journal lines for account payable.
                    createLedgerTrans(
                        payableAccount,
                        giftcardPaymentTrans.currency,
                        taxCode,
                        -taxAmount,
                        lineNum,
                        giftcardPaymentTrans.businessDate);

                    lineNum = lineNum + 1;
                    // Create ledger journal lines for account holding.
                    createLedgerTrans(
                        holdingAccount,
                        giftcardPaymentTrans.currency,
                        taxCode,
                        taxAmount,
                        lineNum,
                        giftcardPaymentTrans.businessDate);
                }
            }
        }

        voucherNumSeq.used();

        // Post the journal
        select firstonly RecId from ledgerJournalTrans
        where ledgerJournalTrans.JournalNum == ledgerJournal.JournalNum;

        if (ledgerJournalTrans.RecId)
        {
            LedgerJournalPost::postJournal(ledgerJournal, NoYes::No, false, true);

            // Link voucher to statement
            RetailStatementId currentStatementId = statementTable.statementId;

            insert_recordset statementVoucher (voucher, voucherDate, statementId)
                select Voucher, TransDate, currentStatementId from ledgerJournalTrans
                    group by ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate
                    where ledgerJournalTrans.JournalNum == ledgerJournal.JournalNum;
        }
        else
        {
            ledgerJournal.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>