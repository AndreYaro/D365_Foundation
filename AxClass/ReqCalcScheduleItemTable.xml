<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReqCalcScheduleItemTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class ReqCalcScheduleItemTable extends ReqCalc implements BatchRetryable
{
    QueryRun        query;
    container       packedOriginalQuery;
    boolean         updateSoftDeletedOnly;

    Map             mapRegen;
    boolean         mustDeleteInventSumLogTTS;

    ReqPlanCopy     reqPlanCopy;
    ReqBackgroundJobService backgroundJobService;

    boolean         autoUpdateStaticPlan;
    boolean         autoUpdateDynamicPlan;
    private readonly boolean planningOptimizationExceptionToggleIsEnabled;
    private boolean isFitForPlanningOptimization;
    private readonly boolean failFastOnLostLockToggleEnabled;
    private boolean giveUpOnReacquiringTheLock;
    private boolean completedEventWasInvoked = false;
    private ReqCalcRestartResumeNative reqCalcRestartResume;
    internal boolean reqCalcInstanceIsRestartable;
    internal utcdatetime mainThreadStuckCheckLastTime;
    internal boolean isMainThreadStuck;
    internal boolean threadExitedDueToMainThreadNotExecuting;

    internal static const int ThreadRetriesOnFailure = 7;

    Batch currentBatchTask;

    #Req
    #define.TotalRuntimeXpp('TotalRuntimeXpp')

    #DEFINE.CurrentVersion(8)

    #LOCALMACRO.CurrentList
    #ENDMACRO
    #DEFINE.ReqCalcScheduleItemTableCurrentThreadVersion(101)
    #LOCALMACRO.ReqCalcScheduleItemTableCurrentThreadList
        autoUpdateStaticPlan,
        autoUpdateDynamicPlan
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>backgroundJobService</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Exposes an instance of the <c>ReqBackgroundJobService</c> class.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>ReqBackgroundJobService</c> class.
    /// </returns>
    public ReqBackgroundJobService backgroundJobService()
    {
        if (!backgroundJobService)
        {
            backgroundJobService = ReqBackgroundJobService::newBatchHeader();
        }
        return backgroundJobService;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bulkDeleteAndUpdateCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Deletes a plan completely or partially.
    /// </summary>
    protected void bulkDeleteAndUpdateCache()
    {
        this.insertApprovedPo();

        try
        {
            if ((setApprovedPlannedOrder && setApprovedPlannedOrder.elements() > 0)
                || reqPlanData.useLockingTimeFence())
            {
                this.insertReqTransCovKeep(sourcePlanVersion, targetPlanVersion);

                // Copy preserved data into the inactive version of the target plan.
                this.reqPlanCopy().copyPreservedPlanData(
                    sourcePlanVersion,
                    targetPlanVersion,
                    reqPlanData);

                this.add2ReqTransCache(false);
            }
        }
        catch (Exception::Deadlock)
        {
            if (this.manageExceptionDeadLock())
            {
                retry;
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (this.retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if ( this.manageExceptionUpdateConflict() )
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the class is shown in a list of the <c>Journal</c> types.
    /// </summary>
    /// <returns>
    ///    true if the class is shown in a list of the <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    A class that can be used in a batch journal is a class where the same parameters can be used
    ///    repeatedly. The dialog can be shown and the parameters can be changed, but parameters of some
    ///    classes might build on data that is only valid for a short time. Running a class two times with the
    ///    same parameters is not always possible. If the <c>RunBaseBatch.canGoBatch</c> method is false, this
    ///    method will not have any effect.
    /// </remarks>
    public boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>caption</Name>
				<Source><![CDATA[
    public ClassDescription caption()
    {
        return "@SYS25297";
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemFilterPreUpdateAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether item filtering at the preupdate phase is allowed. This should only be allowed when a full regeneration with the
    /// filtering parameter for preupdate is run.
    /// </summary>
    /// <returns>A boolean indicating whether running with the preupdate filter is allowed.</returns>
    private boolean itemFilterPreUpdateAllowed()
    {
        return this.isCompleteUpdate() && reqPlanData.useItemFilterPreUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemFilterPreCoverageAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether item filtering at the precoverage phase is allowed. This should only be allowed when a full regeneration with the
    /// filtering parameter for precoverage is run.
    /// </summary>
    /// <returns>A boolean indicating whether running with the precoverage filter is allowed.</returns>
    private boolean itemFilterPreCoverageAllowed()
    {
        return this.isCompleteUpdate() && reqPlanData.useItemFilterPreCoverage();
    }

]]></Source>
			</Method>
			<Method>
				<Name>minInventOnhandQueryValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves minimum inventory on hand query value.
    /// </summary>
    /// <returns>
    /// Minimum inventory on hand query value.
    /// </returns>
    protected str minInventOnhandQueryValue()
    {
        return '> 0';
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReqProcessItemDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a <c>ReqProcessItemDetails</c> record buffer.
    /// </summary>
    /// <param name = "_processId">
    /// A <c>ReqProcessId</c> value.
    /// </param>
    /// <param name = "_inventTable">
    /// An <c>InventTable</c> record buffer.
    /// </param>
    /// <param name = "_loopOnhand">
    /// A boolean value indicating whether or not to use onhand inventory.
    /// </param>
    /// <param name = "_loopReceipt">
    /// A boolean value indicating whether or not to use purchase transactions.
    /// </param>
    /// <param name = "_loopIssue">
    /// A boolean value indicating whether or not to use sales transactions.
    /// </param>
    /// <param name = "_loopForecastDemand">
    /// A boolean value indicating whether or not to use demand forecast.
    /// </param>
    /// <param name = "_loopForecastSupply">
    /// A boolean value indicating whether or not to use supply forecast.
    /// </param>
    /// <param name = "_loopSafety">
    /// A boolean value indicating whether or not to use safety calculations.
    /// </param>
    /// <param name = "_mcrLoopContinuity">
    /// A boolean value indicating whether or not to use continuity plan.
    /// </param>
    /// <returns>
    /// The <c>ReqProcessItemDetails</c> record buffer.
    /// </returns>
    protected static ReqProcessItemDetails createReqProcessItemDetails (
        ReqProcessId _processId,
        InventTable _inventTable,
        boolean _loopOnhand,
        boolean _loopReceipt,
        boolean _loopIssue,
        boolean _loopForecastDemand,
        boolean _loopForecastSupply,
        boolean _loopSafety,
        boolean _mcrLoopContinuity)
    {
        ReqProcessItemDetails reqProcessItemDetails;

        reqProcessItemDetails.ProcessId = _processId;
        reqProcessItemDetails.ItemId = _inventTable.ItemId;
        reqProcessItemDetails.LoopOnhand = _loopOnhand;
        reqProcessItemDetails.LoopReceipt = _loopReceipt;
        reqProcessItemDetails.LoopIssue = _loopIssue;
        reqProcessItemDetails.LoopForecastDemand = _loopForecastDemand;
        reqProcessItemDetails.LoopForecastSupply = _loopForecastSupply;
        reqProcessItemDetails.LoopSafety = _loopSafety;
        reqProcessItemDetails.McrLoopContinuity = _mcrLoopContinuity;

        return reqProcessItemDetails;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLoopMapFromQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a map that contains information about what has to be processed for each item.
    /// </summary>
    /// <returns>
    ///    A map that contains information about what has to be processed for each item.
    /// </returns>
    /// <remarks>
    ///    The returned map is of the format (<c>ItemId</c>, [<c>loopOnhand</c>, <c>loopReceipt</c>,
    ///    <c>loopIssue</c>, <c>loopForecastSales</c>, <c>loopForecastPurch</c>, <c>loopSafety</c>, <c>McrLoopContinuity</c>]).
    /// </remarks>
    protected Map createLoopMapFromQuery()
    {
        ReqProcessItemDetails reqProcessItemDetails;

        if (!mapRegen)
        {
            mapRegen = new Map(Types::String, Types::Container);
        }

        while select reqProcessItemDetails where
            reqProcessItemDetails.ProcessId == processId
        {
            mapRegen.insert(reqProcessItemDetails.ItemId, [
                reqProcessItemDetails.LoopOnhand,
                reqProcessItemDetails.LoopReceipt,
                reqProcessItemDetails.LoopIssue,
                reqProcessItemDetails.LoopForecastDemand,
                reqProcessItemDetails.LoopForecastSupply,
                reqProcessItemDetails.LoopSafety,
                reqProcessItemDetails.McrLoopContinuity]);
        }
        return mapRegen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeReqItemDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Collects and saves information about what has to be processed for each item to ReqProcessItemDetails table.
    /// </summary>
    protected void initializeReqItemDetails()
    {
        InventTable             inventTable;

        Set                     setItemOnhand           = new Set(Types::String);
        Set                     setItemReceipt          = new Set(Types::String);
        Set                     setItemIssue            = new Set(Types::String);
        Set                     setItemSafety           = new Set(Types::String);
        Set                     setItemForecastDemand   = new Set(Types::String);
        Set                     setItemForecastSupply   = new Set(Types::String);
        Map                     itemFilterMap           = new Map(Types::String, Types::Integer);

        Query                   queryRegen;
        QueryRun                queryRunRegen;
        QueryBuildDataSource    dsInventTable;
        QueryBuildDataSource    dsInventSumOnHand;
        QueryBuildDataSource    dsInventSumReceipts;
        QueryBuildDataSource    dsInventSumIssues;
        QueryBuildDataSource    dsWHSInventEnabled;
        QueryBuildDataSource    dsWHSInventReserve;

        QueryBuildDataSource    dsForecastInventSupply;
        QueryBuildDataSource    dsForecastInventDemand;
        QueryBuildDataSource    dsForecastModel;

        QueryBuildDataSource    dsReqItemTableSafety;
        QueryBuildRange         qrRecid;
        container               packedQuery;
        str                     rangeValue;

        Set                     mcrSetItemContinuity     = new Set(Types::String);
        QueryBuildDataSource    mcrDSContinuityCust;

        void initSubQuery()
        {
            queryRegen = new Query(packedQuery);
            dsInventTable = queryRegen.dataSourceNo(1);
            dsInventTable.addSelectionField(fieldNum(InventTable, ItemId));
            if (this.itemFilterPreUpdateAllowed())
            {
                dsInventTable.addSelectionField(fieldNum(InventTable, BOMLevel));
            }
        }

        void fillItemSetFromSubQuery(Set _set, boolean _skipItemFilterMapInsert)
        {
            queryRunRegen = new QueryRun(queryRegen);
            while (queryRunRegen.next())
            {
                inventTable = queryRunRegen.getNo(1);

                if (_set)
                {
                    _set.add(inventTable.ItemId);
                }

                if (!_skipItemFilterMapInsert && !itemFilterMap.exists(inventTable.ItemId) && this.itemFilterPreUpdateAllowed())
                {
                    itemFilterMap.insert(inventTable.ItemId, inventTable.BOMLevel);
                }
            }
        }

        packedQuery = query.query().pack();

        if (reqPlanData.useInventOnHands())
        {
            initSubQuery();
            dsInventSumOnHand = dsInventTable.addDataSource(tableNum(InventSum));
            dsInventSumOnHand.joinMode(JoinMode::ExistsJoin);
            dsInventSumOnHand.addLink(fieldNum(InventTable, ItemId), fieldNum(InventSum, ItemId));
            dsInventSumOnHand.addRange(fieldNum(InventSum, ClosedQty)).value(SysQuery::value(NoYes::No));
            dsInventSumOnHand.addRange(fieldNum(InventSum, PhysicalInvent)).value(SysQuery::valueNot(0));
            fillItemSetFromSubQuery(setItemOnhand, false);

            initSubQuery();
            var dsInventSumLogTTS = dsInventTable.addDataSource(tableNum(InventSumLogTTS));
            dsInventSumLogTTS.joinMode(JoinMode::ExistsJoin);
            dsInventSumLogTTS.addLink(fieldNum(InventTable, ItemId), fieldNum(InventSumLogTTS, ItemId));
            fillItemSetFromSubQuery(null, false);
        }

        if (reqPlanData.useMovements())
        {
            // receipts
            initSubQuery();
            dsInventSumReceipts = dsInventTable.addDataSource(tableNum(InventSum));
            dsInventSumReceipts.joinMode(JoinMode::ExistsJoin);
            dsInventSumReceipts.addLink(fieldNum(InventTable, ItemId), fieldNum(InventSum, ItemId));
            dsInventSumReceipts.addRange(fieldNum(InventSum, ClosedQty)).value(SysQuery::value(NoYes::No));
            qrRecid = dsInventSumReceipts.addRange(fieldNum(InventSum, RecId));
            qrRecid.value(strFmt('((%1 != %2) || (%3 != %4) || (%5 != %6))'
                                 , fieldStr(InventSum, Arrived), 0
                                 , fieldStr(InventSum, Ordered), 0
                                 , fieldStr(InventSum, QuotationReceipt), 0));
            fillItemSetFromSubQuery(setItemReceipt, false);

            // on order, quotation issues
            initSubQuery();
            dsInventSumIssues = dsInventTable.addDataSource(tableNum(InventSum));
            dsInventSumIssues.joinMode(JoinMode::ExistsJoin);
            dsInventSumIssues.addLink(fieldNum(InventTable, ItemId), fieldNum(InventSum, ItemId));
            dsInventSumIssues.addRange(fieldNum(InventSum, ClosedQty)).value(SysQuery::value(NoYes::No));
            qrRecid = dsInventSumIssues.addRange(fieldNum(InventSum, RecId));
            qrRecid.value(strFmt('((%1 != %2) || (%3 != %4))'
                                 , fieldStr(InventSum, OnOrder), 0
                                 , fieldStr(InventSum, QuotationIssue), 0));
            fillItemSetFromSubQuery(setItemIssue, false);

            // reserved ordered, reserved physical issues non-WHS items
            initSubQuery();
            dsWHSInventEnabled = dsInventTable.addDataSource(tableNum(WHSInventEnabled));
            dsWHSInventEnabled.joinMode(JoinMode::NoExistsJoin);
            dsWHSInventEnabled.addLink(fieldNum(InventTable, ItemId), fieldNum(WHSInventEnabled, ItemId));
            dsInventSumIssues = dsInventTable.addDataSource(tableNum(InventSum));
            dsInventSumIssues.joinMode(JoinMode::ExistsJoin);
            dsInventSumIssues.addLink(fieldNum(InventTable, ItemId), fieldNum(InventSum, ItemId));
            dsInventSumIssues.addRange(fieldNum(InventSum, ClosedQty)).value(SysQuery::value(NoYes::No));
            qrRecid = dsInventSumIssues.addRange(fieldNum(InventSum, RecId));

            rangeValue = '(';
            rangeValue += strFmt('(%1 != %2)', fieldStr(InventSum, ReservOrdered), 0);
            if (reqPlanData.useInventOnHands())
            {
                rangeValue += strFmt('|| (%1 != %2)', fieldStr(InventSum, ReservPhysical), 0);
            }

            rangeValue += ')';
            qrRecid.value(rangeValue);
            fillItemSetFromSubQuery(setItemIssue, false);

            // reserved ordered, reserved physical issues WHS items
            initSubQuery();
            dsWHSInventEnabled = dsInventTable.addDataSource(tableNum(WHSInventEnabled));
            dsWHSInventEnabled.joinMode(JoinMode::ExistsJoin);
            dsWHSInventEnabled.addLink(fieldNum(InventTable, ItemId), fieldNum(WHSInventEnabled, ItemId));
            dsWHSInventReserve = dsInventTable.addDataSource(tableNum(WHSInventReserve));
            dsWHSInventReserve.joinMode(JoinMode::ExistsJoin);
            dsWHSInventReserve.addLink(fieldNum(InventTable, ItemId), fieldNum(WHSInventReserve, ItemId));
            qrRecid = dsWHSInventReserve.addRange(fieldNum(WHSInventReserve, RecId));
            qrRecid.value(strFmt('((%1 != %2) || (%3 != %4))'
                                 , fieldStr(WHSInventReserve, ReservPhysical), 0
                                 , fieldStr(WHSInventReserve, ReservOrdered), 0));
            fillItemSetFromSubQuery(setItemIssue, false);
        }

        initSubQuery();
        dsReqItemTableSafety = dsInventTable.addDataSource(tableNum(ReqItemTable));
        dsReqItemTableSafety.joinMode(JoinMode::ExistsJoin);
        dsReqItemTableSafety.addLink(fieldNum(InventTable, ItemId), fieldNum(ReqItemTable, ItemId));
        dsReqItemTableSafety.addRange(fieldNum(ReqItemTable, MinInventOnhand)).value(this.minInventOnhandQueryValue());
        fillItemSetFromSubQuery(setItemSafety, false);

        if (reqPlanData.useForecastDemand())
        {
            initSubQuery();
            dsForecastInventDemand = dsInventTable.addDataSource(tableNum(ForecastInvent));
            dsForecastInventDemand.joinMode(JoinMode::ExistsJoin);
            dsForecastInventDemand.addLink(fieldNum(InventTable, ItemId), fieldNum(ForecastInvent, ItemId));
            dsForecastInventDemand.addRange(fieldNum(ForecastInvent, DateBudget)).value(SysQuery::range(reqPlanData.todaysdate(), SysQuery::valueUnlimited()));
            dsForecastInventDemand.addRange(fieldNum(ForecastInvent, TableType)).value(SysQuery::value(ForecastTableType::Demand));

            dsForecastModel = dsForecastInventDemand.addDataSource(tableNum(ForecastModel));
            dsForecastModel.joinMode(JoinMode::ExistsJoin);
            dsForecastModel.addLink(fieldNum(ForecastInvent, ModelId), fieldNum(ForecastModel, SubModelId));
            dsForecastModel.addRange(fieldNum(ForecastModel, ModelId)).value(SysQuery::value(reqPlanData.forecastModelId()));
            fillItemSetFromSubQuery(setItemForecastDemand, false);
        }

        if (reqPlanData.useForecastSupply())
        {
            initSubQuery();
            dsForecastInventSupply = dsInventTable.addDataSource(tableNum(ForecastInvent));
            dsForecastInventSupply.joinMode(JoinMode::ExistsJoin);
            dsForecastInventSupply.addLink(fieldNum(InventTable, ItemId), fieldNum(ForecastInvent, ItemId));
            dsForecastInventSupply.addRange(fieldNum(ForecastInvent, DateBudget)).value(SysQuery::range(reqPlanData.todaysdate(), SysQuery::valueUnlimited()));
            dsForecastInventSupply.addRange(fieldNum(ForecastInvent, TableType)).value(SysQuery::value(ForecastTableType::Supply));

            dsForecastModel = dsForecastInventSupply.addDataSource(tableNum(ForecastModel));
            dsForecastModel.joinMode(JoinMode::ExistsJoin);
            dsForecastModel.addLink(fieldNum(ForecastInvent, ModelId), fieldNum(ForecastModel, SubModelId));
            dsForecastModel.addRange(fieldNum(ForecastModel, ModelId)).value(SysQuery::value(reqPlanData.forecastModelId()));
            fillItemSetFromSubQuery(setItemForecastSupply, false);
        }
        if (isConfigurationkeyEnabled(configurationKeyNum(MCRContinuity)))
        {
            // Continuity master planning plugin
            //          Include any continuity lines yet to be created
            if (reqPlanData.mcrUseContinuityPlan())
            {
                initSubQuery();
                mcrDSContinuityCust = dsInventTable.addDataSource(tableNum(ReqTrans));
                mcrDSContinuityCust.joinMode(JoinMode::ExistsJoin);

                mcrDSContinuityCust.addLink(fieldNum(InventTable, ItemId), fieldNum(ReqTrans, ItemId));
                mcrDSContinuityCust.addRange(fieldNum(ReqTrans, PlanVersion)).value(SysQuery::value(reqPlanData.mcrPlanVersionContinuity()));
                mcrDSContinuityCust.addRange(fieldNum(ReqTrans, RefType)).value(SysQuery::value(ReqRefType::MCRContinuity));
                mcrDSContinuityCust.addRange(fieldNum(ReqTrans, RefId)).value(SysQuery::value(''));
                mcrDSContinuityCust.addRange(fieldNum(ReqTrans, InventTransOrigin)).value(SysQuery::value(0));

                fillItemSetFromSubQuery(mcrSetItemContinuity, false);
            }
        }

        if (ReqCalcPreUpdateReqProcessItemDetailsCleanupToggle::instance().isEnabled())
        {
            // clean the ReqProcessItemDetails table to avoid getting dublicate key exceptions when retrying the pre-update phase of MRP run.
            ReqProcessItemDetails::cleanUpProcess(processId);
        }

        this.insertReqProcessItemDetails(
            packedQuery,
            setItemOnhand,
            setItemReceipt,
            setItemIssue,
            setItemSafety,
            setItemForecastDemand,
            setItemForecastSupply,
            mcrSetItemContinuity,
            dsInventTable.id());

        if (this.itemFilterPreUpdateAllowed())
        {
            this.insertPreUpdateItemFilter(itemFilterMap);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertReqProcessItemDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and inserts the ReqProcessItemDetails.
    /// </summary>
    /// <param name = "_packedQuery">
    /// Main query for item selection
    /// </param>
    /// <param name = "_setItemOnhand">
    /// Set of items for which inventory onHand is used.
    /// </param>
    /// <param name = "_setItemReceipt">
    /// Set of items that has receipt transactions.
    /// </param>
    /// <param name = "_setItemIssue">
    /// Set of items that has issue transactions.
    /// </param>
    /// <param name = "_setItemSafety">
    /// Set of items with safety stock enabled.
    /// </param>
    /// <param name = "_setItemForecastDemand">
    /// Set of items with forecast demand.
    /// </param>
    /// <param name = "_setItemForecastSupply">
    /// Set of items with forecast supply.
    /// </param>
    /// <param name = "_mcrSetItemContinuity">
    /// Set of items with continuity transactions.
    /// </param>
    /// <param name = "_dsInventTable">
    /// The id of the data source InventTable.
    /// </param>
    protected void insertReqProcessItemDetails(
        container _packedQuery, 
        Set _setItemOnhand,
        Set _setItemReceipt,
        Set _setItemIssue,
        Set _setItemSafety,
        Set _setItemForecastDemand,
        Set _setItemForecastSupply,
        Set _mcrSetItemContinuity,
        int _dsInventTableId)
    {
        InventTable inventTable;

        boolean loopOnhand;
        boolean loopReceipt;
        boolean loopIssue;
        boolean loopSafety;
        boolean loopForecastDemand;
        boolean loopForecastSupply;
        boolean mcrLoopContinuity;

        RecordInsertList recordInsertListReq = new RecordInsertList(tableNum(ReqProcessItemDetails));

        var queryRunRegen = new QueryRun(_packedQuery);
        while (queryRunRegen.next())
        {
            inventTable = queryRunRegen.getNo(_dsInventTableId);

            loopOnhand          = _setItemOnhand.in(inventTable.ItemId);
            loopReceipt         = _setItemReceipt.in(inventTable.ItemId);
            loopIssue           = _setItemIssue.in(inventTable.ItemId);
            loopSafety          = _setItemSafety.in(inventTable.ItemId);
            loopForecastDemand  = _setItemForecastDemand.in(inventTable.ItemId);
            loopForecastSupply  = _setItemForecastSupply.in(inventTable.ItemId);
            mcrLoopContinuity   = reqPlanData.mcrUseContinuityPlan()? _mcrSetItemContinuity.in(inventTable.ItemId) : false;

            recordInsertListReq.add(ReqCalcScheduleItemTable::createReqProcessItemDetails(
                processId, 
                inventTable, 
                loopOnhand, 
                loopReceipt, 
                loopIssue, 
                loopForecastDemand, 
                loopForecastSupply, 
                loopSafety, 
                mcrLoopContinuity));
        }

        recordInsertListReq.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPreUpdateItemFilter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Extracts an approximation of all the items that can create demand or contribute to the plan, and adds them to the <c>ReqProcessItem</c> table in order
    /// to help with prefiltered MRP run.
    /// </summary>
    /// <param name="_itemFilter">
    ///     The map containing the items and their levels.
    /// </param>
    protected void insertPreUpdateItemFilter(Map _itemFilter)
    {
        RecordInsertList reqProcessItemInsertList = new RecordInsertList(tableNum(ReqProcessItem));
        ReqProcessItem   reqProcessItem;
        InventTable      inventTable;
        if (_itemFilter)
        {
            select firstfast RecId from reqProcessItem where reqProcessItem.ProcessId == this.processId;

            if (!reqProcessItem)
            {
                reqProcessItem.skipAosValidation(true);
                reqProcessItem.skipDataMethods(true);
                reqProcessItem.skipDeleteActions(true);

                ttsbegin;
                var mapEnum = _itemFilter.getEnumerator();
                while (mapEnum.moveNext())
                {
                    reqProcessItem.ItemId = mapEnum.currentKey();
                    reqProcessItem.Level = mapEnum.currentValue();
                    reqProcessItem.ProcessId = this.processId;
                    reqProcessItemInsertList.add(reqProcessItem);
                }
                reqProcessItemInsertList.insertDatabase();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReqCalcScheduleItemTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <c>ReqCalcScheduleItemTable</c> class that will be used for a new
    ///    master planning run.
    /// </summary>
    /// <returns>
    ///    A new instance of the <c>ReqCalcScheduleItemTable</c> class.
    /// </returns>
    protected ReqCalcScheduleItemTable createReqCalcScheduleItemTable()
    {
        return ReqCalcScheduleItemTable::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    ///    in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogGroup     parametersGroup;
        Object          mainFormGroupOrig;

        dialog = super();

        //Save the original main form group so we can set it back later
        //This needs to be done because the dialog framework can't handle it automatically when showQueryValues is
        //set to true.
        mainFormGroupOrig = dialog.mainFormGroup();

        parametersGroup = dialog.addGroup("@SYS7764");

        dflReqPlanId            = dialog.addFieldValue(extendedTypeStr(ReqPlanIdSched), reqPlanId);
        parametersGroup.addFieldname(dflReqPlanId.name());

        dflReqCalcUpdate        = dialog.addFieldValue(enumStr(ReqCalcUpdate), reqCalcUpdate);
        parametersGroup.addFieldname(dflReqCalcUpdate.name());

        dflIsTaskTraceEnabled   = dialog.addFieldValue(enumStr(NoYes), isTaskTraceEnabled, "@SYS107551", "@SYS107552");
        parametersGroup.addFieldname(dflIsTaskTraceEnabled.name());

        dflmaxChildThreads      = dialog.addFieldValue(extendedTypeStr(ReqProcessNumThreads), maxChildThreads, "@SYS109551", "@SCMPlanning:ReqCalcScheduleThreadsHelpText");
        dflComment              = dialog.addFieldValue(extendedTypeStr(ReqComment), comment);

        dialog.allowUpdateOnSelectCtrl(true);
        this.dialogSelectCtrl();

        dialog.mainFormGroup(mainFormGroupOrig);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogSelectCtrl</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Selects a control when you use the dialog class for dialog.
    /// </summary>
    /// <remarks>
    ///    To enable this callback, the <c>allowUpdateOnSelectCtrl</c> method must have been set to true.
    /// </remarks>
    public void dialogSelectCtrl()
    {
        super();

        if (dflReqPlanId.value() != ReqPlanSched::defaultDynamicId())
        {
            dflReqCalcUpdate.value(ReqCalcUpdate::Regeneration);
            dflReqCalcUpdate.allowEdit(false);
        }
        else
        {
            dflReqCalcUpdate.allowEdit(true);
        }

        if (dflReqCalcUpdate.value() == ReqCalcUpdate::NetChangeMinimized)
        {
            dflmaxChildThreads.value(0);
            dflmaxChildThreads.enabled(false);

            dflIsTaskTraceEnabled.value(false);
            dflIsTaskTraceEnabled.enabled(false);
        }
        else
        {
            dflmaxChildThreads.enabled(true);
            dflIsTaskTraceEnabled.enabled(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        reqPlanId           = dflReqPlanId.value();

        reqCalcUpdate       = dflReqCalcUpdate.value();

        maxChildThreads     = dflmaxChildThreads.value();

        isTaskTraceEnabled  = dflIsTaskTraceEnabled.value();

        comment             = dflComment.value();

        this.setUpdateAllItemsFlag();

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasUpdatedDynamicPlan</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the dynamic plan has been updated.
    /// </summary>
    /// <returns>
    /// true if the dynamic plan has been updated; otherwise, false.
    /// </returns>
    public boolean hasUpdatedDynamicPlan()
    {
        return (autoUpdateDynamicPlan || this.dynamicReqPlanId() == reqPlanId || reqParameters.autoUpdateDynamicPlan(reqPlanId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCopyToDynamicPlan</Name>
				<Source><![CDATA[
    private boolean mustCopyToDynamicPlan()
    {
        return (this.isCompleteUpdate() && reqParameters.autoUpdateDynamicPlan(reqPlanId)) ||
                (autoUpdateDynamicPlan && reqPlanId != this.dynamicReqPlanId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCopyToStaticPlan</Name>
				<Source><![CDATA[
    private boolean mustCopyToStaticPlan()
    {
        return (autoUpdateStaticPlan
            &&  reqPlanId != this.staticReqPlanId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePlanVersions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the source and target master plan versions that are used by the current scheduling run.
    /// </summary>
    public void initializePlanVersions()
    {
        ReqPlan reqPlan;

        if (this.isOriginalMainThread())
        {
            if (this.isCompleteUpdate()) 
            {
                reqPlan = ReqPlan::findReqPlanId(reqPlanId);

                sourcePlanVersion = reqPlan.getActiveVersion();

                if (!isNativelyResumed)
                {
                    targetPlanVersion = reqPlan.createNewInactiveVersion();
                }
            }
            else
            {
                super();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Limits the items to be processed by coverage before calling super.
    /// </summary>
    protected void preCoverage()
    {
        if (this.itemFilterPreCoverageAllowed())
        {
            this.filterProcessItemTable();
        }
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>filterProcessItemTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Filters out the items from the <c>ReqProcessItem</c> table, so that the following states of MRP like coverage, futures
    /// etc. do not have to create tasks for all the items but rather only the ones which have demand.
    /// </summary>
    protected void filterProcessItemTable()
    {
        ReqProcessItem reqProcessItem;
        ReqTrans       reqTrans;

        // Doing a count of the items so far before filtering, thus the item number logged for the user is correct.
        select count(RecId) from reqProcessItem where reqProcessItem.ProcessId == processId;
        reqPlanData.parmNumberOfItemsProcessed(int642int(reqProcessItem.RecId));

        reqProcessItem.skipAosValidation(true);
        reqProcessItem.skipDataMethods(true);
        reqProcessItem.skipDeleteActions(true);

        delete_from reqProcessItem
              where reqProcessItem.ProcessId == processId
          notexists join reqTrans
              where reqProcessItem.ItemId == reqTrans.ItemId
                 && reqTrans.PlanVersion == this.reqPlanVersionRefRecId()
                 && reqTrans.ReqProcessId == processId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertOnhandReqTransIfNotInserted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert <c>ReqTrans</c> records for onhand inventory if not previously have been inserted.
    /// </summary>
    /// <param name = "_itemId">The item to insert data for.</param>
    protected void insertOnhandReqTransIfNotInserted(ItemId _itemId)
    {
        if (this.itemFilterPreUpdateAllowed()
            && reqPlanData.useInventOnHands())
        {
            ReqTrans reqTrans;
            select firstfast RecId from reqTrans
                where reqTrans.ItemId == _itemId
                   && reqTrans.RefType == ReqRefType::InventOnHand
                   && reqTrans.PlanVersion == this.targetPlanVersion.RecId
                   && reqTrans.ReqProcessId == this.processId;

            if (!reqTrans.RecId)
            {
                this.insertItemInventSum(reqPlanData.newReqSetup(_itemId), true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCalcItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs coverage calculation for one item list.
    /// </summary>
    /// <param name="_level">
    /// Level to process the list on.
    /// </param>
    /// <param name="_itemId">
    /// The item ID to process.
    /// </param>
    protected void covCalcItem(BOMLevel _level, ItemId _itemId)
    {
        this.insertOnhandReqTransIfNotInserted(_itemId);
        super(_level, _itemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates ReqProcessItemDetails table and updates the requirement profile for the current MRP run.
    /// </summary>
    protected void updateData()
    {
        this.initializeReqItemDetails();

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts item data into the <c>reqTrans</c> table, depending on how master scheduling was started.
    /// </summary>
    /// <remarks>
    ///    If the class is running as the main thread, the lists for distributing items among the helpers are
    ///    also created.
    /// </remarks>
    protected void insertData()
    {
        if (this.itemFilterPreUpdateAllowed())
        {
            mapRegen = this.createLoopMapFromQuery();
        }
        else
        {
            reqTransCache.insertProcessItemsFromQuery(query.pack());
        }

        if (reqCalcUpdate == ReqCalcUpdate::Regeneration)
        {
            this.insertDataRegeneration();
        }
        else
        {
            if (updateAllItems && maxChildThreads == 0)
            {
                this.insertDataCompleteNetChange();
            }
            else
            {
                this.insertDataQueryNetChange();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectItemIdSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves item number set from the <c>InventSumLogTTS</c> table.
    /// </summary>
    /// <returns>
    /// Item number set from the <c>InventSumLogTTS</c> table.
    /// </returns>
    protected Set collectItemIdSet()
    {
        InventSumLogTTS inventSumLogItemId;
        Set             itemIdSet;

        itemIdSet = new Set(Types::String);

        while select ItemId
        from inventSumLogItemId
        group by ItemId
        where inventSumLogItemId.SoftDeleted == this.parmUpdateSoftDeletedOnly()
        {
            itemIdSet.add(inventSumLogItemId.ItemId);
        }

        return itemIdSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDataCompleteNetChange</Name>
				<Source><![CDATA[
    protected void insertDataCompleteNetChange()
    {
        ReqTransUpdate  reqTransUpdate;
        Set             itemIdSet = this.collectItemIdSet();
        SetEnumerator   se = itemIdSet.getEnumerator();

        while (se.moveNext())
        {
            reqTransUpdate = ReqTransUpdate::newReqCalcItemId(se.current(), reqPlanData);
            reqTransUpdate.parmUpdateSoftDeletedOnly(this.parmUpdateSoftDeletedOnly());
            reqTransUpdate.run();

            numOfChanges += reqTransUpdate.numOfChanges();
            if (updateSoftDeletedOnly)
            {
                this.addItem2ReqTransCache(se.current(), reqCalcUpdate == ReqCalcUpdate::NetChangeMinimized, reqCalcUpdate == ReqCalcUpdate::NetChange);
            }
        }

        if (!updateSoftDeletedOnly)
        {
            try
            {
                ttsbegin;
                this.add2ReqTransCache(reqCalcUpdate == ReqCalcUpdate::NetChangeMinimized, reqCalcUpdate == ReqCalcUpdate::NetChange);
                ttscommit;
            }
            catch (Exception::Deadlock)
            {
                if (this.manageExceptionDeadLock())
                {
                    retry;
                }
            }
            catch (Exception::TransientSqlConnectionError)
            {
                if (this.retryTransientSqlConnectionError())
                {
                    retry;
                }
                else
                {
                    throw;
                }
            }
            catch (Exception::UpdateConflict)
            {
                if ( this.manageExceptionUpdateConflict() )
                {
                    retry;
                }
            }
            catch (Exception::DuplicateKeyException)
            {
                if (this.manageDuplicateKeyException())
                {
                    retry;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDataItem</Name>
				<Source><![CDATA[
    protected void insertDataItem(BOMLevel _level, ItemId _itemId)
    {
        super(_level, _itemId);

        mustDeleteInventSumLogTTS = reqParameters.mustDeleteInventSumLogTTS(reqPlanId, this.isCompleteUpdate());

        // Get a map containing values for loopOnhand, loopReceipt, loopIssue, loopForecastSales, loopForecastPurch, loopSafety
        // for all items in the query
        if (!mapRegen && reqCalcUpdate == ReqCalcUpdate::Regeneration)
        {
            mapRegen = this.createLoopMapFromQuery();
        }
      
        if (reqCalcUpdate == ReqCalcUpdate::Regeneration)
        {
            this.insertDataItemRegeneration(_level, _itemId);
        }
        else
        {
            this.insertDataItemQueryNetChange(_level, _itemId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDataItemQueryNetChange</Name>
				<Source><![CDATA[
    [SuppressBpWarning("BPParameterNotUsed", "Parameter _level is used by deriving classes that overrides this method.")]
    protected void insertDataItemQueryNetChange(BOMLevel _level, ItemId _itemId)
    {
        ReqSetup    setup;

        setup = reqPlanData.newReqSetup(_itemId);

        if (setup.mustItemReqBeCreated())
        {
            this.updateReqTransUpdate(_itemId);

            try
            {
                ttsbegin;
                this.addItem2ReqTransCache(_itemId, reqCalcUpdate == ReqCalcUpdate::NetChangeMinimized, reqCalcUpdate == ReqCalcUpdate::NetChange);
                ttscommit;
            }
            catch (Exception::Deadlock)
            {
                if (this.manageExceptionDeadLock())
                {
                    retry;
                }
            }
            catch (Exception::TransientSqlConnectionError)
            {
                if (this.retryTransientSqlConnectionError())
                {
                    retry;
                }
                else
                {
                    throw;
                }
            }
            catch (Exception::UpdateConflict)
            {
                if ( this.manageExceptionUpdateConflict() )
                {
                    retry;
                }
            }
            catch (Exception::DuplicateKeyException)
            {
                if (this.manageDuplicateKeyException())
                {
                    retry;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldInsertItemPlanRegenerationData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if regeneration data should be processed for an item.
    /// </summary>
    /// <param name = "_itemId">Item Id</param>
    /// <returns>True if item regeneration data needs to be processed.</returns>
    protected boolean shouldInsertItemPlanRegenerationData(ItemId _itemId)
    {
        boolean         loopOnhand;
        boolean         loopReceipt;
        boolean         loopIssue;
        boolean         loopSafety;
        boolean         loopForecastSales;
        boolean         loopForecastPurch;
        boolean         loopContinuity;

        if (reqPlanData.mcrUseContinuityPlan())
        {
            [loopOnhand, loopReceipt, loopIssue, loopForecastSales, loopForecastPurch, loopSafety, loopContinuity] = mapRegen.lookup(_itemId);
        }
        else
        {
            [loopOnhand, loopReceipt, loopIssue, loopForecastSales, loopForecastPurch, loopSafety] = mapRegen.lookup(_itemId);
        }

        return (loopOnhand || loopReceipt || loopIssue || loopForecastSales || loopForecastPurch || loopSafety || loopContinuity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertItemPlanRegenerationData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts regeneration data for an item.
    /// </summary>
    /// <param name = "_setup">Regeneration setup.</param>
    /// <param name = "_itemId">ItemId</param>
    protected void insertItemPlanRegenerationData(ReqSetup _setup, ItemId _itemId)
    {
        boolean         loopOnhand;
        boolean         loopReceipt;
        boolean         loopIssue;
        boolean         loopSafety;
        boolean         loopForecastSales;
        boolean         loopForecastPurch;
        boolean         loopContinuity;

        if (reqPlanData.mcrUseContinuityPlan())
        {
            [loopOnhand, loopReceipt, loopIssue, loopForecastSales, loopForecastPurch, loopSafety, loopContinuity] = mapRegen.lookup(_itemId);
        }
        else
        {
            [loopOnhand, loopReceipt, loopIssue, loopForecastSales, loopForecastPurch, loopSafety] = mapRegen.lookup(_itemId);
        }

        if (loopOnhand)
        {
            this.insertItemInventSum(_setup, true);
        }

        if (loopReceipt || loopIssue)
        {
            this.insertItemInventTrans(_setup, '', loopIssue, loopReceipt);
        }

        if (loopSafety)
        {
            this.insertItemSafetyInvent(_setup);
        }

        if (loopForecastSales)
        {
            this.insertItemForecastDemand(_setup);
        }

        if (loopForecastPurch)
        {
            this.insertItemForecastSupply(_setup);
        }
        if (loopContinuity)
        {
            this.mcrInsertItemContinuitySales(_setup);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDataItemRegeneration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts regeneration data for one item.
    /// </summary>
    /// <param name="_level">
    /// The BOM level.
    /// </param>
    /// <param name="_itemId">
    /// The item ID.
    /// </param>
    [SuppressBpWarning("BPParameterNotUsed", "Parameter _level is used by deriving classes that overrides this method.")]
    protected void insertDataItemRegeneration(BOMLevel _level, ItemId _itemId)
    {
        ReqSetup setup;
        utcdatetime utcItemProcessingStarted = DateTimeUtil::utcNow();

        if (mapRegen.exists(_itemId))
        {
            if (!updateAllItems)
            {
                setup = reqPlanData.newReqSetup(_itemId);

                this.insertApprovedPo(_itemId);

                try
                {
                    ttsbegin;
                    this.deleteItemRequirement(setup);
                    ttscommit;
                }
                catch (Exception::Deadlock)
                {
                    if (this.manageExceptionDeadLock())
                    {
                        retry;
                    }
                }
                catch (Exception::TransientSqlConnectionError)
                {
                    if (this.retryTransientSqlConnectionError())
                    {
                        retry;
                    }
                    else
                    {
                        throw;
                    }
                }
                catch (Exception::UpdateConflict)
                {
                    if ( this.manageExceptionUpdateConflict() )
                    {
                        retry;
                    }
                }

                this.addItem2ReqTransCache(_itemId, false);
            }

            if (this.shouldInsertItemPlanRegenerationData(_itemId))
            {
                if (updateAllItems)
                {
                    setup = reqPlanData.newReqSetup(_itemId);
                }

                try
                {
                    ttsbegin;
                    this.insertItemPlanRegenerationData(setup, _itemId);
                    ttscommit;
                }
                catch (Exception::Deadlock)
                {
                    if (this.manageExceptionDeadLock())
                    {
                        retry;
                    }
                }
                catch (Exception::TransientSqlConnectionError)
                {
                    if (this.retryTransientSqlConnectionError())
                    {
                        retry;
                    }
                    else
                    {
                        throw;
                    }
                }
                catch (Exception::UpdateConflict)
                {
                    if ( this.manageExceptionUpdateConflict() )
                    {
                        retry;
                    }
                }
            }

            try
            {
                ttsbegin;
                this.applyKeptCoverage(setup);
                ttscommit;
            }
            catch (Exception::Deadlock)
            {
                if (this.manageExceptionDeadLock())
                {
                    retry;
                }
            }
            catch (Exception::TransientSqlConnectionError)
            {
                if (this.retryTransientSqlConnectionError())
                {
                    retry;
                }
                else
                {
                    throw;
                }
            }
            catch (Exception::UpdateConflict)
            {
                if ( this.manageExceptionUpdateConflict() )
                {
                    retry;
                }
            }
        }

        if (mustDeleteInventSumLogTTS)
        {
            ttsbegin;
            InventSumLogTTS::deleteItemId(_itemId, utcItemProcessingStarted);
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDataQueryNetChange</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates tasks for inserting data for a net change query for all item lists.
    /// </summary>
    protected void insertDataQueryNetChange()
    {
        this.insertTasksForAllItems(ReqProcessStatus::Update, ReqLevelState::NotApplicable, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDataRegeneration</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts data into the <c>reqTrans</c> table for all items included in the query.
    /// </summary>
    protected void insertDataRegeneration()
    {
        if (updateAllItems)
        {
            this.bulkDeleteAndUpdateCache();
        }

        this.insertTasksForAllItems(ReqProcessStatus::Update, ReqLevelState::NotApplicable, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertReqLog</Name>
				<Source><![CDATA[
    protected void insertReqLog(boolean _cancelled)
    {
        if (!hasErrors && !_cancelled)
        {
            isFitForPlanningOptimization = isFitForPlanningOptimization || this.canUsePlanningOptimization();
            if (!this.parmInterCompanyCalc() && clearLog && !isFitForPlanningOptimization)
            {               
                info("@SYS28664");
            }
        }
        else if (_cancelled)
        {
            info("@SCM:MasterPlanningWasCanceled");
            warning("@SCM:ReqItemCoveragePartiallyUpdated");
        }
        else
        {
            warning("@SCM:ReqItemCoveragePartiallyUpdated");
        }

        super(_cancelled);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCompleteUpdate</Name>
				<Source><![CDATA[
    boolean isCompleteUpdate()
    {
        return updateAllItems && reqCalcUpdate == ReqCalcUpdate::Regeneration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReqTransUpdated</Name>
				<Source><![CDATA[
    protected boolean isReqTransUpdated(ItemId _itemId)
    {
        if (updateAllItems && maxChildThreads == 0)
        {
            return true;
        }

        return super(_itemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lockDynamicReqPlan</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Locks the default dynamic master plan if current scheduling process is regenerative
    ///     and affects the default dynamic master plan.
    /// </summary>
    protected void lockDynamicReqPlan()
    {
        // Allow only the main thread to perform this operation.
        if (thisIsChildThread)
        {
            return;
        }

        if (reqParameters.mustLockDynamicPlan(reqPlanId, this.isCompleteUpdate()))
        {
            WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::Private, 'Locking dynamic plan');

            activePlanVersionOfDynamicPlan = this.parmReqPlanManager().acquireUpdateLockOnActivePlanVersion(this.dynamicReqPlanId());

            isDynamicReqPlanLocked = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ensureStillHasPlanLocks</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Ensures that plan locks that were taken are still acquired.
    /// </summary>
    internal void ensureStillHasPlanLocks()
    {
        if (!automaticallyReacquireLocks || giveUpOnReacquiringTheLock)
        {
            return;
        }

        // Allow only the main thread to perform this operation as the main threads is managing the locks.
        if (thisIsChildThread)
        {
            return;
        }

        var logLineTry = infologLine();
        try
        {
            super();

            // Target plan version is diffrent than source version in case of complete update.
            if (this.isCompleteUpdate())
            {
                this.parmReqPlanManager().ensureStillHasUpdateLockOnPlanVersion(targetPlanVersion);
            }
        }
        catch
        {
            giveUpOnReacquiringTheLock = true;

            if (failFastOnLostLockToggleEnabled)
            {
                error("@SCMPlanning:ReqCalcScheduleItemTableLockLostMRPFailed");
                throw;
            }

            infolog.clear(logLineTry);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUseCacheDuringUpdate</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected boolean mustUseCacheDuringUpdate()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        query = this.buildBaseQuery();
        this.setUpdateAllItemsFlag();

        planningOptimizationExceptionToggleIsEnabled = ReqPlanningOptimizationExceptionToggle::isReqPlanningOptimizationExceptionToggleEnabled();
        automaticallyReacquireLocks = ReqCalcScheduleItemTableLockReacquiringToggle::instance().isEnabled();
        failFastOnLostLockToggleEnabled = ReqCalcScheduleItemTableFailFastOnLostLockToggle::instance().isEnabled();
        reqCalcInstanceIsRestartable = true;
        nativeRestartResumeIsEnabled = ReqCalcRestartResumeNativeToggle::isEnabled(); 
        resumeHelperThreadsIsEnabled = ReqCalcResumeHelperThreadsFlight::instance().isEnabled();
        reqCalcEndHelperThreadsWhenMainNotProcessingFlightEnabled = ReqCalcEndHelperThreadsWhenMainNotProcessingFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveTransientSqlErrorMaxRetryCount</Name>
				<Source><![CDATA[
    private static int resolveTransientSqlErrorMaxRetryCount()
    {
        int retryCount = 5;

        if (ReqCalcTransientSqlErrorTwentyRetriesToggle::instance().isEnabled())
        {
            // setting maximum number of retries to 20 that allows to handle 17 minute of outage.
            retryCount = 20;
        }
        else if (ReqCalcTransientSqlErrorFifteenRetriesToggle::instance().isEnabled())
        {
            // setting maximum number of retries to 15 that allows to handle 12 minute of outage.
            retryCount = 15;
        }
        else if (ReqCalcTransientSqlErrorTenRetriesToggle::instance().isEnabled())
        {
            // setting maximum number of retries to 10 that allows to handle 7 minute of outage.
            retryCount = 10;
        }

        return retryCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initiateInstrumentationContext</Name>
				<Source><![CDATA[
    protected SysInstrumentationActivityContext initiateInstrumentationContext()
    {
        return this.reqInstrumentationLogger().calc().runMain();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqInstrumentationLoggerClassName</Name>
				<Source><![CDATA[
    protected ClassName reqInstrumentationLoggerClassName()
    {
        return classStr(ReqCalcScheduleItemTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildBaseQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the base query used to find items to schedule.
    /// </summary>
    /// <returns>The base query used to find items to schedule</returns>
    protected QueryRun buildBaseQuery()
    {
        return new QueryRun(queryStr(ReqCalcScheduleItemTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, super(), query.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>packThreadData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Serializes per thread data for the <c>ReqCalcScheduleItemTable</c> class.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>container</c> class.
    /// </returns>
    public container packThreadData()
    {
        return [
            #ReqCalcScheduleItemTableCurrentThreadVersion,
        super(),
            #ReqCalcScheduleItemTableCurrentThreadList,
        packedOriginalQuery
        ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAutoUpdateDynamicPlan</Name>
				<Source><![CDATA[
    public boolean parmAutoUpdateDynamicPlan(boolean _autoUpdateDynamicPlan = autoUpdateDynamicPlan)
    {
        autoUpdateDynamicPlan = _autoUpdateDynamicPlan;
        return autoUpdateDynamicPlan;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAutoUpdateStaticPlan</Name>
				<Source><![CDATA[
    public boolean parmAutoUpdateStaticPlan(boolean _autoUpdateStaticPlan = autoUpdateStaticPlan)
    {
        autoUpdateStaticPlan = _autoUpdateStaticPlan;
        return autoUpdateStaticPlan;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateSoftDeletedOnly</Name>
				<Source><![CDATA[
    public boolean parmUpdateSoftDeletedOnly(boolean _updateSoftDeletedOnly = updateSoftDeletedOnly)
    {
        updateSoftDeletedOnly = _updateSoftDeletedOnly;
        return updateSoftDeletedOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqCalcInstanceIsRestartable</Name>
				<Source><![CDATA[
    internal boolean parmReqCalcInstanceIsRestartable(boolean _reqCalcInstanceIsRestartable)
    {
        reqCalcInstanceIsRestartable = _reqCalcInstanceIsRestartable;
        return reqCalcInstanceIsRestartable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>planVersionSwitched</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The event which is fired when the active version of the master plan is switched.
    /// </summary>
    /// <param name="_fromVersion">
    ///     The deactivated master plan version.
    /// </param>
    /// <param name="_toVersion">
    ///     The activated master plan version.
    /// </param>
    delegate void planVersionSwitched(ReqPlanVersion _fromVersion, ReqPlanVersion _toVersion)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>propagateDependencies</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the <c>ReqPlanCopy</c> class with the instances of <c>ReqPlanManager</c> and <c>ReqBackgroundJobService</c> classes.
    /// </summary>
    protected void propagateDependencies()
    {
        this.reqPlanCopy().setReqPlanManager(this.parmReqPlanManager());

        if (isFlightEnabled(ReqFlighting::ReqDisableUseNewBatchJobForCopyPlan))
        {
            this.reqPlanCopy().setReqBackgroundJobService(this.backgroundJobService());
        }
        else
        {
            // keeping method call below for compatiblity.
            this.reqPlanCopy().setReqBackgroundJobService(ReqBackgroundJobService::newBatchHeader());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    ///    The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    ///    This method is used if a query prompt is the dialog and if a select menu item is added to a dialog.
    ///    Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it in the
    ///    <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    public QueryRun queryRun()
    {
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqPlanCopy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Exposes an instance of the <c>ReqPlanCopy</c> class.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>ReqPlanCopy</c> class.
    /// </returns>
    public ReqPlanCopy reqPlanCopy()
    {
        if (!reqPlanCopy)
        {
            reqPlanCopy = ReqPlanCopy::construct();

            reqPlanCopy.parmSkipCopyLog(ReqCalcCopyReqLogAsPostActionToggle::instance().isEnabled());

            if (this.isInBatch())
            {
                if (reqBatchTasksSchedulingFixToggleEnabled)
                {
                    reqPlanCopy.parmCurrentBatch(this.parmCurrentBatch());
                    reqPlanCopy.parmInBatch(true);
                }
                else if (this.batchInfo().parmGroupId())
                {
                    reqPlanCopy.parmGroupId(this.batchInfo().parmGroupId());
                }
            }
        }
        
        return reqPlanCopy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleRunError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles error situations that occured during reqCalc.Run method.
    /// In case the thread is a helper thread it will release the tasks that is currently in progress so other helpers can pick it up.
    /// In case it is the main thread it will delete all bundles, tasks and ReqProcessList related records.
    /// </summary>
    protected void handleRunError()
    {
        this.cleanUp();
        
        var logLineTry = infologLine();
        try
        {
            this.unlockDynamicReqPlan();
        }
        catch
        {
            if (!ReqCalcScheduleItemTableHandleErrorIgnoreLockErrorsToggle::instance().isEnabled() 
              || this.parmDoNotDisposeReqPlanManager())
            {
                throw;
            }

            // Ignoring all errors as this is only called when a run already failed
            // and even if this throws rest of the cleanup still should be performed.
            // This can happen, for example, if the run failed because of losing a lock.
            // When disposing ReqPlanManager all of the connections used by ReqReaderWriterLock will be still finalized.

            // Removing the information about exceptions from infolog.
            // These errors will not be helpful to a user.
            infolog.clear(logLineTry);
        }

        if (reqTransCache)
        {
            reqTransCache.endProcess();
        }

        if (!isReqLogMerged)
        {
            hasErrors = true;
            this.insertReqLog(true);
        }

        if (!thisIsChildThread)
        {
            ReqProcessList::setStatus(processId, ReqProcessStatus::Error);
        }

        if (!completedEventWasInvoked)
        {
            this.invokeCompletedEvent();
        }

        throw Exception::Error;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPreRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes internal variables that must be set before the main run method is executed.
    /// </summary>
    protected void initPreRun()
    {
        if (reqCalcUpdate == ReqCalcUpdate::NetChangeMinimized)
        {
            thisIsPeriodicProcess = false;
            // NetChangeMinimized is a single threaded process which, when run from the UI, should not be run in batch. It should not be attempting restart - resume.
            reqCalcInstanceIsRestartable = false;
        }
        else
        {
            thisIsPeriodicProcess = true;
        }

        this.setUpdateAllItemsFlag();

        packedOriginalQuery = query.pack();

        this.prepareQueryRun();

        if (!BatchHeader::isExecutingInBatch())
        {
            this.progressInitSeries();
            if (progress)
            {
                progress.update(true);
            }
        }
        else
        {
            progress = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>performReqCalcRestartResume</Name>
				<Source><![CDATA[
    private void performReqCalcRestartResume(Batch _currentBatchTask)
    {
        using (var activity = this.reqInstrumentationLogger().calc().restartResume())
        {
            this.reqInstrumentationLogger().logRestartResumeInformation(_currentBatchTask.retryCount);

            reqCalcRestartResume = ReqCalcRestartResumeNative::construct(
                processId,
                reqCalcUpdate,
                _currentBatchTask,
                this.reqInstrumentationLogger());
        
            if (this.thisIsChildThread)
            {
                isNativelyResumed = reqCalcRestartResume.resumeChildThread();
                return;
            }
        
            reqCalcRestartResume.recoverReqProcessList();

            this.getThreadDataFromRecoveredReqProcessList();

            if (!reqCalcRestartResume.restartResumeMainThread())
            {
                this.failProcessAndCleanUpOnUnsuccessfulRestartResume();
            }

            isNativelyResumed = reqCalcRestartResume.getIsResumed();
                    
            if (isNativelyResumed)
            {
                processId = reqCalcRestartResume.getRecoveredProcessId();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getThreadDataFromRecoveredReqProcessList</Name>
				<Source><![CDATA[
    private void getThreadDataFromRecoveredReqProcessList()
    {
        container params = reqCalcRestartResume.getReqProcessListParameters();
        if (params != conNull())
        {
            this.unpackThreadData(params);
            this.reqInstrumentationLogger().logInformation('Unpacked thread data from recovered reqProcessList parameters.');
        }
        else
        {
            this.reqInstrumentationLogger().logInformation('Unable to unpack thread data. Parameters from recovered reqProcessList are empty.');
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        wrkCtrSchedulerRuntimes.startMeasurement(#TotalRuntimeXpp);
        
        this.initPreRun();

        try
        {
            if (BatchHeader::isExecutingInBatch())
            {
                ReqTransientSqlConnectionErrorHandlingHelper::setDefaultMaxRetryOfTransientSqlConnectionError(ReqCalcScheduleItemTable::resolveTransientSqlErrorMaxRetryCount());
                
                this.handlePossibleBatchRestart();
            }

            this.parmRecalculateBomLevels(reqCalcUpdate == ReqCalcUpdate::Regeneration);
            this.propagateDependencies();
            
            using (var scope = ReqTransRecIdPreallocationScope::construct())
            {
                super();
            }
            
            if (!nativeRestartResumeIsEnabled)
            {
                this.scheduleRestart();
            }
                
            if (isFitForPlanningOptimization)
            {
                this.reqInstrumentationLogger().logInformation('Failing Planning when eligible for Planning Optimization');
                error("@SCMPlanning:ReqCalcScheduleItemTablePlanningOptimizationFitError");      
            }
        }
        catch
        {
            this.handleRunError();
        }
        finally
        {
            this.dispose();
        }

        wrkCtrSchedulerRuntimes.endMeasurement(#TotalRuntimeXpp);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUsePlanningOptimization</Name>
				<Source><![CDATA[
    private boolean canUsePlanningOptimization()
    {  
        ReqLog reqLog = this.reqPlanData.reqLog();
       
        if (!Global::isOnPremEnvironment()
            && !hasErrors
            && reqLog.ReqCalcUpdate == ReqCalcUpdate::Regeneration
            && !this.parmThisIsChildThread()
            && !planningOptimizationExceptionToggleIsEnabled)
        {
            ReqLog pastReqLog;

            utcdatetime dateThreshold = DateTimeUtil::addDays(DateTimeUtil::utcNow(), -60);

            // We have to use crosscompany query because we can't use both optimization and classic MRP on the same partition.
            select firstonly crosscompany RecId from pastReqLog 
                where pastReqLog.EndDateTime > dateThreshold 
                   && pastReqLog.NumOfBOMPlannedOrder != 0;

            var currentNumOfPlannedProductionOrders = reqLog.NumOfBOMPlannedOrder;

            if (currentNumOfPlannedProductionOrders == 0 && !pastReqLog.RecId)
            {
                return true;
            }          
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleRestart</Name>
				<Source><![CDATA[
    private void scheduleRestart()
    {
        if (!this.parmThisIsChildThread() && infrastructureFailure)
        {
            currentBatch = this.parmCurrentBatch();

            Debug::assert(currentBatch.RecId != 0);

            if (currentBatch.retryCount < currentBatch.retriesOnFailure)
            {
                currentBatch.Status = BatchStatus::Waiting;
                currentBatch.retryCount++;
                currentBatch.RunTimeTask = true;
                currentBatch.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>failProcessAndCleanUpOnUnsuccessfulRestartResume</Name>
				<Source><![CDATA[
    private void failProcessAndCleanUpOnUnsuccessfulRestartResume()
    {
        processId = reqCalcRestartResume.getRecoveredProcessId();
        using (var activity = this.reqInstrumentationLogger().restartResume().failProcessAndCleanUp())
        {
            this.reqInstrumentationLogger().logProcessInformation(processId, currentBatchTask);

            ReqProcessList::setStatus(processId, ReqProcessStatus::Error);

            // We need to perform cleanup upon failure of restart/resume despite the fact that an error will be thrown and the
            // standard cleanup process of ReqCalc will be triggered as part of error handling so that: 
            // - We create an instance of reqTransCahce and perform the necessary cleanup of the temporary data of the process.
            // - We perform cleanup of reqCalcTask* tables.
            // Standard cleanup assumes that reqCalcTaskController and reqTransCache have been instantiated but since we are 
            // retrying the batch process, this is not the case.
            ReqCalcFailureRecovery::construct(processId).runOperation();
            cleanupPerformed = true;
            completedEventWasInvoked = true;

            this.reqInstrumentationLogger().logError("Master planning has failed to recover.");
            throw error("@SCMPlanning:ReqCalcResumeRetryCountExceeded");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handlePossibleBatchRestart</Name>
				<Source><![CDATA[
    private void handlePossibleBatchRestart()
    {
        if (!nativeRestartResumeIsEnabled || !reqCalcInstanceIsRestartable)
        {
            return;
        }

        this.reqInstrumentationLogger().logInformation('Checking if batch restart occured during previous execution.');

        currentBatchTask = BatchHeader::getCurrentBatchTask();
        if (currentBatchTask.retryCount > 0)
        {
            this.reqInstrumentationLogger().logInformation('Batch restart occured during previous execution. Attempting restart/resume.');
            this.performReqCalcRestartResume(currentBatchTask);
        }
        else
        {
            this.reqInstrumentationLogger().logInformation('No batch restart occured during previous execution.');

            // Recurring MRP batch jobs have the same batchTaskId for the main thread, hence multiple reqProcessList records 
            // can be linked to the specific batchTaskId. In order to enable restart/resume, we dissociate reqProcessList 
            // records of previous runs from their batchTaskIds if they have the batchTaskId of the current run.
            // This is done in the beginning of every new run.
            ReqCalcTaskController::reqProcessListClearBatchTask(currentBatchTask.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareQueryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepares The <c>QueryRun</c> object that is used in the <c>run</c> method.
    /// </summary>
    protected void prepareQueryRun()
    {
        query.query().dataSourceTable(tableNum(InventTable)).addRange(fieldNum(InventTable, ItemType)).value(InventItemType::valueMustBeReqCreated());
    }

]]></Source>
			</Method>
			<Method>
				<Name>runNetChangeMinimized</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs a net change to be minimized on all soft deleted records in the <c>InventSumLogTTS</c>
    ///    table.
    /// </summary>
    /// <param name="_clearLog">
    ///     A flag that indicates whether the infolog should be cleared.
    /// </param>
    [SuppressBPWarning('BPUpgradeCodeRunBaseRunCalled', 'The current stack frame is already inside the new session.')]
    protected void runNetChangeMinimized(boolean _clearLog = true)
    {
        ReqCalcScheduleItemTable reqCalcNetChangeMinimized;

        reqCalcNetChangeMinimized = this.createReqCalcScheduleItemTable();

        reqCalcNetChangeMinimized.parmReqPlanId(this.dynamicReqPlanId());
        reqCalcNetChangeMinimized.parmReqCalcUpdate(ReqCalcUpdate::NetChangeMinimized);
        reqCalcNetChangeMinimized.parmUpdateSoftDeletedOnly(true);
        reqCalcNetChangeMinimized.parmClearLog(_clearLog);
        reqCalcNetChangeMinimized.parmThrowCovItemValidationErrors(false);
        reqCalcNetChangeMinimized.parmReqPlanManager(this.parmReqPlanManager());
        reqCalcNetChangeMinimized.parmDoNotDisposeReqPlanManager(this.parmDoNotDisposeReqPlanManager());
        // When running NetChangeMinimized as part of Regeneration we do not want to attempt restarting or resuming of NetChangeMinimized reqCalcScheduleItemTable instance. 
        // This would lead to infinite looping since the run batch task will have retry count greater than 0 and the NetChangeMinimized run is under 
        // the Regeneration reqProcessList record. Instead, the main job will attempt to resume the Statistics phase - part of which is NetChangeMinimized.
        reqCalcNetChangeMinimized.parmReqCalcInstanceIsRestartable(false);
        // The current call stack is already inside runOperation, therefore it's safe to just call run.
        reqCalcNetChangeMinimized.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPostActions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the actions that are scheduled to run after the full regeneration.
    /// </summary>
    protected void runPostActions()
    {
        super();

        if (!thisIsChildThread)
        {
            if (ReqCalcCopyReqLogAsPostActionToggle::instance().isEnabled())
            {
                // Now that the ReqLog has been completely created it can be copied if needed 
                if (this.mustCopyToDynamicPlan())
                {
                    this.reqPlanCopy().copyLogForProcess(this.reqPlanId, this.processId, this.dynamicReqPlanId());
                }
                if (this.mustCopyToStaticPlan())
                {
                    this.reqPlanCopy().copyLogForProcess(this.reqPlanId, this.processId, this.staticReqPlanId());
                }
            }

            if (resumeHelperThreadsIsEnabled)
            {
                if (this.mustMarkFailedHelperThreadsAsNotRun())
                {
                    this.markFailedHelperThreadsAsNotRun();

                    warning("@SCMPlanning:ReqCalcHelperFailure");
                }
            }

            if (this.isCompleteUpdate() && this.hasUpdatedDynamicPlan())
            {
                this.runNetChangeMinimized(false);

                // Schedule a dynamic plan version cleanup job because the cleanup job that is part of the plan copy most probably
                // will not execute because the  plan lock will be held while executing the net change minimized.
                if (ReqDynamicPlanVersionCleanupAfterNetChangeMinimizedToggle::instance().isEnabled() && !this.parmInterCompanyCalc())
                {
                    var dynamicPlanActiveVersion = ReqPlan::findReqPlanId(this.dynamicReqPlanId()).findActiveVersion();

                    ReqBackgroundJobService reqBackgroundJobService = ReqBackgroundJobService::newBatchHeader();

                    reqBackgroundJobService.parmTriggeredBy(classStr(ReqCalcScheduleItemTable));
                    reqBackgroundJobService.batchHeader().parmCaption(strFmt("@SCMPlanning:MRPDynamicPlanVersionCleanupCaption", this.dynamicReqPlanId()));

                    if (this.isInBatch())
                    {
                        reqBackgroundJobService.parmGroupId(this.parmCurrentBatch().GroupId);
                    }

                    reqBackgroundJobService.addPlanVersionCleanupTask(dynamicPlanActiveVersion);
                    reqBackgroundJobService.addOrphanedPlanVersionCleanupTask();

                    reqBackgroundJobService.start();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReqBackgroundJobService</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets an instance of the <c>ReqBackgroundJobService</c> class.
    /// </summary>
    /// <param name="_backgroundJobService">
    ///    An instance of the <c>ReqBackgroundJobService</c> class.
    /// </param>
    public void setReqBackgroundJobService(ReqBackgroundJobService _backgroundJobService)
    {
        backgroundJobService = _backgroundJobService;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReqPlanCopy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets an instance of the <c>ReqPlanCopy</c> class.
    /// </summary>
    /// <param name="_reqPlanCopy">
    ///    An instance of the <c>ReqPlanCopy</c> class.
    /// </param>
    public void setReqPlanCopy(ReqPlanCopy _reqPlanCopy)
    {
        reqPlanCopy = _reqPlanCopy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUpdateAllItemsFlag</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the flag that indicates whether all items are updated.
    /// </summary>
    protected void setUpdateAllItemsFlag()
    {
        updateAllItems = this.shouldUpdateAllItems(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to add a select button to the dialog.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    /// <remarks>
    ///    If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    ///    return a valid <c>queryRun</c> class.If you change the return value to false, the button will no
    ///    longer be added.
    /// </remarks>
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTtsLevelValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether isTtsLevelValid or not.
    /// </summary>
    /// <returns>
    ///  Returns true if the transaction level and maximum child threads are valid for a master planning run.
    /// </returns>
    protected boolean isTtsLevelValid()
    {
        return (maxChildThreads == 0 || appl.ttsLevel() == 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ttsbegin</Name>
				<Source><![CDATA[
    protected void ttsbegin()
    {
        if (!this.isTtsLevelValid())
        {
            throw error("@SCM:ReqMasterPlanWithinTransactionError");
        }
        if (!thisIsChildThread)
        {
            //acquire locks before calling super() which will serialize (potentially running) parallel processes
            this.parmReqPlanManager().acquireUpdateLockOnPlanVersion(targetPlanVersion);
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ttscommit</Name>
				<Source><![CDATA[
    protected void ttscommit()
    {
        super();

        if (!thisIsChildThread)
        {
            if (this.isCompleteUpdate())
            {
                this.planVersionSwitched(sourcePlanVersion, targetPlanVersion);
            }

            this.parmReqPlanManager().releaseLockOnPlanVersion(targetPlanVersion);

            this.processBackgroundCleanupTasks();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unlockDynamicReqPlan</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Unlocks the default dynamic master plan if it has been locked.
    /// </summary>
    protected void unlockDynamicReqPlan()
    {
        if (isDynamicReqPlanLocked)
        {
            WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::Private, 'Unlocking dynamic plan');

            this.parmReqPlanManager().releaseLockOnPlanVersion(activePlanVersionOfDynamicPlan);

            isDynamicReqPlanLocked = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Integer         version        = conPeek(packedClass, 1);
        container       packedQuery;
        container       base;

        switch (version)
        {
            case #CurrentVersion:
                [version, base, packedQuery] = packedClass;
                super(base);
                if (packedQuery && conLen(packedQuery) == 1)
                {
                    query = new QueryRun(packedQuery);
                }
                break;
            default:
                return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackThreadData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deserializes per thread data for the <c>ReqCalcScheduleItemTable</c> class.
    /// </summary>
    /// <param name="_packedClass">
    ///    A <c>container</c> that holds the serialized state of the <c>ReqCalcScheduleItemTable</c> class.
    /// </param>
    /// <returns>
    ///    True if the container can be deserialized, false otherwise.
    /// </returns>
    public boolean unpackThreadData(container _packedClass)
    {
        Integer         version = conPeek(_packedClass, 1);
        container       base;
        container       packedQuery;
        boolean         result;

        switch (version)
        {
            case #ReqCalcScheduleItemTableCurrentThreadVersion:
                [version, base, #ReqCalcScheduleItemTableCurrentThreadList, packedQuery] = _packedClass;
                result = super(base);
                if (result && packedQuery && conLen(packedQuery) == 1)
                {
                    query = new QueryRun(packedQuery);
                }
                break;

            default:
                result = false;
                break;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqPlans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates master plans affected by the current scheduling process.
    /// </summary>
    /// <remarks>
    ///    If the current scheduling process is regenerative and updates all items, this method toggles the
    ///    current master plan version and deletes the inactive master plan version. Otherwise, this method
    ///    copies the static master plan into the dynamic master plan if it is specified in master planning
    ///    parameters.
    /// </remarks>
    protected void updateReqPlans()
    {
        if (this.isCompleteUpdate())
        {
            ReqPlan plan = ReqPlan::findReqPlanId(reqPlanId);

            // Redirect the system to the new version of the plan.
            // Note, this might already have happened in case this task is resumed after an MRP failure
            if (plan.getActiveVersion().RecId != targetPlanVersion.RecId)
            {
                plan.switchActiveVersionTo(targetPlanVersion);
            }
        }

        if (this.mustCopyToDynamicPlan())
        {
            this.reqPlanCopy().executePlanCopying(reqPlanId, this.dynamicReqPlanId(), false);
        }

        if (this.mustCopyToStaticPlan())
        {
            this.reqPlanCopy().executePlanCopying(reqPlanId, this.staticReqPlanId(), !this.parmInterCompanyCalc());
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processBackgroundCleanupTasks</Name>
				<Source><![CDATA[
    private void processBackgroundCleanupTasks()
    {
        if (reqCalcUpdate == ReqCalcUpdate::Regeneration)
        {
            ReqBackgroundJobService reqBackgroundJobService = this.backgroundJobService();

            reqBackgroundJobService.parmTriggeredBy(classStr(ReqCalcScheduleItemTable));
            reqBackgroundJobService.batchHeader().parmCaption(strFmt("@SCM:MRPBackgroundJobCaption", reqPlanId));
            reqBackgroundJobService.addNetRequirementsCleanupTask();

            if (reqBatchTasksSchedulingFixToggleEnabled && this.isInBatch())
            {
                reqBackgroundJobService.parmGroupId(this.parmCurrentBatch().GroupId);
            }
            
            if (!this.parmInterCompanyCalc() && this.isCompleteUpdate())
            {
                if (!reqBatchTasksSchedulingFixToggleEnabled && this.batchInfo() && this.batchInfo().parmGroupId())
                {
                    reqBackgroundJobService.parmGroupId(this.batchInfo().parmGroupId());
                }
                reqBackgroundJobService.addPlanVersionCleanupTask(sourcePlanVersion);
                reqBackgroundJobService.addOrphanedPlanVersionCleanupTask();
            }

            reqBackgroundJobService.start();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object calledFrom = null)
    {
        boolean isValidatingFromForm = calledFrom != null;

        if (!ReqCalc::validateMaxChildThreads(this, this.maxChildThreads))
        {
            return false;
        }

        if (!ReqPlanSched::find(this.parmReqPlanId()).RecId)
        {
            return checkFailed(strFmt("@SYS25368", this.parmReqPlanId()));
        }

        if (isValidatingFromForm
            && reqParameters.mustLockDynamicPlan(reqPlanId, this.isCompleteUpdate())
            && this.checkDefaultDynamicPlanLocked())
        {
            error("@SYS133361");
            return false;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDefaultDynamicPlanLocked</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether the the default dynamic plan is locked.
    /// </summary>
    /// <returns>true if the plan is locked; otherwise, false.</returns>
    protected boolean checkDefaultDynamicPlanLocked()
    {
        return ReqPlanManager::isDefaultDynamicReqPlanLocked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static ReqCalcScheduleItemTable construct()
    {
        return new ReqCalcScheduleItemTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS25297";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        ReqParameters::checkPlanningProcessesAreEnabled();

        ReqCalcScheduleItemTable reqCalcScheduleItemTable;
        reqCalcScheduleItemTable = ReqCalcScheduleItemTable::newStandard();

        ReqPlanId planId = ReqCalc::argsReqPlanId(_args);
        if (planId)
        {
            reqCalcScheduleItemTable.parmReqPlanId(planId);
        }

        if (!reqCalcScheduleItemTable.prompt())
        {
            return;
        }

        using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContextByFormAndAction(strFmt('%1_%2', formStr(Dialog), classStr(ReqCalcScheduleItemTable)), _args.menuItemName()))
        {
           reqCalcScheduleItemTable.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newStandard</Name>
				<Source><![CDATA[
    public static ReqCalcScheduleItemTable newStandard(
        ReqPlanCopy _reqPlanCopy = ReqPlanCopy::construct(),
        ReqBackgroundJobService _backgroundJobService = ReqBackgroundJobService::newBatchHeader(),
        ReqPlanManager _reqPlanManager = ReqPlanManager::construct())
    {
        ReqCalcScheduleItemTable reqCalcScheduleItemTable = ReqCalcScheduleItemTable::construct();

        reqCalcScheduleItemTable.getLast();
        reqCalcScheduleItemTable.parmAutoReserveCoverage(false);

        reqCalcScheduleItemTable.parmReqPlanManager(_reqPlanManager);
        reqCalcScheduleItemTable.setReqPlanCopy(_reqPlanCopy);
        reqCalcScheduleItemTable.setReqBackgroundJobService(_backgroundJobService);

        return reqCalcScheduleItemTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>manageDuplicateKeyException</Name>
				<Source><![CDATA[
    protected boolean manageDuplicateKeyException()
    {
        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::Error, 'DuplicateKey');
        if (appl.ttsLevel() == 0)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::DuplicateKeyExceptionNotRecovered;
            }
            else
            {
                return true;
            }
        }
        else
        {
            throw Exception::DuplicateKeyException;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunMultiThreaded</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected boolean canRunMultiThreaded()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchInfo</Name>
				<Source><![CDATA[
    public BatchInfo batchInfo()
    {
        BatchInfo info = super();
        if (nativeRestartResumeIsEnabled && reqCalcInstanceIsRestartable)
        {
            info.parmRetriesOnFailure(ReqCalcScheduleItemTable::ThreadRetriesOnFailure);
        }
        return info;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReqCalcRestartResumeDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if an instance of reqCalcRestartResumeNative was initialized.
    /// </summary>
    /// <returns>A <c>container</c> with [reqCalcRestartResumeNativeInstanceInitialized, restartCalled, resumeCalled] boolean values.</returns>
    internal container getReqCalcRestartResumeDetails()
    {
        if (reqCalcRestartResume)
        {
            var reqCalcRestartResumeNativeInstanceInitialized = true;
            return [reqCalcRestartResumeNativeInstanceInitialized,
                reqCalcRestartResume.getRestartCalled(), 
                reqCalcRestartResume.getResumeCalled()];
        }
        
        return [false, false, false];
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryRecoverMainThreadIfNotExecuting</Name>
				<Source><![CDATA[
    protected boolean tryRecoverMainThreadIfNotExecuting()
    {
        if (this.mustCheckMainThreadStuck() && this.isMainThreadStuck())
        {
            this.reqInstrumentationLogger().logInformation(strFmt(
                "Terminating the execution of the helper batch thread because the main thread is not executing. Thread Id: %1, Batch Task Id: %2",
                threadId,
                BatchHeader::getCurrentBatchTask().RecId));

            threadExitedDueToMainThreadNotExecuting = true;

            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckMainThreadStuck</Name>
				<Source><![CDATA[
    private boolean mustCheckMainThreadStuck()
    {
        const int minutesToWait = 5;

        return reqCalcEndHelperThreadsWhenMainNotProcessingFlightEnabled &&
               nativeRestartResumeIsEnabled &&
              !this.isOriginalMainThread() &&
              (mainThreadStuckCheckLastTime == utcDateTimeNull() ||
               DateTimeUtil::getDifference(DateTimeUtil::getSystemDateTime(), mainThreadStuckCheckLastTime) >= minutesToWait * #secondsPerMinute);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMainThreadStuck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the main thread is stuck by monitoring the batch task status.
    /// If the main thread is stuck for the first time, it updates the internal state.
    /// After a specified waiting time when the main thread is still stuck, it returns true,
    /// indicating that the current thread should be terminated.
    /// </summary>
    /// <returns>
    /// True if the main thread remains stuck for a certain duration; otherwise, false.
    /// </returns>
    private boolean isMainThreadStuck()
    {
        mainThreadStuckCheckLastTime = DateTimeUtil::getSystemDateTime();

        if (!this.isMainThreadExecuting())
        {
            if (isMainThreadStuck)
            {
                return true;
            }
            else
            {
                isMainThreadStuck = true;
            }
        }
        
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMainThreadExecuting</Name>
				<Source><![CDATA[
    private boolean isMainThreadExecuting()
    {
        Batch mainThread;

        mainThread.readCommittedLock(true);

        select firstOnly Status from mainThread
            order by mainThread.RecId desc
            where mainThread.BatchJobId == currentBatchTask.BatchJobId &&
                  mainThread.ClassNumber == classNum(ReqCalcScheduleItemTable) &&
                 !mainThread.RunTimeTask;

        return mainThread.Status == BatchStatus::Executing;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>