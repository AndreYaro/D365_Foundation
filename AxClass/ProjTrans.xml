<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjTrans</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>ProjTrans</c> class is the base class for all project transaction classes.
/// </summary>
/// <remarks>
/// This class provides some functionality of its own, provides default methods that return 0, empty,
/// or null. This class also defines abstract methods that must be implemented in subclasses.
/// </remarks>
abstract class ProjTrans
{
    // Member variable declarations
    ProjAdjustRefId projAdjustRefId;
    Common          buffer;
    Common          childBuffer;
    ProjTransStatus saleTransStatus;
    ProjTransStatus adjustmentStatus;
    ProjOrigin transactionOrigin;
    boolean useLedgerStatusCostOrig;
    AmountCur costAmount;
    private ProjItemType projItemType;
    protected boolean contractLineBasedRevRecFeature = ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled();
    private boolean defaultAccruedRevenueExchangeRateFromPostingDate;

    #ISOCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountOnAccountLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for invoiced revenue minus on account for this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for invoiced revenue minus on account.
    /// </returns>
    public LedgerDimensionDefaultAccount accountOnAccountLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        // <GBR>
        if (ProjParameters::find().EnableCancelPostingProfiles && this.amountMST() < 0)
        {
            return this.canceledRevenueAccountLedgerDimension(_fundingSourceID);
        }
        // </GBR>

        return ProjPosting::getLedgerDimension(ProjAccountType::OnAccountAccount,
                                            this.projId(),
                                            this.categoryId(),
                                            _fundingSourceID,
                                            true,
                                            true,
                                            this.taxGroup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>accruedCostLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accruedCostLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(
            ProjAccountType::AccruedCost,
            this.projId(),
            this.categoryId(),
            _fundingSourceID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>accruedRevenueOnAccountLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for accrue revenue minus on account for this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for accrue revenue minus on account.
    /// </returns>
    public LedgerDimensionDefaultAccount accruedRevenueOnAccountLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(
            ProjAccountType::AccruedRevenueOnAccount,
            this.projId(),
            this.categoryId(),
            _fundingSourceID,
            false,
            true,
            this.taxGroup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>accruedRevenueSubsLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for accrue revenue minus subscription for this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for accrue revenue minus subscription.
    /// </returns>
    public LedgerDimensionDefaultAccount accruedRevenueSubsLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(
            ProjAccountType::AccruedRevenueSubscription,
            this.projId(),
            this.categoryId(),
            _fundingSourceID,
            true,
            true,
            this.taxGroup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>accruedTurnoverProdLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for accrued revenue minus productionthat will be used by this
    /// transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for accrued revenue minus production.
    /// </returns>
    public LedgerDimensionDefaultAccount accruedTurnoverProdLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(ProjAccountType::AccruedTurnoverProd,
                                            this.projId(),
                                            this.categoryId(),
                                            _fundingSourceID,
                                            true,
                                            true,
                                            this.taxGroup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>accruedTurnoverProfitLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for accrued revenue minus profit that will be used by this
    /// transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for account revenue minus profit.
    /// </returns>
    public LedgerDimensionDefaultAccount accruedTurnoverProfitLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(ProjAccountType::AccruedTurnoverProfit,
                                            this.projId(),
                                            this.categoryId(),
                                            _fundingSourceID,
                                            true,
                                            true,
                                            this.taxGroup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>activityNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Default implementation for retrieving the ActivityNumber field for the underlying table buffer. Derived classes
    /// should override if the underlying table for the transaction record does not store the ActivityNumber in a field
    /// named 'ActivityNumber'
    /// </summary>
    /// <returns>The ActivityNumber field for the underlying transaction table buffer.</returns>
    public ProjActivityNumber activityNumber()
    {
        ProjActivityNumber activityNum;

        DictTable dt = new DictTable(this.buffer().TableId);
        if (dt.fieldName2Id('ActivityNumber'))
        {
            activityNum = this.buffer().getFieldValue('ActivityNumber');
        }
        
        return activityNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether a transaction can be adjusted.
    /// </summary>
    /// <returns>
    ///    true if the transaction can be adjusted; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    A transaction can only be adjusted if it has been posted.
    /// </remarks>
    public boolean adjustable()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountMST</Name>
				<Source><![CDATA[
    public AmountMST amountMST()
    {
        if (!this.invoiced())
        {
            return CurrencyExchangeHelper::amountCur2MST(this.transTurnover(), this.currencyIdSales(), this.exchRateSales());
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assessableValue_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the assessable value that is associated with this transaction.
    /// </summary>
    /// <returns>
    /// Always returns zero.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend the class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public AmountCur assessableValue_IN()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buffer</Name>
				<Source><![CDATA[
    Common buffer()
    {
        return buffer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeAccrued</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether revenue from this transaction can be accrued.
    /// </summary>
    /// <returns>
    ///    true if revenue from this transaction can be accrued; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This value is based on project line property and funding source type associated with this transaction.
    /// </remarks>
    public boolean canBeAccrued()
    {
        ProjFundingSource   projFundingSource;
        boolean             ret = false;

        if (ProjLineProperty::find(this.linePropertyId()).ToBeAccrued)
        {
            ret =  true;
        }

        if (ret == true)
        {
            projFundingSource = ProjFundingSource::find(this.fundingSource());
            if ((projFundingSource.FundingType == ProjFundingType::Organization) ||
                (projFundingSource.FundingType == ProjFundingType::OnHoldFundingSource))
            {
                ret =  false;
            }
        }

        if (ret)
        {
            // Only accrue revenue for invoiceable transactions
            ret = ProjInvoiceTable::isBillingRuleInvoiceable(this.projId(), this.categoryId(), this.psaContractLineNum(), this.transType());
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeCapitalize</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether costs from this transaction can be capitalized.
    /// </summary>
    /// <returns>
    ///    true if costs from this transaction can be capitalized; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This value is based on project line property of the project associated with this transaction.
    /// </remarks>
    public boolean canBeCapitalize()
    {
        if (!ProjLineProperty::find(this.linePropertyId()).ToBeCapitalize)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeInvoiced</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether this transaction can be invoiced.
    /// </summary>
    /// <param name="_chargeable">
    /// A Boolean value that determines whether invoice proposal transactions can be invoiced; optional.
    /// </param>
    /// <returns>
    /// true if this transaction can be invoiced; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If the project line property of the project that is associated with this transaction indicates that
    /// the project is not chargeable, it cannot be invoiced. Otherwise, the funding type is validated and
    /// the <c>ProjTrans.canTransStatusBeInvoiced</c> method is called to determine whether the transaction
    /// can be invoiced based on its status.
    /// </remarks>
    public boolean canBeInvoiced(boolean _chargeable = false)
    {
        ProjFundingSource   projFundingSource;
        boolean             ret = true;

        if (!ProjLineProperty::find(this.linePropertyId()).ToBeInvoiced)
        {
            ret = false;
        }

        if (ret)
        {
            projFundingSource = ProjFundingSource::find(this.fundingSource());
            if ((projFundingSource.FundingType == ProjFundingType::Organization) ||
                (projFundingSource.FundingType == ProjFundingType::OnHoldFundingSource))
            {
                ret = false;
            }
        }

        if (ret)
        {
            ret = ProjInvoiceTable::isBillingRuleInvoiceable(this.projId(), this.categoryId(), this.psaContractLineNum(), this.transType());
        }

        if (ret)
        {
            ret = this.canTransStatusBeInvoiced(_chargeable);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canceledRevenueAccountLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for canceled invoiced revenue that will be used by this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for canceled invoiced revenue.
    /// </returns>
    public LedgerDimensionDefaultAccount canceledRevenueAccountLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(
                ProjAccountType::InvoiceCancelRevenueAccount,
                this.projId(),
                this.categoryId(),
                _fundingSourceID,
                false,
                true,
                this.taxGroup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>canTransStatusBeInvoiced</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether a transaction can be invoiced based on its status.
    /// </summary>
    /// <param name="_chargeable">
    ///    A Boolean value that determines whether invoice proposal transactions can be invoiced; optional.
    /// </param>
    /// <returns>
    ///    true if this transaction can be invoiced; otherwise, false.
    /// </returns>
    public boolean canTransStatusBeInvoiced(boolean _chargeable  = false)
    {
        boolean ret = false;

        switch (this.transStatus())
        {
            case ProjTransStatus::NoStatus:
                ret = false; break;
            case ProjTransStatus::Registered:
                ret = false; break;
            case ProjTransStatus::Posted:
                ret = true; break;
            case ProjTransStatus::InvoiceProposal:
                if (_chargeable)
                {
                    ret = true;
                }
                else
                {
                    ret = false;
                }
                break;
            case ProjTransStatus::Invoiced:
                ret = false;           break;
            case ProjTransStatus::MarkedCreditnote:
                ret = true;            break;
            case ProjTransStatus::CreditnoteProposal:
                ret = false;           break;
            case ProjTransStatus::Estimated:
                ret = false;           break;
            case ProjTransStatus::Eliminated:
                ret = false;           break;
            case ProjTransStatus::Adjusted:
                ret = false;           break;
            default:
                ret = false;           break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the category ID for a transaction.
    /// </summary>
    /// <returns>
    ///    The category ID for the transaction.
    /// </returns>
    /// <remarks>
    ///    This abstract method must be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public abstract ProjCategoryId categoryId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>childBuffer</Name>
				<Source><![CDATA[
    Common childBuffer()
    {
        return childBuffer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>contributionMargin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the contribution margin for a transaction.
    /// </summary>
    /// <param name="exchRate">
    ///    The exchange rate that will be used in the calculation; optional.
    /// </param>
    /// <returns>
    ///    The contribution margin for the transaction.
    /// </returns>
    /// <remarks>
    ///    If the exchange rate parameter is 0 or not passed, the method returns 0.
    /// </remarks>
    public  ContributionMargin contributionMargin(ExchRate exchRate = 0)
    {
        if (exchRate)
        {
            return (this.transTurnoverMST() - ((this.transCostMST()*100)/exchRate));
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>contributionRatio</Name>
				<Source><![CDATA[
    public  ContributionRatio contributionRatio(ExchRate exchRate = 0)
    {
        if (this.transTurnoverMST())
        {
            return (this.contributionMargin(exchRate) / this.transTurnoverMST()) * 100;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>controlId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the cost template ID for this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public ProjControlId controlId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>controlPeriodTo</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the end date of the project period for this transaction.
    /// </summary>
    /// <returns>
    ///    A null date.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public ProjPeriodTo controlPeriodTo()
    {
        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>controlVersion</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the version number of the project period for this transaction.
    /// </summary>
    /// <returns>
    ///    A <c>ProjControlVersion</c> value that indicates the version number.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public ProjControlVersion controlVersion()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAccountLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for cost that will be used by this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <param name="throwerror">
    /// A Boolean value that determines whether to throw an exception if a cost account cannot be found;
    /// optional.
    /// </param>
    /// <returns>
    /// The ledger dimension for cost.
    /// </returns>
    public LedgerDimensionDefaultAccount costAccountLedgerDimension(ProjFundingSourceRefId _fundingSourceID,boolean throwerror = true)
    {
        if (this.isIntercompany())
        {
            return this.intercompanyCostAccountLedgerDimension(_fundingSourceID, throwerror);
        }
        else
        {
            return ProjPosting::getLedgerDimension(ProjAccountType::CostAccount,
                                            this.projId(),
                                            this.categoryId(),
                                            _fundingSourceID,
                                            false,
                                            throwerror);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>costPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the cost price for a transaction.
    /// </summary>
    /// <returns>
    ///    The cost price for this transaction.
    /// </returns>
    /// <remarks>
    ///    This abstract method must be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public abstract CostPrice costPrice()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyIdCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the currency code for the costs that are reported by this transaction.
    /// </summary>
    /// <returns>
    ///    The currency code for the costs reported by this transaction.
    /// </returns>
    /// <remarks>
    ///    The costs are always reported in the company currency. Therefore, this method calls the
    ///    <c>standardCurrency</c> method of the <c>CompanyInfo</c> class.
    /// </remarks>
    public CurrencyCode currencyIdCost()
    {
        return CompanyInfoHelper::standardCurrency();
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyIdSales</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the currency code for the sales amounts reported by a transaction.
    /// </summary>
    /// <returns>
    ///    The currency code for the sales amounts that are reported by the transaction.
    /// </returns>
    /// <remarks>
    ///    This abstract method must be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public abstract ProjSalesCurrencyCode currencyIdSales()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns financial dimensions for this transaction.
    /// </summary>
    /// <returns>
    ///    The financial dimensions for this transaction.
    /// </returns>
    /// <remarks>
    ///    This abstract method must be overridden by classes that extend this class to provide the necessary functionality for the specific transaction.
    /// </remarks>
    public abstract DimensionDefault defaultDimension()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentDate</Name>
				<Source><![CDATA[
    public  DocumentDate documentDate()
    {
        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSales</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the exchange rate to use for the sales amounts that are reported by this transaction
    ///    based on the transaction date.
    /// </summary>
    /// <param name="_transDate">
    ///    The date to use to find the exchange rate. Defaults to the transaction date; optional.
    /// </param>
    /// <returns>
    ///    The exchange rate to use for the sales amounts that are reported by this transaction.
    /// </returns>
    public ExchRate exchRateSales(TransDate   _transDate  = this.transDate())
    {
        if (ProjInvoiceCurrency::exist(ProjTable::find(this.projId()).ProjInvoiceProjId,this.currencyIdSales()))
        {
            return ProjInvoiceCurrency::find(ProjTable::find(this.projId()).ProjInvoiceProjId,this.currencyIdSales()).ExchRate;
        }

        // Do not get an exchange rate based on the transaction date for accrued revenue posting when using posting date
        if (this.parmDefaultAccruedRevenueExchangeRateFromPostingDate())
        {
            return 0;
        }

        return ExchangeRateHelper::exchRate(this.currencyIdSales(), _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSecondarySales</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the secondary exchange rate to use for the sales amounts reported by this transaction
    ///    based on the transaction date.
    /// </summary>
    /// <param name="_transDate">
    ///    The date to use to find the exchange rate; optional.
    /// </param>
    /// <returns>
    ///    The secondary exchange rate to use for the sales amounts that are reported by this transaction.
    /// </returns>
    /// <remarks>
    ///    The <paramref name="_transDate" /> parameter will use the transaction date if no value is specified.
    /// </remarks>
    public ExchRate exchRateSecondarySales(TransDate   _transDate  = this.transDate())
    {
        if (ProjInvoiceCurrency::exist(ProjTable::find(this.projId()).ProjInvoiceProjId,this.currencyIdSales()))
        {
            return 0;
        }

        // Do not get an exchange rate based on the transaction date for accrued revenue posting when using posting date
        if (this.parmDefaultAccruedRevenueExchangeRateFromPostingDate())
        {
            return 0;
        }

        return ExchangeRateHelper::exchRateSecond(this.currencyIdSales(), _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>externalItemId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the customer item number that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public SalesExternalItemId externalItemId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>forecastEliminationDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the expected elimination date for this transaction.
    /// </summary>
    /// <returns>
    ///    A null date.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public ProjForecastEliminationDate    forecastEliminationDate()
    {
        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>forecastInvoiceDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the expected invoice date for this transaction.
    /// </summary>
    /// <returns>
    ///    A null date.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public ProjForecastInvoiceDate    forecastInvoiceDate()
    {
        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>forecastModelId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the forecast model for this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public ForecastModelId forecastModelId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>fundingSource</Name>
				<Source><![CDATA[
    public ProjFundingSourceRefId fundingSource()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxTransDate</Name>
				<Source><![CDATA[
    TransDate getTaxTransDate()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasTaxBuffer</Name>
				<Source><![CDATA[
    boolean hasTaxBuffer()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>indirectComponentInvoiceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the total indirect invoice amount for the given transaction
    ///    currency.
    /// </summary>
    /// <returns>
    ///    The indirect invoice amount.
    /// </returns>
    public Amount indirectComponentInvoiceAmount()
    {
        PSAIndirectComponentTrans   psaIndirectComponentTrans;

        select sum(Amount) from psaIndirectComponentTrans
            where psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Invoice
                  && psaIndirectComponentTrans.TransId == this.transId();

        return psaIndirectComponentTrans.Amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>indirectCostAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves indirect cost amount.
    /// </summary>
    /// <returns>
    /// Returns zero for indirect cost amount.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public PSAIndirectCost indirectCostAmount()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>indirectSalesAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves indirect sales amount.
    /// </summary>
    /// <returns>
    /// Returns zero for indirect sales amount.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public PSAIndirectSalesAmount indirectSalesAmount()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>indirectSalesAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the indirect sales amount for this transaction in company currency.
    /// </summary>
    /// <returns>
    /// The indirect sales amount for this transaction.
    /// </returns>
    public AmountMST indirectSalesAmountMST()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the inventory dimension for this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public InventDimId inventDimId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransId</Name>
				<Source><![CDATA[
    public InventTransId inventTransId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether this transaction is invoiceable.
    /// </summary>
    /// <returns>
    ///    false.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary functionality for the specific transaction.
    /// </remarks>
    public boolean invoiceable()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiced</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether this transaction has been invoiced.
    /// </summary>
    /// <returns>
    ///    false.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary functionality for the specific transaction.
    /// </remarks>
    public  boolean invoiced()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the invoice date of this transaction.
    /// </summary>
    /// <returns>
    ///    A null date.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public InvoiceDate invoiceDate()
    {
        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoicedMST</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the amount invoiced in the default currency for this transaction.
    /// </summary>
    /// <returns>
    ///    The amount invoiced.
    /// </returns>
    /// <remarks>
    ///    If the transaction has not been invoiced, this method returns 0.
    /// </remarks>
    public AmountMST invoicedMST()
    {
        if (this.invoiced())
        {
            return CurrencyExchangeHelper::amountCur2MST(this.transTurnover(), this.currencyIdSales(), this.exchRateSales());
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the invoice ID of the invoice for this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public ProjInvoiceId invoiceId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCorrection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the correction field that is associated with a transaction.
    /// </summary>
    /// <returns>
    /// The value of the correction field that is associated with the transaction.
    /// </returns>
    /// <remarks>
    /// This method must be overridden by classes to support storno.
    /// </remarks>
    public LedgerCorrection isCorrection()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSubscription</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether this transaction is for a subscription.
    /// </summary>
    /// <returns>
    ///    true if this transaction is for a subscription; otherwise, false.
    /// </returns>
    public boolean isSubscription()
    {
        return ProjCategory::find(this.categoryId()).SetupSubscription;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemAdjustVersion</Name>
				<Source><![CDATA[
    public ProjItemAdjustVersion itemAdjustVersion()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the inventory item that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend the class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public ItemId itemId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemLedgerAccountLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ledger dimension for the inventory item that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public LedgerDimensionDefaultAccount itemLedgerAccountLedgerDimension()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemLineAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the net sales amount for the inventory item that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    Always returns 0.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public SalesLineAmount itemLineAmount()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the sales order line number for the inventory item that is associated with this
    ///    transaction.
    /// </summary>
    /// <returns>
    ///    Always returns 0.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public LineNum itemLineNum()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the transaction origin for this transaction.
    /// </summary>
    /// <returns>
    ///    The <c>ProjItemType::Project</c> enumeration value.
    /// </returns>
    /// <remarks>
    ///    This method can be overridden by classes that extend this class to return a different transaction
    ///    origin for the specific transaction.
    /// </remarks>
    public ProjTransactionOrigin itemType()
    {
        return ProjOrigin::ItemRequirement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalReportLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for reporting journal entries that will be used by this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for reporting journal entries.
    /// </returns>
    public LedgerDimensionDefaultAccount journalReportLedgerDimension(ProjFundingSourceRefId _fundingSourceID)
    {
        LedgerDimensionDefaultAccount ledgerDimension;
        ProjLedgerStatus costTransCost = ProjRevRecHelper::getCostLedgerStatus(ProjTable::find(this.projId()));

        if (costTransCost == ProjLedgerStatus::BalanceSheet)
        {
            if (this.projLineProperty().ToBeCapitalize)
            {
                if (ProjTable::isPLPostingRequiredForTransType(this.projTable().ProjId, this.transType()))
                {
                    costTransCost = ProjLedgerStatus::Operations;
                }
            }
            else
            {
                costTransCost = ProjLedgerStatus::Operations;
            }
        }

        if (costTransCost)
        {
            switch (costTransCost)
            {
                case ProjLedgerStatus::BalanceSheet:
                            ledgerDimension = ProjPosting::getLedgerDimension(ProjAccountType::StatusAccount,
                                            this.projId(),
                                            this.categoryId(),
                                            _fundingSourceID);
                    break;
                default :
                            ledgerDimension = ProjPosting::getLedgerDimension(ProjAccountType::CostAccount,
                                            this.projId(),
                                            this.categoryId(),
                                            _fundingSourceID);
                    break;
            }
        }
        return    ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerCostAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the cost amount to be posted to the general ledger.
    /// </summary>
    /// <returns>
    ///    Always returns 0.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public AmountMST ledgerCostAmountMST()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerSalesAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the sales amount to be posted to the general ledger.
    /// </summary>
    /// <returns>
    ///    Always returns 0.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public AmountMST ledgerSalesAmountMST()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerSalesPosted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether sales have been posted to the general ledger.
    /// </summary>
    /// <returns>
    ///    The <c>NoYes::No</c> enumeration value.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary functionality for the specific transaction.
    /// </remarks>
    public NoYes ledgerSalesPosted()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerStatusCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ledger status for this transaction.
    /// </summary>
    /// <returns>
    ///    A <c>ProjLedgerStatus::None</c> enumeration value.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public ProjLedgerStatus ledgerStatusCost()
    {
        return ProjLedgerStatus::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ledger date.
    /// </summary>
    /// <returns>
    ///    The ledger date.
    /// </returns>
    /// <remarks>
    ///    This method must be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public TransDate ledgerTransDate()
    {
        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineDisc</Name>
				<Source><![CDATA[
    SalesLineDisc lineDisc()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>linePercent</Name>
				<Source><![CDATA[
    public SalesLinePercent linePercent()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>linePropertyId</Name>
				<Source><![CDATA[
    public abstract ProjLinePropertyId linePropertyId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>maximumRetailPrice_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves Maximum retail price value for this transaction.
    /// </summary>
    /// <returns>
    /// Always returns zero.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public MaximumRetailPrice_IN maximumRetailPrice_IN()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>module</Name>
				<Source><![CDATA[
    public ModuleAxapta module()
    {
        return ModuleAxapta::Project;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustHandleBudget</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether budgetary control is enabled.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    /// <remarks>
    ///    This method will be overridden by child classes to return true if budgetary control is required.
    /// </remarks>
    public boolean mustHandleBudget()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustHandleCommittedCost</Name>
				<Source><![CDATA[
    public boolean mustHandleCommittedCost()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustHandleForecast</Name>
				<Source><![CDATA[
    public boolean mustHandleForecast()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustValidateBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a project budget must be validated.
    /// </summary>
    /// <returns>
    /// true if the project budget must be validated; otherwise, false;
    /// </returns>
    public boolean mustValidateBudget()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(Common _buffer,Common _childBuffer=null)
    {
        buffer=_buffer;
        childBuffer=_childBuffer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccountItemLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for cost minus item that will be used by this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for cost minus item.
    /// </returns>
    public LedgerDimensionDefaultAccount offsetAccountItemLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(ProjAccountType::OffsetAccountItem,
                                            this.projId(),
                                            this.categoryId(),
                                            _fundingSourceID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>origin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the origin of the adjustments to this transaction.
    /// </summary>
    /// <returns>
    ///    The origin of the adjustments to this transaction.
    /// </returns>
    public ProjOriginAdjustment origin()
    {
        ProjOriginAdjustment    projOriginAdjustment    = ProjOriginAdjustment::Blank;

        switch (this.transType())
        {
            case ProjTransType::Hour:
                switch (this.originEmpl())
                {
                    case ProjOrigin::HourJournal:
                        projOriginAdjustment    = ProjOriginAdjustment::Hour;
                        break;
                    case ProjOrigin::ProductionConsumed:
                        projOriginAdjustment    = ProjOriginAdjustment::ProdLine;
                        break;
                    case ProjOrigin::Timesheet:
                        projOriginAdjustment    = ProjOriginAdjustment::Timesheets;
                        break;
                    case ProjOrigin::ProjAdvancedJournal:
                        ProjOriginAdjustment    = ProjOriginAdjustment::ProjAdvancedJournal;
                        break;
                }
                break;
            case ProjTransType::Revenue:
                switch (this.originRevenue())
                {
                    case ProjOrigin::FeeJournal:
                        projOriginAdjustment    = ProjOriginAdjustment::Journal;
                        break;
                    case ProjOrigin::EstimateFee:
                        projOriginAdjustment    = ProjOriginAdjustment::EstimateRevenue;
                        break;
                    case ProjOrigin::Subscription:
                        projOriginAdjustment    = ProjOriginAdjustment::SMASubscription;
                        break;
                    case ProjOrigin::FreeTextInvoice:
                        projOriginAdjustment    = ProjOriginAdjustment::FreeTextInvoice;
                        break;
                    case ProjOrigin::ProjAdvancedJournal:
                        ProjOriginAdjustment    = ProjOriginAdjustment::ProjAdvancedJournal;
                        break;
                }
                break;
            case ProjTransType::Cost:
                switch (this.originCost())
                {
                    case ProjOrigin::GeneralJournal:
                        projOriginAdjustment    = ProjOriginAdjustment::GeneralJournal;
                        break;
                    case ProjOrigin::CostJournal:
                        projOriginAdjustment    = ProjOriginAdjustment::Cost;
                        break;
                    case ProjOrigin::InvoiceJournal:
                        projOriginAdjustment    = ProjOriginAdjustment::InvoiceJournal;
                        break;
                    case ProjOrigin::InvoiceApprovalJournal:
                        projOriginAdjustment    = ProjOriginAdjustment::InvoiceApprovalJournal;
                        break;
                    case ProjOrigin::EstimateAccruedLoss:
                        projOriginAdjustment    = ProjOriginAdjustment::EstimateCost;
                        break;
                    case ProjOrigin::EliminationInvestment:
                        projOriginAdjustment    = ProjOriginAdjustment::InvestmentProject;
                        break;
                    case ProjOrigin::ExpenseManagement:
                        projOriginAdjustment    = ProjOriginAdjustment::ExpenseManagement;
                        break;
                    case ProjOrigin::ProjAdvancedJournal:
                        ProjOriginAdjustment    = ProjOriginAdjustment::ProjAdvancedJournal;
                        break;
                    case ProjOrigin::PurchaseOrder:
                        if (ProjAdjustCostUnbalancedPostingFromPurchOrderFlight::instance().isEnabled())
                        {
                            projOriginAdjustment    = ProjOriginAdjustment::PurchOrder;
                        }
                        break;
                }
                break;
            case ProjTransType::Item:
                switch (this.itemType())
                {
                    case ProjOrigin::ItemRequirement:
                        projOriginAdjustment    = ProjOriginAdjustment::Project;
                        break;
                    case ProjOrigin::SalesOrder:
                        projOriginAdjustment    = ProjOriginAdjustment::SalesOrder;
                        break;
                    case ProjOrigin::ItemJournal:
                        projOriginAdjustment    = ProjOriginAdjustment::InventJournal;
                        break;
                    case ProjOrigin::PurchaseOrder:
                        projOriginAdjustment    = ProjOriginAdjustment::PurchOrder;
                        break;
                    case ProjOrigin::VendorInvoice:
                        projOriginAdjustment    = ProjOriginAdjustment::VendorInvoice;
                        break;
                    case ProjOrigin::ProductionFinished:
                        projOriginAdjustment    = ProjOriginAdjustment::Production;
                        break;
                    case ProjOrigin::ProductionConsumed:
                        projOriginAdjustment    = ProjOriginAdjustment::ProdLine;
                        break;
                }
                break;
        }

        return projOriginAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>originCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the origin of costs on this transaction.
    /// </summary>
    /// <returns>
    ///    A <c>ProjOriginCost::GeneralJournal</c> enumeration value.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public ProjOrigin originCost()
    {
        return ProjOrigin::GeneralJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>originEmpl</Name>
				<Source><![CDATA[
    public ProjOrigin originEmpl()
    {
        return ProjOrigin::HourJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>originRevenue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the origin of revenues on this transaction.
    /// </summary>
    /// <returns>
    ///    A <c>ProjOriginRevenue::Journal</c> enumeration value.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public ProjOrigin originRevenue()
    {
        return ProjOrigin::FeeJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packingSlipId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the packing slip that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public PackingSlipId packingSlipId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerStatusCostOrig</Name>
				<Source><![CDATA[
    public boolean parmLedgerStatusCostOrig(boolean _useLedgerStatusCostOrig = useLedgerStatusCostOrig)
    {
        useLedgerStatusCostOrig = _useLedgerStatusCostOrig;
        return useLedgerStatusCostOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjustmentStatus</Name>
				<Source><![CDATA[
    public ProjTransStatus parmAdjustmentStatus(ProjTransStatus _adjustmentStatus = adjustmentStatus)
    {
        adjustmentStatus = _adjustmentStatus;

        return adjustmentStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjItemType</Name>
				<Source><![CDATA[
    public ProjItemType parmProjItemType(ProjItemType _projItemType = projItemType)
    {
        projItemType = _projItemType;

        return projItemType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjAdjustRefId</Name>
				<Source><![CDATA[
    public ProjAdjustRefId parmProjAdjustRefId(ProjAdjustRefId _projAdjustRefId = projAdjustRefId)
    {
        projAdjustRefId = _projAdjustRefId;

        return projAdjustRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaleTransStatus</Name>
				<Source><![CDATA[
    public ProjTransStatus parmSaleTransStatus(ProjTransStatus _saleTransStatus = saleTransStatus)
    {
        saleTransStatus = _saleTransStatus;

        return saleTransStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionOrigin</Name>
				<Source><![CDATA[
    public ProjOrigin parmTransactionOrigin(ProjOrigin _transactionOrigin = transactionOrigin)
    {
        transactionOrigin = _transactionOrigin;

        return transactionOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultAccruedRevenueExchangeRateFromPostingDate</Name>
				<Source><![CDATA[
    public boolean parmDefaultAccruedRevenueExchangeRateFromPostingDate(boolean _defaultAccruedRevenueExchangeRateFromPostingDate = defaultAccruedRevenueExchangeRateFromPostingDate)
    {
        defaultAccruedRevenueExchangeRateFromPostingDate = _defaultAccruedRevenueExchangeRateFromPostingDate;

        return defaultAccruedRevenueExchangeRateFromPostingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>payrollAllocationLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for payroll allocation that will be used by this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for payroll allocation.
    /// </returns>
    public LedgerDimensionDefaultAccount payrollAllocationLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(ProjAccountType::PayrollAllocation,
                                            this.projId(),
                                            this.categoryId(),
                                            _fundingSourceID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>port</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the port where any deliveries associated with this transaction were loaded.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public IntrastatPortId port()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>postalAddress_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves WearHouse location for this transaction.
    /// </summary>
    /// <returns>
    /// Always returns zero.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public LogisticsPostalAddressRecId postalAddress_IN()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTransTurnover</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the currency amount depending on if the sales price will include taxes or not.
    /// </summary>
    /// <param name="_returnValue">
    /// The <c>AmountCur</c> object that represents the amount calculated without taxes.
    /// </param>
    /// <returns>
    /// An <c>AmountCur</c> object, either the original parameter value or a new object that reflects sales
    /// tax.
    /// </returns>
    /// <remarks>
    /// This method only triggers if the <c>BrazilParameters::isEnabled</c> method returns true from the
    /// <c>transTurnover</c> value that is used for the post-handler.
    /// </remarks>
    public AmountCur postTransTurnover(AmountCur _returnValue)
    {
        if (this.projTable().projInvoice().ProjInvoiceNetPrice_BR)
        {
            return CurrencyExchangeHelper::amount(this.qty() * this.salesPriceInclTaxes_BR(), this.currencyIdSales());
        }

        return _returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceUnit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the price unit, number of units for which the price is specified, for this transaction.
    /// </summary>
    /// <returns>
    ///    The price unit for this transaction.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public PriceUnit priceUnit()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projAdjustRefId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the project adjustment reference that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public ProjAdjustRefId projAdjustRefId()
    {
        if (FeatureStateProvider::isFeatureEnabled(ProjCancelItemReqPackingSlipFeature::instance()))
        {
            return projAdjustRefId;
        }
        else
        {
            return '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>projEmplItemId</Name>
				<Source><![CDATA[
    public ProjEmplItemId projEmplItemId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>projId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the project that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    The ID of the project that is associated with this transaction.
    /// </returns>
    /// <remarks>
    ///    This abstract method must be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public abstract ProjId projId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>projIdentId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the ID of the item that is associated with this transaction depending on the transaction
    /// type that is returned by the <c>ProjTrans.transType</c> method.
    /// </summary>
    /// <returns>
    /// The ID of the item that is associated with this transaction.
    /// </returns>
    /// <remarks>
    /// For item transactions, the item ID will be returned. For all other transactions, an empty string
    /// will be returned.
    /// </remarks>
    public ProjIdentId projIdentId()
    {
        ProjIdentId projIdentId;

        switch (this.transType())
        {
            case ProjTransType::Item:
                projIdentId   = this.itemId();
                break;
            default:
                projIdentId   = '';
        }

        return projIdentId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projIdentResource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ID of the employee that is associated with this transaction depending on the
    /// transaction type that is returned by the <c>ProjTrans.transType</c> method.
    /// </summary>
    /// <returns>
    /// The <c>RecID</c> value of the employee that is associated with this transaction.
    /// </returns>
    /// <remarks>
    /// For hour, cost, and revenue transactions, the employee ID will be returned. For all other
    /// transactions, 0 will be returned.
    /// </remarks>
    public ResourceRecId projIdentResource()
    {
        ResourceRecId     resourceRecId;

        switch (this.transType())
        {
            case ProjTransType::Hour:
            case ProjTransType::Cost:
            case ProjTransType::Revenue:
                resourceRecId   = this.resource();
                break;
            default:
                resourceRecId   = 0;
        }

        return resourceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLineProperty</Name>
				<Source><![CDATA[
    public ProjLineProperty    projLineProperty()
    {
        return ProjLineProperty::find(this.linePropertyId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the project that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    The project that is associated with this transaction.
    /// </returns>
    public ProjTable projTable()
    {
        return ProjTable::find(this.projId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>proposal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether this transaction is from a project proposal.
    /// </summary>
    /// <returns>
    ///    true if this transaction is from a project proposal; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction. This base class implementation returns false.
    /// </remarks>
    boolean proposal()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>proposalId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the project proposal that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public  ProjProposalId proposalId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaContractLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the contract billing rule that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    The ID of the contract billing rule that is associated with this transaction.
    /// </returns>
    public PSAContractLineNum psaContractLineNum()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaIndirectAmount</Name>
				<Source><![CDATA[
    Amount psaIndirectAmount()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaIsOnAccount</Name>
				<Source><![CDATA[
    public NoYes psaIsOnAccount()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaOrigTransId</Name>
				<Source><![CDATA[
    // Description    : Original transaction Id used in adjusting cap writeoff
    public PSAProjOrigTransId psaOrigTransId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaRefRecIdBudgetTrans</Name>
				<Source><![CDATA[
    public RefRecId psaRefRecIdBudgetTrans()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaRefTableIdBudgetTrans</Name>
				<Source><![CDATA[
    public RefTableId psaRefTableIdBudgetTrans()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the quantity for this transaction.
    /// </summary>
    /// <returns>
    ///    The quantity for this transaction.
    /// </returns>
    /// <remarks>
    ///    This abstract method must be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public abstract Qty qty()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>recId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the record ID for this transaction.
    /// </summary>
    /// <returns>
    ///    Always returns zero.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public RecId recId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>RecId</c> value for the resource that is associated with this transaction.
    /// </summary>
    /// <returns>
    /// Zero.
    /// </returns>
    /// <remarks>
    /// This method must be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public ResourceRecId resource()
    {
        ResourceRecId resourceRecId;
        return resourceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resourceCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>RecId</c> value for the resourceCategory that is associated with this transaction.
    /// </summary>
    /// <returns>
    /// Zero.
    /// </returns>
    /// <remarks>
    /// This method must be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public ResourceCategoryRecId resourceCategory()
    {
        ResourceCategoryRecId resourceCategoryRecId;
        return resourceCategoryRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>revenueAccLedgerDimensionDebitNote_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the ledger dimension for debit note issued revenue to be used by this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    ///    The funding source that is associated with the project contract to be used by this transaction.
    /// </param>
    /// <returns>
    ///    The ledger dimension for debit note issued revenue revenue.
    /// </returns>
    public LedgerDimensionDefaultAccount revenueAccLedgerDimensionDebitNote_BR(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(
            ProjAccountType::DebitNote_BR,
            this.projId(),
            this.categoryId(),
            _fundingSourceID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>revenueAccountLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for invoiced revenue that will be used by this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for invoiced revenue.
    /// </returns>
    public LedgerDimensionDefaultAccount revenueAccountLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        // <GBR>
        if (ProjParameters::find().EnableCancelPostingProfiles && this.amountMST() < 0)
        {
            return this.canceledRevenueAccountLedgerDimension(_fundingSourceID);
        }
        // </GBR>

        return ProjPosting::getLedgerDimension(
            ProjAccountType::RevenueAccount,
            this.projId(),
            this.categoryId(),
            _fundingSourceID,
            false,
            true,
            this.taxGroup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the commission sales group that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public CommissSalesGroup salesGroup()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the sales order associated with this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public SalesId salesId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesLineConsumpLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for sales line consumption that will be used by this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for cost.
    /// </returns>
    public LedgerDimensionDefaultAccount salesLineConsumpLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(
            ProjAccountType::CostAccount,
            this.projId(),
            this.categoryId(),
            _fundingSourceID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesLineRevenueLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for sales line revenue that will be used by this transaction.
    /// </summary>
    /// <param name="_salesLine">
    /// The sales line revenue that will be used by this transaction.
    /// </param>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for invoiced revenue.
    /// </returns>
    public LedgerDimensionDefaultAccount salesLineRevenueLedgerDimension(SalesLine _salesLine,ProjFundingSourceRefId _fundingSourceID )
    {
        // <GBR>
        if (ProjParameters::find().EnableCancelPostingProfiles && this.amountMST() < 0)
        {
            return this.canceledRevenueAccountLedgerDimension(_fundingSourceID);
        }
        // </GBR>

        return ProjPosting::getLedgerDimension(
            ProjAccountType::RevenueAccount,
            _salesLine.salesTable().ProjId,
            this.categoryId(),
            _fundingSourceID,
            false,
            true,
            this.taxGroup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the sales mark up for this transaction.
    /// </summary>
    /// <returns>
    ///    Always returns 0.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public SalesMarkup salesMarkup()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesOffsetAccountLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for WIP minus sales value that will be used by this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for WIP minus sales value.
    /// </returns>
    public LedgerDimensionDefaultAccount salesOffsetAccountLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(
            ProjAccountType::SalesOffsetAccount,
            this.projId(),
            this.categoryId(),
            _fundingSourceID,
            false,
            true,
            this.taxGroup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the sales price for this transaction.
    /// </summary>
    /// <returns>
    ///    The sales price for this transaction.
    /// </returns>
    /// <remarks>
    ///    This abstract method must be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public abstract SalesPrice salesPrice()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesPriceInclTaxes_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the sales price including taxes included in classes that need net price be implemented.
    /// </summary>
    /// <returns>
    /// Return salesPrice.
    /// </returns>
    /// <remarks>
    /// <c>salesPriceInclTaxes_BR</c> will be overridden in proposal transaction classes.
    /// </remarks>
    public SalesPrice salesPriceInclTaxes_BR()
    {
        return this.salesPrice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesUnit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the sales unit for this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public UnitOfMeasureSymbol salesUnit()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesValueAccountLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for accrued revenue minus sales value that will be used by this
    /// transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for accrued revenue minus sales value.
    /// </returns>
    public LedgerDimensionDefaultAccount salesValueAccountLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(
            ProjAccountType::SalesValue,
            this.projId(),
            this.categoryId(),
            _fundingSourceID,
            false,
            true,
            this.taxGroup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>smaBasePrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the base price of the subscription that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    Always returns zero.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public SMABasePrice smaBasePrice()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>smaEnddate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the end date for the subscription that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    A null date.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public SMAEnddate smaEnddate()
    {
        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>smaIndex</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the index to use for the calculation of the indexed sales price for the subscription that
    ///    is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    Always returns 0.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public SMAIndex smaIndex()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>smaStartDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the end date for the subscription that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    A null date.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public SMAStartDate smaStartDate()
    {
        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>smaSubscriptionId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the subscription that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public SMASubscriptionId smaSubscriptionId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>smaSubscriptionPeriodType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the subscription type of the subscription associated with this transaction.
    /// </summary>
    /// <returns>
    ///    The <c>SMASubscriptionPeriodType::Regular</c> enumeration value.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public SMASubscriptionPeriodType smaSubscriptionPeriodType()
    {
        return SMASubscriptionPeriodType::Regular;
    }

]]></Source>
			</Method>
			<Method>
				<Name>statprocId</Name>
				<Source><![CDATA[
    public IntrastatProcId statprocId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>statusAccountItemLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for WIP minus cost value minus item that will be used by this
    /// transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for WIP minus cost value minus item.
    /// </returns>
    public LedgerDimensionDefaultAccount statusAccountItemLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(
            ProjAccountType::StatusAccountItem,
            this.projId(),
            this.categoryId(),
            _fundingSourceID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>statusAccountLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for WIP minus cost value that will be used by this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for WIP minus cost value.
    /// </returns>
    public LedgerDimensionDefaultAccount statusAccountLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(
            ProjAccountType::StatusAccount,
            this.projId(),
            this.categoryId(),
            _fundingSourceID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>subscriptionId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the <c>subscriptionId</c> that is associated with this transaction, if it exists.
    /// </summary>
    /// <returns>
    /// Returns the <c>subscriptionId</c> associated with this transaction, if it exists.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public SMASubscriptionId subscriptionId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>tableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the table ID for this transaction.
    /// </summary>
    /// <returns>
    ///    Always returns zero.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public TableId tableId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the tax group for this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public TaxGroup taxGroup()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxItemGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the item tax group for this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public TaxItemGroup taxItemGroup()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>tcsGroup_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves TCS value for this transaction.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public TaxWithholdGroup tcsGroup_IN()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>tdsGroup_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves TDS value for this transaction.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public TaxWithholdGroup tdsGroup_IN()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of transaction code of this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public IntrastatTransactionCodeId transactionCode()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>intrastatCommodity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the commodity code of this transaction.
    /// </summary>
    /// <returns>
    ///    Zero.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public IntrastatCommodityId intrastatCommodity()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>origCountryRegionId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the commodity origin country/region ID.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public ItemOrigCountryRegionId origCountryRegionId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>origStateId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the commodity origin state ID.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public ItemOrigStateId origStateId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>transCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the total cost of this transaction in the transaction currency.
    /// </summary>
    /// <returns>
    ///    The total cost of this transaction.
    /// </returns>
    public  Amount transCost()
    {
        return CurrencyExchangeHelper::amount(this.qty() * this.costPrice(), this.currencyIdCost());
    }

]]></Source>
			</Method>
			<Method>
				<Name>transCostItemPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the total cost of this transaction in the transaction currency.
    /// </summary>
    /// <returns>
    ///    The total cost of this transaction.
    /// </returns>
    public Amount transCostItemPhysical()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transCostBalance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the posted balance for this transaction.
    /// </summary>
    /// <returns>
    ///    The posted balance for this transaction.
    /// </returns>
    Amount transCostBalance()
    {
        return ProjTransPosting::projectPostedBalanceStatic(this.transId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>transCostMST</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the total cost of this transaction in company currency.
    /// </summary>
    /// <returns>
    ///    The total cost of this transaction.
    /// </returns>
    public AmountMST transCostMST()
    {
        return CurrencyExchangeHelper::mstAmount(this.transCost(), this.currencyIdCost(), this.transDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the transaction date.
    /// </summary>
    /// <returns>
    ///    The transaction date.
    /// </returns>
    /// <remarks>
    ///    This abstract method must be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public abstract TransDate transDate()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>transId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the transaction ID.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public TransactionID transId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>transport</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the method of transportation for orders that are associated with this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public IntrastatTransport transport()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>transStatus</Name>
				<Source><![CDATA[
    public ProjTransStatus transStatus()
    {
        return ProjTransStatus::NoStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTaxBaseAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the base transaction amount that will be used to calculate taxes in the transaction
    ///    currency.
    /// </summary>
    /// <returns>
    ///    The base transaction amount that will be used for calculating taxes.
    /// </returns>
    /// <remarks>
    ///    This method returns the result of the <c>transTurnover</c> method. Child classes can override this
    ///    method.
    /// </remarks>
    public AmountCur transTaxBaseAmount()
    {
        AmountCur   taxBaseAmount;
        Amount      indirectComponentInvoiceAmount;

        indirectComponentInvoiceAmount = this.indirectComponentInvoiceAmount();

        taxBaseAmount = this.transTurnover();
        
        if (taxBaseAmount < 0 && indirectComponentInvoiceAmount > 0)
        {
            taxBaseAmount += -indirectComponentInvoiceAmount;
        }
        else if (taxBaseAmount > 0 && indirectComponentInvoiceAmount < 0
                && ProjInvoiceIndirectComponentTaxCalcFlight::instance().isEnabled())
        {
            // for credit notes, indirect invoice amount stays the same but base transaction amount is reversed.
            taxBaseAmount += -indirectComponentInvoiceAmount;
        }
        else
        {
            taxBaseAmount += indirectComponentInvoiceAmount;
        }
        
        return taxBaseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTurnover</Name>
				<Source><![CDATA[
    public AmountCur transTurnover()
    {
        return CurrencyExchangeHelper::amount(this.qty() * this.salesPrice(), this.currencyIdSales());
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTurnoverGTE</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Get the balance amount of current trancation when GTE enable.
    /// </summary>
    /// <returns>
    ///     The balance amount of current trancation.
    /// </returns>
    public AmountCur transTurnoverGTE()
    {
        return this.transTurnover();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTurnoverMST</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the total sales amount for this transaction in company currency.
    /// </summary>
    /// <returns>
    ///    The total sales amount for this transaction.
    /// </returns>
    public AmountMST transTurnoverMST()
    {
        return CurrencyExchangeHelper::mstAmount(this.transTurnover(), this.currencyIdSales(), this.transDate(), Currency::noYes2UnknownNoYes(this.triangulationSales()), this.exchRateSales(), this.exchRateSecondarySales());
    }

]]></Source>
			</Method>
			<Method>
				<Name>transType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the transaction type.
    /// </summary>
    /// <returns>
    ///    The transaction type.
    /// </returns>
    /// <remarks>
    ///    This abstract method must be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public abstract ProjTransType transType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>triangulationSales</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether sales amounts on this transaction are subject to Euro triangulation when calculating currency exchanges.
    /// </summary>
    /// <returns>
    ///    A <c>NoYes::Yes</c> enumeration value if sales amounts on this transaction are subject to Euro triangulation.
    /// </returns>
    public NoYes triangulationSales()
    {
        if (ProjInvoiceCurrency::exist(ProjTable::find(this.projId()).ProjInvoiceProjId,this.currencyIdSales()))
        {
            return NoYes::No;
        }

        return Currency::triangulation(this.currencyIdSales(),this.transDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>txt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the transaction text.
    /// </summary>
    /// <returns>
    ///    The transaction text.
    /// </returns>
    /// <remarks>
    ///    This abstract method must be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public abstract TransTxt txt()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>finTag</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public FinTagRecId finTag()
    {
        FinTagRecId finTagRecId;

        return finTagRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the transaction.
    /// </summary>
    /// <returns>
    ///    true.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary functionality for the specific transaction.
    /// </remarks>
    public boolean validateWrite()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voucherInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the voucher number associated with this transaction.
    /// </summary>
    /// <returns>
    ///    The voucher number that is associated with this transaction.
    /// </returns>
    /// <remarks>
    ///    This abstract method must be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public abstract Voucher voucherInvoice()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>voucherOriginal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the original voucher number that is associated with this transaction.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public Voucher voucherOriginal()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipCostAccruedLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for the WIP minus an accrued loss that will be used by this
    /// transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for the WIP minus an accrued loss.
    /// </returns>
    public LedgerDimensionDefaultAccount wipCostAccruedLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(
            ProjAccountType::WIPCostAccruals,
            this.projId(),
            this.categoryId(),
            _fundingSourceID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipInvoicedOnAccountLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for the WIP minus invoiced minus on account that will be used by
    /// this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for the WIP minus invoiced minus on account.
    /// </returns>
    public LedgerDimensionDefaultAccount wipInvoicedOnAccountLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(
            ProjAccountType::WIPInvoicedOnAccount,
            this.projId(),
            this.categoryId(),
            _fundingSourceID,
            false,
            true,
            this.taxGroup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the start date of the estimate period for this transaction.
    /// </summary>
    /// <returns>
    ///    A null date.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public ProjPeriodFromWIP wipPeriod()
    {
        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipProductionLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for WIP minus production that will be used by this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for the WIP minus production.
    /// </returns>
    public LedgerDimensionDefaultAccount wipProductionLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(
            ProjAccountType::WIPProduction,
            this.projId(),
            this.categoryId(),
            _fundingSourceID,
            true,
            true,
            this.taxGroup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipProfitLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for the WIP minus profit that will be used by this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for the WIP minus profit.
    /// </returns>
    public LedgerDimensionDefaultAccount wipProfitLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(
            ProjAccountType::WIPProfit,
            this.projId(),
            this.categoryId(),
            _fundingSourceID,
            true,
            true,
            this.taxGroup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipSubscriptionLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for the WIP minus subscription that will be used by this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for the WIP minus subscription.
    /// </returns>
    public LedgerDimensionDefaultAccount wipSubscriptionLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return ProjPosting::getLedgerDimension(
            ProjAccountType::WIPSubscription,
            this.projId(),
            this.categoryId(),
            _fundingSourceID,
            true,
            true,
            this.taxGroup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoicedCostValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total quantity and total cost amount of an inventory transaction.
    /// </summary>
    /// <param name="_financial">
    ///    The financial update.
    /// </param>
    /// <returns>
    ///    A container with the total quantity and total cost amount of an inventory transaction.
    /// </returns>
    public static container calcInvoicedCostValue(InventUpd_Financial _financial)
    {
        InventTrans         inventTrans;
        InventQty           qty;
        CostAmount          value;

        while select inventTrans
            where inventTrans.InventTransOrigin ==  _financial.movement().inventTransOriginId()     &&
                  inventTrans.Voucher           ==  _financial.parmLedgerVoucher().lastVoucher()    &&
                  (!_financial.parmPackingSlipId()   || inventTrans.PackingSlipId   == _financial.parmPackingSlipId())  &&
                  (!_financial.parmVoucherPhysical() || inventTrans.VoucherPhysical == _financial.parmVoucherPhysical())
        {
            qty   += inventTrans.Qty;
            value += inventTrans.costValue();
        }

        return [qty,value];
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransCreating</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for getting the new <c>ProjTrans</c> instance.
    /// </summary>
    /// <param name="_buffer">
    /// A table buffer for the type of transaction to be constructed.
    /// </param>
    /// <param name = "_result">
    /// An <c>EventHandlerResult</c> instance, where subscribers can provide the new <c>ProjTrans</c> instance.
    /// </param>
    static delegate void projTransCreating(Common _buffer, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs a new instance of a specific transaction class.
    /// </summary>
    /// <param name="_buffer">
    ///    A table buffer for the type of transaction to be constructed.
    /// </param>
    /// <returns>
    ///    The new class.
    /// </returns>
    /// <remarks>
    ///    If an invalid table buffer is passed an error will be thrown.
    /// </remarks>
    public static ProjTrans construct(Common _buffer)
    {
        TmpProjAdjustmentCreate tmpProjAdjustmentCreate;
        ProjProposalItem        projProposalItem;
        ProjJournalTrans        projJournalTrans;
        ProjTrans               retProjTrans;
        ProjItemTransCost       projItemTransCost;
        ProjItemTrans           projItemTrans;
        ProjBegBalJournalTrans_CostSales    projBegBalJournalTrans_CostSales;
        ProjBegBalJournalTrans_Fee          projBegBalJournalTrans_Fee;
        ProjBegBalJournalTrans_OnAcc        projBegBalJournalTrans_OnAcc;
        // Create ProjTrans base on ProjTransPosting
        ProjTransPosting        tProjTransPosting;
        ProjRevenueTrans        tProjRevenueTrans;
        ProjCostTrans           tProjCostTrans;
        ProjEmplTrans           tProjEmplTrans;
        ProjItemTrans           tProjItemTrans;

        switch (_buffer.TableId)
        {
            case tableNum(ProjEmplTrans):
                retProjTrans = new ProjTransEmplTrans(_buffer);
                break;

            case tableNum(ProjProposalEmpl):
                retProjTrans = new ProjTransEmplProposal(_buffer);
                break;

            case tableNum(ProjInvoiceEmpl):
                retProjTrans = new ProjTransEmplInvoice(_buffer);
                break;

            case tableNum(ProjForecastEmpl):
                retProjTrans = new ProjTransEmplForecast(_buffer);
                break;

            case tableNum(ProjCostTrans):
                retProjTrans = new ProjTransCostTrans(_buffer);
                break;

            case tableNum(LedgerJournalTrans):
                retProjTrans =  new ProjTransCostJournal(_buffer,LedgerJournalTrans_Project::find(_buffer.RecId));
                break;

            case tableNum(ProjProposalCost):
                retProjTrans = new ProjTransCostProposal(_buffer);
                break;

            case tableNum(ProjInvoiceCost):
                retProjTrans = new ProjTransCostInvoice(_buffer);
                break;

            case tableNum(ProjForecastCost):
                retProjTrans = new ProjTransCostForecast(_buffer);
                break;

            case tableNum(SalesLine):
                retProjTrans = new ProjTransSalesLine(_buffer);
                break;

            case tableNum(InventJournalTrans):
                retProjTrans = new ProjTransItemJournal(_buffer);
                break;

            case tableNum(ForecastSales):
                retProjTrans = new ProjTransItemForecast(_buffer);
                break;

            case tableNum(CustPackingSlipTrans):
                retProjTrans = new ProjTransItemPackingSlip(_buffer);
                break;

            case tableNum(ProjItemTrans):
                retProjTrans = new ProjTransItemTrans(_buffer);
                break;

            case tableNum(ProjItemTransCost):
                projItemTransCost = _buffer;
                projItemTrans = ProjItemTrans::findInvent(projItemTransCost.InventTransId,projItemTransCost.ProjAdjustRefId);
                retProjTrans = new ProjTransItemTransCost(projItemTrans, projItemTransCost);
                break;
            case tableNum(ProjProposalItem):
                projProposalItem    = _buffer;
                switch (projProposalItem.ItemType)
                {
                    case ProjItemType::Project:
                        retProjTrans = new ProjTransItemProposal_Project(_buffer);
                        break;

                    case ProjItemType::SalesOrder:
                        return new ProjTransItemProposal_SalesOrder(_buffer);
                }
                break;

            case tableNum(ProjInvoiceItem):
                retProjTrans = new ProjTransItemInvoice(_buffer);
                break;

            case tableNum(TmpProjAdjustmentCreate):
                tmpProjAdjustmentCreate = _buffer;
                if (tmpProjAdjustmentCreate.checkAdjustmentType(ProjAdjustmentType::Item))
                {
                    retProjTrans = new ProjTransItemPackingSlipAdjust(_buffer);
                }
                else
                {
                    throw error("@SYS102342");
                }
                break;

            case tableNum(ProjRevenueTrans):
                retProjTrans = new ProjTransRevenueTrans(_buffer);
                break;

            case tableNum(ProjProposalRevenue):
                retProjTrans = new ProjTransRevenueProposal(_buffer);
                break;

            case tableNum(ProjInvoiceRevenue):
                retProjTrans = new ProjTransRevenueInvoice(_buffer);
                break;

            case tableNum(ProjForecastRevenue):
                retProjTrans = new ProjTransRevenueForecast(_buffer);
                break;

            case tableNum(ProjOnAccTrans):
                retProjTrans = new ProjTransOnAccTrans(_buffer);
                break;

            case tableNum(ProjProposalOnAcc):
                retProjTrans = new ProjTransOnAccProposal(_buffer);
                break;

            case tableNum(ProjInvoiceOnAcc):
                retProjTrans = new ProjTransOnAccInvoice(_buffer);
                break;

            case tableNum(ProjControlPeriodTrans):
                retProjTrans = new ProjTransWIP(_buffer);
                break;

            case tableNum(ProjJournalTrans):
                projJournalTrans = _buffer;
                if (projJournalTrans.projJournalTable().JournalType == ProjJournalType::Hour)
                {
                    retProjTrans = new ProjTransEmplJournal(projJournalTrans);
                }
                else
                {
                    retProjTrans = new ProjTransRevenueJournal(projJournalTrans);
                }
                break;

            case tableNum(ProjBegBalJournalTrans_CostSales):
                projBegBalJournalTrans_CostSales = _buffer;

                switch (projBegBalJournalTrans_CostSales.ProjTransType)
                {
                    case BegBalProjTransTypeCost::Hour :
                        retProjTrans = new ProjTransBegBalHour(projBegBalJournalTrans_CostSales);
                        break;

                    case BegBalProjTransTypeCost::Cost :
                        retProjTrans = new ProjTransBegBalCost(projBegBalJournalTrans_CostSales);
                        break;

                    case BegBalProjTransTypeCost::Item :
                        retProjTrans = new ProjTransBegBalItem(projBegBalJournalTrans_CostSales);
                        break;

                    default :
                        retProjTrans = ProjTrans::defaultBegBalProjTransTypeCustom(projBegBalJournalTrans_CostSales);
                }
                break;
            // Create ProjTrans base on ProjTransPosting
            case tableNum(ProjTransPosting):
                if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                {
                    tProjTransPosting = _buffer;
                    switch (tProjTransPosting.ProjTransType)
                    {
                        case ProjTransType::Cost:
                            tProjCostTrans = ProjCostTrans::find(tProjTransPosting.TransId);
                            retProjTrans = new ProjTransCostTrans(tProjCostTrans);
                            break;
                        case ProjTransType::Hour:
                            tProjEmplTrans = ProjEmplTrans::find(tProjTransPosting.TransId);
                            retProjTrans = new ProjTransEmplTrans(tProjEmplTrans);
                            break;
                        case ProjTransType::Item:
                            tProjItemTrans = ProjItemTrans::find(tProjTransPosting.TransId);
                            retProjTrans = new ProjTransItemTrans(tProjItemTrans);
                            break;
                        case ProjTransType::Revenue:
                            tProjRevenueTrans = ProjRevenueTrans::find(tProjTransPosting.TransId);
                            retProjTrans = new ProjTransRevenueTrans(tProjRevenueTrans);
                            break;
                        default :
                            throw error(strFmt("@SYS23396",funcName()));
                    }
                }

            case tableNum(ProjBegBalJournalTrans_Fee):
                projBegBalJournalTrans_Fee = _buffer;
                retProjTrans = new ProjTransBegBalRevenue(projBegBalJournalTrans_Fee);
                break;

            case tableNum(ProjBegBalJournalTrans_OnAcc):
                projBegBalJournalTrans_OnAcc = _buffer;
                retProjTrans = new ProjTransBegBalOnAcc(projBegBalJournalTrans_OnAcc);
                break;

            default :
                var eventHandlerResult = new EventHandlerResult();
                ProjTrans::projTransCreating(_buffer, eventHandlerResult);

                if (eventHandlerResult.hasResult())
                {
                    retProjTrans = eventHandlerResult.result();
                }
                else
                {
                    throw error(strFmt("@SYS23396",funcName()));
                }
        }

        return retProjTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultBegBalProjTransTypeCustom</Name>
				<Source><![CDATA[
    [Replaceable]
    protected static ProjTrans defaultBegBalProjTransTypeCustom(ProjBegBalJournalTrans_CostSales _projBegBalJournalTrans_CostSales)
    {
        throw error(strFmt("@SYS23396",funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCostControlTransCommittedCost</Name>
				<Source><![CDATA[
    public static ProjTrans newCostControlTransCommittedCost(CostControlTransCommittedCost  _costControlTransCommittedCost)
    {
        ProjTrans   projTransCommittedCost;

        projTransCommittedCost  = new ProjTransCommittedCost(_costControlTransCommittedCost);

        return projTransCommittedCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustPackingSlipTrans</Name>
				<Source><![CDATA[
    public static ProjTrans newCustPackingSlipTrans(CustPackingSlipTrans  _custPackingSlipTrans)
    {
        ProjTrans   projTransItemPackingSlip;

        projTransItemPackingSlip  = new ProjTransItemPackingSlip(_custPackingSlipTrans);

        return projTransItemPackingSlip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustPackingSlipTrans_AdjCost</Name>
				<Source><![CDATA[
    public static ProjTrans newCustPackingSlipTrans_AdjCost(CustPackingSlipTrans  _custPackingSlipTrans, AmountCur _diffAmount)
    {
        ProjTrans projTransItemPackingSlip = new ProjTransItemPackingSlip_AdjCost(_custPackingSlipTrans, _diffAmount);

        return projTransItemPackingSlip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForecastSales</Name>
				<Source><![CDATA[
    public static ProjTrans newForecastSales(ForecastSales _forecastSales)
    {
        ProjTrans   projTransItemForecast;

        projTransItemForecast  = new ProjTransItemForecast(_forecastSales);

        return projTransItemForecast;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventJournalTrans</Name>
				<Source><![CDATA[
    public static ProjTrans newInventJournalTrans(InventJournalTrans  _inventJournalTrans)
    {
        ProjTrans   projTransItemJournal;

        projTransItemJournal  = new ProjTransItemJournal(_inventJournalTrans);

        return projTransItemJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjTransAdvancedJournal</Name>
				<Source><![CDATA[
    public static ProjTrans newProjTransAdvancedJournal(ProjAdvancedJournalLine _projAdvancedJournalLine)
    {
        ProjTrans projTransAdvancedJournal = new ProjTransAdvancedJournal(_projAdvancedJournalLine);

        return projTransAdvancedJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventMovement</Name>
				<Source><![CDATA[
    public static ProjTrans newInventMovement(InventMovement _movement, LedgerVoucher _ledgerVoucher, Qty _qty, Amount _transCost)
    {
        return ProjTransInventMov::newProjTransInventMov(_movement, _ledgerVoucher, _qty, _transCost);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventUpd_Financial</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new financial inventory update transaction.
    /// </summary>
    /// <param name="_financial">
    ///    A financial inventory update.
    /// </param>
    /// <param name="_projAdjustRefId">
    ///    Adjustment number of project item transaction
    /// </param>
    /// <returns>
    ///    The new transaction instance.
    /// </returns>
    public static ProjTrans newInventUpd_Financial(InventUpd_Financial _financial, ProjAdjustRefId _projAdjustRefId)
    {
        return ProjTransInventUpd_Financial::newProjTransInventUpd_Financial(_financial, _projAdjustRefId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventUpd_Physical</Name>
				<Source><![CDATA[
    public static ProjTrans newInventUpd_Physical(InventUpd_Physical _inventUpd_Physical, LedgerVoucher _ledgerVoucher)
    {
        return ProjTransInventUpd_Physical::newProjTransInventUpd_Physical(_inventUpd_Physical, _ledgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerJournalTrans</Name>
				<Source><![CDATA[
    public static ProjTrans newLedgerJournalTrans(LedgerJournalTrans  _ledgerJournalTrans)
    {
        ProjTrans   projTransCostJournal;

        projTransCostJournal  = new ProjTransCostJournal(_ledgerJournalTrans,
                                                         LedgerJournalTrans_Project::find(_ledgerJournalTrans.RecId));

        return projTransCostJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerJournalTransHistory</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public static ProjTrans newLedgerJournalTransHistory(LedgerJournalTransHistory  _ledgerJournalTransHistory)
    {
        ProjTrans projTransCostJournal;
        projTransCostJournal  = new ProjTransCostJournalHistory(_ledgerJournalTransHistory, LedgerJournalTransHistory_Project::find(_ledgerJournalTransHistory.RecId));

        return projTransCostJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdJournalRouteProj</Name>
				<Source><![CDATA[
    public static ProjTrans newProdJournalRouteProj(ProdRouteTrans            _prodRouteTrans,
                                                    ProdJournalRoute          _prodJournalRoute,
                                                    ProdJournalRouteProj      _prodJournalRouteProj)
    {
        ProjTransRouteJournal   projTransJournalTrans;

        projTransJournalTrans  = new ProjTransRouteJournal(_prodJournalRouteProj,_prodJournalRoute);
        projTransJournalTrans.parmProdRouteTrans(_prodRouteTrans);

        return projTransJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newprojControlPeriodTrans</Name>
				<Source><![CDATA[
    public static ProjTrans newprojControlPeriodTrans(ProjControlPeriodTrans  _projControlPeriodTrans)
    {
        ProjTrans   projTransWIP;

        projTransWIP  = new ProjTransWIP(_projControlPeriodTrans);

        return projTransWIP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjCostTrans</Name>
				<Source><![CDATA[
    public static ProjTrans newProjCostTrans(ProjCostTrans  _projCostTrans)
    {
        ProjTrans   projTransCostTrans;

        projTransCostTrans  = new ProjTransCostTrans(_projCostTrans);

        return projTransCostTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjCostTransCost</Name>
				<Source><![CDATA[
    public static ProjTrans newProjCostTransCost(ProjCostTrans _projCostTrans, ProjCostTransCost _projCostTransCost)
    {
        ProjTrans   projTransCostTransCost;

        projTransCostTransCost  = new ProjTransCostTransCost(_projCostTrans, _projCostTransCost);

        return projTransCostTransCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjCostTransSale</Name>
				<Source><![CDATA[
    public static ProjTrans newProjCostTransSale(ProjCostTrans _projCostTrans, ProjCostTransSale _projCostTransSale)
    {
        ProjTrans   projTransCostTransSale;

        projTransCostTransSale  = new ProjTransCostTransSale(_projCostTrans, _projCostTransSale);

        return projTransCostTransSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjEmplTrans</Name>
				<Source><![CDATA[
    public static ProjTrans newProjEmplTrans(ProjEmplTrans  _projEmplTrans)
    {
        ProjTrans   projTransEmplTrans;

        projTransEmplTrans  = new ProjTransEmplTrans(_projEmplTrans);

        return projTransEmplTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjEmplTransCost</Name>
				<Source><![CDATA[
    public static ProjTrans newProjEmplTransCost(ProjEmplTrans _projEmplTrans, ProjEmplTransCost _projEmplTransCost)
    {
        ProjTrans   projTransEmplTransCost;

        projTransEmplTransCost  = new ProjTransEmplTransCost(_projEmplTrans, _projEmplTransCost);

        return projTransEmplTransCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjEmplTransIndirectCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>ProjTrans</c> object for an indirect cost buffer.
    /// </summary>
    /// <param name="_projEmplTrans">
    /// The hour transaction buffer.
    /// </param>
    /// <param name="_projEmplTransCost">
    /// The hour transaction detail buffer.
    /// </param>
    /// <param name="_tIndirectComponentTrans">
    /// The indirect cost buffer.
    /// </param>
    /// <returns>
    /// <c>ProjTrans</c> object for an indirect cost buffer.
    /// </returns>
    public static ProjTrans newProjEmplTransIndirectCost(ProjEmplTrans _projEmplTrans, ProjEmplTransCost _projEmplTransCost, PSAIndirectComponentTrans _tIndirectComponentTrans)
    {
        ProjTrans   projTransEmplTransIndirectCost;

        projTransEmplTransIndirectCost  = new ProjTransEmplTransIndirectCost(_projEmplTrans, _projEmplTransCost, _tIndirectComponentTrans);

        return projTransEmplTransIndirectCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjEmplTransSale</Name>
				<Source><![CDATA[
    public static ProjTrans newProjEmplTransSale(ProjEmplTrans _projEmplTrans, ProjEmplTransSale _projEmplTransSale)
    {
        ProjTrans   projTransEmplTransSale;

        projTransEmplTransSale  = new ProjTransEmplTransSale(_projEmplTrans, _projEmplTransSale);

        return projTransEmplTransSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjForecastCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new expense forecast transaction.
    /// </summary>
    /// <param name="_projForecastCost">
    ///    An expense forecast.
    /// </param>
    /// <returns>
    ///    The new transaction instance.
    /// </returns>
    public static ProjTrans newProjForecastCost(ProjForecastCost _projForecastCost)
    {
        ProjTrans   projTransCostForecast;

        projTransCostForecast  = new ProjTransCostForecast(_projForecastCost);

        return projTransCostForecast;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjForecastEmpl</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new hours forecast transaction.
    /// </summary>
    /// <param name="_projForecastEmpl">
    ///    An hours forecast.
    /// </param>
    /// <returns>
    ///    The new transaction instance.
    /// </returns>
    public static ProjTrans newProjForecastEmpl(ProjForecastEmpl _projForecastEmpl)
    {
        ProjTrans   projTransEmplForecast;

        projTransEmplForecast  = new ProjTransEmplForecast(_projForecastEmpl);

        return projTransEmplForecast;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjForecastOnAcc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new on account forecast transaction.
    /// </summary>
    /// <param name="_projForecastOnAcc">
    ///    An on account forecast.
    /// </param>
    /// <returns>
    ///    The new transaction instance.
    /// </returns>
    public static ProjTrans newProjForecastOnAcc(
        ProjForecastOnAcc _projForecastOnAcc)
    {
        ProjTrans   projTransOnAccForecast;

        projTransOnAccForecast  = new ProjTransOnAccForecast(_projForecastOnAcc);

        return projTransOnAccForecast;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjForecastRevenue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new fee forecast transaction.
    /// </summary>
    /// <param name="_projForecastRevenue">
    ///    A fee forecast.
    /// </param>
    /// <returns>
    ///    The new transaction instance.
    /// </returns>
    public static ProjTrans newProjForecastRevenue(ProjForecastRevenue _projForecastRevenue)
    {
        ProjTrans   projTransRevenueForecast;

        projTransRevenueForecast  = new ProjTransRevenueForecast(_projForecastRevenue);

        return projTransRevenueForecast;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjInvoiceCost</Name>
				<Source><![CDATA[
    public static ProjTrans newProjInvoiceCost(ProjInvoiceCost  _projInvoiceCost)
    {
        ProjTrans   projTransCostInvoice;

        projTransCostInvoice  = new ProjTransCostInvoice(_projInvoiceCost);

        return projTransCostInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjInvoiceCostCost</Name>
				<Source><![CDATA[
    public static ProjTrans newProjInvoiceCostCost(ProjInvoiceCost  _projInvoiceCost, ProjInvoiceCostDetail  _projInvoiceCostDetail, ProjCostTransCost _projCostTransCost)
    {
        ProjTrans   projTransCostInvoiceCost;

        projTransCostInvoiceCost  = new ProjTransCostInvoiceCost(_projInvoiceCost, _projInvoiceCostDetail, _projCostTransCost);

        return projTransCostInvoiceCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjInvoiceCostSale</Name>
				<Source><![CDATA[
    public static ProjTrans newProjInvoiceCostSale(ProjInvoiceCost  _projInvoiceCost, ProjInvoiceCostDetail  _projInvoiceCostDetail)
    {
        ProjTrans   projTransCostInvoiceSale;

        projTransCostInvoiceSale  = new ProjTransCostInvoiceSale(_projInvoiceCost, _projInvoiceCostDetail);

        return projTransCostInvoiceSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjInvoiceEmpl</Name>
				<Source><![CDATA[
    public static ProjTrans newProjInvoiceEmpl(ProjInvoiceEmpl  _projInvoiceEmpl)
    {
        ProjTrans   projTransEmplInvoice;

        projTransEmplInvoice  = new ProjTransEmplInvoice(_projInvoiceEmpl);

        return projTransEmplInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjInvoiceEmplCost</Name>
				<Source><![CDATA[
    public static ProjTrans newProjInvoiceEmplCost(ProjInvoiceEmpl  _projInvoiceEmpl, ProjInvoiceEmplDetail  _projInvoiceEmplDetail, ProjEmplTransCost _projEmplTransCost)
    {
        ProjTrans   projTransEmplInvoiceCost;

        projTransEmplInvoiceCost  = new ProjTransEmplInvoiceCost(_projInvoiceEmpl, _projInvoiceEmplDetail, _projEmplTransCost);

        return projTransEmplInvoiceCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjInvoiceEmplSale</Name>
				<Source><![CDATA[
    public static ProjTrans newProjInvoiceEmplSale(ProjInvoiceEmpl  _projInvoiceEmpl, ProjInvoiceEmplDetail  _projInvoiceEmplDetail)
    {
        ProjTrans   projTransEmplInvoiceSale;

        projTransEmplInvoiceSale  = new ProjTransEmplInvoiceSale(_projInvoiceEmpl, _projInvoiceEmplDetail);

        return projTransEmplInvoiceSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjInvoiceItem</Name>
				<Source><![CDATA[
    public static ProjTrans newProjInvoiceItem(ProjInvoiceItem  _projInvoiceItem)
    {
        ProjTrans   projTransItemInvoice;

        projTransItemInvoice  = new ProjTransItemInvoice(_projInvoiceItem);

        return projTransItemInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjInvoiceItemCost</Name>
				<Source><![CDATA[
    public static ProjTrans newProjInvoiceItemCost(ProjInvoiceItem  _projInvoiceItem, ProjInvoiceItemDetail  _projInvoiceItemDetail, ProjItemTransCost _projItemTransCost)
    {
        ProjTrans   projTransItemInvoiceCost;

        projTransItemInvoiceCost  = new ProjTransItemInvoiceCost(_projInvoiceItem, _projInvoiceItemDetail, _projItemTransCost);

        return projTransItemInvoiceCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjInvoiceItemSale</Name>
				<Source><![CDATA[
    public static ProjTrans newProjInvoiceItemSale(ProjInvoiceItem  _projInvoiceItem, ProjInvoiceItemDetail  _projInvoiceItemDetail)
    {
        ProjTrans   projTransItemInvoiceSale;

        projTransItemInvoiceSale  = new ProjTransItemInvoiceSale(_projInvoiceItem, _projInvoiceItemDetail);

        return projTransItemInvoiceSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjInvoiceOnAcc</Name>
				<Source><![CDATA[
    public static ProjTrans newProjInvoiceOnAcc(ProjInvoiceOnAcc  _projInvoiceOnAcc)
    {
        ProjTrans   projTransOnAccInvoice;

        projTransOnAccInvoice  = new ProjTransOnAccInvoice(_projInvoiceOnAcc);

        return projTransOnAccInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjInvoiceOnAccSale</Name>
				<Source><![CDATA[
    public static ProjTrans newProjInvoiceOnAccSale(ProjInvoiceOnAcc  _projInvoiceOnAcc, ProjInvoiceOnAccDetail  _projInvoiceOnAccDetail)
    {
        ProjTrans   projTransOnAccInvoiceSale;

        projTransOnAccInvoiceSale  = new ProjTransOnAccInvoiceSale(_projInvoiceOnAcc, _projInvoiceOnAccDetail);

        return projTransOnAccInvoiceSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjInvoiceRevenue</Name>
				<Source><![CDATA[
    public static ProjTrans newProjInvoiceRevenue(ProjInvoiceRevenue  _projInvoiceRevenue)
    {
        ProjTrans   projTransRevenueInvoice;

        projTransRevenueInvoice  = new ProjTransRevenueInvoice(_projInvoiceRevenue);

        return projTransRevenueInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjInvoiceRevenueSale</Name>
				<Source><![CDATA[
    public static ProjTrans newProjInvoiceRevenueSale(ProjInvoiceRevenue  _projInvoiceRevenue, ProjInvoiceRevenueDetail  _projInvoiceRevenueDetail)
    {
        ProjTrans   projTransRevenueInvoiceSale;

        projTransRevenueInvoiceSale  = new ProjTransRevenueInvoiceSale(_projInvoiceRevenue, _projInvoiceRevenueDetail);

        return projTransRevenueInvoiceSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjItemProdJournalBOM</Name>
				<Source><![CDATA[
    public static ProjTrans newProjItemProdJournalBOM(ProdJournalBOM  _prodJournalBOM)
    {
        ProjTrans   projTransItemProdJournalBOM;

        projTransItemProdJournalBOM  = new ProjTransItemProdJournalBOM(_prodJournalBOM);

        return projTransItemProdJournalBOM;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjItemProdTable</Name>
				<Source><![CDATA[
    public static ProjTrans newProjItemProdTable(ProdTable  _prodTable)
    {
        ProjTrans   projTransItemProdTable;

        projTransItemProdTable  = new ProjTransItemProdTable(_prodTable);

        return projTransItemProdTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjItemPurchLine</Name>
				<Source><![CDATA[
    public static ProjTrans newProjItemPurchLine(PurchLine  _purchLine)
    {
        ProjTrans   projTransItemPurchLine;

        projTransItemPurchLine  = new ProjTransItemPurchLine(_purchLine);

        return projTransItemPurchLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjItemTrans</Name>
				<Source><![CDATA[
    public static ProjTrans newProjItemTrans(ProjItemTrans  _projItemTrans)
    {
        ProjTrans   projTransItemTrans;

        projTransItemTrans  = new ProjTransItemTrans(_projItemTrans);

        return projTransItemTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjItemTransCost</Name>
				<Source><![CDATA[
    public static ProjTrans newProjItemTransCost(ProjItemTransCost  _projItemTransCost)
    {
        ProjTrans       projTransItemTransCost;
        ProjItemTrans   projItemTrans;

        projItemTrans = ProjItemTrans::findInvent(_projItemTransCost.InventTransId,_projItemTransCost.ProjAdjustRefId);
        projTransItemTransCost  = new ProjTransItemTransCost(projItemTrans, _projItemTransCost);

        return projTransItemTransCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjItemTransSale</Name>
				<Source><![CDATA[
    public static ProjTrans newProjItemTransSale(ProjItemTrans _projItemTrans, ProjItemTransSale _projItemTransSale)
    {
        ProjTrans   projTransItemTransSale;

        projTransItemTransSale  = new ProjTransItemTransSale(_projItemTrans, _projItemTransSale);

        return projTransItemTransSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjJournalTrans</Name>
				<Source><![CDATA[
    public static ProjTrans newProjJournalTrans(ProjJournalTrans _projJournalTrans, PSAContractLineNum _psaContractLineNum = '')
    {
        ProjTrans   projTransJournalTrans;

        if (_projJournalTrans.projJournalTable().JournalType == ProjJournalType::Hour)
        {
            projTransJournalTrans  = new ProjTransEmplJournal(_projJournalTrans);
        }
        else
        {
            projTransJournalTrans   = new ProjTransRevenueJournal(_projJournalTrans, _psaContractLineNum);
        }

        return projTransJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjOnAccTrans</Name>
				<Source><![CDATA[
    public static ProjTrans newProjOnAccTrans(ProjOnAccTrans  _projOnAccTrans)
    {
        ProjTrans   projTransOnAccTrans;

        projTransOnAccTrans  = new ProjTransOnAccTrans(_projOnAccTrans);

        return projTransOnAccTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjOnAccTransSale</Name>
				<Source><![CDATA[
    public static ProjTrans newProjOnAccTransSale(ProjOnAccTrans _projOnAccTrans, ProjOnAccTransSale _projOnAccTransSale)
    {
        ProjTrans   projTransOnAccTransSale;

        projTransOnAccTransSale  = new ProjTransOnAccTransSale(_projOnAccTrans, _projOnAccTransSale);

        return projTransOnAccTransSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProposalCost</Name>
				<Source><![CDATA[
    public static ProjTrans newProjProposalCost(ProjProposalCost  _projProposalCost)
    {
        ProjTrans   projTransCostProposal;

        projTransCostProposal  = new ProjTransCostProposal(_projProposalCost);

        return projTransCostProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProposalCostCost</Name>
				<Source><![CDATA[
    public static ProjTrans newProjProposalCostCost(ProjProposalCost  _projProposalCost, ProjProposalCostDetail  _projProposalCostDetail, ProjCostTransCost _projCostTransCost, ProjTransStatus _saleTransStatus)
    {
        ProjTrans   projTransCostProposalCost;

        projTransCostProposalCost  = new ProjTransCostProposalCost(_projProposalCost, _projProposalCostDetail, _projCostTransCost, _saleTransStatus);

        return projTransCostProposalCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProposalCostSale</Name>
				<Source><![CDATA[
    public static ProjTrans newProjProposalCostSale(ProjProposalCost  _projProposalCost, ProjProposalCostDetail  _projProposalCostDetail, ProjCostTransSale _projCostTransSale)
    {
        ProjTrans   projTransCostProposalSale;

        projTransCostProposalSale  = new ProjTransCostProposalSale(_projProposalCost, _projProposalCostDetail, _projCostTransSale);

        return projTransCostProposalSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProposalEmpl</Name>
				<Source><![CDATA[
    public static ProjTrans newProjProposalEmpl(ProjProposalEmpl  _projProposalEmpl)
    {
        ProjTrans   projTransEmplProposal;

        projTransEmplProposal  = new ProjTransEmplProposal(_projProposalEmpl);

        return projTransEmplProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProposalEmplCost</Name>
				<Source><![CDATA[
    public static ProjTrans newProjProposalEmplCost(ProjProposalEmpl  _projProposalEmpl, ProjProposalEmplDetail  _projProposalEmplDetail, ProjEmplTransCost _projEmplTransCost, ProjTransStatus _saleTransStatus)
    {
        ProjTrans   projTransEmplProposalCost;

        projTransEmplProposalCost  = new ProjTransEmplProposalCost(_projProposalEmpl, _projProposalEmplDetail, _projEmplTransCost, _saleTransStatus);

        return projTransEmplProposalCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProposalEmplSale</Name>
				<Source><![CDATA[
    public static ProjTrans newProjProposalEmplSale(ProjProposalEmpl  _projProposalEmpl, ProjProposalEmplDetail  _projProposalEmplDetail, ProjEmplTransSale _projEmplTransSale)
    {
        ProjTrans   projTransEmplProposalSale;

        projTransEmplProposalSale  = new ProjTransEmplProposalSale(_projProposalEmpl, _projProposalEmplDetail, _projEmplTransSale);

        return projTransEmplProposalSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProposalItem</Name>
				<Source><![CDATA[
    public static ProjTrans newProjProposalItem(ProjProposalItem  _projProposalItem)
    {
        ProjTrans   projTransItemProposal;

        if (_projProposalItem.ItemType  == ProjItemType::SalesOrder)
        {
            projTransItemProposal =  new ProjTransItemProposal_SalesOrder   (_projProposalItem);
        }
        else
        {
            projTransItemProposal =  new ProjTransItemProposal_Project(_projProposalItem);
        }

        return projTransItemProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProposalItemCost</Name>
				<Source><![CDATA[
    public static ProjTrans newProjProposalItemCost(ProjProposalItem  _projProposalItem, ProjProposalItemDetail  _projProposalItemDetail, ProjItemTransCost _projItemTransCost, ProjTransStatus _saleTransStatus)
    {
        ProjTrans   projTransItemProposalCost_Project;

        projTransItemProposalCost_Project  = new ProjTransItemProposalCost_Project(_projProposalItem, _projProposalItemDetail, _projItemTransCost, _saleTransStatus);

        return projTransItemProposalCost_Project;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProposalItemSale</Name>
				<Source><![CDATA[
    public static ProjTrans newProjProposalItemSale(ProjProposalItem _projProposalItem, ProjProposalItemDetail _projProposalItemDetail, ProjItemTransSale _projItemTransSale = null)
    {
        ProjTrans projTrans;

        if (_projProposalItem.ItemType == ProjItemType::SalesOrder)
        {
            projTrans = new ProjTransItemProposalSale_SalesOrder(_projProposalItem, _projProposalItemDetail);
        }
        else
        {
            projTrans = new ProjTransItemProposalSale_Project(_projProposalItem, _projProposalItemDetail, _projItemTransSale);
        }

        return projTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProposalItemSale_Project</Name>
				<Source><![CDATA[
    public static ProjTrans newProjProposalItemSale_Project(ProjProposalItem  _projProposalItem, ProjProposalItemDetail  _projProposalItemDetail, ProjItemTransSale _projItemTransSale)
    {
        ProjTrans   projTransItemProposalSale_Project;

        projTransItemProposalSale_Project  = new ProjTransItemProposalSale_Project(_projProposalItem, _projProposalItemDetail, _projItemTransSale);

        return projTransItemProposalSale_Project;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProposalItemSale_SalesOrder</Name>
				<Source><![CDATA[
    public static ProjTrans newProjProposalItemSale_SalesOrder(ProjProposalItem  _projProposalItem, ProjProposalItemDetail  _projProposalItemDetail)
    {
        ProjTrans   projTransItemProposalSale_SalesOrder;

        projTransItemProposalSale_SalesOrder  = new ProjTransItemProposalSale_SalesOrder(_projProposalItem, _projProposalItemDetail);

        return projTransItemProposalSale_SalesOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProposalOnAcc</Name>
				<Source><![CDATA[
    public static ProjTrans newProjProposalOnAcc(ProjProposalOnAcc  _projProposalOnAcc)
    {
        ProjTrans   projTransOnAccProposal;

        projTransOnAccProposal =  new ProjTransOnAccProposal(_projProposalOnAcc);

        return projTransOnAccProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProposalOnAccSale</Name>
				<Source><![CDATA[
    public static ProjTrans newProjProposalOnAccSale(ProjProposalOnAcc  _projProposalOnAcc, ProjProposalOnAccDetail  _projProposalOnAccDetail, ProjOnAccTransSale _projOnAccTransSale)
    {
        ProjTrans   projTransOnAccProposalSale;

        projTransOnAccProposalSale  = new ProjTransOnAccProposalSale(_projProposalOnAcc, _projProposalOnAccDetail, _projOnAccTransSale);

        return projTransOnAccProposalSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProposalRevenue</Name>
				<Source><![CDATA[
    public static ProjTrans newProjProposalRevenue(ProjProposalRevenue  _projProposalRevenue)
    {
        ProjTrans   projTransRevenueProposal;

        projTransRevenueProposal  = new ProjTransRevenueProposal(_projProposalRevenue);

        return projTransRevenueProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProposalRevenueSale</Name>
				<Source><![CDATA[
    public static ProjTrans newProjProposalRevenueSale(ProjProposalRevenue  _projProposalRevenue, ProjProposalRevenueDetail  _projProposalRevenueDetail, ProjRevenueTransSale _projRevenueTransSale)
    {
        ProjTrans   projTransRevenueProposalSale;

        projTransRevenueProposalSale  = new ProjTransRevenueProposalSale(_projProposalRevenue, _projProposalRevenueDetail, _projRevenueTransSale);

        return projTransRevenueProposalSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjRevenueTrans</Name>
				<Source><![CDATA[
    public static ProjTrans newProjRevenueTrans(ProjRevenueTrans  _projRevenueTrans)
    {
        ProjTrans   projTransRevenueTrans;

        projTransRevenueTrans  = new ProjTransRevenueTrans(_projRevenueTrans);

        return projTransRevenueTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjRevenueTransSale</Name>
				<Source><![CDATA[
    public static ProjTrans newProjRevenueTransSale(ProjRevenueTrans _projRevenueTrans, ProjRevenueTransSale _projRevenueTransSale)
    {
        ProjTrans   projTransRevenueTransSale;

        projTransRevenueTransSale  = new ProjTransRevenueTransSale(_projRevenueTrans, _projRevenueTransSale);

        return projTransRevenueTransSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjTransCostTransCostAdj</Name>
				<Source><![CDATA[
    public static ProjTrans newProjTransCostTransCostAdj(ProjCostTrans _projCostTrans, TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost)
    {
        ProjTrans   projTransCostTransCostAdj;

        projTransCostTransCostAdj  = new ProjTransCostTransCostAdj(_projCostTrans, _tmpProjAdjustmentCreateCost);

        return projTransCostTransCostAdj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjTransCostTransSaleAdj</Name>
				<Source><![CDATA[
    public static ProjTrans newProjTransCostTransSaleAdj(ProjCostTrans _projCostTrans, TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale)
    {
        ProjTrans   projTransCostTransSaleAdj;

        projTransCostTransSaleAdj  = new ProjTransCostTransSaleAdj(_projCostTrans, _tmpProjAdjustmentCreateSale);

        return projTransCostTransSaleAdj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjTransEmplTransCostAdj</Name>
				<Source><![CDATA[
    public static ProjTrans newProjTransEmplTransCostAdj(ProjEmplTrans _projEmplTrans, TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost)
    {
        ProjTrans   projTransEmplTransCostAdj;

        projTransEmplTransCostAdj  = new ProjTransEmplTransCostAdj(_projEmplTrans, _tmpProjAdjustmentCreateCost);

        return projTransEmplTransCostAdj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjTransEmplTransSaleAdj</Name>
				<Source><![CDATA[
    public static ProjTrans newProjTransEmplTransSaleAdj(ProjEmplTrans _projEmplTrans, TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale)
    {
        ProjTrans   projTransEmplTransSaleAdj;

        projTransEmplTransSaleAdj  = new ProjTransEmplTransSaleAdj(_projEmplTrans, _tmpProjAdjustmentCreateSale);

        return projTransEmplTransSaleAdj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjTransItemTransCostAdj</Name>
				<Source><![CDATA[
    public static ProjTrans newProjTransItemTransCostAdj(ProjItemTrans _projItemTrans, TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost)
    {
        ProjTrans   projTransItemTransCostAdj;

        projTransItemTransCostAdj  = new ProjTransItemTransCostAdj(_projItemTrans, _tmpProjAdjustmentCreateCost);

        return projTransItemTransCostAdj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjTransProdBOMTransProj</Name>
				<Source><![CDATA[
    public static ProjTrans newProjTransProdBOMTransProj(ProdBOMTransProj  _prodBOMTransProj)
    {
        ProjTransProdBOMTransProj   projTransProdBOMTransProj;

        projTransProdBOMTransProj  = new ProjTransProdBOMTransProj(_prodBOMTransProj);

        return projTransProdBOMTransProj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjTransProdInvent</Name>
				<Source><![CDATA[
    public static ProjTrans newProjTransProdInvent(ProdTableProj  _prodTableProj, InventTransId _inventTransId = '')
    {
        ProjTransProdInvent   projTransProdInvent;

        projTransProdInvent  = new ProjTransProdInvent(_prodTableProj);
        projTransProdInvent.parmInventTransId(_inventTransId);

        return projTransProdInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjTransRevenueTransSaleAdj</Name>
				<Source><![CDATA[
    public static ProjTrans newProjTransRevenueTransSaleAdj(ProjRevenueTrans _projRevenueTrans, TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale)
    {
        ProjTrans   projTransRevenueTransSaleAdj;

        projTransRevenueTransSaleAdj  = new ProjTransRevenueTransSaleAdj(_projRevenueTrans, _tmpProjAdjustmentCreateSale);

        return projTransRevenueTransSaleAdj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPSAProjTransEmplIndirectSales</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new instance of <c>PSAProjTransEmplIndirectSalesAccrued</c> class.
    /// </summary>
    /// <param name="_projEmplTrans">
    /// A <c>ProjEmplTrans</c> record.
    /// </param>
    /// <param name="_projEmplTransSale">
    /// A <c>ProjEmplTransSale</c> record.
    /// </param>
    /// <returns>
    /// An instance of the <c>ProjTrans</c> class.
    /// </returns>
    public static ProjTrans newPSAProjTransEmplIndirectSales(ProjEmplTrans _projEmplTrans, ProjEmplTransSale _projEmplTransSale)
    {
        ProjTrans   psaProjTransEmplIndirectSalesAccrued;

        psaProjTransEmplIndirectSalesAccrued  = new PSAProjTransEmplIndirectSalesAccrued(_projEmplTrans, _projEmplTransSale);

        return psaProjTransEmplIndirectSalesAccrued;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newSalesLine</Name>
				<Source><![CDATA[
    public static ProjTrans newSalesLine(SalesLine  _salesLine)
    {
        ProjTrans   projTransSalesLine;

        projTransSalesLine  = new ProjTransSalesLine(_salesLine);

        return projTransSalesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newSMAAccruePeriodLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new subscription accrual period transaction.
    /// </summary>
    /// <param name="_smaAccruePeriodLine">
    ///    A subscription accrual period line.
    /// </param>
    /// <returns>
    ///    The new transaction instance.
    /// </returns>
    public static ProjTrans newSMAAccruePeriodLine(SMAAccruePeriodLine  _smaAccruePeriodLine)
    {
        ProjTrans   projTransRevenueTrans;

        projTransRevenueTrans  = new ProjTransSMAAccruePeriodLine(_smaAccruePeriodLine);

        return projTransRevenueTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTmpProjAdjustmentCreate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a new instance of <c>ProjTrans</c> for item adjustment type.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentCreate">
    ///     A <c>TmpProjAdjustmentCreate</c> table buffer.
    /// </param>
    /// <returns>
    ///     An instance of <c>ProjTrans</c>.
    /// </returns>
    public static ProjTrans newTmpProjAdjustmentCreate(TmpProjAdjustmentCreate  _tmpProjAdjustmentCreate)
    {
        ProjTrans   projTransItemPackingSlipAdjust;

        if (_tmpProjAdjustmentCreate.checkAdjustmentType(ProjAdjustmentType::Item))
        {
            projTransItemPackingSlipAdjust  = new ProjTransItemPackingSlipAdjust(_tmpProjAdjustmentCreate);
        }

        return projTransItemPackingSlipAdjust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTmpProjAdjustmentCreateSale</Name>
				<Source><![CDATA[
   /// <summary>
   ///     Creates a new instance of <c>ProjTrans</c> for item adjustment type.
   /// </summary>
   /// <param name = "_tmpProjAdjustmentCreate">
   ///     A <c>TmpProjAdjustmentCreate</c> table buffer.
   /// </param>
   /// <param name = "_tmpProjAdjustmentCreateSale">
   ///     A <c>TmpProjAdjustmentCreateSale</c> table buffer.
   /// </param>
   /// <returns>
   ///     An instance of <c>ProjTrans</c>.
   /// </returns>
    public static ProjTrans newTmpProjAdjustmentCreateSale(TmpProjAdjustmentCreate  _tmpProjAdjustmentCreate, TmpProjAdjustmentCreateSale  _tmpProjAdjustmentCreateSale)
    {
        ProjTrans   projTransItemPackingSlipSaleAdjust;

        if (_tmpProjAdjustmentCreate.checkAdjustmentType(ProjAdjustmentType::Item))
        {
            projTransItemPackingSlipSaleAdjust  = new ProjTransItemPackingSlipSaleAdjust(_tmpProjAdjustmentCreate, _tmpProjAdjustmentCreateSale);
        }

        return projTransItemPackingSlipSaleAdjust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postedOperationsValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Totals the profit and loss posted amount of the financially-updated virtual inventory transactions.
    /// </summary>
    /// <param name="_inventTransId">
    ///    The inventory lot ID.
    /// </param>
    /// <param name="_projAdjustRefId">
    ///    The project adjustment number.
    /// </param>
    /// <returns>
    ///    The profit and loss posted amount of the financially updated virtual inventory transactions.
    /// </returns>
    public static CostAmount postedOperationsValue(InventTransId _inventTransId, ProjAdjustRefId _projAdjustRefId)
    {
        InventTrans         inventTrans;
        InventTransOriginId inventTransOriginId;

        inventTransOriginId = InventTransOrigin::findByInventTransId(_inventTransId).RecId;

        select sum(CostAmountOperations) from inventTrans
            where inventTrans.InventTransOrigin ==  inventTransOriginId &&
                  inventTrans.ProjAdjustRefId   ==  _projAdjustRefId;

        return inventTrans.CostAmountOperations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postedPhysicalValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the total physical cost amount of a project inventory transaction.
    /// </summary>
    /// <param name="_financial">
    ///    The financial update.
    /// </param>
    /// <returns>
    ///    The total physical cost amount of a project inventory transaction.
    /// </returns>
    public static CostAmount postedPhysicalValue(InventUpd_Financial _financial)
    {
        InventTrans         inventTrans;

        select sum(CostAmountPhysical) from inventTrans
            where inventTrans.InventTransOrigin ==  _financial.movement().inventTransOriginId() &&
                  inventTrans.Voucher           ==  _financial.parmLedgerVoucher().lastVoucher() &&
                  inventTrans.ProjAdjustRefId   ==  _financial.movement().projAdjustRefId();

        return inventTrans.CostAmountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTransTurnoverHandler</Name>
				<Source><![CDATA[
    [PostHandlerFor(classStr(ProjTrans), methodStr(ProjTrans, transTurnover))]
    /// <summary>
    /// The handler method that runs after the method <c>transTurnover</c> is complete, and indicates
    /// whether to call the <c>postTransTurnover</c> method and may change the return value of the
    /// <c>transTurnover</c> method.
    /// </summary>
    /// <param name="_args">
    /// The <c>XppPrePostArgs</c> object for this event handler.
    /// </param>
    /// <remarks>
    /// The return value is only modified if the <c>BrazilParameters</c> property is enabled.
    /// </remarks>
    public static void postTransTurnoverHandler(XppPrePostArgs _args)
    {
        ProjTrans projTrans = _args.getThis();
        anytype returnValue;

        if (!BrazilParameters::isEnabled())
        {
            return;
        }
        // <GBR>
        returnValue = projTrans.postTransTurnover(_args.getReturnValue());

        _args.setReturnValue(returnValue);
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaNewProjEmplIndirecTrans</Name>
				<Source><![CDATA[
    // Description    : initiate project tansaction
    public static ProjTrans psaNewProjEmplIndirecTrans(PSAIndirectComponentTrans  _tIndirectComponentTrans)
    {
        return  new PSAProjTransEmplIndirect(_tIndirectComponentTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaProjTransFindAdjustment</Name>
				<Source><![CDATA[
    public static ProjTrans psaProjTransFindAdjustment(ProjTrans _oProjTrans)
    {
        ProjCostTrans       tProjCostTrans;
        ProjCostTransCost   tProjCostTransCost;
        ProjEmplTrans       tProjEmplTrans;
        ProjEmplTransCost   tProjEmplTransCost;
        ProjItemTrans       tProjItemTrans;
        ProjItemTransCost   tProjItemTransCost;
        ProjRevenueTrans    tProjRevenueTrans;
        ProjRevenueTransSale tProjRevenueTransSale;
        ProjTrans       oRetProjTrans;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            switch (_oProjTrans.transType())
            {
                case ProjTransType::Cost:
                select firstonly tProjCostTrans
                    where tProjCostTrans.psaProjOrigTransId == _oProjTrans.psaOrigTransId()
                join TransStatus from tProjCostTransCost
                    where tProjCostTransCost.TransStatus == ProjTransStatus::Adjusted
                       && tProjCostTrans.Qty < 0;

                    oRetProjTrans = ProjTrans::construct(tProjCostTrans);
                    break;

                case ProjTransType::Hour:
                select firstonly tProjEmplTrans
                    where tProjEmplTrans.psaProjOrigTransId == _oProjTrans.psaOrigTransId()
                join TransStatus from tProjEmplTransCost
                    where tProjEmplTransCost.TransStatus == ProjTransStatus::Adjusted
                    &&    tProjEmplTrans.Qty < 0;

                    oRetProjTrans = ProjTrans::construct(tProjEmplTrans);
                    break;

                case ProjTransType::Item:
                select firstonly tProjItemTrans
                    where tProjItemTrans.psaProjOrigTransId == _oProjTrans.psaOrigTransId()
                join  TransStatus from tProjItemTransCost
                    where tProjItemTransCost.TransStatus == ProjTransStatus::Adjusted
                    &&    tProjItemTrans.Qty < 0;

                    oRetProjTrans = ProjTrans::construct(tProjItemTrans);
                    break;

                case ProjTransType::Revenue:
                select firstonly tProjRevenueTrans
                    where tProjRevenueTrans.psaProjOrigTransId == _oProjTrans.psaOrigTransId()
                join  TransStatus from tProjRevenueTransSale
                    where tProjRevenueTransSale.TransStatus == ProjTransStatus::Adjusted
                    &&    tProjRevenueTransSale.SalesPrice < 0;

                    oRetProjTrans = ProjTrans::construct(tProjRevenueTrans);
                    break;
            }
        }

        return oRetProjTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyCostAccountLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for intercompany cost that will be used by this transaction.
    /// </summary>
    /// <param name="_fundingSourceID">
    /// The funding source that is associated with the project contract that will be used by this
    /// transaction.
    /// </param>
    /// <param name="throwerror">
    /// A Boolean value that determines whether to throw an exception if a cost account cannot be found;
    /// optional.
    /// </param>
    /// <returns>
    /// The ledger dimension for cost.
    /// </returns>
    public LedgerDimensionDefaultAccount intercompanyCostAccountLedgerDimension(ProjFundingSourceRefId _fundingSourceID, boolean throwerror = true)
    {
        return ProjPosting::getLedgerDimension(ProjAccountType::IntercompanyCost,
                                               this.projId(),
                                               this.categoryId(),
                                               _fundingSourceID,
                                               false,
                                               throwerror,
                                                '',
                                               this.lendingLegalEntity());
    }

]]></Source>
			</Method>
			<Method>
				<Name>lendingLegalEntity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the lendingLegalEntity for the intercompany transaction.
    /// </summary>
    /// <returns>
    /// The lendingLegalEntity value.
    /// </returns>
    /// <remarks>
    /// This abstract method must be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    protected abstract DataAreaId lendingLegalEntity()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyVendAccountLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for the vendor balance posting type to be used by this transaction.
    /// </summary>
    /// <param name="_workerCompany">
    /// The company where the transaction originated.
    /// </param>
    /// <returns>
    /// The ledger dimension for vendor balance.
    /// </returns>
    public LedgerDimensionDefaultAccount intercompanyVendAccountLedgerDimension(CompanyInfoRecId _workerCompany)
    {
        CompanyInfo                 workerCompany;
        InterCompanyTradingPartner  tradingCustomer;
        InterCompanyTradingPartner  tradingVendor;
        InterCompanyTradingRelation tradingRelation;
        VendTable                   vendTable;

        workerCompany = CompanyInfo::find(false, _workerCompany);

        // We need to find the vendor that represents the lending (worker's) legal entity.
        // For performance reasons we use a single select instead of going through a series of find()
        // calls, also considering that we're only interested in the vendor's account number.
        select firstOnly AccountNum from vendTable
            exists join tradingVendor
            where tradingVendor.VendorParty         == vendTable.Party &&
                  tradingVendor.VendorDataAreaId    == curext()
            exists join tradingRelation
            where tradingRelation.InterCompanyTradingVendor == tradingVendor.RecId &&
                  tradingRelation.Active                    == true
            exists join tradingCustomer
            where tradingCustomer.RecId                 == tradingRelation.InterCompanyTradingCustomer &&
                  tradingCustomer.CustomerDataAreaId    == workerCompany.DataArea;

        if (!vendTable.AccountNum)
        {
            throw error(strFmt("@SYS4005055", workerCompany.DataArea));
        }

        return VendLedgerAccounts::summaryLedgerDimension(vendTable.AccountNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIntercompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the transaction was originally generated in another company.
    /// </summary>
    /// <returns>
    /// true if the transaction is intercompany; false otherwise.
    /// </returns>
    /// <remarks>
    /// Examples of intercompany transactions are hours or expenses posted by employees of other legal
    /// entities working on behalf of the company that owns the contract.
    /// </remarks>
    public boolean isIntercompany()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustHandleActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether activity control is enabled.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    /// <remarks>
    /// This method will be overridden by child classes to return true if activity control is required.
    /// </remarks>
    public boolean mustHandleActivity()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fromTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the from time value for the transaction.
    /// </summary>
    /// <returns>
    /// From time of the transaction
    /// </returns>
    /// <remarks>
    /// This method must be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public ProjFromTime fromTime()
    {
        ProjFromTime ret;
		
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the to time value for the transaction.
    /// </summary>
    /// <returns>
    /// To time of the transaction
    /// </returns>
    /// <remarks>
    /// This method must be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public ProjToTime toTime()
    {
        ProjToTime ret;
		
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCostAmount</Name>
				<Source><![CDATA[
    public AmountCur parmCostAmount(AmountCur _costAmount = costAmount)
    {
        costAmount = _costAmount;

        return costAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWIPProject</Name>
				<Source><![CDATA[
    public ProjWIPTable getWIPProject()
    {
        ProjWIPTable wipProject;
        if (!contractLineBasedRevRecFeature)
        {
            return ProjWIPTable::find(this.projId());
        }

        ProjRevenueTransSale projRevenueTransSale;
        switch(this.tableId())
        {
            case tableNum(ProjEmplTrans):
            case tableNum(ProjCostTrans):
            case tableNum(ProjItemTrans):
            case tableNum(ProjEmplTransCost):
            case tableNum(ProjCostTransCost):
            case tableNum(ProjItemTransCost):
            case tableNum(ProjEmplTransSale):
            case tableNum(ProjCostTransSale):
            case tableNum(ProjItemTransSale):
            case tableNum(ProjOnAccTrans):
            case tableNum(ProjOnAccTransSale):
                wipProject = ProjWIPTable::find(ProjRevRecContractLine::findByContractLineNum(this.psaContractLineNum()).RevenueRecognitionId);
                break;
            case tableNum(ProjControlPeriodTrans):
            case tableNum(ProjControlPeriodTable):
                ProjId       projId = this.projId();
                wipProject = ProjWIPTable::find(projId);
                break;
            case tableNum(ProjRevenueTrans):
                select firstonly WIPProjId from projRevenueTransSale
                    where projRevenueTransSale.TransId == this.transId();
                wipProject = ProjWIPTable::find(projRevenueTransSale.WIPProjId);
                break;
            case tableNum(ProjRevenueTransSale):
                select firstonly WIPProjId from projRevenueTransSale
                    where projRevenueTransSale.TransId == this.transId();
                wipProject = ProjWIPTable::find(projRevenueTransSale.WIPProjId);
                break;
        }
        return wipProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markedInventTransId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the marked <c>InventTrans</c> ID.
    /// </summary>
    /// <returns>
    ///    An empty string.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by classes that extend this class to provide the necessary
    ///    functionality for the specific transaction.
    /// </remarks>
    public InventTransId markedInventTransId()
    {
        return '';
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>