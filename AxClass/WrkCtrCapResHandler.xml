<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WrkCtrCapResHandler</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The class <c>WrkCtrCapResHandler</c> class can be used to retrieve information about resource
/// capacity reservations.
/// </summary>
public class WrkCtrCapResHandler
{
    boolean limitCapPO;
    boolean limitCapProd;
    boolean limitCapProject;
    RecId   planVersion;
    
    SysDictTable            capResDictTable;

    FieldId                 wrkCtrCapResRecId;
    FieldId                 wrkCtrCapResDataAreaId;
    FieldId                 wrkCtrCapResPlanVersion;
    FieldId                 loadType;
    FieldId                 transDate;
    FieldId                 wrkCtrLoadPct;
    FieldId                 wrkCtrSec;
    FieldId                 timestamp;
    FieldId                 endTime;
    FieldId                 startTime;
    FieldId                 wrkCtrId;
    FieldId                 refType;

    FieldId                 schedulingPropertyId;

    boolean                 usePessimisticReadLock;
    boolean                 hasTakenReadLock;

    private const str       transactionScopeCacheKey = 'IsSubscribed';
    private const str       transactionScopeRecursionKey = 'IsRecursion';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addCapResQueryIndex</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add a relevant index to the capacity reservation query data source.
    /// </summary>
    /// <param name="_capResDataSource">
    /// The data source that refers to the capacity reservations table.
    /// </param>
    protected void addCapResQueryIndex(QueryBuildDataSource _capResDataSource)
    {
        _capResDataSource.addSortIndex(indexNum(WrkCtrCapRes, WrkCtrIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>capResPropertyTableFieldId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the field id of the field that corresponds
    /// to the given WrkCtrCapResProperty field.
    /// </summary>
    /// <param name="_fieldId">
    /// The id of the WrkCtrCapResProperty table field to convert.
    /// </param>
    /// <returns>
    /// The corresponding field in the table returned by capResPropertyTableId().
    /// </returns>
    protected FieldId capResPropertyTableFieldId(FieldId _fieldId)
    {
        return _fieldId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>capResPropertyTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the table id of the capacity reservation properties table.
    /// </summary>
    /// <returns>
    /// The table id of the capacity reservation properties table.
    /// </returns>
    protected TableId capResPropertyTableId()
    {
        return tableNum(WrkCtrCapResProperty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>capResTableFieldId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the field id of the field that corresponds
    /// to the given WrkCtrCapRes field.
    /// </summary>
    /// <param name="_fieldId">
    /// The id of the WrkCtrCapRes table field to convert.
    /// </param>
    /// <returns>
    /// The corresponding field in the table returned by capResTableId().
    /// </returns>
    protected FieldId capResTableFieldId(FieldId _fieldId)
    {
        return _fieldId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>capResTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the table id of the capacity reservations table.
    /// </summary>
    /// <returns>
    /// The table id of the capacity reservations table.
    /// </returns>
    protected TableId capResTableId()
    {
        return tableNum(WrkCtrCapRes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteOrderReservations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes capacity reservations for a given order/reference.
    /// </summary>
    /// <param name="_refType">
    /// The reference type (Production, Planned Production, Project).
    /// </param>
    /// <param name="_refNum">
    /// The reference (order) ID.
    /// </param>
    /// <param name="_oprNum">
    /// An operation number to filter on when deleting the capacity reservations; optional.
    /// </param>
    /// <param name="_planVersion">
    /// The plan version to delete the reservations from; optional.
    /// </param>
    /// <param name="_jobId">
    /// A job ID to filter on when deleting the capacity reservations; optional.
    /// </param>
    public void deleteOrderReservations(
            WrkCtrCapRefType        _refType,
            WrkCtrRefId             _refNum,
            OprNum                  _oprNum         = 0,
            RefRecId                _planVersion    = 0
            , ProdJobId               _jobId        = ''
            )
    {
        WrkCtrCapRes            wrkCtrCapRes;
        WrkCtrCapResProperty    wrkCtrCapResProperty;

        wrkCtrCapRes.skipDataMethods(true);
        wrkCtrCapRes.skipDeleteActions(true);

        if (_refType != WrkCtrCapRefType::PlannedOrder)
        {
            _planVersion = 0;
        }
        
        ttsbegin;

        delete_from wrkCtrCapResProperty
            exists join wrkCtrCapRes
                where   wrkCtrCapRes.RecId          == wrkCtrCapResProperty.CapResRefRecId  &&
                        wrkCtrCapRes.PlanVersion    == _planVersion                         &&
                        wrkCtrCapRes.RefType        == _refType                             &&
                        wrkCtrCapRes.RefId          == _refNum                              &&
                        (wrkCtrCapRes.OprNum        == _oprNum || !_oprNum)                 &&
                        (wrkCtrCapRes.JobId         == _jobId  || !_jobId)                  &&
                        wrkCtrCapRes.LoadType       != WrkCtrCapacityType::Deletemarked;

        delete_from wrkCtrCapRes
            where   wrkCtrCapRes.PlanVersion    == _planVersion                         &&
                    wrkCtrCapRes.RefType        == _refType                             &&
                    wrkCtrCapRes.RefId          == _refNum                              &&
                    (wrkCtrCapRes.OprNum        == _oprNum || !_oprNum)                 &&
                    (wrkCtrCapRes.JobId         == _jobId  || !_jobId)                  &&
                    wrkCtrCapRes.LoadType       != WrkCtrCapacityType::Deletemarked;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildHasNewCapacityReservationQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for checking if there is a new reservation for the given session id.
    /// </summary>
    /// <param name = "_conflictCheckSessionId">A <c>guid</c> value.</param>
    /// <returns>A <c>Query</c> object for reservation calculation for the individual resources.</returns>
    protected Query buildHasNewCapacityReservationQuery(guid _conflictCheckSessionId)
    {
        Query query = new Query();

        QueryBuildDataSource qbdsWrkCtrCapResConflictCheck = query.addDataSource(tableNum(WrkCtrCapResConflictCheck));
        qbdsWrkCtrCapResConflictCheck.addRange(fieldNum(WrkCtrCapResConflictCheck, SessionId)).value(queryValue(_conflictCheckSessionId));
        qbdsWrkCtrCapResConflictCheck.addSelectionField(fieldNum(WrkCtrCapResConflictCheck, RecId));
        qbdsWrkCtrCapResConflictCheck.firstOnly(true);

        QueryBuildDataSource qbdsWrkCtrCapRes = qbdsWrkCtrCapResConflictCheck.addDataSource(tableNum(WrkCtrCapRes));
        qbdsWrkCtrCapRes.relations(false);
        qbdsWrkCtrCapRes.joinMode(JoinMode::ExistsJoin);
        qbdsWrkCtrCapRes.addLink(fieldNum(WrkCtrCapRes, WrkCtrId), fieldNum(WrkCtrCapResConflictCheck, ResourceId));

        str endTimeRange = this.buildEndTimeRangeForHasNewCapacityReservationQuery(query, qbdsWrkCtrCapRes);
        if (endTimeRange != '')
        {
            qbdsWrkCtrCapRes.addRange(fieldNum(WrkCtrCapRes, EndTime)).value(endTimeRange);
        }

        str startTimeRange = this.buildStartTimeRangeForHasNewCapacityReservationQuery(query, qbdsWrkCtrCapRes);
        if (startTimeRange != '')
        {
            qbdsWrkCtrCapRes.addRange(fieldNum(WrkCtrCapRes, StartTime)).value(startTimeRange);
        }

        str timeStampRange = this.buildTimeStampRangeForHasNewCapacityReservationQuery(query, qbdsWrkCtrCapRes);
        if (timeStampRange != '')
        {
            qbdsWrkCtrCapRes.addRange(fieldNum(WrkCtrCapRes, Timestamp)).value(timeStampRange);
        }

        str loadTypeRange = this.buildLoadTypeRangeForHasNewCapacityReservationQuery(query, qbdsWrkCtrCapRes);
        if (loadTypeRange != '')
        {
            qbdsWrkCtrCapRes.addRange(fieldNum(WrkCtrCapRes, LoadType)).value(loadTypeRange);
        }

        str refTypeRange = this.buildRefTypeRangeForHasNewCapacityReservationQuery(query, qbdsWrkCtrCapRes);
        if (refTypeRange != '')
        {
            qbdsWrkCtrCapRes.addRange(fieldNum(WrkCtrCapRes, RefType)).value(refTypeRange);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildEndTimeRangeForHasNewCapacityReservationQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the end time range for the query for building reservations on individual resources query.
    /// </summary>
    /// <param name = "_query">A <c>Query</c> object.</param>
    /// <param name = "_qbdsWrkCtrCapRes">A <c>QueryBuildDataSource</c> object.</param>
    /// <returns>A <c>str</c> value with the end time range.</returns>
    protected str buildEndTimeRangeForHasNewCapacityReservationQuery(Query _query, QueryBuildDataSource _qbdsWrkCtrCapRes)
    {
        return (strfmt('( (%1.%2 > %3.%4) || ((%1.%2 == %3.%4) && (%1.%5 > %3.%6)) )',
                _query.dataSourceTable(tableNum(WrkCtrCapRes)).name(),
                fieldStr(WrkCtrCapRes, TransDate),
                _query.dataSourceTable(tableNum(WrkCtrCapResConflictCheck)).name(),
                fieldStr(WrkCtrCapResConflictCheck, IntervalStartDate),
                fieldStr(WrkCtrCapRes, EndTime),
                fieldStr(WrkCtrCapResConflictCheck, IntervalStartTime)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildStartTimeRangeForHasNewCapacityReservationQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the start time related range for the query for building reservations on individual resources query.
    /// </summary>
    /// <param name = "_query">A <c>Query</c> object.</param>
    /// <param name = "_qbdsWrkCtrCapRes">A <c>QueryBuildDataSource</c> object.</param>
    /// <returns>A <c>str</c> value with the start time range.</returns>
    protected str buildStartTimeRangeForHasNewCapacityReservationQuery(Query _query, QueryBuildDataSource _qbdsWrkCtrCapRes)
    {
        return (strfmt('( (%1.%2 < %3.%4) || ((%1.%2 == %3.%4) && (%1.%5 < %3.%6)) )',
                _query.dataSourceTable(tableNum(WrkCtrCapRes)).name(),
                fieldStr(WrkCtrCapRes, TransDate),
                _query.dataSourceTable(tableNum(WrkCtrCapResConflictCheck)).name(),
                fieldStr(WrkCtrCapResConflictCheck, IntervalEndDate),
                fieldStr(WrkCtrCapRes, StartTime),
                fieldStr(WrkCtrCapResConflictCheck, IntervalEndTime)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildTimeStampRangeForHasNewCapacityReservationQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the timestamp range for the query for building reservations on individual resources query.
    /// </summary>
    /// <param name = "_query">A <c>Query</c> object.</param>
    /// <param name = "_qbdsWrkCtrCapRes">A <c>QueryBuildDataSource</c> object.</param>
    /// <returns>A <c>str</c> value with the timestamp range.</returns>
    protected str buildTimeStampRangeForHasNewCapacityReservationQuery(Query _query, QueryBuildDataSource _qbdsWrkCtrCapRes)
    {
        return (strfmt('((%1.%2 > %3.%4))',
                _query.dataSourceTable(tableNum(WrkCtrCapRes)).name(),
                fieldStr(WrkCtrCapRes, Timestamp),
                _query.dataSourceTable(tableNum(WrkCtrCapResConflictCheck)).name(),
                fieldStr(wrkCtrCapResConflictCheck, TimeStampCutoff)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLoadTypeRangeForHasNewCapacityReservationQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the load type range for the query for building reservations on individual resources query.
    /// </summary>
    /// <param name = "_query">A <c>Query</c> object.</param>
    /// <param name = "_qbdsWrkCtrCapRes">A <c>QueryBuildDataSource</c> object.</param>
    /// <returns>A <c>str</c> value with the load type range.</returns>
    protected str buildLoadTypeRangeForHasNewCapacityReservationQuery(Query _query, QueryBuildDataSource _qbdsWrkCtrCapRes)
    {
        return (strfmt('( ((%1.%2 == %3) && (%4.%5 == %6)) || ((%1.%2 == %7) && (%4.%8 == %6)) )',
                _query.dataSourceTable(tableNum(WrkCtrCapRes)).name(),
                fieldStr(WrkCtrCapRes, LoadType),
                int2str(enum2int(WrkCtrCapacityType::JobSched)),
                _query.dataSourceTable(tableNum(WrkCtrCapResConflictCheck)).name(),
                fieldStr(WrkCtrCapResConflictCheck, LoadJobSchedulingCapacity),
                int2str(enum2int(NoYes::Yes)),
                int2str(enum2int(WrkCtrCapacityType::OperationSched)),
                fieldStr(WrkCtrCapResConflictCheck, LoadOperationSchedulingCapacity)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildRefTypeRangeForHasNewCapacityReservationQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the ref type range for the has new capacity reservations query.
    /// </summary>
    /// <param name = "_query">A <c>Query</c> object.</param>
    /// <param name = "_qbdsWrkCtrCapRes">A <c>QueryBuildDataSource</c> object.</param>
    /// <returns>A <c>str</c> value with the ref type range.</returns>
    protected str buildRefTypeRangeForHasNewCapacityReservationQuery(Query _query, QueryBuildDataSource _qbdsWrkCtrCapRes)
    {
        return (WrkCtrCapResQueryBuildHelper::buildRefTypeRange(_query, _qbdsWrkCtrCapRes, planVersion, limitCapProd, limitCapProject, limitCapPO));
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasNewCapacityReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether any capacity reservations occur in a list of specified intervals.
    /// </summary>
    /// <param name="_conflictCheckSessionId">
    /// The ID to use to check for capacity reservation conflicts.
    /// </param>
    /// <returns>
    /// true if a capacity reservation occurs in the interval; otherwise, false.
    /// </returns>
    public boolean hasNewCapacityReservation(guid _conflictCheckSessionId)
    {
        // Select reservations made directly on the resource group
        Query queryReservationsOnResourceGroup = this.buildHasNewCapacityReservationQuery(_conflictCheckSessionId);
        QueryRun queryRun = new QueryRun(queryReservationsOnResourceGroup);

        WrkCtrCapResConflictCheck wrkCtrCapResConflictCheck;
        if (queryRun.next())
        {
            wrkCtrCapResConflictCheck = queryRun.get(tableNum(WrkCtrCapResConflictCheck));
        }

        if (wrkCtrCapResConflictCheck)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustRetrieveLoadCapacityReservations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the load capacity reservations must be loaded.
    /// </summary>
    /// <returns>true if the load capacity reservations must be loaded; otherwise, false.</returns>
    protected boolean mustRetrieveLoadCapacityReservations()
    {
        return (limitCapProd || limitCapProject || limitCapPO);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLoadCapacityReservationsQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for retreiving the capacity reservations for a specified date and time interval for a specified resource.
    /// </summary>
    /// <param name="_resourceId">
    /// A <c>WrkCtrId</c> value that specifies the resource for which to retrieve the capacity reservations.
    /// </param>
    /// <param name="_startDate">
    /// The start date of the interval.
    /// </param>
    /// <param name="_startTime">
    /// The start time of the interval.
    /// </param>
    /// <param name="_endDate">
    /// The end date of the interval.
    /// </param>
    /// <param name="_endTime">
    /// The end time of the interval.
    /// </param>
    /// <param name="_loadJobSchedulingCapacity">
    /// A <c>boolean</c> value that indicates whether the job scheduling capacity reservations are loaded.
    /// </param>
    /// <param name="_loadOperationSchedulingCapacity">
    /// A <c>boolean</c> value that indicates whether the operations scheduling capacity reservations are loaded.
    /// </param>
    /// <param name="_loadProperties">
    /// A <c>boolean</c> value that indicates whether the returned container contains property information.
    /// </param>
    /// <returns>
    /// A <c>Query</c>object.
    /// </returns>
    protected Query buildLoadCapacityReservationsQuery(WrkCtrId      _resourceId,
                                                  date          _startDate,
                                                  timeOfDay     _startTime,
                                                  date          _endDate,
                                                  timeOfDay     _endTime,
                                                  boolean       _loadJobSchedulingCapacity,
                                                  boolean       _loadOperationSchedulingCapacity,
                                                  boolean       _loadProperties)
    {
        Query query = new Query();

        QueryBuildDataSource qbdsWrkCtrCapRes = query.addDataSource(this.capResTableId());

        qbdsWrkCtrCapRes.addSelectionField(TransDate);
        qbdsWrkCtrCapRes.addSelectionField(StartTime);
        qbdsWrkCtrCapRes.addSelectionField(EndTime);
        qbdsWrkCtrCapRes.addSelectionField(WrkCtrSec);
        qbdsWrkCtrCapRes.addSelectionField(Timestamp);
        qbdsWrkCtrCapRes.addSelectionField(WrkCtrLoadPct);
        qbdsWrkCtrCapRes.addSelectionField(LoadType);
        qbdsWrkCtrCapRes.addSelectionField(wrkCtrCapResRecId);

        qbdsWrkCtrCapRes.addRange(WrkCtrId).value(_resourceId);
        qbdsWrkCtrCapRes.addRange(TransDate).value(queryRange(_startDate, _endDate));

        this.addLoadTypeRangeForLoadCapacityReservationsQuery(query, qbdsWrkCtrCapRes, _loadJobSchedulingCapacity, _loadOperationSchedulingCapacity);

        str refTypeFilter = this.buildRefTypeRangeForLoadCapacityReservationsQuery(query, qbdsWrkCtrCapRes);
        if (refTypeFilter != '')
        {
            qbdsWrkCtrCapRes.addRange(wrkCtrCapResDataAreaId).value(refTypeFilter);
        }

        if (_loadProperties)
        {
            QueryBuildDataSource qbdsWrkCtrCapResProperty = qbdsWrkCtrCapRes.addDataSource(this.capResPropertyTableId());
            qbdsWrkCtrCapResProperty.addSelectionField(SchedulingPropertyId);
            qbdsWrkCtrCapResProperty.joinMode(JoinMode::OuterJoin);
            qbdsWrkCtrCapResProperty.relations(true);
        }

        this.addCapResQueryIndex(qbdsWrkCtrCapRes);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLoadTypeRangeForLoadCapacityReservationsQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the load type range for the load capacity reservations query.
    /// </summary>
    /// <param name = "_query">A <c>Query</c> object.</param>
    /// <param name = "_qbdsWrkCtrCapRes">A <c>QueryBuildDataSource</c> object.</param>
    /// <param name="_loadJobSchedulingCapacity">
    /// A <c>boolean</c> value that indicates whether the job scheduling capacity reservations are loaded.
    /// </param>
    /// <param name="_loadOperationSchedulingCapacity">
    /// A <c>boolean</c> value that indicates whether the operations scheduling capacity reservations are loaded.
    /// </param>
    protected void addLoadTypeRangeForLoadCapacityReservationsQuery(
            Query                   _query,
            QueryBuildDataSource    _qbdsWrkCtrCapRes,
            boolean                 _loadJobSchedulingCapacity,
            boolean                 _loadOperationSchedulingCapacity)
    {
        WrkCtrCapResQueryBuildHelper::addLoadTypeRange(_query, _qbdsWrkCtrCapRes, _loadJobSchedulingCapacity, _loadOperationSchedulingCapacity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildRefTypeRangeForLoadCapacityReservationsQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the ref type range for the load capacity reservations query.
    /// </summary>
    /// <param name = "_query">A <c>Query</c> object.</param>
    /// <param name = "_qbdsWrkCtrCapRes">A <c>QueryBuildDataSource</c> object.</param>
    /// <returns>A <c>str</c> value with the ref type range.</returns>
    protected str buildRefTypeRangeForLoadCapacityReservationsQuery(Query _query, QueryBuildDataSource _qbdsWrkCtrCapRes)
    {
        str refTypeFilter;
        if (limitCapProd)
        {
            refTypeFilter = strFmt('((%1.%2 == %4) && (%1.%3 == %5))',
                        _qbdsWrkCtrCapRes.name(),
                        fieldId2name(this.capResTableId(), RefType), fieldId2name(this.capResTableId(), WrkCtrCapResPlanVersion),
                        enum2int(WrkCtrCapRefType::Production), 0);
        }
        if (limitCapProject)
        {
            if (refTypeFilter)
            {
                refTypeFilter += ' || ';
            }
            refTypeFilter += strFmt('(((%1.%2 == %4) || (%1.%2 == %5)) && (%1.%3 == %6))',
                        _qbdsWrkCtrCapRes.name(),
                        fieldId2name(this.capResTableId(), RefType), fieldId2name(this.capResTableId(), WrkCtrCapResPlanVersion),
                        enum2int(WrkCtrCapRefType::Project), enum2int(WrkCtrCapRefType::ProjectActivity), 0);
        }
        if (limitCapPO)
        {
            if (refTypeFilter)
            {
                refTypeFilter += ' || ';
            }
            refTypeFilter += strFmt('((%1.%2 == %4) && (%1.%3 == %5))',
                        _qbdsWrkCtrCapRes.name(),
                        fieldId2name(this.capResTableId(), RefType), fieldId2name(this.capResTableId(), WrkCtrCapResPlanVersion),
                        enum2int(WrkCtrCapRefType::PlannedOrder), planVersion);
        }

        return refTypeFilter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadCapacityReservations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the capacity reservations for a specified date and time interval for a specified resource.
    /// </summary>
    /// <param name="_resourceId">
    /// A <c>WrkCtrId</c> value that specifies the resource for which to retrieve the capacity reservations.
    /// </param>
    /// <param name="_startDate">
    /// The start date of the interval.
    /// </param>
    /// <param name="_startTime">
    /// The start time of the interval.
    /// </param>
    /// <param name="_endDate">
    /// The end date of the interval.
    /// </param>
    /// <param name="_endTime">
    /// The end time of the interval.
    /// </param>
    /// <param name="_loadJobSchedulingCapacity">
    /// A Boolean value that indicates whether the job scheduling capacity reservations are loaded.
    /// </param>
    /// <param name="_loadOperationSchedulingCapacity">
    /// A Boolean value that indicates whether the operations scheduling capacity reservations are loaded.
    /// </param>
    /// <param name="_loadProperties">
    /// A Boolean value that indicates whether the returned container contains property information.
    /// </param>
    /// <returns>
    /// A container that contains the retrieved capacity reservations.
    /// </returns>
    public container loadCapacityReservations(WrkCtrId      _resourceId,
                                                  date          _startDate,
                                                  timeOfDay     _startTime,
                                                  date          _endDate,
                                                  timeOfDay     _endTime,
                                                  boolean       _loadJobSchedulingCapacity = true,
                                                  boolean       _loadOperationSchedulingCapacity = true,
                                                  boolean       _loadProperties = false)
    {
        container               result;
        Common                  wrkCtrCapRes;
        Common                  previousWrkCtrCapRes;
        Common                  wrkCtrCapResProperty;
        container               properties;

        RecId                   previousCapResRecId = 0;
        QueryRun                queryRun;

        // Adds previousWrkCtrCapRes and properties to the result
        void  addReservationToResult()
        {
            if (previousWrkCtrCapRes.(LoadType) == WrkCtrCapacityType::OperationSched)
            {
                result += [previousWrkCtrCapRes.(TransDate),
                               0,
                               0,
                               previousWrkCtrCapRes.(WrkCtrLoadPct) / 100,
                               previousWrkCtrCapRes.(WrkCtrSec),
                               properties,
                               previousWrkCtrCapRes.(Timestamp)];
            }
            else
            {
                if (previousWrkCtrCapRes.(EndTime) != previousWrkCtrCapRes.(StartTime))
                {
                    result += [previousWrkCtrCapRes.(TransDate),
                                   previousWrkCtrCapRes.(StartTime),
                                   previousWrkCtrCapRes.(EndTime),
                                   previousWrkCtrCapRes.(WrkCtrSec) / (previousWrkCtrCapRes.(EndTime) - previousWrkCtrCapRes.(StartTime)),
                                   previousWrkCtrCapRes.(WrkCtrSec),
                                   properties,
                                   previousWrkCtrCapRes.(Timestamp)];
                }
            }
        }

        if (!this.mustRetrieveLoadCapacityReservations())
        {
            return result;
        }

        if (usePessimisticReadLock && !hasTakenReadLock)
        {
            WrkCtrScheduler::incrementWrkCtrCapResTimestampUsingConnection();
            hasTakenReadLock = true;
        }

        Query query = this.buildLoadCapacityReservationsQuery(_resourceId, _startDate, _startTime, _endDate, _endTime, _loadJobSchedulingCapacity, _loadOperationSchedulingCapacity, _loadProperties);
        queryRun = new QueryRun(query);

        previousWrkCtrCapRes = capResDictTable.makeRecord();

        while (queryRun.next())
        {
            wrkCtrCapRes = queryRun.get(this.capResTableId());

            if (previousCapResRecId != wrkCtrCapRes.RecId)
            {
                // save previous
                if (previousCapResRecId != 0)
                {
                    addReservationToResult();
                }

                // reset current
                previousCapResRecId = wrkCtrCapRes.RecId;
                previousWrkCtrCapRes.data(wrkCtrCapRes);
                properties = connull();
            }

            if (_loadProperties)
            {
                wrkCtrCapResProperty = queryRun.get(this.capResPropertyTableId());
                properties += [wrkCtrCapResProperty.(SchedulingPropertyId)];
            }
        }

        if (previousCapResRecId != 0)
        {
            addReservationToResult();
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCapacityReservationFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the fields of the capacity reservations table.
    /// </summary>
    protected void initializeCapacityReservationFields()
    {
        wrkCtrCapResRecId       = this.capResTableFieldId(fieldNum(WrkCtrCapRes, RecId));
        wrkCtrCapResDataAreaId  = this.capResTableFieldId(fieldNum(WrkCtrCapRes, DataAreaId));
        wrkCtrCapResPlanVersion = this.capResTableFieldId(fieldNum(WrkCtrCapRes, PlanVersion));
        loadType                = this.capResTableFieldId(fieldNum(WrkCtrCapRes, LoadType));
        transDate               = this.capResTableFieldId(fieldNum(WrkCtrCapRes, TransDate));
        wrkCtrLoadPct           = this.capResTableFieldId(fieldNum(WrkCtrCapRes, WrkCtrLoadPct));
        wrkCtrSec               = this.capResTableFieldId(fieldNum(WrkCtrCapRes, WrkCtrSec));
        timestamp               = this.capResTableFieldId(fieldNum(WrkCtrCapRes, Timestamp));
        endTime                 = this.capResTableFieldId(fieldNum(WrkCtrCapRes, EndTime));
        startTime               = this.capResTableFieldId(fieldNum(WrkCtrCapRes, StartTime));
        wrkCtrId                = this.capResTableFieldId(fieldNum(WrkCtrCapRes, WrkCtrId));
        refType                 = this.capResTableFieldId(fieldNum(WrkCtrCapRes, RefType));

        schedulingPropertyId    = this.capResPropertyTableFieldId(fieldNum(WrkCtrCapResProperty, SchedulingPropertyId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        capResDictTable = new SysDictTable(this.capResTableId());

        this.initializeCapacityReservationFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLimitCapPO</Name>
				<Source><![CDATA[
    public boolean parmLimitCapPO(boolean _limitCapPO = limitCapPO)
    {
        limitCapPO = _limitCapPO;
        return limitCapPO;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLimitCapProd</Name>
				<Source><![CDATA[
    public boolean parmLimitCapProd(boolean _limitCapProd = limitCapProd)
    {
        limitCapProd = _limitCapProd;
        return limitCapProd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLimitCapProject</Name>
				<Source><![CDATA[
    public boolean parmLimitCapProject(boolean _limitCapProject = limitCapProject)
    {
        limitCapProject = _limitCapProject;
        return limitCapProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPlanVersion</Name>
				<Source><![CDATA[
    public RecId parmPlanVersion(RecId _planVersion = planVersion)
    {
        planVersion = _planVersion;
        return planVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUsePessimisticReadLock</Name>
				<Source><![CDATA[
    public boolean parmUsePessimisticReadLock(boolean _usePessimisticReadLock = usePessimisticReadLock)
    {
        usePessimisticReadLock = _usePessimisticReadLock;
        return usePessimisticReadLock;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHasTakenReadLock</Name>
				<Source><![CDATA[
    public boolean parmHasTakenReadLock(boolean _hasTakenReadLock = hasTakenReadLock)
    {
        hasTakenReadLock = _hasTakenReadLock;
        return hasTakenReadLock;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static WrkCtrCapResHandler construct()
    {
        return new WrkCtrCapResHandler();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newParams</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>WrkCtrCapResHandler</c> class.
    /// </summary>
    /// <param name="_planVersion">
    /// A <c>RecId</c> value that identifies the plan version to use in the capacity reservation queries.
    /// </param>
    /// <param name="_limitCapPO">
    /// A Boolean that indicates whether planned production order capacity reservations are considered in
    /// the queries.
    /// </param>
    /// <param name="_limitCapProd">
    /// A Boolean that indicates whether production order capacity reservations are considered in the
    /// queries.
    /// </param>
    /// <param name="_limitCapProject">
    /// A Boolean that indicates whether the project capacity reservations are considered in the queries.
    /// </param>
    /// <returns>
    /// A new <c>WrkCtrCapResHandler</c> class instance.
    /// </returns>
    public static WrkCtrCapResHandler newParams(RecId   _planVersion,
                                                    boolean _limitCapPO         = true,
                                                    boolean _limitCapProd       = true,
                                                    boolean _limitCapProject    = true)
    {
        WrkCtrCapResHandler capResHandler = new WrkCtrCapResHandler();

        capResHandler.parmPlanVersion(_planVersion);
        capResHandler.parmLimitCapPO(_limitCapPO);
        capResHandler.parmLimitCapProd(_limitCapProd);
        capResHandler.parmLimitCapProject(_limitCapProject);

        return capResHandler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCommitSettingsList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a list of assignments to make when committing capacity reservations.
    /// </summary>
    /// <returns>
    /// A SysDa equivalent of
    /// setting RecordState = WrkCtrCapResRecordState::Committed, RecordStateSessionId = 0, RecordStateSessionLoginDateTime = utcDateTimeNull().
    /// </returns>
    private static SysDaSettingsList buildCommitSettingsList()
    {
        SysDaSettingsList settingsList = new SysDaSettingsList();
        settingsList.add(fieldStr(WrkCtrCapRes, RecordState), new SysDaValueExpression(WrkCtrCapResRecordState::Committed));
        settingsList.add(fieldStr(WrkCtrCapRes, RecordStateSessionId), new SysDaValueExpression(0));
        settingsList.add(fieldStr(WrkCtrCapRes, RecordStateSessionLoginDateTime), new SysDaValueExpression(utcDateTimeNull()));

        return settingsList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWhereClauseForSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a where clause for identifying capacity reservations written in a specific session.
    /// </summary>
    /// <param name = "_buffer">The record buffer that is used for the query.</param>
    /// <param name = "_session">The session to use for filtering.</param>
    /// <param name = "_recordState">The record state to look for</param>
    /// <returns>
    /// A SysDa equivalent of
    /// where _buffer.RecordState == _recordState
    ///     && _buffer.RecordStateSessionId == _session.sessionId
    ///     && _buffer.RecordStateSessionLoginDateTime == _session.loginDateTime().
    /// </returns>
    private static SysDaQueryExpression buildWhereClauseForSession(Common _buffer, Session _session, WrkCtrCapResRecordState _recordState)
    {
        return new SysDaEqualsExpression(new SysDaFieldExpression(_buffer, fieldStr(WrkCtrCapRes, RecordState)), new SysDaValueExpression(_recordState))
            .and(new SysDaEqualsExpression(new SysDaFieldExpression(_buffer, fieldStr(WrkCtrCapRes, RecordStateSessionId)), new SysDaValueExpression(_session.sessionId())))
            .and(new SysDaEqualsExpression(new SysDaFieldExpression(_buffer, fieldStr(WrkCtrCapRes, RecordStateSessionLoginDateTime)), new SysDaValueExpression(_session.loginDateTime())));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSessionJoin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a join statement for identifying capacity reservations written on sessions that are no longer active.
    /// </summary>
    /// <param name = "_buffer">The record buffer that is used for the query.</param>
    /// <returns>
    /// A SysDa equivalent of
    /// notexists join SysClientSessions
    ///     where _buffer.RecordStateSessionId == SysClientSessions.SessionId
    ///     && _buffer.RecordStateSessionLoginDatetime == SysClientSessions.LoginDateTime
    ///     && SysClientSessions.Status != 0
    /// </returns>
    private static SysDaQueryObject buildSessionJoin(Common _buffer)
    {
        SysClientSessions sessions;

        SysDaQueryObject result = new SysDaQueryObject(sessions);

        result.projection()
            .add(fieldStr(SysClientSessions, SessionId));

        result.whereClause(new SysDaEqualsExpression(
                    new SysDaFieldExpression(sessions, fieldStr(SysClientSessions, SessionId)),
                    new SysDaFieldExpression(_buffer, fieldStr(WrkCtrCapRes, RecordStateSessionId)))
            .and(new SysDaEqualsExpression(
                    new SysDaFieldExpression(sessions, fieldStr(SysClientSessions, LoginDateTime)),
                    new SysDaFieldExpression(_buffer, fieldStr(WrkCtrCapRes, RecordStateSessionLoginDateTime))))
            .and(new SysDaNotEqualsExpression(
                    new SysDaFieldExpression(sessions, fieldStr(SysClientSessions, Status)),
                    new SysDaValueExpression(0))));

        result.joinClauseKind(SysDaJoinKind::NotExistsJoin);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUpdateStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a statement to update all capacity reservation records written on the given session.
    /// </summary>
    /// <param name = "_buffer">The record buffer that is used for the update.</param>
    /// <param name = "_session">The session used for filtering.</param>
    /// <param name = "_recordState">The state of records to be updated.</param>
    /// <returns>The update statement.</returns>
    private static SysDaUpdateObject buildUpdateStatement(Common _buffer, Session _session, WrkCtrCapResRecordState _recordState)
    {
        SysDaUpdateObject updateObject = new SysDaUpdateObject(_buffer);

        updateObject.settingClause(WrkCtrCapResHandler::buildCommitSettingsList());
        updateObject.whereClause(WrkCtrCapResHandler::buildWhereClauseForSession(_buffer, _session, _recordState));

        return updateObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildDeleteStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a statement to delete all capacity reservation records written on the given session.
    /// </summary>
    /// <param name = "_buffer">The record buffer that is used for the update.</param>
    /// <param name = "_session">The session used for filtering; if null, records written by sessions that are no longer active will be deleted.</param>
    /// <param name = "_recordState">The state of records to be deleted.</param>
    /// <returns>The delete statement.</returns>
    private static SysDaDeleteObject buildDeleteStatement(Common _buffer, Session _session, WrkCtrCapResRecordState _recordState)
    {
        SysDaQueryObject queryObject = new SysDaQueryObject(_buffer);
        if (_session)
        {
            queryObject.whereClause(WrkCtrCapResHandler::buildWhereClauseForSession(_buffer, _session, _recordState));
        }
        else
        {
            queryObject.whereClause(new SysDaEqualsExpression(new SysDaFieldExpression(_buffer, fieldStr(WrkCtrCapRes, RecordState)), new SysDaValueExpression(_recordState)));
            queryObject.joinClause(SysDaJoinKind::NotExistsJoin, WrkCtrCapResHandler::buildSessionJoin(_buffer));
        }
        SysDaDeleteObject deleteObject = new SysDaDeleteObject(queryObject);

        return deleteObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performReservationCleanup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up all capacity reservations done on a specific session.
    /// </summary>
    /// <param name = "_cleanupType">Identifier of the process responsible for cleanup to be logged in telemetry.</param>
    /// <param name = "_session">The session used for filtering; if null, records written by sessions that are no longer active will be cleaned up.</param>
    /// <param name = "_connection">Connection to use for cleanup; default connection is used when null.</param>
    private static void performReservationCleanup(str _cleanupType, Session _session, UserConnection _connection)
    {
        using (var instrumentationSegment = ProdInstrumentationSegmentFactory::create(ProdInstrumentationActivities::WrkCtrCapResSessionCleanup, 0,
            new SysInstrumentationAdditionalParameters().add(ProdInstrumentationActivities::WrkCtrCapResSessionCleanupType, _cleanupType)))
        {
            WrkCtrCapResProperty wrkCtrCapResProperty;
            WrkCtrCapRes wrkCtrCapRes;

            if (_connection)
            {
                wrkCtrCapRes.setConnection(_connection);                
                wrkCtrCapResProperty.setConnection(_connection);
            }

            // Skip delete actions since we are explicitly deleting orphan WrkCtrCapResProperty records
            wrkCtrCapRes.skipDeleteActions(true);
            int64 removedOrphanedWrkCapResProperties = WrkCtrCapResHandler::deleteOrphanWrkCtrCapResProperty(wrkCtrCapResProperty, _session);
            int64 removedOrphanedWrkCapRes = WrkCtrCapResHandler::deleteOrphanWrkCtrCapRes(wrkCtrCapRes, _session);
            
            int64 revertedInserts = removedOrphanedWrkCapRes + removedOrphanedWrkCapResProperties;

            instrumentationSegment.addAdditionalParameterToStopEvent(ProdInstrumentationActivities::WrkCtrCapResSessionCleanupRevertedInserts, int642str(revertedInserts));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteOrphanWrkCtrCapResProperty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes orhpaned WrkCtrCapResProperty.
    /// select delete, chosen to limit locking.
    /// </summary>
    /// <param name = "_buffer">WrkCtrCapResProperty _buffer.</param>
    /// <param name = "_session">The session to look for, for orphaned WrkCtrCapResProperties.</param>
    /// <returns>The number of deleted rows.</returns>
    private static int64 deleteOrphanWrkCtrCapResProperty(WrkCtrCapResProperty _buffer, Session _session)
    {
        SysClientSessions sessions;
        int64 deleteCounter = 0;

        if (_session)
        {
            Microsoft.Dynamics.Ax.Xpp.PlatformExtensions.CommonExtensions::SetSqlDeleteIndexHint(_buffer, indexStr(WrkCtrCapResProperty, RecordStateIdx));

            new SysDaDeleteStatement().delete(WrkCtrCapResHandler::buildDeleteStatement(_buffer, _session, WrkCtrCapResRecordState::PendingInsert));
            return _buffer.RowCount();
        }
        else
        {
            List recIds = new List(Types::Int64);

            while select RecId
                from _buffer
                where _buffer.RecordState == WrkCtrCapResRecordState::PendingInsert
                    notexists join sessions
                        where sessions.SessionId == _buffer.RecordStateSessionId
                            && sessions.LoginDateTime == _buffer.RecordStateSessionLoginDateTime
                            && sessions.Status != SessionStatus::Inactive
            {
                recIds.addEnd(_buffer.RecId);
            }

            ListEnumerator enumerator = recIds.getEnumerator();
            while (enumerator && enumerator.moveNext())
            {
                delete_from _buffer
                    where _buffer.RecId == enumerator.current();

                deleteCounter++;
            }
        }

        return deleteCounter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteOrphanWrkCtrCapRes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes orhpaned WrkCtrCapResProperty.
    /// select delete, chosen to limit locking.
    /// </summary>
    /// <param name = "_buffer">WrkCtrCapResProperty _buffer.</param>
    /// <param name = "_session">The session to look for, for orphaned WrkCtrCapResProperties.</param>
    /// <returns>The number of deleted rows.</returns>
    private static int64 deleteOrphanWrkCtrCapRes(WrkCtrCapRes _buffer, Session _session)
    {
        SysClientSessions sessions;
        int64 deleteCounter = 0;

        if (_session)
        {
            Microsoft.Dynamics.Ax.Xpp.PlatformExtensions.CommonExtensions::SetSqlDeleteIndexHint(_buffer, indexStr(WrkCtrCapRes, RecordStateIdx));

            new SysDaDeleteStatement().delete(WrkCtrCapResHandler::buildDeleteStatement(_buffer, _session, WrkCtrCapResRecordState::PendingInsert));
            return _buffer.RowCount();
        }
        else
        {
            List recIds = new List(Types::Int64);

            while select RecId
                from _buffer
                where _buffer.RecordState == WrkCtrCapResRecordState::PendingInsert
                    notexists join sessions
                        where sessions.SessionId == _buffer.RecordStateSessionId
                        && sessions.LoginDateTime == _buffer.RecordStateSessionLoginDateTime
                        && sessions.Status != SessionStatus::Inactive
            {
                recIds.addEnd(_buffer.RecId);
            }

            ListEnumerator enumerator = recIds.getEnumerator();
            while (enumerator && enumerator.moveNext())
            {
                delete_from _buffer
                    where _buffer.RecId == enumerator.current();

                deleteCounter++;
            }
        }

        return deleteCounter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rollbackUncommittedReservations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rolls back all reservations done on the current session.
    /// </summary>
    private static void rollbackUncommittedReservations()
    {
        WrkCtrCapResHandler::performReservationCleanup(funcName(), new Session(), null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>commitReservations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Commits all reservations done on the current session.
    /// </summary>
    private static void commitReservations()
    {
        if (appl.GetIsTtsNotifyAbort())
        {
            return;
        }
        WrkCtrCapResProperty wrkCtrCapResProperty;
        WrkCtrCapRes wrkCtrCapRes;

        Session Session = new Session();

        Microsoft.Dynamics.Ax.Xpp.PlatformExtensions.CommonExtensions::SetSqlUpdateIndexHint(wrkCtrCapResProperty, indexStr(WrkCtrCapResProperty, RecordStateIdx));
        Microsoft.Dynamics.Ax.Xpp.PlatformExtensions.CommonExtensions::SetSqlUpdateIndexHint(wrkCtrCapRes, indexStr(WrkCtrCapRes, RecordStateIdx));

        new SysDaUpdateStatement().execute(WrkCtrCapResHandler::buildUpdateStatement(wrkCtrCapResProperty, session, WrkCtrCapResRecordState::PendingInsert));
        new SysDaUpdateStatement().execute(WrkCtrCapResHandler::buildUpdateStatement(wrkCtrCapRes, session, WrkCtrCapResRecordState::PendingInsert));
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupTerminatedSessions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up all reservations done on sessions that are no longer active.
    /// </summary>
    internal static void cleanupTerminatedSessions()
    {
        UserConnection connection = new UserConnection();

        try
        {
            connection.ttsbegin();
            WrkCtrCapResHandler::performReservationCleanup(funcName(), null, connection);
            connection.ttscommit();
        }
        finally
        {
            connection.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTransactionScopeHandlers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds transaction scope handlers to commit capacity reservations from current session when the top level transaction is committed and roll them back when it's aborted.
    /// </summary>
    internal static void initializeTransactionScopeHandlers()
    {
        SysTransactionScope transactionScope = appl.transactionScope();
        SysGlobalCache transactionCache = transactionScope.parmTransactionScopeCache();
                
        if(!transactionCache.isSet(classStr(WrkCtrCapResHandler), transactionScopeCacheKey))
        {
            transactionCache.set(classStr(WrkCtrCapResHandler), transactionScopeCacheKey, true);
            transactionScope.ttsCommitting += eventhandler(WrkCtrCapResHandler::commitReservations);
            transactionScope.ttsAborted += eventhandler(WrkCtrCapResHandler::rollbackUncommittedReservations);
        }
            
   }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>