<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchPackingSlipJournalPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
class PurchPackingSlipJournalPost
extends FormletterJournalPost
{
    // <GEERU>
    PurchParmUpdate             purchParmUpdate;
    boolean                     isCountryRegion_RU;
    // </GEERU>
    PurchParmTable              purchParmTable;
    PurchParmLine               purchParmLine;
    PurchLine                   purchLine;
    PurchTable                  purchTable;
    VendPackingSlipVersion      previousVendPackingSlipVersion;
    VendPackingSlipTransHistory previousVendPackingSlipTransHistory;

    VendPackingSlipVersion      vendPackingSlipVersion;
    VendPackingSlipJour         vendPackingSlipJour;
    VendPackingSlipTrans        vendPackingSlipTrans;
    QueryRun                    vendPackingSlipTransQueryRun;

    PurchTotals                 purchTotals;
    boolean                     useInternalNumber;

    PurchQty                    updateNow;
    PdsCWQty                    updateNowInventCW;
    SysQueryRun                 updateSalesLinesQuery;

    boolean                     updateSalesLines;
    boolean                     postingMultipleJournals;
    boolean                     needUpdateSiblingLinesInSameJournal;

    InventMovement              inventMovement;

    LeanCostingFacadeBase       leanCostingFacade;
    LeanConversionCostUpd       leanConversionCostUpd;
    NoYes                       printSalesFormLetter;
    VersioningUpdateType        versioningUpdateType;

    // <GIN>
    boolean                     isCustomsMarked;
    boolean                     isCountryRegion_IN;
    // </GIN>
    private PurchInstrumentationLogger  instrumentationLogger;
    private ProdJournalPostVendorProdBOM postVendorProdBOM;
    private ProdJournalPostVendorProdBOMHelper postVendorProdBOMHelper;
    private Map inventReportDimHistoryMap;

    private boolean isPostVendorProdBOMInOrderFeatureEnabled;

    #ISOCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addToInventReportDimHistory</Name>
				<Source><![CDATA[
    protected void addToInventReportDimHistory(Common _journalline)
    {
        InventTransOrigin       inventTransOrigin;
        InventTrans             inventTrans;
        VendPackingSlipTrans    localVendPackingSlipTrans = _journalline as VendPackingSlipTrans;
        InventQty               qtyRemain                 = localVendPackingSlipTrans.InventQty;
        VendPackingSlipVersion  localVendPackingSlipVersion;

        if (purchLine.isStocked())
        {
            if (!inventReportDimHistoryMap)
            {
                inventReportDimHistoryMap = new Map(Types::String, Types::Real);
            }

            while select TableId from inventTransOrigin
                where inventTransOrigin.InventTransId       == localVendPackingSlipTrans.InventTransId
                   && inventTransOrigin.ReferenceCategory   == InventTransType::Purch
                join StatusReceipt, InventDimId, sum(Qty) from inventTrans
                group by StatusReceipt, InventDimId
                where inventTrans.InventTransOrigin         == inventTransOrigin.RecId
                   && inventTrans.PackingSlipId             == localVendPackingSlipTrans.PackingSlipId
                   && inventTrans.DatePhysical              == localVendPackingSlipTrans.DeliveryDate
                   exists join localVendPackingSlipVersion
                   where localVendPackingSlipVersion.VendPackingSlipJour == localVendPackingSlipTrans.VendPackingSlipJour
                      && inventTrans.VoucherPhysical                == vendPackingSlipVersion.CostLedgerVoucher
            {
                var key = localVendPackingSlipTrans.InventTransId + '_' + inventTrans.inventDimId + '_' + enum2Str(inventTrans.StatusReceipt);

                if (!inventReportDimHistoryMap.exists(key))
                {
                    inventReportDimHistoryMap.insert(key, min(abs(inventTrans.Qty), abs(qtyRemain)));
                }
                else
                {
                    continue;
                }

                if (qtyRemain)
                {
                    qtyRemain = this.createInventReportDimHistory(localVendPackingSlipTrans.InventTransId,
                                                                  inventTrans.InventDimId,
                                                                  vendPackingSlipVersion.InternalPackingSlipId,
                                                                  -inventTrans.Qty, qtyRemain);
                }
                else
                {
                    break;
                }
            }
        }
        else
        {
            this.createInventReportDimHistory(localVendPackingSlipTrans.InventTransId,
                                              localVendPackingSlipTrans.InventDimId,
                                              vendPackingSlipVersion.InternalPackingSlipId,
                                              localVendPackingSlipTrans.Qty,
                                              localVendPackingSlipTrans.Qty );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostLedger</Name>
				<Source><![CDATA[
    protected boolean canPostLedger()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
        instrumentationLogger = PurchInstrumentationLogger::createLogger(classStr(PurchPackingSlipJournalPost));
        isPostVendorProdBOMInOrderFeatureEnabled = FeatureStateProvider::isFeatureEnabled(ProdJournalPostVendorProdBOMInOrderFeature::instance());
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostTax</Name>
				<Source><![CDATA[
    protected boolean canPostTax()
    {
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && InventParameters::find().PostPhysicalTax)
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForNewConfirmationAccountingEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Throws an error if a new confirmation event was created.
    /// </summary>
    protected void checkForNewConfirmationAccountingEvent()
    {
        PurchParmSubTable purchParmSubTable = purchParmLine.purchParmSubTable();
        AccountingEvent localAccountingEvent = AccountingEvent::getLastEvent(purchLine.purchTable().SourceDocumentHeader);
        if (purchParmSubTable.SourceAccountingEvent != localAccountingEvent.RecId)
        {
            throw error(strFmt("@SCM:PurchasePackingslipNewConfirmationAccountingEvent", purchParmSubTable.OrigPurchId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBeforePostingLine</Name>
				<Source><![CDATA[
    protected void checkBeforePostingLine()
    {
        this.checkForNewConfirmationAccountingEvent();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFixedAsset</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a record in the <c>AssetTable</c> table.
    /// </summary>
    /// <param name="_purchParmLine">
    ///    A <c>PurchParmLine</c> table buffer.
    /// </param>
    /// <param name="_purchParmLine_Asset">
    ///    A <c>PurchParmLine_Asset</c> table buffer.
    /// </param>
    /// <returns>
    ///    The <c>AssetId</c> value from the record created in the <c>AssetTable</c> table.
    /// </returns>
    protected AssetId createFixedAsset(PurchParmLine _purchParmLine, PurchParmLine_Asset _purchParmLine_Asset)
    {
        NumberSequenceTable numberSequenceTable;
        AssetParameters assetParameters = AssetParameters::find();

        AssetGroup assetGroup;

        select firstonly AssetType, PropertyType, MajorType, Location, AutoNumberSequenceTable from assetGroup
            where assetGroup.GroupId == _PurchParmLine_Asset.AssetGroup;

        // It is only possible create fixed assets when the number sequence is marked as continuous
        if (assetGroup.AutoNumberSequenceTable)
        {
            select firstonly Continuous from numberSequenceTable
                where numberSequenceTable.RecId == assetGroup.AutoNumberSequenceTable;
        }

        if (numberSequenceTable.Continuous == NoYes::No)
        {
            if (assetGroup.AutoNumberSequenceTable)
            {
                throw error("@SYS116327");
            }
            else
            {
                if (assetParameters.AutoNumber)
                {
                    NumberSequenceReference numberSequenceReference = AssetParameters::numRefAssetId();
                    numberSequenceTable.Continuous = numberSequenceReference.numberSequenceTable().Continuous;
                    if (numberSequenceTable.Continuous == NoYes::No)
                    {
                        throw error("@SYS116327");
                    }
                }
                else
                {
                    throw error("@SYS122736");
                }
            }
        }
        
        ttsbegin; //Save asset record.

        AssetTable assetTable;
        assetTable.selectForUpdate(true);
        assetTable.clear();
        assetTable.AssetGroup = _purchParmLine_Asset.AssetGroup;
        assetTable.Name = _purchParmLine.purchLine().itemName();
        assetTable.PurchLineRecId = _purchParmLine.PurchLineRecId;
        assetTable.Location = assetGroup.Location;
        assetTable.AssetType = assetGroup.AssetType;
        assetTable.MajorType = assetGroup.MajorType;
        assetTable.PropertyType = assetGroup.PropertyType;

        if (BrazilParameters::isEnabled())
        {
            assetTable.FiscalEstablishment_BR = _purchParmLine.purchLine().InventDim().inventSite().fiscalEstablishment().RecId;
            assetTable.initFromAssetGroupId(assetTable.AssetGroup);
        }

        NumberSeq assetIdNumberSeq = assetTable.initAssetNumberSeq();
        if (assetIdNumberSeq)
        {
            assetTable.AssetId = assetIdNumberSeq.num();
            assetIdNumberSeq.used();
        }

        if (assetParameters.BarcodeEqualsAssetNumber == NoYes::Yes)
        {
            assetTable.Barcode = assetTable.AssetId;
        }
        else
        {
            NumberSeq barcodeNumberSeq = assetTable.initBarcodeNumberSeq();
            if (barcodeNumberSeq)
            {
                assetTable.Barcode = barcodeNumberSeq.num();
                barcodeNumberSeq.used();
            }
        }

        assetTable.insert();

        this.updateAssetBook(_purchParmLine, _purchParmLine_Asset, assetParameters, assetGroup, assetTable);

        ttscommit;

        _purchParmLine_Asset.CreateFixedAsset = NoYes::No;
        _purchParmLine_Asset.AssetId = assetTable.AssetId;
        _purchParmLine_Asset.modifyAssetId();
        _purchParmLine_Asset.doUpdate();

        return assetTable.AssetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetBook</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the corresponding <c>AssetBook</c>.
    /// </summary>
    /// <param name="_purchParmLine">
    ///    A <c>PurchParmLine</c> table buffer.
    /// </param>
    /// <param name="_purchParmLine_Asset">
    ///    A <c>PurchParmLine_Asset</c> table buffer.
    /// </param>
    /// <param name="_assetParameters">
    ///    A <c>AssetParameters</c> table buffer.
    /// </param>
    /// <param name="_assetGroup">
    ///    A <c>AssetGroup</c> table buffer.
    /// </param>
    /// <param name="_assetTable">
    ///    A <c>AssetTable</c> table buffer.
    /// </param>
    protected void updateAssetBook(PurchParmLine        _purchParmLine,
                                   PurchParmLine_Asset  _purchParmLine_Asset,
                                   AssetParameters      _assetParameters,
                                   AssetGroup           _assetGroup,
                                   AssetTable           _assetTable)
    {
        if (this.shouldUpdateAssetBookDepreciation(_purchParmLine, _purchParmLine_Asset, _assetParameters, _assetGroup, _assetTable))
        {
            AssetBook assetBook;

            update_recordset assetBook setting Depreciation = NoYes::No
                where assetBook.AssetId == _assetTable.AssetId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateAssetBookDepreciation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the asset book depreciation should be updated.
    /// </summary>
    /// <param name="_purchParmLine">
    ///    A <c>PurchParmLine</c> table buffer.
    /// </param>
    /// <param name="_purchParmLine_Asset">
    ///    A <c>PurchParmLine_Asset</c> table buffer.
    /// </param>
    /// <param name="_assetParameters">
    ///    A <c>AssetParameters</c> table buffer.
    /// </param>
    /// <param name="_assetGroup">
    ///    A <c>AssetGroup</c> table buffer.
    /// </param>
    /// <param name="_assetTable">
    ///    A <c>AssetTable</c> table buffer.
    /// </param>
    /// <returns>
    ///    true if the asset book depreciation should be updated; otherwise, false.
    /// </returns>
    protected boolean shouldUpdateAssetBookDepreciation(PurchParmLine _purchParmLine,
        PurchParmLine_Asset _purchParmLine_Asset,
        AssetParameters _assetParameters,
        AssetGroup _assetGroup,
        AssetTable _assetTable)
    {
        return (_assetParameters.ConsiderCapitalizationThreshold && (_purchParmLine.LineAmount <= _assetGroup.CapitalizationThreshold));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNotStockedPostCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a <c>TradeNotStockedPostCheck</c> object to use to verify order lines during posting.
    /// </summary>
    /// <returns>
    /// A <c>TradeNotStockedPostCheck</c> object to use to verify order lines during posting.
    /// </returns>
    /// <remarks>
    /// Can return null if no verification should be performed.
    /// </remarks>
    protected TradeNotStockedPostCheck createNotStockedPostCheck()
    {
        return TradeNotStockedPostCheck::newPurchLine(purchLine, vendPackingSlipTrans.Qty, vendPackingSlipTrans.Remain);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReportData</Name>
				<Source><![CDATA[
    public boolean createReportData(FormletterJournalPrint _formletterJournalPrint)
    {
        PurchPackingSlipDP purchPackingSlipDP;
        VendPackingSlipVersion localVendPackingSlipVersion = VendPackingSlipVersion::findLatest(formletterJournal.RecId);
        PurchPackingSlipContract  purchPackingSlipContract;

        if (localVendPackingSlipVersion)
        {
            purchPackingSlipContract = new PurchPackingSlipContract();
            purchPackingSlipContract.parmRecordId(localVendPackingSlipVersion.RecId);

            purchPackingSlipDP = this.instantiateDataProvider();
            purchPackingSlipDP.createData(purchPackingSlipContract);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateDataProvider</Name>
				<Source><![CDATA[
    protected PurchPackingSlipDP instantiateDataProvider()
    {
        return new PurchPackingSlipDP();
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditNote</Name>
				<Source><![CDATA[
    protected NoYes creditNote()
    {
        NoYes creditNote;

        if (previousVendPackingSlipVersion.RecId)
        {
            creditNote = NoYes::Yes;
        }
        else
        {
            creditNote = NoYes::No;
        }

        return creditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultLedgerTransactionText</Name>
				<Source><![CDATA[
    protected LedgerTransTxt defaultLedgerTransactionText()
    {
        return LedgerTransTxt::PurchPckSlpLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentStatus</Name>
				<Source><![CDATA[
    protected DocumentStatus  documentStatus()
    {
        return DocumentStatus::PackingSlip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLedgerVoucher</Name>
				<Source><![CDATA[
    protected void endLedgerVoucher()
    {
        PurchPackingSlipJournalPostCaller caller;

        if (SourceDocumentCompletionRule::useSingleVoucher())
        {
            caller = PurchPackingSlipJournalPostCaller::newFromLedgerVoucher(ledgerVoucher);

            //Transition document to completed state with inventory voucher
            using (CostVoucherPostingDetectInventoryLedgerAccountMissingContext context = CostVoucherPostingDetectInventoryLedgerAccountMissingContext::construct())
            {
                SourceDocumentProcessorFacade::submitSourceDocumentImplementation(
                    vendPackingSlipJour,
                    false,
                    SourceDocumentAccountingStatus::Completed,
                    caller,
                    curUserId(),
                    // The account validation is not needed when the product receipt source document is transitioned to
                    // completed state because the user cannot view distributions prior to posting the product receipt.
                    false);
            }
        }
        else
        {
            CostEventProcessor::process();
            CostJournalizer::journalize(ledgerVoucher);

            super();
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.createTransLink_RU();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endPost</Name>
				<Source><![CDATA[
    protected void endPost()
    {
        super();
        this.updateBankLC();

        if (leanConversionCostUpd)
        {
            leanConversionCostUpd.endLeanSubcontractingPosting();
        }
        this.mcrOrderEvent();
    }

]]></Source>
			</Method>
			<Method>
				<Name>endPostLine</Name>
				<Source><![CDATA[
    protected void endPostLine()
    {
        boolean     doCascadeDetailsToBatchesCreated;

        inventMovement = null; //Ensures that the internal recordViewCache in inventMovement is deactivated again.
        previousVendPackingSlipTransHistory = null;

        if (postingMultipleJournals)
        {
            this.updateSiblingLinesInOtherJournals();
        }

        if (needUpdateSiblingLinesInSameJournal)
        {
            this.updateSiblingLinesInSameJournal();
        }

        if (#PdsEnabled)
        {
            doCascadeDetailsToBatchesCreated = purchParmLine.pdsSetPdsVendBatchInfo();
        }

        super();

        using (InventQualityOrderPhysicalVoucherContext context = InventQualityOrderPhysicalVoucherContext::construct())
        {
            if (ledgerVoucher)
            {
                if (vendPackingSlipVersion.CostLedgerVoucher)
                {
                    context.parmPhysicalVoucherForBlocking(vendPackingSlipVersion.CostLedgerVoucher);
                }
                else
                {
                    context.parmPhysicalVoucherForBlocking(ledgerVoucher.lastVoucher());
                }
            }

            if (vendPackingSlipJour.PackingSlipId)
            {
                context.parmPackingSlipId(vendPackingSlipJour.PackingSlipId);
            }
            InventQualityManagementCreateHandler::createPurchaseProductReceiptAfter(purchParmLine);
        }
        if (#PdsBatchAttribEnabled)
        {
            PdsBatchAttributesInput::cascadeDetailsToBatchAttributes(purchParmLine);
        }

        if (doCascadeDetailsToBatchesCreated)
        {
            purchParmLine.bufferPdsVendBatchInfo().cascadeDetailsToBatchesCreated(purchParmTable.Num);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPostSalesPackingSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the sales packing slip posting must be performed.
    /// </summary>
    /// <returns>
    /// true if the sales packing slip posting must be performed; otherwise false.
    /// </returns>
    protected boolean mustPostSalesPackingSlip()
    {
        return (updateSalesLines && updateSalesLinesQuery
            && !purchTable.InterCompanyDirectDelivery /*IntercompanyDirectDelivery is processed by intercompanyPost()*/);
    }

]]></Source>
			</Method>
			<Method>
				<Name>endUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ends the update of the selected records.
    /// </summary>
    /// <remarks>
    /// The <c>endUpdate</c> method in the derived classes contains the code for ending the posting of the
    /// selected records posted by the derived <c>FormLetter</c> class. For example the <c>endUpdate</c>
    /// method in the <c>SalesFormLetter</c> class ends the update for the selected sales orders. The
    /// <c>endUpdate</c> method is added to the <c>FormLetter</c> class so that you can run the
    /// <c>endUpdate</c> method when you post in batch. The <c>endUpdate</c> method is called from the
    /// <c>run</c> method in the abstract classes derived from the <c>FormLetter</c> class, and from the
    /// <c>run</c> method in the <c>FormLetterEndMultiThread</c> class.
    /// </remarks>
    protected void endUpdate()
    {
        SetEnumerator   se = ordersPosted.getEnumerator();

        super();
        this.interCompanyPost();
        if (this.mustPostSalesPackingSlip())
        {
            this.updateSalesTable(updateSalesLinesQuery);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLeanConversionCostUpd</Name>
				<Source><![CDATA[
    protected LeanConversionCostUpd getLeanConversionCostUpd()
    {
        if (!leanConversionCostUpd)
        {
            leanConversionCostUpd = LeanConversionCostUpd::constructForVoucher(
                ledgerVoucher,
                leanCostingFacade);
        }

        return leanConversionCostUpd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVoucher</Name>
				<Source><![CDATA[
    protected Num getVoucher()
    {
        return vendPackingSlipVersion.LedgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleLeanSubcontractedQtyChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles changes in the packing slip line quantity with regard to assigned kanban jobs.
    /// </summary>
    /// <remarks>
    /// If the quantity reaches 0 then the jobs are unassigned; otherwise, the quantity is compared to
    /// original calculated quantity and warnings are issued in cases of differences.
    /// </remarks>
    protected void handleLeanSubcontractedQtyChange()
    {
        if (purchLine.PlanReference != 0
            && versioningUpdateType != VersioningUpdateType::Initial
            && vendPackingSlipTrans.Qty != previousVendPackingSlipTransHistory.Qty
            && KanbanJobReceiptAdviceLine::findReceiptAdviceLine(vendPackingSlipTrans.RecId).RecId)
        {
            LeanDocumentServiceController::compareAgainstOriginalQuantity(vendPackingSlipTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    public void init()
    {
        vendPackingSlipVersion = VendPackingSlipVersion::findLatest(vendPackingSlipJour.RecId);
        // <GEERU>
        isCountryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]);
        // </GEERU>
        // <GIN>
        isCustomsMarked = TaxParameters::isCustomsEnable_IN();
        isCountryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoIN ]);
        // </GIN>
        super();

        purchTable = PurchTable::find(vendPackingSlipJour.PurchId);

        this.initTotals();
        this.initPreviousVersionDateTime();

        if (PurchPackingSlipDirectDeliverySQLExceptionFlight::instance().isEnabled())
        {
            updateSalesLinesQuery = this.initializeSalesLineQuery();
        }
        else
        {
            updateSalesLinesQuery = new SysQueryRun(queryStr(SalesUpdate));
        }

        // <GEERU>
        purchParmUpdate = purchParmTable.purchParmUpdate();
        // </GEERU>

        if (purchParmTable.numberOfJournalsToPost() > 1)
        {
            postingMultipleJournals = true;
        }

        needUpdateSiblingLinesInSameJournal = PurchParmTable.needUpdateSiblingLinesInSameJournal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeSalesLineQuery</Name>
				<Source><![CDATA[
    private SysQueryRun initializeSalesLineQuery()
    {
        #Query

        SysQueryRun salesLinesQuery;

        salesLinesQuery = new SysQueryRun(queryStr(SalesUpdate));
        salesLinesQuery.literals(#QueryForceLiterals);

        return salesLinesQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFormletterProvider</Name>
				<Source><![CDATA[
    protected void initFormletterProvider()
    {
        formletterProvider = FormletterProvider::newFormletterType(FormletterType::Purchase,purchTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMarkup</Name>
				<Source><![CDATA[
    #ISOCountryRegionCodes
    protected void initMarkup()
    {
        super();

        if (isCountryRegion_RU)
        {
            markup.parmAllowPosting_RU(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPreviousVersionDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the previous packing slip version, if one exists.
    /// </summary>
    protected void initPreviousVersionDateTime()
    {
        select previousVendPackingSlipVersion
            order by VersionDateTime desc
            where previousVendPackingSlipVersion.VendPackingSlipJour == vendPackingSlipJour.RecId
               && previousVendPackingSlipVersion.RecId != vendPackingSlipVersion.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRelatedLineTables</Name>
				<Source><![CDATA[
    protected void initRelatedLineTables()
    {
        super();

        // select statements combined to save on DB calls
        // In case of posting multiple PurchParmLines against same PurchLine need to also select the PurchParmLine based on InventDimId
        select firstonly forupdate * from purchLine
            where purchLine.InventTransId              == vendPackingSlipTrans.InventTransId
               && !purchLine.IsDeleted
        outer join firstonly * from purchParmLine
            where purchParmLine.ParmId                 == vendPackingSlipVersion.ParmId
               && purchParmLine.TableRefId             == purchParmTable.TableRefId
               && purchParmLine.OrigPurchId            == purchLine.PurchId
               && purchParmLine.PurchaseLineLineNumber == purchLine.LineNumber
               && (!needUpdateSiblingLinesInSameJournal
                   || purchParmLine.InventDimId        == vendPackingSlipTrans.InventDimId);

        if (previousVendPackingSlipVersion)
        {
            previousVendPackingSlipTransHistory = VendPackingSlipTransHistory::find(
                vendPackingSlipTrans.RecId,
                previousVendPackingSlipVersion.VersionDateTime);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the totals object.
    /// </summary>
    protected void initTotals()
    {
        PurchTotals_ParmTrans purchTotals_ParmTrans;

        if (VendParameters::find().PostPackingSlip && InventParameters::find().PostPhysicalTax)
        {
            purchTotals = PurchTotals::newParmTable(purchParmTable, any2Enum(this.parmSpecQty()), purchParmTable.ParmId, this.parmSumOrderId(), this.documentStatus());
            // store the VendPackingSlipJour into the PurchTotals_ParmTrans class for use in creation of TaxUncommitted for the packing slip
            purchTotals_ParmTrans = purchTotals as PurchTotals_ParmTrans;
            purchTotals_ParmTrans.setVendPackingSlipJour(vendPackingSlipJour);
            purchTotals.calc();
        }

        if (purchTotals)
        {
            this.tax(purchTotals.tax());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransactionTxt</Name>
				<Source><![CDATA[
    protected TransactionTxt initTransactionTxt(LedgerTransTxt _ledgerTransTxt)
    {
        transactionTxt = TransactionTxt::construct();
        transactionTxt.setType          (_ledgerTransTxt);
        transactionTxt.setVoucher       (vendPackingSlipVersion.LedgerVoucher);
        transactionTxt.setFormLetter    (vendPackingSlipJour.PackingSlipId);
        transactionTxt.setKey1          (vendPackingSlipJour.PurchId);
        transactionTxt.setKey2          (vendPackingSlipJour.OrderAccount);
        transactionTxt.setKey3          (VendTable::groupId(vendPackingSlipJour.OrderAccount));

        if (TransactionTextContext::isTypeSupported(_ledgerTransTxt))
        {
            TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(_ledgerTransTxt);
            transactionTextContext.setTableBuffer(vendPackingSlipJour);
            transactionTextContext.setTableBuffer(vendPackingSlipJour.purchTable());
            transactionTxt.setTransactionTextContext(transactionTextContext);
        }
        return transactionTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyPost</Name>
				<Source><![CDATA[
    protected void interCompanyPost()
    {
        if (purchTable.InterCompanyDirectDelivery)
        {
            if (InterCompanyPostStackOverflowPreventionFlight::instance().isEnabled())
            {
                InterCompanyPost::postContextQueue(
                    InterCompanyPostContractSales_PackingSlip::newFromJournal(this.parmChainFormletterContract(), vendPackingSlipJour));
            }
            else
            {
                InterCompanyPostSales::post(this.parmChainFormletterContract(), vendPackingSlipJour);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyTransferBatchSerial</Name>
				<Source><![CDATA[
    protected void interCompanyTransferBatchSerial(StatusIssue _statusIssue = StatusIssue::OnOrder)
    {
        InterCompanyEndpointActionPolicyTransfer    actionPolicyTransfer;
        SalesTable                                  interCompanySalesTableOriginal;
        SalesTable                                  interCompanySalesTable;

        if (purchLine
        &&  purchLine.InterCompanyInventTransId
        &&  purchLine.purchTable().isInterCompanyOrder())
        {
            if (vendPackingSlipTrans.Qty < 0)
            {
                interCompanySalesTableOriginal = purchLine.purchTable().interCompanySalesTableOriginal();
                if (interCompanySalesTableOriginal.InterCompanyDirectDelivery)
                {
                    interCompanySalesTable = purchLine.purchTable().interCompanySalesTable();
                    actionPolicyTransfer = interCompanySalesTable.interCompanyEndpointActionPolicy().getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::External);
                    InterCompanyTransferInventDim::doTransferReturn(purchLine.purchTable().InterCompanyCompanyId,
                                                              purchLine.InterCompanyInventTransId,
                                                              purchLine.DataAreaId,
                                                              purchLine.InventTransId,
                                                              actionPolicyTransfer,
                                                              StatusReceipt::Received,
                                                              false,
                                                              false);
                }
                else
                {
                    actionPolicyTransfer = purchLine.purchTable().interCompanyEndpointActionPolicy().getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::External);
                    InterCompanyTransferInventDim::doTransfer(purchLine.DataAreaId,
                                                            purchLine.InventTransId,
                                                            purchLine.purchTable().InterCompanyCompanyId,
                                                            purchLine.InterCompanyInventTransId,
                                                            actionPolicyTransfer,
                                                            _statusIssue,
                                                            purchParmTable.Num);
                }
            }
            else if (vendPackingSlipTrans.Qty > 0 && purchLine.OverDeliveryPct > 0 && purchParmLine.ReceiveNow > purchParmLine.RemainBefore)
            {
                interCompanySalesTableOriginal = purchLine.purchTable().interCompanySalesTableOriginal();

                if (interCompanySalesTableOriginal.InterCompanyDirectDelivery)
                {
                    interCompanySalesTable = purchLine.purchTable().interCompanySalesTable();
                    actionPolicyTransfer = interCompanySalesTable.interCompanyEndpointActionPolicy().getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::External);
                    InterCompanyTransferInventDim::doTransfer(purchLine.purchTable().InterCompanyCompanyId,
                                                              purchLine.InterCompanyInventTransId,
                                                              purchLine.DataAreaId,
                                                              purchLine.InventTransId,
                                                              actionPolicyTransfer,
                                                              _statusIssue,
                                                              purchParmTable.Num,
                                                              false,
                                                              false,
                                                              true);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventReportDimHistoryLogType</Name>
				<Source><![CDATA[
    protected InventReportDimHistoryLogType inventReportDimHistoryLogType()
    {
        return InventReportDimHistoryLogType::PurchPackingSlip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalLine</Name>
				<Source><![CDATA[
    protected Common journalLine(Common _journalLine = vendPackingSlipTrans)
    {
        vendPackingSlipTrans = _journalLine as VendPackingSlipTrans;
        return vendPackingSlipTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalLineTableId</Name>
				<Source><![CDATA[
    protected TableId journalLineTableId()
    {
        return tableNum(VendPackingSlipTransHistory);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerVoucherObjectDocument</Name>
				<Source><![CDATA[
    protected container ledgerVoucherObjectDocument(LedgerVoucherObject _ledgerVoucherObject)
    {
        return vendPackingSlipJour.DocumentDate ? [vendPackingSlipJour.DocumentDate] : [vendPackingSlipJour.DeliveryDate, vendPackingSlipJour.PackingSlipId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrOrderEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates order event entry.
    /// </summary>
    private void mcrOrderEvent()
    {
        MCROrderEventTable   mcrOrderEventTable;

        mcrOrderEventTable.insertFromDropShipment(PurchLine::find(PurchTable.PurchId).InventRefId,
                                                PurchTable.PurchId,
                                                MCROrderEventType::DeliverDropShipPO);
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextFormletterJournalTrans</Name>
				<Source><![CDATA[
    protected void nextFormletterJournalTrans()
    {
        vendPackingSlipTrans.clear();

        if (vendPackingSlipTransQueryRun.next())
        {
            vendPackingSlipTrans = vendPackingSlipTransQueryRun.get(tableNum(VendPackingSlipTrans));
        }

        if (needUpdateSiblingLinesInSameJournal)
        {
            vendPackingSlipTrans.reread();
        }

        formletterJournalTrans.data(vendPackingSlipTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalTable</Name>
				<Source><![CDATA[
    public Common parmJournalTable(Common _journalTable = vendPackingSlipJour)
    {
        vendPackingSlipJour = _journalTable as VendPackingSlipJour;
        return vendPackingSlipJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLeanCostingFacade</Name>
				<Source><![CDATA[
    public LeanCostingFacadeBase parmLeanCostingFacade(LeanCostingFacadeBase _leanCostingFacade = leanCostingFacade)
    {
        leanCostingFacade = _leanCostingFacade;

        return leanCostingFacade;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmTable</Name>
				<Source><![CDATA[
    public Common parmParmTable(Common _parmTable = purchParmTable)
    {
        purchParmTable = _parmTable as PurchParmTable;

        return purchParmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintSalesFormLetter</Name>
				<Source><![CDATA[
    public NoYes parmPrintSalesFormLetter(NoYes _printSalesFormLetter = printSalesFormLetter)
    {
        printSalesFormLetter = _printSalesFormLetter;
        return printSalesFormLetter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxableDocumentDescriptor</Name>
				<Source><![CDATA[
    public TaxableDocumentDescriptor parmTaxableDocumentDescriptor()
    {
        return TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(vendPackingSlipJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVersioningUpdateType</Name>
				<Source><![CDATA[
    public VersioningUpdateType parmVersioningUpdateType(VersioningUpdateType _versioningUpdateType = versioningUpdateType)
    {
        versioningUpdateType = _versioningUpdateType;
        return versioningUpdateType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCharge</Name>
				<Source><![CDATA[
    delegate void postCharge(VendPackingSlipTrans _vendPackingSlipTrans, TransDate _transDate, Voucher _voucher)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustVend</Name>
				<Source><![CDATA[
    protected void postCustVend()
    {
        // Note, don't let base class method run, Cust/Vend ledger adjustments are posted in this.journalizeSourceDocument().
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEndDiscount</Name>
				<Source><![CDATA[
    protected void postEndDiscount()
    {
        // Note, don't let base class method run, all discounts are posted in this.journalizeSourceDocument().
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInventory</Name>
				<Source><![CDATA[
    protected void postInventory()
    {
        // <GEERU>
        #ISOCountryRegionCodes
        if (! purchParmLine.ReceiveNow &&
            isCountryRegion_RU &&
            versioningUpdateType == VersioningUpdateType::Initial) // M4/M7
            return;
        // </GEERU>

        // Save current voucher and transdate.
        Voucher lastVoucher     = ledgerVoucher.lastVoucher();
        TransDate lastTransDate   = ledgerVoucher.lastTransDate();

        // Raise event postCharge if this is not a Correction (reason is that if not guarded correction will update charge -voucher, -transdate and -calculated amount)
        if (versioningUpdateType != VersioningUpdateType::Correction)
        {
            this.postCharge(vendPackingSlipTrans, lastTransDate, lastVoucher);
        }

        // Switch to the costing ledgerVoucherObject
        LedgerVoucherObject ledgerVoucherObject = this.findOrCreateLedgerVoucherObject(vendPackingSlipVersion.CostLedgerVoucher, this.updateDate());

        if (InventoryReportingCurrencyTriangulationFeature::instance().IsEnabled())
        {
            ledgerVoucherObject.parmTransactionCurrencyCode(purchParmTable.CurrencyCode);
        }

        inventMovement = InventMovement::construct(purchLine);

        inventMovement.parmInventTransOriginIdOriginalProject(
            InventTransOrigin::findMarkingRefInventTransOrigin(
                inventMovement.inventTransOriginId(),
                inventMovement.itemId(), true));

        // <GEERU>
        if (isCountryRegion_RU)
        {
            inventMovement.parmStorno_RU(this.creditNote() && purchParmUpdate.Storno);
            inventMovement.parmStornoPhysical_RU(purchParmUpdate.StornoPhysical_RU);
        }
        // </GEERU>

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            ITaxDocument taxDocumentObject = TaxBusinessService::calculateTax(TaxableDocumentObject::construct(this.parmTaxableDocumentDescriptor()));
            if (taxDocumentObject)
            {
                inventMovement.setTaxEngineInventMovement(TaxEngineInventMovement::construct(purchParmLine, taxDocumentObject));
            }
        }
        // </GTE>

        inventMovement.parmDistributionLedgerPosting(true);

        InventUpd_Physical inventUpd_Physical = this.constructAndInitializePhysicalInventoryUpdate();
        inventMovement.parmReturnMode(inventUpd_Physical.parmReturnMode());

        if (inventMovement.projId() && inventMovement.parmReturnMode())
        {
            inventMovement.parmPackingSlipId(vendPackingSlipJour.PackingSlipId);
        }

        inventUpd_Physical.updateNow(ledgerVoucher);

        updateNow           = inventUpd_Physical.updPhysicalUnit();
        updateNowInvent     = inventUpd_Physical.updPhysical();
        updateNowInventCW   = InventUpd_Physical.pdsCWUpdPhysical();

        // Restore voucher and transdate
        ledgerVoucher.lastVoucher(lastVoucher);
        ledgerVoucher.lastTransDate(lastTransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructPhysicalInventoryUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs an <c>InventUpd_Physical</c> instance.
    /// </summary>
    /// <returns>An <c>InventUpd_Physical</c> instance.</returns>
    protected InventUpd_Physical constructPhysicalInventoryUpdate()
    {
        return (InventUpd_Physical::newPurchPackingSlip(inventMovement,
                                                        vendPackingSlipTrans,
                                                        // <GEERU>
                                                        purchParmTable.Num ? purchParmTable.Num : vendPackingSlipJour.PackingSlipId,
                                                        // </GEERU>
                                                        previousVendPackingSlipTransHistory,
                                                        purchParmLine.InventDimId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePhysicalInventoryUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an <c>InventUpd_Physical</c> instance.
    /// </summary>
    /// <param name = "_inventUpd_Physical">The <c>InventUpd_Physical</c> to initialize.</param>
    protected void initializePhysicalInventoryUpdate(InventUpd_Physical _inventUpd_Physical)
    {
        _inventUpd_Physical.parmOnlyUpdateRegistered(purchParmUpdate.SpecQty == PurchUpdate::Recorded &&
                                                    PurchParameters::find().PurchRegisteredQuantitySelectionRule == PurchRegisteredQuantitySelectionRule::FilterToRegistered);
        if ((previousVendPackingSlipTransHistory || vendPackingSlipTrans.Qty < 0)
        &&  (purchTable.isInterCompanyOrder() || purchLine.isDropShipment()))
        {
            _inventUpd_Physical.parmAllowNegativePhysical(true);
        }

        _inventUpd_Physical.parmPreferFullPhysicalTrackingDim(true);

        if (purchLine.isConsignmentOrderLineLinkedToProductionBOMLine())
        {
            _inventUpd_Physical.parmAllowAutoReserveDim(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructAndInitializePhysicalInventoryUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs and initializes an <c>InventUpd_Physical</c> instance.
    /// </summary>
    /// <returns>An <c>InventUpd_Physical</c> instance.</returns>
    protected InventUpd_Physical constructAndInitializePhysicalInventoryUpdate()
    {
        InventUpd_Physical inventUpd_Physical = this.constructPhysicalInventoryUpdate();
        this.initializePhysicalInventoryUpdate(inventUpd_Physical);

        return inventUpd_Physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLeanSubcontracting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Records the lean subcontracting cost in case the posted line is related to a production flow.
    /// </summary>
    protected void postLeanSubcontracting()
    {
        RefRecId                productionFlowReferanceRecId;

        // Lean subcontracting
        if (!leanCostingFacade)
        {
            this.parmLeanCostingFacade(LeanCostingFacade::construct());
        }

        productionFlowReferanceRecId = leanCostingFacade.getProductionFlowFromPurchLine(purchLine);
        if (productionFlowReferanceRecId)
        {
            this.getLeanConversionCostUpd().addDirectOutsourcing(
                productionFlowReferanceRecId,
                vendPackingSlipTrans.ItemId,
                vendPackingSlipTrans.InventDimId,
                vendPackingSlipTrans.Qty,
                purchLine.lineAmountMSTExclTax()/purchLine.PurchQty,
                tableNum(VendPackingSlipTrans),
                vendPackingSlipTrans.RecId,
                purchLine.DefaultDimension,
                vendPackingSlipTrans.SourceDocumentLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLine</Name>
				<Source><![CDATA[
    protected void postLine()
    {
        // Note, don't let base class method run, lines are posted in this.journalizeSourceDocument().
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLineDiscount</Name>
				<Source><![CDATA[
    protected void postLineDiscount()
    {
        // Note, don't let base class method run, line level discounts are posted in this.journalizeSourceDocument().
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupOnTrans</Name>
				<Source><![CDATA[
    protected void postMarkupOnTrans()
    {
        MarkupTrans markupTrans;
        PurchTotals purchTotalsMarkup;

        if (isCountryRegion_RU)
        {
            purchTotalsMarkup = PurchTotals::newParmTable(purchParmTable, purchParmUpdate.SpecQty, purchParmUpdate.ParmId, purchParmUpdate.SumPurchId, DocumentStatus::PackingSlip);
            purchTotalsMarkup.calc();
            markup.setTax(purchTotalsMarkup.tax());

            if (versioningUpdateType != VersioningUpdateType::Initial)
            {
                delete_from markupTrans
                    where markupTrans.TransTableId == vendPackingSlipTrans.TableId &&
                          markupTrans.TransRecId   == vendPackingSlipTrans.RecId;
            }

            if (this.isProforma())
            {
                markup.postJournal(purchParmLine.ReceiveNow,
                                   purchParmLine.lineAmountExclTax(vendPackingSlipJour.DeliveryDate),
                                   purchLine,
                                   purchLine.DefaultDimension,
                                   vendPackingSlipTrans);
            }
            else
            {
                markup.postInvoice(purchParmLine.ReceiveNow,
                                    purchParmLine.lineAmountExclTax(vendPackingSlipJour.DeliveryDate),
                                    purchLine,
                                    ledgerVoucher,
                                    purchLine.DefaultDimension,
                                    vendPackingSlipTrans,
                                    purchLine.interCompanyLineAmount(purchParmLine.ReceiveNow, vendPackingSlipJour.DeliveryDate),
                                    purchLine.purchTable().isInterCompanyOrder() ? purchParmTable.Num : "");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupTable</Name>
				<Source><![CDATA[
    protected void postMarkupTable()
    {
        PurchTable              purchTableMarkup;
        VendPackingSlipTrans    vendPackingSlipTransLocal;
        PurchTotals             purchTotalsMarkup;

        if (isCountryRegion_RU)
        {
            purchTableMarkup = purchParmTable.purchTable();

            purchTotalsMarkup = PurchTotals::newParmTable(purchParmTable, purchParmUpdate.SpecQty, purchParmUpdate.ParmId, purchParmUpdate.SumPurchId, DocumentStatus::PackingSlip);
            purchTotalsMarkup.calc();
            markup.setTax(purchTotalsMarkup.tax());

            select sum(LineAmount_W) from vendPackingSlipTransLocal
                where vendPackingSlipTransLocal.VendPackingSlipJour == vendPackingSlipJour.RecId;

            if (purchTableMarkup)
            {
                if (this.isProforma())
                {
                    markup.postJournal(1,
                                       vendPackingSlipTransLocal.LineAmount_W,
                                       purchTableMarkup,
                                       purchTableMarkup.DefaultDimension,
                                       vendPackingSlipJour);
                }
                else
                {
                    markup.postInvoice(1,
                                    vendPackingSlipTransLocal.LineAmount_W,
                                    purchTableMarkup,
                                    ledgerVoucher,
                                    purchTableMarkup.DefaultDimension,
                                    vendPackingSlipJour,
                                    0,
                                    purchTableMarkup.isInterCompanyOrder() ? purchParmTable.Num : "");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNotStocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs posting routines for order lines that cannot be posted to inventory.
    /// </summary>
    protected void postNotStocked()
    {
        TradeNonStockedRegistrationHelper   tradeNonStockedRegistrationHelper;
        PurchQty                            varianceQty;
        PurchQty                            registerQty;

        updateNow   = vendPackingSlipTrans.Qty - previousVendPackingSlipTransHistory.Qty;
        varianceQty = purchParmLine.ReceiveNow + purchParmLine.RemainAfter - purchParmLine.RemainBefore;
        registerQty = updateNow - varianceQty;
        //Delete the pending receipt and pending registration records for the quantity being posted.
        tradeNonStockedRegistrationHelper = TradeNonStockedRegistrationHelper::newFromSalesPurchLine(purchLine);

        if (registerQty < 0 && purchLine.PurchQty > 0)
        {
            if (purchLine.isTangible())
            {
                tradeNonStockedRegistrationHelper.synchronizePendingRegistration(-(registerQty),false);
            }
        }
        else
        {
            tradeNonStockedRegistrationHelper.updatePendingQuantityOnPosting(registerQty);
        }

        this.handleLeanSubcontractedQtyChange();
        this.postLeanSubcontracting();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postRoundOff</Name>
				<Source><![CDATA[
    protected void postRoundOff()
    {
        // Note, don't let base class method run, roundoff are posted in this.journalizeSourceDocument().
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTax</Name>
				<Source><![CDATA[
    protected void postTax(boolean _post)
    {
        // Note, don't let base class method run, Tax are posted in this.journalizeSourceDocument().
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && _post)
        {
            ITaxableDocument taxableDocument = TaxableDocumentObject::construct(this.parmTaxableDocumentDescriptor());
            TaxBusinessService::postTax(ledgerVoucher, taxableDocument);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxOnProforma</Name>
				<Source><![CDATA[
    #ISOCountryRegionCodes
    protected boolean postTaxOnProforma()
    {
        boolean ret;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]))
        {
            ret = true;
        }

        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSourceDocument</Name>
				<Source><![CDATA[
    protected void processSourceDocument()
    {
        if (SourceDocumentCompletionRule::isTransferToFullyDistRequired())
        {
            // Transition lines to fully distributed. The distributions need to be there when the inventory voucher is processed.
            // The document can't be transitioned to Complete as this point because the transfer to GL must be deferred until the inventory voucher has
            // been processed.
            SourceDocumentProcessorFacade::submitSourceDocumentLinesForHeader(vendPackingSlipJour, SourceDocumentLineAccountingStatus::FullyDistributed);
        }
        else
        {
            SourceDocumentProcessorFacade::submitSourceDocumentImplementation(vendPackingSlipJour, false, SourceDocumentAccountingStatus::Completed);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFormletterJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes pointer for document line processing.
    /// </summary>
    protected void selectFormletterJournalTrans()
    {
        vendPackingSlipTrans.clear();

        Query query = this.buildSelectFormletterJournalTransQuery();
        vendPackingSlipTransQueryRun = new QueryRun(query);

        // Without this line condition '1=0' is added to sql query. This happens when packing slip in in three-level intercompany chain is canceled by user assigned to one legal entity.
        if (InterCompanyCancelPackingSlipSecurityFlight::instance().isEnabled() && InterCompanyCancelPackingSlipSecurityContext::current() && purchTable.InterCompanyDirectDelivery)
        {
            vendPackingSlipTransQueryRun.recordLevelSecurity(false);
        }

        if (vendPackingSlipTransQueryRun.next())
        {
            vendPackingSlipTrans = vendPackingSlipTransQueryRun.get(tableNum(VendPackingSlipTrans));
        }

        formletterJournalTrans.data(vendPackingSlipTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSelectFormletterJournalTransQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the <c>Query</c> object to select the <c>VendPackingSlipTrans</c> records.
    /// </summary>
    /// <returns>
    /// A <c>Query</c> object.
    /// </returns>
    protected Query buildSelectFormletterJournalTransQuery()
    {
        Query vendPackingSlipTransQuery = new Query();

        QueryBuildDataSource qbdsVendPackingSlipTrans = vendPackingSlipTransQuery.addDataSource(tableNum(VendPackingSlipTrans));
        qbdsVendPackingSlipTrans.addRange(fieldNum(VendPackingSlipTrans, VendPackingSlipJour)).value(queryValue(vendPackingSlipJour.RecId));

        if (previousVendPackingSlipVersion)
        {
            QueryBuildDataSource qbdsVendPackingSlipTransHistory = qbdsVendPackingSlipTrans.addDataSource(tableNum(VendPackingSlipTransHistory));
            qbdsVendPackingSlipTransHistory.joinMode(JoinMode::ExistsJoin);
            qbdsVendPackingSlipTransHistory.addLink(fieldNum(VendPackingSlipTrans, RecId), fieldNum(VendPackingSlipTransHistory, VendPackingSlipTrans));
            
            str qtyRange = strfmt('((%1.%2 != %3.%4))',
                                  vendPackingSlipTransQuery.dataSourceTable(tableNum(VendPackingSlipTrans)).name(),
                                  fieldStr(VendPackingSlipTrans, Qty),
                                  vendPackingSlipTransQuery.dataSourceTable(tableNum(VendPackingSlipTransHistory)).name(),
                                  fieldStr(VendPackingSlipTransHistory, Qty));

            qbdsVendPackingSlipTransHistory.addRange(fieldNum(VendPackingSlipTransHistory, Qty)).value(qtyRange);
        }

        return vendPackingSlipTransQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLine</Name>
				<Source><![CDATA[
    protected Common sourceLine()
    {
        return purchLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTable</Name>
				<Source><![CDATA[
    protected Common sourceTable()
    {
        return purchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startLines</Name>
				<Source><![CDATA[
    protected void startLines()
    {
        super();

        // Raise event transferCharges
        this.transferCharges(purchParmTable, vendPackingSlipJour);
        
        this.postVendorProdBOMHelper = new ProdJournalPostVendorProdBOMHelper();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogTxt</Name>
				<Source><![CDATA[
    protected TransTxt  transactionLogTxt()
    {
        return "@SYS2023";
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogType</Name>
				<Source><![CDATA[
    protected TransactionLogType  transactionLogType()
    {
        return TransactionLogType::PurchPackingSlip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferCharges</Name>
				<Source><![CDATA[
    delegate void transferCharges(PurchParmTable _purchParmTable, VendPackingSlipJour _vendPackingSlipJour)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankLC</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a Letter of Credit after posting the journal.
    /// </summary>
    private void updateBankLC()
    {
        BankLCImportType bankLCImportType;

        if (BankLCImportFeatureChecker::checkBankLCImportEnabled()
            && purchParmTable.BankLCImportLine != 0)
        {
            bankLCImportType = BankLCImportType::constructByPurchId(purchParmTable.PurchId, true, true);
            bankLCImportType.parmVersioningUpdateType(this.parmVersioningUpdateType());
            bankLCImportType.updatePackingSlipPosted(purchParmTable.BankLCImportLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCrossdocking</Name>
				<Source><![CDATA[
    protected void updateCrossdocking()
    {
        // Transfer orders, sales orders and intercompany purchase orders may be created during updating cross docking.
        RetailReplenishmentTransferOrder::checkOrCreateTransferOrder(purchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomsVendBOETrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///Updates status of CustomsVendBOEJour_IN and CustomsVendBOETrans_IN table once receipt is done.
    /// </summary>
    /// <param name="_customsVendBOETransRecID">
    /// The value to set.
    /// </param>
    public void updateCustomsVendBOETrans_IN(RecId _customsVendBOETransRecID)
    {
        CustomsVendBOETrans_IN  customsVendBOETrans;

        ttsbegin;
        customsVendBOETrans = CustomsVendBOETrans_IN::findRecId(_customsVendBOETransRecID);
        CustomsBOEJournalFacade_IN::tweakBOEJourReceiveStatus(customsVendBOETrans.CustomsBillOfEntryJournal_IN);
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDate</Name>
				<Source><![CDATA[
    protected TransDate updateDate()
    {
        return vendPackingSlipVersion.AccountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Overwrite to update receive status.
    /// </summary>
    protected void updateJournalLine()
    {
        // <GIN>
        CustomsVendPackingSlipBOETransLink_IN customsVendPackingSlipBOETransLink;
        // </GIN>

        super();
        // <GIN>
        if (isCustomsMarked
            && VendDocumentLineMap::isTransactionRelatedToBOE_IN(purchLine.purchTable(), purchParmUpdate))
        {
            customsVendPackingSlipBOETransLink = CustomsVendPackingSlipBOETransLink_IN::findByVendPackingSlipTrans(vendPackingSlipTrans.RecId);
            this.updateCustomsVendBOETrans_IN(customsVendPackingSlipBOETransLink.CustomsVendBOETrans_IN);
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProduction</Name>
				<Source><![CDATA[
    protected void updateProduction(InventQty _qtyUpdateNow)
    {
        if (purchLine.InventRefId && purchLine.ItemRefType == InventRefType::ProdLine)
        {
            ProdBOM prodBOM = ProdBOM::findTransId(purchLine.InventRefTransId);

            if (prodBOM)
            {
                if (isPostVendorProdBOMInOrderFeatureEnabled)
                {
                    postVendorProdBOMHelper.addProdBOM(prodBOM, this.updateDate(), _qtyUpdateNow, purchLine);
                }
                else
                {
                    prodBOM.postVendorProdBOM(this.updateDate(), _qtyUpdateNow, purchLine);
                    prodBOM.postVendorProdRoute(this.updateDate(), _qtyUpdateNow, purchLine);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLines</Name>
				<Source><![CDATA[
    protected void endLines()
    {
        if (isPostVendorProdBOMInOrderFeatureEnabled)
        {
            postVendorProdBOMHelper.postProdBOM();
            postVendorProdBOMHelper.postProdRoute();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectJournal</Name>
				<Source><![CDATA[
    protected void  updateProjectJournal(InventQty  _inventQtyUpdateNow)
    {
        InventJournalTrans  inventJournalTrans;

        if (purchLine.ProjId
            && purchLine.InventRefTransId
            && !purchLine.purchTable().isProjectSalesItemReqPO()
            && !purchLine.getProjCreditNoteSource().purchTable().isProjectSalesItemReqPO())
        {
            select firstonly forupdate inventJournalTrans
                index hint TransIdIdx
                where inventJournalTrans.InventTransId == purchLine.InventRefTransId;

            if (inventJournalTrans && !inventJournalTrans.inventJournalTable().Posted && inventJournalTrans.Qty <= _inventQtyUpdateNow + purchLine.receivedInventInTotal())
            {
                inventJournalTrans.TransDate = this.updateDate();
                inventJournalTrans.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveReferenceTransIdMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a map from the related source lines.
    /// </summary>
    /// <param name = "_purchLine">
    /// A purchase order line record buffer.
    /// </param>
    /// <param name = "_salesUpdateQty">
    /// A <c>PurchQty</c> value.
    /// </param>
    /// <param name = "_updateNowInventCW">
    /// A <c>PdsCWQty</c> value.
    /// </param>
    /// <returns>
    /// A <c>Map</c> object with related source lines.
    /// </returns>
    protected Map retrieveReferenceTransIdMap(PurchLine _purchLine, PurchQty _salesUpdateQty, PdsCWQty _updateNowInventCW)
    {
        Map referenceTransIdMap = new Map(Types::String, Types::Container);

        if (!_salesUpdateQty)
        {
            return referenceTransIdMap;
        }

        if (!_purchLine)
        {
            return referenceTransIdMap;
        }
      
        referenceTransIdMap.insert(_purchLine.InventRefTransId, [_salesUpdateQty, _updateNowInventCW]);

        return referenceTransIdMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateDeliveryNowOnSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the delivery now fields on the sales line.
    /// </summary>
    /// <param name = "_salesLine">
    /// A sales order line record buffer.
    /// </param>
    /// <param name = "_salesUpdateQty">
    /// A <c>PurchQty</c> value.
    /// </param>
    /// <param name = "_updateNowInventCW">
    /// A <c>PdsCWQty</c> value.
    /// </param>
    protected void populateDeliveryNowOnSalesLine(SalesLine _salesLine, PurchQty _salesUpdateQty, PdsCWQty _updateNowInventCW)
    {
        _salesLine.SalesDeliverNow += _salesUpdateQty;
        _salesLine.setInventDeliverNow();
        _salesLine.PdsCWInventDeliverNow += _updateNowInventCW;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDeliveryNowOnSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the delivery now fields on the sales order line record buffer.
    /// </summary>
    /// <param name = "_salesLine">
    /// A <c>SalesLine</c> record buffer.
    /// </param>
    /// <param name = "_salesUpdateQty">
    /// A <c>PurchQty</c> value.
    /// </param>
    /// <param name = "_updateNowInventCW">
    /// A <c>PdsCWQty</c> value.
    /// </param>
    /// <param name = "_purchUnit">
    /// A purchase unit value.
    /// </param>
    protected void updateDeliveryNowOnSalesLine(SalesLine _salesLine, PurchQty _salesUpdateQty, PdsCWQty _updateNowInventCW, UnitOfMeasureSymbol _purchUnit)
    {
        if (_salesLine.SalesUnit != _purchUnit)
        {
            _salesUpdateQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(
                                  _salesLine.ItemId,
                                  _salesLine.InventDimId,
                                  _salesUpdateQty,
                                  _purchUnit,
                                  _salesLine.SalesUnit,
                                  NoYes::No);
        }

        this.populateDeliveryNowOnSalesLine(_salesLine, _salesUpdateQty, _updateNowInventCW);

        _salesLine.doUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventTransIdRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new query range from the record buffer.
    /// </summary>
    /// <param name = "_salesLine">
    /// A sales order line record buffer.
    /// </param>
    /// <returns>
    /// An instance of the <c>QueryBuildRange</c> class.
    /// </returns>
    protected QueryBuildRange addInventTransIdRange(SalesLine _salesLine)
    {
        QueryBuildRange inventTransIdRange = updateSalesLinesQuery.query().dataSourceTable(tableNum(SalesLine)).addRange(fieldNum(SalesLine,InventTransId));
        
        inventTransIdRange.value(queryValue(_salesLine.InventTransId));

        return inventTransIdRange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareSalesLineForPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepares a sales line record buffer for the packing slip posting
    /// </summary>
    /// <param name = "_salesLineInventTransId">
    /// An <c>InventTransId</c> value
    /// </param>
    /// <param name = "_purchLine">
    /// The source purchase line record buffer.
    /// </param>
    /// <param name = "_salesUpdateQty">
    /// A <c>PurchQty</c> value.
    /// </param>
    /// <param name = "_updateNowInventCW">
    /// A <c>PdsCWQty</c> value.
    /// </param>
    /// <returns>
    /// true if the sales order line has been prepared; otherwise false.
    /// </returns>
    protected boolean prepareSalesLineForPosting(InventTransId _salesLineInventTransId, PurchLine _purchLine, PurchQty _salesUpdateQty, PdsCWQty _updateNowInventCW)
    {
        SalesLine salesLine = SalesLine::findInventTransId(_salesLineInventTransId, true);

        if (salesLine)
        {
            this.addInventTransIdRange(salesLine);

            this.updateDeliveryNowOnSalesLine(salesLine, _salesUpdateQty, _updateNowInventCW, _purchLine.PurchUnit);
        }

        return (salesLine.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepares the related sales line record buffer for the packing slip posting
    /// </summary>
    /// <param name = "_purchLine">
    /// A purchase order line record buffer.
    /// </param>
    /// <param name = "_salesUpdateQty">
    /// A <c>PurchQty</c> value.
    /// </param>
    /// <param name = "_updateNowInventCW">
    /// A <c>PdsCWQty</c> value.
    /// </param>
    protected void updateSalesLine(PurchLine _purchLine, PurchQty _salesUpdateQty, PdsCWQty _updateNowInventCW = 0)
    {
        MapEnumerator referenceTransIdEnumerator = this.retrieveReferenceTransIdMap(_purchLine, _salesUpdateQty, _updateNowInventCW).getEnumerator();

        while (referenceTransIdEnumerator.moveNext())
        {
            InventTransId referenceTransId = referenceTransIdEnumerator.currentKey();
            PurchQty salesUpdateQty;
            PdsCWQty updateNowPdsInventCW;

            [salesUpdateQty, updateNowPdsInventCW] = referenceTransIdEnumerator.currentValue();

            updateSalesLines = this.prepareSalesLineForPosting(referenceTransId, _purchLine, salesUpdateQty, updateNowPdsInventCW) || updateSalesLines;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSalesFormLetter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>SalesFormLetter_PackingSlip</c> class.
    /// </summary>
    /// <returns>
    /// Te <c>SalesFormLetter_PackingSlip</c> instance.
    /// </returns>
    protected SalesFormLetter_PackingSlip createSalesFormLetter()
    {
        return SalesFormLetter::construct(DocumentStatus::PackingSlip);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjectSalesFormLetter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>SalesFormLetter_PackingSlipProject</c> class.
    /// </summary>
    /// <returns>
    /// The <c>SalesFormLetter_PackingSlipProject</c> instance.
    /// </returns>
    protected SalesFormLetter_PackingSlipProject createProjectSalesFormLetter()
    {
        SalesFormLetter_PackingSlipProject salesFormLetterPackingSlip = SalesFormLetter::construct(DocumentStatus::ProjectPackingSlip);
        salesFormLetterPackingSlip.resetParmListCommonCS();
        return salesFormLetterPackingSlip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeSalesFormLetter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>SalesFormLetter_PackingSlip</c> instance.
    /// </summary>
    /// <param name = "_salesFormLetter">
    /// A <c>SalesFormLetter_PackingSlip</c> instance.
    /// </param>
    /// <param name = "_updateSalesLinesQuery">
    /// A <c>SysQueryRun</c> instance.
    /// </param>
    /// <returns>
    /// The <c>SalesFormLetter_PackingSlip</c> instance.
    /// </returns>
    protected SalesFormLetter_PackingSlip initializeSalesFormLetter(SalesFormLetter_PackingSlip _salesFormLetter, SysQueryRun _updateSalesLinesQuery)
    {
        PurchFormLetterContract purchFormLetterContract = this.parmChainFormletterContract();

        TradePackingSlipJourChain   tradePackingSlipJourChain;
        CustPackingSlipJour         custPackingSlipJour;

        _salesFormLetter.parmIdSynched(purchParmTable.ParmId);
        if (!previousVendPackingSlipVersion)
        {
            _salesFormLetter.chooseLinesQuery(_updateSalesLinesQuery);
        }
        else
        {
            select forupdate firstonly custPackingSlipJour
                exists join RecId from tradePackingSlipJourChain
                    where tradePackingSlipJourChain.CustPackingSlipJour == custPackingSlipJour.RecId
                       && tradePackingSlipJourChain.VendPackingSlipJour == vendPackingSlipJour.RecId;

            if (custPackingSlipJour.RecId)
            {
                _salesFormLetter.parmCallerTable(custPackingSlipJour);
            }
        }

        _salesFormLetter.parmParmTableRefIdSynched(purchParmTable.TableRefId);
        _salesFormLetter.parmVersioningUpdateType(this.parmVersioningUpdateType());
        _salesFormLetter.transDate(this.updateDate());
        _salesFormLetter.specQty(SalesUpdate::DeliverNow);
        _salesFormLetter.creditRemaining(true);
        _salesFormLetter.printFormLetter (this.parmPrintSalesFormLetter());
        _salesFormLetter.chooseLines(false,true);
        _salesFormLetter.parmRelatedJournal(vendPackingSlipJour);
        _salesFormLetter.parmAccountingDate(purchFormLetterContract.parmAccountingDate());
        _salesFormLetter.parmVersionDateTime(purchFormLetterContract.parmVersionDateTime());

        // Don't call runShipCarrier here because it invokes a dialog that has to be handled separately.
        _salesFormLetter.parmSkipRunShipCarrier(true);

        // We need o use print management when posting sales packing slip via direct delivery from purchase product receipt posting as we don't have UI access.
        _salesFormLetter.usePrintManagement(true);

        return _salesFormLetter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the sales packingslip posting.
    /// </summary>
    /// <param name = "_updateSalesLinesQuery">
    /// A <c>SysQueryRun</c> object.
    /// </param>
    protected void updateSalesTable(SysQueryRun _updateSalesLinesQuery)
    {
        SalesFormLetter_PackingSlip salesFormLetter;
        
        SalesLine localSalesLine = SalesLine::findInventTransId(purchLine.InventRefTransId);
        if (localSalesLine.ProjId && localSalesLine.SalesType == SalesType::ItemReq)
        {
            salesFormLetter = this.createProjectSalesFormLetter();
        }
        else
        {
            salesFormLetter = this.createSalesFormLetter();
        }
        this.initializeSalesFormLetter(salesFormLetter, _updateSalesLinesQuery);

        salesFormLetter.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the source line must be updated or not.
    /// </summary>
    /// <param name = "_purchLine">
    /// A <c>PurchLine</c> record buffer.
    /// </param>
    /// <returns>
    /// true if the source line must be updated; otherwise false.
    /// </returns>
    protected boolean mustUpdateSourceLine(PurchLine _purchLine)
    {
        return _purchLine.isDropShipment();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepares the source line for the packing slip posting
    /// </summary>
    protected void updateSourceLine()
    {
        PurchLineType               purchLineType;
        PurchLine                   orderLine;
        // <GEERU>
        PurchLine_W                 purchLine_W;
        #isoCountryRegionCodes
        // </GEERU>

        if (this.mustUpdateSourceLine(purchLine))
        {
            this.updateSalesLine(purchLine, updateNow, updateNowInventCW);
        }

        this.updateProjectJournal(updateNowInvent);

        this.updateProduction(updateNowInvent);

        if (!purchLine.isStocked()) //Values are set by the inventposting for stocked purchase lines (InventMov_purch).
        {
            purchLine.RemainPurchPhysical  = vendPackingSlipTrans.Remain;
            purchLine.RemainPurchFinancial += vendPackingSlipTrans.Qty - previousVendPackingSlipTransHistory.Qty;
        }

        purchLineType = PurchLineType::construct(purchLine);
        purchLineType.updatePurchLine(inventMovement ? inventMovement.transIdSum() : null);

        switch (purchLineType.parmStatusUpdateResults())
        {
            case PurchStatus::Invoiced:
                checkFailed("@SYS113195");   //Status was not changed to Invoiced because one or more pending invoices exist.
                break;
            case PurchStatus::Canceled:
                checkFailed("@SYS113196");   //Status was not changed to Canceled because one or more pending invoices exist.
                break;
        }

        // <GEERU>
        if (isCountryRegion_RU)
        {
            purchLine_W = purchLine.purchLine_W();
            purchLine_W.DeviationQty_RU = 0;
            purchLine.packPurchLine_W(purchLine_W);
        }
        // </GEERU>

        if (PurchUpdateFromJournalPostFlight::instance().isEnabled())
        {
            using (var purchLineSkipBusinessLogicContext = PurchLineSkipBusinessLogicContext::construct())
            {
                purchLineSkipBusinessLogicContext.parmSkipUpdate(true);
                purchLine.update();
            }
        }
        else
        {
            purchLine.doUpdate();
        }

        purchLine.SysExtensionSerializerMap::postUpdate();

        if (purchLine.LineDeliveryType == LineDeliveryType::DeliveryLine)
        {
            orderLine = PurchDeliverySchedule::findOrderLineForDeliveryLine(purchLine.InventTransId, true);
            orderLine.setPurchStatus();
            orderLine.doUpdate();
        }

        this.interCompanyTransferBatchSerial(StatusIssue::Deducted);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceLineBeforePosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs updates that are to be done before posting, on the <c>PurchLine</c> record.
    /// </summary>
    /// <remarks>
    /// Creates the fixed asset, if asset is to be created for the line; and updates the line with asset
    /// details.
    /// </remarks>
    protected void updateSourceLineBeforePosting()
    {
        // Create the fixed asset and update the PurchParmLine.
        PurchParmLine_Asset purchParmLine_Asset = purchParmLine.purchParmLine_Asset(true);

        if (this.mustCreateFixedAsset(purchParmLine_Asset))
        {
            this.createFixedAsset(purchParmLine, purchParmLine_Asset);
        }
        else if (purchLine.AssetId != strMin())
        {
            PurchLine::updateFixedAssetWithPurchRecId(purchLine.RecId, purchLine.AssetId);
        }

        purchLine.initFromPurchParmLine_Asset(purchParmLine_Asset);

        if (this.mustUpdateAssetInventoryTransaction())
        {
            purchLine.assetUpdateInventTrans();
        }

        purchLine.doUpdate();
        purchLine.SysExtensionSerializerMap::postUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateAssetInventoryTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Determines if asset inventory transaction must be updated.
    /// </summary>
    /// <returns>true if asset inventory transaction must be updated; otherwise, false.</returns>
    protected boolean mustUpdateAssetInventoryTransaction()
    {
        return purchLine.orig().AssetId != purchLine.AssetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateFixedAsset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if fixed assert must be created.
    /// </summary>
    /// <param name = "_purchParmLineAsset">The purchase order lines asset information record.</param>
    /// <returns>true if the fixed asset must be created; otherwise, false.</returns>
    protected boolean mustCreateFixedAsset(PurchParmLine_Asset _purchParmLineAsset)
    {
        return _purchParmLineAsset.CreateFixedAsset == NoYes::Yes
            && AssetParameters::find().AssetAllowCreate == NoYes::Yes
            && purchParmLine.ReceiveNow > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceTable</Name>
				<Source><![CDATA[
    protected void updateSourceTable()
    {
        SetEnumerator se = ordersPosted.getEnumerator();

        ttsbegin;
        while (se.moveNext())
        {
            purchTable = PurchTable::find(se.current(),true);
            if (purchTable)
            {
                purchTable.updateDocumentStatus(this.documentStatus());
                purchTable.updateBackStatus();
                purchTable.updatePurchaseType();
            }
        }

        if (chainFormletterContract
            && chainFormletterContract.parmCallerTable().TableId == tableNum(EGAISWaybillJour_RU))
        {
            EGAISWaybillJour_RU     waybillJour, waybillJourUpd;

            waybillJour = chainFormletterContract.parmCallerTable();
            if (waybillJour)
            {
                waybillJourUpd = EGAISWaybillJour_RU::findRecId(waybillJour.RecId, true);
                waybillJourUpd.StatusReceipt        = EGAISWaybillStatusReceipt_RU::ProductReceiptPosted;
                waybillJourUpd.VendPackingSlipJour  = VendPackingSlipJour.RecId;
                waybillJourUpd.update();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeTaxAmount_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates GEEW tax fields of the packing slip lines.
    /// </summary>
    /// <remarks>
    /// Taxes are written in the purchPackingSlipJournalCreate.updateJournalLine() method.
    /// </remarks>
    protected void writeTaxAmount_W()
    {
        //taxes written in purchPackingSlipJournalCreate.updateJournalLine()
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static PurchPackingSlipJournalPost construct()
    {
        return new PurchPackingSlipJournalPost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPostEndUpdateHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the end update for the <c>PurchPackingSlipJournalPost</c> object.
    /// </summary>
    /// <param name="_args">
    /// The <c>XppPrePostArgs</c> object that holds the <c>PurchPackingSlipJournalPost</c> values.
    /// </param>
    public static void mcrPostEndUpdateHandler(XppPrePostArgs _args)
    {
        PurchPackingSlipJournalPost purchPackingSlipJournalPost = _args.getThis();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPostInitHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PurchPackingSlipJournalPost</c> object.
    /// </summary>
    /// <param name="_args">
    /// The <c>XppPrePostArgs</c> object that holds the values for the <c>PurchPackingSlipJournalPost</c> object.
    /// </param>
    /// <remarks>
    /// This method is called by an event handler.
    /// </remarks>
    public static void mcrPostInitHandler(XppPrePostArgs _args)
    {
        PurchPackingSlipJournalPost purchPackingSlipJournalPost = _args.getThis();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransLink_RU</Name>
				<Source><![CDATA[
    private void createTransLink_RU()
    {
        LedgerTransLink_RU      ledgerTransLink;
        VendPackingSlipTrans    packingSlipTrans;
        InventTrans             inventTrans;
        InventTransOrigin       inventTransOrigin;
        InventTrans             inventTransOrig;
        TransLink_RU            transLink;

        while select inventTrans
            join RefPri from transLink
                where transLink.RefTableId  == tablenum(InventTrans)
                   && transLink.RefSec      == inventTrans.RecId
            exists join inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
            exists join packingSlipTrans
                where packingSlipTrans.InventTransId         == inventTransOrigin.InventTransId
                   && packingSlipTrans.VendPackingSlipJour   == vendPackingSlipJour.RecId
        {
            inventTransOrig = InventTrans::findRecId(transLink.RefPri);
            ledgerTransLink = LedgerTransLink_RU::newTrans(inventTrans, inventTransOrig);
            ledgerTransLink.parmVoucherField(fieldnum(InventTrans, VoucherPhysical));
            ledgerTransLink.parmAccountingDateField(fieldnum(InventTrans, DatePhysical));
            ledgerTransLink.parmReportingDate(inventTransOrig.DatePhysical);
            ledgerTransLink.run();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSiblingLinesInOtherJournals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the siblings decrementing by the appropriate quantity value for Purchase order and Inventory.
    /// </summary>
    /// <remarks>
    /// If more than one product receipt journal is posted at the same time for the same purchase order line we need to update the sibling lines
    /// after each posting so the next posting happens based on updated quantities.
    /// </remarks>
    protected void updateSiblingLinesInOtherJournals()
    {
        PurchParmLine   purchParmLineSibling;
        PurchParmTable  purchParmTableLocal;

        PurchQty setQtyToZeroIfNegative(PurchQty _qty)
        {
            if (_qty * purchLine.PurchQty < 0)
            {
                return 0;
            }

            return _qty;
        }

        ttsbegin;
        while select forupdate purchParmLineSibling
            exists join purchParmTableLocal
            where purchParmLineSibling.TableRefId    == purchParmTableLocal.TableRefId
               && purchParmTableLocal.ParmJobStatus  == ParmJobStatus::Waiting
               && purchParmLineSibling.InventTransId == purchLine.InventTransId
               && purchParmLineSibling.RecId         != purchParmLine.RecId
        {
            purchParmLineSibling.RemainBeforeInvent -= purchParmLine.InventNow;
            purchParmLineSibling.RemainBeforeInvent  = setQtyToZeroIfNegative(purchParmLineSibling.RemainBeforeInvent);

            purchParmLineSibling.RemainAfterInvent -= purchParmLine.InventNow;
            purchParmLineSibling.RemainAfterInvent  = setQtyToZeroIfNegative(purchParmLineSibling.RemainAfterInvent);

            purchParmLineSibling.RemainBefore -= purchParmLine.ReceiveNow;
            purchParmLineSibling.RemainBefore  = setQtyToZeroIfNegative(purchParmLineSibling.RemainBefore);

            purchParmLineSibling.RemainAfter -= purchParmLine.ReceiveNow;
            purchParmLineSibling.RemainAfter  = setQtyToZeroIfNegative(purchParmLineSibling.RemainAfter);

            purchParmLineSibling.RemainBeforeInventPhysical -= purchParmLine.InventNow;
            purchParmLineSibling.RemainBeforeInventPhysical  = setQtyToZeroIfNegative(purchParmLineSibling.RemainBeforeInventPhysical);

            purchParmLineSibling.doUpdate();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSiblingLinesInSameJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the siblings decrementing by the appropriate quantity value for Purchase order and Inventory.
    /// </summary>
    /// <remarks>
    /// If more than one line in a product receipt journal posts quantities for same purchase order line we need to update the sibling lines
    /// so the next line posts based on updated remaining Before and After quantities.
    /// </remarks>
    protected void updateSiblingLinesInSameJournal()
    {
        VendPackingSlipTrans vendPackingSlipTransSibling;

        PurchQty setQtyToZeroIfNegative(PurchQty _qty)
        {
            if (_qty * purchLine.PurchQty < 0)
            {
                return 0;
            }

            return _qty;
        }

        ttsbegin;

        while select forUpdate vendPackingSlipTransSibling
            where vendPackingSlipTransSibling.RecId                != vendPackingSlipTrans.RecId
                && vendPackingSlipTransSibling.PackingSlipId       == vendPackingSlipTrans.PackingSlipId
                && vendPackingSlipTransSibling.InventTransId       == vendPackingSlipTrans.InventTransId
                && vendPackingSlipTransSibling.VendPackingSlipJour == vendPackingSlipTrans.VendPackingSlipJour
        {
            if (!this.getLinesPosted().in(vendPackingSlipTransSibling.RecId))
            {
                vendPackingSlipTransSibling.Remain -= vendPackingSlipTrans.Qty;
                vendPackingSlipTransSibling.Remain = setQtyToZeroIfNegative(vendPackingSlipTransSibling.Remain);
                vendPackingSlipTransSibling.RemainInvent -= vendPackingSlipTrans.InventQty;
                vendPackingSlipTransSibling.RemainInvent = setQtyToZeroIfNegative(vendPackingSlipTransSibling.RemainInvent);
                vendPackingSlipTransSibling.doUpdate();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSingleLine</Name>
				<Source><![CDATA[
    protected void postSingleLine(boolean _countryRegion_RU,
                                  boolean _hasQualityOrder,
                                  boolean _isExciseEnableIN,
                                  boolean _isVATEnableIN,
                                  boolean _isCustomsEnableIN,
                                  boolean _isConfigurationkeyRetailEnabled)
    {
        boolean needContext = purchTable.ProjId != '' && this.versioningUpdateType == versioningUpdateType::Cancel && ProjProductReceiptCancellationMarkingUpdateFlight::instance().isEnabled();

        using (ProjProductReceiptCancellationMarkingUpdateContext context = needContext ? ProjProductReceiptCancellationMarkingUpdateContext::construct() : null)
        {
            using (var activityContext = instrumentationLogger.purchFormLetterInstrumentationActivities().purchPostPackingSlipSingleLine())
            {
                super(_countryRegion_RU,
                  _hasQualityOrder,
                  _isExciseEnableIN,
                  _isVATEnableIN,
                  _isCustomsEnableIN,
                  _isConfigurationkeyRetailEnabled);

                activityContext.addCustomProperty(PurchPurchaseOrderInstrumentationActivities::PurchTableRecId, any2Str(this.purchTable.RecId));
                activityContext.addCustomProperty(PurchPurchaseOrderInstrumentationActivities::SourceDocumentLine, any2Str(this.purchLine.SourceDocumentLine));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        using (var activityContext = instrumentationLogger.purchFormLetterInstrumentationActivities().purchPostPackingSlipSingleOrder())
        {
            super();

            activityContext.addCustomProperty(PurchPurchaseOrderInstrumentationActivities::PurchTableRecId, any2Str(this.purchTable.RecId));
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>