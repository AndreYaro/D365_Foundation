<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BookTransCalc_Purch_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
class BookTransCalc_Purch_RU extends BookTransCalc_RU
{
    TmpPurchBookVATProcessLogTransOper_RU   tmpProcessLogTransOper;
    TmpRestoredVATLogTrans_RU               tmpRestoredVATLogTrans;
    PurchBookVATProcessParameters_RU        vatProcessParameters;
    INN_RU                                  inn;
    KPPU_RU                                 kpp;
    Name                                    name;

    boolean                                 isGroupBy;
    TransDate                               maxAssetOpenDate;
    TransDate                               closingDate;
    boolean                                 messageAlreadySettled;
    boolean                                 checkTransForProcess;
    Integer                                 numOfMonths;
    Map                                     contractorsOpenMapMap, contractorsOpenMap, contractorsStornoMap;
    Map                                     mapFactureAdjBaseAmounts;
    Set                                     contractorsExcludeSet;
    Set                                     contractorsNotAssetSet;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>appendGtd</Name>
				<Source><![CDATA[
    protected Str1260 appendGtd(VendTrans _vendTrans)
    {
        FactureTrans_RU factureTrans;
        Str1260 countryGTD;
        InventGTD_RU inventGTD_RU;
        LogisticsAddressCountryRegion addressCountryRegion;

        const str comma = ', ';

        while select InventGTDId from factureTrans
            group by InventGTDId
            where factureTrans.FactureId == factureJour.FactureId &&
                  factureTrans.Module == factureJour.Module &&
                  factureTrans.InvoiceDate == _vendTrans.TransDate &&
                  factureTrans.InvoiceId == _vendTrans.Invoice &&
                  factureTrans.InventGTDId
        join inventGTD_RU
            where inventGTD_RU.InventGTDId == factureTrans.InventGTDId
                && inventGTD_RU.ItemId == factureTrans.ItemId
        join addressCountryRegion
            where addressCountryRegion.CountryRegionId == inventGTD_RU.ItemOrigCountryRegionId
        {
            // BP deviation documented
            if (countryGTD)
            {
                countryGTD += comma;
            }

            countryGTD += strFmt('%1', factureTrans.InventGTDId);
        }

        return countryGTD;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    public void calc()
    {
        if (RestoredVATLogTable_RU::checkApproved(toDate) && !checkTransForProcess)
        {
            if (this.isRestoredVAT())
            {
                this.processRestoredVAT();
            }
        }
        else
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAmountAdjFactor</Name>
				<Source><![CDATA[
    protected Factor calcAmountAdjFactor(
        TaxCode          _taxCode,
        DimensionDefault _defaultDimension,
        container        _settledAmountsKey)
    {
        Factor                              factor;
        container                           key;
        FactureCalcBalances_OnPayment_RU    factureCalcBalances;
        Map                                 mapFactureAmountsDetails;

        PurchBookVATProcessLogTransOper_RU  processLogTransOper;
        PurchBookVATProcessLogTrans_RU      processLogTrans;

        BookStructSmallVATAmounts_RU        baseAmounts, usedAmounts;

        TransDate                           settlementDate, reverseDate;
        RecId                               transRecId, settlementRecId, reverseTransRecId, paymentTransRecId;
        NoYes                               reverseTrans;
        CompanyId                           transCompany;
        CompanyId                           offsetCompany;

        if (!mapFactureAdjBaseAmounts)
        {
            mapFactureAdjBaseAmounts = new Map(Types::Container, Types::Container);

            factureCalcBalances = new FactureCalcBalances_OnPayment_RU(factureJour);
            factureCalcBalances.calc();

            mapFactureAdjBaseAmounts = this.reduceSettlementMap(factureCalcBalances.mapMapSettledAmounts());
        }

        if (! mapFactureAdjBaseAmounts.exists(_settledAmountsKey))
        {
            return 0;
        }

        mapFactureAmountsDetails = Map::create(mapFactureAdjBaseAmounts.lookup(_settledAmountsKey));
        mapFactureAmountsDetails = this.groupByMapFactureAmounts(mapFactureAmountsDetails);

        [settlementDate,settlementRecId,transRecId,paymentTransRecId,reverseTransRecId,reverseTrans,reverseDate,transCompany,offsetCompany] = _settledAmountsKey;

        key = [_taxCode, _defaultDimension, '', '', '', ''];

        if (mapFactureAmountsDetails.exists(key))
        {
            baseAmounts = BookStructSmallVATAmounts_RU::create(mapFactureAmountsDetails.lookup(key));

            if (! baseAmounts.amountLiableToVAT())
            {
                return 0;
            }

            usedAmounts = new BookStructSmallVATAmounts_RU();

            select sum(AmountLiableToVAT), sum(TaxAmount) from processLogTransOper
                where processLogTransOper.DefaultDimension    == _defaultDimension                    &&
                      processLogTransOper.TaxCode             == _taxCode                             &&
                      processLogTransOper.Blocked             == NoYes::No                            &&
                      processLogTransOper.BlockedAuto         == NoYes::No                            &&
                      processLogTransOper.CanceledRefRecId    == 0                                    &&
                      processLogTransOper.TransDate           >= fromDate                             &&
                      processLogTransOper.TransDate           <= toDate                               &&
                      processLogTransOper.DocumentType        == PurchBookVATDocumentType_RU::Unknown
            exists join processLogTrans
                where processLogTrans.RecId           == processLogTransOper.RefRecId   &&
                      processLogTrans.FactureId       == factureJour.FactureId          &&
                      processLogTrans.InvoiceRecIdRef == transRecId                     &&
                      processLogTrans.PaymentRecIdRef == paymentTransRecId              &&
                      processLogTrans.InvoiceCompany  == transCompany                   &&
                      processLogTrans.PaymentCompany  == offsetCompany                  &&
                      processLogTrans.SettlementRecId == settlementRecId                &&
                      processLogTrans.SettlementDate  == settlementDate                 &&
                      processLogTrans.ProcessingType  == PurchBookProcessingType_RU::Standard;

            usedAmounts.addAmounts(processLogTransOper.AmountLiableToVAT + processLogTransOper.TaxAmount,
                                   processLogTransOper.AmountLiableToVAT,
                                   processLogTransOper.TaxAmount);

            factor = usedAmounts.amountLiableToVAT() / baseAmounts.amountLiableToVAT();
        }

        return factor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAmountAdjustments</Name>
				<Source><![CDATA[
    protected Map calcAmountAdjustments(container _settledAmountsKey)
    {
        TransDate                           settlementDate, reverseDate;
        RecId                               transRecId, settlementRecId, reverseTransRecId, paymentTransRecId;
        NoYes                               reverseTrans;
        CompanyId                           transCompany;
        CompanyId                           offsetCompany;

        container                           key;
        Factor                              factor;
        TransDate                           correctedPeriod;
        TransDate                           dateFrom, dateTo;
        FactureId_RU                        sourceFactureId;
        FactureJour_RU                      factureJourOrig;
        FactureTrans_RU                     factureTrans;
        PurchBookVATProcessLogTransOper_RU  logTransOperPeriod;
        PurchBookVATProcessLogTrans_RU      logTransPeriod;

        AmountMST                           amountInclVAT;
        TaxBase                             amountLiableToVAT;
        TaxAmount                           amountVAT;
        BookStructSmallVATAmounts_RU        structAmounts;
        Set                                 taxPeriodsSet;
        SetEnumerator                       setEnumerator;
        BookTransCalc_Purch_RU              bookTransCalc;
        Map                                 factureAdjustments;
        Map                                 mapBookTransCalc         = new Map(Types::Container, Types::Class);
        Map                                 mapMapFactureAdjustments = new Map(Types::Container, Types::Container);
        ;

        if (! factureJour.AmountAdjustment)
        {
            return mapMapFactureAdjustments;
        }

        [settlementDate, settlementRecId, transRecId, paymentTransRecId, reverseTransRecId, reverseTrans, reverseDate, transCompany, offsetCompany] = _settledAmountsKey;

        while select sum(LineAmountMST),
                     sum(TaxAmountMST),
                     sum(vatAmountMST)
                from factureTrans
                group by SourceFactureId, TaxCode, DefaultDimension
            where factureTrans.FactureId == factureJour.FactureId &&
                  factureTrans.Module    == factureJour.Module    &&
                 !factureTrans.ExcludeFromBook
        {
            if (sourceFactureId != factureTrans.SourceFactureId)
            {
                sourceFactureId = factureTrans.SourceFactureId;
                factureJourOrig = FactureJour_RU::find(sourceFactureId, factureJour.Module);
            }

            taxPeriodsSet = new Set(Types::Container);
            while select logTransOperPeriod
                group by TransDate
                where logTransOperPeriod.TaxCode            == factureTrans.TaxCode          &&
                      logTransOperPeriod.DefaultDimension   == factureTrans.DefaultDimension &&
                      logTransOperPeriod.Blocked            == NoYes::No                     &&
                      logTransOperPeriod.BlockedAuto        == NoYes::No                     &&
                      logTransOperPeriod.CanceledRefRecId   == 0                             &&
                      logTransOperPeriod.TransDate          <= toDate
            exists join logTransPeriod
                where logTransPeriod.RecId           == logTransOperPeriod.RefRecId  &&
                      logTransPeriod.FactureId       == sourceFactureId              &&
                      logTransPeriod.InvoiceRecIdRef == transRecId                   &&
                      logTransPeriod.InvoiceCompany  == transCompany                 &&
                      logTransPeriod.ProcessingType  == PurchBookProcessingType_RU::Standard
            {
                taxPeriodsSet.add(BookDataCalc_RU::datePeriodBook(logTransOperPeriod.TransDate));
            }

            setEnumerator = taxPeriodsSet.getEnumerator();
            while (setEnumerator.moveNext())
            {
                [dateFrom, dateTo] = setEnumerator.current();

                correctedPeriod = dateTo;

                if (mapBookTransCalc.exists([sourceFactureId, dateFrom, dateTo]))
                {
                    bookTransCalc = mapBookTransCalc.lookup([sourceFactureId, dateFrom, dateTo]);
                }
                else
                {
                    bookTransCalc = BookTransCalc_Purch_RU::newTransCalc(factureJourOrig,
                                                                         dateFrom,
                                                                         dateTo,
                                                                         null,
                                                                         null,
                                                                         null,
                                                                         0,
                                                                         NoYes::No,
                                                                         checkTransForProcess,
                                                                         false,
                                                                         0,
                                                                         closingDate,
                                                                         false,
                                                                         false,
                                                                         true);
                    bookTransCalc.parmIsGroupBy(false);

                    mapBookTransCalc.insert([sourceFactureId, dateFrom, dateTo], bookTransCalc);
                }

                factor = bookTransCalc.calcAmountAdjFactor(factureTrans.TaxCode, factureTrans.DefaultDimension, _settledAmountsKey);

                factureAdjustments = mapMapFactureAdjustments.exists([sourceFactureId, correctedPeriod])              ?
                                     Map::create(mapMapFactureAdjustments.lookup([sourceFactureId, correctedPeriod])) :
                                     new Map(Types::Container, Types::Container);

                key = [factureTrans.TaxCode, factureTrans.DefaultDimension, ''];

                structAmounts =  factureAdjustments.exists(key)                                       ?
                                 BookStructSmallVATAmounts_RU::create(factureAdjustments.lookup(key)) :
                                 new BookStructSmallVATAmounts_RU();

                amountInclVAT       = CurrencyExchangeHelper::amount(factor * (factureTrans.LineAmountMST + factureTrans.TaxAmountMST));
                amountVAT           = CurrencyExchangeHelper::amount(factor * factureTrans.vatAmountMST);
                amountLiableToVAT   = amountInclVAT - amountVAT;

                structAmounts.addAmounts(amountInclVAT, amountLiableToVAT, amountVAT);

                factureAdjustments.insert(key, structAmounts.pack());

                mapMapFactureAdjustments.insert([sourceFactureId, correctedPeriod], factureAdjustments.pack());
            }
        }

        return mapMapFactureAdjustments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAssetBlockedAmounts</Name>
				<Source><![CDATA[
    protected BookStructSmallVATAmounts_RU calcAssetBlockedAmounts(BookStructSmallVATAmounts_RU _settledAmounts,
                                                                   BookStructSmallVATAmounts_RU _blockedAmounts,
                                                                   BookStructSmallVATAmounts_RU _usedAmounts,
                                                                   BookStructSmallVATAmounts_RU _assetOpenAmounts,
                                                                   BookStructSmallVATAmounts_RU _remainAssetBlockedAmounts)
    {
        BookStructSmallVATAmounts_RU assetBlockedAmounts,remainAmounts;
        Factor                       factor;
        Amount                       assetAmount;
        ;

        assetBlockedAmounts = new BookStructSmallVATAmounts_RU();

        remainAmounts = new BookStructSmallVATAmounts_RU();
        remainAmounts.addAmounts2(_settledAmounts);
        remainAmounts.subAmounts2(_usedAmounts);
        remainAmounts.subAmounts2(_blockedAmounts);

        if (! remainAmounts.amountInclVAT())
        {
            return assetBlockedAmounts;
        }

        if (VendParameters::find().AssetPaymentAllocation_RU == RAssetPaymentAllocation::operationEqual)
        {
            assetAmount = abs(remainAmounts.amountInclVAT()) < abs(_assetOpenAmounts.taxAmountVAT()) ?
                          remainAmounts.amountInclVAT()                                              :
                          _assetOpenAmounts.taxAmountVAT();
            _assetOpenAmounts.taxAmountVAT(_assetOpenAmounts.taxAmountVAT() - assetAmount);
            factor      = 1 - assetAmount / remainAmounts.amountInclVAT();
            assetBlockedAmounts.amountInclVAT(CurrencyExchangeHelper::amount(remainAmounts.amountInclVAT() * factor));
            assetBlockedAmounts.taxAmountVAT(CurrencyExchangeHelper::amount(remainAmounts.taxAmountVAT() * factor));
        }
        else
        {
            factor = 1 - (_assetOpenAmounts.amountInclVAT() ?
                         (_assetOpenAmounts.amountLiableToVAT()/_assetOpenAmounts.amountInclVAT()) :
                          0);
            assetBlockedAmounts.amountInclVAT(CurrencyExchangeHelper::amount(_settledAmounts.amountInclVAT() * factor));
            assetBlockedAmounts.taxAmountVAT(CurrencyExchangeHelper::amount(_settledAmounts.taxAmountVAT() * factor));
        }

        if (_remainAssetBlockedAmounts)
        {
            assetBlockedAmounts.addAmounts2(_remainAssetBlockedAmounts);
        }

        assetBlockedAmounts.amountLiableToVAT(assetBlockedAmounts.amountInclVAT() - assetBlockedAmounts.taxAmountVAT());

        if (abs(assetBlockedAmounts.amountInclVAT()) > abs(remainAmounts.amountInclVAT()))
        {
            if (_remainAssetBlockedAmounts)
            {
                assetBlockedAmounts.subAmounts2(remainAmounts);
                _remainAssetBlockedAmounts.subAmounts2(_remainAssetBlockedAmounts);
                _remainAssetBlockedAmounts.addAmounts2(assetBlockedAmounts);
            }
            assetBlockedAmounts = BookStructSmallVATAmounts_RU::create(remainAmounts.pack());
        }
        else if (_remainAssetBlockedAmounts)
        {
            _remainAssetBlockedAmounts.addAmounts2(remainAmounts);
            _remainAssetBlockedAmounts.subAmounts2(assetBlockedAmounts);
        }

        return assetBlockedAmounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAssetUsedAmounts</Name>
				<Source><![CDATA[
    protected BookStructSmallVATAmounts_RU calcAssetUsedAmounts(TaxCode                      _taxCode,
                                                                DimensionDefault             _defaultDimension,
                                                                InventTransId                _inventTransId,
                                                                RecId                        _vendTransRecId,
                                                                BookStructSmallVATAmounts_RU _assetAmounts)
    {
        PurchBookVATProcessLogTransOper_RU processLogTransOper;
        PurchBookVATProcessLogTrans_RU     processLogTrans;
        ;

        if (VendParameters::find().AssetPaymentAllocation_RU == RAssetPaymentAllocation::operationEqual)
        {
            select sum(AmountLiableToVAT), sum(TaxAmount) from processLogTransOper
                where processLogTransOper.DefaultDimension == _defaultDimension &&
                      processLogTransOper.TaxCode          == _taxCode          &&
                      processLogTransOper.Blocked          == NoYes::No         &&
                      processLogTransOper.CanceledRefRecId == 0                 &&
                      (! isGroupBy || processLogTransOper.InventTransId    == _inventTransId)
            exists join processLogTrans
                where processLogTrans.RecId           == processLogTransOper.RefRecId  &&
                      processLogTrans.FactureId       == factureJour.FactureId         &&
                      processLogTrans.InvoiceRecIdRef == _vendTransRecId               &&
                      processLogTrans.ProcessingType  == PurchBookProcessingType_RU::Standard &&
                      ! processLogTrans.ReverseDate;

            _assetAmounts.taxAmountVAT(max(0, _assetAmounts.amountLiableToVAT() - (processLogTransOper.AmountLiableToVAT + processLogTransOper.TaxAmount)));
        }

        return _assetAmounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcContractorsBlockedAmounts</Name>
				<Source><![CDATA[
    protected BookStructSmallVATAmounts_RU calcContractorsBlockedAmounts(BookStructSmallVATAmounts_RU _settledAmounts,
                                                                         BookStructSmallVATAmounts_RU _blockedAmounts,
                                                                         BookStructSmallVATAmounts_RU _usedAmounts,
                                                                         BookStructSmallVATAmounts_RU _openAmounts)
    {
        BookStructSmallVATAmounts_RU remainAmounts;
        ;

        remainAmounts = new BookStructSmallVATAmounts_RU();

        remainAmounts.addAmounts2(_settledAmounts);
        remainAmounts.subAmounts2(_usedAmounts);
        remainAmounts.subAmounts2(_blockedAmounts);
        remainAmounts.subAmounts2(_openAmounts);

        return remainAmounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcRDeferralOpenAmounts</Name>
				<Source><![CDATA[
    protected container calcRDeferralOpenAmounts(RecId                        _processLogTransRecId,
                                                 BookStructSmallVATAmounts_RU _settledAmounts,
                                                 BookStructSmallVATAmounts_RU _usedAmounts,
                                                 RecId                        _settlementRecId,
                                                 InventTransId                _inventTransId   = '',
                                                 TaxCode                      _taxCode         = '',
                                                 DimensionDefault             _defaultDimension = 0)
    {
        InventTransId                       inventTransId = _inventTransId;
        TaxCode                             taxCode       = _taxCode;
        DimensionDefault                    defaultDimension    = _defaultDimension;

        RDeferralsParameters                deferralsParameters = RDeferralsParameters::find();
        FactureTrans_RU                     factureTrans;
        RDeferralsTable                     deferralsTable;
        RDeferralsBook                      deferralsBook;
        boolean                             existsRDeferrals = false;

        RDeferralsTrans                     deferralsTransSelect;
        RDeferralsTrans                     deferralsTransStorno;

        PurchBookVATProcessLogTrans_RU      processLogTrans;
        PurchBookVATProcessLogTransOper_RU  processLogTransOper;

        AmountCur                           deferralsTransAmountAll;
        AmountCur                           deferralsTransAmountClosed;

        AmountCur                           deferralsTransAmountOpenAll;
        AmountCur                           deferralsTransAmountOpenClosed;

        AmountCur                           deferralsTransAmountCorrectedAll;
        AmountCur                           deferralsTransAmountCorrectedClosed;

        AmountCur                           deferralsTransAmountOpen;

        Map                                 deferralsOpenTrans    = new Map(Types::Record, Types::Container);
        Map                                 deferralsCorrectDates = new Map(Types::Date, Types::Class);
        Map                                 deferralsCorrectTrans;

        TransDate                           bookFromDate;
        TransDate                           bookToDate;

        BookStructSmallVATAmounts_RU        factureSum;

        real                                disposalCoeffAll;
        BookStructSmallVATAmounts_RU        disposalSumAll;

        MapEnumerator                       meOpenTrans;
        MapEnumerator                       meCorrectTrans;
        MapEnumerator                       meCorrectDates;

        AmountCur                           curOpenSum;
        AmountCur                           curClosedSum;
        real                                curDisposalCoeff;
        BookStructSmallVATAmounts_RU        curDisposalAmounts;

        BookStructSmallVATAmounts_RU        totalOpenAmounts      = new BookStructSmallVATAmounts_RU();
        BookStructSmallVATAmounts_RU        totalCorrectedAmounts = new BookStructSmallVATAmounts_RU();
        BookStructSmallVATAmounts_RU        totalDisposalSum      = new BookStructSmallVATAmounts_RU();

        int                                 openTransCount;

        if (inventTransId)
        {
            taxCode = '';
        }

        if ((inventTransId || taxCode) && isGroupBy)
        {
            while select factureTrans
                where factureTrans.FactureId == factureJour.FactureId               &&
                      factureTrans.Module    == factureJour.Module                  &&
                    ((inventTransId && factureTrans.InventTransId == inventTransId) ||
                     (taxCode && factureTrans.TaxCode == taxCode && factureTrans.DefaultDimension  == defaultDimension))
            {
                deferralsTable   = this.loadDeferrals(factureTrans);
                existsRDeferrals = deferralsTable.RecId != 0;

                if (!existsRDeferrals)
                {
                    continue;
                }

                disposalSumAll = new BookStructSmallVATAmounts_RU();
                factureSum     = new BookStructSmallVATAmounts_RU();

                deferralsBook = RDeferralsBook::find(deferralsTable.DeferralsId, deferralsParameters.DeferralsBookIdDefault);

                if (deferralsBook.RecId)
                {
                    while select Amount, TransDate, DeferralsPeriod, StornoRecId, RecId from deferralsTransSelect
                        where deferralsTransSelect.DeferralsId      == deferralsTable.DeferralsId                   &&
                              deferralsTransSelect.DeferralsBookId  == deferralsParameters.DeferralsBookIdDefault   &&
                              deferralsTransSelect.TransDate        <= toDate                                       &&
                              deferralsTransSelect.Amount           <  0
                    {
                        if (deferralsTransSelect.StornoRecId)
                        {
                            deferralsTransStorno = RDeferralsTrans::find(deferralsTransSelect.StornoRecId);
                            if (deferralsTransStorno.TransDate <= toDate)
                            {
                                continue;
                            }
                        }

                        select sum(rDeferralsClosedAmount) from processLogTransOper
                            where processLogTransOper.rDeferralsTransRecId == deferralsTransSelect.RecId &&
                                  processLogTransOper.TransDate            <= toDate
                        join TableId from processLogTrans
                            where processLogTrans.RecId           == processLogTransOper.RefRecId &&
                                  processLogTrans.SettlementRecId == _settlementRecId;

                        deferralsTransAmountAll     += deferralsTransSelect.Amount;
                        deferralsTransAmountClosed  += processLogTransOper.rDeferralsClosedAmount;

                        if (deferralsTransSelect.Amount == processLogTransOper.rDeferralsClosedAmount)
                        {
                            continue;
                        }

                        [bookFromDate, bookToDate]  = BookDataCalc_RU::datePeriodBook(deferralsTransSelect.DeferralsPeriod);

                        if (! deferralsTransSelect.DeferralsPeriod                                                             ||
                              BookDataCalc_RU::datePeriodBook(deferralsTransSelect.TransDate) == [bookFromDate, bookToDate]    ||
                              BookDataCalc_RU::datePeriodBook(deferralsTransSelect.TransDate) == BookDataCalc_RU::datePeriodBook(factureJour.FactureDate))
                        {
                            deferralsTransAmountOpenAll    += deferralsTransSelect.Amount;
                            deferralsTransAmountOpenClosed += processLogTransOper.rDeferralsClosedAmount;

                            deferralsOpenTrans.insert(deferralsTransSelect, [processLogTransOper.rDeferralsClosedAmount]);
                        }
                        else
                        {
                            deferralsTransAmountCorrectedAll    += deferralsTransSelect.Amount;
                            deferralsTransAmountCorrectedClosed += processLogTransOper.rDeferralsClosedAmount;

                            if (deferralsCorrectDates.exists(bookToDate))
                            {
                                deferralsCorrectTrans = deferralsCorrectDates.lookup(bookToDate);
                            }
                            else
                            {
                                deferralsCorrectTrans = new Map(Types::Record, Types::Container);
                            }

                            deferralsCorrectTrans.insert(deferralsTransSelect, [processLogTransOper.rDeferralsClosedAmount]);

                            deferralsCorrectDates.insert(bookToDate, deferralsCorrectTrans);
                        }
                    }

                    deferralsTransAmountOpen = deferralsTransAmountAll - deferralsTransAmountClosed;
                    disposalCoeffAll         = abs(deferralsBook.DeferralsAmount ? deferralsTransAmountOpen / deferralsBook.DeferralsAmount : 0);

                    disposalSumAll.addAmounts(CurrencyExchangeHelper::amount(_settledAmounts.amountInclVAT() * disposalCoeffAll),
                                              CurrencyExchangeHelper::amount(_settledAmounts.amountLiableToVAT() * disposalCoeffAll),
                                              0);
                    disposalSumAll.taxAmountVAT(disposalSumAll.amountInclVAT() - disposalSumAll.amountLiableToVAT());

                    factureSum.addAmounts(factureTrans.LineAmountMST + factureTrans.TaxAmountMST, factureTrans.LineAmountMST, factureTrans.TaxAmountMST);

                    if (abs(factureSum.amountInclVAT()) < abs(disposalSumAll.amountInclVAT()))
                    {
                        disposalSumAll.clear();
                        disposalSumAll.addAmounts2(factureSum);
                    }

                    totalDisposalSum.addAmounts2(disposalSumAll);

                    meCorrectDates = deferralsCorrectDates.getEnumerator();
                    while (meCorrectDates.moveNext())
                    {
                        deferralsCorrectTrans = meCorrectDates.currentValue();
                        meCorrectTrans        = deferralsCorrectTrans.getEnumerator();

                        while (meCorrectTrans.moveNext())
                        {
                            deferralsTransSelect = meCorrectTrans.currentKey();
                            [curClosedSum]       = meCorrectTrans.currentValue();

                            curOpenSum       = deferralsTransSelect.Amount - curClosedSum;
                            curDisposalCoeff = abs(deferralsTransAmountOpen ? curOpenSum / deferralsTransAmountOpen : 0);

                            curDisposalAmounts = new BookStructSmallVATAmounts_RU();
                            curDisposalAmounts.addAmounts(CurrencyExchangeHelper::amount(disposalSumAll.amountInclVAT() * curDisposalCoeff),
                                                          CurrencyExchangeHelper::amount(disposalSumAll.amountLiableToVAT() * curDisposalCoeff),
                                                          0);
                            curDisposalAmounts.taxAmountVAT(curDisposalAmounts.amountInclVAT() - curDisposalAmounts.amountLiableToVAT());

                            totalCorrectedAmounts.addAmounts2(curDisposalAmounts);

                            deferralsCorrectTrans.insert(meCorrectTrans.currentKey(), [curOpenSum, curDisposalAmounts.pack(), _settlementRecId]);
                        }

                        deferralsCorrectDates.insert(meCorrectDates.currentKey(), deferralsCorrectTrans);
                    }

                    meOpenTrans = deferralsOpenTrans.getEnumerator();
                    while (meOpenTrans.moveNext())
                    {
                        openTransCount ++;

                        deferralsTransSelect = meOpenTrans.currentKey();
                        [curClosedSum]       = meOpenTrans.currentValue();

                        curOpenSum       = deferralsTransSelect.Amount - curClosedSum;
                        curDisposalCoeff = abs(deferralsTransAmountOpen ? curOpenSum / deferralsTransAmountOpen : 0);

                        curDisposalAmounts = new BookStructSmallVATAmounts_RU();
                        curDisposalAmounts.addAmounts(CurrencyExchangeHelper::amount(disposalSumAll.amountInclVAT() * curDisposalCoeff),
                                                      CurrencyExchangeHelper::amount(disposalSumAll.amountLiableToVAT() * curDisposalCoeff),
                                                      0);
                        curDisposalAmounts.taxAmountVAT(curDisposalAmounts.amountInclVAT() - curDisposalAmounts.amountLiableToVAT());

                        totalOpenAmounts.addAmounts2(curDisposalAmounts);

                        deferralsOpenTrans.insert(deferralsTransSelect, [curOpenSum, curDisposalAmounts.pack(), _settlementRecId]);
                    }
                }

                curDisposalCoeff   = abs(deferralsBook.DeferralsAmount ? deferralsTransAmountClosed / deferralsBook.DeferralsAmount : 0);
                curDisposalAmounts = new BookStructSmallVATAmounts_RU();
                curDisposalAmounts.addAmounts(CurrencyExchangeHelper::amount(_settledAmounts.amountInclVAT() * curDisposalCoeff),
                                              CurrencyExchangeHelper::amount(_settledAmounts.amountLiableToVAT() * curDisposalCoeff),
                                              0);
                curDisposalAmounts.taxAmountVAT(curDisposalAmounts.amountInclVAT() - curDisposalAmounts.amountLiableToVAT());

                _settledAmounts.subAmounts2(curDisposalAmounts);
                _settledAmounts.subAmounts2(totalCorrectedAmounts);

                _usedAmounts.subAmounts2(curDisposalAmounts);

                if ( _usedAmounts.amountInclVAT() != 0 && _usedAmounts.amountLiableToVAT() != 0 && _usedAmounts.taxAmountVAT() != 0)
                {
                    _usedAmounts.subAmounts(min(_usedAmounts.amountInclVAT(),     totalCorrectedAmounts.amountInclVAT()),
                                            min(_usedAmounts.amountLiableToVAT(), totalCorrectedAmounts.amountLiableToVAT()),
                                            min(_usedAmounts.taxAmountVAT(),      totalCorrectedAmounts.taxAmountVAT()));
                }

                if (deferralsOpenTrans.empty() && deferralsCorrectDates.empty())
                {
                    _usedAmounts.clear();
                }
            }
        }

        return [[deferralsOpenTrans.pack(), existsRDeferrals], deferralsCorrectDates.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLogTrans</Name>
				<Source><![CDATA[
    protected container createLogTrans(TransDate                  _settlementDate,
                                       RefRecId                   _transRecid,
                                       RefRecId                   _offsetRecId,
                                       CompanyId                  _transCompany,
                                       CompanyId                  _offsetCompany,
                                       RefRecId                   _settlementRecId,
                                       RefRecId                   _processLogTransRecId,
                                       SalesPurchBookTransType_RU _transType,
                                       Map                        _settledAmounts,
                                       Map                        _mapFactureAmountsDetails,
                                       Map                        _mapAssetOpenAmounts = null,
                                       boolean                    _useDocumentType     = false,
                                       PurchBookProcessingType_RU _processingType      = PurchBookProcessingType_RU::Standard,
                                       TransDate                  _correctedPeriod     = dateNull(),
                                       FactureId_RU               _correctedFactureId  = '')
    {
        MapEnumerator                mapEnumerator;
        TaxCode                      taxCode, prevTaxCode;
        DimensionDefault             defaultDimension, prevDefaultDimension;
        BookStructSmallVATAmounts_RU usedAmounts,
                                     blockedAmounts,
                                     settledAmounts,
                                     factureAmounts,
                                     assetBlockedAmounts,
                                     oldUsedAmounts,
                                     finalAmounts,
                                     assetOpenAmounts;
        BookStructVATAmounts_RU      totalUsedAmounts, totalSettledAmounts;
        InventTransId                inventTransId,
                                     prevInventTransId;
        PurchInternalInvoiceId       internalInvoiceId;
        InvoiceId                    invoiceId;
        NumberSequenceGroupId        numberSequenceGroupId;
        container                    key;
        PurchBookVATDocumentType_RU  documentType;
        BookStructSmallVATAmounts_RU remainAssetBlockedAmounts;
        RAssetPaymentAllocation      assetPaymentAllocation = VendParameters::find().AssetPaymentAllocation_RU;
        container                    rDeferralsOpenAmounts;

        mapEnumerator        = _settledAmounts.getEnumerator();
        totalSettledAmounts  = new BookStructVATAmounts_RU();
        totalUsedAmounts     = new BookStructVATAmounts_RU();

        while (mapEnumerator.moveNext())
        {
            [taxCode, defaultDimension, inventTransId, internalInvoiceId, invoiceId, numberSequenceGroupId, documentType] = mapEnumerator.currentKey();

            if (prevTaxCode != taxCode || prevDefaultDimension != defaultDimension || prevInventTransId != inventTransId)
            {
                oldUsedAmounts = new BookStructSmallVATAmounts_RU();
                if (assetPaymentAllocation == RAssetPaymentAllocation::operationEqual)
                {
                    remainAssetBlockedAmounts = new BookStructSmallVATAmounts_RU();
                }
            }

            settledAmounts = BookStructSmallVATAmounts_RU::create(mapEnumerator.currentValue());

            switch (_transType)
            {
                case SalesPurchBookTransType_RU::PrepaymentStorno:
                    settledAmounts.reverseAmounts();
                    key = [taxCode, defaultDimension, ''];
                    break;

                case SalesPurchBookTransType_RU::SumDiff          :
                case SalesPurchBookTransType_RU::ExchAdj          :
                case SalesPurchBookTransType_RU::AdvanceAdjustment:
                case SalesPurchBookTransType_RU::Prepayment       :
                case SalesPurchBookTransType_RU::GTD              :
                case SalesPurchBookTransType_RU::CustomCorrection :
                    key = [taxCode, defaultDimension, ''];
                    break;

                default:
                    key = _useDocumentType ?
                         [taxCode, defaultDimension, inventTransId, internalInvoiceId, invoiceId, numberSequenceGroupId, documentType] :
                         [taxCode, defaultDimension, inventTransId, internalInvoiceId, invoiceId, numberSequenceGroupId];
                    break;
            }

            if (documentType == PurchBookVATDocumentType_RU::ContractorsWork_2005 && contractorsOpenMap && ! contractorsOpenMap.exists(key))
            {
                continue;
            }

            factureAmounts = BookStructSmallVATAmounts_RU::getAmountsByReducedKey(key, _mapFactureAmountsDetails);

            usedAmounts    = PurchBookVATProcessLogTransOper_RU::usedAmounts(factureJour.FactureId,
                                                                             taxCode,
                                                                             defaultDimension,
                                                                             inventTransId,
                                                                             _transRecid,
                                                                             _offsetRecId,
                                                                             _transCompany,
                                                                             _offsetCompany,
                                                                             _settlementRecId,
                                                                             _settlementDate,
                                                                             false,
                                                                             0,
                                                                             NoYes::No,
                                                                             isGroupBy,
                                                                             documentType,
                                                                             _processingType,
                                                                             _correctedPeriod,
                                                                             _correctedFactureId);

            if (max(factureJour.FactureReportDate, _settlementDate) < #TransitionStartDate &&
                documentType != PurchBookVATDocumentType_RU::Unknown)
            {
                if (! oldUsedAmounts.amountInclVAT())
                {
                    oldUsedAmounts = PurchBookVATProcessLogTransOper_RU::usedAmounts(factureJour.FactureId,
                                                                                     taxCode,
                                                                                     defaultDimension,
                                                                                     inventTransId,
                                                                                     _transRecid,
                                                                                     _offsetRecId,
                                                                                     _transCompany,
                                                                                     _offsetCompany,
                                                                                     _settlementRecId,
                                                                                     _settlementDate,
                                                                                     false,
                                                                                     0,
                                                                                     NoYes::No,
                                                                                     isGroupBy,
                                                                                     PurchBookVATDocumentType_RU::Unknown,
                                                                                     _processingType);

                    usedAmounts.addAmounts2(oldUsedAmounts);
                }
            }

            finalAmounts = BookStructSmallVATAmounts_RU::create(settledAmounts.pack());
            finalAmounts.subAmounts2(usedAmounts);

            if (! finalAmounts.amountInclVAT() && oldUsedAmounts)
            {
                 totalSettledAmounts.subSmallAmounts2(taxCode, oldUsedAmounts);
                 totalUsedAmounts.subSmallAmounts2(taxCode, oldUsedAmounts);
                 settledAmounts.subAmounts2(oldUsedAmounts);
                 usedAmounts.subAmounts2(oldUsedAmounts);
                 oldUsedAmounts = new BookStructSmallVATAmounts_RU();
            }

            blockedAmounts = PurchBookVATProcessLogTransOper_RU::usedAmounts(factureJour.FactureId,
                                                                             taxCode,
                                                                             defaultDimension,
                                                                             inventTransId,
                                                                             _transRecid,
                                                                             _offsetRecId,
                                                                             _transCompany,
                                                                             _offsetCompany,
                                                                             _settlementRecId,
                                                                             _settlementDate,
                                                                             true,
                                                                             0,
                                                                             NoYes::No,
                                                                             isGroupBy,
                                                                             documentType,
                                                                             _processingType,
                                                                             _correctedPeriod,
                                                                             _correctedFactureId);

            if (_mapAssetOpenAmounts)
            {
                assetOpenAmounts    = BookStructSmallVATAmounts_RU::getAmountsByReducedKey(key, _mapAssetOpenAmounts);
                assetBlockedAmounts = this.calcAssetBlockedAmounts(settledAmounts, blockedAmounts, usedAmounts, assetOpenAmounts, remainAssetBlockedAmounts);
            }
            rDeferralsOpenAmounts = this.calcRDeferralOpenAmounts(_processLogTransRecId, settledAmounts, usedAmounts,_settlementRecId, inventTransId, taxCode, defaultDimension);

            totalSettledAmounts.addSmallAmounts2(taxCode, settledAmounts);
            totalUsedAmounts.addSmallAmounts2(taxCode, usedAmounts);

            if (documentType == PurchBookVATDocumentType_RU::ContractorsWork_2005)
            {
                if (! contractorsExcludeSet.in(key + _transRecid) && contractorsOpenMap)
                {
                    if (contractorsNotAssetSet.in(key + _transRecid))
                    {
                        assetBlockedAmounts = this.calcContractorsBlockedAmounts(settledAmounts,
                                                                                 blockedAmounts,
                                                                                 usedAmounts,
                                                                                 BookStructSmallVATAmounts_RU::create(contractorsOpenMap.lookup(key)));
                    }
                }
                else
                {
                    totalSettledAmounts.subSmallAmounts2(taxCode, settledAmounts);
                    totalUsedAmounts.subSmallAmounts2(taxCode, usedAmounts);
                    settledAmounts.clear();
                    usedAmounts.clear();
                    blockedAmounts.clear();
                    assetBlockedAmounts.clear();
                }
            }
            TmpPurchBookVATProcessLogTransOper_RU::createLines(tmpProcessLogTransOper,
                                                               factureJour.FactureId,
                                                               max(_settlementDate, factureJour.FactureReportDate),
                                                               prmisDefault(_processingType) ? operationRecId : 0,
                                                               defaultDimension,
                                                               taxCode,
                                                               inventTransId,
                                                               _transType,
                                                               factureAmounts,
                                                               settledAmounts,
                                                               usedAmounts,
                                                               blockedAmounts,
                                                               assetBlockedAmounts,
                                                               _transRecid,
                                                               _offsetRecId,
                                                               _transCompany,
                                                               _offsetCompany,
                                                               _settlementRecId,
                                                               _processLogTransRecId,
                                                               closingDate,
                                                               _settlementDate,
                                                               isGroupBy,
                                                               documentType,
                                                               true,
                                                               dateNull(),
                                                               _processingType,
                                                               conPeek(rDeferralsOpenAmounts, 1));
            prevTaxCode          = taxCode;
            prevDefaultDimension = defaultDimension;
            prevInventTransId    = inventTransId;

            this.processRDeferralsCorrectedAmounts(conPeek(rDeferralsOpenAmounts, 2), _processLogTransRecId, inventTransId, taxCode, defaultDimension);
        }

        return [totalSettledAmounts.pack(), totalUsedAmounts.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLogTransReverse</Name>
				<Source><![CDATA[
    protected container createLogTransReverse(FactureId_RU               _factureId,
                                              RecId                      _transRecId,
                                              RecId                      _offsetRecId,
                                              CompanyId                  _transCompany,
                                              CompanyId                  _offsetCompany,
                                              RefRecId                   _settlementRecId,
                                              TransDate                  _settlementDate,
                                              RefRecId                   _processLogTransRecId,
                                              PurchBookProcessingType_RU _processingType     = PurchBookProcessingType_RU::Standard,
                                              BookStructVATAmounts_RU    _factureAmounts     = null,
                                              TransDate                  _correctedPeriod    = dateNull(),
                                              FactureId_RU               _correctedFactureId = '')
    {
        PurchBookVATProcessLogTransOper_RU  processLogTransOper;
        PurchBookVATProcessLogTrans_RU      processLogTrans;
        BookStructSmallVATAmounts_RU        bookStructSmallVATAmounts;
        BookStructVATAmounts_RU             totalUsedAmounts, totalSettledAmounts;
        Map                                 mapOperSettledAmounts   = new Map(Types::Container, Types::Class);
        boolean                             existRDeferrals;
        FromDate                            fromDateLoc;
        ToDate                              toDateLoc;
        Map                                 datesMap = new Map(Types::Container, Types::Class);
        Set                                 setRecId;
        container                           curTransKey, key;
        MapEnumerator                       me;
        SetEnumerator                       se;
        TmpPurchBookVATProcessLogTrans_RU   tmpProcessLogTrans;
        BookStructVATAmounts_RU             bookUsedAmounts;
        BookStructSmallVATAmounts_RU        usedAmounts;
        RDeferralsTrans                     deferralsTrans;
        RDeferralsTable                     deferralsTable;
        ;

        select firstonly rDeferralsTransRecId
            from processLogTransOper
            where processLogTransOper.rDeferralsTransRecId  != 0
        join TableId
            from processLogTrans
            where processLogTrans.RecId                 == processLogTransOper.RefRecId &&
                  processLogTrans.FactureId             == _factureId                   &&
                  processLogTrans.InvoiceRecIdRef       == _transRecId                  &&
                  processLogTrans.PaymentRecIdRef       == _offsetRecId                 &&
                  processLogTrans.InvoiceCompany        == _transCompany                &&
                  processLogTrans.PaymentCompany        == _offsetCompany               &&
                  processLogTrans.SettlementDate        == _settlementDate              &&
                  processLogTrans.SettlementRecId       == _settlementRecId             &&
                  processLogTrans.ProcessingType        == _processingType;

        existRDeferrals = processLogTransOper.RecId != 0;
        if (existRDeferrals)
        {
            deferralsTrans  = RDeferralsTrans::find(processLogTransOper.rDeferralsTransRecId);
            deferralsTable  = RDeferralsTable::find(deferralsTrans.DeferralsId);
        }

        totalSettledAmounts = new BookStructVATAmounts_RU();
        totalUsedAmounts    = new BookStructVATAmounts_RU();

        while select sum(AmountLiableToVAT), sum(TaxAmount) from processLogTransOper
            group by TaxCode, DefaultDimension, InventTransId, DocumentType, rDeferralsTransRecId
            where processLogTransOper.Blocked         == NoYes::No &&
                 processLogTransOper.CanceledRefRecId == 0
        exists join processLogTrans
            where processLogTrans.RecId                 == processLogTransOper.RefRecId            &&
                  processLogTrans.FactureId             == _factureId                              &&
                  processLogTrans.InvoiceRecIdRef       == _transRecId                             &&
                  processLogTrans.PaymentRecIdRef       == _offsetRecId                            &&
                  processLogTrans.InvoiceCompany        == _transCompany                           &&
                  processLogTrans.PaymentCompany        == _offsetCompany                          &&
                  processLogTrans.SettlementDate        == _settlementDate                         &&
                  processLogTrans.SettlementRecId       == _settlementRecId                        &&
                  processLogTrans.ProcessingType        == _processingType                         &&
                 (! _correctedPeriod    || processLogTrans.CorrectedPeriod    == _correctedPeriod) &&
                 (! _correctedFactureId || processLogTrans.CorrectedFactureId == _correctedFactureId)
        {
            key = [processLogTransOper.TaxCode,
                processLogTransOper.DefaultDimension,
                processLogTransOper.InventTransId,
                processLogTransOper.DocumentType,
                existRDeferrals && deferralsTable.vatRefundingMethod == RDeferralsVATRefundingMethod::Proportional ? processLogTransOper.rDeferralsTransRecId : 0];

            if (mapOperSettledAmounts.exists(key))
            {
                bookStructSmallVATAmounts = mapOperSettledAmounts.lookup(key);
            }
            else
            {
                bookStructSmallVATAmounts = new BookStructSmallVATAmounts_RU();
            }

            bookStructSmallVATAmounts.subAmounts(processLogTransOper.amountInclVAT(), processLogTransOper.AmountLiableToVAT, processLogTransOper.TaxAmount);
            mapOperSettledAmounts.insert(key, bookStructSmallVATAmounts);

            totalSettledAmounts.addSmallAmounts(processLogTransOper.TaxCode,
                                                - processLogTransOper.amountInclVAT(),
                                                - processLogTransOper.AmountLiableToVAT,
                                                - processLogTransOper.TaxAmount);
        }

        if (existRDeferrals && deferralsTable.vatRefundingMethod == RDeferralsVATRefundingMethod::Proportional)
        {
            while select processLogTransOper
                where processLogTransOper.Blocked          == NoYes::No &&
                      processLogTransOper.CanceledRefRecId == 0         &&
                    ! processLogTransOper.rDeferralsStornoRecId
            join CorrectedPeriod from processLogTrans
                where processLogTrans.RecId                 == processLogTransOper.RefRecId &&
                      processLogTrans.FactureId             == _factureId                   &&
                      processLogTrans.InvoiceRecIdRef       == _transRecId                  &&
                      processLogTrans.PaymentRecIdRef       == _offsetRecId                 &&
                      processLogTrans.InvoiceCompany        == _transCompany                &&
                      processLogTrans.PaymentCompany        == _offsetCompany               &&
                      processLogTrans.SettlementDate        == _settlementDate              &&
                      processLogTrans.SettlementRecId       == _settlementRecId             &&
                      processLogTrans.ProcessingType        == _processingType
            {
                if (processLogTrans.CorrectedPeriod)
                {
                    [fromDateLoc, toDateLoc] = BookDataCalc_RU::datePeriodBook(processLogTrans.CorrectedPeriod);
                }
                else
                {
                    [fromDateLoc, toDateLoc] = BookDataCalc_RU::datePeriodBook(processLogTransOper.TransDate);
                }

                if (datesMap.exists([fromDateLoc, toDateLoc]))
                {
                    setRecId = datesMap.lookup([fromDateLoc, toDateLoc]);
                }
                else
                {
                    setRecId = new Set(typeName2Type(extendedTypeStr(RecId)));
                }

                setRecId.add(processLogTransOper.RecId);

                datesMap.insert([fromDateLoc, toDateLoc], setRecId);

                if (salesPurchBookDataMap.ReverseDate >= fromDateLoc && salesPurchBookDataMap.ReverseDate <= toDateLoc)
                {
                    curTransKey = [fromDateLoc, toDateLoc];
                }
            }

            me = datesMap.getEnumerator();
            while (me.moveNext())
            {
                bookUsedAmounts = new BookStructVATAmounts_RU();

                [fromDateLoc, toDateLoc] = me.currentKey();

                tmpProcessLogTrans             = salesPurchBookDataMap;
                tmpProcessLogTrans.Reversed    = NoYes::Yes;

                if ([fromDateLoc, toDateLoc] != curTransKey)
                {
                    tmpProcessLogTrans.insert();
                }
                else
                {
                    tmpProcessLogTrans.update();
                }

                setRecId = me.currentValue();
                se       = setRecId.getEnumerator();

                while (se.moveNext())
                {
                    usedAmounts = new BookStructSmallVATAmounts_RU();

                    processLogTransOper = PurchBookVATProcessLogTransOper_RU::find(se.current());

                    tmpProcessLogTransOper.clear();
                    tmpProcessLogTransOper.initFromPBookVATProcessLogTransOper(processLogTransOper);
                    tmpProcessLogTransOper.TaxAmount              = - tmpProcessLogTransOper.TaxAmount;
                    tmpProcessLogTransOper.AmountLiableToVAT      = - tmpProcessLogTransOper.AmountLiableToVAT;
                    tmpProcessLogTransOper.SettledAmounts         = mapOperSettledAmounts.lookup([processLogTransOper.TaxCode,
                                                                                                  processLogTransOper.DefaultDimension,
                                                                                                  processLogTransOper.InventTransId,
                                                                                                  processLogTransOper.DocumentType,
                                                                                                  processLogTransOper.rDeferralsTransRecId]).pack();
                    tmpProcessLogTransOper.TransDate              = max(_settlementDate, closingDate + 1);
                    tmpProcessLogTransOper.UsedAmounts            = conNull();
                    tmpProcessLogTransOper.RefRecId               = tmpProcessLogTrans.RecId;

                    tmpProcessLogTransOper.rDeferralsTransRecId   = processLogTransOper.rDeferralsTransRecId;
                    tmpProcessLogTransOper.rDeferralsClosedAmount = -1 * processLogTransOper.rDeferralsClosedAmount;
                    tmpProcessLogTransOper.rDeferralsStornoRecId  = processLogTransOper.RecId;
                    tmpProcessLogTransOper.insert();

                    usedAmounts.addAmounts(tmpProcessLogTransOper.AmountLiableToVAT + tmpProcessLogTransOper.TaxAmount,
                                           tmpProcessLogTransOper.AmountLiableToVAT,
                                           tmpProcessLogTransOper.TaxAmount);

                    bookUsedAmounts.addSmallAmounts2(tmpProcessLogTransOper.TaxCode, usedAmounts);
                }

                if (_factureAmounts)
                {
                    tmpProcessLogTrans.FactureAmounts = _factureAmounts.pack();
                }

                tmpProcessLogTrans.UsedAmounts = bookUsedAmounts.pack();
                bookUsedAmounts.addAmounts2(bookUsedAmounts);

                tmpProcessLogTrans.SettledAmounts = bookUsedAmounts.pack();
                tmpProcessLogTrans.update();

                if ([fromDateLoc, toDateLoc] == curTransKey)
                {
                    totalSettledAmounts = BookStructVATAmounts_RU::create(tmpProcessLogTrans.SettledAmounts);
                    totalUsedAmounts    = BookStructVATAmounts_RU::create(tmpProcessLogTrans.UsedAmounts);
                }

                if (tmpProcessLogTrans.ReverseDate < fromDate)
                {
                    tmpProcessLogTrans.CorrectedPeriod  = toDateLoc;
                }
                else
                {
                    tmpProcessLogTrans.CorrectedPeriod  = dateNull();
                }
                tmpProcessLogTrans.update();
            }

            select firstonly salesPurchBookDataMap
                where salesPurchBookDataMap.RecId == _processLogTransRecId;

            if (datesMap.empty())
            {
                totalSettledAmounts = new BookStructVATAmounts_RU();
                totalUsedAmounts    = new BookStructVATAmounts_RU();
            }
        }
        else
        {
            while select processLogTransOper
                where processLogTransOper.Blocked          == NoYes::No &&
                      processLogTransOper.CanceledRefRecId == 0
            exists join processLogTrans
                where processLogTrans.RecId                 == processLogTransOper.RefRecId &&
                      processLogTrans.FactureId             == _factureId                   &&
                      processLogTrans.InvoiceRecIdRef       == _transRecId                  &&
                      processLogTrans.PaymentRecIdRef       == _offsetRecId                 &&
                      processLogTrans.InvoiceCompany        == _transCompany                &&
                      processLogTrans.PaymentCompany        == _offsetCompany               &&
                      processLogTrans.SettlementDate        == _settlementDate              &&
                      processLogTrans.SettlementRecId       == _settlementRecId             &&
                      processLogTrans.ProcessingType        == _processingType              &&
                     (! _correctedPeriod    || processLogTrans.CorrectedPeriod    == _correctedPeriod) &&
                     (! _correctedFactureId || processLogTrans.CorrectedFactureId == _correctedFactureId)
            {
                tmpProcessLogTransOper.clear();
                tmpProcessLogTransOper.initFromPBookVATProcessLogTransOper(processLogTransOper);
                tmpProcessLogTransOper.TaxAmount         = - tmpProcessLogTransOper.TaxAmount;
                tmpProcessLogTransOper.AmountLiableToVAT = - tmpProcessLogTransOper.AmountLiableToVAT;
                tmpProcessLogTransOper.SettledAmounts = mapOperSettledAmounts.lookup([processLogTransOper.TaxCode,
                                                                                      processLogTransOper.DefaultDimension,
                                                                                      processLogTransOper.InventTransId,
                                                                                      processLogTransOper.DocumentType,
                                                                                      0]).pack();
                tmpProcessLogTransOper.TransDate = max(_settlementDate, closingDate + 1);
                tmpProcessLogTransOper.RefRecId  = _processLogTransRecId;
                tmpProcessLogTransOper.insert();
            }
        }

        return [totalSettledAmounts.pack(),totalUsedAmounts.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPrepaymentJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Returns a journal transaction related to the current facure.
    /// </summary>
    /// <returns>
    /// A <c>LedgerJournalTrans</c> record.
    /// </returns>
    protected LedgerJournalTrans findPrepaymentJournalTrans()
    {
        LedgerJournalTrans  journalTrans;
        FactureTrans_RU     factureTrans;

        if (!factureJour.CustVendTransRecId)
        {
            select firstonly journalTrans exists join
                factureTrans where factureTrans.MarkupRefRecId      == journalTrans.RecId
                                && factureTrans.MarkupRefTableId    == tableNum(LedgerJournalTrans)
                                && factureTrans.FactureId           == factureJour.FactureId
                                && factureTrans.Module              == factureJour.Module;
        }
        return journalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupByAssetUsedAmounts</Name>
				<Source><![CDATA[
    protected Map groupByAssetUsedAmounts(Map      _map,
                                          RefRecId _vendTransRecId)
    {
        MapEnumerator                mapEnumerator = _map.getEnumerator();
        TaxCode                      taxCode;
        DimensionDefault             defaultDimension;
        BookStructSmallVATAmounts_RU assetAmounts;
        Map                          resultMap;
        ;

        resultMap = new Map(_map.keyType(),_map.valueType());

        while (mapEnumerator.moveNext())
        {
            [taxCode, defaultDimension] = mapEnumerator.currentKey();
            assetAmounts        = mapEnumerator.currentValue();
            if (assetAmounts.qty())
            {
                assetAmounts = this.calcAssetUsedAmounts(taxCode, defaultDimension, '', _vendTransRecId, assetAmounts);
                assetAmounts.qty(0);
            }

            resultMap.insert(mapEnumerator.currentKey(), assetAmounts);
        }

        return resultMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupByMapFactureAmounts</Name>
				<Source><![CDATA[
    protected Map groupByMapFactureAmounts(Map     _map,
                                           boolean _sumQty = false)
    {
        Map                          resultMap;
        MapEnumerator                mapEnumerator;
        TaxCode                      taxCode;
        DimensionDefault             defaultDimension;
        BookStructSmallVATAmounts_RU transAmounts;
        InventTransId                inventTransId;
        PurchInternalInvoiceId       internalInvoiceId;
        InvoiceId                    invoiceId;
        NumberSequenceGroupId        numberSequenceGroupId;
        PurchBookVATDocumentType_RU  documentType;
        container                    groupByKey;
        ;

        if (isGroupBy)
        {
            return _map;
        }

        resultMap     = new Map(_map.keyType(),_map.valueType());
        mapEnumerator = _map.getEnumerator();

        while (mapEnumerator.moveNext())
        {
            [taxCode, defaultDimension, inventTransId, internalInvoiceId, invoiceId, numberSequenceGroupId, documentType] = mapEnumerator.currentKey();

            if (conLen(mapEnumerator.currentKey()) == 7)
            {
                groupByKey = [taxCode, defaultDimension, '', '', '', '', documentType];
            }
            else
            {
                groupByKey = [taxCode, defaultDimension, '', '', '', ''];
            }

            if (resultMap.valueType() == Types::Container)
            {
                transAmounts =  BookStructSmallVATAmounts_RU::create(mapEnumerator.currentValue());
            }
            else
            {
                transAmounts =  mapEnumerator.currentValue();
            }
            transAmounts.itemName('');
            if (! _sumQty)
            {
                transAmounts.qty(0);
            }

            if (resultMap.exists(groupByKey))
            {
                if (resultMap.valueType() == Types::Container)
                {
                    transAmounts.addAmounts2(BookStructSmallVATAmounts_RU::create(resultMap.lookup(groupByKey)));
                }
                else
                {
                    transAmounts.addAmounts2(resultMap.lookup(groupByKey));
                }
            }

            if (resultMap.valueType() == Types::Container)
            {
                resultMap.insert(groupByKey,transAmounts.pack());
            }
            else
            {
                resultMap.insert(groupByKey,transAmounts);
            }
        }

        return resultMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMapAssetOpenAmounts</Name>
				<Source><![CDATA[
    protected Map initMapAssetOpenAmounts(Map       _mapFactureAmounts,
                                          RecId     _vendTransRecId,
                                          TransDate _settlementDate)
    {
        Map                                mapAssetOpenAmounts = new Map(_mapFactureAmounts.keyType(),Types::Class);
        MapEnumerator                      mapEnumerator = _mapFactureAmounts.getEnumerator();
        TaxCode                            taxCode;
        DimensionDefault                   defaultDimension;
        InventTransId                      inventTransId;
        PurchInternalInvoiceId             internalInvoiceId;
        InvoiceId                          invoiceId;
        NumberSequenceGroupId              numberSequenceGroupId;
        BookStructSmallVATAmounts_RU       openAmounts,factureAmounts;
        RAssetTable                        rAssetTable;
        RAssetStandards                    rAssetStandards;
        RAssetTrans                        rassetTrans;
        Qty                                openAssetQty,factureQty;
        PurchBookVATDocumentType_RU        documentType;
        RAssetStandardId                   bookIdDefault = RAssetParameters::standardIdDefault();

        while (mapEnumerator.moveNext())
        {
            [taxCode, defaultDimension, inventTransId, internalInvoiceId, invoiceId, numberSequenceGroupId, documentType] = mapEnumerator.currentKey();
            factureAmounts = BookStructSmallVATAmounts_RU::create(mapEnumerator.currentValue());

            openAmounts    = new BookStructSmallVATAmounts_RU();
            factureQty   = 0;
            openAssetQty = 0;

            select count(AssetReplaceCost) from rAssetTable
                index PurchInternalInvoiceIdx
                where rAssetTable.PurchInternalInvoiceId == internalInvoiceId                &&
                    rAssetTable.VendInvoiceId          == invoiceId                          &&
                    rAssetTable.InventTransId          == inventTransId                      &&
                    rAssetTable.NumberSequenceGroupId  == numberSequenceGroupId              &&
                    rAssetTable.VendAccount            == factureJour.CustVendInvoiceAccount;

            factureQty = rAssetTable.AssetReplaceCost;

            openAmounts.amountInclVAT(factureAmounts.amountInclVAT());

            if (! factureQty)
            {
                if (documentType == PurchBookVATDocumentType_RU::BuildingForOwnNeeds_Before2005 ||
                    documentType == PurchBookVATDocumentType_RU::ContractorsWork_Before2005     ||
                   (documentType == PurchBookVATDocumentType_RU::Goods                          &&
                    CustParameters::find().CustTaxation_RU == CustTaxation_RU::OnPayment        &&
                    _settlementDate < #TransitionStartDate))
                {
                    openAmounts.amountInclVAT(0);
                }
                openAmounts.amountLiableToVAT(openAmounts.amountInclVAT());
                openAmounts.taxAmountVAT(openAmounts.amountInclVAT());
                mapAssetOpenAmounts.insert(mapEnumerator.currentKey(),openAmounts);

                if (documentType == PurchBookVATDocumentType_RU::ContractorsWork_2005)
                {
                    contractorsNotAssetSet.add(mapEnumerator.currentKey() + _vendTransRecId);
                }

                continue;
            }

            openAmounts.qty(factureQty);
            select count(AssetReplaceCost) from rAssetTable
                index PurchInternalInvoiceIdx
                where rAssetTable.PurchInternalInvoiceId == internalInvoiceId
                    && rAssetTable.VendInvoiceId         == invoiceId
                    && rAssetTable.InventTransId         == inventTransId
                    && rAssetTable.NumberSequenceGroupId == numberSequenceGroupId
                    && rAssetTable.VendAccount           == factureJour.CustVendInvoiceAccount
                    && rAssetTable.Status                != RAssetStatus::PurchInvoice
                    && rAssetTable.VatRefundingStartDate == RAssetVatRefundingStartDate::DepreciationDate
                join maxof(DepStartDate) from rAssetStandards
                    where rAssetStandards.AssetId          == rAssetTable.AccountNum
                        && rAssetStandards.AssetStandardId == bookIdDefault
                        && rAssetStandards.DepStartDate    <= toDate;

            openAssetQty += rAssetTable.AssetReplaceCost;
            maxAssetOpenDate = rAssetStandards.DepStartDate;

            while select AccountNum from rAssetTable
                index PurchInternalInvoiceIdx
                where rAssetTable.PurchInternalInvoiceId == internalInvoiceId
                    && rAssetTable.VendInvoiceId         == invoiceId
                    && rAssetTable.InventTransId         == inventTransId
                    && rAssetTable.NumberSequenceGroupId == numberSequenceGroupId
                    && rAssetTable.VendAccount           == factureJour.CustVendInvoiceAccount
                    && rAssetTable.Status                != RAssetStatus::PurchInvoice
                    && rAssetTable.VatRefundingStartDate == RAssetVatRefundingStartDate::AcquisitionDate
            {
                select firstonly TransDate, RecId from rAssetTrans
                    index RAssetDateIdx
                    where rAssetTrans.AccountNum      == rAssetTable.AccountNum
                        && rAssetTrans.AssetStandardId == bookIdDefault
                        && rAssetTrans.TransDate       <= toDate
                        && rAssetTrans.AssetTransType  == RAssetTransType::Acquisition
                        && !rAssetTrans.StornoRecId;

                if (rAssetTrans.RecId)
                {
                    openAssetQty ++;
                    maxAssetOpenDate = max(maxAssetOpenDate, rAssetTrans.TransDate);
                }
            }

            if (! openAssetQty)
            {
                mapAssetOpenAmounts.insert(mapEnumerator.currentKey(),openAmounts);
                continue;
            }

            openAmounts.amountLiableToVAT(CurrencyExchangeHelper::amount(openAmounts.amountInclVAT() * openAssetQty / factureQty));

            if (isGroupBy)
            {
                openAmounts = this.calcAssetUsedAmounts(taxCode, defaultDimension, inventTransId, _vendTransRecId, openAmounts);
            }

            mapAssetOpenAmounts.insert(mapEnumerator.currentKey(),openAmounts);
        }
        return mapAssetOpenAmounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAmountAdjustment</Name>
				<Source><![CDATA[
    protected boolean isAmountAdjustment()
    {
        return super() && VendParameters::find().AmountDiffBookCorrection_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPrepaymentStorno</Name>
				<Source><![CDATA[
    protected boolean isPrepaymentStorno()
    {
        return super() && factureJour.Module == FactureModule_RU::Cust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRestoredVAT</Name>
				<Source><![CDATA[
    protected boolean isRestoredVAT()
    {
        select firstonly tmpRestoredVATLogTrans
            where tmpRestoredVATLogTrans.FactureId  == factureJour.FactureId &&
                  tmpRestoredVATLogTrans.Module     == factureJour.Module;

        return (tmpRestoredVATLogTrans.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDeferrals</Name>
				<Source><![CDATA[
    private RDeferralsTable loadDeferrals(FactureTrans_RU _factureTrans)
    {
        RDeferralsTable    deferralsTable;
        boolean            rDeferralsWasFound;
        VendInvoiceTrans   vendInvoiceTrans;
        LedgerJournalTrans ledgerJournalTrans;
        VendInvoiceJour    vendInvoiceJour;

        void selectDeferralsTable(RefTableId _refTableId, RefRecId _refRecId)
        {
            select firstonly deferralsTable
                    where deferralsTable.RefTableId == _refTableId &&
                          deferralsTable.RefRecId   == _refRecId;
        }
        ;

        if (factureJour.FactureType != FactureType_RU::TaxCorrection)
        {
            vendInvoiceTrans = VendInvoiceTrans::findFacture_RU(_factureTrans);
            if (vendInvoiceTrans.InventTransId)
            {
                selectDeferralsTable(vendInvoiceTrans.TableId, vendInvoiceTrans.RecId);
            }
            else
            {
                vendInvoiceJour = vendInvoiceTrans.vendInvoiceJour();
                while select AccountType, OffsetAccountType, LedgerDimension, OffsetLedgerDimension, RecId from ledgerJournalTrans
                    where ledgerJournalTrans.Voucher        == vendInvoiceJour.LedgerVoucher  &&
                          ledgerJournalTrans.TransDate      == vendInvoiceJour.InvoiceDate    &&
                          ledgerJournalTrans.Invoice        == vendInvoiceJour.InvoiceId
                {
                    if ((ledgerJournalTrans.AccountType   == LedgerJournalACType::Vend &&
                         ledgerJournalTrans.parmAccount() == vendInvoiceJour.InvoiceAccount) ||
                        (ledgerJournalTrans.OffsetAccountType   == LedgerJournalACType::Vend &&
                         ledgerJournalTrans.parmOffsetAccount() == vendInvoiceJour.InvoiceAccount))
                    {
                        break;
                    }
                }

                selectDeferralsTable(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId);
            }
        }
        else
        {
            ledgerJournalTrans = LedgerJournalTrans_RU_Extension::findFacture_RU(_factureTrans);
            selectDeferralsTable(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId);
        }

        rDeferralsWasFound = (deferralsTable && deferralsTable.vatRefundingMethod == RDeferralsVATRefundingMethod::Proportional) ? true : false;

        if (rDeferralsWasFound)
        {
            return deferralsTable;
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();
        vatProcessParameters   = PurchBookVATProcessParameters_RU::defaultParms();
        isGroupBy              = VendParameters::find().VatProcessGroupBy_RU;

        contractorsOpenMapMap  = new Map(Types::Container, Types::Container);
        contractorsStornoMap   = new Map(Types::Container, Types::Container);
        contractorsExcludeSet  = new Set(Types::Container);
        contractorsNotAssetSet = new Set(Types::Container);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckTransForProcess</Name>
				<Source><![CDATA[
    public boolean parmCheckTransForProcess(boolean _checkTransForProcess = checkTransForProcess)
    {
        checkTransForProcess = _checkTransForProcess;
        return checkTransForProcess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmClosingDate</Name>
				<Source><![CDATA[
    protected TransDate parmClosingDate(TransDate _closingDate = closingDate)
    {
        closingDate = _closingDate;
        return closingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsGroupBy</Name>
				<Source><![CDATA[
    protected boolean parmIsGroupBy(boolean _isGroupBy = isGroupBy)
    {
        isGroupBy = _isGroupBy;

        return isGroupBy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMessageAlreadySettled</Name>
				<Source><![CDATA[
    public boolean parmMessageAlreadySettled(boolean _messageAlreadySettled = messageAlreadySettled)
    {
        messageAlreadySettled = _messageAlreadySettled;
        return messageAlreadySettled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumOfMonths</Name>
				<Source><![CDATA[
    protected Integer parmNumOfMonths(Integer _numOfMonths = numOfMonths)
    {
        numOfMonths = _numOfMonths;
        return numOfMonths;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRestoredTrans</Name>
				<Source><![CDATA[
    protected TmpRestoredVATLogTrans_RU parmRestoredTrans(TmpRestoredVATLogTrans_RU _tmpRestoredVATLogTrans = tmpRestoredVATLogTrans)
    {
        tmpRestoredVATLogTrans = _tmpRestoredVATLogTrans;

        return tmpRestoredVATLogTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransOperTable</Name>
				<Source><![CDATA[
    protected TmpPurchBookVATProcessLogTransOper_RU parmTransOperTable(TmpPurchBookVATProcessLogTransOper_RU   _tmpProcessLogTransOper = tmpProcessLogTransOper)
    {
        tmpProcessLogTransOper = _tmpProcessLogTransOper;

        return tmpProcessLogTransOper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareFactureMap</Name>
				<Source><![CDATA[
    protected Map prepareFactureMap(Map _factureMap)
    {
        return _factureMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareFactureMap_TaxCorrection</Name>
				<Source><![CDATA[
    protected Map prepareFactureMap_TaxCorrection(Map _factureMap)
    {
        return _factureMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAdvanceReport</Name>
				<Source><![CDATA[
    protected void processAdvanceReport()
    {
        FactureTrans_RU                       factureTrans;
        EmplAdvLine_RU                        emplAdvLine;
        BookStructSmallVATAmounts_RU          settledAmounts, usedAmounts, blockedAmounts;
        BookStructVATAmounts_RU               totalUsedAmounts    = new BookStructVATAmounts_RU(),
                                              totalSettledAmounts = new BookStructVATAmounts_RU();
        Set                                   errorSet = new Set(Types::String);
        SetEnumerator                         setEnumerator;
        MapEnumerator                         mapEnumerator;
        TaxCode                               taxCode;
        DimensionDefault                      defaultDimension;
        PurchBookVATProcessParametersRecId_RU bookOperationRecId;
        CompanyId                             curCompany = curext();

        setPrefix(BookDataCalc_Purch_Process_RU::description());

        while select AdvanceId, DocumentDate from emplAdvLine
            exists join RecId from factureTrans
                where factureTrans.FactureId       == factureJour.FactureId             &&
                      factureTrans.Module          == FactureModule_RU::Empl            &&
                      factureTrans.FactureLineType == FactureLineType_RU::AdvanceReport &&
                      factureTrans.InvoiceId       == emplAdvLine.AdvanceId             &&
                      factureTrans.InvoiceLineNum  == emplAdvLine.LineNum
        {
            if (! errorSet.in(emplAdvLine.AdvanceId) && ! TaxReportPeriod::checkVATPeriod_RU(factureJour.FactureDate, emplAdvLine.DocumentDate))
            {
                errorSet.add(emplAdvLine.AdvanceId);
            }
        }

        setEnumerator = errorSet.getEnumerator();

        while (setEnumerator.moveNext())
        {
            setPrefix(strFmt("@GLS102589", factureJour.FactureExternalId));

            warning(strFmt("@GLS102537", emplAdvLine.AdvanceId, factureJour.FactureExternalId),
                    '',
                    new SysInfoAction_FormName_RU(factureJour, formStr(FactureJournal_RU)));
        }

        TmpPurchBookVATProcessLogTrans_RU::createLine(salesPurchBookDataMap,
                                                      factureJour.FactureId,
                                                      factureJour.FactureExternalId,
                                                      factureJour.FactureDate,
                                                      factureJour.FactureDate,
                                                      factureJour.FactureDate,
                                                      factureJour.FactureDate,
                                                      factureJour.CustVendInvoiceAccount,
                                                      this.findCustVendName(factureJour.Module, factureJour.CustVendInvoiceAccount),
                                                      '',
                                                      SalesPurchBookTransType_RU::AdvanceReport,
                                                      0,
                                                      0,
                                                      0,
                                                      curCompany,
                                                      curCompany,
                                                      0);

        mapEnumerator = FactureJour_RU::factureAmounts(factureJour).getEnumerator();

        while (mapEnumerator.moveNext())
        {
            [taxCode, defaultDimension, bookOperationRecId] = mapEnumerator.currentKey();

            settledAmounts = BookStructSmallVATAmounts_RU::create(mapEnumerator.currentValue());

            totalSettledAmounts.addSmallAmounts2(taxCode, settledAmounts);

            usedAmounts    = PurchBookVATProcessLogTransOper_RU::usedAmounts(factureJour.FactureId,
                                                                             taxCode,
                                                                             defaultDimension,
                                                                             '',
                                                                             0,
                                                                             0,
                                                                             curCompany,
                                                                             curCompany,
                                                                             0,
                                                                             factureJour.FactureDate,
                                                                             false);

            totalUsedAmounts.addSmallAmounts2(taxCode, usedAmounts);

            blockedAmounts = PurchBookVATProcessLogTransOper_RU::usedAmounts(factureJour.FactureId,
                                                                             taxCode,
                                                                             defaultDimension,
                                                                             '',
                                                                             0,
                                                                             0,
                                                                             curCompany,
                                                                             curCompany,
                                                                             0,
                                                                             factureJour.FactureDate,
                                                                             true);

            TmpPurchBookVATProcessLogTransOper_RU::createLines(tmpProcessLogTransOper,
                                                               factureJour.FactureId,
                                                               factureJour.FactureDate,
                                                               operationRecId ? operationRecId : bookOperationRecId,
                                                               defaultDimension,
                                                               taxCode,
                                                               '',
                                                               SalesPurchBookTransType_RU::AdvanceReport,
                                                               settledAmounts,
                                                               settledAmounts,
                                                               usedAmounts,
                                                               blockedAmounts,
                                                               null,
                                                               0,
                                                               0,
                                                               curCompany,
                                                               curCompany,
                                                               0,
                                                               salesPurchBookDataMap.RecId,
                                                               closingDate);
        }

        TmpPurchBookVATProcessLogTrans_RU::updateLine(salesPurchBookDataMap,
                                                      totalSettledAmounts,
                                                      totalSettledAmounts,
                                                      totalUsedAmounts,
                                                      fromDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAmountAdjustment</Name>
				<Source><![CDATA[
    protected void processAmountAdjustment()
    {
        TransDate                               settlementDate, reverseDate;
        VendTrans                               invoiceTrans, paymentTrans;
        CustVendTransPostingLog_RU              postingLog;
        MapEnumerator                           settledAmountsEnumerator, factureAmountsEnumerator;
        BookStructVATAmounts_RU                 totalSettledAmounts, totalUsedAmounts, totalFactureAmounts;
        Map                                     mapMapSettledAmounts, mapFactureAmounts;
        RecId                                   transRecId, settlementRecId, reverseTransRecId, paymentTransRecId;
        NoYes                                   reverseTrans;
        container                               totalAmounts;
        TaxCode                                 taxCode;
        SalesPurchBookTransType_RU              salesPurchBookTransType;
        CompanyId                               transCompany;
        CompanyId                               offsetCompany;
        FactureJour_RU                          factureJourOrig;
        MapEnumerator                           mapEnumerator;
        VendSettlement                          vendSettlement;
        FactureId_RU                            sourceFactureId;
        TransDate                               correctedPeriod;
        FactureDate_RU                          factureDate;

        select firstonly TransDate, Reversed, TransRecId, OffSetRecId, TransCompany, OffsetCompany, RecId from postingLog
            where postingLog.RecId == factureJour.PostingLogRecId;

        if (! postingLog)
        {
            return;
        }

        select firstonly vendSettlement
            where vendSettlement.TransRecId       == postingLog.TransRecId    &&
                  vendSettlement.OffsetRecid      == postingLog.OffSetRecId   &&
                  vendSettlement.TransCompany     == postingLog.TransCompany  &&
                  vendSettlement.OffsetCompany    == postingLog.OffsetCompany &&
                  vendSettlement.TransDate        == postingLog.TransDate;

        mapEnumerator = this.calcAmountAdjustments([vendSettlement.TransDate,
                                                    vendSettlement.RecId,
                                                    vendSettlement.TransRecId,
                                                    vendSettlement.OffsetRecid,
                                                    vendSettlement.ReversedRecId_RU,
                                                    vendSettlement.ReverseTrans_RU,
                                                    vendSettlement.reverseDate_RU(),
                                                    vendSettlement.TransCompany,
                                                    vendSettlement.OffsetCompany]).getEnumerator();

        factureDate = factureJour.FactureDate;

        while (mapEnumerator.moveNext())
        {
            [sourceFactureId, correctedPeriod] = mapEnumerator.currentKey();

            factureJourOrig = FactureJour_RU::find(sourceFactureId, factureJour.Module);

            if (factureJourOrig)
            {
                factureJour.FactureExternalId    = factureJourOrig.FactureExternalId;
                factureJour.FactureDate_External = factureJourOrig.FactureDate_External;
            }

            mapFactureAmounts    = Map::create(mapEnumerator.currentValue());
            mapMapSettledAmounts = new Map(Types::Container, Types::Class);

            mapMapSettledAmounts.insert([postingLog.TransDate,
                                        0,
                                        postingLog.TransRecId,
                                        postingLog.OffSetRecId,
                                        0,
                                        NoYes::No,
                                        postingLog.TransDate,
                                        postingLog.TransCompany,
                                        postingLog.OffsetCompany],
                                        mapFactureAmounts);

            if (postingLog.Reversed && factureJour.ReverseDate)
            {
                mapMapSettledAmounts.insert([factureJour.ReverseDate,
                                            0,
                                            postingLog.TransRecId,
                                            postingLog.OffSetRecId,
                                            0,
                                            NoYes::Yes,
                                            postingLog.TransDate,
                                            postingLog.TransCompany,
                                            postingLog.OffsetCompany],
                                            mapFactureAmounts);
            }

            salesPurchBookTransType = SalesPurchBookTransType_RU::SumDiff;

            factureJour.FactureDate = toDate;

            settledAmountsEnumerator = this.reduceSettlementMap(mapMapSettledAmounts,
                                                                fromDate,
                                                                correctedPeriod,
                                                                sourceFactureId).getEnumerator();

            factureJour.FactureDate = factureDate;

            while (settledAmountsEnumerator.moveNext())
            {
                [settlementDate, settlementRecId, transRecId, paymentTransRecId, reverseTransRecId, reverseTrans, reverseDate, transCompany, offsetCompany] = settledAmountsEnumerator.currentKey();

                invoiceTrans        = VendTrans::findByCompany(transCompany, transRecId);
                paymentTrans        = VendTrans::findByCompany(offsetCompany, paymentTransRecId);

                factureAmountsEnumerator = mapFactureAmounts.getEnumerator();

                totalFactureAmounts = new BookStructVATAmounts_RU();
                while (factureAmountsEnumerator.moveNext())
                {
                    [taxCode] = factureAmountsEnumerator.currentKey();
                    totalFactureAmounts.addSmallAmounts2(taxCode, BookStructSmallVATAmounts_RU::create(factureAmountsEnumerator.currentValue()));
                }

                TmpPurchBookVATProcessLogTrans_RU::createLine(salesPurchBookDataMap,
                                                              factureJour.FactureId,
                                                              factureJour.FactureExternalId,
                                                              factureJour.FactureDate,
                                                              paymentTrans.TransDate,
                                                              factureJour.FactureDate_External,
                                                              settlementDate,
                                                              factureJour.CustVendInvoiceAccount,
                                                              this.findCustVendName(factureJour.Module, factureJour.CustVendInvoiceAccount),
                                                              '',
                                                              salesPurchBookTransType,
                                                              invoiceTrans.RecId,
                                                              paymentTrans.RecId,
                                                              invoiceTrans.TableId,
                                                              transCompany,
                                                              offsetCompany,
                                                              settlementRecId,
                                                              reverseTransRecId,
                                                              reverseDate,
                                                              dateNull(),
                                                              PurchBookProcessingType_RU::Standard,
                                                              correctedPeriod,
                                                              sourceFactureId);

                if (reverseTrans)
                {
                    totalAmounts = this.createLogTransReverse(factureJour.FactureId,
                                                              transRecId,
                                                              paymentTransRecId,
                                                              transCompany,
                                                              offsetCompany,
                                                              reverseTransRecId,
                                                              reverseDate,
                                                              salesPurchBookDataMap.RecId,
                                                              PurchBookProcessingType_RU::Standard,
                                                              null,
                                                              correctedPeriod,
                                                              sourceFactureId);
                }
                else
                {
                    totalAmounts = this.createLogTrans(settlementDate,
                                                       transRecId,
                                                       paymentTransRecId,
                                                       transCompany,
                                                       offsetCompany,
                                                       settlementRecId,
                                                       salesPurchBookDataMap.RecId,
                                                       salesPurchBookTransType,
                                                       settledAmountsEnumerator.currentValue(),
                                                       mapFactureAmounts,
                                                       null,
                                                       false,
                                                       PurchBookProcessingType_RU::Standard,
                                                       correctedPeriod,
                                                       sourceFactureId);
                }

                totalSettledAmounts  = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 1));
                totalUsedAmounts     = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 2));

                TmpPurchBookVATProcessLogTrans_RU::updateLine(salesPurchBookDataMap,
                                                              totalFactureAmounts,
                                                              totalSettledAmounts,
                                                              totalUsedAmounts,
                                                              fromDate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAmountDiff</Name>
				<Source><![CDATA[
    protected void processAmountDiff()
    {
        TransDate                       settlementDate, reverseDate;
        VendTrans                       invoiceTrans, paymentTrans;
        CustVendTransPostingLog_RU      postingLog;
        MapEnumerator                   settledAmountsEnumerator, factureAmountsEnumerator;
        BookStructVATAmounts_RU         totalSettledAmounts, totalUsedAmounts, totalFactureAmounts;
        Map                             mapMapSettledAmounts, mapFactureAmounts;
        RecId                           transRecId, settlementRecId, reverseTransRecId, paymentTransRecId;
        NoYes                           reverseTrans;
        container                       totalAmounts;
        TaxCode                         taxCode;
        SalesPurchBookTransType_RU      salesPurchBookTransType;
        CompanyId                       transCompany;
        CompanyId                       offsetCompany;
        ;

        mapMapSettledAmounts = new Map(Types::Container, Types::Class);

        select firstonly TransDate, Reversed, TransRecId, OffSetRecId, TransCompany, OffsetCompany, RecId from postingLog
            where postingLog.RecId == factureJour.PostingLogRecId;

        if (! postingLog)
        {
            return;
        }

        mapFactureAmounts    = FactureJour_RU::factureAmounts(factureJour);
        mapMapSettledAmounts.insert([postingLog.TransDate,
                                    0,
                                    postingLog.TransRecId,
                                    postingLog.OffSetRecId,
                                    0,
                                    NoYes::No,
                                    postingLog.TransDate,
                                    postingLog.TransCompany,
                                    postingLog.OffsetCompany],
                                    mapFactureAmounts);

        if (postingLog.Reversed && factureJour.ReverseDate)
        {
            mapMapSettledAmounts.insert([factureJour.ReverseDate,
                                        0,
                                        postingLog.TransRecId,
                                        postingLog.OffSetRecId,
                                        0,
                                        NoYes::Yes,
                                        postingLog.TransDate,
                                        postingLog.TransCompany,
                                        postingLog.OffsetCompany],
                                        mapFactureAmounts);
        }

        switch (factureJour.FactureType)
        {
            case FactureType_RU::AmoutDifference :
                salesPurchBookTransType = SalesPurchBookTransType_RU::SumDiff;
                break;

            case FactureType_RU::ExchAdj :
                salesPurchBookTransType = SalesPurchBookTransType_RU::ExchAdj;
                break;

            case FactureType_RU::AdvanceAdjustment :
                salesPurchBookTransType = SalesPurchBookTransType_RU::AdvanceAdjustment;
                break;
        }

        settledAmountsEnumerator = this.reduceSettlementMap(mapMapSettledAmounts).getEnumerator();

        while (settledAmountsEnumerator.moveNext())
        {
            [settlementDate, settlementRecId, transRecId, paymentTransRecId, reverseTransRecId, reverseTrans, reverseDate, transCompany, offsetCompany] = settledAmountsEnumerator.currentKey();

            invoiceTrans        = VendTrans::findByCompany(transCompany, transRecId);
            paymentTrans        = VendTrans::findByCompany(offsetCompany, paymentTransRecId);

            factureAmountsEnumerator = mapFactureAmounts.getEnumerator();

            totalFactureAmounts = new BookStructVATAmounts_RU();
            while (factureAmountsEnumerator.moveNext())
            {
                [taxCode] = factureAmountsEnumerator.currentKey();
                totalFactureAmounts.addSmallAmounts2(taxCode, BookStructSmallVATAmounts_RU::create(factureAmountsEnumerator.currentValue()));
            }

            TmpPurchBookVATProcessLogTrans_RU::createLine(salesPurchBookDataMap,
                                                          factureJour.FactureId,
                                                          factureJour.FactureExternalId,
                                                          factureJour.FactureDate,
                                                          paymentTrans.TransDate,
                                                          factureJour.FactureDate_External,
                                                          settlementDate,
                                                          factureJour.CustVendInvoiceAccount,
                                                          this.findCustVendName(factureJour.Module, factureJour.CustVendInvoiceAccount),
                                                          '',
                                                          salesPurchBookTransType,
                                                          invoiceTrans.RecId,
                                                          paymentTrans.RecId,
                                                          invoiceTrans.TableId,
                                                          transCompany,
                                                          offsetCompany,
                                                          settlementRecId,
                                                          reverseTransRecId,
                                                          reverseDate);

            if (reverseTrans)
            {
                totalAmounts = this.createLogTransReverse(factureJour.FactureId,
                                                          transRecId,
                                                          paymentTransRecId,
                                                          transCompany,
                                                          offsetCompany,
                                                          reverseTransRecId,
                                                          reverseDate,
                                                          salesPurchBookDataMap.RecId);
            }
            else
            {
                totalAmounts = this.createLogTrans(settlementDate,
                                                   transRecId,
                                                   paymentTransRecId,
                                                   transCompany,
                                                   offsetCompany,
                                                   settlementRecId,
                                                   salesPurchBookDataMap.RecId,
                                                   salesPurchBookTransType,
                                                   settledAmountsEnumerator.currentValue(),
                                                   mapFactureAmounts);
            }

            totalSettledAmounts  = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 1));
            totalUsedAmounts     = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 2));

            TmpPurchBookVATProcessLogTrans_RU::updateLine(salesPurchBookDataMap,
                                                          totalFactureAmounts,
                                                          totalSettledAmounts,
                                                          totalUsedAmounts,
                                                          fromDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCustom</Name>
				<Source><![CDATA[
    protected void processCustom()
    {
        VendTrans                           vendTrans;
        BookStructVATAmounts_RU             totalUsedAmounts, totalSettledAmounts,totalFactureAmounts;
        Map                                 mapFactureAmounts;
        container                           totalAmounts;
        CustomJournalTable_RU               customJournalTable;
        CustomJournalTrans_RU               customJournalTrans;
        CustomCorrectionTable_RU            customCorrectionTable;

        TransDate                           datePhysical;
        InventTrans                         inventTrans;
        InventTransOrigin                   inventTransOrigin;

        select firstonly vendTrans
            where vendTrans.Voucher      == factureJour.Voucher &&
                  vendTrans.CurrencyCode == factureJour.CurrencyCode;

        select firstonly customJournalTable
            where customJournalTable.FactureId == factureJour.FactureId;

        if (! customJournalTable)
        {
            select firstonly customCorrectionTable
                where customCorrectionTable.FactureId == factureJour.FactureId;

            customJournalTable = customCorrectionTable.customJournalTable();
        }

        while select DatePhysical from inventTrans
            exists join inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
                exists join customJournalTrans
                    where customJournalTrans.SalesPurchInventTransId == inventTransOrigin.InventTransId &&
                          customJournalTrans.InvoiceId               == inventTrans.InvoiceId           &&
                          customJournalTrans.CustomJournalId         == customJournalTable.CustomJournalId
        {
            if (inventTrans.DatePhysical > datePhysical)
            {
                datePhysical = inventTrans.DatePhysical;
            }
        }

        mapFactureAmounts = FactureJour_RU::factureAmounts(factureJour);

        TmpPurchBookVATProcessLogTrans_RU::createLine(salesPurchBookDataMap,
                                                      factureJour.FactureId,
                                                      factureJour.FactureExternalId,
                                                      factureJour.FactureDate,
                                                      dateNull(),
                                                      datePhysical,
                                                      dateNull(),
                                                      factureJour.CustVendInvoiceAccount,
                                                      this.findCustVendName(factureJour.Module, factureJour.CustVendInvoiceAccount),
                                                      customJournalTable.InventGTDId,
                                                      factureJour.FactureType == FactureType_RU::GTD ? SalesPurchBookTransType_RU::GTD : SalesPurchBookTransType_RU::CustomCorrection,
                                                      vendTrans.RecId,
                                                      0,
                                                      vendTrans.TableId,
                                                      vendTrans.company(),
                                                      curext(),
                                                      0,
                                                      0,
                                                      dateNull(),
                                                      dateNull(),
                                                      PurchBookProcessingType_RU::Standard,
                                                      dateNull(),
                                                      '',
                                                      false,
                                                      factureJour.FactureReportDate);

        totalAmounts = this.createLogTrans(dateNull(),
                                           vendTrans.RecId,
                                           0,
                                           vendTrans.company(),
                                           curext(),
                                           0,
                                           salesPurchBookDataMap.RecId,
                                           factureJour.FactureType == FactureType_RU::GTD ? SalesPurchBookTransType_RU::GTD : SalesPurchBookTransType_RU::CustomCorrection,
                                           mapFactureAmounts,
                                           mapFactureAmounts);

        totalSettledAmounts  = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 1));
        totalUsedAmounts     = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 2));
        totalFactureAmounts  = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 1));

        TmpPurchBookVATProcessLogTrans_RU::updateLine(salesPurchBookDataMap,
                                                      totalFactureAmounts,
                                                      totalSettledAmounts,
                                                      totalUsedAmounts,
                                                      fromDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processInvoice</Name>
				<Source><![CDATA[
    protected void processInvoice()
    {
        FactureCalcBalances_OnPayment_RU    factureCalcBalances = new FactureCalcBalances_OnPayment_RU(factureJour);
        BookStructVATAmounts_RU             totalFactureAmounts, totalUsedAmounts, totalSettledAmounts;
        MapEnumerator                       mapEnumerator;
        TransDate                           settlementDate,reverseDate;
        RecId                               transRecId, settlementRecId, reverseTransRecId,paymentTransRecId;
        VendTrans                           invoiceTrans, paymentTrans;
        Set                                 checkedTrans = new Set(typeName2Type(extendedTypeStr(RecId)));
        SalesPurchBookTransType_RU          transType;
        Map                                 mapFactureAmounts, mapMapFactureAmounts, mapFactureAmountsDetails;
        Map                                 countryGTDMap = new Map(typeName2Type(extendedTypeStr(RecId)), Types::String);
        Str1260                             countryGTD;
        NoYes                               reverseTrans;
        container                           totalAmounts;
        Map                                 mapMapAssetOpenAmounts = new Map(Types::Container,Types::Class);
        Map                                 mapAssetOpenAmounts;
        CompanyId                           transCompany;
        CompanyId                           offsetCompany;
        ;

        setPrefix(BookDataCalc_Purch_Process_RU::description());

        factureCalcBalances.calc();

        mapMapFactureAmounts = this.prepareFactureMap(factureCalcBalances.mapMapFactureAmounts());

        mapEnumerator = this.reduceSettlementMap(factureCalcBalances.mapMapSettledAmounts()).getEnumerator();

        maxAssetOpenDate = dateNull();

        while (mapEnumerator.moveNext())
        {
            [settlementDate,settlementRecId,transRecId,paymentTransRecId,reverseTransRecId,reverseTrans,reverseDate,transCompany,offsetCompany] = mapEnumerator.currentKey();

            invoiceTrans = VendTrans::findByCompany(transCompany, transRecId);
            paymentTrans = VendTrans::findByCompany(offsetCompany, paymentTransRecId);

            if (this.isBadAmortisation(paymentTrans))
            {
                continue;
            }

            if (fullCheck && ! checkedTrans.in(transRecId))
            {
                if ( ! TaxReportPeriod::checkVATPeriod_RU(factureJour.FactureReportDate, invoiceTrans.TransDate))
                {
                    setPrefix(strFmt("@GLS102589", factureJour.FactureExternalId));

                    warning(strFmt("@GLS104921", invoiceTrans.Invoice, factureJour.FactureExternalId),
                            '',
                            new SysInfoAction_FormName_RU(factureJour, formStr(FactureJournal_RU)));
                }

                checkedTrans.add(transRecId);
            }

            mapFactureAmounts = factureCalcBalances.mapFactureAmounts();

            totalFactureAmounts  = BookStructVATAmounts_RU::create(mapFactureAmounts.lookup(transRecId));

            transType = totalFactureAmounts.amountInclVAT() > 0 ? SalesPurchBookTransType_RU::Invoice   :
                                                                  SalesPurchBookTransType_RU::CreditNote;

            if ( ! countryGTDMap.exists(transRecId))
            {
                countryGTDMap.insert(transRecId, this.appendGtd(invoiceTrans));
            }

            countryGTD = countryGTDMap.lookup(transRecId);

            mapFactureAmountsDetails = Map::create(mapMapFactureAmounts.lookup(transRecId));

            if (mapMapAssetOpenAmounts.exists([transRecId, max(settlementDate, factureJour.FactureReportDate) < #TransitionStartDate]))
            {
                mapAssetOpenAmounts = mapMapAssetOpenAmounts.lookup([transRecId, max(settlementDate, factureJour.FactureReportDate) < #TransitionStartDate]);
            }
            else
            {
                mapAssetOpenAmounts = this.groupByMapFactureAmounts(this.initMapAssetOpenAmounts(mapFactureAmountsDetails,transRecId, max(settlementDate, factureJour.FactureReportDate)), true);
                if (! isGroupBy)
                {
                    mapAssetOpenAmounts = this.groupByAssetUsedAmounts(mapAssetOpenAmounts,transRecId);
                }
                mapMapAssetOpenAmounts.insert([transRecId, max(settlementDate, factureJour.FactureReportDate) < #TransitionStartDate],mapAssetOpenAmounts);
            }

            TmpPurchBookVATProcessLogTrans_RU::createLine(salesPurchBookDataMap,
                                                          factureJour.FactureId,
                                                          factureJour.FactureExternalId,
                                                          factureJour.FactureDate,
                                                          paymentTrans.TransDate,
                                                          invoiceTrans.TransDate,
                                                          settlementDate,
                                                          factureJour.CustVendInvoiceAccount,
                                                          this.findCustVendName(factureJour.Module, factureJour.CustVendInvoiceAccount),
                                                          countryGTD,
                                                          transType,
                                                          transRecId,
                                                          paymentTrans.RecId,
                                                          invoiceTrans.TableId,
                                                          transCompany,
                                                          offsetCompany,
                                                          settlementRecId,
                                                          reverseTransRecId,
                                                          reverseDate,
                                                          maxAssetOpenDate,
                                                          PurchBookProcessingType_RU::Standard,
                                                          dateNull(),
                                                          '',
                                                          false,
                                                          factureJour.FactureReportDate);
            if (reverseTrans)
            {
                totalAmounts = this.createLogTransReverse(factureJour.FactureId,
                                                          transRecId,
                                                          paymentTransRecId,
                                                          transCompany,
                                                          offsetCompany,
                                                          reverseTransRecId,
                                                          reverseDate,
                                                          salesPurchBookDataMap.RecId,
                                                          PurchBookProcessingType_RU::Standard,
                                                          totalFactureAmounts);
            }
            else
            {
                if (contractorsOpenMapMap && contractorsOpenMapMap.exists(mapEnumerator.currentKey()))
                {
                    contractorsOpenMap = Map::create(contractorsOpenMapMap.lookup(mapEnumerator.currentKey()));
                }
                else
                {
                    contractorsOpenMap = null;
                }
                totalAmounts = this.createLogTrans(settlementDate,
                                                   transRecId,
                                                   paymentTransRecId,
                                                   transCompany,
                                                   offsetCompany,
                                                   settlementRecId,
                                                   salesPurchBookDataMap.RecId,
                                                   transType,
                                                   this.groupByMapFactureAmounts(Map::create(mapEnumerator.currentValue())),
                                                   this.groupByMapFactureAmounts(mapFactureAmountsDetails),
                                                   mapAssetOpenAmounts);
            }

            totalSettledAmounts  = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 1));
            totalUsedAmounts     = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 2));
            totalFactureAmounts.isGroupBy(isGroupBy);

            TmpPurchBookVATProcessLogTrans_RU::updateLine(salesPurchBookDataMap,
                                                          totalFactureAmounts,
                                                          totalSettledAmounts,
                                                          totalUsedAmounts,
                                                          fromDate,
                                                          tmpProcessLogTransOper);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPrepayment</Name>
				<Source><![CDATA[
    protected void processPrepayment()
    {
        VendTrans               paymentTrans;
        VendTrans_W             paymentTrans_W;
        BookStructVATAmounts_RU totalUsedAmounts, totalSettledAmounts,totalFactureAmounts;
        Map                     mapFactureAmounts;
        container               totalAmounts;
        boolean                 factureForNonPostedPrepaymentExists;
        TransDate               paymentDate;

        select firstonly paymentTrans
                where paymentTrans.AccountNum              == factureJour.CustVendInvoiceAccount &&
                      paymentTrans.Voucher                 == factureJour.Voucher                &&
                      paymentTrans.CurrencyCode            == factureJour.CurrencyCode           &&
                      paymentTrans.Prepayment              == NoYes::Yes
            exists join paymentTrans_W
                where paymentTrans_W.VendTrans             == paymentTrans.RecId &&
                      paymentTrans_W.PrepaymentFactureId_W == factureJour.FactureId;

        paymentDate = paymentTrans ? paymentTrans.TransDate : this.findPrepaymentJournalTrans().TransDate;

        factureForNonPostedPrepaymentExists = PurchBookVATProcessLogTransOper_RU::existUsedAmountsForUnpostedPrepayment(
            factureJour.FactureId,
            0,
            curext(),
            0,
            dateNull(),
            false,
            0,
            NoYes::No,
            PurchBookProcessingType_RU::Standard,
            dateNull(),
            '');
        mapFactureAmounts = FactureJour_RU::factureAmounts(factureJour);

        TmpPurchBookVATProcessLogTrans_RU::createLine(salesPurchBookDataMap,
                                                      factureJour.FactureId,
                                                      factureJour.FactureExternalId,
                                                      factureJour.FactureDate,
                                                      paymentDate,
                                                      dateNull(),
                                                      dateNull(),
                                                      factureJour.CustVendInvoiceAccount,
                                                      this.findCustVendName(factureJour.Module, factureJour.CustVendInvoiceAccount),
                                                      '',
                                                      SalesPurchBookTransType_RU::Prepayment,
                                                      0,
                                                      paymentTrans.RecId,
                                                      paymentTrans.TableId,
                                                      curext(),
                                                      paymentTrans.company(),
                                                      0,
                                                      0,
                                                      dateNull(),
                                                      dateNull(),
                                                      PurchBookProcessingType_RU::Standard,
                                                      dateNull(),
                                                      '',
                                                      false,
                                                      factureJour.FactureReportDate);

        totalAmounts = this.createLogTrans(dateNull(),
                                           0,
                                           factureForNonPostedPrepaymentExists ? 0 : paymentTrans.RecId,
                                           curext(),
                                           factureForNonPostedPrepaymentExists ? '' : paymentTrans.company(),
                                           0,
                                           salesPurchBookDataMap.RecId,
                                           SalesPurchBookTransType_RU::Prepayment,
                                           mapFactureAmounts,
                                           mapFactureAmounts);

        totalSettledAmounts  = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 1));
        totalUsedAmounts     = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 2));
        totalFactureAmounts  = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 1));

        TmpPurchBookVATProcessLogTrans_RU::updateLine(salesPurchBookDataMap,
                                                      totalFactureAmounts,
                                                      totalSettledAmounts,
                                                      totalUsedAmounts,
                                                      fromDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPrepaymentStorno</Name>
				<Source><![CDATA[
    protected void processPrepaymentStorno()
    {
        CustTrans                       invoiceTrans, paymentTrans;
        CustTrans_W                     paymentTrans_W;
        BookStructVATAmounts_RU         totalUsedAmounts, totalSettledAmounts,totalFactureAmounts;
        Map                             mapFactureAmounts;
        CustVendCalcSettledAmounts_RU   custVendCalcSettledAmounts;
        MapEnumerator                   settledAmountsEnumerator;
        TransDate                       settlementDate, reverseDate;
        RecId                           transRecId, settlementRecId, reverseTransRecId, paymentTransRecId;
        NoYes                           reverseTrans;
        container                       totalAmounts;
        CompanyId                       transCompany;
        CompanyId                       paymentCompany;

        mapFactureAmounts = FactureJour_RU::factureAmounts(factureJour);

        select firstonly paymentTrans
                where paymentTrans.AccountNum              == factureJour.CustVendInvoiceAccount &&
                  paymentTrans.Voucher                     == factureJour.Voucher                &&
                  paymentTrans.CurrencyCode                == factureJour.CurrencyCode           &&
                  paymentTrans.Prepayment                  == NoYes::Yes
            exists join paymentTrans_W
                where paymentTrans_W.CustTrans             == paymentTrans.RecId &&
                      paymentTrans_W.PrepaymentFactureId_W == factureJour.FactureId;

        custVendCalcSettledAmounts = CustVendCalcSettledAmounts_RU::construct(paymentTrans, factureJour.PostingLogRecId ? NoYes::Yes : NoYes::No);  // RU-473-568-TJGw
        custVendCalcSettledAmounts.calcSettledAmounts();
        settledAmountsEnumerator = this.reduceSettlementMap(custVendCalcSettledAmounts.mapMapSettledAmountsMST()).getEnumerator();

        while (settledAmountsEnumerator.moveNext())
        {
            [settlementDate,settlementRecId,paymentTransRecId,transRecId,reverseTransRecId,reverseTrans,reverseDate,paymentCompany,transCompany] = settledAmountsEnumerator.currentKey();

            invoiceTrans = CustTrans::findByCompany(transCompany, transRecId);

            if (this.isBadAmortisation(invoiceTrans))
            {
                continue;
            }

            TmpPurchBookVATProcessLogTrans_RU::createLine(salesPurchBookDataMap,
                                                          factureJour.FactureId,
                                                          factureJour.FactureExternalId,
                                                          factureJour.FactureDate,
                                                          paymentTrans.TransDate,
                                                          factureJour.FactureDate_External,
                                                          settlementDate,
                                                          factureJour.CustVendInvoiceAccount,
                                                          this.findCustVendName(factureJour.Module, factureJour.CustVendInvoiceAccount),
                                                          '',
                                                          SalesPurchBookTransType_RU::PrepaymentStorno,
                                                          invoiceTrans.RecId,
                                                          paymentTrans.RecId,
                                                          invoiceTrans.TableId,
                                                          transCompany,
                                                          paymentCompany,
                                                          settlementRecId,
                                                          reverseTransRecId,
                                                          reverseDate);

            if (reverseTrans)
            {
                totalAmounts = this.createLogTransReverse(factureJour.FactureId,
                                                          transRecId,
                                                          paymentTransRecId,
                                                          transCompany,
                                                          paymentCompany,
                                                          reverseTransRecId,
                                                          reverseDate,
                                                          salesPurchBookDataMap.RecId);
            }
            else
            {
                totalAmounts = this.createLogTrans(settlementDate,
                                                   transRecId,
                                                   paymentTransRecId,
                                                   transCompany,
                                                   paymentCompany,
                                                   settlementRecId,
                                                   salesPurchBookDataMap.RecId,
                                                   SalesPurchBookTransType_RU::PrepaymentStorno,
                                                   settledAmountsEnumerator.currentValue(),
                                                   mapFactureAmounts);
            }

            totalSettledAmounts  = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 1));
            totalUsedAmounts     = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 2));
            totalFactureAmounts  = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 1));
            if (reverseTrans)
            {
                totalFactureAmounts.reverseAmounts();
            }

            TmpPurchBookVATProcessLogTrans_RU::updateLine(salesPurchBookDataMap,
                                                          totalFactureAmounts,
                                                          totalSettledAmounts,
                                                          totalUsedAmounts,
                                                          fromDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRDeferralsCorrectedAmounts</Name>
				<Source><![CDATA[
    protected void processRDeferralsCorrectedAmounts(container          _correctedAmounts,
                                                     RecId              _processLogTransRecId,
                                                     InventTransId      _inventTransId  = '',
                                                     TaxCode            _taxCode        = '',
                                                     DimensionDefault   _defaultDimension = 0)
    {
        Map                               deferralsCorrectDates   = Map::create(_correctedAmounts);
        Map                               deferralsCorrectTrans;

        MapEnumerator                     meCorrectDates = deferralsCorrectDates.getEnumerator();
        MapEnumerator                     meCorrectTrans;

        TmpPurchBookVATProcessLogTrans_RU tmpPurchBookVATProcessLogTrans;

        RDeferralsTrans                   deferralsTrans;
        AmountCur                         curClosedSum;
        RecId                             settlementRecId;
        BookStructSmallVATAmounts_RU      curDisposalAmounts;
        BookStructVATAmounts_RU           totalSettledAmounts;

        BookStructVATAmounts_RU           transFactureAmounts;
        BookStructSmallVATAmounts_RU      transOperFactureAmounts;
        ;

        tmpPurchBookVATProcessLogTrans.setTmpData(salesPurchBookDataMap);
        buf2Buf(salesPurchBookDataMap, tmpPurchBookVATProcessLogTrans);

        while (meCorrectDates.moveNext())
        {
            totalSettledAmounts = new BookStructVATAmounts_RU();

            select firstonly tmpPurchBookVATProcessLogTrans
                where tmpPurchBookVATProcessLogTrans.RecId == _processLogTransRecId;

            select firstonly tmpProcessLogTransOper
                where (_inventTransId && tmpProcessLogTransOper.InventTransId == _inventTransId) ||
                      (_taxCode && tmpProcessLogTransOper.TaxCode == _taxCode && tmpProcessLogTransOper.DefaultDimension == _defaultDimension);

            transOperFactureAmounts = BookStructSmallVATAmounts_RU::create(tmpProcessLogTransOper.FactureAmounts);

            transFactureAmounts = new BookStructVATAmounts_RU();
            transFactureAmounts.addSmallAmounts2(_taxCode, transOperFactureAmounts);
            transFactureAmounts.isGroupBy(true);

            tmpPurchBookVATProcessLogTrans.CorrectedPeriod = meCorrectDates.currentKey();
            tmpPurchBookVATProcessLogTrans.FactureAmounts  = transFactureAmounts.pack();
            tmpPurchBookVATProcessLogTrans.insert();

            deferralsCorrectTrans = meCorrectDates.currentValue();
            meCorrectTrans        = deferralsCorrectTrans.getEnumerator();

            while (meCorrectTrans.moveNext())
            {
                deferralsTrans                                = meCorrectTrans.currentKey();
                curClosedSum                                  = conPeek(meCorrectTrans.currentValue(), 1);
                curDisposalAmounts                            = BookStructSmallVATAmounts_RU::create(conPeek(meCorrectTrans.currentValue(), 2));
                settlementRecId                               = conPeek(meCorrectTrans.currentValue(), 3);

                tmpProcessLogTransOper.Blocked                = NoYes::No;
                tmpProcessLogTransOper.BlockedAuto            = NoYes::No;
                tmpProcessLogTransOper.SettledAmounts         = curDisposalAmounts.pack();
                tmpProcessLogTransOper.RefRecId               = tmpPurchBookVATProcessLogTrans.RecId;
                tmpProcessLogTransOper.Percent                = 100;
                tmpProcessLogTransOper.AmountLiableToVAT      = curDisposalAmounts.amountLiableToVAT();
                tmpProcessLogTransOper.TaxAmount              = curDisposalAmounts.taxAmountVAT();
                tmpProcessLogTransOper.UsedAmounts            = conNull();
                tmpProcessLogTransOper.AllowDelete            = NoYes::No;
                tmpProcessLogTransOper.rDeferralsTransRecId   = deferralsTrans.RecId;
                tmpProcessLogTransOper.rDeferralsClosedAmount = curClosedSum;
                tmpProcessLogTransOper.insert();

                totalSettledAmounts.addSmallAmounts2(_taxCode, curDisposalAmounts);
            }

            tmpPurchBookVATProcessLogTrans.SettledAmounts = totalSettledAmounts.pack();
            tmpPurchBookVATProcessLogTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRestoredVAT</Name>
				<Source><![CDATA[
    protected void processRestoredVAT()
    {
        FactureCalcBalances_OnDelivery_RU    factureCalcBalances = new FactureCalcBalances_OnDelivery_RU(factureJour);
        Str1260                              countryGTD;
        container                            totalAmounts;
        BookStructVATAmounts_RU              totalFactureAmounts      = new BookStructVATAmounts_RU();
        BookStructVATAmounts_RU              totalUsedAmounts         = new BookStructVATAmounts_RU();
        BookStructVATAmounts_RU              totalSettledAmounts      = new BookStructVATAmounts_RU();
        Map                                  mapFactureAmountsDetails = new Map(Types::Container, Types::Container);
        Map                                  mapMapFactureAmounts     = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Container);
        Map                                  mapRestoredAmounts;
        Set                                  setExpFactureId;
        SetEnumerator                        setEnumerator;
        MapEnumerator                        mapEnumerator;
        MapEnumerator                        enumerator;
        MapEnumerator                        restEnumerator;
        TaxCode                              taxCode;
        DimensionDefault                     dim;
        BookStructSmallVATAmounts_RU         structAmounts;
        CustVendTransPostingLog_RU           postingLog;
        CompanyId                            curCompany = curext();
        ;

        switch (factureJour.FactureType)
        {
            case FactureType_RU::Invoice :
                factureCalcBalances.calc();
                mapMapFactureAmounts = factureCalcBalances.mapMapFactureAmounts();
                break;

            case FactureType_RU::AdvanceAdjustment :
                select firstonly * from postingLog
                    where postingLog.RecId == factureJour.PostingLogRecId;
                //no break!

            case FactureType_RU::AdvanceReport :
            case FactureType_RU::TaxCorrection :
                enumerator = FactureJour_RU::factureAmounts(factureJour).getEnumerator();

                while (enumerator.moveNext())
                {
                    [taxCode, dim] = enumerator.currentKey();

                    structAmounts = mapFactureAmountsDetails.exists([taxCode, dim, '', '', '', ''])                                       ?
                                    BookStructSmallVATAmounts_RU::create(mapFactureAmountsDetails.lookup([taxCode, dim, '', '', '', ''])) :
                                    new BookStructSmallVATAmounts_RU();

                    structAmounts.addAmounts2(BookStructSmallVATAmounts_RU::create(enumerator.currentValue()));

                    mapFactureAmountsDetails.insert([taxCode, dim, '', '', '', ''], structAmounts.pack());
                }

                mapMapFactureAmounts.insert(postingLog.TransRecId, mapFactureAmountsDetails.pack());
                break;
        }

        mapEnumerator = mapMapFactureAmounts.getEnumerator();

        while (mapEnumerator.moveNext())
        {
            select firstonly tmpRestoredVATLogTrans
                where tmpRestoredVATLogTrans.FactureId      == factureJour.FactureId &&
                      tmpRestoredVATLogTrans.Module         == factureJour.Module    &&
                      tmpRestoredVATLogTrans.InvoiceRecId   == mapEnumerator.currentKey();

            if (! tmpRestoredVATLogTrans)
            {
                continue;
            }

            mapFactureAmountsDetails = Map::create(mapEnumerator.currentValue());
            mapRestoredAmounts       = Map::create(tmpRestoredVATLogTrans.RestoredAmounts);
            setExpFactureId          = new Set(Types::String);

            restEnumerator = mapRestoredAmounts.getEnumerator();
            while (restEnumerator.moveNext())
            {
                setExpFactureId.add(conPeek(restEnumerator.currentKey(), 7));
            }

            if (factureJour.FactureType == FactureType_RU::Invoice)
            {
                totalFactureAmounts = BookStructVATAmounts_RU::create(factureCalcBalances.mapFactureAmounts().lookup(mapEnumerator.currentKey()));
            }
            else
            {
                totalFactureAmounts = new BookStructVATAmounts_RU();

                enumerator = mapFactureAmountsDetails.getEnumerator();
                while (enumerator.moveNext())
                {
                    [taxCode] = enumerator.currentKey();
                    totalFactureAmounts.addSmallAmounts2(taxCode, BookStructSmallVATAmounts_RU::create(enumerator.currentValue()));
                }
            }

            totalFactureAmounts.isGroupBy(true);

            countryGTD = this.appendGtd(VendTrans::find(mapEnumerator.currentKey()));

            setEnumerator = setExpFactureId.getEnumerator();

            while (setEnumerator.moveNext())
            {
                TmpPurchBookVATProcessLogTrans_RU::createLine(salesPurchBookDataMap,
                                                              factureJour.FactureId,
                                                              factureJour.FactureExternalId,
                                                              factureJour.FactureDate,
                                                              dateNull(),
                                                              mapEnumerator.currentKey()                            ?
                                                              VendTrans::find(mapEnumerator.currentKey()).TransDate :
                                                              factureJour.FactureDate,
                                                              toDate,
                                                              factureJour.CustVendInvoiceAccount,
                                                              this.findCustVendName(factureJour.Module, factureJour.CustVendInvoiceAccount),
                                                              countryGTD,
                                                              SalesPurchBookTransType_RU::VATExportConfirmation,
                                                              mapEnumerator.currentKey(),
                                                              0,
                                                              tableNum(VendTrans),
                                                              curCompany,
                                                              curCompany,
                                                              0,
                                                              0,
                                                              toDate,
                                                              dateNull(),
                                                              PurchBookProcessingType_RU::ExpConfirmation,
                                                              dateNull(),
                                                              setEnumerator.current(),
                                                              false,
                                                              factureJour.FactureReportDate);

                totalAmounts = this.createLogTrans(toDate,
                                                   mapEnumerator.currentKey(),
                                                   0,
                                                   curCompany,
                                                   curCompany,
                                                   0,
                                                   salesPurchBookDataMap.RecId,
                                                   SalesPurchBookTransType_RU::VATExportConfirmation,
                                                   mapRestoredAmounts,
                                                   mapFactureAmountsDetails,
                                                   null,
                                                   false,
                                                   PurchBookProcessingType_RU::ExpConfirmation,
                                                   dateNull(),
                                                   setEnumerator.current());

                totalSettledAmounts  = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 1));
                totalUsedAmounts     = BookStructVATAmounts_RU::create(conPeek(totalAmounts, 2));
                totalFactureAmounts.isGroupBy(isGroupBy);

                TmpPurchBookVATProcessLogTrans_RU::updateLine(salesPurchBookDataMap,
                                                              totalFactureAmounts,
                                                              totalSettledAmounts,
                                                              totalUsedAmounts,
                                                              fromDate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaxCorrection</Name>
				<Source><![CDATA[
    protected void processTaxCorrection()
    {
        MapEnumerator                   mapEnumerator;
        BookStructVATAmounts_RU         totalSettledAmounts, totalUsedAmounts, totalFactureAmounts;
        BookStructSmallVATAmounts_RU    settledAmounts, usedAmounts, blockedAmounts, factureAmounts;
        TaxCode                         taxCode;
        DimensionDefault                defaultDimension;
        PurchBookVATDocumentType_RU     documentType;
        Map                             mapSettledAmounts, mapFactureAmounts, tmpMap;
        CompanyId                       curCompany = curext();
        container                       rDeferralsOpenAmounts;

        totalSettledAmounts  = new BookStructVATAmounts_RU();
        totalFactureAmounts  = new BookStructVATAmounts_RU();
        totalUsedAmounts     = new BookStructVATAmounts_RU();

        tmpMap            = FactureJour_RU::factureAmounts(factureJour);

        mapSettledAmounts = this.reduceSettlementMap_TaxCorrection(tmpMap);
        mapFactureAmounts = this.prepareFactureMap_TaxCorrection(Map::create(tmpMap.pack()));

        mapEnumerator     = mapFactureAmounts.getEnumerator();

        TmpPurchBookVATProcessLogTrans_RU::createLine(salesPurchBookDataMap,
                                                      factureJour.FactureId,
                                                      factureJour.FactureExternalId,
                                                      factureJour.FactureDate,
                                                      dateNull(),
                                                      factureJour.PrepaymTaxCorrection == NoYes::Yes ? factureJour.CorrectedFactureDate : factureJour.FactureDate_External,
                                                      factureJour.FactureDate,
                                                      factureJour.CustVendInvoiceAccount,
                                                      this.findCustVendName(factureJour.Module, factureJour.CustVendInvoiceAccount),
                                                      '',
                                                      SalesPurchBookTransType_RU::TaxCorrection,
                                                      0,
                                                      0,
                                                      0,
                                                      curCompany,
                                                      curCompany,
                                                      0);

        while (mapEnumerator.moveNext())
        {
            [taxCode, defaultDimension, documentType] = mapEnumerator.currentKey();

            factureAmounts = BookStructSmallVATAmounts_RU::create(mapEnumerator.currentValue());
            totalFactureAmounts.addSmallAmounts2(taxCode, factureAmounts);

            settledAmounts = BookStructSmallVATAmounts_RU::create(mapSettledAmounts.lookup(mapEnumerator.currentKey()));
            totalSettledAmounts.addSmallAmounts2(taxCode, settledAmounts);

            usedAmounts     = PurchBookVATProcessLogTransOper_RU::usedAmounts(factureJour.FactureId,
                                                                              taxCode,
                                                                              defaultDimension,
                                                                              '',
                                                                              0,
                                                                              0,
                                                                              curCompany,
                                                                              curCompany,
                                                                              0,
                                                                              factureJour.FactureDate,
                                                                              false,
                                                                              0,
                                                                              NoYes::No,
                                                                              true,
                                                                              documentType);

            blockedAmounts  = PurchBookVATProcessLogTransOper_RU::usedAmounts(factureJour.FactureId,
                                                                              taxCode,
                                                                              defaultDimension,
                                                                              '',
                                                                              0,
                                                                              0,
                                                                              curCompany,
                                                                              curCompany,
                                                                              0,
                                                                              factureJour.FactureDate,
                                                                              true,
                                                                              0,
                                                                              NoYes::No,
                                                                              true,
                                                                              documentType);

            totalUsedAmounts.addSmallAmounts2(taxCode, usedAmounts);
            rDeferralsOpenAmounts = this.calcRDeferralOpenAmounts(salesPurchBookDataMap.RecId, settledAmounts, usedAmounts, 0, "", taxCode, defaultDimension);

            TmpPurchBookVATProcessLogTransOper_RU::createLines(tmpProcessLogTransOper,
                                                               factureJour.FactureId,
                                                               factureJour.FactureDate,
                                                               operationRecId,
                                                               defaultDimension,
                                                               taxCode,
                                                               '',
                                                               SalesPurchBookTransType_RU::TaxCorrection,
                                                               factureAmounts,
                                                               settledAmounts,
                                                               usedAmounts,
                                                               blockedAmounts,
                                                               null,
                                                               0,
                                                               0,
                                                               curCompany,
                                                               curCompany,
                                                               0,
                                                               salesPurchBookDataMap.RecId,
                                                               closingDate,
                                                               factureJour.FactureDate,
                                                               false,
                                                               documentType,
                                                               true,
                                                               dateNull(),
                                                               PurchBookProcessingType_RU::Standard,
                                                               conPeek(rDeferralsOpenAmounts, 1));

            this.processRDeferralsCorrectedAmounts(conPeek(rDeferralsOpenAmounts, 2), salesPurchBookDataMap.RecId, '', taxCode, defaultDimension);
        }

        TmpPurchBookVATProcessLogTrans_RU::updateLine(salesPurchBookDataMap,
                                                      totalFactureAmounts,
                                                      totalSettledAmounts,
                                                      totalUsedAmounts,
                                                      fromDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reduceSettlementMap</Name>
				<Source><![CDATA[
    protected Map reduceSettlementMap(Map           _settlementMap,
                                      TransDate     _fromDate           = fromDate,
                                      TransDate     _correctedPeriod    = dateNull(),
                                      FactureId_RU  _correctedFactureId = '')
    {
        Map                            reducedMap = new Map(Types::Container, _settlementMap.valueType());
        TransDate                      settlementDate,reverseDate;
        RecId                          settlementRecId,transRecId,reverseTransRecId,paymentTransRecId;
        MapEnumerator                  settlementEnumerator = _settlementMap.getEnumerator();
        NoYes                          reverseTrans;
        PurchBookVATProcessLogTrans_RU processLogTrans;
        RecordSortedList               processLogTransList;
        CompanyId                      transCompany;
        CompanyId                      paymentCompany;
        ;

        while (settlementEnumerator.moveNext())
        {
            [settlementDate,settlementRecId,transRecId,paymentTransRecId,reverseTransRecId,reverseTrans,reverseDate,transCompany,paymentCompany] = settlementEnumerator.currentKey();
            if (max(settlementDate, factureJour.FactureReportDate) > toDate)
            {
                continue;
            }

            if (reverseTrans)
            {
                if (PurchBookVATProcessLogTransOper_RU::checkLogTransOper(factureJour.FactureId,transRecId,paymentTransRecId,transCompany,paymentCompany,reverseDate,reverseTransRecId))
                {
                     reducedMap.insert([settlementDate,settlementRecId,transRecId,paymentTransRecId,reverseTransRecId,reverseTrans,reverseDate,transCompany,paymentCompany], settlementEnumerator.currentValue());
                }
                if (reducedMap.exists([reverseDate,reverseTransRecId,transRecId,paymentTransRecId,settlementRecId,!reverseTrans,reverseDate,transCompany,paymentCompany]))
                {
                    reducedMap.remove([reverseDate,reverseTransRecId,transRecId,paymentTransRecId,settlementRecId,!reverseTrans,reverseDate,transCompany,paymentCompany]);
                }
            }
            else
            {
                if (max(settlementDate, factureJour.FactureReportDate) < _fromDate)
                {
                    if ( factureJour.FactureType == FactureType_RU::Prepayment ||
                        ! PurchBookVATProcessLogTransOper_RU::existsBlockedTrans(factureJour.FactureId,transRecId,paymentTransRecId,transCompany,paymentCompany,settlementDate))
                    {
                        continue;
                    }
                }

                processLogTransList = PurchBookVATProcessLogTrans_RU::findFromSettlement(factureJour.FactureId,
                                                                                         transRecId,
                                                                                         paymentTransRecId,
                                                                                         transCompany,
                                                                                         paymentCompany,
                                                                                         settlementRecId,
                                                                                         settlementDate,
                                                                                         false,
                                                                                         true,
                                                                                         PurchBookProcessingType_RU::Standard,
                                                                                         _correctedPeriod,
                                                                                         _correctedFactureId);
                processLogTrans.clear();
                processLogTransList.first(processLogTrans);
                if (processLogTrans.Reversed == NoYes::No)
                {
                    reducedMap.insert([settlementDate,settlementRecId,transRecId,paymentTransRecId,reverseTransRecId,reverseTrans,reverseDate,transCompany,paymentCompany], settlementEnumerator.currentValue());
                }
            }
        }

        return reducedMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reduceSettlementMap_TaxCorrection</Name>
				<Source><![CDATA[
    protected Map reduceSettlementMap_TaxCorrection(Map _settlementMap)
    {
        return _settlementMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransCalc</Name>
				<Source><![CDATA[
    public static BookTransCalc_Purch_RU newTransCalc(FactureJour_RU                        _factureJour,
                                                      TransDate                             _fromDate,
                                                      TransDate                             _toDate,
                                                      SalesPurchBookDataMap_RU              _salesPurchBookData,
                                                      TmpPurchBookVATProcessLogTransOper_RU _tmpProcessLogTransOper,
                                                      TmpRestoredVATLogTrans_RU             _tmpRestoredVATLogTrans,
                                                      PurchBookVATProcessParametersRecId_RU _operationRecId,
                                                      NoYes                                 _checkTransitionBalances,
                                                      boolean                               _checkTransForProcess,
                                                      boolean                               _messageAlreadySettled,
                                                      Integer                               _numOfMonths,
                                                      TransDate                             _closingDate,
                                                      boolean                               _existRDeferralsStrono = false,
                                                      boolean                               _fullCheck             = false,
                                                      boolean                               _amountAdjCalc         = false)
    {
        BookTransCalc_Purch_RU bookTransCalcPurch;

        if (! RestoredVATLogTable_RU::checkApproved(_toDate) || _checkTransForProcess || _amountAdjCalc)
        {
            switch (_factureJour.FactureType)
            {
                case FactureType_RU::AdvanceReport     :
                case FactureType_RU::AmoutDifference   :
                case FactureType_RU::ExchAdj           :
                case FactureType_RU::AdvanceAdjustment :
                case FactureType_RU::Prepayment        :
                    bookTransCalcPurch = new BookTransCalc_Purch_RU();
                    break;

                case FactureType_RU::Facture         :
                    bookTransCalcPurch = new BookTransCalc_Purch_OnDelivery_RU();
                    break;

                default                              :
                    if ((_fromDate < #TransitionStartDate && _toDate < #TransitionStartDate) || _factureJour.vatOnPayment)
                    {
                        bookTransCalcPurch = new BookTransCalc_Purch_RU();
                    }
                    else
                    {
                        bookTransCalcPurch = new BookTransCalc_Purch_OnDelivery_RU();
                    }
            }

            if (_existRDeferralsStrono)
            {
                bookTransCalcPurch = new BookTransCalc_Purch_RDeferrals_RU();
            }
        }
        else
        {
            bookTransCalcPurch = new BookTransCalc_Purch_OnDelivery_RU();
        }

        bookTransCalcPurch.parmFactureJour(_factureJour);
        bookTransCalcPurch.parmDataMap(_salesPurchBookData);
        bookTransCalcPurch.parmFromDate(_fromDate);
        bookTransCalcPurch.parmToDate(_toDate);

        bookTransCalcPurch.parmTransOperTable(_tmpProcessLogTransOper);
        bookTransCalcPurch.parmRestoredTrans(_tmpRestoredVATLogTrans);
        bookTransCalcPurch.parmOperationRecId(_operationRecId);
        bookTransCalcPurch.parmMessageAlreadySettled(_messageAlreadySettled);
        bookTransCalcPurch.parmNumOfMonths(_numOfMonths);
        bookTransCalcPurch.parmCheckTransForProcess(_checkTransForProcess);
        bookTransCalcPurch.parmClosingDate(_closingDate);
        bookTransCalcPurch.parmFullCheck(_fullCheck);

        return bookTransCalcPurch;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>