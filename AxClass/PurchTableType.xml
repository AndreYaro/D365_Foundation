<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchTableType</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class PurchTableType extends InventType implements SalesPurchIModifiedDefaulter
{
    PurchTable              purchTable;
    
    NumberSeqFormHandler    numberSeqFormHandlerPurchId;
    PurchaseType            purchType;

    ProjId                  projId;

    SalesPurchCycle         salesPurchCycle;
    boolean                 purchCycle;

    #ISOCountryRegionCodes

    boolean                 allowPurchLineCaching;
    PurchTableCheckQuantity purchTableCheckQuantity;

    private PurchInstrumentationLogger instrumentationLogger;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>associateWithAgreementHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Associates the purchase order  with the specified Agreement.
    /// </summary>
    /// <param name="_purchAgreementHeader">
    /// The <c>AgreementHeader</c> record with which to associate the purchase order.
    /// </param>
    public void associateWithAgreementHeader(PurchAgreementHeader _purchAgreementHeader)
    {
        if (!PurchTableTypeAssociateWithAgreementHeaderFlight::instance().isEnabled()
            || !AgreementReleaseHeaderMatch::existPurch(purchTable.PurchId, purchTable.DataAreaId))
        {
            AgreementReleaseHeaderMatch agreementReleaseHeaderMatch;
            agreementReleaseHeaderMatch.initFromAgreementHeader(_purchAgreementHeader);
            agreementReleaseHeaderMatch.initFromPurchTable(purchTable);
            agreementReleaseHeaderMatch.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateOfInventSiteIdAndInventLocationId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if InventSiteId or InventLocationId can be updated.
    /// </summary>
    /// <returns>
    /// true if marking does not exist on the lines, otherwise false.
    /// </returns>
    public boolean checkUpdateOfInventSiteIdAndInventLocationId()
    {
        boolean ok = true;

        if (purchTable.InventLocationId != purchTable.orig().InventLocationId 
            || purchTable.InventSiteId != purchTable.orig().InventSiteId)
        {
            PurchLine purchLineLoc;
            SalesTable salesTable;

            select firstOnly ItemId, InventRefTransId, InventTransId from purchLineLoc
                exists join salesTable
                where purchLineLoc.PurchId == purchTable.PurchId
                    && purchLineLoc.InventRefTransId != ''
                    && purchLineLoc.ItemRefType == InventRefType::Sales
                    && salesTable.SalesId == purchLineLoc.InventRefId
                    && salesTable.SalesType == SalesType::ItemReq;
        
            if (this.checkIfMarkingExistOnPurchLine(purchLineLoc))
            {
                InventDimGroupSetup inventDimGroupSetup = InventDimGroupSetup::newItemId(purchLineLoc.ItemId);

                if(this.checkInventDimGroupSetup(inventDimGroupSetup))
                {
                    ok = checkFailed("@SYS98272");
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventDimGroupSetup</Name>
				<Source><![CDATA[
    protected boolean checkInventDimGroupSetup(InventDimGroupSetup _inventDimGroupSetup)
    { 
        return _inventDimGroupSetup.getFieldSetup(fieldNum(InventDim, InventSiteId)).isFinancialInventoryEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfMarkingExistOnPurchLine</Name>
				<Source><![CDATA[
    private boolean checkIfMarkingExistOnPurchLine(PurchLine _purchLine)
    {
        return  _purchLine.ItemId && InventTransOrigin::findByInventTransId(_purchLine.InventRefTransId).ReferenceId;        
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMarkingExistOnLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if any of the associated purchase order lines contain marking
    /// on modifying the storage dimensions that is site and location in the purchase order header.
    /// </summary>
    /// <returns>
    /// True if marking does not exist on the lines, otherwise false.
    /// </returns>
    ///
    [SysObsolete('This method is replaced by checkUpdateOfInventSiteIdAndInventLocationId()', false, 30\06\2020)]
    public boolean validateMarkingExistOnLines()
    {
        boolean ok = true;

        if (purchTable.InventLocationId != purchTable.orig().InventLocationId
            || purchTable.InventSiteId != purchTable.orig().InventSiteId)
        {
            PurchLine purchLineLoc;
            SalesTable salesTable;

            select firstOnly purchLineLoc
                exists join salesTable
                where purchLineLoc.PurchId == purchTable.PurchId
                    && purchLineLoc.InventRefTransId != ''
                    && purchLineLoc.ItemRefType == InventRefType::Sales
                    && salesTable.SalesId == purchLineLoc.InventRefId
                    && salesTable.SalesType == SalesType::ItemReq;

            if (purchLineLoc 
                && purchLineLoc.isStocked() 
                && InventTransOrigin::findByInventTransId(purchLineLoc.InventRefTransId).ReferenceId)
            {
                InventDimGroupSetup inventDimGroupSetup = InventDimGroupSetup::newItemId(purchLineLoc.ItemId);

                if (inventDimGroupSetup.getFieldSetup(fieldNum(InventDim, InventSiteId)).isFinancialInventoryEnabled())
                {
                    ok = checkFailed("@SYS98272");
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBillOfEntryBeUpdated_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the bill of entry be updated.
    /// </summary>
    /// <param name="_documentStatus">
    /// The document status.
    /// </param>
    /// <returns>
    /// If 'True', the bill of entry can be updated.
    /// </returns>
    public boolean  canBillOfEntryBeUpdated_IN(DocumentStatus _documentStatus = DocumentStatus::BillOfEntry_IN)
    {
        boolean                     ok = true;
        CustomsInvoiceRegnTrans_IN  customsInvoiceRegnTrans;
        CustomsInvoiceRegnJournalTable_IN customsInvoiceRegnJournalTable;
        CustomsInvoiceRegnJournalLine_IN customsInvoiceRegnJournalLine;

        if (_documentStatus == DocumentStatus::BillOfEntry_IN)
        {
            ok = this.mayBillOfEntryBeUpdated_IN();
        }
        if (ok)
        {
            if (!VendTable::canVendorBeUpdated(purchTable.OrderAccount, purchTable.InvoiceAccount, DocumentStatus::BillOfEntry_IN))
                ok = false;
        }
        // Check that at least one line exists in the InvoiceregnTrans table before enabling the BOE button
        if (ok)
        {
            select firstonly RecId from customsInvoiceRegnTrans
                join RecId from customsInvoiceRegnJournalLine
                    where customsInvoiceRegnTrans.CustomsInvoiceRegnJournalLineRecId == customsInvoiceRegnJournalLine.RecId
                join RecId from customsInvoiceRegnJournalTable
                    where customsInvoiceRegnJournalLine.CustomsInvoiceRegnJournalTableRecId == customsInvoiceRegnJournalTable.RecId
                       && customsInvoiceRegnJournalTable.OrderId == purchTable.PurchId;
            if (!customsInvoiceRegnTrans.RecId)
            {
                ok = false;
            }
        }
        if (ok)
        {
            if (CustomsVendBOETrans_IN::checkBillOfEntryComplete(purchTable.PurchId))
            {
                ok = false;
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCommFactureBeUpdated_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Identifies whether facture with type Commission can be updated.
    /// </summary>
    /// <returns>
    /// True if facture can be updated.
    /// </returns>
    /// <remarks>
    /// Identification occurs by agreement property AgencyAgreement.
    /// </remarks>
    public boolean canCommFactureBeUpdated_RU()
    {
        boolean                 ok = true;
        AgreementHeaderExt_RU   agreementHeader = AgreementHeaderExt_RU::find(purchTable.agreementHeaderExt_RU());

        if (agreementHeader.AgencyAgreement == AgencyAgreement_RU::SaleCommission)
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canConfirmationRequestBeUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the current purchase order can be updated for confirmation request.
    /// </summary>
    /// <returns>
    ///     True if it is possible to update the purchase order for confirmation request.
    /// </returns>
    public boolean  canConfirmationRequestBeUpdated()
    {
        return this.canAnyConfirmationRequestBeUpdated() && VendTable::find(purchTable.OrderAccount).VendVendorCollaborationType == VendVendorCollaborationType::Disabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBindingConfirmationRequestBeUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the current purchase order can be updated for binding confirmation request.
    /// </summary>
    /// <returns>
    ///     True if it is possible to update the purchase order for binding confirmation request.
    /// </returns>
    public boolean  canBindingConfirmationRequestBeUpdated()
    {
        return !purchTable.InterCompanyOrder
                && this.canAnyConfirmationRequestBeUpdated()
                && VendTable::find(purchTable.OrderAccount).VendVendorCollaborationType != VendVendorCollaborationType::Disabled
                && (!PurchBindingConfirmationRequestDisableFlight::instance().isEnabled()
                    || VendTable::existVendorCollaborationAccessAllowedContact(purchTable.OrderAccount));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAnyConfirmationRequestBeUpdated</Name>
				<Source><![CDATA[
 /// <summary>
    ///     Checks if the current purchase order can be updated for any confirmation request (binding or not binding).
    /// </summary>
    /// <returns>
    ///     True if it is possible to update the purchase order for any confirmation request.
    /// </returns>
    public boolean  canAnyConfirmationRequestBeUpdated()
    {
        boolean  result;

        result = (purchTable.DocumentState == VersioningDocumentState::Approved);
        result = result && this.mayPurchaseOrderBeUpdated();

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreditNoteBeCreated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the purchase order can be credited.
    /// </summary>
    /// <returns>
    /// true if the purchase order can be credited; otherwise, false.
    /// </returns>
    public boolean canCreditNoteBeCreated()
    {
        return !purchTable.isInvoiceMatched() && !purchTable.isFinalized();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canEditSalesPurchOperationType_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true when SalesPurchOperationType_BR can be edited.
    /// </summary>
    /// <returns>
    /// Returns true when <c>PurchTable</c> is not a cancelling fiscal document order
    /// Returns false when <c>PurchTable</c> is a cancelling fiscal document order
    /// </returns>
    public boolean canEditSalesPurchOperationType_BR()
    {
        return purchTable.purchTable_BR().InvoiceRefRecId_BR == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canFactureBeUpdated_RU</Name>
				<Source><![CDATA[
    public boolean canFactureBeUpdated_RU(DocumentStatus _documentStatus = DocumentStatus::Facture_RU)
    {
        boolean                 ok = true;
        VendInvoicePurchLink    invoicePurchLink;
        VendInvoiceJour         invoiceJour;

        if (_documentStatus == DocumentStatus::Facture_RU)
        {
            ok = this.mayFactureBeUpdated_RU();
        }

        if (ok)
        {
            select firstonly RecId from invoicePurchLink
                index hint origPurchIdx
                where invoicePurchLink.OrigPurchId == purchTable.PurchId
            join RecId from invoiceJour
                where invoiceJour.PurchId     == invoicePurchLink.PurchId     &&
                      invoiceJour.InvoiceId   == invoicePurchLink.InvoiceId   &&
                      invoiceJour.InvoiceDate == invoicePurchLink.InvoiceDate &&
                    ! invoiceJour.FacturedFully_RU;
            ok = ok && invoiceJour.RecId;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canFiscalDocTextBeRegistrated_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if Fiscal document texts can be registered to the Purchase header
    /// </summary>
    /// <returns>
    /// True if the Fiscal document text can be registered; false otherwise.
    /// </returns>
    public boolean canFiscalDocTextBeRegistrated_BR()
    {
        return  purchTable.RecId
                &&  (purchTable.PurchaseType == PurchaseType::Purch
                    || purchTable.PurchaseType == PurchaseType::ReturnItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInvoice4PaymBeUpdated_RU</Name>
				<Source><![CDATA[
    public boolean canInvoice4PaymBeUpdated_RU()
    {
        boolean  ok;

        ok = this.mayInvoice4PaymBeUpdated_RU();
        ok = ok && VendTable::canVendorBeUpdated(purchTable.OrderAccount,
                                                 purchTable.InvoiceAccount,
                                                 DocumentStatus::Invoice4Paym_RU);
        ok = ok && this.checkPurchQty(DocumentStatus::Invoice4Paym_RU);

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInvoiceBeCreatedByVendor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a new vendor invoice can be created for the purchase order.
    /// </summary>
    /// <returns>
    /// true means new vendor invoice can be created; otherwise, false.
    /// </returns>
    public boolean canInvoiceBeCreatedByVendor()
    {
        if (purchTable.InterCompanyOrder == NoYes::No &&
            purchTable.DocumentState == VersioningDocumentState::Confirmed &&
            (purchTable.isOpenOrder() ||
            purchTable.isReceived()))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInvoiceBeUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a vendor invoice can be updated.
    /// Returns true when getInvoiceUpdateAvailability returns NoErrorFound.
    /// </summary>
    /// <param name="_excludePending">
    /// Check invoice update availability
    /// </param>
    /// <returns>
    /// true means a vendor invoice can be updated; otherwise, false.
    /// </returns>
    public boolean canInvoiceBeUpdated(boolean _excludePending = false)
    {
        return this.getInvoiceUpdateAvailability(_excludePending) == InvoiceUpdateAvailability::NoErrorFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceUpdateAvailability</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether a vendor invoice is available to be updated.
    /// If a vendor invoice is not invoiceable, return a reason as InvoiceUpdateAvailability.
    /// </summary>
    /// <param name="_excludePending">
    /// Check invoice update availability
    /// </param>
    /// <returns>
    /// InvoiceUpdateAvailability; Reason code of not available or NoErrorFound.
    /// </returns>
    private InvoiceUpdateAvailability getInvoiceUpdateAvailability(boolean _excludePending)
    {
        boolean ok = true;
        InvoiceUpdateAvailability ret = InvoiceUpdateAvailability::NoErrorFound;

        ok = this.mayInvoiceBeUpdated();
        if (!ok)
        {
            ret = InvoiceUpdateAvailability::SalesPurchCycleInactive;
        }

        if (ok)
        {
            if (!VendTable::canVendorBeUpdated(purchTable.OrderAccount, purchTable.InvoiceAccount, DocumentStatus::Invoice))
            {
                ok = false;
                ret = InvoiceUpdateAvailability::VendorBlocked;
            }
        }

        if (ok)
        {
            if (purchTable.InterCompanyOrder
            &&  purchTable.InterCompanyOriginalSalesId
            &&  purchTable.InterCompanyDirectDelivery)
            {
                if (!purchTable.interCompanyEndpointActionPolicy().PostPurchInvoice
                &&   purchTable.interCompanySalesTable().SalesStatus == SalesStatus::Invoiced)
                {
                    ok = true;
                }
                else
                {
                    ok = false;
                    ret = InvoiceUpdateAvailability::POInterCompanyEndpointActionPolicyFailure;
                }
            }
            else
            {
                ok = true;
            }
        }

        if (ok)
        {
            // if there is a saved or active invoice, enable posting invoice even if there is no qty to invoice
            // so that the user can access the document for deletion etc.
            ok = VendInvoiceInfoLine::existAnyPurch(purchTable.PurchId)
                    || this.checkPurchQty(DocumentStatus::Invoice, _excludePending);
            if (!ok) 
            {
                ret = InvoiceUpdateAvailability::PONotActiveAndNoQtyToInvoice;
            }
        }

        if (!ok && Project::Enabled())
        {
            PurchLine purchLineLoc;

            select firstonly purchLineLoc
                where purchLineLoc.PurchId == purchTable.PurchId &&
                purchLineLoc.psaTotalRetainAmount != 0;

            if (purchLineLoc)
            {
                ok = true;
                ret = InvoiceUpdateAvailability::NoErrorFound;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInvoiceBeUpdated_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the invoice can be updated.
    /// </summary>
    /// <returns>
    /// Returns true if the invoice can be updated.
    /// </returns>
    public boolean  canInvoiceBeUpdated_IN()
    {
        boolean  ok = true;

        ok = this.mayInvoiceBeUpdated();
        if (ok && !VendTable::canVendorBeUpdated(purchTable.OrderAccount, purchTable.InvoiceAccount, DocumentStatus::Invoice))
        {
            ok = false;
        }
        if (ok)
        {
            if (purchTable.InterCompanyOrder
                &&  purchTable.InterCompanyOriginalSalesId
                &&  purchTable.InterCompanyDirectDelivery)
            {
                ok = (!purchTable.interCompanyEndpointActionPolicy().PostPurchInvoice
                    &&   purchTable.interCompanySalesTable().SalesStatus == SalesStatus::Invoiced);
            }
            ok = ok && true;
        }

        if (ok)
        {
            ok = this.checkPurchQty(DocumentStatus::Invoice);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInvoiceRegistrationBeUpdated_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the invoice registration can be updated.
    /// </summary>
    /// <param name="_documentStatus">
    /// The document status.
    /// </param>
    /// <returns>
    /// Returns true if the invoice registration can be updated.
    /// </returns>
    public boolean  canInvoiceRegistrationBeUpdated_IN(DocumentStatus _documentStatus = DocumentStatus::InvoiceRegistration_IN)
    {
        boolean  ok = true;

        if (_documentStatus == DocumentStatus::InvoiceRegistration_IN)
        {
            ok = this.mayInvoiceRegistrationBeUpdated_IN();
        }
        if (ok && !VendTable::canVendorBeUpdated(purchTable.OrderAccount, purchTable.InvoiceAccount, DocumentStatus::InvoiceRegistration_IN))
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPackingslipBeUpdated</Name>
				<Source><![CDATA[
    boolean  canPackingslipBeUpdated(DocumentStatus _documentStatus = DocumentStatus::PackingSlip)
    {
        boolean  ok = true;

        if (_documentStatus == DocumentStatus::PackingSlip)
        {
            ok = this.mayPackingSlipBeUpdated();
        }

        if (ok)
        {
            if (!VendTable::canVendorBeUpdated(purchTable.OrderAccount, purchTable.InvoiceAccount, DocumentStatus::PackingSlip))
                ok = false;
        }

        if (ok)
            ok = this.interCompanyCanBeUpdated();

        if (ok)
            ok = this.checkPurchQty(DocumentStatus::PackingSlip);

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPackingslipBeUpdated_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if packing slip can be updated.
    /// </summary>
    /// <param name="_documentStatus">
    /// The document status.
    /// </param>
    /// <returns>
    /// Returns true if the packing slip can be updated.
    /// </returns>
    public boolean canPackingslipBeUpdated_IN(DocumentStatus _documentStatus = DocumentStatus::PackingSlip)
    {
        boolean  ok = true;

        if (_documentStatus == DocumentStatus::PackingSlip)
        {
            ok = this.mayPackingSlipBeUpdated();
        }
        if (ok && !VendTable::canVendorBeUpdated(purchTable.OrderAccount, purchTable.InvoiceAccount, DocumentStatus::PackingSlip))
        {
            ok = false;
        }
        if (ok)
        {
            ok = this.interCompanyCanBeUpdated();
        }
        if (ok)
        {
            ok = this.checkPurchQty(DocumentStatus::PackingSlip);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPurchaseOrderBeUpdated</Name>
				<Source><![CDATA[
    boolean  canPurchaseOrderBeUpdated()
    {
        boolean  ok = true;

        ok = this.mayPurchaseOrderBeUpdated();

        // <GEERU>
        if (ok
            && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
            && !isFlightEnabled(LocalizationFlights::IgnoreCallCheckPurchQty_RU))
        {
            ok = this.checkPurchQty(DocumentStatus::PurchaseOrder);
        }
        // </GEERU>

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReceiptsListBeUpdated</Name>
				<Source><![CDATA[
    boolean  canReceiptsListBeUpdated()
    {
        boolean  ok = true;

        ok = this.mayReceiptsListBeUpdated();

        if (ok)
        {
            if (!this.canPackingslipBeUpdated(DocumentStatus::ReceiptsList))
            ok = false;
        }

        // <GEERU>
        if (ok && SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]))
        {
            ok = this.checkPurchQty(DocumentStatus::ReceiptsList);
        }
        // </GEERU>

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReceiptsListBeUpdated_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if receipts list can be updates.
    /// </summary>
    /// <returns>
    /// Returns true if the receipts list can be updated.
    /// </returns>
    public boolean  canReceiptsListBeUpdated_IN()
    {
        boolean  ok = true;

        if (this.mayReceiptsListBeUpdated()
            && !this.canPackingslipBeUpdated(DocumentStatus::ReceiptsList))
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReleaseOrderBeCreated</Name>
				<Source><![CDATA[
    boolean  canReleaseOrderBeCreated()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canTypeBeChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the order type can be changed.
    /// </summary>
    /// <returns>
    /// true when all lines in the order correspond to order type change conditions; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The order type cannot be changed if any of the lines are not in the status open order.The order
    /// type cannot be changed for intercompany orders.The order type cannot be changed to order types
    /// apart from the <c>Journal</c> and <c>Purch</c>, where delivery lines are part of the order.The
    /// order type cannot be changed to Journal if any of the lines do not satisfy the conditions for
    /// changing the <c>StockedProduct</c>.The order type cannot be changed if any related Bank document
    /// has been created.
    /// </remarks>
    public boolean canTypeBeChanged()
    {
        boolean                 ok = true;
        PurchStatus             highestLineStatus;
        PurchLine               purchLine;
        PurchDeliverySchedule   purchDeliverySchedule;

        // <GIN>
        if (TaxParameters::isCustomsEnable_IN() &&
            purchTable.purchTable_W().CustomsImportOrder_IN == NoYes::Yes &&
            purchTable.PurchaseType          != PurchaseType::Purch)
        {
            ok = checkFailed("@GLS5766");
        }
        // </GIN>

        if (purchTable.PurchaseType != purchTable.orig().PurchaseType)
        {
            highestLineStatus = PurchLine::highestPurchStatus(purchTable.PurchId);

            if (highestLineStatus != PurchStatus::None && highestLineStatus != PurchStatus::Backorder)
            {
                ok = checkFailed(strFmt("@SYS99056",purchTable.orig().PurchaseType,purchTable.PurchaseType));
            }

            if (PurchConfirmationRequestJour::exist(purchTable.PurchId, purchTable.DataAreaId) || VendPurchOrderJour::exist(purchTable.PurchId))
            {
                ok = checkFailed(strFmt("@SYS4004803", purchTable.orig().PurchaseType, purchTable.PurchaseType));
            }
        }

        if (purchTable.isInterCompanyOrder())
        {
            if (purchTable.InterCompanySalesId && !this.interCompanyCreateAllowed())
            {
                ok = checkFailed(strFmt("@SYS98521",purchTable.PurchaseType));
            }
        }

        if (ok
            && purchTable.PurchaseType != PurchaseType::Journal
            && purchTable.PurchaseType != PurchaseType::Purch
            && (   purchTable.orig().PurchaseType == PurchaseType::Journal
                || purchTable.orig().PurchaseType == PurchaseType::Purch))
        {
            select firstonly RecId from purchLine
                where purchLine.PurchId == purchTable.PurchId
                   && !purchLine.IsDeleted
                join RecId from purchDeliverySchedule
                    where purchDeliverySchedule.DeliveryLine == purchLine.InventTransId
                       && !purchDeliverySchedule.IsDeleted;
            if (purchLine.RecId)
            {
                // Orders with Delivery Schedules cannot be converted to type %1.
                ok = checkFailed(strFmt("@SYS131416",purchTable.PurchaseType));
            }
        }

        if (ok
            && purchTable.PurchaseType != purchTable.orig().PurchaseType
            && purchTable.PurchaseType == PurchaseType::Journal)
        {
            //Only lines which are not inventoried are checked here.
            //Inventoried lines are checked through the inventory module
            if (!this.canTypeBeChangedNonInventoried())
            {
                ok = checkFailed(strFmt("@SYS190600", purchTable.PurchaseType));
            }
        }

        if (ok)
        {
            if (BankLCImportFeatureChecker::checkBankLCImportEnabled())
            {
                if (purchTable.isBankLCCreated())
                {
                    // The Bank document has been created for this order. Order type could not be changed.
                    ok = checkFailed("@SYS316265");
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canTypeBeChangedNonInventoried</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the order type can be changed.
    /// </summary>
    /// <returns>
    /// true when all lines in the order correspond to a change in the <c>StockedProduct</c> value;
    /// otherwise, false.
    /// </returns>
    protected boolean canTypeBeChangedNonInventoried()
    {
        PurchLine purchLine;

        select firstonly RecId from purchLine
            where purchLine.PurchId       == purchTable.PurchId
            &&  purchLine.StockedProduct == NoYes::No
            && !purchLine.IsDeleted
            && (purchLine.InventRefTransId != '' || purchLine.InventRefId != '');

        return(purchLine.RecId == 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateRemainingQty</Name>
				<Source><![CDATA[
    boolean canUpdateRemainingQty()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDelete</Name>
				<Source><![CDATA[
    public boolean checkDelete()
    {
        return !purchTable.RecId ||
               (purchTable.DocumentState != VersioningDocumentState::InReview   &&
                purchTable.DocumentState != VersioningDocumentState::Rejected   &&
                !purchTable.isInvoiceMatched()                                  && 
                !VersioningPurchaseOrder::newPurchaseOrder(purchTable).doesHistoryExist());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the various posting updates are allowed for the order.
    /// </summary>
    /// <param name = "_packedCheckIfUpdateContract">
    ///     Specifies which of the posting update allowance values for the order to get.
    /// </param>
    /// <returns>
    ///    A packed <c>PurchTableCanBeUpdatedContract</c> class with the values of whether the order can do a posting of a given type.
    /// </returns>
    container checkIfUpdate(container _packedCheckIfUpdateContract)
    {
        PurchTableCheckIfUpdateContract checkIfUpdateContract;
        PurchTableCanBeUpdatedContract  canBeUpdatedContract = PurchTableCanBeUpdatedContract::construct();

        if (_packedCheckIfUpdateContract == conNull())
        {
            checkIfUpdateContract = PurchTableCheckIfUpdateContract::newCheckAll();
        }
        else
        {
            checkIfUpdateContract = PurchTableCheckIfUpdateContract::create(_packedCheckIfUpdateContract);
        }

        this.parmAllowPurchLineCaching(true);

        if (checkIfUpdateContract.parmCheckConfirmationRequest())
        {
            canBeUpdatedContract.parmCanConfirmationRequestBeUpdated(this.canConfirmationRequestBeUpdated());
        }

        if (checkIfUpdateContract.parmCheckBindingConfirmationRequest())
        {
            canBeUpdatedContract.parmCanBindingConfirmationRequestBeUpdated(this.canBindingConfirmationRequestBeUpdated());
        }

        if (checkIfUpdateContract.parmCheckPurchaseOrder())
        {
            canBeUpdatedContract.parmCanPurchaseOrderBeUpdated(this.canPurchaseOrderBeUpdated());
        }

        if (checkIfUpdateContract.parmCheckReceiptsList())
        {
            canBeUpdatedContract.parmCanReceiptsListBeUpdated(this.canReceiptsListBeUpdated());
        }

        if (checkIfUpdateContract.parmCheckPackingSlip())
        {
            canBeUpdatedContract.parmCanPackingSlipBeUpdated(this.canPackingslipBeUpdated());
        }

        if (checkIfUpdateContract.parmCheckInvoice())
        {
            canBeUpdatedContract.parmInvoiceUpdateAvailability(this.getInvoiceUpdateAvailability(checkIfUpdateContract.parmExcludePendingInvoice()));
        }
        this.parmAllowPurchLineCaching(false);

        // <GEERU>
        if (checkIfUpdateContract.parmCheckInvoice4Paym_RU())
        {
            canBeUpdatedContract.parmCanInvoice4PaymBeUpdated_RU(this.canInvoice4PaymBeUpdated_RU());
        }
        if (checkIfUpdateContract.parmCheckFacture_RU())
        {
            canBeUpdatedContract.parmCanFactureBeUpdated_RU(this.canFactureBeUpdated_RU());
        }
        if (checkIfUpdateContract.parmCheckCommFacture_RU())
        {
            canBeUpdatedContract.parmCanCommFactureBeUpdated_RU(this.canCommFactureBeUpdated_RU());
        }
        // </GEERU>

        canBeUpdatedContract.parmMCRCanDropShipBeReleased(this.canPurchaseOrderBeUpdated());
        canBeUpdatedContract.parmMCRCanDropShipBeDelivered(this.canPackingslipBeUpdated());

        return canBeUpdatedContract.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfUpdate_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the instance should be updated.
    /// </summary>
    /// <returns>
    /// The result of the check.
    /// </returns>
    public container checkIfUpdate_IN()
    {
        container c;

        c = conIns(c, PurchTableType::posPurchaseOrder_IN()         , this.canPurchaseOrderBeUpdated());
        c = conIns(c, PurchTableType::posInvoiceRegistration_IN()   , this.canInvoiceRegistrationBeUpdated_IN());
        c = conIns(c, PurchTableType::posBillOfEntry_IN()           , this.canBillOfEntryBeUpdated_IN());
        c = conIns(c, PurchTableType::posReceiptsList_IN()          , this.canReceiptsListBeUpdated_IN());
        c = conIns(c, PurchTableType::posPackingSlip_IN()           , this.canPackingslipBeUpdated_IN());
        c = conIns(c, PurchTableType::posInvoice_IN()               , this.canInvoiceBeUpdated_IN());

        return c;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPurchQty</Name>
				<Source><![CDATA[
    private boolean checkPurchQty(DocumentStatus  documentStatus, boolean _excludePending = false)
    {
        return this.parmPurchTableCheckQuantity().checkQuantity(documentStatus, _excludePending);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPurchQty_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks purch quantity information.
    /// </summary>
    /// <param name="documentStatus">
    /// The document status.
    /// </param>
    /// <returns>
    /// Returns true if the purch quantity check succeed.
    /// </returns>
    //This method will be used to disable the Invoice regn and Bill of entry buttons if the entire ordered qty is exhausted
    public  boolean checkPurchQty_IN(DocumentStatus  documentStatus)
    {
        boolean         ok = false;
        PurchQuantity   purchQuantity;
        PurchLine       purchLine;
        PurchQty        purchQty;

        purchQuantity = PurchQuantity::construct(documentStatus);

        while select purchLine
            index hint PurchLineIdx
            where purchLine.PurchId     == purchTable.PurchId
                && (purchLine.PurchStatus == PurchStatus::Backorder 
                    || purchLine.PurchStatus == PurchStatus::None
                    || purchLine.PurchStatus == PurchStatus::Received
                    || purchLine.PurchReceivedNow != 0)
        {
            [purchQty] = purchQuantity.qtyPurch(purchLine, PurchUpdate::All);

            if (purchQty)
            {
                ok = true;
                break;
            }
            [purchQty] = purchQuantity.qtyPurch(purchLine, PurchUpdate::ReceiveNow);

            if (purchQty)
            {
                ok = true;
                break;
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a purchase order record is deleted.
    /// </summary>
    public void deleting()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a purchase order record has been deleted.
    /// </summary>
    public void deleted()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSalesTable</Name>
				<Source><![CDATA[
    void deleteSalesTable()
    {
        SalesTable      salesTable;
        if (purchTable.SkipUpdate == InterCompanySkipUpdate::Internal
        ||  purchTable.SkipUpdate == InterCompanySkipUpdate::Both
        || !purchTable.isInterCompanyOrder())
            return;

        salesTable = SalesTable::find(purchTable.InterCompanyOriginalSalesId,true);

        if (salesTable
        && !salesTable.existSalesLine())
        {
            salesTable.SkipUpdate = InterCompanySkipUpdate::Internal;
            salesTable.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>TaxUncommitted</c> records for the entire document if it has not yet been confirmed.
    /// </summary>
    public void deleteTaxUncommitted()
    {
        if (!purchTable.maintainTaxUncommitted())
        {
            TaxUncommitted::deleteForDocumentHeader(purchTable.TableId,purchTable.RecId, true, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxWithholdUncommitted_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>TaxWithholdUncommitted_IN</c> records for the entire document if it has not yet been confirmed.
    /// </summary>
    public void deleteTaxWithholdUncommitted_IN()
    {
        if (!purchTable.maintainTaxUncommitted())
        {
            TaxWithholdUncommitted_IN::deleteForDocumentHeader(purchTable.TableId,purchTable.RecId, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxWithholdUncommitted</Name>
				<Source><![CDATA[
    public void deleteTaxWithholdUncommitted()
    {
        TaxWithholdUncommitted::deleteForDocumentHeader(purchTable.TableId, purchTable.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deletePurchLinkFromProdBom</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes <c>ProdBom</c> references when <c>PurchTable</c> is deleted.
    /// </summary>
    internal void deletePurchLinkFromProdBom()
    {
        ProdBOM prodBOM;

        select firstonly InventRefId from prodBOM
              where prodBOM.InventRefId == purchTable.PurchId
                 && prodBOM.InventRefType == InventRefType::Purch;

        if(prodBOM.InventRefId)
        {
            ttsbegin;
            update_recordset prodBOM
                    setting InventRefId = '',
                            InventRefType = InventRefType::None
                where prodBOM.InventRefId == purchTable.PurchId
                    && prodBOM.InventRefType == InventRefType::Purch;
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentStatusOrder_RU</Name>
				<Source><![CDATA[
    // this method assumes order to document statuses,
    // because enum values are not in right order
    #define.None           (0)
    #define.ConfirmationRequest  (1)
    #define.PurchaseOrder  (2)
    #define.Invoice4Paym_RU(3)
    #define.ReceiptsList   (4)
    #define.PackingSlip    (5)
    #define.Invoice        (6)
    #define.ApproveJournal (7)
    #define.Facture_RU     (8)
    private int documentStatusOrder_RU(DocumentStatus _documentStatus)
    {
        int ret;

        switch (_documentStatus)
        {
            case DocumentStatus::None            :
                ret = #None;
                break;
            case DocumentStatus::ConfirmationRequest    :
                ret = #ConfirmationRequest;
                break;
            case DocumentStatus::PurchaseOrder   :
                ret = #PurchaseOrder;
                break;
            case DocumentStatus::Invoice4Paym_RU :
                ret = #Invoice4Paym_RU;
                break;
            case DocumentStatus::ReceiptsList    :
                ret = #ReceiptsList;
                break;
            case DocumentStatus::PackingSlip     :
                ret = #PackingSlip;
                break;
            case DocumentStatus::Invoice         :
                ret = #Invoice;
                break;
            case DocumentStatus::ApproveJournal  :
                ret = #ApproveJournal;
                break;
            case DocumentStatus::Facture_RU      :
                ret = #Facture_RU;
                break;
            default                  :
                ret = enum2int(_documentStatus);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editInvoiceAccount</Name>
				<Source><![CDATA[
    boolean  editInvoiceAccount()
    {
        return ! purchTable.isInterCompanyOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>editOrderAccount</Name>
				<Source><![CDATA[
    boolean  editOrderAccount()
    {
        return ! purchTable.isInterCompanyOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>editPurchType</Name>
				<Source><![CDATA[
    boolean editPurchType()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodClose</Name>
				<Source><![CDATA[
    public void formMethodClose()
    {
        if (numberSeqFormHandlerPurchId)
        {
            numberSeqFormHandlerPurchId.formMethodClose();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceCreate</Name>
				<Source><![CDATA[
    public void formMethodDataSourceCreate(FormRun _element, FormDataSource _purchtable_ds)
    {
        this.numberSeqFormHandlerPurchId(_element, _purchtable_ds).formMethodDataSourceCreate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceDelete</Name>
				<Source><![CDATA[
    public void formMethodDataSourceDelete(FormRun _element, FormDataSource _purchtable_ds)
    {
        this.numberSeqFormHandlerPurchId(_element, _purchtable_ds).formMethodDataSourceDelete();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceLinkActive</Name>
				<Source><![CDATA[
    public void formMethodDataSourceLinkActive(FormRun _element, FormDataSource _purchTable_ds)
    {
        this.numberSeqFormHandlerPurchId(_element, _purchTable_ds).formMethodDataSourceLinkActive();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceValidateWrite</Name>
				<Source><![CDATA[
    public boolean formMethodDataSourceValidateWrite(FormRun _element, FormDataSource _purchTable_ds)
    {
        boolean ret = true;

        if (!this.numberSeqFormHandlerPurchId(_element, _purchTable_ds).formMethodDataSourceValidateWrite())
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceWrite</Name>
				<Source><![CDATA[
    public void formMethodDataSourceWrite(FormRun _element, FormDataSource _purchTable_ds)
    {
        this.numberSeqFormHandlerPurchId(_element, _purchTable_ds).formMethodDataSourceWrite();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    void  initValue()
    {
        // <GEERU>
        PurchTable_RU       purchTable_RU;
        // </GEERU>

        date currentDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        purchTable.DeliveryDate     = currentDate;
        if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
        {
            purchTable.RequestedShipDate = currentDate;
        }
        purchTable.PurchStatus      = PurchStatus::Backorder;
        purchTable.TransactionCode  = IntrastatParameters::find().DefaultSalePurchase;
        purchTable.Transport        = IntrastatParameters::find().TransportModeParm;
        purchTable.Port             = IntrastatParameters::find().PortParm;
        purchTable.StatProcId       = IntrastatParameters::find().StatProcIdParm;
        purchTable.CountyOrigDest   = IntrastatParameters::find().CountyOrigDest;
        purchTable.PurchPoolId      = PurchParameters::find().PurchPoolId;
        purchTable.AccountingDate   = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::getSystemDateTime(), DateTimeUtil::getUserPreferredTimeZone()));

        if (VendParameters::find().AutoSettle == NoYes::Yes)
            purchTable.SettleVoucher = SettlementType::OpenTransact;

        purchTable.PostingProfile   = VendParameters::find().PostingProfile;
        purchTable.WorkerPurchPlacer = DirPersonUserEx::findUserWorkerReference();
        purchTable.PurchaseOrderHeaderCreationMethod = PurchPurchaseOrderCreationMethod::Purchase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inserting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a purchase order record is inserted.
    /// </summary>
    public void inserting()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>inserted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a purchase order record has been inserted.
    /// </summary>
    public void inserted()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyCalcDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates discount of sales table from inter-company purchase table.
    /// </summary>
    public void interCompanyCalcDisc()
    {
        if (purchTable.InterCompanyCompanyId
        &&  purchTable.InterCompanySalesId
        && !purchTable.isInvoiceMatched())
        {
            changecompany(purchTable.InterCompanyCompanyId)
            {
                ttsbegin;
                SalesTable salesTable = SalesTable::find(purchTable.InterCompanySalesId,true);
                InterCompanyEndpointActionPolicy salesEndpointActionPolicy = salesTable.interCompanyEndpointActionPolicy();
                if (salesEndpointActionPolicy.PriceDiscountSearch)
                {
                    SalesLine salesLine;
                    salesTable.PriceDiscHeading::updateMultiLineDiscount(salesLine);
                    salesTable.PriceDiscHeading::updateFinalDiscount(salesLine);
                }
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyCanBeUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an intercompany order can be updated.
    /// </summary>
    /// <returns>
    /// true if the intercompany order can be updated; otherwise, false.
    /// </returns>
    public boolean interCompanyCanBeUpdated()
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().purchaseTableTypeActivities().interCompanyCanBeUpdated(purchTable))
        {
            if (purchTable.InterCompanyOrder
                &&  purchTable.InterCompanyOriginalSalesId
                &&  purchTable.InterCompanyDirectDelivery)
            {
                return false;
            }
            else
            {
                return true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyCreateAllowed</Name>
				<Source><![CDATA[
    boolean interCompanyCreateAllowed()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyDelete</Name>
				<Source><![CDATA[
    void  interCompanyDelete()
    {
        SalesTable  salesTable;

        if (purchTable.SkipUpdate == InterCompanySkipUpdate::InterCompany
        ||  purchTable.SkipUpdate == InterCompanySkipUpdate::Both
        || !purchTable.isInterCompanyOrder()
        || !this.interCompanyCreateAllowed())
            return;

        if (! TradeInterCompany::checkDataAreaAccess(purchTable.InterCompanyCompanyId))
            return;

        changecompany(purchTable.InterCompanyCompanyId)
        {
            setPrefix(strFmt("@SYS93821",TradeInterCompany::curCompanyName()));

            salesTable = SalesTable::find(purchTable.InterCompanySalesId, true);

            if (salesTable)
            {
                salesTable.SkipUpdate = InterCompanySkipUpdate::InterCompany;

                if (!salesTable.validateDelete())
                {
                    throw error(strFmt("@WAX:IntercompanySalesOrderDeleteError", salesTable.SalesId));
                }

                salesTable.delete();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyIsDerivedOrder</Name>
				<Source><![CDATA[
    public boolean interCompanyIsDerivedOrder()
    {
        return (purchTable.isInterCompanyOrder() &&
                purchTable.InterCompanyOrigin == InterCompanyOrigin::Derived);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyMarkupMirror</Name>
				<Source><![CDATA[
    void  interCompanyMarkupMirror()
    {
        SalesTable  salesTable;
        MarkupTrans markupTrans;

        if (!purchTable.isInterCompanyOrder())
            return;

        changecompany(purchTable.InterCompanyCompanyId)
        {
            setPrefix(strFmt("@SYS93821",TradeInterCompany::curCompanyName()));

            salesTable = SalesTable::find(purchTable.InterCompanySalesId);
            if (salesTable)
            {
                while select forupdate markupTrans
                      index hint TableRecIdIdx
                      where markupTrans.TransTableId == salesTable.TableId
                      &&    markupTrans.TransRecId   == salesTable.RecId
                      &&   !markupTrans.IsDeleted
                {
                    markupTrans.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the corresponding <c>SalesType</c> value.
    /// </summary>
    /// <returns>Sales order type value 'Journal'.</returns>
    public SalesType salesType()
    {
        return SalesType::Journal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanySyncEngine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the intercompany header-level syncronization engine.
    /// </summary>
    /// <returns>An instance of <c>InterCompanySyncPurchTableType</c> class.</returns>
    public InterCompanySyncPurchTableType interCompanySyncEngine()
    {
        return InterCompanySyncPurchTableType::newFromPurchTableType(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>forceIntercompanyLineSynchronization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Force intercompany synchronization of all purchase order lines.
    /// </summary>
    public void forceIntercompanyLineSynchronization()
    {
        PurchLine purchLine;

        while select forupdate purchLine
            index hint PurchLineIdx
            where purchLine.PurchId == purchTable.PurchId
               && !purchLine.IsDeleted
        {
            purchLine.forceIntercompanySynchronization();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventLotInvoke</Name>
				<Source><![CDATA[
    boolean  inventLotInvoke()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventOnhandInvoke</Name>
				<Source><![CDATA[
    boolean  inventOnhandInvoke()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransactInvoke</Name>
				<Source><![CDATA[
    boolean  inventTransactInvoke()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDocumentStatusTransitionPossible</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether it is possible to update the <c>DocumentStatus</c> field of the PurchTable.
    /// </summary>
    /// <param name="finalDocumentStatus">
    ///     the final Document Status
    /// </param>
    /// <returns>
    ///     true if it is possible to change the Document Status; otherwise, false.
    /// </returns>
    private boolean isDocumentStatusTransitionPossible(DocumentStatus finalDocumentStatus)
    {
        //This is the sequence documents should transition through.
        Map map = new Map(Types::Enum, Types::Integer);
        map.insert(DocumentStatus::None, 0);
        map.insert(DocumentStatus::Quotation, 1);
        map.insert(DocumentStatus::ConfirmationRequest, 2);
        map.insert(DocumentStatus::PurchaseOrder, 3);
        map.insert(DocumentStatus::Confirmation, 4);
        map.insert(DocumentStatus::PickingList, 5);
        map.insert(DocumentStatus::PackingSlip, 6);
        map.insert(DocumentStatus::ReceiptsList, 7);
        map.insert(DocumentStatus::Invoice, 8);

        if (map.exists(finalDocumentStatus))
        {
            if (map.exists(purchTable.DocumentStatus))
            {
                //Prevent transitions backwards in the sequence
                return (map.lookup(purchTable.DocumentStatus) < map.lookup(finalDocumentStatus));
            }

            //Prevent transitions from a status without restrictions back into the sequence
            return false;
        }

        //It is a transition to a status without restrictions.
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns if Markup is allowed on the PurchTable
    /// </summary>
    /// <returns>
    /// An object of type <c>boolean</c>
    /// </returns>
    public boolean markupAllowed()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayBankDocumentTypeBeModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the <c>BankDocumentType</c> field can be modified.
    /// </summary>
    /// <returns>
    /// true if the field could be modified; otherwise, false.
    /// </returns>
    public boolean mayBankDocumentTypeBeModified()
    {
        boolean ok              = false;
        boolean enableLCFeature = BankLCImportFeatureChecker::checkBankLCImportEnabled();
        boolean enableLGFeature = BankLGFeatureChecker::checkBankLGEnabled();

        if (enableLCFeature || enableLGFeature)
        {
            if (!purchTable.isBankDocumentCreated())
            {
                if (enableLCFeature)
                {
                    if (purchTable.mayBankDocumentTypeBeBankLCImport())
                    {
                        ok = true;
                    }
                }

                if (!ok && enableLGFeature)
                {
                    if (purchTable.mayBankDocumentTypeBeBankLG())
                    {
                        ok = true;
                    }
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayBillOfEntryBeUpdated_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the bill of entry can be updated.
    /// </summary>
    /// <returns>
    /// Returns true if the bill of entry can be updated.
    /// </returns>
    public boolean  mayBillOfEntryBeUpdated_IN()
    {
        boolean ok = true;
        CustomsInvoiceRegnJournalLine_IN customsInvoiceRegnJournalLine;
        CustomsInvoiceRegnJournalTable_IN customsInvoiceRegnJournalTable;

        // If Invoice regn is done for that particular PO then return true
        if (ok)
        {
            while select Updated from customsInvoiceRegnJournalLine
                join RecId from customsInvoiceRegnJournalTable
                where customsInvoiceRegnJournalLine.CustomsInvoiceRegnJournalTableRecId == customsInvoiceRegnJournalTable.RecId
                    && customsInvoiceRegnJournalTable.OrderId == purchTable.PurchId
            {
                ok = (customsInvoiceRegnJournalLine.Updated == NoYes::Yes);
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayFactureBeUpdated_RU</Name>
				<Source><![CDATA[
    final public boolean mayFactureBeUpdated_RU()
    {
        return this.mayInvoiceBeUpdated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayInvoice4PaymBeUpdated_RU</Name>
				<Source><![CDATA[
    final public boolean mayInvoice4PaymBeUpdated_RU()
    {
        return this.mayPackingSlipBeUpdated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayInvoiceBeUpdated</Name>
				<Source><![CDATA[
    boolean  mayInvoiceBeUpdated()
    {
        boolean ok = true;

        if (ok && purchCycle)
        {
            salesPurchCycle = SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::Invoice,
                SalesPurchCycleModuleParameter::Vend, purchTable.OrderAccount);

            if (salesPurchCycle)
            {
                if (!salesPurchCycle.Active)
                {
                    ok = false;
                }
            }
            else
            {
                if (!SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::Invoice,
                    SalesPurchCycleModuleParameter::VendParameter, '').Active)
                {
                    ok = false;
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayInvoiceRegistrationBeUpdated_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the invoice registration can be updated.
    /// </summary>
    /// <returns>
    /// Returns true if the invoice registration can be updated.
    /// </returns>
    public boolean  mayInvoiceRegistrationBeUpdated_IN()
    {
        return (!purchTable.isInvoiced() && !purchTable.isCanceled());
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayPackingSlipBeUpdated</Name>
				<Source><![CDATA[
    boolean mayPackingSlipBeUpdated(VersioningUpdateType _updateType = VersioningUpdateType::Initial)
    {
        boolean ok = true;

        ok = (purchTable.DocumentState == VersioningDocumentState::Confirmed
            || (purchTable.ChangeRequestRequired == NoYes::No
                && (   _updateType == VersioningUpdateType::Correction
                    || _updateType == VersioningUpdateType::Cancel)));

        if (ok && purchCycle)
        {
            salesPurchCycle = SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::PackingSlip,
                SalesPurchCycleModuleParameter::Vend, purchTable.OrderAccount);

            if (salesPurchCycle)
            {
                if (!salesPurchCycle.Active)
                {
                    ok = false;
                }
            }
            else
            {
                if (!SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::PackingSlip,
                    SalesPurchCycleModuleParameter::VendParameter, '').Active)
                {
                    ok = false;
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayPurchaseOrderBeUpdated</Name>
				<Source><![CDATA[
    boolean  mayPurchaseOrderBeUpdated()
    {
        boolean     ok = true;
        PurchLine   purchLine;

        ok = this.doesDocumentStateAllowUpdate();

        if (ok)
        {
            ok = this.checkNoBlockedBackOrderLine();
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayReceiptsListBeUpdated</Name>
				<Source><![CDATA[
    boolean  mayReceiptsListBeUpdated()
    {
        boolean ok = true;

        ok = (purchTable.DocumentState == VersioningDocumentState::Confirmed);

        if (ok && purchCycle)
        {
            salesPurchCycle = SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::ReceiptsList,
                SalesPurchCycleModuleParameter::Vend, purchTable.OrderAccount);

            if (salesPurchCycle)
            {
                if (!salesPurchCycle.Active)
                {
                    ok = false;
                }
            }
            else
            {
                if (!SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::ReceiptsList,
                    SalesPurchCycleModuleParameter::VendParameter, '').Active)
                {
                    ok = false;
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrRetrieveMinDropShipStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the lowest drop shipment status for a purchase order.
    /// </summary>
    /// <returns>
    ///     The lowest <c>MCRDropShipStatus</c> for a purchase order.
    /// </returns>
    MCRDropShipStatus mcrRetrieveMinDropShipStatus()
    {
        PurchLine           purchLine;
        MCRDropShipStatus   mcrDropShipStatus;

        //Don't look at canceled items because they prevent actions on the remaining items in the order
        select minof(mcrDropShipStatus) from purchLine
            where purchLine.PurchId == purchTable.PurchId
            && purchLine.PurchStatus != PurchStatus::Canceled;

        mcrDropShipStatus = purchLine.mcrDropShipStatus;

        return mcrDropShipStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedBankDocumentType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the fields which are impacted by <c>BankDocumentType</c> field.
    /// The method should be called after <c>BankDocumentType</c> field has been modified.
    /// </summary>
    public void modifiedBankDocumentType()
    {
        if (purchTable.isMarkedForBankLC())
        {
            purchTable.Payment          = '';
            purchTable.FixedDueDate     = dateNull();
            purchTable.PaymMode         = '';
            purchTable.PaymSpec         = '';
            purchTable.PaymentSched     = '';
            purchTable.CashDisc         = '';
            purchTable.CashDiscPercent  = 0;
            purchTable.SettleVoucher    = SettlementType::None;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifyPurchaseType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the related field and table values when the <see cref="T:PurchaseType" /> field value of
    /// the <see cref="T:PurchTable" /> buffer is changed.
    /// </summary>
    /// <remarks>
    /// The fixed asset fields of all <see cref="T:PurchLine" /> detail records have to be cleared out if
    /// the purchase type does not support entering fixed assets.
    /// </remarks>
    public void modifyPurchaseType()
    {
        PurchLine               purchLine;
        boolean                 isPurchaseTypeChangedToJournalType;
        SourceDocumentLine      sourceDocumentLine;

        if ((purchTable) && (purchTable.PurchaseType != PurchaseType::Purch))
        {
            ttsbegin;

            if (purchTable.orig().PurchaseType != purchTable.PurchaseType
                && purchTable.PurchaseType == PurchaseType::Journal)
            {
                isPurchaseTypeChangedToJournalType = true;
            }

            while select forupdate purchLine
                where purchLine.PurchId == purchTable.PurchId
                   && !purchLine.IsDeleted
            {
                if ((purchLine.CreateFixedAsset == NoYes::Yes) || (purchLine.AssetId))
                {
                    purchLine.CreateFixedAsset = NoYes::No;
                    purchLine.AssetGroup = '';
                    purchLine.AssetId = '';
                    purchLine.AssetGroup = '';
                    purchLine.AssetBookId = '';
                    purchLine.update();
                }

                if (isPurchaseTypeChangedToJournalType && purchLine.SourceDocumentLine)
                {
                    ProjectCommitmentFacade::deleteProjectCommitments(purchLine.SourceDocumentLine);

                    // Remove budget reservation for the line amounts because journal type purchase order should not have budget reservation.
                    BudgetControlSourceDocumentProcessor::submitSourceDocumentLineToRemoveBudget(
                        SourceDocumentLine::find(purchLine.SourceDocumentLine));
                }
            } // while

            if (isPurchaseTypeChangedToJournalType)
            {
                while select sourceDocumentLine
                    where sourceDocumentLine.SourceDocumentHeader == purchTable.SourceDocumentHeader
                        && sourceDocumentLine.ParentSourceDocumentLine == 0
                        && sourceDocumentLine.SourceRelationType != tableNum(PurchLine)
                {
                    ProjectCommitmentFacade::deleteProjectCommitments(sourceDocumentLine.RecId);

                    // Remove budget reservation for the header amounts because journal type purchase order should not have budget reservation.
                    BudgetControlSourceDocumentProcessor::submitSourceDocumentLineToRemoveBudget(
                        sourceDocumentLine);
                }
            }

            ttscommit;
        } // if
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeCovPlanned</Name>
				<Source><![CDATA[
    boolean  mustBeCovPlanned()
    {
        PurchLine  purchLine;

        if (!purchTable.isInvoiced())
        {
            while select purchLine
                index hint PurchLineIdx
                where purchLine.PurchId == purchTable.PurchId
                   && !purchLine.IsDeleted
            {
                if (purchLine.mustBeCovPlanned())
                {
                    return true;
                }
            }
        }
        else
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void  new(PurchTable _purchTable)
    {
        PurchParameters purchParameters = PurchParameters::find();

        purchTable      = _purchTable;
        purchType       = purchParameters.PurchaseType;
        purchCycle      = purchParameters.PurchaseCycle;
        super(_purchTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSeqFormHandlerPurchId</Name>
				<Source><![CDATA[
    protected NumberSeqFormHandler numberSeqFormHandlerPurchId(FormRun _element, FormDataSource _purchTable_ds)
    {
        if (!numberSeqFormHandlerPurchId)
        {
            numberSeqFormHandlerPurchId = NumberSeqFormHandler::newForm(PurchParameters::numRefPurchId().NumberSequenceId,
                                                                 _element,
                                                                 _purchTable_ds,
                                                                 fieldNum(PurchTable, PurchId)
                                                                );
        }
        return numberSeqFormHandlerPurchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowPurchLineCaching</Name>
				<Source><![CDATA[
    private boolean parmAllowPurchLineCaching(boolean _allowPurchLineCaching = allowPurchLineCaching)
    {
        allowPurchLineCaching = _allowPurchLineCaching;

        return allowPurchLineCaching;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumberSeqFormHandlerPurchId</Name>
				<Source><![CDATA[
    public NumberSeqFormHandler parmNumberSeqFormHandlerPurchId(NumberSeqFormHandler _numberSeqFormHandlerPurchId = numberSeqFormHandlerPurchId)
    {
        numberSeqFormHandlerPurchId = _numberSeqFormHandlerPurchId;
        return numberSeqFormHandlerPurchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchTable</Name>
				<Source><![CDATA[
    public PurchTable parmPurchTable()
    {
        return purchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchTableCheckQuantity</Name>
				<Source><![CDATA[
    private PurchTableCheckQuantity parmPurchTableCheckQuantity()
    {
        if (!purchTableCheckQuantity)
        {
            purchTableCheckQuantity = PurchTableCheckQuantity::newFromPurchTable(purchTable);
        }
        purchTableCheckQuantity.parmAllowCaching(this.parmAllowPurchLineCaching());
        return purchTableCheckQuantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsApprovedVendorListCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get an instance of PdsApprovedVendorListCheck appropriate for this order type.
    /// </summary>
    /// <returns>Instance of PdsApprovedVendorListCheck appropriate for this order type.</returns>
    /// <remarks>
    /// The base implementation in PurchTableType always returns an instance of
    /// PdsApprovedVendorListCheck_AllValid.
    /// <syntax>
    /// public PdsApprovedVendorListCheck pdsApprovedVendorListCheck()
    /// </syntax>
    /// </remarks>
    public PdsApprovedVendorListCheck pdsApprovedVendorListCheck()
    {
        return PdsApprovedVendorListCheck_AllValid::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDefaultDeliveryAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default delivery address for the <c>purchTable</c> record.
    /// </summary>
    /// <remarks>
    /// The primary postal address is set as the default delivery address if a delivery address is not
    /// found.
    /// </remarks>
    public void setDefaultDeliveryAddress()
    {
        LogisticsLocationRecId  locationRecId;
        boolean                 isCompanyLocation;
        LogisticsLocationRole   roleDelivery = LogisticsLocationRole::findBytype(LogisticsLocationRoleType::Delivery);

        [locationRecId, isCompanyLocation] = PurchTableType::getDefaultDeliveryLocation(purchTable.InventSiteId, purchTable.InventLocationId);

        if (!isCompanyLocation)
        {
            purchTable.setLocation(locationRecId);
        }
        else
        {
            // Warehouse and site didn't have location, use company location
            var companyInfo = CompanyInfo::find();

            purchTable.DeliveryName           = companyInfo.name();
            purchTable.DeliveryPostalAddress  = LogisticsPostalAddress::addressRecIdFromLocationRecId(locationRecId);
            purchTable.AddressRefRecId        = companyInfo.RecId;
            purchTable.AddressRefTableId      = companyInfo.TableId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultDeliveryLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets default delivery location for purchase table, based on the given site and warehouse.
    /// </summary>
    /// <param name = "_inventSiteId">The site ID.</param>
    /// <param name = "_inventLocationId">The warehouse ID.</param>
    /// <returns>A container with delivery location and boolean indicating whether returned location is a location of company.</returns>
    public static container getDefaultDeliveryLocation(InventSiteId _inventSiteId, InventLocationId _inventLocationId)
    {
        LogisticsLocationRecId  locationRecId;
        boolean                 isCompanyLocation;

        locationRecId = LogisticsLocationDefaultAppUtil::warehouseSiteDefaultLocation(LogisticsLocationRoleType::Delivery,
            _inventLocationId, _inventSiteId);

        if (!locationRecId)
        {
            // Warehouse and site didn't have location, use company location
            var companyInfo = CompanyInfo::find();
            locationRecId = LogisticsLocationDefault::findSimpleDefault(companyInfo,
                LogisticsLocationRole::findBytype(LogisticsLocationRoleType::Delivery)).RecId;

            isCompanyLocation = true;
        }

        return [locationRecId, isCompanyLocation];
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxGroup</Name>
				<Source><![CDATA[
    void setTaxGroup(TaxGroup _taxGroup)
    {
        purchTable.TaxGroup = _taxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncSalesTable</Name>
				<Source><![CDATA[
    AxSalesTable syncSalesTable(PurchTable _purchTable, SalesTable _salesTable = null, boolean _forceAddressSync = false)
    {
        SalesTable                                  salesTableLocal;
        ReqPlanSched                                reqPlanSched;
        LeadTime                                    leadTimeInternal;
        boolean                                     create;
        SalesParameters                              salesParameters;
        InterCompanyEndpointActionPolicyTransfer    transferInternal = purchTable.interCompanyEndpointActionPolicy().getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::Internal);
        SalesCalcAvailableDlvDates                  salesCalcAvailableDlvDates;

        AxSalesTable axSalesTable = this.constructAxSalesTable(_salesTable);

        if (!_salesTable)
            create = true;

        if (SalesPurchSyncDeliveryInfoFeature::instance().isEnabled())
        {
            this.setSalesTableDeliveryInformation(axSalesTable, _purchTable, _salesTable, create);
        }
        else
        {
            if (create || _purchTable.fieldChanged(fieldNum(PurchTable, DlvTerm)))
                axSalesTable.parmDlvTerm(_purchTable.DlvTerm);
            if (create || _purchTable.fieldChanged(fieldNum(PurchTable, DlvMode)))
                axSalesTable.parmDlvMode(_purchTable.DlvMode);
        }

        if (_purchTable.interCompanyEndpointActionPolicy().getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::Internal).CustomerInfo)
        {
            if (create || _purchTable.fieldChanged(fieldNum(PurchTable, InterCompanyCustPurchOrderFormNum)))
                axSalesTable.parmPurchOrderFormNum(_purchTable.InterCompanyCustPurchOrderFormNum);
            if (create || _purchTable.fieldChanged(fieldNum(PurchTable, VendorRef)))
                axSalesTable.parmCustomerRef(_purchTable.VendorRef);
        }

        if (_purchTable.interCompanyEndpointActionPolicy().getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::Internal).ReturnItemNum)
        {
            if (create || _purchTable.fieldChanged(fieldNum(PurchTable, ReturnItemNum)))
                axSalesTable.parmReturnItemNum(_purchTable.ReturnItemNum);
        }

        if (purchTable.InterCompanyDirectDelivery)
        {
            PurchTableType::syncDeliveryAddress(_purchTable, axSalesTable, _forceAddressSync);
        }

        if (_purchTable.InterCompanyDirectDelivery
            && !SalesPurchSyncDeliveryInfoFeature::instance().isEnabled())
        {
            if (create || _purchTable.fieldChanged(fieldNum(PurchTable, DlvTerm)))
                axSalesTable.parmDlvTerm(_purchTable.DlvTerm);
            if (create || _purchTable.fieldChanged(fieldNum(PurchTable, DlvMode)))
                axSalesTable.parmDlvMode(_purchTable.DlvMode);
        }

        if (create || purchTable.fieldChanged(fieldNum(PurchTable, ReturnReasonCodeId)))
            axSalesTable.parmReturnReasonCodeId(purchTable.ReturnReasonCodeId);

        if (create || purchTable.fieldChanged(fieldNum(PurchTable, ReturnReplacementCreated)))
            axSalesTable.parmReturnReplacementCreated(purchTable.ReturnReplacementCreated);

        if (transferInternal.PriceDiscount
        && (create || _purchTable.fieldChanged(fieldNum(PurchTable, DiscPercent))))
            axSalesTable.parmDiscPercent(_purchTable.DiscPercent);

        if (_purchTable.InterCompanyDirectDelivery)
        {
            if (new DictConfigurationKey(configurationKeyNum(SalesDeliveryDateControl)).enabled())
            {
                axSalesTable.parmReceiptDateRequested (_purchTable.DeliveryDate);

                // In case the confirmed receipt date is empty, it should also be synchronized.
                axSalesTable.parmReceiptDateConfirmed (_purchTable.ReceiptDateConfirmed);

                axSalesTable.setShippingDateRequestedFromPurchTable(_purchTable);

                // In case the confirmed shipping date is empty, it should also be synchronized.
                axSalesTable.parmShippingDateConfirmed(_purchTable.ShippingDateConfirmed);
            }
            else
            {
                axSalesTable.parmShippingDateRequested(_purchTable.DeliveryDate);
                axSalesTable.parmShippingDateConfirmed(_purchTable.ShippingDateConfirmed);
            }
        }
        else
        {
            if (create
            || _purchTable.fieldChanged(fieldNum(PurchTable, DeliveryDate)))
            {
                reqPlanSched     = ReqPlanSched::find(ReqParameters::find().CurrentReqPlanIdSchedStatic);
                leadTimeInternal = reqPlanSched.IssueMargin + reqPlanSched.ReceiptMargin;
                axSalesTable.parmShippingDateRequested(_purchTable.DeliveryDate + leadTimeInternal);
            }
            if (create
            &&  new DictConfigurationKey(configurationKeyNum(SalesDeliveryDateControl)).enabled())
            {
                buf2Buf(axSalesTable.salesTable(),salesTableLocal);
                salesParameters                          = SalesParameters::find();
                salesTableLocal.DeliveryDateControlType  = salesParameters.DeliveryDateControlType;
                salesCalcAvailableDlvDates = SalesCalcAvailableDlvDates::newCommonSalesDlvDateType(salesTableLocal);

                if (salesCalcAvailableDlvDates.validateWritePrompt(salesTableLocal,false,true))
                    axSalesTable.parmShippingDateConfirmed(salesTableLocal.ShippingDateConfirmed);
                else
                    axSalesTable.parmShippingDateConfirmed(_purchTable.DeliveryDate);
            }
        }

        return axSalesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSalesTableWithDeliveryInformation</Name>
				<Source><![CDATA[
    internal AxSalesTable createSalesTableWithDeliveryInformation(PurchTable _purchTable, SalesTable _salesTable = null, boolean _create = false)
    {
        AxSalesTable axSalesTable = this.constructAxSalesTable(_salesTable);
        this.setSalesTableDeliveryInformation(axSalesTable, _purchTable, _salesTable, _create);

        return axSalesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructAxSalesTable</Name>
				<Source><![CDATA[
    private AxSalesTable constructAxSalesTable(SalesTable _salesTable)
    {
        AxSalesTable axSalesTable;

        if (_salesTable)
        {
            axSalesTable = AxSalesTable::newSalesTable(SalesTable::find(_salesTable.SalesId, true));
        }
        else
        {
            axSalesTable = AxSalesTable::newSalesTable(_salesTable);
        }

        return axSalesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSalesTableDeliveryInformation</Name>
				<Source><![CDATA[
    private void setSalesTableDeliveryInformation(AxSalesTable _axSalesTable, PurchTable _purchTable, SalesTable _salesTable = null, boolean _create = false)
    {
        PurchParameters purchParameters = PurchParameters::find();
        boolean canDeliveryInfoSync = _purchTable.isAllLinesDeliveryTypeIdentical() && _salesTable.isAllLinesDeliveryTypeIdentical();

        if (_purchTable.InterCompanyDirectDelivery
            || (_purchTable.isDropShipment()
                && ((canDeliveryInfoSync
                        && purchParameters.DeliveryInfoSyncFromPurchaseOrderToSalesOrderDirectDelivery)
                    || _create)))
        {
            if (purchParameters.isDirectDeliveryInformationCreateOrUpdateAllowed(_purchTable, fieldNum(PurchTable, DlvTerm), _create))
            {
                _axSalesTable.parmDlvTerm(_purchTable.DlvTerm);
            }

            if (purchParameters.isDirectDeliveryInformationCreateOrUpdateAllowed(_purchTable, fieldNum(PurchTable, DlvMode), _create))
            {
                _axSalesTable.parmDlvMode(_purchTable.DlvMode);
            }
        }
        else if ((canDeliveryInfoSync 
                    && purchParameters.DeliveryInfoSyncFromPurchaseOrderToSalesOrderStock)
                || _purchTable.InterCompanyOrder
                || _create)
        {
            if (purchParameters.isStockDeliveryInformationCreateOrUpdateAllowed(_purchTable, fieldNum(PurchTable, DlvTerm), _create))
            {
                _axSalesTable.parmDlvTerm(_purchTable.DlvTerm);
            }

            if (purchParameters.isStockDeliveryInformationCreateOrUpdateAllowed(_purchTable, fieldNum(PurchTable, DlvMode), _create))
            {
                _axSalesTable.parmDlvMode(_purchTable.DlvMode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncSalesTableSave</Name>
				<Source><![CDATA[
    void syncSalesTableSave(PurchTable _purchTable)
    {
        SalesTable      salesTable;
        AxSalesTable    axSalesTable;
        if (!_purchTable
        ||  !_purchTable.InterCompanyOriginalSalesId)
            return;

        boolean isSalesPurchSyncDeliveryInfoFeatureEnabled = SalesPurchSyncDeliveryInfoFeature::instance().isEnabled();

        if (_purchTable.SkipUpdate        == InterCompanySkipUpdate::Internal
            ||  _purchTable.SkipUpdate        == InterCompanySkipUpdate::Both
            || (_purchTable.InterCompanyOrder == false
                && !isSalesPurchSyncDeliveryInfoFeatureEnabled))
        {
            return;
        }

        salesTable = SalesTable::find(_purchTable.InterCompanyOriginalSalesId);

        if (!salesTable)
            return;

        if (_purchTable.InterCompanyOrder 
            || !isSalesPurchSyncDeliveryInfoFeatureEnabled)
        {
            if (SalesTableType::construct(salesTable).canCreatePurchOrder())
            {
                axSalesTable = this.syncSalesTable(_purchTable, salesTable);
                axSalesTable.parmSkipUpdate(InterCompanySkipUpdate::Internal);
                axSalesTable.save();
            }
        }
        else
        {
            if (isSalesPurchSyncDeliveryInfoFeatureEnabled
                && this.isDeliveryInformationCreateAllowed())
            {
                if (SalesTableType::construct(salesTable).canCreatePurchOrder())
                {
                    axSalesTable = this.createSalesTableWithDeliveryInformation(_purchTable, salesTable);
                    axSalesTable.parmSkipUpdate(InterCompanySkipUpdate::Internal);
                    axSalesTable.save();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDeliveryInformationCreateAllowed</Name>
				<Source><![CDATA[
    private boolean isDeliveryInformationCreateAllowed()
    {
        PurchParameters purchParameters = PurchParameters::find();
        return purchParameters.DeliveryInfoSyncOnCreateDirectDelivery
                || purchParameters.DeliveryInfoSyncOnCreateStock;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmsModifiedDlvMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies all the fields of the correspondent <c>TMSPurchTable</c> record that depend on delivery mode field.
    /// </summary>
    /// <param name="_insert">
    /// A <c>Boolean</c> value specifies if the corresponding <c>TMSPurchTable</c> should be inserted or updated.
    /// </param>
    /// <param name="_syncAgentPurch">
    /// A instance of <c>TMSDeliveryModeSyncAgentPurch</c> class.
    /// </param>
    public void tmsModifiedDlvMode(
        boolean _insert = false,
        TMSDeliveryModeSyncAgentPurch _syncAgentPurch = null)
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(WHSandTMS)))
        {
            if (_syncAgentPurch == null)
            {
                _syncAgentPurch = TMSDeliveryModeSyncAgentPurch::newFromBuffer(purchTable);
            }

            if (_insert)
            {
                _syncAgentPurch.syncOnInsert(purchTable.DlvMode);
            }
            else
            {
                _syncAgentPurch.syncOnUpdate(purchTable.DlvMode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updating</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a purchase order record is updated.
    /// </summary>
    public void updating()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a purchase order record has been updated.
    /// </summary>
    /// <param name="_purchTableOrig">
    /// The original purchase order which is updated.
    /// </param>
    public void updated(PurchTable _purchTableOrig)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBackStatus</Name>
				<Source><![CDATA[
    void  updateBackStatus()
    {
        ttsbegin;
        unchecked(Uncheck::XDS)
        {
            purchTable.PurchStatus = PurchLine::lowestPurchStatus(purchTable.PurchId);
        }
        purchTable.doUpdate();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDistribution</Name>
				<Source><![CDATA[
    public void updateDistribution()
    {
        if (purchTable.DiscPercent != 0 || purchTable.SourceDocumentLine != 0)
        {
            if (SourceDocumentLine::find(purchTable.SourceDocumentLine).AccountingStatus == SourceDocumentLineAccountingStatus::Completed)
            {
                SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(purchTable, false, SourceDocumentLineAccountingStatus::FullyDistributed);
                this.updateMarkupTransDistribution(false, SourceDocumentLineAccountingStatus::FullyDistributed);
            }
            else
            {
                SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(purchTable, purchTable.SourceDocumentLine ? false : true);
                this.updateMarkupTransDistribution(purchTable.SourceDocumentLine ? false : true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarkupTransDistribution</Name>
				<Source><![CDATA[
    public void updateMarkupTransDistribution(
        boolean _updateImplementation = false,
        SourceDocumentLineAccountingStatus _targetSourceDocumentLineAccountingStatus = SourceDocumentLineAccountingStatus::None)
    {
        MarkupTrans markupTrans;
        while select markupTrans
            where markupTrans.TransTableId == purchTable.TableId
                && markupTrans.TransRecId == purchTable.RecId
                && markupTrans.SourceDocumentLine
        {
            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(markupTrans, _updateImplementation, _targetSourceDocumentLineAccountingStatus);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentStatus</Name>
				<Source><![CDATA[
    void  updateDocumentStatus(DocumentStatus  documentStatus)
    {
        ttsbegin;

        // <GIN>
        if (TaxParameters::isCustomsEnable_IN())
        {
            if (this.isDocumentStatusTransitionPossible(documentStatus)      ||
                (purchTable.DocumentStatus == DocumentStatus::ReceiptsList   && documentStatus == DocumentStatus::PackingSlip) ||
                (purchTable.DocumentStatus == DocumentStatus::BillOfEntry_IN &&
                (documentStatus == DocumentStatus::PackingSlip               ||
                documentStatus == DocumentStatus::ReceiptsList               ||
                documentStatus == DocumentStatus::Invoice)))
            {
                purchTable.DocumentStatus = documentStatus;
                purchTable.doUpdate();
            }
        }
        // </GIN>
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])  && (this.documentStatusOrder_RU(purchTable.DocumentStatus) < this.documentStatusOrder_RU(documentStatus)))
        {
            purchTable.DocumentStatus = documentStatus;
            purchTable.doUpdate();
        }
        else if (this.isDocumentStatusTransitionPossible(documentStatus) || (purchTable.DocumentStatus == DocumentStatus::ReceiptsList && documentStatus == DocumentStatus::PackingSlip))
        // </GEERU>
        {
            purchTable.DocumentStatus = documentStatus;
            purchTable.doUpdate();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFiscalDocumentText_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Fiscal document texts of a specific type on the Purchase header.
    /// </summary>
    /// <param name="_type">
    /// A <c>FiscalDocumentTextType_BR</c> value indicating the type.
    /// </param>
    /// <remarks>
    /// This method does nothing if the Purchase header has not been inserted yet.
    /// </remarks>
    public void updateFiscalDocumentText_BR(FiscalDocumentTextType_BR _type)
    {
        if (this.canFiscalDocTextBeRegistrated_BR())
        {
            FiscalDocumentTextUpdate_BR::newFromRecord(purchTable).updateTexts(_type);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStatusFromPurchLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets values on the purchase order that are depending on purchase order lines values.
    /// </summary>
    public void updateStatusFromPurchLines()
    {
        PurchStatus originalPurchStatus = purchTable.PurchStatus;

        ttsbegin;

        purchTable.PurchStatus          = PurchLine::lowestPurchStatus(purchTable.PurchId);
        purchTable.ConfirmedDlvEarliest = PurchLine::earliestConfirmedDlv(purchTable.PurchId);
        purchTable.doUpdate();

        if (originalPurchStatus != PurchStatus::Canceled
            && purchTable.isCanceled())
        {
            PurchPrepayTable::reverseUnpaidPostedAdvances(purchTable.PurchId);

            PurchPrepayTable::checkApplicationRemaining(purchTable.PurchId, purchTable.InvoiceAccount);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFromPurchLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets values on the purchase order that are depending on purchase order line values.
    /// </summary>
    /// <param name="_updateDistributions">
    /// True if the <c>PurchTable</c> distributions are to be updated.
    /// </param>
    [SysObsolete('Use the method updateStatusFromPurchLines', false, 30\06\2018)]
    public void updateFromPurchLines(boolean _updateDistributions)
    {
        PurchStatus originalPurchStatus = purchTable.PurchStatus;

        ttsbegin;

        purchTable.PurchStatus          = PurchLine::lowestPurchStatus(purchTable.PurchId);
        purchTable.ConfirmedDlvEarliest = PurchLine::earliestConfirmedDlv(purchTable.PurchId);
        purchTable.doUpdate();

        if (_updateDistributions)
        {
            this.updateDistribution();
        }

        if (originalPurchStatus != PurchStatus::Canceled 
            && purchTable.isCanceled())
        {
            PurchPrepayTable::reverseUnpaidPostedAdvances(purchTable.PurchId);

            PurchPrepayTable::checkApplicationRemaining(purchTable.PurchId, purchTable.InvoiceAccount);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerCov</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the routine for calling the <see cref="T:LedgerCoverage" /> to pass the purchase receipt
    /// fixed asset <see cref="T:LedgerPostingType" /> instead of the purchase receipt type when the <see
    /// cref="T:PurchLine" /> record is related to a fixed asset.
    /// </summary>
    /// <param name = "_ledgerCoverage">The cash flow forecasting calculations.</param>
    public void  updateLedgerCov(LedgerCoverage _ledgerCoverage)
    {
        if (purchTable.mustBeCovPlanned())
        {
            _ledgerCoverage.init(purchTable);

            SalesPurchTableLedgerCovIUpdateLedgerCov ledgerCovIUpdateLedgerCov = SalesPurchTableLedgerCovType::newFromDocument(_ledgerCoverage, purchTable);
            ledgerCovIUpdateLedgerCov.updateLedgerCov();

            _ledgerCoverage.endCov();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchaseType</Name>
				<Source><![CDATA[
    void  updatePurchaseType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchLineDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Makes <c>PurchLine</c> table deletion related updates to <c>PurchTable</c>.
    /// </summary>
    public void updatePurchLineDelete()
    {
        if (purchTable.PriceDiscResultFields::multiLineDiscPolicyExist()
            && !purchTable.existPurchLine())
        {
            purchTable.PriceDiscResultFields::removeMultiLineDiscCodeFromPolicy();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if it is allowed to delete the current <c>PurchTable</c> record
    /// </summary>
    /// <param name = "_intercompanyForce">Determines if check for derived intercompany purchase order should be skipped; optional</param>
    /// <returns>true if deletion is allowed; otherwise, false</returns>
    boolean validateDelete(boolean _intercompanyForce = false)
    {
        boolean                 ok          = true;
        boolean                 linesExist  = false;
        PurchLine               purchLine;
        List                    warningList = new List(Types::String);
        ListEnumerator          warningListEnumerator;
        str                     warningTxt;
        PurchDeliverySchedule   purchDeliverySchedule;
        BankLCImport            bankLCImportLocal;

        flush  PurchLine;

        setPrefix(#PreFixField(purchTable,PurchId));

        if (!_intercompanyForce
        &&  purchTable.isInterCompanyOrder()
        &&  purchTable.SkipUpdate         != InterCompanySkipUpdate::InterCompany
        &&  purchTable.SkipUpdate         != InterCompanySkipUpdate::Both
        &&  purchTable.InterCompanyOrigin == InterCompanyOrigin::Derived)
        {
            ok = checkFailed(this.intercompanyCheckMessageForValidateDelete());
        }

        if (purchTable.existActivity())
        {
            ok = checkFailed("@SCM:PurchOrderCanNotBeDeletedPleaseCleanupHistory");
        }

        if (ok && FormDataUtil::isFormDataSource(purchTable))
        {
            ok = this.checkDelete();
        }

        while select purchLine
                where purchLine.PurchId     == purchTable.PurchId
                   && !purchLine.IsDeleted
                notexists join purchDeliverySchedule
                    where purchDeliverySchedule.OrderLine == purchLine.InventTransId
                       && !purchDeliverySchedule.IsDeleted
        {
            linesExist = true;

            if(!this.validatePurchLineDelete(purchLine))
            {
                ok = false;
                break;
            }

            if (ok && FormDataUtil::isFormDataSource(purchTable))
            {
                warningTxt = purchLine.referenceWarningTxt();
                if (warningTxt)
                {
                    warningList.addEnd(warningTxt);
                }
            }           
        }

        if (ok  &&  linesExist  &&  purchTable.PurchStatus == PurchStatus::Backorder)
        {
            if (FormDataUtil::isFormDataSource(purchTable)) // the dialog must only appear when called from a form
            {
                if (warningList.elements())
                {
                    warningTxt = '';
                    warningListEnumerator = warningList.getEnumerator();
                    while (warningListEnumerator.moveNext())
                    {
                        warningTxt += warningListEnumerator.current() + '\n';
                    }
                    warningTxt += '\n';

                    warningTxt += "@SYS75611";
                    if (Box::yesNo(warningTxt, DialogButton::No) == DialogButton::No)
                    {
                        ok = checkFailed("@SYS19437");
                    }
                }
            }
        }

        if (ok)
        {
            if (BankLCImportFeatureChecker::checkBankLCImportEnabled())
            {
                if (purchTable.isMarkedForBankLC())
                {
                    bankLCImportLocal = BankLCImport::findByPurchTable(purchTable.PurchId);

                    if (bankLCImportLocal.RecId != 0
                        && !bankLCImportLocal.validateDelete())
                    {
                        // The order could not be deleted, because the related Letter of Credit is still existed.
                        ok = checkFailed("@SYS316256");
                    }
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyCheckMessageForValidateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the label that says the order cannot be deleted because it has been created through an intercompany order.
    /// </summary>
    /// <returns>The label converted to a string.</returns>
    [Replaceable]
    protected str intercompanyCheckMessageForValidateDelete()
    {
        return "@SYS98648";
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    boolean  validateField(FieldId  fieldId)
    {
        boolean  ok = true;
        // <GEERU>
        PurchTable_RU   purchTable_RU;
        // </GEERU>

        switch (fieldId)
        {
            case fieldNum(PurchTable, OrderAccount)     :   ok = purchTable.checkAccount();
                ok = ok && purchTable.allowCurrencyChange();
                // Checking against Filters
                ok = ok && WHSFilter::orderFilterMatch(purchTable.OrderAccount, purchTable.PurchId, ModuleCustVend::Vend);
                break;
            case fieldNum(PurchTable, InvoiceAccount): 
                if (CFMParameters::isPaymentRequestsEnabled())
                {
                    ok = purchTable.checkInvoiceAccount();
                }
                break;
            case fieldNum(PurchTable, vatNum)           :   ok = TaxVATNumTable::checkVATNum(purchTable.vatNum, purchTable, fieldId);
                ok = ok && TaxEnterpriseBranchNumber_BE::checkEnterPriseNumber(purchTable.EnterpriseNumber, purchTable.vatNum, true);
                break;
            case fieldNum(PurchTable, EnterpriseNumber) :   ok = TaxEnterpriseBranchNumber_BE::checkEnterPriseNumber(purchTable.EnterpriseNumber);
                break;
            case fieldNum(PurchTable, PurchaseType)     :   ok = this.canTypeBeChanged();
                break;
            case fieldNum(PurchTable, CurrencyCode)     :   ok = purchTable.interCompanyCheckCurrency();
                ok = ok && purchTable.allowCurrencyChange();
                break;
            case fieldNum(PurchTable, url) :                if (purchTable.url)
                {
                    ok = isValidURL(purchTable.url);
                    if (!ok)
                    {
                        ok = checkFailed("@SYS91305");
                    }
                }
                break;

            case fieldNum(PurchTable, InventLocationId):    ok = purchTable.InventStorageDimMap::validateField(fieldNum(InventStorageDimMap, InventLocationId));
                break;

            case fieldNum(PurchTable, BankDocumentType):
                if (purchTable.BankDocumentType != purchTable.orig().BankDocumentType)
                {
                    if (purchTable.orig().isBankDocumentCreated())
                    {
                        // Bank document type could not be changed.
                        ok = checkFailed("@SYS316266");
                    }

                    if (ok)
                    {
                        switch (purchTable.BankDocumentType)
                        {
                            case BankDocumentType::ImportCollection:
                            case BankDocumentType::LetterOfCredit:
                                if (BankLCImportFeatureChecker::checkBankLCImportEnabled())
                                {
                                    if (!purchTable.mayBankDocumentTypeBeBankLCImport())
                                    {
                                        // It is not allowed to set to %1 at the current status.
                                        ok = checkFailed(strFmt("@SYS318015", enum2Value(purchTable.BankDocumentType)));
                                    }
                                }
                                else
                                {
                                    // It is not allowed to set to %1 because the Import Letter of Credit feature is not enabled.
                                    ok = checkFailed(
                                        strFmt("@SYS318003", enum2Value(purchTable.BankDocumentType)),
                                        '',
                                        SysInfoAction_Formrun::newFormnameControlnameDesc(
                                            formStr(BankParameters),
                                            formControlStr(BankParameters, BankLC_BankLCImportEnable),
                                            "@SYS24215"));
                                }
                                break;
                            case BankDocumentType::LetterOfGuarantee:
                                if (BankLGFeatureChecker::checkBankLGEnabled())
                                {
                                    if (!purchTable.mayBankDocumentTypeBeBankLG())
                                    {
                                        // It is not allowed to set to %1 at the current status.
                                        ok = checkFailed(strFmt("@SYS318015", enum2Value(purchTable.BankDocumentType)));
                                    }
                                }
                                else
                                {
                                    // It is not allowed to set to Letter of Guarantee because the Letter of Guarantee feature is not enabled.
                                    ok = checkFailed(
                                        "@SYS318001",
                                        '',
                                        SysInfoAction_Formrun::newFormnameControlnameDesc(
                                            formStr(BankParameters),
                                            formControlStr(BankParameters, BankLG_BankLGEnable),
                                            "@SYS24215"));
                                }
                                break;
                            default:
                                break;
                        }
                    }
                }
                break;

            case fieldNum(PurchTable, InterCompanyOrder):
                if (BankLCImportFeatureChecker::checkBankLCImportEnabled())
                {
                    if (purchTable.InterCompanyOrder
                        && purchTable.isBankLCCreated())
                    {
                        // The Bank document has been created for this order.
                        // Order could not be changed to inter-company order.
                        ok = checkFailed("@SYS316279");
                    }
                }
                break;
            // <GSA>
            case fieldNum(PurchTable, ContractNum_SA)  :
                ok = VendContractZakat_SA::checkExist(purchTable.OrderAccount, purchTable.ContractNum_SA);
                break;
            // </GSA>
            case fieldNum(PurchTable, AccountingDate):
                ok = purchTable.allowAccountingDateChange();
                break;

            case fieldNum(PurchTable, MatchingAgreement):
                // <GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                {
                    ok = purchTable.checkAgreement_RU(
                        PurchAgreementHeaderExt_RU::findByPurchAgreementHeader(purchTable.MatchingAgreement).RecId);
                }
                else
                {
                    // </GEERU>
                    if (purchTable.MatchingAgreement)
                    {
                        if (PurchAgreementHeader::find(purchTable.MatchingAgreement).canReleaseAgreement() != true)
                        {
                            ok = checkFailed("@SYS103075");
                        }
                    }
                    // <GEERU>
                }
                // </GEERU>
                break;
            
            case fieldNum(PurchTable, DeliveryDate):
                // <GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                {
                    purchTable_RU = purchTable.purchTable_RU();
                    if (purchTable_RU.AgreementHeaderExt_RU)
                    {
                        if (PurchAgreementHeaderExt_RU::purchAgreementHeader(purchTable_RU.AgreementHeaderExt_RU).canReleaseAgreement(purchTable.DeliveryDate) != true)
                        {
                            ok = checkFailed(strFmt("@GLS221056", fieldPName(PurchTable, DeliveryDate)));
                        }
                    }
                }
                // </GEERU>
                
                break;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postModifiedField_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes after a Brazilian field modification.
    /// </summary>
    /// <param name="_fieldId">The modified Brazilian field ID.</param>
    /// <param name="_tableId">
    /// Table ID of the field related table. Optional.
    /// </param>
    public void postModifiedField_BR(FieldId _fieldId, TableId _tableId = tableNum(PurchTable))
    {
        if (_tableId == tableNum(PurchTable))
        {
            switch (_fieldId)
            {
                case fieldNum(PurchTable, OrderAccount):
                    this.setDefaultDeliveryAddress();
                    this.updateFiscalDocumentText_BR(FiscalDocumentTextType_BR::CustVend);
                    break;

                case fieldNum(PurchTable, PurchaseType):
                    purchTable.initFiscalDocumentType_BR();
                    this.updateFiscalDocumentText_BR(FiscalDocumentTextType_BR::CustVend);
                    break;
            }
        }
        else if (_tableId == tableNum(PurchTable_BR))
        {
            switch (_fieldId)
            {
                case fieldNum(PurchTable_BR, SalesPurchOperationType_BR):
                    purchTable.PostingProfile = SalesPurchOperationType_BR::find(purchTable.purchTable_BR().SalesPurchOperationType_BR).VendPostingProfile;
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates Brazilian fields.
    /// </summary>
    /// <param name="_fieldId">The Brazilian field ID to be validated.</param>
    /// <returns>true if the field value is valid; otherwise, false.</returns>
    public boolean validateField_BR(FieldId _fieldId)
    {
        boolean         askUserYesOrNo = false;
        boolean         ok = true;
        PurchTable_BR   purchTableOrig_BR;

        boolean createInventTrans(RecId _salesPurchOperationType_BR)
        {
            if (!_salesPurchOperationType_BR)
            {
                return true;
            }

            return SalesPurchOperationType_BR::find(_salesPurchOperationType_BR).CreateInventTrans;
        }

        switch (_fieldId)
        {
            case fieldNum(PurchTable_BR, SalesPurchOperationType_BR):
                purchTableOrig_BR = purchTable.orig().purchTable_BR();
                if (purchTableOrig_BR.SalesPurchOperationType_BR && purchTable.existPurchLine())
                {
                    if (createInventTrans(purchTableOrig_BR.SalesPurchOperationType_BR) == false
                        && createInventTrans(purchTableOrig_BR.SalesPurchOperationType_BR) != createInventTrans(purchTable.purchTable_BR().SalesPurchOperationType_BR))
                    {
                        ok = checkFailed("@GLS63949");
                    }
                }
                break;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates Russia fields.
    /// </summary>
    /// <param name="_fieldId">
    /// The Russia field ID to be validated.
    /// </param>
    /// <returns>
    /// true if the field value is valid; otherwise, false.
    /// </returns>
    boolean  validateField_RU(FieldId _fieldId)
    {
        boolean  ok = true;

        switch (_fieldId)
        {
            case fieldNum(PurchTable_RU, InventProfileType_RU) :
            case fieldNum(PurchTable_RU, InventProfileId_RU)   :
                ok = purchTable.checkInventProfile_RU();
                break;

            case fieldNum(PurchTable_RU, AgreementHeaderExt_RU):
                ok = purchTable.checkAgreement_RU();
                break;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates countries' fields.
    /// </summary>
    /// <param name="_fieldId">
    /// The countries' field ID to be validated.
    /// </param>
    /// <returns>
    /// true if the field value is valid; otherwise, false.
    /// </returns>
    boolean  validateField_W(FieldId  _fieldId)
    {
        boolean         ok = true;
        PurchTable_W    purchTable_W = purchTable.purchTable_W();

        switch (_fieldId)
        {
            case fieldNum(PurchTable_W, tdsGroup_IN):
                if (TaxWithholdParameters_IN::find().tdsActivate
                    && purchTable_W.tdsGroup_IN)
                {
                    if (TaxWithholdGroupHeading::find(purchTable_W.tdsGroup_IN).TaxType_IN != TaxWithholdCodeType_IN::TDS)
                    {
                        ok = checkFailed(strFmt("@GLS5461", purchTable_W.tdsGroup_IN, TaxWithholdCodeType_IN::TDS));
                    }
                }
                break;

            case fieldNum(PurchTable_W, tcsGroup_IN):
                if (TaxWithholdParameters_IN::find().tcsActivate
                    && purchTable_W.tcsGroup_IN)
                {
                    if (TaxWithholdGroupHeading::find(purchTable_W.tcsGroup_IN).TaxType_IN != TaxWithholdCodeType_IN::TCS)
                    {
                        ok = checkFailed(strFmt("@GLS5461", purchTable_W.tcsGroup_IN, TaxWithholdCodeType_IN::TCS));
                    }
                }
                break;

            case fieldNum(PurchTable_W, CustomsImportOrder_IN) :
                if (TaxParameters::find().Customs_IN
                    && purchTable_W.CustomsImportOrder_IN == NoYes::Yes
                    && purchTable.PurchaseType != PurchaseType::Purch)
                {
                    ok = checkFailed("@GLS5766");
                }
                break;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    boolean  validateWrite()
    {
        PurchTable purchTable_Orig = purchTable.extensionOrig();
        boolean  ok        = true;
        boolean  isChanged = true;
        #ISOCountryRegionCodes

        if (purchTable_Orig.RecId)
        {
            if (purchTable.PurchId != purchTable_Orig.PurchId)
                ok = checkFailed("@SYS2650");

            if ((purchTable_Orig.ProjId) && (!purchTable.ProjId))
                ok = checkFailed("@SYS78501");

            if ((!purchTable_Orig.ProjId) && (purchTable.ProjId))
                ok = checkFailed("@SYS339382");

            isChanged = !purchTable_Orig.equal(purchTable);
        }

        if (isChanged && !purchTable.checkAccount())
            ok = false;

        if (!purchTable.checkPayment())
            ok = false;

        if (!purchTable.checkCashPayment())
            ok = false;

        // If the commitments feature is enabled then we want to present a warning if there are unallocated misc. charges.
        if (PublicSectorUtils::isFrenchRegulatoryEnabled() && purchTable.existUnallocatedMiscCharge())
        {
            warning("@SPS2201");
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (ok
                && purchTable.vendTable_OrderAccount().vatTaxAgent_RU
                && ! purchTable.purchTable_RU().vatOperationCode_RU)
            {
                ok = checkFailed("@GLS112883");
            }

            if (isChanged && !purchTable.checkInventOwner_RU())
            {
                ok = false;
            }
        }
        // </GEERU>

        if (ok)
        {
            if (!purchTable.isReturnOrPurchaseOrder()
                && PurchTable::pdsCWItemLine(purchTable.PurchId))
            {
                ok = checkFailed("@PDS122");
            }
        }
        if (ok
        &&  #PdsMRCEnabled)
        {
            purchTable.pdsMRCLineCheck();
        }

        if (ok 
            && PurchParameters::find().IsSupplierShipmentDatesEnabled 
            && purchTable.RequestedShipDate && purchTable.DeliveryDate 
            && purchTable.RequestedShipDate > purchTable.DeliveryDate)
        {
            ok = checkFailed(strFmt("@SCM:VendorDispatchDateRequestedReceiptDateGreaterThanError", purchTable.DeliveryDate, purchTable.RequestedShipDate));
        }

        if (ok 
            && PurchParameters::find().IsSupplierShipmentDatesEnabled 
            && purchTable.ConfirmedShipDate && purchTable.ConfirmedDlv 
            && purchTable.ConfirmedShipDate > purchTable.ConfirmedDlv)
        {
            ok = checkFailed(strFmt("@SCM:VendorDispatchDateConfirmedReceiptDateGreaterThanError", purchTable.ConfirmedDlv, purchTable.ConfirmedShipDate));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static PurchTableType construct(PurchTable _purchTable)
    {
        switch (_purchTable.PurchaseType)
        {
            case  PurchaseType::Journal: 
                return PurchTableType_Journal::construct(_purchTable);
            case  PurchaseType::Purch: 
                return PurchTableType_Purch::construct(_purchTable);
            case  PurchaseType::ReturnItem: 
                return PurchTableType_ReturnItem::construct(_purchTable);
            default:
                EventHandlerResult resultPurchTableType = EventHandlerResult::newSingleResponse();
                PurchTableType::constructDelegate(_purchTable, resultPurchTableType);
                if (resultPurchTableType.hasResult())
                {
                    return resultPurchTableType.result();
                }

                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for instantiating the corresponding <c>PurchTableType</c> derived class for the specified purchase order.
    /// </summary>
    /// <param name = "_purchTable">Purchase order header record.</param>
    /// <param name = "_result">An instance of <c>EventHandlerResult</c> class subscribers can use to return the instantiated class.</param>
    static delegate void constructDelegate(PurchTable _purchTable, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>posBillOfEntry_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The position bill of entry.
    /// </summary>
    /// <returns>
    /// Returns the position bill of entry.
    /// </returns>
    public static int  posBillOfEntry_IN()
    {
        return 3;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posDropShipDelivery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the dropship delivery position.
    /// </summary>
    /// <returns>
    /// The dropship delivery position.
    /// </returns>
    static int  posDropShipDelivery()
    {
        return 6;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posDropShipRelease</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the dropship release position.
    /// </summary>
    /// <returns>
    /// The dropship release position.
    /// </returns>
    static int  posDropShipRelease()
    {
        return 5;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posFacture_RU</Name>
				<Source><![CDATA[
    public static int posFacture_RU()
    {
        return 6;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posInvoice</Name>
				<Source><![CDATA[
    static int  posInvoice()
    {
        return 4;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posInvoice_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The position of invoice.
    /// </summary>
    /// <returns>
    /// The position of invoice.
    /// </returns>
    public static int  posInvoice_IN()
    {
        return 6;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posInvoice4Paym_RU</Name>
				<Source><![CDATA[
    public static int posInvoice4Paym_RU()
    {
        return 5;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posInvoiceRegistration_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the position invoice registration.
    /// </summary>
    /// <returns>
    /// The position invoice registration.
    /// </returns>
    public static int  posInvoiceRegistration_IN()
    {
        return 2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posPackingSlip</Name>
				<Source><![CDATA[
    static int  posPackingSlip()
    {
        return 3;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posPackingSlip_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the position packing slip.
    /// </summary>
    /// <returns>
    /// The position of packing slip.
    /// </returns>
    public static int  posPackingSlip_IN()
    {
        return 5;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posPurchaseOrder</Name>
				<Source><![CDATA[
    static int  posPurchaseOrder()
    {
        return 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posPurchaseOrder_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the position of the purchase order.
    /// </summary>
    /// <returns>
    /// The position of the purchase order.
    /// </returns>
    public static int  posPurchaseOrder_IN()
    {
        return 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posReceiptsList</Name>
				<Source><![CDATA[
    static int  posReceiptsList()
    {
        return 2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posReceiptsList_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the position of the receipts list.
    /// </summary>
    /// <returns>
    /// The position of the receipts list.
    /// </returns>
    public static int  posReceiptsList_IN()
    {
        return 4;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInventExtPackingSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the position for the InventExtPackingSlip value.
    /// </summary>
    /// <returns>
    /// Always returns 5.
    /// </returns>
    static int  postInventExtPackingSlip()
    {
        return 5;
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncDeliveryAddress</Name>
				<Source><![CDATA[
    static void  syncDeliveryAddress(PurchTable     _purchTable,
                                     AxSalesTable   _axSalesTable,
                                     boolean        _forceAddressSync)
    {
        CompanyInfo companyInfo = CompanyInfo::find();

        if (_forceAddressSync
        ||  !_axSalesTable.salesTable()
        ||  _purchTable.fieldChanged(fieldNum(PurchTable, DeliveryName))
        ||  _purchTable.fieldChanged(fieldNum(PurchTable, InterCompanyDirectDelivery)))
        {
            _axSalesTable.parmDeliveryName(_purchTable.DeliveryName);
        }

        if (_forceAddressSync
        ||  !_axSalesTable.salesTable()
        ||  _purchTable.fieldChanged(fieldNum(PurchTable, DeliveryPostalAddress))
        ||  _purchTable.fieldChanged(fieldNum(PurchTable, InterCompanyDirectDelivery)))
        {
            _axSalesTable.parmDeliveryPostalAddress(_purchTable.DeliveryPostalAddress);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultFromField</Name>
				<Source><![CDATA[
    public void defaultFromField(FieldId _fieldId, boolean _userInput)
    {
        switch (_fieldId)
        {
            case fieldnum(PurchTable, InventLocationId):
                if (purchTable.InventLocationId && !purchTable.InventSiteId)
                {
                    purchTable.InventSiteId = InventLocation::find(purchTable.InventLocationId).InventSiteId;
                }
                break;
        }

        purchTable.modifiedFieldWithUserInput(_fieldId, _userInput);
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultingFields</Name>
				<Source><![CDATA[
    public List defaultingFields()
    {
        List result = new List(Types::Integer);

        result.addEnd(fieldNum(PurchTable, OrderAccount));
        result.addEnd(fieldNum(PurchTable, InvoiceAccount));
        result.addEnd(fieldNum(PurchTable, ProjId));
        result.addEnd(fieldNum(PurchTable, InventSiteId));
        result.addEnd(fieldNum(PurchTable, InventLocationId));
        result.addEnd(fieldNum(PurchTable, DeliveryPostalAddress));
        result.addEnd(fieldNum(PurchTable, ContactPersonId));
        result.addEnd(fieldNum(PurchTable, InterCompanyOrder));
        result.addEnd(fieldNum(PurchTable, BankDocumentType));
        result.addEnd(fieldNum(PurchTable, MarkupGroup));
        result.addEnd(fieldNum(PurchTable, Payment));
        result.addEnd(fieldNum(PurchTable, PaymMode));
        result.addEnd(fieldNum(PurchTable, BankCentralBankPurposeCode));
        result.addEnd(fieldNum(PurchTable, Requester));
        result.addEnd(fieldNum(PurchTable, DiscPercent));
        result.addEnd(fieldNum(PurchTable, MatchingAgreement));
        result.addEnd(fieldNum(PurchTable, PurchaseType));
        result.addEnd(fieldNum(PurchTable, AccountingDate));
        result.addEnd(fieldNum(PurchTable, DlvMode));

        if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
        {
            result.addEnd(fieldNum(PurchTable, RequestedShipDate));
            result.addEnd(fieldNum(PurchTable, DeliveryDate));
            
            result.addEnd(fieldNum(PurchTable, ConfirmedShipDate));
            result.addEnd(fieldNum(PurchTable, ConfirmedDlv));      
            
            result.addEnd(fieldNum(PurchTable, ShipCalendarId));
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDefaults</Name>
				<Source><![CDATA[
    public void initDefaults()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeChanges</Name>
				<Source><![CDATA[
    public void mergeChanges()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergableFields</Name>
				<Source><![CDATA[
    public Set mergableFields()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePurchLineDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if purch line can be deleted.
    /// </summary>
    /// <param name = "_purchLine">
    /// A <c>PurchLine</c> record buffer.
    /// </param>
    /// <returns>
    /// true if purch line can be deleted; otherwise, false.
    /// </returns>
    protected boolean validatePurchLineDelete(PurchLine _purchLine)
    {
        return _purchLine.validateDelete(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesDocumentStateAllowUpdate</Name>
				<Source><![CDATA[
    protected boolean doesDocumentStateAllowUpdate()
    {
        boolean ok = (purchTable.DocumentState == VersioningDocumentState::Approved || purchTable.DocumentState == VersioningDocumentState::InExternalReview);

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNoBlockedBackOrderLine</Name>
				<Source><![CDATA[
    protected boolean checkNoBlockedBackOrderLine()
    {
        boolean     ok ;
        PurchLine   purchLine;

        select firstonly RecId from purchLine
                where purchLine.PurchId     == purchTable.PurchId
                   && purchLine.PurchStatus == PurchStatus::Backorder
                   && purchLine.Blocked     == true
                   && purchLine.IsDeleted   == false;

        ok = !(purchLine.RecId);

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    final internal PurchInstrumentationLogger instrumentationLogger()
    {
        if (!instrumentationLogger)
        {
            instrumentationLogger = PurchInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
        }

        return instrumentationLogger;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>