<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailKitConfigurator</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>RetailKitConfigurator</c> class is used to maintain kit variants.
/// </summary>
public class RetailKitConfigurator
{
    RetailKit retailKit;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkAllCombinations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates kit variants for all combinations of kit components that don't have an existing variant.
    /// </summary>
    /// <param name="_lines">
    /// Kit definition lines. A valid combination consists of one product from each line.
    /// </param>
    protected void checkAllCombinations(Array _lines)
    {
        boolean nextFound;
        List combination; // current combination products along with quantities and UoM
        Set combinationProducts; // current combination product RecIds only
        Set existingVariants; // Set of product combinations of already existing variants.
        ListEnumerator lineEnumerator;
        int lineNo, prevLineNo;
        RecordInsertList variantInsertList;

        ttsbegin;

        existingVariants = this.loadExistingVariants();
        variantInsertList = new RecordInsertList(tableNum(RetailKitVariantComponent));

        do // loop over combinations
        {
            nextFound = false;
            combination = new List(Types::Container);
            combinationProducts = new Set(Types::Int64);

            // loop over all kit lines collecting the distinct product ids for the current combination
            // plus trying to find the next combination by incrementing the line enumerator for the
            // first line possible and resetting enumerators for prior lines.
            for (lineNo = 1; lineNo <= _lines.lastIndex(); lineNo++)
            {
                lineEnumerator = _lines.value(lineNo);

                combination.addEnd(lineEnumerator.current());
                combinationProducts.add(conPeek(lineEnumerator.current(), 1));

                if (!nextFound)
                {
                    if (lineEnumerator.moveNext())
                    {
                        nextFound = true;

                        // reset enumerators for previous lines
                        for (prevLineNo = 1; prevLineNo < lineNo; prevLineNo++)
                        {
                            lineEnumerator = _lines.value(prevLineNo);
                            lineEnumerator.reset();
                            lineEnumerator.moveNext();
                        }
                    }
                }
            }

            if (!existingVariants.in(combinationProducts.toString()))
            {
                // We skip past any pre-existing variants
                this.insertNewVariant(variantInsertList, combination);
            }
            else if (RetailUpdateComponentRefForReAddedItemsInApprovedKitConfigFlight::instance().isEnabled())
            {
                this.remapComponentToExistingVariant(combination);
            }
        }
        while (nextFound);
        variantInsertList.insertDatabase();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateNewVariants</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates new variants for a kit based on its current definition.
    /// </summary>
    public void generateNewVariants()
    {
        Array lines;

        this.validateUOMReferences();
        lines = this.readKitDefinition();
        this.checkAllCombinations(lines);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertNewVariant</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts new kit variant.
    /// </summary>
    /// <param name="_retailKitVariantComponentList">
    /// A record list for table of type <c>RetailKitVariantComponent</c>.
    /// </param>
    /// <param name="_combination">
    /// List of distinct products components of the new kit variant.
    /// </param>
    /// <param name="_languageId">
    /// System language parameter for creating new variants
    /// </param>
    private void insertNewVariant(
        RecordInsertList _retailKitVariantComponentList,
        List        _combination,
        LanguageId  _languageId = SystemParameters::getSystemLanguageId())
    {
        EcoResProductMasterConfiguration ecoResProductMasterConfiguration;
        EcoResProductMasterDimValueTranslation  productMasterDimValueTranslation;
        EcoResDistinctProductVariantRecId ecoResDistinctProductVariantRecId;
        RetailKitVariantComponent retailKitVariantComponent;
        EcoResConfiguration ecoResConfiguration;
        ListEnumerator enumerator = _combination.getEnumerator();
        EcoResConfigurationName configurationName = NumberSeq::newGetNum(
            NumberSeqReference::findReference(extendedTypeNum(RetailKitConfigurationName))).num();
        RefRecId configDimensionAttributeRecId = EcoResProductDimensionAttribute::inventDimFieldId2DimensionAttributeRecId(fieldNum(InventDim, ConfigId));

        // create it if doesn't exist.
        ecoResConfiguration = EcoResConfiguration::findByName(configurationName);
        if (!ecoResConfiguration)
        {
            ecoResConfiguration.Name = configurationName;
            ecoResConfiguration.insert();
        }

        // make it a kit configuration.
        ecoResProductMasterConfiguration.ConfigProductMaster = retailKit.ProductMaster;
        ecoResProductMasterConfiguration.ConfigProductDimensionAttribute = configDimensionAttributeRecId;
        ecoResProductMasterConfiguration.Configuration = ecoResConfiguration.RecId;
        ecoResProductMasterConfiguration.insert();

        productMasterDimValueTranslation.ProductMasterDimensionValue    = ecoResProductMasterConfiguration.RecId;
        productMasterDimValueTranslation.Name                           =  "@REX1317"+" "+"@SYS53395"+ ": " + EcoResConfiguration::find(ecoResConfiguration.RecId).Name;
        productMasterDimValueTranslation.Description                    = '';
        productMasterDimValueTranslation.LanguageId                     = _languageId;
        productMasterDimValueTranslation.insert();

        ecoResDistinctProductVariantRecId = EcoResProductVariantManager::createProductVariant(retailKit.ProductMaster, configurationName,
            [[configDimensionAttributeRecId, ecoResConfiguration.RecId]]);

        // define what products make up that variant
        while (enumerator.moveNext())
        {
            retailKitVariantComponent.KitVariant = ecoResDistinctProductVariantRecId;
            [retailKitVariantComponent.Component,
             retailKitVariantComponent.Quantity,
             retailKitVariantComponent.UnitOfMeasure,
            retailKitVariantComponent.ComponentRecId] = enumerator.current();

            _retailKitVariantComponentList.add(retailKitVariantComponent);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadExistingVariants</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads distinct product lists for existing kit variants.
    /// </summary>
    /// <returns>
    /// A set of strings represending existing variants. Each element is a sorted list of variant disting product ids.
    /// </returns>
    private Set loadExistingVariants()
    {
        EcoResDistinctProductVariant kitVariant;
        RetailKitVariantComponent retailKitVariantComponent;
        Set existingVariants = new Set(Types::String);
        Set variantProducts;
        EcoResDistinctProductVariantRecId variantRecId;

        while select RecId from kitVariant
            order by kitVariant.RecId
            where kitVariant.ProductMaster == retailKit.ProductMaster
            join Component from retailKitVariantComponent
                where retailKitVariantComponent.KitVariant == kitVariant.RecId
        {
            if (kitVariant.RecId != variantRecId)
            {
                if (variantRecId)
                {
                    existingVariants.add(variantProducts.toString());
                }
                variantProducts = new Set(Types::Int64);
                variantRecId = kitVariant.RecId;
            }
            variantProducts.add(retailKitVariantComponent.Component);
        }

        if (variantRecId)
        {
            existingVariants.add(variantProducts.toString());
        }

        return existingVariants;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRetailKit</Name>
				<Source><![CDATA[
    protected RetailKit parmRetailKit(RetailKit _retailKit = retailKit)
    {
        retailKit = _retailKit;
        return retailKit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToKitElements</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates new variants for a kit based on its current definition.
    /// </summary>
    /// <param name="_kitRecId">
    /// The kit record id to check in.
    /// </param>
    /// <param name="_KitElementRecId">
    /// The id of the kit element to check for.
    /// </param>
    /// <param name="_KitElementProductMasterRecId">
    /// The record id of product master of the component or substitute if it is a variant.
    /// </param>
    public static void addToKitElements(RetailKitRecid _kitRecId, EcoResProductRecId _KitElementRecId, EcoResProductRecId _KitElementProductMasterRecId)
    {
        if (!RetailKitElements::checkKitElementExists(_kitRecId,_KitElementRecId))
        {
            RetailKitElements::addKitElement(_kitRecId,_KitElementRecId,_KitElementProductMasterRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>readKitDefinition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads kit definiton from the database.
    /// </summary>
    /// <returns>
    /// An array of kit lines. Each line is a list of distinct products - kit component and its substitites.
    /// </returns>
    public Array readKitDefinition()
    {
        RetailKitComponent retailKitComponent;
        RetailKitComponentSubstitute retailKitComponentSubstitute;
        EcoResDistinctProductVariant ecoResDistinctProductVariant;
        EcoResDistinctProductVariant ecoResDistinctProductVariant1;
        EcoResDistinctProductVariant ecoResDistinctProductVariantNew;
        List line;
        ListEnumerator lineEnumerator;
        Array lines = new Array(Types::Class);
        int lineNo;
        Set substitutionProducts;

        while select retailKitComponent
            where retailKitComponent.Kit == retailKit.RecId
                outer join ecoResDistinctProductVariantNew
                where ecoResDistinctProductVariantNew.RecId == retailKitComponent.Component
        {
            // For each component...

            lineNo++;
            line = new List(Types::Container);
            // Add the component...
            line.addEnd([retailKitComponent.Component,
                         retailKitComponent.Quantity,
                         retailKitComponent.UnitOfMeasure,
                         retailKitComponent.RecId]);

            substitutionProducts = new Set(Types::Int64);
            substitutionProducts.add(retailKitComponent.Component); // Don't add the compnent itself as a substitute

            // Begin - Add kit component to RetailKitElements table
            if (!ecoResDistinctProductVariantNew)
            {
                RetailKitConfigurator::addToKitElements(retailKit.RecId,retailKitComponent.Component,0);
            }
            else
            {
                RetailKitConfigurator::addToKitElements(retailKit.RecId,retailKitComponent.Component,ecoResDistinctProductVariantNew.ProductMaster);
            }
            // End - Add kit component

            while select retailKitComponentSubstitute
                where retailKitComponentSubstitute.KitComponent == retailKitComponent.RecId
                outer join ecoResDistinctProductVariant1
                    where ecoResDistinctProductVariant1.RecId == retailKitComponentSubstitute.SubstituteProduct
                notexists join ecoResDistinctProductVariant
                    where ecoResDistinctProductVariant.ProductMaster == retailKitComponentSubstitute.SubstituteProduct
            {
                // Phase 1 - Standard products...
                line.addEnd([retailKitComponentSubstitute.SubstituteProduct,
                                 retailKitComponentSubstitute.Quantity,
                                 retailKitComponentSubstitute.UnitOfMeasure,
                                 retailKitComponent.RecId]);

                substitutionProducts.add(retailKitComponentSubstitute.SubstituteProduct);

                // Begin - Add kit component to RetailKitElements table
                if (!ecoResDistinctProductVariant1)
                {
                    RetailKitConfigurator::addToKitElements(retailKit.RecId,retailKitComponentSubstitute.SubstituteProduct,0);
                }
                else
                {
                    RetailKitConfigurator::addToKitElements(retailKit.RecId,retailKitComponentSubstitute.SubstituteProduct,ecoResDistinctProductVariant1.ProductMaster);
                }
                // End - Add kit component
            }

            while select retailKitComponentSubstitute
                where retailKitComponentSubstitute.KitComponent == retailKitComponent.RecId
                join RecId from ecoResDistinctProductVariant
                    where ecoResDistinctProductVariant.ProductMaster == retailKitComponentSubstitute.SubstituteProduct
            {
                // Phease 2 - Process Product Masters and their variants...
                if ((ecoResDistinctProductVariant.RecId != retailKitComponent.Component) &&
                    !substitutionProducts.in(ecoResDistinctProductVariant.RecId))
                {
                    line.addEnd([ecoResDistinctProductVariant.RecId,
                                 retailKitComponentSubstitute.Quantity,
                                 retailKitComponentSubstitute.UnitOfMeasure,
                                 retailKitComponent.RecId]);
                }
                // Add kit substitute to RetailKitElements table
                RetailKitConfigurator::addToKitElements(retailKit.RecId,retailKitComponentSubstitute.SubstituteProduct,0);
            }

            lineEnumerator = line.getEnumerator();
            lineEnumerator.moveNext();
            lines.value(lineNo, lineEnumerator);
        }

        return lines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createKitPricesPerCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts kit price for each kit component and Substitute.
    /// </summary>
    /// <param name="_totalKitPrice">
    /// Base sales price of the kit.
    /// </param>
    /// <param name="_retailKit">
    /// Retail Kit record id.
    /// </param>
    /// <param name="_company">
    /// Context of the legal entity to create prices.
    /// </param>
    public static void createKitPricesPerCompany(AmountCur _totalKitPrice, RetailKit _retailKit, CompanyId _company)
    {
        EcoResDistinctProductVariant    ecoResDistinctProductVariant;
        EcoResDistinctProductVariant    productMasterDistinctProductVariant;
        RetailKitVariantComponent       retailKitVariantComponent;
        RetailKitComponent              retailKitComponent;
        RetailKitComponentSubstitute    retailKitComponentSubstitute;
        AmountCur                       kitVariantPrice;
        PriceDiscTable                  priceDiscTable;
        PriceDiscTable                  priceDiscTableToExpire;
        PriceDiscAdmTable               priceDiscAdmTable;
        PriceDiscAdmTable               priceDiscAdmTableJournalToMarkTAForExpire;
        PriceDiscAdmTrans               priceDiscAdmTrans;
        PriceDiscAdmTrans               priceDiscAdmTransToExpire;
        PriceDiscAdmName                priceDiscAdmName;
        Set                             selectedPriceDiscAdmTrans;
        Set                             expiredPriceDiscAdmTrans;
        TmpRetailKitPricing             tmpRetailKitPricing;
        TmpRetailKitPricing             tmpRetailKitPricing_local;
        InventDimCombination            inventDimCombination;
        ItemId                          itemId;
        InventDimId                     inventDimIdBlank = InventDim::findOrCreateBlank().InventDimId;
        UnitOfMeasureSymbol             salesUnitOfMeasure;
        CurrencyCode                    standardCurrency;
        NoYes                           isDifferentFromPosted = NoYes::Yes;
        NoYes                           isDisregardedLeadTime = NoYes::Yes;
        ToDate                          todayDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
        LineNum                         lineNumForExpJournal = 1.0;
        LineNum                         lineNum = 1.0;
        ValidToDate                     noEndDate = DateTimeUtil::date(DateTimeUtil::minValue());
        boolean                         expirePreviousTradeAgreement = true;
        InventTable                     inventTable;

        changecompany(_company)
        {
            ttsBegin;

            // find the default journal name for price/disc trage agreements used when creating TAs for kit configurations
            priceDiscAdmName = PriceDiscAdmName::find(RetailParameters::find().JournalNameForKitPricing);

            if (!priceDiscAdmName)
            {
                error("@REX4161201");
            }

            inventTable = InventTable::findByProduct(_retailKit.ProductMaster);

            standardCurrency = CompanyInfoHelper::standardCurrency();
            salesUnitOfMeasure = UnitOfMeasure::findBySymbol(inventTable.salesUnitId()).Symbol;

            if (salesUnitOfMeasure == "")
            {
                throw error("@SYP4861437");
            }

            itemId = inventTable.ItemId;
            date today = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
            RetailKitConfigurator::loadComponentAndSubstitutePrices(_retailKit.RecId, tmpRetailKitPricing_local);

            // Set the temporary price table
            tmpRetailKitPricing.setTmpData(tmpRetailKitPricing_local);

            ttsbegin;

            // create a journal to expire previous TA.
            priceDiscAdmTableJournalToMarkTAForExpire = RetailKitConfigurator::createTradeAgreement(priceDiscAdmName);

            // create a journal for adding new TA .
            priceDiscAdmTable = RetailKitConfigurator::createTradeAgreement(priceDiscAdmName);

            ttscommit;

            // Initialize the Price Discount trans lines
            expiredPriceDiscAdmTrans = new Set(Types::Int64);
            selectedPriceDiscAdmTrans = new Set(Types::Int64);

            // search for previous trade agreement for the master product kit
            while select Relation, AccountCode, ItemCode, ItemRelation, InventDimId, UnitId, FromDate, PriceUnit, Amount, Currency, SearchAgain, DisregardLeadTime, RecId
               from priceDiscTableToExpire
               where priceDiscTableToExpire.Relation          == PriceType::PriceSales &&
                   priceDiscTableToExpire.AccountCode         == PriceDiscPartyCodeType::All &&
                   priceDiscTableToExpire.ItemCode            == PriceDiscProductCodeType::Table &&
                   priceDiscTableToExpire.ItemRelation        == itemId &&
                   priceDiscTableToExpire.InventDimId         == inventDimIdBlank &&
                   priceDiscTableToExpire.UnitId              == salesUnitOfMeasure &&
                   priceDiscTableToExpire.PriceUnit           == 1 &&
                   priceDiscTableToExpire.FromDate            <= DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) &&
                   priceDiscTableToExpire.ToDate              == noEndDate &&
                   priceDiscTableToExpire.DisregardLeadTime   == isDisregardedLeadTime &&
                   priceDiscTableToExpire.SearchAgain         == NoYes::Yes &&
                   priceDiscTableToExpire.Currency            == standardCurrency
            {
                // if price on the previous trade agreement of the master is same as current price of the master then set expirePreviousTradeAgreement to false
                if (priceDiscTableToExpire.Amount == _totalKitPrice)
                {
                    expirePreviousTradeAgreement = false;
                }
                else  // if the price on the previous TA of the master is different from the new total kit price, then expire the TA by creating a priceDiscAdmTrans line with ToDate = today()
                {
                    priceDiscAdmTransToExpire = RetailKitConfigurator::initPriceDiscAdmTrans(priceDiscAdmTableJournalToMarkTAForExpire.JournalNum,
                        salesUnitOfMeasure,
                        standardCurrency,
                        isDifferentFromPosted,
                        isDisregardedLeadTime,
                        priceDiscTableToExpire);

                    RetailKitConfigurator::updateDatesForTradeAgreementJournalToExpire(priceDiscAdmTransToExpire, today);
                    priceDiscAdmTransToExpire.LineNum = lineNumForExpJournal;
                    priceDiscAdmTransToExpire.insert();

                    expiredPriceDiscAdmTrans.add(priceDiscAdmTransToExpire.RecId);
                    lineNumForExpJournal++;
                }
            }

            // if the previous trade agreement of the kit product master is set to expire then create a new trade agreement for the new price.
            if (expirePreviousTradeAgreement)
            {
                priceDiscAdmTrans = RetailKitConfigurator::initPriceDiscAdmTrans(priceDiscAdmTable.JournalNum,
                    salesUnitOfMeasure,
                    standardCurrency,
                    isDifferentFromPosted,
                    isDisregardedLeadTime);

                priceDiscAdmTrans.ItemRelation = itemId;
                priceDiscAdmTrans.InventDimId = inventDimIdBlank;
                priceDiscAdmTrans.LineNum = lineNum;
                priceDiscAdmTrans.ToDate = noEndDate;
                priceDiscAdmTrans.Amount = _totalKitPrice;
                priceDiscAdmTrans.insert();

                selectedPriceDiscAdmTrans.add(priceDiscAdmTrans.RecId);
                lineNum++;
            }

            // Get All the Kit Variants and Create Trade Agreements
            while select RecId from ecoResDistinctProductVariant
                where ecoResDistinctProductVariant.ProductMaster == _retailKit.ProductMaster
            {
                kitVariantPrice = 0.0;
                expirePreviousTradeAgreement = true;

                // Get all the Components of the Kit Variant
                while select Component, ComponentRecId from retailKitVariantComponent
                    where retailKitVariantComponent.KitVariant == ecoResDistinctProductVariant.RecId
                {
                    kitVariantPrice = kitVariantPrice + TmpRetailKitPricing::LookUpPrice(retailKitVariantComponent.ComponentRecId, retailKitVariantComponent.Component, tmpRetailKitPricing);
                }

                info(any2Str(kitVariantPrice));
                select sum(KitElementPrice) from tmpRetailKitPricing
                    where tmpRetailKitPricing.kitElementRecId == retailKitVariantComponent.ComponentRecId &&
                          tmpRetailKitPricing.KitElement == retailKitVariantComponent.Component;

                info(any2Str(tmpRetailKitPricing.KitElementPrice));

                inventDimCombination = InventDimCombination::findByDistinctProductVariant(ecoResDistinctProductVariant.RecId);

                // - if the new kitvariant price is different from base sales price and there is no trade agreement with that price then create a trade agreement for the kit variant with the latest price.
                // - if the new kitvariant price is same as base sales price and if the variant doesnt have existing trade agreements then skip TA creation for the variant,
                // - if there are previous trade agreements for the kit variant which have different amount than the new kitvariant price, then expire those TAs
                while select Amount, RecId from priceDiscTable
                   where priceDiscTable.Relation == PriceType::PriceSales &&
                         priceDiscTable.AccountCode == PriceDiscPartyCodeType::All &&
                         priceDiscTable.ItemCode == PriceDiscProductCodeType::Table &&
                         priceDiscTable.ItemRelation == itemId &&
                         priceDiscTable.InventDimId == inventDimCombination.InventDimId &&
                         priceDiscTable.UnitId == salesUnitOfMeasure &&
                         priceDiscTable.PriceUnit == 1 &&
                         priceDiscTable.ToDate == noEndDate &&
                         priceDiscTable.SearchAgain == NoYes::Yes &&
                         priceDiscTable.Currency == standardCurrency
                {
                    // if existing trade agreement amount is same as new kitvariant price keep it,
                    // but if the new price of the master TA is the same as the price on previous kit variant TA then override the previous kitvariant TAs
                    if ((priceDiscTable.Amount == kitVariantPrice) && (kitVariantPrice != _totalKitPrice))
                    {
                        expirePreviousTradeAgreement = false;
                    }
                    else
                    {
                        // Add a line to expire the previous trade agreement.
                        while select Relation, AccountCode, ItemCode, ItemRelation, InventDimId, QuantityAmountFrom, UnitId, FromDate, PriceUnit, Amount, Currency, SearchAgain, RecId
                            from priceDiscTableToExpire
                            where priceDiscTableToExpire.Relation == PriceType::PriceSales &&
                                priceDiscTableToExpire.AccountCode == PriceDiscPartyCodeType::All &&
                                priceDiscTableToExpire.ItemCode == PriceDiscProductCodeType::Table &&
                                priceDiscTableToExpire.ItemRelation == itemId &&
                                priceDiscTableToExpire.InventDimId == inventDimCombination.InventDimId &&
                                priceDiscTableToExpire.UnitId == salesUnitOfMeasure &&
                                priceDiscTableToExpire.PriceUnit == 1 &&
                                priceDiscTableToExpire.Amount != kitVariantPrice &&
                                priceDiscTableToExpire.FromDate <= DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) &&
                                priceDiscTableToExpire.ToDate == noEndDate &&
                                priceDiscTableToExpire.SearchAgain == NoYes::Yes &&
                                priceDiscTableToExpire.Currency == standardCurrency
                        {
                            priceDiscAdmTransToExpire = RetailKitConfigurator::initPriceDiscAdmTrans(
                                priceDiscAdmTableJournalToMarkTAForExpire.JournalNum,
                                salesUnitOfMeasure,
                                standardCurrency,
                                isDifferentFromPosted,
                                isDisregardedLeadTime,
                                priceDiscTableToExpire);

                            priceDiscAdmTransToExpire.LineNum = lineNumForExpJournal;
                            RetailKitConfigurator::updateDatesForTradeAgreementJournalToExpire(priceDiscAdmTransToExpire, today);
                            priceDiscAdmTransToExpire.insert();

                            expiredPriceDiscAdmTrans.add(priceDiscAdmTransToExpire.RecId);
                            lineNumForExpJournal++;
                        }
                    }
                }

                //  if the new kit variant price is different from the price set on the master kit product and if expirePreviousTradeAgreement is set to true then create a new TA
                if (expirePreviousTradeAgreement && (kitVariantPrice != _totalKitPrice))
                {
                    priceDiscAdmTrans = RetailKitConfigurator::initPriceDiscAdmTrans(priceDiscAdmTable.JournalNum,
                        salesUnitOfMeasure,
                        standardCurrency,
                        isDifferentFromPosted,
                        isDisregardedLeadTime);

                    priceDiscAdmTrans.ItemRelation = itemId;
                    priceDiscAdmTrans.InventDimId = inventDimCombination.InventDimId;
                    priceDiscAdmTrans.LineNum = lineNum;
                    priceDiscAdmTrans.Amount = kitVariantPrice;
                    priceDiscAdmTrans.insert();

                    selectedPriceDiscAdmTrans.add(priceDiscAdmTrans.RecId);
                    lineNum++;
                }

                priceDiscTable.clear();

                priceDiscTableToExpire.clear();
            }

            RetailKitConfigurator::postOrDeletePriceDiscAdmTrans(priceDiscAdmTableJournalToMarkTAForExpire, expiredPriceDiscAdmTrans);

            RetailKitConfigurator::postOrDeletePriceDiscAdmTrans(priceDiscAdmTable, selectedPriceDiscAdmTrans);

            ttsCommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postOrDeletePriceDiscAdmTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the trade agreement if the it has any trade agreement lines 
    /// or deletes the trade agreement if it does not contain any trade agreement lines.
    /// </summary>
    /// <param name = "_priceDiscAdmTable">The <c>PriceDiscAdmTable</c> record representing the trade agreement to be processed.</param>
    /// <param name = "_priceDiscAdmTrans">The list of <c>PriceDiscAdmTrans</c> record Ids to be posted.</param>
    [HookableAttribute(true)]
    private static void postOrDeletePriceDiscAdmTrans(priceDiscAdmTable _priceDiscAdmTable, Set _priceDiscAdmTrans)
    {
        if (_priceDiscAdmTrans && !_priceDiscAdmTrans.empty())
        {
            PriceDiscAdmCheckPostInputContract  priceDiscAdmCheckPostInputContract = PriceDiscAdmCheckPostInputContract::construct();
            priceDiscAdmCheckPostInputContract.parmJournalNum(_priceDiscAdmTable.JournalNum);
            priceDiscAdmCheckPostInputContract.parmCheckActionType(PriceDiscAdmCheckActionType::ValidateAll);
            priceDiscAdmCheckPostInputContract.parmPriceDiscAdmTransSetSelected(_priceDiscAdmTrans);
            priceDiscAdmCheckPostInputContract.parmCheckOnly(false);
            priceDiscAdmCheckPostInputContract.parmAcceptWarnings(true);

            container postOutput = PriceDiscAdmCheckPost::runFromContract(priceDiscAdmCheckPostInputContract.pack());
            if (!conPeek(postOutput, 3))
            {
                warning("@REX4161202");
            }
        }
        else
        {
            // When there is no line added to TA, just delete the journal
            _priceDiscAdmTable.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPriceDiscAdmTrans</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    private static PriceDiscAdmTrans initPriceDiscAdmTrans(PriceDiscJournalNum _journalNum,
        UnitOfMeasureSymbol _salesUnitOfMeasure,
        CurrencyCode standardCurrency,
        NoYes isDifferentFromPosted,
        NoYes isDisregardedLeadTime,
        PriceDiscTable _priceDiscTable = null)
    {
        // initialize a new PriceDiscAdmTrans with default values used in kit trade agreement creation
        PriceDiscAdmTrans newPriceDiscAdmTrans;

        newPriceDiscAdmTrans.JournalNum = _journalNum;
        newPriceDiscAdmTrans.Relation = PriceType::PriceSales;
        newPriceDiscAdmTrans.AccountCode = PriceDiscPartyCodeType::All;
        newPriceDiscAdmTrans.ItemCode = PriceDiscProductCodeType::Table;
        newPriceDiscAdmTrans.UnitId= _salesUnitOfMeasure;
        newPriceDiscAdmTrans.Currency = standardCurrency;
        newPriceDiscAdmTrans.PriceUnit = 1;
        newPriceDiscAdmTrans.DifferentFromPosted = isDifferentFromPosted;
        newPriceDiscAdmTrans.DisregardLeadTime = isDisregardedLeadTime;
        newPriceDiscAdmTrans.SearchAgain = NoYes::Yes;

        if (_priceDiscTable)
        {
            newPriceDiscAdmTrans.FromDate = _priceDiscTable.FromDate;
            newPriceDiscAdmTrans.ItemRelation = _priceDiscTable.ItemRelation;
            newPriceDiscAdmTrans.InventDimId = _priceDiscTable.InventDimId;
            newPriceDiscAdmTrans.Amount = _priceDiscTable.Amount;
            newPriceDiscAdmTrans.PriceDiscTableRef = _priceDiscTable.RecId;
        }
        else
        {
            newPriceDiscAdmTrans.FromDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
        }

        return newPriceDiscAdmTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadComponentAndSubstitutePrices</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    private static TmpRetailKitPricing loadComponentAndSubstitutePrices(RetailKitRecId _retailKitRecId, TmpRetailKitPricing _tmpRetailKitPricing_local)
    {
        // Retrieve Prices for All the Kit Components and Substitutes
        RetailKitReleasedComponentPricing retailKitReleasedComponentPricing;
        RetailKitReleasedSubstituteCharge retailKitReleasedSubstituteCharge;
        RetailKitComponent retailKitComponent;
        RetailKitComponentSubstitute retailKitComponentSubstitute;
        EcoResDistinctProductVariant ecoResDistinctProductVariant;
        EcoResDistinctProductVariant    productMasterDistinctProductVariant;

        while select RecId, Component from retailKitComponent
                outer join retailKitReleasedComponentPricing
                where retailKitComponent.Kit == _retailKitRecId &&
                retailKitReleasedComponentPricing.KitComponent == retailKitComponent.RecId

        {
            //componentPrice = RetailKitReleasedComponentPricing::findPriceByRetailKitComponent(retailKitComponent.RecId, _company);
            AmountCur componentPrice = retailKitReleasedComponentPricing.KitPrice;
            TmpRetailKitPricing::AddKitElement(retailKitComponent.RecId, retailKitComponent.Component, componentPrice, _tmpRetailKitPricing_local);

            // Retrieve substitute prices of the kit
            while select SubstituteProduct, RecId from retailKitComponentSubstitute
                    where retailKitComponentSubstitute.KitComponent == retailKitComponent.RecId
                    outer join ecoResDistinctProductVariant
                    where ecoResDistinctProductVariant.RecId == retailKitComponentSubstitute.SubstituteProduct
                    outer join retailKitReleasedSubstituteCharge
                    where retailKitReleasedSubstituteCharge.KitComponentSubstitute == retailKitComponentSubstitute.RecId
            {
                // Get the variants of the product master substitute and add it to temporary price table
                AmountCur substitutePrice = componentPrice + retailKitReleasedSubstituteCharge.SubstituteCharge;
                if (!ecoResDistinctProductVariant)
                {
                    if (EcoResProductMaster::exist(retailKitComponentSubstitute.SubstituteProduct))
                    {
                        while select RecId from productMasterDistinctProductVariant
                                where productMasterDistinctProductVariant.ProductMaster == retailKitComponentSubstitute.SubstituteProduct
                        {
                            // Price explicitly specified for a variant or standard product takes precedence over price specified for the product master of the same product
                            if (!TmpRetailKitPricing::exist(retailKitComponent.RecId, productMasterDistinctProductVariant.RecId, _tmpRetailKitPricing_local))
                            {
                                TmpRetailKitPricing::AddKitElement(retailKitComponent.RecId, productMasterDistinctProductVariant.RecId, substitutePrice, _tmpRetailKitPricing_local);
                            }
                        }
                    }
                    else
                    {
                        TmpRetailKitPricing::AddKitElement(retailKitComponent.RecId, retailKitComponentSubstitute.SubstituteProduct, substitutePrice, _tmpRetailKitPricing_local);
                    }
                }
                else
                {
                    TmpRetailKitPricing::AddKitElement(retailKitComponent.RecId, ecoResDistinctProductVariant.RecId, substitutePrice, _tmpRetailKitPricing_local);
                }
            }
        }

        return _tmpRetailKitPricing_local;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTradeAgreement</Name>
				<Source><![CDATA[
    private static PriceDiscAdmTable createTradeAgreement(PriceDiscAdmName priceDiscAdmName)
    {
        PriceDiscAdmTable priceDiscAdmTable;
        priceDiscAdmTable.initFromPriceDiscAdmName(priceDiscAdmName);
        priceDiscAdmTable.JournalNum = NumberSeq::newGetNum(NumberSeqReference::findReference(extendedTypeNum(PriceDiscJournalNum))).num();
        priceDiscAdmTable.insert();

        return priceDiscAdmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReleasedKitComponentByCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if all the kit components and substitutes are released to legal entity.
    /// </summary>
    /// <param name="_recId">
    /// Product Record Id.
    /// </param>
    /// <param name="_companyId">
    /// Context of the legal entity to create prices.
    /// </param>
    /// <returns>
    /// Returns true if all the kit components and substitutes are released. Else False.
    /// </returns>
    public static boolean isReleasedKitComponentByCompany(RecId _recId, CompanyId _companyId)
    {
        EcoResDistinctProductVariant ecoResDistinctProductVariant;
        boolean allComponentsReleased = false;

        changecompany(_companyId)
        {
            select ecoResDistinctProductVariant
                where ecoResDistinctProductVariant.RecId == _recId;

            if (!ecoResDistinctProductVariant && InventTable::findByProduct(_recId))
            {
                allComponentsReleased = true;
            }
            else if (InventDimCombination::findByDistinctProductVariant(_recId))
            {
                allComponentsReleased = true;
            }
        }
        return allComponentsReleased;
    }

]]></Source>
			</Method>
			<Method>
				<Name>kitComponentSubstituteValidation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate if the component substitute product is same as component product
    /// </summary>
    /// <param name="_retailKitComponent">
    /// Retail Kit Component record id.
    /// </param>
    /// <param name="_ecoResDistinctProductRecId">
    /// Eco Res product Record id
    /// </param>
    /// <returns>
    /// true if the substitute product is same as component or substitute is a kit. Else false.
    /// </returns>
    public static boolean kitComponentSubstituteValidation(RetailKitComponent _retailKitComponent, EcoResDistinctProductRecId _ecoResDistinctProductRecId)
    {
        // Verify that substitute product is not same as component product
        if (_retailKitComponent.Component == _ecoResDistinctProductRecId)
        {
            throw error(strFmt("@REX4161203",EcoResProduct::find(_ecoResDistinctProductRecId).productName()));
        }
        // Verify that Kit product master or variant cannot be as substitute for another kit
        else if ( retailKit::existByProductMaster(_ecoResDistinctProductRecId))
        {
            throw error(strFmt("@REX4520282",EcoResProduct::find(_ecoResDistinctProductRecId).productName()));
        }
        else if (retailKit::existByProductMaster(EcoResDistinctProductVariant::find(_ecoResDistinctProductRecId).ProductMaster))
        {
            throw error(strFmt("@REX4520282" , EcoResProduct::find(_ecoResDistinctProductRecId).productName()));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        if (!_args || !_args.record())
        {
            throw error("@SYS25407");
        }
        RetailKitConfigurator::newFromRetailKit(_args.record()).generateNewVariants();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromRetailKit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Public constructor.
    /// </summary>
    /// <param name="_retailKit">
    /// <c>RetailKit</c> for which to create an object.
    /// </param>
    /// <returns>
    /// Object of the class.
    /// </returns>
    public static RetailKitConfigurator newFromRetailKit(RetailKit _retailKit)
    {
        RetailKitConfigurator ret = new RetailKitConfigurator();
        ret.parmRetailKit(_retailKit);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateUOMReferences</Name>
				<Source><![CDATA[
    /// <summary>
    /// validates if <c>RetailKitComponent</c> and <c>RetailKitComponentSubstitute</c> have valid unit of measure reference.
    /// </summary>
    /// <remarks>
    /// When adding product to a component line using <c>RetailAddItems</c> picker form, if the default uom isn't set in inventory management parameters, then the form saves the
    /// unitofmeasure of the component line as 0,
    /// hence check has to be made if uom referenes in component and substitute tables are valid.
    /// This check is done before approving the kit, as user can not edit such properties once kit is approved.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// Throws exception if references without valid uom are found.
    /// </exception>
    private void validateUOMReferences()
    {
        RetailKitComponentSubstitute retailKitComponentSubstitute;
        RetailKitComponent           retailKitComponent;
        UnitOfMeasure                unitOfMeasure;
        int64                        uomCount = 0;

        // count component rows which have invalid uom references
        select count(RecId) from retailKitComponent
            where retailKitComponent.Kit == retailKit.RecId
        notexists join unitOfMeasure
            where retailKitComponent.UnitOfMeasure == unitOfMeasure.RecId;

        // cache the counts from retailKitComponent because it will be reset during the next query...
        uomCount += retailKitComponent.RecId;

        // count substitute rows which have invalid uom references
        select count(RecId) from retailKitComponentSubstitute
        join recid from retailKitComponent
            where retailKitComponent.kit == retailKit.RecId &&
                  retailKitComponentSubstitute.kitcomponent == retailKitComponent.RecId
        notexists join unitOfMeasure
            where retailKitComponentSubstitute.UnitOfMeasure == unitOfMeasure.RecId;

        uomCount += retailKitComponentSubstitute.RecId;

        // if there are any invalid uom references throw an error
        if (uomCount)
        {
            // Unit of measure must be filled in for all components and substitutes.
            throw error("@REX4520707");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDatesForTradeAgreementJournalToExpire</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update From / To dates of trade agreement journal to expire existing trade agreement.
    /// </summary>
    /// <param name = "_tradeAgreementJournalToExpire">Trade agreement journal to expire existing trade agreement.</param>
    /// <param name = "_today">Today's date.</param>
    private static void updateDatesForTradeAgreementJournalToExpire(PriceDiscAdmTrans _tradeAgreementJournalToExpire, date _today)
    {
        if (_tradeAgreementJournalToExpire.FromDate >= _today)
        {
            _tradeAgreementJournalToExpire.FromDate = _today - 1;
        }
        _tradeAgreementJournalToExpire.ToDate = _today - 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remapComponentToExistingVariant</Name>
				<Source><![CDATA[
    private void remapComponentToExistingVariant(List _combination)
    {
        RetailKitComponent kitComponent;
        RetailKitVariantComponent kitVariantComponent, existingKitVariantComponent;
        RetailKitComponentSubstitute kitComponentSubstitute;
        EcoResDistinctProductVariant distinctProductVariant;
        ListEnumerator enumerator = _combination.getEnumerator();

        ttsbegin;
        while (enumerator.moveNext())
        {
            [existingKitVariantComponent.Component,
             existingKitVariantComponent.Quantity,
             existingKitVariantComponent.UnitOfMeasure,
             existingKitVariantComponent.ComponentRecId] = enumerator.current();

            // Get the component recid if <c>existingKitVariantComponent.Component</c> is a component
            select RecId from kitComponent
                where kitComponent.Component == existingKitVariantComponent.Component
                    && kitComponent.Kit == retailKit.RecId;

            RefRecId kitComponentRecId = kitComponent.RecId;

            // Get the component recid from substitute product if <c>existingKitVariantComponent.Component</c> is a substitue.
            if (!kitComponentRecId)
            {
                select firstonly kitComponentSubstitute
                    where kitComponentSubstitute.SubstituteProduct == existingKitVariantComponent.Component
                    exists join kitComponent
                        where kitComponent.RecId == kitComponentSubstitute.KitComponent
                            && kitComponent.Kit == retailKit.RecId;

                kitComponentRecId = kitComponentSubstitute.KitComponent;
            }

            // See if the product is duplicated in components or Substitutes and or in both
            select count(RecId) from kitComponent
                where kitComponent.Component == existingKitVariantComponent.Component
                    && kitComponent.Kit == retailKit.RecId;

            int componentsCount = kitComponent.RecId;

            select count(RecId) from kitComponentSubstitute
                where kitComponentSubstitute.SubstituteProduct == existingKitVariantComponent.Component
                exists join kitComponent
                    where kitComponent.RecId == kitComponentSubstitute.KitComponent
                        && kitComponent.Kit == retailKit.RecId;

            int substitutesCount = kitComponentSubstitute.RecId;

            boolean isDuplicatedProduct = (componentsCount + substitutesCount) > 1;

            // Update the ComponentRecId if the product is not duplicated.
            if (!isDuplicatedProduct && kitComponentRecId)
            {
                while select forupdate kitVariantComponent
                    where kitVariantComponent.Component == existingKitVariantComponent.Component
                    exists join distinctProductVariant
                        where distinctProductVariant.RecId == kitVariantComponent.KitVariant
                            && distinctProductVariant.ProductMaster == retailKit.ProductMaster
                notexists join kitComponent
                    where kitComponent.RecId == kitVariantComponent.ComponentRecId
                        && kitComponent.Kit == retailKit.RecId
                {
                    kitVariantComponent.ComponentRecId = kitComponentRecId;
                    kitVariantComponent.update();
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>