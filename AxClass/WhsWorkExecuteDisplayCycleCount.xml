<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWorkExecuteDisplayCycleCount</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Handles the logic behind the RF flow used to cycle counting.
/// </summary>
[WHSWorkExecuteMode(WHSWorkExecuteMode::CycleCounting)]
public class WhsWorkExecuteDisplayCycleCount extends WHSWorkExecuteDisplay
{
    private static const str ReturnToStepKey = 'ReturnToStep';

    private boolean hideConfirmedConfirmationControls = WHSSkipBuildingConfirmationControlsCycleCountFlight::instance().isEnabled();
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>mustGoToMenuWhenCancelling</Name>
				<Source><![CDATA[
    protected boolean mustGoToMenuWhenCancelling()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelClicked</Name>
				<Source><![CDATA[
    protected void cancelClicked()
    {
        if (WHSWorkUserSession::find(pass.parmUserId()).sessionState().parmPrevPass() == conNull())
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildAddLPOrFinish</Name>
				<Source><![CDATA[
    /// <summary> 
    /// Adds controls to form state for prompting to add new LP or item.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    private container buildAddLPOrFinish(container _con)
    {
        container ret = _con;

        ret += [this.buildControl(#RFLabel, #AddLPOrFinish, "@WAX2212", 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret = this.buildLocationIdControl(ret);
        ret += [this.buildControl(#RFButton, #RFAddLP, "@WAX1649", 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFButton, #RFFinished, "@SYS56424", 1, '', #WHSRFUndefinedDataType, '', 1)];
		ret = this.addCancelButton(ret, 1, true);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFinish</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for finishing the counting.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    protected container buildFinish(container _con)
    {
        container ret = _con;

        ret += [this.buildControl(#RFLabel, WHSWorkExecuteDisplayCycleCountControls::FinishPartialLocationCount, "@WAX:LocationCountingCompleted", 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret = this.buildLocationIdControl(ret);
        ret += [this.buildControl(#RFButton, #RFFinished, "@SYS56424", 1, '', #WHSRFUndefinedDataType, '', 1)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldDisplayLocConfirm</Name>
				<Source><![CDATA[
    private boolean shouldDisplayLocConfirm()
    {
        return WHSRFAutoConfirm::isLocationConfirmationEnabled(pass.lookup(#MenuItem), WHSWorkType::Count)
            && (!hideConfirmedConfirmationControls
                || pass.parmPreviousLocation() != pass.lookupStr(#WMSLocationId)
                || this.canUsePieceByPieceConfirmation(pass.lookupStr(#MenuItem), workline.WorkType, pass.lookupStr(#ItemId)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldDisplayProductConfirmation</Name>
				<Source><![CDATA[
    internal boolean shouldDisplayProductConfirmation(WHSWorkType _whsWorkType)
    {
        return super(_whsWorkType)
            && (!hideConfirmedConfirmationControls
                || pass.parmPreviousItem() != pass.lookupStr(#ItemId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCycleCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for Cycle Counting screen.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_extraText">
    /// Label text; optional.
    /// </param>
    /// <param name="_addNew">
    /// Determines whether new item is added for cycle counting or not, false by default; optional.
    /// </param>
    /// <param name="_buttonClicked">
    /// Button clicked in RF flow.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    protected container buildCycleCount(
		container	_con,
        str         _extraText	   = '',
        boolean     _addNew		   = false,
        str         _buttonClicked = '')
    {
        container ret = _con;

        str finalLabel = _extraText ? _extraText : "@WAX1553";

        ret += [this.buildControl(#RFLabel, #CycleCount, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret = this.buildLocationIdControl(ret);

        WMSLocation location = WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId);

        if (pass.exists(#MenuItem))
        {
            if (this.shouldDisplayLocConfirm())
            {
                if (location.CheckText)
                {
                    ret += [this.buildControl(#RFText, #CheckDigit, "@WAX1197", 0, '', extendedTypeNum(WMSCheckText), '', 0)];
                }
                else
                {
                    ret += [this.buildControl(#RFText, #LocVerification, "@WAX1196", 1, '', extendedTypeNum(WMSLocationId), '', 0)];
                }
            }
        }

        InventTable             inventTable;
        WHSRFMenuItemCycleCount rfMenuItemCycleCount = WHSRFMenuItemCycleCount::find(pass.lookup(#MenuItem));

        if (pass.lookupStr(#ItemId))
        {
            inventTable = InventTable::find(pass.lookup(#ItemId));

            ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, pass.lookup(#ItemId), extendedTypeNum(InventInventItemSearchItem), '', 0, false)];
            ret += this.addProductConfirmationControl(WHSWorkType::Count, workLine.InventQtyRemain, pass.lookup(#ItemId));

            if (inventTable)
            {
                WHSInventTable whsInventTable = WHSInventTable::find(pass.lookup(#ItemId));

                if (whsInventTable.rfDescription1)
                {
                    ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', whsInventTable.rfDescription1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
                }
                else
                {
                    ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', inventTable.productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
                }

                if (whsInventTable.rfDescription2)
                {
                    ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt('\t        %1', whsInventTable.rfDescription2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
                }
            }

            if (this.canUsePieceByPieceConfirmation(pass.lookupStr(#MenuItem), workline.WorkType, pass.lookupStr(#ItemId)))
            {
                WHSUOMSeqGroupTable::validateCycleCountUOMExistsForItem(pass.lookup(#ItemId));

                str elements = this.buildCycleCountUOMSequenceGroupString(pass.lookup(#ItemId));
                ret += [this.buildControl(#RFCombobox, #CycleCountUOM1, "@WAX721", 0, elements, #WHSRFUndefinedDataType, '', 0, true, '', WHSRFColorText::Default, extendedTypeNum(UnitOfMeasureSymbol))];            
            }

            ret = this.buildProductDimensionsText(ret, inventTable.ItemId, true, (!rfMenuItemCycleCount.BlindItem || _addNew));

            if (pass.lookupStr(#LicensePlateId))
            {
                ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookup(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];

                if (!pass.exists(#RFAddLP))
                {
                    WHSInventStatusId defaultInventStatusId = this.retrieveDefaultInventStatusId();

                    pass.insert(#InventoryStatus, defaultInventStatusId);
                    pass.insert(#SelectedValue, defaultInventStatusId);
                }
                
                if (location.whsLocationProfile().DisplayMobileDeviceLocationLicensePlatePositioning)
                {
                    if (pass.exists(WHSWorkExecuteDisplayLocationLicensePlatePositionControls::LocationLicensePlatePosition))
                    {
                            ret += [this.buildControl(#RFText,
                                                      WHSWorkExecuteDisplayLocationLicensePlatePositionControls::LocationLicensePlatePosition,
                                                      "@WAX:WHSLocationLicensePlatePosition",
                                                      1,
                                                      pass.lookupStr(WHSWorkExecuteDisplayLocationLicensePlatePositionControls::LocationLicensePlatePosition),
                                                      extendedTypeNum(WHSLocationLicensePlatePosition),
                                                      '',
                                                      0,
                                                      true)];
                    }
                    else
                    {
                        
                        WHSLocationLicensePlatePosition currentPosition = WHSLocationLicensePlatePositioning::find(pass.lookupStr(#LicensePlateId)).LicensePlatePosition;

                        ret += [this.buildControl(#RFText,
                                                  WHSWorkExecuteDisplayLocationLicensePlatePositionControls::LocationLicensePlatePosition,
                                                  "@WAX:WHSLocationLicensePlatePosition",
                                                  1,
                                                  int2Str((currentPosition != 0) ? currentPosition : WHSLocationLicensePlatePositioningSequencer::FirstPosition),
                                                  extendedTypeNum(WHSLocationLicensePlatePosition),
                                                  '',
                                                  0,
                                                  true)];
                    }
                }
            }
            else if (location.whsLocationIsLPControlled())
            {
                ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, '', extendedTypeNum(WHSLicensePlateId), '', 0)];
            }
        }
        else
        {
            ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, '', extendedTypeNum(InventInventItemSearchItem), '', 0)];
        }

		boolean addingNewItem;

        if (inventTable.RecId != 0)
        {
            ret = this.buildCycleCountTrackingDimensions(ret, inventTable.ItemId, _addNew);

            if (!this.canUsePieceByPieceConfirmation(pass.lookup(#MenuItem), workLine.WorkType, inventTable.ItemId))
            {
                ret = this.buildCycleCountUOM(ret);
            }

            if (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight)
                || (pass.exists(#RFAddLP) && PdsGlobal::pdsIsCWItem(pass.lookup(#ItemId)) 
                    && WHSInventTable::correctionWeightCapturingProcess(pass.lookup(#ItemId)) != WHSCountingWeightCapturingMethod::NotCaptured
                    && WHSInventTable::cycleCountWeightCapturingMethod(pass.lookup(#ItemId)) == WHSCycleCountWeightCapturingMethod::PerCountingQty))
            {
                ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayCatchWeightControls::CatchWeight, "@WAX:Weight", 1, pass.lookupStr(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight), extendedTypeNum(Weight), '', 0)];
            }
        }

        if (pass.exists(#RFAddLP))
        {
            addingNewItem = true;
        }

        WHSRFMenuItemTable menuItemTable = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));

        if (menuItemTable.RFDisplayStatus)
        {
            WHSInventStatusId inventStatusId;
            
            if (((pass.exists(#SerialId) && pass.lookup(#SerialId) != '') 
                || (pass.exists(#BatchId) && pass.lookup(#BatchId) != ''))
                && WHSCycleCountTrackDimDefaultInventStatusFlight::instance().isEnabled())
            {
                WHSInventStatusId defaultInventStatusId = this.getDefaultTrackDimInventStatusId(pass.parmInventSiteId(),
                                                                                            pass.parmInventLocationId(),
                                                                                            pass.parmWMSLocationId(),
                                                                                            pass.parmSerialId(),
                                                                                            pass.parmBatchId());

                if (defaultInventStatusId != '')
                {
                    inventStatusId = defaultInventStatusId;
                }
            }
            else 
            {
                inventStatusId = pass.lookupStr(#SelectedValue);
            }

            ret = this.buildInventoryStatus(ret, '', false, false, false, inventStatusId, addingNewItem);
        }

        if (((step == 3 || step == 4) 
            && this.canReasonCountingCodeControlBeBuilt(_buttonClicked))
            || pass.exists(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode))
        {
            ret = this.buildCountingReasonCodeControl(ret, rfMenuItemCycleCount);
        } 

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFFinished, "@SYS56424", 1, '', #WHSRFUndefinedDataType, '', 0)];
        
        if (menuItemTable.MenuItemDirectedBy == WHSMenuItemDirectedBy::SystemDirected)
        {
            ret += [this.buildControl(#RFButton, #RFSkip, "@WAX3534", 1, '', #WHSRFUndefinedDataType, '', 0)];
        }

        if (pass.exists(#RFAddLP))
        {
            ret += [this.buildControl(#RFButton, WHSWorkExecuteDisplayCycleCountControls::RFAddLPBackButtonName, "@SYS56453", 1, '', #WHSRFUndefinedDataType, '', 0)];
        }

        if (step == 3 && _buttonClicked != #RFFinished)
        {
            ret += [this.buildControl(#RFButton, WHSWorkExecuteDisplayCycleCountControls::BackToItemEntering, "@SYS56453", 1, '', #WHSRFUndefinedDataType, '', 0)];
        }
        else
        {
            ret = this.addCancelButton(ret, 1, true);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveDefaultInventStatusId</Name>
				<Source><![CDATA[
    private WHSInventStatusId retrieveDefaultInventStatusId()
    {
        WHSInventStatusId defaultInventStatusId;

        ItemId itemId = pass.lookupStr(#ItemId);

        if (itemId)
        {
            InventDim inventDim = pass.createInventDimFromPass();
            inventDim.InventStatusId = ''; // Clear the status from the pass' InventDim as it could have been defaulted before all the dimensions were known.

            var statusRetriever = WHSItemAndDimensionsOnHandInventoryStatusRetriever::newFromItemIdAndInventDim(itemId, inventDim);

            // If the status can't be found or there are multiple statuses for the given dimensions, the retriever will return an empty value.
            defaultInventStatusId = statusRetriever.retrieveInventoryStatusId();
        }

        // As it is not allowed to have multiple statuses on the same license plate if all other dimensions are the same,
        // the retriever would usually return a single status and this if block will not be entered.
        // However, in same cases (e.g. if there given dimensions are not enough to uniquely identify a status) the returned value would be empty,
        // so we need to fallback to getting the status from the license plate.
        if (!defaultInventStatusId)
        {
            defaultInventStatusId = this.getDefaultLPInventStatusId(pass.lookup(#LicensePlateId));
        }

        return defaultInventStatusId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCountingReasonCodeControl</Name>
				<Source><![CDATA[
    private container buildCountingReasonCodeControl(container _ret, WHSRFMenuItemCycleCount _rfMenuItemCycleCount)
    {
        container ret = _ret;

        if (_rfMenuItemCycleCount.DisplayReasonCode == WHSDisplayCountingReasonCode::Line)
        {
            ret = this.buildCountingReasonCode(ret, _rfMenuItemCycleCount.DefaultCountingReasonCode, _rfMenuItemCycleCount.EditReasonCode);
        }
        else
        {
            pass.insert(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode, _rfMenuItemCycleCount.DefaultCountingReasonCode);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDimId</Name>
				<Source><![CDATA[
    private InventDimId getInventDimId()
    {
        InventDimId inventDimId;

        if (!pass.hasValue(#InventDimId))
        {
            InventDim inventDim = pass.createInventDimFromPass();

            if (!pass.exists(#InventoryStatus) && !WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).RFDisplayStatus)
            {
                this.addDefaultInventoryStatus(inventDim);
                inventDim = InventDim::findOrCreate(inventDim);
            }

            inventDimId = inventDim.inventDimId;
        }
        else
        {
            inventDimId = pass.lookup(#InventDimId);
        }
        
        return inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCycleCountTrackingDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds RF text controls for tracking dimensions during cycle counting.
    /// </summary>
    /// <param name="_con">
    /// The current RF control container.
    /// </param>
    /// <param name="_itemId">
    /// The current item being counted.
    /// </param>
    /// <param name="_addNewInventory">
    /// Boolean determining if we are adding new inventory or counting existing inventory.
    /// </param>
    /// <returns>
    /// An updated RF control container included newly built tracking dimension controls.
    /// </returns>
    private container buildCycleCountTrackingDimensions(
        container           _con,
        ItemId              _itemId,
        boolean             _addNewInventory)
    {
        container ret = _con;

        WHSRFMenuItemCycleCount menuItemCycleCount = WHSRFMenuItemCycleCount::find(pass.lookup(#MenuItem));
        InventTable inventTable = InventTable::find(_itemId);
        ListEnumerator le = InventDimGroupSetup::newDimensionGroups(0, 0, inventTable.trackingDimensionGroup()).activeFields().getEnumerator();

        while (le.moveNext())
        {
            FieldId inventoryDimension = le.current();
            if (!this.mustShowInventoryDimensionForItem(inventTable, inventoryDimension))
            {
                continue;
            }

            switch (inventoryDimension)
            {
                case fieldNum(InventDim, InventSerialId):
                    if (this.mustCaptureSerialOnReceipt(_itemId) 
                        || this.allowShowSerialIdControl(_addNewInventory, menuItemCycleCount))
                    {
                        ret += [this.buildControl(#RFText, #SerialId, "@WAX1614", 1, pass.lookupStr(#SerialId), extendedTypeNum(InventSerialId), '', 0, _addNewInventory || !menuItemCycleCount.BlindSerial)];
                    }
                    break;

                case fieldNum(InventDim, InventBatchId):
                    ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, pass.lookupStr(#BatchId), extendedTypeNum(InventBatchId), '', 0, _addNewInventory || !menuItemCycleCount.BlindBatch)];

                    if (_addNewInventory && this.showBatchExpDate())
                    {
                        ret += [this.buildControl(#RFText, #ExpDate, strFmt("@WAX1769", WHSParameters::getDateFormat(pass.lookupStr(#UserId))), 1, pass.lookupStr(#ExpDate), extendedTypeNum(InventBatchExpDate), '', 0)];
                    }
                    break;

                default:
                    ret = this.buildCycleCountTrackingDimension(ret, _itemId, inventoryDimension, _addNewInventory);                    
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCycleCountTrackingDimension</Name>
				<Source><![CDATA[
    [Replaceable]
    protected container buildCycleCountTrackingDimension(
        container           _con,
        ItemId              _itemId,
        FieldId             _inventDimension,
        boolean             _addNewInventory)
    {
        container ret = _con;

        ret += [this.buildControlForTableField(tableNum(InventDim), _inventDimension, fieldId2name(tableNum(InventDim), _inventDimension), 1, pass.lookupStr(fieldId2name(tableNum(InventDim), _inventDimension)), true)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFirstPassCycleCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for Cycle Counting first pass screen.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_extraText">
    /// Label text; optional.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    container buildFirstPassCycleCount(container _con, str _extraText = '')
    {
        container ret = _con;

        str finalLabel = _extraText ? _extraText : "@WAX1553";

        ret += [this.buildControl(#RFLabel, #CycleCount, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret = this.buildLocationIdControl(ret);

        if (pass.exists(#MenuItem))
        {
            if (WHSRFAutoConfirm::isLocationConfirmationEnabled(pass.lookup(#MenuItem), WHSWorkType::Count))
            {
                WMSLocation location = WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId);

                if (location.CheckText)
                {
                    ret += [this.buildControl(#RFText, #CheckDigit, "@WAX1197", 0, '', extendedTypeNum(WMSCheckText), '', 0)];
                }
                else
                {
                    ret += [this.buildControl(#RFText, #LocVerification, "@WAX1196", 1, '', extendedTypeNum(WMSLocationId), '', 0)];
                }
            }
        }

        if (pass.exists(#ItemId) && pass.lookup(#ItemId) != '')
        {
            InventTable inventTable = InventTable::find(pass.lookup(#ItemId));
            
            ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, pass.lookup(#ItemId), extendedTypeNum(InventInventItemSearchItem), '', 0, false)];
            ret += this.addProductConfirmationControl(WHSWorkType::Count, workLine.InventQtyRemain, pass.lookup(#ItemId));

            if (inventTable)
            {
                WHSInventTable whsInventTable = WHSInventTable::find(pass.lookup(#ItemId));

                if (whsInventTable.rfDescription1)
                {
                    ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', whsInventTable.rfDescription1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
                }
                else
                {
                    ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', inventTable.itemName()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(ItemNameDisplay))];
                }

                if (whsInventTable.rfDescription2)
                {
                    ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt('\t        %1', whsInventTable.rfDescription2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
                }

                boolean piecePickingEnabled = this.canUsePieceByPieceConfirmation(pass.lookupStr(#MenuItem),
                                                                                  workline.WorkType,
                                                                                  whsInventTable.ItemId);

                if (piecePickingEnabled)
                {
                    str elements = this.buildCycleCountUOMSequenceGroupString(pass.lookup(#ItemId));
                    ret += [this.buildControl(#RFCombobox, #CycleCountUOM1, "@WAX721", 0, elements, #WHSRFUndefinedDataType, '', 0, true, '', WHSRFColorText::Default, extendedTypeNum(UnitOfMeasureSymbol))];
                }

                ret = this.buildProductDimensions(ret, inventTable);

                if (!piecePickingEnabled)
                {
                    ret = this.buildCycleCountUOM(ret);
                }
            }
        }
        else
        {
            ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, '', extendedTypeNum(InventInventItemSearchItem), '', 0)];
        }

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFFinished, "@SYS56424", 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildProductDimensions</Name>
				<Source><![CDATA[
    private container buildProductDimensions(container _con, InventTable _inventTable)
    {
        container ret = _con;

        EcoResProduct ecoResProduct = EcoResProduct::find(_inventTable.Product);

        if (ecoResProduct.isProductMaster())
        {
            InventDim	productDimensions;
            boolean		enableProductDimensionControls = true;

            WHSRFMenuItemCycleCount menuItemCycleCount = WHSRFMenuItemCycleCount::find(pass.lookup(#MenuItem));

            if (!_inventTable.isProductVariantUnitConversionEnabled()
                || menuItemCycleCount.BlindItem)
            {
                InventDimParm inventDimParm;
                inventDimParm.setAllProductDimensions();

                pass.initInventDimFromPassParm(productDimensions, inventDimParm);

                enableProductDimensionControls = false;
            }

            /*
				Product dimensions are left blank in case when product variant unit conversion is enabled or it is not blind counting,
				because the user will enter all the required dimensions.
            */

            ret = this.buildProductDimensionsFromInventDim(ret, _inventTable.ItemId, productDimensions, enableProductDimensionControls);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLocationSelect</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for selecting location for cycle count.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    private container buildLocationSelect(container _con)
    {
        container ret = _con;

        ret += [this.buildControl(#RFLabel, "@SYS53388", pass.lookup(#MenuItem), 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFText, #WMSLocationId, "@SYS80395", 1, '', extendedTypeNum(WMSLocationId), '', 0)];
        ret += [this.buildControl(#RFButton, #RFOK, "@SYS62581", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret = this.addCancelButton(ret, 1, true);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTotalQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates total counted quantity.
    /// </summary>
    /// <returns>
    /// The total counted quantity.
    /// </returns>
    real calculateTotalQty()
    {
        return WHSWorkExecuteCycleCountQuantityValidator::newPass(pass).calculateTotalQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpPassCycleCountQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes CycleCountQty* fields from the pass. 
    /// </summary>
    private void cleanUpPassCycleCountQuantities()
    {
        if (pass.exists(#CycleCountQty1))
        {
            pass.remove(#CycleCountQty1);
        }
        if (pass.exists(#CycleCountQty2))
        {
            pass.remove(#CycleCountQty2);
        }
        if (pass.exists(#CycleCountQty3))
        {
            pass.remove(#CycleCountQty3);
        }
        if (pass.exists(#CycleCountQty4))
        {
            pass.remove(#CycleCountQty4);
        }

        pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpPass</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears all inventory dimension values, selected inventory status and cycle counting quantities stored in pass through map.
    /// </summary>
    void cleanUpPass()
    {
        List			dimList     = InventDim::dimFieldsList();
        ListEnumerator	enumerator	= dimList.getEnumerator();

        // Clear all inventory dimension values
        while (enumerator.moveNext())
        {
            FieldName fieldName = fieldId2name(tableNum(InventDim), enumerator.current());

            if (pass.exists(fieldName))
            {
                pass.remove(fieldName);
            }
        }

        if (pass.exists(#ExpDate))
        {
            pass.remove(#ExpDate);
        }

        this.cleanUpPassCycleCountQuantities();

        // Remove selected drop down value for inventory status
        if (pass.exists(#SelectedValue))
        {
            pass.remove(#SelectedValue);
        }
        if (pass.exists(WHSWorkExecuteDisplayPieceByPieceControls::CycleCountContainer))
        {
            pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::CycleCountContainer);
        }
        if (pass.exists(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed))
        {
            pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed);
        }
        if (pass.exists(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm))
        {
            pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm);
        }

        if (pass.exists(WHSWorkExecuteDisplayLocationLicensePlatePositionControls::LocationLicensePlatePosition))
        {
            pass.remove(WHSWorkExecuteDisplayLocationLicensePlatePositionControls::LocationLicensePlatePosition);
        }
    
        pass.remove(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode);
      
        // Reinsert the site, warehouse, and location dimensions back into the pass.
        InventDim workLineInventDim = workLine.inventDim();

        pass.insert(#InventSiteId, workLineInventDim.InventSiteId);
        pass.insert(#InventLocationId, workLineInventDim.InventLocationId);
        pass.insert(#WMSLocationId, workLineInventDim.wmsLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCycleCountQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears cycle counting quantities from form state and adds an error label indicating that quantities did not match.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the quantities are cleared.
    /// </param>
    /// <returns>
    /// Container containing the form state after the quantities are cleared.
    /// </returns>
    private container clearCycleCountQuantities(container _con)
    {
        container con = _con;
        container ret = this.addErrorLabel(conNull(), strFmt("%1\n%2", "@SYP5070000", "@SYP5070001"), WHSRFColorText::Error);

        if (conLen(conPeek(_con, 1)) == 2)
        {
            con = conDel(con, 1, 2);
        }

        ret += con;
		int	i		= 2;
        int	length	= conLen(ret);

        int catchWeightPos = 0;

        while (i <= length)
        {
            str name = conPeek(conPeek(ret, i), #name);

            if (name == #CycleCountQty1 
                || name == #CycleCountQty2 
                || name == #CycleCountQty3 
                || name == #CycleCountQty4
                || name == WHSWorkExecuteDisplayPieceByPieceControls::PieceByPieceConfirmation)
            {
                ret = conPoke(ret, i, conPoke(conPeek(ret, i), #data, ''));
            }

            if (name == WHSWorkExecuteDisplayPieceByPieceControls::CycleCountContainer)
            {
                ret = conPoke(ret, i, conPoke(conPeek(ret, i), #label, strFmt("@WAX:LastCountedCycleCountAttempt",
                                                                              pass.lookup(WHSWorkExecuteDisplayPieceByPieceControls::LastCycleCount),
                                                                              WHSCatchWeightHelper::inventHandlingUnitId(pass.lookup(#ItemId)))));
            }

            if (name == WHSWorkExecuteDisplayCatchWeightControls::CatchWeight)
            {
                catchWeightPos = i;
            }

            ++i;
        }

        // Remove the capture weight control as the user will be re-entering the handling quantities and may no longer need to enter capture weight if the new count matches the on-hand
        if (catchWeightPos > 0)
        {
            ret = conDel(ret, catchWeightPos, 1);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDefaultInventoryStatus</Name>
				<Source><![CDATA[
    private void addDefaultInventoryStatus(InventDim _inventDim)
    {
        WHSInventStatusId defaultInventoryStatusId = WHSInventStatus::getDefaultInventStatus(pass.lookup(#InventLocationId)).InventStatusId;
        if (defaultInventoryStatusId)
        {
            pass.insert(#InventoryStatus, defaultInventoryStatusId);
            _inventDim.InventStatusId = defaultInventoryStatusId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayForm</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Form displayed for cycle count RF flow.
    /// </summary>
    /// <param name="_con">
    ///    Container for RF information.
    /// </param>
    /// <param name="_buttonClicked">
    ///    Button clicked in RF flow.
    /// </param>
    /// <returns>
    ///    Next form to display.
    /// </returns>
    public container displayForm(container _con, str _buttonClicked = "")
    {
        container ret = conNull();
        container con = _con;

        pass = WHSRFPassthrough::create(conPeek(con, 2));
        step = conPeek(conPeek(con, 1), 2);

        int initialStep = step;

        [ret, con] = this.prepareStepExecution(ret, con, _buttonClicked);

        switch (step)
        {
            case 0, 1:
                ret = this.executeStepsZeroAndOne(ret);
                break;

            case 2:
                ret = this.executeStepTwo(ret, con);
                break;

            case 3:
                ret = this.executeStepThree(ret, con, _buttonClicked);
                break;

            case 4:
                ret = this.executeStepFour(ret, con, _buttonClicked);
                break;

            case 5:
                ret = this.executeStepFive(ret, con, _buttonClicked);
                break;

            case 6:
                ret = this.executeStepSix(ret, con, initialStep);
                break;

            case 7:
                ret = this.executeStepSeven(ret, con, _buttonClicked);
                break;

            case #CWOutboundWeightCapture:
                ret = this.processWeightCapture(con);
                break;
        }

        ret = this.updateModeStepPassForCycleCount(ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateModeStepPassForCycleCount</Name>
				<Source><![CDATA[
    private container updateModeStepPassForCycleCount(container _ret)
    {
        container ret = _ret;

        WHSRFMenuItemTable menuItemTable = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));

        if (menuItemTable.WorkCreationProcess == WHSWorkCreationProcess::SpotCycleCounting)
        {
            ret = this.updateModeStepPass(ret, WHSWorkExecuteMode::SpotCycleCounting, step, pass);
        }
        else if (menuItemTable.MenuItemDirectedBy == WHSMenuItemDirectedBy::CycleCountGrouping)
        {
            ret = this.updateModeStepPass(ret, WHSWorkExecuteMode::CycleCountGrouping, step, pass);
        }
        else
        {
            ret = this.updateModeStepPass(ret, WHSWorkExecuteMode::UserDirected, step, pass);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateCycleCountWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a new cycle count work line should be created,
    /// if none could be found.
    /// </summary>
    /// <returns>
    /// true if a cycle count work line should be created; otherwise, false.
    /// </returns>
    protected boolean shouldCreateCycleCountWorkLine()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateCycleCountWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates cycle counting work lines if they are not created before.
    /// </summary>
    /// <returns>
    /// A cycle counting work line.
    /// </returns>
    protected WHSWorkLineCycleCount findOrCreateCycleCountWorkLines()
    {
        WHSWorkLineCycleCount workLineCycleCount;

        select firstonly workLineCycleCount
            where workLineCycleCount.WorkId == workTable.WorkId;

        if (!workLineCycleCount && this.shouldCreateCycleCountWorkLine())
        {
            boolean isCatchWeightFeatureEnabled = WHSCatchWeightConfigurationKeyManager::instance().isEnabled();

            if (this.isPartialLocationCount())
            {
                using (var activityContext = this.instrumentationLogger().workExecuteSpotCycleCount().partialLocationCountExpectedTransactionsCreation())
                {
                    workLineCycleCount = this.partialLocationCreateCycleCountWorkLines(isCatchWeightFeatureEnabled);
                }
            }
            else
            {
                using (var activityContext = this.instrumentationLogger().workExecuteSpotCycleCount().fullLocationCountExpectedTransactionsCreation())
                {
                    workLineCycleCount = this.nonPartialLocationCreateCycleCountWorkLines(isCatchWeightFeatureEnabled);
                }
            }
        }

        return workLineCycleCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>finishWorkLineCycleCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds work lines for cycle counting to finalize them.
    /// </summary>
    /// <returns>
    /// Cycle counting work line iterator.
    /// </returns>
    WHSWorkLineCycleCount finishWorkLineCycleCount()
    {
        WHSWorkLineCycleCount workLineCycleCount;

        WHSRFMenuItemCycleCount cycleCountRF = WHSRFMenuItemCycleCount::find(pass.lookup(#MenuItem));

        if (cycleCountRF.BlindItem && pass.exists(#ItemId))
        {
            select forupdate workLineCycleCount
                where workLineCycleCount.WorkId					== pass.lookup(#WorkId)
					&& workLineCycleCount.LineNum				== pass.parmLineNum()
					&& workLineCycleCount.CycleCountCounted		== NoYes::No
					&& workLineCycleCount.CycleCountReconcile	== NoYes::No
					&& workLineCycleCount.ItemId				== pass.lookup(#ItemId);
        }
		else
        {
            select forupdate workLineCycleCount
                where workLineCycleCount.WorkId					== pass.lookup(#WorkId)
					&& workLineCycleCount.LineNum				== pass.parmLineNum()
					&& workLineCycleCount.CycleCountCounted		== NoYes::No
					&& workLineCycleCount.CycleCountReconcile	== NoYes::No;
        }

        return workLineCycleCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasRelatedWorkLineCycleCount</Name>
				<Source><![CDATA[
    private boolean hasRelatedWorkLineCycleCount(WHSWorkLine _workLine)    
    {
        WHSWorkLineCycleCount workLineCycleCount;

        select firstonly RecId from workLineCycleCount
                where workLineCycleCount.WorkId	  == _workLine.WorkId
                    && workLineCycleCount.LineNum == _workLine.LineNum;

        return workLineCycleCount.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCycleCountPass</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates pass through map with the values from cycle counting work line.
    /// </summary>
    /// <param name="_workLineCycleCount">
    /// The cycle counting work line.
    /// </param>
    public void updateCycleCountPass(WHSWorkLineCycleCount _workLineCycleCount)
    {
        WHSWorkLineCycleCount workLineCycleCount = _workLineCycleCount;

        select firstonly workLineCycleCount
			where workLineCycleCount.WorkId              == workLine.WorkId
				&& workLineCycleCount.CycleCountCounted   == NoYes::No
				&& workLineCycleCount.CycleCountReconcile == NoYes::No
                && (workLine.ItemId == '' || workLineCycleCount.ItemId == workLine.ItemId); // This line was added, so we get to count the items in order of the work lines.

        InventDim inventDim = InventDim::find(workLineCycleCount.InventDimId);

        WHSRFMenuItemCycleCount menuItemCycleCount = WHSRFMenuItemCycleCount::find(pass.lookup(#MenuItem));

        if (workLine)
        {
            pass.insert(#WMSLocationId, workLine.wmsLocationId);
        }

        this.updateCycleCountPassDimensions(workLineCycleCount.ItemId, inventDim, menuItemCycleCount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCycleCountPassDimensions</Name>
				<Source><![CDATA[
    protected void updateCycleCountPassDimensions(
        ItemId _itemId, 
        InventDim _inventDim, 
        WHSRFMenuItemCycleCount _menuItemCycleCount)
    {
        if (_menuItemCycleCount.BlindItem && _itemId)
        {
            pass.insert(#ItemId, _itemId);

            InventDimParm inventDimParm;

            inventDimParm.setAllProductDimensions();
            pass.initFromInventDimParm(_inventDim, inventDimParm);
        }

        if (_menuItemCycleCount.BlindLP && _inventDim.LicensePlateId)
        {
            pass.insert(#LicensePlateId, _inventDim.LicensePlateId);
        }

        if (_menuItemCycleCount.BlindBatch && _inventDim.InventBatchId)
        {
            pass.insert(#BatchId, _inventDim.InventBatchId);
        }

        if (_menuItemCycleCount.BlindSerial && _inventDim.InventSerialId)
        {
            pass.insert(#SerialId, _inventDim.InventSerialId);
        }

        WMSLocation location = WMSLocation::find(_inventDim.wmsLocationId, _inventDim.InventLocationId);
        if (!location.whsLocationIsLPControlled())
        {
            if (pass.lookupStr(#ItemId) == '')
            {
                pass.insert(#SelectedValue, '');
            }
            else
            {
                pass.insert(#SelectedValue, _inventDim.InventStatusId);
            }
        }

        #ISOCountryRegionCodes
        if (_inventDim.InventOwnerId_RU && !SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            pass.insert(#OwnerId_RU, _inventDim.InventOwnerId_RU);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCycleCountPassStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates pass through map with the inventory status of the cycle counting item.
    /// </summary>
    void updateCycleCountPassStatus()
    {
        WHSWorkLineCycleCount workLineCycleCount;

        select firstonly InventDimId from workLineCycleCount
            where workLineCycleCount.WorkId                 == workLine.WorkId
				&& workLineCycleCount.CycleCountCounted     == NoYes::No
				&& workLineCycleCount.CycleCountReconcile	== NoYes::No
				&& workLineCycleCount.ItemId                == pass.lookup(#ItemId);

        // When everything for the itemId is counted, then workLineCycleCount.InventDimId would be blank.
        // Then we want to do counting for the already counted item
        if (!workLineCycleCount.InventDimId)
        {
            select firstonly InventDimId from workLineCycleCount
                where workLineCycleCount.WorkId                 == workLine.WorkId
                    && workLineCycleCount.ItemId                == pass.lookup(#ItemId);
        }

        InventDim inventDim = InventDim::find(workLineCycleCount.InventDimId);

        if (!WMSLocation::find(inventDim.wmsLocationId, inventDim.InventLocationId).whsLocationIsLPControlled())
        {
            pass.insert(#SelectedValue, inventDim.InventStatusId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    [SysObsolete('Use WhsWorkExecuteDisplay::construct() instead.', true, 31\05\2017)]
    public static WHSWorkExecuteDisplayCycleCount construct()
    {
        return new WHSWorkExecuteDisplayCycleCount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFieldValues</Name>
				<Source><![CDATA[
    container processFieldValues(
        container        _con, 
        WHSRFPassthrough _fieldValues,
        str              _buttonClicked = '')
    {
        str         value;
        boolean     complete = true;
        container   con = _con;
        str         controlType;
        str         name;
        int         enabled;
        container   subCon;
        boolean     allEnabledFieldsAreEmpty = true;
        boolean     isPieceByPieceEnabled = this.canUsePieceByPieceConfirmation(pass.lookupStr(#MenuItem),
                                                                                workline.WorkType, 
                                                                                pass.lookupStr(#ItemId));        
		int length = conLen(con); 

        for (int i = 1; i <= length; ++i)
        {
            subCon = conPeek(con, i);
            controlType = conPeek(subCon, #controlType);

            if (controlType == #RFText
                || controlType == #RFPassword)
            {
                name = conPeek(subCon, #name);

                if (_fieldValues.exists(name))
                {
                    if (!isPieceByPieceEnabled
                        || (isPieceByPieceEnabled
                        &&  name != #ProductConfirmation
                        &&  name != WHSWorkExecuteDisplayPieceByPieceControls::PieceByPieceConfirmation))
                    {
                        con = conPoke(con, i, conPoke(subCon, #data, _fieldValues.lookup(name)));
                    }

                    value   = _fieldValues.lookup(name);
                    enabled = conPeek(subCon, #enabled);

                    if (!value && enabled)
                    {
                        if (!isPieceByPieceEnabled
                            || (_buttonClicked != #RFFinished)
                            || (_buttonClicked == #RFFinished
                            &&  name != #ProductConfirmation
                            &&  name != WHSWorkExecuteDisplayPieceByPieceControls::PieceByPieceConfirmation))
                        {
                            complete = false;
                        }
                    }
                    if (value
                        && enabled
                        && name != #LocVerification // location confirmation value should not prevent going to next step.
                        && (name != WHSWorkExecuteDisplayPieceByPieceControls::PieceByPieceConfirmation 
                            || WhsWorkExecuteDisplay::str2numDisplay(value) != 0)) // Zero is taken as empty.
                    {
                        allEnabledFieldsAreEmpty = false;
                    }
                }
            }
            else if (controlType == #RFComboBox && conPeek(subCon, #data) == '' && conPeek(conPeek(con,i), #selected) == '')
            {
                name    = conPeek(subCon, #name);
                enabled = conPeek(subCon, #enabled);

                if (name != #Disposition
                    && name != #InventoryStatus
                    && enabled)
                {
                    complete = false;
                }
            }
        }

        return [con, complete, allEnabledFieldsAreEmpty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPartialLocationCount</Name>
				<Source><![CDATA[
    private boolean isPartialLocationCount()
    {
        return WHSWorkTable::find(pass.lookupStr(#WorkId)).IsPartialCycleCountWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLocationIdControl</Name>
				<Source><![CDATA[
    private container buildLocationIdControl(container _con)
    {
        container ret = _con;

		WMSLocationId locationId;

		if (workLine.wmsLocationId)
		{
			locationId = workLine.wmsLocationId;
		}
		else
		{
			locationId = pass.lookupStr(#WMSLocationId);
		}

        ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, locationId, extendedTypeNum(WMSLocationId), '', 0, false)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareStepExecution</Name>
				<Source><![CDATA[
    private container prepareStepExecution(
		container	_ret,
		container	_con,
        str			_buttonClicked)
    {
        container ret = _ret;
        container con = _con;        
        
        if (_buttonClicked == #RFSkip)  // Skip
        {
            pass.remove(#ItemId);
            pass.remove(#UOM);
            step = 1;
        }

        WHSRFMenuItemTable		menuItemTable		= WHSRFMenuItemTable::find(pass.lookup(#MenuItem));
        WHSRFMenuItemCycleCount	menuItemCycleCount	= WHSRFMenuItemCycleCount::find(pass.lookup(#MenuItem));

        if (pass.exists(#WorkId))
        {
            workTable = WHSWorkTable::find(pass.lookupStr(#WorkId));

            if (this.isPartialLocationCount())
            {
                if (!menuItemCycleCount.BlindItem)
                {
                    throw error("@WAX:NonGuidedCountingErrorLocationHasNonCompletedPartialCycleCountWork");
                }

                workLine = WHSWorkLine::firstOpenOrInProcessCountLine(pass.lookup(#WorkId));

                pass.parmLineNum(workLine.LineNum);
            }
            else
            {
				if (pass.exists(#LineNum))
				{
					workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
				}
				else
				{
					pass.parmLineNum(1);
					workLine = WHSWorkLine::find(pass.lookup(#WorkId), 1);
                }

				/*
					This validation is not done for the partial cycle count, because all the work lines get closed when the work is done.
					No work lines should be fetched in that case.
				*/
                if (!workLine || !workTable)
                {
                    throw error("@WAX613");
                }

                if (workTable.LockedUser && workTable.LockedUser != pass.lookup(#UserId))
                {
                    throw error("@WAX1831");
                }
            }
        }

        if (menuItemTable.CycleCountFirstPass
            && !pass.exists(#FirstPassFail)
            && !pass.exists(#RFFinished)
            && step != 4 
            && step != 7)
        {
            step = 6;

            if (workTable.WorkStatus == WHSWorkStatus::Open
                || (workTable.WorkStatus == WHSWorkStatus::InProcess
                    && workTable.LockedUser == ''))
            {
                this.updateWorkTableAndLineToInProcess();
            }

            if (!pass.exists(#RetryCounter))
            {
                pass.insert(#RetryCounter, 0);
            }
        }

        if (this.shouldPrepareAddNewLicensePlateOrItemStepForProcessing(_buttonClicked, menuItemCycleCount))
        {
            step = 4;
            pass.insert(#RFAddLP, 1);

            if (pass.exists(#RFFinished))
            {
                pass.remove(#RFFinished);
            }
        }

        // if step is no longer related to "Add new LP or item" remove the tag.
        // step 4 is for adding a new LP or item, 
        // step 7 is for confirming a LP will be moved from another location
        if (pass.exists(#RFAddLP) && step != 4 && step != 7 && step != #CWOutboundWeightCapture)
        {
            pass.remove(#RFAddLP);
        }

        boolean isPieceByPieceEnabled = this.canUsePieceByPieceConfirmation(pass.lookupStr(#MenuItem),
                                                                            workline.WorkType,
                                                                            pass.lookupStr(#ItemId));

        if (_buttonClicked == #RFFinished
        &&  (!isPieceByPieceEnabled
        ||   step != 6
        ||   pass.exists(#RFFinished)))
        {
            if (pass.exists(#RFFinished) || (step != 3 && step != 4))
            {
                step = 5;
            }
            else
            {
                if (step == 3 || step == 4)
                {
                    container tmpFieldValues;

                    [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
                    WHSRFPassthrough fieldValues = WHSRFPassthrough::create(tmpFieldValues);    

                    boolean complete;
                    boolean allEnabledFieldsAreEmpty;

                    [ret, complete, allEnabledFieldsAreEmpty] = this.processFieldValues(con, fieldValues, _buttonClicked);

                    // Do not bypass a logic of a corresponding case if any of enabled fields has a value.
                    // If piece by piece is enabled, go to next step until finish.
                    // If counting reason code control should be built and the pass does not contain the counting reason code, go to next step until finish.
                    if (allEnabledFieldsAreEmpty
                        && (!isPieceByPieceEnabled || pass.exists(#RFFinished))
                        && (this.canReasonCountingCodeControlBeBuilt(_buttonClicked) && pass.exists(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode)))
                    {
                        // Save values to pass for step 5, step 3 and 4 will process the values separately.
                        pass = this.combineMaps(pass, fieldValues);
                        step = 5;
                    }

                    ret = conNull(); // Reset a container since each case has its own instantiation logic.
                }
            }
        }
        else if (_buttonClicked == WHSWorkExecuteDisplayCycleCountControls::RFAddLPBackButtonName && step == 4)
        {
            step = 5;

            container tmpFieldValues;

            [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
            WHSRFPassthrough fieldValues = WHSRFPassthrough::create(tmpFieldValues);
            pass = this.combineMaps(pass, fieldValues);
            this.clearPassValuesForEnabledFields(con, fieldValues);

            ret = conNull();
        }
        else if (_buttonClicked == #RFCancel
                && WHSWorkUserSession::find(pass.parmUserId()).sessionState().parmPrevPass() != conNull())
        {
            step = 5;
        }
        else if (_buttonClicked == WHSWorkExecuteDisplayCycleCountControls::BackToItemEntering && step == 3)
        {
            step = 1;

            pass.remove(#ItemId);
            pass.remove(#LicensePlateId);
            pass.removeTrackingDimensions();
            pass.removeProductDimensions();

            ret = conNull();
        }

        if (this.hasError(con))
        {
            con = conDel(con, 3, 1);
        }

        return [ret, con];
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPrepareAddNewLicensePlateOrItemStepForProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the cycle counting flow should prepare the add new license plate or item step for processing.
    /// </summary>
    /// <param name = "_buttonClicked">Button clicked in RF flow.</param>
    /// <param name = "_menuItemCycleCount">Mobile device menu item used for cycle counting.</param>
    /// <returns>true if the add new license plate or item step should be prepared; otherwise, false.</returns>
    protected boolean shouldPrepareAddNewLicensePlateOrItemStepForProcessing(str _buttonClicked, WHSRFMenuItemCycleCount _menuItemCycleCount)
    {
        return pass.exists(#RetryCounter)
            && (_buttonClicked == #RFAddLP
                || (_menuItemCycleCount.NumRetries == pass.lookupNum(#RetryCounter)
                    && pass.exists(#RFAddLP) 
                    && this.isQtyPopulated()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isQtyPopulated</Name>
				<Source><![CDATA[
    private boolean isQtyPopulated()
    {
        return (pass.exists(#CycleCountQty1) && pass.lookupStr(#CycleCountQty1) != '')
                || (pass.exists(#CycleCountQty2) && pass.lookupStr(#CycleCountQty2) != '')
                || (pass.exists(#CycleCountQty3) && pass.lookupStr(#CycleCountQty3) != '')
                || (pass.exists(#CycleCountQty4) && pass.lookupStr(#CycleCountQty4) != '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeStepsZeroAndOne</Name>
				<Source><![CDATA[
    private container executeStepsZeroAndOne(container _ret)
    {
        container ret = _ret;

        pass.insert(#RetryCounter, 0);

        WHSWorkLineCycleCount workLineCycleCount = this.findOrCreateCycleCountWorkLines();

        this.autoCloseFirstWorkLinesForWhichCycleCountSkipped(workLine);

        this.updateCycleCountPass(workLineCycleCount);

        ret = this.buildCycleCount(ret);

        step = 2;

        if (pass.exists(#ItemId) && pass.lookup(#ItemId) != '')
        {
            step = 3;
        }

        if (workLineCycleCount.RecId == 0)
        {
            ret = this.buildLocationComplete();
        }

        // Work could be already closed at this point, if it happened that on-hand
        // for all corresponding items and dimensions was zeroed out
        // after work creation and before it's executiuon
        workTable.reread();
        if (workTable.WorkStatus == WHSWorkStatus::Open
            || (workTable.WorkStatus == WHSWorkStatus::InProcess
                && workTable.LockedUser == ''))
        {
            this.updateWorkTableAndLineToInProcess();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoCloseFirstWorkLinesForWhichCycleCountSkipped</Name>
				<Source><![CDATA[
    private void autoCloseFirstWorkLinesForWhichCycleCountSkipped(WHSWorkLine _currentWorkLine)
    {
        if (this.isPartialLocationCount()
                && !this.hasRelatedWorkLineCycleCount(_currentWorkLine))
        {
            pass.insert(#WMSLocationId, _currentWorkLine.wmsLocationId);
            this.closeWorkLineForPartialLocationCountIfAllRelatedCycleCountWorkLinesAreCounted();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkTableAndLineToInProcess</Name>
				<Source><![CDATA[
    private void updateWorkTableAndLineToInProcess()
    {
        ttsbegin;

        WHSWorkTable	newWorkTable	= WHSWorkTable::find(workLine.WorkId, true);
        WHSWorkLine		newWorkLine		= WHSWorkLine::find(workLine.WorkId, workLine.LineNum, true);

        if (!newWorkTable || !newWorkLine)
        {
            throw error("@WAX613");
        }

        if (newWorkTable.LockedUser
			&& newWorkTable.LockedUser != pass.lookup(#UserId))
        {
            throw error("@WAX1831");
        }

        newWorkTable.WorkStatus = WHSWorkStatus::InProcess;
        newWorkTable.WorkInProcessUTCDateTime = DateTimeUtil::utcNow();
        newWorkTable.LockedUser = pass.lookup(#UserId);
        newWorkTable.update();

        newWorkLine.WorkStatus = WHSWorkStatus::InProcess;
        newWorkLine.WorkInProcessUTCDateTime = DateTimeUtil::utcNow();
        newWorkLine.UserId = pass.lookup(#UserId);
        newWorkLine.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeStepTwo</Name>
				<Source><![CDATA[
    private container executeStepTwo(container _ret, container _con)
    {
        container ret = _ret;
        container con = _con;

        this.findOrCreateCycleCountWorkLines();

        container tmpFieldValues;

        [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
        WHSRFPassthrough fieldValues = WHSRFPassthrough::create(tmpFieldValues);

        if (!this.isItemWorkLineCycleCountNotCreated(fieldValues.parmItemId()))
        {
            throw error(strFmt("@WAX:WHSItemWorkLineCycleCountNotCreatedError", pass.lookupStr(#WMSLocationId), fieldValues.parmItemId()));
        }

        pass = this.combineMaps(pass, fieldValues);
    
        if (this.hasError(con))
        {
            return con;
        }

        if (pass.exists(#ItemId) && pass.lookup(#ItemId) != '')
        {
            this.updateCycleCountPassStatus();
            step = 3;
        }

        ret = this.buildCycleCount(ret);

        [ret] = this.processFieldValues(ret, fieldValues);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeCompletedPieceByPieceValues</Name>
				<Source><![CDATA[
    private void removeCompletedPieceByPieceValues(boolean _pieceByPieceEnabled)
    {
        if (_pieceByPieceEnabled
            && pass.hasValue(#ProductConfirmation)
            && pass.lookupReal(WHSWorkExecuteDisplayPieceByPieceControls::PieceByPieceConfirmation) != 0)
        {
            pass.remove(#ProductConfirmation);
            pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::PieceByPieceConfirmation);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasZeroPieceByPieceCycleCountQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if no quantity is set for piece by piece cycle counting.
    /// </summary>
    /// <param name = "_totalQty">Already counted quantity.</param>
    /// <returns>true if no quantity is set; otherwise, false</returns>
    private boolean hasZeroPieceByPieceCycleCountQty(Qty _totalQty)
    {
        return pass.lookupReal(WHSWorkExecuteDisplayPieceByPieceControls::PieceByPieceConfirmation) == 0
                && _totalQty == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasCycleCountQty</Name>
				<Source><![CDATA[
	private boolean hasCycleCountQty()
    {
        return pass.exists(#CycleCountQty1) || pass.exists(#CycleCountQty2) || pass.exists(#CycleCountQty3) || pass.exists(#CycleCountQty4);
	}

]]></Source>
			</Method>
			<Method>
				<Name>canReasonCountingCodeControlBeBuilt</Name>
				<Source><![CDATA[
    private boolean canReasonCountingCodeControlBeBuilt(str _buttonClicked)
    {
        if (this.hasCycleCountQty() || _buttonClicked == #RFFinished)
        {
            InventDimId inventDimId = this.getInventDimId();

            if (this.calculateTotalQty() != WHSWorkLineCycleCount::find(workTable.WorkId, workLine.LineNum, pass.lookupStr(#ItemId), inventDimId).QtyExpected)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeStepThree</Name>
				<Source><![CDATA[
    private container executeStepThree(
        container _ret, 
        container _con,
        str		  _buttonClicked)
    {
        container ret = _ret;
        container con = _con;

        this.findOrCreateCycleCountWorkLines();

        container tmpFieldValues;

        [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
        WHSRFPassthrough fieldValues = WHSRFPassthrough::create(tmpFieldValues);
        pass = this.combineMaps(pass, fieldValues);
        

        boolean isPieceByPieceEnabled = this.canUsePieceByPieceConfirmation(pass.lookupStr(#MenuItem),
                                                                            workline.WorkType,
                                                                            pass.lookupStr(#ItemId));

        if (pass.exists(#RetryCounter) 
            && pass.lookupNum(#RetryCounter) > 0
            && !pass.exists(#CycleCountQty1)
            && !pass.exists(#CycleCountQty2)
            && !pass.exists(#CycleCountQty3)
            && !pass.exists(#CycleCountQty4)
            && (!isPieceByPieceEnabled || !pass.exists(#CurrentQty))) // CycleCountQty can be empty when piece by piece confirmation is enabled
        {
            pass.insert(#RetryCounter, pass.lookupNum(#RetryCounter) - 1);
        }       
        
        if (this.hasError(con))
        {
            ret = con;

            if (!WHSUOMSeqGroupTable::hasCycleCountUOM(WHSInventTable::find(pass.lookup(#ItemId)).uomSeqGroupId))
            {
                int uom1pos = this.getControlLocation(ret, #CycleCountUOM1);
                if (!uom1pos)
                {
                    throw error(error::wrongUseOfFunction(funcName()));
                }
                ret = conPoke(ret, uom1pos, conPeek(this.buildCycleCountUOM(conNull(), '', false, pass.lookupStr(#CycleCountUOM1)), 2));
            }
            return ret;
        }
        if (this.isLicensePlateMovementConfirmationNeeded()) 
        {
            con = this.buildLicensePlateMovementConfirmationScreen(ret);
			
			return con;
        }

        WHSRFMenuItemCycleCount rfMenuItemCycleCount = WHSRFMenuItemCycleCount::find(pass.lookup(#MenuItem));

        if (!pass.exists(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode)
            && rfMenuItemCycleCount.DisplayReasonCode == WHSDisplayCountingReasonCode::Line
            && this.canReasonCountingCodeControlBeBuilt(_buttonClicked))
        {
            return this.buildCycleCount(ret, '', false, _buttonClicked);
        }
        
        this.removeCompletedPieceByPieceValues(isPieceByPieceEnabled);
        
        con = this.buildCycleCount(ret, '', false, _buttonClicked);

        boolean complete;

        [ret, complete] = this.processFieldValues(con, fieldValues, this.getButtonClicked(_con));
        
        if (complete && !pass.hasValue(#ExpDate) && this.showBatchExpDate())
        {
            complete = false;
        }

        Qty totalQty = this.calculateTotalQty();

        if (!complete
            && _buttonClicked == #RFFinished
            && (!isPieceByPieceEnabled
                || this.hasZeroPieceByPieceCycleCountQty(totalQty)))
        {
            ret = this.executeStepFive(ret, con, _buttonClicked);
        }

        if (complete
        &&  (!isPieceByPieceEnabled
        ||   _buttonClicked == #RFFinished))
        {
            InventDim testInventDim = pass.createInventDimFromPass();

            // If Inventory status is not displayed need to resolve a default value.
            if (!pass.exists(#InventoryStatus) && !WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).RFDisplayStatus)
            {
                this.addDefaultInventoryStatus(testInventDim);
                testInventDim = InventDim::findOrCreate(testInventDim);
            } 

            if (WHSRFAutoConfirm::isProductConfirmationEnabled(pass.lookup(#MenuItem), workLine.WorkType))
            {
                pass.remove(#ProductConfirmation);
            }

            WHSWorkLineCycleCount testWorkLineCycleCount;

            select firstonly forupdate testWorkLineCycleCount
				where testWorkLineCycleCount.WorkId         == workTable.WorkId
					&& testWorkLineCycleCount.LineNum       == workLine.LineNum
					&& testWorkLineCycleCount.ItemId        == pass.lookup(#ItemId)
					&& testWorkLineCycleCount.InventDimId   == testInventDim.InventDimId;

			
            testWorkLineCycleCount.LocationLicensePlatePosition = fieldValues.lookupInt64(WHSWorkExecuteDisplayLocationLicensePlatePositionControls::LocationLicensePlatePosition);

            if (this.updateExpectedQtyOnOnHandChange(testWorkLineCycleCount, testInventDim))
            {
				ret = conNull();
				ret = this.addErrorLabel(ret, strFmt("@WAX:CycleCountInventoryHasBeenUpdated", testWorkLineCycleCount.ItemId, testInventDim.wMSLocationId));
				ret = this.buildCycleCount(ret);
				return ret;
            }

            if (hideConfirmedConfirmationControls)
            {
                pass.parmPreviousLocation(pass.lookup(#WMSLocationId));
                pass.parmPreviousItem(pass.lookup(#ItemId));
            }

            ret = this.finalizeStepThreeCycleCounting(ret, con, totalQty, testWorkLineCycleCount, testInventDim);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeStepThreeCycleCounting</Name>
				<Source><![CDATA[
    protected container finalizeStepThreeCycleCounting(
        container             _ret, 
        container             _cycleCountFormControls,
        Qty                   _totalQty, 
        WhsWorkLineCycleCount _workLineCycleCount, 
        InventDim             _inventDimCycleCount)
    {
        if (this.allowStepThreeCorrectCount(_totalQty, _workLineCycleCount))
        {
            _ret = this.processStepThreeCorrectCount(_ret, _workLineCycleCount);
        }
        else
        {
            this.validateCountingReasonCode(pass.lookup(#ItemId), _inventDimCycleCount.inventDimId);
            _ret = this.processStepThreeIncorrectCount(_ret, _cycleCountFormControls, _workLineCycleCount, _totalQty, _inventDimCycleCount);
        }
        return _ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExpectedQtyOnOnHandChange</Name>
				<Source><![CDATA[
    private boolean updateExpectedQtyOnOnHandChange(WHSWorkLineCycleCount _workLineCycleCount, InventDim _inventDim)
    {
        if (!_workLineCycleCount.displayInventJournalId())
        {
            boolean isCWItem = PdsGlobal::pdsIsCWItem(pass.lookup(#ItemId));
            InventOnhandQty inventOnhandQty = InventOnhandQty::newParameters(pass.lookup(#ItemId), _inventDim);

            InventHandlingQty recalculatedQty =  isCWItem ?
                    inventOnhandQty.pdsCWPhysicalInvent() : inventOnhandQty.physicalInvent();

            if (_workLineCycleCount.QtyExpected != recalculatedQty)
            {
                _workLineCycleCount.QtyExpected = recalculatedQty;

                if (isCWItem)
                {
                    _workLineCycleCount.ExpectedWeight = inventOnhandQty.physicalInvent();
                }

                _workLineCycleCount.update();

                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLicensePlateMovementConfirmationNeeded</Name>
				<Source><![CDATA[
    private boolean isLicensePlateMovementConfirmationNeeded() 
    {
        return pass.lookupStr(WHSWorkExecuteDisplayLicensePlateMovementConfirmationConstants::State) == WHSWorkExecuteDisplayLicensePlateMovementConfirmationConstants::Required;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLicensePlateMovementConfirmationScreen</Name>
				<Source><![CDATA[
    private container buildLicensePlateMovementConfirmationScreen(container _con)
    {
        container con = this.buildLicensePlateMovementConfirmation(_con);
        pass.insert(ReturnToStepKey, step);
        step = 7;

        return con;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLicensePlateMovementConfirmation</Name>
				<Source><![CDATA[
    private container buildLicensePlateMovementConfirmation(container _ret)
    {
        container ret = _ret;
        
        str LicensePlateMovementConfirmationText = strFmt("@WAX:LicensePlateMovementConfirmationText", pass.lookupStr(#LicensePlateId), pass.lookupStr(WHSWorkExecuteDisplayLicensePlateMovementConfirmationConstants::FromWMSLocationId), pass.lookupStr(WHSWorkExecuteDisplayLicensePlateMovementConfirmationConstants::ToWMSLocationId));

        ret += [this.buildControl(#RFLabel, WHSWorkExecuteDisplayLicensePlateMovementConfirmationConstants::Label, LicensePlateMovementConfirmationText, 1, '', #WHSRFUndefinedDataType, '', 0)];
        // Do not remove LicensePlate control as it is required to process the license plate
        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookup(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        
        ret += [this.buildControl(#RFButton, #RFYes, "@SYS323111", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFReturn, "@WAX:Return", 1, '', #WHSRFUndefinedDataType, '', 0)];
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processStepThreeCorrectCount</Name>
				<Source><![CDATA[
    private container processStepThreeCorrectCount(container _ret, WHSWorkLineCycleCount _currentWorkLineCycleCount)
    {
        container ret = _ret;

        ttsbegin;

        if (_currentWorkLineCycleCount)
        {
            _currentWorkLineCycleCount.QtyCounted	        = _currentWorkLineCycleCount.QtyExpected;
            _currentWorkLineCycleCount.CapturedWeight       = _currentWorkLineCycleCount.ExpectedWeight;
            _currentWorkLineCycleCount.CycleCountCounted    = NoYes::Yes;
            _currentWorkLineCycleCount.AcceptReject		    = WHSAcceptReject::Accept;
            _currentWorkLineCycleCount.update();

            // Update counting history records
            InventCountJour inventCountJour;
            inventCountJour.initFromWHSWorkLineCycleCount(_currentWorkLineCycleCount);
            inventCountJour.insert();
        }

        this.closeWorkLineForPartialLocationCountIfAllRelatedCycleCountWorkLinesAreCounted();

        ttscommit;

        ret = this.processFinishingStepThree(ret);

        return ret;
	}

]]></Source>
			</Method>
			<Method>
				<Name>closeWorkLineForPartialLocationCountIfAllRelatedCycleCountWorkLinesAreCounted</Name>
				<Source><![CDATA[
	private void closeWorkLineForPartialLocationCountIfAllRelatedCycleCountWorkLinesAreCounted()
    {
        if (this.isPartialLocationCount())
        {
            WHSWorkLineCycleCount workLineCycleCount;

            select firstonly RecId from workLineCycleCount
                where workLineCycleCount.WorkId					== workLine.WorkId
                    && workLineCycleCount.LineNum				== workLine.LineNum
                    && workLineCycleCount.CycleCountCounted		== NoYes::No
                    && workLineCycleCount.CycleCountReconcile	== NoYes::No;

            if (!workLineCycleCount)
            {
                this.processPartialLocationCountWorkLineClosing();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPartialLocationCountWorkLineClosing</Name>
				<Source><![CDATA[
	private void processPartialLocationCountWorkLineClosing()
    {
        ttsbegin;

        WHSWorkLine workLineSelectedForUpdate = WHSWorkLine::find(workLine.WorkId, workLine.LineNum, true);

        if (workLineSelectedForUpdate)
        {
            workLineSelectedForUpdate.updateStatus(WHSWorkStatus::Closed);
            workLineSelectedForUpdate.WorkClosedUTCDateTime = DateTimeUtil::utcNow();
            workLineSelectedForUpdate.update();
        }

        workLine = WHSWorkLine::firstOpenOrInProcessCountLine(pass.lookup(#WorkId));

        if (workLine)
        {
            workLineSelectedForUpdate = WHSWorkLine::find(workLine.WorkId, workLine.LineNum, true);

            if (workLineSelectedForUpdate)
            {
                workLineSelectedForUpdate.WorkStatus				= WHSWorkStatus::InProcess;
                workLineSelectedForUpdate.WorkInProcessUTCDateTime	= DateTimeUtil::utcNow();
                workLineSelectedForUpdate.UserId					= pass.lookup(#UserId);
                workLineSelectedForUpdate.update();

                this.autoCloseWorkLinesForWhichCycleCountSkipped(workLineSelectedForUpdate);                
            }
        }
        else
        {
            this.processPartialLocationCountWorkHeaderClosing();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoCloseWorkLinesForWhichCycleCountSkipped</Name>
				<Source><![CDATA[
    private void autoCloseWorkLinesForWhichCycleCountSkipped(WHSWorkLine _currentWorkLine)
    {
        if (!this.hasRelatedWorkLineCycleCount(_currentWorkLine))
        {
            this.processPartialLocationCountWorkLineClosing();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPartialLocationCountWorkHeaderClosing</Name>
				<Source><![CDATA[
    private void processPartialLocationCountWorkHeaderClosing()
    {
        WHSWorkTable newWorkTable = WHSWorkTable::find(pass.lookupStr(#WorkId), true);
       
        if (newWorkTable)
        {
            WHSWorkLineCycleCount workLineCycleCount;
            WHSWorkTable          localWorkTable;

            select firstonly RecId from workLineCycleCount
				where workLineCycleCount.WorkId					== pass.lookup(#WorkId)
					&& workLineCycleCount.AcceptReject			!= WHSAcceptReject::Accept
                    && workLineCycleCount.CycleCountReconcile	== NoYes::Yes
                    exists join localWorkTable
                        where localWorkTable.WorkId     == workLineCycleCount.WorkId
                            && localWorkTable.WorkStatus != WHSWorkStatus::Closed;

            if (workLineCycleCount)
            {
                this.updateWorkHeaderWithStatusPendingReview(newWorkTable);
            }
            else
            {
                this.updateWorkHeaderWithStatusClosed(newWorkTable);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFullLocationCountWorkHeaderClosing</Name>
				<Source><![CDATA[
    private void processFullLocationCountWorkHeaderClosing()
    {
        WHSWorkTable newWorkTable = WHSWorkTable::find(pass.lookupStr(#WorkId), true);
       
        if (newWorkTable)
        {
            WHSWorkLineCycleCount workLineCycleCount;

            select firstonly workLineCycleCount
                where workLineCycleCount.WorkId					== pass.lookup(#WorkId)
					&& workLineCycleCount.LineNum				== pass.parmLineNum()
                    && workLineCycleCount.AcceptReject			!= WHSAcceptReject::Accept
                    && workLineCycleCount.CycleCountReconcile	== NoYes::Yes;

            if (workLineCycleCount)
            {
                this.updateWorkHeaderWithStatusPendingReview(newWorkTable);
            }
            else
            {
                this.updateWorkHeaderWithStatusClosed(newWorkTable);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkHeaderWithStatusClosed</Name>
				<Source><![CDATA[
    private void updateWorkHeaderWithStatusClosed(WHSWorkTable _workTable)
    {
        if (_workTable)
        {
            _workTable.WorkStatus = WHSWorkStatus::Closed;

            this.updateWorkHeaderForClosingOrPendingReview(_workTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkHeaderWithStatusPendingReview</Name>
				<Source><![CDATA[
    private void updateWorkHeaderWithStatusPendingReview(WHSWorkTable _workTable)
    {
        if (_workTable)
        {
            _workTable.WorkStatus = WHSWorkStatus::PendingReview;

            this.updateWorkHeaderForClosingOrPendingReview(_workTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkHeaderForClosingOrPendingReview</Name>
				<Source><![CDATA[
    private void updateWorkHeaderForClosingOrPendingReview(WHSWorkTable _workTable)
    {
        if (_workTable)
        {
            _workTable.WorkClosedUTCDateTime	= DateTimeUtil::utcNow();
            _workTable.LockedUser				= '';
            _workTable.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processStepThreeIncorrectCount</Name>
				<Source><![CDATA[
    private container processStepThreeIncorrectCount(
		container				_ret,
        container				_con,
        WHSWorkLineCycleCount	_currentWorkLineCycleCount,
		Qty						_totalQty,
        InventDim				_currentInventDim)
    {
        container ret = _ret;
        container con = _con;

        Debug::assert(_currentWorkLineCycleCount.QtyExpected != 0);

        boolean isCWItem = PdsGlobal::pdsIsCWItem(pass.lookup(#ItemId));
        WHSCountingWeightCapturingMethod weightCapturingMethod;

        int numRetries = WHSRFMenuItemCycleCount::find(pass.lookup(#MenuItem)).NumRetries;

        if (pass.exists(#CurrentQty)
			&& pass.lookupNum(#RetryCounter) == numRetries
			&& _totalQty != pass.lookupNum(#CurrentQty))
        {
            pass.insert(#RetryCounter, pass.lookupNum(#RetryCounter) - 1);
        }

        if (pass.lookupNum(#RetryCounter) >= numRetries)
        {
            if (isCWItem)
            {
                weightCapturingMethod = WHSInventTable::correctionWeightCapturingProcess(pass.lookup(#ItemId));
                if (weightCapturingMethod == WHSCountingWeightCapturingMethod::AtQuantityDiscrepancy && !pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight))
                {
                    if (WHSInventTable::cycleCountWeightCapturingMethod(pass.lookup(#ItemId)) == WHSCycleCountWeightCapturingMethod::PerCountingQty)
                    {
                        pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight, '');
                        ret = this.buildCycleCount(conNull());
                    }
                    else if (_totalQty != 0)
                    {
                        ret = this.buildWeightCapture(conNull());
                        step = #CWOutboundWeightCapture;
                    }
                    return ret;
                }
            }

            WHSWorkUser workUser = WHSWorkUser::find(pass.lookupStr(#UserId));

            boolean failLimit = this.checkLimitFail(workUser, _currentWorkLineCycleCount, _currentInventDim, _totalQty);

            WHSCapturedWeight capturedWeight;

            if (isCWItem)
            {
                if (weightCapturingMethod == WHSCountingWeightCapturingMethod::NotCaptured)
                {
                    capturedWeight = PdsCatchWeight::inventQty(pass.lookup(#ItemId), _totalQty);
                }
                else
                {
                    capturedWeight = pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight);
                }
            }

            if (failLimit && !workUser.WorkCountIsSupervisor)
            {
                if (_currentWorkLineCycleCount)
                {
                    ttsbegin;

                    _currentWorkLineCycleCount.QtyCounted           = _totalQty;
                    _currentWorkLineCycleCount.CapturedWeight       = capturedWeight;
                    _currentWorkLineCycleCount.CycleCountReconcile  = NoYes::Yes;
                    _currentWorkLineCycleCount.CountingReasonCode   = pass.lookupStr(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode);

                    if (_currentWorkLineCycleCount.AcceptReject != WHSAcceptReject::None)
                    {
                        _currentWorkLineCycleCount.CycleCountCounted    = NoYes::No;
                        _currentWorkLineCycleCount.AcceptReject			= WHSAcceptReject::None;
                    }

                    _currentWorkLineCycleCount.update();

                    ttscommit;
                }
            }
            else
            {
                ttsbegin;

                Qty                 adjustmentQty       = this.getAdjustmentQty(_totalQty, _currentWorkLineCycleCount);
                WHSCapturedWeight   adjustmentWeight    = this.getAdjustmentWeight(capturedWeight, _currentWorkLineCycleCount);
                
                _currentWorkLineCycleCount.AdjustmentWorkId = this.createAdjustmentWork(adjustmentQty, adjustmentWeight, _currentInventDim);
                
                if (_currentWorkLineCycleCount)
                {
                    _currentWorkLineCycleCount.QtyCounted		    = _totalQty;
                    _currentWorkLineCycleCount.CapturedWeight       = capturedWeight;
                    _currentWorkLineCycleCount.CycleCountReconcile	= NoYes::Yes;
                    _currentWorkLineCycleCount.AcceptReject			= WHSAcceptReject::Accept;
                    _currentWorkLineCycleCount.CountingReasonCode   = pass.lookupStr(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode);

                    _currentWorkLineCycleCount.CycleCountCounted	= NoYes::No;
                    

                    _currentWorkLineCycleCount.update();
                }

                if (pass.hasValue(#LicensePlateId))
                {
                    // Break the parent/child relationship if necessary.
                    WHSLicensePlate::removeLPFromParentLPIfNecessary(pass.lookupStr(#LicensePlateId), 
                                                                    pass.lookupStr(#WMSLocationId), 
                                                                    pass.lookupStr(#InventLocationId));
                }

                ttscommit;
            }

            this.closeWorkLineForPartialLocationCountIfAllRelatedCycleCountWorkLinesAreCounted();

            ret = this.processFinishingStepThree(ret);
        }
        else
        {           
            ret = this.clearPassAndCycleCountQuantites(con, _totalQty);            
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFinishingStepThree</Name>
				<Source><![CDATA[
    private container processFinishingStepThree(container _ret)
    {
        container ret = _ret;
		
        WHSWorkLineCycleCount workLineCycleCount;

        workLineCycleCount = this.getNotCountedWorkLineCycleCount(workLine.WorkId);

        if (workLineCycleCount)
        {
            pass.insert(#RetryCounter, 0);

            if (this.shouldBuildFirstPassCycleCount(workLineCycleCount))
            {
                pass.remove(#ItemId);

                if (pass.exists(#FirstPassFail))
                {
                    pass.remove(#FirstPassFail);
                }

                this.cleanUpPass();
                this.updateCycleCountPass(workLineCycleCount);

                ret = this.buildFirstPassCycleCount(conNull());

                step = 6;

                return ret;
            }

            pass.remove(#ItemId);

            this.cleanUpPass();

            this.updateCycleCountPass(workLineCycleCount);
            ret = this.buildCycleCount(conNull());
            step = 2;
            if (pass.exists(#ItemId) && pass.lookup(#ItemId) != '')
            {
                step = 3;
            }
        }
        else
        {
            ret = this.buildLocationComplete();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldBuildFirstPassCycleCount</Name>
				<Source><![CDATA[
    private boolean shouldBuildFirstPassCycleCount(WHSWorkLineCycleCount _workLineCycleCount)
    {
        if (!WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).CycleCountFirstPass)
        {
            return false;
        }

        if (_workLineCycleCount.ItemId != pass.lookup(#ItemId))
        {
            return true;
        }

        if (pass.anyProductDimensionSpecified())
        {
            InventDim passProductInventDim = pass.initProductInventDimFromPass();
            InventDim workLineInventDim = InventDim::find(_workLineCycleCount.InventDimId);

            return !InventDim::isInventDimEqual(workLineInventDim, passProductInventDim, InventDim::dimProductDimensionEnabledFieldList());
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeStepFour</Name>
				<Source><![CDATA[
    private container executeStepFour(
		container	_ret,
        container	_con,
		str			_buttonClicked)
    {
        container ret = _ret;
        container con = _con;

        WHSRFMenuItemCycleCount rfMenuItemCycleCount = WHSRFMenuItemCycleCount::find(pass.lookup(#MenuItem));

        int numRetries = rfMenuItemCycleCount.NumRetries;

        if (numRetries == pass.lookupNum(#RetryCounter) || _buttonClicked == #RFAddLP)
        {
            if (_buttonClicked == #RFAddLP || !rfMenuItemCycleCount.BlindItem)
            {
                pass.remove(#ItemId);
                pass.remove(#ProductConfirmation);          
            }
            this.cleanUpPass();
        }
        if (pass.exists(#RFAddLP) && numRetries == pass.lookupNum(#RetryCounter) || _buttonClicked == #RFAddLP)
        {
            ret = this.buildCycleCount(conNull(), "@WAX1675", true);
            if (numRetries == pass.lookupNum(#RetryCounter))
            {
                pass.insert(#RetryCounter, pass.lookupNum(#RetryCounter) + 1);
            }
            return ret;
        }

        this.findOrCreateCycleCountWorkLines();

        container tmpFieldValues;

        [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
        WHSRFPassthrough fieldValues = WHSRFPassthrough::create(tmpFieldValues);
        pass = this.combineMaps(pass, fieldValues);
        boolean isPieceByPieceEnabled = this.canUsePieceByPieceConfirmation(pass.lookupStr(#MenuItem),
                                                                            workline.WorkType,
                                                                            pass.lookupStr(#ItemId));

        if (this.hasError(con))
        {
            step = conPeek(conPeek(con, 1), 2);

            if (step == 2)
            {
                pass.insert(#RetryCounter, 0);

                if (pass.exists(#RFAddLP))
                {
                    pass.remove(#RFAddLP);
                }
                ret = this.addErrorLabel(ret, "@WAX1677", WHSRFColorText::Error);
                ret = this.buildCycleCount(ret, '', true);
                return ret;
            }

            return con;
        }

        if (this.isLicensePlateMovementConfirmationNeeded())
        {
            con = this.buildLicensePlateMovementConfirmationScreen(ret);

            return con;
        }
		
		if (!pass.exists(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode)
                && rfMenuItemCycleCount.DisplayReasonCode == WHSDisplayCountingReasonCode::Line
                && this.canReasonCountingCodeControlBeBuilt(_buttonClicked))
		{
			return this.buildCycleCount(ret, '', false, _buttonClicked);
		}
		
        if (pass.exists(#RFAddLP))
		{
			this.removeCompletedPieceByPieceValues(isPieceByPieceEnabled);
			con = this.buildCycleCount(ret, "@WAX1675", true, _buttonClicked);
		}
		else
		{
			con = this.buildCycleCount(ret, '', true, _buttonClicked);
		}

        boolean complete;

        [ret, complete] = this.processFieldValues(con, fieldValues, _buttonClicked);

        if (complete && !pass.hasValue(#ExpDate) && this.showBatchExpDate())
        {
            complete = false;
        }

        if (!pass.exists(#RFAddLP))
        {
            if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).CycleCountFirstPass)
            {
                pass.insert(#FirstPassFail, 1);
            }

            pass.insert(#RetryCounter, 0);
            step = 3;
            return ret;
        }

        if (!complete
            && _buttonClicked == #RFFinished
            && !isPieceByPieceEnabled)
        {
            ret = this.executeStepFive(ret, con, _buttonClicked);
        }
       
        if (complete && (pass.exists(#CycleCountQty1)
                        || (isPieceByPieceEnabled
                            && _buttonClicked == #RFFinished
                            && pass.hasValue(WHSWorkExecuteDisplayPieceByPieceControls::CycleCountContainer))))
        {
            if (PdsGlobal::pdsIsCWItem(pass.lookup(#ItemId))
                && WHSInventTable::correctionWeightCapturingProcess(pass.lookup(#ItemId)) != WHSCountingWeightCapturingMethod::NotCaptured
                && WHSInventTable::cycleCountWeightCapturingMethod(pass.lookup(#ItemId)) == WHSCycleCountWeightCapturingMethod::PerCatchWeightUnit
                && !pass.hasValue(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight))
            {
                ret = this.buildWeightCapture(conNull());
                step = #CWOutboundWeightCapture;
                return ret;
            }

            ttsbegin;

            InventDim testInventDim = pass.createInventDimFromPass();

            // If Inventory status is not displayed need to resolve a default value.
            if (!pass.lookupStr(#InventoryStatus) && !WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).RFDisplayStatus)
            {
                this.addDefaultInventoryStatus(testInventDim);
                testInventDim = InventDim::findOrCreate(testInventDim);
            }

            WHSWorkLineCycleCount workLineCycleCount;

            select firstonly QtyExpected from workLineCycleCount
                where workLineCycleCount.WorkId         == workTable.WorkId
                    && workLineCycleCount.LineNum       == workLine.LineNum
                    && workLineCycleCount.ItemId        == pass.lookup(#ItemId)
                    && workLineCycleCount.InventDimId   == testInventDim.inventDimId;

            Qty totalQty = this.calculateTotalQty();

            if (workLineCycleCount.QtyExpected != totalQty)
            {
                this.validateCountingReasonCode(pass.lookup(#ItemId), testInventDim.inventDimId);
            }

            if (pass.exists(#LicensePlateId))
            {
                WHSLicensePlate::createLicensePlate(pass.lookup(#LicensePlateId));
            }

            ItemId currentItemId = pass.lookup(#ItemId);

            if (pass.lookupStr(#BatchId) && this.showBatchExpDate())
            {
                InventBatch inventBatch;
                inventBatch.ItemId        = currentItemId;
                inventBatch.InventBatchId = pass.lookupStr(#BatchId);

                this.initializeBatchDates(inventBatch);

                inventBatch.insert();
            }

            if (this.hasItemAlreadyBeenCounted(currentItemId, testInventDim))
            {
                throw error(strFmt("@WAX:ItemHasAlreadyBeenCounted", currentItemId));
            }

            if (WHSWorkUser::find(pass.lookupStr(#UserId)).WorkCountIsSupervisor
                && pass.hasValue(#LicensePlateId))
            {
                // Break the parent/child relationship if necessary.
                WHSLicensePlate::removeLPFromParentLPIfNecessary(pass.lookupStr(#LicensePlateId),
                                                                 pass.lookupStr(#WMSLocationId),
                                                                 pass.lookupStr(#InventLocationId));
            }

            WHSWorkLineCycleCount testWorkLineCycleCount = this.initializeCycleCountWorkline(currentItemId, testInventDim, totalQty);
            testWorkLineCycleCount.insert();

            ttscommit;

            workLineCycleCount = this.getNotCountedWorkLineCycleCount(workLine.WorkId);

            if (workLineCycleCount)
            {
                pass.insert(#RetryCounter, 0);

                if (workLineCycleCount.ItemId != currentItemId && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).CycleCountFirstPass)
                {
                    pass.remove(#ItemId);

                    if (pass.exists(#FirstPassFail))
                    {
                        pass.remove(#FirstPassFail);
                    }

                    this.cleanUpPass();
                    this.updateCycleCountPass(workLineCycleCount);

                    ret = this.buildFirstPassCycleCount(conNull());

                    step = 6;

                    return ret;
                }

                pass.remove(#ItemId);

                this.cleanUpPass();

                this.updateCycleCountPass(workLineCycleCount);
                ret = this.buildCycleCount(conNull());
                step = 2;
                if (pass.exists(#ItemId) && pass.lookup(#ItemId) != '')
                {
                    step = 3;
                }
            }
            else
            {
                ret = this.buildLocationComplete();
            }
        }
        else
        {
            ret = this.buildCycleCount(conNull(), "@WAX1675", true);
     
            [ret] = this.processFieldValues(ret, fieldValues);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeBatchDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes dates on the batch before it gets inserted.
    /// </summary>
    /// <param name = "_inventBatch">The new batch.</param>
    protected void initializeBatchDates(InventBatch _inventBatch)
    {
        if (pass.exists(#ExpDate))
        {
            _inventBatch.ExpDate = WHSRFControlData::convertDateFormatStr2Date(pass.lookup(#ExpDate), pass.lookupStr(#UserId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCycleCountWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new cycle count work line.
    /// </summary>
    /// <param name = "_itemId">The item number.</param>
    /// <param name = "_inventDim">The inventory dimension record.</param>
    /// <param name = "_totalCountedQuantity">The total counted quantity.</param>
    /// <returns>The new initialzed cycle count work line record.</returns>
    protected WHSWorkLineCycleCount initializeCycleCountWorkLine(
        ItemId      _itemId,
        InventDim   _inventDim,
        Qty         _totalCountedQuantity)
    {
        WHSWorkLineCycleCount workLineCycleCount;
        InventQty expectedQty;
        PdsCWInventQty expectedWeight;

        
        InventSumDateDimPhysical sumDateDimPhysical = InventSumDateDimPhysical::newParameters(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), _itemId, _inventDim, InventDimParm::allInventDim());
            
        if (PdsGlobal::pdsIsCWItem(_itemId)) 
        {
            expectedQty = sumDateDimPhysical.pdsCWPhysicalQuantity();
            expectedWeight = sumDateDimPhysical.physicalQuantity();
        }
        else
        {
            expectedQty = sumDateDimPhysical.physicalQuantity();
            expectedWeight = sumDateDimPhysical.pdsCWPhysicalQuantity();
        }

        workLineCycleCount.QtyCounted  = _totalCountedQuantity;
        workLineCycleCount.QtyExpected = expectedQty;
        workLineCycleCount.LocationLicensePlatePosition = pass.lookupInt64(WHSWorkExecuteDisplayLocationLicensePlatePositionControls::LocationLicensePlatePosition);

        if (PdsGlobal::pdsIsCWItem(_itemId))
        {
            workLineCycleCount.ExpectedWeight = expectedWeight;

            if (WHSInventTable::correctionWeightCapturingProcess(_itemId) == WHSCountingWeightCapturingMethod::NotCaptured)
            {
                workLineCycleCount.CapturedWeight = PdsCatchWeight::inventQty(_itemId, _totalCountedQuantity);
            }
            else
            {
                workLineCycleCount.CapturedWeight = pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight);
            }
        }

        if (WHSWorkUser::find(pass.lookupStr(#UserId)).WorkCountIsSupervisor)
        {
            workLineCycleCount.AdjustmentWorkId		= this.createAdjustmentWork(
            workLineCycleCount.QtyCounted - workLineCycleCount.QtyExpected,
            workLineCycleCount.CapturedWeight - workLineCycleCount.ExpectedWeight,
            _inventDim);
            
            workLineCycleCount.CycleCountReconcile	= NoYes::No;
            workLineCycleCount.AcceptReject			= WHSAcceptReject::Accept;
        }
        else
        {
            workLineCycleCount.CycleCountReconcile   = NoYes::Yes;
        }

        workLineCycleCount.WorkId				= workTable.WorkId;
        workLineCycleCount.LineNum				= workLine.LineNum;
        workLineCycleCount.ItemId				= _itemId;
        workLineCycleCount.CycleCountCounted	= NoYes::Yes;
        workLineCycleCount.InventDimId			= _inventDim.InventDimId;
        workLineCycleCount.CountingReasonCode   = pass.lookupStr(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode);

        return workLineCycleCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showBatchExpDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if mobile device should show batch expiry date.
    /// </summary>
    /// <returns>
    /// True if mobile device should show batch expiry date; otherwise false.
    /// </returns>
    private boolean showBatchExpDate()
    {
        if (   pass.hasValue(#ItemId)
            && pass.hasValue(#BatchId)
            && !InventBatch::exist(pass.lookupStr(#BatchId), pass.lookupStr(#ItemId))
            && (WHSRFMenuItemTable::getWHSWorkExecuteMode(WHSRFMenuItemTable::find(pass.lookup(#MenuItem))) != WHSWorkExecuteMode::SpotCycleCounting
                || (pass.exists(#UserId) && WHSWorkUser::find(pass.lookup(#UserId)).WorkCountIsSupervisor))
           )
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasItemAlreadyBeenCounted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if item has already been counted.
    /// </summary>
    /// <param name = "_itemId">The item number.</param>
    /// <param name = "_inventDim">The inventory dimension record.</param>
    /// <returns>true if the item has been counted; otherwise, false.</returns>
    protected boolean hasItemAlreadyBeenCounted(ItemId _itemId, InventDim _inventDim)
    {
        return WHSWorkLineCycleCount::exist(workTable.WorkId, workLine.LineNum, _itemId, _inventDim.InventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeStepFive</Name>
				<Source><![CDATA[
    private container executeStepFive(
        container	_ret,
        container	_con,
        str			_buttonClicked)
    {
        container ret = _ret;

        if (_buttonClicked != #RFCancel
            && _buttonClicked != #RFFinished // In case when Finished button is clicked after counting has been completed, counting reason code should not be validated.
            && this.canReasonCountingCodeControlBeBuilt(_buttonClicked))
        {
            this.validateCountingReasonCode(pass.lookup(#ItemId), this.getInventDimId());
        }

        if (!pass.exists(#RFFinished) && _buttonClicked != #RFCancel)
        {
            ttsbegin;
   
            WHSWorkUser workUser = WHSWorkUser::find(pass.lookupStr(#UserId));

            WHSWorkLineCycleCount workLineCycleCount = this.finishWorkLineCycleCount();

            boolean cyclyCountCheckWorkLimitFlightEnabled = WHSCycleCountCheckWorkLimitPerLineFlight::instance().isEnabled();

            while (workLineCycleCount.RecId != 0)
            {
                Qty totalQty = this.calculateTotalQty();
                workLineCycleCount.CycleCountReconcile = NoYes::Yes;
                workLineCycleCount.CountingReasonCode  = pass.lookupStr(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode);

                if (!workLineCycleCount.CountingReasonCode &&
                    totalQty != workLineCycleCount.QtyExpected)
                {
                    pass.insert(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode, WHSRFMenuItemCycleCount::find(pass.parmMenuItem()).DefaultCountingReasonCode);
                    workLineCycleCount.CountingReasonCode = pass.lookupStr(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode);
                }

                if (workUser.WorkCountIsSupervisor
                    || (cyclyCountCheckWorkLimitFlightEnabled
                        && !this.checkLimitFail(workUser, workLineCycleCount, pass.createInventDimFromPass(), totalQty)))
                {
                    InventDim workLineCycleCountInventDim = InventDim::find(workLineCycleCount.InventDimId);

                    workLineCycleCount.AdjustmentWorkId = this.createAdjustmentWork(
                            -workLineCycleCount.QtyExpected,
                            -workLineCycleCount.ExpectedWeight,
                            workLineCycleCountInventDim,
                            workLineCycleCount.ItemId,
                            workLineCycleCountInventDim.LicensePlateId);
                    
                    workLineCycleCount.CycleCountReconcile	= NoYes::No;
                    workLineCycleCount.CycleCountCounted	= NoYes::Yes;
                    workLineCycleCount.AcceptReject			= WHSAcceptReject::Accept;   

                    if (pass.hasValue(#LicensePlateId))
                    {
                        // Break the parent/child relationship if necessary.
                        WHSLicensePlate::removeLPFromParentLPIfNecessary(pass.lookupStr(#LicensePlateId),
                                                                        pass.lookupStr(#WMSLocationId),
                                                                        pass.lookupStr(#InventLocationId));
                    }
                }

                workLineCycleCount.update();

                next workLineCycleCount;
            }         
            this.closeWorkLineForPartialLocationCountIfAllRelatedCycleCountWorkLinesAreCounted();

            ttscommit;

            workLineCycleCount = this.getNotCountedWorkLineCycleCount(workLine.WorkId);

            if (workLineCycleCount)
            {
                pass.insert(#RetryCounter, 0);

                if (workLineCycleCount.ItemId != pass.lookup(#ItemId) && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).CycleCountFirstPass)
                {
                    pass.remove(#ItemId);

                    if (pass.exists(#FirstPassFail))
                    {
                        pass.remove(#FirstPassFail);
                    }

                    this.cleanUpPass();
                    this.updateCycleCountPass(workLineCycleCount);

                    ret = this.buildFirstPassCycleCount(conNull());

                    step = 6;

                    return ret;
                }

                pass.remove(#ItemId);

                this.cleanUpPass();

                this.updateCycleCountPass(workLineCycleCount);

                ret = this.buildCycleCount(conNull());

                step = 2;

                if (pass.exists(#ItemId) && pass.lookup(#ItemId) != '')
                {
                    step = 3;
                }
            }
            else
            {
                ret = this.buildLocationComplete();
            }
        }
        else
        {
            if (_buttonClicked != #RFCancel)
            {
                ttsbegin;

                WHSWorkLine newWorkLine = WHSWorkLine::find(workLine.WorkId, workLine.LineNum, true);

                if (newWorkLine)
                {
                    newWorkLine.updateStatus(WHSWorkStatus::Closed);
                    newWorkLine.WorkClosedUTCDateTime = DateTimeUtil::utcNow();
                    newWorkLine.update();
                }

                if (this.isPartialLocationCount())
                {
                    this.processPartialLocationCountWorkHeaderClosing();
                }

				else
                {
                    this.processFullLocationCountWorkHeaderClosing();
                }

                ttscommit;
            }

            ret		= this.addErrorLabel(conNull(), "@WAX866", WHSRFColorText::Success);
            step	= 1;

            WHSRFMenuItemTable menuItemTable = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));
            var userSession = WHSWorkUserSession::find(pass.parmUserId());
            var sessionState = userSession.sessionState();

            // If executing an immediate count due to a threshold, must get back into the appropriate RF flow.
            if (sessionState.parmPrevPass() != conNull())
            {
                mode = WHSRFMenuItemTable::getWHSWorkExecuteMode(menuItemTable);
                step = pass.lookup(#PrevCountStep);
                pass = WHSRFPassthrough::create(sessionState.parmPrevPass());
                WHSWorkUserSession::clearPrevPass(pass.parmUserId());

                if (mode == WHSWorkExecuteMode::PickPack)
                {
                    ret = conNull();

                    if (!this.checkForPickPackWork(pass.lookup(#TargetWorkId)))
                    {
                        ret = this.addErrorLabel(ret, "@WAX2875", WHSRFColorText::Success);
                    }

                    ret = this.buildGetWorkId(ret);
                    ret = this.addDoneButton(ret, true);
                    step = 3;

                    ret = this.updateModeStepPass(ret, mode, step, pass);
                }
                else if (mode == WHSWorkExecuteMode::ClusterPicking || mode == WHSWorkExecuteMode::SystemDirectedClusterPicking)
                {
                    ret = this.updateModeStepPass(ret, mode, step, pass);
                    WHSWorkExecuteDisplay workExecuteDisplay = WHSWorkExecuteDisplay::construct(mode);
                    workExecuteDisplay.setGlobals(mode, step, pass.lookup(#UserId), pass);
                    ret = workExecuteDisplay.displayForm(ret, #RFDone);
                }
                else if (mode == WHSWorkExecuteMode::MovementByTemplate)
                {
                    ret = this.getFormStateAfterCycleCount(ret);
                }
                else if (mode == WHSWorkExecuteMode::UserDirected || mode == WHSWorkExecuteMode::SystemDirected)
                {
                    ret = this.getFormStateAfterCycleCount(ret);
                }
                else
                {
                    ret = this.getFormStateAfterCycleCount(ret);
                }

                this.initPassFromCurrentFormState(ret);

                return ret;
            }
            else if (menuItemTable.WorkCreationProcess == WHSWorkCreationProcess::SpotCycleCounting)
            {
                ret = this.buildLocationSelect(ret);
                ret = this.updateModeStepPass(ret, WHSWorkExecuteMode::SpotCycleCounting, step, pass);
            }
            else if (menuItemTable.MenuItemDirectedBy == WHSMenuItemDirectedBy::CycleCountGrouping)
            {
                ret = this.updateModeStepPass(ret, WHSWorkExecuteMode::CycleCountGrouping, step, pass);
            }
            else
            {
                ret  = this.buildGetWorkIdLicensePlateId(ret);
                ret  = this.updateModeStepPass(ret, WHSWorkExecuteMode::UserDirected, step, pass);
            }

            str prevGroupingValue, prevWork;

            if (WHSCycleCountKeepWorkListGroupingValueFlight::instance().isEnabled() && pass.exists(WHSWorkExecuteDisplayListWorkControls::WorkListGroupingFieldValue))
            {
                prevGroupingValue = pass.lookupStr(WHSWorkExecuteDisplayListWorkControls::WorkListGroupingFieldValue);
                prevWork = pass.lookupStr(#WorkId);
            }

            pass = this.resetPassthrough(ret, false);
            pass.insert(#WorkComplete, 1);

            if (prevGroupingValue)
            {
                pass.insert(WHSWorkExecuteDisplayListWorkControls::WorkListGroupingFieldValue, prevGroupingValue);
                pass.insert(#PrevWorkId, prevWork);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLimitFail</Name>
				<Source><![CDATA[
    private boolean checkLimitFail(
        WHSWorkUser             _workUser, 
        WHSWorkLineCycleCount   _currentWorkLineCycleCount,
        InventDim               _inventDim,
        Qty                     _totalQty)
    {
        Qty absoluteDifferenceInCountedQuantity = abs(_totalQty - _currentWorkLineCycleCount.QtyExpected);

        boolean failLimit;

        if (absoluteDifferenceInCountedQuantity > _workUser.WorkCountMaxQty)
        {
            failLimit = true;
        }
        else if ((absoluteDifferenceInCountedQuantity * InventTable::find(_currentWorkLineCycleCount.ItemId).costPcsPrice('', _inventDim)) > _workUser.WorkCountMaxValue)
        {
            failLimit = true;
        }
        else if (_currentWorkLineCycleCount.QtyExpected && (absoluteDifferenceInCountedQuantity / _currentWorkLineCycleCount.QtyExpected) * 100 > _workUser.WorkCountMaxPercent)
        {
            failLimit = true;
        }

        return failLimit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAdjustmentWork</Name>
				<Source><![CDATA[
    private WHSAdjustmentWorkId createAdjustmentWork(
		Qty					_totalQty,
        WHSCapturedWeight   _totalWeight,
        InventDim			_currentInventDim,
        ItemId				_currentItemId		= pass.lookup(#ItemId),
        WHSLicensePlateId	_licensePlateId		= pass.lookupStr(#LicensePlateId))
    {
        WHSInventAdjustmentCreateParameters params;
        
        using (var activityContext = this.instrumentationLogger().workExecuteSpotCycleCount().creationOfAdjustmentWork())
        {
            if (WHSInventTable::correctionWeightCapturingProcess(_currentItemId) == WHSCountingWeightCapturingMethod::NotCaptured)
            {
                params = this.initInventAdjustmentCreateParams(_currentItemId, _currentInventDim, _totalQty, _licensePlateId);
            }
            else
            {
                params = this.initInventAdjustmentCreateParamsWithWeight(_currentItemId, _currentInventDim, _totalQty, _totalWeight, _licensePlateId);
            }

            WHSInventAdjustmentCreate createAdj = WHSInventAdjustmentCreate::newFromParams(params);
            createAdj.run();
            return createAdj.createdWorkId();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventAdjustmentCreateParams</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes parameters for inventory adjustment.
    /// </summary>
    /// <param name = "_itemId">The item for which inventory adjustment parameter initialized.</param>
    /// <param name = "_inventDim">The inventory dimensions for the item.</param>
    /// <param name = "_adjustmentQty">The number of units of the item.</param>
    /// <param name = "_licensePlateId">The license plate id for item.</param>
    /// <returns>The initialized <c>WHSInventAdjustmentCreateParameters</c> object.</returns>
    protected WHSInventAdjustmentCreateParameters initInventAdjustmentCreateParams(
        ItemId				_itemId,
        InventDim			_inventDim,
        Qty					_adjustmentQty,
        WHSLicensePlateId	_licensePlateId)
    {
        WHSCapturedWeight averageAdjustmentWeight = 0;

        if (PdsGlobal::pdsIsCWItem(_itemId))
        {
            InventOnHandQty inventOnHandQty = InventOnHandQty::newParameters(_itemId,  _inventDim);
            
            if (inventOnHandQty.pdsCWPhysicalInvent() > 0)
            {
                averageAdjustmentWeight = WHSCatchWeightHelper::calculateAverageWeight(_adjustmentQty, 
                                                                                        inventOnHandQty.pdsCWPhysicalInvent(), 
                                                                                        inventOnHandQty.physicalInvent(), 
                                                                                        InventTable::inventDecimals(_itemId));
            }
            else
            {
                averageAdjustmentWeight = PdsCatchWeightItem::find(_itemId).nominalQty() * _adjustmentQty;
            }
        }

        WHSInventAdjustmentCreateParameters params = this.initInventAdjustmentCreateParamsWithWeight(_itemId, _inventDim, _adjustmentQty, averageAdjustmentWeight, _licensePlateId);
        return params;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventAdjustmentCreateParamsWithWeight</Name>
				<Source><![CDATA[
    private WHSInventAdjustmentCreateParameters initInventAdjustmentCreateParamsWithWeight(
        ItemId				_itemId,
        InventDim			_inventDim,
        Qty					_adjustmentQty,
        WHSCapturedWeight   _adjustmentWeight,
        WHSLicensePlateId	_licensePlateId)
    {
        WHSInventAdjustmentCreateParameters params = WHSInventAdjustmentCreateParameters::construct();

        params.WorkUserId				                    = pass.lookup(#UserId);
        params.ItemId					                    = _itemId;
        params.InventDim				                    = _inventDim;
        params.AdjustmentQty			                    = _adjustmentQty;
        params.AdjustmentUnit                               = WHSCatchWeightHelper::inventHandlingUnitId(_itemId);
        params.AdjustmentCatchWeight                        = _adjustmentWeight;
        params.WmsLocationId			                    = pass.lookup(#WMSLocationId);
        params.InventLocationId			                    = pass.lookup(#InventLocationId);
        params.AdjustmentTypeCode		                    = WHSParameters::find().CycleCountAdjustmentTypeCode;
        params.LicensePlateId			                    = _licensePlateId;
        params.WorkTransType			                    = WHSWorkTransType::CycleCountAccepted;
        params.WorkType					                    = WHSWorkType::Count;
        params.WorkCreatedBy			                    = WHSWorkUser::getWorkerEmployeeRecId(params.WorkUserId);
        params.InventCountingReasonCode                     = pass.lookupStr(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode);
        params.SkipLocationLicensePlatePositionSequencing   = true;

        return params;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeStepSix</Name>
				<Source><![CDATA[
    private container executeStepSix(
		container	_ret,
		container	_con,
		int			_initialStep)
    {
        container ret = _ret;
        container con = _con;

        WHSWorkLineCycleCount workLineCycleCount = this.findOrCreateCycleCountWorkLines();

        this.updateCycleCountPass(workLineCycleCount);

        if (workLineCycleCount.RecId == 0)
        {
            return this.buildLocationComplete();
        }

        ret = this.buildFirstPassCycleCount(ret);

        if (_initialStep < step)
        {
            return ret;
        }

        container tmpFieldValues;

        [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
        WHSRFPassthrough fieldValues = WHSRFPassthrough::create(tmpFieldValues);
        
        if (!this.isItemWorkLineCycleCountNotCreated(fieldValues.parmItemId()))
        {
            throw error(strFmt("@WAX:WHSItemWorkLineCycleCountNotCreatedError", pass.lookupStr(#WMSLocationId), fieldValues.parmItemId()));
        }

        pass = this.combineMaps(pass, fieldValues);
        if (this.hasError(con))
        {
            return con;
        }

        boolean isPieceByPieceEnabled = this.canUsePieceByPieceConfirmation(pass.lookupStr(#MenuItem),
                                                                            workline.WorkType,
                                                                            pass.lookupStr(#ItemId));
        
        this.removeCompletedPieceByPieceValues(isPieceByPieceEnabled);

        con = this.buildFirstPassCycleCount(conNull());
        str     buttonClicked = this.getButtonClicked(_con);
        boolean complete;

        [ret, complete] = this.processFieldValues(con, fieldValues, buttonClicked);

        if (complete 
        &&  (pass.exists(#CycleCountQty1)
        ||   (isPieceByPieceEnabled
        &&    buttonClicked == #RFFinished)))
        {
            Qty totalQty = this.calculateTotalQty();

            InventDimParm	inventDimParm;
            InventDim		prodInventDim;

            inventDimParm.setAllProductDimensions();
            pass.initInventDimFromPassParm(prodInventDim, inventDimParm);

            boolean anyProductDimensionSpecified = prodInventDim.anyProductDimensionSpecified();
                    
            InventDim inventDimTemp;

            WHSWorkLineCycleCount testWorkLineCycleCount;

            if (anyProductDimensionSpecified)
            {
                inventDimParm.initProductDimensionsAllGroups();

                select sum(QtyExpected) from testWorkLineCycleCount
					where testWorkLineCycleCount.WorkId     == workLine.WorkId
						&& testWorkLineCycleCount.LineNum	== workLine.LineNum
						&& testWorkLineCycleCount.ItemId    == pass.lookup(#ItemId)
					#InventDimExistsJoinNoField(testWorkLineCycleCount.InventDimId, inventDimTemp, prodInventDim, inventDimParm);
            }
            else
            {
                select sum(QtyExpected) from testWorkLineCycleCount
					where testWorkLineCycleCount.WorkId		== workLine.WorkId
						&& testWorkLineCycleCount.LineNum	== workLine.LineNum
						&& testWorkLineCycleCount.ItemId	== pass.lookup(#ItemId);
            }

            if (totalQty == testWorkLineCycleCount.QtyExpected)
            {
                ttsbegin;

                testWorkLineCycleCount.clear();

                this.updateWorkLineCycleCountAccepted(testWorkLineCycleCount, inventDimTemp, prodInventDim, inventDimParm);

                RecordInsertList inventCountJourList = new RecordInsertList(tableNum(InventCountJour));

                if (anyProductDimensionSpecified)
                {
                    while select testWorkLineCycleCount
						where testWorkLineCycleCount.WorkId		== workLine.WorkId
							&& testWorkLineCycleCount.LineNum	== workLine.LineNum
							&& testWorkLineCycleCount.ItemId	== pass.lookup(#ItemId)
						#InventDimExistsJoinNoField(testWorkLineCycleCount.InventDimId, inventDimTemp, prodInventDim, inventDimParm)
                    {
                        // Update counting history records.
                        InventCountJour inventCountJour;
                        inventCountJour.initFromWHSWorkLineCycleCount(testWorkLineCycleCount);
                        inventCountJourList.add(inventcountjour);
                    }
                }
                else
                {
                    while select testWorkLineCycleCount
						where testWorkLineCycleCount.WorkId		== workLine.WorkId
							&& testWorkLineCycleCount.LineNum	== workLine.LineNum
							&& testWorkLineCycleCount.ItemId	== pass.lookup(#ItemId)
                    {
                        // Update counting history records.
                        InventCountJour inventCountJour;
                        inventCountJour.initFromWHSWorkLineCycleCount(testWorkLineCycleCount);
                        inventCountJourList.add(inventcountjour);
                    }
                }

                inventCountJourList.insertDatabase();

				this.closeWorkLineForPartialLocationCountIfAllRelatedCycleCountWorkLinesAreCounted();

                ttscommit;

                workLineCycleCount = this.getNotCountedWorkLineCycleCount(workLine.WorkId);

                if (workLineCycleCount)
                {
                    pass.insert(#RetryCounter, 0);

                    pass.remove(#ItemId);
                    
                    if (pass.exists(#ProductConfirmation))
                    {
                        pass.remove(#ProductConfirmation);
                    }

                    this.cleanUpPass();

                    this.updateCycleCountPass(workLineCycleCount);
                    ret = this.buildFirstPassCycleCount(conNull());
                }
                else
                {
                    ret = this.buildLocationComplete();
                }
            }
            else
            {
                int numRetries = WHSRFMenuItemCycleCount::find(pass.lookup(#MenuItem)).NumRetries;

                if (pass.exists(#CurrentQty)
					&& pass.lookupNum(#RetryCounter) == numRetries
					&& totalQty != pass.lookupNum(#CurrentQty))
                {
                    pass.insert(#RetryCounter, pass.lookupNum(#RetryCounter) - 1);
                }

                InventTable inventTable = InventTable::find(pass.lookup(#ItemId));
                boolean shouldRetryAndBuildCycleCount = pass.lookupNum(#RetryCounter) >= numRetries
                        || (inventTable.isProductVariantUnitConversionEnabled() && pass.lookupNum(#RetryCounter) > numRetries);

                if (shouldRetryAndBuildCycleCount)
                {
                    ret = this.retryAndBuildCycleCount(workLineCycleCount, totalQty);
                }
                else
                {                    
                    ret = this.clearPassAndCycleCountQuantites(con, totalQty);                                        
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPassAndCycleCountQuantites</Name>
				<Source><![CDATA[
    private container clearPassAndCycleCountQuantites(container _con, Qty _totalQty)
    {
        if (pass.exists(WHSWorkExecuteDisplayPieceByPieceControls::CycleCountContainer))
        {
            pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::CycleCountContainer);
            pass.insert(WHSWorkExecuteDisplayPieceByPieceControls::LastCycleCount, _totalQty);
        }

        pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight);

        container ret = this.clearCycleCountQuantities(_con);

        pass.insert(#CurrentQty, _totalQty);
        pass.insert(#RetryCounter, pass.lookupNum(#RetryCounter) + 1);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLocationComplete</Name>
				<Source><![CDATA[
    private container buildLocationComplete()
    {
        container ret;
        pass.insert(#RFFinished, 1);
            
        if (this.isPartialLocationCount())
        {
            ret = this.buildFinish(conNull());
        }
        else
        {
            ret = this.buildAddLPOrFinish(conNull());
        }

        return this.updateModeStepPassForCycleCount(ret);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemWorkLineCycleCountNotCreated</Name>
				<Source><![CDATA[
    private boolean isItemWorkLineCycleCountNotCreated(ItemId _itemId)
    {
        boolean ret = true;

        if (_itemId != '')
        {
            WHSWorkLineCycleCount existingWorkLineCycleCount;
            select firstonly RecId from existingWorkLineCycleCount
                where existingWorkLineCycleCount.WorkId == pass.lookup(#WorkId)
                    && existingWorkLineCycleCount.ItemId == _itemId;
                
            if (!existingWorkLineCycleCount)
            {
                ret = false;
            } 
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkLineCycleCountAccepted</Name>
				<Source><![CDATA[
    protected void updateWorkLineCycleCountAccepted(
        WHSWorkLineCycleCount _workLineCycleCount,
        InventDim             _inventDimTemp, 
        InventDim             _prodInventDim, 
        InventDimParm         _inventDimParm)
    {
        if (_prodInventDim.anyProductDimensionSpecified())
        {
            update_recordset _workLineCycleCount
                setting
                    QtyCounted			= _workLineCycleCount.QtyExpected,
                    CycleCountCounted	= NoYes::Yes,
                    AcceptReject		= WHSAcceptReject::Accept,
                    CountingReasonCode  = pass.lookupStr(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode),
                    LocationLicensePlatePosition = pass.lookupInt64(WHSWorkExecuteDisplayLocationLicensePlatePositionControls::LocationLicensePlatePosition)
                where _workLineCycleCount.WorkId		== workLine.WorkId
                    && _workLineCycleCount.LineNum	    == workLine.LineNum
                    && _workLineCycleCount.ItemId	    == pass.lookup(#ItemId)
                #InventDimExistsJoinNoField(_workLineCycleCount.InventDimId, _inventDimTemp, _prodInventDim, _inventDimParm);
        }
        else
        {
            update_recordset _workLineCycleCount
                setting
                    QtyCounted			= _workLineCycleCount.QtyExpected,
                    CycleCountCounted	= NoYes::Yes,
                    AcceptReject		= WHSAcceptReject::Accept,
                    CountingReasonCode  = pass.lookupStr(WHSWorkExecuteDisplayCycleCountControls::CountingReasonCode),
                    LocationLicensePlatePosition = pass.lookupInt64(WHSWorkExecuteDisplayLocationLicensePlatePositionControls::LocationLicensePlatePosition)
                where _workLineCycleCount.WorkId		== workLine.WorkId
                    && _workLineCycleCount.LineNum	    == workLine.LineNum
                    && _workLineCycleCount.ItemId	    == pass.lookup(#ItemId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retryAndBuildCycleCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retries and build cycle count for incorrect counting.
    /// </summary>
    /// <param name = "_workLineCycleCount"> A <c>WHSWorkLineCycleCount</c> record used to initialize counting history fields.</param>
    /// <param name = "_totalQty">The total count quantity.</param>
    /// <returns>Controls for next form to display.</returns>
    protected container retryAndBuildCycleCount(WHSWorkLineCycleCount _workLineCycleCount, Qty _totalQty)
    {       
        pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::CycleCountContainer);
        pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::LastCycleCount);        
        this.cleanUpPassCycleCountQuantities();
        pass.insert(#FirstpassFail, 1);
        pass.insert(#RetryCounter, 0);
        container ret = this.buildCycleCount(conNull());
        step = 3;
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPassValuesForEnabledFields</Name>
				<Source><![CDATA[
    private void clearPassValuesForEnabledFields(container _con, WHSRFPassthrough _fieldValues)
    {
        int length = conLen(_con);

        for (int i = 1; i <= length; ++i)
        {
            container controlCon = conPeek(_con, i);
            str controlType = conPeek(controlCon, #controlType);

            if (controlType == #RFText
                || controlType == #RFPassword)
            {
                str name = conPeek(controlCon, #name);

                if (_fieldValues.exists(name))
                {
                    str value   = _fieldValues.lookup(name);
                    int enabled = conPeek(controlCon, #enabled);

                    if (value && enabled && pass.exists(name))
                    {
                        pass.remove(name);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeStepSeven</Name>
				<Source><![CDATA[
    /// <summary>
    /// Step executed right after LP movement confirmation is displayed.
    /// </summary>
    /// <param name = "_ret">container in which new state is stored.</param>
    /// <param name = "_con">container with current state.</param>
    /// <param name = "_buttonClicked">button that caused execute of 7th step.</param>
    /// <returns>updated _ret container that containing new display.</returns>
    private container executeStepSeven(
        container	_ret,
        container	_con,
        str			_buttonClicked)
    {

        if (_buttonClicked == #RFYes)
        {
            pass.insert(WHSWorkExecuteDisplayLicensePlateMovementConfirmationConstants::State, WHSWorkExecuteDisplayLicensePlateMovementConfirmationConstants::Confirmed);

            // processData and move the LP to the location that is being counted
            WHSRFControlData::processData(_con, pass);
            
            // proceed to "normal" cycle count now when LP is moved to the location.
            if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).CycleCountFirstPass)
            {
                step = 6;
            }
            else
            {
                step = 3;
            }

            WHSWorkLineCycleCount workLineCycleCount = this.getNotCountedWorkLineCycleCount(workLine.WorkId);

            if (workLineCycleCount)
            {
                this.updateCycleCountPass(workLineCycleCount);
            }
        }
        else
        {
            // User had decided that they don't want to move LP to the new location. 
            // LP & tag that suggest confirmation is needed are therefore removed.
            pass.remove(WHSWorkExecuteDisplayLicensePlateMovementConfirmationConstants::State);
            pass.remove(#LicensePlateId);

            // return to the previous step
            step = pass.lookupNum(ReturnToStepKey);
        }
        
        return this.buildCycleCount(_ret);
    }

]]></Source>
			</Method>
			<Method>
				<Name>partialLocationCreateCycleCountWorkLines</Name>
				<Source><![CDATA[
    private WHSWorkLineCycleCount partialLocationCreateCycleCountWorkLines(boolean _isCatchWeightFeatureEnabled)
    {
        WHSWorkId                      workId = workTable.WorkId;
        WHSWorkLineCycleCount          workLineCycleCount;
        InventDim                      inventDim;
        PdsCatchWeightItem             catchWeightItem;
        WHSWorkLine                    localWorkLine;
        InventDim                      workLineInventDim;
        InventDimParm                  inventDimParmAll;
                
        inventDimParmAll.setAllInventDim();

        /*
        Insert into the WHSWorkLineCycleCount table all work lines that have some physical inventory
        in the InventSum and InventSumDelta. The InventSum and InventSumDelta records which
        have dimensions stamped, which are empty on the WorkLine table, are also included.
        */
        ttsbegin;

        if (InventUpdateOnhandGlobal::instance().inventUpdateOnhand().mustAddAnyInventSumDeltaOnhand())
        {
            InventSumUnionDeltaPhysicalQty inventSumUnionDeltas;

            if (_isCatchWeightFeatureEnabled)
            {
                insert_recordset workLineCycleCount (LineNum, WorkId, ItemId, QtyExpected, InventDimId)
					select LineNum, WorkId from localWorkLine
						where localWorkLine.WorkId == workId
							&& (localWorkLine.workStatus == WHSWorkStatus::Open
								|| localWorkLine.WorkStatus == WHSWorkStatus::InProcess)
					join ItemId, PhysicalInvent, InventDimId from inventSumUnionDeltas
						where inventSumUnionDeltas.PhysicalInvent > 0
							&& inventSumUnionDeltas.ItemId == localWorkLine.ItemId
					exists join workLineInventDim
						where workLineInventDim.InventDimId == localWorkLine.InventDimId
					exists join inventDim
						where inventDim.InventDimId == inventSumUnionDeltas.InventDimId
							&& #InventDimRanges(workLineInventDim, inventDim, inventDimParmAll, inventDimParmAll)
					notExists join catchWeightItem
						where catchWeightItem.ItemId == inventSumUnionDeltas.ItemId;

                insert_recordset workLineCycleCount (LineNum, WorkId, ItemId, QtyExpected, ExpectedWeight, InventDimId)
					select LineNum, WorkId from localWorkLine
						where localWorkLine.WorkId == workId
							&& (localWorkLine.workStatus == WHSWorkStatus::Open
								|| localWorkLine.WorkStatus == WHSWorkStatus::InProcess)
					join ItemId, PdsCWPhysicalInvent, PhysicalInvent, InventDimId from inventSumUnionDeltas
						where inventSumUnionDeltas.PdsCWPhysicalInvent > 0
							&& inventSumUnionDeltas.ItemId == localWorkLine.ItemId
					exists join workLineInventDim
						where workLineInventDim.InventDimId == localWorkLine.InventDimId
					exists join inventDim
						where inventDim.InventDimId == inventSumUnionDeltas.InventDimId
							&& #InventDimRanges(workLineInventDim, inventDim, inventDimParmAll, inventDimParmAll)
					exists join catchWeightItem
						where catchWeightItem.ItemId == inventSumUnionDeltas.ItemId;
            }
            else
            {
                // Kept as separate statements to avoid perf overhead when catch weight is not enabled.
                insert_recordset workLineCycleCount (LineNum, WorkId, ItemId, QtyExpected, InventDimId)
					select LineNum, WorkId from localWorkLine
						where localWorkLine.WorkId == workId
							&& (localWorkLine.workStatus == WHSWorkStatus::Open
								|| localWorkLine.WorkStatus == WHSWorkStatus::InProcess)
					join ItemId, PhysicalInvent, InventDimId from inventSumUnionDeltas
						where inventSumUnionDeltas.PhysicalInvent > 0
							&& inventSumUnionDeltas.ItemId == localWorkLine.ItemId
					exists join workLineInventDim
						where workLineInventDim.InventDimId == localWorkLine.InventDimId
					exists join inventDim
						where inventDim.InventDimId == inventSumUnionDeltas.InventDimId
							&& #InventDimRanges(workLineInventDim, inventDim, inventDimParmAll, inventDimParmAll);
            }
        }
		else
        {
            InventSum inventSum;

            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                if (_isCatchWeightFeatureEnabled)
                {
                    insert_recordset workLineCycleCount (LineNum, WorkId, ItemId, QtyExpected, InventDimId)
                        select LineNum, WorkId from localWorkLine
                            where localWorkLine.WorkId == workId
                                && (localWorkLine.workStatus == WHSWorkStatus::Open
                                    || localWorkLine.WorkStatus == WHSWorkStatus::InProcess)
                        join workLineInventDim
                            where workLineInventDim.InventDimId == localWorkLine.InventDimId
                        join ItemId, PhysicalInvent, InventDimId from inventSum
                            where inventSum.PhysicalInvent > 0
                                && inventSum.ClosedQty	== NoYes::No
                                && inventSum.ItemId		== localWorkLine.ItemId
                                && #InventDimRanges(workLineInventDim, inventSum, inventDimParmAll, inventDimParmAll)
                        notExists join catchWeightItem
                            where catchWeightItem.ItemId == inventSum.ItemId;

                    insert_recordset workLineCycleCount (LineNum, WorkId, ItemId, QtyExpected, ExpectedWeight, InventDimId)
                        select LineNum, WorkId from localWorkLine
                            where localWorkLine.WorkId == workId
                                && (localWorkLine.workStatus == WHSWorkStatus::Open
                                    || localWorkLine.WorkStatus == WHSWorkStatus::InProcess)
                        join workLineInventDim
                            where workLineInventDim.InventDimId == localWorkLine.InventDimId
                        join ItemId, PdsCWPhysicalInvent, PhysicalInvent, InventDimId from inventSum
                            where inventSum.PdsCWPhysicalInvent > 0
                                && inventSum.ClosedQty	== NoYes::No
                                && inventSum.ItemId		== localWorkLine.ItemId
                                && #InventDimRanges(workLineInventDim, inventSum, inventDimParmAll, inventDimParmAll)
                        exists join catchWeightItem
                            where catchWeightItem.ItemId == inventSum.ItemId;
                }
                else
                {
                    // Kept as separate statements to avoid perf overhead when catch weight is not enabled.
                    insert_recordset workLineCycleCount (LineNum, WorkId, ItemId, QtyExpected, InventDimId)
                        select LineNum, WorkId from localWorkLine
                            where localWorkLine.WorkId == workId
                                && (localWorkLine.workStatus == WHSWorkStatus::Open
                                    || localWorkLine.WorkStatus == WHSWorkStatus::InProcess)
                        join workLineInventDim
                            where workLineInventDim.InventDimId == localWorkLine.InventDimId
                        join ItemId, PhysicalInvent, InventDimId from inventSum
                            where inventSum.PhysicalInvent > 0
                                && inventSum.ClosedQty	== NoYes::No
                                && inventSum.ItemId		== localWorkLine.ItemId
                                && #InventDimRanges(workLineInventDim, inventSum, inventDimParmAll, inventDimParmAll);
                }
            }
            else
            {
                if (_isCatchWeightFeatureEnabled)
                {
                    insert_recordset workLineCycleCount (LineNum, WorkId, ItemId, QtyExpected, InventDimId)
                        select LineNum, WorkId from localWorkLine
                            where localWorkLine.WorkId == workId
                                && (localWorkLine.workStatus == WHSWorkStatus::Open
                                    || localWorkLine.WorkStatus == WHSWorkStatus::InProcess)
                        join ItemId, PhysicalInvent, InventDimId from inventSum
                            where inventSum.PhysicalInvent > 0
                                && inventSum.ClosedQty	== NoYes::No
                                && inventSum.ItemId		== localWorkLine.ItemId
                        exists join workLineInventDim
                            where workLineInventDim.InventDimId == localWorkLine.InventDimId
                        exists join inventDim
                            where inventDim.InventDimId == inventSum.InventDimId
                                && #InventDimRanges(workLineInventDim, inventDim, inventDimParmAll, inventDimParmAll)
                        notExists join catchWeightItem
                            where catchWeightItem.ItemId == inventSum.ItemId;

                    insert_recordset workLineCycleCount (LineNum, WorkId, ItemId, QtyExpected, ExpectedWeight, InventDimId)
                        select LineNum, WorkId from localWorkLine
                            where localWorkLine.WorkId == workId
                                && (localWorkLine.workStatus == WHSWorkStatus::Open
                                    || localWorkLine.WorkStatus == WHSWorkStatus::InProcess)
                        join ItemId, PdsCWPhysicalInvent, PhysicalInvent, InventDimId from inventSum
                            where inventSum.PdsCWPhysicalInvent > 0
                                && inventSum.ClosedQty	== NoYes::No
                                && inventSum.ItemId		== localWorkLine.ItemId
                        exists join workLineInventDim
                            where workLineInventDim.InventDimId == localWorkLine.InventDimId
                        exists join inventDim
                            where inventDim.InventDimId == inventSum.InventDimId
                                && #InventDimRanges(workLineInventDim, inventDim, inventDimParmAll, inventDimParmAll)
                        exists join catchWeightItem
                            where catchWeightItem.ItemId == inventSum.ItemId;
                }
                else
                {
                    // Kept as separate statements to avoid perf overhead when catch weight is not enabled.
                    insert_recordset workLineCycleCount (LineNum, WorkId, ItemId, QtyExpected, InventDimId)
                        select LineNum, WorkId from localWorkLine
                            where localWorkLine.WorkId == workId
                                && (localWorkLine.workStatus == WHSWorkStatus::Open
                                    || localWorkLine.WorkStatus == WHSWorkStatus::InProcess)
                        join ItemId, PhysicalInvent, InventDimId from inventSum
                            where inventSum.PhysicalInvent > 0
                                && inventSum.ClosedQty	== NoYes::No
                                && inventSum.ItemId		== localWorkLine.ItemId
                        exists join workLineInventDim
                            where workLineInventDim.InventDimId == localWorkLine.InventDimId
                        exists join inventDim
                            where inventDim.InventDimId == inventSum.InventDimId
                                && #InventDimRanges(workLineInventDim, inventDim, inventDimParmAll, inventDimParmAll);
                }
            }
        }

        ttscommit;

        return workLineCycleCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>nonPartialLocationCreateCycleCountWorkLines</Name>
				<Source><![CDATA[
    private WHSWorkLineCycleCount nonPartialLocationCreateCycleCountWorkLines(boolean _isCatchWeightFeatureEnabled)
    {
        WHSWorkId                      workId = workTable.WorkId;
        WHSWorkLineCycleCount          workLineCycleCount;
        InventDim                      inventDim;
        PdsCatchWeightItem             catchWeightItem;
        LineNum                        lineNum = workLine.LineNum;
        InventDim                      inventDimCriteria;

        inventDimCriteria.InventSiteId      = workTable.InventSiteId;
        inventDimCriteria.InventLocationId  = workTable.InventLocationId;
        inventDimCriteria.wmsLocationId     = workLine.wmsLocationId;

        InventDimParm inventDimParm;
        inventDimParm.initFromInventDim(inventDimCriteria);

        ttsbegin;

        if (InventUpdateOnhandGlobal::instance().inventUpdateOnhand().mustAddAnyInventSumDeltaOnhand())
        {
            InventSumUnionDeltaPhysicalQty inventSumUnionDeltas;

			if (_isCatchWeightFeatureEnabled)
			{
				insert_recordset workLineCycleCount (WorkId, LineNum, ItemId, QtyExpected, InventDimId)
					select workId, lineNum, ItemId, PhysicalInvent, InventDimId from inventSumUnionDeltas
						where inventSumUnionDeltas.PhysicalInvent	>  0
						#InventDimExistsJoin(inventSumUnionDeltas.InventDimId, inventDim, inventDimCriteria, inventDimParm)
						notExists join catchWeightItem
							where catchWeightItem.ItemId == inventSumUnionDeltas.ItemId;

				insert_recordset workLineCycleCount (WorkId, LineNum, ItemId, QtyExpected, ExpectedWeight, InventDimId)
					select workId, lineNum, ItemId, PdsCWPhysicalInvent, PhysicalInvent, InventDimId from inventSumUnionDeltas
						where inventSumUnionDeltas.PdsCWPhysicalInvent	>  0
						#InventDimExistsJoin(inventSumUnionDeltas.InventDimId, inventDim, inventDimCriteria, inventDimParm)
						exists join catchWeightItem
							where catchWeightItem.ItemId == inventSumUnionDeltas.ItemId;
			}
			else
			{
				// Kept as separate statements to avoid perf overhead when catch weight is not enabled.
				insert_recordset workLineCycleCount (WorkId, LineNum, ItemId, QtyExpected, InventDimId)
					select workId, lineNum, ItemId, PhysicalInvent, InventDimId from inventSumUnionDeltas
						where inventSumUnionDeltas.PhysicalInvent	>  0
						#InventDimExistsJoin(inventSumUnionDeltas.InventDimId, inventDim, inventDimCriteria, inventDimParm);
			}
        }
		else
        {
            InventSum inventSum;

            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                if (_isCatchWeightFeatureEnabled)
                {
                    insert_recordset workLineCycleCount (WorkId, LineNum, ItemId, QtyExpected, InventDimId)
                        select workId, lineNum, ItemId, PhysicalInvent, InventDimId from inventSum
                            where inventSum.PhysicalInvent	>  0
                                && inventSum.ClosedQty	== NoYes::No
                                && #InventDimFieldsFilter(inventSum, inventDimCriteria, inventDimParm)
                    notExists join catchWeightItem
                                    where catchWeightItem.ItemId == inventSum.ItemId;

                    insert_recordset workLineCycleCount (WorkId, LineNum, ItemId, QtyExpected, ExpectedWeight, InventDimId)
                            select workId, lineNum, ItemId, PdsCWPhysicalInvent, PhysicalInvent, InventDimId from inventSum
                                where inventSum.PdsCWPhysicalInvent	>  0
                                    && inventSum.ClosedQty	== NoYes::No
                                    && #InventDimFieldsFilter(inventSum, inventDimCriteria, inventDimParm)
                    exists join catchWeightItem
                                    where catchWeightItem.ItemId == inventSum.ItemId;
                }
                else
                {
                    // Kept as separate statements to avoid perf overhead when catch weight is not enabled.
                    insert_recordset workLineCycleCount (WorkId, LineNum, ItemId, QtyExpected, InventDimId)
                            select workId, lineNum, ItemId, PhysicalInvent, InventDimId from inventSum
                                where inventSum.PhysicalInvent	>  0
                                    && inventSum.ClosedQty	== NoYes::No
                                    && #InventDimFieldsFilter(inventSum, inventDimCriteria, inventDimParm);
                }
            }
            else
            {
                if (_isCatchWeightFeatureEnabled)
                {
                    insert_recordset workLineCycleCount (WorkId, LineNum, ItemId, QtyExpected, InventDimId)
                        select workId, lineNum, ItemId, PhysicalInvent, InventDimId from inventSum
                            where inventSum.PhysicalInvent	>  0
                                && inventSum.ClosedQty	== NoYes::No
                            #InventDimExistsJoin(inventSum.InventDimId, inventDim, inventDimCriteria, inventDimParm)
                    notExists join catchWeightItem
                                    where catchWeightItem.ItemId == inventSum.ItemId;

                    insert_recordset workLineCycleCount (WorkId, LineNum, ItemId, QtyExpected, ExpectedWeight, InventDimId)
                            select workId, lineNum, ItemId, PdsCWPhysicalInvent, PhysicalInvent, InventDimId from inventSum
                                where inventSum.PdsCWPhysicalInvent	>  0
                                    && inventSum.ClosedQty	== NoYes::No
                                #InventDimExistsJoin(inventSum.InventDimId, inventDim, inventDimCriteria, inventDimParm)
                    exists join catchWeightItem
                                    where catchWeightItem.ItemId == inventSum.ItemId;
                }
                else
                {
                    // Kept as separate statements to avoid perf overhead when catch weight is not enabled.
                    insert_recordset workLineCycleCount (WorkId, LineNum, ItemId, QtyExpected, InventDimId)
                            select workId, lineNum, ItemId, PhysicalInvent, InventDimId from inventSum
                                where inventSum.PhysicalInvent	>  0
                                    && inventSum.ClosedQty	== NoYes::No
                                #InventDimExistsJoin(inventSum.InventDimId, inventDim, inventDimCriteria, inventDimParm);
                }
            }
        }

        ttscommit;

        return workLineCycleCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWeightCapture</Name>
				<Source><![CDATA[
    private container buildWeightCapture(container _con)
    {
        container ret = _con;

        if (!pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
        {
            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, 1);
            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty, this.calculateTotalQty());
        }

        // Capturing weight per catch weight unit
        ret += [this.buildControl(#RFLabel, #Scan, "@WAX:CaptureWeight", 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFLabel, WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, strFmt("@SYS333411", pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter), pass.lookup(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty)), 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, pass.lookupStr(#ItemId), extendedTypeNum(InventInventItemSearchItem), '', 0, false)];

        ret = this.buildProductDimensionsText(ret, pass.lookupStr(#ItemId), true, false);

        ret += [this.buildControl(#RFLabel, #Qty, strFmt("@WAX736", 1, WHSCatchWeightHelper::inventHandlingUnitId(pass.lookupStr(#ItemId))), 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtyOutboundWeight, "@WAX:Weight", 1, pass.lookupStr(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtyOutboundWeight), extendedTypeNum(Weight), '', 0)];

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processWeightCapture</Name>
				<Source><![CDATA[
    private container processWeightCapture(container _con)
    {
        container           ret = _con;
        container           tmpFieldValues;
        WHSRFPassthrough    fieldValues = new WHSRFPassthrough(Types::String, Types::String);
        boolean             complete;

        if (this.hasError(_con))
        {
            ret = conDel(ret, #RFErrorLoc, 1);
        }

        [ret, tmpFieldValues] = WHSRFControlData::processData(ret, pass);
        fieldValues = WHSRFPassthrough::create(tmpFieldValues);
        pass = this.combineMaps(pass, fieldValues);

        if (this.hasError(ret))
        {
            return ret;
        }

        if (!fieldValues.empty())
        {
            [ret, complete] = this.processFieldValues(ret, fieldValues);

            if (complete)
            {
                pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, (pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter) + 1));

                // Increment total counting weight for counting quantity
                if (!pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight))
                {
                    pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight, pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtyOutboundWeight));
                }
                else
                {
                    pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight, (pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight) + pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtyOutboundWeight)));
                }

                pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtyOutboundWeight);

                // Check to see if weight has been captured for total quantity
                if (pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter) > pass.lookupInt64(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
                {
                    pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter);
                    pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty);

                    step = pass.exists(#RFAddLP) ? 4 : 3;

                    ret = conNull();
                    ret += [this.buildControl(#RFLabel, #Scan, "@WAX:CaptureWeight", 1, '', #WHSRFUndefinedDataType, '', 0)];
                    ret = this.updateModeStepPass(ret, mode, step, pass);
                    ret = this.displayForm(ret);
                }
                else
                {
                    ret = this.buildWeightCapture(conNull());
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustmentQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets adjustment quantity to perform inventory on-hand correction.
    /// </summary>
    /// <param name = "_totalQty">Total quantity.</param>
    /// <param name = "_workLineCycleCount">Cycle counting transaction.</param>
    /// <returns>Adjustment quantity.</returns>
    private Qty getAdjustmentQty(Qty _totalQty, WHSWorkLineCycleCount _workLineCycleCount)
    {
        Qty adjustmentQty;

        if (_workLineCycleCount.displayInventJournalId())
        {
            // Calculate adjustment quantity based on counted quantity because item was already counted and adjusted.
            adjustmentQty = _totalQty - _workLineCycleCount.QtyCounted;
        }
        else
        {
            adjustmentQty = _totalQty - _workLineCycleCount.QtyExpected;
        }

        return adjustmentQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustmentWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets adjustment weight to perform inventory on-hand correction.
    /// </summary>
    /// <param name = "_capturedWeight">Captured weight.</param>
    /// <param name = "_workLineCycleCount">Cycle counting transaction.</param>
    /// <returns>Adjustment weight.</returns>
    private WHSCapturedWeight getAdjustmentWeight(Qty _capturedWeight, WHSWorkLineCycleCount _workLineCycleCount)
    {
        WHSCapturedWeight adjustmentWeight;

        if (_workLineCycleCount.displayInventJournalId())
        {
            // Calculate adjustment weight based on captured weight because item was already captured and adjusted.
            adjustmentWeight = _capturedWeight - _workLineCycleCount.CapturedWeight;
        }
        else
        {
            adjustmentWeight = _capturedWeight - _workLineCycleCount.ExpectedWeight;
        }

        return adjustmentWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowStepThreeCorrectCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if quantity is not need to be adjusted and <c>processStepThreeCorrectCount</c> method need to be executed.
    /// </summary>
    /// <param name = "_totalQty">Total quantity.</param>
    /// <param name = "_workLineCycleCount">Cycle counting transaction.</param>
    /// <returns>True if quantity is not need to be adjusted and <c>processStepThreeCorrectCount</c> method need to be executed; Otherwise false.</returns>
    private boolean allowStepThreeCorrectCount(Qty _totalQty, WHSWorkLineCycleCount _workLineCycleCount)
    {
        if (_workLineCycleCount.displayInventJournalId())
        {
            return (_totalQty == _workLineCycleCount.QtyCounted);
        }
        else 
        {
            return (_totalQty == _workLineCycleCount.QtyExpected);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNotCountedWorkLineCycleCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets not counted cycle count work record by work ID.
    /// </summary>
    /// <param name = "_workId">Work ID.</param>
    /// <returns>Cycle count work record.</returns>
    private WHSWorkLineCycleCount getNotCountedWorkLineCycleCount(WHSWorkId _workId)
    {
        WHSWorkLineCycleCount workLineCycleCount;
            
        select firstonly workLineCycleCount
            where workLineCycleCount.WorkId					== _workId
                && workLineCycleCount.CycleCountCounted		== NoYes::No
                && workLineCycleCount.CycleCountReconcile	== NoYes::No;

        return workLineCycleCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPassFromCurrentFormState</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes form pass from the current state. Pass should be in sync with form state.
    /// </summary>
    /// <param name = "_ret">Container in which current state is stored.</param>
    private void initPassFromCurrentFormState(container	_ret)
    {
        pass = new WHSRFPassthrough(Types::String, Types::String);
        pass = WHSRFPassthrough::create(conpeek(_ret, 2));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFormStateAfterCycleCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets back into the appropriate RF flow after  immediate count due to a threshold.
    /// </summary>
    /// <param name = "_ret">Container in which current state is stored.</param>
    /// <returns>Container in which new state is stored.</returns>
    private container getFormStateAfterCycleCount(container _ret)
    {
        container ret = this.updateModeStepPass(_ret, mode, step, pass);
        WHSWorkExecuteDisplay workExecuteDisplay = WHSWorkExecuteDisplay::construct(mode);
        workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
        workExecuteDisplay.setGlobals(mode, step, pass.lookup(#UserId), pass, workLine);
        ret = workExecuteDisplay.displayForm(ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowShowSerialIdControl</Name>
				<Source><![CDATA[
    private boolean allowShowSerialIdControl(boolean _addNewInventory, WHSRFMenuItemCycleCount _menuItemCycleCount)
    {
        return !_addNewInventory
               && _menuItemCycleCount.BlindSerial;

    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>