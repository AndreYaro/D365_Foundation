<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailKitAssemblyOrder</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

/// <summary>
/// The <c>RetailKitAssemblyOrder</c> class is used for Retail Kit assembly and disassembly Order Processing based on Kit Configurations
/// </summary>
public class RetailKitAssemblyOrder
{
    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>initBOMJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the BOM journal record.
    /// </summary>
    /// <param name = "_journalSource">The source of the journal.</param>
    /// <returns>Returns the <c>InventJournalTable</c> record.</returns>
    private static InventJournalTable initBOMJournal(InventJournalSource _journalSource = '')
    {
        InventJournalTable journalTable;

        InventJournalTableData journalTableData = JournalTableData::newTable(journalTable);
        // Init JournalTable
        journalTable.clear();
        journalTable.initValue();
        journalTable.JournalId  = journalTableData.nextJournalId();
        journalTable.Source = _journalSource;
        journalTable.JournalType = InventJournalType::BOM;
        journalTable.JournalNameId = journalTableData.journalStatic().standardJournalNameId(enum2int(journalTable.JournalType));
        journalTableData.initFromJournalName(journalTableData.journalStatic().findJournalName(journalTable.JournalNameId));
        // set all other additional journal properties AFTER calls to .initFromJournalName() to avoid having them overwritten.
        journalTable.Reservation = ItemReservation::Automatic;
        return journalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBOMJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the BOM journal line record using the specified kit parameters.
    /// </summary>
    /// <param name = "journalTable"> The BOM journal <c>InventJournalTable</c> instance.</param>
    /// <param name = "_itemId"> The item Id of the kit or its components</param>
    /// <param name = "_quantity"> The quantity.</param>
    /// <param name = "_isBomLine"> Specifies whether the journal line is a BomLine or not.
    /// If the line is created for the kit item this is set to false.
    /// If the item represents a kit component this is set to true.</param>
    /// <param name = "inventDimId">The inventory dimension Id.</param>
    /// <returns>Returns the <c>InventJournalTrans</c> record.</returns>
    [HookableAttribute(true)]
    private static InventJournalTrans initBOMJournalLine(InventJournalTable journalTable, ItemId _itemId, Qty _quantity, boolean _isBomLine, InventDimId inventDimId)
    {
        InventJournalTrans journalTrans;
        RetailStoreTable retailStoreTable;
        
        // create a InventJournalTrans for the item
        journalTrans.clear();
        journalTrans.initValue();
        journalTrans.ItemId      = _itemId;
        journalTrans.bomLine     = _isBomLine;
        journalTrans.Qty         = _quantity;
        journalTrans.InventDimId = inventDimId;
        journalTrans.initFromInventJournalTable(journalTable);
            
        // initialize from Invent Table to ensure that financial dimensions are included.
        journalTrans.initFromInventTable(InventTable::find(journalTrans.ItemId), false, false, false);

        // Initialize store's financial dimension from inventLocation to the DefaultDimension.
        InventLocationId inventLocation = InventDim::find(inventDimId).InventLocationId;

        if (inventLocation)
        {
            select firstonly DefaultDimension from retailStoreTable
                where retailStoreTable.inventLocation == inventLocation
                   && retailStoreTable.inventLocationDataAreaId == curExt();

            if (retailStoreTable.DefaultDimension)
            {
                journalTrans.DefaultDimension = journalTrans.mergeDimension(retailStoreTable.DefaultDimension, journalTrans.DefaultDimension);
            }
        }

        journalTrans.setCostPrice(journalTrans.InventDimId, InventDim::find(inventDimId), journalTrans.inventTableModuleInvent());

        // If the item is component of a Kit set its InventTransIdFather
        if (_isBomLine)
        {
            // get the inventTransIdFather value from the kit (non-component) line in the BOM Journal
            InventJournalTrans kitJournalTrans;

            select InventTransId from kitJournalTrans
                    where !kitJournalTrans.BOMLine &&
                           kitJournalTrans.JournalId == journalTable.JournalId;

            journalTrans.InventTransIdFather = kitJournalTrans.InventTransId;
        }

        InventSite inventSite = InventDim::find(InventDimId).inventSite();

        if (InventParameters::find().MultiSiteDimensionLink == InventMultiSiteDimensionLink::Locked)
        {
            if (inventSite)
            {
                journalTrans.DefaultDimension = inventSite.DefaultDimension;
            }
        }
        else
        {
            journalTrans.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(journalTrans.DefaultDimension, inventSite.DefaultDimension);
        }

        return journalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateBOMJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates the BOM journal record using the specified kit parameters.
    /// </summary>
    /// <param name = "_retailKitOrder">
    /// The kit order to create.
    /// </param>
    /// <param name="_distinctProductVariantRecId">
    /// The kit variant to be processed.
    /// </param>
    /// <param name = "quantity">
    /// The ordered quantity.
    /// </param>
    /// <param name = "journalSource">
    /// The inventory journal source.
    /// </param>
    [Hookable(true), Wrappable(true)]
    final protected static void createOrUpdateBOMJournal(RetailKitOrder _retailKitOrder, EcoResDistinctProductVariantRecId _distinctProductVariantRecId, Qty quantity, InventJournalSource journalSource = '')
    {
        RetailKitOrderJournal       retailKitOrderJournal;
        InventJournalTable          journalTable;
        InventTable                 inventTableComp;            // kit component inventTable record
        InventDimCombination        inventDimCombinationKit;    // kit variant's inventdimcombination record
        InventDimCombination        inventDimCombinationComp;   // kit component inventdimcombination record
        InventTableModule           inventTableModule;          // kit components InventTableModule records
        RetailKitVariantComponent   retailKitVariantComponent;
        UnitOfMeasure               unitOfMeasure;
        Map                         quantityUpdate = new Map(Types::Int64, Types::Real);

        select forupdate retailKitOrderJournal
            where retailKitOrderJournal.RetailKitOrder == _retailKitOrder.RecId
                && retailKitOrderJournal.EcoResDistinctProductVariantID == _distinctProductVariantRecId;

        if (!quantity && retailKitOrderJournal)
        {
            retailKitOrderJournal.delete();
            return;
        }

        // for disassembly order multiply quantity by -1 as inventory has go down
        if (_retailKitOrder.OrderType == RetailKitOrderType::DisassemblyOrder)
        {
            quantity = -1.0 * quantity;
        }

        if (retailKitOrderJournal)
        {
            journalTable = InventJournalTable::find(retailKitOrderJournal.JournalId);

            retailKitOrderJournal.Quantity = quantity;
            retailKitOrderJournal.update();
        }
        else
        {
            journalTable = RetailKitAssemblyOrder::initBOMJournal(journalSource);
            journalTable.InventLocationId = _retailKitOrder.InventLocation;
            journalTable.InventSiteId = InventLocation::find(_retailKitOrder.InventLocation).InventSiteId;
            journalTable.validateWrite();
            journalTable.insert();
        }

        // Get inventdimcombination of the retail kit variant
        inventDimCombinationKit = InventDimCombination::findByDistinctProductVariant(_distinctProductVariantRecId);

        // Create a Bom journal line for the kit item
        RetailKitAssemblyOrder::createOrUpdateBOMJournalLine(journalTable, inventDimCombinationKit.ItemId, quantity, false, inventDimCombinationKit.inventDim(), _retailKitOrder.InventLocation);

        // Iterate through each VARIANT components of the kit variant and add a journal line for each kit component

        while select retailKitVariantComponent
            join inventDimCombinationComp
                where retailKitVariantComponent.KitVariant == inventDimCombinationKit.DistinctProductVariant &&
                      retailKitVariantComponent.Component  == inventDimCombinationComp.DistinctProductVariant
            join UnitId, ItemId from inventTableModule
            join RecId from unitOfMeasure
                where inventTableModule.ItemId     == inventDimCombinationComp.ItemId &&
                      inventTableModule.ModuleType == ModuleInventPurchSales::Invent &&
                      unitOfMeasure.Symbol         == inventTableModule.UnitId           // retrieves inventory unit of component
        {
            RetailKitAssemblyOrder::createOrUpdateBOMJournalLineForComponent(journalTable, retailKitVariantComponent, unitOfMeasure.RecId, inventDimCombinationComp.ItemId, inventDimCombinationComp.inventDim(), _retailKitOrder, quantity);
        }

        while select retailKitVariantComponent
            join inventTableComp
                where retailKitVariantComponent.KitVariant == inventDimCombinationKit.DistinctProductVariant &&
                      retailKitVariantComponent.Component  == inventTableComp.Product
            join UnitId from inventTableModule
            join RecId from unitOfMeasure
                where inventTableModule.ItemId       == inventTableComp.ItemId &&
                      inventTableModule.ModuleType   == ModuleInventPurchSales::Invent &&
                      unitOfMeasure.Symbol           == inventTableModule.UnitId           // retrieves inventory unit of component
        {
            InventDim inventDim = InventDim::findOrCreateBlank();
            inventDim.initFromInventTable(inventTableComp);

           // If there are multiple same componennt for kit against POS Transactions then summing the quantity.
            if (_retailKitOrder.OrderSource == RetailKitOrderSource::POS)
            {
                if (quantityUpdate.exists(retailKitVariantComponent.Component))
                {
                    retailKitVariantComponent.Quantity += quantity;
                }
                else
                {
                    quantityUpdate.insert(retailKitVariantComponent.Component, retailKitVariantComponent.Quantity);
                }
            }

            RetailKitAssemblyOrder::createOrUpdateBOMJournalLineForComponent(journalTable, retailKitVariantComponent, unitOfMeasure.RecId, inventTableComp.ItemId, InventDim::findOrCreate(inventDim), _retailKitOrder, quantity);
        }

        if (!retailKitOrderJournal)
        {
            journalTable.update();
            RetailKitOrderJournal::insertJournal(_distinctProductVariantRecId,
                                             _retailKitOrder.InventDataAreaId,
                                             journalTable.JournalId,
                                             quantity,
                                             _retailKitOrder.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateBOMJournalLineForComponent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates the BOM journal line for a component.
    /// </summary>
    /// <param name = "_journalTable">The journal header.</param>
    /// <param name = "_retailKitVariantComponent">The component to create the line for.</param>
    /// <param name = "_unitOfMeasure">The inventory unit of measure</param>
    /// <param name = "_itemId">The id of the item.</param>
    /// <param name = "_inventDim">The dimension of the item.</param>
    /// <param name = "_retailKitOrder">The kit order</param>
    /// <param name = "_quantity">The ordered quantity.</param>
    protected static void createOrUpdateBOMJournalLineForComponent(
        InventJournalTable          _journalTable,
        RetailKitVariantComponent   _retailKitVariantComponent,
        UnitOfMeasureRecId          _unitOfMeasureRecId,
        ItemId                      _itemId,
        InventDim                   _inventDim,
        RetailKitOrder              _retailKitOrder,
        Qty                         _quantity)
    {
        // If the unit of measure is not the default inventory unit of the item recalculate the quantity
        Qty componentTotalQty = -1 * EcoResProductUnitConverter::convertForReleasedProduct(
                 _itemId,
                 _inventDim.InventDimId,
                 _retailKitVariantComponent.Quantity * _quantity,
                 _retailKitVariantComponent.UnitOfMeasure,
                 _unitOfMeasureRecId,
                 NoYes::Yes);

        RetailKitAssemblyOrder::createOrUpdateBOMJournalLine(_journalTable, _itemId, componentTotalQty, true, _inventDim, _retailKitOrder.InventLocation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateBOMJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates the BOM journal line with specified parameters.
    /// </summary>
    /// <param name = "journalTable">
    /// The <c>InventJournalTable</c> record.
    /// </param>
    /// <param name = "_itemId">
    /// The item Id of the kit or its components.
    /// </param>
    /// <param name = "quantity">
    /// Specifies the quantity.
    /// </param>
    /// <param name = "_isBomLine">
    /// Specifies whether the journal line is a Bom Line or not.
    /// </param>
    /// <param name = "_inventDim">
    /// The dimension of the item.
    /// </param>
    /// <param name = "_inventLocationId">
    /// The inventory location Id.
    /// </param>
    [Hookable(true), Wrappable(true)]
    final protected static InventJournalTrans createOrUpdateBOMJournalLine(InventJournalTable journalTable, ItemId _itemId, Qty _quantity, boolean _isBomLine, InventDim inventDim, InventLocationId _inventLocationId)
    {
        InventJournalTrans journalTrans;
        InventDimId inventDimId;
        InventLocation inventLocationStandard;
        InventDimGroupSetup inventDimGroupSetup;

        // Retrieve the inventDimId which has site and warehouse information
        inventDim.InventLocationId = _inventLocationId;

        inventDimGroupSetup = InventDimGroupSetup::newItemId(_itemId);
        inventLocationStandard = InventLocation::find(_inventLocationId);
        inventDim.initFromInventLocation(inventLocationStandard);

        if (inventLocationStandard.WHSEnabled == NoYes::Yes)
        {
            if (inventDimGroupSetup.isDimensionActive(fieldNum(InventDim,wmsLocationId)))
            {
                inventDim.wMSLocationId = inventLocationStandard.RBODefaultWMSLocationId;
            }

            if (inventDimGroupSetup.isDimensionActive(fieldNum(InventDim,InventStatusId)))
            {
                inventDim.InventStatusId = inventLocationStandard.DefaultStatusId;
            }
        }
        // adding wmsLocationId to <c>inventDim</c> if the item has active <c>InventDimGroupSetup</c>.
        else if (inventDimGroupSetup.isDimensionActive(fieldNum(InventDim,wmsLocationId)))
        {
            inventDim.wMSLocationId = WMSLocation::defaultItemLocation(_itemId,
                                                                       _isBomLine ? InventDirection::Issue : InventDirection::Receipt,
                                                                       inventDim,
                                                                       false).wMSLocationId;
        }

        // Specify default Invent status id if Inventory status is an active dimension.
        if (!inventDim.InventStatusId && inventDimGroupSetup.isDimensionActive(fieldNum(InventDim,InventStatusId)))
        {
            inventDim.InventStatusId = WHSInvent::getDefaultStatus(inventDim);
        }

        inventDimId = InventDim::findOrCreate(inventDim).InventDimId;
        
        journalTrans = InventJournalTrans::findItemInfo(journalTable.JournalId, _itemId, inventDimId, true);
        
        if (journalTrans)
        {
            // updates the existing InventJournalTrans quantity and cost amount for the item.
            journalTrans.Qty = _quantity;
            journalTrans.setCostPrice(journalTrans.InventDimId, inventDim, journalTrans.inventTableModuleInvent());
            journalTrans.update();
        }
        else
        {
            // create a InventJournalTrans for the item
            journalTrans = RetailKitAssemblyOrder::initBOMJournalLine(journalTable, _itemId, _quantity, _isBomLine, inventDimId);
            RetailKitAssemblyOrderContext context = RetailKitAssemblyOrderContext::current();
            
            // If the order is created from statement posting, the trans date should be set based on the statement date not the current date.
            if (context && context.parmIsCashAndCarry())
            {
                journalTrans.TransDate = context.parmTransDate();
            }

            JournalTransData journalTransData = JournalTransData::newTransTableLineNum(journalTrans, journalTable, InventJournalTrans::lastLineNum(journalTrans.JournalId) + 1);
            journalTransData.initFromJournalTable();
            journalTransData.create();
        }

        // Update cost based on components
        if (_isBomLine && journalTrans.RecId)
        {
            journalTrans.updateAssemblyLineAmounts();
        }

        return journalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventTransIdFather</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the invent transfer id father for the given <c>RetailKitOrder</c>.
    /// </summary>
    /// <param name = "_retailKitOrder">The retail kit order.</param>
    /// <returns>The invent transfer Id.</returns>
    public static InventTransId getInventTransIdFather(RetailKitOrder _retailKitOrder)
    {
        InventJournalTrans inventJournalTrans;
        RetailKitOrderJournal kitOrderJournal;

        select firstOnly inventTransId from inventJournalTrans
            exists join kitOrderJournal
            where inventJournalTrans.JournalId == kitOrderJournal.JournalId &&
                  kitOrderJournal.RetailKitOrder == _retailKitOrder.RecId &&
                  inventJournalTrans.BOMLine == false;

        return inventJournalTrans.inventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assembleKitFromSalesTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to process sales transactions with kit items pulled from the store.
    /// It will update the physical inventory of the kit's by the quantity specified in RetailTransactionSalesTrans.
    /// </summary>
    /// <param name="_transactionSalesTrans">
    /// The Retail transaction sales line of a store whose transaction is being processed.
    /// </param>
    /// <param name="_qtyRemaining">
    /// The quantity of retail kits that need to be assembled.
    /// </param>
    /// <remarks>
    /// This method is called from in RetailTransactionSalesTransMark to assemble kits if physical inventory is not available
    /// </remarks>
    public static void assembleKitFromSalesTransactions(RetailTransactionSalesTrans _transactionSalesTrans, Qty _qtyRemaining)
    {
        RetailKitOrder                          retailKitOrder;
        RetailKit                               retailKit;
        EcoResDistinctProductVariantRecId       distinctProductVariantRecId;

        eventSource.EventWriteAssembleKitFromSalesTransactionsPrep(_transactionSalesTrans.RecId, _qtyRemaining);
        retailKit = RetailKit::findByProductmaster(InventTable::find(_transactionSalesTrans.ItemId).Product);

        ttsbegin;
        
        retailKitOrder.initValue();
        
        // Initialize values from the custom fields, e.g., IsConsolidation
        RetailKitAssemblyOrder::initKitOrderDelegate(retailKitOrder);

        retailKitOrder.Kit = retailKit.RecId;
        retailKitOrder.InventLocation = RetailStoreTable::find(_transactionSalesTrans.Store).InventLocation;
        retailKitOrder.InventDataAreaId = _transactionSalesTrans.dataAreaId;
        retailKitOrder.Quantity = _qtyRemaining;
        retailKitOrder.Name = NumberSeq::newGetNum(RetailParameters::numRefAssemblyOrderName()).num();
        retailKitOrder.OrderSource = RetailKitOrderSource::POS;
        retailKitOrder.OrderType = RetailKitOrderType::AssemblyOrder;
        if (_transactionSalesTrans.transactionId != '')
        {
            retailKitOrder.Comments = "@SYS2192" + ' '+ "@RET3008" + ': '+ _transactionSalesTrans.transactionId;
        }
        else
        {
            retailKitOrder.Comments = "@SYS2192" + ' '+ "@RET3230" + ': '+ _transactionSalesTrans.statementId;
        }
        retailKitOrder.insert();

        distinctProductVariantRecId = InventDimCombination::findVariantId(_transactionSalesTrans.VariantId).DistinctProductVariant;
        
        using (RetailKitAssemblyOrderContext context = RetailKitAssemblyOrderContext::construct())
        {
            context.parmIsCashAndCarry(NoYes::Yes);
            context.parmTransDate(_transactionSalesTrans.businessDate);
            
            eventSource.EventWriteAssembleKitFromSalesTransactionsProcessStart(_transactionSalesTrans.RecId, _qtyRemaining);

            RetailKitAssemblyOrder::processOrder(retailKitOrder,
                                        distinctProductVariantRecId,
                                        _qtyRemaining
                                        );

            eventSource.EventWriteAssembleKitFromSalesTransactionsProcessStop(_transactionSalesTrans.RecId, _qtyRemaining);
        }

        eventSource.EventWriteAssembleKitFromSalesTransactionsPostStart(_transactionSalesTrans.RecId, _qtyRemaining);

        RetailKitAssemblyOrder::post(retailKitOrder);

        eventSource.EventWriteAssembleKitFromSalesTransactionsPostStop(_transactionSalesTrans.RecId, _qtyRemaining);
        
        ttscommit;

        eventSource.EventWriteAssembleKitFromSalesTransactionsComplete(_transactionSalesTrans.RecId, _qtyRemaining);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSalesLineAssemblyOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes any not posted assembly orders marked against the specified sales line.
    /// </summary>
    /// <param name="_salesLine">
    /// The sales line to delete the assembly order for.
    /// </param>
    public static void deleteSalesLineAssemblyOrder(SalesLine _salesLine)
    {
        RetailKit retailKit;
        RetailKitOrder retailKitOrder;
        RetailKitOrderJournal retailKitOrderJournal;
        InventTable inventTable;
        InventJournalTable journalTable;
        InventJournalTrans journalTrans;
        InventTransOrigin bomJournalInventTransOrigin;
        InventTransOrigin salesLineInventTransOrigin;
        InventTrans bomJounralInventTrans;

        inventTable = InventTable::find(_salesLine.ItemId);
        retailKit = retailKit::findByProductmaster(inventTable.Product);

        if (retailKit)
        {
            salesLineInventTransOrigin = InventTransOrigin::findByInventTransId(_salesLine.InventTransId);

            if (salesLineInventTransOrigin)
            {
                delete_from retailKitOrder
                    where retailKitOrder.Kit == retailKit.RecId
                    exists join retailKitOrderJournal
                        where retailKitOrderJournal.RetailKitOrder == retailKitOrder.RecId
                    join journalTable
                        where journalTable.JournalId == retailKitOrderJournal.JournalId
                           && journalTable.Posted == NoYes::No
                    join journalTrans
                        where journalTrans.JournalId == journalTable.JournalId
                           && journalTrans.ItemId == _salesLine.ItemId
                           && journalTrans.BOMLine == NoYes::No
                    join bomJournalInventTransOrigin
                        where bomJournalInventTransOrigin.InventTransId == journalTrans.InventTransId
                    join bomJounralInventTrans
                        where bomJounralInventTrans.InventTransOrigin == bomJournalInventTransOrigin.RecId
                           && bomJounralInventTrans.MarkingRefInventTransOrigin == salesLineInventTransOrigin.RecId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findMarkedAssemblyOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds not posted, marked kit assembly order for a sales line.
    /// </summary>
    /// <param name="_salesLine">
    /// The <c>SalesLine</c> to find the marked assembly order for.
    /// </param>
    /// <param name="_salesLineInventTransOrigin">
    /// The <c>InventTransOrigin</c> of the sales line.
    /// </param>
    /// <param name="_retailKit">
    /// The kit used by the sales line.
    /// </param>
    /// <param name="_inventDimCombination">
    /// The kit variant used by the sales line.
    /// </param>
    /// <param name="_checkPostedAsWell">
    /// Should posted be included in check as well?
    /// </param>
    /// <returns>
    /// The found assembly order.
    /// </returns>
    protected static RetailKitOrder findMarkedAssemblyOrder(
        SalesLine _salesLine,
        InventTransOrigin _salesLineInventTransOrigin,
        RetailKit _retailKit,
        InventDimCombination _inventDimCombination,
        boolean _checkPostedAsWell)
    {
        RetailKitOrder retailKitOrder;
        RetailKitOrderJournal retailKitOrderJournal;
        InventJournalTable journalTable;
        InventJournalTrans journalTrans;
        InventTransOrigin bomJournalInventTransOrigin;
        InventTrans bomJounralInventTrans;

        if (_checkPostedAsWell)
        {
            select forUpdate retailKitOrder
                where retailKitOrder.Kit == _retailKit.RecId
                exists join retailKitOrderJournal
                    where retailKitOrderJournal.RetailKitOrder == retailKitOrder.RecId
                exists join journalTable
                    where journalTable.JournalId == retailKitOrderJournal.JournalId // Include regardless of posted or not
                exists join journalTrans
                    where journalTrans.JournalId == journalTable.JournalId
                        && journalTrans.ItemId == _salesLine.ItemId
                        && journalTrans.BOMLine == NoYes::No
                exists join bomJournalInventTransOrigin
                    where bomJournalInventTransOrigin.InventTransId == journalTrans.InventTransId
                        && bomJournalInventTransOrigin.ItemInventDimId == _inventDimCombination.InventDimId
                exists join bomJounralInventTrans
                    where bomJounralInventTrans.InventTransOrigin == bomJournalInventTransOrigin.RecId
                        && bomJounralInventTrans.MarkingRefInventTransOrigin == _salesLineInventTransOrigin.RecId;
        }
        else
        {
            select forUpdate retailKitOrder
                where retailKitOrder.Kit == _retailKit.RecId
                exists join retailKitOrderJournal
                    where retailKitOrderJournal.RetailKitOrder == retailKitOrder.RecId
                exists join journalTable
                    where journalTable.JournalId == retailKitOrderJournal.JournalId
                        && journalTable.Posted == NoYes::No
                exists join journalTrans
                    where journalTrans.JournalId == journalTable.JournalId
                        && journalTrans.ItemId == _salesLine.ItemId
                        && journalTrans.BOMLine == NoYes::No
                exists join bomJournalInventTransOrigin
                    where bomJournalInventTransOrigin.InventTransId == journalTrans.InventTransId
                        && bomJournalInventTransOrigin.ItemInventDimId == _inventDimCombination.InventDimId
                exists join bomJounralInventTrans
                    where bomJounralInventTrans.InventTransOrigin == bomJournalInventTransOrigin.RecId
                        && bomJounralInventTrans.MarkingRefInventTransOrigin == _salesLineInventTransOrigin.RecId;
        }

        return retailKitOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesOrderMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines is a kit orders is marked against a sales order.
    /// </summary>
    /// <param name="_retailKitOrder">
    /// The kit order to check.
    /// </param>
    /// <returns>
    /// True if the kit order is marked against a sales order; otherwise, false.
    /// </returns>
    public static boolean isSalesOrderMarked(RetailKitOrder _retailKitOrder)
    {
        RetailKitOrderJournal retailKitOrderJournal;
        InventJournalTable journalTable;
        InventJournalTrans journalTrans;
        InventTransOrigin bomJournalInventTransOrigin;
        InventTrans bomJounralInventTrans;
        InventTransOriginSalesLine inventTransOriginSalesLine;

        changeCompany(_retailKitOrder.InventDataAreaId)
        {
            select firstOnly RecId from retailKitOrderJournal
                    where retailKitOrderJournal.RetailKitOrder == _retailKitOrder.RecId
                exists join journalTable
                    where journalTable.JournalId == retailKitOrderJournal.JournalId
                       && journalTable.Posted == NoYes::No
                join RecId from journalTrans
                    where journalTrans.JournalId == journalTable.JournalId
                       && journalTrans.BOMLine == NoYes::No
                join RecId from bomJournalInventTransOrigin
                    where bomJournalInventTransOrigin.InventTransId == journalTrans.InventTransId
                join RecId from bomJounralInventTrans
                    where bomJounralInventTrans.InventTransOrigin == bomJournalInventTransOrigin.RecId
                join RecId from inventTransOriginSalesLine
                    where inventTransOriginSalesLine.InventTransOrigin == bomJounralInventTrans.MarkingRefInventTransOrigin;
        }

        return retailKitOrderJournal.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts a kit order.
    /// </summary>
    /// <param name="_retailKitOrder">
    /// The kit order to post.
    /// </param>
    public static void post(RetailKitOrder _retailKitOrder)
    {
        RetailKitOrderJournal kitOrderJournal;
        InventJournalTable inventJournalTable;

        ttsBegin;

        changeCompany(_retailKitOrder.InventDataAreaId)
        {
            while select inventJournalTable
                exists join kitOrderJournal
                where kitOrderJournal.RetailKitOrder == _retailKitOrder.RecId
                    && kitOrderJournal.JournalId == inventJournalTable.JournalId
                    && kitOrderJournal.InventDataAreaId == inventJournalTable.dataAreaId
            {
                eventSource.EventWriteKitAssembleOrderPostStart(_retailKitOrder.RecId);

                InventJournalCheckPost::newPostJournal(inventJournalTable).runOperation();

                eventSource.EventWriteKitAssembleOrderPostStop(_retailKitOrder.RecId);
            }
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSalesLineAssemblyOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts an assembly order marked against a sales line up to the deliver now quantity.
    /// </summary>
    /// <param name="_salesLine">
    /// The <c>SalesLine</c> to post the assembly order for.
    /// </param>
    public static void postSalesLineAssemblyOrder(SalesLine _salesLine)
    {
        RetailKit retailKit;
        RetailKitOrder retailKitOrder;
        InventTable inventTable;
        InventDimCombination inventDimCombination;
        InventTransOrigin salesLineInventTransOrigin;
        Qty qtyToPost;
        RetailKitAssemblyOrder retailKitAssemblyOrder;

        inventTable = InventTable::find(_salesLine.ItemId);
        retailKit = RetailKit::findByProductmaster(inventTable.Product);

        if (retailKit)
        {
            // When this flight is enabled, kit order posts automatically when order got picked and pickup the kit order from pos.
            // InventDeliverNow is the quantity to invoice which is submitted from POS, itâ€™s the quantity to post. We should neither subtract reservedPhysical() or pickedInTotalInventUnit().
            if (RetailAutomaticallyPostKitOrderWhenPickedThenPickUpFlight::instance().isEnabled())
            {
                qtyToPost = _salesLine.InventDeliverNow;
            }
            else
            {
                qtyToPost = _salesLine.InventDeliverNow - _salesLine.reservedPhysical() - _salesLine.pickedInTotalInventUnit();
            }

            if (qtyToPost > 0)
            {
                ttsBegin;

                salesLineInventTransOrigin = InventTransOrigin::findByInventTransId(_salesLine.InventTransId);
                inventDimCombination = InventDimCombination::find(_salesLine.ItemId, salesLineInventTransOrigin.ItemInventDimId);

                retailKitOrder = RetailKitAssemblyOrder::findMarkedAssemblyOrder(_salesLine, salesLineInventTransOrigin, retailKit, inventDimCombination, false);

                if (retailKitOrder && retailKitOrder.Quantity != qtyToPost)
                {
                    // if partial posting reduce the quantity on the existing assembly order.
                    retailKitOrder.Quantity = qtyToPost;
                    retailKitOrder.update();

                    InventJournalSource journalSource = _salesLine.SalesId;
                    RetailKitAssemblyOrder::createOrUpdateBOMJournal(retailKitOrder, inventDimCombination.DistinctProductVariant, qtyToPost, journalSource);
                }

                if (retailKitOrder)
                {
                    RetailKitAssemblyOrder::post(retailKitOrder);

                    if (_salesLine.InventDeliverNow != _salesLine.RemainInventPhysical)
                    {
                        // if partial posting create a new assembly order for the remaining quantity.
                        InventUpd_Estimated::newInventMovement(InventMovement::construct(_salesLine)).updateReservation();
                        RetailKitAssemblyOrder::syncSalesLine(_salesLine, true);
                    }
                }

                ttsCommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processKitTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to process kit disassembly transactions pulled from the store.
    /// it will update the inventory of the kit's by the quantity specified in RetailTransactionKitsDisassemblyTrans and
    /// updates the kit's components by the quantity of the component contained in the kit multiplied by the quantity of the kit specified in
    /// RetailTransactionKitsDisassemblyTrans
    /// </summary>
    /// <param name="_store">
    /// the store whose transaction is being processed, only kit disassembly transactions from this store will be used in the inventory posting
    /// </param>
    /// <remarks>
    /// This method is called in RetailStatementCalculate_Multi right before inventory posting for sales transactions is performed
    /// </remarks>
    public static void processKitTransactions(RetailStoreTable _store)
    {
        RetailKitOrder                          retailKitOrder;
        RetailTransactionTable                  groupedRetailTransaction;
        RetailTransactionTable                  retailTransaction;
        RetailTransactionKitsDisassemblyTrans   groupedKitTransaction;
        RetailTransactionKitsDisassemblyTrans   kitTransaction;
        EcoResDistinctProductVariantRecId       distinctProductVariant;

        changecompany(_store.InventLocationDataAreaId)
        {
            ttsbegin;

            // Select unposted kit disassembly transactions in _store and group them by the kit itemid
            // This is done to create one kitorder per kit item instead of creating a kitorder for each disassembly transaction

            while select sum(Qty), ItemId from  groupedKitTransaction
            join RecId from groupedRetailTransaction group by groupedKitTransaction.ItemId
            where groupedKitTransaction.TransactionStatus == RetailEntryStatus::None &&
               groupedRetailTransaction.Channel == groupedKitTransaction.Channel &&
               groupedRetailTransaction.store == groupedKitTransaction.StoreId &&
               groupedRetailTransaction.terminal == groupedKitTransaction.TerminalId &&
               groupedRetailTransaction.TransactionId == groupedKitTransaction.TransactionId &&
               groupedRetailTransaction.Type  == RetailTransactionType::KitDisassembly &&
               groupedRetailTransaction.Store == _store.StoreNumber
            {
                // Create retail kit order per kit (Note this is per kit and not per kit variant)
                retailKitOrder.OrderType        = RetailKitOrderType::DisassemblyOrder;
                retailKitOrder.Name             = NumberSeq::newGetNum(NumberSeqReference::findReference(extendedTypeNum(RetailKitAssemblyOrderName))).num();
                retailKitOrder.InventDataAreaId = _store.InventLocationDataAreaId;
                retailKitOrder.InventLocation   = _store.InventLocation;
                retailKitOrder.Quantity         = groupedKitTransaction.Qty;
                retailKitOrder.OrderSource      = RetailKitOrderSource::POS;
                retailKitOrder.Kit              = RetailKit::findByProductmaster(InventTable::find(groupedKitTransaction.ItemId).Product).RecId;
                retailKitOrder.insert();

                // update inventory of each of the disassembled kitvariants in of the current kit - using the order created above.

                while select forupdate kitTransaction
                join forupdate retailTransaction
                where kitTransaction.TransactionStatus == RetailEntryStatus::None &&
                    retailTransaction.Channel == kitTransaction.Channel &&
                    retailTransaction.store == kitTransaction.StoreId &&
                    retailTransaction.terminal == kitTransaction.TerminalId &&
                    retailTransaction.TransactionId == kitTransaction.TransactionId &&
                    retailTransaction.Type  == RetailTransactionType::KitDisassembly &&
                    retailTransaction.Store == _store.StoreNumber &&
                    kitTransaction.ItemId == groupedKitTransaction.ItemId
                {
                    distinctProductVariant = InventDimCombination::findVariantId(kitTransaction.VariantId).DistinctProductVariant;

                    using (RetailKitAssemblyOrderContext context = RetailKitAssemblyOrderContext::construct())
                    {
                        context.parmIsCashAndCarry(NoYes::Yes);
                        context.parmTransDate(retailTransaction.businessDate);
                        
                        RetailKitAssemblyOrder::processOrder(retailKitOrder,
                                                         distinctProductVariant,
                                                         kitTransaction.Qty
                                                         );
                    }
                   
                    // Mark processed transaction
                   
                    retailTransaction.EntryStatus = RetailEntryStatus::Posted;
                    kitTransaction.TransactionStatus = RetailEntryStatus::Posted;

                    kitTransaction.update();
                    retailTransaction.update();
                }

                RetailKitAssemblyOrder::post(retailKitOrder);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes a kit order depending on the order type.  For an assembly type kit order the specified kit variant will be assembled; for a disassembly type
    /// kit order the specified variant of the kit is disassembled.
    /// </summary>
    /// <param name="_kitOrder">
    /// The retail kit order
    /// </param>
    /// <param name="_kitVariantRecId">
    /// The kit variant to be processed
    /// </param>
    /// <param name="_qty">
    /// The quantity to be processed
    /// </param>
    /// <remarks>
    /// Fulfills the kit order i.e. assembles or disassembles the kit order based on the order type
    /// </remarks>
    public static void processOrder(RetailKitOrder _kitOrder, EcoResDistinctProductVariantRecId _kitVariantRecId, Qty _qty)
    {
        changecompany(_kitOrder.InventDataAreaId)
        {
            // Check if the variant is released
            if (InventDimCombination::findByDistinctProductVariant(_kitVariantRecId))
            {
                ttsBegin;

                eventSource.EventWriteKitAssembleOrderProcessStart(_kitOrder.RecId, _kitVariantRecId, _qty);
                
                RetailKitAssemblyOrder::createOrUpdateBOMJournal(_kitOrder, _kitVariantRecId, _qty);

                eventSource.EventWriteKitAssembleOrderProcessStop(_kitOrder.RecId, _kitVariantRecId, _qty);

                ttsCommit;
            }
            else
            {
                eventSource.EventWriteProductsRetailKitAssemblyVariantNotReleased('RetailKitAssemblyOrder', funcName(), _kitVariantRecId);

                error(strFmt("@REX1638", _kitVariantRecId, _kitOrder.InventDataAreaId));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldProcessSalesLineDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for determining if sales line should be procesed.
    /// </summary>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide the a boolean result.</param>
    /// <param name = "_salesLine">The sales line to synchronize an assembly order with.</param>
    static delegate void shouldProcessSalesLineDelegate(EventHandlerResult _result, SalesLine _salesLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldProcessKitDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for determining if the kit should be procesed.
    /// </summary>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide the a boolean result.</param>
    /// <param name = "_salesLine">The sales line to synchronize an assembly order with.</param>
    /// <param name = "_retailKitOrder">The retail kit order.</param>
    static delegate void shouldProcessKitDelegate(EventHandlerResult _result, SalesLine _salesLine, RetailKitOrder _retailKitOrder)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initKitOrderDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to allow initialization of <c>RetailKitOrder</c>.
    /// </summary>
    /// <param name = "_retailKitOrder">The retail kit order being initialized.</param>
    static delegate void initKitOrderDelegate(RetailKitOrder _retailKitOrder)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes an assembly order with a sales line.
    /// </summary>
    /// <param name="_salesLine">
    /// The sales line to synchronize an assembly order with.
    /// </param>
    /// <param name="_initialSync">
    /// Boolean flag indicating whether it's a first synchronization. On initial synchronization the check for existing assembly order is skipped.
    /// </param>
    public static void syncSalesLine(SalesLine _salesLine, boolean _initialSync = false)
    {
        RetailKit retailKit;
        RetailKitOrder retailKitOrder;
        InventTable inventTable;
        InventDimCombination inventDimCombination;
        InventTransOrigin bomJournalInventTransOrigin;
        InventTransOrigin salesLineInventTransOrigin;
        Qty qtyRemaining;
        RetailKitAssemblyOrder retailKitAssemblyOrder;
        EventHandlerResult res;

        inventTable = InventTable::find(_salesLine.ItemId);
        retailKit = retailKit::findByProductmaster(inventTable.Product);

        // Should this salesline be processed at all?
        res = EventHandlerResult::newSingleResponse();
        RetailKitAssemblyOrder::shouldProcessSalesLineDelegate(res, _salesLine);
        if (res.hasResult() && res.booleanResult() == false)
        {
            // skip processing for this sales line.
            return;
        }

        if (retailKit)
        {
            ttsBegin;

            qtyRemaining = _salesLine.RemainInventPhysical - _salesLine.reservedPhysical() - _salesLine.pickedInTotalInventUnit();

            if (qtyRemaining > 0)
            {
                salesLineInventTransOrigin = InventTransOrigin::findByInventTransId(_salesLine.InventTransId);
                inventDimCombination = InventDimCombination::find(_salesLine.ItemId, salesLineInventTransOrigin.ItemInventDimId);

                if (!_initialSync)
                {
                    retailKitOrder = RetailKitAssemblyOrder::findMarkedAssemblyOrder(_salesLine, salesLineInventTransOrigin, retailKit, inventDimCombination, true);
                }

                res = EventHandlerResult::newSingleResponse();
                RetailKitAssemblyOrder::shouldProcessKitDelegate(res, _salesLine, retailKitOrder);

                if (!res.hasResult() || res.booleanResult() == true)
                {
                    if (retailKitOrder)
                    {
                        retailKitOrder.Quantity = qtyRemaining;
                        retailKitOrder.update();
                    }
                    else
                    {
                        retailKitOrder.initValue();
                        retailKitOrder.Kit = retailKit.RecId;
                        retailKitOrder.InventLocation = _salesLine.inventDim().InventLocationId;
                        retailKitOrder.InventDataAreaId = _salesLine.dataAreaId;
                        retailKitOrder.Quantity = qtyRemaining;
                        retailKitOrder.Name = NumberSeq::newGetNum(RetailParameters::numRefAssemblyOrderName()).num();
                        retailKitOrder.OrderSource = RetailKitOrderSource::RetailHQ;
                        retailKitOrder.OrderType = RetailKitOrderType::AssemblyOrder;
                        retailKitOrder.Comments = _salesLine.SalesId;
                        retailKitOrder.insert();
                    }

                    InventJournalSource journalSource = _salesLine.SalesId;
                    RetailKitAssemblyOrder::createOrUpdateBOMJournal(retailKitOrder, inventDimCombination.DistinctProductVariant, qtyRemaining, journalSource);

                    RetailKitAssemblyOrderContext context = RetailKitAssemblyOrderContext::current();
            
                    // Kit orders should be automatically posted when the flag is true in the context.
                    // This is valid for statement posting.
                    // We should also check if the kit order is not posted yet.
                    if (context && context.parmShouldAutomaticallyPostSalesLineKitOrder() && retailKitOrder.GetJournalPostedStatus() == NoYes::No)
                    {
                        eventSource.EventWriteKitAssembleOrderSyncSalesLineStart(_salesLine.RecId, qtyRemaining);

                        RetailKitAssemblyOrder::post(retailKitOrder);

                        eventSource.EventWriteKitAssembleOrderSyncSalesLineStop(_salesLine.RecId, qtyRemaining);
                    }

                    bomJournalInventTransOrigin = InventTransOrigin::findByInventTransId(RetailKitAssemblyOrder::getInventTransIdFather(retailKitOrder));
                    InventTransOrigin::updateMarking(bomJournalInventTransOrigin.RecId, salesLineInventTransOrigin.RecId, qtyRemaining, '', SortOrder::Descending);
                    InventTransOrigin::updateMarking(salesLineInventTransOrigin.RecId, bomJournalInventTransOrigin.RecId, -(qtyRemaining), '', SortOrder::Descending);
                    InventUpd_Estimated::newInventMovement(InventMovement::construct(_salesLine)).updateReservation();
                }
            }

            ttsCommit;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>