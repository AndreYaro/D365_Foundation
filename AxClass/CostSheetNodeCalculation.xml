<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CostSheetNodeCalculation</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>CostSheetNodeCalculation</c> class is the base class for all calculation nodes.
/// </summary>
abstract class CostSheetNodeCalculation extends CostSheetNode
{
    CostGroupId                     parentCostGroupId;
    LedgerDimensionDefaultAccount   accountEstimatedIndirectAbsorption;
    LedgerDimensionDefaultAccount   accountEstimatedIndirectAbsorptionOffset;
    LedgerDimensionDefaultAccount   accountIndirectAbsorption;
    LedgerDimensionDefaultAccount   accountIndirectAbsorptionOffset;
    DimensionDefault                defaultDimension;
    CostSheetFactorPerItem      factorPerItem;
    List                        basisList;
    List                        factorList;

    BOMCalcCheckIndirectCost    bomCalcCheckIndirectCost;

    #define.CurrentVersion(4)
    #localmacro.CurrentList
        parentCostGroupId,
        accountEstimatedIndirectAbsorption,
        accountEstimatedIndirectAbsorptionOffset,
        accountIndirectAbsorption,
        accountIndirectAbsorptionOffset,
        defaultDimension,
        factorPerItem
    #endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowedSubtypeSet</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a <c>Set</c> object that contains the calculation subtypes that are allowed for this class.
    /// </summary>
    /// <returns>
    ///    The set that contains the <c>CostCalculationUnitBasedSubtype</c> enumeration elements.
    /// </returns>
    abstract Set allowedSubtypeSet()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>bomCalcCheckIndirectCost</Name>
				<Source><![CDATA[
    protected BOMCalcCheckIndirectCost bomCalcCheckIndirectCost()
    {
        if (bomCalcCheckIndirectCost == null)
        {
            bomCalcCheckIndirectCost = BOMCalcCheckIndirectCost::newBOMCalcBase(this.getCostCalcTransData().getBOMCalcItem());
        }

        return bomCalcCheckIndirectCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the amounts based on input data and costing sheet structure.
    /// </summary>
    /// <param name="_costSheet">
    ///    The costing sheet object.
    /// </param>
    /// <param name="_costCalcTransData">
    ///    The <c>CostCalcTransData</c> object that has input data.
    /// </param>
    /// <returns>
    ///    A <c>CostCalcTransData</c> object.
    /// </returns>
    /// <remarks>
    ///    Every node may be in either "calculated" or "not calculated‚Äù state. The costing sheet is calculated
    ///    in one or more passes until all nodes have "calculated" status. If the node is a "leaf", that is,
    ///    has no subnodes, the <c>calcLowestLevel</c> method is called that processes the input data and
    ///    marks the node as "calculated". If the node is a composite, that is, has subnodes, it is marked as
    ///    "calculated" after all its subnodes are "calculated".
    /// </remarks>
    public CostCalcTransData calc(
        CostSheet           _costSheet,
        CostCalcTransData   _costCalcTransData)
    {
        if (calculated)
        {
            return costCalcTransData;
        }

        super(_costSheet, _costCalcTransData);
        this.calcLowestLevel(_costSheet, _costCalcTransData);

        return costCalcTransData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLowestLevel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the concrete amounts based on input data and costing sheet structure for leaf nodes.
    /// </summary>
    /// <param name="_costSheet">
    ///    The costing sheet object.
    /// </param>
    /// <param name="_costCalcTransData">
    ///    The <c>CostCalcTransData</c> object that has input data.
    /// </param>
    public void calcLowestLevel(CostSheet _costSheet, CostCalcTransData _costCalcTransData)
    {
        super(_costSheet, _costCalcTransData);

        bomCalcCheckIndirectCost = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHaveSubnode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether a proposed node may be added as a subnode.
    /// </summary>
    /// <param name="_node">
    ///    The potential subnode.
    /// </param>
    /// <returns>
    ///    Always returns <c>false</c>.
    /// </returns>
    public boolean canHaveSubnode(CostSheetNode _node)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHaveSubnodes</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the instance of the <c>CostSheetNodeCalculation</c> class can have subnodes.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    public boolean canHaveSubnodes()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculationNodeTypeList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a list of calculation <c>CostSheetNodeType</c>s.
    /// </summary>
    /// <param name = "_calculationNodeTypes">This param can be overridden with CoC to add additional calculation types.</param>
    /// <returns>A list of calculation <c>CostSheetNodeType</c>s</returns>
    public static List calculationNodeTypeList(List _calculationNodeTypes = new List(Types::Enum))
    {
        _calculationNodeTypes.addEnd(CostSheetNodeType::CalculationSurcharge);
        _calculationNodeTypes.addEnd(CostSheetNodeType::CalculationRate);
        _calculationNodeTypes.addEnd(CostSheetNodeType::CalculationOutUnitBased);
        _calculationNodeTypes.addEnd(CostSheetNodeType::CalculationInUnitBased);
        _calculationNodeTypes.addEnd(CostSheetNodeType::CalculationPurchUnitBased);

        return _calculationNodeTypes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCalculationNodeType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the <c>CostSheetNodeType</c> is a calculation type.
    /// </summary>
    /// <param name = "_type">The <c>CostSheetNodeType</c>.</param>
    /// <returns>true if _type is a calculation node type; otherwise, false.</returns>
    public static boolean isCalculationNodeType(CostSheetNodeType _type)
    {
        return (_type == CostSheetNodeType::CalculationSurcharge
            ||  _type == CostSheetNodeType::CalculationRate
            ||  _type == CostSheetNodeType::CalculationOutUnitBased
            ||  _type == CostSheetNodeType::CalculationInUnitBased
            ||  _type == CostSheetNodeType::CalculationPurchUnitBased);
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectBasisCostCalcTransData</Name>
				<Source><![CDATA[
    protected CostCalcTransData collectBasisCostCalcTransData(CostSheet _costSheet)
    {
        CostSheetNode                   basisCostSheetNode;

        CostCalcTransData basisCostCalcTransData = CostCalcTransData::construct();

        boolean basisIsCalculated = true;

        Map code2NodeIdMap = _costSheet.getCode2NodeIdMap();
        ListEnumerator basisEnumerator = basisList.getEnumerator();
        while (basisEnumerator.moveNext())
        {
            CostSheetCalculationBasis costSheetCalculationBasis = basisEnumerator.current();

            if (code2NodeIdMap.exists(costSheetCalculationBasis.BasisCode))
            {
                basisCostSheetNode = _costSheet.findNode(code2NodeIdMap.lookup(costSheetCalculationBasis.BasisCode));
            }
            else
            {
                basisCostSheetNode = null;
            }

            if (basisCostSheetNode != null)
            {
                if (basisCostSheetNode.isCalculated())
                {
                    basisCostCalcTransData.addCostCalcTransData(
                        this.filterBasisCostCalcTransData(
                            basisCostSheetNode.getCostCalcTransData(),
                            costSheetCalculationBasis));

                    basisIsCalculated = true && basisIsCalculated;
                }
                else
                {
                    basisIsCalculated = false && basisIsCalculated;
                }
            }
        }

        if (basisIsCalculated)
        {
            CostTmpCalcTrans costTmpCalcTrans = basisCostCalcTransData.getCostTmpCalcTrans();

            // Verify the input data consistency
            select minof(Level), RecId from costTmpCalcTrans;
            if (costTmpCalcTrans.RecId != 0 && costTmpCalcTrans.Level < this.getCostCalcTransData().getLevel())
            {
                throw error("@SCM:InputDataInconsistent");
            }
        }
        else
        {
            // Some basis nodes are yet to be calculated: roll back basisCostCalcTransData
            basisCostCalcTransData = null;
        }

        return basisCostCalcTransData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editBasisSubtype</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets and gets the subtype values for the indirect cost basis lines.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that indicates whether to set the value.
    /// </param>
    /// <param name="_costSheetCalculationBasis">
    ///    The table buffer that represents the indirect cost basis line.
    /// </param>
    /// <param name="_subtypeName">
    ///    The subtype to assign to the basis line.
    /// </param>
    /// <returns>
    ///    The subtype of the indirect cost basis line.
    /// </returns>
    public CostCalculationSubtypeName editBasisSubtype(
        boolean                     _set,
        CostSheetCalculationBasis   _costSheetCalculationBasis,
        CostCalculationSubtypeName  _subtypeName)
    {
        if (!this.useBasis() || this.getBasisSubtypeFieldName() == '')
        {
            return '';
        }

        SysDictField sysDictField = SysDictField::newName(tableStr(CostSheetCalculationBasis), this.getBasisSubtypeFieldName());
        SysDictEnum sysDictEnum = new SysDictEnum(sysDictField.enumId());

        if (_set)
        {
            int value = sysDictEnum.name2Value(_subtypeName);

            if (sysDictEnum.value2Symbol(value) != ''
             && this.allowedSubtypeSet().in(value))
            {
                _costSheetCalculationBasis.(sysDictField.id()) = value;
            }
        }

        return sysDictEnum.value2Name(_costSheetCalculationBasis.(sysDictField.id()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>editCommon</Name>
				<Source><![CDATA[
    public Common editCommon(
        TableId _tableId,
        boolean _set = false,
        Common  _common = null
        )
    {
        Common common = super(_tableId, _set, _common);

        switch (_tableId)
        {
            case tableNum(CostSheetCalculationBasis) :
                common = this.editCostSheetCalculationBasis(_set, _common);
                break;

            case tableNum(CostSheetCalculationFactor) :
                common = this.editCostSheetCalculationFactor(_set, _common);
                break;
        }

        return common;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editCostSheetCalculationBasis</Name>
				<Source><![CDATA[
    protected CostSheetCalculationBasis editCostSheetCalculationBasis(
        boolean _set,
        CostSheetCalculationBasis _costSheetCalculationBasis
        )
    {
        CostSheetCalculationBasis  tmpCostSheetCalculationBasis;

        if (!_costSheetCalculationBasis.isTmp())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (_set)
        {
            tmpCostSheetCalculationBasis.setTmp();
            tmpCostSheetCalculationBasis.setTmpData(_costSheetCalculationBasis); // disconnect from the form datasource to save the cursor position
            basisList = new List(Types::Record);
            while select tmpCostSheetCalculationBasis
            {
                basisList.addEnd(tmpCostSheetCalculationBasis);
            }
        }

        CostSheetCalculationBasis costSheetCalculationBasis = null;
        costSheetCalculationBasis.setTmp();
        ListEnumerator basisListEnumerator = basisList.getEnumerator();
        while (basisListEnumerator.moveNext())
        {
            CostSheetCalculationBasis costSheetCalculationBasisRecord = basisListEnumerator.current();
            costSheetCalculationBasis.clear();
            costSheetCalculationBasis.data(costSheetCalculationBasisRecord);
            costSheetCalculationBasis.insert();
        }

        return costSheetCalculationBasis;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editCostSheetCalculationFactor</Name>
				<Source><![CDATA[
    protected CostSheetCalculationFactor editCostSheetCalculationFactor(
        boolean                     _set,
        CostSheetCalculationFactor _costSheetCalculationFactor
        )
    {
        CostSheetCalculationFactor tmpCostSheetCalculationFactor;

        if (!_costSheetCalculationFactor.isTmp())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (_set)
        {
            tmpCostSheetCalculationFactor.setTmp();
            tmpCostSheetCalculationFactor.setTmpData(_costSheetCalculationFactor); // disconnect from the form datasource to save the cursor position

            factorList = new List(Types::Record);

            while select tmpCostSheetCalculationFactor
            {
                factorList.addEnd(tmpCostSheetCalculationFactor);
            }
        }

        return this.getCostSheetCalculationFactor();
    }

]]></Source>
			</Method>
			<Method>
				<Name>editCostSheetNodeTable</Name>
				<Source><![CDATA[
    protected CostSheetNodeTable editCostSheetNodeTable(boolean _set = false, CostSheetNodeTable _costSheetNodeTable = null)
    {
        CostSheetNodeTable costSheetNodeTable = super(_set, _costSheetNodeTable);

        if (_set)
        {
            accountEstimatedIndirectAbsorption = _costSheetNodeTable.EstimatedIndirectAbsorpLedgerDimension;
            accountEstimatedIndirectAbsorptionOffset = _costSheetNodeTable.EstimIndirectAbsorpOffsetLedgerDimension;
            accountIndirectAbsorption = _costSheetNodeTable.IndirectAbsorptionLedgerDimension;
            accountIndirectAbsorptionOffset = _costSheetNodeTable.IndirectAbsorptionOffsetLedgerDimension;
            defaultDimension = _costSheetNodeTable.DefaultDimension;
            factorPerItem                   = _costSheetNodeTable.CalculationFactorPerItem;
        }

        costSheetNodeTable.EstimatedIndirectAbsorpLedgerDimension = accountEstimatedIndirectAbsorption;
        costSheetNodeTable.EstimIndirectAbsorpOffsetLedgerDimension = accountEstimatedIndirectAbsorptionOffset;
        costSheetNodeTable.IndirectAbsorptionLedgerDimension = accountIndirectAbsorption;
        costSheetNodeTable.IndirectAbsorptionOffsetLedgerDimension = accountIndirectAbsorptionOffset;
        costSheetNodeTable.DefaultDimension = CostSheetNodeTable::copyDimensionServer(defaultDimension, costSheetNodeTable);
        costSheetNodeTable.CalculationFactorPerItem        = factorPerItem;

        return costSheetNodeTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editSubtype</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets and gets the subtype values for indirect cost nodes.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that indicates whether to set the value.
    /// </param>
    /// <param name="_costSheetNodeTable">
    ///    The table buffer that represents the indirect cost node.
    /// </param>
    /// <param name="_subtypeName">
    ///    The subtype to assign to the indirect cost.
    /// </param>
    /// <returns>
    ///    The subtype of the indirect cost.
    /// </returns>
    public CostCalculationSubtypeName editSubtype(
        boolean                     _set,
        CostSheetNodeTable          _costSheetNodeTable,
        CostCalculationSubtypeName  _subtypeName)
    {
        Set             allowedSubtypeSet = this.allowedSubtypeSet();

        SysDictField sysDictField = SysDictField::newName(tableStr(CostSheetNodeTable), this.getSubtypeFieldName());
        SysDictEnum sysDictEnum = new SysDictEnum(sysDictField.enumId());

        if (_set)
        {
            int value = sysDictEnum.name2Value(_subtypeName);

            if (sysDictEnum.value2Symbol(value) != ''
             && allowedSubtypeSet.in(value))
            {
                _costSheetNodeTable.(sysDictField.id()) = value;
            }
        }

        return sysDictEnum.value2Name(_costSheetNodeTable.(sysDictField.id()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNodeEqual</Name>
				<Source><![CDATA[
    protected boolean isNodeEqual(CostSheetNodeCalculation _costSheetNodeCalculation)
    {
        return accountEstimatedIndirectAbsorption == _costSheetNodeCalculation.getAcctEstimatedIndirectAbsorption() &&
               accountEstimatedIndirectAbsorptionOffset == _costSheetNodeCalculation.getAcctEstimatedIndirectAbsorptionOffset() &&
               accountIndirectAbsorption == _costSheetNodeCalculation.getAcctIndirectAbsorption() &&
               accountIndirectAbsorptionOffset == _costSheetNodeCalculation.getAcctIndirectAbsorptionOffset() &&
               DimensionDefaultFacade::areEqual(defaultDimension, _costSheetNodeCalculation.getDefaultDimension()) &&
               factorPerItem == _costSheetNodeCalculation.getFactorPerItem();
    }

]]></Source>
			</Method>
			<Method>
				<Name>equal</Name>
				<Source><![CDATA[
    public boolean equal(Object _costSheetNode)
    {
        boolean ret = super(_costSheetNode);

        if (ret && (_costSheetNode is CostSheetNodeCalculation))
        {
            CostSheetNodeCalculation costSheetNodeCalculation = _costSheetNode;

            ret = this.isNodeEqual(costSheetNodeCalculation);

            if (!ret)
            {
                return false;
            }

            ListEnumerator basisEnumerator = this.getBasisEnumerator();
            ListEnumerator basisToCompareEnumerator = costSheetNodeCalculation.getBasisEnumerator();
            while (basisEnumerator.moveNext())
            {
                if (!basisToCompareEnumerator.moveNext())
                {
                    return false;
                }

                CostSheetCalculationBasis costSheetCalculationBasis = basisEnumerator.current();
                CostSheetCalculationBasis costSheetCalculationBasisToCompare = basisToCompareEnumerator.current();

                if (costSheetCalculationBasis.BasisCode != costSheetCalculationBasisToCompare.BasisCode)
                {
                    return false;
                }
            }

            if (basisToCompareEnumerator.moveNext())
            {
                return false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchCostGroupIdsForImpactUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines which cost groups would require the calculation node to be loaded during transactions
    ///    processing.
    /// </summary>
    /// <param name="_costSheet">
    ///    The costing sheet identifier.
    /// </param>
    /// <returns>
    ///    A set of cost group identifiers.
    /// </returns>
    /// <remarks>
    ///    If the calculation node uses no basis, all cost groups are returned because the node should always
    ///    be loaded when calculating the costing sheet.
    /// </remarks>
    public Set fetchCostGroupIdsForImpactUpdate(CostSheet _costSheet)
    {
        BOMCostGroup                bomCostGroup;

        Set costGroupIdSet = new Set(Types::String);

        if (this.useBasis())
        {
            ListEnumerator basisEnumerator = this.getBasisEnumerator();
            while (basisEnumerator.moveNext())
            {
                CostSheetCalculationBasis costSheetCalculationBasis = basisEnumerator.current();
                CostSheetNode basisNode = _costSheet.findNode(costSheetCalculationBasis.BasisNodeId);

                costGroupIdSet = Set::union(costGroupIdSet, basisNode.parmCostGroupImpactSet());
            }
        }
        else
        {
            while select CostGroupId from bomCostGroup
            {
                costGroupIdSet.add(bomCostGroup.CostGroupId);
            }
        }

        // Inherit the existed impact set.
        if (costGroupImpactSet)
        {
            costGroupIdSet = Set::union(costGroupIdSet, costGroupImpactSet);
        }

        return costGroupIdSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillNodeList</Name>
				<Source><![CDATA[
    public void fillNodeList(List _nodeList, CostSheetNodeListType _nodeListType)
    {
        switch (_nodeListType)
        {
            case CostSheetNodeListType::All,
                 CostSheetNodeListType::IndirectCalculation :
                _nodeList.addEnd(this);
                break;

            case CostSheetNodeListType::Undefined :
                throw error(Error::wrongUseOfFunction(funcName()));

            default :
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>filterBasisCostCalcTransData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Filters the data that was collected from the indirect cost basis lines by using the subtypes that
    ///    are assigned to the basis lines.
    /// </summary>
    /// <param name="_basisCostCalcTransData">
    ///    The collected indirect cost basis data.
    /// </param>
    /// <param name="_costSheetCalculationBasis">
    ///    The table buffer that represents a particular basis line.
    /// </param>
    /// <returns>
    ///    The filtered data.
    /// </returns>
    /// <remarks>
    ///    This method should be overwritten if there is a possibility to edit subtypes on the indirect cost
    ///    basis lines.
    /// </remarks>
    protected CostCalcTransData filterBasisCostCalcTransData(
        CostCalcTransData           _basisCostCalcTransData,
        CostSheetCalculationBasis   _costSheetCalculationBasis)
    {
        return _basisCostCalcTransData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAcctEstimatedIndirectAbsorption</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount getAcctEstimatedIndirectAbsorption()
    {
        return accountEstimatedIndirectAbsorption;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAcctEstimatedIndirectAbsorptionOffset</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount getAcctEstimatedIndirectAbsorptionOffset()
    {
        return accountEstimatedIndirectAbsorptionOffset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAcctIndirectAbsorption</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount  getAcctIndirectAbsorption()
    {
        return accountIndirectAbsorption;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAcctIndirectAbsorptionOffset</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount  getAcctIndirectAbsorptionOffset()
    {
        return accountIndirectAbsorptionOffset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBasisEnumerator</Name>
				<Source><![CDATA[
    protected ListEnumerator getBasisEnumerator()
    {
        return basisList.getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBasisSubtypeFieldName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the name of the field in the <c>CostSheetCalculationBasis</c> table that stores subtype
    ///    values for this type of indirect costs.
    /// </summary>
    /// <returns>
    ///    The field name.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden if the indirect cost type allows editing of the subtype on the
    ///    basis lines.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    The indirect cost type cannot use other costing sheet nodes as the basis for calculation.
    /// </exception>
    protected FieldName getBasisSubtypeFieldName()
    {
        if (!this.useBasis())
        {
            throw error("@SCM:CannotUseOtherCostingSheetNodesAsBasis");
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCostSheetCalculationFactor</Name>
				<Source><![CDATA[
    protected CostSheetCalculationFactor getCostSheetCalculationFactor()
    {
        CostSheetCalculationFactor costSheetCalculationFactor;

        costSheetCalculationFactor.setTmp();

        ListEnumerator factorEnumerator = factorList.getEnumerator();

        while (factorEnumerator.moveNext())
        {
            CostSheetCalculationFactor costSheetCalculationFactorRecord = factorEnumerator.current();
            costSheetCalculationFactor.clear();
            costSheetCalculationFactor.data(costSheetCalculationFactorRecord);
            costSheetCalculationFactor.insert();
        }

        return costSheetCalculationFactor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCostSheetCalculationFactorCursor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the cursor pointing to <c>CostSheetCalculationFactor</c> relevant in current calculation context.
    /// </summary>
    /// <param name="_modeStrategy">
    /// The <c>CostSheetModeStrategy</c> class instance providing additional context for the factor selection.
    /// </param>
    /// <returns>
    /// The <c>QueryRun</c> class instance.
    /// </returns>
    private QueryRun getCostSheetCalculationFactorCursor(CostSheetModeStrategy   _modeStrategy)
    {
        Query                   calculationFactorQuery = _modeStrategy.buildCalculationFactorsQuery(sheetId, nodeId);

        QueryRun queryRun = new QueryRun(calculationFactorQuery);

        queryRun.interactive(false);
        queryRun.setCursor(_modeStrategy.getCalculationFactorCursor());

        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultDimension</Name>
				<Source><![CDATA[
    public DimensionDefault getDefaultDimension()
    {
        return defaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactorEnumerator</Name>
				<Source><![CDATA[
    protected ListEnumerator getFactorEnumerator()
    {
        return factorList.getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactorPerItem</Name>
				<Source><![CDATA[
    public CostSheetFactorPerItem getFactorPerItem()
    {
        return factorPerItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getImage</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the resource index of the image that will represent this node in the editor.
    /// </summary>
    /// <returns>
    ///    The resource ID.
    /// </returns>
    public int getImage()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSubtypeFieldName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the name of the field in the <c>CostSheetNodeTable</c> table that stores the subtype
    ///    values for this type of indirect costs.
    /// </summary>
    /// <returns>
    ///    The field name.
    /// </returns>
    abstract protected FieldName getSubtypeFieldName()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getType</Name>
				<Source><![CDATA[
    public CostSheetNodeType getType()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasFactorsPerItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether factors specific to items or item groups exist.
    /// </summary>
    /// <returns>
    ///    true if one or more specific factors exists; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method should be used when you clear the Per item check box.
    /// </remarks>
    public boolean hasFactorsPerItem()
    {
        boolean ret = false;
        ListEnumerator factorEnumerator = factorList.getEnumerator();
        while (!ret && factorEnumerator.moveNext())
        {
            CostSheetCalculationFactor costSheetCalculationFactor = factorEnumerator.current();
            if (costSheetCalculationFactor.ItemCode != TableGroupAll::All)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasSubnodes</Name>
				<Source><![CDATA[
    public boolean hasSubnodes()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadSubnodes</Name>
				<Source><![CDATA[
    protected void loadSubnodes(CostSheetModeStrategy _modeStrategy)
    {
        // Calculation nodes cannot have subnodes
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateSubtype</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Populates the combobox with the available subtype values of indirect costs.
    /// </summary>
    /// <param name="_formControl">
    ///    The form combobox control.
    /// </param>
    public void populateSubtype(FormComboBoxControl _formControl)
    {
        SysDictField    sysDictField        = SysDictField::newName(tableStr(CostSheetNodeTable), this.getSubtypeFieldName());
        Set             allowedSubtypeSet   = this.allowedSubtypeSet();
        SysDictEnum     sysDictEnum         = new SysDictEnum(sysDictField.enumId());

        _formControl.clear();
        for (int i = 0; i < sysDictEnum.values(); i++)
        {
            int value = sysDictEnum.index2Value(i);
            if (allowedSubtypeSet.in(value))
            {
                _formControl.add(sysDictEnum.index2Label(i));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes a new instance of the <c>CostSheetNodeCalculation</c> class.
    /// </summary>
    /// <param name="_costSheetNodeTable">
    ///     The record in the <c>CostSheetNodeTable</c> table that will be used to initialize this object.
    /// </param>
    /// <param name="_parentNodeId">
    ///     The ID of the parent node.
    /// </param>
    /// <param name="_modeStrategy">
    ///     The <c>CostSheetModeStrategy</c> object that controls the creation of the costing sheet.
    /// </param>
    /// <param name="_parentCostGroupId">
    ///     The ID of the <c>CostSheetNodeGroup</c> object that the calculation node belongs to.
    /// </param>
    protected void new(
        CostSheetNodeTable      _costSheetNodeTable,
        CostSheetNodeId         _parentNodeId,
        CostSheetModeStrategy   _modeStrategy,
        CostGroupId             _parentCostGroupId)
    {
        accountEstimatedIndirectAbsorption = _costSheetNodeTable.EstimatedIndirectAbsorpLedgerDimension;
        accountEstimatedIndirectAbsorptionOffset = _costSheetNodeTable.EstimIndirectAbsorpOffsetLedgerDimension;
        accountIndirectAbsorption = _costSheetNodeTable.IndirectAbsorptionLedgerDimension;
        accountIndirectAbsorptionOffset = _costSheetNodeTable.IndirectAbsorptionOffsetLedgerDimension;
        defaultDimension = _costSheetNodeTable.DefaultDimension;
        factorPerItem                   = _costSheetNodeTable.CalculationFactorPerItem;

        parentCostGroupId = _parentCostGroupId;

        super(_costSheetNodeTable, _parentNodeId, _modeStrategy);

        basisList         = new List(Types::Record);
        factorList        = new List(Types::Record);

        if (_modeStrategy.mustLoadCalculationBasisAndFactors())
        {
            QueryRun costSheetCalculationFactorCursor = this.getCostSheetCalculationFactorCursor(_modeStrategy);
            while (costSheetCalculationFactorCursor.next())
            {
                CostSheetCalculationFactor costSheetCalculationFactor = costSheetCalculationFactorCursor.getNo(1);
                factorList.addEnd(costSheetCalculationFactor);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack(boolean _areSurchargesPackedByParentContext = false)
    {
        if (_areSurchargesPackedByParentContext)
        {
            return [#CurrentVersion, _areSurchargesPackedByParentContext, this.getType(), #CurrentList, basisList.pack()] + [super(_areSurchargesPackedByParentContext)];
        }
        else
        {
            return [#CurrentVersion, _areSurchargesPackedByParentContext, this.getType(), #CurrentList, basisList.pack(), factorList.pack()] + [super(_areSurchargesPackedByParentContext)];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetNodeId</Name>
				<Source><![CDATA[
    public CostSheetNodeId resetNodeId(CostSheetNodeId _newNodeId)
    {
        CostSheetCalculationFactor costSheetCalculationFactor;

        // Reset NodeId value on all calculation factors -->

        costSheetCalculationFactor.setTmp();
        ListEnumerator listEnumerator = factorList.getEnumerator();
        while (listEnumerator.moveNext())
        {
            costSheetCalculationFactor.data(listEnumerator.current());
            costSheetCalculationFactor.NodeId = _newNodeId;
            costSheetCalculationFactor.insert();
        }

        factorList = new List(Types::Record);
        while select costSheetCalculationFactor
        {
            factorList.addEnd(costSheetCalculationFactor);
        }

        // <-- Reset NodeId value on all calculation factors

        CostSheetNodeId ret = super(_newNodeId);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFactorList</Name>
				<Source><![CDATA[
    public List parmFactorList(List _factorList = factorList)
    {
        factorList = _factorList;
        return factorList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>save</Name>
				<Source><![CDATA[
    public Integer save(
        CostSheet   _costSheet,
        Integer     _lineNum)
    {
        CostSheetCalculationBasis   costSheetCalculationBasis;
        CostSheetCalculationFactor  costSheetCalculationFactor;

        ttsbegin;

        Integer ret = super(_costSheet, _lineNum);

        Map code2NodeIdMap = _costSheet.getCode2NodeIdMap();

        RecordInsertList rilCostSheetCalculationBasis = new RecordInsertList(tableNum(CostSheetCalculationBasis));
        ListEnumerator basisEnumerator = basisList.getEnumerator();
        while (basisEnumerator.moveNext())
        {
            CostSheetCalculationBasis tmpCostSheetCalculationBasis = basisEnumerator.current();
            costSheetCalculationBasis.clear();
            costSheetCalculationBasis.data(tmpCostSheetCalculationBasis);

            if (code2NodeIdMap.exists(costSheetCalculationBasis.BasisCode))
            {
                costSheetCalculationBasis.SheetId = sheetId;
                costSheetCalculationBasis.NodeId = nodeId;
                costSheetCalculationBasis.BasisNodeId = code2NodeIdMap.lookup(costSheetCalculationBasis.BasisCode);
                rilCostSheetCalculationBasis.add(costSheetCalculationBasis);
            }
        }
        rilCostSheetCalculationBasis.insertDatabase();

        RecordInsertList rilCostSheetCalculationFactor = new RecordInsertList(tableNum(CostSheetCalculationFactor));
        ListEnumerator factorEnumerator = factorList.getEnumerator();
        while (factorEnumerator.moveNext())
        {
            CostSheetCalculationFactor tmpCostSheetCalculationFactor = factorEnumerator.current();
            costSheetCalculationFactor.clear();
            costSheetCalculationFactor.data(tmpCostSheetCalculationFactor);
            costSheetCalculationFactor.SheetId = sheetId;
            costSheetCalculationFactor.NodeId = nodeId;
            rilCostSheetCalculationFactor.add(costSheetCalculationFactor);
        }
        rilCostSheetCalculationFactor.insertDatabase();

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectCostSheetCalculationFactor</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the most appropriate calculation factor for overhead cost.
    /// </summary>
    /// <returns>
    ///    A <c>CostSheetCalculationFactor</c> record.
    /// </returns>
    protected CostSheetCalculationFactor selectCostSheetCalculationFactor()
    {
        CostSheetCalculationFactor costSheetCalculationFactor;

        BOMCalcItem bomCalcItem = this.getCostCalcTransData().getBOMCalcItem();

        if (bomCalcItem)
        {
            if (bomCalcItem.parmCostingVersionId())
            {
                costSheetCalculationFactor = CostSheetCalculationFactor::findCostingVersion(nodeId,
                                                                                            this.getCostCalcTransData().getItemId(),
                                                                                            this.getCostCalcTransData().getItemGroupId(),
                                                                                            bomCalcItem.parmSiteId(),
                                                                                            bomCalcItem.parmCostingVersionId(),
                                                                                            bomCalcItem.parmCalcDate(),
                                                                                            costSheetCalculationFactor);
            }
            else
            {
                costSheetCalculationFactor = CostSheetCalculationFactor::findCurrentFlex(nodeId,
                                                                                         this.getCostCalcTransData().getItemId(),
                                                                                         this.getCostCalcTransData().getItemGroupId(),
                                                                                         bomCalcItem.parmSiteId(),
                                                                                         costSheetCalculationFactor);
            }

            if (!costSheetCalculationFactor)
            {
                switch (bomCalcItem.parmBOMCalcFallBack())
                {
                    case BOMCalcFallBack::None :
                        // Do not fetch a price from the fallback system
                        break;

                    case BOMCalcFallBack::CurrentActive :
                        costSheetCalculationFactor = CostSheetCalculationFactor::findCurrentFlex(nodeId,
                                                                                                 this.getCostCalcTransData().getItemId(),
                                                                                                 this.getCostCalcTransData().getItemGroupId(),
                                                                                                 bomCalcItem.parmSiteId(),
                                                                                                 costSheetCalculationFactor);

                        this.bomCalcCheckIndirectCost().checkUseFallBack(code, costSheetCalculationFactor.VersionId);
                        break;

                    case BOMCalcFallBack::Simulated :
                        costSheetCalculationFactor = CostSheetCalculationFactor::findCostingVersion(nodeId,
                                                                                                    this.getCostCalcTransData().getItemId(),
                                                                                                    this.getCostCalcTransData().getItemGroupId(),
                                                                                                    bomCalcItem.parmSiteId(),
                                                                                                    bomCalcItem.parmFallBackVersionId(),
                                                                                                    bomCalcItem.parmCalcDate(),
                                                                                                    costSheetCalculationFactor);

                        this.bomCalcCheckIndirectCost().checkUseFallBack(code, costSheetCalculationFactor.VersionId);
                        break;

                    default:
                        throw error(Error::wrongUseOfFunction(funcName()));
                }
            }

            this.bomCalcCheckIndirectCost().checkNoCostPrice(code, costSheetCalculationFactor.RecId != 0);
        }
        else
        {
            costSheetCalculationFactor = CostSheetCalculationFactor::findCurrentFlex(nodeId,
                                                                                     this.getCostCalcTransData().getItemId(),
                                                                                     this.getCostCalcTransData().getItemGroupId(),
                                                                                     this.getCostCalcTransData().getInventSiteId(),
                                                                                     costSheetCalculationFactor);
        }

        return costSheetCalculationFactor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toBOMCalcTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a <c>BOMCalcTrans</c> record based on this costing sheet node.
    /// </summary>
    /// <param name="_costProfitSet">
    ///     An element of the <c>CostProfitSet</c> enumeration that identifies the profit settings.
    /// </param>
    /// <param name="_transDate">
    ///     The date of the transaction.
    /// </param>
    /// <returns>
    ///     The <c>BOMCalcTrans</c> record.
    /// </returns>
    public BOMCalcTrans toBOMCalcTrans(
        CostProfitSet   _costProfitSet,
        TransDate       _transDate)
    {
        BOMCalcTrans    bomCalcTrans;
        bomCalcTrans.clear();
        bomCalcTrans.CalcGroupId = '';
        bomCalcTrans.CostGroupId = parentCostGroupId;
        bomCalcTrans.Level       = this.getCostCalcTransData().getLevel();
        bomCalcTrans.Qty         = this.getCostCalcTransData().getQty();

        bomCalcTrans.ConsumptionVariable = this.getCostCalcTransData().getConsumptionVariable();
        bomCalcTrans.ConsumptionConstant = this.getCostCalcTransData().getConsumptionConstant();

        bomCalcTrans.TransDate   = _transDate;
        bomCalcTrans.Resource    = code;
        bomCalcTrans.bom         = NoYes::No;

        bomCalcTrans.CostPriceQty = this.getCostCalcTransData().getContributionVariable() / this.getCostCalcTransData().getQty();
        bomCalcTrans.CostPrice    = this.getCostCalcTransData().getContributionVariable() / (this.getCostCalcTransData().getConsumptionVariable() ? this.getCostCalcTransData().getConsumptionVariable() : 1);

        bomCalcTrans.SalesPriceQty = BOMCostProfit::calcSalesPrice(bomCalcTrans.CostPriceQty,
                                                                   _costProfitSet,
                                                                   parentCostGroupId);

        bomCalcTrans.SalesPrice    = bomCalcTrans.SalesPriceQty * this.getCostCalcTransData().getQty() / (this.getCostCalcTransData().getConsumptionVariable() ? this.getCostCalcTransData().getConsumptionVariable() : 1);

        bomCalcTrans.CostMarkupQty = this.getCostCalcTransData().getContributionConstant();
        bomCalcTrans.CostMarkup    = bomCalcTrans.CostMarkupQty;

        bomCalcTrans.SalesMarkupQty = BOMCostProfit::calcSalesPrice(bomCalcTrans.CostMarkupQty,
                                                                    _costProfitSet,
                                                                    parentCostGroupId);
        bomCalcTrans.SalesMarkup    = bomCalcTrans.SalesMarkupQty;

        bomCalcTrans.NumOfSeries = 1;
        bomCalcTrans.CostPriceUnit = 1;
        bomCalcTrans.SalesPriceUnit = 1;

        if (bomCalcCheckIndirectCost != null && bomCalcCheckIndirectCost.hasMessages())
        {
            bomCalcTrans.Infolog = bomCalcCheckIndirectCost.getMessages();
        }

        return bomCalcTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toPmfCoByProdCalcTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PmfCoByProdCalcTrans</c> record.
    /// </summary>
    /// <param name="_prodCalcMode">
    /// The calculation mode.
    /// </param>
    /// <param name="_costProfitSet">
    /// A <c>CostProfitSet</c> object.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <returns>
    /// The initialized <c>PmfCoByProdCalcTrans</c> record.
    /// </returns>
    public PmfCoByProdCalcTrans toPmfCoByProdCalcTrans(
        CostSheetProdCalcMode   _prodCalcMode,
        CostProfitSet           _costProfitSet  = CostProfitSet::Standard,
        TransDate               _transDate      = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        PmfCoByProdCalcTrans  prodCalcTrans;

        prodCalcTrans.clear();
        prodCalcTrans.CalcGroupId       = '';
        prodCalcTrans.CostGroupId       = parentCostGroupId;
        prodCalcTrans.CollectRefLevel   = this.getCostCalcTransData().getLevel();
        prodCalcTrans.Qty               = this.getCostCalcTransData().getQty();
        prodCalcTrans.TransDate         = _transDate;
        prodCalcTrans.Resource           = code;
        prodCalcTrans.bom               = NoYes::No;

        switch (_prodCalcMode)
        {
            case CostSheetProdCalcMode::Estimation :
                prodCalcTrans.ConsumpVariable = this.getCostCalcTransData().getConsumptionVariable();
                prodCalcTrans.ConsumpConstant = this.getCostCalcTransData().getConsumptionConstant();
                prodCalcTrans.CostAmount = costCalcTransData.getContributionVariable();
                prodCalcTrans.SalesAmount = BOMCostProfit::calcSalesPrice(
                                                prodCalcTrans.CostAmount,
                                                _costProfitSet,
                                                parentCostGroupId);

                prodCalcTrans.CostMarkup = costCalcTransData.getContributionConstant();
                prodCalcTrans.SalesMarkup = BOMCostProfit::calcSalesPrice(
                                                prodCalcTrans.CostMarkup,
                                                _costProfitSet,
                                                parentCostGroupId);
                break;
            case CostSheetProdCalcMode::Costing :
                prodCalcTrans.RealConsump = this.getCostCalcTransData().getConsumptionConstant()
                                            + this.getCostCalcTransData().getConsumptionVariable();
                prodCalcTrans.RealCostAmount = this.getCostCalcTransData().getCostTotal();
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return prodCalcTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toProdCalcTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a <c>ProdCalcTrans</c> record based on this costing sheet node.
    /// </summary>
    /// <param name="_prodCalcMode">
    ///     An element of the <c>CostSheetProdCalcMode</c> enumeration that identifies whether
    ///     the calculation is made for estimation or actual costing.
    /// </param>
    /// <param name="_costProfitSet">
    ///     An element of the <c>CostProfitSet</c> enumeration that identifies the profit settings.
    /// </param>
    /// <param name="_transDate">
    ///     The date of the transaction.
    /// </param>
    /// <returns>
    ///     The <c>ProdCalcTrans</c> record.
    /// </returns>
    public ProdCalcTrans toProdCalcTrans(
        CostSheetProdCalcMode  _prodCalcMode,
        CostProfitSet           _costProfitSet = CostProfitSet::Standard,
        TransDate               _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
        )
    {
        ProdCalcTrans    prodCalcTrans;

        prodCalcTrans.clear();
        prodCalcTrans.CalcGroupId       = '';
        prodCalcTrans.CostGroupId       = parentCostGroupId;
        prodCalcTrans.CollectRefLevel   = this.getCostCalcTransData().getLevel();
        prodCalcTrans.Qty               = this.getCostCalcTransData().getQty();
        prodCalcTrans.TransDate         = _transDate;
        prodCalcTrans.Resource          = code;
        prodCalcTrans.bom               = NoYes::No;

        switch (_prodCalcMode)
        {
            case CostSheetProdCalcMode::Estimation :
                prodCalcTrans.ConsumpVariable = this.getCostCalcTransData().getConsumptionVariable();
                prodCalcTrans.ConsumpConstant = this.getCostCalcTransData().getConsumptionConstant();
                prodCalcTrans.CostAmount = costCalcTransData.getContributionVariable();
                prodCalcTrans.SalesAmount = BOMCostProfit::calcSalesPrice(prodCalcTrans.CostAmount,
                                                                          _costProfitSet,
                                                                          parentCostGroupId);

                prodCalcTrans.CostMarkup = costCalcTransData.getContributionConstant();
                prodCalcTrans.SalesMarkup = BOMCostProfit::calcSalesPrice(prodCalcTrans.CostMarkup,
                                                                          _costProfitSet,
                                                                          parentCostGroupId);
                break;
            case CostSheetProdCalcMode::Costing :
                prodCalcTrans.RealConsump = this.getCostCalcTransData().getConsumptionConstant() + this.getCostCalcTransData().getConsumptionVariable();
                prodCalcTrans.RealCostAmount = this.getCostCalcTransData().getCostTotal();
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return prodCalcTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toProdIndirectTrans</Name>
				<Source><![CDATA[
    public ProdIndirectTrans toProdIndirectTrans()
    {
        ProdIndirectTrans   prodIndirectTrans;

        prodIndirectTrans.clear();
        prodIndirectTrans.Type = this.getType();
        prodIndirectTrans.Code = code;
        prodIndirectTrans.CostGroupId = parentCostGroupId;
        prodIndirectTrans.Amount = costCalcTransData.getCostTotal();
        prodIndirectTrans.Basis  = costCalcTransData.getConsumptionConstant() + costCalcTransData.getConsumptionVariable();
        prodIndirectTrans.DefaultDimension = prodIndirectTrans.copyDimension(defaultDimension);

        return prodIndirectTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        container           base;
        boolean             ret;
        Integer             version = RunBase::getVersion(_packedClass);
        CostSheetNodeType   nodeType;
        container           packedBasisList;
        container           packedFactorList;
        boolean             areSurchargesPackedByParentContext = conPeek(_packedClass, 2);

        switch (version)
        {
            case #CurrentVersion:
                if (areSurchargesPackedByParentContext)
                {
                    [version, areSurchargesPackedByParentContext, nodeType, #CurrentList, packedBasisList, base] = _packedClass;
                }
                else
                {
                    [version, areSurchargesPackedByParentContext, nodeType, #CurrentList, packedBasisList, packedFactorList, base] = _packedClass;
                    factorList = List::create(packedFactorList);
                }

                basisList = List::create(packedBasisList);
                ret = super(base);
                break;

            case 2:
                container unused;
                [version, nodeType, #CurrentList, packedBasisList, unused, base] = _packedClass;
                basisList = List::create(packedBasisList);
                ret = super(base);
                break;

            default:
                ret = false;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useBasis</Name>
				<Source><![CDATA[
    protected boolean useBasis()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(CostSheet _costSheet)
    {
        boolean ret = super(_costSheet);

        ret = (accountEstimatedIndirectAbsorption ? true : this.checkFailed(strFmt("@SYS105933", "@SYS311628"))) && ret;
        ret = (accountIndirectAbsorption ? true : this.checkFailed(strFmt("@SYS105933", "@SYS105355"))) && ret;

        if (this.getCostType() == CostPriceType::COGM)
        {
            ret = (accountEstimatedIndirectAbsorptionOffset ? true : this.checkFailed(strFmt("@SYS105933", "@SYS311629"))) && ret;
            ret = (accountIndirectAbsorptionOffset ? true : this.checkFailed(strFmt("@SYS105933", "@SYS105354"))) && ret;
        }

        if (factorList.elements() == 0)
        {
            info("@SYS105363", '', SysInfoAction_CostSheetValidate::newNodeId(nodeId));
        }

        Map code2NodeIdMap = _costSheet.getCode2NodeIdMap();

        if (this.useBasis())
        {
            ret = (basisList.elements() >= 1 ? true : this.checkFailed("@SYS105365")) && ret;

            // Find duplicate basises
            Set basisCodeSet = new Set(Types::String);
            Set basisIdentifierSet = new Set(Types::String);

            str basisIdentifier;
            ListEnumerator basisEnumerator = basisList.getEnumerator();
            while (basisEnumerator.moveNext())
            {
                CostSheetCalculationBasis costSheetCalculationBasis = basisEnumerator.current();

                basisCodeSet.add(costSheetCalculationBasis.BasisCode);

                if (this.getBasisSubtypeFieldName() == '')
                {
                    basisIdentifier = costSheetCalculationBasis.BasisCode;
                }
                else
                {
                    SysDictField sysDictField = SysDictField::newName(tableStr(CostSheetCalculationBasis), this.getBasisSubtypeFieldName());
                    basisIdentifier = strFmt("@SYS53184", costSheetCalculationBasis.BasisCode, costSheetCalculationBasis.(sysDictField.id()));
                }

                if (basisIdentifierSet.in(basisIdentifier))
                {
                    ret = this.checkFailed(strFmt("@SYS105361", basisIdentifier)) && ret;
                }
                else
                {
                    if (!code2NodeIdMap.exists(costSheetCalculationBasis.BasisCode))
                    {
                        ret = this.checkFailed(strFmt("@SYS106738", costSheetCalculationBasis.BasisCode)) && ret;
                    }
                }
            }

            // Be sure that there are no direct parents of this particular Calculation among the basis nodes (prevent loops)
            MapEnumerator nodeIndexMapEnumerator = _costSheet.getNodeIndexMapEnumerator();
            while (nodeIndexMapEnumerator.moveNext())
            {
                CostSheetNode costSheetNode = nodeIndexMapEnumerator.currentValue();

                if (basisCodeSet.in(costSheetNode.getCode()))
                {
                    if (this.isDescendantOf(_costSheet, costSheetNode.getNodeId()))
                    {
                        ret = this.checkFailed("@SYS105366") && ret;
                    }
                    else if (costSheetNode.getNodeId() == this.getNodeId())
                    {
                        ret = this.checkFailed("@SYS4002134") && ret;
                    }
                }
            }
        }

        //Check for duplicate factors
        Set usedFactors = new Set(Types::Container);
        ListEnumerator factorEnumerator = factorList.getEnumerator();
        while (factorEnumerator.moveNext())
        {
            ret = !this.checkFactorAlreadyUsed(usedFactors, factorEnumerator.current()) && ret;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFactorAlreadyUsed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the set of fields in <c>CostSheetCalculationFactor</c> is unique across the collection.
    /// </summary>
    /// <param name = "_usedFactors">The <c>Set</c> of field values used for the uniqueness check.</param>
    /// <param name = "_costSheetCalculationFactor">The <c>CostSheetCalculationFactor</c> instance to check its field values.</param>
    /// <returns>true if the set of fields in <c>CostSheetCalculationFactor</c> is already present in the collection; otherwise, false.</returns>
    protected boolean checkFactorAlreadyUsed(Set _usedFactors, CostSheetCalculationFactor _costSheetCalculationFactor)
    {
        container fieldsToValidate = this.fieldsToValidateInCostSheetCalculationFactor(_costSheetCalculationFactor);

        if (_usedFactors.in(fieldsToValidate))
        {
            this.checkFailed(strFmt("@SYS105357", strFmt("@SYS153411", fieldsToValidate)));
            return true;
        }
        else
        {
            _usedFactors.add(fieldsToValidate);
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldsToValidateInCostSheetCalculationFactor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns subset of fields from <c>CostSheetCalculationFactor</c> used in validation.
    /// </summary>
    /// <param name = "_costSheetCalculationFactor">The source <c>CostSheetCalculationFactor</c> for field values.</param>
    /// <returns>The container with the field values.</returns>
    protected container fieldsToValidateInCostSheetCalculationFactor(CostSheetCalculationFactor _costSheetCalculationFactor)
    {
        return [_costSheetCalculationFactor.CostingVersionStatus,
                _costSheetCalculationFactor.VersionId,
                _costSheetCalculationFactor.InventSiteId,
                _costSheetCalculationFactor.ItemCode,
                _costSheetCalculationFactor.ItemRelation,
                _costSheetCalculationFactor.FromDate,
                _costSheetCalculationFactor.LineId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>validSubnodeTypeSet</Name>
				<Source><![CDATA[
    public Set validSubnodeTypeSet()
    {
        return new Set(Types::Enum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a new instance of the <c>CostSheetNodeCalculation</c> class.
    /// </summary>
    /// <param name="_costSheetNodeTable">
    ///     The record in the <c>CostSheetNodeTable</c> table that will be used to initialize this object.
    /// </param>
    /// <param name="_parentNodeId">
    ///     The ID of the parent node.
    /// </param>
    /// <param name="_modeStrategy">
    ///     The <c>CostSheetModeStrategy</c> object that controls the creation of the costing sheet.
    /// </param>
    /// <param name="_parentCostGroupId">
    ///     The ID of the <c>CostSheetNodeGroup</c> object that the calculation node belongs to.
    /// </param>
    /// <returns>
    ///     The new instance of the <c>CostSheetNodeCalculation</c> class.
    /// </returns>
    public static CostSheetNodeCalculation construct(
        CostSheetNodeTable      _costSheetNodeTable,
        CostSheetNodeId         _parentNodeId,
        CostSheetModeStrategy   _modeStrategy,
        CostGroupId             _parentCostGroupId)
    {
        CostSheetNodeCalculation   costSheetNodeCalculation;

        switch (_costSheetNodeTable.Type)
        {
            case CostSheetNodeType::CalculationSurcharge :
                costSheetNodeCalculation = CostSheetNodeCalculationSurcharge::construct(_costSheetNodeTable,
                                                                                         _parentNodeId,
                                                                                         _modeStrategy,
                                                                                         _parentCostGroupId);
                break;

            case CostSheetNodeType::CalculationRate :
                costSheetNodeCalculation = CostSheetNodeCalculationRate::construct(_costSheetNodeTable,
                                                                                    _parentNodeId,
                                                                                    _modeStrategy,
                                                                                    _parentCostGroupId);
                break;

            case CostSheetNodeType::CalculationOutUnitBased :
                costSheetNodeCalculation = CostSheetNodeCalculationOutUnitBased::construct(_costSheetNodeTable,
                                                                                     _parentNodeId,
                                                                                     _modeStrategy,
                                                                                     _parentCostGroupId);
                break;

            case CostSheetNodeType::CalculationInUnitBased :
                costSheetNodeCalculation = CostSheetNodeCalculationInUnitBased::construct(_costSheetNodeTable,
                                                                                       _parentNodeId,
                                                                                       _modeStrategy,
                                                                                       _parentCostGroupId);
                break;

            case CostSheetNodeType::CalculationPurchUnitBased :
                costSheetNodeCalculation = CostSheetNodeCalcPurchUnitBased::construct(_costSheetNodeTable,
                                                                                       _parentNodeId,
                                                                                       _modeStrategy,
                                                                                       _parentCostGroupId);
                break;
        }

        return costSheetNodeCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>compareCostSheetCalculationFactor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Makes comparison between two instances of <c>CostSheetCalculationFactor</c> based on item code, item relation and from date.
    /// </summary>
    /// <param name = "_costSheetCalculationFactor">The <c>CostSheetCalculationFactor</c> instance.</param>
    /// <param name = "_costSheetCalculationFactorToCompare">The <c>CostSheetCalculationFactor</c> instance.</param>
    /// <returns>true if item code, item relation and from date are equal in both instances; otherwise, false.</returns>
    protected boolean compareCostSheetCalculationFactor(CostSheetCalculationFactor _costSheetCalculationFactor, CostSheetCalculationFactor _costSheetCalculationFactorToCompare)
    {
        return _costSheetCalculationFactor.ItemCode     == _costSheetCalculationFactorToCompare.ItemCode &&
               _costSheetCalculationFactor.ItemRelation == _costSheetCalculationFactorToCompare.ItemRelation &&
               _costSheetCalculationFactor.FromDate     == _costSheetCalculationFactorToCompare.FromDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>compareCostSheetCalculationFactorAndAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Makes comparison between two instances of <c>CostSheetCalculationFactor</c> based on item code, item relation, from date and amount.
    /// </summary>
    /// <param name = "_costSheetCalculationFactor">The <c>CostSheetCalculationFactor</c> instance.</param>
    /// <param name = "_costSheetCalculationFactorToCompare">The <c>CostSheetCalculationFactor</c> instance.</param>
    /// <returns>true if item code, item relation, from date and amount are equal in both instances; otherwise, false.</returns>
    protected boolean compareCostSheetCalculationFactorAndAmount(CostSheetCalculationFactor _costSheetCalculationFactor, CostSheetCalculationFactor _costSheetCalculationFactorToCompare)
    {
        return this.compareCostSheetCalculationFactor(_costSheetCalculationFactor, _costSheetCalculationFactorToCompare) &&
               _costSheetCalculationFactor.Amount == _costSheetCalculationFactorToCompare.Amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>compareCostSheetCalculationFactorAndPercentage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Makes comparison between two instances of <c>CostSheetCalculationFactor</c> based on item code, item relation, from date and percentage.
    /// </summary>
    /// <param name = "_costSheetCalculationFactor">The <c>CostSheetCalculationFactor</c> instance.</param>
    /// <param name = "_costSheetCalculationFactorToCompare">The <c>CostSheetCalculationFactor</c> instance.</param>
    /// <returns>true if item code, item relation, from date and percentage are equal in both instances; otherwise, false.</returns>
    protected boolean compareCostSheetCalculationFactorAndPercentage(CostSheetCalculationFactor _costSheetCalculationFactor, CostSheetCalculationFactor _costSheetCalculationFactorToCompare)
    {
        return this.compareCostSheetCalculationFactor(_costSheetCalculationFactor, _costSheetCalculationFactorToCompare) &&
               _costSheetCalculationFactor.Percentage == _costSheetCalculationFactorToCompare.Percentage;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>