<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>FactureCalcAmountAdjustments_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Calculates amount adjustments for facture
/// </summary>
class FactureCalcAmountAdjustments_RU implements IFactureHeaderCaller_RU
{
    CustVendTrans               custVendTransInvoice;
    FactureModule_RU            module;

    FactureJour_RU                      tmpFactureJour;
    FactureTrans_RU                     tmpFactureTrans;
    TaxTrans                            tmpTaxTrans;
    TaxTransGeneralJournalAccountEntry  tmpTaxTransGeneralJournalAccountEntry;
    GeneralJournalAccountEntry          tmpGeneralJournalAccountEntry;
    TmpFactureAmountAdjTrans_RU         tmpFactureAdjustments;

    FactureJour_RU              factureJourSource;
    Map                         mapPaymentDocuments;

    RecId                       taxDimensionAttribute;

    container                   printerSettings;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates amount adjustments for given invoice
    /// </summary>
    public void calc()
    {
        FactureJour_RU      factureJour;
        FactureTrans_RU     factureTrans;
        FactureTrans_RU     factureTransSource;

        CustInvoiceTrans    custInvoiceTrans;
        VendInvoiceTrans    vendInvoiceTrans;
        ;

        if (!custVendTransInvoice.RecId)
            return;

        ttsbegin;

        this.init();

        while select forupdate factureTrans
            where factureTrans.Module == module
        exists join factureJour
            where factureJour.FactureId           == factureTrans.FactureId     &&
                  factureJour.Module              == factureTrans.Module        &&
                  factureJour.ExchAdjInvoiceRecId == custVendTransInvoice.RecId &&
                  factureJour.FactureType         == FactureType_RU::ExchAdj    &&
                  factureJour.AmountAdjustment
        {
            factureTransSource.clear();

            switch (factureTrans.InvoiceTransTableId)
            {
                case tableNum(CustInvoiceTrans) :
                    custInvoiceTrans = CustInvoiceTrans::findRecId(factureTrans.InvoiceTransRecId);

                    select firstonly factureTransSource
                        where factureTransSource.Module              == FactureModule_RU::Cust          &&
                              factureTransSource.FactureLineType     == FactureLineType_RU::InvoiceLine &&
                              factureTransSource.InvoiceLineNum      == custInvoiceTrans.LineNum        &&
                              factureTransSource.InvoiceDate         == custInvoiceTrans.InvoiceDate    &&
                              factureTransSource.InvoiceId           == custInvoiceTrans.InvoiceId      &&
                              factureTransSource.SalesPurchId        == custInvoiceTrans.SalesId        &&
                              factureTransSource.NumberSequenceGroup == custInvoiceTrans.NumberSequenceGroup;
                    break;

                case tableNum(VendInvoiceTrans) :
                    vendInvoiceTrans = VendInvoiceTrans::findRecId(factureTrans.InvoiceTransRecId);

                    select firstonly factureTransSource
                        where factureTransSource.Module              == FactureModule_RU::Vend             &&
                              factureTransSource.FactureLineType     == FactureLineType_RU::InvoiceLine    &&
                              factureTransSource.InvoiceLineNum      == vendInvoiceTrans.LineNum           &&
                              factureTransSource.InternalInvoiceId   == vendInvoiceTrans.InternalInvoiceId &&
                              factureTransSource.InvoiceDate         == vendInvoiceTrans.InvoiceDate       &&
                              factureTransSource.InvoiceId           == vendInvoiceTrans.InvoiceId         &&
                              factureTransSource.SalesPurchId        == vendInvoiceTrans.PurchID           &&
                              factureTransSource.NumberSequenceGroup == vendInvoiceTrans.NumberSequenceGroup;
                    break;

                case tableNum(MarkupTrans) :
                    select firstonly FactureId from factureTransSource
                        where factureTransSource.FactureLineType == FactureLineType_RU::Markup &&
                              factureTransSource.MarkupRefRecId  == factureTrans.InvoiceTransRecId;
            }

            factureTrans.SourceFactureId = factureTransSource.FactureId;
            factureTrans.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcFactureOnDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates facture amounts on specified date
    /// </summary>
    /// <param name="_factureJourSource">
    /// Source facture journal
    /// </param>
    /// <param name="_calcDate">
    /// Date of revaluation
    /// </param>
    /// <param name="_includedOnly">
    /// Determines if only included in book facture trans should be processed
    /// </param>
    #define.factureTransValue([factureTrans.LineAmountMST,
                               factureTrans.TaxAmountMST,
                               factureTrans.ExciseAmountMST,
                               factureTrans.vatAmountMST])

    #define.tmpFactureTransValue([tmpFactureTrans.LineAmountMST,
                                  tmpFactureTrans.TaxAmountMST,
                                  tmpFactureTrans.ExciseAmountMST,
                                  tmpFactureTrans.vatAmountMST])

    public void calcFactureOnDate(FactureJour_RU _factureJourSource,
                                  TransDate      _calcDate,
                                  boolean        _includedOnly)
    {
        TaxCode                     taxCode;
        DimensionDefault            defaultDimension;
        FactureJour_RU              factureJour;
        FactureTrans_RU             factureTrans;
        FactureTrans_RU             factureTransSource;
        CustVendTransPostingLog_RU  postingLog;
        container                   key;
        container                   value;
        MapEnumerator               enumerator;
        CustVendTrans               paymentTrans;
        Map                         mapFactureAmounts     = new Map(Types::Container, Types::Container);
        Map                         mapFactureAdjustments = new Map(Types::Container, Types::Container);
        Map                         mapUsedAdjustments    = new Map(Types::Container, Types::Container);
        ;

        delete_from tmpFactureJour;
        delete_from tmpFactureTrans;

        paymentTrans = CustVendTransStatic::newModuleCustVend(_factureJourSource.Module == FactureModule_RU::Cust ?
                                                              ModuleCustVend::Cust                                :
                                                              ModuleCustVend::Vend).custVendTrans();

        buf2Buf(_factureJourSource, tmpFactureJour);
        tmpFactureJour.PrintInMST = NoYes::Yes;
        tmpFactureJour.insert();

        while select sum(LineAmountMST),
                     sum(TaxAmountMST),
                     sum(ExciseAmountMST),
                     sum(vatAmountMST)
                from factureTrans
            group by TaxCode, DefaultDimension
            where factureTrans.Module          == _factureJourSource.Module    &&
                  factureTrans.SourceFactureId == _factureJourSource.FactureId &&
                 (! _includedOnly || ! factureTrans.ExcludeFromBook)
        exists join factureJour
            where factureJour.FactureId   == factureTrans.FactureId  &&
                  factureJour.Module      == factureTrans.Module     &&
                  factureJour.FactureDate <= _calcDate               &&
                  factureJour.FactureType == FactureType_RU::ExchAdj &&
                  factureJour.AmountAdjustment                       &&
                 !factureJour.Reversed
        {
            key   = [factureTrans.TaxCode, factureTrans.DefaultDimension];
            value = #factureTransValue;

            mapFactureAdjustments.insert(key, value);

            select sum(LineAmountMST),
                   sum(TaxAmountMST),
                   sum(ExciseAmountMST),
                   sum(vatAmountMST)
                from factureTransSource
                where factureTransSource.FactureId        == _factureJourSource.FactureId &&
                      factureTransSource.Module           == _factureJourSource.Module    &&
                      factureTransSource.TaxCode          == factureTrans.TaxCode         &&
                      factureTransSource.DefaultDimension == factureTrans.DefaultDimension;

            value = [factureTransSource.LineAmountMST,
                     factureTransSource.TaxAmountMST,
                     factureTransSource.ExciseAmountMST,
                     factureTransSource.vatAmountMST];

            mapFactureAmounts.insert(key, value);
        }

        while select factureTrans
            where factureTrans.FactureId == _factureJourSource.FactureId &&
                  factureTrans.Module    == _factureJourSource.Module
        {
            key = [factureTrans.TaxCode, factureTrans.DefaultDimension];

            if (mapFactureAmounts.exists(key))
            {
                value = this.conRatio(#factureTransValue, mapFactureAmounts.lookup(key), mapFactureAdjustments.lookup(key));

                #factureTransValue = this.conAdd(#factureTransValue, value);

                if (mapUsedAdjustments.exists(key))
                {
                    value = this.conAdd(mapUsedAdjustments.lookup(key), value);
                }

                mapUsedAdjustments.insert(key, value);
            }

            buf2Buf(factureTrans, tmpFactureTrans);
            tmpFactureTrans.insert();
        }

        enumerator = mapUsedAdjustments.getEnumerator();
        while (enumerator.moveNext())
        {
            [taxCode, defaultDimension] = enumerator.currentKey();

            value = this.conSub(mapFactureAdjustments.lookup([taxCode, defaultDimension]), enumerator.currentValue());

            select firstonly forupdate tmpFactureTrans
                order by LineAmountMST desc
                where tmpFactureTrans.TaxCode          == taxCode &&
                      tmpFactureTrans.DefaultDimension == defaultDimension;

            #tmpFactureTransValue = this.conAdd(#tmpFactureTransValue, value);
            tmpFactureTrans.update();
        }

        mapPaymentDocuments = new Map(Types::String, Types::Container);

        while select PostingLogRecId, FactureId from factureJour
            where factureJour.FactureDate <= _calcDate               &&
                  factureJour.FactureType == FactureType_RU::ExchAdj &&
                  factureJour.AmountAdjustment                       &&
                 !factureJour.Reversed
        exists join factureTrans
            where factureTrans.FactureId       == factureJour.FactureId        &&
                  factureTrans.Module          == factureJour.Module           &&
                  factureTrans.Module          == _factureJourSource.Module    &&
                  factureTrans.SourceFactureId == _factureJourSource.FactureId &&
                 (! _includedOnly || ! factureTrans.ExcludeFromBook)
        {
            select firstonly paymentTrans
                where paymentTrans.DocumentNum  &&
                      paymentTrans.DocumentDate &&
                      paymentTrans.Invoice == ''
            exists join postingLog
                where postingLog.RecId          == factureJour.PostingLogRecId &&
                    ((postingLog.TransRecId     == paymentTrans.RecId          &&
                      postingLog.TransCompany   == paymentTrans.DataAreaId)    ||
                     (postingLog.OffSetRecId    == paymentTrans.RecId          &&
                      postingLog.OffsetCompany  == paymentTrans.DataAreaId));

            if (paymentTrans)
            {
                mapPaymentDocuments.insert(factureJour.FactureId, [paymentTrans.DocumentNum, paymentTrans.DocumentDate]);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates tax data
    /// </summary>
    /// <param name="_exchAdjTrans">
    /// Customer or vendor transaction representing amount adjustment
    /// </param>
    /// <param name="_totalFactureAmountMST">
    /// Total amount of facture in base currency
    /// </param>
    /// <param name="_ledgerVoucher">
    /// Ledger voucher holding taxTrans relations
    /// </param>
    public void calcTaxTrans(CustVendTrans _exchAdjTrans, AmountMST _totalFactureAmountMST, LedgerVoucher _ledgerVoucher)
    {
        TaxTrans                           taxTrans;

        TaxTrans                    tmpTaxTransLocal;
        TaxTable                    taxTable;
        container                   key, value;
        TaxCode                     taxCode;
        DimensionDefault            defaultDimension;

        CustVendInvoiceJour         custVendInvoiceJour;
        CustVendInvoiceTrans        custVendInvoiceTrans;
        CustVendTransPostingLog_RU  postingLog;
        MapEnumerator               enumerator;
        QueryRun                    queryRun;
        QueryBuildDataSource        dataSource;
        MarkupTrans                 markupTrans;
        AmountMST                   pennyDiff;
        CustVendTrans               custVendTrans      = custVendTransInvoice;
        Query                       query              = new Query();
        Map                         mapInvoiceAmounts  = new Map(Types::Container, Types::Container);
        Map                         mapUsedAdjustments = new Map(Types::Container, Types::Container);
        LedgerVoucherObject         ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();

        TaxAmount                   taxAmount, taxBaseAmount;

        LedgerDimensionAccount taxTransLedgerDimension(TaxTransRecId _taxTrans)
        {
            LedgerDimensionAccount ret = ledgerVoucherObject.getLedgerDimensionForTaxTrans_RU(taxTrans.RecId, TaxTransRelationshipType::Tax);
            if (!ret)
            {
                ret = TaxTransGeneralJournalAccountEntry::getTaxLedgerDimensionForTaxTrans(_taxTrans);
            }
            if (!ret)
            {
                ret = TaxTransGeneralJournalAccountEntry::find_RU(_taxTrans, TaxTransRelationshipType::Tax).LedgerDimension;
            }
            return ret;
        }
        void processUsedAdjustments()
        {
            DimensionDefault taxTransDefaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(taxTransLedgerDimension(taxTrans.RecId));

            if (mapUsedAdjustments.exists([taxTrans.TaxCode, taxTransDefaultDimension]))
            {
                value = this.conAdd(mapUsedAdjustments.lookup([taxTrans.TaxCode, taxTransDefaultDimension]), value);
            }

            mapUsedAdjustments.insert([taxTrans.TaxCode, taxTransDefaultDimension], value);
        }

        void processMarkup(RefTableId _tableId, RefRecId _recId, DimensionDefault _dimensionDefault)
        {
            while select forupdate markupTrans
                where markupTrans.TransTableId  == _tableId &&
                      markupTrans.TransRecId    == _recId   &&
                      markupTrans.CustVendPosted_RU
            {
                taxCode          = TaxTable::vatCode_RU(markupTrans.TaxGroup, markupTrans.TaxItemGroup);
                defaultDimension = this.getDefaultDimension(_dimensionDefault);

                key   = [taxCode, defaultDimension];
                value = [markupTrans.CustVendPosted_RU, markupTrans.TaxAmountVAT_RU];

                if (mapInvoiceAmounts.exists(key))
                {
                    value = this.conAdd(mapInvoiceAmounts.lookup(key), value);
                }

                mapInvoiceAmounts.insert(key, value);
            }
        }

        void processMarkupTax(RefTableId _tableId, RefRecId _recId, DimensionDefault _defaultDimension)
        {
            while select forupdate markupTrans
                where markupTrans.TransTableId  == _tableId &&
                      markupTrans.TransRecId    == _recId   &&
                      markupTrans.CustVendPosted_RU
            {
                taxCode          = TaxTable::vatCode_RU(markupTrans.TaxGroup, markupTrans.TaxItemGroup);
                defaultDimension = this.getDefaultDimension(_defaultDimension);

                if (key == [taxCode, defaultDimension])
                {
                    value = [markupTrans.CustVendPosted_RU, markupTrans.TaxAmountVAT_RU];
                    value = this.conRatio([taxTrans.TaxBaseAmount, taxTrans.TaxAmount], mapInvoiceAmounts.lookup(key), value);
                    value = [CurrencyExchangeHelper::amount(conPeek(value, 1)), CurrencyExchangeHelper::amount(conPeek(value, 2))];

                    select firstonly forupdate tmpTaxTransLocal
                        where tmpTaxTransLocal.SourceTableId == markupTrans.TableId &&
                              tmpTaxTransLocal.SourceRecId   == markupTrans.RecId;

                    if (tmpTaxTransLocal)
                    {
                        [tmpTaxTransLocal.TaxBaseAmount, tmpTaxTransLocal.TaxAmount] = this.conAdd([tmpTaxTransLocal.TaxBaseAmount, tmpTaxTransLocal.TaxAmount], value);

                        tmpTaxTransLocal.update();
                    }
                    else
                    {
                        [tmpTaxTrans.TaxBaseAmount, tmpTaxTrans.TaxAmount] = value;

                        tmpTaxTrans.SourceTableId   = markupTrans.TableId;
                        tmpTaxTrans.SourceRecId     = markupTrans.RecId;
                        tmpTaxTrans.insert();

                        tmpGeneralJournalAccountEntry.LedgerDimension                    = _defaultDimension;
                        tmpGeneralJournalAccountEntry.insert();

                        tmpTaxTransGeneralJournalAccountEntry.TaxTrans                   = tmpTaxTrans.RecId;
                        tmpTaxTransGeneralJournalAccountEntry.TaxTransRelationship       = TaxTransRelationshipType::Tax;
                        tmpTaxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry = tmpGeneralJournalAccountEntry.RecId;
                        tmpTaxTransGeneralJournalAccountEntry.insert();
                    }

                    processUsedAdjustments();
                }
            }
        }

        void processDimension()
        {
            switch (tmpTaxTrans.SourceTableId)
            {
                case tableNum(CustInvoiceTrans) :
                    tmpGeneralJournalAccountEntry.LedgerDimension = CustInvoiceTrans::findRecId(tmpTaxTrans.SourceRecId).DefaultDimension;
                    break;

                case tableNum(VendInvoiceTrans) :
                    tmpGeneralJournalAccountEntry.LedgerDimension = VendInvoiceTrans::findRecId(tmpTaxTrans.SourceRecId).DefaultDimension;
                    break;

                case tableNum(MarkupTrans)      :
                    markupTrans = MarkupTrans::findRecId_W(tmpTaxTrans.SourceRecId);

                    switch (markupTrans.TransTableId)
                    {
                        case tableNum(CustInvoiceJour)  :
                            tmpGeneralJournalAccountEntry.LedgerDimension = CustInvoiceJour::findRecId(markupTrans.TransRecId).DefaultDimension;
                            break;
                        case tableNum(VendInvoiceJour)  :
                            tmpGeneralJournalAccountEntry.LedgerDimension = VendInvoiceJour::findRecId(markupTrans.TransRecId).DefaultDimension;
                            break;
                        case tableNum(CustInvoiceTrans)  :
                            tmpGeneralJournalAccountEntry.LedgerDimension = CustInvoiceTrans::findRecId(markupTrans.TransRecId).DefaultDimension;
                            break;
                        case tableNum(VendInvoiceTrans)  :
                            tmpGeneralJournalAccountEntry.LedgerDimension = VendInvoiceTrans::findRecId(markupTrans.TransRecId).DefaultDimension;
                            break;
                    }
                    break;
            }
        }

        if (! custVendTrans.RecId)
        {
            return;
        }

        delete_from tmpTaxTrans;

        tmpTaxTransLocal.setTmp();
        tmpTaxTransLocal.setTmpData(tmpTaxTrans);

        switch (custVendTrans.TableId)
        {
            case (tableNum(CustTrans)) :
                custVendInvoiceJour = CustInvoiceJour::findFromCustTrans(custVendTrans.Invoice,
                                                                         custVendTrans.TransDate,
                                                                         custVendTrans.AccountNum,
                                                                         false,
                                                                         custVendTrans.Voucher);

                dataSource = query.addDataSource(tableNum(CustInvoiceTrans));
                findOrCreateRange_W(dataSource, fieldNum(CustInvoiceTrans, SalesId), queryValue(custVendInvoiceJour.Num));
                findOrCreateRange_W(dataSource, fieldNum(CustInvoiceTrans, InvoiceId), queryValue(custVendInvoiceJour.InvoiceId));
                findOrCreateRange_W(dataSource, fieldNum(CustInvoiceTrans, InvoiceDate), queryValue(custVendInvoiceJour.InvoiceDate));
                findOrCreateRange_W(dataSource, fieldNum(CustInvoiceTrans, NumberSequenceGroup), queryValue(custVendInvoiceJour.NumberSequenceGroupId));

                break;
            case (tableNum(VendTrans)) :
                custVendInvoiceJour = VendInvoiceJour::findFromVendTrans(custVendTrans.Invoice,
                                                                         custVendTrans.TransDate,
                                                                         custVendTrans.AccountNum,
                                                                         false,
                                                                         custVendTrans.Voucher);

                dataSource = query.addDataSource(tableNum(VendInvoiceTrans));
                findOrCreateRange_W(dataSource, fieldNum(VendInvoiceTrans, PurchID), queryValue(custVendInvoiceJour.Num));
                findOrCreateRange_W(dataSource, fieldNum(VendInvoiceTrans, InvoiceId), queryValue(custVendInvoiceJour.InvoiceId));
                findOrCreateRange_W(dataSource, fieldNum(VendInvoiceTrans, InvoiceDate), queryValue(custVendInvoiceJour.InvoiceDate));
                findOrCreateRange_W(dataSource, fieldNum(VendInvoiceTrans, NumberSequenceGroup), queryValue(custVendInvoiceJour.NumberSequenceGroupId));
                findOrCreateRange_W(dataSource, fieldNum(VendInvoiceTrans, InternalInvoiceId), queryValue(custVendInvoiceJour.PurchInternalInvoiceId_RU));

                break;
        }

        processMarkup(custVendInvoiceJour.TableId, custVendInvoiceJour.RecId, custVendInvoiceJour.DefaultDimension);

        queryRun = new QueryRun(query);
        while (queryRun.next())
        {
            custVendInvoiceTrans = queryRun.getNo(1);

            taxCode   = TaxTable::vatCode_RU(custVendInvoiceTrans.TaxGroup_RU, custVendInvoiceTrans.TaxItemGroup_RU);
            defaultDimension = this.getDefaultDimension(custVendInvoiceTrans.DefaultDimension_RU);

            key   = [taxCode, defaultDimension];
            value = [custVendInvoiceTrans.LineAmountMST_W, custVendInvoiceTrans.CustVendInvoiceTrans::getVATAmountMST_RU()];

            if (mapInvoiceAmounts.exists(key))
            {
                value = this.conAdd(mapInvoiceAmounts.lookup(key), value);
            }

            mapInvoiceAmounts.insert(key, value);

            processMarkup(custVendInvoiceTrans.TableId, custVendInvoiceTrans.RecId, custVendInvoiceTrans.DefaultDimension_RU);
        }

        while select taxTrans
            where taxTrans.TransDate     == _exchAdjTrans.TransDate &&
                  taxTrans.Voucher       == _exchAdjTrans.Voucher   &&
                  taxTrans.SourceRecId   == _exchAdjTrans.RecId     &&
                  taxTrans.SourceTableId == _exchAdjTrans.TableId
        join TaxType_W from taxTable
            where  taxTable.TaxCode   == taxTrans.TaxCode &&
                  (taxTable.TaxType_W == TaxType_W::VAT          ||
                   taxTable.TaxType_W == TaxType_W::VATReduced   ||
                   taxTable.TaxType_W == TaxType_W::VATZero)

        {
            buf2Buf(taxTrans, tmpTaxTrans);

            tmpTaxTrans.SourceTableId = 0;
            tmpTaxTrans.SourceRecId   = 0;
            tmpTaxTransLocal.clear();

            select firstonly postingLog
                where postingLog.TransDate == taxTrans.TransDate &&
                      postingLog.Voucher   == taxTrans.Voucher   &&
                      postingLog.RecId     == taxTrans.taxTrans_RU().CustVendTransPostingLog_RU;

            if (postingLog.InvoiceTransRecId)
            {
                tmpTaxTrans.SourceTableId   = postingLog.InvoiceTransTableId;
                tmpTaxTrans.SourceRecId     = postingLog.InvoiceTransRecId;

                processDimension();

                tmpTaxTrans.insert();

                tmpGeneralJournalAccountEntry.insert();

                tmpTaxTransGeneralJournalAccountEntry.TaxTrans                   = tmpTaxTrans.RecId;
                tmpTaxTransGeneralJournalAccountEntry.TaxTransRelationship       = TaxTransRelationshipType::Tax;
                tmpTaxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry = tmpGeneralJournalAccountEntry.RecId;
                tmpTaxTransGeneralJournalAccountEntry.insert();

                continue;
            }

            key = [taxTrans.TaxCode,
                   this.getDefaultDimension(LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(taxTransLedgerDimension(taxTrans.RecId)))];

            processMarkupTax(custVendInvoiceJour.TableId, custVendInvoiceJour.RecId, custVendInvoiceJour.DefaultDimension);

            queryRun = new QueryRun(query);
            while (queryRun.next())
            {
                custVendInvoiceTrans = queryRun.getNo(1);

                taxCode          = TaxTable::vatCode_RU(custVendInvoiceTrans.TaxGroup_RU, custVendInvoiceTrans.TaxItemGroup_RU);
                defaultDimension = this.getDefaultDimension(custVendInvoiceTrans.DefaultDimension_RU);

                if (key == [taxCode, defaultDimension])
                {
                    value = [custVendInvoiceTrans.LineAmountMST_W, custVendInvoiceTrans.CustVendInvoiceTrans::getVATAmountMST_RU()];
                    value = this.conRatio([taxTrans.TaxBaseAmount, taxTrans.TaxAmount], mapInvoiceAmounts.lookup(key), value);
                    value = [CurrencyExchangeHelper::amount(conPeek(value, 1)), CurrencyExchangeHelper::amount(conPeek(value, 2))];

                    select firstonly forupdate tmpTaxTransLocal
                        where tmpTaxTransLocal.SourceTableId == custVendInvoiceTrans.TableId &&
                              tmpTaxTransLocal.SourceRecId   == custVendInvoiceTrans.RecId;

                    if (tmpTaxTransLocal)
                    {
                        [tmpTaxTransLocal.TaxBaseAmount, tmpTaxTransLocal.TaxAmount] = this.conAdd([tmpTaxTransLocal.TaxBaseAmount, tmpTaxTransLocal.TaxAmount], value);

                        tmpTaxTransLocal.update();
                    }
                    else
                    {
                        [tmpTaxTrans.TaxBaseAmount, tmpTaxTrans.TaxAmount] = value;

                        tmpTaxTrans.SourceTableId   = custVendInvoiceTrans.TableId;
                        tmpTaxTrans.SourceRecId     = custVendInvoiceTrans.RecId;
                        tmpTaxTrans.insert();

                        tmpGeneralJournalAccountEntry.LedgerDimension                    = custVendInvoiceTrans.DefaultDimension_RU;
                        tmpGeneralJournalAccountEntry.insert();

                        tmpTaxTransGeneralJournalAccountEntry.TaxTrans                   = tmpTaxTrans.RecId;
                        tmpTaxTransGeneralJournalAccountEntry.TaxTransRelationship       = TaxTransRelationshipType::Tax;
                        tmpTaxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry = tmpGeneralJournalAccountEntry.RecId;
                        tmpTaxTransGeneralJournalAccountEntry.insert();
                    }

                    processUsedAdjustments();
                }

                processMarkupTax(custVendInvoiceTrans.TableId, custVendInvoiceTrans.RecId, custVendInvoiceTrans.DefaultDimension_RU);
            }

            if (! tmpTaxTrans.SourceRecId && ! tmpTaxTransLocal.SourceRecId)
            {
                tmpTaxTrans.insert();

                value = [taxTrans.TaxBaseAmount, taxTrans.TaxAmount];
                processUsedAdjustments();
            }
        }

        enumerator = mapUsedAdjustments.getEnumerator();
        while (enumerator.moveNext())
        {
            [taxCode, defaultDimension] = enumerator.currentKey();

            taxAmount     = 0;
            taxBaseAmount = 0;

            while select TaxBaseAmount, TaxAmount, RecId
                from taxTrans
                where taxTrans.TransDate     == _exchAdjTrans.TransDate &&
                      taxTrans.Voucher       == _exchAdjTrans.Voucher   &&
                      taxTrans.SourceRecId   == _exchAdjTrans.RecId     &&
                      taxTrans.SourceTableId == _exchAdjTrans.TableId   &&
                      taxTrans.TaxCode       == taxCode
            {
                if (defaultDimension == LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(taxTransLedgerDimension(taxTrans.RecId))
                )
                {
                    taxAmount     += taxTrans.TaxAmount;
                    taxBaseAmount += taxTrans.TaxBaseAmount;
                }
            }

            value = this.conSub([taxBaseAmount, taxAmount], enumerator.currentValue());

            while select forupdate tmpTaxTrans
                order by TaxBaseAmount desc
                where tmpTaxTrans.TaxCode == taxCode
            join * from tmpTaxTransGeneralJournalAccountEntry
                where tmpTaxTrans.RecId                                          == tmpTaxTransGeneralJournalAccountEntry.TaxTrans &&
                      tmpTaxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::Tax
            join RecId, LedgerDimension from tmpGeneralJournalAccountEntry
                where tmpGeneralJournalAccountEntry.RecId                        == tmpTaxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry
            {
                if (tmpGeneralJournalAccountEntry.LedgerDimension == this.getDefaultDimension(defaultDimension))
                {
                    [tmpTaxTrans.TaxBaseAmount, tmpTaxTrans.TaxAmount] = this.conAdd([tmpTaxTrans.TaxBaseAmount, tmpTaxTrans.TaxAmount], value);
                    tmpTaxTrans.update();
                    break;
                }
            }
        }

        select sum(TaxBaseAmount),
               sum(TaxAmount) from tmpTaxTransLocal;

        pennyDiff = abs(_totalFactureAmountMST) - abs(tmpTaxTransLocal.TaxBaseAmount + tmpTaxTransLocal.TaxAmount);

        if (abs(pennyDiff) <= LedgerParameters::find().MaxRoundingDifferenceMST)
        {
            select firstonly forupdate tmpTaxTrans
                order by TaxBaseAmount desc;

            if (tmpTaxTrans)
            {
                tmpTaxTrans.TaxBaseAmount += pennyDiff * sign(tmpTaxTransLocal.TaxBaseAmount);
                tmpTaxTrans.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>conAdd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Summarises values in two containers
    /// </summary>
    /// <param name="_c1">
    /// First container
    /// </param>
    /// <param name="_c2">
    /// Second container
    /// </param>
    /// <returns>
    /// Container with summarized data
    /// </returns>
    private container conAdd(container _c1, container _c2)
    {
        int       idx;
        container ret;
        ;

        for (idx = 1; idx <= conLen(_c1); idx++)
        {
            ret += conPeek(_c1, idx) + conPeek(_c2, idx);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>conRatio</Name>
				<Source><![CDATA[
    /// <summary>
    /// Divides values in two containers and multiplies them to  specified factor
    /// </summary>
    /// <param name="_dividend">
    /// First container
    /// </param>
    /// <param name="_divisor">
    /// Second container
    /// </param>
    /// <param name="_factor">
    /// Container with factors
    /// </param>
    /// <returns>
    /// Container with subtracted data
    /// </returns>
    private container conRatio(container _dividend, container _divisor, container _factor)
    {
        int       idx;
        container ret;
        ;

        for (idx = 1; idx <= conLen(_dividend); idx++)
        {
            ret += (conPeek(_divisor, idx) ? conPeek(_dividend, idx) / conPeek(_divisor, idx) * conPeek(_factor, idx) : 0);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>conSub</Name>
				<Source><![CDATA[
    /// <summary>
    /// Subtracts values in two containers
    /// </summary>
    /// <param name="_c1">
    /// First container
    /// </param>
    /// <param name="_c2">
    /// Second container
    /// </param>
    /// <returns>
    /// Container with subtracted data
    /// </returns>
    private container conSub(container _c1, container _c2)
    {
        int       idx;
        container ret;
        ;

        for (idx = 1; idx <= conLen(_c1); idx++)
        {
            ret += conPeek(_c1, idx) - conPeek(_c2, idx);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes tax dimension attribute from specified default dimension
    /// </summary>
    /// <param name="_defaultDimension">
    /// Default dimension to be processed
    /// </param>
    /// <returns>
    /// Created default dimension
    /// </returns>
    private DimensionDefault getDefaultDimension(DimensionDefault _defaultDimension)
    {
        DimensionAttributeValueSetStorage dimAttrValueSetStorage = DimensionAttributeValueSetStorage::find(_defaultDimension);

        dimAttrValueSetStorage.removeDimensionAttribute(taxDimensionAttribute);

        return dimAttrValueSetStorage.save();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactureJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns facture journal
    /// </summary>
    /// <returns>
    /// Facture journal
    /// </returns>
    public FactureJour_RU getFactureJour()
    {
        return tmpFactureJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactureTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns created <c>FactureTrans_RU</c> temporary table
    /// </summary>
    /// <returns>
    /// Created <c>FactureTrans_RU</c> temporary table
    /// </returns>
    public FactureTrans_RU getFactureTrans()
    {
        return tmpFactureTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGeneralJournalAccountEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns created <c>GeneralJournalAccountEntry</c> record
    /// </summary>
    /// <returns>
    /// Created <c>GeneralJournalAccountEntry</c> record
    /// </returns>
    public GeneralJournalAccountEntry getGeneralJournalAccountEntry()
    {
        return tmpGeneralJournalAccountEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentDoc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns container with payment documents.
    /// </summary>
    /// <returns>
    /// Container with payment documents.
    /// </returns>
    public container getPaymentDoc()
    {
        MapEnumerator enumerator;
        container     ret = ['', ''];
        ;

        if (! mapPaymentDocuments)
        {
            return ret;
        }

        enumerator = mapPaymentDocuments.getEnumerator();

        if (enumerator.moveNext())
        {
            ret = enumerator.currentValue();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns string containing description of payment documents
    /// </summary>
    /// <returns>
    /// String containing description of payment documents
    /// </returns>
    public str getPaymentInfo()
    {
        DocumentNum   documentNum;
        DocumentDate  documentDate;
        MapEnumerator enumerator;
        str           ret;
        ;

        if (! mapPaymentDocuments)
        {
            return '';
        }

        enumerator = mapPaymentDocuments.getEnumerator();

        while (enumerator.moveNext())
        {
            [documentNum, documentDate] = enumerator.currentValue();

            if (ret)
            {
                ret += ', ';
            }

            ret += strFmt("@GLS114490", documentNum, documentDate);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns created <c>TaxTrans</c> record
    /// </summary>
    /// <returns>
    /// Created <c>TaxTrans</c> record
    /// </returns>
    public TaxTrans getTaxTrans()
    {
        select firstonly tmpTaxTrans;
        return tmpTaxTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxTransGeneralJournalAccountEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns created <c>TaxTransGeneralJournalAccountEntry</c> record
    /// </summary>
    /// <returns>
    /// Created <c>TaxTransGeneralJournalAccountEntry</c> record
    /// </returns>
    public TaxTransGeneralJournalAccountEntry getTaxTransGeneralJournalAccountEntry()
    {
        return tmpTaxTransGeneralJournalAccountEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes class internal variables and prepares data for processing
    /// </summary>
    protected void init()
    {
        FactureJour_RU  factureJour;
        FactureTrans_RU factureTrans;
        ;

        module = custVendTransInvoice.TableId == tableNum(CustTrans) ? FactureModule_RU::Cust : FactureModule_RU::Vend;

        update_recordset factureTrans
            setting SourceFactureId = ''
            where factureTrans.Module == module
        exists join factureJour
            where factureJour.FactureId           == factureTrans.FactureId     &&
                  factureJour.Module              == factureTrans.Module        &&
                  factureJour.ExchAdjInvoiceRecId == custVendTransInvoice.RecId &&
                  factureJour.FactureType         == FactureType_RU::ExchAdj    &&
                  factureJour.AmountAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProforma</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether created facture is proforma
    /// </summary>
    /// <returns>
    /// Always false, as amount adjustments have no proforma
    /// </returns>
    public boolean isProforma()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        tmpFactureJour.setTmp();
        tmpFactureTrans.setTmp();
        tmpTaxTrans.setTmp();
        tmpTaxTransGeneralJournalAccountEntry.setTmp();
        tmpGeneralJournalAccountEntry.setTmp();

        taxDimensionAttribute = RTax25Parameters::find().DimensionAttribute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendTrans</Name>
				<Source><![CDATA[
    public CustVendTrans parmCustVendTrans(CustVendTrans _custVendTrans = custVendTransInvoice)
    {
        ;
        custVendTransInvoice = _custVendTrans;

        return custVendTransInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFindOfficials</Name>
				<Source><![CDATA[
    public boolean parmFindOfficials(boolean _findOfficials = false)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrinterSettings</Name>
				<Source><![CDATA[
    public container parmPrinterSettings(container _settings = printerSettings)
    {
        printerSettings = _settings;
        return printerSettings;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printFacture</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints specified facture journal
    /// </summary>
    /// <param name="_factureJour">
    /// A <c>FactureJour_RU</c> to be printed
    /// </param>
    /// <param name="_printCopyOriginal">
    /// Determines whether copy or original should be printed
    /// </param>
    /// <exception cref="Exception::Error">
    /// When OriginalPrint passed as parameter
    /// </exception>
    public void printFacture(FactureJour_RU _factureJour, PrintCopyOriginal _printCopyOriginal)
    {
        FactureJour_RU              factureJourSrc;
        FactureTrans_RU             factureTrans;
        FactureTrans_RU             factureTransGrp;
        CustVendTransPostingLog_RU  postingLog;
        CustVendTrans               paymentTrans;
        MenuFunction                func;
        Args                        args         = new Args();
        ;

        delete_from tmpFactureJour;

        buf2Buf(_factureJour, tmpFactureJour);

        paymentTrans = CustVendTransStatic::newModuleCustVend(_factureJour.Module == FactureModule_RU::Cust ?
                                                              ModuleCustVend::Cust                          :
                                                              ModuleCustVend::Vend).custVendTrans();

        select firstonly paymentTrans
            where paymentTrans.Invoice == ''
        exists join postingLog
            where postingLog.RecId          == _factureJour.PostingLogRecId &&
                ((postingLog.TransRecId     == paymentTrans.RecId           &&
                  postingLog.TransCompany   == paymentTrans.DataAreaId)     ||
                 (postingLog.OffSetRecId    == paymentTrans.RecId           &&
                  postingLog.OffsetCompany  == paymentTrans.DataAreaId));

        tmpFactureJour.DocumentNum  = paymentTrans.DocumentNum;
        tmpFactureJour.DocumentDate = paymentTrans.DocumentDate;
        tmpFactureJour.insert();

        mapPaymentDocuments = new Map(Types::String, Types::Container);
        mapPaymentDocuments.insert(tmpFactureJour.FactureId, [paymentTrans.DocumentNum, paymentTrans.DocumentDate]);

        while select factureTransGrp
            group by SourceFactureId
            where factureTransGrp.FactureId == _factureJour.FactureId &&
                  factureTransGrp.Module    == _factureJour.Module
        {
            factureJourSrc = FactureJour_RU::find(factureTransGrp.SourceFactureId, _factureJour.Module);

            if (factureJourSrc)
            {
                tmpFactureJour.FactureExternalId    = factureJourSrc.FactureExternalId;
                tmpFactureJour.FactureDate_External = factureJourSrc.FactureDate_External ?
                                                      factureJourSrc.FactureDate_External :
                                                      factureJourSrc.FactureDate;
                tmpFactureJour.update();
            }

            delete_from tmpFactureTrans;

            while select factureTrans
                where factureTrans.FactureId        == _factureJour.FactureId &&
                      factureTrans.Module           == _factureJour.Module    &&
                      factureTrans.SourceFactureId  == factureTransGrp.SourceFactureId
            {
                buf2Buf(factureTrans, tmpFactureTrans);
                tmpFactureTrans.insert();
            }

            if (tmpFactureTrans)
            {
                if (_factureJour.isCorrection())
                {
                    func = new MenuFunction(menuitemoutputstr(CustVendCorrFactureToExcel_RU), MenuItemType::Output);
                }
                else
                {
                    switch (_printCopyOriginal)
                    {
                        case PrintCopyOriginal::Original :
                            func = new MenuFunction(menuitemOutputStr(FactureOriginal_RU), MenuItemType::Output);
                            break;
                        case PrintCopyOriginal::Copy :
                            func = new MenuFunction(menuitemOutputStr(FactureCopy_RU), MenuItemType::Output);
                            break;
                        default :
                            throw error(Error::wrongUseOfFunction(funcName()));
                    }

                    args.caller(this);
                    args.record(tmpFactureJour);
                    func.run(args);
                }

                select tmpFactureJour;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpFactureAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills <c>TmpFactureAmountAdjTrans_RU</c> temporary table with data
    /// </summary>
    /// <param name="_factureJourSource">
    /// Facture journal which is source for amount adjustments
    /// </param>
    /// <returns>
    /// Filled temporary table
    /// </returns>
    public TmpFactureAmountAdjTrans_RU tmpFactureAdjustments(FactureJour_RU _factureJourSource)
    {
        FactureJour_RU              factureJour;
        FactureJour_RU              factureJourExchAdj;
        FactureTrans_RU             factureTrans;
        ;

        if (factureJourSource.RecId != _factureJourSource.RecId)
        {
            factureJourSource = _factureJourSource.data();

            delete_from tmpFactureAdjustments;

            while select sum(LineAmountMST),
                         sum(TaxAmountMST),
                         sum(ExciseAmountMST),
                         sum(vatAmountMST)
                from factureTrans
                group by FactureId, Module, ExcludeFromBook
                where factureTrans.Module          == _factureJourSource.Module &&
                      factureTrans.SourceFactureId == _factureJourSource.FactureId
            exists join factureJour
                where factureJour.FactureId   == factureTrans.FactureId &&
                      factureJour.Module      == factureTrans.Module    &&
                      factureJour.AmountAdjustment                      &&
                     !factureJour.Reversed
            {
                factureJourExchAdj = FactureJour_RU::find(factureTrans.FactureId, factureTrans.Module);

                tmpFactureAdjustments.TransDate         = factureJourExchAdj.FactureDate;
                tmpFactureAdjustments.FactureId         = factureJourExchAdj.FactureId;
                tmpFactureAdjustments.Module            = factureJourExchAdj.Module;
                tmpFactureAdjustments.FactureExternalId = factureJourExchAdj.FactureExternalId;
                tmpFactureAdjustments.LineAmountMST     = factureTrans.LineAmountMST;
                tmpFactureAdjustments.TaxAmountMST      = factureTrans.TaxAmountMST;
                tmpFactureAdjustments.vatAmountMST      = factureTrans.vatAmountMST;
                tmpFactureAdjustments.ExciseAmountMST   = factureTrans.ExciseAmountMST;
                tmpFactureAdjustments.IncludeInBook     = ! factureTrans.ExcludeFromBook;
                tmpFactureAdjustments.insert();
            }
        }

        return tmpFactureAdjustments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBookInclusion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets exclude from book parameter based on specified facture adjustment
    /// </summary>
    /// <param name="_sourceFactureId">
    /// Facture id of source facture
    /// </param>
    /// <param name="_tmpFactureAdjTrans">
    /// Facture adjustment
    /// </param>
    public void updateBookInclusion(FactureId_RU _sourceFactureId, TmpFactureAmountAdjTrans_RU _tmpFactureAdjTrans)
    {
        FactureTrans_RU factureTrans;
        NoYes           exclude = ! _tmpFactureAdjTrans.IncludeInBook;
        ;

        ttsbegin;

        update_recordset factureTrans
            setting ExcludeFromBook = exclude
            where factureTrans.FactureId       == _tmpFactureAdjTrans.FactureId &&
                  factureTrans.Module          == _tmpFactureAdjTrans.Module    &&
                  factureTrans.SourceFactureId == _sourceFactureId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static FactureCalcAmountAdjustments_RU construct()
    {
        return new FactureCalcAmountAdjustments_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>factureAdjUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates amount adjustments for specified facture
    /// </summary>
    /// <param name="_factureJour">
    /// <c>FactureJour_RU</c> record to be updated
    /// </param>
    static void factureAdjUpdate(FactureJour_RU _factureJour)
    {
        RecordSortedList                invoiceJourList;
        CustVendInvoiceJour             custVendInvoiceJour;
        CustVendTrans                   custVendTrans;
        FactureCalcAmountAdjustments_RU factureCalcAdj;
        ;

        if (_factureJour.FactureType != FactureType_RU::Invoice)
            return;

        custVendInvoiceJour = new DictTable(_factureJour.Module == FactureModule_RU::Cust ?
                                            tableNum(CustInvoiceJour)                     :
                                            tableNum(VendInvoiceJour)).makeRecord();

        custVendTrans = new DictTable(_factureJour.Module == FactureModule_RU::Cust ?
                                      tableNum(CustTrans)                           :
                                      tableNum(VendTrans)).makeRecord();

        ttsbegin;

        invoiceJourList = _factureJour.invoiceJourSortedList();

        while (invoiceJourList.next(custVendInvoiceJour))
        {
            select firstonly custVendTrans
                where custVendTrans.AccountNum  == custVendInvoiceJour.InvoiceAccount
                   && custVendTrans.TransDate   == custVendInvoiceJour.InvoiceDate
                   && custVendTrans.Invoice     == custVendInvoiceJour.InvoiceId
                   && custVendTrans.Voucher     == custVendInvoiceJour.LedgerVoucher;

            factureCalcAdj = FactureCalcAmountAdjustments_RU::newCustVendTrans(custVendTrans);
            factureCalcAdj.calc();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>FactureCalcAmountAdjustments_RU</c> object using customer or vendor transaction
    /// </summary>
    /// <param name="_custVendTrans">
    /// <c>CustVendTrans</c> record to be passed as parameter
    /// </param>
    /// <returns>
    /// Created <c>FactureCalcAmountAdjustments_RU</c> object
    /// </returns>
    public static FactureCalcAmountAdjustments_RU newCustVendTrans(CustVendTrans _custVendTrans)
    {
        FactureCalcAmountAdjustments_RU factureCalcAmountAdjustments = FactureCalcAmountAdjustments_RU::construct();

        factureCalcAmountAdjustments.parmCustVendTrans(_custVendTrans);

        return factureCalcAmountAdjustments;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>