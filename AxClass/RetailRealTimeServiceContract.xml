<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailRealTimeServiceContract</Name>
	<SourceCode>
		<Declaration><![CDATA[
using AppLogging = Microsoft.Dynamics.Application.Instrumentation.ApplicationEventSource;

/// <summary>
///    The <c>RetailRealTimeServiceContract</c> class is the contract for Real-Time service.
/// </summary>
/// <remarks>
///    This class is the contract class for Real-time service.
/// </remarks>
// This is a framework class. Customizing this class may cause problems Real-Time Service in channels.
public class RetailRealTimeServiceContract
{
    private const str retailTransactionServiceClassName = 'RetailTransactionService';
    private const str retailTransactionServiceExClassName = 'RetailTransactionServiceEx';
    private const str retailTransactionServiceAX63ClassName = 'RetailTransactionServiceAX63';
    private const int retryNum = 5;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>IsAlive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns whether transaction service is alive.
    /// </summary>
    /// <returns>
    /// true if the transaction service is alive; otherwise, false.
    /// </returns>
    public RetailTransactionServiceResponse IsAlive()
    {
        System.Diagnostics.Stopwatch timer = new System.Diagnostics.Stopwatch();

        timer.Start();
        RetailTransactionServiceResponse response = null;
        AppLogging::EventWriteRetailRealtimeServiceInvokeStart(funcName(), funcName(), 0);

        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();
        boolean methodCallSuccessful = false;

        try
        {
            response = RetailRealTimeServiceWrapper::ConvertContainerToResponse([true, '', this.CurrentConfigurationMode()]);
            methodCallSuccessful = true;
        }
        finally
        {
            // Look for and log any messages observed during method invocation, as they typically indicate an error occurred
            if (!methodCallSuccessful)
            {
                str messages = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), messages);
            }
        }

        timer.Stop();
        AppLogging::EventWriteRetailRealtimeServiceInvokeStop(funcName(), funcName(), timer.ElapsedMilliseconds);
        return response;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CurrentConfigurationMode</Name>
				<Source><![CDATA[
    #define.SELECT_CONGIGURATIONMODE_VALUE('select value from SqlSystemVariables where parm = \'CONFIGURATIONMODE\'')

    private str CurrentConfigurationMode()
    {
        str configurationModeValue = '';
        Connection con = new Connection();
        Statement stmt = con.createStatement();
        ResultSet r;
        SqlStatementExecutePermission ssep = new SqlStatementExecutePermission(#SELECT_CONGIGURATIONMODE_VALUE);

        ssep.assert();
        r = stmt.executeQuery(#SELECT_CONGIGURATIONMODE_VALUE);
        CodeAccessPermission::revertAssert();

        while ( r.next() )
        {
            configurationModeValue = r.getString(1);
        }

        return configurationModeValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>InvokeMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Invokes transaction service method.
    /// </summary>
    /// <param name = "request">Transaction service request.</param>
    /// <param name = "methodName">Transaction service method name.</param>
    /// <param name = "parameters">Transaction service parameters.</param>
    /// <returns>Transaction service response.</returns>
    [AifCollectionType("parameters", Types::AnyType)]
    public RetailTransactionServiceResponse InvokeMethod(RetailTransactionServiceRequestInfo request, str methodName, List parameters)
    {
        return this.InvokeMethodHelper(request, methodName, parameters, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>InvokeAX63Method</Name>
				<Source><![CDATA[
    /// <summary>
    /// Invokes AX63 transaction service method.
    /// </summary>
    /// <param name = "request">Transaction service request.</param>
    /// <param name = "methodName">Transaction service method name.</param>
    /// <param name = "parameters">Transaction service parameters.</param>
    /// <returns>Transaction service response.</returns>
    [AifCollectionType("parameters", Types::AnyType)]
    public RetailTransactionServiceResponse InvokeAX63Method(RetailTransactionServiceRequestInfo request, str methodName, List parameters)
    {
        if (!isConfigurationkeyEnabled(configurationKeyNum(RetailCDXBackwardCompatibility)))
        {
            throw Global::error("@Retail:RetailConfigurationKeyDisabledError");
        }

        return this.InvokeMethodHelper(request, methodName, parameters, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>InvokeExtensionMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Invokes transaction service extension method.
    /// </summary>
    /// <param name = "request">Transaction service request.</param>
    /// <param name = "methodName">Transaction service method name.</param>
    /// <param name = "parameters">Transaction service parameters.</param>
    /// <returns>Transaction service response.</returns>
    [AifCollectionType("parameters", Types::AnyType)]
    public RetailTransactionServiceResponse InvokeExtensionMethod(RetailTransactionServiceRequestInfo request, str methodName, List parameters)
    {
        System.Diagnostics.Stopwatch timer = new System.Diagnostics.Stopwatch();

        timer.Start();
        RetailTransactionServiceResponse results = null;
        AppLogging::EventWriteRetailRealtimeServiceInvokeStart(funcName(), methodName, 0);

        RetailExtensibleEnumerationInitializer::setExtensibleEnumInitializer(funcName());

        if (request == null)
        {
            throw Global::error("@Retail:RealTimeServiceInputRequestNullError");
        }

        if (strlen(methodName) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceInputMethodNameEmptyError");
        }

        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();
        boolean methodCallSuccessful = false;

        try
        {
            results = RetailRealTimeServiceWrapper::MakeStaticCall(retailTransactionServiceExClassName, methodName, parameters, request.Company(), request.Language());
            methodCallSuccessful = true;
        }
        finally
        {
            // Look for and log any messages observed during method invocation, as they typically indicate an error occurred
            if (!methodCallSuccessful)
            {
                str messages = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), messages);
            }
        }

        timer.Stop();
        AppLogging::EventWriteRetailRealtimeServiceInvokeStop(funcName(), methodName, timer.ElapsedMilliseconds);
        return results;
    }

]]></Source>
			</Method>
			<Method>
				<Name>InvokeGetMethodWithCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Invokes transaction service method with filter criteria.
    /// </summary>
    /// <param name = "request">Transaction service request.</param>
    /// <param name = "methodName">Transaction service method name.</param>
    /// <param name = "filterCriteria">Transaction service filter criteria.</param>
    /// <param name = "parameters">Transaction service parameters.</param>
    /// <returns>Transaction service response.</returns>
    [AifCollectionType("parameters", Types::AnyType)]
    public RetailTransactionServiceResponse InvokeGetMethodWithCriteria(RetailTransactionServiceRequestInfo request, str methodName, str filterCriteria, List parameters)
    {
        System.Diagnostics.Stopwatch timer = new System.Diagnostics.Stopwatch();

        timer.Start();
        RetailTransactionServiceResponse results = null;
        AppLogging::EventWriteRetailRealtimeServiceInvokeStart(funcName(), methodName, 0);
        if (request == null)
        {
            throw Global::error("@Retail:RealTimeServiceInputRequestNullError");
        }

        if (strlen(methodName) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceInputMethodNameEmptyError");
        }

        if (strlen(filterCriteria) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceInputFilterCriteriaNullError");
        }

        // Add filter criteria at the start of parameters.
        if (parameters != null)
        {
            parameters.addStart(filterCriteria);
        }
        else
        {
            parameters = new List(Types::AnyType);
            parameters.addStart(filterCriteria);
        }

        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();
        boolean methodCallSuccessful = false;

        try
        {
            results = RetailRealTimeServiceWrapper::MakeStaticCall(retailTransactionServiceClassName, methodName, parameters, request.Company(), request.Language());
            methodCallSuccessful = true;
        }
        finally
        {
            // Look for and log any messages observed during method invocation, as they typically indicate an error occurred
            if (!methodCallSuccessful)
            {
                str messages = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), messages);
            }
        }

        timer.Stop();
        AppLogging::EventWriteRetailRealtimeServiceInvokeStop(funcName(), methodName, timer.ElapsedMilliseconds);
        return results;
    }

]]></Source>
			</Method>
			<Method>
				<Name>InvokeExtensionGetMethodWithCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Invokes transaction service extension method with filter criteria.
    /// </summary>
    /// <param name = "request">Transaction service request.</param>
    /// <param name = "methodName">Transaction service method name.</param>
    /// <param name = "filterCriteria">Transaction service filter criteria.</param>
    /// <param name = "parameters">Transaction service parameters.</param>
    /// <returns>Transaction service response.</returns>
    [AifCollectionType("parameters", Types::AnyType)]
    public RetailTransactionServiceResponse InvokeExtensionGetMethodWithCriteria(RetailTransactionServiceRequestInfo request, str methodName, str filterCriteria, List parameters)
    {
        System.Diagnostics.Stopwatch timer = new System.Diagnostics.Stopwatch();

        timer.Start();
        RetailTransactionServiceResponse results = null;
        AppLogging::EventWriteRetailRealtimeServiceInvokeStart(funcName(), methodName, 0);
        if (request == null)
        {
            throw Global::error("@Retail:RealTimeServiceInputRequestNullError");
        }

        if (strlen(methodName) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceInputMethodNameEmptyError");
        }

        if (strlen(filterCriteria) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceInputFilterCriteriaNullError");
        }

        // Add filter criteria at the start of parameters.
        if (parameters != null)
        {
            parameters.addStart(filterCriteria);
        }
        else
        {
            parameters = new List(Types::AnyType);
            parameters.addStart(filterCriteria);
        }

        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();
        boolean methodCallSuccessful = false;

        try
        {
            results = RetailRealTimeServiceWrapper::MakeStaticCall(retailTransactionServiceExClassName, methodName, parameters, request.Company(), request.Language());
            methodCallSuccessful = true;
        }
        finally
        {
            // Look for and log any messages observed during method invocation, as they typically indicate an error occurred
            if (!methodCallSuccessful)
            {
                str messages = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), messages);
            }
        }

        timer.Stop();
        AppLogging::EventWriteRetailRealtimeServiceInvokeStop(funcName(), methodName, timer.ElapsedMilliseconds);
        return results;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetTerminalDataStoreName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get data store name for terminal.
    /// </summary>
    /// <param name = "terminalId">Terminal id</param>
    /// <returns>Data store name</returns>
    public str GetTerminalDataStoreName(str terminalId)
    {
        AppLogging::EventWriteRetailRealtimeServiceGetTerminalStoreIdStart(terminalId);
        if (strlen(terminalId) == 0)
        {
            throw Global::error("@Retail:RealtimeServiceTerminalIdEmptyError");
        }

        str dataStoreName =  RetailCDXDownloadService::GetTerminalDataStoreName(terminalId);
        AppLogging::EventWriteRetailRealtimeServiceGetTerminalStoreIdStop(terminalId);

        return dataStoreName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDownloadSessions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get download sessions for a data store.
    /// </summary>
    /// <param name = "dataStoreName">Data store name.</param>
    /// <returns>The list of download sessions.</returns>
    [AifCollectionTypeAttribute('return', Types::Class, classStr(RetailAsyncClientDownloadSession))]
    public List GetDownloadSessions(str dataStoreName)
    {
        List downloadSessions = null;
        AppLogging::EventWriteRetailRealtimeServiceGetDownloadSessionsStart(dataStoreName);
        if (strlen(dataStoreName) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceDataStoreNameEmptyError");
        }

        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();
        boolean methodCallSuccessful = false;

        try
        {
            downloadSessions = RetailCDXDownloadService::GetDownloadSessions(dataStoreName);
            methodCallSuccessful = true;
        }
        finally
        {
            // Look for and log any messages observed during method invocation, as they typically indicate an error occurred
            if (!methodCallSuccessful)
            {
                str messages = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), messages);
            }
        }

        AppLogging::EventWriteRetailRealtimeServiceGetDownloadSessionsStop(dataStoreName);

        return downloadSessions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetInitialDownloadSessions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get initial download sessions for a data store.
    /// </summary>
    /// <param name = "dataStoreName">Data store name.</param>
    /// <returns>List of download sessions</returns>
    [AifCollectionTypeAttribute('return', Types::Class, classStr(RetailAsyncClientDownloadSession))]
    public List GetInitialDownloadSessions(str dataStoreName)
    {
        AppLogging::EventWriteRetailRealtimeServiceGetInitialDownloadSessionsStart(dataStoreName);
        if (strlen(dataStoreName) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceDataStoreNameEmptyError");
        }

        List downloadSessions = RetailCDXDownloadService::GetInitialDownloadSessionsList(dataStoreName, false);
        AppLogging::EventWriteRetailRealtimeServiceGetInitialDownloadSessionsStop(dataStoreName);

        return downloadSessions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDownloadSessionsAX63</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get download sessions for all AX 2012 R3 channels.
    /// </summary>
    /// <returns>List of download sessions for all AX 2012 R3 channels.</returns>
    [AifCollectionTypeAttribute('return', Types::String)]
    public List GetDownloadSessionsAX63()
    {
        boolean success = false;
        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();

        try
        {
            AppLogging::EventWriteRetailRealtimeServiceGetDownloadSessionsAX63Start();
            List downloadSessions = RetailCDXDownloadService::GetDownloadSessionsAX63();
            success = true;
            AppLogging::EventWriteRetailRealtimeServiceGetDownloadSessionsAX63Stop();

            return downloadSessions;
        }
        finally
        {
            if (!success)
            {
                str errMsg = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), errMsg);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDownloadUri</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get download session uri for file.
    /// </summary>
    /// <param name = "dataStoreName">Data store name.</param>
    /// <param name = "downloadSessionId">Download session id.</param>
    /// <returns>Uri for passed file</returns>
    public str GetDownloadUri(str dataStoreName, int64 downloadSessionId)
    {
        str downloadUri = null;
        AppLogging::EventWriteRetailRealtimeServiceGetDownloadUriStart(dataStoreName, downloadSessionId);

        if (strlen(dataStoreName) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceDataStoreNameEmptyError");
        }
        
        if (downloadSessionId == 0)
        {
            throw Global::error("@Retail:RealTimeServiceDownloadSessionIdZeroError");
        }

        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();
        boolean methodCallSuccessful = false;

        try
        {
            downloadUri = RetailCDXDownloadService::GetDownloadUri(dataStoreName, downloadSessionId);
            methodCallSuccessful = true;
        }
        finally
        {
            // Look for and log any messages observed during method invocation, as they typically indicate an error occurred
            if (!methodCallSuccessful)
            {
                str messages = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), messages);
            }
        }

        AppLogging::EventWriteRetailRealtimeServiceGetDownloadUriStop(dataStoreName, downloadSessionId);

        return downloadUri;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDownloadSessionDataPackageUri</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the data package file download uri for the specified download session.
    /// </summary>
    /// <param name = "downloadSessionId">The download session id.</param>
    /// <returns>The data package file download uri for the specified download session.</returns>
    public str GetDownloadSessionDataPackageUri(RetailCDXDownloadSessionRefRecId downloadSessionId)
    {
        boolean success = false;
        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();
        
        try
        {
            AppLogging::EventWriteRetailRealtimeServiceGetDownloadSessionDataPackageUriStart('', downloadSessionId);
            str uri = RetailCDXDownloadService::GetDownloadUriOnly(downloadSessionId);
            success = true;
            AppLogging::EventWriteRetailRealtimeServiceGetDownloadSessionDataPackageUriStop('', downloadSessionId);
            return uri;
        }
        finally
        {
            if (!success)
            {
                str errMsg = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), errMsg);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDataDownloadParametersByTerminal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the data download parameters object containing the download session and other information
    /// required to apply a download session to the target database.
    /// </summary>
    /// <param name = "requestInfo">The data download parameters request argument.</param>
    /// <returns>The <c>RetailCDXDataDownloadParameters</c> object.</returns>
    internal RetailCDXDataDownloadParameters GetDataDownloadParametersByTerminal(RetailCDXDataDownloadParametersByTerminalRequestInfo requestInfo)
    {
        if (requestInfo == null)
        {
            throw Global::error("@Retail:RealTimeServiceInputRequestNullError");
        }

        AppLogging::EventWriteRealtimeServiceGetDataDownloadParametersByTerminalStart(requestInfo.TerminalId(), requestInfo.RequiresDataInitialization(), requestInfo.HasBeenInitializedBefore());

        RetailCDXDataDownloadParameters dataDownloadParameters;
        System.Exception ex;

        try
        {
            RetailConnDatabaseProfile dataStore  = RetailConnDatabaseProfile::findByTerminalId(requestInfo.TerminalId());
            dataDownloadParameters = RetailCDXDownloadService::GetDataDownloadParameters(dataStore.Name, requestInfo.RequiresDataInitialization(), requestInfo.HasBeenInitializedBefore());
        }
        catch (ex)
        {
            AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), ex.ToString());
            throw error(ex.ToString());
        }
        finally
        {
            AppLogging::EventWriteRealtimeServiceGetDataDownloadParametersByTerminalStop(requestInfo.TerminalId(), requestInfo.RequiresDataInitialization(), requestInfo.HasBeenInitializedBefore());
        }

        return dataDownloadParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDataDownloadParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the data download parameters object containing the download session and other information
    /// required to apply a download session to the target database.
    /// </summary>
    /// <param name = "requestInfo">The data download parameters request argument.</param>
    /// <returns>The <c>RetailCDXDataDownloadParameters</c> object.</returns>
    internal RetailCDXDataDownloadParameters GetDataDownloadParameters(RetailCDXDataDownloadParametersRequestInfo requestInfo)
    {
        if (requestInfo == null)
        {
            throw Global::error("@Retail:RealTimeServiceInputRequestNullError");
        }

        AppLogging::EventWriteRealtimeServiceGetDataDownloadParametersStart(requestInfo.DataStoreName());

        RetailCDXDataDownloadParameters dataDownloadParameters = null;
        System.Exception ex;

        try
        {            
            RetailCDXDownloadSessionResultSetting resultSetting = requestInfo.SessionResultSetting();

            // previous/older version clients dont have the capability to stop processing subsequent sessions after a failure.
            // In such scenario need to send one session at a time so as to support the download session dependency enforcement feature's requirement of 
            // stopping processing when one of the session in the list fails.
            if (resultSetting == null)
            {
                resultSetting = new RetailCDXDownloadSessionResultSetting();

                if (RetailCdxFeatureControl::isDownloadSessionDependencyEnforcementEnabled())
                {
                    resultSetting.SessionListPageSize(1);
                }
            }

            dataDownloadParameters = RetailCDXDownloadService::GetDataDownloadParameters(requestInfo.DataStoreName(), /* wasChannelUpgraded */ false, /* hasBeenInitializedBefore */ false, resultSetting);
        }
        catch (ex)
        {
            AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), ex.ToString());
            throw error(ex.ToString());
        }
        finally
        {
            AppLogging::EventWriteRealtimeServiceGetDataDownloadParametersStop(requestInfo.DataStoreName());
        }

        return dataDownloadParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDataDownloadParametersForTransformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the data download parameters object containing the download session and other information
    /// required to transform a download session.
    /// </summary>
    /// <param name = "requestInfo">The data download parameters for transformation request argument.</param>
    /// <returns>The <c>RetailCDXDataDownloadParameters</c> object.</returns>
    internal RetailCDXDataDownloadParameters GetDataDownloadParametersForTransformation(RetailCDXDataDownloadParametersForTransformationRequestInfo requestInfo)
    {
        if (requestInfo == null)
        {
            throw Global::error("@Retail:RealTimeServiceInputRequestNullError");
        }

        AppLogging::EventWriteRealtimeServiceGetDataDownloadParametersForTransformationStart(strList2str(requestInfo.DataStoreNames(), ","));

        RetailCDXDataDownloadParameters dataDownloadParameters = null;
        System.Exception ex;

        try
        {
            RetailCDXDownloadSessionResultSetting resultSetting = requestInfo.SessionResultSetting() == null ? new RetailCDXDownloadSessionResultSetting() : requestInfo.SessionResultSetting();

            dataDownloadParameters = RetailCDXDownloadService::GetDataDownloadParametersForTransformation(requestInfo.DataStoreNames(), requestInfo.SessionIds(), resultSetting);
        }
        catch (ex)
        {
            AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), ex.ToString());
            throw error(ex.ToString());
        }
        finally
        {
            AppLogging::EventWriteRealtimeServiceGetDataDownloadParametersForTransformationStop(strList2str(requestInfo.DataStoreNames(), ","));
        }

        return dataDownloadParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDownloadInterval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get download interval for data store.
    /// </summary>
    /// <param name = "dataStoreName">Data store name.</param>
    /// <returns>Download interval.</returns>
    public int GetDownloadInterval(str dataStoreName)
    {
        AppLogging::EventWriteRetailRealtimeServiceGetDownloadIntervalStart(dataStoreName);
        if (strlen(dataStoreName) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceDataStoreNameEmptyError");
        }

        int downloadInterval = RetailCDXDownloadService::GetDownloadInterval(dataStoreName);
        AppLogging::EventWriteRetailRealtimeServiceGetDownloadIntervalStop(dataStoreName);

        return downloadInterval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetFeatureList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get feature control, feature management and feature flight lists with features filtered according to request.
    /// </summary>
    /// <param name = "requestInfo">Filters to look up features.</param>
    /// <returns>The <c>RetailFeatureList</c> object. </returns>
    internal RetailFeatureList GetFeatureList(RetailFeatureListRequestInfo requestInfo)
    {
        if (requestInfo == null)
        {
            throw Global::error("@Retail:RealTimeServiceInputRequestNullError");
        }

        str eventMessage = strFmt('FeatureControlFilter: %1, FeatureManagementFilter: %2, FeatureFlightFilter: %3',
                requestInfo.FeatureControlFilter(),
                requestInfo.FeatureManagementFilter(),
                requestInfo.FeatureFlightFilter());

        AppLogging::EventWriteRealtimeServiceGetFeatureListStart(eventMessage);

        RetailFeatureList retailFeatureList;
        System.Exception ex;

        try
        {
            List featureControlList    = RetailFeatureControl::getFeatureControlList(requestInfo.FeatureControlFilter());
            List featureManagementList = RetailFeatureControl::getFeatureManagementList(requestInfo.FeatureManagementFilter());
            List featureFlightList     = RetailFeatureControl::getFeatureFlightList(requestInfo.FeatureFlightFilter(), requestInfo.FeatureFlightServiceFilter());

            eventMessage = strFmt('FeatureControlList: %1, FeatureManagementList: %2, FeatureFlightList: %3',
                featureControlList.elements(),
                featureManagementList.elements(),
                featureFlightList.elements());

            retailFeatureList = RetailFeatureList::create(featureControlList, featureManagementList, featureFlightList);
        }
        catch (ex)
        {
            AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), ex.ToString());
            throw error(ex.ToString());
        }
        finally
        {
            AppLogging::EventWriteRealtimeServiceGetFeatureListStop(eventMessage);
        }

        return retailFeatureList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>UpdateDownloadSessionStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update download session status in database.
    /// </summary>
    /// <param name = "downloadSession">The download session.</param>
    public void UpdateDownloadSessionStatus(RetailAsyncClientDownloadSessionUpdateStatus downloadSession)
    {
        System.Exception exception;

        try
        {
            if (downloadSession == null)
            {
                throw Global::error("@Retail:RealtimeServiceDownloadSessionNullError");
            }

            AppLogging::EventWriteRetailRealtimeServiceUpdateDownloadSessionStatusStart(downloadSession.paramDataStoreName(), downloadSession.paramId(), enum2Symbol(enumNum(RetailCDXDownloadSessionStatus), downloadSession.paramStatus()));
            RetailCDXDownloadService::UpdateDownloadSessionStatus(downloadSession);
        }
        catch(exception)
        {
            AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), exception.ToString());
            throw error(exception.ToString());
        }
        finally
        {
            AppLogging::EventWriteRetailRealtimeServiceUpdateDownloadSessionStatusStop(downloadSession.paramDataStoreName(), downloadSession.paramId(), enum2Symbol(enumNum(RetailCDXDownloadSessionStatus), downloadSession.paramStatus()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>MarkFileDownloaded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Mark if the data package file has been successfully downloaded for AX 2012 R3 clients.
    /// </summary>
    /// <param name = "downloadSessionId">Download session Id.</param>
    /// <param name = "isDownloadSuccessful">True if data package file is downloaded successfully, otherwise, false.</param>
    /// <param name = "message">Error message, when the data package file is not downloaded successfully.</param>
    public void MarkFileDownloaded(RetailCDXDownloadSessionRefRecId downloadSessionId, boolean isDownloadSuccessful, RetailCDXMonDataSyncMessage message)
    {
        RetailCDXDownloadSessionStatus status = isDownloadSuccessful ? RetailCDXDownloadSessionStatus::Downloaded : RetailCDXDownloadSessionStatus::DownloadFailed;

        boolean success = false;
        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();
        
        try
        {
            AppLogging::EventWriteRetailRealtimeServiceMarkPackageFileDownloadedStart('', downloadSessionId, enum2Str(status));
            RetailCDXDownloadService::MarkFileDownloaded(downloadSessionId, isDownloadSuccessful, message);
            AppLogging::EventWriteRetailRealtimeServiceMarkPackageFileDownloadedStop('', downloadSessionId, enum2Str(status));
        }
        finally
        {
            if (!success)
            {
                str errMsg = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), errMsg);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ValidateDataStore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates data store.
    /// </summary>
    /// <param name = "dataStoreName">Data store name</param>
    /// <param name = "userName">User name</param>
    /// <returns>If data store is valid.</returns>
    public boolean ValidateDataStore(str dataStoreName, str userName)
    {
        AppLogging::EventWriteRetailRealtimeServiceValidateDataStoreStart(dataStoreName, userName);
        if (strlen(dataStoreName) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceDataStoreNameEmptyError");
        }

        if (strlen(userName) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceUserNameEmptyError");
        }

        boolean status = RetailCDXDownloadService::ValidateDataStore(dataStoreName, userName);
        AppLogging::EventWriteRetailRealtimeServiceValidateDataStoreStop(dataStoreName, userName);

        return status;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDataUploadParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the data upload parameters object containing information required for generating upload packages from the target datastore.
    /// </summary>
    /// <param name = "requestInfo">The data upload parameters request info object.</param>
    /// <returns>The <c>RetailCDXDataUploadParameters</c> object.</returns>
    internal RetailCDXDataUploadParameters GetDataUploadParameters(RetailCDXDataUploadParametersRequestInfo requestInfo)
    {
        if (requestInfo == null)
        {
            throw Global::error("@Retail:RealTimeServiceInputRequestNullError");
        }

        AppLogging::EventWriteRealtimeServiceGetDataUploadParametersStart(requestInfo.DataStoreName());

        RetailCDXDataUploadParameters dataUploadParameters = null;
        System.Exception ex;

        try
        {
            dataUploadParameters = RetailCDXUploadService::GetDataUploadParameters(requestInfo.DataStoreName());
        }
        catch (ex)
        {
            AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), ex.ToString());
            throw error(ex.ToString());
        }
        finally
        {
            AppLogging::EventWriteRealtimeServiceGetDataUploadParametersStop(requestInfo.DataStoreName());
        }

        return dataUploadParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDataUploadParametersByTerminal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the data upload parameters object containing information required for generating upload packages from the target datastore.
    /// </summary>
    /// <param name = "requestInfo">The data upload parameters request info object.</param>
    /// <returns>The <c>RetailCDXDataUploadParameters</c> object.</returns>
    internal RetailCDXDataUploadParameters GetDataUploadParametersByTerminal(RetailCDXDataUploadParametersByTerminalRequestInfo requestInfo)
    {
        if (requestInfo == null)
        {
            throw Global::error("@Retail:RealTimeServiceInputRequestNullError");
        }

        AppLogging::EventWriteRealtimeServiceGetDataUploadParametersStart(requestInfo.TerminalId());

        RetailCDXDataUploadParameters dataUploadParameters = null;
        System.Exception ex;

        try
        {
            RetailConnDatabaseProfile dataStore  = RetailConnDatabaseProfile::findByTerminalId(requestInfo.TerminalId());
            dataUploadParameters = RetailCDXUploadService::GetDataUploadParameters(dataStore.Name);
        }
        catch (ex)
        {
            AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), ex.ToString());
            throw error(ex.ToString());
        }
        finally
        {
            AppLogging::EventWriteRealtimeServiceGetDataUploadParametersStop(requestInfo.TerminalId());
        }

        return dataUploadParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetUploadInterval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get upload interval for data store.
    /// </summary>
    /// <param name = "dataStoreName">Data store name</param>
    /// <returns>Upload interval</returns>
    public int GetUploadInterval(str dataStoreName)
    {
        AppLogging::EventWriteRetailRealtimeServiceGetUploadIntervalStart(dataStoreName);

        if (strlen(dataStoreName) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceDataStoreNameEmptyError");
        }

        RetailConnDatabaseProfile dataStore;
        select firstonly dataStore where dataStore.Name == dataStoreName;

        if (dataStore)
        {
            RetailCDXDataStoreHeartbeatLog::LogAccess(dataStore.RecId);
        }

        int uploadInterval = RetailCDXUploadService::GetUploadInterval(dataStoreName);
        AppLogging::EventWriteRetailRealtimeServiceGetUploadIntervalStop(dataStoreName);

        return uploadInterval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetRerunUploadSessionId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get rerun upload session id for a job.
    /// </summary>
    /// <param name = "dataStoreName">Data store name</param>
    /// <param name = "jobId">Job id</param>
    /// <returns>Rerun upload session id</returns>
    public int64 GetRerunUploadSessionId(str dataStoreName, str jobId)
    {
        if (strlen(dataStoreName) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceDataStoreNameEmptyError");
        }

        if (strlen(jobId) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceJobIdEmptyError");
        }

        int64 minSessionId = RetailCDXUploadService::GetRerunUploadSessionId(dataStoreName, jobId);

        return minSessionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetUploadJobDefinitions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of upload job definitions.
    /// </summary>
    /// <param name = "dataStoreName">Data store name</param>
    /// <returns>List of upload job definitions</returns>
    [AifCollectionTypeAttribute('return', Types::String)]
    public List GetUploadJobDefinitions(str dataStoreName)
    {
        AppLogging::EventWriteRetailRealtimeServiceGetUploadJobDefinitionsStart(dataStoreName);
        if (strlen(dataStoreName) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceDataStoreNameEmptyError");
        }

        List uploadJobDefinitions = RetailCDXUploadService::GetUploadJobDefinitions(dataStoreName);
        AppLogging::EventWriteRetailRealtimeServiceGetUploadJobDefinitionsStop(dataStoreName);

        return uploadJobDefinitions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetUploadUri</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get upload parameters for data store.
    /// </summary>
    /// <param name = "dataStoreName">The data store name.</param>
    /// <returns>RetailAsyncClientUploadParameter.</returns>
    public RetailAsyncClientUploadParameter GetUploadUri(str dataStoreName)
    {
        AppLogging::EventWriteRetailRealtimeServiceGetUploadUriStart(dataStoreName);
        if (strlen(dataStoreName) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceDataStoreNameEmptyError");
        }

        RetailAsyncClientUploadParameter uploadParameter = RetailCDXUploadService::GetUploadUri(dataStoreName);
        AppLogging::EventWriteRetailRealtimeServiceGetUploadUriStop(dataStoreName);

        return uploadParameter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreateUploadSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create upload session in database.
    /// </summary>
    /// <param name = "uploadSession">The upload session.</param>
    /// <returns>Created upload session Id.</returns>
    public RetailCDXSessionNumber CreateUploadSession(RetailAsyncClientUploadSession uploadSession)
    {
        if (uploadSession == null)
        {
            throw Global::error("@Retail:RealtimeServiceUploadSessionNullError");
        }

        AppLogging::EventWriteRetailRealtimeServiceCreateUploadSessionStart(uploadSession.paramDataStoreName(), uploadSession.paramLocalUploadSessionId());

        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();
        boolean methodCallSuccessful = false;
        RetailCDXSessionNumber uploadSessionId;

        try
        {
            uploadSessionId = RetailCDXUploadService::CreateUploadSession(uploadSession);
            methodCallSuccessful = true;
        }
        finally
        {
            // Look for and log any messages observed during method invocation, as they typically indicate an error occurred
            if (!methodCallSuccessful)
            {
                str messages = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), messages);
            }
        }

        AppLogging::EventWriteRetailRealtimeServiceCreateUploadSessionStop(uploadSession.paramDataStoreName(), uploadSession.paramLocalUploadSessionId());

        return uploadSessionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CancelRerunnedUploadSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates rerunned upload session status to Canceled with error message.
    /// </summary>
    /// <param name = "dataStoreName">Data store name</param>
    /// <param name = "uploadSessionId">The channel local upload session id</param>
    public void CancelRerunnedUploadSession(str dataStoreName, int64 uploadSessionId)
    {
        System.Exception ex;

        try
        {
            AppLogging::EventWriteRetailRealtimeServiceCancelRerunedUploadSessionStart(dataStoreName, uploadSessionId);

            if (strlen(dataStoreName) == 0)
            {
                throw Global::error("@Retail:RealTimeServiceDataStoreNameEmptyError");
            }

            if (uploadSessionId <= 0)
            {
                throw Global::error("@Retail:RealTimeServiceInvalidUploadSessionIdError");
            }

            RetailCDXUploadService::CancelRerunnedUploadSession(dataStoreName, uploadSessionId);
        }
        catch(ex)
        {
            AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), ex.ToString());
            throw error(ex.ToString());
        }
        finally
        {
            AppLogging::EventWriteRetailRealtimeServiceCancelRerunedUploadSessionStop(dataStoreName, uploadSessionId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>InvokeMethodHelper</Name>
				<Source><![CDATA[
    private RetailTransactionServiceResponse InvokeMethodHelper(RetailTransactionServiceRequestInfo request, str methodName, List parameters, boolean isCallFromRealtimeService63)
    {
        System.Diagnostics.Stopwatch timer = new System.Diagnostics.Stopwatch();

        timer.Start();
        RetailTransactionServiceResponse results = null;
        AppLogging::EventWriteRetailRealtimeServiceInvokeStart(funcName(), methodName, 0);

        RetailExtensibleEnumerationInitializer::setExtensibleEnumInitializer(funcName());

        if (request == null)
        {
            throw Global::error("@Retail:RealTimeServiceInputRequestNullError");
        }
        else if (strlen(methodName) == 0)
        {
            throw Global::error("@Retail:RealTimeServiceInputMethodNameEmptyError");
        }

        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();
        boolean methodCallSuccessful = false;

        try
        {
            if (isCallFromRealtimeService63)
                results = RetailRealTimeServiceWrapper::MakeStaticCall(retailTransactionServiceAX63ClassName, methodName, parameters, request.Company(), request.Language());
            else
                results = RetailRealTimeServiceWrapper::MakeStaticCall(retailTransactionServiceClassName, methodName, parameters, request.Company(), request.Language());

            methodCallSuccessful = true;
        }
        finally
        {
            // Look for and log any messages observed during method invocation, as they typically indicate an error occurred
            if (!methodCallSuccessful)
            {
                str messages = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), messages);
            }
        }

        timer.Stop();
        AppLogging::EventWriteRetailRealtimeServiceInvokeStop(funcName(), methodName, timer.ElapsedMilliseconds);
        return results;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetAsyncServerMetadataLastSyncCounter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the last sync counter of Async Server metadata for AX 2012 R3 HQ message database in UTC datetime.
    /// </summary>
    /// <returns>The last sync counter of Async Server metadata for AX 2012 R3 HQ message database in UTC datetime.</returns>
    public utcdatetime GetAsyncServerMetadataLastSyncCounter()
    {
        boolean success = false;
        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();

        try
        {
            AppLogging::EventWriteRetailRealtimeServiceGetAsyncServerMetadataLastSyncCounterStart('');
            RetailCDXMetadataSyncVersion syncVersion = RetailCDXHQMessageDBProfile::find().LastMetadataSyncVersion;
            success = true;
            AppLogging::EventWriteRetailRealtimeServiceGetAsyncServerMetadataLastSyncCounterStop(DateTimeUtil::toStr(syncVersion));
            return syncVersion;
        }
        finally
        {
            if (!success)
            {
                str errMsg = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), errMsg);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetAsyncServerMetadataXml</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get Async Server metadata for AX 2012 R3 HQ message database.
    /// </summary>
    /// <param name = "lastSyncCounter">The last sync counter.</param>
    /// <returns>Async Server metadata in Xml.</returns>
    public str GetAsyncServerMetadataXml(utcdatetime lastSyncCounter)
    {
        boolean success = false;
        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();

        try
        {
            AppLogging::EventWriteRetailRealtimeServiceGetAsyncServerMetadataXmlStart(DateTimeUtil::toStr(lastSyncCounter));
            str metadataXml = RetailCDXMetadataSync::getMetadataXml(lastSyncCounter);
            success = true;
            AppLogging::EventWriteRetailRealtimeServiceGetAsyncServerMetadataXmlStop(DateTimeUtil::toStr(lastSyncCounter));
            return metadataXml;
        }
        finally
        {
            if (!success)
            {
                str errMsg = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), errMsg);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>SetAsyncServerMetadataLastSyncCounter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the Async Server metadata last sync counter in UTC datetime.
    /// </summary>
    /// <param name = "lastSyncCounter">The last sync counter of Async Server metadata for AX 2012 R3 HQ message database in UTC datetime.</param>
    public void SetAsyncServerMetadataLastSyncCounter(utcdatetime lastSyncCounter)
    {
        RetailCDXHQMessageDBProfile hqMessageDBProfile;

        boolean success = false;
        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();

        try
        {
            AppLogging::EventWriteRetailRealtimeServiceSetAsyncServerMetadataLastSyncCounterStart(DateTimeUtil::toStr(lastSyncCounter));
            
            ttsbegin;
            hqMessageDBProfile = RetailCDXHQMessageDBProfile::find(true);
            hqMessageDBProfile.LastMetadataSyncVersion = lastSyncCounter;
            hqMessageDBProfile.update();
            ttscommit;

            success = true;
            AppLogging::EventWriteRetailRealtimeServiceSetAsyncServerMetadataLastSyncCounterStop(DateTimeUtil::toStr(lastSyncCounter));
        }
        catch (Exception::UpdateConflict)
        {
            if (xSession::currentRetryCount() > retryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                retry;
            }
        }
        finally
        {
            if (!success)
            {
                str errMsg = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), errMsg);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetAsyncServerStatusLastSyncCounter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the last status sync counter for AX 2012 R3 HQ message database.
    /// </summary>
    /// <returns>The last status sync counter for AX 2012 R3 HQ message database.</returns>
    public int64 GetAsyncServerStatusLastSyncCounter()
    {
        boolean success = false;
        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();

        try
        {
            AppLogging::EventWriteRetailRealtimeServiceGetAsyncServerStatusLastSyncCounterStart(0);
            RetailCDXLastMonDataSyncVersion syncVersion = RetailCDXHQMessageDBProfile::find().LastMonDataSyncVersion;
            success = true;
            AppLogging::EventWriteRetailRealtimeServiceGetAsyncServerStatusLastSyncCounterStop(syncVersion);
            return syncVersion;
        }
        finally
        {
            if (!success)
            {
                str errMsg = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), errMsg);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>SetAsyncServerStatusLastSyncCounter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the last status sync counter for AX 2012 R3 HQ message database.
    /// </summary>
    /// <param name = "lastStatusSyncCounter">The status sync counter for AX 2012 R3 HQ message database.</param>
    public void SetAsyncServerStatusLastSyncCounter(int64 lastStatusSyncCounter)
    {
        RetailCDXHQMessageDBProfile hqMessageDBProfile;

        boolean success = false;
        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();

        try
        {
            AppLogging::EventWriteRetailRealtimeServiceSetAsyncServerStatusLastSyncCounterStart(lastStatusSyncCounter);

            ttsbegin;
            hqMessageDBProfile = RetailCDXHQMessageDBProfile::find(true);
            hqMessageDBProfile.LastMonDataSyncVersion = lastStatusSyncCounter;
            hqMessageDBProfile.update();
            ttscommit;

            success = true;
            AppLogging::EventWriteRetailRealtimeServiceSetAsyncServerStatusLastSyncCounterStop(lastStatusSyncCounter);
        }
        catch (Exception::UpdateConflict)
        {
            if (xSession::currentRetryCount() > retryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                retry;
            }
        }
        finally
        {
            if (!success)
            {
                str errMsg = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), errMsg);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>UpdateDownloadSessionStatusAX63</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update download session status for AX 2012 R3 clients.
    /// </summary>
    /// <param name = "downloadSessionStatusCollection">The collection of download session status details.</param>
    [AifCollectionTypeAttribute('downloadSessionStatusCollection', Types::Class, classStr(RetailAsyncClientDownloadSessionUpdateStatus))]
    public void UpdateDownloadSessionStatusAX63(List downloadSessionStatusCollection)
    {
        boolean success = false;
        Counter infologline = infolog.num();
        int fromLine = Global::infologLine();

        try
        {
            AppLogging::EventWriteRetailRealtimeServiceUpdateDownloadSessionStatusAX63Start();
            RetailCDXDownloadService::UploadDownloadSessionStatusAX63(downloadSessionStatusCollection);
            success = true;
            AppLogging::EventWriteRetailRealtimeServiceUpdateDownloadSessionStatusAX63Stop();
        }
        finally
        {
            if (!success)
            {
                str errMsg = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                AppLogging::EventWriteRealTimeServiceContractMethodFailedError(funcName(), errMsg);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetNextLocalUploadSessionId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the value for the next local upload session id for the given datastore.
    /// </summary>
    /// <returns>The value of the next local session id.</returns>
    /// <param name = "dataStoreName">Data Store Name.</param>
    public int GetNextLocalUploadSessionId(str dataStoreName)
    {
        RetailConnDatabaseProfile dataStore;
        RetailCDXUploadSession retailCDXUploadSession;
        int nextLocalUploadSessionId = 1;

        try
        {
            AppLogging::EventWriteRetailCDXChannelServiceContractGetNextLocalUploadSessionIdStart();
            
            dataStore = RetailConnDatabaseProfile::find(dataStoreName);

            if (!dataStore)
            {
                AppLogging::EventWriteRetailCDXChannelServiceContractGetNextLocalUploadSessionIdFailure(dataStoreName);
                throw Global::error(strfmt("@Retail:CDXDataStoreNotExistError", dataStoreName));
            }

            select maxof(LocalUploadSessionId)
                from retailCDXUploadSession
                where retailCDXUploadSession.DataStore == dataStore.RecId;
        
            // if there is an upload session entry for the data store, then we get the max local upload session ID for it
            if (retailCDXUploadSession)
            {
                nextLocalUploadSessionId = retailCDXUploadSession.LocalUploadSessionId + 1;
                AppLogging::EventWriteRetailRealTimeServiceContractDataReseed(dataStoreName, nextLocalUploadSessionId);
            }

            return nextLocalUploadSessionId;
        }
        finally
        {
            AppLogging::EventWriteRetailCDXChannelServiceContractGetNextLocalUploadSessionIdStop();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreatePublishSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>RetailCDXPublishSession</c>.
    /// </summary>
    /// <param name = "dataStoreName">The data store.</param>
    /// <returns>The Session Id.</returns>
    [SysObsolete('The method has been deprecated. Use CreatePublishingSession instead.', false, 30\7\2022)]
    public str CreatePublishSession(str dataStoreName)
    {
        AppLogging::EventWriteRetailCDXChannelServiceContractCreatePublishSessionStart();

        RetailSearchPublishingSession   publishSession;
        System.Exception                ex;
        
        try
        {
            RetailConnDatabaseProfile dataStore = RetailConnDatabaseProfile::find(dataStoreName);

            if (!dataStore)
            {
                throw Global::error(strfmt("@Retail:CDXDataStoreNotExistError",dataStoreName));
            }

            publishSession = RetailSearchPublishingService::CreatePublishSession(dataStore);

            if (!publishSession.RecId)
            {
                AppLogging::EventWriteRetailRealTimeServiceContractCreatePublishSessionFailure(dataStoreName, 'Failed to create session');
            }

            return guid2Str(publishSession.Session);
        }
        catch (ex)
        {
            AppLogging::EventWriteRetailRealTimeServiceContractCreatePublishSessionFailure(dataStoreName, ex.ToString());

            throw Global::error(ex.Message);
        }
        finally
        {
            AppLogging::EventWriteRetailCDXChannelServiceContractCreatePublishSessionStop();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>UpdatePublishSessionStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the status of an existing session.
    /// </summary>
    /// <param name="updateStatus">The <c>RetailAsyncClientPublishSessionUpdateStatus</c> contract data.</param>
    [SysObsolete('The method has been deprecated. Use UpdatePublishingSession instead.', false, 30\7\2022)]
    public void UpdatePublishSessionStatus(RetailSearchPublishingSessionUpdateStatus updateStatus)
    {
        System.Exception ex;
        AppLogging::EventWriteRetailCDXChannelServiceContractUpdatePublishSessionStatusStart();

        try
        {
            if (updateStatus == null)
            {
                throw Global::error('The update status contract is null');
            }

            RetailConnDatabaseProfile dataStore = RetailConnDatabaseProfile::find(updateStatus.parmDataStoreName());

            if (!dataStore)
            {
                throw Global::error(strfmt("@Retail:CDXDataStoreNotExistError", updateStatus.parmDataStoreName()));
            }

            if (!updateStatus.parmSession())
            {
                throw Global::error('The session id is empty or null.');
            }
        
            RetailSearchPublishingService::UpdatePublishSessionStatus(updateStatus);
        }
        catch (ex)
        {
            AppLogging::EventWriteRetailRealTimeServiceContractUpdatePublishSessionStatusFailure(ex.ToString());

            throw Global::error(ex.Message);
        }
        finally
        {
            AppLogging::EventWriteRetailCDXChannelServiceContractUpdatePublishSessionStatusStop();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreatePublishingSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>RetailSearchPublishingSession</c>.
    /// </summary>
    /// <param name="createSessionRequest">The <c>RetailSearchPublishingSessionCreateRequest</c> contract data.</param>
    public void CreatePublishingSession(RetailSearchPublishingSessionCreateRequest createSessionRequest)
    {
        AppLogging::EventWriteRetailCDXChannelServiceContractCreatePublishSessionStart();
        System.Exception    ex;
        
        try
        {
            RetailSearchPublishingService::CreatePublishingSession(createSessionRequest);
        }
        catch (ex)
        {
            AppLogging::EventWriteRetailRealTimeServiceContractCreatePublishSessionFailure(createSessionRequest.parmDataStoreName(), ex.ToString());

            throw Global::error(ex.Message);
        }
        finally
        {
            AppLogging::EventWriteRetailCDXChannelServiceContractCreatePublishSessionStop();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>UpdatePublishingSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of an existing session.
    /// </summary>
    /// <param name="updateSessionRequest">The <c>RetailSearchPublishingSessionUpdateRequest</c> contract data.</param>
    public void UpdatePublishingSession(RetailSearchPublishingSessionUpdateRequest updateSessionRequest)
    {
        System.Exception ex;
        AppLogging::EventWriteRetailCDXChannelServiceContractUpdatePublishSessionStatusStart();

        try
        {
            RetailSearchPublishingService::UpdatePublishingSession(updateSessionRequest);
        }
        catch (ex)
        {
            AppLogging::EventWriteRetailRealTimeServiceContractUpdatePublishSessionStatusFailure(ex.ToString());

            throw Global::error(ex.Message);
        }
        finally
        {
            AppLogging::EventWriteRetailCDXChannelServiceContractUpdatePublishSessionStatusStop();
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>