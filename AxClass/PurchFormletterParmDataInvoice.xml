<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchFormletterParmDataInvoice</Name>
	<SourceCode>
		<Declaration><![CDATA[
[DocumentStatusFactoryAttribute(DocumentStatus::Invoice)]
class PurchFormletterParmDataInvoice extends PurchFormletterParmData
{
    #ISOCountryRegionCodesVendInv_W

    RecordInsertList recordInsertParmSubLine;

    RecordInsertList recordInsertVendInvoiceMatchingLine;
    RecordInsertList recordInsertListSourceDocumentHeader;
    RecordInsertList recordInsertListSourceDocumentLine;
    RecordInsertList recordInsertParmLine_Project;

    RecordInsertList recordInsertParmTable_RU;
    RecordInsertList recordInsertParmTable_W;
    RecordInsertList recordInsertParmLine_W;
    private RecordInsertList recordInsertParmLine_BR;
    // <GIN>
    RecordInsertList recordInsertParmLine_IN;
    // </GIN>
    RecordInsertList recordInsertParmTable_Officials;
    // <GTH>
    RecordInsertList recordInsertParmTable_TH;
    // </GTH>
    RecordInsertList recordVendInvoiceInfoTable_W;

    VendInvoiceInfoTableTmp vendInvoiceInfoTableTmp;
    boolean insertHeaderInTempTable;

    Map parmSourceDocumentHeaderMap; // TableRefId, SourceDocument
    boolean autoConsolidate;
    boolean existMultipleLinesForVendorCurrency;
    boolean wasMatchStatusReset;
    boolean isPostingDateInClosedPeriod;

    /// The invoice number used by an intercompany invoice.
    Num currentInterCompanyInvoiceNum;

    // temporary state for chooseLines
    Map pendingInvoices;

    PurchQty newPostingPurchQty;
    InventQty newPostingInventQty;
    PdsCWInventQty newPostingCWQty;

    boolean isAdvanceReversal;

    // Create VendInvoiceInfoTable table records based on the chooseLines query when invoices are being created from packing slips?
    //  - This changes the behaviour in some functions.
    //  - The change is that the chooseLine query skips multiple lines before creating parm records. This is done in order to fetch inventTrans records for sublines.
    //  - The functionality is not provided through inheritance since PurchFormletterParmDataApproveJournal requires the same changes.
    boolean isFromPackingSlip;
    // Current source table and line. These are used since chooseLines will point to the next records.
    Common currentSourceLine;
    Common currentSourceTable;
    // Map for holding the vendPackingSlipTrans records
    Map subLinesMap;
    // Is chooselines pointing at the end?
    boolean chooseLinesEOF;
    // Is current source table changed? (Saved value of chooseLines.changed(tablenum(PurchTable))
    boolean currentSourceTableChanged;

    // Used for reSelect
    Map interCompanyInvoiceNumMap;

    // Used for reArrange
    Map unapproveInvoiceTotalsMap;
    Map arrangedInvoicesMap;
    Map holdUnapproveInvoicesMap;
    VendDocumentSubTableMap previousSubTable;

    NoYes splitSavedInvoice;

    SysQueryRun chooseLinesPendingInvoice;
    SysQueryRun chooseLinesNonPOInvoice;

    List activeInvoiceList;
    List invoicesInUseList;
    int activeInvoiceFlags = 0;

    // <GEERU>
    #ISOCountryRegionCodes
    RecordInsertList recordInsertParmLine_Asset_RU;
    OfficialsServ_RU offSrv;
    // </GEERU>

    RecId sourceDocumentHeaderRecId;
    DimensionDefault defaultDimension;
    RecId sourceDocumentLineRecId;
    Set headerSourceDocumentLines;
    Set newSourceDocumentHeaderIdSet;

    PurchInvoiceType invoiceType;
    AmountCur prepayInvoiceAmount;

    boolean isProcessingActiveInvoices;

    #define.HOLD(1)
    #define.UNAPPROVE(2)
    // <GEEU>
    #EECountryRegionCodes
    // </GEEU>

    boolean isFromPurchAgreement;
    // <GIN>
    boolean isFromBillOfEntry;
    // </GIN>

    TradeLineRefId tradeLineRefId;

    SysInstrumentationActivityContext activityContext;

    private Set scannedPurchIds;
    private boolean isFinTagConfigurationSetForCurrent = FinTagConfiguration::isFinTagConfigurationSet(curExt());

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addInsertFieldMapping</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a field mapping into the given <c>QueryBuildFieldList</c> instance and <c>Map</c> instance.
    /// </summary>
    /// <param name = "_fieldList">The given <c>QueryBuildFieldList</c> instance in which to add the field mapping.</param>
    /// <param name = "_fieldMapping">The given <c>Map</c> instance in which to add the field mapping.</param>
    /// <param name = "_sourceTableUniqueId">Unique ID for the datasource.</param>
    /// <param name = "_sourceFieldId">The field ID of the field to be added.</param>
    /// <param name = "_sourceFieldName">The name of the source field to be added.</param>
    /// <param name = "_destinationFieldName">The name of the destination field.</param>
    protected void addInsertFieldMapping(QueryBuildFieldList _fieldList, Map _fieldMapping, int _sourceTableUniqueId, FieldId _sourceFieldId, FieldName _sourceFieldName, FieldName _destinationFieldName)
    {
        _fieldList.addField(_sourceFieldId);
        _fieldMapping.insert(_destinationFieldName, [_sourceTableUniqueId, _sourceFieldName]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToKey_W</Name>
				<Source><![CDATA[
    protected str addToKey_W(str _key, VendDocumentSubTableMap _parmSubTable)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceInfoTable_W vendInvoiceInfoTable_W;

        select firstonly DeliveryName, DeliveryPostalAddress from vendInvoiceInfoTable
            join TaxInformation_IN from vendInvoiceInfoTable_W
                where vendInvoiceInfoTable.ParmId == _parmSubTable.ParmId
                    && vendInvoiceInfoTable.TableRefId == _parmSubTable.TableRefId
                    && vendInvoiceInfoTable_W.VendInvoiceInfoTable == vendInvoiceInfoTable.RecId;

        _key = this.addToKey(_key, vendInvoiceInfoTable.DeliveryName);
        _key = this.addToKey(_key, int642str(vendInvoiceInfoTable.DeliveryPostalAddress));
        if (taxesMarked)
        {
            _key = this.addToKey(_key, int642str(vendInvoiceInfoTable_W.TaxInformation_IN));
        }

        return _key;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInvoiceInfoMarkupMatchingTolerances</Name>
				<Source><![CDATA[
    private void createInvoiceInfoMarkupMatchingTolerances(ParmId _parmId)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;

        while select vendInvoiceInfoTable
            where vendInvoiceInfoTable.ParmId == _parmId
        {
            if (vendInvoiceInfoTable.VarianceApproved == NoYes::No)
            {
                VendInvoiceInfoMarkupMatchingTolerance::create(vendInvoiceInfoTable.ParmId, vendInvoiceInfoTable.TableRefId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyRanges</Name>
				<Source><![CDATA[
    private void copyRanges(QueryBuildDataSource _sourceDataSource, QueryBuildDataSource _destinationDataSource)
    {
        QueryBuildRange range;

        for (int i = 1; i <= _sourceDataSource.rangeCount(); i++)
        {
            range = _sourceDataSource.range(i);
            _destinationDataSource.addRange(range.field()).value(range.value());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTableRangeExists</Name>
				<Source><![CDATA[
    private boolean purchTableRangeExists(QueryBuildDataSource _purchTableDataSource, QueryBuildDataSource _nonPOInvoiceTableDataSource)
    {
        boolean rangeExists = false;

        // Loop through ranges and check for values
        for (int i = 1; i <= _purchTableDataSource.rangeCount(); i++)
        {
            QueryBuildRange purchTableRange = _purchTableDataSource.range(i);

            if (purchTableRange.value() != '')
            {
                FieldId purchTableRangeFieldId = fieldExt2Id(purchTableRange.field());

                // If it is a vendor range, allow it and copy it to the non-PO query
                if (purchTableRangeFieldId == fieldNum(PurchTable, InvoiceAccount))
                {
                    _nonPOInvoiceTableDataSource.addRange(fieldNum(VendInvoiceInfoTable, InvoiceAccount)).value(purchTableRange.value());
                }
                else if (purchTableRangeFieldId == fieldNum(PurchTable, OrderAccount))
                {
                    _nonPOInvoiceTableDataSource.addRange(fieldNum(VendInvoiceInfoTable, OrderAccount)).value(purchTableRange.value());
                }
                // We will allow range on PurchStatus, since it is added by the system and hidden
                else if (purchTableRangeFieldId != fieldNum(PurchTable, PurchStatus))
                {
                    rangeExists = true;
                }
            }

            if (rangeExists)
            {
                break;
            }
        }

        return rangeExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustLinesQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the <c>chooseLines</c> query to work with additional data sources.
    /// </summary>
    /// <param name="_queryAdditional">
    /// Specifies whether to query additional data sources.
    /// </param>
    /// <remarks>
    /// This method is called after the query ranges are already known.
    /// </remarks>
    protected void adjustLinesQuery(boolean _queryAdditional)
    {
        QueryBuildDataSource nonPOInvoiceTableDataSource;

        QueryBuildDataSource vendInvoiceInfoTableDataSource = chooseLines.query().dataSourceTable(tableNum(VendInvoiceInfoTable));
        QueryBuildDataSource purchTableDataSource = chooseLines.query().dataSourceTable(tableNum(PurchTable));
        
        if (chooseLinesNonPOInvoice)
        {
            nonPOInvoiceTableDataSource = chooseLinesNonPOInvoice.query().dataSourceTable(tableNum(VendInvoiceInfoTable));
        }

        if (_queryAdditional)
        {
            if (documentOrigin == DocumentOrigin::EnterprisePortal)
            {
                vendInvoiceInfoTableDataSource.clearRange(fieldNum(VendInvoiceInfoTable, VendInvoiceSaveStatus));
                vendInvoiceInfoTableDataSource.addRange(fieldNum(VendInvoiceInfoTable, VendInvoiceSaveStatus)).value(queryValue(VendInvoiceSaveStatus::New));
            }

            QueryBuildRange saveStatusRange = SysQuery::findOrCreateRange(vendInvoiceInfoTableDataSource, fieldNum(VendInvoiceInfoTable, VendInvoiceSaveStatus));

            if (saveStatusRange.value() == queryValue(VendInvoiceSaveStatus::Pending))
            {
                // Modify the query to avoid creating new invoices.
                purchTableDataSource.enabled(false);
            }
            else if (saveStatusRange.value() == queryValue(VendInvoiceSaveStatus::New))
            {
                // Modify the query to avoid fetching saved invoices.
                vendInvoiceInfoTableDataSource.enabled(false);
            }

            // allow only records with empty pool id
            SysQuery::findOrCreateRange(vendInvoiceInfoTableDataSource, fieldNum(VendInvoiceInfoTable, PoolRecId)).value(SysQuery::value(0));

            // --- Prepare pending invoices query ---
            this.copyRanges(purchTableDataSource, chooseLinesPendingInvoice.query().dataSourceTable(tableNum(PurchTable)));

            this.copyRanges(vendInvoiceInfoTableDataSource, chooseLinesPendingInvoice.query().dataSourceTable(tableNum(VendInvoiceInfoTable)));

            this.copyRanges(
                chooseLines.query().dataSourceTable(tableNum(VendInvoiceInfoLine)),
                chooseLinesPendingInvoice.query().dataSourceTable(tableNum(VendInvoiceInfoLine)));

            // --- Prepare non-PO invoices query ---
            if (!this.purchTableRangeExists(purchTableDataSource, nonPOInvoiceTableDataSource))
            {
                this.copyRanges(vendInvoiceInfoTableDataSource, nonPOInvoiceTableDataSource);

                this.copyRanges(
                    chooseLines.query().dataSourceTable(tableNum(VendInvoiceInfoLine)),
                    chooseLinesNonPOInvoice.query().dataSourceTable(tableNum(VendInvoiceInfoLine)));

                // allow only records with empty PO Id
                QueryBuildRange purchIdRange = SysQuery::findOrCreateRange(nonPOInvoiceTableDataSource, fieldNum(VendInvoiceInfoTable, PurchId));
                purchIdRange.value(SysQuery::value(''));
            }
            else
            {
                // PO range exists; don't retrieve non-PO invoices
                nonPOInvoiceTableDataSource.enabled(false);
                chooseLinesNonPOInvoice.query().dataSourceTable(tableNum(VendInvoiceInfoLine)).enabled(false);

                // Make PurchTable inner join to properly restrict query to force the PurchTable datasource to be used in the final query.
                chooseLinesPendingInvoice.query().dataSourceTable(tableNum(PurchTable)).joinMode(JoinMode::InnerJoin);
            }
        }
        else
        {
            // disable additional datasources
            vendInvoiceInfoTableDataSource.enabled(false);
            if (nonPOInvoiceTableDataSource)
            {
                nonPOInvoiceTableDataSource.enabled(false);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allInvoicesAreNegative</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether all of the vendor invoices have negative total amounts.
    /// </summary>
    /// <returns>
    /// true if the all invoices are negative; otherwise, false.
    /// </returns>
    protected boolean allInvoicesAreNegative()
    {
        VendInvoiceInfoTable invoice;
        PurchTotals purchTotals;
        boolean hasRecords;

        while select invoice
            where invoice.ParmId == parmId
        {
            hasRecords = true;
            purchTotals = PurchTotals::newParmTable(invoice, initialSpecQty, parmId, '', invoice.Ordering);
            purchTotals.calc();
            if (purchTotals.purchTotalAmount() >= 0)
            {
                return false;
            }
        }
        return hasRecords;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowChooseLines</Name>
				<Source><![CDATA[
    protected boolean allowChooseLines()
    {
        // Due to the possibility of pending lines we always need to allow here.
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowReArrange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a purchase invoice posting can be rearranged.
    /// </summary>
    /// <param name="_vendInvoiceInfoTable">
    /// The document to test to determine whether a saved pending invoice may be rearranged.
    /// </param>
    /// <returns>
    /// true if the provided saved pending invoice can be rearranged; otherwise, false.
    /// </returns>
    protected boolean allowReArrange(VendDocumentTableMap _vendInvoiceInfoTable)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;

        Debug::assert(_vendInvoiceInfoTable.TableId == tableNum(VendInvoiceInfoTable));

        if (purchParmUpdate.SumIncludePending == NoYes::No && _vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::Pending)
        {
            // If user doesn't want to include pending invoices, reject them
            return false;
        }

        vendInvoiceInfoTable = _vendInvoiceInfoTable;

        if (vendInvoiceInfoTable.hasPrepaymentApplicationLines())
        {
            // An invoice with prepayment application lines cannot be rearranged
            return false;
        }

        if (vendInvoiceInfoTable.RequestStatus != VendInvoiceRequestStatus::Draft)
        {
            // the current document is submitted to workflow;
            return false;
        }

        if (purchParmUpdate.SumBy != AccountOrder::None)
        {
            // Allow summary by something other than "None"
            return true;
        }

        if (_vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New)
        {
            // the current document is not a saved pending document;
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowSetBasedLogic</Name>
				<Source><![CDATA[
    protected boolean allowSetBasedLogic()
    {
        boolean allowSetBasedLogic = true;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) ||
            SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]) ||
            BrazilParameters::isEnabled() ||
            (!VendInvoiceCannotBePostedByMultiUserForJPFlight::instance().isEnabled() && 
            SysCountryRegionCode::isLegalEntityInCountryRegion([#isoJP])) ||
            (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && isFromPurchAgreement) ||
            interCompanyParmId ||
            purchParmUpdate.SpecQty == PurchUpdate::Recorded ||
            purchParmUpdate.SpecQty == PurchUpdate::RegisteredAndServices ||
            purchParmUpdate.SpecQty == PurchUpdate::BillOfEntryQuantity_IN)
        {
            allowSetBasedLogic = false;
        }

        return allowSetBasedLogic;
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoConsolidate</Name>
				<Source><![CDATA[
    protected void autoConsolidate()
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;

        if (autoConsolidate)
        {
            // Loop through new invoices and count unique vendor/currency combinations
            while select count(RecId) from vendInvoiceInfoTable
                group by vendInvoiceInfoTable.InvoiceAccount, vendInvoiceInfoTable.CurrencyCode
                where vendInvoiceInfoTable.ParmId == this.parmId()
                   && vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New
            {
                if (vendInvoiceInfoTable.RecId > 1)
                {
                    existMultipleLinesForVendorCurrency = true;
                    break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAllowEmptyParmTableByLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether allowing an empty invoice header should be checked per line.
    /// </summary>
    /// <returns>
    /// true if allowing an empty invoice header should be checked per line; otherwise, false.
    /// </returns>
    protected boolean canAllowEmptyParmTableByLine()
    {
        // <GEERU>
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        if (countryRegion_RU)
        {
            return true;
        }
        //</GEERU>

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateParmLine</Name>
				<Source><![CDATA[
    protected boolean canCreateParmLine(
        PurchId _purchId,
        VendPostingProfile _postingProfile_RU = PurchTable::find(_purchId).PostingProfile,
        InventProfileType_RU _inventProfileType_RU = InventProfileType_RU::General)
    {
        boolean isAllowed;
        PurchLine localPurchLine;

        // <GEERU>
        #ISOCountryRegionCodes
        PurchTable localPurchTable = PurchTable::find(_purchId);
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        boolean hasQty(PurchUpdate localSpecQty)
        {
            PurchQty receiveNow, remainBefore, remainAfter;

            if (localSpecQty != purchParmUpdate.SpecQty)
            {
                if (localSpecQty == PurchUpdate::PackingSlip)
                {
                    newPostingPurchQty = naReal();
                }

                while select localPurchLine
                    where localPurchLine.PurchId == _purchId
                        && !localPurchLine.IsDeleted
                {
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        if (this.postingProfile_RU(localPurchLine.purchLine_W().PostingProfile_RU, localPurchTable.PostingProfile) != _postingProfile_RU)
                        {
                            continue;
                        }

                        if (this.inventProfileType_RU(localPurchLine) != _inventProfileType_RU)
                        {
                            continue;
                        }
                    }
                    // </GEERU>
                    [receiveNow, remainBefore, remainAfter] = this.qtyPurch (localPurchLine, naReal(), localSpecQty);

                    if (receiveNow != 0)
                    {
                        break;
                    }
                }
            }

            return receiveNow != 0.0;
        }

        isAllowed = true;

        if (pendingInvoices != null && isAllowed)
        {
            // verify there is no pending invoice for current purchase order
            isAllowed = !pendingInvoices.exists(_purchId);

            if (!isAllowed)
            {
                // verify if a line would be created for any specQty position
                isAllowed = hasQty(PurchUpdate::All) || hasQty(PurchUpdate::PackingSlip) ||
                    hasQty(PurchUpdate::ReceiveNow) || hasQty(PurchUpdate::Recorded);
            }
        }

        return isAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGetPurchIdFromParmTable</Name>
				<Source><![CDATA[
    protected boolean canGetPurchIdFromParmTable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAdvancePayments_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if advance payments exists for current update and checks them
    /// </summary>
    /// <param name="_showBox">
    /// Determines if box should be shown to user to prompt for proceeding if prepayments exist
    /// </param>
    /// <returns>
    /// True, if no prepayments found or user decided to proceed
    /// </returns>
    public boolean checkAdvancePayments_W(boolean _showBox = false)
    {
        boolean ret = true;

        VendInvoiceInfoTable localVendInvoiceInfoTable;
        VendInvoiceInfoLine localVendInvoiceInfoLine;
        PurchTable localPurchTable;

        Set purchSet = new Set(Types::String);

        Set vendSet = new Set(Types::Container);
        SetIterator vendIterator;

        boolean advanceAdjustment = LedgerParameters::find().AdvanceAdjustment_W;

        if (!isConfigurationkeyEnabled(configurationKeyNum(CzCustVendAdvanceInvoices)) && !advanceAdjustment)
        {
            return true;
        }

        while select PurchId, InvoiceAccount, RecId from localPurchTable
            join TransDate from localVendInvoiceInfoTable
                where localVendInvoiceInfoTable.ParmId == purchParmUpdate.ParmId
            exists join localVendInvoiceInfoLine
                where localVendInvoiceInfoLine.OrigPurchId == localPurchTable.PurchId &&
                    localVendInvoiceInfoLine.ParmId == purchParmUpdate.ParmId &&
                    localVendInvoiceInfoTable.TableRefId == localVendInvoiceInfoLine.TableRefId
        {
            if (purchSet.in(localPurchTable.PurchId))
                continue;

            if ((advanceAdjustment &&
                CustVendExchAdjustment_W::existsPrepayments(ModuleCustVend::Vend,
                                                            localPurchTable.InvoiceAccount,
                                                            localVendInvoiceInfoTable.TransDate)) ||
                (CzVendAdvanceInvoiceLink::existsPaymentForOrder(localPurchTable.company(), localPurchTable.PurchId) &&
                ! SpecTrans::findBySpec(localPurchTable.DataAreaId, tableNum(PurchTable), localPurchTable.RecId)))
            {
                if (!_showBox)
                {
                    warning(strFmt("@GLS111760", localPurchTable.PurchId));
                }

                purchSet.add(localPurchTable.PurchId);
            }

            vendSet.add([localPurchTable.company(), localPurchTable.InvoiceAccount]);
        }

        if (_showBox && purchSet.elements())
        {
            ret = Box::okCancel(strFmt("@GLS111763", strRem(purchSet.toString(), '{}')), DialogButton::Cancel) == DialogButton::Ok;
        }
        else if (! advanceAdjustment)
        {
            vendIterator = new SetIterator(vendSet);
            while (vendIterator.more())
            {
                if (CzVendAdvanceInvoiceLink::existsNonLinkedPayment(conPeek(vendIterator.value(), 1), VendTable::find(conPeek(vendIterator.value(), 2)).Party))
                {
                    info(strFmt("@GLS111764", conPeek(vendIterator.value(), 2)));
                }

                if (CzVendAdvanceInvoiceLink::existsPaymentLinkedToManual(conPeek(vendIterator.value(), 1), conPeek(vendIterator.value(), 2)))
                {
                    info(strFmt("@GLS111765", conPeek(vendIterator.value(), 2)));
                }

                vendIterator.next();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBeforePost</Name>
				<Source><![CDATA[
    public boolean checkBeforePost(boolean _showBox = false)
    {
        return this.checkAdvancePayments_W(_showBox) && this.checkStorno(_showBox);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a budget funds available check.
    /// </summary>
    /// <param name="_cachingMethod">
    /// An Enum value that specifies whether to use new or existing cached instances of the <c>PurchTotals</c> class within a transactional scope.
    /// </param>
    /// <remarks>
    /// This method will create distributions if the budget funds available check is required and
    /// distributions are not yet created.
    /// </remarks>
    protected void checkBudget(PurchTotalsCachingMethod _cachingMethod = PurchTotalsCachingMethod::Reuse)
    {
        SetEnumerator sourceDocumentHeaderIdSetEnumerator;
        RecId sourceDocumentHeaderId;
        VendInvoiceInfoTable vendInvoice;
        PurchTotals localPurchTotals;

        if (newSourceDocumentHeaderIdSet != null)
        {
            if (Ledger::isLedgerBudgetControlEnabled(Ledger::current()))
            {
                sourceDocumentHeaderIdSetEnumerator = newSourceDocumentHeaderIdSet.getEnumerator();

                while (sourceDocumentHeaderIdSetEnumerator.moveNext())
                {
                    sourceDocumentHeaderId = sourceDocumentHeaderIdSetEnumerator.current();

                    vendInvoice = VendInvoiceInfoTable::findSourceDocumentHeader(sourceDocumentHeaderId);

                    if (!VendInvoiceInfoTable::existSaved(vendInvoice.TableRefId))
                    {
                        // force the TaxUncommitted records to be created so that SourceDocumentProcessorFacade has a completed document to operate against
                        localPurchTotals = PurchTotals::newParmTable(vendInvoice, // parmTable
                                                        PurchUpdate::All, // specQty
                                                        vendInvoice.ParmId, // parmId
                                                        '', // sumPurchId
                                                        vendInvoice.Ordering, // documentStatus
                                                        _cachingMethod);

                        localPurchTotals.calc(true, false, true);

                        if (VendInvoiceInfoSubTable::existAnyPurchId(vendInvoice.ParmId, vendInvoice.TableRefId))
                        {
                            // Budget check should be performed immediately for newly created invoice that is matched to a purchase order
                            // to ensure budget encumbrance reservations are relieved.
                            SourceDocumentProcessorFacade::submitOnDemandSourceDocumentImpl(vendInvoice);
                        }
                        else
                        {
                            SourceDocumentProcessorFacade::submitSourceDocumentImplementation(vendInvoice);
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkStorno</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks a posibility of storno of the invoice.
    /// </summary>
    /// <param name="_showBox">
    /// A Boolean optional value that allows displaying a confirmation dialog box.
    /// </param>
    /// <returns>
    /// true if the storno can be posted; otherwise, false.
    /// </returns>
    public boolean checkStorno(boolean _showBox = false)
    {
        return !PurchParmUpdate::find(parmId).Storno ||
            this.allInvoicesAreNegative() ||
            !_showBox ||
            Box::confirm("@GLS221792");
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesAdvance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an advance header and line that are based on the <c>newAdvancePurchId</c> set values that
    /// contain purchase IDs.
    /// </summary>
    protected void chooseLinesAdvance()
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        PurchPrepayTable purchPrepayTable;

        Debug::assert(purchTable.RecId != 0);

        purchPrepayTable = PurchPrepayTable::findPurchId(purchTable.PurchId);
        prepayInvoiceAmount = purchPrepayTable.PrepayAvailable - purchPrepayTable.amountPrepayPending();

        if (prepayInvoiceAmount > 0.0 && this.createAdvance(purchTable))
        {
            this.createAdvanceLine(purchTable);
        }

        if (VendInvoiceInfoTable::existPrepayPendingForPurchOrder(purchTable.PurchId))
        {
            while select forUpdate vendInvoiceInfoTable
                where vendInvoiceInfoTable.InvoiceType == PurchInvoiceType::VendorAdvance
                    && vendInvoiceInfoTable.ParmId == ''
                    && vendInvoiceInfoTable.PurchId == purchTable.PurchId
            {
                VendInvoiceInfoTable::moveFromSavedToActive(vendInvoiceInfoTable, this.parmId());
            }
        }

        activeInvoiceList.appendList(this.getActiveList(purchTable.PurchId, this.parmId(), PurchInvoiceType::VendorAdvance));
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesChangedSourceTable</Name>
				<Source><![CDATA[
    protected boolean chooseLinesChangedSourceTable()
    {
        // <GIN>
        if (isFromBillOfEntry)
        {
            return currentSourceTableChanged;
        }
        else
        {
            // </GIN>
            return isFromPackingSlip ? currentSourceTableChanged : super();
            // <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesCleanupList</Name>
				<Source><![CDATA[
    private void chooseLinesCleanupList()
    {
        pendingInvoices = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesFromPurchSelectLinesManager</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or deletes the invoice lines based on user selection in the <c>PurchSelectLines</c> form.
    /// </summary>
    protected void chooseLinesFromPurchSelectLinesManager()
    {
        Set newPurchLineRecIdSet; //VendInvoiceInfoLine to be created
        Set deletePurchTablePurchIdSet; //VendInvoiceInfoTable to be deleted
        Set deletePurchLineRecIdSet; //VendInvoiceInfoLine to be deleted
        SetEnumerator tmpSE;
        PurchTable localPurchTable;
        PurchLine localPurchLine;
        TradeLineRefId localTradeLineRefId;
        boolean mayJournalBePosted;
        boolean isCurrentInvoiceLineCreated = false;
        boolean isAnyInvoiceLineCreated = false;
        boolean areAllInvoiceLinesCreated = true;
        PurchId prvPurchLinePurchId;
        MapEnumerator parmLineMapEnumerator;
        VendInvoiceInfoLine invoiceLine;
        VendInvoiceInfoTable invoiceTable;
        VendInvoiceInfoSubTable invoiceSubTable;
        VendParameters vendParameters;
        MarkupCopy markupCopy;

        //creates the local set objects
        newPurchLineRecIdSet = Set::create(this.parmNewPurchLineRecIdSet());
        deletePurchTablePurchIdSet = Set::create(this.parmDeletePurchTablePurchIdSet());
        deletePurchLineRecIdSet = Set::create(this.parmDeletePurchLineRecIdSet());
        subLinesMap = this.initSubLinesMap();
        mayJournalBePosted = true;

        ttsbegin;

        //deletes the VendInvoiceInfoLine records based on deletePurchLineRecIdSet
        tmpSE = deletePurchLineRecIdSet.getEnumerator();

        while (tmpSE.moveNext())
        {
            this.deleteParmLine(tmpSE.current());
        }
        //deletes the VendInvoiceInfoTable records based on deletePurchTablePurchIdSet
        tmpSE = deletePurchTablePurchIdSet.getEnumerator();

        while (tmpSE.moveNext())
        {
            this.deleteParmSubTable(tmpSE.current());
        }

        this.initRecordLists();

        tmpSE = newPurchLineRecIdSet.getEnumerator();

        while (tmpSE.moveNext())
        {
            localPurchLine = PurchLine::findRecId(tmpSE.current());

            // <GIN>
            if (isFromBillOfEntry)
            {
                subLinesMap = this.initSubLinesMap();
            }
            else
            {
                // </GIN>
                if (isFromPackingSlip)
                {
                    subLinesMap = this.initSubLinesMap();
                }
                // <GIN>
            }
            // </GIN>
            if (prvPurchLinePurchId != localPurchLine.PurchId)
            {
                localPurchTable = PurchTable::find(localPurchLine.PurchId);
                prvPurchLinePurchId = localPurchLine.PurchId;

                //checks for issue of HeaderMiscCharges allocation and PrepayLimit field of PurchPrepayTable table validation
                //warning messages need to be shown once per PurchTable

                mayJournalBePosted = this.mayJournalBePosted(localPurchTable);

                if (mayJournalBePosted && PurchPrepayTable::exist(localPurchTable.PurchId))
                {
                    mayJournalBePosted = PurchPrepayTable::isPrepayLimitValid(localPurchTable.PurchId, strFmt("@SYS303213", localPurchTable.PurchId));
                }

                if (!mayJournalBePosted)
                {
                    this.infoSourceTableSkipped(localPurchTable);
                }
            }

            //creates the VendInvoiceInfoLine records based on newPurchLineRecIdSet
            if (mayJournalBePosted)
            {
                localTradeLineRefId = externalDefaultedParmTable.TableRefId;

                // Get inventTrans records for current
                this.collectAndInsertSubLines(localPurchLine);
                
                initQtyFromPO = true;
                isCurrentInvoiceLineCreated = this.createParmLine(localPurchLine, localTradeLineRefId);
                isAnyInvoiceLineCreated = isAnyInvoiceLineCreated || isCurrentInvoiceLineCreated;
                areAllInvoiceLinesCreated = areAllInvoiceLinesCreated && isCurrentInvoiceLineCreated;
                initQtyFromPO = false;
            }
            else
            {
                continue;
            }
        }

        prvPurchLinePurchId = '';

        // Insert the new lines into the database
        this.insertRecordLists();

        markupCopy = MarkupCopy::construct();

        parmLineMapEnumerator = parmLineMap.getEnumerator();
        while (parmLineMapEnumerator.moveNext())
        {
            invoiceLine = parmLineMapEnumerator.currentValue();
            localPurchLine = invoiceLine.purchLine();

            if (prvPurchLinePurchId != localPurchLine.PurchId)
            {
                prvPurchLinePurchId = localPurchLine.PurchId;

                // create VendInvoiceInfoSubTable row for each distinct OrigPurchId
                if (!VendInvoiceInfoSubTable::exist(invoiceLine.ParmId, invoiceLine.TableRefId, invoiceLine.OrigPurchId))
                {
                    invoiceSubTable = VendInvoiceInfoSubTable::createFromVendInvoiceInfoLine(invoiceLine, invoiceLine.ParmId, localPurchLine.purchTable().PurchName, false);

                    PurchFormletterParmDataInvoice::initSubTableSourceAccountingEvent(invoiceSubTable);

                    invoiceSubTable.insert();

                    localPurchTable = localPurchLine.purchTable();
                    MarkupCopyFromPurchOrderParameters copyFromPurchOrderToSubTableParameters = 
                        this.createMarkupCopyParametersForChooseLinesSubtable(
                            localPurchTable, 
                            invoiceSubTable, 
                            '', 
                            localPurchTable.CurrencyCode, 
                            SourceDocumentLineAccountingStatus::Draft, 
                            localPurchTable, 
                            false);
                    markupCopy.copyFromPurchOrder(copyFromPurchOrderToSubTableParameters);
                }
            }

            // MarkupTrans holds a reference to SourceDocumentLine and since we have suppressed RecID generation for SourceDocumentLine we need to
            // insert MarkupTrans after the recordInsertLists have been inserted to disk and RecID generation has been reenabled.
            // keep the markupTrans at Draft so that its parent, ie, vendInvoiceInfoLine also stays in draft as vendInvoiceInfoLine taxes
            // do not yet exist and will be missed during distribution.
            localPurchTable = localPurchLine.purchTable();
            MarkupCopyFromPurchOrderParameters copyFromPurchOrderToLineParameters = 
                this.createMarkupCopyParametersForChooseLinesInfoLine(
                    localPurchLine, 
                    invoiceLine, 
                    '', 
                    '', 
                    SourceDocumentLineAccountingStatus::Draft, 
                    localPurchTable, 
                    false);
            markupCopy.copyFromPurchOrder(copyFromPurchOrderToLineParameters);
        }

        if (invoiceSubTable)
        {
            // at least one PO-related new sub-table was created. Cleanup non-PO sub table with no lines if exists.
            VendInvoiceInfoSubTable::deleteIfNoLines('', invoiceSubTable.ParmId, invoiceSubTable.TableRefId);
        }

        if (isAnyInvoiceLineCreated)
        {
            invoiceTable = VendInvoiceInfoTable::find(this.parmId(), localTradeLineRefId, true);

            this.invoiceLineCreated(invoiceTable);
        }

        invoiceTable = VendInvoiceInfoTable::find(this.parmId(), externalDefaultedParmTable.TableRefId, true);

        // Update the PurchId field on the invoice header if the previously selected purchase order is no longer included
        // Or at least one line was added for an additional PO, in case the original PO has no lines on this invoice.
        if (invoiceTable && (isAnyInvoiceLineCreated || invoiceTable.PurchId == '' || (!deletePurchTablePurchIdSet.empty() && deletePurchTablePurchIdSet.in(invoiceTable.PurchId))))
        {
            VendInvoiceInfoSubTable::deleteIfNoLines(invoiceTable.PurchId, invoiceTable.ParmId, invoiceTable.TableRefId);
        }

        vendParameters = VendParameters::find();
        //If automatic header matching is off and we have removed a PO, PO line, or added a line, then invalidate the current invoice.
        if (!vendParameters.editAutomaticHeaderMatching() && (!deletePurchTablePurchIdSet.empty() || !deletePurchLineRecIdSet.empty() || isAnyInvoiceLineCreated))
        {
            invoiceTable.checkIfMatched();
        }

        if (!deletePurchTablePurchIdSet.empty() || !deletePurchLineRecIdSet.empty() || isAnyInvoiceLineCreated)
        {
            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                // If we have removed a PO, PO line, or added any new line, then mark current tax status as dirty.
                invoiceTable.markCurrentTaxDocumentTaxStatusDirty();
            }
        }

        this.processPrepaymentApplication(invoiceTable);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]))
        {
            this.defaultHeaderCountryRegionData();
        }

        ttscommit;

        if (isFromPackingSlip && !areAllInvoiceLinesCreated)
        {
            warning("@SYS4000972");
        }
        else if ((purchParmUpdate.SpecQty == PurchUpdate::Recorded) && !areAllInvoiceLinesCreated)
        {
            warning("@AccountsPayable:POLinesNoRegisteredQuantity");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectAndInsertSubLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and inserts sublines into the <c>subLinesMap</c>.
    /// </summary>
    /// <param name="_localPurchLine">The local <c>PurchLine</c> table instance used to collect and insert sublines.</param>
    protected void collectAndInsertSubLines(PurchLine _localPurchLine)
    {
        // <GIN>
        if (isFromBillOfEntry)
        {
            CustomsVendBOETrans_IN customsVendBOETransCopy;

            // When creating from Bill of entry collect bill of entry to create sub lines.
            while select customsVendBOETransCopy
                where customsVendBOETransCopy.InventTransId == _localPurchLine.InventTransId
                    && customsVendBOETransCopy.RemainingQty != 0
                    && customsVendBOETransCopy.Status != CustomsVendBOEStatus_IN::Canceled
            {
                subLinesMap.insert(customsVendBOETransCopy.RecId, customsVendBOETransCopy);
            }
        }
        else
        {
            // </GIN>
            if (isFromPackingSlip)
            {
                VendPackingSlipTrans vendPackingSlipTrans;

                // When creating from packing slip collect packing slips to create sub lines.
                while select vendPackingSlipTrans
                    where vendPackingSlipTrans.InventTransId == _localPurchLine.InventTransId
                        && vendPackingSlipTrans.FullyMatched == NoYes::No
                {
                    subLinesMap.insert(vendPackingSlipTrans.RecId, vendPackingSlipTrans);
                }
            }
            // <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesGetSourceLine</Name>
				<Source><![CDATA[
    protected Common chooseLinesGetSourceLine()
    {
        // <GIN>
        if (isFromBillOfEntry)
        {
            return currentSourceLine;
        }
        else
        {
            // </GIN>
            return isFromPackingSlip ? currentSourceLine : super();
            // <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceLineCreated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the updates after an invoice line is created.
    /// </summary>
    /// <param name = "_invoiceTable">A <c>VendInvoiceInfoTable</c> record.</param>
    protected void invoiceLineCreated(VendInvoiceInfoTable _invoiceTable)
    {
        if (this.mustApproveVariance())
        {
            // Unapprove the invoice, since changes have been made
            _invoiceTable.approveVariance(false, true);
        }

        TaxUncommitted::deleteForDocumentHeader(_invoiceTable.TableId, _invoiceTable.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustApproveVariance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to approve variance.
    /// </summary>
    /// <returns>true if the variance must be approved; otherwise, false.</returns>
    protected boolean mustApproveVariance()
    {
        VendParameters vendParameters = VendParameters::find();

        return  (vendParameters.UseTotalPriceMatching == NoYes::Yes || vendParameters.UseMiscChargeMatching == NoYes::Yes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesGetSourceTable</Name>
				<Source><![CDATA[
    protected Common chooseLinesGetSourceTable()
    {
        // <GIN>
        if (isFromBillOfEntry)
        {
            return currentSourceTable;
        }
        else
        {
            // </GIN>
            return isFromPackingSlip ? currentSourceTable : super();
            // <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesNext</Name>
				<Source><![CDATA[
    protected boolean chooseLinesNext()
    {
        boolean ret;
        VendPackingSlipTrans vendPackingSlipTrans;
        // <GIN>
        CustomsVendBOETrans_IN customsVendBOETransCopy;
        // </GIN>

        // <GIN>
        if (isFromBillOfEntry)
        {
            // Reset map
            subLinesMap = this.initSubLinesMap();

            // Invariant: chooseLines either points to a new PurchLine and possibly a new PurchTable OR it is at eof.
            // If at eof then latest super() returned false.
            // Since chooseLines the very first time points before the next, we have to call super() once.
            // First run?
            if (!currentSourceTable.RecId)
            {
                chooseLinesEOF = !super();
            }
            // any records left?
            ret = !chooseLinesEOF;
            // Also cache whether we have a new sourceTable.
            currentSourceTableChanged = chooseLines.changed(tableNum(PurchTable));

            // process next couple of records.
            while (!chooseLinesEOF)
            {
                // copy records since we will go to next.
                currentSourceTable = chooseLines.get(this.sourceTableTableId()).data();
                currentSourceLine = chooseLines.get(this.sourceLineTableId()).data();

                while select InventTransId, RecId from customsVendBOETransCopy
                where customsVendBOETransCopy.PurchLineRecId == currentSourceLine.RecId
                    && customsVendBOETransCopy.RemainingQty != 0
                    && customsVendBOETransCopy.Status != CustomsVendBOEStatus_IN::Canceled
                {
                    subLinesMap.insert(customsVendBOETransCopy.RecId, customsVendBOETransCopy);
                }
                // Go to to next or eof
                chooseLinesEOF = !super();
                if (!chooseLinesEOF)
                {
                    // if next is different, stop the loop.
                    if (chooseLines.changed(tableNum(PurchLine)) || chooseLines.changed(tableNum(PurchTable)))
                    {
                        break;
                    }
                }
            }
        }
        else
        {
            // </GIN>
            if (!isFromPackingSlip)
            {
                ret = super();
            }
            else
            {
                // Reset map
                subLinesMap = this.initSubLinesMap();

                // Invariant: chooseLines either points to a new PurchLine and possibly a new PurchTable OR it is at eof.
                // If at eof then latest super() returned false.
                // Since chooseLines the very first time points before the next, we have to call super() once.
                // First run?
                if (!currentSourceTable.RecId)
                {
                    chooseLinesEOF = !super();
                }
                // any records left?
                ret = !chooseLinesEOF;
                // Also cache whether we have a new sourceTable.
                currentSourceTableChanged = chooseLines.changed(tableNum(PurchTable));

                // process next couple of records.
                while (!chooseLinesEOF)
                {
                    vendPackingSlipTrans = chooseLines.get(tableNum(VendPackingSlipTrans));

                    this.collectPackingSlipSubLines(subLinesMap,vendPackingSlipTrans.VendPackingSlipJour, vendPackingSlipTrans.InventTransId);

                    // copy records since we will go to next.
                    currentSourceTable = chooseLines.get(this.sourceTableTableId()).data();
                    currentSourceLine = chooseLines.get(this.sourceLineTableId()).data();
                    // Go to to next or eof
                    chooseLinesEOF = !super();
                    if (!chooseLinesEOF)
                    {
                        // if next is different, stop the loop.
                        if (chooseLines.changed(tableNum(PurchLine)) || chooseLines.changed(tableNum(PurchTable)))
                        {
                            break;
                        }
                    }
                }
            }
            // <GIN>
        }
        // </GIN>
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupChooseLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Re-enables a source table in a query.
    /// </summary>
    /// <remarks>
    /// This method can be overridden in derived classes to perform a cleanup at the end of the
    /// <c>ChooseLines</c> method.
    /// </remarks>
    protected void cleanupChooseLines()
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        MapEnumerator invoiceTableMapEnumerator;

        super();

        this.chooseLinesCleanupList();
        chooseLines.query().dataSourceTable(tableNum(VendInvoiceInfoTable)).enabled(true);
        this.moveTaxRegulations();

        invoiceTableMapEnumerator = parmTableMap.getEnumerator();
        while (invoiceTableMapEnumerator.moveNext())
        {
            vendInvoiceInfoTable = invoiceTableMapEnumerator.currentValue();

            if (vendInvoiceInfoTable.RecId == 0)
            {
                // If the table buffer doesn't have the RecId, get it from disk
                vendInvoiceInfoTable = VendInvoiceInfoTable::find(vendInvoiceInfoTable.ParmId, vendInvoiceInfoTable.TableRefId);
            }
            
            this.cleanupForHeader(vendInvoiceInfoTable);
        }

        if (!lastParmTableRecId)
        {
            lastParmTableRecId = vendInvoiceInfoTable.RecId;
        }

        this.autoConsolidate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectPackingSlipSubLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Collects a packing slip line that is not fully matched for a packing slip.
    /// </summary>
    /// <param name="_map">
    /// The map in which to insert the found line.
    /// </param>
    /// <param name="_vendPackingSlipJourRecId">
    /// The packing slip for which to find the line.
    /// </param>
    /// <param name="_inventTransId">
    /// The <c>InventTransId</c> data type for the line.
    /// </param>
    protected void collectPackingSlipSubLines(Map _map, VendPackingSlipJourRecId _vendPackingSlipJourRecId, TradeInventTransId _inventTransId)
    {
        VendPackingSlipTrans vendPackingSlipTrans;

        select firstonly vendPackingSlipTrans
            where vendPackingSlipTrans.VendPackingSlipJour == _vendPackingSlipJourRecId
               && vendPackingSlipTrans.InventTransId == _inventTransId
               && vendPackingSlipTrans.FullyMatched == NoYes::No;

        if (vendPackingSlipTrans.RecId)
        {
            _map.insert(vendPackingSlipTrans.RecId, vendPackingSlipTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyMarkupFromPurchOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies markup transaction using purchase order.
    /// </summary>
    /// <param name = "_vendInvoiceInfoTable">
    /// The <c>VendInvoiceInfoTable</c> record.
    /// </param>
    [Wrappable(true)]
    protected final void copyMarkupFromPurchOrder(VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        // MarkupTrans holds a reference to SourceDocumentLine and since we have suppressed RecID generation for SourceDocumentLine we need to
        // insert MarkupTrans after the recordInsertLists have been inserted to disk and RecID generation has been reenabled.

        VendInvoiceInfoSubTable vendInvoiceInfoSubTable;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        PurchTable localPurchTable;
        PurchLine localPurchLine;
        Num localCurrentInterCompanyInvoiceNum;
        MarkupTrans markupTrans;
        MarkupCopy markupCopy;
        boolean isIntercompanyOrder = false;

        markupCopy = MarkupCopy::construct();

        while select vendInvoiceInfoSubTable
            where vendInvoiceInfoSubTable.ParmId == _vendInvoiceInfoTable.ParmId
                && vendInvoiceInfoSubTable.TableRefId == _vendInvoiceInfoTable.TableRefId
            join localPurchTable
                where localPurchTable.PurchId == vendInvoiceInfoSubTable.OrigPurchId
            notExists join markupTrans
                where markupTrans.TransTableId == vendInvoiceInfoSubTable.TableId
                    && markupTrans.TransRecId == vendInvoiceInfoSubTable.RecId
                    && !markupTrans.IsDeleted
        {
            localCurrentInterCompanyInvoiceNum = this.interCompanyInvoiceNum(localPurchTable);
            isIntercompanyOrder = isIntercompanyOrder || localPurchTable.isInterCompanyOrder();
            MarkupCopyFromPurchOrderParameters copyFromPurchOrderToSubTableParameters =
                this.createMarkupCopyParametersForCopyMarkupSubTable(
                    localPurchTable,
                    vendInvoiceInfoSubTable,
                    localCurrentInterCompanyInvoiceNum,
                    _vendInvoiceInfoTable.CurrencyCode,
                    SourceDocumentLineAccountingStatus::Draft,
                    localPurchTable);
            markupCopy.copyFromPurchOrder(copyFromPurchOrderToSubTableParameters);
        }

        select firstonly RecId from vendInvoiceInfoLine
            where vendInvoiceInfoLine.ParmId == _vendInvoiceInfoTable.ParmId
                && vendInvoiceInfoLine.TableRefId == _vendInvoiceInfoTable.TableRefId
            exists join localPurchLine
                where localPurchLine.RecId == vendInvoiceInfoLine.PurchLineRecId
            join markupTrans
                where markupTrans.TransTableId == localPurchLine.TableId
                    && markupTrans.TransRecId == localPurchLine.RecId
                    && !markupTrans.IsDeleted;

        if (vendInvoiceInfoLine.RecId == 0)
        {
            return;
        }

        if (!isInterCompanyOrder && !TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            //insert_recordset markupTransDestination (
            //    TransTableId, TransRecId,
            //    OrigTableId, OrigRecId,
            //    CurrencyCode, Keep, LineNum, MarkupCategory, MarkupCode, ModuleType, Txt, Value)
            //select TableId, RecId from vendInvoiceInfoLine
            //    where vendInvoiceInfoLine.ParmId == _vendInvoiceInfoTable.ParmId
            //        && vendInvoiceInfoLine.TableRefId == _vendInvoiceInfoTable.TableRefId
            //join from localPurchLine
            //    where localPurchLine.RecId == vendInvoiceInfoLine.PurchLineRecId
            //join TableId, RecId, CurrencyCode, Keep, LineNum, MarkupCategory, MarkupCode, ModuleType, Txt, Value from markupTransSource
            //    where markupTransSource.TransTableId == localPurchLine.TableId
            //        && markupTransSource.TransRecId == localPurchLine.RecId
            //        && !markupTransSource.IsDeleted
            //        && (markupTransSource.Keep || markupTransSource.DocumentStatus != DocumentStatus::Invoice)
            //notExists join markupTrans
            //    where markupTrans.TransTableId == vendInvoiceInfoLine.TableId
            //        && markupTrans.TransRecId == vendInvoiceInfoLine.RecId
            //        && !markupTrans.IsDeleted;

            // Perform set-based copy
            
            ttsbegin;

            MarkupCopyFromPurchOrderParameters copyFromPurchOrderToLineParameters =
                    this.createMarkupCopyParametersForCopyMarkupInfoLine(
                        localPurchLine,
                        vendInvoiceInfoLine,
                        '',
                        '',
                        SourceDocumentLineAccountingStatus::Draft,
                        null,
                        false);
            copyFromPurchOrderToLineParameters.parmBufferToWhereClause(this.buildWhereClauseForMarkupTransDestination(_vendInvoiceInfoTable, vendInvoiceInfoLine));
            copyFromPurchOrderToLineParameters.parmBufferFromWhereClause(this.buildWhereClauseForMarkupTransSource(localPurchLine, vendInvoiceInfoLine));
            copyFromPurchOrderToLineParameters.parmDocumentStatusToExclude(DocumentStatus::Invoice);
            
            if (PurchOrderInvoiceMarkUpTransCopyPerformanceFlight::instance().isEnabled())
            {
                MarkupTransTmp markUpTransTmp = markupCopy.copyForAllDocumentLinesUsingTempMarkupTrans(copyFromPurchOrderToLineParameters);
                this.copyMarkupFromPurchOrderOptimizedCleanup(_vendInvoiceInfoTable, markUpTransTmp);
            }
            else
            {
                markupCopy.copyForAllDocumentLines(copyFromPurchOrderToLineParameters);
                this.copyMarkupFromPurchOrderCleanup(_vendInvoiceInfoTable);
            }

            ttscommit;
        }
        else
        {
            while select vendInvoiceInfoLine
                where vendInvoiceInfoLine.ParmId == _vendInvoiceInfoTable.ParmId
                    && vendInvoiceInfoLine.TableRefId == _vendInvoiceInfoTable.TableRefId
                join localPurchLine
                    where localPurchLine.RecId == vendInvoiceInfoLine.PurchLineRecId
                join localPurchTable
                    where localPurchTable.PurchId == localPurchLine.PurchId
                notExists join markupTrans
                    where markupTrans.TransTableId == vendInvoiceInfoLine.TableId
                        && markupTrans.TransRecId == vendInvoiceInfoLine.RecId
                        && !markupTrans.IsDeleted
            {
                localCurrentInterCompanyInvoiceNum = this.interCompanyInvoiceNum(localPurchTable);
                // keep the markupTrans at Draft so that its parent, ie, vendInvoiceInfoLine also stays in draft as vendInvoiceInfoLine taxes
                // do not yet exist and will be missed during distribution.
                MarkupCopyFromPurchOrderParameters copyFromPurchOrderToLineParameters =
                    this.createMarkupCopyParametersForCopyMarkupInfoLine(
                        localPurchLine,
                        vendInvoiceInfoLine,
                        localCurrentInterCompanyInvoiceNum,
                        '',
                        SourceDocumentLineAccountingStatus::Draft,
                        localPurchTable);
                markupCopy.copyFromPurchOrder(copyFromPurchOrderToLineParameters);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyMarkupFromBOEJour</Name>
				<Source><![CDATA[
    private void copyMarkupFromBOEJour(VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        // Copy charge from BOE journal instead of Purchase order for import order of India.

        VendInvoiceInfoSubTable vendInvoiceInfoSubTable;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        PurchTable localPurchTable;
        PurchLine localPurchLine;
        Num localCurrentInterCompanyInvoiceNum;
        MarkupTrans markupTrans;
        CustomsVendBOEJour_IN customsVendBOEJour;
        CustomsVendBOETrans_IN customsVendBOETrans;

        MarkupCopy_BillOfEntry_IN markupCopy = MarkupCopy_BillOfEntry_IN::construct();

        while select vendInvoiceInfoSubTable
            where vendInvoiceInfoSubTable.ParmId == _vendInvoiceInfoTable.ParmId
                && vendInvoiceInfoSubTable.TableRefId == _vendInvoiceInfoTable.TableRefId
            join localPurchTable
                where localPurchTable.PurchId == vendInvoiceInfoSubTable.OrigPurchId
            join customsVendBOEJour
                where customsVendBOEJour.PurchId == vendInvoiceInfoSubTable.OrigPurchId
            exists join customsVendBOETrans
                where customsVendBOETrans.CustomsBillOfEntryJournal_IN == customsVendBOEJour.RecId
                    && customsVendBOETrans.RemainingQty != 0
                    && customsVendBOETrans.Status != CustomsVendBOEStatus_IN::Canceled
            notExists join markupTrans
                where markupTrans.TransTableId == vendInvoiceInfoSubTable.TableId
                    && markupTrans.TransRecId == vendInvoiceInfoSubTable.RecId
                    && !markupTrans.IsDeleted
        {
            localCurrentInterCompanyInvoiceNum = this.interCompanyInvoiceNum(localPurchTable);

            MarkupCopyFromPurchOrderParameters copyFromPurchOrderToSubTableParameters =
                this.createMarkupCopyParametersForCopyMarkupSubTable(
                    customsVendBOEJour,
                    vendInvoiceInfoSubTable,
                    localCurrentInterCompanyInvoiceNum,
                    _vendInvoiceInfoTable.CurrencyCode,
                    SourceDocumentLineAccountingStatus::Draft,
                    localPurchTable);
            markupCopy.copyFromBOEJournal(copyFromPurchOrderToSubTableParameters);
        }

        VendInvoiceInfoLineTaxExtension_IN vendInvoideInfoLineTaxExtension;
        while select vendInvoiceInfoLine
            where vendInvoiceInfoLine.ParmId == _vendInvoiceInfoTable.ParmId
                && vendInvoiceInfoLine.TableRefId == _vendInvoiceInfoTable.TableRefId
            join localPurchTable
                where localPurchTable.PurchId == _vendInvoiceInfoTable.PurchId
            join RecId from vendInvoideInfoLineTaxExtension
                where vendInvoideInfoLineTaxExtension.vendInvoiceInfoLine == vendInvoiceInfoLine.RecId
            join customsVendBOETrans
                where customsVendBOETrans.TableId == vendInvoideInfoLineTaxExtension.SourceTableId
                    && customsVendBOETrans.RecId == vendInvoideInfoLineTaxExtension.SourceRecId
            notExists join markupTrans
                where markupTrans.TransTableId == vendInvoiceInfoLine.TableId
                    && markupTrans.TransRecId == vendInvoiceInfoLine.RecId
                    && !markupTrans.IsDeleted
        {
            localCurrentInterCompanyInvoiceNum = this.interCompanyInvoiceNum(localPurchTable);

            // keep the markupTrans at Draft so that its parent, ie, vendInvoiceInfoLine also stays in draft as vendInvoiceInfoLine taxes
            // do not yet exist and will be missed during distribution.
            MarkupCopyFromPurchOrderParameters copyFromPurchOrderToLineParameters =
                this.createMarkupCopyParametersForCopyMarkupInfoLine(
                    customsVendBOETrans,
                    vendInvoiceInfoLine,
                    localCurrentInterCompanyInvoiceNum,
                    '',
                    SourceDocumentLineAccountingStatus::Draft,
                    localPurchTable);
            markupCopy.copyFromBOEJournal(copyFromPurchOrderToLineParameters);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyMarkupFromPurchOrderCleanup</Name>
				<Source><![CDATA[
    private void copyMarkupFromPurchOrderCleanup(VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        MarkupTrans markupTransDestination, markupTransOtherInvoices;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        MarkupTransMapping markUpTransMapping;


        vendInvoiceInfoLine.clear();
        markupTransDestination.clear();
        markupTransOtherInvoices.clear();

        // Don't create a MarkupTrans if it is not marked Keep and it is already connected to another invoice
        markupTransDestination.skipDataMethods(true);

        markupTransDestination.skipDeleteActions(true);
        markupTransDestination.skipEvents(true);

        delete_from markupTransDestination
        where markupTransDestination.SourceDocumentLine == 0
            && !markupTransDestination.Keep
        exists join vendInvoiceInfoLine
            where vendInvoiceInfoLine.ParmId == _vendInvoiceInfoTable.ParmId
                && vendInvoiceInfoLine.TableRefId == _vendInvoiceInfoTable.TableRefId
                && markupTransDestination.TransTableId == vendInvoiceInfoLine.TableId
                && markupTransDestination.TransRecId == vendInvoiceInfoLine.RecId
        join markupTransOtherInvoices
            where markupTransOtherInvoices.OrigTableId == markupTransDestination.OrigTableId
                && markupTransOtherInvoices.OrigRecId == markupTransDestination.OrigRecId
                && markupTransOtherInvoices.TransTableId == markupTransDestination.TransTableId
                && markupTransOtherInvoices.TransRecId != markupTransDestination.TransRecId;

        //Perform cascading delete action for <c>MarkupTransMapping</c> table
        markupTransDestination.clear();
        markUpTransMapping.clear();

        markUpTransMapping.skipDataMethods(true);
        markUpTransMapping.skipDeleteActions(true);
        markUpTransMapping.skipEvents(true);

        delete_from markUpTransMapping
        notexists join markupTransDestination
            where markupTransDestination.TransRecId == markUpTransMapping.MarkupTransTransRecId &&
                markupTransDestination.TransTableId == markUpTransMapping.MarkupTransTransTableId &&
                markupTransDestination.LineNum == markUpTransMapping.MarkupTransLineNum;

        // Create a SourceDocumentLine record for each new charge
        // Set the actual SourceDocumentHeader; temporarily use ParentSourceDocumentLine to join to a unique MarkupTrans
        RecId sourceDocumentHeader = _vendInvoiceInfoTable.SourceDocumentHeader;
        SourceDocumentLine sourceDocumentLine;

        sourceDocumentLine.clear();
        vendInvoiceInfoLine.clear();
        markupTransDestination.clear();

        sourceDocumentLine.skipDataMethods(true);
        sourceDocumentLine.skipEvents(true);

        insert_recordset sourceDocumentLine (SourceDocumentHeader, ParentSourceDocumentLine)
        select sourceDocumentHeader from vendInvoiceInfoLine
            where vendInvoiceInfoLine.ParmId == _vendInvoiceInfoTable.ParmId
                && vendInvoiceInfoLine.TableRefId == _vendInvoiceInfoTable.TableRefId
        join RecId from markupTransDestination
            where markupTransDestination.TransTableId == vendInvoiceInfoLine.TableId
                && markupTransDestination.TransRecId == vendInvoiceInfoLine.RecId
                && markupTransDestination.SourceDocumentLine == 0;

        sourceDocumentLine.clear();
        vendInvoiceInfoLine.clear();
        markupTransDestination.clear();

        markupTransDestination.skipDataMethods(true);
        markupTransDestination.skipEvents(true);

        update_recordset markupTransDestination setting
            SourceDocumentLine = sourceDocumentLine.RecId
        where markupTransDestination.SourceDocumentLine == 0
        join vendInvoiceInfoLine
            where vendInvoiceInfoLine.ParmId == _vendInvoiceInfoTable.ParmId
                && vendInvoiceInfoLine.TableRefId == _vendInvoiceInfoTable.TableRefId
                && vendInvoiceInfoLine.TableId == markupTransDestination.TransTableId
                && vendInvoiceInfoLine.RecId == markupTransDestination.TransRecId
        join sourceDocumentLine
            where sourceDocumentLine.ParentSourceDocumentLine == markupTransDestination.RecId
                && sourceDocumentLine.SourceDocumentHeader == sourceDocumentHeader;

        // Update SourceDocumentLine with final values
        // Reset the ParentSourceDocumentLine value, now that we have set each charge SourceDocumentLine
        var stateContainer = [conNull(), conNull(), conNull()];

        sourceDocumentLine.clear();
        vendInvoiceInfoLine.clear();
        markupTransDestination.clear();

        sourceDocumentLine.skipDataMethods(true);
        sourceDocumentLine.skipEvents(true);

        update_recordset sourceDocumentLine setting
            SourceRelationType = tableNum(MarkupTrans),
            TypeEnumName = enumStr(SourceDocumentLine_VendorInvoice),
            TypeEnumValue = SourceDocumentLine_VendorInvoice::VendorInvoiceChargeLine,
            AccountingStatus = SourceDocumentLineAccountingStatus::Draft,
            ExchangeRateDate = _vendInvoiceInfoTable.updateDate(),
            StateContainer = stateContainer,
            ParentSourceDocumentLine = vendInvoiceInfoLine.SourceDocumentLine
        where sourceDocumentLine.TypeEnumName == ''
            && sourceDocumentLine.TypeEnumValue == 0
            && sourceDocumentLine.SourceDocumentHeader == sourceDocumentHeader
        join vendInvoiceInfoLine
            where vendInvoiceInfoLine.ParmId == _vendInvoiceInfoTable.ParmId
                && vendInvoiceInfoLine.TableRefId == _vendInvoiceInfoTable.TableRefId
        join markupTransDestination
            where markupTransDestination.TransTableId == vendInvoiceInfoLine.TableId
                && markupTransDestination.TransRecId == vendInvoiceInfoLine.RecId
                && markupTransDestination.RecId == sourceDocumentLine.ParentSourceDocumentLine;

        //dispose buffers
        vendInvoiceInfoLine.dispose();
        markupTransDestination.dispose();
        markupTransOtherInvoices.dispose();
        markUpTransMapping.dispose();
        sourceDocumentLine.dispose();
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyMarkupFromPurchOrderOptimizedCleanup</Name>
				<Source><![CDATA[
    private void copyMarkupFromPurchOrderOptimizedCleanup(VendInvoiceInfoTable _vendInvoiceInfoTable, MarkupTransTmp _markUpTransTmpCopy)
    {
        MarkupTrans markupTransOtherInvoices;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        MarkupTransMapping markUpTransMapping;
        
        // Find if there is a MarkupTrans that is not marked Keep and it is already connected to another invoice
        // we will only call delete if there exists one
        select firstonly RecId from _markUpTransTmpCopy
        join vendInvoiceInfoLine
            where vendInvoiceInfoLine.ParmId == _vendInvoiceInfoTable.ParmId
                && vendInvoiceInfoLine.TableRefId == _vendInvoiceInfoTable.TableRefId
                && _markUpTransTmpCopy.TransTableId == vendInvoiceInfoLine.TableId
                && _markUpTransTmpCopy.TransRecId == vendInvoiceInfoLine.RecId
                && _markUpTransTmpCopy.SourceDocumentLine == 0
                && !_markUpTransTmpCopy.Keep
        join markupTransOtherInvoices
            where markupTransOtherInvoices.OrigTableId == _markUpTransTmpCopy.OrigTableId
                && markupTransOtherInvoices.OrigRecId == _markUpTransTmpCopy.OrigRecId
                && markupTransOtherInvoices.TransTableId == _markUpTransTmpCopy.TransTableId
                && markupTransOtherInvoices.TransRecId != _markUpTransTmpCopy.TransRecId;

        if (_markUpTransTmpCopy.RecId != 0)
        {
            vendInvoiceInfoLine.clear();
            markupTransOtherInvoices.clear();

            delete_from _markUpTransTmpCopy
            exists join vendInvoiceInfoLine
                where vendInvoiceInfoLine.ParmId == _vendInvoiceInfoTable.ParmId
                    && vendInvoiceInfoLine.TableRefId == _vendInvoiceInfoTable.TableRefId
                    && _markUpTransTmpCopy.TransTableId == vendInvoiceInfoLine.TableId
                    && _markUpTransTmpCopy.TransRecId == vendInvoiceInfoLine.RecId
                    && _markUpTransTmpCopy.SourceDocumentLine == 0
                    && !_markUpTransTmpCopy.Keep
            join markupTransOtherInvoices
                where markupTransOtherInvoices.OrigTableId == _markUpTransTmpCopy.OrigTableId
                    && markupTransOtherInvoices.OrigRecId == _markUpTransTmpCopy.OrigRecId
                    && markupTransOtherInvoices.TransTableId == _markUpTransTmpCopy.TransTableId
                    && markupTransOtherInvoices.TransRecId != _markUpTransTmpCopy.TransRecId;
        
            //Perform cascading delete action for <c>MarkupTransMapping</c> table
            markUpTransMapping.clear();

            markUpTransMapping.skipDataMethods(true);
            markUpTransMapping.skipDeleteActions(true);
            markUpTransMapping.skipEvents(true);

            delete_from markUpTransMapping
            notexists join _markUpTransTmpCopy
                where _markUpTransTmpCopy.TransRecId == markUpTransMapping.MarkupTransTransRecId &&
                    _markUpTransTmpCopy.TransTableId == markUpTransMapping.MarkupTransTransTableId &&
                    _markUpTransTmpCopy.LineNum == markUpTransMapping.MarkupTransLineNum;
        }

        // Create a SourceDocumentLine record for each new charge
        RecId sourceDocumentHeader = _vendInvoiceInfoTable.SourceDocumentHeader;
        int SourceRelationType = tableNum(MarkupTrans);
        EnumName TypeEnumName = enumStr(SourceDocumentLine_VendorInvoice);
        EnumValue TypeEnumValue = SourceDocumentLine_VendorInvoice::VendorInvoiceChargeLine;
        SourceDocumentLineAccountingStatus AccountingStatus = SourceDocumentLineAccountingStatus::Draft;
        AccountingDate ExchangeRateDate = _vendInvoiceInfoTable.updateDate();

        vendInvoiceInfoLine.clear();
        
        SourceDocumentLine sourceDocumentLine;
        
        sourceDocumentLine.skipDataMethods(true);
        sourceDocumentLine.skipEvents(true);
        sourceDocumentLine.skipTempTableForInsertRecordSet(true);

        insert_recordset sourceDocumentLine
        (
            ParentSourceDocumentLine,
            SourceDocumentHeader,
            AccountingStatus,
            ExchangeRateDate,
            SourceRelationType,
            TypeEnumName,
            TypeEnumValue,
            SourceImplementationRecId
        )
        select
            SourceDocumentLine,
            sourceDocumentHeader,
            AccountingStatus,
            ExchangeRateDate,
            SourceRelationType,
            TypeEnumName,
            TypeEnumValue
        from vendInvoiceInfoLine
            where vendInvoiceInfoLine.ParmId == _vendInvoiceInfoTable.ParmId
                && vendInvoiceInfoLine.TableRefId == _vendInvoiceInfoTable.TableRefId
        join RecId from _markUpTransTmpCopy
            where _markUpTransTmpCopy.TransTableId == vendInvoiceInfoLine.TableId
                && _markUpTransTmpCopy.TransRecId == vendInvoiceInfoLine.RecId
                && _markUpTransTmpCopy.SourceDocumentLine == 0;

        sourceDocumentLine.skipTempTableForInsertRecordSet(false);

        vendInvoiceInfoLine.clear();
        sourceDocumentLine.clear();

        update_recordset _markUpTransTmpCopy setting
            SourceDocumentLine = sourceDocumentLine.RecId
            where _markUpTransTmpCopy.SourceDocumentLine == 0
        join vendInvoiceInfoLine
            where vendInvoiceInfoLine.ParmId == _vendInvoiceInfoTable.ParmId
                && vendInvoiceInfoLine.TableRefId == _vendInvoiceInfoTable.TableRefId
                && vendInvoiceInfoLine.TableId == _markUpTransTmpCopy.TransTableId
                && vendInvoiceInfoLine.RecId == _markUpTransTmpCopy.TransRecId
        join sourceDocumentLine
            where sourceDocumentLine.SourceDocumentHeader == sourceDocumentHeader &&
                sourceDocumentLine.ParentSourceDocumentLine == vendInvoiceInfoLine.SourceDocumentLine &&
                sourceDocumentLine.SourceImplementationRecId == _markUpTransTmpCopy.RecId;

        if (VendInvoiceMarkupTransCopyPerformanceEnableSysDaFlight::instance().isEnabled())
        {
            this.insertMarkupTransRecordFromMarkupTransTmp(_markUpTransTmpCopy);
        }
        else
        {
            //Add the final charges to the markup trans table
            MarkupTrans markupTransDestination;

            markupTransDestination.skipEvents(true);
            markupTransDestination.skipDataMethods(true);
            markupTransDestination.skipTempTableForInsertRecordSet(true);

            insert_recordset markupTransDestination
            (
                BankLCImportChargeAllocation_SA,
                CalculatedAmount,
                CalculatedAmountMST_W,
                CurrencyCode,
                CustomsAssessableValue_IN,
                CustVendPosted_RU,
                ExchRate_RU,
                ExchRateSecond_RU,
                FromAmount,
                IsAutoCharge,
                IsTieredCharge,
                ItemPosted_RU,
                Keep,
                LineNum,
                MarkupAllocateAfter_IN,
                MarkupCategory,
                MarkupClassification_BR,
                MarkupCode,
                MCRBrokerContractFee,
                MCRCouponMarkup,
                MCRInstallmentEligible,
                MCRMarkupTransCreatedBy,
                MCRMiscChargeOverride,
                MCROriginalMiscChargeValue,
                MCRReasonCode,
                MCRRetailInfoCodeId,
                MCRSavedRecId,
                MCRSavedTableId,
                ModuleCategory,
                ModuleType,
                NotionalCharges_IN,
                NotionalPct_IN,
                TaxAmount,
                TaxAmountExcise_RU,
                TaxAmountExciseMST_RU,
                TaxAmountMst_W,
                TaxAmountVAT_RU,
                TaxAmountVATMST_RU,
                TaxAutoGenerated,
                TaxGroup,
                TaxItemGroup,
                TaxValueVAT_RU,
                TaxVATType_RU,
                TaxWriteCode,
                ToAmount,
                Txt,
                Value,
                VATDocumentType_RU,
                SATProductCode_MX,
                SATUnitCode_MX,
                WithholdingTypeCode_MX,
                MarkupAutoTableRecId,
                RetailShippingPromotionDiscount,
                IsAdvancedLineProrated,
                IsOverriddenProratedLine,
                MarkupAutoLineRecId,
                IsOverriddenLine,
                PreviousValue,
                OverrideSalesTax,
                TransTableId,
                TransRecId,
                OrigTableId,
                OrigRecId,
                SpecificUnitSymbol,
                SourceDocumentLine
            )
            select
                BankLCImportChargeAllocation_SA,
                CalculatedAmount,
                CalculatedAmountMST_W,
                CurrencyCode,
                CustomsAssessableValue_IN,
                CustVendPosted_RU,
                ExchRate_RU,
                ExchRateSecond_RU,
                FromAmount,
                IsAutoCharge,
                IsTieredCharge,
                ItemPosted_RU,
                Keep,
                LineNum,
                MarkupAllocateAfter_IN,
                MarkupCategory,
                MarkupClassification_BR,
                MarkupCode,
                MCRBrokerContractFee,
                MCRCouponMarkup,
                MCRInstallmentEligible,
                MCRMarkupTransCreatedBy,
                MCRMiscChargeOverride,
                MCROriginalMiscChargeValue,
                MCRReasonCode,
                MCRRetailInfoCodeId,
                MCRSavedRecId,
                MCRSavedTableId,
                ModuleCategory,
                ModuleType,
                NotionalCharges_IN,
                NotionalPct_IN,
                TaxAmount,
                TaxAmountExcise_RU,
                TaxAmountExciseMST_RU,
                TaxAmountMst_W,
                TaxAmountVAT_RU,
                TaxAmountVATMST_RU,
                TaxAutoGenerated,
                TaxGroup,
                TaxItemGroup,
                TaxValueVAT_RU,
                TaxVATType_RU,
                TaxWriteCode,
                ToAmount,
                Txt,
                Value,
                VATDocumentType_RU,
                SATProductCode_MX,
                SATUnitCode_MX,
                WithholdingTypeCode_MX,
                MarkupAutoTableRecId,
                RetailShippingPromotionDiscount,
                IsAdvancedLineProrated,
                IsOverriddenProratedLine,
                MarkupAutoLineRecId,
                IsOverriddenLine,
                PreviousValue,
                OverrideSalesTax,
                TransTableId,
                TransRecId,
                OrigTableId,
                OrigRecId,
                SpecificUnitSymbol,
                SourceDocumentLine
            from _markUpTransTmpCopy;

            markupTransDestination.skipTempTableForInsertRecordSet(false);
        }

        //dispose buffers
        vendInvoiceInfoLine.dispose();
        _markUpTransTmpCopy.dispose();
        markupTransOtherInvoices.dispose();
        markUpTransMapping.dispose();
        sourceDocumentLine.dispose();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertMarkupTransRecordFromMarkupTransTmp</Name>
				<Source><![CDATA[
    protected void insertMarkupTransRecordFromMarkupTransTmp(MarkupTransTmp _markUpTransTmpCopy)
    {
        SysDaInsertObject insertObj = this.buildMarkupTransInsertObject();
        SysDaQueryObject  queryObj  = this.buildMarkupTransTmpQueryObject(_markUpTransTmpCopy);
            
        this.insertRecords(queryObj, insertObj);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildMarkupTransInsertObject</Name>
				<Source><![CDATA[
    private SysDaInsertObject buildMarkupTransInsertObject()
    {
        //insert_recordset markupTransDestination (
        //    BankLCImportChargeAllocation_SA, CalculatedAmount, CalculatedAmountMST_W, CurrencyCode, etc.)

        MarkupTrans markupTransDestination;

        markupTransDestination.skipEvents(true);
        markupTransDestination.skipDataMethods(true);
        markupTransDestination.skipTempTableForInsertRecordSet(true);

        SysDaInsertObject markupTransInsertObject = new SysDaInsertObject(markupTransDestination);

        this.addMarkupTransFields(markupTransInsertObject.fields());

        return markupTransInsertObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildMarkupTransTmpQueryObject</Name>
				<Source><![CDATA[
    private SysDaQueryObject buildMarkupTransTmpQueryObject(MarkupTransTmp _markupTransTmpSource)
    {
        //select BankLCImportChargeAllocation_SA, CalculatedAmount, CalculatedAmountMST_W, CurrencyCode, etc. from markupTransTmpSource

        SysDaQueryObject markupTransTmpQueryObject = new SysDaQueryObject(_markupTransTmpSource);
        this.addMarkupTransFields(markupTransTmpQueryObject.projection());
        
        return markupTransTmpQueryObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMarkupTransFields</Name>
				<Source><![CDATA[
    protected void addMarkupTransFields(SysDaSelection _selectionObject)
    {
        _selectionObject
            .add(fieldStr(MarkupTrans, BankLCImportChargeAllocation_SA))
            .add(fieldStr(MarkupTrans, CalculatedAmount))
            .add(fieldStr(MarkupTrans, CalculatedAmountMST_W))
            .add(fieldStr(MarkupTrans, CurrencyCode))
            .add(fieldStr(MarkupTrans, CustomsAssessableValue_IN))
            .add(fieldStr(MarkupTrans, CustVendPosted_RU))
            .add(fieldStr(MarkupTrans, ExchRate_RU))
            .add(fieldStr(MarkupTrans, ExchRateSecond_RU))
            .add(fieldStr(MarkupTrans, FromAmount))
            .add(fieldStr(MarkupTrans, IsAutoCharge))
            .add(fieldStr(MarkupTrans, IsTieredCharge))
            .add(fieldStr(MarkupTrans, ItemPosted_RU))
            .add(fieldStr(MarkupTrans, Keep))
            .add(fieldStr(MarkupTrans, LineNum))
            .add(fieldStr(MarkupTrans, MarkupAllocateAfter_IN))
            .add(fieldStr(MarkupTrans, MarkupCategory))
            .add(fieldStr(MarkupTrans, MarkupClassification_BR))
            .add(fieldStr(MarkupTrans, MarkupCode))
            .add(fieldStr(MarkupTrans, MCRBrokerContractFee))
            .add(fieldStr(MarkupTrans, MCRCouponMarkup))
            .add(fieldStr(MarkupTrans, MCRInstallmentEligible))
            .add(fieldStr(MarkupTrans, MCRMarkupTransCreatedBy))
            .add(fieldStr(MarkupTrans, MCRMiscChargeOverride))
            .add(fieldStr(MarkupTrans, MCROriginalMiscChargeValue))
            .add(fieldStr(MarkupTrans, MCRReasonCode))
            .add(fieldStr(MarkupTrans, MCRRetailInfoCodeId))
            .add(fieldStr(MarkupTrans, MCRSavedRecId))
            .add(fieldStr(MarkupTrans, MCRSavedTableId))
            .add(fieldStr(MarkupTrans, ModuleCategory))
            .add(fieldStr(MarkupTrans, ModuleType))
            .add(fieldStr(MarkupTrans, NotionalCharges_IN))
            .add(fieldStr(MarkupTrans, NotionalPct_IN))
            .add(fieldStr(MarkupTrans, TaxAmount))
            .add(fieldStr(MarkupTrans, TaxAmountExcise_RU))
            .add(fieldStr(MarkupTrans, TaxAmountExciseMST_RU))
            .add(fieldStr(MarkupTrans, TaxAmountMst_W))
            .add(fieldStr(MarkupTrans, TaxAmountVAT_RU))
            .add(fieldStr(MarkupTrans, TaxAmountVATMST_RU))
            .add(fieldStr(MarkupTrans, TaxAutoGenerated))
            .add(fieldStr(MarkupTrans, TaxGroup))
            .add(fieldStr(MarkupTrans, TaxItemGroup))
            .add(fieldStr(MarkupTrans, TaxValueVAT_RU))
            .add(fieldStr(MarkupTrans, TaxVATType_RU))
            .add(fieldStr(MarkupTrans, TaxWriteCode))
            .add(fieldStr(MarkupTrans, ToAmount))
            .add(fieldStr(MarkupTrans, Txt))
            .add(fieldStr(MarkupTrans, Value))
            .add(fieldStr(MarkupTrans, VATDocumentType_RU))
            .add(fieldStr(MarkupTrans, SATProductCode_MX))
            .add(fieldStr(MarkupTrans, SATUnitCode_MX))
            .add(fieldStr(MarkupTrans, WithholdingTypeCode_MX))
            .add(fieldStr(MarkupTrans, MarkupAutoTableRecId))
            .add(fieldStr(MarkupTrans, RetailShippingPromotionDiscount))
            .add(fieldStr(MarkupTrans, IsAdvancedLineProrated))
            .add(fieldStr(MarkupTrans, IsOverriddenProratedLine))
            .add(fieldStr(MarkupTrans, MarkupAutoLineRecId))
            .add(fieldStr(MarkupTrans, IsOverriddenLine))
            .add(fieldStr(MarkupTrans, PreviousValue))
            .add(fieldStr(MarkupTrans, OverrideSalesTax))
            .add(fieldStr(MarkupTrans, TransTableId))
            .add(fieldStr(MarkupTrans, TransRecId))
            .add(fieldStr(MarkupTrans, OrigTableId))
            .add(fieldStr(MarkupTrans, OrigRecId))
            .add(fieldStr(MarkupTrans, SpecificUnitSymbol))
            .add(fieldStr(MarkupTrans, SourceDocumentLine));
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRecords</Name>
				<Source><![CDATA[
    private void insertRecords(SysDaQueryObject _queryObject, SysDaInsertObject _insertObject)
    {
        _insertObject.query(_queryObject);
        SysDaInsertStatement insertStatement = new SysDaInsertStatement();

        insertStatement.executeQuery(_insertObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMarkupCopyParametersForChooseLinesSubtable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes the parameter class for copy of markup transactions.
    /// </summary>
    /// <param name="_fromTable">
    /// The source table record.
    /// </param>
    /// <param name="_toTable">
    /// The destination table record.
    /// </param>
    /// <param name="_interCompanyInvoiceNum">
    /// The invoice number used by an intercompany invoice.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code to use during conversion to the destination table record.
    /// </param>
    /// <param name="_targetAccountingStatus">
    /// The desired source document line accounting status.
    /// </param>
    /// <param name="_purchTable">
    /// The purch order used to resolve the _interCompanyInvoiceNum (last invoice) if it wasn't provided in the method call.
    /// </param>
    /// <param name="_interCompanyInvoiceNumPassed">
    /// A boolean which indicates if defaulting of _interCompanyInvoiceNum should be skipped.
    /// </param>
    /// <returns>
    /// An initialized <c>MarkupCopyFromPurchOrderParameters</c> class.
    /// </returns>
    /// <remarks>
    /// If no currency code is provided, the currency code of the destination table record will be used for conversion.
    /// </remarks>
    protected MarkupCopyFromPurchOrderParameters createMarkupCopyParametersForChooseLinesSubtable(
        Common                             _fromTable,
        Common                             _toTable,
        Num                                _interCompanyInvoiceNum,
        CurrencyCode                       _currencyCode,
        SourceDocumentLineAccountingStatus _targetAccountingStatus,
        PurchTable                         _purchTable,
        boolean                            _interCompanyInvoiceNumPassed)
    {
        return MarkupCopyFromPurchOrderParameters::createCopyFromPurchOrderParameters(
            _fromTable,
            _toTable,
            _interCompanyInvoiceNum,
            _currencyCode,
            _targetAccountingStatus,
            _purchTable,
            _interCompanyInvoiceNumPassed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMarkupCopyParametersForChooseLinesInfoLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes the parameter class for copy of markup transactions.
    /// </summary>
    /// <param name="_fromTable">
    /// The source table record.
    /// </param>
    /// <param name="_toTable">
    /// The destination table record.
    /// </param>
    /// <param name="_interCompanyInvoiceNum">
    /// The invoice number used by an intercompany invoice.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code to use during conversion to the destination table record.
    /// </param>
    /// <param name="_targetAccountingStatus">
    /// The desired source document line accounting status.
    /// </param>
    /// <param name="_purchTable">
    /// The purch order used to resolve the _interCompanyInvoiceNum (last invoice) if it wasn't provided in the method call.
    /// </param>
    /// <param name="_interCompanyInvoiceNumPassed">
    /// A boolean which indicates if defaulting of _interCompanyInvoiceNum should be skipped.
    /// </param>
    /// <returns>
    /// An initialized <c>MarkupCopyFromPurchOrderParameters</c> class.
    /// </returns>
    /// <remarks>
    /// If no currency code is provided, the currency code of the destination table record will be used for conversion.
    /// </remarks>
    protected MarkupCopyFromPurchOrderParameters createMarkupCopyParametersForChooseLinesInfoLine(
        Common                             _fromTable,
        Common                             _toTable,
        Num                                _interCompanyInvoiceNum,
        CurrencyCode                       _currencyCode,
        SourceDocumentLineAccountingStatus _targetAccountingStatus,
        PurchTable                         _purchTable,
        boolean                            _interCompanyInvoiceNumPassed)
    {
        return MarkupCopyFromPurchOrderParameters::createCopyFromPurchOrderParameters(
            _fromTable,
            _toTable,
            _interCompanyInvoiceNum,
            _currencyCode,
            _targetAccountingStatus,
            _purchTable,
            _interCompanyInvoiceNumPassed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMarkupCopyParametersForCopyMarkupSubTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes the parameter class for copy of markup transactions.
    /// </summary>
    /// <param name="_fromTable">
    /// The source table record.
    /// </param>
    /// <param name="_toTable">
    /// The destination table record.
    /// </param>
    /// <param name="_interCompanyInvoiceNum">
    /// The invoice number used by an intercompany invoice.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code to use during conversion to the destination table record.
    /// </param>
    /// <param name="_targetAccountingStatus">
    /// The desired source document line accounting status.
    /// </param>
    /// <param name="_purchTable">
    /// The purch order used to resolve the _interCompanyInvoiceNum (last invoice) if it wasn't provided in the method call.
    /// </param>
    /// <param name="_interCompanyInvoiceNumPassed">
    /// A boolean which indicates if defaulting of _interCompanyInvoiceNum should be skipped.
    /// </param>
    /// <returns>
    /// An initialized <c>MarkupCopyFromPurchOrderParameters</c> class.
    /// </returns>
    /// <remarks>
    /// If no currency code is provided, the currency code of the destination table record will be used for conversion.
    /// </remarks>
    protected MarkupCopyFromPurchOrderParameters createMarkupCopyParametersForCopyMarkupSubTable(
        Common                             _fromTable,
        Common                             _toTable,
        Num                                _interCompanyInvoiceNum,
        CurrencyCode                       _currencyCode,
        SourceDocumentLineAccountingStatus _targetAccountingStatus,
        PurchTable                         _purchTable,
        boolean                            _interCompanyInvoiceNumPassed = true)
    {
        return MarkupCopyFromPurchOrderParameters::createCopyFromPurchOrderParameters(
            _fromTable,
            _toTable,
            _interCompanyInvoiceNum,
            _currencyCode,
            _targetAccountingStatus,
            _purchTable,
            _interCompanyInvoiceNumPassed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMarkupCopyParametersForCopyMarkupInfoLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes the parameter class for copy of markup transactions.
    /// </summary>
    /// <param name="_fromTable">
    /// The source table record.
    /// </param>
    /// <param name="_toTable">
    /// The destination table record.
    /// </param>
    /// <param name="_interCompanyInvoiceNum">
    /// The invoice number used by an intercompany invoice.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code to use during conversion to the destination table record.
    /// </param>
    /// <param name="_targetAccountingStatus">
    /// The desired source document line accounting status.
    /// </param>
    /// <param name="_purchTable">
    /// The purch order used to resolve the _interCompanyInvoiceNum (last invoice) if it wasn't provided in the method call.
    /// </param>
    /// <param name="_interCompanyInvoiceNumPassed">
    /// A boolean which indicates if defaulting of _interCompanyInvoiceNum should be skipped.
    /// </param>
    /// <returns>
    /// An initialized <c>MarkupCopyFromPurchOrderParameters</c> class.
    /// </returns>
    /// <remarks>
    /// If no currency code is provided, the currency code of the destination table record will be used for conversion.
    /// </remarks>
    protected MarkupCopyFromPurchOrderParameters createMarkupCopyParametersForCopyMarkupInfoLine(
        Common                             _fromTable,
        Common                             _toTable,
        Num                                _interCompanyInvoiceNum,
        CurrencyCode                       _currencyCode,
        SourceDocumentLineAccountingStatus _targetAccountingStatus,
        PurchTable                         _purchTable,
        boolean                            _interCompanyInvoiceNumPassed = true)
    {
        return MarkupCopyFromPurchOrderParameters::createCopyFromPurchOrderParameters(
            _fromTable,
            _toTable,
            _interCompanyInvoiceNum,
            _currencyCode,
            _targetAccountingStatus,
            _purchTable,
            _interCompanyInvoiceNumPassed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMarkupCopyParametersForReSelectEndInfoLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes the parameter class for copy of markup transactions.
    /// </summary>
    /// <param name="_fromTable">
    /// The source table record.
    /// </param>
    /// <param name="_toTable">
    /// The destination table record.
    /// </param>
    /// <param name="_interCompanyInvoiceNum">
    /// The invoice number used by an intercompany invoice.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code to use during conversion to the destination table record.
    /// </param>
    /// <param name="_targetAccountingStatus">
    /// The desired source document line accounting status.
    /// </param>
    /// <param name="_purchTable">
    /// The purch order used to resolve the _interCompanyInvoiceNum (last invoice) if it wasn't provided in the method call.
    /// </param>
    /// <param name="_interCompanyInvoiceNumPassed">
    /// A boolean which indicates if defaulting of _interCompanyInvoiceNum should be skipped.
    /// </param>
    /// <returns>
    /// An initialized <c>MarkupCopyFromPurchOrderParameters</c> class.
    /// </returns>
    /// <remarks>
    /// If no currency code is provided, the currency code of the destination table record will be used for conversion.
    /// </remarks>
    protected MarkupCopyFromPurchOrderParameters createMarkupCopyParametersForReSelectEndInfoLine(
        Common                             _fromTable,
        Common                             _toTable,
        Num                                _interCompanyInvoiceNum,
        CurrencyCode                       _currencyCode,
        SourceDocumentLineAccountingStatus _targetAccountingStatus,
        PurchTable                         _purchTable,
        boolean                            _interCompanyInvoiceNumPassed)
    {
        return MarkupCopyFromPurchOrderParameters::createCopyFromPurchOrderParameters(
            _fromTable,
            _toTable,
            _interCompanyInvoiceNum,
            _currencyCode,
            _targetAccountingStatus,
            _purchTable,
            _interCompanyInvoiceNumPassed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWhereClauseForMarkupTransDestination</Name>
				<Source><![CDATA[
    private SysDaBinaryExpression buildWhereClauseForMarkupTransDestination(VendInvoiceInfoTable _vendInvoiceInfoTable, VendInvoiceInfoLine _vendInvoiceInfoLine)
    {
        // where vendInvoiceInfoLine.ParmId == _vendInvoiceInfoTable.ParmId
        //        && vendInvoiceInfoLine.TableRefId == _vendInvoiceInfoTable.TableRefId

        return new SysDaEqualsExpression(
                new SysDaFieldExpression(_vendInvoiceInfoLine, fieldStr(VendInvoiceInfoLine, ParmId)), new SysDaValueExpression(_vendInvoiceInfoTable.ParmId))
            .and(new SysDaEqualsExpression(
                new SysDaFieldExpression(_vendInvoiceInfoLine, fieldStr(VendInvoiceInfoLine, TableRefId)), new SysDaValueExpression(_vendInvoiceInfoTable.TableRefId)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWhereClauseForMarkupTransSource</Name>
				<Source><![CDATA[
    private SysDaBinaryExpression buildWhereClauseForMarkupTransSource(PurchLine _purchLine, VendInvoiceInfoLine _vendInvoiceInfoLine)
    {
        // where localPurchLine.RecId == vendInvoiceInfoLine.PurchLineRecId

        return new SysDaEqualsExpression(
                new SysDaFieldExpression(_purchLine, fieldStr(PurchLine, RecId)), new SysDaFieldExpression(_vendInvoiceInfoLine, fieldStr(VendInvoiceInfoLine, PurchLineRecId)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAdvance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates a record in the <c>VendInvoiceInfoTable</c> table as an advance header.
    /// </summary>
    /// <param name="_purchTable">
    /// A record in the <c>PurchTable</c> table that is used to initialize a record in the
    /// <c>VendInvoiceInfoTable</c> table.
    /// </param>
    /// <returns>
    /// true if the record in the <c>VendInvoiceInfoTable</c> table was created; otherwise, false.
    /// </returns>
    protected boolean createAdvance(PurchTable _purchTable)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        boolean createdAdvance;

        if (_purchTable.RecId != 0)
        {
            if (purchParmUpdate.SpecQty != PurchUpdate::All)
            {
                if (! purchParmUpdate.selectForUpdate())
                {
                    purchParmUpdate = PurchParmUpdate::find(purchParmUpdate.ParmId, true);
                }

                purchParmUpdate.SpecQty = PurchUpdate::All;
                purchParmUpdate.update();
            }

            vendInvoiceInfoTable = VendInvoiceInfoTable::find(externalDefaultedParmTable.ParmId, externalDefaultedParmTable.TableRefId, true);

            if (vendInvoiceInfoTable.RecId)
            {
                if (! vendInvoiceInfoTable.isAdvance())
                {
                    vendInvoiceInfoTable.InvoiceType = PurchInvoiceType::VendorAdvance;
                    vendInvoiceInfoTable.LastMatchVariance = LastMatchVarianceOptions::OK;
                }

                this.updateParmTable(vendInvoiceInfoTable, _purchTable);
                vendInvoiceInfoTable.fieldState(fieldNum(VendInvoiceInfoTable, FixedDueDate), FieldState::NotSet);
                vendInvoiceInfoTable.defaultRow();
                vendInvoiceInfoTable.update();
                createdAdvance = true;
            }
            else
            {
                this.updateParmTable(vendInvoiceInfoTable, _purchTable);
                vendInvoiceInfoTable.InvoiceType = PurchInvoiceType::VendorAdvance;
                vendInvoiceInfoTable.LastMatchVariance = LastMatchVarianceOptions::OK;
                vendInvoiceInfoTable.ParmId = this.parmId();
                vendInvoiceInfoTable.Num = this.parmParmTableNum();
                vendInvoiceInfoTable.fieldState(fieldNum(VendInvoiceInfoTable, FixedDueDate), FieldState::NotSet);
                vendInvoiceInfoTable.defaultRow();
                vendInvoiceInfoTable.TableRefId = this.getTableRefId(null, false);
                vendInvoiceInfoTable.ParmJobStatus = ParmJobStatus::Waiting;
                vendInvoiceInfoTable.insert();
                this.tableRefIdUsed(true);
                createdAdvance = true;
            }

            externalDefaultedParmTable = vendInvoiceInfoTable;
        }

        return createdAdvance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAdvanceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a record in the <c>VendInvoiceInfoLine</c> table as an advance line.
    /// </summary>
    /// <param name="_purchTable">
    /// A record in the <c>PurchTable</c> table that is used to initialize a record in the
    /// <c>VendInvoiceInfoLine</c> table.
    /// </param>
    /// <returns>
    /// true if the record in the <c>VendInvoiceInfoLine</c> table was created; otherwise, false.
    /// </returns>
    protected boolean createAdvanceLine(PurchTable _purchTable)
    {
        VendInvoiceInfoLine vendInvoiceInfoLine;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        PurchPrepayTable purchPrepayTable;
        boolean createdLine;
        VendInvoiceInfoLineTaxExtension_IN vendInvoiceInfoLineTaxExtension_IN;
        // <GIN>
        VendInvoiceInfoLine_W   vendInvoiceInfoLine_W;
        // </GIN>

        //this method expects prepayment invoice amount to be set before calling
        Debug::assert(prepayInvoiceAmount != 0);

        purchPrepayTable = PurchPrepayTable::findPurchId(_purchTable.PurchId);

        vendInvoiceInfoTable = externalDefaultedParmTable;

        if ((vendInvoiceInfoTable.RecId != 0) && (purchPrepayTable.RecId !=0))
        {
            vendInvoiceInfoLine.clear();

            vendInvoiceInfoLine = this.initVendInvoiceLineAdvance(vendInvoiceInfoLine, vendInvoiceInfoTable);

            vendInvoiceInfoLine.insert();
            createdLine = true;

            if (_purchTable.ProjId)
            {
                VendInvoiceInfoLine_project::createFromVendInvoiceInfoLine(vendInvoiceInfoLine, _purchTable.PurchId, purchPrepayTable.PrepayCategoryId);
                if (!vendInvoiceInfoLine.InventTransId)
                {
                    ttsbegin;
                    vendInvoiceInfoLine.selectForUpdate(true);
                    NumberSeq numberSeq = NumberSeq::newGetNum(InventParameters::numRefInventTransId());
                    vendInvoiceInfoLine.InventTransId = numberSeq.num();
                    vendInvoiceInfoLine.update();
                    ttscommit;
                }
            }

            if (!VendInvoiceInfoSubTable::exist(this.parmId(), vendInvoiceInfoLine.TableRefId, vendInvoiceInfoLine.OrigPurchId))
            {
                VendInvoiceInfoSubTable::createFromVendInvoiceInfoLine(vendInvoiceInfoLine, this.parmId(), vendInvoiceInfoTable.PurchName, true);
            }
            // <GIN>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]) && vendInvoiceInfoLine)
            {
                vendInvoiceInfoLineTaxExtension_IN.VendInvoiceInfoLine = vendInvoiceInfoLine.RecId;
                vendInvoiceInfoLineTaxExtension_IN.insert();

                ttsbegin;
                vendInvoiceInfoLine_W = vendInvoiceInfoLine.vendInvoiceInfoLine_W();
                vendInvoiceInfoLine_W.selectForUpdate(true);
                vendInvoiceInfoLine_W.VendInvoiceInfoLine = vendInvoiceInfoLine.RecId;
                vendInvoiceInfoLine_W.AssessableValue_IN = prepayInvoiceAmount;
                vendInvoiceInfoLine_W.write();
                ttscommit;
            }
            // </GIN>
        }

        return createdLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVendInvoiceLineAdvance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>VendInvoiceInfoLine</c> table.
    /// </summary>
    /// <param name = "_vendInvoiceInfoLine">
    /// The <c>VendInvoiceInfoLine</c> table buffer.
    /// </param>
    /// <param name = "_vendInvoiceInfoTable">
    /// The <c>VendInvoiceInfoTable</c> table buffer.
    /// </param>
    /// <returns>
    /// The initialized <c>VendInvoiceInfoLine</c> table buffer.
    /// </returns>
    protected VendInvoiceInfoLine initVendInvoiceLineAdvance(VendInvoiceInfoLine _vendInvoiceInfoLine, VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        _vendInvoiceInfoLine.ParmId = this.parmId();

        _vendInvoiceInfoLine.TableRefId = _vendInvoiceInfoTable.TableRefId;

        _vendInvoiceInfoLine.Ordering = this.parmDocumentStatus();
        _vendInvoiceInfoLine.LineType = PurchInvoiceLineType::Advance;
        _vendInvoiceInfoLine.defaultRow(null, null, 1.0);

        //vendor advance invoice line net amount will be vendor advance available for invoicing
        _vendInvoiceInfoLine.LineAmount = prepayInvoiceAmount;
        _vendInvoiceInfoLine.PurchPrice = prepayInvoiceAmount;

        return _vendInvoiceInfoLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createData</Name>
				<Source><![CDATA[
    public void createData(boolean _append = false)
    {
        super(_append);

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.updateParmAfterChooseLines();
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromHistoryParmLine_Asset</Name>
				<Source><![CDATA[
    protected void createFromHistoryParmLine_Asset(RefRecId _parmLineRecId, RefRecId _newParmLineRecId)
    {
        VendInvoiceInfoLine_Asset parmLine_Asset;
        VendInvoiceInfoLine_Asset parmLine_AssetNew;

        parmLine_Asset = VendInvoiceInfoLine_Asset::findByVendInvoiceInfoLineRecId(_parmLineRecId);
        if (parmLine_Asset.RecId)
        {
            parmLine_AssetNew = parmLine_Asset.data();
            parmLine_AssetNew.VendInvoiceInfoLineRecId = _newParmLineRecId;
            this.insertParmLine_Asset(parmLine_AssetNew);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromHistoryParmLines</Name>
				<Source><![CDATA[
    protected void createFromHistoryParmLines(Common _vendInvoiceInfoTable)
    {
        //don't call super as VendInvoiceInfoLine records are handled in this method.
        VendDocumentTableMap vendInvoiceInfoTable = _vendInvoiceInfoTable;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        VendInvoiceInfoLine vendInvoiceInfoLineNew;
        VendInvoiceInfoSubLine vendInvoiceInfoSubLine;
        VendInvoiceInfoSubLine vendInvoiceInfoSubLineNew;
        RecId prevRecId;

        Debug::assert(_vendInvoiceInfoTable.TableId == tableNum(VendInvoiceInfoTable));

        while select vendInvoiceInfoLine
            where vendInvoiceInfoLine.ParmId == vendInvoiceInfoTable.ParmId &&
                  vendInvoiceInfoLine.TableRefId == vendInvoiceInfoTable.TableRefId
                  outer join vendInvoiceInfoSubLine
                    where vendInvoiceInfoSubLine.LineRefRecId == vendInvoiceInfoLine.RecId
        {
            if (prevRecId != vendInvoiceInfoLine.RecId)
            {
                prevRecId = vendInvoiceInfoLine.RecId;
                vendInvoiceInfoLineNew = vendInvoiceInfoLine.data();
                vendInvoiceInfoLineNew.ParmId = this.parmId();
                this.insertParmLine(vendInvoiceInfoLineNew);
                this.createFromHistoryParmLine_Asset(vendInvoiceInfoLine.RecId, vendInvoiceInfoLineNew.RecId);
            }
            if (vendInvoiceInfoSubLine.RecId)
            {
                vendInvoiceInfoSubLineNew = vendInvoiceInfoSubLine.data();
                vendInvoiceInfoSubLineNew.initFromLine(vendInvoiceInfoLineNew);
                vendInvoiceInfoSubLineNew.ParmId = this.parmId();
                this.insertParmSubLine(vendInvoiceInfoSubLineNew);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInfoSubLineForBOE_IN</Name>
				<Source><![CDATA[
    private void createInfoSubLineForBOE_IN(PurchLine _purchLine,
                                            container _packedParmLinesMap,
                                            Set _packedSubLineSet,
                                            PurchQty _openEndedMatchedPurchQty = 0,
                                            InventQty _openEndedMatchedInventQty = 0)
    {
        MapEnumerator me;
        SetEnumerator se;
        PurchLine purchLineCopy = _purchLine;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        VendInvoiceInfoSubLine vendInvoiceInfoSubLine;
        CustomsVendBOETrans_IN customsVendBOETransCopy;
        VendPackingSlipTrans vendPackingSlipTrans;
        CustomsVendPackingSlipBOETransLink_IN customsVendPackingSlipBOETransLink;

        me = Map::create(_packedParmLinesMap).getEnumerator();

        while (me.moveNext())
        {
            vendInvoiceInfoLine = me.currentValue();

            if (vendInvoiceInfoLine.PurchLineRecId == purchLineCopy.RecId && vendInvoiceInfoLine.InventTransId && purchLineCopy.InventTransId)
            {
                se = _packedSubLineSet.getEnumerator();
                while (se.moveNext())
                {
                    if (isFromBillOfEntry)
                    {
                        customsVendBOETransCopy = se.current();
                        if (parmLineBOEMap.exists(this.parmLineBOEMapKey_IN(vendInvoiceInfoLine, customsVendBOETransCopy.RecId)))
                        {
                            vendInvoiceInfoSubLine.clear();
                            vendInvoiceInfoSubLine.initFromLine(vendInvoiceInfoLine);
                            vendInvoiceInfoSubLine.initFromCustomsBillOfEntryTrans_IN(customsVendBOETransCopy);
                            vendInvoiceInfoSubLine.ReceiveNow = vendInvoiceInfoSubLine.ReceiveNow - _openEndedMatchedPurchQty;
                            vendInvoiceInfoSubLine.InventNow = vendInvoiceInfoSubLine.InventNow - _openEndedMatchedInventQty;
                            this.insertParmSubLine(vendInvoiceInfoSubLine);
                        }
                    }
                    else if (isFromPackingSlip)
                    {
                        vendPackingSlipTrans = se.current();
                        customsVendPackingSlipBOETransLink = CustomsVendPackingSlipBOETransLink_IN::findByVendPackingSlipTrans(vendPackingSlipTrans.RecId);
                        if (parmLineBOEMap.exists(this.parmLineBOEMapKey_IN(vendInvoiceInfoLine, customsVendPackingSlipBOETransLink.CustomsVendBOETrans_IN)))
                        {
                            vendInvoiceInfoSubLine.clear();
                            vendInvoiceInfoSubLine.initFromLine(vendInvoiceInfoLine);
                            vendInvoiceInfoSubLine.initFromVendPackingSlipTrans(vendPackingSlipTrans);
                            vendInvoiceInfoSubLine.ReceiveNow = vendInvoiceInfoSubLine.ReceiveNow - _openEndedMatchedPurchQty;
                            vendInvoiceInfoSubLine.InventNow = vendInvoiceInfoSubLine.InventNow - _openEndedMatchedInventQty;
                            this.insertParmSubLine(vendInvoiceInfoSubLine);
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInvoiceHeaderFromTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copy the records that have been added to the vendor invoice temp table into the physical table
    /// </summary>
    /// <remarks>
    /// Every field in <c>VendInvoiceInfoTable</c> that is defaulted when generating an invoice from a purchase order should be
    /// added to the VendInvoiceInfoTableTmp table and included in this method.
    /// </remarks>
    protected void createInvoiceHeaderFromTempTable()
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        SysRecIdSequence sysRecIdSequence = appl.sysRecIdSequence();
    
        if (sysRecIdSequence.isRecidSuspended(tableNum(VendInvoiceInfoTable)))
        {
            sysRecIdSequence.removeRecIdSuspension(tableNum(VendInvoiceInfoTable));
        }

        Query query = new Query();
        QueryBuildDataSource qbdsVendInvoiceInfoTableTmp = query.addDataSource(tableNum(VendInvoiceInfoTableTmp));
        qbdsVendInvoiceInfoTableTmp.cursor(vendInvoiceInfoTableTmp);

        this.buildCreateInvoiceHeaderFromTempTableFieldQuery(qbdsVendInvoiceInfoTableTmp);

        Map targetToSourceMap = this.buildCreateInvoiceHeaderFromTempTableFieldMap(qbdsVendInvoiceInfoTableTmp);

        vendInvoiceInfoTable.skipEvents(true);
        vendInvoiceInfoTable.skipDataMethods(true);
        vendInvoiceInfoTable.skipDatabaseLog(true);
        Query::insert_recordset(vendInvoiceInfoTable, targetToSourceMap, query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCreateInvoiceHeaderFromTempTableFieldQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the fields from <c>VendInvoiceInfoTableTmp</c> and adds into the query.
    /// </summary>
    /// <param name = "_qbdsVendInvoiceInfoTableTmp">
    ///     An instance of <c>QueryBuildDataSource</c> class.
    /// </param>
    protected void buildCreateInvoiceHeaderFromTempTableFieldQuery(QueryBuildDataSource _qbdsVendInvoiceInfoTableTmp)
    {
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, AddressRefRecId));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, AddressRefTableId));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, Approved));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, Approver));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, AutomationStatus));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, BatchAdministration));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, CashDisc));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, CashDiscdate));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, CreditCorrection));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, CurrencyCode));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, DeliveryName));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, DeliveryPostalAddress));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, Description));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, DocumentDate));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, DocumentNum));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, DocumentOrigin));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, EUROTriangulation));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, ExchRate));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, ExchRateSecondary));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, FixedDueDate));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, FixedExchRate));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, Hold));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, ImportedAmount));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, ImportedSalesTax));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, IncludeInAutomatedProcessing));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, InvoiceAccount));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, LastMatchVariance));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, ListCode));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, LogisticsElectronicAddress));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, Num));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, OrderAccount));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, Ordering));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, PackedExtensions));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, ParmId));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, ParmJobStatus));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, PaymId));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, PaymMode));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, PaymSpec));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, PoolRecId));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, PurchAgreementHeader_PSN));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, PurchId));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, PurchName));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, Recalculate));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, ReceivedDate));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, RemittanceLocation));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, ReportingCurrencyExchangeRate));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, SourceDocumentHeader));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, SourceDocumentLine));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, TableRefId));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, TransDate));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, TransportationDocument));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, VendBankAccountId));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, VendInvoiceGroup));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, VendInvoiceSaveStatus));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, VendorRequestedWorkerEmail));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, Log));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, InvoiceReleaseDate));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, ReleaseDateComment));
        if (VendInvoiceFetchVATNumFromPOV2Flight::instance().isEnabled())
        {
            _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, VATNum));
            _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, VATNumRecId));
            _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, VATNumTableType));
        }
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, VendorChargedSalesTax));
        _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, AccrueSalesTaxType));
        if (isFinTagConfigurationSetForCurrent && PurchaseOrderFinTagFeature::isEnabled())
        {
            _qbdsVendInvoiceInfoTableTmp.addSelectionField(fieldNum(VendInvoiceInfoTableTmp, FinTag));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCreateInvoiceHeaderFromTempTableFieldMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Maps the fields to insert into the <c>VendInvoiceInfoTable</c> table.
    /// </summary>
    /// <param name = "_qbdsVendInvoiceInfoTableTmp">
    ///     An instance of <c>QueryBuildDataSource</c> class.
    /// </param>
    /// <returns>
    ///     An instance of a <c>Map</c> which holds the fields.
    /// </returns>
    protected Map buildCreateInvoiceHeaderFromTempTableFieldMap(QueryBuildDataSource _qbdsVendInvoiceInfoTableTmp)
    {
        Map targetToSourceMap = new Map(Types::String, Types::Container);

        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, AddressRefRecId), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, AddressRefRecId)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, AddressRefTableId), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, AddressRefTableId)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, Approved), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, Approved)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, Approver), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, Approver)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, AutomationStatus), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, AutomationStatus)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, BatchAdministration), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, BatchAdministration)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, CashDisc), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, CashDisc)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, CashDiscdate), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, CashDiscdate)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, CreditCorrection), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, CreditCorrection)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, CurrencyCode), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, CurrencyCode)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, DeliveryName), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, DeliveryName)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, DeliveryPostalAddress), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, DeliveryPostalAddress)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, Description), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, Description)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, DocumentDate), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, DocumentDate)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, DocumentNum), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, DocumentNum)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, DocumentOrigin), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, DocumentOrigin)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, EUROTriangulation), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, EUROTriangulation)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, ExchRate), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, ExchRate)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, ExchRateSecondary), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, ExchRateSecondary)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, FixedDueDate), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, FixedDueDate)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, FixedExchRate), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, FixedExchRate)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, Hold), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, Hold)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, ImportedAmount), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, ImportedAmount)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, ImportedSalesTax), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, ImportedSalesTax)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, IncludeInAutomatedProcessing), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, IncludeInAutomatedProcessing)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, InvoiceAccount), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, InvoiceAccount)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, LastMatchVariance), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, LastMatchVariance)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, ListCode), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, ListCode)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, LogisticsElectronicAddress), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, LogisticsElectronicAddress)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, Num), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, Num)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, OrderAccount), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, OrderAccount)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, Ordering), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, Ordering)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, PackedExtensions), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, PackedExtensions)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, ParmId), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, ParmId)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, ParmJobStatus), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, ParmJobStatus)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, PaymId), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, PaymId)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, PaymMode), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, PaymMode)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, PaymSpec), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, PaymSpec)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, PoolRecId), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, PoolRecId)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, PurchAgreementHeader_PSN), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, PurchAgreementHeader_PSN)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, PurchId), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, PurchId)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, PurchName), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, PurchName)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, Recalculate), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, Recalculate)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, ReceivedDate), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, ReceivedDate)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, RemittanceLocation), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, RemittanceLocation)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, ReportingCurrencyExchangeRate), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, ReportingCurrencyExchangeRate)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, SourceDocumentHeader), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, SourceDocumentHeader)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, SourceDocumentLine), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, SourceDocumentLine)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, TableRefId), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, TableRefId)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, TransDate), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, TransDate)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, TransportationDocument), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, TransportationDocument)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, VendBankAccountId), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, VendBankAccountId)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, VendInvoiceGroup), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, VendInvoiceGroup)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, VendInvoiceSaveStatus), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, VendInvoiceSaveStatus)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, VendorRequestedWorkerEmail), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, VendorRequestedWorkerEmail)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, Log), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, Log)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, InvoiceReleaseDate), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, InvoiceReleaseDate)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, ReleaseDateComment), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, ReleaseDateComment)]);
        if (VendInvoiceFetchVATNumFromPOV2Flight::instance().isEnabled())
        {
            targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, VATNum), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, VATNum)]);
            targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, VATNumRecId), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, VATNumRecId)]);
            targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, VATNumTableType), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, VATNumTableType)]);
        }
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, VendorChargedSalesTax), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, VendorChargedSalesTax)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, AccrueSalesTaxType), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, AccrueSalesTaxType)]);
        if (isFinTagConfigurationSetForCurrent && PurchaseOrderFinTagFeature::isEnabled())
        {
            targetToSourceMap.insert(fieldStr(VendInvoiceInfoTable, FinTag), [_qbdsVendInvoiceInfoTableTmp.uniqueId(), fieldStr(VendInvoiceInfoTableTmp, FinTag)]);
        }

        return targetToSourceMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInvoiceMatchingLine</Name>
				<Source><![CDATA[
    protected void createInvoiceMatchingLine()
    {
        VendInvoiceInfoLine vendInvoiceInfoLineUpdate;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceMatchingLine vendInvoiceMatchingLine;
        PurchLine localPurchLine;
        PurchPriceTolerance ppt;
        InventTable inventTable;
        VendTable vendTable;
        VendParameters vendParameters = VendParameters::find();
        RefTableId localTableNum = tableNum(VendInvoiceInfoLine);

        if (vendParameters.editUseInvoiceMatching(false) == NoYes::Yes)
        {
            vendInvoiceMatchingLine.skipDataMethods(true);
            vendInvoiceMatchingLine.skipDatabaseLog(true);
            vendInvoiceMatchingLine.skipEvents(true);
            insert_recordset vendInvoiceMatchingLine
                (RefRecId, RefTableId,
                ExpectedQty, ExpectedPrice, ExpectedLinePercent, ExpectedLineDisc, ExpectedMultiLnDisc, ExpectedMultiLnPercent,
                ExpectedPriceUnit, ExpectedMarkup, ExpectedLineAmount, ExpectedCurrencyCode, MatchingPolicy)
            select RecId, localTableNum from vendInvoiceInfoLineUpdate
                where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
            join PurchQty, PurchPrice, LinePercent, LineDisc, MultiLnDisc, MultiLnPercent,
                    PriceUnit, PurchMarkup, LineAmount, CurrencyCode, MatchingPolicy from localPurchLine
                where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
            notexists join vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                   && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;

            update_recordset vendInvoiceMatchingLine setting
                PriceTolerancePercentage = ppt.PercentTolerance
            join vendInvoiceInfoLineUpdate
                where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                   && vendInvoiceInfoLineUpdate.TableId == vendInvoiceMatchingLine.RefTableId
                   && vendInvoiceInfoLineUpdate.RecId == vendInvoiceMatchingLine.RefRecId
            outer join inventTable
                where inventTable.ItemId == vendInvoiceInfoLineUpdate.ItemId
            join vendTable
                where vendTable.AccountNum == vendInvoiceInfoLineUpdate.OrderAccount
            join firstonly ppt
                where
            (ppt.ItemCode == TableGroupAll::Table && ppt.ItemRelation == vendInvoiceInfoLineUpdate.ItemId &&
                ppt.AccountCode == TableGroupAll::Table && ppt.AccountRelation == vendInvoiceInfoLineUpdate.OrderAccount) ||
            (ppt.ItemCode == TableGroupAll::Table && ppt.ItemRelation == vendInvoiceInfoLineUpdate.ItemId &&
                ppt.AccountCode == TableGroupAll::GroupId && ppt.AccountRelation == vendTable.VendPriceToleranceGroupId) ||
            (ppt.ItemCode == TableGroupAll::Table && ppt.ItemRelation == vendInvoiceInfoLineUpdate.ItemId &&
                ppt.AccountCode == TableGroupAll::All && ppt.AccountRelation == '') ||

            (ppt.ItemCode == TableGroupAll::GroupId && ppt.ItemRelation == inventTable.ItemPriceToleranceGroupId &&
                ppt.AccountCode == TableGroupAll::Table && ppt.AccountRelation == vendInvoiceInfoLineUpdate.OrderAccount) ||
            (ppt.ItemCode == TableGroupAll::GroupId && ppt.ItemRelation == inventTable.ItemPriceToleranceGroupId &&
                ppt.AccountCode == TableGroupAll::GroupId && ppt.AccountRelation == vendTable.VendPriceToleranceGroupId) ||
            (ppt.ItemCode == TableGroupAll::GroupId && ppt.ItemRelation == inventTable.ItemPriceToleranceGroupId &&
                ppt.AccountCode == TableGroupAll::All && ppt.AccountRelation == '') ||

            (ppt.ItemCode == TableGroupAll::All && ppt.ItemRelation == '' &&
                ppt.AccountCode == TableGroupAll::Table && ppt.AccountRelation == vendInvoiceInfoLineUpdate.OrderAccount) ||
            (ppt.ItemCode == TableGroupAll::All && ppt.ItemRelation == '' &&
                ppt.AccountCode == TableGroupAll::GroupId && ppt.AccountRelation == vendTable.VendPriceToleranceGroupId) ||
            (ppt.ItemCode == TableGroupAll::All && ppt.ItemRelation == '' &&
                ppt.AccountCode == TableGroupAll::All && ppt.AccountRelation == '')

            notexists join vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                   && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLineAsset</Name>
				<Source><![CDATA[
    protected void createLineAsset()
    {
        VendInvoiceInfoLine vendInvoiceInfoLineUpdate;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceTrans vendInvoiceTrans;
        VendInvoiceInfoLine_Asset invoiceLine_Asset;
        PurchLine localPurchLine;
        AssetParameters assetParameters = AssetParameters::find();
        boolean assetParamAllowCreate = assetParameters.AssetAllowCreate;
        boolean assetMultiAcquisition = assetParameters.MultiAcquisition;
        AssetTransTypePurch assetTransTypePurch;

        invoiceLine_Asset.skipDataMethods(true);
        invoiceLine_Asset.skipDatabaseLog(true);
        invoiceLine_Asset.skipEvents(true);

        //In the future, when it's time to remove obsolete methods and replace them with new ones,
        //remove the entire 'else' block and also remove the check for the 'assetParamAllowCreate' value within the 'if' clause
        if (assetParamAllowCreate)
        {
            Query invoiceLineAssetQuery = this.getQueryForInvoiceLineAssetAllowCreate();
            QueryBuildDataSource qbdsVendInvoiceInfoLineUpdate = invoiceLineAssetQuery.dataSourceTable(tableNum(VendInvoiceInfoLine));
            QueryBuildDataSource qbdsLocalPurchLine = invoiceLineAssetQuery.dataSourceTable(tableNum(PurchLine));

            Map searchResultMapInvoiceLine = this.createFieldMappingForInvoiceLineAssetAllowCreate(qbdsVendInvoiceInfoLineUpdate, qbdsLocalPurchLine);

            Query::insert_recordset(invoiceLine_Asset, searchResultMapInvoiceLine, invoiceLineAssetQuery);
        }
        else
        {
            Query invoiceLineAssetQuery = this.getQueryForInvoiceLineAsset();
            QueryBuildDataSource qbdsVendInvoiceInfoLineUpdate = invoiceLineAssetQuery.dataSourceTable(tableNum(VendInvoiceInfoLine));
            QueryBuildDataSource qbdsLocalPurchLine = invoiceLineAssetQuery.dataSourceTable(tableNum(PurchLine));

            Map searchResultMapInvoiceLine = this.createFieldMappingForInvoiceLineAsset(qbdsVendInvoiceInfoLineUpdate, qbdsLocalPurchLine);

            Query::insert_recordset(invoiceLine_Asset, searchResultMapInvoiceLine, invoiceLineAssetQuery);

            if (!AssetPurchaseOrderFormPerfImprovementFlight::instance().isEnabled())
            {
                invoiceLine_Asset.skipDataMethods(true);
                invoiceLine_Asset.skipDatabaseLog(true);
                invoiceLine_Asset.skipEvents(true);
                update_recordset invoiceLine_Asset setting
                    AssetGroup = localPurchLine.AssetGroup,
                    AssetTransTypePurch = localPurchLine.AssetTransTypePurch
                join vendInvoiceInfoLineUpdate
                    where vendInvoiceInfoLineUpdate.RecId == invoiceLine_Asset.VendInvoiceInfoLineRecId
                       && vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                join localPurchLine
                    where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
                       && localPurchLine.AssetId != ''
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                       && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
            }
        }

        if (assetMultiAcquisition)
        {
            assetTransTypePurch = AssetTransTypePurch::Acquisition;
        }
        else
        {
            assetTransTypePurch = AssetTransTypePurch::AcquisitionAdj;
        }

        if (AssetPurchaseOrderFormPerfImprovementFlight::instance().isEnabled())
        {
            invoiceLine_Asset.skipDataMethods(true);
            invoiceLine_Asset.skipDatabaseLog(true);
            invoiceLine_Asset.skipEvents(true);
            update_recordset invoiceLine_Asset setting
                    AssetTransTypePurch = assetTransTypePurch
                    where invoiceLine_Asset.AssetId != ''
                        && invoiceLine_Asset.AssetAcquired == NoYes::No
                        && invoiceLine_Asset.AssetTransTypePurch != assetTransTypePurch
                join vendInvoiceInfoLineUpdate
                    where vendInvoiceInfoLineUpdate.RecId == invoiceLine_Asset.VendInvoiceInfoLineRecId
                        && vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                join vendInvoiceTrans
                    where vendInvoiceTrans.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
                        && vendInvoiceTrans.Qty > 0
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                        && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
        }
        else
        {
            invoiceLine_Asset.skipDataMethods(true);
            invoiceLine_Asset.skipDatabaseLog(true);
            invoiceLine_Asset.skipEvents(true);
            update_recordset invoiceLine_Asset setting
                    AssetTransTypePurch = assetTransTypePurch
                join vendInvoiceInfoLineUpdate
                    where vendInvoiceInfoLineUpdate.RecId == invoiceLine_Asset.VendInvoiceInfoLineRecId
                        && vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                join vendInvoiceTrans
                    where vendInvoiceTrans.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
                        && vendInvoiceTrans.Qty > 0
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                        && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryForInvoiceLineAssetAllowCreate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the query to create Invoice line fixed asset.
    /// </summary>
    /// <returns>
    /// The Invoice line asset allow create query.
    /// </returns>
    [Wrappable(true),
     SysObsolete('This method will be deprecated in a future release, use getQueryForVendInfoInvoiceLineAsset instead.', false, 04\04\2024)]
    protected final Query getQueryForInvoiceLineAssetAllowCreate()
    {
        Query query = new Query();

        if (AssetPurchaseOrderFormPerfImprovementFlight::instance().isEnabled())
        {
            query = this.getQueryForVendInfoInvoiceLineAsset();
        }
        else
        {
            QueryBuildDataSource qbdsVendInvoiceInfoLineUpdate = query.addDataSource(tableNum(VendInvoiceInfoLine));

            qbdsVendInvoiceInfoLineUpdate.addRange(fieldNum(VendInvoiceInfoLine, ParmId)).value(queryValue(this.parmId()));
            qbdsVendInvoiceInfoLineUpdate.relations(true);

            QueryBuildFieldList qbdsVendInvoiceInfoLineUpdateFieldList = qbdsVendInvoiceInfoLineUpdate.fields();
            qbdsVendInvoiceInfoLineUpdateFieldList.dynamic(QueryFieldListDynamic::No);
            qbdsVendInvoiceInfoLineUpdate.fields().clearFieldList();
            qbdsVendInvoiceInfoLineUpdate.addSelectionField(fieldNum(VendInvoiceInfoLine, RecId));

            QueryBuildDataSource qbdsLocalPurchLine = qbdsVendInvoiceInfoLineUpdate.addDataSource(tableNum(PurchLine));
            qbdsLocalPurchLine.addLink(fieldNum(VendInvoiceInfoLine, InventTransId), fieldNum(PurchLine, InventTransId));
            qbdsLocalPurchLine.joinMode(JoinMode::InnerJoin);

            QueryBuildFieldList qbdsLocalPurchLineFieldList = qbdsLocalPurchLine.fields();
            qbdsLocalPurchLineFieldList.dynamic(QueryFieldListDynamic::No);
            qbdsLocalPurchLine.fields().clearFieldList();
            qbdsLocalPurchLine.addSelectionField(fieldNum(PurchLine, CreateFixedAsset));
            qbdsLocalPurchLine.addSelectionField(fieldNum(PurchLine, AssetGroup));
            qbdsLocalPurchLine.addSelectionField(fieldNum(PurchLine, AssetId));
            qbdsLocalPurchLine.addSelectionField(fieldNum(PurchLine, AssetBookId));
            qbdsLocalPurchLine.addSelectionField(fieldNum(PurchLine, AssetTransTypePurch));

            QueryBuildDataSource qbdsVendInvoiceInfoTable = qbdsLocalPurchLine.addDataSource(tableNum(VendInvoiceInfoTable));
            QueryBuildFieldList qbdsVendInvoiceInfoTableFieldList = qbdsVendInvoiceInfoTable.fields();
            qbdsVendInvoiceInfoTableFieldList.dynamic(QueryFieldListDynamic::No);
            qbdsVendInvoiceInfoTable.fields().clearFieldList();

            qbdsVendInvoiceInfoTable.addLink(fieldNum(VendInvoiceInfoLine, ParmId), fieldNum(VendInvoiceInfoTable, ParmId), qbdsVendInvoiceInfoLineUpdate.name());
            qbdsVendInvoiceInfoTable.addLink(fieldNum(VendInvoiceInfoLine, TableRefId), fieldNum(VendInvoiceInfoTable, TableRefId), qbdsVendInvoiceInfoLineUpdate.name());
            qbdsVendInvoiceInfoTable.joinMode(JoinMode::NoExistsJoin);
        }
        
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryForVendInfoInvoiceLineAsset</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    protected final Query getQueryForVendInfoInvoiceLineAsset()
    {
        Query query = new Query();

        QueryBuildDataSource qbdsVendInvoiceInfoLineUpdate = query.addDataSource(tableNum(VendInvoiceInfoLine));

        qbdsVendInvoiceInfoLineUpdate.addRange(fieldNum(VendInvoiceInfoLine, ParmId)).value(queryValue(this.parmId()));
        qbdsVendInvoiceInfoLineUpdate.relations(true);

        QueryBuildFieldList qbdsVendInvoiceInfoLineUpdateFieldList = qbdsVendInvoiceInfoLineUpdate.fields();
        qbdsVendInvoiceInfoLineUpdateFieldList.dynamic(QueryFieldListDynamic::No);
        qbdsVendInvoiceInfoLineUpdate.fields().clearFieldList();
        qbdsVendInvoiceInfoLineUpdate.addSelectionField(fieldNum(VendInvoiceInfoLine, RecId));

        QueryBuildDataSource qbdsLocalPurchLine = qbdsVendInvoiceInfoLineUpdate.addDataSource(tableNum(PurchLine));
        qbdsLocalPurchLine.addLink(fieldNum(VendInvoiceInfoLine, InventTransId), fieldNum(PurchLine, InventTransId));
        qbdsLocalPurchLine.joinMode(JoinMode::InnerJoin);

        QueryBuildFieldList qbdsLocalPurchLineFieldList = qbdsLocalPurchLine.fields();
        qbdsLocalPurchLineFieldList.dynamic(QueryFieldListDynamic::No);
        qbdsLocalPurchLine.fields().clearFieldList();
        qbdsLocalPurchLine.addSelectionField(fieldNum(PurchLine, CreateFixedAsset));
        qbdsLocalPurchLine.addSelectionField(fieldNum(PurchLine, AssetGroup));
        qbdsLocalPurchLine.addSelectionField(fieldNum(PurchLine, AssetId));
        qbdsLocalPurchLine.addSelectionField(fieldNum(PurchLine, AssetBookId));
        qbdsLocalPurchLine.addSelectionField(fieldNum(PurchLine, AssetTransTypePurch));

        QueryBuildDataSource qbdsVendInvoiceInfoTable = qbdsLocalPurchLine.addDataSource(tableNum(VendInvoiceInfoTable));
        QueryBuildFieldList qbdsVendInvoiceInfoTableFieldList = qbdsVendInvoiceInfoTable.fields();
        qbdsVendInvoiceInfoTableFieldList.dynamic(QueryFieldListDynamic::No);
        qbdsVendInvoiceInfoTable.fields().clearFieldList();

        qbdsVendInvoiceInfoTable.addLink(fieldNum(VendInvoiceInfoLine, ParmId), fieldNum(VendInvoiceInfoTable, ParmId), qbdsVendInvoiceInfoLineUpdate.name());
        qbdsVendInvoiceInfoTable.addLink(fieldNum(VendInvoiceInfoLine, TableRefId), fieldNum(VendInvoiceInfoTable, TableRefId), qbdsVendInvoiceInfoLineUpdate.name());
        qbdsVendInvoiceInfoTable.joinMode(JoinMode::NoExistsJoin);
        
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFieldMappingForInvoiceLineAssetAllowCreate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes field mapping to do a set-based insert from source(query) to destination(table) buffer.
    /// </summary>
    /// <param name = "_qbdsVendInvoiceInfoLineUpdate">
    /// The query build data source used for initialization.
    /// </param>
    /// <param name = "_qbdsLocalPurchLine">
    /// The query build data source used for initialization.
    /// </param>
    /// <returns>
    /// The Map with source(query) and target(buffer) fields.
    /// </returns>
    [Wrappable(true),
     SysObsolete('This method will be deprecated in a future release, use createFieldMappingForVendInfoInvoiceLineAsset instead.', false, 04\04\2024)]
    protected final Map createFieldMappingForInvoiceLineAssetAllowCreate(
        QueryBuildDataSource _qbdsVendInvoiceInfoLineUpdate,
        QueryBuildDataSource _qbdsLocalPurchLine)
    {
        Map targetToSourceMap = new Map(Types::String, Types::Container);

        if (AssetPurchaseOrderFormPerfImprovementFlight::instance().isEnabled())
        {
            targetToSourceMap = this.createFieldMappingForVendInfoInvoiceLineAsset(_qbdsVendInvoiceInfoLineUpdate, _qbdsLocalPurchLine);
        }
        else
        {
            targetToSourceMap.insert(fieldStr(VendInvoiceInfoLine_Asset, VendInvoiceInfoLineRecId), [_qbdsVendInvoiceInfoLineUpdate.uniqueId(), fieldStr(VendInvoiceInfoLine, RecId)]);
            targetToSourceMap.insert(fieldStr(VendInvoiceInfoLine_Asset, CreateFixedAsset), [_qbdsLocalPurchLine.uniqueId(), fieldStr(PurchLine, CreateFixedAsset)]);
            targetToSourceMap.insert(fieldStr(VendInvoiceInfoLine_Asset, AssetGroup), [_qbdsLocalPurchLine.uniqueId(), fieldStr(PurchLine, AssetGroup)]);
            targetToSourceMap.insert(fieldStr(VendInvoiceInfoLine_Asset, AssetId), [_qbdsLocalPurchLine.uniqueId(), fieldStr(PurchLine, AssetId)]);
            targetToSourceMap.insert(fieldStr(VendInvoiceInfoLine_Asset, AssetBookId), [_qbdsLocalPurchLine.uniqueId(), fieldStr(PurchLine, AssetBookId)]);
            targetToSourceMap.insert(fieldStr(VendInvoiceInfoLine_Asset, AssetTransTypePurch), [_qbdsLocalPurchLine.uniqueId(), fieldStr(PurchLine, AssetTransTypePurch)]);
        }

        return targetToSourceMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFieldMappingForVendInfoInvoiceLineAsset</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    protected final Map createFieldMappingForVendInfoInvoiceLineAsset(
        QueryBuildDataSource _qbdsVendInvoiceInfoLineUpdate,
        QueryBuildDataSource _qbdsLocalPurchLine)
    {
        Map targetToSourceMap = new Map(Types::String, Types::Container);

        targetToSourceMap.insert(fieldStr(VendInvoiceInfoLine_Asset, VendInvoiceInfoLineRecId), [_qbdsVendInvoiceInfoLineUpdate.uniqueId(), fieldStr(VendInvoiceInfoLine, RecId)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoLine_Asset, CreateFixedAsset), [_qbdsLocalPurchLine.uniqueId(), fieldStr(PurchLine, CreateFixedAsset)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoLine_Asset, AssetGroup), [_qbdsLocalPurchLine.uniqueId(), fieldStr(PurchLine, AssetGroup)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoLine_Asset, AssetId), [_qbdsLocalPurchLine.uniqueId(), fieldStr(PurchLine, AssetId)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoLine_Asset, AssetBookId), [_qbdsLocalPurchLine.uniqueId(), fieldStr(PurchLine, AssetBookId)]);
        targetToSourceMap.insert(fieldStr(VendInvoiceInfoLine_Asset, AssetTransTypePurch), [_qbdsLocalPurchLine.uniqueId(), fieldStr(PurchLine, AssetTransTypePurch)]);

        return targetToSourceMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryForInvoiceLineAsset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Invoice line asset query.
    /// </summary>
    /// <returns>
    /// The Invoice line asset query.
    /// </returns>
    [Wrappable(true),
     SysObsolete('This method will be deprecated in a future release, use getQueryForVendInfoInvoiceLineAsset instead.', false, 04\04\2024)]
    protected final Query getQueryForInvoiceLineAsset()
    {
        Query query = new Query();

        if (AssetDisposalParametersAcquisitionFlight::instance().isEnabled())
        {
            query = this.getQueryForVendInfoInvoiceLineAsset();
        }
        else
        {
            QueryBuildDataSource qbdsVendInvoiceInfoLineUpdate = query.addDataSource(tableNum(VendInvoiceInfoLine));

            qbdsVendInvoiceInfoLineUpdate.addRange(fieldNum(VendInvoiceInfoLine, ParmId)).value(queryValue(this.parmId()));
            qbdsVendInvoiceInfoLineUpdate.relations(true);

            QueryBuildFieldList qbdsVendInvoiceInfoLineUpdateFieldList = qbdsVendInvoiceInfoLineUpdate.fields();
            qbdsVendInvoiceInfoLineUpdateFieldList.dynamic(QueryFieldListDynamic::No);
            qbdsVendInvoiceInfoLineUpdate.fields().clearFieldList();
            qbdsVendInvoiceInfoLineUpdate.addSelectionField(fieldNum(VendInvoiceInfoLine, RecId));

            QueryBuildDataSource qbdsLocalPurchLine = qbdsVendInvoiceInfoLineUpdate.addDataSource(tableNum(PurchLine));
            qbdsLocalPurchLine.addLink(fieldNum(VendInvoiceInfoLine, InventTransId), fieldNum(PurchLine, InventTransId));
            qbdsLocalPurchLine.joinMode(JoinMode::InnerJoin);

            QueryBuildFieldList qbdsLocalPurchLineFieldList = qbdsLocalPurchLine.fields();
            qbdsLocalPurchLineFieldList.dynamic(QueryFieldListDynamic::No);
            qbdsLocalPurchLine.fields().clearFieldList();
            qbdsLocalPurchLine.addSelectionField(fieldNum(PurchLine, AssetId));
            qbdsLocalPurchLine.addSelectionField(fieldNum(PurchLine, AssetBookId));

            QueryBuildDataSource qbdsVendInvoiceInfoTable = qbdsLocalPurchLine.addDataSource(tableNum(VendInvoiceInfoTable));
            QueryBuildFieldList qbdsVendInvoiceInfoTableFieldList = qbdsVendInvoiceInfoTable.fields();
            qbdsVendInvoiceInfoTableFieldList.dynamic(QueryFieldListDynamic::No);
            qbdsVendInvoiceInfoTable.fields().clearFieldList();

            qbdsVendInvoiceInfoTable.addLink(fieldNum(VendInvoiceInfoLine, ParmId), fieldNum(VendInvoiceInfoTable, ParmId), qbdsVendInvoiceInfoLineUpdate.name());
            qbdsVendInvoiceInfoTable.addLink(fieldNum(VendInvoiceInfoLine, TableRefId), fieldNum(VendInvoiceInfoTable, TableRefId), qbdsVendInvoiceInfoLineUpdate.name());
            qbdsVendInvoiceInfoTable.joinMode(JoinMode::NoExistsJoin);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFieldMappingForInvoiceLineAsset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes field mapping to do a set-based insert from source(query) to destination(table) buffer.
    /// </summary>
    /// <param name = "_qbdsVendInvoiceInfoLineUpdate">
    /// The query build data source used for initialization.
    /// </param>
    /// <param name = "_qbdsLocalPurchLine">
    /// The query build data source used for initialization.
    /// </param>
    /// <returns>
    /// The Map with source(query) and target(buffer) fields.
    /// </returns>
    [Wrappable(true),
     SysObsolete('This method will be deprecated in a future release, use createFieldMappingForVendInfoInvoiceLineAsset instead.', false, 04\04\2024)]
    protected final Map createFieldMappingForInvoiceLineAsset(
        QueryBuildDataSource _qbdsVendInvoiceInfoLineUpdate,
        QueryBuildDataSource _qbdsLocalPurchLine)
    {
        Map targetToSourceMap = new Map(Types::String, Types::Container);

        if (AssetDisposalParametersAcquisitionFlight::instance().isEnabled())
        {
            targetToSourceMap = this.createFieldMappingForVendInfoInvoiceLineAsset(_qbdsVendInvoiceInfoLineUpdate, _qbdsLocalPurchLine);
        }
        else
        {
            targetToSourceMap.insert(fieldStr(VendInvoiceInfoLine_Asset, VendInvoiceInfoLineRecId), [_qbdsVendInvoiceInfoLineUpdate.uniqueId(), fieldStr(VendInvoiceInfoLine, RecId)]);
            targetToSourceMap.insert(fieldStr(VendInvoiceInfoLine_Asset, AssetId), [_qbdsLocalPurchLine.uniqueId(), fieldStr(PurchLine, AssetId)]);
            targetToSourceMap.insert(fieldStr(VendInvoiceInfoLine_Asset, AssetBookId), [_qbdsLocalPurchLine.uniqueId(), fieldStr(PurchLine, AssetBookId)]);
        }
        return targetToSourceMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLineProject</Name>
				<Source><![CDATA[
    protected void createLineProject()
    {
        if (Project::Enabled())
        {
            #OCCRetryCount

            PurchLine localPurchLine;
            VendInvoiceInfoLine vendInvoiceInfoLineUpdate;
            VendInvoiceInfoTable vendInvoiceInfoTable;

            // Add resource from PurchLine.ProjWorker field.
            while select ProjWorker from localPurchLine
                where localPurchLine.ProjId != ''
                    && localPurchLine.ProjWorker != 0
                join vendInvoiceInfoLineUpdate
                    where vendInvoiceInfoLineUpdate.InventTransId == localPurchLine.InventTransId
                        && vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                        && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId
            {
                ResourceFacade::findOrCreateByWorker(localPurchLine.ProjWorker);
            }
                
            try
            {
                ttsbegin;
                this.createLineProjectNoProjectWorker();

                this.createLineProjectWithProjectWorker();
                ttscommit;
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    sleep(ProjConstants::DeadLockRetryInterval * xSession::currentRetryCount());
                    retry;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLineProjectNoProjectWorker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates project vendor invoice lines with no project worker defined in PurchLine table.
    /// </summary>
    protected void createLineProjectNoProjectWorker()
    {
        PurchLine localPurchLine;
        VendInvoiceInfoLine vendInvoiceInfoLineUpdate;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceInfoLine_Project invoiceLine_Project;
        UnitOfMeasure unitOfMeasure;
        
        // ----- Create invoice line project records for PO lines with a project ID
        invoiceLine_Project.skipDataMethods(true);
        invoiceLine_Project.skipDatabaseLog(true);
        invoiceLine_Project.skipEvents(true);

        if (FeatureStateProvider::isFeatureEnabled(ProjVendInvoicePurchUnitFixFlight::instance()))
        {
            // First add the records with no project worker defined in PurchLine table.
            if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
            {
                invoiceLine_Project.skipDataMethods(false); // Do not skip table methods

                // If ProjProjectOperationsIntegrationFeature enabled, do not assign ProjTransId from PurchLine to VendInvoiceInfoLine_Project
                insert_recordset invoiceLine_Project
                (VendInvoiceInfoLineRefRecId,
                ProjDataAreaId, ProjId, ProjActivityNumber, ProjCategoryId, ProjLinePropertyId,
                ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId)
                select RecId from vendInvoiceInfoLineUpdate
                    where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                join DataAreaId, ProjId, ActivityNumber, ProjCategoryId, ProjLinePropertyId,
                    ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId from localPurchLine
                    where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
                        && localPurchLine.ProjId != ''
                        && localPurchLine.ProjWorker == 0
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                        && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
            }
            else
            {
                insert_recordset invoiceLine_Project
                (VendInvoiceInfoLineRefRecId,
                ProjDataAreaId, ProjId, ProjActivityNumber, ProjCategoryId, ProjLinePropertyId,
                ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId, ProjTransId)
                select RecId from vendInvoiceInfoLineUpdate
                    where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                join DataAreaId, ProjId, ActivityNumber, ProjCategoryId, ProjLinePropertyId,
                    ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId, ProjTransId from localPurchLine
                    where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
                        && localPurchLine.ProjId != ''
                        && localPurchLine.ProjWorker == 0
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                        && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
            }

            //Update records that have sales unit in purchline
            //The insert and update is being split as the VendInvoiceInfoLine_Project record does not get created
            //if the purchline does not have ProjSalesUnitId as VendInvoiceInfoLine_Project stores recid of the unit
            update_recordset invoiceLine_Project setting ProjSalesUnitId = unitOfMeasure.RecId
            where invoiceLine_Project.ProjSalesUnitId == 0
           join vendInvoiceInfoLineUpdate where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                && vendInvoiceInfoLineUpdate.RecId == invoiceLine_Project.VendInvoiceInfoLineRefRecId
           join localPurchLine where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
                && localPurchLine.ProjId != ''
                && localPurchLine.ProjWorker == 0
                && localpurchline.projsalesunitid != ''
           join  unitOfMeasure where unitOfMeasure.Symbol == localPurchLine.ProjSalesUnitId
            notexists join vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                    && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
        }
        else
        {
            if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
            {
                invoiceLine_Project.skipDataMethods(false); // Do not skip table methods

                // If ProjProjectOperationsIntegrationFeature enabled, do not assign ProjTransId from PurchLine to VendInvoiceInfoLine_Project
                insert_recordset invoiceLine_Project
                (VendInvoiceInfoLineRefRecId,
                ProjDataAreaId, ProjId, ProjActivityNumber, ProjCategoryId, ProjLinePropertyId,
                ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId,
                ProjSalesUnitId)
                select RecId from vendInvoiceInfoLineUpdate
                    where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                join DataAreaId, ProjId, ActivityNumber, ProjCategoryId, ProjLinePropertyId,
                        ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId from localPurchLine
                    where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
                        && localPurchLine.ProjId != ''
                        && localPurchLine.ProjWorker == 0
                join RecId from unitOfMeasure
                    where unitOfMeasure.Symbol == localPurchLine.ProjSalesUnitId
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                        && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
            }
            else
            {
                insert_recordset invoiceLine_Project
                (VendInvoiceInfoLineRefRecId,
                ProjDataAreaId, ProjId, ProjActivityNumber, ProjCategoryId, ProjLinePropertyId,
                ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId, ProjTransId,
                ProjSalesUnitId)
                select RecId from vendInvoiceInfoLineUpdate
                    where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                join DataAreaId, ProjId, ActivityNumber, ProjCategoryId, ProjLinePropertyId,
                        ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId, ProjTransId from localPurchLine
                    where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
                        && localPurchLine.ProjId != ''
                        && localPurchLine.ProjWorker == 0
                join RecId from unitOfMeasure
                    where unitOfMeasure.Symbol == localPurchLine.ProjSalesUnitId
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                        && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLineProjectWithProjectWorker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates project vendor invoice lines with project workers defined in PurchLine table.
    /// </summary>
    protected void createLineProjectWithProjectWorker()
    {
        PurchLine localPurchLine;
        VendInvoiceInfoLine vendInvoiceInfoLineUpdate;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceInfoLine_Project invoiceLine_Project;
        ResourceWorkerView resourceWorkerView;
        UnitOfMeasure unitOfMeasure;
        
        // ----- Create invoice line project records for PO lines with a project ID
        invoiceLine_Project.skipDataMethods(true);
        invoiceLine_Project.skipDatabaseLog(true);
        invoiceLine_Project.skipEvents(true);

        if (FeatureStateProvider::isFeatureEnabled(ProjVendInvoicePurchUnitFixFlight::instance()))
        {
            // Then add the records with project workers are defined in PurchLine table.
            if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
            {
                invoiceLine_Project.skipDataMethods(false); // Do not skip table method

                // If ProjProjectOperationsIntegrationFeature enabled, do not assign ProjTransId from PurchLine to VendInvoiceInfoLine_Project
                insert_recordset invoiceLine_Project
                    (VendInvoiceInfoLineRefRecId,
                    ProjDataAreaId, ProjId, ProjActivityNumber, ProjCategoryId, ProjLinePropertyId,
                    ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId, Resource)
                select RecId from vendInvoiceInfoLineUpdate
                    where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                join DataAreaId, ProjId, ActivityNumber, ProjCategoryId, ProjLinePropertyId,
                        ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId from localPurchLine
                    where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
                        && localPurchLine.ProjId != ''
                        && localPurchLine.ProjWorker != 0
                join RecId from resourceWorkerView
                    where resourceWorkerView.Worker == localPurchLine.ProjWorker
                        && resourceWorkerView.ResourceCompanyId == localPurchLine.DataAreaId
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                        && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
            }
            else
            {
                insert_recordset invoiceLine_Project
                (VendInvoiceInfoLineRefRecId,
                ProjDataAreaId, ProjId, ProjActivityNumber, ProjCategoryId, ProjLinePropertyId,
                ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId, ProjTransId, Resource)
                select RecId from vendInvoiceInfoLineUpdate
                    where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                join DataAreaId, ProjId, ActivityNumber, ProjCategoryId, ProjLinePropertyId,
                        ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId, ProjTransId from localPurchLine
                    where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
                        && localPurchLine.ProjId != ''
                        && localPurchLine.ProjWorker != 0
                join RecId from resourceWorkerView
                    where resourceWorkerView.Worker == localPurchLine.ProjWorker
                        && resourceWorkerView.ResourceCompanyId == localPurchLine.DataAreaId
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                        && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
            }

            //Update records that have sales unit in purchline
            //The insert and update is being split as the VendInvoiceInfoLine_Project record does not get created
            //if the purchline does not have ProjSalesUnitId as VendInvoiceInfoLine_Project stores recid of the unit
            update_recordset invoiceLine_Project setting ProjSalesUnitId = unitOfMeasure.RecId
                where invoiceLine_Project.ProjSalesUnitId == 0
               join vendInvoiceInfoLineUpdate where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                    && vendInvoiceInfoLineUpdate.RecId == invoiceLine_Project.VendInvoiceInfoLineRefRecId
               join localPurchLine where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
                    && localPurchLine.ProjId != ''
                    && localPurchLine.ProjWorker == 0
                    && localpurchline.projsalesunitid != ''
               join  unitOfMeasure where unitOfMeasure.Symbol == localPurchLine.ProjSalesUnitId
               join resourceWorkerView where resourceWorkerView.Worker == localPurchLine.ProjWorker
                    && resourceWorkerView.ResourceCompanyId == localPurchLine.DataAreaId
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                        && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
        }
        else
        {
            if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
            {
                invoiceLine_Project.skipDataMethods(false); // Do not skip table methods

                // If ProjProjectOperationsIntegrationFeature enabled, do not assign ProjTransId from PurchLine to VendInvoiceInfoLine_Project
                insert_recordset invoiceLine_Project
                (VendInvoiceInfoLineRefRecId,
                ProjDataAreaId, ProjId, ProjActivityNumber, ProjCategoryId, ProjLinePropertyId,
                ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId, ProjSalesUnitId, Resource)
                select RecId from vendInvoiceInfoLineUpdate
                    where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                join DataAreaId, ProjId, ActivityNumber, ProjCategoryId, ProjLinePropertyId,
                        ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId from localPurchLine
                    where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
                        && localPurchLine.ProjId != ''
                        && localPurchLine.ProjWorker != 0
                join RecId from unitOfMeasure
                    where unitOfMeasure.Symbol == localPurchLine.ProjSalesUnitId
                join RecId from resourceWorkerView
                    where resourceWorkerView.Worker == localPurchLine.ProjWorker
                        && resourceWorkerView.ResourceCompanyId == localPurchLine.DataAreaId
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                        && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
            }
            else
            {
                insert_recordset invoiceLine_Project
                (VendInvoiceInfoLineRefRecId,
                ProjDataAreaId, ProjId, ProjActivityNumber, ProjCategoryId, ProjLinePropertyId,
                ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId, ProjTransId,
                ProjSalesUnitId, Resource)
                select RecId from vendInvoiceInfoLineUpdate
                    where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                join DataAreaId, ProjId, ActivityNumber, ProjCategoryId, ProjLinePropertyId,
                        ProjSalesCurrencyId, ProjSalesPrice, ProjTaxGroupId, ProjTaxItemGroupId, ProjTransId from localPurchLine
                    where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
                        && localPurchLine.ProjId != ''
                        && localPurchLine.ProjWorker != 0
                join RecId from unitOfMeasure
                    where unitOfMeasure.Symbol == localPurchLine.ProjSalesUnitId
                join RecId from resourceWorkerView
                    where resourceWorkerView.Worker == localPurchLine.ProjWorker
                        && resourceWorkerView.ResourceCompanyId == localPurchLine.DataAreaId
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                        && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new record in the <c>VendInvoiceInfoLine</c> table.
    /// </summary>
    /// <param name="_purchLine">
    /// A record in the <c>PurchLine</c> table that is used to initialize the new record in the
    /// <c>VendInvoiceInfoLine</c> table.
    /// </param>
    /// <param name="_tableRef">
    /// The table reference of the new record in the <c>VendInvoiceInfoLine</c> table.
    /// </param>
    /// <param name="_callFromCreateParmLineAndSubLines">
    /// If called from the <c>createParmLineAndSubLines</c> we always want normal behaviour, even though we
    /// are creating a packing slip.
    /// </param>
    /// <returns>
    /// true if the <c>VendInvoiceInfoLine</c> table record was created; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If this method is called from the <c>createParmLineAndSubLines</c> method this should use regular
    /// behavior, even though a packing slip is being created.
    /// </remarks>
    protected boolean createParmLine(Common _purchLine,
                                     TradeLineRefId _tableRef = '',
                                     boolean _callFromCreateParmLineAndSubLines = false)
    {
        boolean createdLine;
        str vendInvoiceInfoLineKey;
        VendInvoiceInfoLine localVendInvoiceInfoLine;
        VendDocumentLineProjectMap localParmLine_Project = this.initParmLine_project();
        AgreementLine agreementLine;

        if (this.skipParmLine(_purchLine, _tableRef, _callFromCreateParmLineAndSubLines))
        {
            return false;
        }
        
        // <GIN>
        MapEnumerator me;
        container packedParmLinesMap;
        PurchLine purchLineCopy;
        PurchTable purchTableCopy;
        boolean isCustomsMarked = TaxParameters::isCustomsEnable_IN();
        // </GIN>

        // <GIN>
        if (isCustomsMarked)
        {
            if (_purchLine.TableId == tableNum(PurchLine))
            {
                purchLineCopy = _purchLine;
                purchTableCopy = purchLineCopy.purchTable();
            }
            else
            {
                isCustomsMarked = false;
            }
        }
        // </GIN>

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && isFromPurchAgreement)
        {
            agreementLine = _purchLine;
            if (!agreementLine.IsDeleted)
            {
                return this.createVendInvoiceLineFromPurchAgrLine(agreementLine, _tableRef);
            }
        }
        else
    // <GIN>
    if (isFromBillOfEntry)
        {
            if (!isFromBillOfEntry || _callFromCreateParmLineAndSubLines)
            {
                createdLine = super(_purchLine, _tableRef);
                vendInvoiceInfoLineKey = this.parmLineMapKey(_purchLine);

                if (createdLine && parmLineMap.exists(vendInvoiceInfoLineKey))
                {
                    localVendInvoiceInfoLine = parmLineMap.lookup(vendInvoiceInfoLineKey);
                }
            }
            else
            {
                createdLine = this.createParmLineAndSubLines(_purchLine, subLinesMap.pack(), _tableRef);
            }
        }
        else
        {
            // </GIN>
            if (!isFromPackingSlip || _callFromCreateParmLineAndSubLines)
            {
                createdLine = super(_purchLine, _tableRef);
                vendInvoiceInfoLineKey = this.parmLineMapKey(_purchLine);
                if (createdLine && parmLineMap.exists(vendInvoiceInfoLineKey))
                {
                    if (!isCustomsMarked || !VendDocumentLineMap::isTransactionRelatedToBOE_IN(purchTableCopy, purchParmUpdate))
                    {
                        localVendInvoiceInfoLine = parmLineMap.lookup(vendInvoiceInfoLineKey);
                        this.addVendInvoiceMatchingLine(localVendInvoiceInfoLine, _purchLine);
                    }
                }
            }
            else
            {
                createdLine = this.createParmLineAndSubLines(_purchLine, subLinesMap.pack(), _tableRef);
            }
        }

        // <GIN>
        if (_callFromCreateParmLineAndSubLines 
            && isCustomsMarked && VendDocumentLineMap::isTransactionRelatedToBOE_IN(purchTableCopy, purchParmUpdate)
            && createdLine)
        {
            packedParmLinesMap = parmLineMap.pack();
            me = Map::create(packedParmLinesMap).getEnumerator();
            while (me.moveNext())
            {
                localVendInvoiceInfoLine = me.currentValue();

                if (localVendInvoiceInfoLine.PurchLineRecId == purchLineCopy.RecId && localVendInvoiceInfoLine.InventTransId && purchLineCopy.InventTransId)
                {
                    this.addVendInvoiceMatchingLine(localVendInvoiceInfoLine, _purchLine);
                }
            }
        }
        // </GIN>

        //initializing project data for invoice
        if (createdLine && localVendInvoiceInfoLine.ReceiveNow)
        {
            // <GIN>
            if (isCustomsMarked
                && VendDocumentLineMap::isTransactionRelatedToBOE_IN(purchTableCopy, purchParmUpdate))
            {
                packedParmLinesMap = parmLineMap.pack();
                me = Map::create(packedParmLinesMap).getEnumerator();
                while (me.moveNext())
                {
                    localVendInvoiceInfoLine = me.currentValue();

                    if (localVendInvoiceInfoLine.PurchLineRecId == purchLineCopy.RecId && localVendInvoiceInfoLine.InventTransId && purchLineCopy.InventTransId)
                    {
                        localParmLine_Project.clear();
                        localParmLine_Project.initFromPurchLine(_purchLine);
                        localParmLine_Project.VendDocumentLineProjectMap::initFromLine(localVendInvoiceInfoLine);
                        this.insertParmLine_Project(localParmLine_Project);
                    }
                }
            }
            else
            {
                // </GIN>
                localParmLine_Project.clear();
                localParmLine_Project.initFromPurchLine(_purchLine);
                localParmLine_Project.VendDocumentLineProjectMap::initFromLine(localVendInvoiceInfoLine);
                this.insertParmLine_Project(localParmLine_Project);
                // <GIN>
            }
            // </GIN>

            this.allowCreateParmTable(true);
        }
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (createdLine && localVendInvoiceInfoLine.ReceiveNow && RAssetPurchTrans::exist(_purchLine) && ! RAssetPurchTrans::exist(localVendInvoiceInfoLine))
            {
                this.createParmLineAsset_RU(_purchLine, localVendInvoiceInfoLine);
            }
        }
        // </GEERU>

        return createdLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipProcessingVendPackingTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines where to skip the <c>VendPackingSlipTrans</c> for processing.
    /// </summary>
    /// <param name = "_vendPackingSlipTrans">A <c>VendPackingSlipTrans</c> record.</param>
    /// <param name = "_purchLine">A <c>PurchLine</c> record.</param>
    /// <returns>true if the given <c>VendPackingSlipTrans</c> should be skipped from processing further; otherwise, false.</returns>
    protected boolean skipProcessingVendPackingTrans(VendPackingSlipTrans _vendPackingSlipTrans, PurchLine _purchLine)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmLineAndSubLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates document processing lines and related sublines.
    /// </summary>
    /// <param name="_purchLine">
    /// Original order lines.
    /// </param>
    /// <param name="_packedSubLinesMap">
    /// Packed map of sublines.
    /// </param>
    /// <param name="_tableRef">
    /// The reference ID from the connected record in order header posting parameter table.
    /// </param>
    /// <returns>
    /// true, if any lines were created. Otherwise returns false.
    /// </returns>
    protected boolean createParmLineAndSubLines(PurchLine _purchLine, container _packedSubLinesMap, TradeLineRefId _tableRef)
    {
        MapEnumerator me;
        VendInvoiceInfoSubLine vendInvoiceInfoSubLine;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        VendPackingSlipTrans vendPackingSlipTrans;
        PurchQty purchQty;
        PurchQty openEndedMatchedPurchQty;
        InventQty openEndedMatchedInventQty;
        InventQty inventQty;

        InventQty cwOpenEndedMatchedQty;
        PdsCWInventQty cwQty;

        Set subLineSet = new Set(Types::Record);
        SetEnumerator se;
        boolean lineCreated, anyLineCreated;

        // <GIN>
        PurchLine purchLineCopy = _purchLine;
        CustomsVendBOETrans_IN customsVendBOETransCopy;
        boolean isCustomsMarked = TaxParameters::isCustomsEnable_IN();
        // </GIN>
        newPostingCWQty = 0;

        newPostingPurchQty = 0;
        newPostingInventQty = 0;

        if (_purchLine.RecId)
        {
            // <GIN>
            if (isFromBillOfEntry)
            {
                me = Map::create(_packedSubLinesMap).getEnumerator();

                while (me.moveNext())
                {
                    customsVendBOETransCopy = me.currentValue();
                    customsVendBOETransCopy = CustomsVendBOETrans_IN::findRecId(customsVendBOETransCopy.RecId);

                    customsVendBOETransCopy.BillOfEntryQty = CustomsVendBOETrans_IN::getRemainingQuantityForInvoiceUpdate(_purchLine.PurchId, _purchLine.InventTransId, customsVendBOETransCopy.RecId);

                    subLineSet.add(customsVendBOETransCopy);

                    inventQty += customsVendBOETransCopy.BillOfEntryQty;
                    purchQty += customsVendBOETransCopy.BillOfEntryQty;
                }
            }
            else
            {
                // </GIN>
                me = Map::create(_packedSubLinesMap).getEnumerator();

                while (me.moveNext())
                {
                    vendPackingSlipTrans = me.currentValue();
                    vendPackingSlipTrans = this.initVendPackingSlipTrans(_purchLine, vendPackingSlipTrans);

                    if (vendPackingSlipTrans)
                    {
                        subLineSet.add(vendPackingSlipTrans);

                        inventQty += vendPackingSlipTrans.InventQty;
                        purchQty += vendPackingSlipTrans.Qty;
                        cwQty += vendPackingSlipTrans.PdsCWQty;
                    }
                }
                // <GIN>
            }
            // </GIN>

            newPostingCWQty = cwQty;
            newPostingPurchQty = purchQty;
            newPostingInventQty = inventQty;

            if (isFromPackingSlip)
            {
                // subtract Qty from open ended sub lines
                openEndedMatchedPurchQty = _purchLine.calcPendingMatchedQtyPurch(true, true);

                openEndedMatchedInventQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_purchLine.ItemId,
                                                                                                                  _purchLine.InventDimId,
                                                                                                                  openEndedMatchedPurchQty,
                                                                                                                  _purchLine.PurchUnit,
                                                                                                                  InventTable::find(_purchLine.ItemId).inventUnitId(),
                                                                                                                  NoYes::No,
                                                                                                                  NoYes::No);
                                                

                if (PdsGlobal::pdsIsCWItem(_purchLine.ItemId))
                {
                    cwOpenEndedMatchedQty = _purchLine.pdsCWCalcPendingMatchedQtyInvent(true, true);
                }

                newPostingPurchQty = newPostingPurchQty - openEndedMatchedPurchQty;
                newPostingInventQty = newPostingInventQty - openEndedMatchedInventQty;
                newPostingCWQty = newPostingCWQty - cwOpenEndedMatchedQty;
            }

            lineCreated = this.createParmLine(_purchLine, _tableRef, true);

            anyLineCreated = anyLineCreated || lineCreated;
            // <GIN>
            if (lineCreated
                && parmLineMap.elements() > 0
                && subLineSet.elements() > 0
                && isCustomsMarked
                && VendDocumentLineMap::isTransactionRelatedToBOE_IN(purchLineCopy.purchTable(), purchParmUpdate)
                && VendBOEInvoiceMatch_INFlight::instance().isEnabled())
            {
                this.createInfoSubLineForBOE_IN(_purchLine, parmLineMap.pack(), subLineSet, openEndedMatchedPurchQty, openEndedMatchedInventQty);
            }
            else
            {
                // </GIN>
                if (lineCreated && parmLineMap.exists(this.parmLineMapKey(_purchLine)))
                {
                    vendInvoiceInfoLine = parmLineMap.lookup(this.parmLineMapKey(_purchLine));

                    se = subLineSet.getEnumerator();
                    while (se.moveNext())
                    {
                        vendPackingSlipTrans = se.current();
                        vendInvoiceInfoSubLine.clear();
                        vendInvoiceInfoSubLine.initFromLine(vendInvoiceInfoLine);
                        vendInvoiceInfoSubLine.initFromVendPackingSlipTrans(vendPackingSlipTrans);

                        if (isFromPackingSlip)
                        {
                            vendInvoiceInfoSubLine.ReceiveNow = vendInvoiceInfoSubLine.ReceiveNow - openEndedMatchedPurchQty;
                            vendInvoiceInfoSubLine.InventNow = vendInvoiceInfoSubLine.InventNow - openEndedMatchedInventQty;
                            vendInvoiceInfoSubLine.PdsCWInventNow = vendInvoiceInfoSubLine.PdsCWInventNow - cwOpenEndedMatchedQty;
                        }
                        this.insertParmSubLine(vendInvoiceInfoSubLine);
                    }
                }
                // <GIN>
            }
            // </GIN>
        }

        return anyLineCreated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVendPackingSlipTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a <c>VendPackingSlipTrans</c> table buffer.
    /// </summary>
    /// <param name="_purchLine">
    /// Original order lines.
    /// </param>
    /// <param name = "_vendPackingSlipTrans">
    /// A <c>VendPackingSlipTrans</c> table buffer.
    /// </param>
    /// <returns>
    /// A <c>VendPackingSlipTrans</c> table buffer.
    /// </returns>
    protected VendPackingSlipTrans initVendPackingSlipTrans(PurchLine _purchLine, VendPackingSlipTrans _vendPackingSlipTrans)
    {
        _vendPackingSlipTrans.Qty = _vendPackingSlipTrans.remainPurchFinancial();
        _vendPackingSlipTrans.InventQty = _vendPackingSlipTrans.remainInventFinancial();

        if (this.skipProcessingVendPackingTrans(_vendPackingSlipTrans, _purchLine))
        {
            return null;
        }
        else if (PdsGlobal::pdsIsCWItem(_vendPackingSlipTrans.ItemId))
        {
            _vendPackingSlipTrans.PdsCWQty = _vendPackingSlipTrans.pdsCWRemainFinancial();
        }

        return _vendPackingSlipTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmLineAsset_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the parameter line which holds the RU fixed asset data.
    /// </summary>
    /// <param name="_purchLine">
    /// The purchase line to reference when creating the parameter lines
    /// </param>
    /// <param name="_infoLine">
    /// The parameter line which should hold the fixed asset data.
    /// </param>
    protected void createParmLineAsset_RU(Common _purchLine, VendInvoiceInfoLine _infoLine)
    {
        RAssetPurchTrans purchLineTrans, infoTrans;
        PurchQty receiveNow = abs(_infoLine.ReceiveNow);

        if (_purchLine.TableId == tableNum(PurchLine))
        {
            while select purchLineTrans
                where purchLineTrans.TableTableId == _purchLine.TableId &&
                    purchLineTrans.TableRecId == _purchLine.RecId &&
                    !purchLineTrans.Posted
            {
                infoTrans.clear();
                infoTrans.initFromPurchLine(_infoLine);
                infoTrans.AssetId = purchLineTrans.AssetId;
                infoTrans.PurchTransType = RAssetPurchTransType::PurchaseLine;
                infoTrans.ReceiveNow = receiveNow > 0 ? NoYes::Yes : NoYes::No;
                receiveNow--;
                recordInsertParmLine_Asset_RU.add(infoTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldMappingsPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds <c>PurchLine</c> table specific fields to the insert field mappings.
    /// </summary>
    /// <param name = "_queryBuildDataSource">The given <c>QueryBuildDataSource</c> used for the field mapping.</param>
    /// <param name = "_queryBuildFieldList">The given <c>QueryBuildFieldList</c> instance in which to add the field mapping.</param>
    /// <param name = "_insertRecordsetMap">The given <c>Map</c> instance in which to add the field mapping.</param>
    protected void addFieldMappingsPurchLine(QueryBuildDataSource _queryBuildDataSource, QueryBuildFieldList _queryBuildFieldList, Map _insertRecordsetMap)
    {
        int dataSourceUniqueId = _queryBuildDataSource.uniqueId();
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, PurchId), fieldStr(PurchLine, PurchId), fieldStr(VendInvoiceInfoLine, OrigPurchId));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, InventTransId), fieldStr(PurchLine, InventTransId), fieldStr(VendInvoiceInfoLine, InventTransId));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, ItemId), fieldStr(PurchLine, ItemId), fieldStr(VendInvoiceInfoLine, ItemId));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, LineNumber), fieldStr(PurchLine, LineNumber), fieldStr(VendInvoiceInfoLine, LineNum));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, CurrencyCode), fieldStr(PurchLine, CurrencyCode), fieldStr(VendInvoiceInfoLine, CurrencyCode));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, DeliveryName), fieldStr(PurchLine, DeliveryName), fieldStr(VendInvoiceInfoLine, DeliveryName));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, DeliveryPostalAddress), fieldStr(PurchLine, DeliveryPostalAddress), fieldStr(VendInvoiceInfoLine, DeliveryPostalAddress));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, PriceUnit), fieldStr(PurchLine, PriceUnit), fieldStr(VendInvoiceInfoLine, PriceUnit));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, InventDimId), fieldStr(PurchLine, InventDimId), fieldStr(VendInvoiceInfoLine, InventDimId));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, ProcurementCategory), fieldStr(PurchLine, ProcurementCategory), fieldStr(VendInvoiceInfoLine, ProcurementCategory));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, RemainInventPhysical), fieldStr(PurchLine, RemainInventPhysical), fieldStr(VendInvoiceInfoLine, RemainBeforeInventPhysical));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, TaxGroup), fieldStr(PurchLine, TaxGroup), fieldStr(VendInvoiceInfoLine, TaxGroup));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, TaxItemGroup), fieldStr(PurchLine, TaxItemGroup), fieldStr(VendInvoiceInfoLine, TaxItemGroup));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, OverrideSalesTax), fieldStr(PurchLine, OverrideSalesTax), fieldStr(VendInvoiceInfoLine, OverrideSalesTax));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, PDSCalculationId), fieldStr(PurchLine, PDSCalculationId), fieldStr(VendInvoiceInfoLine, PDSCalculationId));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, PurchMarkup), fieldStr(PurchLine, PurchMarkup), fieldStr(VendInvoiceInfoLine, PurchMarkup));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, MultiLnDisc), fieldStr(PurchLine, MultiLnDisc), fieldStr(VendInvoiceInfoLine, MultiLnDisc));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, MultiLnPercent), fieldStr(PurchLine, MultiLnPercent), fieldStr(VendInvoiceInfoLine, MultiLnPercent));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, LineDisc), fieldStr(PurchLine, LineDisc), fieldStr(VendInvoiceInfoLine, LineDisc));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, LinePercent), fieldStr(PurchLine, LinePercent), fieldStr(VendInvoiceInfoLine, LinePercent));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, PurchPrice), fieldStr(PurchLine, PurchPrice), fieldStr(VendInvoiceInfoLine, PurchPrice));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, IntrastatCommodity), fieldStr(PurchLine, IntrastatCommodity), fieldStr(VendInvoiceInfoLine, IntrastatCommodity));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, OrigCountryRegionId), fieldStr(PurchLine, OrigCountryRegionId), fieldStr(VendInvoiceInfoLine, OrigCountryRegionId));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, OrigStateId), fieldStr(PurchLine, OrigStateId), fieldStr(VendInvoiceInfoLine, OrigStateId));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, PurchUnit), fieldStr(PurchLine, PurchUnit), fieldStr(VendInvoiceInfoLine, PurchUnit));

        if (FeatureStateProvider::isFeatureEnabled(ProjOpsSubcontractPurchaseOrderFeature::instance()))
        {
            this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, ProjSubContractLineNumber), fieldStr(PurchLine, ProjSubContractLineNumber), fieldStr(VendInvoiceInfoLine, ProjSubcontractLineNumber));
        }

        if (isFinTagConfigurationSetForCurrent && PurchaseOrderFinTagFeature::isEnabled())
        {
            this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, FinTag), fieldStr(PurchLine, FinTag), fieldStr(VendInvoiceInfoLine, FinTag));
        }

        if (TaxWithholdingGlobalFeature::isExtendedWHTSupportedInCountryRegionOrParamEnabled())
        {
            this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, TaxWithholdItemGroupHeading_TH), fieldStr(PurchLine, TaxWithholdItemGroupHeading_TH), fieldStr(VendInvoiceInfoLine, TaxWithholdItemGroupHeadingId));

            // Withholding tax group should be defaulted from purchline when enable amount calculation in invoice.
            if (TaxWithholdParameters::find().EnableCalcWHTInInvoice)
            {
                this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, TaxWithholdGroup_TH), fieldStr(PurchLine, TaxWithholdGroup_TH), fieldStr(VendInvoiceInfoLine, TaxWithholdGroup));
            }
        }

        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, PurchCommitmentLine_PSN), fieldStr(PurchLine, PurchCommitmentLine_PSN), fieldStr(VendInvoiceInfoLine, PurchCommitmentLine_PSN));
        }

        if (purchParmUpdate.SpecQty== PurchUpdate::ReceiveNow)
        {
            this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, PurchReceivedNow), fieldStr(PurchLine, PurchReceivedNow), fieldStr(VendInvoiceInfoLine, ReceiveNow));
            this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, InventReceivedNow), fieldStr(PurchLine, InventReceivedNow), fieldStr(VendInvoiceInfoLine, InventNow));
            this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, PdsCWInventReceivedNow), fieldStr(PurchLine, PdsCWInventReceivedNow), fieldStr(VendInvoiceInfoLine, PdsCWReceiveNow));
        }
        
        // SourceDocumentLine does not allow duplicates, but it can not be set until source document lines have been created
        // PurchLine.RecId cannot be used in case PurchLine RecId values collide with SourceDocumentLine RecId values, causing duplicate invoice lines
        // PurchLine.SourceDocumentLine can be used temporarily because it will not exist as the SourceDocumentLine for other vendor invoice lines
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchLine, SourceDocumentLine), fieldStr(PurchLine, SourceDocumentLine), fieldStr(VendInvoiceInfoLine, SourceDocumentLine));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldMappingsPurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds <c>PurchTable</c> table specific fields to the insert field mappings.
    /// </summary>
    /// <param name = "_queryBuildDataSource">The given <c>QueryBuildDataSource</c> used for the field mapping.</param>
    /// <param name = "_queryBuildFieldList">The given <c>QueryBuildFieldList</c> instance in which to add the field mapping.</param>
    /// <param name = "_insertRecordsetMap">The given <c>Map</c> instance in which to add the field mapping.</param>
    protected void addFieldMappingsPurchTable(QueryBuildDataSource _queryBuildDataSource, QueryBuildFieldList _queryBuildFieldList, Map _insertRecordsetMap)
    {
        int dataSourceUniqueId = _queryBuildDataSource.uniqueId();
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchTable, OrderAccount), fieldStr(PurchTable, OrderAccount), fieldStr(VendInvoiceInfoLine, OrderAccount));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchTable, InvoiceAccount), fieldStr(PurchTable, InvoiceAccount), fieldStr(VendInvoiceInfoLine, InvoiceAccount));

        // TableRefId is a required field, but needs to be set per PO.
        // This value (TableRefId = PurchId) will be used to find the new invoice lines after the insert_recordset
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchTable, PurchId), fieldStr(PurchTable, PurchId), fieldStr(VendInvoiceInfoLine, TableRefId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldMappingsPurchParmUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds <c>PurchParmUpdate</c> table specific fields to the insert field mappings.
    /// </summary>
    /// <param name = "_queryBuildDataSource">The given <c>QueryBuildDataSource</c> used for the field mapping.</param>
    /// <param name = "_queryBuildFieldList">The given <c>QueryBuildFieldList</c> instance in which to add the field mapping.</param>
    /// <param name = "_insertRecordsetMap">The given <c>Map</c> instance in which to add the field mapping.</param>
    protected void addFieldMappingsPurchParmUpdate(QueryBuildDataSource _queryBuildDataSource, QueryBuildFieldList _queryBuildFieldList, Map _insertRecordsetMap)
    {
        int dataSourceUniqueId = _queryBuildDataSource.uniqueId();

        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(PurchParmUpdate, ParmId), fieldStr(PurchParmUpdate, ParmId), fieldStr(VendInvoiceInfoLine, ParmId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldMappingsVendPackingSlipTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds <c>VendPackingSlipTrans</c> table specific fields to the insert field mappings.
    /// </summary>
    /// <param name = "_queryBuildDataSource">The given <c>QueryBuildDataSource</c> used for the field mapping.</param>
    /// <param name = "_queryBuildFieldList">The given <c>QueryBuildFieldList</c> instance in which to add the field mapping.</param>
    /// <param name = "_insertRecordsetMap">The given <c>Map</c> instance in which to add the field mapping.</param>    
    protected void addFieldMappingsVendPackingSlipTrans(QueryBuildDataSource _queryBuildDataSource, QueryBuildFieldList _queryBuildFieldList, Map _insertRecordsetMap)
    {
        int dataSourceUniqueId = _queryBuildDataSource.uniqueId();
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, RecId), fieldStr(VendPackingSlipTrans, RecId), fieldStr(VendInvoiceInfoSubLine, JournalRefRecId));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, TableId), fieldStr(VendPackingSlipTrans, TableId), fieldStr(VendInvoiceInfoSubLine, JournalRefTableId));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, InventTransId), fieldStr(VendPackingSlipTrans, InventTransId), fieldStr(VendInvoiceInfoSubLine, DocumentId));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, Qty), fieldStr(VendPackingSlipTrans, Qty), fieldStr(VendInvoiceInfoSubLine, ReceiveNow));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, InventQty), fieldStr(VendPackingSlipTrans, InventQty), fieldStr(VendInvoiceInfoSubLine, InventNow));
        this.addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, PdsCWQty), fieldStr(VendPackingSlipTrans, PdsCWQty), fieldStr(VendInvoiceInfoSubLine, PdsCWInventNow));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmLinesAndTable</Name>
				<Source><![CDATA[
    protected void createParmLinesAndTable()
    {
        Query query = chooseLines.query();
        Map insertRecordsetMap = new Map(Types::String,Types::Container);
        QueryBuildDataSource qbds, qbds_ParmUpdate;
        QueryBuildFieldList qbfl;
        int dataSourceUniqueId;

        VendInvoiceInfoLine vendInvoiceInfoLine, vendInvoiceInfoLineUpdate;
        VendInvoiceInfoSubLine vendInvoiceInfoSubLine;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        PurchTable localPurchTable;
        PurchLine localPurchLine;
        SourceDocumentLine sourceDocumentLine;
        TradeLineRefId tableRefId;
        ParmId currentParmId = this.parmId();

        // If the PO datasource is disabled, return as no new lines will be created
        if ((query.dataSourceTable(tableNum(PurchTable)) && !query.dataSourceTable(tableNum(PurchTable)).enabled())||
            (this.parmCallerTable().TableId == tableNum(VendInvoiceInfoTable) && datasourceRecordsPacked))
        {
            return;
        }

        if (!this.allowSetBasedLogic())
        {
            super();
            return;
        }

        insertHeaderInTempTable = true;

        // Clear all selection fields so mapping for insert recordset is guaranteed correct
        query.clearAllFields();

        // Map fields from PurchLine
        qbds = query.dataSourceTable(tableNum(PurchLine));
        qbfl = qbds.fields();

        this.addFieldMappingsPurchLine(qbds, qbfl, insertRecordsetMap);

        if (purchParmUpdate.SpecQty == PurchUpdate::PackingSlip)
        {
            // Disable the packingslip datasource so only one invoice line is created for PO lines that have multiple packing slips
            query.dataSourceTable(tableNum(VendPackingSlipTrans)).enabled(false);
        }

        // Map fields from PurchTable
        qbds = query.dataSourceTable(tableNum(PurchTable));
        qbfl = qbds.fields();

        this.addFieldMappingsPurchTable(qbds, qbfl, insertRecordsetMap);

        qbds = query.dataSourceTable(tableNum(PurchLine));
        qbds_ParmUpdate = qbds.addDataSource(tableNum(PurchParmUpdate));
        qbds_ParmUpdate.enabled(true);
        qbds_ParmUpdate.joinMode(JoinMode::InnerJoin);
        qbds_ParmUpdate.fetchMode(QueryFetchMode::One2One);
        qbds_ParmUpdate.addRange(fieldNum(PurchParmUpdate, ParmId)).value(queryValue(currentParmId));
        qbfl = qbds_ParmUpdate.fields();

        this.addFieldMappingsPurchParmUpdate(qbds_ParmUpdate, qbfl, insertRecordsetMap);

        // Insert the data as an insert recordset
        vendInvoiceInfoLine.skipDataMethods(true);
        vendInvoiceInfoLine.skipDatabaseLog(true);
        vendInvoiceInfoLine.skipEvents(true);
        Query::insert_recordset(vendInvoiceInfoLine, insertRecordsetMap, query);

        if (this.shouldCreateVendInvoiceInfoSubLine())
        {
            query.clearAllFields();
            query.dataSourceTable(tableNum(PurchParmUpdate)).enabled(false);
            insertRecordsetMap = new Map(Types::String,Types::Container);

            // Map fields from VendPackingSlipTrans
            qbds = query.dataSourceTable(tableNum(VendPackingSlipTrans));
            qbds.enabled(true);
            qbds.joinMode(JoinMode::InnerJoin);
            qbfl = qbds.fields();

            this.addFieldMappingsVendPackingSlipTrans(qbds, qbfl, insertRecordsetMap);

            qbds_ParmUpdate = qbds.addDataSource(tableNum(PurchParmUpdate));
            qbds_ParmUpdate.enabled(true);
            qbds_ParmUpdate.joinMode(JoinMode::InnerJoin);
            qbds_ParmUpdate.fetchMode(QueryFetchMode::One2One);
            qbds_ParmUpdate.addRange(fieldNum(PurchParmUpdate, ParmId)).value(queryValue(currentParmId));
            qbfl = qbds_ParmUpdate.fields();

            this.addFieldMappingsPurchParmUpdate(qbds_ParmUpdate, qbfl, insertRecordsetMap);

            vendInvoiceInfoSubLine.skipDataMethods(true);
            vendInvoiceInfoSubLine.skipDatabaseLog(true);
            vendInvoiceInfoSubLine.skipEvents(true);
            Query::insert_recordset(vendInvoiceInfoSubLine, insertRecordsetMap, query);

            qbds.joinMode(JoinMode::OuterJoin);

            this.defaultQuantityPackingSlip();
        }
        else if (purchParmUpdate.SpecQty == PurchUpdate::All)
        {
            this.defaultQuantityAll();
        }

        // Update values that need to be set per PO
        while select OrigPurchId, sum(ReceiveNow) from vendInvoiceInfoLine
            group by vendInvoiceInfoLine.OrigPurchId
            where vendInvoiceInfoLine.OrigPurchId == vendInvoiceInfoLine.TableRefId &&
                  vendInvoiceInfoLine.ParmId == currentParmId
        {
            localPurchTable = PurchTable::find(vendInvoiceInfoLine.OrigPurchId);

            if (!this.skipMayJournalBePosted() && !this.doMayJournalBePosted(localPurchTable))
            {
                // Do not create invoice lines or header if PO cannot be invoiced
                vendInvoiceInfoLineUpdate.skipDataMethods(true);
                vendInvoiceInfoLineUpdate.skipDatabaseLog(true);
                vendInvoiceInfoLineUpdate.skipEvents(true);
                vendInvoiceInfoLineUpdate.skipDeleteActions(true);
                vendInvoiceInfoLineUpdate.skipDeleteMethod(true);
                delete_from vendInvoiceInfoLineUpdate
                where vendInvoiceInfoLineUpdate.OrigPurchId == vendInvoiceInfoLine.OrigPurchId &&
                      vendInvoiceInfoLineUpdate.TableRefId == vendInvoiceInfoLine.OrigPurchId &&
                      vendInvoiceInfoLineUpdate.ParmId == currentParmId;

                continue;
            }

            tableRefId = this.getTableRefId(vendInvoiceInfoLine);

            // Set fields that don't default from PurchLine/PurchTable
            vendInvoiceInfoLineUpdate.skipDataMethods(true);
            vendInvoiceInfoLineUpdate.skipDatabaseLog(true);
            vendInvoiceInfoLineUpdate.skipEvents(true);
            update_recordset vendInvoiceInfoLineUpdate setting
                TableRefId = tableRefId,
                DocumentOrigin = this.parmDocumentOrigin()
            where vendInvoiceInfoLineUpdate.OrigPurchId == vendInvoiceInfoLine.OrigPurchId &&
                  vendInvoiceInfoLineUpdate.TableRefId == vendInvoiceInfoLine.OrigPurchId &&
                  vendInvoiceInfoLineUpdate.ParmId == currentParmId;

            // Create the invoice header if:
            //      1) There is at least one line with a non-zero quantity, or
            //      2) All lines are zero quantity, but there are no pending invoices, or
            //      3) All lines are zero quantity, there are pending invoices, but a new invoice would be created for a different SpecQty
            select firstonly ReceiveNow from vendInvoiceInfoLineUpdate
                where vendInvoiceInfoLineUpdate.TableRefId == tableRefId
                   && vendInvoiceInfoLineUpdate.ParmId == currentParmId
                   && vendInvoiceInfoLineUpdate.ReceiveNow != 0;

            if (vendInvoiceInfoLineUpdate.ReceiveNow ||
                (pendingInvoices != null && (!pendingInvoices.exists(vendInvoiceInfoLine.OrigPurchId) ||
                this.hasQtyToInvoice(vendInvoiceInfoLine.OrigPurchId, purchParmUpdate.SpecQty))) || // line would be created for different SpecQty
                this.hasRetainedBalance(vendInvoiceInfoLine.OrigPurchId))
            {
                if (activityContext) activityContext.addCustomProperty(VendInvoiceInstrumentationConstants::VendInvoiceInfoIsCreation, 'True');

                // Now that we know we are creating an invoice, create the source document header and lines
                sourceDocumentHeaderRecId = this.insertSourceDocumentHeader(tableRefId, this.transDate());

                this.createSourceDocumentLine(tableRefId, sourceDocumentHeaderRecId);

                if (!this.parmParmTableNum())
                {
                    currentInterCompanyInvoiceNum = this.interCompanyInvoiceNum(localPurchTable);
                }

                // Each invoice header will be added to a temp table, and inserted in the database after line processing is done
                // The fact that the header is not in the database yet will be utilized to find invoice lines below
                this.createParmTable(localPurchTable, null, tableRefId);
            }
        }

        // Delete lines without a quantity to invoice
        this.deleteZeroQuantityLines();

        // Default RemainBefore/RemainAfter quantities
        this.defaultRemainingQuantities();

        // setting PurchaseLineLineNumber and PurchLineRecId here, as a source field couldn't be used twice in initial insert
        vendInvoiceInfoLineUpdate.skipDataMethods(true);
        vendInvoiceInfoLineUpdate.skipDatabaseLog(true);
        vendInvoiceInfoLineUpdate.skipEvents(true);
        if (VendInvoiceOptimizeUpdatePurchLineNumberQueryFlight::instance().isEnabled())
        {
            VendInvoicePurchLineTmp vendInvoicePurchTmp;

            // Get all line by ParmId regardless of PurchLineRecId
            insert_recordset vendInvoicePurchTmp(
                VendInvoiceLineRecId,
                VendInvoiceLinePurchLineRecId,
                PurchLineRecId,
                PurchLineNumber
            )
            select RecId, PurchLineRecId from vendInvoiceInfoLineUpdate
                where vendInvoiceInfoLineUpdate.ParmId == currentParmId
            join RecId, LineNumber from localPurchLine
                where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId;

            // Update by joining on RecId and apply the PurchLineRecId filter on temp table
            update_recordset vendInvoiceInfoLineUpdate setting
                PurchaseLineLineNumber = vendInvoicePurchTmp.PurchLineNumber,
                PurchLineRecId = vendInvoicePurchTmp.PurchLineRecId
            join vendInvoicePurchTmp
                where vendInvoiceInfoLineUpdate.RecId == vendInvoicePurchTmp.VendInvoiceLineRecId
                    && vendInvoicePurchTmp.VendInvoiceLinePurchLineRecId == 0;
        }
        else
        {
            update_recordset vendInvoiceInfoLineUpdate setting
                PurchaseLineLineNumber = localPurchLine.LineNumber,
                PurchLineRecId = localPurchLine.RecId
            where vendInvoiceInfoLineUpdate.ParmId == currentParmId &&
                  vendInvoiceInfoLineUpdate.PurchLineRecId == 0
            join localPurchLine
                where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId;
        }

        // Create invoice line project records
        this.createLineProject();

        // Create invoice line fixed asset records for PO lines
        this.createLineAsset();

        // Update invoice line 1099 fields
        this.defaultLine1099();

        // Create invoice matching line records
        this.createInvoiceMatchingLine();

        // Update country-specific data
        this.defaultCountryRegionData();

        if (PublicSectorUtils::isBudgetReservationEnabled())
        {
            this.defaultBudgetReservation();
        }

        // Update values that cannot be done in set-based logic
        while select forupdate vendInvoiceInfoLine
        where vendInvoiceInfoLine.ParmId == currentParmId
        notexists join vendInvoiceInfoTable
            where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLine.ParmId
               && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLine.TableRefId
        {
            this.defaultLineAmount(vendInvoiceInfoLine);
            numberOfLines++;
        }

        if (activityContext) {
            activityContext.addCustomProperty(VendInvoiceInstrumentationConstants::VendInvoiceInfoMaginitudeOfLineNumber, ApplicationCommonInstrumentationMagnitude::log10Magnitude(numberOfLines));
        }

        this.createInvoiceHeaderFromTempTable();
    
        this.defaultHeaderCountryRegionData();

        insertHeaderInTempTable = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateVendInvoiceInfoSubLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the vendor invoice info subline should be created.
    /// </summary>
    /// <returns>
    ///     true if the vendor invoice info subline should be created; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean shouldCreateVendInvoiceInfoSubLine()
    {
        return purchParmUpdate.SpecQty == PurchUpdate::PackingSlip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmTable</Name>
				<Source><![CDATA[
    protected Common createParmTable(Common _purchTable,
                                    Common _purchLine,
                                    TradeLineRefId _tableRefId,
                                    boolean _skipParmSubTable = false,
                                    boolean _hold = false,
                                    boolean _notApproved = false,
                                    Num _purchSummaryFormLetterId = '',
                                    VendPostingProfile _postingProfile = '',
                                    InventProfileType_RU _inventProfileType = InventProfileType_RU::General)
    {
        // <GEERU>
        PurchTable localPurchTable = _purchTable as PurchTable;
        PurchLine localPurchLine = _purchLine as PurchLine;
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceInfoTable_RU vendInvoiceInfoTable_RU;
        // <GEEU>
        boolean countryRegion_LTLV = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLT,#isoLV]);
        VendInvoiceInfoTable_W vendInvoiceInfoTable_W;
        // </GEEU>
        // <GEERU>
        if (countryRegion_RU)
        {
            vendInvoiceInfoTable = super(_purchTable,
                                        _purchLine,
                                        _tableRefId,
                                        _skipParmSubTable,
                                        false,
                                        false,
                                        '',
                                        prmisDefault(_postingProfile) ?
                                        this.postingProfile_RU(localPurchLine.purchLine_W().PostingProfile_RU, localPurchTable.PostingProfile) :
                                        _postingProfile,
                                        prmisDefault(_inventProfileType) ?
                                        this.inventProfileType_RU(localPurchLine) :
                                        _inventProfileType);

            vendInvoiceInfoTable.Storno = storno;

            if (fixedExchRate && exchRate)
            {
                vendInvoiceInfoTable.FixedExchRate = fixedExchRate;
                vendInvoiceInfoTable.ExchRate = exchRate;
                vendInvoiceInfoTable.setReportingCurrencyFixedExchangeRateFromAccounting();
            }

            if (usePostingProfileFromContract)
            {
                vendInvoiceInfoTable.PostingProfile = postingProfile;

                vendInvoiceInfoTable_RU = vendInvoiceInfoTable.vendInvoiceInfoTable_RU();
                vendInvoiceInfoTable_RU.InventProfileType_RU = inventProfileType;
                vendInvoiceInfoTable.packVendInvoiceInfoTable_RU(vendInvoiceInfoTable_RU);
            }
        }
        else
        {
            // </GEERU>
            vendInvoiceInfoTable = super(_purchTable, _purchLine, _tableRefId, _skipParmSubTable);
            // <GEERU>
        }
        // </GEERU>

        if (countryRegion_LTLV && !insertHeaderInTempTable)
        {
            vendInvoiceInfoTable_W = vendInvoiceInfoTable.vendInvoiceInfoTable_W();
            vendInvoiceInfoTable_W.DocAutoNumbering_LT = localPurchTable.InvoiceAutoNumbering_LT;
            vendInvoiceInfoTable.packVendInvoiceInfoTable_W(vendInvoiceInfoTable_W);
        }

        if (this.parmProcessAdditional())
        {
            activeInvoiceList.appendList(this.getActiveList(vendInvoiceInfoTable.PurchId, this.parmId()));
        }

        return vendInvoiceInfoTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentDisbursementTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>VendInvoiceInfo_PaymentDisbursement</c> table record based on the data provided
    /// in the <c>VendInvoiceInfoTable</c> table and in the <c>VendTable</c> table.
    /// </summary>
    /// <param name="_vendInvoiceInfoTable">
    ///  The <c>VendInvoiceInfoTable</c> table record containing the data to be copied.
    /// </param>
    protected void createPaymentDisbursementTable(VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        VendBankAccountId bankAccount;
        VendInvoiceInfo_PaymentDisbursement paymentDisbursement;

        bankAccount = VendTable::find(_vendInvoiceInfoTable.InvoiceAccount).BankAccount;

        if (bankAccount)
        {
            ttsbegin;
            paymentDisbursement.ParmId = _vendInvoiceInfoTable.ParmId;
            paymentDisbursement.TableRefId = _vendInvoiceInfoTable.TableRefId;
            paymentDisbursement.VendAccount = _vendInvoiceInfoTable.InvoiceAccount;
            paymentDisbursement.VendBankAccountID = bankAccount;
            paymentDisbursement.PercentageAllocation = 100;
            paymentDisbursement.insert();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSourceDocumentLine</Name>
				<Source><![CDATA[
    protected void createSourceDocumentLine(TradeLineRefId _tableRefId, RecId _sourceDocumentHeaderRecId)
    {
        SysRecIdSequence sysRecIdSequence = appl.sysRecIdSequence();
        VendInvoiceInfoLine vendInvoiceInfoLineUpdate;
        SourceDocumentLine sourceDocumentLine;

        if (sysRecIdSequence.isRecidSuspended(tableNum(SourceDocumentLine)))
        {
            sysRecIdSequence.removeRecIdSuspension(tableNum(SourceDocumentLine));
        }

        // Create a SourceDocumentLine record for each non-zero invoice line
        // Set the actual SourceDocumentHeader; temporarily use ParentSourceDocumentLine to join to a unique VendInvoiceInfoLine
        sourceDocumentLine.skipDataMethods(true);
        sourceDocumentLine.skipDatabaseLog(true);
        sourceDocumentLine.skipEvents(true);
        insert_recordset sourceDocumentLine (SourceDocumentHeader, ParentSourceDocumentLine)
        select _sourceDocumentHeaderRecId, RecId from vendInvoiceInfoLineUpdate
            where vendInvoiceInfoLineUpdate.TableRefId == _tableRefId
                && vendInvoiceInfoLineUpdate.ReceiveNow != 0;

        if (Project::Enabled())
        {
            insert_recordset sourceDocumentLine (SourceDocumentHeader, ParentSourceDocumentLine)
            select _sourceDocumentHeaderRecId, RecId from vendInvoiceInfoLineUpdate
                where vendInvoiceInfoLineUpdate.TableRefId == _tableRefId
                    && vendInvoiceInfoLineUpdate.ReceiveNow == 0
                    && vendInvoiceInfoLineUpdate.PSARetainageBalance != 0;
        }

        // Update each non-zero invoice line with its corresponding SourceDocumentLine
        vendInvoiceInfoLineUpdate.skipDataMethods(true);
        vendInvoiceInfoLineUpdate.skipDatabaseLog(true);
        vendInvoiceInfoLineUpdate.skipEvents(true);
        update_recordset vendInvoiceInfoLineUpdate setting
            SourceDocumentLine = sourceDocumentLine.RecId
        where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
           && vendInvoiceInfoLineUpdate.TableRefId == _tableRefId
        join sourceDocumentLine
            where sourceDocumentLine.ParentSourceDocumentLine == vendInvoiceInfoLineUpdate.RecId &&
                  sourceDocumentLine.SourceDocumentHeader == _sourceDocumentHeaderRecId;

        // Update SourceDocumentLine values that couldn't be set on insert
        // Reset the ParentSourceDocumentLine value, now that we have set each invoice line's SourceDocumentLine
        var stateContainer = [conNull(), conNull(), conNull()];

        update_recordset sourceDocumentLine setting
            SourceRelationType = tableNum(VendInvoiceInfoLine),
            TypeEnumName = enumStr(SourceDocumentLine_VendorInvoice),
            TypeEnumValue = SourceDocumentLine_VendorInvoice::VendorInvoiceLine,
            AccountingStatus = SourceDocumentLineAccountingStatus::Draft,
            ExchangeRateDate = this.transDate(),
            StateContainer = stateContainer,
            ParentSourceDocumentLine = 0
        where sourceDocumentLine.SourceDocumentHeader == _sourceDocumentHeaderRecId
        join vendInvoiceInfoLineUpdate
            where vendInvoiceInfoLineUpdate.SourceDocumentLine == sourceDocumentLine.RecId &&
                    vendInvoiceInfoLineUpdate.TableRefId == _tableRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVendInvoiceLineFromPurchAgrLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize <c>VendInvoiceInfoLine</c> table record by calling initFromPurchAgreementLine() method from passed <c>AgreementLine</c> record.
    /// </summary>
    /// <param name="_agreementLine">
    /// An <c>AgreementLine</c> table record used to initialize the new <c>VendInvoiceInfoLine</c> table record.
    /// </param>
    /// <param name="_tableRef">
    /// The table reference of the new <c>VendInvoiceInfoLine</c> table record.
    /// </param>
    /// <returns>
    /// true if the <c>VendInvoiceInfoLine</c> table record was created; otherwise, false.
    /// </returns>
    protected boolean createVendInvoiceLineFromPurchAgrLine(AgreementLine _agreementLine, TradeLineRefId _tableRef)
    {
        VendInvoiceInfoLine vendInvoiceInfoLine;
        FiscalCalendarYear fiscalCalendarYear;
        PurchCommitmentLine_PSN purchCommitmentLine_PSN;
        PurchCommitmentHeader_PSN purchCommitmentHeader_PSN;
        SourceDocumentLine sourceDocumentLine;
        boolean allowInsert;
        VendInvoiceLineForeignTradeCategory vendInvoiceLineForeignTradeCategory;

        if (_agreementLine.ExpirationDate < this.parmExternalDefaultedParmTable().TransDate)
        {
            return false;
        }

        allowInsert = vendInvoiceInfoLine.initFromPurchAgreementLine(_agreementLine);

        if (!allowInsert)
        {
            return false;
        }

        //Retrieve all commitment lines associated with the current agreement, and if there is 1 and only 1 associated with the agreement then default that on the line.
        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            fiscalCalendarYear = FiscalCalendarYear::findYearByCalendarDate(Ledger::fiscalCalendar(CompanyInfo::current()), this.parmExternalDefaultedParmTable().TransDate);

            select count (RecId), PurchCommitmentHeader_PSN, SourceDocumentLine from purchCommitmentLine_PSN
                exists join purchCommitmentHeader_PSN
                exists join sourceDocumentLine
                    where purchCommitmentLine_PSN.AgreementLine == _agreementLine.RecId &&
                        purchCommitmentLine_PSN.LineDate >= fiscalCalendarYear.StartDate &&
                        purchCommitmentLine_PSN.LineDate <= fiscalCalendarYear.EndDate &&
                        purchCommitmentHeader_PSN.RecId == purchCommitmentLine_PSN.PurchCommitmentHeader_PSN &&
                        purchCommitmentHeader_PSN.DocumentStatus == PurchCommitmentDocumentStatus_PSN::Complete &&
                        sourceDocumentLine.RecId == purchCommitmentLine_PSN.SourceDocumentLine &&
                        sourceDocumentLine.AccountingStatus != SourceDocumentLineAccountingStatus::Finalized;

            if (purchCommitmentLine_PSN.RecId == 1)
            {
                select RecId from purchCommitmentLine_PSN
                    exists join purchCommitmentHeader_PSN
                    exists join sourceDocumentLine
                        where purchCommitmentLine_PSN.AgreementLine == _agreementLine.RecId &&
                            purchCommitmentLine_PSN.LineDate >= fiscalCalendarYear.StartDate &&
                            purchCommitmentLine_PSN.LineDate <= fiscalCalendarYear.EndDate &&
                            purchCommitmentHeader_PSN.RecId == purchCommitmentLine_PSN.PurchCommitmentHeader_PSN &&
                            purchCommitmentHeader_PSN.DocumentStatus == PurchCommitmentDocumentStatus_PSN::Complete &&
                            sourceDocumentLine.RecId == purchCommitmentLine_PSN.SourceDocumentLine &&
                            sourceDocumentLine.AccountingStatus != SourceDocumentLineAccountingStatus::Finalized;

                vendInvoiceInfoLine.PurchCommitmentLine_PSN = purchCommitmentLine_PSN.RecId;
            }
        }

        vendInvoiceInfoLine.ParmId = this.parmId();
        vendInvoiceInfoLine.TableRefId = _tableRef;
        vendInvoiceInfoLine.Ordering = this.parmDocumentStatus();
        this.insertParmLine(vendInvoiceInfoLine);

        if (vendInvoiceInfoLine)
        {
            vendInvoiceLineForeignTradeCategory.VendInvoiceInfoLine = vendInvoiceInfoLine.RecId;
            vendInvoiceLineForeignTradeCategory.insert();

            this.insertParmLine_Asset(VendInvoiceInfoLine_Asset::createVendInvoiceInfoLine_Asset(vendInvoiceInfoLine));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVendInvoiceMatchingLineForServices</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a record in the <c>VendInvoiceMatchingLine</c> table from a <c>PurchLine</c> record.
    /// </summary>
    /// <param name="_vendInvoiceInfoLine">A <c>VendInvoiceInfoLine</c> record with which the new <c>VendInvoiceMatchingLine</c> record will be associated.</param>
    /// <param name="_purchLine">The <c>PurchLine</c> record where the expected values will be found.</param>
    /// <param name="_varianceApproved">The <c>NoYes::Yes</c> enumeration value if the invoice has been approved to post with variances; otherwise, the <c>NoYes::No</c> enumeration value.</param>
    /// <param name="_writeRecord">Indicates whether or not to write the record to the database after populating the table buffer with values.</param>
    /// <returns>An initialized or updated <c>VendInvoiceMatchingLine</c> table buffer.</returns>
    /// <remarks>This method should only be used to attach a <c>VendInvoiceMatchingLine</c> record to an existing <c>VendInvoiceInfoLine</c> record.</remarks>
    public static VendInvoiceMatchingLine createVendInvoiceMatchingLineForServices(VendDocumentLineMap _vendInvoiceInfoLine,
        PurchLine _purchLine,
        NoYes _varianceApproved = NoYes::No,
        boolean _writeRecord = false)
    {
        VendInvoiceMatchingLine vendInvoiceMatchingLine;

        Debug::assert(_vendInvoiceInfoLine.TableId == tableNum(VendInvoiceInfoLine));
        
        if ((_vendInvoiceInfoLine.TableId != 0 ) && (_vendInvoiceInfoLine.RecId != 0) && (_purchLine.RecId != 0))
        {
            if (VendParameters::find().editUseInvoiceMatching() == NoYes::Yes)
            {
                vendInvoiceMatchingLine = VendInvoiceMatchingLine::find(_vendInvoiceInfoLine.TableId, _vendInvoiceInfoLine.RecId, true);
                if (!vendInvoiceMatchingLine.RecId || _varianceApproved == NoYes::No)
                {
                    vendInvoiceMatchingLine.initExpectedValues(_purchLine, _vendInvoiceInfoLine);
                    vendInvoiceMatchingLine.RefTableId = _vendInvoiceInfoLine.TableId;
                    vendInvoiceMatchingLine.RefRecId = _vendInvoiceInfoLine.RecId;

                    if (_writeRecord)
                    {
                        vendInvoiceMatchingLine.write();
                    }
                }
            }
        }

        return vendInvoiceMatchingLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultCountryRegionData</Name>
				<Source><![CDATA[
    protected void defaultCountryRegionData()
    {
        VendInvoiceInfoLine vendInvoiceInfoLineUpdate;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceInfoLine_W invoiceLine_W;
        VendTable vendTable;
        PurchLine localPurchLine;

        if (TaxWithholdingGlobalFeature::isExtendedWHTSupportedInCountryRegionOrParamEnabled() && !TaxWithholdParameters::find().EnableCalcWHTInInvoice)
        {
            vendInvoiceInfoLineUpdate.skipDataMethods(true);
            vendInvoiceInfoLineUpdate.skipDatabaseLog(true);
            vendInvoiceInfoLineUpdate.skipEvents(true);
            update_recordset vendInvoiceInfoLineUpdate setting
                TaxWithholdGroup = vendTable.TaxWithholdGroup
            where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
            join vendTable
                where vendTable.AccountNum == vendInvoiceInfoLineUpdate.OrderAccount
            notexists join vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                   && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#VendInvLine_W))
        {
            invoiceLine_W.skipDataMethods(true);
            invoiceLine_W.skipDatabaseLog(true);
            invoiceLine_W.skipEvents(true);
            insert_recordset invoiceLine_W
                (VendInvoiceInfoLine, DiotOperationType)
            select RecId from vendInvoiceInfoLineUpdate
                where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
            join OperationType_MX from localPurchLine
                where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
            notexists join vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                   && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
            {
                PurchLine_W purchLine_W;

                update_recordSet invoiceLine_W setting
                    WithholdingTypeCode_MX = purchLine_W.WithholdingTypeCode_MX
                join WithholdingTypeCode_MX from purchLine_W
                exists join vendInvoiceInfoLineUpdate
                    where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                        && vendInvoiceInfoLineUpdate.RecId == invoiceLine_W.VendInvoiceInfoLine
                        && vendInvoiceInfoLineUpdate.PurchLineRecId == purchLine_W.PurchLine
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                        && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultHeaderCountryRegionData</Name>
				<Source><![CDATA[
    protected void defaultHeaderCountryRegionData()
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        SysRecIdSequence sysRecIdSequence = appl.sysRecIdSequence();

        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#VendInv_W) || TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            PurchTable localPurchTable;
            VendInvoiceInfoTable_W localVendInvoiceInfoTable_W;

            if (sysRecIdSequence.isRecidSuspended(tableNum(VendInvoiceInfoTable_W)))
            {
                sysRecIdSequence.removeRecIdSuspension(tableNum(VendInvoiceInfoTable_W));
            }
    
            localVendInvoiceInfoTable_W.skipDataMethods(true);
            localVendInvoiceInfoTable_W.skipDatabaseLog(true);
            localVendInvoiceInfoTable_W.skipEvents(true);
    
            if (TaxGSTFeatureChecker_MY::isCountryRegionMY())
            {
                PurchTable_W purchTable_W;

                insert_recordset localVendInvoiceInfoTable_W
                    (VendInvoiceInfoTable, InvoiceType_MY)
                select RecId from vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == this.parmId()
                        && vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New
                join InvoiceType_MY from purchTable_W
                    exists join localPurchTable
                        where localPurchTable.PurchId == vendInvoiceInfoTable.PurchId
                           && localPurchTable.RecId == purchTable_W.PurchTable;
            }
            else if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLT,#isoLV]))
            {
                insert_recordset localVendInvoiceInfoTable_W
                    (VendInvoiceInfoTable, DocAutoNumbering_LT)
                select RecId from vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == this.parmId()
                        && vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New
                join InvoiceAutoNumbering_LT from localPurchTable
                    where localPurchTable.PurchId == vendInvoiceInfoTable.PurchId;
            }
            else
            {
                boolean inserted = false;
                VendInvoiceInfoTable_W existedVendInvoiceInfoTable_W;

                if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
                {
                    TaxGroup taxGroup;

                    if (purchTable || !TaxDateOfVATRegisterFilledFlight::instance().isEnabled())
                    {
                        taxGroup = purchTable.TaxGroup;
                    }
                    else
                    {
                        VendInvoiceInfoTable localVendInvoiceInfoTable;

                        select firstonly taxGroup from localPurchTable
                            join RecId from localVendInvoiceInfoTable
                                where localVendInvoiceInfoTable.PurchId == localPurchTable.PurchId
                                    && localVendInvoiceInfoTable.ParmId == this.parmId()
                                    && localVendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New;

                        taxGroup = localPurchTable.TaxGroup;
                    }

                    switch (TaxGroupHeading::find(taxGroup).FillVATDueDate_W)
                    {
                        case FillVATDueDate_W::DocumentDate:
                            if (VatDueDateFeature::isEnabled())
                            {
                                insert_recordset localVendInvoiceInfoTable_W
                                    (VendInvoiceInfoTable, VATDueDate_W)
                                select RecId, DocumentDate from vendInvoiceInfoTable
                                    where vendInvoiceInfoTable.ParmId == this.parmId()
                                        && vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New
                                    notexists join existedVendInvoiceInfoTable_W
                                        where existedVendInvoiceInfoTable_W.VendInvoiceInfoTable == vendInvoiceInfoTable.RecId;

                                inserted = true;
                            }
                            break;

                        case FillVATDueDate_W::PostingDate:
                            insert_recordset localVendInvoiceInfoTable_W
                                (VendInvoiceInfoTable, VATDueDate_W)
                            select RecId, TransDate from vendInvoiceInfoTable
                                where vendInvoiceInfoTable.ParmId == this.parmId()
                                    && vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New
                                notexists join existedVendInvoiceInfoTable_W
                                    where existedVendInvoiceInfoTable_W.VendInvoiceInfoTable == vendInvoiceInfoTable.RecId;

                            inserted = true;
                            break;

                        case FillVATDueDate_W::LastDeliveryDate:
                            if (VatDueDateFeature::isEnabled())
                            {
                                TransDate lastDeliveryDate = this.getLastDeliveryDate();
                                if (lastDeliveryDate)
                                {
                                    insert_recordset localVendInvoiceInfoTable_W
                                        (VendInvoiceInfoTable, VATDueDate_W)
                                    select RecId, lastDeliveryDate from vendInvoiceInfoTable
                                        where vendInvoiceInfoTable.ParmId == this.parmId()
                                            && vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New
                                    notexists join existedVendInvoiceInfoTable_W
                                        where existedVendInvoiceInfoTable_W.VendInvoiceInfoTable == vendInvoiceInfoTable.RecId;
                                }
                                else
                                {
                                    insert_recordset localVendInvoiceInfoTable_W
                                        (VendInvoiceInfoTable, VATDueDate_W)
                                    select RecId, TransDate from vendInvoiceInfoTable
                                        where vendInvoiceInfoTable.ParmId == this.parmId()
                                            && vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New
                                        notexists join existedVendInvoiceInfoTable_W
                                            where existedVendInvoiceInfoTable_W.VendInvoiceInfoTable == vendInvoiceInfoTable.RecId;
                                }

                                inserted = true;
                            }
                            break;

                        case FillVATDueDate_W::Customized:
                            while select RecId, TransDate, DocumentDate from vendInvoiceInfoTable
                                where vendInvoiceInfoTable.ParmId == this.parmId()
                                    && vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New
                                notexists join existedVendInvoiceInfoTable_W
                                    where existedVendInvoiceInfoTable_W.VendInvoiceInfoTable == vendInvoiceInfoTable.RecId
                            {
                                localVendInvoiceInfoTable_W.VendInvoiceInfoTable = VendInvoiceInfoTable.RecId;
                                localVendInvoiceInfoTable_W.VatDueDate_W = TaxVATDueDateUtility::calculateVATDueDateCustomized(
                                    TaxGroupHeading::find(purchTable.TaxGroup),
                                    vendInvoiceInfoTable.TransDate,
                                    vendInvoiceInfoTable.DocumentDate);
                                recordVendInvoiceInfoTable_W.add(localVendInvoiceInfoTable_W);
                                inserted = true;
                            }
                            recordVendInvoiceInfoTable_W.insertDatabase();
                            break;

                        default:
                            break;
                    }
                }

                if (!inserted)
                {
                    insert_recordset localVendInvoiceInfoTable_W
                        (VendInvoiceInfoTable)
                    select RecId from vendInvoiceInfoTable
                        where vendInvoiceInfoTable.ParmId == this.parmId()
                            && vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New
                        notexists join existedVendInvoiceInfoTable_W
                            where existedVendInvoiceInfoTable_W.VendInvoiceInfoTable == vendInvoiceInfoTable.RecId;
                }
            }

            // Set the default value of localization fields on vendor invoice,
            // when the vendor invoice is converted from purchase order.
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
            {
                if (TaxPolishUseDefaultReceiveDocumentDateFlight::instance().isEnabled())
                {
                    TransDate receiptDate = this.transDate();
                    update_recordset localVendInvoiceInfoTable_W
                    setting
                        TaxPeriodPaymentCode_PL = localPurchTable.TaxPeriodPaymentCode_PL,
                        PurchReceiptDate_W = receiptDate
                        where localVendInvoiceInfoTable_W.PurchReceiptDate_W == dateNull()
                    join vendInvoiceInfoTable
                        where vendInvoiceInfoTable.ParmId == this.parmId()
                            && vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New
                            && vendInvoiceInfoTable.RecId == localVendInvoiceInfoTable_W.VendInvoiceInfoTable
                    join TaxPeriodPaymentCode_PL from localPurchTable
                        where localPurchTable.PurchId == vendInvoiceInfoTable.PurchId;
                }
                else
                {
                    update_recordset localVendInvoiceInfoTable_W
                    setting TaxPeriodPaymentCode_PL = localPurchTable.TaxPeriodPaymentCode_PL
                    join vendInvoiceInfoTable
                        where vendInvoiceInfoTable.ParmId == this.parmId()
                            && vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New
                            && vendInvoiceInfoTable.RecId == localVendInvoiceInfoTable_W.VendInvoiceInfoTable
                    join TaxPeriodPaymentCode_PL from localPurchTable
                        where localPurchTable.PurchId == vendInvoiceInfoTable.PurchId;
                }
            }
        }
    
        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU))
        {
            VendInvoiceInfoTable_Officials localVendInvoiceInfoTable_Officials;

            if (sysRecIdSequence.isRecidSuspended(tableNum(VendInvoiceInfoTable_Officials)))
            {
                sysRecIdSequence.removeRecIdSuspension(tableNum(VendInvoiceInfoTable_Officials));
            }
    
            localVendInvoiceInfoTable_Officials.skipDataMethods(true);
            localVendInvoiceInfoTable_Officials.skipDatabaseLog(true);
            localVendInvoiceInfoTable_Officials.skipEvents(true);
            insert_recordset localVendInvoiceInfoTable_Officials
                (VendInvoiceInfoTable)
            select RecId from vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == this.parmId()
                    && vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New;
        }
    
        if (TaxThaiGovCertificationFeatureChecker::isCountryRegionTH())
        {
            if (sysRecIdSequence.isRecidSuspended(tableNum(VendInvoiceInfoTableExtensionTH)))
            {
                sysRecIdSequence.removeRecIdSuspension(tableNum(VendInvoiceInfoTableExtensionTH));
            }

            VendInvoiceInfoTableExtensionTH localVendInvoiceInfoTableExtensionTH;
            localVendInvoiceInfoTableExtensionTH.skipDataMethods(true);
            localVendInvoiceInfoTableExtensionTH.skipDatabaseLog(true);
            localVendInvoiceInfoTableExtensionTH.skipEvents(true);

            VendInvoiceInfoTableExtensionTH vendInvoiceInfoTableExtensionTH;
            insert_recordset localVendInvoiceInfoTableExtensionTH
                (VendInvoiceInfoTable)
            select RecId from vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == this.parmId()
                    && vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New
            notexists join vendInvoiceInfoTableExtensionTH
                where vendInvoiceInfoTableExtensionTH.VendInvoiceInfoTable == vendInvoiceInfoTable.RecId;

            PurchTable localPurchTable;
            PurchTable_W purchTable_W;
            LedgerJournalTransExtensionTH ledgerJournalTransExtensionTH;

            update_recordset localVendInvoiceInfoTableExtensionTH setting
                InvoiceDate = ledgerJournalTransExtensionTH.InvoiceDate,
                InvoiceReceiptDate = ledgerJournalTransExtensionTH.InvoiceReceiptDate,
                TaxInvoiceReceiptDate = ledgerJournalTransExtensionTH.TaxInvoiceReceiptDate,
                RealVendName = ledgerJournalTransExtensionTH.RealVendName,
                PostalAddress = purchTable_W.InvoicePostalAddress_TH
            join vendInvoiceInfoTable
                where vendInvoiceInfoTable.RecId == localVendInvoiceInfoTableExtensionTH.VendInvoiceInfoTable
                    && vendInvoiceInfoTable.ParmId == this.parmId()
                    && vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::New
            outer join InvoiceDate, InvoiceReceiptDate, TaxInvoiceReceiptDate, RealVendName from ledgerJournalTransExtensionTH
                where ledgerJournalTransExtensionTH.LedgerJournalTrans == vendInvoiceInfoTable.PoolRecId
            join localPurchTable
                where localPurchTable.PurchId == vendInvoiceInfoTable.PurchId
                outer join InvoicePostalAddress_TH from purchTable_W
                    where purchTable_W.PurchTable == localPurchTable.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultLine1099</Name>
				<Source><![CDATA[
    protected void defaultLine1099()
    {
        VendInvoiceInfoLine vendInvoiceInfoLineUpdate;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendTable vendTable;
        PurchLine localPurchLine;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoUS]))
        {
            vendInvoiceInfoLineUpdate.skipDataMethods(true);
            vendInvoiceInfoLineUpdate.skipDatabaseLog(true);
            vendInvoiceInfoLineUpdate.skipEvents(true);

            if (isConfigurationkeyEnabled(configurationKeyNum(Tax1099S)) || isConfigurationkeyEnabled(configurationKeyNum(Tax1099G)))
            {
                update_recordset vendInvoiceInfoLineUpdate setting
                    Tax1099Fields = localPurchLine.Tax1099Fields,
                    Tax1099Amount = localPurchLine.Tax1099Amount,
                    Tax1099State = localPurchLine.Tax1099State,
                    Tax1099StateAmount = localPurchLine.Tax1099StateAmount,
                    Tax1099BoxDetail = localPurchLine.Tax1099RecId
                where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                join localPurchLine
                    where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
                exists join vendTable
                    where vendTable.AccountNum == vendInvoiceInfoLineUpdate.OrderAccount
                       && vendTable.Tax1099Reports == NoYes::Yes
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                       && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
            }
            else
            {
                update_recordset vendInvoiceInfoLineUpdate setting
                    Tax1099Fields = localPurchLine.Tax1099Fields,
                    Tax1099Amount = localPurchLine.Tax1099Amount,
                    Tax1099State = localPurchLine.Tax1099State,
                    Tax1099StateAmount = localPurchLine.Tax1099StateAmount
                where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
                join localPurchLine
                    where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
                exists join vendTable
                    where vendTable.AccountNum == vendInvoiceInfoLineUpdate.OrderAccount
                       && vendTable.Tax1099Reports == NoYes::Yes
                notexists join vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                       && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultLineAmount</Name>
				<Source><![CDATA[
    protected void defaultLineAmount(VendInvoiceInfoLine _vendInvoiceInfoLine)
    {
        PurchLine localPurchLine;
        VendInvoiceMatchingLine vendInvoiceMatchingLine;
        VendParameters vendParameters = VendParameters::find();

        _vendInvoiceInfoLine.VendDocumentLineMap::setLineAmount();

        if (abs(_vendInvoiceInfoLine.Tax1099Amount) > abs(_vendInvoiceInfoLine.LineAmount))
        {
            _vendInvoiceInfoLine.Tax1099Amount = 0;
        }

        if (abs(_vendInvoiceInfoLine.Tax1099StateAmount) > abs(_vendInvoiceInfoLine.LineAmount))
        {
            _vendInvoiceInfoLine.Tax1099StateAmount = 0;
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)) && isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            localPurchLine = _vendInvoiceInfoLine.purchLine();
            _vendInvoiceInfoLine.psaSetRetainage(_vendInvoiceInfoLine.LineAmount, this.parmDocumentStatus(), localPurchLine);
        }

        _vendInvoiceInfoLine.doUpdate();

        if (vendParameters.useExtendedPriceMatching() != ExtendedPriceMatching::None)
        {
            vendInvoiceMatchingLine = VendInvoiceMatchingLine::find(_vendInvoiceInfoLine.TableId, _vendInvoiceInfoLine.RecId, true);
            if (vendInvoiceMatchingLine)
            {
                if (localPurchLine.RecId != _vendInvoiceInfoLine.PurchLineRecId)
                {
                    localPurchLine = _vendInvoiceInfoLine.purchLine();
                }

                vendInvoiceMatchingLine.setExtendendedPriceVarianceAmounts(localPurchLine, _vendInvoiceInfoLine);
                vendInvoiceMatchingLine.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultQuantityAll</Name>
				<Source><![CDATA[
    protected void defaultQuantityAll()
    {
        // TableRefId == OrigPurchId is used to find the new invoice lines until the TableRefId is set on the invoice

        VendInvoiceInfoLine vendInvoiceInfoLineUpdate;
        VendInvoiceInfoLineSum vendInvoiceInfoLineSum;
        PurchLine localPurchLine;
        ParmId currentParmId = this.parmId();

        vendInvoiceInfoLineUpdate.skipDataMethods(true);
        vendInvoiceInfoLineUpdate.skipDatabaseLog(true);
        vendInvoiceInfoLineUpdate.skipEvents(true);

        // Default ReceiveNow & InventNow
        update_recordset vendInvoiceInfoLineUpdate setting
            ReceiveNow = localPurchLine.RemainPurchFinancial + localPurchLine.RemainPurchPhysical,
            InventNow = localPurchLine.RemainInventFinancial + localPurchLine.RemainInventPhysical,
            PdsCWReceiveNow = localPurchLine.PdsCWRemainInventFinancial + localPurchLine.PdsCwRemainInventPhysical
        where vendInvoiceInfoLineUpdate.OrigPurchId == vendInvoiceInfoLineUpdate.TableRefId &&
                vendInvoiceInfoLineUpdate.ParmId == currentParmId
        join localPurchLine
            where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId;

        // Reduce the default quantity by existing quantity on other unposted invoices
        update_recordset vendInvoiceInfoLineUpdate setting
            ReceiveNow = vendInvoiceInfoLineUpdate.ReceiveNow - vendInvoiceInfoLineSum.SumOfReceiveNow,
            InventNow = vendInvoiceInfoLineUpdate.InventNow - vendInvoiceInfoLineSum.SumOfInventNow,
            PdsCWReceiveNow = vendInvoiceInfoLineUpdate.PdsCWReceiveNow - vendInvoiceInfoLineSum.SumOfPdsCWReceiveNow
        where vendInvoiceInfoLineUpdate.OrigPurchId == vendInvoiceInfoLineUpdate.TableRefId &&
                vendInvoiceInfoLineUpdate.ParmId == currentParmId
        join SumOfReceiveNow, SumOfInventNow, SumOfPdsCWReceiveNow from vendInvoiceInfoLineSum
            where vendInvoiceInfoLineSum.InventTransId == vendInvoiceInfoLineUpdate.InventTransId;

        // Never use a value of the opposite sign
        update_recordset vendInvoiceInfoLineUpdate setting
            ReceiveNow = 0
        where vendInvoiceInfoLineUpdate.OrigPurchId == vendInvoiceInfoLineUpdate.TableRefId &&
                vendInvoiceInfoLineUpdate.ParmId == currentParmId
        join localPurchLine
            where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId &&
                (localPurchLine.RemainPurchFinancial + localPurchLine.RemainPurchPhysical) * vendInvoiceInfoLineUpdate.ReceiveNow < 0;

        // Never use a value of the opposite sign
        update_recordset vendInvoiceInfoLineUpdate setting
            InventNow = 0
        where vendInvoiceInfoLineUpdate.OrigPurchId == vendInvoiceInfoLineUpdate.TableRefId &&
                vendInvoiceInfoLineUpdate.ParmId == currentParmId
        join localPurchLine
            where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId &&
                (localPurchLine.RemainInventFinancial + localPurchLine.RemainInventPhysical) * vendInvoiceInfoLineUpdate.InventNow < 0;

        if (isConfigurationkeyEnabled(configurationkeynum(PdsCatchWeight)))
        {
            // Never use a value of the opposite sign
            update_recordset vendInvoiceInfoLineUpdate setting
                PdsCWReceiveNow = 0
            where vendInvoiceInfoLineUpdate.OrigPurchId == vendInvoiceInfoLineUpdate.TableRefId &&
                    vendInvoiceInfoLineUpdate.ParmId == currentParmId
            join localPurchLine
                where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId &&
                    (localPurchLine.PdsCWRemainInventFinancial + localPurchLine.PdsCwRemainInventPhysical) * vendInvoiceInfoLineUpdate.PdsCWReceiveNow < 0;
        }

        // Update the amount retained
        if (Project::Enabled())
        {
            update_recordset vendInvoiceInfoLineUpdate setting
                PSARetainageBalance = localPurchLine.PSATotalRetainAmount
            where vendInvoiceInfoLineUpdate.OrigPurchId == vendInvoiceInfoLineUpdate.TableRefId &&
                    vendInvoiceInfoLineUpdate.ParmId == currentParmId
            join localPurchLine
                where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId &&
                        localPurchLine.PSATotalRetainAmount != 0;
            
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultQuantityPackingSlip</Name>
				<Source><![CDATA[
    protected void defaultQuantityPackingSlip()
    {
        // VendInvoiceInfoLine.TableRefId == OrigPurchId is used to find the new invoice lines until the TableRefId is set on the invoice
        // VendInvoiceInfoSubLine.DocumentId == InventTransId is used to find the new invoice sublines

        VendInvoiceInfoLine vendInvoiceInfoLineUpdate;
        VendInvoiceInfoSubLine vendInvoiceInfoSubLine;
        VendInvoiceInfoSubLineSum vendInvoiceInfoSubLineSum;
        VendInvoiceInfoSubLineSumAll vendInvoiceInfoSubLineSumAll;
        VendInvoicePackingSlipQuantityMatchSum vendInvoicePackingSlipQuantityMatchSum;
        VendPackingSlipTrans vendPackingSlipTrans;
        ParmId currentParmId = this.parmId();

        // Set quantities, reducing them for quantities already used on posted invoices
        vendInvoiceInfoSubLine.skipDataMethods(true);
        vendInvoiceInfoSubLine.skipDatabaseLog(true);
        vendInvoiceInfoSubLine.skipEvents(true);
        update_recordset vendInvoiceInfoSubLine setting
            ReceiveNow = vendInvoiceInfoSubLine.ReceiveNow - vendInvoicePackingSlipQuantityMatchSum.SumOfQuantity,
            InventNow = vendInvoiceInfoSubLine.InventNow - vendInvoicePackingSlipQuantityMatchSum.SumOfInventQuantity,
            PdsCWInventNow = vendInvoiceInfoSubLine.PdsCWInventNow - vendInvoicePackingSlipQuantityMatchSum.SumOfPdsCWQuantity
        where vendInvoiceInfoSubLine.ParmId == currentParmId
        join vendPackingSlipTrans
            where vendPackingSlipTrans.RecId == vendInvoiceInfoSubLine.JournalRefRecId &&
                vendPackingSlipTrans.InventTransId == vendInvoiceInfoSubLine.DocumentId
        join vendInvoicePackingSlipQuantityMatchSum
            where vendInvoicePackingSlipQuantityMatchSum.PackingSlipSourceDocumentLine == vendPackingSlipTrans.SourceDocumentLine;

        // Reduce the subline for quantities already used on other unposted invoices
        //  VendInvoiceInfoSubLineSum restricts LineRefRecId != 0 to exclude lines on current invoice
        update_recordset vendInvoiceInfoSubLine setting
            ReceiveNow = vendInvoiceInfoSubLine.ReceiveNow - vendInvoiceInfoSubLineSum.SumOfReceiveNow,
            InventNow = vendInvoiceInfoSubLine.InventNow - vendInvoiceInfoSubLineSum.SumOfInventNow,
            PdsCWInventNow = vendInvoiceInfoSubLine.PdsCWInventNow - vendInvoiceInfoSubLineSum.SumOfPdsCWInventNow
        where vendInvoiceInfoSubLine.ParmId == currentParmId
        join vendPackingSlipTrans
            where vendPackingSlipTrans.RecId == vendInvoiceInfoSubLine.JournalRefRecId &&
                vendPackingSlipTrans.InventTransId == vendInvoiceInfoSubLine.DocumentId
        join vendInvoiceInfoSubLineSum
            where vendInvoiceInfoSubLineSum.JournalRefTableId == vendPackingSlipTrans.TableId &&
                  vendInvoiceInfoSubLineSum.JournalRefRecId == vendPackingSlipTrans.RecId;

        // Delete subline records that have zero quantity remaining
        vendInvoiceInfoSubLine.skipDeleteActions(true);
        vendInvoiceInfoSubLine.skipDeleteMethod(true);
        delete_from vendInvoiceInfoSubLine
        where vendInvoiceInfoSubLine.ParmId == currentParmId &&
              vendInvoiceInfoSubLine.ReceiveNow == 0;

        // Link the subline records to their invoice lines
        update_recordset vendInvoiceInfoSubLine setting
            LineRefRecId = vendInvoiceInfoLineUpdate.RecId,
            JournalRefTableId = vendPackingSlipTrans.TableId,
            DocumentId = vendPackingSlipTrans.PackingSlipId
        where vendInvoiceInfoSubLine.ParmId == currentParmId
        join vendPackingSlipTrans
            where vendPackingSlipTrans.RecId == vendInvoiceInfoSubLine.JournalRefRecId &&
                vendPackingSlipTrans.InventTransId == vendInvoiceInfoSubLine.DocumentId
        join vendInvoiceInfoLineUpdate
            where vendInvoiceInfoLineUpdate.InventTransId == vendPackingSlipTrans.InventTransId &&
                  vendInvoiceInfoLineUpdate.OrigPurchId == vendInvoiceInfoLineUpdate.TableRefId &&
                  vendInvoiceInfoLineUpdate.ParmId == currentParmId;

        // Default ReceiveNow & InventNow on the invoice lines
        // The view for all subline records is used because there isn't an invoice header to join to yet
        vendInvoiceInfoLineUpdate.skipDataMethods(true);
        vendInvoiceInfoLineUpdate.skipDatabaseLog(true);
        vendInvoiceInfoLineUpdate.skipEvents(true);
        update_recordset vendInvoiceInfoLineUpdate setting
            ReceiveNow = vendInvoiceInfoSubLineSumAll.SumOfReceiveNow,
            InventNow = vendInvoiceInfoSubLineSumAll.SumOfInventNow,
            PdsCWReceiveNow = vendInvoiceInfoSubLineSumAll.SumOfPdsCWInventNow
        where vendInvoiceInfoLineUpdate.OrigPurchId == vendInvoiceInfoLineUpdate.TableRefId &&
              vendInvoiceInfoLineUpdate.ParmId == currentParmId
        join vendInvoiceInfoSubLineSumAll
            where vendInvoiceInfoSubLineSumAll.LineRefRecId == vendInvoiceInfoLineUpdate.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultRemainingQuantities</Name>
				<Source><![CDATA[
    protected void defaultRemainingQuantities()
    {
        VendInvoiceInfoLine vendInvoiceInfoLineUpdate;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        InventTransPhysicalBalance inventTransPhysicalBalance;
        InventTransOriginPurchLine inventTransOriginPurchLine;
        PurchLine localPurchLine;
        ParmId currentParmId = this.parmId();

        vendInvoiceInfoLineUpdate.skipDataMethods(true);
        vendInvoiceInfoLineUpdate.skipDatabaseLog(true);
        vendInvoiceInfoLineUpdate.skipEvents(true);

        // Default RemainBefore
        update_recordset vendInvoiceInfoLineUpdate setting
            RemainBefore = localPurchLine.RemainPurchPhysical + localPurchLine.RemainPurchFinancial,
            RemainAfter = localPurchLine.RemainPurchPhysical
        where vendInvoiceInfoLineUpdate.ParmId == currentParmId
        join localPurchLine
            where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
        notexists join vendInvoiceInfoTable
            where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
               && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;

        // ----- Default RemainBeforeInvent/PdsCWRemainBefore
        update_recordset vendInvoiceInfoLineUpdate setting
            RemainBeforeInvent = localPurchLine.RemainInventPhysical + inventTransPhysicalBalance.SumOfQty,
            RemainAfterInvent = localPurchLine.RemainInventPhysical,
            PdsCWRemainBefore = localPurchLine.PdsCWRemainInventPhysical + inventTransPhysicalBalance.SumOfPdsCWQty,
            PdsCWRemainAfter = localPurchLine.PdsCWRemainInventPhysical
        where vendInvoiceInfoLineUpdate.ParmId == currentParmId
        join localPurchLine
            where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
        join inventTransOriginPurchLine
            where inventTransOriginPurchLine.PurchLineDataAreaId == localPurchLine.DataAreaId &&
                  inventTransOriginPurchLine.PurchLineInventTransId == localPurchLine.InventTransId
        outer join SumOfQty, SumOfPdsCWQty from inventTransPhysicalBalance
            where inventTransPhysicalBalance.InventTransOrigin == inventTransOriginPurchLine.InventTransOrigin
        notexists join vendInvoiceInfoTable
            where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
               && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;

        // ----- Default RemainAfter
        update_recordset vendInvoiceInfoLineUpdate setting
            RemainAfter = vendInvoiceInfoLineUpdate.RemainAfter
                        - (vendInvoiceInfoLineUpdate.ReceiveNow - localPurchLine.RemainPurchFinancial)
        where vendInvoiceInfoLineUpdate.ParmId == currentParmId
        join localPurchLine
            where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId &&
                ((vendInvoiceInfoLineUpdate.ReceiveNow > 0 &&
                    vendInvoiceInfoLineUpdate.ReceiveNow > localPurchLine.RemainPurchFinancial) ||
                (vendInvoiceInfoLineUpdate.ReceiveNow < 0 &&
                    vendInvoiceInfoLineUpdate.ReceiveNow < localPurchLine.RemainPurchFinancial))
        notexists join vendInvoiceInfoTable
            where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
               && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;

        //  Update RemainAfter to 0 if it has a different sign now than ReceiveNow
        update_recordset vendInvoiceInfoLineUpdate setting
            RemainAfter = 0
        where vendInvoiceInfoLineUpdate.ParmId == currentParmId &&
                vendInvoiceInfoLineUpdate.RemainAfter * vendInvoiceInfoLineUpdate.ReceiveNow < 0
        notexists join vendInvoiceInfoTable
            where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
               && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;

        // ----- Default RemainAfterInvent
        update_recordset vendInvoiceInfoLineUpdate setting
            RemainAfterInvent = vendInvoiceInfoLineUpdate.RemainAfterInvent
                        - (vendInvoiceInfoLineUpdate.InventNow - inventTransPhysicalBalance.SumOfQty)
        where vendInvoiceInfoLineUpdate.ParmId == currentParmId
        join inventTransOriginPurchLine
            where inventTransOriginPurchLine.PurchLineDataAreaId == vendInvoiceInfoLineUpdate.DataAreaId &&
                  inventTransOriginPurchLine.PurchLineInventTransId == vendInvoiceInfoLineUpdate.InventTransId
        join SumOfQty from inventTransPhysicalBalance
            where inventTransPhysicalBalance.InventTransOrigin == inventTransOriginPurchLine.InventTransOrigin &&
                ((vendInvoiceInfoLineUpdate.InventNow > 0 &&
                    vendInvoiceInfoLineUpdate.InventNow > inventTransPhysicalBalance.SumOfQty) ||
                (vendInvoiceInfoLineUpdate.InventNow < 0 &&
                    vendInvoiceInfoLineUpdate.InventNow < inventTransPhysicalBalance.SumOfQty))
        notexists join vendInvoiceInfoTable
            where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
               && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;

        update_recordset vendInvoiceInfoLineUpdate setting
            RemainAfterInvent = vendInvoiceInfoLineUpdate.RemainAfterInvent - vendInvoiceInfoLineUpdate.InventNow
        where vendInvoiceInfoLineUpdate.ParmId == currentParmId &&
              vendInvoiceInfoLineUpdate.PurchLineRecId == 0
        join inventTransOriginPurchLine
            where inventTransOriginPurchLine.PurchLineDataAreaId == vendInvoiceInfoLineUpdate.DataAreaId &&
                  inventTransOriginPurchLine.PurchLineInventTransId == vendInvoiceInfoLineUpdate.InventTransId
        notexists join inventTransPhysicalBalance
            where inventTransPhysicalBalance.InventTransOrigin == inventTransOriginPurchLine.InventTransOrigin;

        //  Update RemainAfterInvent to 0 if it has a different sign now than InventNow
        update_recordset vendInvoiceInfoLineUpdate setting
            RemainAfterInvent = 0
        where vendInvoiceInfoLineUpdate.ParmId == currentParmId &&
              vendInvoiceInfoLineUpdate.RemainAfterInvent * vendInvoiceInfoLineUpdate.InventNow < 0
        notexists join vendInvoiceInfoTable
            where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
               && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;

        if (isConfigurationkeyEnabled(configurationkeynum(PdsCatchWeight)))
        {
            // ----- Default PdsCWRemainAfter
            update_recordset vendInvoiceInfoLineUpdate setting
                PdsCWRemainAfter = vendInvoiceInfoLineUpdate.PdsCWRemainAfter
                            - (vendInvoiceInfoLineUpdate.PdsCWReceiveNow - inventTransPhysicalBalance.SumOfPdsCWQty)
            where vendInvoiceInfoLineUpdate.ParmId == currentParmId
            join localPurchLine
                where localPurchLine.InventTransId == vendInvoiceInfoLineUpdate.InventTransId
            join inventTransOriginPurchLine
                where inventTransOriginPurchLine.PurchLineDataAreaId == localPurchLine.DataAreaId &&
                      inventTransOriginPurchLine.PurchLineInventTransId == localPurchLine.InventTransId
            outer join SumOfPdsCWQty from inventTransPhysicalBalance
                where inventTransPhysicalBalance.InventTransOrigin == inventTransOriginPurchLine.InventTransOrigin &&
                    ((vendInvoiceInfoLineUpdate.PdsCWReceiveNow > 0 &&
                        vendInvoiceInfoLineUpdate.PdsCWReceiveNow > inventTransPhysicalBalance.SumOfPdsCWQty) ||
                    (vendInvoiceInfoLineUpdate.PdsCWReceiveNow < 0 &&
                        vendInvoiceInfoLineUpdate.PdsCWReceiveNow < inventTransPhysicalBalance.SumOfPdsCWQty))
            notexists join vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                   && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;

            //  Update PdsCWRemainAfter to 0 if it has a different sign now than PdsCWReceiveNow
            update_recordset vendInvoiceInfoLineUpdate setting
                PdsCWRemainAfter = 0
            where vendInvoiceInfoLineUpdate.ParmId == currentParmId &&
                  vendInvoiceInfoLineUpdate.PdsCWRemainAfter * vendInvoiceInfoLineUpdate.PdsCWReceiveNow < 0
            notexists join vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                   && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultStorno</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the default value for the <c>Storno</c> parameter.
    /// </summary>
    /// <returns>
    /// The default value for the <c>Storno</c>.
    /// </returns>
    protected NoYesId defaultStorno()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteZeroQuantityLines</Name>
				<Source><![CDATA[
    protected void deleteZeroQuantityLines()
    {
        VendInvoiceInfoLine vendInvoiceInfoLineUpdate;
        VendInvoiceInfoTable vendInvoiceInfoTable;

        vendInvoiceInfoLineUpdate.skipDataMethods(true);
        vendInvoiceInfoLineUpdate.skipDatabaseLog(true);
        vendInvoiceInfoLineUpdate.skipEvents(true);
        vendInvoiceInfoLineUpdate.skipDeleteActions(true);
        vendInvoiceInfoLineUpdate.skipDeleteMethod(true);

        if (Project::Enabled())
        {
            delete_from vendInvoiceInfoLineUpdate
            where vendInvoiceInfoLineUpdate.ParmId == this.parmId() &&
                    vendInvoiceInfoLineUpdate.ReceiveNow == 0 &&
                    vendInvoiceInfoLineUpdate.PSARetainageBalance == 0
            notexists join vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                    && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
        }
        else
        {
            delete_from vendInvoiceInfoLineUpdate
            where vendInvoiceInfoLineUpdate.ParmId == this.parmId() &&
                  vendInvoiceInfoLineUpdate.ReceiveNow == 0
            notexists join vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLineUpdate.ParmId
                   && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLineUpdate.TableRefId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteParmLines</Name>
				<Source><![CDATA[
    protected void deleteParmLines()
    {
        VendInvoiceInfoLine::deleteFromPurchParmUpdateNotPending(purchParmUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteParmTables</Name>
				<Source><![CDATA[
    protected void deleteParmTables()
    {
        VendInvoiceInfoTable::deleteActiveWithoutUpdate(this.parmId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsParmLines</Name>
				<Source><![CDATA[
    protected boolean existsParmLines()
    {
        VendInvoiceInfoLine vendInvoiceInfoLine;

        return (select firstonly RecId from vendInvoiceInfoLine
                    where vendInvoiceInfoLine.ParmId == this.parmId()).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsParmSubTable</Name>
				<Source><![CDATA[
    protected boolean existsParmSubTable(Common _parmSubTable)
    {
        boolean ret;
        VendInvoiceInfoSubTable localParmSubTable;

        ret = super(_parmSubTable);

        if (!ret)
        {
            localParmSubTable = _parmSubTable as VendInvoiceInfoSubTable;
            ret = VendInvoiceInfoSubTable::exist(localParmSubTable.ParmId, localParmSubTable.TableRefId, localParmSubTable.OrigPurchId);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillOrigOrderIsSet</Name>
				<Source><![CDATA[
    protected void fillOrigOrderIsSet()
    {
        VendInvoiceInfoTable localParmTable;
        VendInvoiceInfoSubTable localParmSubTable;
        PurchTable localPurchTable;

        // Recreate lines for documents that do not have a status of pending
        while select forceplaceholders localParmTable
        where localParmTable.ParmId == this.parmId()
            && localParmTable.VendInvoiceSaveStatus != VendInvoiceSaveStatus::Pending
            join localParmSubTable
                where localParmSubTable.ParmId == localParmTable.ParmId
                    && localParmSubTable.TableRefId == localParmTable.TableRefId
            join localPurchTable
                where localPurchTable.PurchId == localParmSubTable.OrigPurchId
        {
            this.addToOrigOrderIdSet(localParmTable, localParmSubTable, localPurchTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillOutputContract</Name>
				<Source><![CDATA[
    protected void fillOutputContract()
    {
        super();

        outputContract.parmActiveInvoiceListPacked(SysOperationHelper::base64Encode(activeInvoiceList.pack()));
        outputContract.parmInvoicesInUseListPacked(SysOperationHelper::base64Encode(invoicesInUseList.pack()));
        outputContract.parmActiveInvoiceFlags(activeInvoiceFlags);
        outputContract.parmExistMultipleLinesForVendorCurrency(existMultipleLinesForVendorCurrency);
        outputContract.parmWasMatchStatusReset(wasMatchStatusReset);
        outputContract.parmIsPostingDateInClosedPeriod(isPostingDateInClosedPeriod);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActiveList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a list of the active invoices for the given <c>PurchId</c>.
    /// </summary>
    /// <param name="_purchId">
    /// The <c>PurchId</c> to find the list for.
    /// </param>
    /// <param name="_excludeParmId">
    /// A <c>ParmId</c> to exclude from the list.
    /// </param>
    /// <param name="_invoiceType">
    /// A <c>PurchInvoiceType</c> to include in the list.
    /// </param>
    /// <returns>
    /// A list of the active invoices for the given <c>PurchId</c>.
    /// </returns>
    public List getActiveList(PurchId _purchId, ParmId _excludeParmId = '', PurchInvoiceType _invoiceType = PurchInvoiceType::Standard)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        PurchParmUpdate activePurchParmUpdate;
        VendInvoiceInfoSubTable vendInvoiceInfoSubTable;

        List activeSavedList = new List(Types::String);

        while select TableRefId, Num from vendInvoiceInfoTable
            where vendInvoiceInfoTable.ParmJobStatus != ParmJobStatus::Executed
                && vendInvoiceInfoTable.InvoiceType == _invoiceType
            join CreatedBy from activePurchParmUpdate
                where activePurchParmUpdate.ParmId == vendInvoiceInfoTable.ParmId
                    && activePurchParmUpdate.ParmId != _excludeParmId
            exists join vendInvoiceInfoSubTable
                where vendInvoiceInfoSubTable.OrigPurchId == _purchId
                    && vendInvoiceInfoSubTable.ParmId == vendInvoiceInfoTable.ParmId
                    && vendInvoiceInfoSubTable.TableRefId == vendInvoiceInfoTable.TableRefId
        {
            if (activePurchParmUpdate.CreatedBy == curUserId() || !this.isUserOnLine(activePurchParmUpdate.CreatedBy))
            {
                activeSavedList.addEnd(vendInvoiceInfoTable.TableRefId);
            }
            else
            {
                this.setActiveInvoiceFlag(VendActiveInvoiceFlags::InvoiceInUse, true);
                invoicesInUseList.addEnd(vendInvoiceInfoTable.RecId);
            }
        }

        return activeSavedList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineQuantities</Name>
				<Source><![CDATA[
    protected container getLineQuantities(PurchLine _purchLine)
    {
        // <GIN>
        if (isFromBillOfEntry)
        {
            return [newPostingPurchQty, newPostingInventQty, 0, 0];
        }
        else
        {
            // </GIN>
            return [isFromPackingSlip ? newPostingPurchQty : naReal(), isFromPackingSlip ? newPostingInventQty : naReal(), 0, 0];
            // <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParmTableNum</Name>
				<Source><![CDATA[
    protected Num getParmTableNum(Num _num, PurchTable _purchTable, Num _purchSummaryFormLetterId)
    {
        _num = super(_num, _purchTable, _purchSummaryFormLetterId);

        if (!_num && _purchTable.isInterCompanyOrder())
        {
            _num = currentInterCompanyInvoiceNum;
        }

        return _num;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyInvoiceDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieve the intercomany invoice date.
    /// </summary>
    /// <param name = "_purchTable">The purchase order header.</param>
    /// <returns>Intercompany invoice date.</returns>
    internal InvoiceDate interCompanyInvoiceDate(PurchTable _purchTable)
    {
        InvoiceDate invoiceDate;
        Debug::assert(_purchTable.isInterCompanyOrder());

        changecompany(_purchTable.InterCompanyCompanyId)
        {
            invoiceDate = _purchTable.interCompanySalesTable().lastInvoiceDate();
        }

        return invoiceDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryPendingInvoice</Name>
				<Source><![CDATA[
    public SysQueryRun getQueryPendingInvoice()
    {
        this.updateQueryBuild();
        return chooseLinesPendingInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceDocumentHeaderRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the source document header RecId corresponding to the supplied tableRefId.
    /// </summary>
    /// <param name="_tableRefId">
    /// The unique identifier of a vendor invoice.
    /// </param>
    /// <returns>
    /// The unique identifier of a source document header
    /// </returns>
    /// <remarks>
    /// A cached source document header will be used, if available. Otherwise a new one will be created.
    /// </remarks>
    protected SourceDocumentHeaderRecId getSourceDocumentHeaderRecId(TradeLineRefId _tableRefId)
    {
        SourceDocumentHeader sourceDocumentHeader;
        SourceDocumentHeaderRecId localSourceDocumentHeaderRecId;
        AccountingDate emptyDate;

        if (parmSourceDocumentHeaderMap.exists(_tableRefId))
        {
            sourceDocumentHeader = parmSourceDocumentHeaderMap.lookup(_tableRefId);
            localSourceDocumentHeaderRecId = sourceDocumentHeader.RecId;
        }
        else
        {
            localSourceDocumentHeaderRecId = this.insertSourceDocumentHeader(_tableRefId, emptyDate);
        }

        return localSourceDocumentHeaderRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitInventProfileType_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a invoice should be separated for each kind of activity.
    /// </summary>
    /// <returns>
    /// true if a invoice should be separated for each kind of activity; otherwise, false.
    /// </returns>
    #ISOCountryRegionCodes
    protected NoYes getSplitInventProfileType_RU()
    {
        return SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitPostingProfile_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if an invoice should be separated for each posting profile.
    /// </summary>
    /// <returns>
    ///    true if an invoice should be separated for each posting profile; otherwise, false.
    /// </returns>
    #ISOCountryRegionCodes
    protected NoYes getSplitPostingProfile_RU()
    {
        return SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasQtyToInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if a given purchase order has a quantity remaining to invoice.
    /// </summary>
    /// <param name = "_purchId">
    ///     The Id of the purchase order being invoiced.
    /// </param>
    /// <param name = "_currentSpecQty">
    ///     The <c>PurchUpdate</c> value being used to create the current invoice.
    /// </param>
    /// <returns>
    ///    true if the purchase order has at least one line with a quantity remaining to invoice;
    ///    otherwise, false.
    /// </returns>
    protected boolean hasQtyToInvoice(PurchId _purchId, PurchUpdate _currentSpecQty)
    {
        PurchLine localPurchLine;
        VendInvoiceInfoLineSum vendInvoiceInfoLineSum;
        VendInvoiceInfoSubLineSum vendInvoiceInfoSubLineSum;
        boolean hasQty;

        if (_currentSpecQty != PurchUpdate::ReceiveNow)
        {
            select firstOnly RecId from localPurchLine
            where localPurchLine.PurchId == _purchId
                && !localPurchLine.IsDeleted
                && localPurchLine.PurchReceivedNow != 0;

            if (localPurchLine)
            {
                hasQty = true;
            }
        }

        if (!hasQty && _currentSpecQty != PurchUpdate::All)
        {
            select firstOnly RecId from localPurchLine
            where localPurchLine.PurchId == _purchId
                && !localPurchLine.IsDeleted
                && (localPurchLine.RemainPurchFinancial + localPurchLine.RemainPurchPhysical) != 0
            exists join vendInvoiceInfoLineSum
                where vendInvoiceInfoLineSum.InventTransId == localPurchLine.InventTransId
                   && (vendInvoiceInfoLineSum.SumOfReceiveNow) < (localPurchLine.RemainPurchFinancial + localPurchLine.RemainPurchPhysical);

            if (localPurchLine)
            {
                hasQty = true;
            }
            else
            {
                select firstOnly RecId from localPurchLine
                where localPurchLine.PurchId == _purchId
                    && !localPurchLine.IsDeleted
                    && (localPurchLine.RemainPurchFinancial + localPurchLine.RemainPurchPhysical) != 0
                notexists join vendInvoiceInfoLineSum
                    where vendInvoiceInfoLineSum.InventTransId == localPurchLine.InventTransId;

                if (localPurchLine)
                {
                    hasQty = true;
                }
            }
        }

        if (!hasQty && _currentSpecQty != PurchUpdate::PackingSlip)
        {
            select firstOnly RecId from localPurchLine
            where localPurchLine.PurchId == _purchId
                && !localPurchLine.IsDeleted
                && localPurchLine.RemainPurchFinancial != 0
            exists join vendInvoiceInfoSubLineSum
                where vendInvoiceInfoSubLineSum.InventTransId == localPurchLine.InventTransId
                   && (vendInvoiceInfoSubLineSum.SumOfReceiveNow) < (localPurchLine.RemainPurchFinancial);

            if (localPurchLine)
            {
                hasQty = true;
            }
            else
            {
                select firstOnly RecId from localPurchLine
                where localPurchLine.PurchId == _purchId
                    && !localPurchLine.IsDeleted
                    && localPurchLine.RemainPurchFinancial != 0
                notexists join vendInvoiceInfoSubLineSum
                    where vendInvoiceInfoSubLineSum.InventTransId == localPurchLine.InventTransId;

                if (localPurchLine)
                {
                    hasQty = true;
                }
            }
        }

        return hasQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the Set instances.
    /// </summary>
    public void init()
    {
        super();

        newSourceDocumentHeaderIdSet = new Set(typeName2Type(extendedTypeStr(RecId)));
        headerSourceDocumentLines = new Set(Types::Int64);
        isProcessingActiveInvoices = true;
        activeInvoiceList = new List(Types::String);
        invoicesInUseList = new List(Types::Int64);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initChooseLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows a method to be overridden for the initialization at the start of the <c>ChooseLines</c>
    /// method can be done.
    /// </summary>
    protected void initChooseLines()
    {
        QueryBuildDataSource vendInvoiceInfoTableDS = chooseLines.query().dataSourceTable(tableNum(VendInvoiceInfoTable));
        QueryBuildDataSource savedInvoicesQueryRootDS = chooseLinesPendingInvoice.query().dataSourceTable(tableNum(VendInvoiceInfoTable));
        QueryBuildDataSource nonPOInvoicesQueryRootDS, qbdsVendInvoiceInfoLine;
        int joinMode;

        super();
        if (chooseLinesNonPOInvoice)
        {
            nonPOInvoicesQueryRootDS = chooseLinesNonPOInvoice.query().dataSourceTable(tableNum(VendInvoiceInfoTable));
        }
        currentInterCompanyInvoiceNum = '';

        // Cache inserted pending lines
        // Initialized here since it lives over a subsequent call to initRecordLists
        pendingInvoices = new Map(Types::String, Types::Enum);

        // copy the enabled status from the initial query to the secondary queries
        savedInvoicesQueryRootDS.enabled(vendInvoiceInfoTableDS.enabled());

        if (nonPOInvoicesQueryRootDS && nonPOInvoicesQueryRootDS.enabled())
        {
            nonPOInvoicesQueryRootDS.enabled(vendInvoiceInfoTableDS.enabled());
        }

        // copy the line's joinMode from the intial query to the secondary queries
        qbdsVendInvoiceInfoLine = chooseLines.query().dataSourceTable(tableNum(VendInvoiceInfoLine));
        if (qbdsVendInvoiceInfoLine)
        {
            joinMode = qbdsVendInvoiceInfoLine.joinMode();
            chooseLinesPendingInvoice.query().dataSourceTable(tableNum(VendInvoiceInfoLine)).joinMode(joinMode);
        }
        if (chooseLinesNonPOInvoice)
        {
            chooseLinesNonPOInvoice.query().dataSourceTable(tableNum(VendInvoiceInfoLine)).joinMode(joinMode);
        }

        // Saved invoices are processed by chooseLinesPendingInvoices query.
        // The only reason for VendInvoiceInfoTable in chooseLines query is that user can enter criteria.
        vendInvoiceInfoTableDS.enabled(false);

        currentSourceTable.clear();

        chooseLinesEOF = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOfficials_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method initializes officials for given <c>VendInvoiceInfoTable</c> record or for all update
    /// </summary>
    /// <param name="_purchParmTable">
    /// <c>VendInvoiceInfoTable</c> record for which officials should be initialized
    /// </param>
    public void initOfficials_RU(Common _purchParmTable = null)
    {
        VendInvoiceInfoTable localInfoTable = _purchParmTable as VendInvoiceInfoTable;
        VendInvoiceInfoTable_Officials vendInvoiceInfoTable_Officials = localInfoTable.vendInvoiceInfoTable_Officials();

        void updatePurchParmTable()
        {
            boolean newId = true;

            if (vendInvoiceInfoTable_Officials.OffSessionId)
            {
                newId = false;
                offSrv.newId(vendInvoiceInfoTable_Officials.OffSessionId);
                vendInvoiceInfoTable_Officials.OffSessionId = "";
            }

            vendInvoiceInfoTable_Officials.OffReportType =
                offSrv.initTablePurch(localInfoTable, purchParmUpdate, newId, this.initOfficialsFacture_RU());

            if (! vendInvoiceInfoTable_Officials.OffSessionId)
            {
                vendInvoiceInfoTable_Officials.OffSessionId = offSrv.newId();
            }
            if (localInfoTable.RecId && localInfoTable.selectForUpdate())
            {
                localInfoTable.packVendInvoiceInfoTable_Officials(vendInvoiceInfoTable_Officials);
                localInfoTable.update();
            }
        }

        if (! OfficialsServ_RU::isFeatureEnabled())
        {
            return;
        }

        if (! offSrv)
        {
            offSrv = new OfficialsServ_RU();
        }

        ttsbegin;
        if (localInfoTable) // Editing parmTable
        {
            updatePurchParmTable();
        }
        else // Creating parmTables
        {
            while select forupdate localInfoTable
                where localInfoTable.ParmId == purchParmUpdate.ParmId &&
                    localInfoTable.Ordering == this.parmDocumentStatus()

            {
                select firstonly vendInvoiceInfoTable_Officials
                    where vendInvoiceInfoTable_Officials.VendInvoiceInfoTable == localInfoTable.RecId &&
                        !vendInvoiceInfoTable_Officials.OffSessionId;
                if (vendInvoiceInfoTable_Officials)
                {
                    updatePurchParmTable();
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOfficialsFacture_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the officials should be initialized for the facture.
    /// </summary>
    /// <returns>
    /// true if the officials should be initialized; false for the invoice posting only.
    /// </returns>
    protected boolean initOfficialsFacture_RU()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the correct type of table buffer to initialize a line.
    /// </summary>
    /// <returns>
    /// A new table buffer of the correct type.
    /// </returns>
    protected VendDocumentLineMap initParmLine()
    {
        VendInvoiceInfoLine vendInvoiceInfoLine;
        return vendInvoiceInfoLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmLine_Asset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the correct type of table buffer to initialize a line asset.
    /// </summary>
    /// <returns>
    /// A new table buffer of the correct type.
    /// </returns>
    protected VendDocumentLineAssetMap initParmLine_Asset()
    {
        VendInvoiceInfoLine_Asset vendInvoiceInfoLine_Asset;
        return vendInvoiceInfoLine_Asset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmLine_project</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the correct type of table buffer to initialize a project buffer for the invoice line.
    /// </summary>
    /// <returns>
    /// A new table buffer of the correct type.
    /// </returns>
    protected VendDocumentLineProjectMap initParmLine_project()
    {
        VendInvoiceInfoLine_Project vendInvoiceInfoLine_Project;
        return vendInvoiceInfoLine_Project;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmSubTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the correct type of table buffer to initialize a sub header.
    /// </summary>
    /// <returns>
    /// A new table buffer of the correct type.
    /// </returns>
    protected VendDocumentSubTableMap initParmSubTable()
    {
        VendInvoiceInfoSubTable vendInvoiceInfoSubTable;
        return vendInvoiceInfoSubTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the correct type of table buffer to initialize a header.
    /// </summary>
    /// <returns>
    /// A new table buffer of the correct type.
    /// </returns>
    protected VendDocumentTableMap initParmTable()
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        return vendInvoiceInfoTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasRetainedBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current purchase line has retained amount.
    /// </summary>
    /// <param name="_purchId">
    /// The <c>PurchId</c> buffer that holds the purchase order ID.
    /// </param>
    /// <returns>
    /// True if there is retained amount on the purchase order.
    /// </returns>
    protected boolean hasRetainedBalance(PurchId _purchId)
    {
        boolean ret;
        
        if (Project::Enabled())
        {
            ret = PurchLine::find(_purchId).PSATotalRetainAmount ? true : false;
        }
        
        return ret;   
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQueryBuild</Name>
				<Source><![CDATA[
    protected void initQueryBuild()
    {
        QueryBuildDataSource savedInvoicesDS;
        QueryBuildDataSource savedInvoicesLinesDS;
        QueryBuildRange parmIdRange;

        super();

        chooseLinesPendingInvoice = new SysQueryRun(queryStr(PurchUpdatePendingInvoice));
        chooseLinesPendingInvoice.query().dataSourceTable(tableNum(VendInvoiceInfoTable)).addSortField(fieldNum(VendInvoiceInfoTable, TableRefId));
        chooseLinesPendingInvoice.query().dataSourceTable(tableNum(VendInvoiceInfoLine)).addSortField(fieldNum(VendInvoiceInfoLine, TableRefId));

        chooseLinesNonPOInvoice = new SysQueryRun(queryStr(VendInvoiceNonPO));
        chooseLinesNonPOInvoice.query().dataSourceTable(tableNum(VendInvoiceInfoTable)).addSortField(fieldNum(VendInvoiceInfoTable, TableRefId));
        chooseLinesNonPOInvoice.query().dataSourceTable(tableNum(VendInvoiceInfoLine)).addSortField(fieldNum(VendInvoiceInfoLine, TableRefId));

        // add additional datasources for saved invoices
        savedInvoicesDS = chooseLines.query().addDataSource(tableNum(VendInvoiceInfoTable));
        savedInvoicesDS.addSortField(fieldNum(VendInvoiceInfoTable, RecId));
        savedInvoicesLinesDS = savedInvoicesDS.addDataSource(tableNum(VendInvoiceInfoLine));
        savedInvoicesLinesDS.relations(true);
        savedInvoicesLinesDS.joinMode(JoinMode::OuterJoin); // allow invoices with no lines

        // add default ranges for saved invoices
        savedInvoicesDS.addRange(fieldNum(VendInvoiceInfoTable, VendInvoiceSaveStatus));
        parmIdRange = savedInvoicesDS.addRange(fieldNum(VendInvoiceInfoTable, ParmJobStatus));
        parmIdRange.value(SysQuery::valueNot(ParmJobStatus::Executed));
        parmIdRange.status(RangeStatus::Hidden);
        savedInvoicesLinesDS.addRange(fieldNum(VendInvoiceInfoLine, ItemId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRecordLists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the record list and map variables.
    /// </summary>
    protected void initRecordLists()
    {
        super();
        recordInsertParmSubLine = new RecordInsertList(this.parmSubLineTableId(), true, true, true);
        parmSubTableMap = new Map(Types::String,Types::Record);
        parmSourceDocumentHeaderMap = new Map(Types::String,Types::Record);

        recordInsertVendInvoiceMatchingLine = new RecordInsertList(tableNum(VendInvoiceMatchingLine));
        recordInsertListSourceDocumentHeader = new RecordInsertList(tableNum(SourceDocumentHeader));
        recordInsertListSourceDocumentLine = new RecordInsertList(tableNum(SourceDocumentLine));

        recordInsertParmLine_Project = new RecordInsertList(this.parmLineProjectTableId(), true, true, true);
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            recordInsertParmLine_Asset_RU = new RecordInsertList(tableNum(RAssetPurchTrans), true, true, true);
            recordInsertParmTable_RU = new RecordInsertList(tableNum(VendInvoiceInfoTable_RU));
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#VendInv_W))
        {
            recordInsertParmTable_W = new RecordInsertList(tableNum(VendInvoiceInfoTable_W));
        }
        // </GEERU>

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            recordInsertParmLine_IN = new RecordInsertList(tableNum(VendInvoiceInfoLineTaxExtension_IN));
        }
        // </GIN>

        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#VendInvLine_W))
        {
            recordInsertParmLine_W = new RecordInsertList(tableNum(VendInvoiceInfoLine_W));
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR]))
        {
            recordInsertParmLine_BR = new RecordInsertList(tableNum(VendInvoiceInfoLine_BR));
        }

        // <GEEU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU))
        {
            recordInsertParmTable_Officials = new RecordInsertList(tableNum(VendInvoiceInfoTable_Officials));
        }
        // </GEEU>
        // <GTH>
        if (TaxThaiGovCertificationFeatureChecker::isCountryRegionTH())
        {
            recordInsertParmTable_TH = new RecordInsertList(tableNum(VendInvoiceInfoTableExtensionTH));
        }
        // </GTH>

        if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            recordVendInvoiceInfoTable_W = new RecordInsertList(tableNum(VendInvoiceInfoTable_W));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSubLinesMap</Name>
				<Source><![CDATA[
    private Map initSubLinesMap()
    {
        return new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmLine</Name>
				<Source><![CDATA[
    protected void insertParmLine(Common _parmLine)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceInfoLine vendInvoiceInfoLine = _parmLine;
        VendInvoiceInfoLine_W vendInvoiceInfoLine_W;
        RecId localSourceDocumentLineRecId;
        SourceDocumentHeader sourceDocumentHeader;
        // <GIN>
        VendInvoiceInfoLineTaxExtension_IN insertVendInvoiceInfoLineTax_IN;
        // </GIN>

        if (!parmSourceDocumentHeaderMap.exists(vendInvoiceInfoLine.TableRefId))
        {
            vendInvoiceInfoTable = VendInvoiceInfoTable::find(vendInvoiceInfoLine.ParmId, vendInvoiceInfoLine.TableRefId);

            // if not in memory then it must exist on disk, probably running from reselect
            if (!vendInvoiceInfoTable)
            {
                this.insertSourceDocumentHeader(vendInvoiceInfoLine.TableRefId, this.parmTransDate());
            }
            else
            {
                // Header already exists in database, find SourceDocumentHeader & add to in-memory processing collections
                sourceDocumentHeader = SourceDocumentHeader::find(vendInvoiceInfoTable.SourceDocumentHeader);
                this.insertSourceDocumentMap(vendInvoiceInfoLine.TableRefId, sourceDocumentHeader);
            }
        }

        localSourceDocumentLineRecId = this.insertSourceDocumentLine(vendInvoiceInfoLine);

        vendInvoiceInfoLine.SourceDocumentLine = localSourceDocumentLineRecId;

        super(vendInvoiceInfoLine);

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]) && isFromPurchAgreement)
        {
            insertVendInvoiceInfoLineTax_IN.initForNonPO(vendInvoiceInfoLine);
            insertVendInvoiceInfoLineTax_IN.VendInvoiceInfoLine = vendInvoiceInfoLine.RecId;

            insertVendInvoiceInfoLineTax_IN.RecId = systemSequence.reserveValues(1, VendInvoiceInfoLine.TableId);

            vendInvoiceInfoLine.packVendInvoiceInfoLineTaxExtension_IN(insertVendInvoiceInfoLineTax_IN);

            recordInsertParmLine_IN.add(insertVendInvoiceInfoLineTax_IN);
        }
        // </GIN>

        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#VendInvLine_W))
        {
            vendInvoiceInfoLine_W = vendInvoiceInfoLine.vendInvoiceInfoLine_W();
            vendInvoiceInfoLine_W.VendInvoiceInfoLine = vendInvoiceInfoLine.RecId;

            vendInvoiceInfoLine_W.RecId = systemSequence.reserveValues(1, vendInvoiceInfoLine_W.TableId);

            vendInvoiceInfoLine.packVendInvoiceInfoLine_W(vendInvoiceInfoLine_W);

            recordInsertParmLine_W.add(vendInvoiceInfoLine_W);
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR]))
        {
            this.insertVendInvoiceInfoLine_BR(vendInvoiceInfoTable, vendInvoiceInfoLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmLine_Project</Name>
				<Source><![CDATA[
    protected void insertParmLine_Project(VendDocumentLineProjectMap _parmLine_Project)
    {
        if (_parmLine_Project.ProjId)
        {
            recordInsertParmLine_Project.add(_parmLine_Project);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmSubLine</Name>
				<Source><![CDATA[
    protected void insertParmSubLine(Common _parmSubLine)
    {
        VendInvoiceInfoSubLine vendInvoiceInfoSubLine = _parmSubLine;

        if (vendInvoiceInfoSubLine.ReceiveNow == 0.0)
        {
            return;
        }

        recordInsertParmSubLine.add(_parmSubLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmSubTable</Name>
				<Source><![CDATA[
    protected void insertParmSubTable(Common _vendInvoiceInfoSubTable)
    {
        PurchFormletterParmDataInvoice::initSubTableSourceAccountingEvent(_vendInvoiceInfoSubTable);

        super(_vendInvoiceInfoSubTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmTable</Name>
				<Source><![CDATA[
    protected void insertParmTable(Common _vendInvoiceInfoTable)
    {
        #EECountryRegionCodes

        VendInvoiceInfoTable vendInvoiceInfoTable = this.populateVendInvoiceInfoTable(_vendInvoiceInfoTable);

        if (insertHeaderInTempTable)
        {
            PurchFormletterParmDataInvoice::buf2Buf(vendInvoiceInfoTable, vendInvoiceInfoTableTmp);
            vendInvoiceInfoTableTmp.doInsert();
            this.insertParmTableMap(vendInvoiceInfoTable);
        }
        else
        {
            super(vendInvoiceInfoTable);

            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                VendInvoiceInfoTable_RU localVendInvoiceInfoTable_RU = vendInvoiceInfoTable.vendInvoiceInfoTable_RU();
                localVendInvoiceInfoTable_RU.VendInvoiceInfoTable = vendInvoiceInfoTable.RecId;

                localVendInvoiceInfoTable_RU.RecId = systemSequence.reserveValues(1, localVendInvoiceInfoTable_RU.TableId);

                vendInvoiceInfoTable.packVendInvoiceInfoTable_RU(localVendInvoiceInfoTable_RU);

                recordInsertParmTable_RU.add(localVendInvoiceInfoTable_RU);
            }

            if (SysCountryRegionCode::isLegalEntityInCountryRegion(#VendInv_W))
            {
                VendInvoiceInfoTable_W localVendInvoiceInfoTable_W = vendInvoiceInfoTable.vendInvoiceInfoTable_W();
                localVendInvoiceInfoTable_W.VendInvoiceInfoTable = vendInvoiceInfoTable.RecId;

                // <GJP>
                if (vendInvoiceInfoTable.InvoiceAccount != '' && VendConsInvoiceType_JP::isVendConsInvoiceEnabled())
                {
                    localVendInvoiceInfoTable_W.ConsTarget_JP = VendTable::find(vendInvoiceInfoTable.InvoiceAccount).ConsDay_JP != 0 ? NoYes::Yes : NoYes::No;
                }
                // </GJP>
                // <GMY>
                if (TaxGSTFeatureChecker_MY::isCountryRegionMY())
                {
                    localVendInvoiceInfoTable_W.InvoiceType_MY = purchTable::find(vendInvoiceInfoTable.PurchId).purchTable_W().InvoiceType_MY;
                }
                // </GMY>

                localVendInvoiceInfoTable_W.RecId = systemSequence.reserveValues(1, localVendInvoiceInfoTable_W.TableId);

                if (!localVendInvoiceInfoTable_W.PurchReceiptDate_W  && this.parmInterCompanyParmId() && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
                {
                    localVendInvoiceInfoTable_W.PurchReceiptDate_W = this.transDate();
                }

                if (!localVendInvoiceInfoTable_W.VatDueDate_W
                    && TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
                {
                    localVendInvoiceInfoTable_W.VatDueDate_W =
                        TaxVATDueDateUtility::determineVATDueDateForVendDocumentTableMap(vendInvoiceInfoTable, vendInvoiceInfoTable.purchTable());
                }

                vendInvoiceInfoTable.packVendInvoiceInfoTable_W(localVendInvoiceInfoTable_W);

                recordInsertParmTable_W.add(localVendInvoiceInfoTable_W);
            }
            // </GEERU>
            // <GEEU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU))
            {
                VendInvoiceInfoTable_Officials localVendInvoiceInfoTable_Officials = vendInvoiceInfoTable.vendInvoiceInfoTable_Officials();
                localVendInvoiceInfoTable_Officials.VendInvoiceInfoTable = vendInvoiceInfoTable.RecId;

                localVendInvoiceInfoTable_Officials.RecId = systemSequence.reserveValues(1, localVendInvoiceInfoTable_Officials.TableId);

                vendInvoiceInfoTable.packVendInvoiceInfoTable_Officials(localVendInvoiceInfoTable_Officials);

                recordInsertParmTable_Officials.add(localVendInvoiceInfoTable_Officials);
            }
            // </GEEU>

            // <GTH>
            if (TaxThaiGovCertificationFeatureChecker::isCountryRegionTH())
            {
                VendInvoiceInfoTableExtensionTH localVendInvoiceInfoTableExtensionTH = vendInvoiceInfoTable.vendInvoiceInfoTableExtensionTH();
                localVendInvoiceInfoTableExtensionTH.VendInvoiceInfoTable = vendInvoiceInfoTable.RecId;

                localVendInvoiceInfoTableExtensionTH.RecId = systemSequence.reserveValues(1, localVendInvoiceInfoTableExtensionTH.TableId);

                this.initVendInvoiceInfoTableExtensionTH(localVendInvoiceInfoTableExtensionTH, vendInvoiceInfoTable);

                vendInvoiceInfoTable.SysExtensionSerializerMap::packExtensionTable(localVendInvoiceInfoTableExtensionTH);

                recordInsertParmTable_TH.add(localVendInvoiceInfoTableExtensionTH);
            }
            // </GTH>
        }

        headerSourceDocumentLines.add(vendInvoiceInfoTable.SourceDocumentLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVendInvoiceInfoTableExtensionTH</Name>
				<Source><![CDATA[
    private void initVendInvoiceInfoTableExtensionTH(VendInvoiceInfoTableExtensionTH _vendInvoiceInfoTableExtensionTH, VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        if (_vendInvoiceInfoTable.PurchId
            && TaxAutoGeneratePurchInvoiceField_THFlight::instance().isEnabled())
        {
            PurchTable localPurchTable = _vendInvoiceInfoTable.purchTable();
            if (!_vendInvoiceInfoTableExtensionTH.TaxInvoiceReceiptDate
                && localPurchTable
                && localPurchTable.isInterCompanyOrder()
                && localPurchTable.interCompanyEndpointActionPolicy().PostPurchInvoice)
            {
                if (_vendInvoiceInfoTable.DocumentDate)
                {
                    _vendInvoiceInfoTableExtensionTH.InvoiceReceiptDate = _vendInvoiceInfoTable.DocumentDate;
                    _vendInvoiceInfoTableExtensionTH.TaxInvoiceReceiptDate = _vendInvoiceInfoTable.DocumentDate;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeParmTableFromInterCompanyCustInvoiceJour_TH</Name>
				<Source><![CDATA[
    private void initializeParmTableFromInterCompanyCustInvoiceJour_TH(VendDocumentTableMap _parmTable, PurchTable _purchTable)
    {
        if (_purchTable.InterCompanySalesId
            && TaxThaiGovCertificationFeatureChecker::isCountryRegionTH()
            && TaxAutoGeneratePurchInvoiceField_THFlight::instance().isEnabled())
        {
            if ((!_parmTable.DocumentNum || !_parmTable.DocumentDate)
                && _purchTable
                && _purchTable.isInterCompanyOrder()
                && _purchTable.interCompanyEndpointActionPolicy().PostPurchInvoice)
            {
                CustInvoiceJour custInvoiceJour;
                //When there are multiple invoices for one sales order, we will using the latest one.
                select firstonly crosscompany InvoiceId, InvoiceDate from custInvoiceJour
                    order by RecId desc
                    where custInvoiceJour.SalesId == _purchTable.InterCompanySalesId
                        && custInvoiceJour.DataAreaId == _purchTable.InterCompanyCompanyId;

                if (custInvoiceJour)
                {
                    _parmTable.DocumentNum = custInvoiceJour.InvoiceId;
                    _parmTable.DocumentDate = custInvoiceJour.InvoiceDate;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateVendInvoiceInfoTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates a <c>VendInvoiceInfoTable</c> record buffer.
    /// </summary>
    /// <param name = "_vendInvoiceInfoTable">
    /// A <c>VendInvoiceInfoTable</c> record buffer.
    /// </param>
    /// <returns>
    /// A populated <c>VendInvoiceInfoTable</c> record buffer.
    /// </returns>
    protected VendInvoiceInfoTable populateVendInvoiceInfoTable(Common _vendInvoiceInfoTable)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable = _vendInvoiceInfoTable;
        vendInvoiceInfoTable.RecId = 0;

        sourceDocumentHeaderRecId = this.getSourceDocumentHeaderRecId(vendInvoiceInfoTable.TableRefId);

        vendInvoiceInfoTable.SourceDocumentHeader = sourceDocumentHeaderRecId;
        defaultDimension = vendInvoiceInfoTable.DefaultDimension;

        sourceDocumentLineRecId = this.insertSourceDocumentLine(vendInvoiceInfoTable);

        vendInvoiceInfoTable.SourceDocumentLine = sourceDocumentLineRecId;

        if (purchSummary && purchSummary.sumBy() == AccountOrder::Auto)
        {
            // Prior to a summary update by Auto, fields were defaulted from the PO that need to be reset
            vendInvoiceInfoTable.cleanupAfterRearrange();
        }

        if (!VendParameters::find().editAutomaticHeaderMatching())
        {
            vendInvoiceInfoTable.LastMatchVariance = LastMatchVarianceOptions::Unknown;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll))
        {
            vendInvoiceInfoTable.VendBankAccountID = VendBankAccount::findDefault_LV(vendInvoiceInfoTable.OrderAccount, vendInvoiceInfoTable.CurrencyCode).AccountID;
        }

        return vendInvoiceInfoTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRecordLists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records in the record lists into the database.
    /// </summary>
    protected void insertRecordLists()
    {
        recordInsertParmSubLine.insertDatabase();
        recordInsertVendInvoiceMatchingLine.insertDatabase();
        recordInsertListSourceDocumentHeader.insertDatabase();
        recordInsertListSourceDocumentLine.insertDatabase();

        recordInsertParmLine_Project.insertDatabase();

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            recordInsertParmLine_Asset_RU.insertDatabase();
            recordInsertParmTable_RU.insertDatabase();
        }
        // </GEERU>
        // <GEEU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU))
        {
            recordInsertParmTable_Officials.insertDatabase();
        }
        // </GEEU>

        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#VendInv_W))
        {
            recordInsertParmTable_W.insertDatabase();
        }

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            recordInsertParmLine_IN.insertDatabase();
        }
        // </GIN>

        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#VendInvLine_W))
        {
            recordInsertParmLine_W.insertDatabase();
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR]))
        {
            recordInsertParmLine_BR.insertDatabase();
        }

        // <GTH>
        if (TaxThaiGovCertificationFeatureChecker::isCountryRegionTH())
        {
            recordInsertParmTable_TH.insertDatabase();
        }
        // </GTH>

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSourceDocumentHeader</Name>
				<Source><![CDATA[
    protected SourceDocumentHeaderRecId insertSourceDocumentHeader(TradeLineRefId _tableRefId, AccountingDate _accountingDate)
    {
        SourceDocumentHeader sourceDocumentHeader;
        VendInvoiceInfoTable vendInvoiceInfoTable;

        sourceDocumentHeader.SourceRelationType = tableNum(VendInvoiceInfoTable);
        sourceDocumentHeader.TypeEnumName = vendInvoiceInfoTable.parmSourceDocHeaderTypeEnumName();
        sourceDocumentHeader.TypeEnumValue = this.parmSourceDocumentTypeEnumValue();

        sourceDocumentHeader.AccountingStatus = SourceDocumentAccountingStatus::InProcess;

        sourceDocumentHeader.RecId = systemSequence.reserveValues(1, tableNum(SourceDocumentHeader));

        recordInsertListSourceDocumentHeader.add(sourceDocumentHeader);

        this.insertSourceDocumentMap(_tableRefId, sourceDocumentHeader);

        return sourceDocumentHeader.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSourceDocumentLine</Name>
				<Source><![CDATA[
    private SourceDocumentLineRecId insertSourceDocumentLine(Common _common)
    {
        SourceDocumentLine sourceDocumentLine;
        SourceDocumentHeaderRecId sourceDocumentHeader;
        SourceDocumentHeader localSourceDocumentHeader;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceInfoSubTable vendInvoiceInfoSubTable;
        AccountingDate exchangeRateDate;

        switch (_common.TableId)
        {
            case tableNum(VendInvoiceInfoTable):

                vendInvoiceInfoTable = _common;

                if (parmSourceDocumentHeaderMap.exists(vendInvoiceInfoTable.TableRefId))
                {
                    localSourceDocumentHeader = parmSourceDocumentHeaderMap.lookup(vendInvoiceInfoTable.TableRefId);
                    sourceDocumentHeader = localSourceDocumentHeader.RecId;
                }

                sourceDocumentLine.SourceRelationType = tableNum(VendInvoiceInfoTable);
                sourceDocumentLine.TypeEnumName = vendInvoiceInfoTable.parmSourceDocLineTypeEnumName();
                sourceDocumentLine.TypeEnumValue = vendInvoiceInfoTable.parmSourceDocLineTypeEnumValue();
                exchangeRateDate = vendInvoiceInfoTable.parmExchangeRateDate();
                break;

            case tableNum(VendInvoiceInfoSubTable):

                vendInvoiceInfoSubTable = _common;

                if (parmSourceDocumentHeaderMap.exists(vendInvoiceInfoSubTable.TableRefId))
                {
                    localSourceDocumentHeader = parmSourceDocumentHeaderMap.lookup(vendInvoiceInfoSubTable.TableRefId);
                    sourceDocumentHeader = localSourceDocumentHeader.RecId;
                }
                exchangeRateDate = vendInvoiceInfoSubTable.vendInvoiceInfoTable().parmExchangeRateDate();
                break;

            case tableNum(VendInvoiceInfoLine):

                vendInvoiceInfoLine = _common;

                if (parmSourceDocumentHeaderMap.exists(vendInvoiceInfoLine.TableRefId))
                {
                    localSourceDocumentHeader = parmSourceDocumentHeaderMap.lookup(vendInvoiceInfoLine.TableRefId);
                    sourceDocumentHeader = localSourceDocumentHeader.RecId;
                }
                else
                {
                    // if not in memory then it must exist on disk, probably running from reselect
                    sourceDocumentHeader = vendInvoiceInfoLine.vendInvoiceInfoTable().SourceDocumentHeader;
                }

                sourceDocumentLine.SourceRelationType = tableNum(VendInvoiceInfoLine);
                sourceDocumentLine.TypeEnumName = vendInvoiceInfoLine.parmSourceDocLineTypeEnumName();
                sourceDocumentLine.TypeEnumValue = vendInvoiceInfoLine.parmSourceDocLineTypeEnumValue();

                exchangeRateDate = vendInvoiceInfoLine.parmExchangeRateDate();
                break;
        }

        sourceDocumentLine.SourceDocumentHeader = sourceDocumentHeader;
        sourceDocumentLine.AccountingStatus = SourceDocumentLineAccountingStatus::Draft;
        sourceDocumentLine.StateContainer = [conNull(),conNull(),conNull()];

        if (VendInvoicePostingDateAutoAdjustmentV2Flight::instance().isEnabled() && exchangeRateDate)
        {
            sourceDocumentLine.ExchangeRateDate = exchangeRateDate;
        }
        else
        {
            sourceDocumentLine.ExchangeRateDate = this.transDate();
        }
        Debug::assert(sourceDocumentLine.SourceDocumentHeader != 0);

        if (appl.sysRecIdSequence().isRecidSuspended(tableNum(SourceDocumentLine)))
        {
            sourceDocumentLine.RecId = systemSequence.reserveValues(1, tableNum(SourceDocumentLine));
            recordInsertListSourceDocumentLine.add(sourceDocumentLine);
        }
        else
        {
            sourceDocumentLine.insert();
        }

        return sourceDocumentLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSourceDocumentMap</Name>
				<Source><![CDATA[
    protected void insertSourceDocumentMap(TradeLineRefId _tableRefId, SourceDocumentHeader _sourceDocumentHeader)
    {
        parmSourceDocumentHeaderMap.insert(_tableRefId, _sourceDocumentHeader);

        if (isProcessingActiveInvoices)
        {
            // Add new source document header for the active invoice to the collection.
            newSourceDocumentHeaderIdSet.add(_sourceDocumentHeader.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertVendInvoiceInfoLine_BR</Name>
				<Source><![CDATA[
    private void insertVendInvoiceInfoLine_BR(
        VendInvoiceInfoTable _vendInvoiceInfoTable, 
        VendInvoiceInfoLine _vendInvoiceInfoLine)
    {
        if (_vendInvoiceInfoTable.purchTable().PurchaseType != PurchaseType::ReturnItem
            && ICMSSTAdditionalInfoFeature::isEnabled())
        {
            VendInvoiceInfoLine_BR vendInvoiceInfoLine_BR = _vendInvoiceInfoLine.vendInvoiceInfoLine_BR();
            TaxationCode_BR receiverICMSSTTaxationCode = _vendInvoiceInfoLine.getICMSSTTaxationCode_BR();

            if (receiverICMSSTTaxationCode)
            {
                EFDocRecXmlUpdICMSST_BR efDocRecXmlUpdICMSST = new EFDocRecXmlUpdICMSST_BR();
                TaxationCode_BR senderICMSSTTaxationCode = efDocRecXmlUpdICMSST.getICMSSTTaxationCode(_vendInvoiceInfoTable, _vendInvoiceInfoLine.RecId);

                if (!senderICMSSTTaxationCode)
                {
                    senderICMSSTTaxationCode = receiverICMSSTTaxationCode;
                }

                VendInvoiceInfoLine_W vendInvoiceInfoLine_W = _vendInvoiceInfoLine.vendInvoiceInfoLine_W();
                vendInvoiceInfoLine_BR.RespWithholdingICMSST = TaxRespWithholdingICMSSTSetup_BR::find(
                    CFOPTable_BR::find(vendInvoiceInfoLine_W.CFOPTable_BR).cfopId,
                    _vendInvoiceInfoTable.hasToIssueFiscalDocument_BR() ? FiscalDocumentIssuer_BR::OwnEstablishment : FiscalDocumentIssuer_BR::ThirdParty,
                    receiverICMSSTTaxationCode,
                    senderICMSSTTaxationCode,
                    SalesPurchTrntype_BR::Purchase).RespWithholdingICMSST;
            }

            _vendInvoiceInfoLine.packVendInvoiceInfoLine_BR(vendInvoiceInfoLine_BR);
            recordInsertParmLine_BR.add(vendInvoiceInfoLine_BR);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addVendInvoiceMatchingLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a record in the <c>VendInvoiceMatchingLine</c> table from a <c>PurchLine</c> record.
    /// </summary>
    /// <param name="_vendInvoiceInfoLine">A <c>VendInvoiceInfoLine</c> record with which the new <c>VendInvoiceMatchingLine</c> record will be associated.</param>
    /// <param name="_purchLine">The <c>PurchLine</c> record where the expected values will be found.</param>
    /// <param name="_varianceApproved">The <c>NoYes::Yes</c> enumeration value if the invoice has been approved to post with variances; otherwise, the <c>NoYes::No</c> enumeration value.</param>
    /// <remarks>This method should only be used to attach a <c>VendInvoiceMatchingLine</c> record to an existing <c>VendInvoiceInfoLine</c> record.</remarks>
    protected void addVendInvoiceMatchingLine(VendDocumentLineMap _vendInvoiceInfoLine, PurchLine _purchLine, NoYes _varianceApproved = NoYes::No)
    {
        VendInvoiceMatchingLine vendInvoiceMatchingLine =
            PurchFormletterParmDataInvoice::createVendInvoiceMatchingLineForServices(_vendInvoiceInfoLine, _purchLine, _varianceApproved);
        
        if (vendInvoiceMatchingLine.RefRecId)
        {
            recordInsertVendInvoiceMatchingLine.add(vendInvoiceMatchingLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyInvoiceNum</Name>
				<Source><![CDATA[
    protected Num interCompanyInvoiceNum(PurchTable _purchTable)
    {
        if (_purchTable.isInterCompanyOrder())
        {
            if (this.parmParmTableNum())
            {
                return this.parmParmTableNum();
            }

            changecompany(_purchTable.InterCompanyCompanyId)
            {
                return _purchTable.interCompanySalesTable().lastInvoice(true);
            }
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyParmLineQty</Name>
				<Source><![CDATA[
    protected Qty interCompanyParmLineQty(Common _common, boolean _isInventQty = false)
    {
        PurchLine           purchLineLocal = _common;
        CustInvoiceTrans    custInvoiceTrans;
        CustInvoiceJour     custInvoiceJour;
        InventQty           inventQty;
        Qty                 qty;
        InventTable         inventTable;
        UnitOfMeasureSymbol inventUnit;
        UnitOfMeasureSymbol intercompanyInventUnit;

        if (interCompanyCompanyId)
        {
            if (_isInventQty)
            {
                inventUnit = purchLineLocal.inventTable().inventUnitId();
            }
            changecompany(interCompanyCompanyId)
            {
                select forceplaceholders InventQty, Qty, SalesUnit, ItemId, InventDimId from custInvoiceTrans
                    where custInvoiceTrans.InventTransId == purchLineLocal.InterCompanyInventTransId
                exists join custInvoiceJour
                    where custInvoiceJour.InvoiceId == custInvoiceTrans.InvoiceId
                        && custInvoiceJour.InvoiceDate == custInvoiceTrans.InvoiceDate
                        && custInvoiceJour.NumberSequenceGroup == custInvoiceTrans.NumberSequenceGroup
                        && custInvoiceJour.SalesId == custInvoiceTrans.SalesId
                        && custInvoiceJour.ParmId == interCompanyParmId
                        && custInvoiceJour.InvoiceId == number;

                inventQty = custInvoiceTrans.InventQty;
                qty       = custInvoiceTrans.Qty;

                if (_isInventQty)
                {
                    intercompanyInventUnit = custInvoiceTrans.inventTable().inventUnitId();
                    if (inventUnit != intercompanyInventUnit)
                    {
                        inventQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(custInvoiceTrans.ItemId,
                                                                                                          custInvoiceTrans.InventDimId,
                                                                                                          inventQty,
                                                                                                          intercompanyInventUnit,
                                                                                                          inventUnit,
                                                                                                          NoYes::Yes);
                    }
                }
                else if (custInvoiceTrans.SalesUnit != purchLineLocal.PurchUnit)
                {
                    qty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(custInvoiceTrans.ItemId,
                                                                                                custInvoiceTrans.InventDimId,    
                                                                                                qty,
                                                                                                custInvoiceTrans.SalesUnit,
                                                                                                purchLineLocal.PurchUnit,
                                                                                                NoYes::Yes);
                }
            }
        }
        else
        {
            select forceplaceholders InventQty, Qty from custInvoiceTrans
                where custInvoiceTrans.InventTransId == purchLineLocal.InventRefTransId
                exists join custInvoiceJour
                    where custInvoiceJour.InvoiceId == custInvoiceTrans.InvoiceId
                        && custInvoiceJour.InvoiceDate == custInvoiceTrans.InvoiceDate
                        && custInvoiceJour.NumberSequenceGroup == custInvoiceTrans.NumberSequenceGroup
                        && custInvoiceJour.SalesId == custInvoiceTrans.SalesId
                        && custInvoiceJour.ParmId == interCompanyParmId
                        && custInvoiceJour.InvoiceId == number;

            inventQty = custInvoiceTrans.InventQty;
            qty       = custInvoiceTrans.Qty;
        }

        return _isInventQty ? inventQty : qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAccountInQuery</Name>
				<Source><![CDATA[
    protected boolean invoiceAccountInQuery()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayJournalBePosted</Name>
				<Source><![CDATA[
    protected boolean mayJournalBePosted(Common _sourceTable)
    {
        PurchTable sourceTable = _sourceTable as PurchTable;
        return super(_sourceTable) && sourceTable.mayInvoiceBeUpdated() && this.maySelectPO(sourceTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayJournalTransBePosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a parameter line is created for a given source line.
    /// </summary>
    /// <param name="_sourceLineTable">
    /// A source line record.
    /// </param>
    /// <returns>
    /// true if a parameter line is created for the source line; otherwise, false.
    /// </returns>
    protected boolean mayJournalTransBePosted(Common _sourceLineTable)
    {
        PurchLine sourceLineTable = _sourceLineTable as PurchLine;
        boolean nonPendingLinesExist;

        // We allow creation of an empty parmTable if there are no pending lines.

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && isFromPurchAgreement)
        {
            return true;
        }

        //<GEERU>
        if (this.canAllowEmptyParmTableByLine())
        {
            if (!scannedPurchIds)
            {
                scannedPurchIds = new Set(Types::String);
            }

            if (!this.parmAllowEmptyParmTable() && !scannedPurchIds.in(sourceLineTable.PurchId))
            {
                this.parmAllowEmptyParmTable(this.canCreateParmLine(sourceLineTable.PurchId,
                                                                    this.postingProfile_RU(sourceLineTable.purchLine_W().PostingProfile_RU,
                                                                                           sourceLineTable.purchTable().PostingProfile),
                                                                    this.inventProfileType_RU(sourceLineTable)));

                scannedPurchIds.add(sourceLineTable.PurchId);
            }
        }
        //</GEERU>

        if (sourceLineTable.isCategoryBased() && sourceLineTable.isInterCompanyOrder())
        {
            return false;
        }

        // <GIN>
        if (isFromBillOfEntry)
        {
            return (subLinesMap.elements() > 0);
        }
        else
        {
            // </GIN>
            if (!isFromPackingSlip)
            {
                nonPendingLinesExist = VendInvoiceInfoLine::existActiveNotSaved(this.parmParmId(), sourceLineTable.InventTransId);
                return !nonPendingLinesExist;
            }
            else
            {
                return (subLinesMap.elements() > 0);
            }
            // <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>maySelectPO</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a <c>PurchTable</c> table record may be selected for invoicing.
    /// </summary>
    /// <param name="_purchTable">
    /// A PurchTable table record.
    /// </param>
    /// <returns>
    /// true if the PurchTable table record may be selected for invoicing; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The PurchTable table record is checked to determine whether it has any MarkupTrans table records with a <c>MarkupType</c> enumerated value of <c>MarkupType::Item</c>.
    /// A PurchTable table record with such MarkupTrans table records must not be selected for invoicing.
    /// </remarks>
    protected boolean maySelectPO(PurchTable _purchTable)
    {
        if (Markup::hasMarkupTypeItem(_purchTable) && !(_purchTable.isInterCompanyOrder() && _purchTable.isDropShipment()))
        {
            info("@SYS115806");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveFromSavedToActive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies data from a saved <c>VendInvoiceInfoTable</c> table into an active
    /// <c>VendInvoiceInfoTable</c> table.
    /// </summary>
    /// <param name="_savedVendInvoiceInfoTable">
    /// The record in the <c>VendInvoiceInfoTable</c> table that represents the structure from which to
    /// copy.
    /// </param>
    /// <returns>
    /// true if one or more subtable source accounting events has changed; otherwise, false.
    /// </returns>
    protected boolean moveFromSavedToActive(VendInvoiceInfoTable _savedVendInvoiceInfoTable)
    {
        LastMatchVariance origLastMatchVariance = _savedVendInvoiceInfoTable.LastMatchVariance;

        boolean hasAccountingEventChanged = VendInvoiceInfoTable::moveFromSavedToActive(_savedVendInvoiceInfoTable, this.parmId(), purchParmUpdate.CreditRemaining);

        if (origLastMatchVariance != LastMatchVarianceOptions::Unknown && _savedVendInvoiceInfoTable.LastMatchVariance == LastMatchVarianceOptions::Unknown)
        {
            wasMatchStatusReset = true;
        }

        // If the posting date is in a period that is closed or on hold, and the user won't be able to edit the posting date, we will ask if we should update it
        if (!isPostingDateInClosedPeriod &&
            (_savedVendInvoiceInfoTable.RequestStatus == VendInvoiceRequestStatus::Approved ||
                (_savedVendInvoiceInfoTable.RequestStatus == VendInvoiceRequestStatus::InReview && !VendInvoiceWorkflow::isUserTaskOrApprovalOwner(_savedVendInvoiceInfoTable))) &&
            !LedgerFiscalCalendar::checkLedgerPeriodDateModule(CompanyInfoHelper::fiscalCalendarRecId(), _savedVendInvoiceInfoTable.updateDate(), SysModule::Purch, false))
        {
            isPostingDateInClosedPeriod = true;
        }

        return hasAccountingEventChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveTaxRegulations</Name>
				<Source><![CDATA[
    protected void moveTaxRegulations()
    {
        TaxWorkRegulation taxWorkRegulation;
        VendInvoiceInfoTable localVendInvoiceInfoTable;
        PurchTable localPurchTable;

        ttsbegin;
        update_recordset taxWorkRegulation
        setting HeadingTableId = localVendInvoiceInfoTable.TableId,
                HeadingRecId = localVendInvoiceInfoTable.RecId
        join localPurchTable
            where taxWorkRegulation.HeadingTableId == localPurchTable.TableId &&
                taxWorkRegulation.HeadingRecId == localPurchTable.RecId
        join localVendInvoiceInfoTable
            where localVendInvoiceInfoTable.ParmId == this.parmId() &&
                localVendInvoiceInfoTable.PurchId == localPurchTable.PurchId;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needVarianceApproval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the specified <c>VendInvoiceInfoTable</c> table record needs variance approval.
    /// </summary>
    /// <param name="_vendInvoiceInfoTable">
    /// The record to check.
    /// </param>
    /// <returns>
    /// true if the specified record needs variance approval; otherwise, false.
    /// </returns>
    protected boolean needVarianceApproval(VendDocumentTableMap _vendInvoiceInfoTable)
    {
        Debug::assert(_vendInvoiceInfoTable.TableId == tableNum(VendInvoiceInfoTable));

        return _vendInvoiceInfoTable.VarianceApproved == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packExtensions</Name>
				<Source><![CDATA[
    public void packExtensions(VendDocumentTableMap _oldParmTable, VendDocumentTableMap _newParmTable)
    {
        VendInvoiceInfoTable_W vendInvoiceInfoTable_W;
        VendInvoiceInfoTable_RU vendInvoiceInfoTable_RU;
        VendInvoiceInfoTable localVendInvoiceInfoTable;
        // <GTH>
        VendInvoiceInfoTableExtensionTH vendInvoiceInfoTableExtensionTH;
        // </GTH>

        Debug::assert(_oldParmTable.TableId == tableNum(VendInvoiceInfoTable));

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            localVendInvoiceInfoTable = _oldParmTable;
            vendInvoiceInfoTable_RU = localVendInvoiceInfoTable.vendInvoiceInfoTable_RU();
            _newParmTable.packVendInvoiceInfoTable_RU(vendInvoiceInfoTable_RU);
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#VendInv_W))
        {
            localVendInvoiceInfoTable = _oldParmTable;
            vendInvoiceInfoTable_W = localVendInvoiceInfoTable.vendInvoiceInfoTable_W();
            _newParmTable.packVendInvoiceInfoTable_W(vendInvoiceInfoTable_W);
        }

        // <GTH>
        if (TaxThaiGovCertificationFeatureChecker::isCountryRegionTH())
        {
            localVendInvoiceInfoTable = _oldParmTable;
            vendInvoiceInfoTableExtensionTH = localVendInvoiceInfoTable.vendInvoiceInfoTableExtensionTH();
            _newParmTable.packVendInvoiceInfoTableExtensionTH(vendInvoiceInfoTableExtensionTH);
        }
        // </GTH>
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAutoConsolidate</Name>
				<Source><![CDATA[
    public boolean parmAutoConsolidate(boolean _autoConsolidate = autoConsolidate)
    {
        autoConsolidate = _autoConsolidate;
        return autoConsolidate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreditRemaining</Name>
				<Source><![CDATA[
    protected boolean parmCreditRemaining(boolean _creditRemaining = creditRemaining)
    {
        // An invoice line's quantity cannot have a different sign than the PO, so we will never credit a remaining quantity
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExternalDefaultedParmTable</Name>
				<Source><![CDATA[
    public VendDocumentTableMap parmExternalDefaultedParmTable(VendDocumentTableMap _externalDefaultedParmTable = externalDefaultedParmTable)
    {
        VendDocumentTableMap localVendDocumentTableMap;

        localVendDocumentTableMap = super(_externalDefaultedParmTable);

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            if (localVendDocumentTableMap.TableId == tableNum(VendInvoiceInfoTable))
            {
                isFromPurchAgreement = localVendDocumentTableMap.PurchAgreementHeader_PSN && !localVendDocumentTableMap.PurchId;
            }
        }

        return localVendDocumentTableMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceType</Name>
				<Source><![CDATA[
    public PurchInvoiceType parmInvoiceType(PurchInvoiceType _invoiceType = invoiceType)
    {
        invoiceType = _invoiceType;
        return invoiceType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineAssetTableId</Name>
				<Source><![CDATA[
    protected TableId parmLineAssetTableId()
    {
        return tableNum(VendInvoiceInfoLine_Asset);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineProjectTableId</Name>
				<Source><![CDATA[
    protected TableId parmLineProjectTableId()
    {
        return tableNum(VendInvoiceInfoLine_Project);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineTableId</Name>
				<Source><![CDATA[
    protected TableId parmLineTableId()
    {
        return tableNum(VendInvoiceInfoLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmUpdate</Name>
				<Source><![CDATA[
    public Common parmParmUpdate(Common _purchParmUpdate = purchParmUpdate)
    {
        PurchParmUpdate ret;

        ret = super(_purchParmUpdate);
        isFromPackingSlip = ret.SpecQty == PurchUpdate::PackingSlip;
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            isFromPackingSlip = isFromPackingSlip && !isFromPurchAgreement;
        }
        // <GIN>
        if (TaxParameters::isCustomsEnable_IN())
        {
            isFromBillOfEntry = ret.SpecQty == PurchUpdate::BillOfEntryQuantity_IN;
            if (isFromBillOfEntry)
            {
                isFromPackingSlip = false;
            }
        }
        // </GIN>
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQueryChooseLinesPendingInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the query used against the <c>VendInvoiceInfoTable</c> to select the lines to copy to the <c>VendInvoiceInfoTable</c>.
    /// </summary>
    /// <param name="_chooseLinesPendingInvoice">
    /// When setting, the SysQueryRun to store.
    /// </param>
    /// <returns>
    /// The SysQueryRun used to select the lines to copy from the pending invoice.
    /// </returns>
    public SysQueryRun parmQueryChooseLinesPendingInvoice(SysQueryRun _chooseLinesPendingInvoice = chooseLinesPendingInvoice)
    {
        chooseLinesPendingInvoice = _chooseLinesPendingInvoice;
        return chooseLinesPendingInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocumentTypeEnumValue</Name>
				<Source><![CDATA[
    protected SourceDocumentTypeEnumValue parmSourceDocumentTypeEnumValue()
    {
        return SourceDocument_VendorInvoice::VendorInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocumentLineRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the source document line record id.
    /// </summary>
    /// <param name="_sourceDocumentLineRecId">
    /// The source document line record id.
    /// </param>
    /// <returns>
    /// The source document line record id.
    /// </returns>
    public RecId parmSourceDocumentLineRecId(RecId _sourceDocumentLineRecId = sourceDocumentLineRecId)
    {
        sourceDocumentLineRecId = _sourceDocumentLineRecId;
        return sourceDocumentLineRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSubLineTableId</Name>
				<Source><![CDATA[
    protected TableId parmSubLineTableId()
    {
        return tableNum(VendInvoiceInfoSubLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSubTableMapKey</Name>
				<Source><![CDATA[
    protected str parmSubTableMapKey(Common _common)
    {
        str key;
        VendDocumentTableMap vendInvoiceInfoTable = this.initParmTable();
        VendInvoiceInfoSubTable vendInvoiceInfoSubTable;
        VendInvoiceInfoLine vendInvoiceInfoLine;

        switch (_common.TableId)
        {
            case tableNum(VendInvoiceInfoTable) :
                vendInvoiceInfoTable = _common;
                key = this.addToKey(key, vendInvoiceInfoTable.TableRefId);
                key = this.addToKey(key, vendInvoiceInfoTable.PurchId);
                break;
            case tableNum(VendInvoiceInfoLine) :
                vendInvoiceInfoLine = _common;
                key = this.addToKey(key,vendInvoiceInfoLine.TableRefId);
                key = this.addToKey(key,vendInvoiceInfoLine.OrigPurchId);
                break;
            case tableNum(VendInvoiceInfoSubTable) :
                vendInvoiceInfoSubTable = _common;
                key = this.addToKey(key, vendInvoiceInfoSubTable.TableRefId);
                key = this.addToKey(key, vendInvoiceInfoSubTable.OrigPurchId);
                break;
        }

        return key;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSubTableTableId</Name>
				<Source><![CDATA[
    protected TableId parmSubTableTableId()
    {
        return tableNum(VendInvoiceInfoSubTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTableMapKey</Name>
				<Source><![CDATA[
    protected str parmTableMapKey(Common _source)
    {
        VendDocumentTableMap vendInvoiceInfoTable = this.initParmTable();
        // <GEERU>
        VendDocumentLineMap vendInvoiceInfoLine = this.initParmLine();

        #ISOcountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        AgreementLine agreementLine;
        VendDocumentTableMap parmTable = this.initParmTable();
        str key = super(_source);

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && !key)
        {
            switch (_source.TableId)
            {
                case tableNum(AgreementLine):
                    agreementLine = _source;
                    key = this.addToKey(key, agreementLine.purchAgreementHeader().PurchNumberSequence);
                    break;

                case this.parmTableTableId():
                    parmTable = _source;
                    key = this.addToKey(key, PurchAgreementHeader::find(parmTable.PurchAgreementHeader_PSN).PurchNumberSequence);
                    break;
            }
        }

        if (this.splitSavedInvoice())
        {
            switch (_source.TableId)
            {
                case this.parmTableTableId() :
                    vendInvoiceInfoTable = _source;
                    key = this.addToKey(key, vendInvoiceInfoTable.TableRefId);
                    break;
                // <GEERU>
                case this.parmLineTableId() :
                    if (countryRegion_RU &&
                        (this.splitInventProfileType_RU() ||
                         this.splitPostingProfile_RU()))
                    {
                        vendInvoiceInfoLine = _source;
                        key = this.addToKey(key, vendInvoiceInfoLine.TableRefId);
                    }
                    break;
                // </GEERU>
            }
        }

        return key;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTableTableId</Name>
				<Source><![CDATA[
    protected TableId parmTableTableId()
    {
        return tableNum(VendInvoiceInfoTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTradeLineRefId_RU</Name>
				<Source><![CDATA[
    public TradeLineRefId parmTradeLineRefId_RU(TradeLineRefId _tradeLineRefId = tradeLineRefId)
    {
        tradeLineRefId = _tradeLineRefId;
        return tradeLineRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWInterCompanyParmLineQty</Name>
				<Source><![CDATA[
    protected PdsCWInventQty pdsCWInterCompanyParmLineQty(Common _common)
    {
        PurchLine purchLineLocal = _common;
        CustInvoiceTrans custInvoiceTrans;
        CustInvoiceJour custInvoiceJour;

        if (interCompanyCompanyId)
        {
            changecompany(interCompanyCompanyId)
            {
                select forceplaceholders PdsCWQty from custInvoiceTrans
                    where custInvoiceTrans.InventTransId == purchLineLocal.InterCompanyInventTransId
                    exists join custInvoiceJour
                        where custInvoiceJour.InvoiceId == custInvoiceTrans.InvoiceId
                            && custInvoiceJour.InvoiceDate == custInvoiceTrans.InvoiceDate
                            && custInvoiceJour.NumberSequenceGroup == custInvoiceTrans.NumberSequenceGroup
                            && custInvoiceJour.SalesId == custInvoiceTrans.SalesId
                            && custInvoiceJour.ParmId == interCompanyParmId
                            && custInvoiceJour.InvoiceId == number;
            }
        }
        else
        {
            select forceplaceholders PdsCWQty from custInvoiceTrans
                where custInvoiceTrans.InventTransId == purchLineLocal.InventRefTransId
                exists join custInvoiceJour
                    where custInvoiceJour.InvoiceId == custInvoiceTrans.InvoiceId
                        && custInvoiceJour.InvoiceDate == custInvoiceTrans.InvoiceDate
                        && custInvoiceJour.NumberSequenceGroup == custInvoiceTrans.NumberSequenceGroup
                        && custInvoiceJour.SalesId == custInvoiceTrans.SalesId
                        && custInvoiceJour.ParmId == interCompanyParmId
                        && custInvoiceJour.InvoiceId == number;
        }

        return custInvoiceTrans.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAdditionalMoveFromSavedToActive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies data from a saved <c>VendInvoiceInfoTable</c> table into an active <c>VendInvoiceInfoTable</c> table.
    /// </summary>
    /// <param name = "_savedVendInvoiceInfoTable">The record buffer.</param>
    /// <param name = "_accountingEventChangedMap">A map that keeps track of which purchase orders' accounting event have changed.</param>
    protected void processAdditionalMoveFromSavedToActive(VendInvoiceInfoTable _savedVendInvoiceInfoTable, Map _accountingEventChangedMap)
    {
        PurchParmUpdate         activePurchParmUpdate;
        VendInvoiceInfoTable    activeVendInvoiceInfoTable;
        VendInvoiceInfoTable    localVendInvoiceInfoTable;
        boolean                 isAccountingEventChanged = false;

        if (VendInvoiceInfoTable::isActive(_savedVendInvoiceInfoTable.TableRefId, this.parmId()))
        {
            select firstonly CreatedBy from activePurchParmUpdate
                exists join activeVendInvoiceInfoTable
                    where activeVendInvoiceInfoTable.ParmId == activePurchParmUpdate.ParmId &&
                        activeVendInvoiceInfoTable.TableRefId == _savedVendInvoiceInfoTable.TableRefId;

            if (activePurchParmUpdate.CreatedBy == curUserId() || !this.isUserOnLine(activePurchParmUpdate.CreatedBy))
            {
                activeInvoiceList.addEnd(_savedVendInvoiceInfoTable.TableRefId);
            }
            else
            {
                this.setActiveInvoiceFlag(VendActiveInvoiceFlags::InvoiceInUse, true);
                invoicesInUseList.addEnd(_savedVendInvoiceInfoTable.RecId);
            }
        }
        else if (!_savedVendInvoiceInfoTable.isAdvance() || callerTable.TableId == tableNum(VendInvoiceInfoTable))
        {
            select firstOnly forupdate localVendInvoiceInfoTable
                    where localVendInvoiceInfoTable.TableRefId == _savedVendInvoiceInfoTable.TableRefId
                        && localVendInvoiceInfoTable.ParmId == '';

            if (localVendInvoiceInfoTable)
            {
                isAccountingEventChanged = this.moveFromSavedToActive(localVendInvoiceInfoTable);
                this.insertParmTableMap(localVendInvoiceInfoTable);
            }
            else
            {
                isAccountingEventChanged = false;
            }
        }

        if (isAccountingEventChanged)
        {
            _accountingEventChangedMap.insert(_savedVendInvoiceInfoTable.TableRefId, NoYes::Yes);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAdditional</Name>
				<Source><![CDATA[
    /// <summary>
    /// Overrides method to support the processing of additional lines in parameter tables that were used
    /// by the purchase invoice.
    /// </summary>
    // chooseLines query initially represents both saved invoices and new invoices as a single query.
    // After criteria is entered the single query is split into two queries by disabling VendInvoiceInfo
    // in the initial query, and processing it separately (chooseLinesPendingInvoice query).
    // For performance reasons saved invoices should be processed first.
    protected void processAdditional()
    {
        VendInvoiceInfoTable savedVendInvoiceInfoTable;
        VendInvoiceInfoSubTable vendInvoiceInfoSubTable;
        MapEnumerator invoiceMapEnumerator;
        VendInvoiceInfoTable activeVendInvoiceInfoTable;
        PurchTotals localPurchTotals;
        SourceDocumentLine sourceDocumentLine;
        SourceDocumentLineItem currentSourceDocumentLineItem;
        SourceDocumentLineAccountingStatus requestedSourceDocumentLineAccountingStatus;
        AccountingDate newExchangeRateDate;
        Map accountingEventChangedMap;

        // Begin processing pending invoices.
        isProcessingActiveInvoices = false;

        super();

        if (this.parmProcessAdditional())
        {
            parmTableMap = new Map(Types::String, Types::Record);
            accountingEventChangedMap = new Map(Types::String, Types::Enum);

            QueryBuildDataSource purchTableDS = chooseLinesPendingInvoice.query().dataSourceTable(tableNum(PurchTable));

            if (purchTableDS.joinMode() != JoinMode::InnerJoin || purchTableDS.rangeCount() == 0)
            {
                purchTableDS.enabled(false);
            }

            // Retrieve saved PO invoices
            chooseLinesPendingInvoice.reset();
            while (chooseLinesPendingInvoice.next())
            {
                if (chooseLinesPendingInvoice.changed(tableNum(VendInvoiceInfoTable)))
                {
                    savedVendInvoiceInfoTable = chooseLinesPendingInvoice.get(tableNum(VendInvoiceInfoTable));

                    this.processAdditionalMoveFromSavedToActive(savedVendInvoiceInfoTable, accountingEventChangedMap);

                    if (savedVendInvoiceInfoTable.RecId)
                    {
                        // Refresh the record buffer since ParmId is generated when invoice is set to active.
                        savedVendInvoiceInfoTable.reread();

                        while select OrigPurchId from vendInvoiceInfoSubTable
                            where vendInvoiceInfoSubTable.TableRefId == savedVendInvoiceInfoTable.TableRefId
                                && vendInvoiceInfoSubTable.ParmId == savedVendInvoiceInfoTable.ParmId
                                && vendInvoiceInfoSubTable.OrigPurchId != ''
                        {
                            // add pending invoice to the list
                            if (!pendingInvoices.exists(vendInvoiceInfoSubTable.OrigPurchId))
                            {
                                pendingInvoices.insert(vendInvoiceInfoSubTable.OrigPurchId, VendInvoiceSaveStatus::Pending);
                            }
                        }
                    }
                }
            }

            // Retrieve saved non-PO invoices
            chooseLinesNonPOInvoice.reset();
            while (chooseLinesNonPOInvoice.next())
            {
                if (chooseLinesNonPOInvoice.changed(tableNum(VendInvoiceInfoTable)))
                {
                    savedVendInvoiceInfoTable = chooseLinesNonPOInvoice.get(tableNum(VendInvoiceInfoTable));
                    
                    this.processAdditionalMoveFromSavedToActive(savedVendInvoiceInfoTable, accountingEventChangedMap);
                }
            }

            invoiceMapEnumerator = parmTableMap.getEnumerator();
            while (invoiceMapEnumerator.moveNext())
            {
                activeVendInvoiceInfoTable = invoiceMapEnumerator.currentValue();

                // only calc taxes & redistribute the document if the PO's accounting event has changed
                if (!accountingEventChangedMap.exists(activeVendInvoiceInfoTable.TableRefId))
                {
                    continue;
                }

                // Now that the entire document is on disk with the exception of Tax, call PurchTotals to default TaxUncommitted.
                localPurchTotals = PurchTotals::newParmTable(activeVendInvoiceInfoTable, // parmTable
                                                        PurchUpdate::All, // specQty
                                                        activeVendInvoiceInfoTable.ParmId, // parmId
                                                        '', // sumPurchId
                                                        activeVendInvoiceInfoTable.Ordering, // documentStatus
                                                        PurchTotalsCachingMethod::Reuse); // Use existing cache (override default)
                localPurchTotals.calc(true, false, true);

                // Now the Active Copy of the invoice should be distributed.
                while select sourceDocumentLine
                    where sourceDocumentLine.SourceDocumentHeader == activeVendInvoiceInfoTable.SourceDocumentHeader
                {
                    // NOTE - this class does not create the SDLs in a top down left to right fashion and the SDL fascade expects that, so we will walk ALL
                    // the SDLs for the given header.

                    currentSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(sourceDocumentLine);

                    if (sourceDocumentLine.SourceRelationType == tableNum(TaxUncommitted))
                    {
                        // Tax must follow its parent.
                        requestedSourceDocumentLineAccountingStatus = currentSourceDocumentLineItem.parmParentSourceDocumentLineItem().parmSourceDocumentLine().AccountingStatus;
                    }
                    // <GIN>
                    else if (TaxWithholdParameters_IN::checkTaxParameters() && sourceDocumentLine.SourceRelationType == tableNum(TaxWithholdUncommitted_IN))
                    {
                        // TaxWithHoldUncommitted_IN must follow its parent.
                        requestedSourceDocumentLineAccountingStatus = currentSourceDocumentLineItem.parmParentSourceDocumentLineItem().parmSourceDocumentLine().AccountingStatus;
                    }
                    // </GIN>
                    else
                    {
                        requestedSourceDocumentLineAccountingStatus = currentSourceDocumentLineItem.parmSourceDocumentLine().AccountingStatus;
                    }

                    SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(sourceDocumentLine.getSourceDocumentLineImplementation(), true, requestedSourceDocumentLineAccountingStatus);
                }

                if (VendInvoicePostingDateAutoAdjustmentV2Flight::instance().isEnabled())
                {
                    newExchangeRateDate = activeVendInvoiceInfoTable.parmExchangeRateDate();
                }
                else
                {
                    newExchangeRateDate = activeVendInvoiceInfoTable.updateDate();
                }
                if (this.transDate() != newExchangeRateDate)
                {
                    SourceDocumentHeaderProvider::updateExchangeRateDate(activeVendInvoiceInfoTable.SourceDocumentHeader, newExchangeRateDate);
                }
            }
        }

        // End processing pending invoices.
        isProcessingActiveInvoices = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUserOnLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Is the user online.
    /// </summary>
    /// <param name = "_userId">The user Id</param>
    /// <returns>
    /// True when the user is online; otherwise false.
    /// </returns>
    protected boolean isUserOnLine(UserId _userId)
    {
        boolean isUserOnLine;
        SysUserLog userLog;
        utcdatetime nullDateTime;

        isUserOnLine = SysUsersOnline::isUserOnline(_userId);

        if (isUserOnLine)
        {
            select firstonly userLog
                where  userLog.UserId == _userId
                    && userLog.Alive == 1
                    && userLog.Type == SysLogType::Login
                    && userLog.LogoutDateTime == nullDateTime;

            if (!userLog)
            {
                isUserOnLine = false;
            }
        }

        return isUserOnLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPrepaymentApplication</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method processes the prepayment invoices that can be applied to the standard invoice
    /// based on the prepayment application policy.
    /// </summary>
    /// <param name="_vendInvoiceInfoTable">
    /// The <c>VendInvoiceInfoTable</c> record for which prepayment invoices needs to be processed.
    /// </param>
    protected void processPrepaymentApplication(VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        VendAdvanceInvoiceApplication vendAdvanceInvoiceApplication = VendAdvanceInvoiceApplication::construct(_vendInvoiceInfoTable);
        VendParameters vendParameters = VendParameters::find();

        if (vendParameters.PurchPrepayApplicationPolicy == PurchPrepayApplicationPolicy::Notification)
        {
            if (!this.isSetActiveInvoiceFlag(VendActiveInvoiceFlags::PrepaymentApplicationPending) && vendAdvanceInvoiceApplication.hasPrepaymentApplicationPending(false))
            {
                //Give a message that a prepayment application is pending
                this.setActiveInvoiceFlag(VendActiveInvoiceFlags::PrepaymentApplicationPending, true);
            }
        }
        else if (vendParameters.PurchPrepayApplicationPolicy == PurchPrepayApplicationPolicy::Automatic)
        {
            if (vendAdvanceInvoiceApplication.hasPrepaymentApplicationPending(true))
            {
                if (!_vendInvoiceInfoTable.isNonPO() && VendAdvanceBlockApplyWithPaymentScheduleFlight::instance().isEnabled() && _vendInvoiceInfoTable.purchTable().PaymentSched != "")
                {
                    warning("@AccountsPayable:BlockPrepaymentWithPaymSchedule");
                }
                else
                {
                    //Apply prepayment invoices to the standard invoice
                    vendAdvanceInvoiceApplication.createPrepaymentApplicationLines();
                }
            }
        }

        // Find the related PO when there are prepayment invoices that have been marked
        // for settlement but not paid, if this feature is enabled.
        if (this.hasRelatedPrepaymentWithMarkedSettlementNotPaid(_vendInvoiceInfoTable))
        {
            //Give a message that a prepayment application is marked
            this.setActiveInvoiceFlag(VendActiveInvoiceFlags::PrepaymentApplicationMarked, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasRelatedPrepaymentWithMarkedSettlementNotPaid</Name>
				<Source><![CDATA[
    private boolean hasRelatedPrepaymentWithMarkedSettlementNotPaid(VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        VendInvoiceInfoSubTable vendInvoiceInfoSubTable;
        VendInvoiceJour vendInvoiceJour;
        VendTrans vendTrans;
        VendTransOpen vendTransOpen;
        SpecTrans specTrans;

        // Find the related PO when there are prepayment invoices that have been marked for settlement but not paid
        select firstonly RecId from vendInvoiceInfoSubTable
                where vendInvoiceInfoSubTable.ParmId == _vendInvoiceInfoTable.ParmId
                    && vendInvoiceInfoSubTable.TableRefId == _vendInvoiceInfoTable.TableRefId
                    && vendInvoiceInfoSubTable.OrigPurchId != ''
                exists join vendInvoiceJour
                    where vendInvoiceJour.InvoiceType == PurchInvoiceType::VendorAdvance
                        && vendInvoiceJour.PurchId == vendInvoiceInfoSubTable.OrigPurchId
                exists join vendTrans
                    where vendTrans.Voucher == vendInvoiceJour.LedgerVoucher
                        && vendTrans.AccountNum == vendInvoiceJour.OrderAccount
                        && vendTrans.TransDate == vendInvoiceJour.InvoiceDate
                        && vendTrans.Invoice == vendInvoiceJour.InvoiceId
                exists join vendTransOpen
                    where vendTransOpen.RefRecId == vendTrans.RecId
                exists join specTrans
                    where specTrans.RefCompany == vendTransOpen.dataAreaId
                        && specTrans.RefTableId == VendTransOpen.TableId
                        && specTrans.RefRecId == VendTransOpen.RecId;

        return vendInvoiceInfoSubTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchStatusRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the purchase status range to use to select purchase orders to be invoice updated.
    /// </summary>
    /// <returns>
    /// The purchase status range to use to select purchase orders to be invoice updated.
    /// </returns>
    protected str purchStatusRange()
    {
        return queryRange(PurchStatus::Backorder,PurchStatus::Received);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyInvent</Name>
				<Source><![CDATA[
    public container qtyInvent(PurchLine _purchLine, InventQty _qty = 0)
    {
        // <GIN>
        if (isFromBillOfEntry)
        {
            _qty = newPostingInventQty;
        }
        else
        {
            // </GIN>
            if (isFromPackingSlip)
            {
                _qty = newPostingInventQty;
            }
            // <GIN>
        }
        // </GIN>
        return super(_purchLine, _qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyPurch</Name>
				<Source><![CDATA[
    public container qtyPurch(PurchLine _purchLine, PurchQty _qty = 0, PurchUpdate _specQty = purchParmUpdate.SpecQty)
    {
        // <GIN>
        if (isFromBillOfEntry)
        {
            _qty = newPostingInventQty;
        }
        else
        {
            // </GIN>
            if (_specQty == PurchUpdate::PackingSlip)
            {
                _qty = newPostingPurchQty;
            }
            // <GIN>
        }
        // </GIN>
        return super(_purchLine, _qty, _specQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryName</Name>
				<Source><![CDATA[
    protected str queryName()
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && isFromPurchAgreement)
        {
            return queryStr(PurchAgreementUpdate_PSN);
        }
        else if (isFromPackingSlip)
        {
            return queryStr(PurchUpdatePackingSlip);
        }
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeCreateNewJournal</Name>
				<Source><![CDATA[
    protected boolean reArrangeCreateNewJournal(PurchTable _purchTable, VendDocumentTableMap _parmTable, VendDocumentSubTableMap _parmSubTable)
    {
        VendInvoiceInfoTable invoiceTable = _parmTable;

        Debug::assert(_parmSubTable.TableId == tableNum(VendInvoiceInfoSubTable));

        if (_parmSubTable.isNonPO())
        {
            if (invoiceTable.isNonPO())
            {
                purchTable = VendInvoiceInfoTable::initPurchTableFromNonPO(invoiceTable);
            }
            else
            {
                purchTable = invoiceTable.purchTable();
            }
        }

        if (previousSubTable && (_parmSubTable.isNonPO() || previousSubTable.isNonPO()))
        {
            // Non-PO invoice lines will stay with the "master" invoice when sum by is none
            if (purchSummary.sumBy() == AccountOrder::None && (_parmSubTable.TableRefId == previousSubTable.TableRefId))
            {
                previousSubTable = _parmSubTable.data();
                return false;
            }
        }

        previousSubTable = _parmSubTable.data();

        return ((_parmSubTable.isNonPO() || this.checkIfPurchOrderExist(purchTable)) && purchSummary.createNewJournal(purchTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeEnd</Name>
				<Source><![CDATA[
    protected void reArrangeEnd()
    {
        using (var activityContextInvoice = this.instrumentationLogger().formLetterParmDataActivities().reArrangeEndInvoice())
        {
            VendInvoiceInfoTable newInvoice;
            boolean doUpdate;
            MarkupTrans localMarkupTrans;
            VendInvoiceInfoSubTable localVendInvoiceInfoSubTable;

            MapEnumerator unapproveInvoicesEnumerator = unapproveInvoiceTotalsMap.getEnumerator();
            MapEnumerator holdUnapproveInvoicesEnumerator = holdUnapproveInvoicesMap.getEnumerator();

            ttsbegin;

            super();

            while select forupdate MarkupCode from localMarkupTrans
                join PurchId, ParmId, TableRefId from newInvoice
                    where newInvoice.ParmId == purchParmUpdate.ParmId
                        && newInvoice.TableId == localMarkupTrans.TransTableId
                        && newInvoice.RecId == localMarkupTrans.TransRecId
            {
                select count(RecId) from localVendInvoiceInfoSubTable
                    where localVendInvoiceInfoSubTable.ParmId == newInvoice.ParmId &&
                        localVendInvoiceInfoSubTable.TableRefId == newInvoice.TableRefId;

                if (localVendInvoiceInfoSubTable.RecId == 1)
                {
                    // UnArranged invoices are not allowed MarkupTrans on VendInvoiceInfoTable
                    info(strFmt("@SYS120666", localMarkupTrans.MarkupCode, newInvoice.PurchId));

                    localMarkupTrans.delete();
                }
            }

            ttscommit;

            while (unapproveInvoicesEnumerator.moveNext())
            {
                newInvoice = VendInvoiceInfoTable::find(purchParmUpdate.ParmId, unapproveInvoicesEnumerator.currentValue(), true);

                // If new invoice was retrieved, unapprove it and reset the expected totals
                if (newInvoice)
                {
                    // Unapprove the invoice
                    newInvoice.approveVariance(false, true);
                }
            }

            while (holdUnapproveInvoicesEnumerator.moveNext())
            {
                newInvoice = VendInvoiceInfoTable::find(purchParmUpdate.ParmId, holdUnapproveInvoicesEnumerator.currentKey(), true);

                // If new invoice was retrieved, put it on hold and/or unapprove it
                if (newInvoice)
                {
                    if (newInvoice.Hold == NoYes::No && holdUnapproveInvoicesEnumerator.currentValue() & #HOLD == #HOLD)
                    {
                        newInvoice.Hold = NoYes::Yes;
                        newInvoice.VendInvoiceSaveStatus = VendInvoiceSaveStatus::Pending;
                        doUpdate = true;
                    }
                    if (newInvoice.VarianceApproved == NoYes::Yes && holdUnapproveInvoicesEnumerator.currentValue() & #UNAPPROVE == #UNAPPROVE)
                    {
                        newInvoice.approveVariance(false, false);
                        doUpdate = true;
                    }

                    if (doUpdate)
                    {
                        newInvoice.update();
                        doUpdate = false;
                    }
                }
            }

            this.createInvoiceInfoMarkupMatchingTolerances(this.parmId());

            this.splitSavedInvoice(NoYes::No);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeInit</Name>
				<Source><![CDATA[
    protected void reArrangeInit()
    {
        super();

        unapproveInvoiceTotalsMap = new Map(typeName2Type(extendedTypeStr(TradeLineRefId)), Types::String);
        arrangedInvoicesMap = new Map(typeName2Type(extendedTypeStr(TradeLineRefId)), Types::String);
        holdUnapproveInvoicesMap = new Map(typeName2Type(extendedTypeStr(TradeLineRefId)), Types::Integer);
        previousSubTable.clear();

        this.splitSavedInvoice(NoYes::Yes);

        if (purchSummary.sumBy() == AccountOrder::Auto)
        {
            // Update fields on the invoices so they can be sorted properly for arranging
            VendInvoiceInfoTable::rearrangeInitFromPO(purchParmUpdate.ParmId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeParmSubTableMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the source document header and parent source document line references of the <c>SourceDocumentLine</c> records
    /// for the <c>MarkupTrans</c> records associated to a <c>VendInvoiceInfoSubTable</c> record.
    /// </summary>
    /// <param name="_vendInvoiceInfoSubTable">
    /// The <c>VendInvoiceInfoSubTable</c> record to process the <c>MarkupTrans</c> records for.
    /// </param>
    /// <param name="_tableRefId">
    /// The unique identifier of the new vendor invoice
    /// </param>
    protected void reArrangeParmSubTableMarkup(VendDocumentSubTableMap _vendInvoiceInfoSubTable, TradeLineRefId _tableRefId)
    {
        MarkupTrans markupTrans;

        Debug::assert(_vendInvoiceInfoSubTable.TableId != tableNum(VendDocumentSubTableMap));

        // Get the SourceDocumentLine for the markupTrans referenced by the subTable that is being updated.
        while select SourceDocumentLine from markupTrans
            where markupTrans.TransTableId == tableNum(VendInvoiceInfoSubTable)
                && markupTrans.TransRecId == _vendInvoiceInfoSubTable.RecId

        {
            this.updateSourceDocumentLines(markupTrans.SourceDocumentLine, this.getSourceDocumentHeaderRecId(_tableRefId), defaultDimension);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeParmTableMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the source document header and parent source document line references of the <c>SourceDocumentLine</c> records
    /// for the <c>MarkupTrans</c> records associated to a <c>VendInvoiceInfoTable</c> record.
    /// </summary>
    /// <param name="_vendInvoiceInfoTable">
    /// The <c>VendInvoiceInfoTable</c> record to process the <c>MarkupTrans</c> records for.
    /// </param>
    /// <param name="_tableRefId">
    /// The unique identifier of the new vendor invoice
    /// </param>
    protected void reArrangeParmTableMarkup(VendDocumentTableMap _vendInvoiceInfoTable, TradeLineRefId _tableRefId)
    {
        MarkupTrans markupTrans;

        Debug::assert(_vendInvoiceInfoTable.TableId != tableNum(VendDocumentTableMap));

        // Get the SourceDocumentLine for the markupTrans referenced by the Vend Document Table that is being updated.
        while select SourceDocumentLine from markupTrans
            where markupTrans.TransTableId == tableNum(VendInvoiceInfoTable)
                && markupTrans.TransRecId == _vendInvoiceInfoTable.RecId
        {
            this.updateSourceDocumentLines(markupTrans.SourceDocumentLine, this.getSourceDocumentHeaderRecId(_tableRefId), defaultDimension);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeUpdateParmLine</Name>
				<Source><![CDATA[
    //This overrides reArrangeUpdateParmLine on PurchForletterParmData to make it invoice-specific. A call to super() would break that.
    protected void reArrangeUpdateParmLine(ParmId _fromParmId, PurchId _fromPurchId, TradeLineRefId _fromTableRefId, TradeLineRefId _toTableRefId)
    {
        SourceDocumentLine sourceDocumentLine;
        VendInvoiceInfoLineMarkupMatchingTrans vendInvoiceInfoLineMarkupMatchingTrans;
        VendInvoiceInfoLine localVendInvoiceInfoLine;
        VendInvoiceInfoSubTable oldSubTable, newSubTable;

        ttsbegin;

        // Get the SourceDocumentLine for the VendInvoiceInfoLine that is being updated.
        while select RecId from sourceDocumentLine
            exists join localVendInvoiceInfoLine
                where localVendInvoiceInfoLine.SourceDocumentLine == sourceDocumentLine.RecId
                    && localVendInvoiceInfoLine.ParmId == _fromParmId
                    && localVendInvoiceInfoLine.OrigPurchId == _fromPurchId
                    && localVendInvoiceInfoLine.TableRefId == _fromTableRefId
        {
            this.updateSourceDocumentLines(sourceDocumentLine.RecId, this.getSourceDocumentHeaderRecId(_toTableRefId));
        }

        localVendInvoiceInfoLine.clear();

        update_recordset localVendInvoiceInfoLine
            setting TableRefId = _toTableRefId
            where localVendInvoiceInfoLine.ParmId == _fromParmId
                && localVendInvoiceInfoLine.OrigPurchId == _fromPurchId
                && localVendInvoiceInfoLine.TableRefId == _fromTableRefId;

        ttscommit;

        //Super Type/Sub Type pattern does not support set based operations
        while select forupdate vendInvoiceInfoLineMarkupMatchingTrans
            where vendInvoiceInfoLineMarkupMatchingTrans.VendInvoiceInfoLineParmId == _fromParmId
                && vendInvoiceInfoLineMarkupMatchingTrans.VendInvoiceInfoLineTableRefId == _fromTableRefId
                && vendInvoiceInfoLineMarkupMatchingTrans.VendInvoiceInfoLineOrigPurchId == _fromPurchId
        {
            vendInvoiceInfoLineMarkupMatchingTrans.VendInvoiceInfoLineTableRefId = _toTableRefId;
            vendInvoiceInfoLineMarkupMatchingTrans.update();
        }

        // Move the expected totals for these lines
        this.reArrangeUpdateVendInvoiceMatching(_fromParmId, _fromTableRefId, _toTableRefId);

        // Move non-PO misc charges, as the non-PO lines will never be unarranged
        if (_fromPurchId == '')
        {
            newSubTable = VendInvoiceInfoSubTable::find(_fromParmId, _toTableRefId, _fromPurchId);

            if (newSubTable.RecId != 0)
            {
                // If the new SubTable already exists, move the old subTable misc charges to the new record
                oldSubTable = VendInvoiceInfoSubTable::find(_fromParmId, _fromTableRefId, _fromPurchId);

                this.reArrangeParmSubTableMarkup(oldSubTable, _toTableRefId);

                Markup::move(oldSubTable.TableId, oldSubTable.RecId, newSubTable.TableId, newSubTable.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeUpdateParmSingleLine</Name>
				<Source><![CDATA[
    protected void reArrangeUpdateParmSingleLine(VendDocumentLineMap _line, PurchId _fromPurchId, TradeLineRefId _toTableRefId)
    {
        // see also reArrangeUpdateParmLine implementation
        VendInvoiceInfoLineMarkupMatchingTrans vendInvoiceInfoLineMarkupMatchingTrans;
        VendInvoiceInfoLine localVendInvoiceInfoLine = _line;
        TradeLineRefId fromTableRefId = _line.orig().TableRefId;

        this.updateSourceDocumentLines(localVendInvoiceInfoLine.SourceDocumentLine, this.getSourceDocumentHeaderRecId(_toTableRefId));

        //Super Type/Sub Type pattern does not support set based operations
        while select forupdate vendInvoiceInfoLineMarkupMatchingTrans
            where vendInvoiceInfoLineMarkupMatchingTrans.VendInvoiceInfoLineParmId ==_line.ParmId
                && vendInvoiceInfoLineMarkupMatchingTrans.VendInvoiceInfoLineTableRefId == fromTableRefId
                && vendInvoiceInfoLineMarkupMatchingTrans.VendInvoiceInfoLineOrigPurchId == _line.OrigPurchId
                && vendInvoiceInfoLineMarkupMatchingTrans.VendInvoiceInfoLineNum == _line.LineNum
        {
            vendInvoiceInfoLineMarkupMatchingTrans.VendInvoiceInfoLineTableRefId = _toTableRefId;
            vendInvoiceInfoLineMarkupMatchingTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeUpdateParmSubTable</Name>
				<Source><![CDATA[
    protected void reArrangeUpdateParmSubTable(VendDocumentSubTableMap _vendInvoiceInfoSubTable)
    {
        VendInvoiceInfoSubMarkupMatchingTrans vendInvoiceInfoSubMarkupMatchingTrans;

        Debug::assert(_vendInvoiceInfoSubTable.TableId == tableNum(VendInvoiceInfoSubTable));

        super(_vendInvoiceInfoSubTable);

        // Get the SourceDocumentLine for the markupTrans referenced by the subTable that is being updated.
        this.reArrangeParmSubTableMarkup(_vendInvoiceInfoSubTable, _vendInvoiceInfoSubTable.TableRefId);

        //Super-type/Sub-type pattern does not support set based operations
        while select forupdate vendInvoiceInfoSubMarkupMatchingTrans
            where vendInvoiceInfoSubMarkupMatchingTrans.VendInvoiceInfoSubTableParmId == _vendInvoiceInfoSubTable.ParmId
                && vendInvoiceInfoSubMarkupMatchingTrans.VendInvoiceInfoSubTableOrigPurchId == _vendInvoiceInfoSubTable.OrigPurchId
        {
            vendInvoiceInfoSubMarkupMatchingTrans.VendInvoiceInfoSubTableTableRefId = _vendInvoiceInfoSubTable.TableRefId;
            vendInvoiceInfoSubMarkupMatchingTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeUpdateParmTable</Name>
				<Source><![CDATA[
    protected void reArrangeUpdateParmTable(VendDocumentTableMap _vendInvoiceInfoTable)
    {
        Debug::assert(_vendInvoiceInfoTable.TableId == tableNum(VendInvoiceInfoTable));

        super(_vendInvoiceInfoTable);

        // Get the SourceDocumentLine for the markupTrans referenced by the Vend Document Table that is being updated.
        this.reArrangeParmTableMarkup(_vendInvoiceInfoTable, _vendInvoiceInfoTable.TableRefId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeUpdateVendInvoiceMatching</Name>
				<Source><![CDATA[
    //Move the expected totals during the arrange:
    //    a) 1-to-1: Move is all that’s needed
    //    b) many-to-1: If VIM record already exists on new invoice, delete from old and unapprove new, resetting expected totals
    //    c) 1-to-many: If old record VIM is already gone, unapprove new invoice, resetting expected totals
    //          Find the first new invoice that got the old totals record and unapprove it too
    protected void reArrangeUpdateVendInvoiceMatching(ParmId _fromParmId, TradeLineRefId _fromTableRefId, TradeLineRefId _toTableRefId)
    {
        VendInvoiceMatching oldVIM;
        boolean unapprove;

        if (VendParameters::find().UseTotalPriceMatching == NoYes::No)
        {
            return;
        }

        // 1-to-many: If old VIM record is already gone, unapprove new invoice, resetting expected totals
        //        Find the first new invoice that got the old totals record and unapprove it too
        oldVIM = VendInvoiceMatching::findActive(_fromParmId, _fromTableRefId, true);
        if (oldVIM == null)
        {
            // many-to-many: VIM record is already moved - Nothing else is needed when the structure of the invoice isn't changing
            if (arrangedInvoicesMap.exists(_fromTableRefId) &&
                arrangedInvoicesMap.lookup(_fromTableRefId) == _toTableRefId)
            {
                return;
            }

            unapproveInvoiceTotalsMap.insert(_toTableRefId, _toTableRefId);
            unapprove = true;

            if (unapproveInvoiceTotalsMap.exists(_fromTableRefId))
            {
                unapproveInvoiceTotalsMap.insert(arrangedInvoicesMap.lookup(_fromTableRefId), arrangedInvoicesMap.lookup(_fromTableRefId));
            }
        }

        // many-to-1: If VIM record already exists on new invoice, delete from old and unapprove new, resetting expected totals
        if (VendInvoiceMatching::existsActive(_fromParmId, _toTableRefId))
        {
            if (oldVIM)
            {
                oldVIM.delete();
            }

            unapproveInvoiceTotalsMap.insert(_toTableRefId, _toTableRefId);
            unapprove = true;
        }

        if (!unapprove)
        {
            // Move the expected totals for these lines
            VendInvoiceMatching::moveActive(_fromParmId, _fromTableRefId, _fromParmId, _toTableRefId);
            arrangedInvoicesMap.insert(_fromTableRefId, _toTableRefId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recIdSuspensionTables</Name>
				<Source><![CDATA[
    protected List recIdSuspensionTables()
    {
        List list = super();

        list.addEnd(tableNum(SourceDocumentHeader));
        list.addEnd(tableNum(SourceDocumentLine));

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            list.addEnd(tableNum(VendInvoiceInfoTable_RU));
        }

        #EECountryRegionCodes
        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU))
        {
            list.addEnd(tableNum(VendInvoiceInfoTable_Officials));
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#VendInv_W))
        {
            list.addEnd(tableNum(VendInvoiceInfoTable_W));
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#VendInvLine_W))
        {
            list.addEnd(tableNum(VendInvoiceInfoLine_W));
        }

        // <GTH>
        if (TaxThaiGovCertificationFeatureChecker::isCountryRegionTH())
        {
            list.addEnd(tableNum(VendInvoiceInfoTableExtensionTH));
        }
        // </GTH>

        return list;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recopyMarkupFromPurchTable</Name>
				<Source><![CDATA[
    protected boolean recopyMarkupFromPurchTable(PurchTable _purchTable, VendInvoiceInfoSubTable _vendInvoiceInfoSubTable)
    {
        MarkupTrans markupTrans;
        MarkupTable markupTable;
        //<GIN>
        #ISOCountryRegionCodes
        boolean countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        //</GIN>

        Markup::recopyFromPurchOrder(_purchTable, _vendInvoiceInfoSubTable, currentInterCompanyInvoiceNum, _purchTable.CurrencyCode);

        // <GIN>
        if (countryRegion_IN && LedgerParameters::find().Miscellaneouscharges_IN)
        {
            select firstonly RecId from markupTrans
                where markupTrans.TransTableId == _vendInvoiceInfoSubTable.TableId
                    && markupTrans.TransRecId == _vendInvoiceInfoSubTable.RecId
                    && !markupTrans.IsDeleted
                exists join markupTable
                    where markupTable.ModuleType == markupTrans.ModuleType
                        && markupTable.MarkupCode == markupTrans.MarkupCode
                        && (markupTable.CustType == MarkupType::Item || markupTable.VendType == MarkupType::Item);
        }
        else
        {
            // </GIN>
            select firstonly RecId from markupTrans
                where markupTrans.TransTableId == _vendInvoiceInfoSubTable.TableId
                    && markupTrans.TransRecId == _vendInvoiceInfoSubTable.RecId
                    && !markupTrans.IsDeleted
                exists join markupTable
                    where markupTable.ModuleType == markupTrans.ModuleType
                        && markupTable.MarkupCode == markupTrans.MarkupCode
                        && (markupTable.CustType == MarkupType::Item || markupTable.VendType == MarkupType::Item);
            // <GIN>
        }
        // </GIN>
        return !markupTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelectEnd</Name>
				<Source><![CDATA[
    protected void reSelectEnd()
    {
        VendInvoiceInfoTable localVendInvoiceInfoTable;
        VendInvoiceInfoSubTable localVendInvoiceInfoSubTable;
        VendInvoiceInfoLine localVendInvoiceInfoLine;
        PurchTable localPurchTable;
        PurchLine localPurchLine;
        MarkupTrans markupTrans;
        MarkupCopy markupCopy;
        boolean isIntercompanyOrder;

        while select TableId, RecId, ParmId from localVendInvoiceInfoTable
            where localVendInvoiceInfoTable.ParmId == this.parmId()
        {
            // delete any taxUncommitted for the selected documents
            TaxUncommitted::deleteForDocumentHeader(localVendInvoiceInfoTable.TableId, localVendInvoiceInfoTable.RecId);
        }

        // --- Copy misc charges before creating total and MC matching info ---
        while select * from localVendInvoiceInfoSubTable
            join localVendInvoiceInfoTable
            join localPurchTable
            where localVendInvoiceInfoTable.ParmId == this.parmId()
                && localVendInvoiceInfoTable.VendInvoiceSaveStatus != VendInvoiceSaveStatus::Pending
                && localVendInvoiceInfoSubTable.ParmId == localVendInvoiceInfoTable.ParmId
                && localVendInvoiceInfoSubTable.TableRefId == localVendInvoiceInfoTable.TableRefId
                && localPurchTable.PurchId == localVendInvoiceInfoSubTable.OrigPurchId
        {
            isIntercompanyOrder = isIntercompanyOrder || localPurchTable.isInterCompanyOrder();

            if (!this.recopyMarkupFromPurchTable(localPurchTable, localVendInvoiceInfoSubTable))
            {
                // Recopy failed, so delete the entire invoice
                error("@SYS115806");
                localVendInvoiceInfoTable.delete();
            }
        }

        markupCopy = MarkupCopy::construct();

        if (!isIntercompanyOrder && !TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            while select localVendInvoiceInfoTable
            where localVendInvoiceInfoTable.ParmId == this.parmId()
                && localVendInvoiceInfoTable.VendInvoiceSaveStatus != VendInvoiceSaveStatus::Pending
            {
                // Perform set-based copy
                ttsbegin;

                MarkupCopyFromPurchOrderParameters copyFromPurchOrderToLineParameters =
                        this.createMarkupCopyParametersForReSelectEndInfoLine(
                            localPurchLine,
                            localVendInvoiceInfoLine,
                            '',
                            '',
                            SourceDocumentLineAccountingStatus::Draft,
                            null,
                            false);
                copyFromPurchOrderToLineParameters.parmBufferToWhereClause(this.buildWhereClauseForMarkupTransDestination(localVendInvoiceInfoTable, localVendInvoiceInfoLine));
                copyFromPurchOrderToLineParameters.parmBufferFromWhereClause(this.buildWhereClauseForMarkupTransSource(localPurchLine, localVendInvoiceInfoLine));
                copyFromPurchOrderToLineParameters.parmDocumentStatusToExclude(DocumentStatus::Invoice);
                markupCopy.copyForAllDocumentLines(copyFromPurchOrderToLineParameters);

                this.copyMarkupFromPurchOrderCleanup(localVendInvoiceInfoTable);

                ttscommit;
            }
        }
        else
        {
            if (this.shouldCopyMarkupFromBOEJournal())
            {
                select firstonly localVendInvoiceInfoTable
                    where localVendInvoiceInfoTable.ParmId == this.parmId()
                        && localVendInvoiceInfoTable.VendInvoiceSaveStatus != VendInvoiceSaveStatus::Pending;

                this.copyMarkupFromBOEJour(localVendInvoiceInfoTable);
            }
            else
            {
                while select * from localVendInvoiceInfoLine
                    join RecId from localVendInvoiceInfoTable
                    join localPurchLine
                        where localVendInvoiceInfoTable.ParmId == this.parmId()
                            && localVendInvoiceInfoTable.VendInvoiceSaveStatus != VendInvoiceSaveStatus::Pending
                            && localVendInvoiceInfoLine.ParmId == localVendInvoiceInfoTable.ParmId
                            && localVendInvoiceInfoLine.TableRefId == localVendInvoiceInfoTable.TableRefId
                            && localPurchLine.RecId == localVendInvoiceInfoLine.PurchLineRecId
                    join localPurchTable
                        where localPurchTable.PurchId == localPurchLine.PurchId
                    notExists join markupTrans
                        where markupTrans.TransTableId == localVendInvoiceInfoLine.TableId
                            && markupTrans.TransRecId == localVendInvoiceInfoLine.RecId
                            && !markupTrans.IsDeleted
                {
                    // keep the markupTrans at Draft so that its parent, ie, vendInvoiceInfoLine also stays in draft as vendInvoiceInfoLine taxes
                    // do not yet exist and will be missed during distribution.
                    MarkupCopyFromPurchOrderParameters copyFromPurchOrderToLineParameters =
                        this.createMarkupCopyParametersForReSelectEndInfoLine(
                            localPurchLine,
                            localVendInvoiceInfoLine,
                            '',
                            '',
                            SourceDocumentLineAccountingStatus::Draft,
                            localPurchTable,
                            false);
                    markupCopy.copyFromPurchOrder(copyFromPurchOrderToLineParameters);
                }
            }
        }

        this.createInvoiceInfoMarkupMatchingTolerances(this.parmId());

        // --- Always unapprove the variance on any reselect regardless if anything changed. Method forces update. ---
        while select forupdate localVendInvoiceInfoTable
            where localVendInvoiceInfoTable.ParmId == this.parmId()
                && localVendInvoiceInfoTable.VendInvoiceSaveStatus != VendInvoiceSaveStatus::Pending
        {
            localVendInvoiceInfoTable.approveVariance(false, true);

            // Add the source document header to the set for budget checking.
            newSourceDocumentHeaderIdSet.add(localVendInvoiceInfoTable.SourceDocumentHeader);

            VendInvoiceInfoTable::defaultCreditCorrection(localVendInvoiceInfoTable.RecId);

            this.processPrepaymentApplication(localVendInvoiceInfoTable);
        }

        // Performs budget check on newly selected invoices.
        this.checkBudget(PurchTotalsCachingMethod::Replace);

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.validateVendorInvoice_BR();
            FiscalReferenceParmCreator_BR::runForReturnVendInvoiceInfoTable(parmId);
        }
        // <GBR>

        this.reSelectVendInvoiceEnd(this.ParmId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCopyMarkupFromBOEJournal</Name>
				<Source><![CDATA[
    private boolean shouldCopyMarkupFromBOEJournal()
    {
        return TaxIntegrationUtils::isChargeOnBOEEnabled()
                && (isFromBillOfEntry || isFromPackingSlip)
                && this.purchParmUpdate.CustomsImportOrderType_IN == CustomsImportOrderType_IN::ImportOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelectInit</Name>
				<Source><![CDATA[
    protected void reSelectInit()
    {
        super();
        interCompanyInvoiceNumMap = new Map(typeName2Type(extendedTypeStr(PurchId)), Types::String);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelectLines</Name>
				<Source><![CDATA[
    protected void reSelectLines(PurchId _origOrderId)
    {
        TradeLineRefId tableRefId;
        PurchLine localPurchLine,prevPurchLine;
        // <GIN>
        CustomsVendBOETrans_IN customsVendBOETransCopy;
        // </GIN>
        Map map = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record);

        // Set currentInterComapnyInvoiceNum from values cached in fillOrigOrderIdSetSub
        currentInterCompanyInvoiceNum = interCompanyInvoiceNumMap.lookup(_origOrderId);

        // <GIN>
        if (isFromBillOfEntry)
        {
            // When creating from Bill Of Entry collect inventtrans to create sub lines.
            while select localPurchLine
                where localPurchLine.PurchId == _origOrderId
                    && localPurchLine.Blocked == NoYes::No
                    && !localPurchLine.IsDeleted
                join customsVendBOETransCopy
                    where customsVendBOETransCopy.InventTransId == localPurchLine.InventTransId
                        && customsVendBOETransCopy.PurchLineRecId == localPurchLine.RecId
                        && customsVendBOETransCopy.RemainingQty != 0
                        && customsVendBOETransCopy.Status != CustomsVendBOEStatus_IN::Canceled
            {
                tableRefId = this.getTableRefId(localPurchLine);
                if (localPurchLine.RecId != prevPurchLine.RecId)
                {
                    if (map.elements() > 0)
                    {
                        this.createParmLineAndSubLines(prevPurchLine,map.pack(),tableRefId);
                    }
                    prevPurchLine = localPurchLine.data();
                    map = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record);
                }

                map.insert(customsVendBOETransCopy.RecId, customsVendBOETransCopy);
            }

            if (prevPurchLine.RecId && map.elements() > 0)
            {
                this.createParmLineAndSubLines(prevPurchLine,map.pack(),tableRefId);
                prevPurchLine = null;
            }
        }
        else
        {
            // </GIN>
            if (!isFromPackingSlip)
            {
                super(_origOrderId);
            }
            else
            {
                // When creating from packing slip collect inventtrans to create sub lines.
                QueryRun queryRun = new QueryRun(this.buildInventoryTransactionsQuery(_origOrderId));
                while (queryRun.next())
                {
                    if (this.mustSkipCollectingInventTransactions())
                    {
                        continue;
                    }

                    localPurchLine = queryRun.get(tableNum(PurchLine));
                    tableRefId = this.getTableRefId(localPurchLine);

                    if (localPurchLine.RecId != prevPurchLine.RecId)
                    {
                        if (map.elements() > 0)
                        {
                            this.createParmLineAndSubLines(prevPurchLine,map.pack(),tableRefId);
                        }
                        prevPurchLine = localPurchLine.data();
                        map = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record);
                    }

                    VendPackingSlipTrans vendPackingSlipTrans = queryRun.get(tableNum(VendPackingSlipTrans));
                    map.insert(vendPackingSlipTrans.RecId, vendPackingSlipTrans);
                }

                if (prevPurchLine.RecId && map.elements() > 0)
                {
                    this.createParmLineAndSubLines(prevPurchLine,map.pack(),tableRefId);
                    prevPurchLine = null;
                }
            }
            // <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInventoryTransactionsQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query that retrieves the inventory transactions in order to create sub lines.
    /// </summary>
    /// <param name = "_origOrderId">The original order identifier.</param>
    /// <returns>The query.</returns>
    protected Query buildInventoryTransactionsQuery(PurchId _origOrderId)
    {
        Query query = new Query();

        QueryBuildDataSource qbdsPurchLine = query.addDataSource(tableNum(PurchLine));
        qbdsPurchLine.addRange(fieldNum(PurchLine, PurchId)).value(_origOrderId);
        qbdsPurchLine.addRange(fieldNum(PurchLine, Blocked)).value(queryValue(NoYes::No));
        qbdsPurchLine.addRange(fieldNum(PurchLine, IsDeleted)).value(queryValue(NoYes::No));
        
        QueryBuildDataSource qbdsVendPackingSlipTrans = qbdsPurchLine.addDataSource(tableNum(VendPackingSlipTrans));
        qbdsVendPackingSlipTrans.addLink(fieldNum(PurchLine, InventTransId), fieldNum(VendPackingSlipTrans, InventTransId));
        qbdsVendPackingSlipTrans.addRange(fieldNum(VendPackingSlipTrans, FullyMatched)).value(queryValue(NoYes::No));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSkipCollectingInventTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether inventory transactions must be collected when creating from packing slip in order to create sub lines.
    /// </summary>
    /// <returns>true if the inventory transactions must be collected; false, otherwise.</returns>
    protected boolean mustSkipCollectingInventTransactions()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelectVendInvoiceEnd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Perform additional processing on the vendor invoice after the reselect processing has been completed.
    /// </summary>
    /// <param name = "_parmId">The form letter parameter ID.</param>
    delegate void reSelectVendInvoiceEnd(ParmId _parmId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectChooseLinesNonStandard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates invoice lines based on user selection in the <c>PurchSelectLines</c> form.
    /// </summary>
    /// <returns>
    /// true if the chooseLines is handled; otherwise, false.
    /// </returns>
    protected boolean selectChooseLinesNonStandard()
    {
        boolean isHandled = false;

        //check the parameters for PurchSelectManager for invoice lines creation or deletion
        if (packedNewPurchLineRecIdSet !=conNull() ||
            packedDeletePurchTablePurchIdSet !=conNull() ||
            packedDeletePurchLineRecIdSet !=conNull())
        {
            this.chooseLinesFromPurchSelectLinesManager();
            isHandled = true;
        }
        else if (invoiceType == PurchInvoiceType::VendorAdvance && purchTable.RecId > 0) //prepayment invoice parameters check for prepayment creation
        {
            this.chooseLinesAdvance();
            isHandled = true;
        }
        return isHandled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectChooseLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls the methods for invoice lines creation.
    /// </summary>
    /// <param name="_append">
    /// A boolean value to indicate whether the invoice lines are to be appended instead of over-writing.
    /// </param>
    /// <remarks>
    /// The method <c>chooseLinesFromPurchSelectLinesManager()</c> is called for invoice lines creation or deletion
    /// when the packed sets are populated from <c>PurchSelectLines</c> form.
    /// </remarks>
    protected void selectChooseLines(boolean _append = false)
    {
        using (var _activityContext = SysInstrumentationLoggerFactory::CreateLogger(VendInvoiceInstrumentationConstants::SourceNameVendInvoiceCreationAndEdit)
            .activityContext(VendInvoiceInstrumentationConstants::ActivityNameCreateEditVendInvoice, VendInvoiceInstrumentationConstants::InstrumentationNamespace))
        {
            activityContext = _activityContext;

            boolean isHandled = this.selectChooseLinesNonStandard();

            if (!isHandled)
            {
                this.adjustLinesQuery(this.parmProcessAdditional());
                super(_append);
            }

            // Perform budget check
            this.checkBudget();
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.validateVendorInvoice_BR();
            FiscalReferenceParmCreator_BR::runForReturnVendInvoiceInfoTable(parmId);
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFromJournal</Name>
				<Source><![CDATA[
    public void selectFromJournal(container _packedTmpFrmVirtualList)
    {
        List tmpFrmVirtualList = List::create(_packedTmpFrmVirtualList);
        ListEnumerator enumerator = tmpFrmVirtualList.getEnumerator();

        PurchParmUpdate localPurchParmUpdate;
        VendPackingSlipJour vendPackingSlipJour;
        VendPackingSlipJour tmpVendPackingSlipJour;
        VendPackingSlipTrans vendPackingSlipTrans;
        TmpFrmVirtual tmpFrmVirtual;

        TradeLineRefId tableRef;

        PurchLine localPurchLine;
        PurchTable localPurchTable;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        Map purchLinePackingSlipLineMap;
        Map allowPostingMap = new Map(Types::String, Types::Enum);
        Map purchIdLinesMap = new Map(Types::String, Types::Container);
        Map packingSlipLineMap = new Map(typeName2Type(extendedTypeStr(RecId)),Types::Record);
        MapEnumerator me, lineEnumerator,invoiceTableMapEnumerator;
        InventQty remainInventFinancial;

        Map activeVendInvoiceInfoTableMap = new Map(Types::String, Types::Record);

        // <GEERU>
        PostingProfile postingProfile_RU;
        InventProfileType_RU inventProfileType_RU;
        PurchLine_W localPurchLine_W;
        // </GEERU>

        if (!this.parmParmUpdate().RecId)
        {
            ttsbegin;
            localPurchParmUpdate = this.createParmUpdate();
            this.insertParmUpdate(localPurchParmUpdate);
            ttscommit;
        }

        ttsbegin;

        this.initRecordLists();

        while (enumerator.moveNext())
        {
            tmpFrmVirtual.data(enumerator.current());
            tmpFrmVirtual.insert();

            // Cache each active invoice to use as a default later when creating new invoices
            select vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == purchParmUpdate.ParmId
                exists join vendPackingSlipJour
                    where vendPackingSlipJour.PurchId == vendInvoiceInfoTable.PurchId
                        && vendPackingSlipJour.TableId == tmpFrmVirtual.TableNum
                        && vendPackingSlipJour.RecId == tmpFrmVirtual.RecordNo;

            if (!activeVendInvoiceInfoTableMap.exists(vendInvoiceInfoTable.PurchId))
            {
                activeVendInvoiceInfoTableMap.insert(vendInvoiceInfoTable.PurchId, vendInvoiceInfoTable);
            }
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            vendInvoiceInfoTable = VendInvoiceInfoTable::find(purchParmUpdate.ParmId, tradeLineRefId);
            inventProfileType_RU = vendInvoiceInfoTable.vendInvoiceInfoTable_RU().InventProfileType_RU;
            postingProfile_RU = vendInvoiceInfoTable.PostingProfile;
        }
        // </GEERU>

        VendInvoiceInfoTable::deleteActiveWithoutUpdate(purchParmUpdate.ParmId);

        tmpVendPackingSlipJour.setTmp();

        while select tmpFrmVirtual
            order by Id
            join PackingSlipId, InventProfileType_RU from vendPackingSlipJour
                where tmpFrmVirtual.RecordNo == vendPackingSlipJour.RecId
                    && tmpFrmVirtual.TableNum == vendPackingSlipJour.TableId
            join vendPackingSlipTrans
                where vendPackingSlipJour.RecId == vendPackingSlipTrans.VendPackingSlipJour
                    && vendPackingSlipTrans.FullyMatched == NoYes::No
                join localPurchLine
                    where localPurchLine.InventTransId == vendPackingSlipTrans.InventTransId
                        && !localPurchLine.IsDeleted
        {
            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                localPurchTable = PurchTable::find(localPurchLine.PurchId);
                localPurchLine_W = localPurchLine.purchLine_W();

                if (vendInvoiceInfoTable && !(((localPurchLine_W.PostingProfile_RU && localPurchLine_W.PostingProfile_RU == postingProfile_RU) || (!localPurchLine_W.PostingProfile_RU && localPurchTable.PostingProfile == postingProfile_RU))
                    && vendPackingSlipJour.InventProfileType_RU == inventProfileType_RU))
                {
                    continue;
                }
            }
            // </GEERU>

            if (!allowPostingMap.exists(vendPackingSlipTrans.OrigPurchid))
            {
                localPurchTable = PurchTable::find(vendPackingSlipTrans.OrigPurchid);
                allowPostingMap.insert(vendPackingSlipTrans.OrigPurchid, this.mayJournalBePosted(localPurchTable));
            }
            if (!allowPostingMap.lookup(vendPackingSlipTrans.OrigPurchid))
            {
                continue;
            }

            if (localPurchLine.isStocked())
            {
                remainInventFinancial = vendPackingSlipTrans.remainInventFinancial();
                if ((remainInventFinancial == 0.0) ||
                    (vendPackingSlipTrans.InventQty * remainInventFinancial < 0) ||
                    (abs(vendPackingSlipTrans.InventQty) < abs(remainInventFinancial)))
                {
                    //The Inventory quantity to match for packing slip %1 item %2 cannot be reserved.
                    checkFailed(strFmt("@SYS111789", vendPackingSlipJour.PackingSlipId, localPurchLine.ItemId));
                    continue;
                }
            }

            if (purchIdLinesMap.exists(vendPackingSlipTrans.OrigPurchid))
            {
                purchLinePackingSlipLineMap = Map::create(purchIdLinesMap.lookup(vendPackingSlipTrans.OrigPurchid));
            }
            else
            {
                purchLinePackingSlipLineMap = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Container);
            }

            if (purchLinePackingSlipLineMap.exists(localPurchLine.RecId))
            {
                packingSlipLineMap = Map::create(purchLinePackingSlipLineMap.lookup(localPurchLine.RecId));
            }
            else
            {
                packingSlipLineMap = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record);
            }

            packingSlipLineMap.insert(vendPackingSlipTrans.RecId, vendPackingSlipTrans);
            purchLinePackingSlipLineMap.insert(localPurchLine.RecId, packingSlipLineMap.pack());
            purchIdLinesMap.insert(vendPackingSlipTrans.OrigPurchid, purchLinePackingSlipLineMap.pack());
        }

        if (VendBOEInvoiceFromProductReceiptMatchStatus_INFlight::instance().isEnabled()
            && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
            && TaxParameters::isCustomsEnable_IN()
            && localPurchTable
            && localPurchTable.purchTable_W().CustomsImportOrder_IN == NoYes::Yes)
        {
            if (!purchParmUpdate.selectForUpdate())
            {
                purchParmUpdate = PurchParmUpdate::find(purchParmUpdate.parmId, true);
            }
            purchParmUpdate.CustomsImportOrderType_IN = CustomsImportOrderType_IN::ImportOrder;
            purchParmUpdate.doUpdate();
        }
        
        me = purchIdLinesMap.getEnumerator();
        while (me.moveNext())
        {
            tableRef = this.getTableRefId(null, false);
            localPurchTable = PurchTable::find(me.currentKey());
            currentInterCompanyInvoiceNum = this.interCompanyInvoiceNum(localPurchTable);
            lineEnumerator = Map::create(me.currentValue()).getEnumerator();

            // Retrieve the PO's old invoice to use for defaulting when creating the new invoice
            if (activeVendInvoiceInfoTableMap.exists(me.currentKey()))
            {
                this.parmSkipParmTableDefaulting(true);
                this.parmExternalDefaultedParmTable(activeVendInvoiceInfoTableMap.lookup(me.currentKey()));
            }
            else
            {
                this.parmSkipParmTableDefaulting(false);
            }

            while (lineEnumerator.moveNext())
            {
                localPurchLine = PurchLine::findRecId(lineEnumerator.currentKey());
                this.createParmLineAndSubLines(localPurchLine, lineEnumerator.currentValue(), tableRef);
            }

            if (this.allowCreateParmTable())
            {
                // <GEERU>
                this.createParmTable(localPurchTable, null, tableRef, false, false, false, "", postingProfile_RU, inventProfileType_RU);
                // </GEERU>
            }
        }
        this.insertRecordLists();

        invoiceTableMapEnumerator = parmTableMap.getEnumerator();
        while (invoiceTableMapEnumerator.moveNext())
        {
            this.cleanupForHeader(invoiceTableMapEnumerator.currentValue());
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]))
        {
            this.defaultHeaderCountryRegionData();
        }

        ttscommit;
        this.fillOutputContract();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrompt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets or sets value of prompt.
    /// </summary>
    /// <param name = "_prompt">
    ///     A new value for the property.
    /// </param>
    /// <returns>
    ///     true if prompt dialog should be displayed; otherwise, false.
    /// </returns>
    public boolean parmPrompt(boolean _prompt = true)
    {
        return _prompt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateQtyNonInteractive</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    protected final boolean shouldUpdateQtyNonInteractive()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFromJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates invoice lines based on matched packing slips.
    /// </summary>
    /// <param name="_packedRecordList">
    /// A packed set of the <c>SalesPurchParmSubLineLinkTmp</c> records that represent matches between
    /// invoice lines and packing slip lines.
    /// </param>
    public void selectFromJournalLines(container _packedRecordList)
    {
        List packingSlipLinkList = List::create(_packedRecordList);
        ListEnumerator enumerator = packingSlipLinkList.getEnumerator();
        VendPackingSlipTrans localvendPackingSlipTrans;
        VendPackingSlipJour localvendPackingSlipJour;
        SalesPurchParmSubLineLinkTmp packingSlipLink;
        VendInvoiceInfoLine activeVendInvoiceInfoLine;
        VendInvoiceInfoLine activeVendInvoiceInfoLine2;
        PurchLine localPurchLine;
        RefRecId vendInvoiceInfoLineRecId;
        VendInvoiceInfoSubLine activeVendInvoiceInfoSubLine;
        InventQty tmpInventNow;
        PdsCWInventQty tmpCatchWeightNow;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        ParmId vendInvoiceInfoTableParmId;
        TradeLineRefId vendInvoiceInfoTableRefId;
        boolean prevRecordDeleted;
        boolean updateInvoiceLine; // indicates whether invoice line needs to be updated
        boolean updateQty;
        boolean shouldInitializeUpdateQty = true;
        boolean prompt =  this.parmPrompt();
        
        ttsbegin;

        while (enumerator.moveNext())
        {
            packingSlipLink.data(enumerator.current());
            packingSlipLink.insert();
        }
        
        while select packingSlipLink
            order by GrandParentRecId //this will get contiguous VendInvoiceInfoLine records so we can detect when we've moved to a new VendInvoiceInfoLine
            join localvendPackingSlipTrans
                where localvendPackingSlipTrans.RecId == packingSlipLink.ChildRecId
            join activeVendInvoiceInfoLine
                where activeVendInvoiceInfoLine.RecId == packingSlipLink.GrandParentRecId
                    && activeVendInvoiceInfoLine.ParmId != ''
            join localPurchLine
                where localPurchLine.InventTransId == localvendPackingSlipTrans.InventTransId
                    && !localPurchLine.IsDeleted
            join RecId, PackingSlipId, SourceDocumentHeader from localvendPackingSlipJour
                where localvendPackingSlipJour.RecId == localvendPackingSlipTrans.VendPackingSlipJour
        {

            if (packingSlipLink.Matched == NoYes::Yes)
            {
                if (packingSlipLink.InventQty == 0.0 && localPurchLine.isStocked())
                {
                    this.logVendInvoiceInfoLineMessage(localPurchLine, localvendPackingSlipJour);
                    continue;
                }

                if (localPurchLine.PurchQty > 0.0)
                {
                    if (localPurchLine.isStocked() && localvendPackingSlipTrans.InventQty < localvendPackingSlipTrans.remainInventFinancial(this.parmId()))
                    {
                        this.logVendInvoiceInfoLineMessage(localPurchLine, localvendPackingSlipJour);
                        continue;
                    }
                }
                else
                {
                    if (localPurchLine.isStocked() && localvendPackingSlipTrans.InventQty > localvendPackingSlipTrans.remainInventFinancial(this.parmId()))
                    {
                        this.logVendInvoiceInfoLineMessage(localPurchLine, localvendPackingSlipJour);
                        continue;
                    }
                }
            }

            if (vendInvoiceInfoLineRecId != activeVendInvoiceInfoLine.RecId)
            {
                // Positioned on a different purchParmLine

                if (updateInvoiceLine)
                {
                    // commit the previous record
                    this.updateInvoiceLine(activeVendInvoiceInfoLine2);
                }

                activeVendInvoiceInfoLine2.clear();

                tmpInventNow = 0.0;
                tmpCatchWeightNow = 0;
                updateInvoiceLine = false;

                select forupdate activeVendInvoiceInfoLine2
                    where activeVendInvoiceInfoLine2.RecId == activeVendInvoiceInfoLine.RecId;

                if (!VendInvoiceMatchPRDeleteBOESubLine_INFlight::instance().isEnabled() && TaxParameters::isCustomsEnable_IN())
                {
                    delete_from activeVendInvoiceInfoSubLine
                        where activeVendInvoiceInfoSubLine.LineRefRecId == activeVendInvoiceInfoLine.RecId
                            && activeVendInvoiceInfoSubLine.JournalRefTableId != tableNum(CustomsVendBOETrans_IN)
                            && activeVendInvoiceInfoSubLine.ParmId != '';
                }
                else
                {
                    delete_from activeVendInvoiceInfoSubLine
                        where activeVendInvoiceInfoSubLine.LineRefRecId == activeVendInvoiceInfoLine.RecId
                            && activeVendInvoiceInfoSubLine.ParmId != '';
                }
            }

            prevRecordDeleted = false;

            if (packingSlipLink.Matched == NoYes::Yes)
            {
                tmpInventNow += packingSlipLink.InventQty;
                tmpCatchWeightNow += packingSlipLink.PdsCWQty;

                newPostingInventQty = tmpInventNow;
                newPostingCWQty = tmpCatchWeightNow;

                [activeVendInvoiceInfoLine2.InventNow, activeVendInvoiceInfoLine2.RemainBeforeInvent, activeVendInvoiceInfoLine2.RemainAfterInvent] = this.qtyInvent(localPurchLine, tmpInventNow);
                if (PdsGlobal::pdsIsCWItem(activeVendInvoiceInfoLine2.ItemId))
                {
                    [activeVendInvoiceInfoLine2.PdsCWReceiveNow, activeVendInvoiceInfoLine2.PdsCWRemainBefore, activeVendInvoiceInfoLine2.PdsCWRemainAfter] = this.pdsCWQtyInvent(localPurchLine, tmpCatchWeightNow);
                }

                // Matching, create a VendInvoiceInfoSubLine.
                activeVendInvoiceInfoSubLine.clear();
                activeVendInvoiceInfoSubLine.initFromLine(activeVendInvoiceInfoLine2);
                activeVendInvoiceInfoSubLine.initFromVendPackingSlipTrans(localvendPackingSlipTrans);
                activeVendInvoiceInfoSubLine.ReceiveNow = packingSlipLink.PurchQty;
                activeVendInvoiceInfoSubLine.InventNow = packingSlipLink.InventQty;
                activeVendInvoiceInfoSubLine.PdsCWInventNow = packingSlipLink.PdsCWQty;
                
                if(VendInvoiceReceiveQtyUpdateTelemetryFlight::instance().isEnabled())
                {
                    var logger = SysInstrumentationLoggerFactory::CreateLogger("PurchFormletterParmDataInvoice::selectFromJournalLines");
                    logger.logInformation(strFmt("VendInoviceInfoSubLine.TableRefId->%1, original receiveNow->%2, updated receiveNow->%3, updated inventNow->%4", activeVendInvoiceInfoLine2.TableRefId, packingSlipLink.PurchQtyBeforeEdits, packingSlipLink.PurchQty, packingSlipLink.InventQty));
                }
                activeVendInvoiceInfoSubLine.insert();
            }

            vendInvoiceInfoTableRefId = activeVendInvoiceInfoLine2.TableRefId;
            vendInvoiceInfoTableParmId = activeVendInvoiceInfoLine2.ParmId;

            PurchFormLetterParmDataInvoiceUpdateQuantityParams updateQuantityParams = PurchFormLetterParmDataInvoiceUpdateQuantityParams::constructFromParams(
                packingSlipLink.GrandParentRecId,
                packingSlipLink,
                activeVendInvoiceInfoLine2,
                localPurchLine,
                updateQty,
                prevRecordDeleted,
                shouldInitializeUpdateQty,
                prompt);

            PurchFormLetterParmDataInvoiceUpdateQuantityResults results = this.updateInvoiceQuantity(updateQuantityParams);

            updateQty = results.updateQuantity;
            prevRecordDeleted = results.previousRecordDeleted;
            shouldInitializeUpdateQty = results.shouldInitializeUpdateQty;
            prompt = results.prompt;

            vendInvoiceInfoLineRecId = activeVendInvoiceInfoLine.RecId;

            if (!prevRecordDeleted && ((packingSlipLink.Matched != packingSlipLink.OriginalMatched)
                || (packingSlipLink.PurchQty != packingSlipLink.PurchQtyBeforeEdits)
                || (packingSlipLink.PdsCWQty != packingSlipLink.PdsCWQtyBeforeEdits)
                || updateQty))
            {
                updateInvoiceLine = true;
            }

            if ((updateInvoiceLine || prevRecordDeleted) && !vendInvoiceInfoTable)
            {
                vendInvoiceInfoTable = VendInvoiceInfoTable::find(vendInvoiceInfoTableParmId, vendInvoiceInfoTableRefId);
            }
        }

        if (updateInvoiceLine)
        {
            // commit the previous record
            this.updateInvoiceLine(activeVendInvoiceInfoLine2);
        }

        // if the invoice was altered, update the expected values
        if (vendInvoiceInfoTable)
        {
            VendInvoiceMatching::updateExpectedValues(vendInvoiceInfoTable);
        }

        ttscommit;
        this.fillOutputContract();
    }

]]></Source>
			</Method>
			<Method>
				<Name>logVendInvoiceInfoLineMessage</Name>
				<Source><![CDATA[
    private void logVendInvoiceInfoLineMessage(PurchLine _purchLine, VendPackingSlipJour _vendPackingSlipJour)
    {
        //Cannot reserve packing slip quantity
        setPrefix("@SYS112742");

        //Invoice line: item %1
        setPrefix(strFmt("@SYS112743", _purchLine.ItemId));

        //The inventory quantity to match for packing slip %1 item %2 cannot be reserved.
        checkFailed(strFmt("@SYS111789", _vendPackingSlipJour.PackingSlipId, _purchLine.ItemId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInvoiceLine</Name>
				<Source><![CDATA[
    private void updateInvoiceLine(VendInvoiceInfoLine _activeVendInvoiceInfoLine)
    {
        // give warning if the receiveNow quantity is less than the matching packing slip quantity
        if (VendInvoiceInfoSubLine::existForLine(_activeVendInvoiceInfoLine.RecId))
        {
            if (abs(_activeVendInvoiceInfoLine.ReceiveNow) < abs(_activeVendInvoiceInfoLine.purchQtyMatched())
                || (PdsGlobal::pdsIsCWItem(_activeVendInvoiceInfoLine.ItemId) && (abs(_activeVendInvoiceInfoLine.PdsCWReceiveNow) < abs(_activeVendInvoiceInfoLine.pdsCWQtyMatched()))))
            {
                checkFailed("@SYS120462");
            }
        }

        if (AccountingDistribution::existSourceDocumentLine(_activeVendInvoiceInfoLine.SourceDocumentLine))
        {
            // If distributions already exist, give warning and delete them
            checkFailed("@SYS327630");
            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(_activeVendInvoiceInfoLine, true, SourceDocumentLineAccountingStatus::Draft);
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            PurchLine purchLineLocal = _activeVendInvoiceInfoLine.purchLine();
            _activeVendInvoiceInfoLine.psaSetRetainage(_activeVendInvoiceInfoLine.LineAmount, this.parmDocumentStatus(), purchLineLocal);
        }

        _activeVendInvoiceInfoLine.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInvoiceQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates invoice line quantity values.
    /// </summary>
    /// <param name = "_purchFormLetterParmDataInvoiceUpdateQuantityParams">
    ///     <c>PurchFormLetterParmDataInvoiceUpdateQuantityParams</c> class instance holding values required to properly set line quantity values.
    /// </param>
    /// <returns>A <c>PurchFormLetterParmDataInvoiceUpdateQuantityResults</c> class instance holding results of the quantity update.</returns>
    protected PurchFormLetterParmDataInvoiceUpdateQuantityResults updateInvoiceQuantity(PurchFormLetterParmDataInvoiceUpdateQuantityParams _purchFormLetterParmDataInvoiceUpdateQuantityParams)
    {
        SalesPurchParmSubLineLinkTmp packingSlipLinkLoc;
        RealBase factor;
        AmountMST amountMST;
        
        VendInvoiceInfoLine activeVendInvoiceInfoLine = _purchFormLetterParmDataInvoiceUpdateQuantityParams.activeVendInvoiceInfoLine;
        
        // A new instance link(Populating data/Copying Reference) from packingSlipLink instance to the other with SQL temp db type tables(In Memory).
        packingSlipLinkLoc.linkPhysicalTableInstance(_purchFormLetterParmDataInvoiceUpdateQuantityParams.packingSlipLink);

        // Updating invoice line quantity if there is mismatch with matched quantity.
        select sum(PurchQty) from packingSlipLinkLoc
                where packingSlipLinkLoc.GrandParentRecId ==_purchFormLetterParmDataInvoiceUpdateQuantityParams.vendInvoiceInfoLineRecId
                    && packingSlipLinkLoc.Matched == NoYes::Yes;

        PurchFormLetterParmDataInvoiceUpdateQuantityResults results = PurchFormLetterParmDataInvoiceUpdateQuantityResults::construct();
        results.shouldInitializeUpdateQty = _purchFormLetterParmDataInvoiceUpdateQuantityParams.shouldInitializeUpdateQty;
        results.updateQuantity = _purchFormLetterParmDataInvoiceUpdateQuantityParams.updateQuantity;
        results.previousRecordDeleted = _purchFormLetterParmDataInvoiceUpdateQuantityParams.previousRecordDeleted;
        results.prompt = _purchFormLetterParmDataInvoiceUpdateQuantityParams.prompt;

        if (activeVendInvoiceInfoLine && activeVendInvoiceInfoLine.ReceiveNow != packingSlipLinkLoc.PurchQty)
        {
            if (results.shouldInitializeUpdateQty)
            {
                if (results.prompt)
                {
                    results.updateQuantity = PurchFormletterParmDataInvoice::promptForUpdateQty();
                    results.prompt = false;
                }
                else
                {
                    results.updateQuantity = this.shouldUpdateQtyNonInteractive();
                }

                results.shouldInitializeUpdateQty = false;
            }

            if (results.updateQuantity)
            {
                if (packingSlipLinkLoc.PurchQty == 0)
                {
                    activeVendInvoiceInfoLine.delete();
                    results.previousRecordDeleted = true;
                }
                else
                {
                    activeVendInvoiceInfoLine.ReceiveNow = packingSlipLinkLoc.PurchQty;
                    activeVendInvoiceInfoLine.VendDocumentLineMap::setQty(VendDocumentLineMap::header(activeVendInvoiceInfoLine).Ordering, VendDocumentLineMap::purchParmUpdate(activeVendInvoiceInfoLine).CreditRemaining,false,false);
                    activeVendInvoiceInfoLine.VendDocumentLineMap::setLineAmount();
                    // <GIN>
                    if (TaxParameters::checkTaxParameters_IN())
                    {
                        factor = _purchFormLetterParmDataInvoiceUpdateQuantityParams.purchLine.purchLine_IN().AssessableValueTransactionCurrency / _purchFormLetterParmDataInvoiceUpdateQuantityParams.purchLine.PurchQty;
                        activeVendInvoiceInfoLine.VendDocumentLineMap::parmAssessableValue_IN(factor * activeVendInvoiceInfoLine.ReceiveNow);
                        amountMST = TaxAssessableValueHandler_IN::calcAssessableValueAccountingCurrency(
                            activeVendInvoiceInfoLine.VendDocumentLineMap::parmAssessableValue_IN(), 
                            activeVendInvoiceInfoLine.CurrencyCode, 
                            activeVendInvoiceInfoLine.purchTable().AccountingDate);
                        activeVendInvoiceInfoLine.VendDocumentLineMap::parmAssessableValueAccountingCurrency(amountMST);
                    }
                    // </GIN>
                }
            }
        }

        return results;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setActiveInvoiceFlag</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets a specific bit in the <c>activeInvoiceFlags</c> integer to set or unset a flag. See
    /// the <c>VendActiveInvoiceFlags</c> enum for available values.
    /// </summary>
    /// <param name = "_flag">The flag to set</param>
    /// <param name = "_value">The value to set the flag to</param>
    protected void setActiveInvoiceFlag(VendActiveInvoiceFlags _flag, boolean _value)
    {
        if (_value)
        {
            //set the specified flag
            activeInvoiceFlags = activeInvoiceFlags | (1 << _flag);
        }
        else
        {
            //clear the specified flag
            activeInvoiceFlags = activeInvoiceFlags & ~(1 << _flag);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSetActiveInvoiceFlag</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the specified <c>VendActiveInvoiceFlags</c> flag is set.
    /// </summary>
    /// <param name="_flag">
    /// The flag to check
    /// </param>
    /// <returns>
    /// True if the specified flag is set
    /// </returns>
    protected boolean isSetActiveInvoiceFlag(VendActiveInvoiceFlags _flag)
    {
        return (activeInvoiceFlags >> _flag) & 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setHoldOrNotApproved</Name>
				<Source><![CDATA[
    protected void setHoldOrNotApproved(VendDocumentTableMap _parmTable, boolean _hold, boolean _notApproved)
    {
        int updateFlags;

        Debug::assert(_parmTable.TableId == tableNum(VendInvoiceInfoTable));

        // If the invoice has already been saved, then add the invoice to the map to be updated in rearrangeEnd()
        if (_parmTable.RecId != 0)
        {
            if (_hold)
            {
                updateFlags += #HOLD;
            }
            if (_notApproved)
            {
                updateFlags += #UNAPPROVE;
            }

            holdUnapproveInvoicesMap.insert(_parmTable.TableRefId, updateFlags);
        }
        else
        {
            // If the invoice has not been saved yet, just set the fields in the table buffer
            if (_hold)
            {
                // Place the new journal on hold
                _parmTable.Hold = NoYes::Yes;
                _parmTable.VendInvoiceSaveStatus = VendInvoiceSaveStatus::Pending;
            }
            if (_notApproved)
            {
                // Make sure new journal is not approved
                _parmTable.approveVariance(false, false);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setnewPostingPurchAndInventQty_IN</Name>
				<Source><![CDATA[
    protected void setnewPostingPurchAndInventQty_IN(RefRecId _customsVendBOETrans)
    {
        VendPackingSlipTrans vendPackingSlipTrans;
        CustomsVendBOETrans_IN customsVendBOETrans;
        CustomsVendPackingSlipBOETransLink_IN customsVendPackingSlipBOETransLink;
        PurchLine purchLineLoc;

        newPostingPurchQty = 0;
        newPostingInventQty = 0;

        if (isFromPackingSlip)
        {
            while select vendPackingSlipTrans
                exists join customsVendPackingSlipBOETransLink
                    where vendPackingSlipTrans.RecId == customsVendPackingSlipBOETransLink.VendPackingSlipTrans
                        && customsVendPackingSlipBOETransLink.CustomsVendBOETrans_IN == _customsVendBOETrans
                        && vendPackingSlipTrans.FullyMatched == NoYes::No
            {
                newPostingPurchQty += vendPackingSlipTrans.remainPurchFinancial();
                newPostingInventQty += vendPackingSlipTrans.remainInventFinancial();
            }
        }

        if (isFromBillOfEntry)
        {
            select sum(RemainingQty) from customsVendBOETrans
                where customsVendBOETrans.RecId == _customsVendBOETrans
                    && customsVendBOETrans.Status != CustomsVendBOEStatus_IN::Canceled;

            if (customsVendBOETrans.RemainingQty)
            {
                newPostingPurchQty = customsVendBOETrans.RemainingQty;
                purchLineLoc = CustomsVendBOETrans_IN::find(_customsVendBOETrans).purchLine();

                if (purchLineLoc.PurchUnit != purchLineLoc.inventTable().inventUnitId())
                {
                    newPostingInventQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(purchLineLoc.ItemId,
                                                                                                                purchLineLoc.InventDimId,
                                                                                                                customsVendBOETrans.RemainingQty,
                                                                                                                purchLineLoc.PurchUnit,
                                                                                                                purchLineLoc.inventTable().inventUnitId(),
                                                                                                                NoYes::Yes);
                }
                else
                {
                    newPostingInventQty = customsVendBOETrans.RemainingQty;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setParmTableLog</Name>
				<Source><![CDATA[
    void setParmTableLog(VendDocumentTableMap _vendInvoiceInfoTable)
    {
        Debug::assert(_vendInvoiceInfoTable.TableId == tableNum(VendInvoiceInfoTable));
        PurchFormletterParmDataInvoice::checkW9Received(_vendInvoiceInfoTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipMayJournalBePosted</Name>
				<Source><![CDATA[
    protected boolean skipMayJournalBePosted()
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && isFromPurchAgreement)
        {
            return true;
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipOrderIdInReSelect</Name>
				<Source><![CDATA[
    protected boolean skipOrderIdInReSelect(PurchTable _purchTable, VendDocumentTableMap _vendInvoiceInfoTable, VendDocumentSubTableMap _vendInvoiceInfoSubTable)
    {
        Debug::assert(_vendInvoiceInfoTable.TableId == tableNum(VendInvoiceInfoTable));
        Debug::assert(_vendInvoiceInfoSubTable.TableId == tableNum(VendInvoiceInfoSubTable));

        setPrefix(strFmt("@SYS76498", "@SYS15812", _vendInvoiceInfoSubTable.OrigPurchId));
        // currentInterCompanyInvoiceNum is used by recopyMarkupFromPurchTable
        currentInterCompanyInvoiceNum = this.interCompanyInvoiceNum(_purchTable);

        interCompanyInvoiceNumMap.insert(_vendInvoiceInfoSubTable.OrigPurchId, currentInterCompanyInvoiceNum);
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLineTableId</Name>
				<Source><![CDATA[
    protected TableId sourceLineTableId()
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && isFromPurchAgreement)
        {
            return tableNum(AgreementLine);
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTableChanged</Name>
				<Source><![CDATA[
    protected void sourceTableChanged(Common newSourceTable)
    {
        PurchTable sourceTable = newSourceTable as PurchTable;

        super(newSourceTable);

        if (!isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) || !isFromPurchAgreement)
        {
            if (this.parmParmTableNum() && newSourceTable.isInterCompanyOrder())
            {
                currentInterCompanyInvoiceNum = this.parmParmTableNum();
            }
            else
            {
                currentInterCompanyInvoiceNum = this.interCompanyInvoiceNum(newSourceTable);
            }
        }

        if (!this.canAllowEmptyParmTableByLine())
        {
            this.parmAllowEmptyParmTable(this.canCreateParmLine(sourceTable.PurchId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTableTableId</Name>
				<Source><![CDATA[
    protected TableId sourceTableTableId()
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && isFromPurchAgreement)
        {
            return tableNum(PurchAgreementHeader);
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitInventProfileType_RU</Name>
				<Source><![CDATA[
    public NoYes splitInventProfileType_RU(NoYes _splitInventProfileType = purchParmUpdate.SplitInventProfileType_RU)
    {
        purchParmUpdate.SplitInventProfileType_RU = _splitInventProfileType;
        return purchParmUpdate.SplitInventProfileType_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitPostingProfile_RU</Name>
				<Source><![CDATA[
    public NoYes splitPostingProfile_RU(NoYes _splitPostingProfile = purchParmUpdate.SplitPostingProfile_RU)
    {
        purchParmUpdate.SplitPostingProfile_RU = _splitPostingProfile;
        return purchParmUpdate.SplitPostingProfile_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitSavedInvoice</Name>
				<Source><![CDATA[
    protected NoYes splitSavedInvoice(NoYes _splitSavedInvoice = splitSavedInvoice)
    {
        splitSavedInvoice = _splitSavedInvoice;
        return splitSavedInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateParmAfterChooseLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Updates PurchParmUpdate table after chooselines is performed
    /// </summary>
    protected void updateParmAfterChooseLines()
    {
        PurchParmUpdate parmUpdate;

        if (VendParameters::find().CreditError && this.allInvoicesAreNegative())
        {
            ttsbegin;
            parmUpdate = PurchParmUpdate::find(parmId, true);
            parmUpdate.Storno = true;
            parmUpdate.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateParmTable</Name>
				<Source><![CDATA[
    protected void updateParmTable(VendDocumentTableMap _parmTable,
                        PurchTable _purchTable,
                        Name _purchName = _purchTable.PurchName,
                        VendName _deliveryName = _purchTable.DeliveryName,
                        LogisticsLocationRecId _deliveryLocation = _purchTable.deliveryLocation(),
                        CustPostingProfile _postingProfile_RU = _purchTable.PostingProfile,
                        InventProfileType_RU _inventProfileType_RU = InventProfileType_RU::General)
    {
        Debug::assert(_parmTable.TableId == tableNum(VendInvoiceInfoTable));

        if (_parmTable.isNonPO() && _purchTable.RecId == 0)
        {
            // Non-PO invoices do not need defaulting
            return;
        }

        super(_parmTable, _purchTable, _purchName, _deliveryName, _deliveryLocation);

        // If it is not a valid PO record, default non-PO invoice
        if (_purchTable.RecId == 0)
        {
            _parmTable.PurchId = '';
            _parmTable.defaultRow();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryBuild</Name>
				<Source><![CDATA[
    public void updateQueryBuild()
    {
        super();

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && isFromPurchAgreement)
        {
            chooseLines.query().dataSourceTable(tableNum(PurchAgreementHeader)).addRange(fieldNum(PurchAgreementHeader, RecId)).value(queryValue(externalDefaultedParmTable.PurchAgreementHeader_PSN));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryBuildLines</Name>
				<Source><![CDATA[
    protected void updateQueryBuildLines()
    {
        if (!isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) || !isFromPurchAgreement)
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryBuildSpecQty</Name>
				<Source><![CDATA[
    protected void updateQueryBuildSpecQty()
    {
        QueryBuildDataSource qbds;
        QueryBuildRange qbr;

        // Set based logic cannot have outer joins on the query
        if (!this.allowSetBasedLogic())
        {
            super();
        }

        if (isFromPackingSlip)
        {
            qbds = chooseLines.query().dataSourceTable(tableNum(VendPackingSlipTrans));
            if (qbds)
            {
                qbr = SysQuery::findOrCreateRange(qbds, fieldNum(VendPackingSlipTrans, FullyMatched));
                qbr.value(queryValue(NoYes::No));
                qbr.status(RangeStatus::Hidden);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryDocumentRanges</Name>
				<Source><![CDATA[
    protected int updateQueryDocumentRanges(container _datasourceRecordsPackedMap, boolean _abortOnError = false)
    {
        VendInvoiceInfoTable localVendInvoiceInfoTable;
        container viiTableContainer;
        Map mapViiTable;
        MapEnumerator mapViiTableEnumerator;
        boolean purchTableInitialized;
        int noSelected;
        container datasourceRecordsPackedMap;
        QueryBuildRange qbrParmJobStatus;        

        datasourceRecordsPackedMap = _datasourceRecordsPackedMap;

        if (this.parmCallerTable().TableId == tableNum(VendInvoiceInfoTable))
        {
            noSelected = super(conNull()); //passing conNull as VendInvoiceInfoTable should not be handled in super()
        }
        else
        {
            noSelected = super(datasourceRecordsPackedMap);
        }

        if (datasourceRecordsPackedMap)
        {
            switch (this.parmCallerTable().TableId)
            {
                case tableNum(VendInvoiceInfoTable):
                    viiTableContainer = datasourceRecordsPackedMap;
                    if (viiTableContainer)
                    {
                        // When coming from the pending invoices list page, include invoices with no lines
                        chooseLines.query().dataSourceTable(tableNum(VendInvoiceInfoLine)).joinMode(JoinMode::OuterJoin);

                        // Add selected invoices to query
                        mapViiTable = Map::create(viiTableContainer);
                        mapViiTableEnumerator = mapViiTable.getEnumerator();

                        while (mapViiTableEnumerator.moveNext())
                        {
                            localVendInvoiceInfoTable = mapViiTableEnumerator.currentValue();

                            if (!purchTableInitialized)
                            {
                                purchTable = PurchTable::find(localVendInvoiceInfoTable.PurchId);
                                purchTableInitialized = true;
                            }

                            QueryBuildDataSource vendInvoiceInfoDataSource = chooseLines.query().dataSourceTable(tableNum(VendInvoiceInfoTable));
                            vendInvoiceInfoDataSource.addRange(fieldNum(VendInvoiceInfoTable, TableRefId)).value(queryValue(localVendInvoiceInfoTable.TableRefId));
                            
                            noSelected++;
                        }
                    }
                    break;

                case tableNum(PurchTable):
                    // This disables the VendInvoiceInfoTable data source if the PurchTable data source is disabled.
                    // The PurchTable data source can become disabled in the super() method, which must run first,
                    // because all of the PO's the user selected were rejected. See the comment in the super() method
                    // about "selectedPOs == 0".
                    chooseLines.query().dataSourceTable(tableNum(VendInvoiceInfoTable)).enabled(chooseLines.query().dataSourceTable(tableNum(PurchTable)).enabled());
                    break;

                case tableNum(EGAISWaybillJour_RU):
                    if (isFromPackingSlip)
                    {
                        EGAISWaybillJour_RU waybillJour = this.parmCallerTable();
                        chooseLines.query().dataSourceTable(tableNum(VendPackingSlipTrans)).addRange(fieldNum(VendPackingSlipTrans, VendPackingSlipJour)).value(queryValue(waybillJour.VendPackingSlipJour));
                    }
                    break;

            }
        }

        return noSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceDocumentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a <c>SourceDocumentLine</c> record and all its child <c>SourceDocumentLine</c> records
    /// to have a new SourceDocumentHeader value.
    /// </summary>
    /// <param name="_sourceDocumentLineID">
    /// The ID of a <c>SourceDocumentLine</c> record.
    /// </param>
    /// <param name="_newSourceDocumentHeaderRecId">
    /// The ID of the new <c>SourceDocumentHeader</c> record.
    /// </param>
    /// <param name="_defaultDimension">
    /// The ID of the new <c>DimensionDefault</c> record.
    /// </param>
    protected void updateSourceDocumentLines(RecId _sourceDocumentLineID, RecId _newSourceDocumentHeaderRecId, DimensionDefault _defaultDimension = 0)
    {
        SourceDocumentLine sourceDocumentLine;
        SourceDocumentLine childSourceDocumentLine;
        AccountingDistribution accountingDistribution;
        SourceDocumentLineStateContainer origSourceDocumentLineStateContainer;
        container defaultDimensionContainer;

        sourceDocumentLine = SourceDocumentLine::find(_sourceDocumentLineID, true);

        if (sourceDocumentLine && _newSourceDocumentHeaderRecId)
        {
            ttsbegin;

            if (AccountsPayableAddHeaderClauseInSourceDocumentLineQueryFlight::instance().isEnabled())
            {
                // All SourceDocumentLine records that are child records with respect to the _sourceDocumentLineID
                // need to be updated to the new header before the parent SourceDocumentline is updated with the new header,
                // excluding TaxUncommitted as they will be deleted.
                while select forupdate childSourceDocumentLine
                    where childSourceDocumentLine.SourceDocumentHeader == sourceDocumentLine.SourceDocumentHeader
                    && childSourceDocumentLine.ParentSourceDocumentLine == _sourceDocumentLineID
                {
                    if (childSourceDocumentLine.SourceRelationType != tableNum(TaxUncommitted) &&
                        childSourceDocumentLine.SourceRelationType != tableNum(TaxWithholdUncommitted_IN))
                    {
                        update_recordset accountingDistribution setting SourceDocumentHeader = _newSourceDocumentHeaderRecId
                            where accountingDistribution.SourceDocumentLine == childSourceDocumentLine.RecId;

                        childSourceDocumentLine.SourceDocumentHeader = _newSourceDocumentHeaderRecId;
                        childSourceDocumentLine.update();
                    }
                }
            }
            else
            {
                while select forupdate childSourceDocumentLine
                    where childSourceDocumentLine.ParentSourceDocumentLine == _sourceDocumentLineID
                {
                    if (childSourceDocumentLine.SourceRelationType != tableNum(TaxUncommitted) &&
                        childSourceDocumentLine.SourceRelationType != tableNum(TaxWithholdUncommitted_IN))
                    {
                        update_recordset accountingDistribution setting SourceDocumentHeader = _newSourceDocumentHeaderRecId
                            where accountingDistribution.SourceDocumentLine == childSourceDocumentLine.RecId;

                        childSourceDocumentLine.SourceDocumentHeader = _newSourceDocumentHeaderRecId;
                        childSourceDocumentLine.update();
                    }
                }
            }

            // Update accounting distributions with the new header value.
            update_recordset accountingDistribution
            setting SourceDocumentHeader = _newSourceDocumentHeaderRecId
                where accountingDistribution.SourceDocumentLine == _sourceDocumentLineID;

            // Update the SourceDocumentLine to have the new header value.
            sourceDocumentLine.SourceDocumentHeader = _newSourceDocumentHeaderRecId;

            if (_defaultDimension)
            {
                defaultDimensionContainer = [_defaultDimension];

                // On reArranging MarkupTrans that move from the original VendInvoiceInfoTable to the new VendInvoiceInfoTable the
                // DefaultDimension in the StateContainer needs to be updated.

                origSourceDocumentLineStateContainer = sourceDocumentLine.StateContainer;
                origSourceDocumentLineStateContainer = conPoke(origSourceDocumentLineStateContainer, 3, defaultDimensionContainer);
                sourceDocumentLine.StateContainer = origSourceDocumentLineStateContainer;
            }

            sourceDocumentLine.update();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSplitting</Name>
				<Source><![CDATA[
    protected boolean useSplitting()
    {
        boolean ret = super();

        ret = ret || (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
                  && (this.splitInventProfileType_RU()
                      || this.splitPostingProfile_RU()
                      || this.splitInventOwnerId_RU()));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVendorInvoice_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the vendor invoice lines.
    /// </summary>
    protected void validateVendorInvoice_BR()
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;

        while select vendInvoiceInfoTable
            where vendInvoiceInfoTable.ParmId == parmId
        {
            if (conLen(vendInvoiceInfoTable.getFiscalEstablishment()) > 1)
            {
                checkFailed("@GLS221859");
            }

            vendInvoiceInfoTable.validateLineDeliveryAddress_BR();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendAccountInQuery</Name>
				<Source><![CDATA[
    protected boolean vendAccountInQuery()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buf2Buf</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies data from one record buffer to another.
    /// </summary>
    /// <param name="_from">The source record.</param>
    /// <param name="_to">The destination record.</param>
    /// <remarks>
    /// Only fields with modified values (as determined by field state) will be copied.
    /// If a field with a modified value does not exist in the destination table but has a value in the source, an error will be given.
    /// </remarks>
    public static void buf2Buf(Common _from, Common _to)
    {
        DictTable sourceTable = new DictTable(_from.TableId);
        DictTable destTable = new DictTable(_to.TableId);

        FieldId fieldId = sourceTable.fieldNext(0);

        while (fieldId && !isSysId(fieldId))
        {
            // Copy each field, only if they have been set in the source table
            if ((_from.(fieldId)) || (_from.fieldState(fieldId) != FieldState::NotSet))
            {
                FieldId destFieldId = destTable.fieldName2Id(sourceTable.fieldName(fieldId));
                
                if (destFieldId)
                {
                    _to.(destFieldId) = _from.(fieldId);
                }
                else if (_from.(fieldId))
                {
                    // Skip SysRowVersionNumber field. Value for SysRowVersionNumber is auto generated by sql server.
                    // Also SQL server does not support row version field on temp tables.
                    SysDictField missingField = new SysDictField(_from.TableId, fieldId);
                    if (missingField && !missingField.isSqlRowVersion())
                    {
                        error(strFmt("@SYS70691", sourceTable.fieldName(fieldId)));
                    }
                }
            }

            fieldId = sourceTable.fieldNext(fieldId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkW9Received</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the W9 form has been received for the Vendor with the specified
    /// <c>VendorAccount</c> value; if not, an error message is logged.
    /// </summary>
    /// <param name="_vendInvoiceInfoTable">
    /// The record that contains the <c>VendorAccount</c> object.
    /// </param>
    /// <returns>
    /// true if the check passed; otherwise, false.
    /// </returns>
    static boolean checkW9Received(VendDocumentTableMap _vendInvoiceInfoTable)
    {
        PurchTable purchTable;
        VendAccount vendAccount;

        Debug::assert(_vendInvoiceInfoTable.TableId == tableNum(VendInvoiceInfoTable));

        if (_vendInvoiceInfoTable.InvoiceAccount && _vendInvoiceInfoTable.InvoiceAccount != _vendInvoiceInfoTable.OrderAccount)
        {
            vendAccount = _vendInvoiceInfoTable.InvoiceAccount;
        }
        else
        {
            vendAccount = _vendInvoiceInfoTable.OrderAccount;
        }

        if (vendAccount == "")
        {
            select OrderAccount, InvoiceAccount from purchTable
                where purchTable.PurchId == _vendInvoiceInfoTable.PurchId;

            if (purchTable.InvoiceAccount && purchTable.InvoiceAccount != purchTable.OrderAccount)
            {
                vendAccount = purchTable.InvoiceAccount;
            }
            else
            {
                vendAccount = purchTable.OrderAccount;
            }
        }

        return VendTable::checkW9Received(vendAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesServer</Name>
				<Source><![CDATA[
    static public container chooseLinesServer(
        container _purchFormletterInvoiceContractPacked,
        boolean _append,
        boolean _reuseParmUpdate = false,
        boolean _onlyCreateParmUpdate = false,
        boolean _executeLateSelection = false,
        PurchInvoiceType _invoiceType = PurchInvoiceType::Standard)
    {
        // <GEEU>
        #EECountryRegionCodes
        // </GEEU>
        PurchFormletterParmDataInvoice purchFormletterParmDataInvoice;

        purchFormletterParmDataInvoice = PurchFormletterParmData::newChooseLines(_purchFormletterInvoiceContractPacked,
                                                                                _reuseParmUpdate,
                                                                                _onlyCreateParmUpdate,
                                                                                _executeLateSelection);
        purchFormletterParmDataInvoice.parmInvoiceType(_invoiceType);

        purchFormletterParmDataInvoice.createData(_append);

        // <GEEU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeCZHUPL))
        {
            purchFormletterParmDataInvoice.checkAdvancePayments_W();
        }
        // </GEEU>

        return purchFormletterParmDataInvoice.getOutputContractPacked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    [SysObsolete('Use PurchFormletterParmData::construct() instead.', false, 30\6\2020)]
    static PurchFormletterParmDataInvoice construct()
    {
        return new PurchFormletterParmDataInvoice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSubTableSourceAccountingEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the accounting event value in the <c>VendInvoiceInfoSubTable</c> if it has not already been set.
    /// </summary>
    /// <param name="_vendInvoiceInfoSubTable">
    /// The <c>VendInvoiceInfoSubTable</c> table to update.
    /// </param>
    /// <param name="_update">
    /// A Boolean value that determines whether the record should be selected for update; optional.
    /// </param>
    /// <returns>
    /// true if the subtable source accounting event has changed; otherwise, false.
    /// </returns>
    public static boolean initSubTableSourceAccountingEvent(Common _vendInvoiceInfoSubTable, boolean _update = false)
    {
        VendInvoiceInfoSubTable vendInvoiceInfoSubTable = _vendInvoiceInfoSubTable;
        AccountingEvent localAccountingEvent;
        boolean isValueChanged;

        if ( (vendInvoiceInfoSubTable.SourceAccountingEvent == 0 || _update) && vendInvoiceInfoSubTable.OrigPurchId != '')
        {
            localAccountingEvent = AccountingEvent::getLastEvent(PurchTable::find(vendInvoiceInfoSubTable.OrigPurchId).SourceDocumentHeader);

            isValueChanged = (vendInvoiceInfoSubTable.SourceAccountingEvent != localAccountingEvent.RecId);

            vendInvoiceInfoSubTable.SourceAccountingEvent = localAccountingEvent.RecId;
        }

        return isValueChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>promptForUpdateQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prompt the user to update invoice quantity for all invoice lines and making it run always on client.
    /// </summary>
    /// <returns>
    /// True or false based on the selection.
    /// </returns>
    public static boolean promptForUpdateQty()
    {
        return (Box::yesNo("@AccountsPayable:ImbalancedLineMatchedQuantityConfirmation", DialogButton::Yes) == DialogButton::Yes) ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupForHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up a vendor invoice header record.
    /// </summary>
    /// <param name = "_vendInvoiceInfoTable">
    /// A vendor invoice header record to be cleaned up.
    /// </param>
    protected void cleanupForHeader(VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        // Copy misc charges before creating total and MC matching info
        if (this.shouldCopyMarkupFromBOEJournal())
        {
            this.copyMarkupFromBOEJour(_vendInvoiceInfoTable);
        }
        else
        {
            this.copyMarkupFromPurchOrder(_vendInvoiceInfoTable);
        }

        // Copy attachment if the VendInvoiceInfoTable have record and if the findRecId() method returns a record
        if (_vendInvoiceInfoTable.PoolRecId != 0)
        {
            LedgerJournalTrans ledgerJournalTransLocal = LedgerJournalTrans::findRecId(_vendInvoiceInfoTable.PoolRecId, false);

            if (ledgerJournalTransLocal)
            {
                Docu::copy(ledgerJournalTransLocal, _vendInvoiceInfoTable);
            }
        }

        VendInvoiceInfoTable::defaultCreditCorrection(_vendInvoiceInfoTable.RecId);

        if (_vendInvoiceInfoTable.VarianceApproved == NoYes::No)
        {
            VendInvoiceInfoMarkupMatchingTolerance::create(_vendInvoiceInfoTable.ParmId, _vendInvoiceInfoTable.TableRefId);
        }

        VendParameters vendParameters = VendParameters::find();

        if (vendParameters.editAutomaticHeaderMatching())
        {
            VendInvoiceMatching::create(_vendInvoiceInfoTable);
            VendInvoiceInfoSubMarkupMatchingTrans::createFromVendInvoiceInfoTable(_vendInvoiceInfoTable);
        }

        this.processPrepaymentApplication(_vendInvoiceInfoTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines wheter to skip the creation of the vendor invoice info line record.
    /// </summary>
    /// <param name = "_purchLine">
    /// The purchase line table record to check.
    /// </param>
    /// <param name = "_tableRef">
    /// The table reference to check.
    /// </param>
    /// <param name = "_callFromCreateParmLineAndSubLines">
    /// The boolean value that carries the called from method information.
    /// </param>
    /// <returns>
    /// true if the vendor invoice info line creation should be skipped; otherwise, false.
    /// </returns>
    [Hookable]
    protected boolean skipParmLine(Common _purchLine, TradeLineRefId _tableRef = '', boolean _callFromCreateParmLineAndSubLines = false)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeParmTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize <c>VendDocumentTableMap</c>.
    /// </summary>
    /// <param name = "_parmTable">The <c>VendDocumentTableMap</c>.</param>
    /// <param name = "_purchLine">The purchase line.</param>
    /// <param name = "_purchTable">The purchase header.</param>
    /// <param name = "_tableRefId">The vendor invoice table reference.</param>
    /// <param name = "_hold">Hold on the vendor invoice.</param>
    /// <param name = "_notApproved">Is vendor invoice approved.</param>
    /// <param name = "_purchSummaryFormLetterId">The invoice number.</param>
    /// <param name = "_postingProfile">Vendor posting profile.</param>
    /// <param name = "_inventProfileType">Inventory profile type.</param>
    /// <returns>The initialized <c>VendDocumentTableMap</c>.</returns>
    protected VendDocumentTableMap initializeParmTable(
        VendDocumentTableMap  _parmTable,
        PurchLine             _purchLine,
        PurchTable            _purchTable,
        TradeLineRefId        _tableRefId,
        boolean               _hold = false,
        boolean               _notApproved = false,
        Num                   _purchSummaryFormLetterId = '',
        VendPostingProfile    _postingProfile = '',
        InventProfileType_RU  _inventProfileType = InventProfileType_RU::General
       )
    {
        // Populate document date with the invoice date from the intercompany order so that
        // the due date is calculated as per the invoice date for the intercompany orders.
        // This field needs to be populated prior to the call to super to ensure the defaults works properly.
        if (_purchTable.isInterCompanyOrder())
        {
            _parmTable.DocumentDate = this.interCompanyInvoiceDate(_purchTable);
        }

        VendDocumentTableMap parmTable = super(
            _parmTable,
            _purchLine,
            _purchTable,
            _tableRefId,
            _hold,
            _notApproved,
            _purchSummaryFormLetterId,
            _postingProfile,
            _inventProfileType);

        this.initializeParmTableFromInterCompanyCustInvoiceJour_TH(parmTable, _purchTable);

        return parmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastDeliveryDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets last delivery date for invoice.
    /// </summary>
    /// <returns>
    /// Date of physical posting.
    /// </returns>
    private TransDate getLastDeliveryDate()
    {
        InventTrans inventTrans;
        InventTransOrigin inventTransOrigin;
        VendInvoiceInfoLine vendInvoiceInfoLine;

        select RecId, InventTransId, OrigPurchId from vendInvoiceInfoLine
            where vendInvoiceInfoLine.ParmId == this.parmId()
                && vendInvoiceInfoLine.OrigPurchId == purchTable.PurchId
        outer join InventTransId, RecId from inventTransOrigin
            where inventTransOrigin.InventTransId == vendInvoiceInfoLine.InventTransId
        outer join maxof (DatePhysical) from inventTrans
            where !inventTrans.DateFinancial
                && inventTrans.InventTransOrigin == inventTransOrigin.RecId;

        return inventTrans.DatePhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWGetLineQuantities</Name>
				<Source><![CDATA[
    protected container pdsCWGetLineQuantities(PurchLine _purchLine)
    {
        return [(isFromBillOfEntry || isFromPackingSlip) ? newPostingCWQty : naReal(), 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>setParmLineMap</Name>
				<Source><![CDATA[
    protected void setParmLineMap(Map _parmLineMap)
    {
        parmLineMap = _parmLineMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultBudgetReservation</Name>
				<Source><![CDATA[
    private void defaultBudgetReservation()
    {
        PurchLine purchLineLocal;
        VendInvoiceInfoLine vendInvoiceInfoLineUpdate;

        vendInvoiceInfoLineUpdate.skipBusinessEvents(true);
        vendInvoiceInfoLineUpdate.skipAosValidation(true);
        vendInvoiceInfoLineUpdate.skipDataMethods(true);
        vendInvoiceInfoLineUpdate.skipEvents(true);
        vendInvoiceInfoLineUpdate.skipDataSourceValidateWrite(true);

        ttsbegin;
        update_recordset vendInvoiceInfoLineUpdate 
            setting BudgetReservationLine_PSN = purchLineLocal.BudgetReservationLine_PSN
            where vendInvoiceInfoLineUpdate.ParmId == this.parmId()
            join purchLineLocal
                where purchLineLocal.InventTransId == vendInvoiceInfoLineUpdate.InventTransId;
        ttscommit;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>