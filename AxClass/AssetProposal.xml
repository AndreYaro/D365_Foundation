<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AssetProposal</Name>
	<SourceCode>
		<Declaration><![CDATA[
class AssetProposal extends RunBaseBatch implements BatchRetryable
{
    #isoCountryRegionCodes
    AssetTransDate runDate;
    QueryRun queryRun;

    FiscalCalendarPeriod fiscalCalendarPeriod;
    LedgerJournalId journalNum;
    boolean isFixedAssetBudgetJournal;

    DialogField dialogAssetBudgetModelId;
    AssetBudgetModelId assetBudgetModelId;
    AssetTransType assetTransType;
    DialogField dialogPostingLayer;
    CurrentOperationsTax postingLayer;
    boolean batchEnabled;
    LedgerJournalNameId ledgerNameId;
    DialogField dialogJournalName;
    LedgerJournalName journalName;
    AssetTransType transType;  // for batch mode

    // <GCN>
    DialogField dialogVoucherType_CN;
    LedgerVoucherTypeId_CN voucherType_CN;
    boolean isChineseVoucher;
    boolean isFixedAssetJournal;
    
    private Set booksCalculatedInPreviousRun = new Set(Types::Int64);
    internal boolean isExecutingInBatch = BatchHeader::isExecutingInBatch();

    const int CurrentVersion = 10;

    #DEFINE.Version9(9)
    // </GCN>
    #LOCALMACRO.CurrentListV9
        assetBudgetModelId,
        journalNum,
        isFixedAssetBudgetJournal
        // <GCN>
        ,isFixedAssetJournal,
        voucherType_CN
        // </GCN>
    #ENDMACRO

    #DEFINE.Version8(8)
    #LOCALMACRO.CurrentListV8
        assetBudgetModelId,
        journalNum,
        isFixedAssetBudgetJournal
    #ENDMACRO

    #DEFINE.Version7(7)
    #LOCALMACRO.CurrentListV7
        assetBudgetModelId,
        journalNum
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransAlreadyPosted</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Checks if the asset transaction already exists with the specified details.
    /// </summary>
    /// <param name="_assetBook">
    /// The assetbook buffer.
    /// </param>
    /// <param name="_transAmount">
    /// The transaction amount.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <param name="_assetTransType">
    /// The transaction type.
    /// </param>
    /// <returns>
    /// true if the asset transaction already exists; otherwise, false.
    /// </returns>
    public boolean checkTransAlreadyPosted(
        AssetBook _assetBook,
        AmountMST _transAmount,
        TransDate _transDate,
        AssetTransType _assetTransType)
    {
        AssetTransTmp assetTransTmp = AssetCacheManager::getCacheAssetTrans(_assetBook.AssetId, _assetBook.BookId);
        select firstonly RecId from assetTransTmp
            where assetTransTmp.AssetId == _assetBook.AssetId
                && assetTransTmp.BookId == _assetBook.BookId
                && assetTransTmp.AmountMST == _transAmount
                && assetTransTmp.TransDate == _transDate
                && assetTransTmp.TransType == _assetTransType;

        return assetTransTmp.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>budgetJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves whether the proposal is called from the fixed asset budget journal.
    /// </summary>
    /// <returns>
    ///    true if the proposal is called from a fixed asset budget journal; otherwise, false.
    /// </returns>
    boolean budgetJournal()
    {
        return isFixedAssetBudgetJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildRange</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Builds the range from the set provided.
    /// </summary>
    /// <param name="_items">
    /// Set of items.
    /// </param>
    /// <returns>
    /// String for range value.
    /// </returns>
    public str buildRange(Set _items)
    {
        str rangeValue;
        SetEnumerator enumerator;
        int counter;
        str firstElement, lastElement;
        enumerator = _items.getEnumerator();

        while (enumerator.moveNext())
        {
            if (counter == 0)
            {
                firstElement = enumerator.current();
            }
            lastElement = enumerator.current();
            counter ++;
        }

        if (firstElement != lastElement && lastElement)
        {
            rangeValue = SysQuery::range(firstElement, lastElement);
        }
        else
        {
            rangeValue = firstElement;
        }

        return rangeValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildRangeFromList</Name>
				<Source><![CDATA[
    private str buildRangeFromList(Set _items)
    {
        str rangeValue;
        SetEnumerator enumerator;
        enumerator = _items.getEnumerator();

        while (enumerator.moveNext())
        {
            rangeValue += strFmt("%1,", enumerator.current().ToString());
        }

        return rangeValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBatchHeader</Name>
				<Source><![CDATA[
    internal BatchHeader getBatchHeader()
    {
        BatchHeader batchHeader = BatchHeader::construct(this.parmCurrentBatch().BatchJobId);
        Batch currentBatchTask = BatchHeader::getCurrentBatchTask();
        
        if (currentBatchTask.GroupId)
        {
            batchHeader.parmBatchGroup(currentBatchTask.GroupId);
        }

        return batchHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the subtasks for asset proposal.
    /// </summary>
    public void buildTasks()
    {
        const int MaxThreadsPortionToSave = 10;

        AssetProposal assetProposalCopy;
        AssetBook assetBook;
        Set booksInAsset;
        Set assets;
        Set assetBooks;
        int assetBookCount;
        boolean bundleReady;
        BatchHeader batchHeader = this.getBatchHeader();

        #OCCRetryCount

        booksInAsset = new Set(Types::String);
        assets = new Set(Types::String);
        assetBooks = new Set(Types::Int64);

        try
        {
            int numberOfThreadsToSave = min(this.getNumberOfAvailableThreads(batchHeader.parmBatchGroup()), MaxThreadsPortionToSave);
            int bundleCount;
            RefRecId assetBookPrevRecId;

            while (queryRun.next())
            {
                assetBook = queryRun.get(tableNum(AssetBook)) as AssetBook;

                if (assetBookPrevRecId != assetBook.RecId)
                {
                    assetBookPrevRecId = assetBook.RecId;

                    if (!assetBooks.in(assetBook.RecId))
                    {
                        if (queryRun.changed(tableNum(AssetTable)))
                        {
                            bundleReady = this.isBundleReady(assetBookCount);

                            if (bundleReady)
                            {
                                assetBookCount = 0;
                                bundleReady = false;

                                assetProposalCopy = this.makeChildTask(booksInAsset, assets);

                                if (AssetProposalBatchRunTimeFlight::instance().isEnabled())
                                {
                                    batchHeader.addRuntimeTask(assetProposalCopy, this.parmCurrentBatch().RecId);
                                }
                                else
                                {
                                    batchHeader.addTask(assetProposalCopy);
                                }
                                booksInAsset = new Set(Types::String);
                                assets = new Set(Types::String);
                                assetBooks = new Set(Types::Int64);

                                bundleCount++;

                                if (bundleCount == numberOfThreadsToSave)
                                {
                                    batchHeader.save();
                                    bundleCount = 0;
                                }
                            }

                            assets.add(assetBook.AssetId);
                        }

                        assetBooks.add(assetBook.RecId);
                        booksInAsset.add(assetBook.BookId);

                        assetBookCount++;
                    }
                }
            }

            if (assetBookCount > 0)
            {
                assetBookCount = 0;
                assetProposalCopy = this.makeChildTask(booksInAsset, assets);

                if (AssetProposalBatchRunTimeFlight::instance().isEnabled())
                {
                    batchHeader.addRuntimeTask(assetProposalCopy, this.parmCurrentBatch().RecId);
                }
                else
                {
                    batchHeader.addTask(assetProposalCopy);
                }
            }

            batchHeader.save();
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::Error)
        {
            exceptionTextFallThrough();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    public boolean canGoBatch()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDateIsValid</Name>
				<Source><![CDATA[
    boolean checkDateIsValid(TransDate _transDate)
    {
        boolean ret = true;

        if (!isFixedAssetBudgetJournal)
        {
            RecId calendarRecId = CompanyInfoHelper::fiscalCalendarRecId();
            ret = LedgerFiscalCalendar::checkDateIsValid(calendarRecId,_transDate);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPeriodicFields</Name>
				<Source><![CDATA[
    private Object addPeriodicFields(Dialog _dialog)
    {
        FormBuildCommandButtonControl   okButton;

        okButton = _dialog.formBuildDesign().control('okButton');
        if (okButton)
        {
            okButton.text("@FixedAssets:CreateJournalButton");
        }

        _dialog.formBuildDesign().setCompany(true);
        _dialog.form().addDataSource(tableStr(Common), tableStr(Common));

        _dialog.addGroup("@FixedAssets:AssetBatchJournal");
        dialogPostingLayer = _dialog.addField(extendedTypeStr(AssetPostingLayerString));
        dialogPostingLayer.value(AssetPostingLayerXdsTmp::getStringByValue(postingLayer));
        dialogPostingLayer.fieldControl().lookupOnly(true);

        dialogJournalName = _dialog.addField(extendedTypeStr(LedgerJournalNameId));
        dialogJournalName.label("@SYS1436");
        dialogJournalName.value(AssetParametersProposalJournalNames::getLedgerJournalNameId(postingLayer));
        dialogJournalName.fieldControl().mandatory(true);

        dialogJournalName.registerOverrideMethod(methodStr(FormStringControl, lookup),
            methodStr(AssetProposal, journalNameLookup), this);

        dialogJournalName.registerOverrideMethod(methodStr(FormStringControl, modified),
            methodStr(AssetProposal, journalNameModified), this);
        return _dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDialogWithVoucher_CN</Name>
				<Source><![CDATA[
    private DialogRunbase createDialogWithVoucher_CN(DialogRunbase _dialog, boolean _isFixedAssetJournal = true)
    {
        isChineseVoucher = LedgerParameters::isChineseVoucher_CN();
        if (isChineseVoucher
            && _isFixedAssetJournal
            && !(this is AssetProposalRevaluation))
        {
            _dialog.addGroup("@GLS54929");
            dialogVoucherType_CN = _dialog.addFieldValue(extendedTypeStr(LedgerVoucherTypeId_CN), voucherType_CN, "@GLS54929", "@GLS54489");
        }

        return _dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    ///    in the Application Object Tree (AOT).
    /// </remarks>
    Object dialog()
    {
        DialogRunbase   dialog;
        FormBuildTabPageControl queryTab;

        dialog =  super();

        // If not running as periodic process then hide the batch tab.
        if (!this.parmBatchEnabled())
        {
            this.showBatchTab(false);
            this.parmInBatch(false);
            dialog = this.createDialogWithVoucher_CN(dialog, isFixedAssetJournal);
        }
        else
        {
            dialog = this.addPeriodicFields(dialog);
            dialog = this.createDialogWithVoucher_CN(dialog);
            if (dialogVoucherType_CN)
            {
                dialogVoucherType_CN.allowEdit(false);
            }
        }

        if (this.budgetJournal())
        {
            dialog.addGroup("@SYS15436");
            dialogAssetBudgetModelId = dialog.addField(extendedTypeStr(AssetBudgetModelId));
            dialogAssetBudgetModelId.value(assetBudgetModelId);
        }

        queryTab = dialog.formBuildDesign().control('query');
        if (queryTab)
        {
            queryTab.fastTabExpanded(true);
        }

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalNameModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs operations required after the modification of journal name field
    /// </summary>
    /// <param name = "_control">The control that has been modified.</param>
    /// <returns>true if operation was successful; otherwise false.</returns>
    public boolean journalNameModified(FormStringControl _control)
    {
        return _control.modified();
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalNameLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the lookup of journal names.
    /// </summary>
    /// <param name = "_control">The control on which to apply the lookup.</param>
    public void journalNameLookup(FormStringControl _control)
    {
        SysTableLookup          sysTableLookup;
        QueryBuildDataSource    queryBuildDataSource;

        Query query = new Query();

        sysTableLookup = SysTableLookup::newParameters(tableNum(LedgerJournalName), _control);

        sysTableLookup.addLookupfield(fieldNum(LedgerJournalName, JournalName));
        sysTableLookup.addLookupfield(fieldNum(LedgerJournalName, Name));

        queryBuildDataSource = query.addDataSource(tableNum(LedgerJournalName));
        QueryBuildRange queryBuildRangeJournalType = queryBuildDataSource.addRange(fieldNum(LedgerJournalName, JournalType));
        queryBuildRangeJournalType.value(int2str(enum2int(LedgerJournalType::Assets)));

        QueryBuildRange queryBuildRangePostingLayer = queryBuildDataSource.addRange(fieldNum(LedgerJournalName, CurrentOperationsTax));
        CurrentOperationsTax chosenLayer =
            AssetPostingLayerXdsTmp::getValueByString(dialogPostingLayer.value());
        queryBuildRangePostingLayer.value(enum2str(chosenLayer));        
        sysTableLookup.parmQuery(query);

        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDepreciationRunDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the depreciation run date.
    /// </summary>
    /// <returns>
    /// The depreciation run date.
    /// </returns>
    /// <remarks>
    /// This method is used to access the depreciation run date that is used during depreciation proposal
    /// calculation.
    /// </remarks>
    [SysObsolete('The getDepreciationRunDate() method has been replaced by the parmRunDate() method.', true, 31\01\2016)]
    public AssetTransDate getDepreciationRunDate()
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    boolean getFromDialog()
    {
        boolean retValue = super();

        if (!this.parmBatchEnabled())
        {
            if (this.budgetJournal())
            {
                assetBudgetModelId = dialogAssetBudgetModelId.value();
            }

            // <GCN>
            if (isChineseVoucher
                && isFixedAssetJournal
                && !(this is AssetProposalRevaluation))
            {
                voucherType_CN = dialogVoucherType_CN.value();
            }
            // </GCN>
        }
        else 
        {
            if (isChineseVoucher
                && !(this is AssetProposalRevaluation))
            {
                voucherType_CN = dialogVoucherType_CN.value();
            }
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    public void getLast()
    {
        boolean isBatchEnable;
        getLastCalled = true;
        inGetSaveLast = true;

        // Need to preserve the value of proposal execution as getLast overwrites it.
        isBatchEnable = this.parmBatchEnabled();

        xSysLastValue::getLast(this);

        inGetSaveLast = false;

        this.parmBatchEnabled(isBatchEnable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxInCostPriceMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the sum of the non-recoverable taxes for a given transaction.
    /// </summary>
    /// <param name="sourceTableId">
    /// Table id of a given transaction.
    /// </param>
    /// <param name="sourceRecId">
    /// Id of a given transaction.
    /// </param>
    /// <returns>
    /// The sum of non-recoverable taxes.
    /// </returns>
    public TaxAmount getTaxInCostPriceMST(
        RefRecId sourceTableId,
        RefRecId sourceRecId)
    {
        TaxTrans taxTrans;

        select sum(TaxInCostPriceMST)
            from taxTrans
            where taxTrans.SourceRecId == sourceRecId
                && taxTrans.SourceTableId == sourceTableId;

        return taxTrans.TaxInCostPriceMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFirstDate</Name>
				<Source><![CDATA[
    public AssetTransDate initFirstDate(AssetTransDate  _assetTransDate,AssetId _assetId)
    {
        AssetTransDate   assetTransDate = _assetTransDate;

        if (!assetTransDate)
        {
            assetTransDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        this.initFiscalCalendarPeriod(_assetTransDate);

        // deal with dates that are prior to first open ledgerPeriod
        // required for imported/old data
        if (assetTransDate < fiscalCalendarPeriod.StartDate)
        {
            info(strFmt("@SYS67579",_assetId, date2StrUsr(assetTransDate, DateFlags::FormatAll), date2StrUsr(fiscalCalendarPeriod.StartDate, DateFlags::FormatAll)));
            assetTransDate = fiscalCalendarPeriod.StartDate;
        }
        return assetTransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFiscalCalendarPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes the first opening fiscal calendar period.
    /// </summary>
    /// <param name="_assetTransDate">
    ///   The date which falls in the fiscal calendar year which is to be searched.
    /// </param>
    protected void initFiscalCalendarPeriod(AssetTransDate _assetTransDate)
    {
        if (!fiscalCalendarPeriod)
        {
            RecId calendarRecId = CompanyInfoHelper::fiscalCalendarRecId();
            // find first period
            select firstonly fiscalCalendarPeriod
                index RecId
                where fiscalCalendarPeriod.Type == FiscalPeriodType::Opening
                    && fiscalCalendarPeriod.FiscalCalendarYear == FiscalCalendarYear::findYearByCalendarDate(calendarRecId, _assetTransDate).RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the query used by the proposal.
    /// </summary>
    protected void initQuery()
    {
        Query               query;

        query = queryRun.query();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertJournalTableSystemBlocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts <c>LedgerJournalTable</c> record based on the Journal Name and Journal ID.
    /// </summary>
    /// <param name="_journalName">
    /// Journal name
    /// </param>
    /// <param name="_journalId">
    /// Journal ID
    /// </param>
    /// <returns>
    /// <c>LedgerJournalTable</c> buffer
    /// </returns>
    /// <remarks>
    /// SystemBlocked column is set to Yes.
    /// </remarks>
    protected LedgerJournalTable insertJournalTableSystemBlocked(
        LedgerJournalNameId _journalName,
        LedgerJournalId _journalId = '')
    {
        LedgerJournalTable journalTable;

        if (_journalId)
        {
            journalTable.JournalNum = _journalId;
        }

        journalTable.JournalName = _journalName;
        journalTable.SystemBlocked = NoYes::Yes;
        journalTable.insert();

        return journalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBundleReady</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the bundle is full for the sub tasks of a batch.
    /// </summary>
    /// <param name="_bookCount">
    /// The number of asset books.
    /// </param>
    /// <returns>
    /// true if the bundle is full; otherwise, false.
    /// </returns>
    public boolean isBundleReady(int _bookCount)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUniqueItem</Name>
				<Source><![CDATA[
    private boolean isUniqueItem(List _items, str _item)
    {
        ListEnumerator enumerator;
        boolean isUnique = true;

        enumerator = _items.getEnumerator();

        while (enumerator.moveNext())
        {
            if (enumerator.current() == _item)
            {
                isUnique = false;
            }
        }

        return isUnique;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalNum</Name>
				<Source><![CDATA[
    public LedgerJournalId journalNum(LedgerJournalId _journalNum = journalNum)
    {
        journalNum = _journalNum;
        return journalNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeChildTask</Name>
				<Source><![CDATA[
    private AssetProposal makeChildTask(Set _books, Set _assets)
    {
        AssetProposal assetProposalCopy;
        QueryRun childQueryRun;
        QueryRun taskQuery;
        Query query;
        QueryBuildDataSource qbdsAssetId;
        QueryBuildRange rangeAssetId;
        QueryBuildDataSource qbdsBookId;
        QueryBuildRange rangeBookId;
        LedgerJournalTable journalTable;
        str assetIds, bookids;
	    // <GJP>
	    AssetDocumentProposal_JP   assetDocumentProposal;
	    // </GJP>

	    // <GJP>
	    if (AssetDocumentUtility_JP::isAssetDocumentEnabled()
	        && this is AssetDocumentProposal_JP)
	    {
	        assetDocumentProposal = this;
	        assetProposalCopy = AssetDocumentProposal_JP::construct(assetDocumentProposal.parmAssetDocumentProposalType());
	    }
	    else
	    {
	    // </GJP>
        assetProposalCopy = AssetProposal::construct(this.getAssetTransType());
	    // <GJP>
	    }
	    // </GJP>

        assetProposalCopy.unpack(this.pack());
        taskQuery = assetProposalCopy.parmQueryRun();
        assetProposalCopy.parmBatchEnabled(false);

        assetIds = this.buildRange(_assets);
        bookids = this.buildRangeFromList(_books);

        query = taskQuery.query();

        qbdsAssetId = query.dataSourceTable(tableNum(AssetTable));
        rangeAssetId = SysQuery::findOrCreateRange(qbdsAssetId, fieldNum(AssetTable, AssetId));
        rangeAssetId.value(assetIds);

        qbdsBookId = query.dataSourceTable(tableNum(AssetBook));
        rangeBookId = SysQuery::findOrCreateRange(qbdsBookId, fieldNum(AssetBook, BookId));
        rangeBookId.value(bookIds);

        childQueryRun = new QueryRun(query);
        assetProposalCopy.parmQueryRun(childQueryRun);

        // Journal has to be blocked until the batch task completes so that it is not available for other users.
        journalTable = null;
        journalTable = this.insertJournalTableSystemBlocked(journalName.JournalName);

        assetProposalCopy.journalNum(journalTable.JournalNum);
        assetProposalCopy.batchInfo().parmCaption(strFmt("@FixedAssets:FABatchCaption",
            journalTable.JournalNum, assetIds, bookids));

        return assetProposalCopy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [CurrentVersion,
        assetBudgetModelId,
        journalNum,
        isFixedAssetBudgetJournal,
        // <GCN>
        isFixedAssetJournal,
        voucherType_CN,
        // </GCN>
        batchEnabled,
        journalName,
        transType, queryRun.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRunDate</Name>
				<Source><![CDATA[
    public TransDate parmRunDate(TransDate _runDate = runDate)
    {
        runDate = _runDate;
        return runDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetTransType</Name>
				<Source><![CDATA[
    public AssetTransType parmAssetTransType(AssetTransType _assetTransType = assetTransType)
    {
        assetTransType = _assetTransType;
        return assetTransType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBatchEnabled</Name>
				<Source><![CDATA[
    public boolean parmBatchEnabled(boolean _batchEnabled = batchEnabled)
    {
        batchEnabled = _batchEnabled;
        return batchEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalName</Name>
				<Source><![CDATA[
    public LedgerJournalName parmJournalName(LedgerJournalName _journalName = journalName)
    {
        journalName = _journalName;
        return journalName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalId</Name>
				<Source><![CDATA[
    public LedgerJournalId parmJournalId(LedgerJournalId _journalId = journalNum)
    {
        LedgerJournalId local = journalNum;
        journalNum = _journalId;
        return journalNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQueryRun</Name>
				<Source><![CDATA[
    public QueryRun parmQueryRun(QueryRun _queryRun = queryRun)
    {
        queryRun = _queryRun;
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransType</Name>
				<Source><![CDATA[
    public AssetTransType parmTransType(AssetTransType _transType = transType)
    {
        transType = _transType;
        return transType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssetTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns asset transaction type associated with this class.
    /// </summary>
    /// <returns>Asset transaction</returns>
    public AssetTransType getAssetTransType()
    {
        return AssetTransType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetModelId</Name>
				<Source><![CDATA[
    public AssetBudgetModelId parmBudgetModelId(AssetBudgetModelId _budgetModelId = assetBudgetModelId)
    {
        assetBudgetModelId = _budgetModelId;
        return assetBudgetModelId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucherType_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the voucher type used for the asset journals being created.
    /// </summary>
    /// <param name="_voucherType_CN">
    /// A <c>LedgerVoucherTypeId_CN</c> value representing the voucher type to be used.
    /// </param>
    /// <returns>
    /// The voucher type for the asset journals being created.
    /// </returns>
    public LedgerVoucherTypeId_CN parmVoucherType_CN(LedgerVoucherTypeId_CN _voucherType_CN = voucherType_CN)
    {
        voucherType_CN = _voucherType_CN;
        return voucherType_CN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prompt</Name>
				<Source><![CDATA[
    public boolean prompt()
    {
        boolean ret;

        this.batchInfo().fieldBatchExecuteValue(false);
        this.batchInfo().parmBatchExecute(false);

        ret = super();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    ///    The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    ///    This method is used if a query prompt is in the dialog and if a select menu item is added to a
    ///    dialog. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it
    ///    in the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveLast</Name>
				<Source><![CDATA[
    public void saveLast()
    {
        if (!this.parmBatchEnabled())
        {
            inGetSaveLast = true;
            xSysLastValue::saveLast(this);
            inGetSaveLast = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDepreciationRunDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the depreciation run date.
    /// </summary>
    /// <param name="_depreciationRunDate">
    /// The depreciation run date.
    /// </param>
    /// <remarks>
    /// This method is used to set the depreciation run date
    /// that is used during depreciation proposal calculation.
    /// </remarks>
    [SysObsolete('The setDepreciationRunDate() method has been replaced by the parmRunDate() method.', true, 31\01\2016)]
    public void setDepreciationRunDate(AssetTransDate _depreciationRunDate)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setIsAssetBudgetJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets whether the proposal is called from the fixed asset budget journal.
    /// </summary>
    /// <param name="_isFixedAssetBudgetJournal">
    ///    true if the proposal is called from a fixed asset budget journal; otherwise, false.
    /// </param>
    protected void setIsAssetBudgetJournal(boolean _isFixedAssetBudgetJournal)
    {
        isFixedAssetBudgetJournal = _isFixedAssetBudgetJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setIsFixedAssetJournal_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets whether the proposal is called from fixed asset journal.
    /// </summary>
    /// <param name="_isFixedAssetJournal">
    /// true if the propsal is called from a fixed asset journal; otherwise, false.
    /// </param>
    protected void setIsFixedAssetJournal_CN(boolean _isFixedAssetJournal)
    {
        isFixedAssetJournal = _isFixedAssetJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to add a Select button to the dialog box.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    /// <remarks>
    ///    If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    ///    return a valid instance of the <c>QueryRun</c> class. If you change the return value to false, the
    ///    button will no longer be added.
    /// </remarks>
    boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unlockJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unlocks the journal.
    /// </summary>
    /// <remarks>
    /// During batch processing the journals are locked.
    /// This function is called once the batch processing is complete.
    /// </remarks>
    public void unlockJournal()
    {
        LedgerJournalTable journalTable;

        update_recordset journalTable
            setting SystemBlocked = NoYes::No
                where journalTable.JournalNum == journalNum
                    && journalTable.SystemBlocked == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalTotals</Name>
				<Source><![CDATA[
    internal void updateJournalTotals()
    {
        Amount journalTotalDebit;
        Amount journalTotalCredit;
        Amount journalTotalOffsetBalance;
        Amount journalTotalDebitReportingCurrency;
        Amount journalTotalCreditReportingCurrency;

        [journalTotalDebit,
            journalTotalCredit,
            journalTotalOffsetBalance,
            journalTotalDebitReportingCurrency,
            journalTotalCreditReportingCurrency] = LedgerJournalTable::journalBalanceMST(journalNum);

        LedgerJournalTable journalTable;

        update_recordset journalTable
            setting JournalTotalDebit = journalTotalDebit,
                JournalTotalCredit = journalTotalCredit,
                JournalTotalOffsetBalance = journalTotalOffsetBalance,
                JournalTotalDebitReportingCurrency = journalTotalDebitReportingCurrency,
                JournalTotalCreditReportingCurrency = journalTotalCreditReportingCurrency
            where journalTable.JournalNum == journalNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndLockJournalForBatchProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Creates and locks the journal.
    /// </summary>
    /// <remarks>
    /// This function is called only for the batch processing of the proposals.
    /// During batch processing the journals are locked.
    /// </remarks>
    protected void createAndLockJournalForBatchProcessing()
    {
        if (!journalNum && journalName)
        {
            LedgerJournalTable journalTable;

            journalTable.JournalName = journalName.JournalName;
            journalTable.SystemBlocked = NoYes::Yes;
            journalTable.insert();

            journalNum = journalTable.JournalNum;
            info(strFmt("@FixedAssets:JournalCreateNotification", journalNum));
        }
        else
        {
            booksCalculatedInPreviousRun = this.getBooksCalculatedInPreviousRun();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBooksCalculatedInPreviousRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// If system re-ran this batch job due to batch retryable option
    /// get lines which have been already calculated during the previous run.
    /// </summary>
    private Set getBooksCalculatedInPreviousRun()
    {
        if (isExecutingInBatch && journalNum)
        {
            AssetBook assetBook;
            LedgerJournalTrans_Asset ledgerJournalTransAsset;
            LedgerJournalTrans ledgerJournalTrans;

            while select RecId from assetBook
                join RecId from ledgerJournalTransAsset
                where assetBook.AssetId == ledgerJournalTransAsset.AssetId
                    && assetBook.BookId == ledgerJournalTransAsset.BookId
                join RecId from ledgerJournalTrans
                where ledgerJournalTrans.RecId == ledgerJournalTransAsset.RefRecId
                    && ledgerJournalTrans.JournalNum == journalNum
            {
                if (!booksCalculatedInPreviousRun.in(assetBook.RecId))
                {
                    booksCalculatedInPreviousRun.add(assetBook.RecId);
                }
            }
        }

        return booksCalculatedInPreviousRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Integer         version     = conPeek(packedClass,1);
        PackedQueryRun  packedQuery;

        // Since the macro version was incremented from version 8 to version 9
        //  without changing the macro list as part of the AX2012 RTM release, it produces a
        //  collision with those updgrading from AX2009 GLS/GLP Cons to AX6.2 and those
        //  upgrading from AX2012 RTM to AX6.2.  To remedy this situation, we need to
        //  assign the appropriate version based on both the version and the size of the
        //  container.
        if (version == CurrentVersion
            && conLen(packedClass) == 5)  // [version, assetBudgetModelId, journalNum, isFixedAssetBudgetJournal, packedQuery]
        {
                version = #Version8;
        }

        switch (version)
        {
            case CurrentVersion:
                [version,
                assetBudgetModelId,
                journalNum,
                isFixedAssetBudgetJournal,
                // <GCN>
                isFixedAssetJournal,
                voucherType_CN,
                // </GCN>
                batchEnabled,
                journalName,
                transType, packedQuery] = packedClass;
                if (SysQuery::isPackedOk(packedQuery))
                {
                    queryRun = new QueryRun(packedQuery);
                }
                break;
            case #Version9:
                [version,#CurrentListV9,packedQuery] = packedClass;
                if (SysQuery::isPackedOk(packedQuery))
                {
                    queryRun = new QueryRun(packedQuery);
                }
                break;
            case #Version8:
                [version,#CurrentListV8,packedQuery] = packedClass;
                if (SysQuery::isPackedOk(packedQuery))
                {
                    queryRun = new QueryRun(packedQuery);
                }
                break;
            case #Version7:
                [version,#CurrentListV7,packedQuery] = packedClass;
                if (SysQuery::isPackedOk(packedQuery))
                {
                    queryRun = new QueryRun(packedQuery);
                }
                break;
            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostingLayer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the query range value for posting layer with the provided value.
    /// </summary>
    /// <param name="_postingLayer">
    ///  The posting layer.
    /// </param>
    /// <param name = "_rangeStatus">
    /// The status of the object, optional.
    /// </param>
    public void updatePostingLayer(CurrentOperationsTax _postingLayer, RangeStatus _rangeStatus = RangeStatus::Locked)
    {
        QueryBuildRange qr;
        Query query;

        query = queryRun.query();

        qr = SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(AssetBookTable)),
            fieldNum(AssetBookTable, CurrentOperationsTax));
        if (qr)
        {
            qr.status(_rangeStatus);
            qr.value(queryValue(_postingLayer));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    boolean validate(Object _calledFrom = null)
    {
        boolean ret = true;

        if (!this.parmBatchEnabled() && ret && this.budgetJournal())
        {
            if (!assetBudgetModelId)
            {
                ret = checkFailed("@SYS71103");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetProposalCreating</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for getting the new <c>AssetProposal</c> instance.
    /// </summary>
    /// <param name = "_assetTransType">
    /// A <c>AssetTransType</c> enumeration value.
    /// </param>
    /// <param name = "_result">
    /// An <c>EventHandlerResult</c> instance, where subscribers can provide the new <c>AssetProposal</c> instance.
    /// </param>
    static delegate void assetProposalCreating(AssetTransType _assetTransType, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static AssetProposal construct(AssetTransType  _assetTransType)
    {
        AssetProposal   assetProposal;
        switch (_assetTransType)
        {
            case AssetTransType::Depreciation              :
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
                {
                    assetProposal = new AssetProposalDepreciation_PL();
                }
                else
                {
                    assetProposal = new AssetProposalDepreciation();
                }
                break;
            case AssetTransType::DepreciationAdj:
                throw error("@SYS67581");
                break;
            case AssetTransType::Acquisition               :
                assetProposal = new AssetProposalAcquisition();
                break;
            case AssetTransType::AcquisitionAdj            :                
                assetProposal = new AssetProposalAcquisitionAdj();
                break;
            case AssetTransType::Revaluation               :
                assetProposal = new AssetProposalRevaluation();
                break;
            case AssetTransType::None                      :
                assetProposal = new AssetProposalTransferCapital();
                break;
            case AssetTransType::ExtraordinaryDepreciation :
                assetProposal = new AssetProposalExtraordinary();
                break;
            // <GIN>
            case AssetTransType::BonusDepreciation         :
                if (AssetParameters::isDepreciationIncomeTaxActEnable_IN())
                {
                    assetProposal = new AssetProposalBonusDepreciation_IN();
                }
                else
                {
                    assetProposal = new AssetProposalBonusDepreciation();
                }
                break;
            // </GIN>
            // <GEEU>
            case AssetTransType::PreAcquisition_CZ         :
                assetProposal = new AssetProposalCategorization_CZ();
                break;
            // </GEEU>
            case AssetTransType::DisposalScrap:
                if (isconfigurationkeyenabled(configurationKeyNum(Asset)))
                {
                    assetProposal = new AssetProposalDisposalScrap();
                }
                else
                {
                    throw error("@SYS67581");
                }
                break;

            case AssetTransType::DisposalSale   :
                throw error("@SYS67581");
				break;

            default:
                var eventHandlerResult = new EventHandlerResult();
                AssetProposal::assetProposalCreating(_assetTransType, eventHandlerResult);

                if (eventHandlerResult.hasResult())
                {
                    assetProposal = eventHandlerResult.result();
                }
                else
                {
                    throw error("@SYS67581");
                }
        }

        assetProposal.parmAssetTransType(_assetTransType);

        return assetProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static public ClassDescription description()
    {
        return "@SYS67580";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        // <GJP>
        AssetProposal                 assetProposal;
        AssetDocumentProposalType_JP  proposalType   = AssetDocumentProposalType_JP::None;
        // </GJP>
        LedgerJournalTable  ledgerJournalTable;
        LedgerJournalEngine ledgerJournalEngine;
        FormDataSource      formDataSource;
        LedgerJournalTrans  ledgerJournalTrans;

        AssetTransType      assetTransType;

        if (Ledger::reportingCurrency() && !AssetParameters::find().ReportingCurrencyAmountUpdatesComplete)
        {
            Box::stop("@FixedAssets:FA_JournalEntries_DepreciationValidation");
            return;
        }

        // The process is running as a periodic process.
        if (args.menuItemName() == menuItemActionStr(AssetMultiJournalAcqProposal)
            || args.menuItemName() == menuItemActionStr(AssetMultiJournalDepProposal)
            // <GJP>
            || args.menuItemName() == menuItemActionStr(AssetMultiJournalAcceleratedDepProposal_JP)
            || args.menuItemName() == menuItemActionStr(AssetMultiJournalImpairmentProposal_JP)
            // </GJP>
            )
        {
	        // <GJP>
	        if (AssetDocumentUtility_JP::isAssetDocumentEnabled()
	            && args.parmEnumType() == enumNum(AssetDocumentProposalType_JP))
	        {
	            proposalType = args.parmEnum();
	            assetProposal = AssetDocumentProposal_JP::construct(proposalType);
	        }
	        else
	        {
	        // </GJP>
            assetTransType = args.parmEnum();
            assetProposal = AssetProposal::construct(args.parmEnum());
	        // <GJP>
	        }
	        // </GJP>

            assetProposal.parmBatchEnabled(true);
            assetProposal.parmTransType(assetTransType);
            assetProposal.updatePostingLayer(assetProposal.postingLayer, RangeStatus::Hidden);

            if (assetProposal.prompt())
            {
                // User can change the posting layer or the journal used for the proposal
                // on the proposal form.
                assetProposal.parmJournalId('');
                assetProposal.updatePostingLayer(assetProposal.postingLayer, RangeStatus::Hidden);
                // Budget functionality is not supported for the periodic proposals.
                assetProposal.setIsAssetBudgetJournal(false);
                assetProposal.parmBudgetModelId('');
                assetProposal.pack();
                assetProposal.runOperation();
            }
        }
        else
        {
            ledgerJournalTable  = args.caller().ledgerJournalTable();
            ledgerJournalEngine = args.caller().ledgerJournalEngine();
            formDataSource      = FormDataUtil::getFormDataSource(args.record());
            ledgerJournalTrans  = args.record();

            // <GJP>
            if (args.parmEnumType() == enumNum(AssetDocumentProposalType_JP))
            {
                assetProposal = AssetDocumentProposal_JP::construct(args.parmEnum());
                proposalType = args.parmEnum();
            }
            else
            {
                assetProposal = AssetProposal::construct(args.parmEnum());
            }
            // </GJP>

            AssetProposal::performInitialization_Server(assetProposal, ledgerJournalTable.JournalNum);
            assetProposal.updatePostingLayer(ledgerJournalTable.CurrentOperationsTax);

            if (assetProposal.prompt())
            {
                assetProposal.parmJournalId(ledgerJournalTable.JournalNum);
                assetProposal.updatePostingLayer(ledgerJournalTable.CurrentOperationsTax);

                // Check if line exists on form that hasn't been saved, and clear the voucher number
                if (!ledgerJournalTrans.RecId && ledgerJournalTrans.Voucher)
                {
                    ledgerJournalEngine.clearVoucher();
                }

                AssetProposal::performProposal_Server(assetProposal, ledgerJournalTrans, ledgerJournalTable.JournalNum
                    // <GJP>
                    , proposalType
                    // </GJP>
                    , args.parm()
                );

                // Update the totals.  This is needed because is updates variables in
                // JournalEngine that control if the voucher is complete.
                if (ledgerJournalTrans)
                {
                    ledgerJournalEngine.voucherTotals(ledgerJournalTrans, true);
                }

                // redisplay the form
                formDataSource.executeQuery();
                ledgerJournalEngine.ledgerJournalTableUpdateTotals(ledgerJournalTable,true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>performInitialization_Server</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs some of the initialization of the asset proposal on the server.
    /// </summary>
    /// <param name="_assetProposal">
    ///    The asset proposal to perform the initialization on.
    /// </param>
    /// <param name="_journalNum">
    ///    The journal number that will be used by the proposal.
    /// </param>
    protected static void performInitialization_Server(AssetProposal _assetProposal, LedgerJournalId _journalNum)
    {
        // <GCN>
        LedgerJournalType journalType;
        // </GCN>

        _assetProposal.getLast();
        // <GCN>
        if (LedgerParameters::isChineseVoucher_CN())
        {
            journalType = LedgerJournalName::find(LedgerJournalTable::find(_journalNum).JournalName).JournalType;
            _assetProposal.setIsAssetBudgetJournal(journalType == LedgerJournalType::AssetBudgets);
            _assetProposal.setIsFixedAssetJournal_CN(journalType == LedgerJournalType::Assets);
        }
        else
        {
        // </GCN>
            _assetProposal.setIsAssetBudgetJournal(LedgerJournalName::find(LedgerJournalTable::find(_journalNum).JournalName).JournalType == LedgerJournalType::AssetBudgets);
        // <GCN>
        }
        // </GCN>

        _assetProposal.journalNum(_journalNum);
        _assetProposal.parmBatchEnabled(false);
        _assetProposal.initQuery();
    }

]]></Source>
			</Method>
			<Method>
				<Name>performProposal_Server</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Runs the proposal.
    /// </summary>
    /// <param name="_assetProposal">
    ///    The asset proposal that will be run.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    ///    The journal line that the user was on when they performed the proposal.
    /// </param>
    /// <param name="_journalNum">
    ///    The journal number that will be used by the proposal.
    /// </param>
    /// <param name="_assetDocumentProposalType">
    ///    The asset document proposal type; Optional.
    /// </param>
    /// <param name="_argParmProposalType_RU">A parameter proposal type to identify ad-hoc asset operations; optional.</param>
    protected static void performProposal_Server(AssetProposal _assetProposal, LedgerJournalTrans _ledgerJournalTrans, LedgerJournalId _journalNum
        , AssetDocumentProposalType_JP   _assetDocumentProposalType  = AssetDocumentProposalType_JP::None
        , ParmTxt _argParmProposalType_RU = ''
    )
    {
        Voucher lastVoucher;
        LedgerJournalTrans  ledgerJournalTransLocal;

        // <GJP>
        AssetProposal assetProposal;
        boolean isDocumentProposal = false;
        // </GJP>

        //
        // Find the last voucher number. This is needed when user had done a ctrl-N to
        // create a new line and then deleted the line.
        //
        if (_ledgerJournalTrans.RecId)
        {
            select firstonly Voucher from _ledgerJournalTrans
                order by Voucher desc
                where _ledgerJournalTrans.JournalNum == _journalNum;

            lastVoucher = _ledgerJournalTrans.Voucher;
        }

        // <GJP>
        if (AssetDocumentUtility_JP::isAssetDocumentEnabled())
        {
            if (_assetDocumentProposalType != AssetDocumentProposalType_JP::None)
            {
                isDocumentProposal = true;
                assetProposal = AssetDocumentProposal_JP::construct(_assetDocumentProposalType);
            }
        }
        // </GJP>

        if (!isDocumentProposal)
        {
            assetProposal = AssetProposal::construct(_assetProposal.parmAssetTransType());
        }

        assetProposal.unpack(_assetProposal.pack());
        assetProposal.runOperation();

        // update the voucher totals if reuse the voucher
        if (!_ledgerJournalTrans.Voucher || !_ledgerJournalTrans.RecId)
        {
            // No lines existed where user did the proposal, need to update the
            // totals for the first voucher.
            if (!_ledgerJournalTrans.Voucher)
            {
                select firstonly _ledgerJournalTrans
                    order by Voucher
                    where _ledgerJournalTrans.JournalNum == _journalNum;
            }
            // User was on a new line when doing the proposal, need to update the
            // totals for the voucher on that line.
            else
            {
                _ledgerJournalTrans = LedgerJournalTrans::find(_journalNum, _ledgerJournalTrans.Voucher, false);
            }
        }
        // User was on an existing line when doing the proposal, need to update the
        // total for the next voucher after the last voucher number that existed
        // before doing the proposal
        else
        {
            select firstonly ledgerJournalTransLocal
                order by Voucher
                where ledgerJournalTransLocal.JournalNum == _journalNum &&
                      ledgerJournalTransLocal.Voucher > lastVoucher;
            if (ledgerJournalTransLocal)
            {
                _ledgerJournalTrans.data(ledgerJournalTransLocal);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxJournalLinesInTransactionBoundry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Maximum number of journal line in one data base transaction
    /// </summary>
    public int getMaxJournalLinesInTransactionBoundry()
    {
        return 1000;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxBooksInTaskBoundry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Maximum number of value models in one batch task
    /// </summary>
    public int getMaxBooksInTaskBoundry()
    {
        return 2000;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidJournalNameAndPostingLayer</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method validates if a given posting layer matches the posting layer value of the given journal name.
    /// </summary>
    /// <param name = "_ledgerJournalName">Journal name</param>
    /// <param name = "_postingLayer">Posting layer to validate</param>
    /// <returns>True if the posting layer matches the posting layer value of the journal, otherwise false</returns>
    public static boolean isValidJournalNameAndPostingLayer(
        LedgerJournalNameId _ledgerJournalName,
        CurrentOperationsTax _postingLayer)
    {
        boolean returnValue = true;
        LedgerJournalName ledgerJournalNameLocal;

        select firstonly CurrentOperationsTax from ledgerJournalNameLocal
            where ledgerJournalNameLocal.JournalName == _ledgerJournalName;

        if (ledgerJournalNameLocal.CurrentOperationsTax != _postingLayer)
        {
            returnValue = checkFailed(strFmt("@SYS4006645", _ledgerJournalName));
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildAccountItemLedgerDimensionParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a parameter for searching an inventory posting account ledger dimension for an item.
    /// </summary>
    /// <param name = "_vendInvoiceInfoLine">A vendor invoice line.</param>
    /// <param name = "_inventDim">An inventory dimension.</param>
    /// <returns>The built parameter instance.</returns>
    protected InventPostingAccountItemLedgerDimensionParameters buildAccountItemLedgerDimensionParameter(VendInvoiceInfoLine _vendInvoiceInfoLine, InventDim _inventDim)
    {
        return InventPostingAccountItemLedgerDimensionParameters::newFromParameters(
            InventAccountType::PurchExpense,
            _vendInvoiceInfoLine.ItemId,
            _vendInvoiceInfoLine.inventTable().itemGroupId(),
            _vendInvoiceInfoLine.ProcurementCategory,
            _vendInvoiceInfoLine.OrderAccount,
            VendTable::find(_vendInvoiceInfoLine.OrderAccount).VendGroup,
            _vendInvoiceInfoLine.TaxGroup,
            _inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfAvailableThreads</Name>
				<Source><![CDATA[
    private int getNumberOfAvailableThreads(BatchGroupId _batchGroupId)
    {
        SysServerConfig     sysServerConfig;
        BatchServerConfig   batchServerConfig;
        BatchServerGroup    batchServerGroup;

        select sum(MaxBatchSessions) from batchServerConfig
            exists join sysServerConfig exists join batchServerGroup
                where batchServerConfig.ServerId == sysServerConfig.ServerId &&
                        batchServerConfig.ServerId == batchServerGroup.ServerId &&
                        batchServerGroup.GroupId == _batchGroupId;

        return batchServerConfig.MaxBatchSessions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    public boolean isRetryable() 
    {
        boolean ret = true;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBookCalculatedInPreviousRun</Name>
				<Source><![CDATA[
    internal boolean isBookCalculatedInPreviousRun(AssetBook _assetBook)
    {
        return !booksCalculatedInPreviousRun.empty()
            && booksCalculatedInPreviousRun.in(_assetBook.RecId);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>