<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BomCalcJob</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class BomCalcJob extends RunBaseBatch
{
    ItemId                      itemId;
    InventDimId                 inventDimId;
    BOMId                       bomId;
    RouteId                     routeId;

    boolean                     findOutItemProductionMode;
    ItemProcurementMode         itemProcurementMode;
    RefRecId                    productionFlowReferenceRecId;

    PriceCalcId                 priceCalcId;
    CostingVersionIdOpen        versionId;
    boolean                     allowConversionCostingVersion;
    BOMCalcCostingVersionUpdate calcCostingVersionUpdate;
    BOMCalcFallBack             bomCalcFallBack;
    CostingVersionId            fallBackVersionId;
    BOMCostPriceModel           costPriceModel;
    PurchPriceModel             purchPriceModel;

    TransDate                   calcDate;
    CostProfitSet               profitSet;

    BOMCalcItem                 bomCalcItem;
    boolean                     showItemPriceCalcFormAfterRun;

    InventSiteId                siteId;

    BOMRouteVersionSelect       bomRouteVersionSelect;

    LeanCostingFacadeBase       leanCostingFacade;

    // Transfer cost price
    NoYes                       costPriceTransfer;
    NoYes                       costPriceInclInUnitPrice;
    NoYes                       costPriceRoundOff;

    // Transfer sales price
    NoYes                       salesPriceTransfer;
    NoYes                       salesPriceInclInUnitPrice;
    NoYes                       salesPriceRoundOff;

    // Transfer net weight
    NoYes                       netWeightTransfer;

    // Price explosion mode
    BOMCalcExplosionMode        bomCalcExplosionMode;

    // Where used update
    BOMCalcWhereUsedUpdate      bomCalcWhereUsedUpdate;

    // Warnings
    NoYes                       overrideGroupWarnings;

    NoYes                       checkNoBOM;
    NoYes                       checkNoRoute;
    NoYes                       checkNoResource;
    NoYes                       checkNoConsump;
    NoYes                       checkNoCostPrice;
    int                         checkAgeCostPrice;
    real                        checkMinContribution;
    NoYes                       checkMissingUpdates;
    NoYes                       checkUseFallBack;
    Exception                   exceptionType;

    ItemId                      pmfCoProductItemId;
    InventDimId                 pmfCoProductInventDimId;
    PmfPriceCalcId              pmfParentCalcId;
    CostingVersion              costingVersion;
    PmfCostAllocationPct        pmfCostAllocationPct;
    Qty                         pmfFormulaSeries;
    PmfYieldPct                 pmfYieldPct;
    BOMVersion                  pmfBOMVersion;
    PdsComdPricingRun           pdsComdPricingRun;
    PmfProductType              pmfCoByProductType;
    private boolean             useCostCalculationLevel;

    #Define.CurrentVersion(15)
    #LOCALMACRO.CurrentList
        CalcDate,
        ProfitSet,
        costPriceTransfer,
        costPriceInclInUnitPrice,
        costPriceRoundOff,
        salesPriceTransfer,
        salesPriceInclInUnitPrice,
        salesPriceRoundOff,
        netWeightTransfer,
        bomCalcExplosionMode,
        overrideGroupWarnings,
        checkNoBOM,
        checkNoRoute,
        checkNoConsump,
        checkNoCostPrice,
        checkAgeCostPrice,
        checkMinContribution,
        versionId,
        calcCostingVersionUpdate,
        checkMissingUpdates,
        checkUseFallBack,
        BOMCalcFallBack,
        fallBackVersionId,
        costPriceModel,
        purchPriceModel,
        siteId,
        allowConversionCostingVersion,
        bomCalcWhereUsedUpdate,
        findOutItemProductionMode,
        itemProcurementMode,
        productionFlowReferenceRecId,
        checkNoResource,
        pmfYieldPct,
        pmfBOMVersion,
        pmfCoByProductType,
        itemId,
        inventDimId,
        bomId,
        routeId,
        priceCalcId,
        bomRouteVersionSelect,
        exceptionType,
        pmfCoProductItemId,
        pmfCoProductInventDimId,
        pmfParentCalcId,
        costingVersion,
        pmfCostAllocationPct,
        pmfFormulaSeries,
        pdsComdPricingRun
    #ENDMACRO
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowConversionCostingVersion</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets up the bill of materials (BOM) calculation to let you use costing versions of the type
    ///    conversion.
    /// </summary>
    /// <param name="_costingVersion">
    ///    The costing version.
    /// </param>
    void allowConversionCostingVersion(CostingVersion _costingVersion)
    {
        costingVersion = _costingVersion;

        if (_costingVersion.VersionId && _costingVersion.CostingType == CostingVersionCostingType::Conversion)
        {
            allowConversionCostingVersion = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowedBOMCalcExplosionModeSet</Name>
				<Source><![CDATA[
    public Set allowedBOMCalcExplosionModeSet()
    {
        Set allowedBOMCalcExplosionModeSet;

        allowedBOMCalcExplosionModeSet = new Set(Types::Enum);
        allowedBOMCalcExplosionModeSet.add(BOMCalcExplosionMode::MultiLevel);
        allowedBOMCalcExplosionModeSet.add(BOMCalcExplosionMode::MakeToOrder);
        allowedBOMCalcExplosionModeSet.add(BOMCalcExplosionMode::SingleLevel);
        allowedBOMCalcExplosionModeSet.add(BOMCalcExplosionMode::AccordingBOMLineType);

        return allowedBOMCalcExplosionModeSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBOMCalcItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes calculation on the BOMCalcItem object.
    /// </summary>
    protected void calcBOMCalcItem()
    {
        bomCalcItem.calc();
        bomCalcItem.showInfolog();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateAll</Name>
				<Source><![CDATA[
    boolean calculateAll()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the class is shown in the list of <c>Journal</c> types.
    /// </summary>
    /// <returns>
    ///    true if the class is shown in the list of <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    A class that can be used in a batch journal is a class in which the same parameters can be used
    ///    repeatedly. The dialog box can be shown and the parameters can be changed but parameters of some
    ///    classes might build on data that is only valid for a short time. Not all classes can be run two
    ///    times with the same parameters. If the <c>canGoBatch</c> method returns false, this method will not
    ///    have any effect.
    /// </remarks>
    protected boolean canGoBatchJournal()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSwapBetweenCS</Name>
				<Source><![CDATA[
    protected boolean canSwapBetweenCS()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCloseDialog</Name>
				<Source><![CDATA[
    public boolean checkCloseDialog(Object calledFrom = null)
    {
        boolean         ret;
        CostingVersion  fallbackCostingVersion;

        ret = super();

        if (! this.showSales())
        {
            if (!siteId)
            {
                ret = checkFailed(strFmt("@SYS84378", fieldPName(InventSite,SiteId))) && ret;
            }

            if (versionId)
            {
                costingVersion = CostingVersion::find(versionId);
                if (! costingVersion.RecId)
                {
                    ret = checkFailed("@SYS40636");
                }

                if (costingVersion.Blocked)
                {
                    ret = checkFailed("@SYS104362");
                }
                if (costingVersion.CostingType == CostingVersionCostingType::Conversion)
                {
                    if (! allowConversionCostingVersion)
                    {
                        ret = checkFailed("@SYS120283");
                    }
                    if (InventStdCostConv::findCostingVersion(costingVersion.VersionId).Status != InventStdCostConvStatus::Planned)
                    {
                        ret = checkFailed("@SYS123281");
                    }
                }
            }
            else
            {
                ret = checkFailed("@SYS105588");
            }

            if (!costPriceTransfer && !salesPriceTransfer)
            {
                ret = checkFailed("@SYS105680");
            }

            switch (bomCalcFallBack)
            {
                case BOMCalcFallBack::Simulated:
                    if (fallBackVersionId)
                    {
                        fallbackCostingVersion = CostingVersion::find(fallBackVersionId);
                        if ((costingVersion.CostingType == CostingVersionCostingType::Standard || costingVersion.CostingType == CostingVersionCostingType::Conversion) &&
                            fallbackCostingVersion.CostingType != CostingVersionCostingType::Standard)
                        {
                            ret = checkFailed(strFmt("@SYS112057", CostingVersionCostingType::Standard));
                        }

                        if (fallbackCostingVersion.CostingType == CostingVersionCostingType::Conversion)
                        {
                            ret = checkFailed(strFmt("@SYS120284", CostingVersionCostingType::Conversion));
                        }
                    }
                    else
                    {
                        ret  = checkFailed("@SYS106033");
                    }
                    if (fallBackVersionId == versionId)
                    {
                        ret  = checkFailed("@SYS104634");
                    }
                    break;

                case BOMCalcFallBack::None,
                    BOMCalcFallBack::CurrentActive:
                    if (fallBackVersionId)
                    {
                        ret  = checkFailed("@SYS106034");
                    }
                    break;
            }

            if (! calcDate)
            {
                ret = checkFailed("@SYS107048");
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructBOMCalcItem</Name>
				<Source><![CDATA[
    protected BOMCalcItem constructBOMCalcItem()
    {
        BomCalcItem_PmfCoProduct bomCalcItem_CoProduct;
        BOMCalcItem bomCalcItemLocal;
        BOMVersion  bomVersionItem = this.findBOMVersion();

        this.updateQuantitiesForFormula(bomVersionItem);

        if (this.parmPmfCoProduct() != '')
        {
            bomCalcItem_CoProduct = BomCalcItem_PmfCoProduct::newCoByProduct(
                this.parmPmfCoByProductType(),
                this.parmPmfCoProduct(),
                itemId,
                inventDimId,
                this.seriesSize(),
                bomId,
                routeId,
                profitSet,
                bomCalcExplosionMode,
                this.parmPmfParentCalcId(),
                this.parmPmfFormulaSeries(),
                '',
                calcDate,
                bomRouteVersionSelect,
                !this.calculateAll(),
                    versionId
                    ? BOMCalcType::Version
                    : BOMCalcType::Order,
                    versionId,
                    calcCostingVersionUpdate,
                    costPriceTransfer,
                    salesPriceTransfer,
                    bomCalcFallBack,
                    fallBackVersionId,
                    costPriceModel);

            bomCalcItem_CoProduct.parmCoProductInventDimId(this.parmPmfCoProductInventDimId());
            bomCalcItemLocal = bomCalcItem_CoProduct;
            bomCalcItemLocal.parmPmfCostAllocationPct(this.parmPmfCostAllocationPct());
            bomCalcItemLocal.parmPmfYieldPct(this.parmPmfYieldPct());
            bomCalcItemLocal.parmPmfBomVersion(bomVersionItem);
        }
        else
        {
            bomCalcItemLocal =
            BOMCalcItem::newItem(itemId,
                            inventDimId,
                            this.seriesSize(),
                            bomId,
                            routeId,
                            profitSet,
                            bomCalcExplosionMode,
                            '',
                            calcDate,
                            bomRouteVersionSelect,
                            !this.calculateAll(),
                            versionId ? BOMCalcType::Version : BOMCalcType::Order,
                            versionId,
                            calcCostingVersionUpdate,
                            costPriceTransfer,
                            salesPriceTransfer,
                            bomCalcFallBack,
                            fallBackVersionId,
                            costPriceModel,
                            purchPriceModel,
                            findOutItemProductionMode,
                            productionFlowReferenceRecId,
                            itemProcurementMode,
                            leanCostingFacade);
            if (#PmfEnabled && bomCalcItemLocal)
            {
                if (BOM::isPmfFormula(bomVersionItem.bomId))
                {
                    this.parmPmfCostAllocationPct(BOMCalcItem::pmfUnallocated(bomVersionItem));
                    bomCalcItemLocal.parmPmfYieldPct(this.parmPmfYieldPct());
                }
                bomCalcItemLocal.parmPmfCostAllocationPct(this.parmPmfCostAllocationPct());
                bomCalcItemLocal.parmPmfBomVersion(bomVersionItem);
            }
        }

        return bomCalcItemLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructBOMCalcJobCoProduct</Name>
				<Source><![CDATA[
    protected BOMCalcJob_Item constructBOMCalcJobCoProduct()
    {
        return BOMCalcJob_Item::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>coProductInventDimId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the inventory dimension ID used when running calculations for co-products and byproducts.
    /// </summary>
    /// <param name = "_coByProduct">The <c>PmfFormulaCoBy</c> record.</param>
    /// <returns>The inventory dimension ID used when running calculations for co-products and byproducts.</returns>
    protected InventDimId coProductInventDimId(PmfFormulaCoBy _coByProduct)
    {
        InventDim coByProductInventoryDimensions = InventDim::find(_coByProduct.InventDimId);

        if (!coByProductInventoryDimensions.InventSiteId)
        {
            coByProductInventoryDimensions.InventSiteId = InventDim::find(this.parmInventDimId()).InventSiteId;

            return InventDim::findOrCreate(coByProductInventoryDimensions).inventDimId;
        }

        return _coByProduct.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCoProductCalcs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and runs calculations for co-products and byproducts.
    /// </summary>
    public void createCoProductCalcs()
    {
        BOMCalcJob_Item     calc_coProduct;
        PmfFormulaCoBy      coBy;
        InventQty           calcQty;

        if (bomCalcItem.parmPmfBomVersion().RecId)
        {
            while select ItemId, InventDimId, CoByQty, CoByQtySerie, CostAllocationPct, ProductType
                from coBy
                where   coBy.bomVersionRefRecId  == bomCalcItem.parmPmfBomVersion().RecId
                     && !(  coBy.ProductType == PmfProductType::By_Product
                         && coBy.BurdenType  == PmfBurdenType::Recycled)
            {
                if (coBy.CoByQty == 0 || coBy.CoByQtySerie == 0)
                {
                    warning(
                        strFmt("@PRO2870",
                            fieldPName(PmfFormulaCoBy, CoByQty),
                            fieldPName(PmfFormulaCoBy, CoByQtySerie),
                            coBy.ItemId,
                            coBy.bomId));
                }
                else
                {
                    calc_coProduct = this.constructBOMCalcJobCoProduct();
                    calc_coProduct.getLast();
                    calc_coProduct.parmPmfCoProduct(coBy.ItemId);
                    calc_coProduct.parmPmfCoByProductType(coBy.ProductType);
                    calc_coProduct.parmPmfCoProductInventDimId(this.coProductInventDimId(coBy));
                    calc_coProduct.parmItemId(this.parmItemId());
                    calc_coProduct.parmInventDimId(this.parmInventDimId());

                    if (this.parmItemQty())
                    {
                        calcQty = this.parmItemQty();
                    }
                    else
                    {
                        calcQty = this.seriesSize();
                    }

                    calc_coProduct.parmItemQty(
                                        calcQty
                                        * coBy.CoByQty
                                        / coBy.CoByQtySerie);
                    calc_coProduct.parmBOMId(bomCalcItem.parmPmfBomVersion().bomId);
                    calc_coProduct.parmPmfBOMVersion(bomCalcItem.parmPmfBomVersion());
                    calc_coProduct.parmRouteId(this.parmRouteId());
                    calc_coProduct.parmVersionId(this.parmVersionId());
                    calc_coProduct.allowConversionCostingVersion(costingVersion);
                    calc_coProduct.parmPmfParentCalcId(priceCalcId);
                    calc_coProduct.parmPmfCostAllocationPct(coBy.CostAllocationPct);
                    calc_coProduct.parmPmfFormulaSeries(calcQty);
                    calc_coProduct.parmPmfYieldPct(this.parmPmfYieldPct());
                    calc_coProduct.parmCostPriceTransfer(costPriceTransfer);
                    calc_coProduct.parmCostPriceInclInUnitPrice(costPriceInclInUnitPrice);
                    calc_coProduct.parmCostPriceRoundOff(costPriceRoundOff);
                    calc_coProduct.parmSalesPriceTransfer(salesPriceTransfer);
                    calc_coProduct.parmSalesPriceInclInUnitPrice(salesPriceInclInUnitPrice);
                    calc_coProduct.parmSalesPriceRoundOff(salesPriceRoundOff);
                    calc_coProduct.parmCalcDate(calcDate);
                    calc_coProduct.parmCostPriceModel(this.parmCostPriceModel());
                    calc_coProduct.parmPurchPriceModel(this.parmPurchPriceModel());
                    calc_coProduct.parmBOMCalcExplosionMode(this.parmBOMCalcExplosionMode());
                    calc_coProduct.parmBOMCalcFallBack(this.parmBOMCalcFallBack());
                    calc_coProduct.parmFallBackVersionId(this.parmFallBackVersionId());
                    calc_coProduct.parmBomCalcWhereUsedUpdate(this.parmBomCalcWhereUsedUpdate());
                    calc_coProduct.parmCalcCostingVersionUpdate(this.parmCalcCostingVersionUpdate());
                    calc_coProduct.parmProfitSet(this.parmProfitSet());
                    calc_coProduct.parmItemProcurementMode(this.parmItemProcurementMode());
                    calc_coProduct.parmFindOutItemProductionMode(this.parmFindOutItemProductionMode());
                    calc_coProduct.parmProductionFlowReferenceRecId(0);
                    calc_coProduct.runOperation();
                }
            }

            this.runCalculationForRecycledBPsMissingCost();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
    ///    created in the Application Object Tree (AOT).
    /// </remarks>
    Object dialog()
    {
        return this.dialogInternal(Dialog::newFormnameRunbase(formStr(BOMCalcDialog),this));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFormulaBomVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method finds BOM version for formula item based on bomId
    /// </summary>
    /// <returns>
    /// <c>BOMVersion</c> record
    /// </returns>
    /// <remarks>
    /// First tries to find active BOM version in calculation period.
    /// If there is no such record finds any BOM version for specified BOM.
    /// </remarks>
    protected BOMVersion findFormulaBomVersion()
    {
        BOMVersion bomVersion;

        bomVersion = BOMVersion::selectBomVersion(this.parmItemId(),
                                                  this.parmCalcDate(),
                                                  this.parmItemQty() ? this.parmItemQty() : this.seriesSize(),
                                                  InventDim::find(this.parmInventDimId()),
                                                  true,
                                                  false,
                                                  true,
                                                  false,
                                                  true,
                                                  bomId);
        if (!bomVersion)
        {
            bomVersion = BOMVersion::selectBomVersion(this.parmItemId(),
                                                      dateNull(),
                                                      maxInt(),
                                                      InventDim::find(this.parmInventDimId()),
                                                      true,
                                                      true,
                                                      true,
                                                      true,
                                                      false,
                                                      bomId);
        }

        return bomVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the last choice that was stored in the last value table.
    /// </summary>
    /// <remarks>
    ///    If no record can be found or the <c>unpack</c> method returns false, the <c>initParmDefault</c>
    ///    method will be called.This method should not typically be overridden.
    /// </remarks>
    void getLast()
    {
        super();

        calcDate                    = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        versionId                   = '';
        allowConversionCostingVersion = false;
        bomCalcWhereUsedUpdate      = NoYes::No;
        pmfBOMVersion               = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the internal variables.
    /// </summary>
    /// <remarks>
    ///    This method is called when no <c>SysLastValue</c> record can be found when the
    ///    <c>SysLastValue.GetLast</c> method is called. Remember to call the <c>super</c> method.
    /// </remarks>
    void initParmDefault()
    {
        calcDate                    = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        profitSet                   = CostProfitSet::Standard;

        costPriceTransfer           = NoYes::No;
        costPriceInclInUnitPrice    = NoYes::No;
        costPriceRoundOff           = NoYes::No;

        salesPriceTransfer          = NoYes::No;
        salesPriceInclInUnitPrice   = NoYes::No;
        salesPriceRoundOff          = NoYes::No;

        netWeightTransfer           = NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimIdSite</Name>
				<Source><![CDATA[
    InventDimId inventDimIdSite()
    {
        InventDim   inventDimSite;

        inventDimSite.InventSiteId = this.parmSiteId();
        return InventDim::findOrCreate(inventDimSite).InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
        super();

        calcDate                    = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        profitSet                   = CostProfitSet::Standard;
        priceCalcId                 = '';

        costPriceTransfer           = NoYes::Yes;
        costPriceInclInUnitPrice    = NoYes::Yes;
        costPriceRoundOff           = NoYes::Yes;

        salesPriceTransfer          = NoYes::Yes;
        salesPriceInclInUnitPrice   = NoYes::Yes;
        salesPriceRoundOff          = NoYes::Yes;

        netWeightTransfer           = NoYes::Yes;

        bomCalcExplosionMode        = BOMCalcExplosionMode::MultiLevel;

        overrideGroupWarnings       = NoYes::No;
        checkNoBOM                  = NoYes::No;
        checkNoRoute                = NoYes::No;
        checkNoResource             = NoYes::No;
        checkNoConsump              = NoYes::No;
        checkNoCostPrice            = NoYes::No;
        checkAgeCostPrice           = NoYes::No;
        checkMinContribution        = NoYes::No;
        versionId                   = '';
        calcCostingVersionUpdate    = BOMCalcCostingVersionUpdate::Overwrite;
        checkMissingUpdates         = NoYes::No;
        checkUseFallBack            = NoYes::No;
        bomCalcFallBack             = BOMCalcFallBack::None;
        fallBackVersionId           = '';
        costPriceModel              = BOMCostPriceModel::BOMCalcGroup;
        purchPriceModel             = PurchPriceModel::PurchPrice;
        allowConversionCostingVersion = false;
        exceptionType               = Exception::Warning;
        pmfCoProductItemId          = '';
        pmfParentCalcId             = '';
        pmfCostAllocationPct        = 100;
        pmfYieldPct                 = 100;
        useCostCalculationLevel     = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packed = [#CurrentVersion,#CurrentList];

        return SysPackExtensions::appendExtension(packed, classStr(BomCalcJob), [useCostCalculationLevel]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseCostCalculationLevel</Name>
				<Source><![CDATA[
    public boolean parmUseCostCalculationLevel(boolean _useCostCalculationLevel = useCostCalculationLevel)
    {
        if (!BOMCalcJobExcludeProdOrderFromCostCalculationFeature::instance().isEnabled())
        {
            return false;
        }

        useCostCalculationLevel = _useCostCalculationLevel;
        return useCostCalculationLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBOMLevelFieldId</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    protected FieldId getBOMLevelFieldId()
    {
        if (this.parmUseCostCalculationLevel())
        {
            return fieldNum(InventTable, CostBOMLevel);
        }
        return fieldNum(InventTable, BOMLevel);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBOMCalcExplosionMode</Name>
				<Source><![CDATA[
    public BOMCalcExplosionMode parmBOMCalcExplosionMode(BOMCalcExplosionMode _bomCalcExplosionMode = bomCalcExplosionMode)
    {
        bomCalcExplosionMode = _bomCalcExplosionMode;

        return bomCalcExplosionMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBOMCalcFallBack</Name>
				<Source><![CDATA[
    BOMCalcFallBack parmBOMCalcFallBack(BOMCalcFallBack _bomCalcFallBack = bomCalcFallBack)
    {
        bomCalcFallBack = _bomCalcFallBack;
        return bomCalcFallBack;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBomCalcWhereUsedUpdate</Name>
				<Source><![CDATA[
    public BOMCalcWhereUsedUpdate parmBomCalcWhereUsedUpdate(BOMCalcWhereUsedUpdate _bomCalcWhereUsedUpdate = bomCalcWhereUsedUpdate)
    {
        bomCalcWhereUsedUpdate = _bomCalcWhereUsedUpdate;

        return bomCalcWhereUsedUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBOMId</Name>
				<Source><![CDATA[
    BOMId parmBOMId(BOMId _bomId = bomId)
    {
        bomId = _bomId;
        return bomId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBOMRouteVersionSelect</Name>
				<Source><![CDATA[
    BOMRouteVersionSelect parmBOMRouteVersionSelect(BOMRouteVersionSelect _bomRouteVersionSelect = bomRouteVersionSelect)
    {
        bomRouteVersionSelect = _bomRouteVersionSelect;
        return bomRouteVersionSelect;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCalcCostingVersionUpdate</Name>
				<Source><![CDATA[
    BOMCalcCostingVersionUpdate parmCalcCostingVersionUpdate(BOMCalcCostingVersionUpdate _calcCostingVersionUpdate = calcCostingVersionUpdate)
    {
        calcCostingVersionUpdate = _calcCostingVersionUpdate;
        return calcCostingVersionUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCalcDate</Name>
				<Source><![CDATA[
    TransDate parmCalcDate(TransDate newCalcDate = calcDate)
    {
        calcDate = newCalcDate;
        return calcDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckAgeCostPrice</Name>
				<Source><![CDATA[
    int parmCheckAgeCostPrice(int _checkAgeCostPrice = checkAgeCostPrice)
    {
        checkAgeCostPrice = _checkAgeCostPrice;
        return checkAgeCostPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckMinContribution</Name>
				<Source><![CDATA[
    real parmCheckMinContribution(real _checkMinContribution = checkMinContribution)
    {
        checkMinContribution = _checkMinContribution;
        return checkMinContribution;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckMissingUpdates</Name>
				<Source><![CDATA[
    NoYes parmCheckMissingUpdates(NoYes _checkMissingUpdates = checkMissingUpdates)
    {
        checkMissingUpdates = _checkMissingUpdates;
        return checkMissingUpdates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckNoBOM</Name>
				<Source><![CDATA[
    NoYes parmCheckNoBOM(NoYes _checkNoBOM = checkNoBOM)
    {
        checkNoBOM = _checkNoBOM;
        return checkNoBOM;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckNoConsump</Name>
				<Source><![CDATA[
    NoYes parmCheckNoConsump(NoYes _checkNoConsump = checkNoConsump)
    {
        checkNoConsump = _checkNoConsump;
        return checkNoConsump;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckNoCostPrice</Name>
				<Source><![CDATA[
    NoYes parmCheckNoCostPrice(NoYes _checkNoCostPrice = checkNoCostPrice)
    {
        checkNoCostPrice = _checkNoCostPrice;
        return checkNoCostPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckNoResource</Name>
				<Source><![CDATA[
    NoYes parmCheckNoResource(NoYes _checkNoResource = checkNoResource)
    {
        checkNoResource = _checkNoResource;
        return checkNoResource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckNoRoute</Name>
				<Source><![CDATA[
    NoYes parmCheckNoRoute(NoYes _checkNoRoute = checkNoRoute)
    {
        checkNoRoute = _checkNoRoute;
        return checkNoRoute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckUseFallBack</Name>
				<Source><![CDATA[
    NoYes parmCheckUseFallBack(NoYes _checkUseFallBack = checkUseFallBack)
    {
        checkUseFallBack = _checkUseFallBack;
        return checkUseFallBack;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCostPriceInclInUnitPrice</Name>
				<Source><![CDATA[
    // Include charges in cost price
    NoYes parmCostPriceInclInUnitPrice(NoYes _costPriceInclInUnitPrice = costPriceInclInUnitPrice)
    {
        costPriceInclInUnitPrice = _costPriceInclInUnitPrice;
        return costPriceInclInUnitPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCostPriceModel</Name>
				<Source><![CDATA[
    BOMCostPriceModel parmCostPriceModel(BOMCostPriceModel _costPriceModel = costPriceModel)
    {
        costPriceModel = _costPriceModel;
        return costPriceModel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCostPriceRoundOff</Name>
				<Source><![CDATA[
    // Round off the cost price
    public NoYes parmCostPriceRoundOff(
        NoYes _costPriceRoundOff = costPriceRoundOff)
    {
        costPriceRoundOff = _costPriceRoundOff;
        return costPriceRoundOff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCostPriceTransfer</Name>
				<Source><![CDATA[
    // Transfer cost price and charges
    NoYes parmCostPriceTransfer(NoYes _costPriceTransfer = costPriceTransfer)
    {
        costPriceTransfer = _costPriceTransfer;
        return costPriceTransfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCWQty</Name>
				<Source><![CDATA[
    // CW quantity does not participate in BOM calculation. It is used only as a data provider for BOMCalcDialog form.
    abstract PdsCWInventQty parmCWQty(PdsCWInventQty _cwQty = 0)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExceptionType</Name>
				<Source><![CDATA[
    private Exception parmExceptionType(Exception _exceptionType = exceptionType)
    {
        exceptionType = _exceptionType;
        return exceptionType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFallBackVersionId</Name>
				<Source><![CDATA[
    CostingVersionIdOpen parmFallBackVersionId(CostingVersionIdOpen _fallBackVersionId = fallBackVersionId)
    {
        fallBackVersionId = _fallBackVersionId;
        return fallBackVersionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFindOutItemProductionMode</Name>
				<Source><![CDATA[
    public boolean parmFindOutItemProductionMode(boolean _findOutItemProductionMode = findOutItemProductionMode)
    {
        findOutItemProductionMode = _findOutItemProductionMode;

        return findOutItemProductionMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimId</Name>
				<Source><![CDATA[
    InventDimId parmInventDimId(InventDimId _inventDimId = inventDimId)
    {
        inventDimId = _inventDimId;

        return inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemId</Name>
				<Source><![CDATA[
    ItemId parmItemId(ItemId _itemId = itemId)
    {
        itemId = _itemId;
        return itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemProcurementMode</Name>
				<Source><![CDATA[
    public ItemProcurementMode parmItemProcurementMode(ItemProcurementMode _itemProcurementMode = itemProcurementMode)
    {
        itemProcurementMode = _itemProcurementMode;

        return itemProcurementMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemQty</Name>
				<Source><![CDATA[
    abstract Qty parmItemQty(Qty _itemQty = 0)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLeanCostingFacade</Name>
				<Source><![CDATA[
    LeanCostingFacadeBase parmLeanCostingFacade(LeanCostingFacadeBase _leanCostingFacade = leanCostingFacade)
    {
        leanCostingFacade = _leanCostingFacade;
        return leanCostingFacade;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOverrideGroupWarnings</Name>
				<Source><![CDATA[
    // Override BOMCalcGroup warnings
    NoYes parmOverrideGroupWarnings(NoYes _overrideGroupWarnings = overrideGroupWarnings)
    {
        overrideGroupWarnings = _overrideGroupWarnings;
        return overrideGroupWarnings;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPdsComdPricingRun</Name>
				<Source><![CDATA[
    public PdsComdPricingRun parmPdsComdPricingRun(
        PdsComdPricingRun _pdsComdPricingRun = pdsComdPricingRun)
    {
        pdsComdPricingRun = _pdsComdPricingRun;
        return pdsComdPricingRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPmfBOMVersion</Name>
				<Source><![CDATA[
    public BOMVersion parmPmfBOMVersion(BOMVersion _bomVersion = pmfBOMVersion)
    {
        pmfBOMVersion = _bomVersion;
        return pmfBOMVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPmfCoByProductType</Name>
				<Source><![CDATA[
    public PmfProductType parmPmfCoByProductType(PmfProductType _pmfCoByProductType = pmfCoByProductType)
    {
        pmfCoByProductType = _pmfCoByProductType;

        return pmfCoByProductType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPmfCoProduct</Name>
				<Source><![CDATA[
    public ItemId parmPmfCoProduct(ItemId _pmfCoProductItemId = pmfCoProductItemId)
    {
        pmfCoProductItemId = _pmfCoProductItemId;
        return pmfCoProductItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPmfCoProductInventDimId</Name>
				<Source><![CDATA[
    public InventDimId parmPmfCoProductInventDimId(InventDimId _pmfCoProductInventDimId = pmfCoProductInventDimId)
    {
        pmfCoProductInventDimId = _pmfCoProductInventDimId;

        return pmfCoProductInventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPmfCostAllocationPct</Name>
				<Source><![CDATA[
    public PmfCostAllocationPct parmPmfCostAllocationPct(
        PmfCostAllocationPct    _pmfCostAllocationPct = pmfCostAllocationPct)
    {
        pmfCostAllocationPct = _pmfCostAllocationPct;
        return pmfCostAllocationPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPmfFormulaSeries</Name>
				<Source><![CDATA[
    public Qty parmPmfFormulaSeries(Qty _pmfFormulaSeries = pmfFormulaSeries)
    {
        pmfFormulaSeries = _pmfFormulaSeries;
        return pmfFormulaSeries;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPmfParentCalcId</Name>
				<Source><![CDATA[
    public PmfPriceCalcId parmPmfParentCalcId(
        PmfPriceCalcId _pmfParentCalcId = pmfParentCalcId)
    {
        pmfParentCalcId = _pmfParentCalcId;
        return pmfParentCalcId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPmfYieldPct</Name>
				<Source><![CDATA[
    public PmfYieldPct parmPmfYieldPct(PmfYieldPct _pmfYieldPct = pmfYieldPct)
    {
        pmfYieldPct = _pmfYieldPct;
        return pmfYieldPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProductionFlowReferenceRecId</Name>
				<Source><![CDATA[
    public RefRecId parmProductionFlowReferenceRecId(RefRecId _productionFlowReferenceRecId = productionFlowReferenceRecId)
    {
        productionFlowReferenceRecId = _productionFlowReferenceRecId;

        return productionFlowReferenceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProfitSet</Name>
				<Source><![CDATA[
    CostProfitSet parmProfitSet(CostProfitSet newProfitSet = profitSet)
    {
        profitSet = newProfitSet;
        return profitSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchPriceModel</Name>
				<Source><![CDATA[
    PurchPriceModel parmPurchPriceModel(PurchPriceModel _purchPriceModel = purchPriceModel)
    {
        purchPriceModel = _purchPriceModel;
        return purchPriceModel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRouteId</Name>
				<Source><![CDATA[
    RouteId parmRouteId(RouteId _routeId = routeId)
    {
        routeId = _routeId;
        return routeId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesPriceInclInUnitPrice</Name>
				<Source><![CDATA[
    // Include charges in sales price
    NoYes parmSalesPriceInclInUnitPrice(NoYes _salesPriceInclInUnitPrice = salesPriceInclInUnitPrice)
    {
        salesPriceInclInUnitPrice = _salesPriceInclInUnitPrice;
        return salesPriceInclInUnitPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesPriceRoundOff</Name>
				<Source><![CDATA[
    // Round off the sales price
    NoYes parmSalesPriceRoundOff(NoYes _salesPriceRoundOff = salesPriceRoundOff)
    {
        salesPriceRoundOff = _salesPriceRoundOff;
        return salesPriceRoundOff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesPriceTransfer</Name>
				<Source><![CDATA[
    // Transfer sales price and charges
    NoYes parmSalesPriceTransfer(NoYes _salesPriceTransfer = salesPriceTransfer)
    {
        salesPriceTransfer = _salesPriceTransfer;
        return salesPriceTransfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesQty</Name>
				<Source><![CDATA[
    Qty parmSalesQty(Qty _salesQty = 0)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesUnit</Name>
				<Source><![CDATA[
    public SalesUnit parmSalesUnit(SalesUnit _salesUnit = '')
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSiteId</Name>
				<Source><![CDATA[
    public InventSiteId parmSiteId(InventSiteId _siteId = siteId)
    {
        siteId = _siteId;

        return siteId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowItemPriceCalcFormAfterRun</Name>
				<Source><![CDATA[
    public boolean parmShowItemPriceCalcFormAfterRun(boolean _showItemPriceCalcFormAfterRun = showItemPriceCalcFormAfterRun)
    {
        showItemPriceCalcFormAfterRun = _showItemPriceCalcFormAfterRun;
        return showItemPriceCalcFormAfterRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVersionId</Name>
				<Source><![CDATA[
    CostingVersionIdOpen parmVersionId(CostingVersionIdOpen _versionId = versionId)
    {
        versionId = _versionId;
        return versionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceCalcId</Name>
				<Source><![CDATA[
    public PriceCalcId priceCalcId()
    {
        return priceCalcId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    void run()
    {
        this.runBOMCalculation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>runBOMCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the BOM calculation for this class.
    /// </summary>
    protected void runBOMCalculation()
    {
        #OCCRetryCount

        setPrefix(BOMCalcJob::description());

        if (this.skipItem())
        {
            return;
        }

        try
        {
            ttsbegin;

            bomCalcItem = this.constructBOMCalcItem();

            if (bomCalcItem != null)
            {
                if (overrideGroupWarnings)
                {
                    bomCalcItem.parmOverrideGroupWarnings(overrideGroupWarnings);
                    bomCalcItem.parmCheckNoBOM(checkNoBOM);
                    bomCalcItem.parmCheckNoRoute(checkNoRoute);
                    bomCalcItem.parmCheckNoResource(checkNoResource);
                    bomCalcItem.parmCheckNoConsump(checkNoConsump);
                    bomCalcItem.parmCheckNoCostPrice(checkNoCostPrice);
                    bomCalcItem.parmCheckAgeCostPrice(checkAgeCostPrice);
                    bomCalcItem.parmCheckMinContribution(checkMinContribution);
                }

                bomCalcItem.parmExceptionType(this.parmExceptionType());
                bomCalcItem.parmCheckMissingUpdates(checkMissingUpdates);
                bomCalcItem.parmCheckUseFallBack(checkUseFallBack);

                // cache BOMDependencyManager instance for eventual circularity checks
                bomCalcItem.parmBOMDependencyManager(BOMDependencyManager::construct());

                if (pdsComdPricingRun)
                {
                    bomCalcItem.parmPdsComdPricingRun(pdsComdPricingRun);
                }

                // This will call calculation and infolog on the bomCalcItem object
                this.calcBOMCalcItem();

                // transfer calculation data to inventItemPrice
                if (bomCalcItem.parmBOMCalcTable() &&
                    bomCalcItem.parmCreatePendingPriceRecord())
                {
                    this.updateItemPriceFromBomCalcData(bomCalcItem);
                }

                this.updateParameters();

                if (#PmfEnabled && this.parmPmfCoProduct() == '')
                {
                    this.createCoProductCalcs();
                }
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::Error)
        {
            if (this.calculateAll())
            {
                throw error(strFmt("@SYS24365", itemId), '', InventTable::infoActionItemId(itemId));
            }
            else
            {
                throw error("@SYS21990");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateItemPriceFromBomCalcData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates item price information after BOM calculation.
    /// </summary>
    /// <param name = "_bomCalcItem"><c>BOMCalcItem</c> instance containing BOM calculation details.</param>
    protected void updateItemPriceFromBomCalcData(BOMCalcItem _bomCalcItem)
    {
        BOMCalcUpdateItem bomCalcUpdateItem = this.initBomCalcUpdateItem(_bomCalcItem);
        bomCalcUpdateItem.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBomCalcUpdateItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the engine that updates item price information after BOM calculation.
    /// </summary>
    /// <param name = "_bomCalcItem"><c>BOMCalcItem</c> instance containing BOM calculation details.</param>
    /// <returns>A new instance of <c>BOMCalcUpdateItem</c> class.</returns>
    protected BOMCalcUpdateItem initBomCalcUpdateItem(BOMCalcItem _bomCalcItem)
    {
        BOMCalcUpdateItem bomCalcUpdateItem = BOMCalcUpdateItem::construct();
        bomCalcUpdateItem.initFromBuffer(_bomCalcItem.parmBOMCalcTable());

        bomCalcUpdateItem.initParameters(costPriceTransfer,
                                        costPriceInclInUnitPrice,
                                        costPriceRoundOff,
                                        salesPriceTransfer,
                                        salesPriceInclInUnitPrice,
                                        salesPriceRoundOff,
                                        versionId,
                                        calcDate,
                                        calcCostingVersionUpdate,
                                        siteId);

        return bomCalcUpdateItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runCalculationForRecycledBPsMissingCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs calculation for recycled byproducts that have been not calculated yet.
    /// </summary>
    private void runCalculationForRecycledBPsMissingCost()
    {
        PmfRecycledBpBomCalcCreator            bomCalcCreator   = PmfRecycledBpBomCalcCreator::construct();
        PmfRecycledBpMissingCostCalc_Bom       missingCostCalc  = PmfRecycledBpMissingCostCalc_Bom::construct();

        bomCalcCreator.parmParentBomCalc(bomCalcItem);
        missingCostCalc.parmBomCalcCreator(bomCalcCreator);

        missingCostCalc.runCalculationsForBpMissingCost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the batch task is run on the server or on a client.
    /// </summary>
    /// <returns>
    ///    true if the task is run on the server; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Your classes that extend <c>RunBaseBatch</c> must override the <c>runsImpersonated</c> method and
    ///    return false, if you want those tasks to run on a client.
    /// </remarks>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openItemPriceCalcForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the item price form for the specified item.
    /// </summary>
    /// <param name = "_caller">The instance of the object that created the <c>BomCalcJob</c></param>
    protected void openItemPriceCalcForm(Object _caller)
    {
        if (this.parmShowItemPriceCalcFormAfterRun())
        {
            Args argsItemPriceCalcForm = new Args();
            argsItemPriceCalcForm.caller(_caller);
            argsItemPriceCalcForm.record(InventTable::find(this.parmItemId()));

            FormRun formRunItemPriceCalcForm = new MenuFunction(menuitemDisplayStr(InventItemPrice), MenuItemType::Display).create(argsItemPriceCalcForm);
            formRunItemPriceCalcForm.run();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>seriesSize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the default calculation job size.
    /// </summary>
    /// <returns>
    /// The default calculation job size.
    /// </returns>
    /// <remarks>
    /// The default size is calculated as the max between the standard and the minimum order quantity, or, in
    /// case of a formula item, the formula default quantity.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// Throws exception if the item Id has not been initialized.
    /// </exception>
    public Qty seriesSize()
    {
        Qty seriesSize;

        if (itemId == '')
        {
            throw error("@SYS25157");
        }

        if (pmfBOMVersion)
        {
            seriesSize = pmfBOMVersion.getFormulaDefaultQty(itemId, inventDimId);
        }
        else
        {
            seriesSize = InventTable::find(itemId).inventStandardQty(inventDimId);
        }

        return seriesSize;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCalculationTypeDefaults</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the default values for calculation type parameters
    /// </summary>
    /// <param name="_costingVersion">
    /// The costing version that will be used by the calculation
    /// </param>
    protected void setCalculationTypeDefaults(CostingVersion _costingVersion)
    {
        if (_costingVersion.CostingType == CostingVersionCostingType::Standard ||
            _costingVersion.CostingType == CostingVersionCostingType::Conversion)
        {
            this.parmCostPriceModel(BOMCostPriceModel::ItemCostPrice);
            this.parmPurchPriceModel(PurchPriceModel::PurchPrice);
            this.parmBOMCalcExplosionMode(BOMCalcExplosionMode::SingleLevel);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showItem</Name>
				<Source><![CDATA[
    boolean showItem()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showSales</Name>
				<Source><![CDATA[
    boolean showSales()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showWhereUsedUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Defines whether BOM calculation dialog box should have a Where used update combo box.
    /// </summary>
    /// <returns>
    ///    true if the combo box should be displayed; otherwise, false.
    /// </returns>
    public boolean showWhereUsedUpdate()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipItem</Name>
				<Source><![CDATA[
    protected boolean skipItem()
    {
        boolean ret;

        if (calcCostingVersionUpdate == BOMCalcCostingVersionUpdate::MissingOnly)
        {
            ret = true;

            if (costPriceTransfer)
            {
                ret = InventItemPriceSim::find(itemId, versionId, calcDate, CostingVersionPriceType::Cost, inventDimId, siteId).RecId;
            }

            if (salesPriceTransfer && ret)
            {
                ret = InventItemPriceSim::find(itemId, versionId, calcDate, CostingVersionPriceType::Sales, inventDimId, siteId).RecId;
            }

            if (ret)
            {
                info(strFmt("@SYS106132", InventTable::showItemSiteAndProductDim(itemId, InventDim::find(inventDimId), siteId)));
            }
        }
        else
        {
            ret  = false;
        }

        if (!ret && itemId && #PmfEnabled && InventTable::find(itemId).PmfProductType == PmfProductType::Co_Product)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Integer  version    = conPeek(packedClass,1);

        switch (version)
        {
            case #CurrentVersion:
                [version,#CurrentList] = packedClass;

                container packedExtension = SysPackExtensions::findExtension(packedClass, classStr(BomCalcJob));
                if(packedExtension != conNull())
                {
                    [useCostCalculationLevel] = packedExtension;
                }
                return true;
            default:
                return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateParameters</Name>
				<Source><![CDATA[
    protected void updateParameters()
    {
        if (!bomCalcItem)
        {
            return;
        }

        priceCalcId = bomCalcItem.parmPriceCalcId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuantitiesForFormula</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>BOMCalcJob</c> with corresponding quantities in case of a formula item.
    /// </summary>
    /// <param name="_bomVersionItem">
    /// The <c>BOMVersion</c> record for the formula.
    /// </param>
    private void updateQuantitiesForFormula(BOMVersion _bomVersionItem)
    {
        if (#PmfEnabled
            && !pmfBOMVersion
            && _bomVersionItem
            && _bomVersionItem.PmfTypeId == PmfBOMFormula::Formula)
        {
            this.parmPmfBOMVersion(_bomVersionItem);
            this.parmItemQty(max(this.parmItemQty(), this.seriesSize()));
            this.parmCWQty(PdsCatchWeight::cwQty(this.parmItemId(), this.parmItemQty()));

            this.parmPmfYieldPct(_bomVersionItem.PmfYieldPct);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    boolean validate(Object calledFrom = null)
    {
        boolean ok = true;
        return  ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static BOMCalcJob construct(Args args)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static ClassDescription description()
    {
        return "@SYS343262";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
    {
        if (!args)
        {
            throw error(strFmt("@SYS23686",formStr(BOMCalcTable)));
        }

        BOMCalcJob bomCalc = BOMCalcJob::newBomCalcJobFromArgs(args);

        if (bomCalc.prompt())
        {
            using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContext(args))
            {
                bomCalc.parmUseCostCalculationLevel(true);
                bomCalc.runOperation();
            }

            bomCalc.openItemPriceCalcForm(args.caller());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newAll</Name>
				<Source><![CDATA[
    static BOMCalcJob newAll(CostingVersion _costingVersion)
    {
        BOMCalcJob_All  bomCalc = BOMCalcJob_All::construct();

        bomCalc.getLast();
        bomCalc.parmVersionId(_costingVersion.VersionId);
        bomCalc.parmSiteId(_costingVersion.InventSiteId);
        bomCalc.parmInventDimId(bomCalc.inventDimIdSite());
        bomCalc.parmUseCostCalculationLevel(true);

        bomCalc.allowConversionCostingVersion(_costingVersion);

        bomCalc.setCalculationTypeDefaults(_costingVersion);

        return bomCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newBomCalcJobFromArgs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>BOMCalcJob</c> of the desired type, based on the arguments passed.
    /// </summary>
    /// <param name = "args"></param>
    /// <returns>A <c>BOMCalcJob</c></returns>
    static BOMCalcJob newBomCalcJobFromArgs(Args args)
    {
        BOMCalcJob          bomCalc;
        BOMCalcIRunnable    calcFormRun;
        BOMDesignerBOMCalc  bomDesignerBOMCalc;

        if (args.dataset() == tableNum(BOMVersion) && args.record())
        {
            bomCalc =  BOMCalcJob::newBOMVersion(args.record());
        }
        else
        {
            calcFormRun = args.caller();

            if (calcFormRun.salesLine())
            {
                bomCalc = BOMCalcJob::newSales(calcFormRun.parentItemId(),
                                           calcFormRun.parentInventDimId(),
                                           calcFormRun.parentBOMId(),
                                           calcFormRun.parentRouteId(),
                                           calcFormRun.salesLine().RecId);
            }
            else if (calcFormRun.salesQuotationLine())
            {
                bomCalc = BOMCalcJob::newQuotation(calcFormRun.parentItemId(),
                                           calcFormRun.parentInventDimId(),
                                           calcFormRun.parentBOMId(),
                                           calcFormRun.parentRouteId(),
                                           calcFormRun.salesQuotationLine().RecId);
            }
            else if (calcFormRun.serviceOrderLine())
            {
                bomCalc = BOMCalcJob::newServiceOrder(calcFormRun.parentItemId(),
                                                   calcFormRun.parentInventDimId(),
                                                   calcFormRun.serviceOrderLine().RecId);
            }
            else
            {
                if (calcFormRun.bomDesignerBOMCalc())
                {
                    bomDesignerBOMCalc = calcFormRun.bomDesignerBOMCalc();
                    bomCalc =  BOMCalcJob::newBOMDesigner(bomDesignerBOMCalc.parmItemId(),
                                                      bomDesignerBOMCalc.parmInventDimId(),
                                                      bomDesignerBOMCalc.parmBOMId(),
                                                      bomDesignerBOMCalc.parmRouteId(),
                                                      bomDesignerBOMCalc.parmCalcDate(),
                                                      bomDesignerBOMCalc.parmCalcQty(),
                                                      bomDesignerBOMCalc.parmBOMRouteVersionSelect());
                }
                else if (calcFormRun.parentItemId())
                {
                    bomCalc =  BOMCalcJob::newItem(calcFormRun.parentItemId(),
                                               calcFormRun.parentInventDimId(),
                                               calcFormRun.costingVersion());
                }
                else
                {
                    bomCalc = BOMCalcJob::newAll(calcFormRun.costingVersion());
                }
            }
        }
        return bomCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newBOMDesigner</Name>
				<Source><![CDATA[
    static BOMCalcJob newBOMDesigner(ItemId                  _itemId,
                                            InventDimId             _inventDimId,
                                            BOMId                   _bomId,
                                            RouteId                 _routeId,
                                            TransDate               _calcDate,
                                            InventQty               _calcQty,
                                            BOMRouteVersionSelect   _selectMode
                                           )
    {
        BOMCalcJob_Item bomCalc = BOMCalcJob_Item_BOMDesigner::construct();

        bomCalc.getLast();
        bomCalc.parmItemId(_itemId);
        bomCalc.parmInventDimId(_inventDimId);
        bomCalc.parmBOMId(_bomId);
        bomCalc.parmRouteId(_routeId);
        bomCalc.parmCalcDate(_calcDate);
        bomCalc.parmItemQty(_calcQty);
        bomCalc.parmBOMRouteVersionSelect(_selectMode);

        return bomCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newBOMVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a new instance of the <c>BOMCalcJob</c> class based on a BOM version.
    /// </summary>
    /// <param name="_bomVersion">The BOM version to create the calculation for.</param>
    /// <returns>A new calculation instance.</returns>
    static BOMCalcJob newBOMVersion(BOMVersion _bomVersion)
    {
        BOMCalcJob_Item bomCalc = BOMCalcJob_Item::construct();
        RouteId         routeId;
        InventDim       inventDimCalc = InventDim::find(_bomVersion.InventDimId);

        bomCalc.getLast();
        bomCalc.parmItemId(_bomVersion.ItemId);

        inventDimCalc = BOMCalcJob::updateWithDefaultInventSite(_bomVersion.ItemId, inventDimCalc);
        bomCalc.parmInventDimId(inventDimCalc.InventDimId);

        bomCalc.parmItemQty(_bomVersion.getFormulaDefaultQty(_bomVersion.ItemId, inventDimCalc.inventDimId));
        bomCalc.parmCWQty(_bomVersion.PdsCWSize);

        bomCalc.parmPmfBOMVersion(_bomVersion);
        bomCalc.parmBOMId(_bomVersion.bomId);
        bomCalc.parmPmfYieldPct(_bomVersion.PmfYieldPct);

        routeId = RouteVersion::findActive(_bomVersion.ItemId, bomCalc.parmCalcDate(), bomCalc.parmItemQty(), inventDimCalc).RouteId;
        bomCalc.parmRouteId(routeId);

        bomCalc.parmProductionFlowReferenceRecId(0);
        bomCalc.parmItemProcurementMode(ItemProcurementMode::ProductionOrder);

        bomCalc.parmShowItemPriceCalcFormAfterRun(true);

        return bomCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newItem</Name>
				<Source><![CDATA[
    static BOMCalcJob newItem(
        ItemId          _itemId,
        InventDimId     _inventDimId,
        CostingVersion  _costingVersion
        )
    {
        BOMCalcJob_Item bomCalc = BOMCalcJob_Item::construct();
        BOMId           bomId;
        RouteId         routeId;
        InventDim       inventDimCalc = InventDim::find(_inventDimId);

        bomCalc.getLast();
        bomCalc.parmItemId(_itemId);
        bomCalc.parmInventDimId(_inventDimId);
        bomCalc.parmItemQty(InventTable::find(_itemId).inventStandardQty(_inventDimId));
        bomCalc.parmCWQty(PdsCatchWeight::cwQty(_itemId, bomCalc.parmItemQty()));

        bomId   = BOMVersion::findActive(_itemId, bomCalc.parmCalcDate(), bomCalc.parmItemQty(), inventDimCalc).bomId;
        routeId = RouteVersion::findActive(_itemId, bomCalc.parmCalcDate(), bomCalc.parmItemQty(), inventDimCalc).RouteId;

        bomCalc.parmBOMId(bomId);
        bomCalc.parmRouteId(routeId);
        bomCalc.parmProductionFlowReferenceRecId(0);

        bomCalc.parmItemProcurementMode(ItemProcurementMode::ProductionOrder);

        bomCalc.parmVersionId(_costingVersion.VersionId);
        bomCalc.allowConversionCostingVersion(_costingVersion);

        bomCalc.setCalculationTypeDefaults(_costingVersion);

        return bomCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newQuotation</Name>
				<Source><![CDATA[
    static BOMCalcJob newQuotation(ItemId          _itemId,
                                   InventDimId     _inventDimId,
                                   BOMId           _bomId,
                                   RouteId         _routeId,
                                   RecId           _salesQuotationLineRecId)
    {
        BOMCalcJob_Item_Sales   bomCalc = BOMCalcJob_Item_Sales::construct();

        bomCalc.getLast();
        bomCalc.parmItemId(_itemId);
        bomCalc.parmInventDimId(_inventDimId);
        bomCalc.parmBOMId(_bomId);
        bomCalc.parmRouteId(_routeId);
        bomCalc.parmQuotationLine(SalesQuotationLine::findRecId(_salesQuotationLineRecId));

        return bomCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newSales</Name>
				<Source><![CDATA[
    static BOMCalcJob newSales(
        ItemId          _itemId,
        InventDimId     _inventDimId,
        BOMId           _bomId,
        RouteId         _routeId,
        RecId           _salesLineRecId)
    {
        BOMCalcJob_Item_Sales   bomCalc = BOMCalcJob_Item_Sales::construct();

        bomCalc.getLast();
        bomCalc.parmItemId(_itemId);
        bomCalc.parmInventDimId(_inventDimId);
        bomCalc.parmBOMId(_bomId);
        bomCalc.parmRouteId(_routeId);
        bomCalc.parmSalesLine(SalesLine::findRecId(_salesLineRecId));

        return bomCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newServiceOrder</Name>
				<Source><![CDATA[
    static BOMCalcJob newServiceOrder(
        ItemId              _itemId,
        InventDimId         _inventDimId,
        RecId               _serviceOrderLineLineRecId
        )
    {
        BOMCalcJob_Item_Sales   bomCalc = BOMCalcJob_Item_Sales::construct();
        BOMId                   bomId;
        RouteId                 routeId;
        SMAServiceOrderLine     smaServiceOrderLine = SMAServiceOrderLine::findRecId(_serviceOrderLineLineRecId);
        InventDim               inventDimCalc = InventDim::find(_inventDimId);

        bomCalc.getLast();
        bomCalc.parmItemId(_itemId);
        bomCalc.parmInventDimId(_inventDimId);
        bomCalc.parmSalesQty(smaServiceOrderLine.Qty);

        bomId   = BOMVersion::findActive(_itemId, bomCalc.parmCalcDate(), bomCalc.parmItemQty(), inventDimCalc).bomId;
        routeId = RouteVersion::findActive(_itemId, bomCalc.parmCalcDate(), bomCalc.parmItemQty(), inventDimCalc).RouteId;
        bomCalc.parmBOMId(bomId);
        bomCalc.parmRouteId(routeId);

        return bomCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWithDefaultInventSite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the specified inventory dimensions with a default site id if needed.
    /// </summary>
    /// <param name="_itemId">
    /// The id of the item.
    /// </param>
    /// <param name="_inventDim">
    /// The current inventory dimensions to be updated if needed.
    /// </param>
    /// <returns>
    /// The <c>InventDim</c> object updated with the default site id if the original site id was empty.
    /// </returns>
    private static InventDim updateWithDefaultInventSite(ItemId _itemId, InventDim _inventDim)
    {
        InventTable     inventTable;
        InventSiteId    inventSiteId;

        if (!_inventDim.InventSiteId)
        {
            inventTable = InventTable::find(_itemId);

            if (inventTable)
            {
                inventSiteId = inventTable.inventInventSiteId('', _inventDim.inventDimId);

                if (inventSiteId)
                {
                    _inventDim.InventSiteId  = inventSiteId;
                    _inventDim               = InventDim::findOrCreate(_inventDim);
                }
            }
        }

        return _inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBOMVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method finds BOM version.
    /// </summary>
    /// <returns>
    /// <c>BOMVersion</c> record.
    /// </returns>
	protected BOMVersion findBOMVersion()
    {
        BOMVersion bomVersionItem;

        if (pmfBOMVersion.RecId)
        {
            // Use the BOMVersion that was supplied as general parameter
            bomVersionItem = pmfBOMVersion;
        }
        else if (bomId && #PmfEnabled && BOM::isPmfFormula(bomId))
        {
            bomVersionItem = this.findFormulaBomVersion();
        }
        else
        {
            // Find the active BOMVersion for the item
            bomVersionItem = BOMVersion::findActive(
                this.parmItemId(),
                this.parmCalcDate(),
                (this.parmItemQty() ? this.parmItemQty() : this.seriesSize()),
                InventDim::find(this.parmInventDimId()));
        }

        return bomVersionItem;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>