<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesTableInteractionHelper</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>SalesTableInteractionHelper</c> class is the interaction class helper for the sales table
/// details form.
/// </summary>
/// <remarks>
/// This class determines the visibility state of the controls.
/// </remarks>
class SalesTableInteractionHelper
{
    SalesTable      salesTable;
    SalesLine       salesLine;
    SalesTableType  salesTableType;
    SalesTableForm  salesTableForm;

    boolean                     isCommonInitialized;

    // Common
    boolean                     isReturnItem;

    // Header
    boolean                     fetchedPurchTableReference;
    PurchTable                  purchTableReference;

    InventTransIdSum            inventTransIdSum;

    UnknownNoYes                intercompanyOrgExist;
    UnknownNoYes                markupAllowed;
    UnknownNoYes                matchingAgreement;
    UnknownNoYes                paymentScheduleEnabled;
    UnknownNoYes                regularOrder;
    UnknownNoYes                salesTableCanCreatePurchOrder;
    UnknownNoYes                canCreatePurchOrder;
    UnknownNoYes                canCreateDropShipment;
    UnknownNoYes                buttonCalculateConfirmDates;
    UnknownNoYes                canCreditNoteBeCreated;
    UnknownNoYes                interCompanyPurchaseOrderInvoiceMatched;
    UnknownNoYes                existsQuotation;
    UnknownNoYes                existsConfirmation;
    UnknownNoYes                existsPickingList;
    UnknownNoYes                existsPackingSlip;
    UnknownNoYes                existsInvoice;
    UnknownNoYes                relatedPurchaseOrderEnabled;
    UnknownNoYes                interCompanyPurchId;
    UnknownNoYes                intercompanySalesId;
    UnknownNoYes                interCompanyOriginalSalesId;
    UnknownNoYes                enableICPickingListButton;
    UnknownNoYes                buttonBankLGRequestForm;
    UnknownNoYes                buttonCreateBankLCExport;
    UnknownNoYes                referencesEnabled;
    UnknownNoYes                existInterCompanyPurch;
    UnknownNoYes                contactPersonExists;
    UnknownNoYes                buttonTieredChargesEnabled;
    UnknownNoYes                buttonAutoChargesEnabled;
    UnknownNoYes                buttonAutoChargesVisible;
    UnknownNoYes                canReleaseToWarehouse;

    // <GEERU>
    UnknownNoYes                existsInvoice4Paym;
    UnknownNoYes                existsFacture;
    // </GEERU>

    // Lines
    boolean                     isStocked;
    boolean                     isCategoryBased;
    boolean                     hasMultipleDeliveries;
    boolean                     isTangible;
    boolean                     isRetailKit;

    // Cached - None of these values should be accessed directly
    InventItemType              inventItemType;
    boolean                     inventItemTypeCreated;
    boolean                     fetchedInventTable;
    InventTable                 inventTable;

    RetailMCRChannelTable       retailMCRChannelTable;
    boolean                     fetchedRetailMCRChannelTable;

    UnknownNoYes                shouldLineFunctionsBeEnabled;
    UnknownNoYes                lineTaxTransSourceEnabled;
    UnknownNoYes                lineMarkupAllowed;
    UnknownNoYes                buttonLineExpandBOMEnabled;
    UnknownNoYes                icpoLineInvoiceMatched;
    UnknownNoYes                deliveryScheduleEnabled;
    UnknownNoYes                salesLineDeliveryDetailsEnabled;
    UnknownNoYes                lineExists;
    UnknownNoYes                salesUpdateRemainEnabled;
    UnknownNoYes                salesDropShipmentCancelEnabled;
    UnknownNoYes                addressButtonsEnabled;
    UnknownNoYes                buttonProductionEnabled;
    UnknownNoYes                canBeProduced;
    UnknownNoYes                buttonExplosionEnabled;
    UnknownNoYes                stockedNotReturn;
    UnknownNoYes                canHaveBOM;
    UnknownNoYes                canHaveBOMNotReturn;
    UnknownNoYes                productBasedNotReturn;
    UnknownNoYes                relatedPOLineInvoiceMatched;
    UnknownNoYes                bomPriceCalcEnabled;
    UnknownNoYes                suppItemCalcEnabled;
    UnknownNoYes                suppItemCalcEnabledHeader;

    UnknownNoYes                interCompanyActionsEnabled;
    UnknownNoYes                interCompanyRemoveEnabled;

    UnknownNoYes                buttonLineInventTrans;
    UnknownNoYes                orderCanceled;
    UnknownNoYes                buttonLineInventOnHand;
    UnknownNoYes                buttonLineInventLot;
    UnknownNoYes                stockedNotCanceledNotMultipleDlv;
    UnknownNoYes                buttonLineInventReservation;
    UnknownNoYes                stockedNotReturnNotMultipleDlv;
    UnknownNoYes                inventTransRegisterEnabled;
    UnknownNoYes                inventTransPickEnabled;
    UnknownNoYes                wmsOrderAllowCreate;
    UnknownNoYes                buttonCustVendCreditInvoicingHeader;
    UnknownNoYes                buttonCustVendCreditInvoicingLines;
    UnknownNoYes                lineKitVariantComponentsEnabled;

    UnknownNoYes                canCreditCardPreAuthorizeEnabled;
    UnknownNoYes                creditCardWizardEnabled;

    UnknownNoYes                lineUpdateAllowed;
    UnknownNoYes                agreementRemoveLinkEnabled;
    UnknownNoYes                agreementLineEnabled;
    UnknownNoYes                agreementCreateLinkEnabled;

    UnknownNoYes                buttonConfigureLineEnabled;
    UnknownNoYes                buttonLineConfigurationEnabled;

    UnknownNoYes                buttonSalesLineReturnLineEnabled;
    // Header depending on line
    UnknownNoYes                canConfirmationBeUpdated;
    UnknownNoYes                canPickingListBeUpdated;
    UnknownNoYes                canPackingslipBeUpdated;
    UnknownNoYes                canInvoiceBeUpdated;
    UnknownNoYes                canPickingListBeRegistrated;
    UnknownNoYes                canProjectPackingSlipBeUpdated;

    // <GEERU>
    UnknownNoYes                canInvoice4PaymBeUpdated;
    UnknownNoYes                canFactureBeUpdated;
    UnknownNoYes                canCommFactureBeUpdated;    
    // </GEERU>

    // <GBR>
    UnknownNoYes                canDeliverySlipBeUpdated_BR;
    UnknownNoYes                canCreateInventTrans_BR;
    UnknownNoYes                canFiscalDocTextBeRegistrated_BR;
    UnknownNoYes                canLineFiscalDocTextBeRegistrated_BR;
    // </GBR>

    //Internal caches
    UnknownNoYes                deliveredInTotal;
    UnknownNoYes                interCompanyOrderLineInvoiceMatched;
    UnknownNoYes                orderAllowEdit;

    UnknownNoYes                isRetailOrder;
    UnknownNoYes                isRetailCashAndCarrySales;

    UnknownNoYes            buttonSalesCancelOrder;

    #localmacro.GetCached
        if (%1 == UnknownNoYes::Unknown)
        {
            %1 = (
                %2
                ) ? UnknownNoYes::Yes : UnknownNoYes::No;
        }
        return %1 == UnknownNoYes::Yes;
    #endmacro

    boolean                     isBulkOrPack;
    boolean                     isFormulaEnabled;
    boolean                     isRegulated;
    boolean                     isRestricted;
    boolean                     isItemBatchActivated;
    boolean                     isCWItem;
    // <GEERU>
    #isoCountryRegionCodes
    // </GEERU>

    // <GEEPL>
    UnknownNoYes existPlInventExternalForProcessing;
    // </GEEPL>

    #localmacro.GetCachedLineStrip
        if (salesLine)
        {
            #GetCached(%1, %2)
        }
        else
        {
            return false;
        }
      #endmacro

    UnknownNoYes            enableHeaderDiscountButtons;
    UnknownNoYes            buttonMultiLineDiscEnabled;
    UnknownNoYes            buttonEndDiscEnabled;

    boolean                 mcrAllowEdit;
    boolean                 mcrAllowDelete;
    boolean                 mcrSalesOrderModifyEnabled;
    boolean                 mcrEnableOrderCompletion;
    boolean                 mcrPriceOverridden;
    boolean                 mcrIsGiftCardItem;
    boolean                 mcrIsGiftCardTypePhysical;
    boolean                 mcrIsExternalGiftCardItem;

    UnknownNoYes            mcrHeaderAllowEdit;
    UnknownNoYes            mcrHeaderAllowDelete;
    UnknownNoYes            mcrCancelOrderEnabled;
    UnknownNoYes            mcrHeaderFunctionButtonsEnabled;
    UnknownNoYes            mcrOrderModifyEnabled;
    UnknownNoYes            mcrEditItemAllowed;
    UnknownNoYes            mcrLineStripDeleteEnabled;
    UnknownNoYes            mcrLineNotesLineEnalbed;
    UnknownNoYes            mcrAllowEditSalesUnit;
    UnknownNoYes            mcrAllowEditSalesQty;
    UnknownNoYes            mcrAllowEditSalesPrice;
    UnknownNoYes            mcrAllowEditSourceId;
    UnknownNoYes            mcrClearGiftCardNumber;
    UnknownNoYes            mcrUpdateGiftCardEnabled;
    UnknownNoYes            mcrGiftCardVirtualVisible;
    UnknownNoYes            mcrGiftCardPhysicalVisible;
    UnknownNoYes            mcrGiftCardNumberVisible;
    UnknownNoYes            mcrGiftCardNumberEnabled;
    UnknownNoYes            mcrGiftCardExpirationVisible;
    UnknownNoYes            mcrOrderCompletionEnabled;
    UnknownNoYes            mcrOrderPriceControlEnabled;
    UnknownNoYes            mcrOrderHoldsEnabled;
    UnknownNoYes            mcrCanCreditHeader;
    UnknownNoYes            mcrAllowPaymentAccess;
    // <GEERU>
    UnknownNoYes            mcrGiftCardAmountVisible;
    // </GEERU>
    UnknownNoYes            mcrGiftCardPoliciesVisible;

    UnknownNoYes            tmsInvoiceJournalButtonEnable;

    UnknownNoYes            whsLoadDetailsButtonEnable;
    UnknownNoYes            whsShipmentDetailsButtonEnable;

    UnknownNoYes            cfmPaymentRequestViewEnabled;
    #define.CurrentVersion(1)
    #LOCALMACRO.CurrentList
        contactPersonExists,
        interCompanyPurchId,
        existInterCompanyPurch,
        referencesEnabled,
        isRetailOrder,
        mcrOrderCompletionEnabled,
        mcrOrderPriceControlEnabled,
        tmsInvoiceJournalButtonEnable,
        whsLoadDetailsButtonEnable
    #ENDMACRO
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcEnableICPickingListButton</Name>
				<Source><![CDATA[
      /// <summary>
    /// Determines whether the intercompany picking list button should be enabled.
    /// </summary>
    /// <returns>
    /// true if the intercompany picking list button should be enabled; otherwise, false.
    /// </returns>
    protected boolean calcEnableICPickingListButton()
    {
        SalesTable intercompanySalesTable = this.purchTableReference().interCompanySalesTable();

        if (intercompanySalesTable)
        {
            changecompany(intercompanySalesTable.company())
            {
                return intercompanySalesTable.type().canPickingListBeUpdated();
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceAdjustAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an order line can adjust the item price.
    /// </summary>
    /// <returns>
    /// true if the item price can be adjusted; otherwise, false.
    /// </returns>
    protected boolean priceAdjustAllowed()
    {
        boolean ret;

        if (salesLine.ItemId == RetailParameters::find().GiftcardItem)
        {
            ret = true;
        }
        else
        {
            ret = this.parmMCROrderPriceControlEnabled() && (salesLine.mcrInventTable().AllowPriceAdjust == NoYes::Yes);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDeliveryAddressForSalesTableDlvMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the delivery address of the  sales order header based on the mode of delivery.
    /// </summary>
    /// <param name = "_dlvModeSalesTable">
    /// Sales order mode of delivery.
    /// </param>
    /// <param name = "_custAccount">
    /// Customer account number.
    /// </param>
    /// <param name = "_inventLocationId">
    /// Warehouse of the product dimension.
    /// </param>
    /// <returns>
    /// Returns the delivery address of the sales order header based on the mode of delivery.
    /// </returns>
    public LogisticsPostalAddressRecId findDeliveryAddressForSalesTableDlvMode(CustDlvModeId _dlvModeSalesTable, CustAccount _custAccount, InventLocationId _inventLocationId)
    {
        return this.findDeliveryAddressForDlvMode(_dlvModeSalesTable, _custAccount, _inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDeliveryAddressForSalesLineDlvMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the delivery address of the  sales order lines based on the mode of delivery.
    /// </summary>
    /// <param name = "_dlvModeSalesLine">
    /// Salesline mode of delivery.
    /// </param>
    /// <param name = "_custAccount">
    /// Customer account number.
    /// </param>
    /// <param name = "_inventLocationId">
    /// Warehouse of the product dimension.
    /// </param>
    /// <returns>
    /// Returns the delivery address of the sales order lines based on the mode of delivery.
    /// </returns>
    public LogisticsPostalAddressRecId findDeliveryAddressForSalesLineDlvMode(CustDlvModeId _dlvModeSalesLine, CustAccount _custAccount, InventLocationId _inventLocationId)
    {
        return this.findDeliveryAddressForDlvMode(_dlvModeSalesLine, _custAccount, _inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustomerPostalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if the given address is a postal address at the given customer.
    /// </summary>
    /// <param name = "_partyRecId">
    /// The customer party id.
    /// </param>
    /// <param name = "_prevDlvAddress">
    /// The postal address to be verified.
    /// </param>
    /// <returns>
    /// True if the address is a postal address for the customer; otherwise, false.
    /// </returns>
    public static NoYes  isCustomerPostalAddress(DirPartyRecId _partyRecId, LogisticsPostalAddressRecId _prevDlvAddress)
    {
        LogisticsPostalAddress  postalAddress;
        DirPartyLocation        partyLocation;

        select firstonly postalAddress
            where postalAddress.RecId == _prevDlvAddress
        exists join partyLocation
            where partyLocation.Location == postalAddress.Location
            && partyLocation.Party == _partyRecId;

        return postalAddress ? NoYes::Yes : NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustomerDeliveryAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the customer delivery address  based on the customer account number.
    /// </summary>
    /// <param name = "_custAccount">
    /// Customer account number.
    /// </param>
    /// <returns>
    /// Returns the customer delivery address.
    /// </returns>
    private LogisticsPostalAddressRecId findCustomerDeliveryAddress(CustAccount _custAccount)
    {
        CustTable custTable = CustTable::find(_custAccount);
        if (custTable)
        {
            LogisticsPostalAddressRecId deliveryPostalAddress = DirParty::primaryPostalAddress(custTable.Party).RecId;

            return deliveryPostalAddress;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOpenOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the sales order is an open order, and not a project related order.
    /// </summary>
    /// <returns>true if the sales order is an open order and not a project related order; otherwise, false.</returns>
    protected boolean isOpenOrder()
    {
        return (salesTable.SalesType == SalesType::Sales || salesTable.SalesType == SalesType::Journal)
             && salesLine.SalesStatus == SalesStatus::Backorder           // Open order status
             && salesLine.SalesQty >= 0                                  // No negative qty
             && !salesTable.ProjId;                                     // not part of a project
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventTransIdSumForSalesLine</Name>
				<Source><![CDATA[
    private InventTransIdSum getInventTransIdSumForSalesLine()
    {
        InventTransOriginId inventTransOriginId = InventTransOriginSalesLine::findInventTransOriginId(salesLine.DataAreaId, salesLine.InventTransId);

        if (!inventTransIdSum || inventTransIdSum.parmTransOriginId() != inventTransOriginId)
        {
            inventTransIdSum = InventTransIdSum::newTransOriginId(inventTransOriginId);
        }
        return inventTransIdSum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReservedOrderedOrPhysical</Name>
				<Source><![CDATA[
	/// <summary>
    /// Check if quantity is reserved against orders or physical stock.
    /// </summary>
    /// <returns>true if not reserved against orders and physical stock; otherwise, false.</returns>
    protected boolean isReservedOrderedOrPhysical()
    {
        InventTransIdSum localInventTransIdSum = this.getInventTransIdSumForSalesLine();
        return localInventTransIdSum.reserveOrdered()                    //  reserving against orders
            || localInventTransIdSum.reservPhysical();                  //  reserving physical stock
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPartiallyPickedPackedOrInvoiced</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if quantity is partially picked, packed Or invoiced.
    /// </summary>
    /// <returns>true if not partially picked, packed Or invoiced; otherwise, false.</returns>
    protected boolean isPartiallyPickedPackedOrInvoiced()
    {
        if (!this.skipTotalCalculation(salesTable))
        {
            return this.getInventTransIdSumForSalesLine().picked()		//  picked
            || this.parmDeliveredInTotal()								//  physically updated
            || salesLine.invoicedInTotalServer(salesTable)				//  financially updated
            || salesLine.qtyOnPickNotReserved();						//  referenced by any output order
        }
        
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryAlternativesAllowed</Name>
				<Source><![CDATA[
    protected boolean deliveryAlternativesAllowed()
    {
        // Check conditions(and call server method)
        // only when line is saved to reduce amount of RPC calls with SalesTable from execution!
        return salesLine.RecId
            && this.isOpenOrder()
            && (salesLine.InventRefType == InventRefType::None || salesLine.InventRefType == InventRefType::Purch)
            // Expensive calls last
            && !this.isPartiallyPickedPackedOrInvoiced();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryScheduleConversionAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an order line can be converted to a delivery schedule.
    /// </summary>
    /// <returns>
    /// true if the specified line can be converted; otherwise, false.
    /// </returns>
    protected boolean deliveryScheduleConversionAllowed()
    {
        // Check conditions(and call server method)
        // only when line is saved to reduce amount of RPC calls with SalesTable from execution!
        return salesLine.RecId
            && this.isOpenOrder()
            && salesLine.InventRefType == InventRefType::None           // no reference to other modules (e.g. production)
            && !salesLine.InterCompanyInventTransId                     // no intercompany derived order
            // Expensive calls last
            && !this.isReservedOrderedOrPhysical()
            && !this.isPartiallyPickedPackedOrInvoiced();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCommon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the common header and line level controls visibility state.
    /// </summary>
    protected void initCommon()
    {
        salesTableType = salesTable.type();
        salesTableType.parmAllowSalesLineCaching(true);
        isReturnItem = salesTableType.returnItem();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initHeaderActions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the sales header controls visibility states.
    /// </summary>
    /// <param name="_salesTable">
    /// The header record.
    /// </param>
    public void initHeaderActions(SalesTable _salesTable)
    {
        this.setSalesTable(_salesTable);
        this.initCommon();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLineActions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the visibility state of the sales line controls.
    /// </summary>
    /// <param name="_salesTable">
    /// A header record.
    /// </param>
    /// <param name="_salesLine">
    /// A line record.
    /// </param>
    public void initLineActions(SalesTable _salesTable, SalesLine _salesLine)
    {
        salesTable  = _salesTable;
        salesLine   = _salesLine;
        InventTable lineInventTable;
        
        if (salesLine.ItemId || salesLine.SalesCategory)
        {
            isStocked               = salesLine.isStocked();
            isCategoryBased         = salesLine.isCategoryBased();
            hasMultipleDeliveries   = salesLine.LineDeliveryType == LineDeliveryType::OrderLineWithMultipleDeliveries;
            isTangible              = salesLine.isTangible();
            lineInventTable         = salesLine.inventTable();
            isRetailKit             = RetailKit::existByProductMaster(lineInventTable.Product);
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(PDS)))
        {
            if (salesLine.ItemId)
            {
                isBulkOrPack = PmfBulkItemConv::isBulkorPack(salesLine.ItemId);
                isRegulated  = PdsMRCRegulatedCountry::isRegulated(salesLine.ItemId);
                isRestricted = PdsMRCRestrictedListByItem::isRestricted(salesLine.ItemId);
            }
            
            if (lineInventTable)
            {
                isFormulaEnabled     = lineInventTable.isFormulaAllowed();
                isItemBatchActivated = lineInventTable.isItemBatchActivated();
                isCWItem             = lineInventTable.pdsCWItem();
            }
        }
        else
        {
            isBulkOrPack            = false;
            isFormulaEnabled        = false;
            isRegulated             = false;
            isRestricted            = false;
            isItemBatchActivated    = false;
            isCWItem                = false;
        }

        this.initCommon();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventItemType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a cached instance of the <c>InventItemType</c> class for the line.
    /// </summary>
    /// <returns>
    /// A cached instance of the <c>InventItemType</c> class.
    /// </returns>
    protected InventItemType inventItemType()
    {
        if (!inventItemTypeCreated)
        {
            inventItemTypeCreated   = true;
            inventItemType          = salesLine.ItemId ? this.inventTable().inventItemType() : null;
        }
        return inventItemType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>InventTable</c> record for the line.
    /// </summary>
    /// <returns>
    /// The <c>InventTable</c> record for the line.
    /// </returns>
    protected InventTable inventTable()
    {
        if (!fetchedInventTable)
        {
            fetchedInventTable = true;
            inventTable = salesLine.inventTable();
        }
        return inventTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrInitGiftCardControls</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the visibility state of the gift card controls.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID of the sales line.
    /// </param>
    /// <param name="_giftCardType">
    /// The type of gift card if the item is of type gift.
    /// </param>
    public void mcrInitGiftCardControls(ItemId _itemId, MCRGiftCardType _giftCardType)
    {
        mcrIsGiftCardTypePhysical = false;
        mcrIsGiftCardItem = false;
        ItemId itemId = RetailParameters::find().GiftcardItem;
        if (itemId && _itemId == itemId)
        {
            mcrIsGiftCardItem = true;
            mcrIsGiftCardTypePhysical = (_giftCardType == MCRGiftCardType::Physical);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSetExternalGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the if sales line has extenral gift card.
    /// </summary>
    /// <param name = "_itemId">
    /// The item ID of the sales line.
    /// </param>
    /// <param name = "_giftCardType">
    /// The type of gift card.
    /// </param>
    /// <param name = "_channelRecId">
    /// The channel rec Id of salesTable.
    /// </param>
    [Hookable(false)]
    public void mcrSetExternalGiftCard(ItemId _itemId, MCRGiftCardType _giftCardType, RetailChannelRecId _channelRecId)
    {
        mcrIsExternalGiftCardItem = false;
        RetailStoreTenderTypeTable retailStoreTenderTypeTable;

        select retailStoreTenderTypeTable
            where retailStoreTenderTypeTable.Channel == _channelRecId
            && retailStoreTenderTypeTable.ConnectorName != ''
            && retailStoreTenderTypeTable.GiftCardItemId == _itemid;

        if (retailStoreTenderTypeTable)
        {
            mcrIsExternalGiftCardItem =  true;
            mcrIsGiftCardTypePhysical = (_giftCardType == MCRGiftCardType::Physical);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrInitHeaderControls</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the visibility state of the sales line controls.
    /// </summary>
    /// <param name="_salesTable">
    /// A header record.
    /// </param>
    /// <param name="_enableOrderCompletion">
    /// A boolean to indicate if order completion is enabled.
    /// </param>
    /// <param name="_returnProcessing">
    /// A boolean to indicate if return processing is being performed
    /// </param>
    /// <param name="_isExchange">
    /// A boolean to indicate if the order is an exchange order
    /// </param>
    public void mcrInitHeaderControls(SalesTable _salesTable,
        boolean   _enableOrderCompletion,
        boolean   _returnProcessing,
        boolean   _isExchange)
    {
        mcrEnableOrderCompletion    = _enableOrderCompletion;
        salesTable                  = _salesTable;

        mcrAllowEdit = true;
        mcrAllowDelete = true;
        mcrSalesOrderModifyEnabled = false;

        if (mcrEnableOrderCompletion
            && salesTable.mcrOrderStopped == NoYes::No)
        {
            mcrAllowEdit = false;
        }
        else if (_isExchange == NoYes::Yes)
        {
            if (salesTable.SalesStatus == SalesStatus::Backorder)
            {
                if (!_returnProcessing)
                {
                    mcrAllowEdit = false;
                }
            }
            else
            {
                mcrAllowDelete = false;
            }
        }

        if (!this.parmMCRCompleteButtonEnabled())
        {
            if (salesTable.mcrAllowStatusRollback())
            {
                MCRSalesTable mcrSalesTableLocal = salesTable.mcrSalesTable();

                //Enable based on the order not being cancelled, full delivered, or processing continuity child
                if ((salesTable.SalesStatus == SalesStatus::None
                    || salesTable.SalesStatus == SalesStatus::Backorder
                    || salesTable.SalesStatus == SalesStatus::Invoiced)
                    && !(mcrSalesTableLocal.ContinuityChild
                        && salesTable.mcrOrderStopped == NoYes::No
                        && salesTable.SalesStatus == SalesStatus::Backorder
                        && mcrSalesTableLocal.ContinuityLineEval == MCRContinuityLineEval::Paid))
                {
                    mcrSalesOrderModifyEnabled = true;
                }
            }
            else if (salesTable.SalesStatus == SalesStatus::Invoiced)
            {
                mcrAllowDelete = false;
            }
        }

        // Disable Edit/Delete/Modify for Retail Orders created for Default Retail Customer
        if (this.parmisRetailCashAndCarrySales())
        {
            mcrAllowEdit = false;
            mcrAllowDelete = false;
            mcrSalesOrderModifyEnabled = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrInitLineControls</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the visibility state of the sales line controls.
    /// </summary>
    /// <param name="_salesTable">
    /// A header record.
    /// </param>
    /// <param name="_salesLine">
    /// A line record.
    /// </param>
    /// <param name="_enableOrderCompletion">
    /// A boolean to indicate if order completion is enabled.
    /// </param>
    /// <param name="_enableDirectedSelling">
    /// A boolean to indicate if directed selling is enabled
    /// </param>
    /// <param name="_priceOverridden">
    /// A boolean to indicate if the line record has been price overridden.
    /// </param>
    public void mcrInitLineControls(SalesTable _salesTable,
        SalesLine _salesLine,
        boolean   _enableOrderCompletion,
        boolean   _enableDirectedSelling,
        boolean   _priceOverridden)
    {
        mcrEnableOrderCompletion    = _enableOrderCompletion;
        salesTable                  = _salesTable;
        salesLine                   = _salesLine;
        mcrPriceOverridden          = _priceOverridden;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAddressButtonsEnabled</Name>
				<Source><![CDATA[
    public boolean parmAddressButtonsEnabled()
    {
        #GetCached(addressButtonsEnabled, this.parmShouldLineFunctionsBeEnabled()
            && !this.parmICPOLineInvoiceMatched()
            && !salesLine.isDropShipmentPOLineInvoiceMatched())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAgreementCreateLinkEnabled</Name>
				<Source><![CDATA[
    public boolean parmAgreementCreateLinkEnabled()
    {
        #GetCached(agreementCreateLinkEnabled, salesTable.MatchingAgreement
            && this.parmLineUpdateAllowed()
            && salesLine.canAgreementBeLinked()
            && !salesTable.isCompletedCallCenterOrder())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAgreementLineEnabled</Name>
				<Source><![CDATA[
    public boolean parmAgreementLineEnabled()
    {
        #GetCached(agreementLineEnabled, salesLine.MatchingAgreementLine
            && salesLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAgreementRemoveLinkEnabled</Name>
				<Source><![CDATA[
    public boolean parmAgreementRemoveLinkEnabled()
    {
        #GetCached(agreementRemoveLinkEnabled, salesLine.MatchingAgreementLine
            && this.parmLineUpdateAllowed()
            && salesLine.LineDeliveryType != LineDeliveryType::DeliveryLine
            && !salesTable.isCompletedCallCenterOrder())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBomPriceCalcEnabled</Name>
				<Source><![CDATA[
    public boolean parmBomPriceCalcEnabled()
    {
        #GetCached(bomPriceCalcEnabled, this.parmCanHaveBOM()
            && !this.parmRelatedPOLineInvoiceMatched())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonBankLGRequestForm</Name>
				<Source><![CDATA[
    public boolean parmButtonBankLGRequestForm()
    {
        #GetCached(buttonBankLGRequestForm, BankLGFeatureChecker::construct().checkFeatureEnabled()
            && salesTable.isMarkedForBankLG())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonCalculateConfirmDates</Name>
				<Source><![CDATA[
    public boolean parmButtonCalculateConfirmDates()
    {
        #GetCached(buttonCalculateConfirmDates, this.parmRegularOrder()
            && salesTable.SalesStatus == SalesStatus::Backorder)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonConfigureLineEnabled</Name>
				<Source><![CDATA[
    public boolean parmButtonConfigureLineEnabled()
    {
        #GetCached(buttonConfigureLineEnabled, salesLine
                    && salesLine.ItemId
                    && !isReturnItem
                    && salesLine.LineDeliveryType == LineDeliveryType::OrderLine
                    && PCRuntimeLibrary::isConstraintBasedConfigurable(salesLine.ItemId)
                    && !this.parmIntercompanyOriginalSalesId()
                    && !this.parmIntercompanyPurchId()
                    && !this.parmIntercompanySalesId())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonCreateBankLCExport</Name>
				<Source><![CDATA[
    public boolean parmButtonCreateBankLCExport()
    {
        #GetCached(buttonCreateBankLCExport, BankLCExportFeatureChecker::construct().checkFeatureEnabled()
            && salesTable.isMarkedForBankLC())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonCustVendCreditInvoicingHeader</Name>
				<Source><![CDATA[
    public boolean parmButtonCustVendCreditInvoicingHeader()
    {
        if (buttonCustVendCreditInvoicingHeader == UnknownNoYes::Unknown)
        {
                boolean enabled = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]) // allow debit-notes for Italy
                        || (CustVendCreditInvoicingTable::useCreditInvoicingReporting()
                            && (salesTable.existNegativeAmountLine()
                                || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoID])
                                || FeatureStateProvider::isFeatureEnabled(CreditInvoicingAllowDebitNoteFeature::instance()))
                            && (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES, #isoSE, #isoPL])
                                || !salesTable.existCustVendCreditInvoicingTableRef()));
                
                buttonCustVendCreditInvoicingHeader = enabled ? UnknownNoYes::Yes : UnknownNoYes::No;
                
        }
            
        return buttonCustVendCreditInvoicingHeader == UnknownNoYes::Yes ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonCustVendCreditInvoicingLines</Name>
				<Source><![CDATA[
    public boolean parmButtonCustVendCreditInvoicingLines()
    {
        #ISOCountryRegionCodes

        #GetCached(buttonCustVendCreditInvoicingLines, SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES, #isoSE, #isoPL]))
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmbuttonEndDiscEnabled</Name>
				<Source><![CDATA[
    public boolean parmbuttonEndDiscEnabled()
    {
        #GetCached(buttonEndDiscEnabled, this.parmEnableHeaderDiscountButtons())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonExplosionEnabled</Name>
				<Source><![CDATA[
    public boolean parmButtonExplosionEnabled()
    {
        #GetCached(buttonExplosionEnabled, !isReturnItem
            && isStocked
            && salesTableType.canExplosionBeExecuted()
            && !hasMultipleDeliveries)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonLineExpandBOMEnabled</Name>
				<Source><![CDATA[
    public boolean parmButtonLineExpandBOMEnabled()
    {
        #GetCached(buttonLineExpandBOMEnabled, this.parmShouldLineFunctionsBeEnabled()
                && salesLine.RecId
                && salesLine.isStocked()
                && salesLine.LineDeliveryType == LineDeliveryType::OrderLine
                && !this.parmICPOLineInvoiceMatched()
                && !this.parmDeliveredInTotal())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonLineInventLot</Name>
				<Source><![CDATA[
    public boolean parmButtonLineInventLot()
    {
        #GetCached(buttonLineInventLot, this.parmStockedNotCanceledNotMultipleDlv()
            && salesTableType.inventLotInvoke())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonLineInventMarking</Name>
				<Source><![CDATA[
    public boolean parmButtonLineInventMarking()
    {
        return !isCWItem
            && this.parmStockedNotReturnNotMultipleDlv();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonLineInventOnHand</Name>
				<Source><![CDATA[
    public boolean parmButtonLineInventOnHand()
    {
        #GetCachedLineStrip(buttonLineInventOnHand, isStocked
            && salesLine.ReturnStatus != ReturnStatusLine::Canceled
            && salesTableType.inventOnHandInvoke())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonLineInventReservation</Name>
				<Source><![CDATA[
    public boolean parmButtonLineInventReservation()
    {
        #GetCached(buttonLineInventReservation, isStocked
            && !hasMultipleDeliveries
            && salesTableType.inventReservationInvoke())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonLineInventTrans</Name>
				<Source><![CDATA[
    public boolean parmButtonLineInventTrans()
    {
        #GetCached(buttonLineInventTrans, isStocked
            && salesLine.ReturnStatus != ReturnStatusLine::Canceled
            && !hasMultipleDeliveries
            && salesTableType.inventTransactInvoke())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmbuttonMultiLineDiscEnabled</Name>
				<Source><![CDATA[
    public boolean parmbuttonMultiLineDiscEnabled()
    {
        #GetCached(buttonMultiLineDiscEnabled, this.parmEnableHeaderDiscountButtons())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonProductionEnabled</Name>
				<Source><![CDATA[
    public boolean parmButtonProductionEnabled()
    {
        #GetCached(buttonProductionEnabled, !isReturnItem
        && isStocked
        && salesTableType.showProductionMenu()
        && this.parmCanBeProduced()
        && !hasMultipleDeliveries)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonSalesLineReturnLineEnabled</Name>
				<Source><![CDATA[
    public boolean parmButtonSalesLineReturnLineEnabled()
    {
        #GetCached(buttonSalesLineReturnLineEnabled, this.parmShouldLineFunctionsBeEnabled() && salesLine.istangible())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonTieredChargesEnabled</Name>
				<Source><![CDATA[
    public boolean parmButtonTieredChargesEnabled()
    {
        #GetCached(buttonTieredChargesEnabled, salesTable.markupAllowed())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonAutoChargesEnabled</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmButtonAutoChargesEnabled()
    {
        #GetCached(buttonAutoChargesEnabled, AutoChargesSetupSequenceCompoundFeature::instance().isEnabled() && salesTable.markupAllowed())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonAutoChargesVisible</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmButtonAutoChargesVisible()
    {
        #GetCached(buttonAutoChargesVisible, AutoChargesSetupSequenceCompoundFeature::instance().isEnabled())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanBeProduced</Name>
				<Source><![CDATA[
    public boolean parmCanBeProduced()
    {
        #GetCached(canBeProduced, this.inventItemType() ? this.inventItemType().canBeProduced() : false)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanCancel</Name>
				<Source><![CDATA[
    public boolean parmCanCancel()
    {
        #GetCached(buttonSalesCancelOrder, salesTable.SalesStatus == SalesStatus::Backorder && !salesTable.isRetailCashAndCarrySales() && !RetailCommercePaymentsFeatureHelper::commercePaymentsOrderWhenFeatureDisabled(salesTable))
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanCommFactureBeUpdated_RU</Name>
				<Source><![CDATA[
    public boolean parmCanCommFactureBeUpdated_RU()
    {
        #GetCached(canCommFactureBeUpdated, salesTableType.canCommFactureBeUpdated_RU())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanConfirmationBeUpdated</Name>
				<Source><![CDATA[
    public boolean parmCanConfirmationBeUpdated()
    {
        #GetCached(canConfirmationBeUpdated, salesTableType.canConfirmationBeUpdated())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanCreateDropShipment</Name>
				<Source><![CDATA[
    public boolean parmCanCreateDropShipment()
    {
        #GetCached(canCreateDropShipment, this.parmCanCreatePurchOrder()
            && salesTableType.canCreateDropShipment())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanCreateInventTrans_BR</Name>
				<Source><![CDATA[
    public boolean parmCanCreateInventTrans_BR()
    {
        #GetCached(canCreateInventTrans_BR, salesTable.createInventTrans_BR())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanCreatePurchOrder</Name>
				<Source><![CDATA[
    public boolean parmCanCreatePurchOrder()
    {
        #GetCached(canCreatePurchOrder, (salesTable.SalesStatus == SalesStatus::None || salesTable.SalesStatus == SalesStatus::Backorder)
            && salesTable.MCROrderStopped == NoYes::No
            && this.parmSalesTableCanCreatePurchOrder())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanCreditCardPreAuthorizeEnabled</Name>
				<Source><![CDATA[
    public boolean parmCanCreditCardPreAuthorizeEnabled()
    {
        #GetCached(canCreditCardPreAuthorizeEnabled, salesTable.CreditCardCustRefId != 0
            && !(salesLine.creditNoteLine() || salesLine.returnItem())
            && salesTable.checkCreditCard()
            && CustParameters::find().CreditCardPreAuthorization)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanCreditNoteBeCreated</Name>
				<Source><![CDATA[
    public boolean parmCanCreditNoteBeCreated()
    {
        #GetCached(canCreditNoteBeCreated, salesTableType.canCreditNoteBeCreated())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanDeliverySlipBeUpdated_BR</Name>
				<Source><![CDATA[
    public boolean parmCanDeliverySlipBeUpdated_BR()
    {
        #GetCached(canDeliverySlipBeUpdated_BR, salesTableType.canDeliverySlipBeUpdated_BR())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanFactureBeUpdated_RU</Name>
				<Source><![CDATA[
    public boolean parmCanFactureBeUpdated_RU()
    {
        #GetCached(canFactureBeUpdated, salesTableType.canFactureBeUpdated_RU())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanFiscalDocTextBeRegistrated_BR</Name>
				<Source><![CDATA[
    public boolean parmCanFiscalDocTextBeRegistrated_BR()
    {
        #GetCached(canFiscalDocTextBeRegistrated_BR, salesTableType.canFiscalDocTextBeRegistrated_BR())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanHaveBOM</Name>
				<Source><![CDATA[
    public boolean parmCanHaveBOM()
    {
        #GetCached(canHaveBOM, (salesLine.inventTable().isFormulaOrBOMAllowed()))
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanHaveBOMNotReturn</Name>
				<Source><![CDATA[
    public boolean parmCanHaveBOMNotReturn()
    {
        #GetCached(canHaveBOMNotReturn, !isReturnItem && isStocked && this.parmCanHaveBOM())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanInvoice4PaymBeUpdated_RU</Name>
				<Source><![CDATA[
    public boolean parmCanInvoice4PaymBeUpdated_RU()
    {
        #GetCached(canInvoice4PaymBeUpdated, salesTableType.canInvoice4PaymBeUpdated_RU())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanInvoiceBeUpdated</Name>
				<Source><![CDATA[
    public boolean parmCanInvoiceBeUpdated()
    {
        #GetCached(canInvoiceBeUpdated, salesTableType.canInvoiceBeUpdated())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanLineFiscalDocTextBeRegistrated_BR</Name>
				<Source><![CDATA[
    public boolean parmCanLineFiscalDocTextBeRegistrated_BR()
    {
        #GetCached(canLineFiscalDocTextBeRegistrated_BR, salesLine.type().canFiscalDocTextBeRegistrated_BR())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanPackingslipBeUpdated</Name>
				<Source><![CDATA[
    public boolean parmCanPackingslipBeUpdated()
    {
        #GetCached(canPackingslipBeUpdated, salesTableType.canPackingslipBeUpdated())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanPickingListBeRegistrated</Name>
				<Source><![CDATA[
    public boolean parmCanPickingListBeRegistrated()
    {
        #GetCached(canPickingListBeRegistrated, salesTableType.canPickingListBeRegistrated())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanPickingListBeUpdated</Name>
				<Source><![CDATA[
    public boolean parmCanPickingListBeUpdated()
    {
        #GetCached(canPickingListBeUpdated, salesTableType.canPickingListBeUpdated())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanProjectPackingSlipBeUpdated</Name>
				<Source><![CDATA[
    public boolean parmCanProjectPackingSlipBeUpdated()
    {
        #GetCached(canProjectPackingSlipBeUpdated, salesTableType.canProjectPackingSlipBeUpdated())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanReleaseToWarehouse</Name>
				<Source><![CDATA[
    public boolean parmCanReleaseToWarehouse()
    {
        #GetCached(canReleaseToWarehouse, salesTable.canReleaseToWarehouse())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmContactPersonExists</Name>
				<Source><![CDATA[
    public boolean parmContactPersonExists()
    {
        #GetCached(contactPersonExists, this.existContactPerson())
    }

]]></Source>
			</Method>
			<Method>
				<Name>existContactPerson</Name>
				<Source><![CDATA[
    private boolean existContactPerson()
    {
        ContactPerson   contactPerson;
        CustTable       custTable;

        select firstonly recId from contactPerson
            join TableId from custTable
            where custTable.accountNum          == salesTable.CustAccount
               && contactPerson.ContactForParty == custTable.party;

        return contactPerson.recId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreditCardWizardEnabled</Name>
				<Source><![CDATA[
    public boolean parmCreditCardWizardEnabled()
    {
        #GetCached(creditCardWizardEnabled, salesTable.payment().CreditCardPaymentType == CreditCardPaymentType::CreditCard)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDeliveredInTotal</Name>
				<Source><![CDATA[
    public boolean parmDeliveredInTotal()
    {
        #GetCached(deliveredInTotal, salesLine.deliveredInTotal())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDeliveryScheduleEnabled</Name>
				<Source><![CDATA[
    public boolean parmDeliveryScheduleEnabled()
    {
        #GetCached(deliveryScheduleEnabled, this.parmShouldLineFunctionsBeEnabled()
            && (salesLine.LineDeliveryType == LineDeliveryType::OrderLineWithMultipleDeliveries
                || salesLine.LineDeliveryType == LineDeliveryType::DeliveryLine
                || this.deliveryScheduleConversionAllowed()))
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesLineDeliveryDetailsEnabled</Name>
				<Source><![CDATA[
    public boolean parmSalesLineDeliveryDetailsEnabled()
    {
        #GetCached(salesLineDeliveryDetailsEnabled, this.parmShouldLineFunctionsBeEnabled() &&
                                                    salesLine.LineDeliveryType == LineDeliveryType::OrderLine &&
                                                    salesLine.DeliveryDateControlType != SalesDeliveryDateControlType::None &&
                                                    this.deliveryAlternativesAllowed())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEditHeaderAllowed</Name>
				<Source><![CDATA[
    public boolean parmEditHeaderAllowed()
    {
        #GetCached(enableHeaderDiscountButtons, salesTableForm.editHeaderAllowed())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEnableBatchAttribReserve</Name>
				<Source><![CDATA[
    public boolean parmEnableBatchAttribReserve()
    {
        return isStocked && isItemBatchActivated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEnableCustDocumentLog</Name>
				<Source><![CDATA[
    public boolean parmEnableCustDocumentLog()
    {
        return isRegulated || isRestricted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEnableHeaderDiscountButtons</Name>
				<Source><![CDATA[
    public boolean parmEnableHeaderDiscountButtons()
    {
        #GetCached(enableHeaderDiscountButtons, !this.parmInterCompanyOrderLineInvoiceMatched() && salesTable.ICCheckUpdateHeaderDiscounts())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEnableICPickingListButton</Name>
				<Source><![CDATA[
    public boolean parmEnableICPickingListButton()
    {
        #GetCached(enableICPickingListButton, this.calcEnableICPickingListButton())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEnableMSDSDocument</Name>
				<Source><![CDATA[
    public boolean parmEnableMSDSDocument()
    {
        return isRegulated || isRestricted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEnablePackOnHand</Name>
				<Source><![CDATA[
    public boolean parmEnablePackOnHand()
    {
        return isBulkOrPack;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExistInterCompanyPurch</Name>
				<Source><![CDATA[
    public boolean parmExistInterCompanyPurch()
    {
        #GetCached(existInterCompanyPurch, salesTable.existInterCompanyPurch())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExistsConfirmation</Name>
				<Source><![CDATA[
    public boolean parmExistsConfirmation()
    {
        #GetCached(existsConfirmation, !isReturnItem && salesTable.lastConfirm() != '')
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExistsFacture_RU</Name>
				<Source><![CDATA[
    public boolean parmExistsFacture_RU()
    {
        #GetCached(existsFacture, salesTable.lastFacture_RU() != '')
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExistsInvoice</Name>
				<Source><![CDATA[
    public boolean parmExistsInvoice()
    {
        #GetCached(existsInvoice, !salesTable.ProjId && salesTable.lastInvoice() != '')
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExistsInvoice4Paym_RU</Name>
				<Source><![CDATA[
    public boolean parmExistsInvoice4Paym_RU()
    {
        #GetCached(existsInvoice4Paym, salesTable.lastInvoice4Paym_RU() != '')
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExistsPackingSlip</Name>
				<Source><![CDATA[
    public boolean parmExistsPackingSlip()
    {
        #GetCached(existsPackingSlip, salesTable.lastPackingSlip() != '')
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExistsPickingList</Name>
				<Source><![CDATA[
    public boolean parmExistsPickingList()
    {
        #GetCached(existsPickingList, !isReturnItem && salesTable.lastPickingList() != '')
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExistsQuotation</Name>
				<Source><![CDATA[
    public boolean parmExistsQuotation()
    {
        #GetCached(existsQuotation, salesTable.lastQuotation() != '')
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHasMultipleDeliveries</Name>
				<Source><![CDATA[
    public boolean parmHasMultipleDeliveries()
    {
        return hasMultipleDeliveries;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmICPOLineInvoiceMatched</Name>
				<Source><![CDATA[
    public boolean parmICPOLineInvoiceMatched()
    {
        #GetCached(ICPOLineInvoiceMatched, this.parmShouldLineFunctionsBeEnabled()
            && this.parmInterCompanyOrderLineInvoiceMatched())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyActionsEnabled</Name>
				<Source><![CDATA[
    public boolean parmInterCompanyActionsEnabled()
    {
        #GetCached(interCompanyActionsEnabled, this.parmIntercompanyOrgExist()
            && !isReturnItem
            && !isCategoryBased)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyOrderLineInvoiceMatched</Name>
				<Source><![CDATA[
    public boolean parmInterCompanyOrderLineInvoiceMatched()
    {
        #GetCached(interCompanyOrderLineInvoiceMatched, salesLine.isInterCompanyOrderLineInvoiceMatched())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIntercompanyOrgExist</Name>
				<Source><![CDATA[
    public boolean parmIntercompanyOrgExist()
    {
        #GetCached(intercompanyOrgExist, InterCompanyTradingRelation::tradingRelationExists())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIntercompanyOriginalSalesId</Name>
				<Source><![CDATA[
    public boolean parmIntercompanyOriginalSalesId()
    {
        #GetCached(interCompanyOriginalSalesId, salesTable.InterCompanyOriginalSalesId)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyPOInvoiceMatched</Name>
				<Source><![CDATA[
    public boolean parmInterCompanyPOInvoiceMatched()
    {
        #GetCached(interCompanyPurchaseOrderInvoiceMatched, salesTable.isInterCompanyPOInvoiceMatched())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIntercompanyPurchId</Name>
				<Source><![CDATA[
    public boolean parmIntercompanyPurchId()
    {
        #GetCached(interCompanyPurchId, salesTable.InterCompanyPurchId)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyRemoveEnabled</Name>
				<Source><![CDATA[
    public boolean parmInterCompanyRemoveEnabled()
    {
        #GetCached(interCompanyRemoveEnabled, this.parmInterCompanyActionsEnabled()
            && !salesLine.isDropShipment()
            && salesLine.InventRefTransId
            && salesLine.interCompanySalesLineExist()
            && (!salesLine.ProjId || !this.isPurchLineActive()))
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIntercompanySalesId</Name>
				<Source><![CDATA[
    public boolean parmIntercompanySalesId()
    {
        #GetCached(intercompanySalesId, this.purchTableReference().InterCompanySalesId)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTransPickEnabled</Name>
				<Source><![CDATA[
    public boolean parmInventTransPickEnabled()
    {
        #GetCached(inventTransPickEnabled, isStocked
            && !hasMultipleDeliveries
            && !(isReturnItem && salesLine.SalesQty < 0)
            && !salesLine.isDropShipment()
            && salesTable.canCustomerBeUpdated(DocumentStatus::PickingList))
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTransRegisterEnabled</Name>
				<Source><![CDATA[
    public boolean parmInventTransRegisterEnabled()
    {
        #GetCached(inventTransRegisterEnabled, salesLine.SalesQty < 0
            && isTangible
            && !hasMultipleDeliveries
            && !isReturnItem)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsRetailAttribute</Name>
				<Source><![CDATA[
    public boolean parmIsRetailAttribute()
    {
        // If retail config key is enabled, this method
        // should return true.
        return isConfigurationkeyEnabled(configurationKeyNum(Retail));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsRetailOrder</Name>
				<Source><![CDATA[
    public boolean parmIsRetailOrder()
    {
        #GetCached(isRetailOrder, isConfigurationkeyEnabled(configurationkeynum(Retail))
            && RetailPricingEngine::getOrderChannelId(salesTable.SalesId) != 0)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmisRetailCashAndCarrySales</Name>
				<Source><![CDATA[
    public boolean parmisRetailCashAndCarrySales()
    {
        #GetCached(isRetailCashAndCarrySales, this.salesTable.isRetailCashAndCarrySales())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineExists</Name>
				<Source><![CDATA[
    public boolean parmLineExists()
    {
        #GetCached(lineExists, salesLine.RecId != 0
            && this.parmShouldLineFunctionsBeEnabled())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineKitVariantComponentsEnabled</Name>
				<Source><![CDATA[
    public boolean parmLineKitVariantComponentsEnabled()
    {
        #GetCached(lineKitVariantComponentsEnabled, isRetailKit)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineMarkupAllowed</Name>
				<Source><![CDATA[
    public boolean parmLineMarkupAllowed()
    {
        #GetCached(lineMarkupAllowed, salesLine.markupAllowed())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineUpdateAllowed</Name>
				<Source><![CDATA[
    public boolean parmLineUpdateAllowed()
    {
        #GetCached(lineUpdateAllowed, salesTableForm.editLineAllowed())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkupAllowed</Name>
				<Source><![CDATA[
    public boolean parmMarkupAllowed()
    {
        #GetCached(markupAllowed, salesTable.markupAllowed())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMatchingAgreement</Name>
				<Source><![CDATA[
    public boolean parmMatchingAgreement()
    {
        #GetCached(matchingAgreement, salesTable.MatchingAgreement)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRAllowEditSalesQty</Name>
				<Source><![CDATA[
    public boolean parmMCRAllowEditSalesQty()
    {
        #GetCached(mcrAllowEditSalesQty,
                    !mcrEnableOrderCompletion
                    || !mcrPriceOverridden)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRAllowEditSalesUnit</Name>
				<Source><![CDATA[
    public boolean parmMCRAllowEditSalesUnit()
    {
        // Added the salesLine.RecID condition because salesQty == RemainSalesPhysical always
        // returned false for new lines (as the RemainSalesPhysical has yet to be calculated)
        #GetCached(mcrAllowEditSalesUnit, !mcrEnableOrderCompletion
                                        || (!mcrPriceOverridden
                                            && (salesLine.SalesQty == salesLine.RemainSalesPhysical
                                                || !salesLine.RecID)
                                            ))
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRAllowEditSourceId</Name>
				<Source><![CDATA[
    public boolean parmMCRAllowEditSourceId()
    {
        #GetCached(mcrAllowEditSourceId, true)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRAllowPaymentAccess</Name>
				<Source><![CDATA[
    public boolean parmMCRAllowPaymentAccess()
    {
        #GetCached(mcrAllowPaymentAccess, salesTableType.mcrAllowPaymentAccess())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRCancelOrderEnabled</Name>
				<Source><![CDATA[
    public boolean parmMCRCancelOrderEnabled()
    {
        #GetCached(mcrCancelOrderEnabled, (salesTable.SalesStatus == SalesStatus::None
                                            || salesTable.SalesStatus == SalesStatus::Backorder
                                            || salesTable.SalesStatus == SalesStatus::Canceled)
                                            && ! this.parmisRetailCashAndCarrySales())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRCanCreditHeader</Name>
				<Source><![CDATA[
    public boolean parmMCRCanCreditHeader()
    {
        #GetCached(mcrCanCreditHeader, this.retailMCRChannelTable().mcrEnableOrderPriceControl
            && MCRCustomerCredits::canCreditHeader(salesTable))
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRClearGiftCardNumber</Name>
				<Source><![CDATA[
    public boolean parmMCRClearGiftCardNumber()
    {
        #GetCached(mcrClearGiftCardNumber, (!mcrIsGiftCardItem
                                            && !mcrIsExternalGiftCardItem)
                                            || (!mcrIsGiftCardTypePhysical && salesLine.SalesStatus != SalesStatus::Invoiced))
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRCompleteButtonEnabled</Name>
				<Source><![CDATA[
    public boolean parmMCRCompleteButtonEnabled()
    {
        #GetCached(mcrHeaderFunctionButtonsEnabled, ((salesTable.SalesStatus == SalesStatus::Backorder || salesTable.SalesStatus == SalesStatus::Delivered)
                                                    && salesTable.mcrOrderStopped == NoYes::Yes))
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCREditItemAllowed</Name>
				<Source><![CDATA[
    public boolean parmMCREditItemAllowed()
    {
        #GetCached(mcrEditItemAllowed, !salesLine.recID && !this.parmisRetailCashAndCarrySales())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRGiftCardNumberVisible</Name>
				<Source><![CDATA[
    public boolean parmMCRGiftCardNumberVisible()
    {
        #GetCached(mcrGiftCardNumberVisible, (mcrIsGiftCardItem
                                            || mcrIsExternalGiftCardItem))
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRGiftCardExpirationVisible</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean parmMCRGiftCardExpirationVisible()
    {
        #GetCached(mcrGiftCardExpirationVisible, (mcrIsExternalGiftCardItem))
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRGiftCardPhysicalVisible</Name>
				<Source><![CDATA[
    public boolean parmMCRGiftCardPhysicalVisible()
    {
        #GetCached(mcrGiftCardPhysicalVisible, (mcrIsGiftCardItem
                                            || mcrIsExternalGiftCardItem)
                                            && mcrIsGiftCardTypePhysical)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRGiftCardVirtualVisible</Name>
				<Source><![CDATA[
    public boolean parmMCRGiftCardVirtualVisible()
    {
        #GetCached(mcrGiftCardVirtualVisible, (mcrIsGiftCardItem
                                            || mcrIsExternalGiftCardItem)
                                            && !mcrIsGiftCardTypePhysical)
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramMCRGiftCardNumberEnabled</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean paramMCRGiftCardNumberEnabled()
    {
        #GetCached(mcrGiftCardNumberEnabled, this.parmMCRGiftCardNumberVisible()
                                           && !mcrIsExternalGiftCardItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRHeaderAllowDelete</Name>
				<Source><![CDATA[
    public boolean parmMCRHeaderAllowDelete()
    {
        #GetCached(mcrHeaderAllowDelete, mcrAllowDelete)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRHeaderAllowEdit</Name>
				<Source><![CDATA[
    public boolean parmMCRHeaderAllowEdit()
    {
        #GetCached(mcrHeaderAllowEdit, mcrAllowEdit)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRHeaderFunctionButtonsEnabled</Name>
				<Source><![CDATA[
    public boolean parmMCRHeaderFunctionButtonsEnabled()
    {
        #GetCached(mcrHeaderFunctionButtonsEnabled, salesTable.RecId != 0)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRLineNotesLineEnabled</Name>
				<Source><![CDATA[
    public boolean parmMCRLineNotesLineEnabled()
    {
        #GetCached(mcrLineNotesLineEnalbed, salesLine.recID)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRLineStripDeleteEnabled</Name>
				<Source><![CDATA[
    public boolean parmMCRLineStripDeleteEnabled()
    {
        #GetCached(mcrLineStripDeleteEnabled, !mcrEnableOrderCompletion
                                    || salesTable.SalesStatus  == SalesStatus::None
                                    || salesTable.SalesStatus  == SalesStatus::Backorder)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCROrderCompletionEnabled</Name>
				<Source><![CDATA[
    public boolean parmMCROrderCompletionEnabled()
    {
        #GetCached(mcrOrderCompletionEnabled, this.retailMCRChannelTable().MCREnableOrderCompletion)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCROrderHoldsEnabled</Name>
				<Source><![CDATA[
    public boolean parmMCROrderHoldsEnabled()
    {
        #GetCached(mcrOrderHoldsEnabled, SalesTableForm::mcrEnableOrderHoldsButton(salesTable))
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCROrderModifyEnabled</Name>
				<Source><![CDATA[
    public boolean parmMCROrderModifyEnabled()
    {
        #GetCached(mcrOrderModifyEnabled, mcrSalesOrderModifyEnabled)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCROrderPriceControlEnabled</Name>
				<Source><![CDATA[
    public boolean parmMCROrderPriceControlEnabled()
    {
        #GetCached(mcrOrderPriceControlEnabled, this.retailMCRChannelTable().MCREnableOrderPriceControl)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRUpdateGiftCardEnabled</Name>
				<Source><![CDATA[
    public boolean parmMCRUpdateGiftCardEnabled()
    {
        #GetCached(mcrUpdateGiftCardEnabled, (mcrIsGiftCardItem
                                            || mcrIsExternalGiftCardItem)
                                            && mcrIsGiftCardTypePhysical)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymentScheduleEnabled</Name>
				<Source><![CDATA[
    public boolean parmPaymentScheduleEnabled()
    {
        #GetCached(paymentScheduleEnabled, !isReturnItem && salesTable.PaymentSched)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProductBasedNotReturn</Name>
				<Source><![CDATA[
    public boolean parmProductBasedNotReturn()
    {
        #GetCached(productBasedNotReturn, !isReturnItem && !isCategoryBased)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReferencesEnabled</Name>
				<Source><![CDATA[
    public boolean parmReferencesEnabled()
    {
        #GetCached(referencesEnabled, (this.parmIntercompanyPurchId()
            || this.parmExistInterCompanyPurch())
            || salesTable.ReturnItemNum)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRegularOrder</Name>
				<Source><![CDATA[
    public boolean parmRegularOrder()
    {
         #GetCached(regularOrder, salesTable.SalesType == SalesType::Sales
            || salesTable.SalesType == SalesType::ItemReq)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRelatedPOLineInvoiceMatched</Name>
				<Source><![CDATA[
    public boolean parmRelatedPOLineInvoiceMatched()
    {
        #GetCached(relatedPOLineInvoiceMatched, !isReturnItem
            && (this.parmInterCompanyOrderLineInvoiceMatched() || salesLine.isDropShipmentPOLineInvoiceMatched()))
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRelatedPurchaseOrderEnabled</Name>
				<Source><![CDATA[
    public boolean parmRelatedPurchaseOrderEnabled()
    {
        #GetCached(relatedPurchaseOrderEnabled, !isReturnItem
            && this.parmExistInterCompanyPurch())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReturnItem</Name>
				<Source><![CDATA[
    public boolean parmReturnItem()
    {
        return isReturnItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesDropShipmentCancelEnabled</Name>
				<Source><![CDATA[
    public boolean parmSalesDropShipmentCancelEnabled()
    {
        #GetCached(salesDropShipmentCancelEnabled, this.parmShouldLineFunctionsBeEnabled()
            && salesLine.RecId
            && salesLine.isDropShipment()
            && !salesLine.isInterCompanyOrder()
            && !salesLine.interCompanySalesLineExist())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesStatusInvoiced</Name>
				<Source><![CDATA[
    public boolean parmSalesStatusInvoiced()
    {
        return SalesTable.SalesStatus == SalesStatus::Invoiced;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesTableCanCreatePurchOrder</Name>
				<Source><![CDATA[
    public boolean parmSalesTableCanCreatePurchOrder()
    {
         #GetCached(salesTableCanCreatePurchOrder, salesTableType.canCreatePurchOrder())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesUpdateRemainEnabled</Name>
				<Source><![CDATA[
    public boolean parmSalesUpdateRemainEnabled()
    {
        #GetCached(salesUpdateRemainEnabled, this.parmShouldLineFunctionsBeEnabled()
            && salesLine.RecId
            && salesLine.type().canDeliverRemainderBeUpdated()
            && !hasMultipleDeliveries
            && salesTable.type().canUpdateRemainingQty()
            && this.isSalesOrderAllowedEdit())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShouldLineFunctionsBeEnabled</Name>
				<Source><![CDATA[
    public boolean parmShouldLineFunctionsBeEnabled()
    {
        #GetCached(shouldLineFunctionsBeEnabled, !isReturnItem && salesTable.RecId)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStockedNotCanceledNotMultipleDlv</Name>
				<Source><![CDATA[
    public boolean parmStockedNotCanceledNotMultipleDlv()
    {
        #GetCached(stockedNotCanceledNotMultipleDlv, isStocked
            && salesLine.ReturnStatus != ReturnStatusLine::Canceled
            && !hasMultipleDeliveries)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStockedNotReturn</Name>
				<Source><![CDATA[
    public boolean parmStockedNotReturn()
    {
        #GetCached(stockedNotReturn, !isReturnItem && isStocked)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStockedNotReturnNotMultipleDlv</Name>
				<Source><![CDATA[
    public boolean parmStockedNotReturnNotMultipleDlv()
    {
        #GetCached(stockedNotReturnNotMultipleDlv, !hasMultipleDeliveries
            && this.parmStockedNotReturn())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSuppItemCalcEnabled</Name>
				<Source><![CDATA[
    public boolean parmSuppItemCalcEnabled()
    {
        #GetCached(suppItemCalcEnabled, !isCategoryBased
            && !isReturnItem
            && !this.parmRelatedPOLineInvoiceMatched())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSuppItemCalcEnabledHeader</Name>
				<Source><![CDATA[
    public boolean parmSuppItemCalcEnabledHeader()
    {
        #GetCached(suppItemCalcEnabledHeader, !isReturnItem
            && salesTable.checkUpdate(false, false))
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTMSInvoiceJournalButtonEnabled</Name>
				<Source><![CDATA[
    public boolean parmTMSInvoiceJournalButtonEnabled()
    {
        #GetCached(tmsInvoiceJournalButtonEnable, isConfigurationkeyEnabled(configurationkeynum(WHSandTMS))
            && this.tmsInvoiceJournalButtonEnabled())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWHSLoadDetailsButtonEnabled</Name>
				<Source><![CDATA[
    public boolean parmWHSLoadDetailsButtonEnabled()
    {
        #GetCached(whsLoadDetailsButtonEnable, isConfigurationkeyEnabled(configurationkeynum(WHSandTMS))
            && this.whsLoadDetailsButtonEnabled())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWHSLoadTableEnabled</Name>
				<Source><![CDATA[
    public boolean parmWHSLoadTableEnabled()
    {
        return salesLine.whsHasLoadTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWHSShipmentDetailsButtonEnabled</Name>
				<Source><![CDATA[
    public boolean parmWHSShipmentDetailsButtonEnabled()
    {
        #GetCached(whsShipmentDetailsButtonEnable, isConfigurationkeyEnabled(configurationkeynum(WHSandTMS))
            && this.whsShipmentDetailsButtonEnabled())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWHSWorkTableEnabled</Name>
				<Source><![CDATA[
    public boolean parmWHSWorkTableEnabled()
    {
        return isStocked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWMSOrderAllowCreate</Name>
				<Source><![CDATA[
    public boolean parmWMSOrderAllowCreate()
    {
        #GetCached(WMSOrderAllowCreate, this.parmStockedNotReturnNotMultipleDlv()
            && !salesLine.isDropShipment())
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRAllowEditSalesPrice</Name>
				<Source><![CDATA[
    public boolean parmMCRAllowEditSalesPrice()
    {
        #GetCached(mcrAllowEditSalesPrice, this.priceAdjustAllowed())
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTableReference</Name>
				<Source><![CDATA[
    protected PurchTable purchTableReference()
    {
        if (!fetchedPurchTableReference)
        {
            fetchedPurchTableReference = true;
            purchTableReference = salesTable.referencePurchTable();
        }
        return purchTableReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailMCRChannelTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>RetailMCRChannelTable</c> record for the header.
    /// </summary>
    /// <returns>
    /// The <c>RetailMCRChannelTable</c> record for the header.
    /// </returns>
    public RetailMCRChannelTable retailMCRChannelTable()
    {
        if (!fetchedRetailMCRChannelTable)
        {
            fetchedRetailMCRChannelTable = true;

            // Disabled tables are transformed to temp tables.
            if (!retailMCRChannelTable.isTmp())
            {
                retailMCRChannelTable = RetailMCRChannelTable::findChannelBySalesTable(salesTable);
            }
        }
        return retailMCRChannelTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSalesTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the header record.
    /// </summary>
    /// <param name="_salesTable">
    /// The header record.
    /// </param>
    protected void setSalesTable(SalesTable _salesTable)
    {
        salesTable = _salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSalesTableForm</Name>
				<Source><![CDATA[
    public void setSalesTableForm(SalesTableForm _salesTableForm)
    {
        salesTableForm = _salesTableForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipTotalCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the quantity totals should be avoided.
    /// </summary>
    /// <param name="_salesTable">
    /// A <c>SalesTable</c> record; optional.
    /// </param>
    /// <returns>
    /// false if the calculation of the quantity totals should be avoided; otherwise, true.
    /// </returns>
    protected boolean skipTotalCalculation(SalesTable _salesTable)
    {
        return _salesTable
            && (_salesTable.DocumentStatus == DocumentStatus::None
            || _salesTable.DocumentStatus == DocumentStatus::Confirmation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmsInvoiceJournalButtonEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines whether the invoice journal button should be enabled.
    /// </summary>
    /// <returns>
    ///   true if the button should be enabled; Otherwise false.
    /// </returns>
    private boolean tmsInvoiceJournalButtonEnabled()
    {
        return TMSFreightBillDetail::existsInvoiceJournal('', '', '', salesTable.SalesId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        int version = RunBase::getVersion(_packedClass);

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = _packedClass;
                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsLoadDetailsButtonEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not the Load Details button should be enabled.
    /// </summary>
    /// <returns>
    /// true if the button should be enabled; Otherwise false.
    /// </returns>
    private boolean whsLoadDetailsButtonEnabled()
    {
        return WHSLoadLine::existForOrderNum(salesTable.SalesId, InventTransType::Sales);
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsShipmentDetailsButtonEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not the Shipment Details button should be enabled.
    /// </summary>
    /// <returns>
    /// true if the button should be enabled; Otherwise false.
    /// </returns>
    private boolean whsShipmentDetailsButtonEnabled()
    {
        return WHSLoadLine::getShipmentId(salesLine.InventTransId) !='';
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static SalesTableInteractionHelper construct()
    {
        return new SalesTableInteractionHelper();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeServer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an instance of the <c>SalesTableInteractionHelper</c> class.
    /// </summary>
    /// <param name="_salesTable">
    /// The header record used for initialization.
    /// </param>
    /// <returns>
    /// A container which holds a serialized <c>SalesTableInteractionHelper</c> class object.
    /// </returns>
    private static container initializeServer(
        SalesTable  _salesTable)
    {
        SalesTableInteractionHelper helper = SalesTableInteractionHelper::construct();

        helper.setSalesTable(_salesTable);

        helper.parmReferencesEnabled();
        helper.parmIsRetailOrder();
        helper.parmContactPersonExists();

        helper.parmWHSLoadDetailsButtonEnabled();
        helper.parmTMSInvoiceJournalButtonEnabled();

        helper.parmMCROrderCompletionEnabled();
        helper.parmMCROrderPriceControlEnabled();

        return helper.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromListPage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes an instance of the <c>SalesTableInteractionHelper</c> class.
    /// </summary>
    /// <param name="_salesTable">
    /// The header record used for initialization.
    /// </param>
    /// <returns>
    /// An instance of the <c>SalesTableInteractionHelper</c> class.
    /// </returns>
    public static SalesTableInteractionHelper newFromListPage(
        SalesTable  _salesTable)
    {
        SalesTableInteractionHelper helper = SalesTableInteractionHelper::construct();

        helper.unpack(SalesTableInteractionHelper::initializeServer(_salesTable));

        return helper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRGiftCardAmountVisible_RU</Name>
				<Source><![CDATA[
    public boolean parmMCRGiftCardAmountVisible_RU()
    {
        #GetCached(mcrGiftCardAmountVisible, mcrIsGiftCardItem && RetailParameters::find().ProcessGiftCardsAsPrepayments_RU)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRGiftCardPoliciesVisible</Name>
				<Source><![CDATA[
    public boolean parmMCRGiftCardPoliciesVisible()
    {
        #GetCached(mcrGiftCardPoliciesVisible, mcrIsGiftCardItem &&
                                               RetailParameters::find().UseGiftCardPolicies)
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCFMPaymentRequestViewEnabled</Name>
				<Source><![CDATA[
    public boolean parmCFMPaymentRequestViewEnabled()
    {
        #GetCached(CFMPaymentRequestViewEnabled, CFMPaymentRequestTable::lastPaymentRequestSale(salesTable.SalesId) != '')
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStateJournalButtonsMultipleOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the enabled property on buttons that are used for posting sales orders, when multiple sales orders are selected.
    /// </summary>
    /// <param name="_salesTable">
    ///    The <c>SalesTable</c> data source record that is used to determine whether the buttons must be enabled or
    ///    disabled.
    /// </param>
    public static void updateStateJournalButtonsMultipleOrders(SalesTable _salesTable)
    {
        FormDataSource salesTable_ds = FormDataUtil::getFormDataSource(_salesTable);

        MultiSelectionHelper multiSelectionHelper = MultiSelectionHelper::construct();
        multiSelectionHelper.parmDatasource(salesTable_ds);

        SalesTable localSalesTable = multiSelectionHelper.getFirst() as SalesTable;

        if (localSalesTable)
        {
            SalesTableFormJournalButtonState buttonState = SalesTableFormJournalButtonState::construct();
            buttonState.parmFormRun(salesTable_ds.formRun());
            
            if (SalesTableInteractionHelper::canDisplayJournalButtons(multiSelectionHelper))
            {
                localSalesTable = multiSelectionHelper.getFirst() as SalesTable;

                while (localSalesTable)
                {
                    if (buttonState.isAllEnabled())
                    {
                        break;
                    }

                    SalesTableCheckIfUpdateContract checkIfUpdateContract = SalesTableCheckIfUpdateContract::construct();
                    buttonState.initializeCheckIfUpdateContract(checkIfUpdateContract);
  
                    container canBeUpdated = localSalesTable.checkIfUpdate(checkIfUpdateContract.pack());
                    SalesTableCanBeUpdatedContract canBeUpdatedContract = SalesTableCanBeUpdatedContract::create(canBeUpdated);

                    buttonState.parseCanBeUpdatedContract(canBeUpdatedContract);

                    localSalesTable = salesTable_ds.getNext() as SalesTable;
                }
            }

            buttonState.applyState();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDisplayJournalButtons</Name>
				<Source><![CDATA[
    private static boolean canDisplayJournalButtons(MultiSelectionHelper _multiSelectionHelper)
    {
        SalesMaxNumberOfSalesOrdersForPosting maxRecordsMarked = SalesParameters::find().MaxNumberOfSalesOrdersForPosting;
        
        if (!maxRecordsMarked)
        {
            return true;
        }

        boolean ret = true;
        int recordsMarked;
        SalesTable localSalesTable = _multiSelectionHelper.getFirst() as SalesTable;

        while (localSalesTable)
        {
            recordsMarked++;

            if (recordsMarked > maxRecordsMarked)
            {
                ret = false;
                break;
            }

            localSalesTable = _multiSelectionHelper.getNext() as SalesTable;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDeliveryAddressForDlvMode</Name>
				<Source><![CDATA[
    private LogisticsPostalAddressRecId findDeliveryAddressForDlvMode(CustDlvModeId _dlvMode, CustAccount _custAccount, InventLocationId _inventLocationId)
    {
        LogisticsPostalAddressRecId logisticsPostalAddressRecId;
        RetailParameters            retailParameters = RetailParameters::find();

        if (_dlvMode != '' && RetailDlvMode::isPickupDeliveryMode(_dlvMode))
        {
            logisticsPostalAddressRecId = this.findStoreAddressByInventLocation(_inventLocationId).RecId;
        }

        if (!logisticsPostalAddressRecId)
        {
            logisticsPostalAddressRecId = this.findCustomerDeliveryAddress(_custAccount);
        }

        return logisticsPostalAddressRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findStoreAddressByInventLocation</Name>
				<Source><![CDATA[
    private LogisticsPostalAddress findStoreAddressByInventLocation(InventLocationId _inventLocationId)
    {
        LogisticsPostalAddress storePickupAddress = this.findStorePickupAddress(_inventLocationId);

        if (!storePickupAddress)
        {
            info(strFmt("@Retail_Hotfix_255925:StoreAddressNotFound", _inventLocationId));
        }

        return storePickupAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findStorePickupAddress</Name>
				<Source><![CDATA[
    private LogisticsPostalAddress findStorePickupAddress(InventLocationId _inventLocationId)
    {
        DirPartyTable    dirPartyTable;
        RetailStoreId    fulfillmentStore;
        PartyNumber      partyNumber;
        RetailStoreTable retailStoreTable;

        fulfillmentStore = RetailStoreTable::getFirstStoreIdByPickupLocation(_inventLocationId);
        retailStoreTable = RetailStoreTable::find(fulfillmentStore);
        partyNumber = RetailStoreTable::findOperatingUnit(retailStoreTable.RecId).PartyNumber;

        select firstonly RecId from dirPartyTable
            where dirPartyTable.partyNumber == partyNumber;

        return DirParty::primaryPostalAddress(dirPartyTable.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesOrderAllowedEdit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Can the order be edited.
    /// </summary>
    /// <returns>
    /// true if the order can be edited; otherwise, false.
    /// </returns>
    private boolean isSalesOrderAllowedEdit()
    {
        #GetCached(orderAllowEdit,
            !(mcrEnableOrderCompletion || salesTableForm.isMcrOrderCompletionEnabled())  // order completion is not enabled
            || this.parmMCRCompleteButtonEnabled())                                      // order completion is eanbled and order is in edit mode
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchLineActive</Name>
				<Source><![CDATA[
    private boolean isPurchLineActive()
    {
        PurchLine purchLine = salesLine.referencedPurchLine();
        return purchLine && purchLine.PurchStatus != PurchStatus::Invoiced && purchLine.PurchStatus != PurchStatus::Canceled;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>