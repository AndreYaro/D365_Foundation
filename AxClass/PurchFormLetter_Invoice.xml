<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchFormLetter_Invoice</Name>
	<SourceCode>
		<Declaration><![CDATA[
[SysOperationJournaledParametersAttribute(true)]
class PurchFormLetter_Invoice extends PurchFormLetter implements BatchRetryable
{
    PurchFormLetterInvoiceContract purchFormLetterInvoiceContract;
    PurchFormLetterNewSession purchFormLetterNewSession;

    //List of records
    str activeInvoiceListPacked;
    str invoicesInUseListPacked;
    int activeInvoiceFlags;

    boolean existMultipleLinesForVendorCurrency;
    boolean wasMatchStatusReset;
    boolean isPostingDateInClosedPeriod;

    private PurchInstrumentationLogger  instrumentationLogger;

    // <GIN>
    container purchLineRec;
    container vendInvoiceTransRec;
    AmountCur withholdingTax;
    MarkupAmount markupCustVendCopy;
    // </GIN>

    #define.InvoiceVersion(1003)
    #LOCALMACRO.ParmListPurchInvoice
        activeInvoiceListPacked,
        activeInvoiceFlags,
        existMultipleLinesForVendorCurrency,
        wasMatchStatusReset,
        isPostingDateInClosedPeriod,
        invoicesInUseListPacked
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>afterOperationBody</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes main logic of after operation, before cleanup.
    /// </summary>
    protected void afterOperationBody()
    {
        super();
        this.createPayment();
    }

]]></Source>
			</Method>
			<Method>
				<Name>afterOperationUpdateError</Name>
				<Source><![CDATA[
    protected void afterOperationUpdateError(boolean _updateError)
    {
        if (_updateError)
        {
            throw Exception::Error;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>caption</Name>
				<Source><![CDATA[
    public ClassDescription caption()
    {
        return PurchFormLetter_Invoice::description();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkClientOutput</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the selected destination for printing is the screen.
    /// </summary>
    /// <param name="_showError">
    ///    A boolean value that determines whether error messages should be reported; optional.
    /// </param>
    /// <returns>
    ///    true if the selected destination is the screen; otherwise, false.
    /// </returns>
    protected boolean checkClientOutput(boolean _showError = true)
    {
        boolean isClientOutput = super(_showError);

        if (this.printEUVatInvoice())
        {
            if (FormLetter::isClientOutput(this.printerSettingsEUVatInvoice()))
            {
                // Override non-client print destination setting.
                isClientOutput = true;

                if (_showError)
                {
                    checkFailed("@SYS118819");
                }
            }
        }

        return isClientOutput;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkClientOutputPrintManagement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the selected destination for printing the original and copies of reports in print management is the screen.
    /// </summary>
    /// <param name="_showError">
    ///    A boolean value that determines whether error messages should be reported; optional.
    /// </param>
    /// <returns>
    ///    true if the destination is the screen; otherwise, false.
    /// </returns>
    protected boolean checkClientOutputPrintManagement(boolean _showError = true)
    {
        boolean isClientOutputPrintManagement = super(_showError);

        if (this.printEUVatInvoice())
        {
            if (FormLetter::isClientOutput(this.printerSettingsEUVatInvoice()))
            {
                // Override non-client print destination setting.
                isClientOutputPrintManagement = true;
                printerSetupError = true;

                if (_showError)
                {
                    checkFailed("@SYS118819");
                }
            }
        }

        return isClientOutputPrintManagement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkConsignmentNoteNum_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate if the vendor is gtaVendor, then if ConsignmentNoteNum_IN field is entered return true else return false.
    /// </summary>
    /// <returns>
    /// returns true if the consignment number is entered otherwise false
    /// </returns>
    public boolean checkConsignmentNoteNum_IN()
    {
        boolean ok = true;
        PurchSummary checkPurchSummary;

        if (VendTable::find(this.purchTable().OrderAccount).isGTA())
        {
            if (PurchLine::find(this.purchTable().PurchId).LineAmount < 0)
            {
                return ok;
            }

            checkPurchSummary = PurchSummary::construct(this.purchParmUpdate().SumBy, this.purchParmUpdate().ParmId, this.purchParmUpdate().SumPurchId, this.documentStatus(),this.parmNumber());
            ok = checkPurchSummary.checkConsignmentNoteNum_IN();
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCreditCorrection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for positive credit correction invoices and asks the user to confirm.
    /// </summary>
    /// <returns>
    /// true if the user wants the invoice to be posted; otherwise, false.
    /// </returns>
    public boolean checkCreditCorrection()
    {
        VendInvoiceInfoTable localVendInvoiceInfoTable;

        while select localVendInvoiceInfoTable
            where localVendInvoiceInfoTable.ParmId == this.parmId() &&
                localVendInvoiceInfoTable.Hold == NoYes::No
        {
            if (!localVendInvoiceInfoTable.checkCreditCorrection())
            {
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFormLetterId</Name>
				<Source><![CDATA[
    boolean checkFormLetterId()
    {
        boolean ok = true;
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();
        // If posting or printing and saving changes, make sure the document number is entered
        if ((!purchParmUpdate.Proforma) || (this.parmSaveChanges()))
        {
            int lastLine = infologLine();

            ok = PurchSummary::checkFormletterIdServer(purchParmUpdate.SumBy,
                                                       purchParmUpdate.ParmId,
                                                       purchParmUpdate.SumPurchId,
                                                       this.documentStatus(),
                                                       this.parmNumber(),
                                                       this.missingNumber());

            if (!ok)
            {
                // Removing warning message and raise as an error.
                infolog.clear(lastLine);
                error(this.missingNumber());
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPaymentSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks payment schedule in the current invoice for adjusted payment.
    /// </summary>
    /// <returns>
    /// returns true if the payment schedules are adjusted correctly, otherwise false
    /// </returns>
    public boolean checkPaymentSchedule()
    {
        boolean ret = true;
        VendPaymSched vendPaymSched;
        VendInvoiceInfoTable localVendInvoiceInfoTable;
        str errorText;
        int infologNum;

        if (this.purchParmUpdate().numberOfSubTables() <= 1)
        {
            // If there is only one subtable, arrange will have no effect. Allow adjusted payments in that case.
            return true;
        }

        // Check all documents in the current session for adjusted payments
        setPrefix("@AccountsPayable:PaymentScheuleFound");

        while select localVendInvoiceInfoTable
            where localVendInvoiceInfoTable.ParmId == this.parmId()
            exists join vendPaymSched
                where vendPaymSched.ExtTableId == localVendInvoiceInfoTable.TableId &&
                        vendPaymSched.ExtRecId == localVendInvoiceInfoTable.RecId
        {
            ret = false;
            errorText = strFmt("@AccountsPayable:PaymentSchedFound", localVendInvoiceInfoTable.PurchId);
            error(errorText);

            parmTable = localVendInvoiceInfoTable;
            infologNum = infolog.num();
            ttsbegin;
            this.updateParmTableWithErrors(Info::infoCon2Str(infolog.copy(infologNum,infologNum)));
            ttscommit;
        }

        if (!ret)
        {
            info("@AccountsPayable:UnabletoArrangeVendorInvoiceswithPaymentSchedLines" +
                    '\n' + "@AccountsPayable:ActionMessageForInvoiceswithPaymentSchedLines");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFundingLimit</Name>
				<Source><![CDATA[
    protected boolean checkFundingLimit()
    {
        PurchParmUpdate parmUpdate = this.purchParmUpdate();
        VendInvoiceInfoTable vendInvoiceInfo;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            select firstonly SourceDocumentHeader from vendInvoiceInfo
                where vendInvoiceInfo.ParmId == parmUpdate.ParmId &&
                      vendInvoiceInfo.PurchId == this.purchTable().PurchId;

            if (ProjFundingLimitTrackingManager::hasLimitErrorSourceDocument(vendInvoiceInfo.SourceDocumentHeader))
            {
                if (vendInvoiceInfo.PurchId)
                {
                    // Linked documents - return distribute message
                    return checkFailed("@SYS4110061");
                }
                else
                {
                    // Non-linked document - return reset message
                    return checkFailed("@SYS4110062");
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkImportDeclarations_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks all documents in the current session for import declarations
    /// </summary>
    /// <returns>
    /// True if there is at least one direct import for the current parmId; otherwise, false
    /// </returns>
    protected boolean checkImportDeclarations_BR()
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceInfoTable_W vendInvoiceInfoTable_W;
        boolean ret = true;

        if (this.purchParmUpdate().numberOfTables() == 1)
        {
            return true;
        }

        while select PurchId from vendInvoiceInfoTable
                    where vendInvoiceInfoTable.ParmId == this.parmId()
                exists join vendInvoiceInfoTable_W
                    where vendInvoiceInfoTable_W.VendInvoiceInfoTable == vendInvoiceInfoTable.RecId &&
                            vendInvoiceInfoTable_W.ImportDeclaration_BR != 0
        {
            ret = checkFailed(strFmt("@GLS63615", vendInvoiceInfoTable.PurchId));
        }

        if (!ret)
        {
            info("@GLS63617" + '\n' + "@GLS63618");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInterCompany</Name>
				<Source><![CDATA[
    protected boolean checkInterCompany()
    {
        VendInvoiceInfoTable vendInvoiceInfoTableLocal;
        PurchTable purchTableLocal;

        Counter recordCount = 0;
        boolean interCompanyFound = false;
        boolean ok = true;
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();

        if (purchParmUpdate.SumBy == AccountOrder::Order)
        {
            while select RecId from vendInvoiceInfoTableLocal
                where vendInvoiceInfoTableLocal.ParmId == purchParmUpdate.ParmId
                   && vendInvoiceInfoTableLocal.Hold == NoYes::No
                join InterCompanyOrder from purchTableLocal
                    where purchTableLocal.PurchId == vendInvoiceInfoTableLocal.PurchId
            {
                recordCount++;

                if (purchTableLocal.InterCompanyOrder)
                {
                    interCompanyFound = true;
                }

                if (interCompanyFound && recordCount > 1)
                {
                    ok = checkFailed(strFmt("@SYS75337", "@SYS57755"));
                    break;
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIntrastat</Name>
				<Source><![CDATA[
    protected boolean checkIntrastat(VendDocumentLineMap _parmLine, PurchLine _purchLine)
    {
        boolean ok = true;
        VendInvoiceInfoLine vendInvoiceInfoLine;

        Debug::assert(_parmLine.TableId == tableNum(VendInvoiceInfoLine));
        vendInvoiceInfoLine = _parmLine;

        if (!vendInvoiceInfoLine.isNonPO())
        {
            ok = super(_parmLine, _purchLine);
        }
        else if (IntrastatParameters::isLegalEntityInEEU() && this.mustCheckIntrastat())
        {
            ok = vendInvoiceInfoLine.checkIntrastat();
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPurchLinesChanged</Name>
				<Source><![CDATA[
    protected boolean checkPurchLinesChanged()
    {
        VendInvoiceInfoLine vendInvoiceInfoLineLocal;
        PurchLine purchLineLocal;
        // <GIN>
        VendInvoiceInfoLine previousvendInvoiceInfoLineLocal;
        PurchTable purchTableCopy = this.purchTable();
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();
        boolean isCustomsEnabled = TaxParameters::isCustomsEnable_IN();
        // </GIN>

        boolean ok = true;

        while select vendInvoiceInfoLineLocal
            where vendInvoiceInfoLineLocal.ParmId == this.purchParmUpdate().ParmId
            outer join purchLineLocal
                where purchLineLocal.InventTransId == vendInvoiceInfoLineLocal.InventTransId
                   && !purchLineLocal.IsDeleted
        {
            // <GIN>
            if (isCustomsEnabled
                && VendDocumentLineMap::isTransactionRelatedToBOE_IN(purchTableCopy, purchParmUpdate)
                && purchLineLocal)
            {
                if (vendInvoiceInfoLineLocal.InventTransId != previousvendInvoiceInfoLineLocal.InventTransId)
                {
                    previousvendInvoiceInfoLineLocal = vendInvoiceInfoLineLocal;
                    if ( vendInvoiceInfoLineLocal.vendInvoiceInfoTable().Hold == NoYes::No &&
                        !this.checkPurchLineChanged(vendInvoiceInfoLineLocal, purchLineLocal) )
                    {
                        ok = false;
                    }
                }
                else
                {
                    continue;
                }
            }
            else
            {
                // </GIN>
                if ( vendInvoiceInfoLineLocal.vendInvoiceInfoTable().Hold == NoYes::No &&
                    !this.checkPurchLineChanged(vendInvoiceInfoLineLocal, purchLineLocal, false) )
                {
                    ok = false;
                }
                // <GIN>
            }
            // </GIN>
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPurchLineChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the specified <c>VendDocumentLineMap</c> record.
    /// </summary>
    /// <param name="_parmLine">
    /// The <c>VendDocumentLineMap</c> record to verify.
    /// </param>
    /// <param name="_purchLine">
    /// The source <c>PurchLine</c> table for the <c>VendDocumentLineMap</c> record.
    /// </param>
    /// <param name="_checkQtys">
    /// Determines if the remaining quantities should be validated; optional.
    /// </param>
    /// <returns>
    /// true if the <c>VendDocumentLineMap</c> record is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// An Infolog message can be shown if a correction is being made for a line with active tracking
    /// dimensions, but no specific dimension is specified.
    /// </remarks>
    protected boolean checkPurchLineChanged(VendDocumentLineMap _parmLine, PurchLine _purchLine, boolean _checkQtys = true)
    {
        boolean ret = super(_parmLine, _purchLine, _checkQtys);

        // Validate the length of purchase order line names are valid.
        if (ret
            && this.needValidateLineName_PL())
        {
            ret = this.validateLineName_PL(_parmLine);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSumNum</Name>
				<Source><![CDATA[
    protected boolean checkSumNum()
    {
        boolean ok = true;
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();

        if (purchParmUpdate.SumBy == AccountOrder::Order)
        {
            if (!VendInvoiceInfoLine::existPurch(this.parmId(), purchParmUpdate.SumPurchId))
            {
                ok = checkFailed("@SYS26185");
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxWorkRegulation</Name>
				<Source><![CDATA[
    public boolean checkTaxWorkRegulation()
    {
        boolean ret = true;
        TaxWorkRegulation localTaxWorkRegulation;
        VendInvoiceInfoTable localVendInvoiceInfoTable;
        str errorText;
        int infologNum;

        if (this.purchParmUpdate().numberOfSubTables() <= 1)
        {
            // If there is only one subtable, arrange will have no effect. Allow adjusted taxes in that case.
            return true;
        }

        // Check all documents in the current session for adjusted taxes
        setPrefix("@SYS82342");

        while select localVendInvoiceInfoTable
          where localVendInvoiceInfoTable.ParmId == this.parmId()
            exists join localTaxWorkRegulation
                where localTaxWorkRegulation.HeadingTableId == localVendInvoiceInfoTable.TableId &&
                      localTaxWorkRegulation.HeadingRecId == localVendInvoiceInfoTable.RecId
        {
            ret = false;
            errorText = strFmt("@SYS82343", localVendInvoiceInfoTable.PurchId);
            error(errorText);

            parmTable = localVendInvoiceInfoTable;
            infologNum = infolog.num();
            ttsbegin;
            this.updateParmTableWithErrors(Info::infoCon2Str(infolog.copy(infologNum,infologNum)));
            ttscommit;
        }

        if (!ret)
        {
            info("@SYS82344" + '\n' +
                 "@SYS82345");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkW9Received</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls the static <c>checkW9Received</c> method in the <c>PurchFormletterParmDataInvoice</c> class.
    /// </summary>
    /// <param name="_vendInvoiceInfoTable">
    ///    The <c>VendInvoiceInfoTable</c> record that contains the <c>VendorAccount</c> object.
    /// </param>
    /// <returns>
    ///    true if the check passed; otherwise, false.
    /// </returns>
    boolean checkW9Received(VendDocumentTableMap _vendInvoiceInfoTable)
    {
        return PurchFormletterParmDataInvoice::checkW9Received(_vendInvoiceInfoTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLines</Name>
				<Source><![CDATA[
    public void chooseLines(boolean _processAdditional = false,
                            VendDocumentTableMap _parmTable = this.initParmTable(),
                            boolean _append = false)
    {
        // <GEEU>
        #EECountryRegionCodes
        // </GEEU>

        super(_processAdditional, _parmTable, _append);

        // <GEEU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU))
        {
            this.initOfficials_RU(null);
        }
        // </GEEU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesServer</Name>
				<Source><![CDATA[
    protected container chooseLinesServer(boolean _append = false)
    {
        return PurchFormletterParmDataInvoice::chooseLinesServer(this.packDataContract(purchFormLetterInvoiceContract),
                                                                 _append,
                                                                 this.parmId() ? true : false,
                                                                 false,
                                                                 false,
                                                                 this.parmInvoiceType());
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates payments and prints payment proposals if needed.
    /// </summary>
    protected void createPayment()
    {
        VendInvoiceJour vendInvoiceJour;
        VendTrans vendTrans;

        Set journalSet = Set::create(formletterOutputContract.parmAllJournalsPacked());
        SetEnumerator se = journalSet.getEnumerator();

        while (se.moveNext())
        {
            vendInvoiceJour = se.current();
            vendTrans = vendInvoiceJour.vendTrans();

            if (VendPaymModeTable::find(vendTrans.PaymMode).PaymOnInvoice)
            {
                CustVendPaymInvoiceWithJournal::construct(vendInvoiceJour).run();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteParmUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the necessary cleanup when the process encounters a failure.
    /// </summary>
    public void deleteParmUpdate()
    {
        VendInvoiceInfoTable::deleteParmUpdate(this.purchParmUpdate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWithoutUpdate</Name>
				<Source><![CDATA[
    protected void deleteWithoutUpdate(ParmId _parmId)
    {
        VendInvoiceInfoTable::deleteActiveWithoutUpdate(_parmId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    IDialogable dialog()
    {
        FormRun purchEditLines;
        Args clientArgs;

        if (!this.parmShowDialog())
        {
            return null;
        }

        clientArgs = FormLetterServiceController::newClientArgs(formStr(VendEditInvoice), this);
        clientArgs.menuItemName(this.parmCallerMenuItem());
        clientArgs.menuItemType(MenuItemType::Display);
        clientArgs.openMode(new MenuFunction(this.parmCallerMenuItem(), MenuItemType::Display).openMode());
        clientArgs.formViewOption(new MenuFunction(this.parmCallerMenuItem(), MenuItemType::Display).formViewOption());

        this.prePromptInitForBatchTask();

        purchEditLines = classfactory.formRunClass(clientArgs);

        purchEditLines.init();

        return purchEditLines as IDialogable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doCheckAdvancePaymentsOnValidate_RU</Name>
				<Source><![CDATA[
    protected boolean doCheckAdvancePaymentsOnValidate_RU()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentPostMessaging</Name>
				<Source><![CDATA[
    public boolean documentPostMessaging(container parmIds, Counter numberOfRecords = 0)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        ParmId currentParmId;
        Counter recIds;
        String20 invoiceAccount;
        VendInvoiceId num;

        if (numberOfRecords == 0)
        {
            return false;
        }

        boolean isAnyNonTaxable_BR;
        for (int i=conLen(parmIds); i >= 1; i--)
        {
            currentParmId = conPeek(parmIds, i);

            while select RecId, InvoiceAccount, Num, SourceDocumentHeader, Ordering, PurchId
                from vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == currentParmId
                    && vendInvoiceInfoTable.Hold == NoYes::No
                    && vendInvoiceInfoTable.ParmJobStatus == ParmJobStatus::Executed
            {
                recIds++;
                invoiceAccount = vendInvoiceInfoTable.InvoiceAccount;
                num = vendInvoiceInfoTable.Num;

                if (BrazilParameters::isEnabled() && vendInvoiceInfoTable.hasToIssueFiscalDocument_BR())
                {
                    var vendInvoiceJour = VendInvoiceJour::findSourceDocumentHeader(vendInvoiceInfoTable.SourceDocumentHeader);
                    num = FiscalDocument_BR::getInvoiceIdWithoutSeriesPrefix(vendInvoiceJour.InvoiceId, vendInvoiceInfoTable.vendInvoiceInfoTable_W().FiscalDocumentSeries_BR);
                    if (!isAnyNonTaxable_BR && vendInvoiceInfoTable.vendTable_InvoiceAccount().NonTaxable_BR)
                    {
                        isAnyNonTaxable_BR = true;
                        GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceBR00033, funcName());
                    }
                }
            }
        }

        if (recIds == 1)
        {
            info(strFmt("@AccountsPayable:VendInvoiceSinglePostSuccess", invoiceAccount, num));
            return true;
        }
        else if (recIds > 1)
        {
            info(strFmt("@AccountsPayable:VendInvoiceMultiPostSuccess", recIds));
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentStatus</Name>
				<Source><![CDATA[
    public DocumentStatus documentStatus()
    {
        return DocumentStatus::Invoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doRefreshCallerDataSource</Name>
				<Source><![CDATA[
    public boolean doRefreshCallerDataSource()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContract</Name>
				<Source><![CDATA[
    public FormLetterContract getContract()
    {
        return purchFormLetterInvoiceContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoicesInUseList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a list of pending vendor invoices that are in use by another user.
    /// </summary>
    /// <returns>
    /// A list of pending vendor invoices that are in use by another user.
    /// </returns>
    public List getInvoicesInUseList()
    {
        return List::create(SysOperationHelper::base64Decode(invoicesInUseListPacked));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryPendingInvoice</Name>
				<Source><![CDATA[
    public QueryRun getQueryPendingInvoice()
    {
        PurchFormletterParmDataInvoice parmData = PurchFormletterParmData::newChooseLines(this.packDataContract(purchFormLetterContract));

        return parmData.getQueryPendingInvoice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getValuesFormletterParmData</Name>
				<Source><![CDATA[
    protected void getValuesFormletterParmData(FormLetterParmDataOutputContract _outputContract)
    {
        super(_outputContract);

        activeInvoiceListPacked =_outputContract.parmActiveInvoiceListPacked();
        invoicesInUseListPacked = _outputContract.parmInvoicesInUseListPacked();
        activeInvoiceFlags = _outputContract.parmActiveInvoiceFlags();
        existMultipleLinesForVendorCurrency = _outputContract.parmExistMultipleLinesForVendorCurrency();
        wasMatchStatusReset = _outputContract.parmWasMatchStatusReset();
        isPostingDateInClosedPeriod = _outputContract.parmIsPostingDateInClosedPeriod();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initNewFromSaved</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes various class variables.
    /// </summary>
    /// <param name="_savedInvoice">
    /// The <c>VendInvoiceInfoTable</c> table buffer held by this class.
    /// </param>
    public void initNewFromSaved(VendInvoiceInfoTable _savedInvoice)
    {
        Map mapSavedInvoiceRecord;

        mapSavedInvoiceRecord = this.initDataSourceRecordsPacked(_savedInvoice);
        this.parmDataSourceRecordsPacked(mapSavedInvoiceRecord.pack());
        this.parmCallerTable(_savedInvoice);
        this.parmCallerMenuItem('');
        this.currentPurchParmTable();
        this.showQueryForm(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmTable</Name>
				<Source><![CDATA[
    protected VendDocumentTableMap initParmTable()
    {
        VendInvoiceInfoTable localVendInvoiceInfoTable;
        return localVendInvoiceInfoTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceHasLinesWithGoods_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the given invoice has one or more lines with goods.
    /// </summary>
    /// <param name="_vendInvoiceInfoTable">
    /// The <c>VendInvoiceInfoTable</c> of the current invoice.
    /// </param>
    /// <returns>
    /// Whether the invoice has at least one line with goods (true) or only service items (false).
    /// </returns>
    protected boolean invoiceHasLinesWithGoods_BR(VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        VendInvoiceInfoLine vendInvoiceInfoLine;
        InventTable inventTable;

        select firstonly RecId from inventTable
        exists join vendInvoiceInfoLine
            where vendInvoiceInfoLine.ItemId == inventTable.ItemId &&
                    vendInvoiceInfoLine.ParmId == _vendInvoiceInfoTable.ParmId &&
                    vendInvoiceInfoLine.TableRefId == _vendInvoiceInfoTable.TableRefId &&
                    inventTable.ItemType == ItemType::Item;

        return inventTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInvoiceNumberNumericOnly_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a given candidate invoice number has only numeric characters.
    /// </summary>
    /// <param name="_candidateNumber">
    /// The candidate invoice number to check.
    /// </param>
    /// <returns>
    /// True if the candidate invoice number in numeric only; otherwise, false.
    /// </returns>
    protected boolean isInvoiceNumberNumericOnly_BR(Num _candidateNumber)
    {
        return strKeep(_candidateNumber, '1234567890') == _candidateNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSetActiveInvoiceFlag</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the specified <c>VendActiveInvoiceFlags</c> flag is set.
    /// </summary>
    /// <param name="_flag">
    /// The flag to check
    /// </param>
    /// <returns>
    /// True if the specified flag is set
    /// </returns>
    public boolean isSetActiveInvoiceFlag(VendActiveInvoiceFlags _flag)
    {
        return (activeInvoiceFlags >> _flag) & 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>missingNumber</Name>
				<Source><![CDATA[
    str missingNumber()
    {
        return "@AccountsPayable:MissingInvoiceNumber";
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckIntrastat</Name>
				<Source><![CDATA[
    protected boolean mustCheckIntrastat()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(
        IdentifierName _className = classStr(FormletterService),
        IdentifierName _methodName= methodStr(FormletterService, postPurchaseOrderInvoice),
        SysOperationExecutionMode _executionMode = SysOperationExecutionMode::Synchronous)
    {
        super(_className, _methodName, _executionMode);
        instrumentationLogger = PurchInstrumentationLogger::createLogger(classStr(PurchFormLetter_Invoice));
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of <c>PurchFormLetter_Invoice</c>.
    /// </summary>
    /// <param name="_className">
    /// The class name of the service class.
    /// </param>
    /// <param name="_methodName">
    /// The method name of the service operation.
    /// </param>
    /// <param name="_executionMode">
    /// The execution mode to use when executing the service operation.
    /// </param>
    /// <returns>
    /// An instance of the <c>PurchFormLetter_Invoice</c> class.
    /// </returns>
    [Hookable(false)]
    public static PurchFormLetter_Invoice construct(
        IdentifierName _className = classStr(FormletterService),
        IdentifierName _methodName = methodStr(FormletterService, postPurchaseOrderInvoice),
        SysOperationExecutionMode _executionMode = SysOperationExecutionMode::Synchronous)
    {
        return new PurchFormLetter_Invoice(_className, _methodName, _executionMode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newJournalTransList</Name>
				<Source><![CDATA[
    RecordSortedList newJournalTransList()
    {
        RecordSortedList journalTransList;
        journalTransList = new RecordSortedList(tableNum(VendInvoiceTrans));
        journalTransList.sortOrder(fieldNum(VendInvoiceTrans, RecId));
        return journalTransList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#InvoiceVersion, #ParmListPurchInvoice] + [super()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAutoConsolidate</Name>
				<Source><![CDATA[
    public boolean parmAutoConsolidate(boolean _autoConsolidate = purchFormLetterInvoiceContract.parmAutoConsolidate())
    {
        return purchFormLetterInvoiceContract.parmAutoConsolidate(_autoConsolidate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCallerMenuItem</Name>
				<Source><![CDATA[
    public MenuItemNameAction parmCallerMenuItem(MenuItemNameAction _callerMenuItem = purchFormLetterContract.parmCallerMenuItem())
    {
        MenuItemNameAction menuItem = super(_callerMenuItem);

        if (!prmisDefault(_callerMenuItem))
        {
            this.synchronizeDocumentOrigin(_callerMenuItem);
        }

        return menuItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchRate_RU</Name>
				<Source><![CDATA[
    public ExchRate parmExchRate_RU(ExchRate _exchRate = purchFormLetterInvoiceContract.parmExchRate_RU())
    {
        return purchFormLetterInvoiceContract.parmExchRate_RU(_exchRate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExecutingPaymentAuthorizationTask</Name>
				<Source><![CDATA[
    public boolean parmExecutingPaymentAuthorizationTask(boolean _executingPaymentAuthorizationTask = purchFormLetterInvoiceContract.parmExecutingPaymentAuthorizationTask())
    {
        return purchFormLetterInvoiceContract.parmExecutingPaymentAuthorizationTask(_executingPaymentAuthorizationTask);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFixedExchRate_RU</Name>
				<Source><![CDATA[
    public NoYes parmFixedExchRate_RU(NoYes _fixedExchRate = purchFormLetterInvoiceContract.parmFixedExchRate_RU())
    {
        return purchFormLetterInvoiceContract.parmFixedExchRate_RU(_fixedExchRate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventProfileType_RU</Name>
				<Source><![CDATA[
    public InventProfileType_RU parmInventProfileType_RU(InventProfileType_RU _inventProfileType = purchFormLetterInvoiceContract.parmInventProfileType_RU())
    {
        return purchFormLetterInvoiceContract.parmInventProfileType_RU(_inventProfileType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsPostingDateInClosedPeriod</Name>
				<Source><![CDATA[
    public boolean parmIsPostingDateInClosedPeriod(boolean _isPostingDateInClosedPeriod = isPostingDateInClosedPeriod)
    {
        isPostingDateInClosedPeriod = _isPostingDateInClosedPeriod;
        return isPostingDateInClosedPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingProfile_RU</Name>
				<Source><![CDATA[
    public PostingProfile parmPostingProfile_RU(PostingProfile _postingProfile = purchFormLetterInvoiceContract.parmPostingProfile_RU())
    {
        return purchFormLetterInvoiceContract.parmPostingProfile_RU(_postingProfile);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchFormLetterNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets an instance of <c>PurchFormLetterNewSession</c> to indicate that a new session should be spun up after this session completes.
    /// </summary>
    /// <param name = "_purchFormLetterNewSession">An instance of <c>PurchFormLetterNewSession</c></param>
    /// <returns>The value of the instance of <c>PurchFormLetterNewSession</c></returns>
    public PurchFormLetterNewSession parmPurchFormLetterNewSession(PurchFormLetterNewSession _purchFormLetterNewSession = purchFormLetterNewSession)
    {
        if (!prmIsDefault(_purchFormLetterNewSession))
        {
            purchFormLetterNewSession = _purchFormLetterNewSession;
        }

        return purchFormLetterNewSession;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQueryChooseLinesPendingInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets the query that is used on the saved <c>VendInvoiceInfoTable</c> table to select the
    ///    lines to copy to the active <c>VendInvoiceInfoTable</c> table.
    /// </summary>
    /// <param name="_chooseLinesPendingInvoice">
    ///    The new <c>QueryRun</c> object; optional.
    /// </param>
    /// <returns>
    ///    The <c>QueryRun</c> object that is used to select the lines to copy from the pending invoice.
    /// </returns>
    public QueryRun parmQueryChooseLinesPendingInvoice(QueryRun _chooseLinesPendingInvoice = new QueryRun(SysOperationHelper::base64Decode(purchFormLetterInvoiceContract.parmChooseLinesPendingInvoicePacked())))
    {
        if (_chooseLinesPendingInvoice != null)
        {
            return new QueryRun(SysOperationHelper::base64Decode(purchFormLetterInvoiceContract.parmChooseLinesPendingInvoicePacked(SysOperationHelper::base64Encode(_chooseLinesPendingInvoice.pack()))));
        }
        else
        {
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveChanges</Name>
				<Source><![CDATA[
    public boolean parmSaveChanges(boolean _saveChanges = purchFormLetterInvoiceContract.parmSaveChanges())
    {
        return purchFormLetterInvoiceContract.parmSaveChanges(_saveChanges);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStorno_RU</Name>
				<Source><![CDATA[
    public NoYes parmStorno_RU(NoYes _storno = purchFormLetterInvoiceContract.parmStorno_RU())
    {
        return purchFormLetterInvoiceContract.parmStorno_RU(_storno);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUsePostingProfileFromContract_RU</Name>
				<Source><![CDATA[
    public boolean parmUsePostingProfileFromContract_RU(boolean _usePostingProfileFromContract = purchFormLetterInvoiceContract.parmUsePostingProfileFromContract_RU())
    {
        return purchFormLetterInvoiceContract.parmUsePostingProfileFromContract_RU(_usePostingProfileFromContract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWasMatchStatusReset</Name>
				<Source><![CDATA[
    public boolean parmWasMatchStatusReset(boolean _wasMatchStatusReset = wasMatchStatusReset)
    {
        wasMatchStatusReset = _wasMatchStatusReset;
        return wasMatchStatusReset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prePromptModifyData</Name>
				<Source><![CDATA[
    /// <summary>
    /// checks for any orphaned invoices,
    /// prompts the user,
    /// and processes them based on user input.
    /// </summary>
    public void prePromptModifyData()
    {
        List activeInvoiceList, selectedActiveInvoiceList;
        ListEnumerator activeInvoiceListEnumerator;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        str range;
        FormRun formRun;
        FormDataSource fds;
        QueryBuildDataSource qbds;
        VendIInvoiceDeleteActive formVendInvoiceDeleteActive;

        super();

        // Get the list of active invoices to be deleted
        activeInvoiceList = List::create(SysOperationHelper::base64Decode(activeInvoiceListPacked));
        selectedActiveInvoiceList = new List(Types::Int64);

        if (!activeInvoiceList)
        {
            return;
        }

        activeInvoiceListEnumerator = activeInvoiceList.getEnumerator();

        // Add each active invoice to a range string to apply to the form
        while (activeInvoiceListEnumerator.moveNext())
        {
            range += activeInvoiceListEnumerator.current() + ',';
        }

        if (range != '')
        {
            //Check if the form should be opened
            if (!this.shouldSkipPrompt())
            {
                // Apply the range to the form and open it
                args = new Args(formStr('VendInvoiceDeleteActive'));
                formRun = classfactory.formRunClass(args);
                formRun.init();
                formVendInvoiceDeleteActive = formRun as VendIInvoiceDeleteActive;
                if (formVendInvoiceDeleteActive.showNextTime())
                {
                    fds = formRun.dataSource();
                    qbds = fds.query().dataSourceTable(tableNum(VendInvoiceInfoTable));
                    qbds.addRange(fieldNum(VendInvoiceInfoTable,TableRefId)).value(range);
                    qbds.addRange(fieldNum(VendInvoiceInfoTable,ParmId)).value(SysQuery::valueNotEmptyString());
                    formRun.run();
                    formRun.wait();

                    if (formRun.closedOk())
                    {
                        vendInvoiceInfoTable = fds.getFirst(true);
                        while (vendInvoiceInfoTable)
                        {
                            selectedActiveInvoiceList.addEnd(vendInvoiceInfoTable.RecId);
                            vendInvoiceInfoTable = fds.getNext();
                        }

                        PurchFormLetter_Invoice::processSelectedActiveInvoices(selectedActiveInvoiceList, this.purchParmUpdate().ParmId);
                    }
                }
                else
                {
                    warning("@AccountsPayable:VendInvoiceInUseByAnotherUser");
                }
            }
        }

        if (existMultipleLinesForVendorCurrency)
        {
            // More than one invoice contains lines for the same vendor and currency - ask user if they want to consolidate
            if (Box::yesNo("@AccountsPayable:ConsolidatePOQuestion", DialogButton::Yes))
            {
                AccountOrder origSumBy;
                boolean origIncludePending;

                origSumBy = this.purchParmUpdate().SumBy;
                origIncludePending = this.purchParmUpdate().SumIncludePending;

                this.purchParmUpdate().SumBy = AccountOrder::Account;
                this.purchParmUpdate().SumIncludePending = NoYes::No;

                this.reArrange(false, false);

                this.purchParmUpdate().SumBy = origSumBy;
                this.purchParmUpdate().SumIncludePending = origIncludePending;
            }
        }

        if (isPostingDateInClosedPeriod 
            && !FeatureStateProvider::isFeatureEnabled(VendInvoicePostingDateAutoAdjustmentFeature::instance()))
        {
            if (Box::yesNo("@AccountsPayable:PostingDateInClosedPeriod", DialogButton::Yes))
            {
                this.updateClosedPostingDatesInWorkflow();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printerSettingsEUVatInvoice</Name>
				<Source><![CDATA[
    public container printerSettingsEUVatInvoice()
    {
        return SysOperationHelper::base64Decode(purchFormLetterInvoiceContract.parmPrinterSettingsEuVatInvoice());
    }

]]></Source>
			</Method>
			<Method>
				<Name>printEUVatInvoice</Name>
				<Source><![CDATA[
    public boolean printEUVatInvoice(boolean _printEUVatInvoice = purchFormLetterInvoiceContract.parmPrintEuVatInvoice())
    {
        return purchFormLetterInvoiceContract.parmPrintEuVatInvoice(_printEUVatInvoice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printMgmtDocumentType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Identifies the print management document type.
    /// </summary>
    /// <returns>
    /// The print management document type for purchase order invoice.
    /// </returns>
    protected PrintMgmtDocumentType printMgmtDocumentType()
    {
        return PrintMgmtDocumentType::PurchaseOrderInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processProjectItemRequirements</Name>
				<Source><![CDATA[
    protected void processProjectItemRequirements(FormletterOutputContract _outputContract)
    {
        if (!this.purchParmUpdate().Proforma && !this.interCompanyNoSalesFormletterUpdate())
        {
            SalesFormLetter     salesFormLetter;
            VendInvoiceJour     localVendInvoiceJour;
            VendInvoiceTrans    localVendInvoiceTrans;
            SalesLine           localSalesLine;
            PurchLine           localPurchLine;

            select firstonly RecId, InvoiceDate from localVendInvoiceJour
                where localVendInvoiceJour.ParmId == this.parmId()
                exists join localVendInvoiceTrans
                    where localVendInvoiceTrans.PurchID == localVendInvoiceJour.PurchId &&
                          localVendInvoiceTrans.InvoiceId == localVendInvoiceJour.InvoiceId &&
                          localVendInvoiceTrans.InvoiceDate == localVendInvoiceJour.InvoiceDate &&
                          localVendInvoiceTrans.NumberSequenceGroup == localVendInvoiceJour.NumberSequenceGroup &&
                          localVendInvoiceTrans.InternalInvoiceId == localVendInvoiceJour.InternalInvoiceId &&
                          localVendInvoiceTrans.QtyPhysical
                    exists join localPurchLine
                        where localPurchLine.InventTransId == localVendInvoiceTrans.InventTransId &&
                             !localPurchLine.IsDeleted &&
                              localPurchLine.ItemRefType == InventRefType::Sales &&
                              localPurchLine.InventRefId &&
                              localPurchLine.InventRefTransId
                        exists join localSalesLine
                            where localSalesLine.InventTransId == localPurchLine.InventRefTransId &&
                                  localSalesLine.ProjId &&
                                  localSalesLine.SalesType == SalesType::ItemReq;

            if (localVendInvoiceJour.RecId)
            {
                if (this.automaticItemConsumption())
                {
                    salesFormLetter = SalesFormLetter::newFromPurchFormLetter_Invoice(SysOperationHelper::base64Encode(_outputContract.parmJournalLinesPacked()),
                        DocumentStatus::ProjectPackingSlip);
                    salesFormLetter.transDate(localVendInvoiceJour.InvoiceDate);
                    salesFormLetter.prePromptInit();
                    salesFormLetter.run();
                }
                else
                {
                    boolean consumeItemImmediately = this.shouldConsumeItemImmediately();
                    if (this.showDialogToConsumeItemsImmediately())
                    {
                        consumeItemImmediately = Box::yesNo("@SYS70024", DialogButton::Yes) == DialogButton::Yes;
                    }

                    if (consumeItemImmediately)
                    {
                        salesFormLetter = SalesFormLetter::newFromPurchFormLetter_Invoice(SysOperationHelper::base64Encode(_outputContract.parmJournalLinesPacked()),
                            DocumentStatus::ProjectPackingSlip);
                        salesFormLetter.transDate(localVendInvoiceJour.InvoiceDate);
                        salesFormLetter.promptAndRun();
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>automaticItemConsumption</Name>
				<Source><![CDATA[
	/// <summary>
	/// Returns if the system is setup to automatically consume items.
	/// </summary>
	/// <returns>
	/// true if the system is setup to consume automatically; Otherwise false.
	/// </returns>
	protected boolean automaticItemConsumption()
	{
		return ProjParameters::find().AutomaticItemConsumption == NoYes::Yes;
	}

]]></Source>
			</Method>
			<Method>
				<Name>showDialogToConsumeItemsImmediately</Name>
				<Source><![CDATA[
	/// <summary>
	/// Determines whether the user is prompted about immediately consume items.
	/// </summary>
	/// <returns>
	/// true if the prompt should be shown; Otherwise false.
	/// </returns>
	protected boolean showDialogToConsumeItemsImmediately()
	{
		return true;
	}

]]></Source>
			</Method>
			<Method>
				<Name>shouldConsumeItemImmediately</Name>
				<Source><![CDATA[
	/// <summary>
	/// Returns whether an item should be consumed immediately.
	/// </summary>
	/// <returns>
	/// true if the item is to be consumed immediately; Otherwise false.
	/// </returns>
	protected boolean shouldConsumeItemImmediately()
	{
		return true;
	}

]]></Source>
			</Method>
			<Method>
				<Name>purchSelectLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates records in the <c>VendInvoiceInfoLine</c> table and consolidates the default record in the
    ///    <c>_vendInvoiceInfoTable</c> table in the <c>VendEditInvoice</c> form when the selected purchase
    ///    lines are retrieved from the <c>PurchSelectLines</c> form.
    /// </summary>
    /// <param name="_origPurchSubTableSet">
    ///    A set of <c>PurchId</c> values for creating records in the <c>_vendInvoiceInfoTable</c> table.
    /// </param>
    /// <param name="_newPurchLineSet">
    ///    A set of <c>RecId</c> values for creating records in the <c>VendInvoiceInfoLine</c> table.
    /// </param>
    /// <param name="_vendInvoiceInfoTable">
    ///    The default <c>VendInvoiceInfoTable</c> record in the <c>VendEditInvoice</c> form.
    /// </param>
    public void purchSelectLines(Set _origPurchSubTableSet, Set _newPurchLineSet, VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        Set tmpPurchLineRecIdSet;
        Set tmpPurchTablePurchIdSet;
        VendInvoiceInfoLine localPurchParmLine;
        container outputContainer;

        Debug::assert(_vendInvoiceInfoTable.TableId == tableNum(VendInvoiceInfoTable));

        if (BrazilParameters::isEnabled() && !this.validatePurchTableSet_BR(_origPurchSubTableSet))
        {
            return;
        }

        parmTable = _vendInvoiceInfoTable;

        tmpPurchLineRecIdSet = new Set(typeName2Type(extendedTypeStr(RecId)));
        tmpPurchTablePurchIdSet = new Set(typeName2Type(extendedTypeStr(PurchId)));

        while select PurchLineRecId, OrigPurchId from localPurchParmLine
            where localPurchParmLine.ParmId == this.parmId() &&
                  localPurchParmLine.TableRefId == this.currentPurchParmTable().TableRefId &&
                  localPurchParmLine.PurchLineRecId != 0
        {
            tmpPurchLineRecIdSet.add(localPurchParmLine.PurchLineRecId);

            if (!tmpPurchTablePurchIdSet.in(localPurchParmLine.OrigPurchId))
            {
                tmpPurchTablePurchIdSet.add(localPurchParmLine.OrigPurchId);
            }
        }

        //sets VendInvoiceInfoTable and VendInvoiceInfoLine to be created or deleted
        this.parmDeletePurchTablePurchIdSet(Set::difference(tmpPurchTablePurchIdSet, _origPurchSubTableSet).pack());
        this.parmNewPurchLineRecIdSet(Set::difference(_newPurchLineSet, tmpPurchLineRecIdSet).pack());
        this.parmDeletePurchLineRecIdSet(Set::difference(tmpPurchLineRecIdSet, _newPurchLineSet).pack());

        //Don't show SysQueryForm.
        this.showQueryForm(false);
        outputContainer = PurchFormletterParmDataInvoice::chooseLinesServer(this.packDataContract(purchFormLetterContract),
                                                                            true,
                                                                            this.parmId() ? true : false,
                                                                            false,
                                                                            true,
                                                                            this.parmInvoiceType());

        this.getValuesFormletterParmData(this.unpackFormletterParmDataOutputContract(outputContainer));

        // reset the variables used for processing the current record.
        this.parmDeletePurchTablePurchIdSet(conNull());
        this.parmNewPurchLineRecIdSet(conNull());
        this.parmDeletePurchLineRecIdSet(conNull());
        purchFormLetterInvoiceContract.parmParmTable(null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeValidate</Name>
				<Source><![CDATA[
    protected boolean reArrangeValidate(boolean _logErrors = false)
    {
        boolean ret = super(_logErrors);

        if (ret && BrazilParameters::isEnabled())
        {
            ret = this.checkImportDeclarations_BR();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runRemainUpdates</Name>
				<Source><![CDATA[
    protected void runRemainUpdates()
    {
        super();

        // Check to see if a new session is required upon the completion of the current session.
        // If so, switch to the proper company and kick off the new session using the MenuFunction specified in the PurchFormLetterNewSession object.
        PurchFormLetterNewSession newSession = this.parmPurchFormLetterNewSession();
        if (newSession)
        {
            changecompany(newSession.parmDataAreaId())
            {
                newSession.parmNewSessionOnCloseMenuFunction().run();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFromJournal</Name>
				<Source><![CDATA[
    public void selectFromJournal(container _packedTmpFrmVirtualList, boolean _reuseParmUpdate = true)
    {
        PurchFormletterParmDataInvoice purchFormletterParmData = PurchFormletterParmData::newChooseLines(this.packDataContract(purchFormLetterContract), _reuseParmUpdate);

        // <GEERU>
        purchFormletterParmData.parmTradeLineRefId_RU(this.parmTradeLineRefId_RU());
        // </GEERU>
        purchFormletterParmData.selectFromJournal(_packedTmpFrmVirtualList);
        this.getValuesFormletterParmData(purchFormletterParmData.getOutputContract());

        this.reArrangeNow(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFromJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates invoice lines based on matched packing slips.
    /// </summary>
    /// <param name="_packedRecordList">
    ///    A packed set of <c>SalesPurchParmSubLineLinkTmp</c> records that represents matches between invoice
    ///    lines and packing slip lines.
    /// </param>
    public void selectFromJournalLines(container _packedRecordList)
    {
        PurchFormletterParmDataInvoice purchFormletterParmData = PurchFormletterParmData::newChooseLines(this.packDataContract(purchFormLetterInvoiceContract), true);

        purchFormletterParmData.selectFromJournalLines(_packedRecordList);
        this.getValuesFormletterParmData(purchFormletterParmData.getOutputContract());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBatchInfo</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>BatchInfo</c> object.
    /// </summary>
    /// <param name="_batchInfo">
    ///    An instance of <c>BatchInfo</c> class.
    /// </param>
    public void setBatchInfo(BatchInfo _batchInfo)
    {
        batchInfo = _batchInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setActiveInvoiceFlag</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets a specific bit in the <c>activeInvoiceFlags</c> integer to set or unset a flag. See
    /// the <c>VendActiveInvoiceFlags</c> enum for available values.
    /// </summary>
    /// <param name = "_flag">The flag to set</param>
    /// <param name = "_value">The value to set the flag to</param>
    public void setActiveInvoiceFlag(VendActiveInvoiceFlags _flag, boolean _value)
    {
        if (_value)
        {
            //set the specified flag
            activeInvoiceFlags = activeInvoiceFlags | (1 << _flag);
        }
        else
        {
            //clear the specified flag
            activeInvoiceFlags = activeInvoiceFlags & ~(1 << _flag);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setForUpdatePurchParmTable</Name>
				<Source><![CDATA[
    void setForUpdatePurchParmTable()
    {
        parmTable = VendInvoiceInfoTable::findRecId(parmTable.RecId, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNewContract</Name>
				<Source><![CDATA[
    protected void setNewContract(FormLetterContract _contract)
    {
        super(_contract);
        if (!contractIsFromPreviousVersion)
        {
            purchFormLetterInvoiceContract = _contract;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQueryRangePendingInvoice</Name>
				<Source><![CDATA[
    public void setQueryRangePendingInvoice(VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        // Initialize the query for the pending lines selection - Check for multiple copies is done in chooseLines()
        QueryRun qr = this.getQueryPendingInvoice();

        qr.query().dataSourceTable(tableNum(PurchTable)).addRange(fieldNum(PurchTable, PurchId)).value(queryValue(_vendInvoiceInfoTable.PurchId));
        qr.query().dataSourceTable(tableNum(VendInvoiceInfoTable)).addRange(fieldNum(VendInvoiceInfoTable, TableRefId)).value(queryValue(_vendInvoiceInfoTable.TableRefId));
        qr.query().dataSourceTable(tableNum(VendInvoiceInfoTable)).addRange(fieldNum(VendInvoiceInfoTable, VendInvoiceSaveStatus)).value(queryValue(VendInvoiceSaveStatus::Pending));

        this.parmQueryChooseLinesPendingInvoice(qr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeDocumentOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the document origin based on the caller menu item.
    /// </summary>
    /// <param name="_callerMenuItem">
    /// The caller menu item.
    /// </param>
    private void synchronizeDocumentOrigin(MenuItemNameAction _callerMenuItem)
    {
        switch (_callerMenuItem)
        {
            case identifierStr(EPVendInvoice):
                this.parmDocumentOrigin(DocumentOrigin::EnterprisePortal);
                break;
            case identifierStr(EPVendInvoiceVendAdvance):
                this.parmDocumentOrigin(DocumentOrigin::EnterprisePortal);
                this.parmInvoiceType(PurchInvoiceType::VendorAdvance);
                break;
            default:
                this.parmDocumentOrigin(DocumentOrigin::Manual);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateForm</Name>
				<Source><![CDATA[
    protected FormName templateForm()
    {
        return formStr(VendEditInvoice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateClosedPostingDatesInWorkflow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the posting date of invoices that are currently being edited, have a posting date in a closed or on hold period,
    /// and have a workflow status of approved or in review.
    /// </summary>
    protected void updateClosedPostingDatesInWorkflow()
    {
        VendInvoiceInfoTable vendInvoiceInfoTableLocal;
        FiscalPeriodStart newDate;

        while select forupdate vendInvoiceInfoTableLocal
            where vendInvoiceInfoTableLocal.ParmId == this.parmId()
               && (vendInvoiceInfoTableLocal.RequestStatus == VendInvoiceRequestStatus::Approved ||
                vendInvoiceInfoTableLocal.RequestStatus == VendInvoiceRequestStatus::InReview)
        {
            vendInvoiceInfoTableLocal.updatePostingDate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>udpateNum</Name>
				<Source><![CDATA[
    protected void udpateNum(PurchParmUpdate _purchParmUpdate)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;

        // This should only be done if arranging by Order with an order id
        if (_purchParmUpdate.SumBy != AccountOrder::Order || _purchParmUpdate.SumPurchId == '')
        {
            return;
        }

        update_recordset vendInvoiceInfoTable
            setting Num = _purchParmUpdate.SumNum
                where vendInvoiceInfoTable.ParmId == _purchParmUpdate.ParmId
                   && vendInvoiceInfoTable.PurchId == _purchParmUpdate.SumPurchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    boolean unpack(container _packedClass)
    {
        Integer version = conPeek(_packedClass, 1);
        NoYes remain;
        NoYes approved;
        HcmPersonnelNumberId approvedBy;
        NoYes printPromissoryNote;
        ParmId parmId;
        PurchParmUpdate purchParmUpdate;
        NoYes queryCriteria;
        NoYes editing;
        Printout printout;
        NoYes printFormletter;
        container printersettingsFormletter;
        container printersettingsFormletterCopy;
        container printerSettingsEUVatInvoice;
        container printerSettingsPromissoryNote;
        boolean usePrintManagement;
        boolean saveChanges;
        boolean printEUVatInvoice;
        boolean printSalesFormletter;
        container packedBase;

        #LOCALMACRO.ParmList_v25sp2
            ParmId,
            purchParmUpdate.SpecQty,
            remain,
            purchParmUpdate.CreditRemaining,
            QueryCriteria,
            Editing,
            approved,
            approvedBy,
            Printout,
            PrintFormletter,
            PrinterSettingsFormLetter,
            printEuVatInvoice,
            printerSettingsEuVatInvoice
        #ENDMACRO

        #LOCALMACRO.ParmList_v30
            parmId,
            purchParmUpdate,
            QueryCriteria,
            Editing,
            Printout,
            PrintFormletter,
            PrinterSettingsFormLetter,
            printEuVatInvoice,
            printerSettingsEuVatInvoice,
            printPromissoryNote,
            printerSettingsPromissoryNote
        #ENDMACRO

        #LOCALMACRO.ParmList_v40
            parmId,
            purchParmUpdate,
            QueryCriteria,
            Editing,
            Printout,
            PrintFormletter,
            PrinterSettingsFormLetter,
            printEuVatInvoice,
            printerSettingsEuVatInvoice,
            printerSettingsPromissoryNote,
            PrintSalesFormletter,
            printerSettingsFormletterCopy
        #ENDMACRO

        #LOCALMACRO.ParmList_v5
            parmId,
            purchParmUpdate,
            QueryCriteria,
            Editing,
            Printout,
            PrintFormletter,
            PrinterSettingsFormLetter,
            printEuVatInvoice,
            printerSettingsEuVatInvoice,
            printerSettingsPromissoryNote,
            PrintSalesFormletter,
            printerSettingsFormletterCopy,
            saveChanges,
            usePrintManagement
        #ENDMACRO

        switch (version)
        {
            case #InvoiceVersion:
                [version, #ParmListPurchInvoice, packedBase] = _packedClass;
                return super(packedBase);

            case 1002:
                [version, #ParmListPurchInvoice, packedBase] = _packedClass;
                return super(packedBase);
                
            case 1001:
                [version, #ParmListPurchInvoice, packedBase] = _packedClass;
                activeInvoiceFlags = 0;
                return super(packedBase);

            case 10+1 /*case is old currentversion + old parentversion*/ :
                [version, #parmList_v5] = _packedClass;
                this.setNewContract(PurchFormLetterInvoiceContract::construct());

                contractIsFromPreviousVersion = true;
                this.parmId(parmId);
                this.purchParmUpdate(purchParmUpdate);
                this.printout(printout);
                this.printFormLetter(printFormletter);
                this.updatePrinterSettingsFormLetter(printerSettingsFormletter, PrintSetupOriginalCopy::Original);
                this.updatePrinterSettingsFormLetter(printerSettingsFormletterCopy, PrintSetupOriginalCopy::Copy);
                this.usePrintManagement(usePrintManagement);
                this.printSalesFormLetter(printSalesFormletter);
                this.parmSaveChanges(saveChanges);
                this.updatePrinterSettingsEUVatInvoice(printerSettingsEuVatInvoice);
                this.printEUVatInvoice(printEUVatInvoice);
                break;

            case 9:
                [version, #ParmList_v40] = _packedClass;
                break;

            case 8:
                [version, #ParmList_v30] = _packedClass;
                printerSettingsFormLetterCopy = printerSettingsFormLetter;
                break;

            case 5:
                [version, #ParmList_v25sp2] = _packedClass;
                break;

            default :
                return super(_packedClass);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateParmTableWithErrors</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates a <c>VendInvoiceInfo</c> record with the specified log text.
    /// </summary>
    /// <param name="_logText">
    ///    The log text to assign to the <c>VendInvoiceInfo</c> record.
    /// </param>
    public void updateParmTableWithErrors(LogText _logText)
    {
        parmTable = VendInvoiceInfoTable::findRecId(parmTable.RecId, true);
        parmTable.Log = _logText;
        parmTable.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePrinterSettingsEUVatInvoice</Name>
				<Source><![CDATA[
    protected void updatePrinterSettingsEUVatInvoice(container _printerSettings)
    {
        purchFormLetterInvoiceContract.parmPrinterSettingsEuVatInvoice(SysOperationHelper::base64Encode(_printerSettings));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if it is ok to continue.
    /// </summary>
    /// <param name="_calledFrom">
    /// Identifies the object from which this method is called. The default value is null.
    /// </param>
    /// <returns>
    /// true if it is ok to continue; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The validate method is used for validating if it is ok to close the purchase posting form when you
    /// post purchase orders.
    /// </remarks>
    boolean validate(Object _calledFrom = null)
    {
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        boolean countryRegion_BR = BrazilParameters::isEnabled();
        boolean ret;

        if (countryRegion_BR)
        {
            if (!this.validateAccessKey_BR())
            {
                return false;
            }
        }

        ret = super(_calledFrom);

        if (ret)
        {
            ret = this.validateBankLC();
        }

        if (ret && this.reArrangeNow())
        {
            ret = this.checkTaxWorkRegulation();
            ret = this.checkPaymentSchedule() && ret;
        }

        if (countryRegion_BR)
        {
            ret = this.validate_BR() && ret;
        }

        if (countryRegion_RU)
        {
            ret = AlcoholLicenseTable_RU::checkAlcoholLicenseSeriesNumInInvoice(this.purchTable().vendTable_InvoiceAccount(), this.purchParmUpdate().ParmId) && ret;
        }

        if (ret && !countryRegion_RU)
        {
            ret = this.checkCreditCorrection();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates all <c>vendInvoiceInfoTable</c> records of the posting
    /// </summary>
    /// <returns>
    /// True when validated, otherwise false
    /// </returns>
    public boolean validate_BR()
    {
        boolean ret = true;
        VendInvoiceInfoTable vendInvoiceInfoTable;

        while select vendInvoiceInfoTable
              where vendInvoiceInfoTable.ParmId == this.parmId()
        {
            setPrefix(strFmt("@SYS27357", vendInvoiceInfoTable.PurchId));

            ret = this.validateVendInvoiceInfoTable_BR(vendInvoiceInfoTable);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAccessKey_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// For each invoice to be posted, checks if access key is mandatory and valid.
    /// </summary>
    /// <returns>
    /// True if access key is valid or not mandatory for all invoices.
    /// </returns>
    protected boolean validateAccessKey_BR()
    {
        boolean ret = true;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceInfoTable_W vendInvoiceInfoTable_W;

        while select vendInvoiceInfoTable
              where vendInvoiceInfoTable.ParmId == this.parmId()
        {
            setPrefix(strFmt("@SYS27357", vendInvoiceInfoTable.PurchId));

            vendInvoiceInfoTable_W = vendInvoiceInfoTable.vendInvoiceInfoTable_W();

            if (vendInvoiceInfoTable_W.mustHaveAccessKey() &&
                !vendInvoiceInfoTable.purchTable().purchTable_BR().isCancellingOrReversingFiscalDocument())
            {
                if (!EFDocAccessKeyBase_BR::validate(vendInvoiceInfoTable_W.AccessKey_BR))
                {
                    ret = checkFailed("@SYS4110579");
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBankLC</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that a Letter of Credit required information is attached correctly with the invoice or
    /// not.
    /// </summary>
    /// <returns>
    /// true if the validation is ok; otherwise, false
    /// </returns>
    private boolean validateBankLC()
    {
        boolean ret = true;

        if (BankLCImportFeatureChecker::checkBankLCImportEnabled()
            && !this.proforma())
        {
            ret = BankLCImportType::validateInvoices(this.purchParmUpdate().ParmId);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDirectImport_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the invoice is valid in the direct import context.
    /// </summary>
    /// <param name="_vendInvoiceInfoTable">
    /// The <c>VendInvoiceInfoTable</c> of the current invoice.
    /// </param>
    /// <returns>
    /// True if it is valid; otherwise, false.
    /// </returns>
    protected boolean validateDirectImport_BR(VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        boolean ok = true;

        if (this.invoiceHasLinesWithGoods_BR(_vendInvoiceInfoTable)
            && _vendInvoiceInfoTable.isForeignerVendor_BR()
            && _vendInvoiceInfoTable.purchTable().PurchaseType != PurchaseType::ReturnItem
            && this.purchParmUpdate().numberOfTables() == 1)
        {
            if (!_vendInvoiceInfoTable.vendInvoiceInfoTable_W().ImportDeclaration_BR)
            {
                ok = checkFailed("@SYS4081911");
            }

            if (!this.validateLinesWithGoodsHaveDiAddition_BR(_vendInvoiceInfoTable))
            {
                ok = checkFailed("@SYS4081912");
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLinesWithGoodsHaveDiAddition_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that all lines with goods in the given invoice have DI addition.
    /// </summary>
    /// <param name="_vendInvoiceInfoTable">
    /// The <c>VendInvoiceInfoTable</c> of the current invoice.
    /// </param>
    /// <returns>
    /// Whether all goods lines have DI addition or not.
    /// </returns>
    protected boolean validateLinesWithGoodsHaveDiAddition_BR(VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        VendInvoiceInfoLine_W vendInvoiceInfoLine_W;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        InventTable inventTable;

        select firstonly RecId from vendInvoiceInfoLine_W
        exists join vendInvoiceInfoLine
            where vendInvoiceInfoLine.RecId == vendInvoiceInfoLine_W.VendInvoiceInfoLine &&
                vendInvoiceInfoLine.ParmId == _vendInvoiceInfoTable.ParmId &&
                vendInvoiceInfoLine.TableRefId == _vendInvoiceInfoTable.TableRefId
        exists join inventTable
            where inventTable.ItemId == vendInvoiceInfoLine.ItemId &&
                inventTable.ItemType == ItemType::Item &&
                vendInvoiceInfoLine_W.diAddition_BR == '';

        return !vendInvoiceInfoLine_W;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVoucherSeries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates voucher series.
    /// </summary>
    /// <returns>
    /// Always true.
    /// </returns>
    protected boolean validateVoucherSeries()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMatchStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that matching has been run when we are attempting to post and On demand matching is active. If matching has not been run,
    /// then a message is displayed.
    /// </summary>
    /// <returns>
    /// true if matching has been run; otherwise, false.
    /// </returns>
    public boolean validateMatchStatus()
    {
        VendParameters vendParameters = VendParameters::find();
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceInfoSubTable vendInvoiceInfoSubTable;
        boolean hasBeenMatched = true;

        if (vendParameters.editUseInvoiceMatching() && !vendParameters.editAutomaticHeaderMatching() &&
            vendParameters.PostInvoiceMatchDiscrepancies == InvoiceMatchPostingOption::AllowWithWarning)
        {
            select firstonly RecId from vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == this.parmId()
                    && vendInvoiceInfoTable.LastMatchVariance == LastMatchVarianceOptions::Unknown
                    && vendInvoiceInfoTable.Hold == NoYes::No
            exists join vendInvoiceInfoSubTable
                where vendInvoiceInfoSubTable.ParmId == vendInvoiceInfoTable.ParmId
                    && vendInvoiceInfoSubTable.TableRefId == vendInvoiceInfoTable.TableRefId
                    && vendInvoiceInfoSubTable.OrigPurchId != '';

            if (vendInvoiceInfoTable.RecId)
            {
                error(strFmt("@AccountsPayable:InvoiceMatchingNotPerformedMustPost", "@AccountsPayable:MatchStatus"));
                hasBeenMatched = false;
            }
        }

        return hasBeenMatched;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVendInvoiceInfoTable_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates a single <c>vendInvoiceInfoTable</c> record
    /// </summary>
    /// <param name="_vendInvoiceInfoTable">
    /// The <c>VendInvoiceInfoTable</c> to be validated
    /// </param>
    /// <returns>
    /// True when validated, otherwise false
    /// </returns>
    protected boolean validateVendInvoiceInfoTable_BR(VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        boolean ok = true;

        if (_vendInvoiceInfoTable.IsTheFiscalDocumentIssuer_BR())
        {
            if (!_vendInvoiceInfoTable.vendInvoiceInfoTable_W().FiscalDocumentType_BR)
            {
                ok = checkFailed("@GLS62");
            }
        }
        else
        {
            if (!_vendInvoiceInfoTable.vendInvoiceInfoTable_W().FiscalDocumentModel_BR)
            {
                ok = checkFailed(strFmt("@SYS84378", fieldPName(VendInvoiceInfoTable_W, FiscalDocumentModel_BR)));
            }

            if (!this.isInvoiceNumberNumericOnly_BR(_vendInvoiceInfoTable.Num))
            {
                ok = checkFailed("@GLS63680");
            }
        }

        ok = this.validateDirectImport_BR(_vendInvoiceInfoTable) && ok;

        if (conLen(_vendInvoiceInfoTable.getFiscalEstablishment()) > 1)
        {
            ok = checkFailed("@GLS221859");
        }

        ok = _vendInvoiceInfoTable.validateLineDeliveryAddress_BR() && ok;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>callPrinterSettingsEUVatInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Allows the user to modify the printer settings for EU VAT invoices using the standard print job
    ///    settings dialog box.
    /// </summary>
    /// <param name="_purchFormLetter">
    ///    The <c>PurchFormLetter_Invoice</c> class in which the printer settings for EU VAT invoices are being
    ///    modified.
    /// </param>
    /// <returns>
    ///    true if the settings were modified; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The <c>callPrinterSettingsFormLetter</c> method is static so that users can select AOS printers.
    ///    Selecting AOS printers requires that the <c>SysPrintForm</c> is called from the server.
    /// </remarks>
    static boolean callPrinterSettingsEUVatInvoice(PurchFormLetter_Invoice _purchFormLetter)
    {
        SRSPrintDestinationSettings printSettings = new SRSPrintDestinationSettings(_purchFormLetter.printerSettingsEUVatInvoice());
        boolean ok = SrsReportRunUtil::showSettingsDialog(printSettings);

        _purchFormLetter.updatePrinterSettingsEUVatInvoice(printSettings.pack());

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkParmTable</Name>
				<Source><![CDATA[
    static container checkParmTable(Num parmId,
                                           boolean vendAccountInQuery,
                                           boolean invoiceAccountInQuery)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        Counter numOfAccounts = 0;
        Counter numOfCurrency = 0;

        if (vendAccountInQuery)
        {
            while select vendInvoiceInfoTable
                      group by OrderAccount
                      where vendInvoiceInfoTable.ParmId == parmId
            {
                numOfAccounts++;
            }
        }

        if (invoiceAccountInQuery)
        {
            while select vendInvoiceInfoTable
                      group by InvoiceAccount
                      where vendInvoiceInfoTable.ParmId == parmId
            {
                numOfAccounts++;
            }
        }

        while select vendInvoiceInfoTable
                  group by CurrencyCode
                  where vendInvoiceInfoTable.ParmId == parmId
        {
            numOfCurrency++;
        }

        return [numOfAccounts, numOfCurrency];
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static ClassDescription description()
    {
        return "@SYS23176";
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromSavedInvoice</Name>
				<Source><![CDATA[
    public static PurchFormLetter_Invoice newFromSavedInvoice(VendInvoiceInfoTable _savedInvoice)
    {
        Map mapSavedInvoiceRecord;
        SysQueryRun emptyChooseLines = null;
        PurchFormLetter_Invoice purchFormLetterInvoice;

        purchFormLetterInvoice = PurchFormLetter::construct(DocumentStatus::Invoice);

        mapSavedInvoiceRecord = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record);
        mapSavedInvoiceRecord.insert(_savedInvoice.RecId, _savedInvoice);
        purchFormLetterInvoice.parmDataSourceRecordsPacked(mapSavedInvoiceRecord.pack());

        purchFormLetterInvoice.parmCallerTable(_savedInvoice);
        purchFormLetterInvoice.parmCallerMenuItem('');
        purchFormLetterInvoice.currentPurchParmTable();
        purchFormLetterInvoice.chooseLinesQuery(emptyChooseLines);
        purchFormLetterInvoice.setQueryRangePendingInvoice(_savedInvoice);
        purchFormLetterInvoice.showQueryForm(false);

        purchFormLetterInvoice.initNewFromSaved(_savedInvoice);

        return purchFormLetterInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInvoice</Name>
				<Source><![CDATA[
    static public PurchFormLetter_Invoice newInvoice(
        IdentifierName _className = classStr(FormletterService),
        IdentifierName _methodName = methodStr(FormletterService, postPurchaseOrderInvoice),
        SysOperationExecutionMode _executionMode = SysOperationExecutionMode::Synchronous)
    {
        PurchFormLetter_Invoice formletter = PurchFormLetter_Invoice::construct(_className, _methodName, _executionMode);
        formletter.init();
        return formletter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSelectedActiveInvoices</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the list of selected orphaned invoices
    /// </summary>
    /// <param name="_selectedActiveInvoice">
    /// list of selected active invoice recId's
    /// </param>
    /// <param name="_parmId">
    /// ParmId of the current session.
    /// </param>
    private static void processSelectedActiveInvoices(List _selectedActiveInvoice, ParmId _parmId)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        PurchParmUpdate purchParmUpdate;
        int invoiceCount;
        ListEnumerator savedActiveInvoiceListEnumerator;

        savedActiveInvoiceListEnumerator = _selectedActiveInvoice.getEnumerator();

        ttsbegin;

        while (savedActiveInvoiceListEnumerator.moveNext())
        {
            vendInvoiceInfoTable = VendInvoiceInfoTable::findRecId(savedActiveInvoiceListEnumerator.current(), true);
            if (VendInvoiceInfoTable::existSaved(vendInvoiceInfoTable.TableRefId))
            {
                // We don't expect saved AND active to exist, but this is here to correct any legacy data in this scenario
                // For each invoice the user selected, if it has a saved record delete the orphaned active record and create a new one to edit
                purchParmUpdate = PurchParmUpdate::find(vendInvoiceInfoTable.ParmId, true);
                invoiceCount = purchParmUpdate.numberOfTables();

                if (invoiceCount == 1)
                {
                    purchParmUpdate.delete();
                }
                else
                {
                    vendInvoiceInfoTable.delete();
                }

                VendInvoiceInfoTable::moveFromSavedToActive(VendInvoiceInfoTable::find('', vendInvoiceInfoTable.TableRefId), _parmId);
            }
            else
            {
                // For each invoice the user selected, if it doesn't have a saved record set the ParmId to current ParmId for the invoice.
                vendInvoiceInfoTable.resetParmId(_parmId);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDataSourceRecordsPacked</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method retrieves a map of the saved invoice records.
    /// </summary>
    /// <param name="_vendInvoiceInfoTable">
    /// The saved invoice record.
    /// </param>
    /// <returns>
    /// This method returns a map of the saved invoice records.
    /// </returns>
    protected Map initDataSourceRecordsPacked(VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        Map mapSavedInvoiceRecord;

        mapSavedInvoiceRecord = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record);

        mapSavedInvoiceRecord.insert(_vendInvoiceInfoTable.RecId, _vendInvoiceInfoTable);
        this.setQueryRangePendingInvoice(_vendInvoiceInfoTable);

        return mapSavedInvoiceRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePurchTableSet_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate the purch table set according to summary update mandatory fields.
    /// </summary>
    /// <param name = "origPurchSubTableSet">Set of purchase orders to be validated</param>
    /// <returns>Returns true if the purch table set is correct regarding the summary update parameters; otherwise, false.</returns>
    protected boolean validatePurchTableSet_BR(Set origPurchSubTableSet)
    {
        boolean			isFirstValidation = true;
        Enumerator		purchEnumerator = origPurchSubTableSet.getEnumerator();
        container		summaryUpdateFields = PurchSummaryParameters::summaryFieldIdList();
        PurchTable		firstPO;
        PurchSummary	summary = new PurchSummary_None('', '', DocumentStatus::Invoice);

        while (purchEnumerator.moveNext())
        {
            PurchId purchId = purchEnumerator.current();
            PurchTable purchTable = PurchTable::find(purchId);

            if (isFirstValidation)
            {
                isFirstValidation = false;
                firstPO = purchTable;
            }
            else
            {
                for (var pos = 1; pos <= conlen(summaryUpdateFields); pos++)
                {
                    var fieldId = conPeek(summaryUpdateFields, pos);
                    if (!summary.areFieldsEqual(purchTable, firstPO, fieldId))
                    {
                        return checkFailed("@Brazil:TaskButtonOkAssociatePOWithDifferentSummaryUpdateValues");
                    }
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return this.checkRunInNewSession();
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        using (var activityContext = instrumentationLogger.purchFormLetterInstrumentationActivities().purchPostInvoiceMultiOrders(this.parmBatchJobId(), this.lateSelection()))
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchInfo</Name>
				<Source><![CDATA[
    public BatchInfo batchInfo()
    {
        BatchInfo localBatchInfo = super();
        if (PurchFormLetterInvoiceDisableRetriesWhenFailedInBatchFlight::instance().isEnabled())
        {
            localBatchInfo.parmRetriesOnFailure(0);
        }

        return localBatchInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorMessageHelpScopeShowLink</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean errorMessageHelpScopeShowLink()
    {
        if (PurchFormLetterErrorMessageHelpScopeInvoiceFlight::instance().isEnabled())
        {
            return super();
        }

        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>