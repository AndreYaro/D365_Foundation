<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>GeneralLedgerExtension</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System.ComponentModel.Composition;

/// <summary>
/// A collection of general ledger extensions.
/// </summary>
[ExportMetadataAttribute("GeneralLedger", "GeneralLedger"),ExportAttribute("Dynamics.AX.Application.GeneralLedgerIExtension")]
public class GeneralLedgerExtension implements GeneralLedgerIExtension
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>deleteForAcctDatePeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the <c>LedgerEntry</c> records with the specified accounting date
    /// and fiscal calendar period.
    /// </summary>
    /// <param name="_accountingDate">
    /// The accounting date.
    /// </param>
    /// <param name="_fiscalCalendarPeriodRecId">
    /// The fiscal calendar period.
    /// </param>
    /// <remarks>
    /// The <c>deleteForAcctDatePeriod</c>
    /// method on the <c>GeneralJournalAccountEntry</c> table is for general use
    /// and cascades to related tables.
    /// </remarks>
    public void deleteForAcctDatePeriod(TransDate _accountingDate,FiscalCalendarPeriodRecId _fiscalCalendarPeriodRecId)
    {
        LedgerEntry::deleteForAcctDatePeriod(_accountingDate, _fiscalCalendarPeriodRecId);
        GeneralJournalAccountEntry_W::deleteForAcctDatePeriod(_accountingDate, _fiscalCalendarPeriodRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForAcctDatePeriodExclPostType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the <c>LedgerEntry</c> records with the specified accounting date
    /// and fiscal calendar period, excluding records with specified posting type.
    /// </summary>
    /// <param name="_accountingDate">
    /// The accounting date.
    /// </param>
    /// <param name="_fiscalCalendarPeriodRecId">
    /// The fiscal calendar period.
    /// </param>
    /// <param name="_postingTypeToExclude">
    /// The posting type to exclude.
    /// </param>
    /// <remarks>
    /// The <c>deleteForAcctDatePeriodExclPostType</c>
    /// method on the <c>GeneralJournalAccountEntry</c> table is for general use
    /// and cascades to related tables.
    /// </remarks>
    public void deleteForAcctDatePeriodExclPostType(TransDate _accountingDate,FiscalCalendarPeriodRecId _fiscalCalendarPeriodRecId,LedgerPostingType _postingTypeToExclude)
    {
        LedgerEntry::deleteForAcctDatePeriodExclPostType(_accountingDate, _fiscalCalendarPeriodRecId, _postingTypeToExclude);
        GeneralJournalAccountEntry_W::deleteForAcctDatePeriodExclPostType(_accountingDate, _fiscalCalendarPeriodRecId, _postingTypeToExclude);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForAcctDatePeriodPostType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the <c>LedgerEntry</c> records that have the specified accounting date, fiscal
    /// calendar period, and posting type.
    /// </summary>
    /// <param name="_accountingDate">
    /// The accounting date.
    /// </param>
    /// <param name="_fiscalCalendarPeriodRecId">
    /// The fiscal calendar period.
    /// </param>
    /// <param name="_postingType">
    /// The posting type.
    /// </param>
    /// <remarks>
    /// The <c>deleteForAcctDatePeriodPostType</c>
    /// method on the <c>GeneralJournalAccountEntry</c> table is for general use
    /// and cascades to related tables.
    /// </remarks>
    public void deleteForAcctDatePeriodPostType(TransDate _accountingDate,FiscalCalendarPeriodRecId _fiscalCalendarPeriodRecId,LedgerPostingType _postingType)
    {
        LedgerEntry::deleteForAcctDatePeriodPostType(_accountingDate, _fiscalCalendarPeriodRecId, _postingType);
        GeneralJournalAccountEntry_W::deleteForAcctDatePeriodPostType(_accountingDate, _fiscalCalendarPeriodRecId, _postingType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForFundAcctDatePeriodPostType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the <c>LedgerEntry</c> records with the specified accounting date,
    /// range of funds and fiscal calendar period, excluding records with specified
    /// posting type.
    /// </summary>
    /// <param name="_fromFund">
    /// The start fund number.
    /// </param>
    /// <param name="_toFund">
    /// The end fund number.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date.
    /// </param>
    /// <param name="_fiscalCalendarPeriodRecId">
    /// The fiscal calendar period.
    /// </param>
    /// <param name="_postingType">
    /// The posting type.
    /// </param>
    /// <remarks>
    /// The <c>deleteForFundAcctDatePeriodPostType</c>
    /// method on the <c>GeneralJournalAccountEntry</c> table is for general use
    /// and cascades to related tables.
    /// </remarks>
    public void deleteForFundAcctDatePeriodPostType(
        FundNumber                  _fromFund,
        FundNumber                  _toFund,
        TransDate                   _accountingDate,
        FiscalCalendarPeriodRecId   _fiscalCalendarPeriodRecId,
        LedgerPostingType           _postingType)
    {
        LedgerEntry::deleteForFundAcctDatePeriodPostType(_fromFund, _toFund, _accountingDate, _fiscalCalendarPeriodRecId, _postingType);
        GeneralJournalAccountEntry_W::deleteForFundAcctDatePeriodPostType(_fromFund, _toFund, _accountingDate, _fiscalCalendarPeriodRecId, _postingType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForPostType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the <c>LedgerEntry</c> records with either of the specified posting types.
    /// </summary>
    /// <param name="_firstPostingType">
    /// The first posting type.
    /// </param>
    /// <param name="_secondPostingType">
    /// The second posting type.
    /// </param>
    /// <remarks>
    /// The <c>deleteForPostType</c>
    /// method on the <c>GeneralJournalAccountEntry</c> table is for general use
    /// and cascades to related tables.
    /// </remarks>
    public void deleteForPostType(LedgerPostingType _firstPostingType, LedgerPostingType _secondPostingType)
    {
        LedgerEntry::deleteForPostType(_firstPostingType, _secondPostingType);
        GeneralJournalAccountEntry_W::deleteForPostType(_firstPostingType, _secondPostingType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForTransferId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the <c>LedgerEntry</c> records for the specified transfer ID.
    /// </summary>
    /// <param name="_transferId">
    /// The transfer ID.
    /// </param>
    /// <remarks>
    /// The <c>deleteForTransferId</c>
    /// method on the <c>GeneralJournalAccountEntry</c> table is for general use
    /// and cascades to related tables.
    /// </remarks>
    public void deleteForTransferId(SubledgerJournalTransferId _transferId)
    {
        LedgerEntry::deleteForTransferId(_transferId);
        GeneralJournalAccountEntry_W::deleteForTransferId(_transferId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFundAcctDatePeriodExclPostType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the <c>LedgerEntry</c> records with the specified accounting date,
    /// range of funds and fiscal calendar period, excluding records with specified
    /// posting type.
    /// </summary>
    /// <param name="_fromFund">
    /// The start fund number.
    /// </param>
    /// <param name="_toFund">
    /// The end fund number.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date.
    /// </param>
    /// <param name="_fiscalCalendarPeriodRecId">
    /// The fiscal calendar period.
    /// </param>
    /// <param name="_postingTypeToExclude">
    /// The posting type to exclude.
    /// </param>
    /// <remarks>
    /// The <c>deleteFundAcctDatePeriodExclPostType</c>
    /// method on the <c>GeneralJournalAccountEntry</c> table is for general use
    /// and cascades to related tables.
    /// </remarks>
    public void deleteFundAcctDatePeriodExclPostType(
        FundNumber                  _fromFund,
        FundNumber                  _toFund,
        TransDate                   _accountingDate,
        FiscalCalendarPeriodRecId   _fiscalCalendarPeriodRecId,
        LedgerPostingType           _postingTypeToExclude)
    {
        LedgerEntry::deleteFundAcctDatePeriodExclPostType(
            _fromFund, _toFund, _accountingDate, _fiscalCalendarPeriodRecId, _postingTypeToExclude);
        GeneralJournalAccountEntry_W::deleteFundAcctDatePeriodExclPostType(
            _fromFund, _toFund, _accountingDate, _fiscalCalendarPeriodRecId, _postingTypeToExclude);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateReferenceNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if the subledger voucher and accounting date are valid.
    /// </summary>
    /// <param name="_fiscalCalendarRecId">
    /// The foreign key to the fiscal calendar.
    /// </param>
    /// <param name="_reuseVoucher">
    /// The reuse voucher option.
    /// </param>
    /// <param name="_subledgerVoucher">
    /// The subledger voucher to validate.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date to validate.
    /// </param>
    /// <param name="_subledgerVoucherDataAreaId">
    /// The data area ID of the subledger voucher.
    /// </param>
    /// <param name="_checkSubledgerJournalForCustomer">
    /// Indicates whether to check the customer subledger journal for an allowed
    /// duplicate; optional.
    /// </param>
    /// <param name="_checkSubledgerJournalForVendor">
    /// Indicates whether to check the vendor subledger journal for an allowed
    /// duplicate; optional.
    /// </param>
    /// <param name="_isSubledgerJournalExpectedToExist">
    /// Indicates whether to check whether the subledger journal exists or does
    /// not exist; optional.
    /// </param>
    /// <param name="_sourceDocumentHeaderRecId">
    /// The record ID of the source document header associated with the voucher.; optional.
    /// </param>
    /// <param name="_skipDuplicateVoucherCheck">
    /// Indicates whether checking for duplicate vouchers won't be performed; optional.
    /// </param>
    /// <returns>
    /// true if the subledger voucher and accounting date are valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// A valid subledger voucher and accounting date are available for ledger
    /// posting. Checking the subledger journal assumes there is exactly one
    /// additional subledger voucher.
    /// </remarks>
    public static boolean validateReferenceNumber(
        RecId _fiscalCalendarRecId,
        ReuseVoucher _reuseVoucher,
        Voucher _subledgerVoucher,
        TransDate _accountingDate,
        CompanyId _subledgerVoucherDataAreaId = curext(),
        boolean _checkSubledgerJournalForCustomer = false,
        boolean _checkSubledgerJournalForVendor = false,
        boolean _isSubledgerJournalExpectedToExist = false,
        SourceDocumentHeaderRecId _sourceDocumentHeaderRecId = 0,
        boolean _skipDuplicateVoucherCheck = false)
    {
        SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;
        int64 voucherLinkCount;
        boolean isSameSourceDocumentHeader;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        Common common;

        boolean isValid = true;

        if (_reuseVoucher != ReuseVoucher::AcceptDuplicate)
        {
            select count(RecId) from subledgerVoucherLink
                where subledgerVoucherLink.Voucher == _subledgerVoucher
                    && subledgerVoucherLink.VoucherDataAreaId == _subledgerVoucherDataAreaId;

            voucherLinkCount = subledgerVoucherLink.RecId;

            if (voucherLinkCount > 0)
            {
                if (_sourceDocumentHeaderRecId)
                {
                    // check if a subledger voucher link already exists for the source document header
                    // because multiples to the same source document header  are allowed
                    isSameSourceDocumentHeader = GeneralLedgerExtension::isSourceDocumentHeaderRelatedToVoucher(_sourceDocumentHeaderRecId, _subledgerVoucher, _subledgerVoucherDataAreaId);

                    if (!isSameSourceDocumentHeader)
                    {
                        common = SourceDocumentHeader::find(_sourceDocumentHeaderRecId).getSourceDocumentImplementation();

                        if (common.TableId  == tableNum(VendInvoiceInfoTable))
                        {
                            vendInvoiceInfoTable = common as VendInvoiceInfoTable;
                            if (vendInvoiceInfoTable.Ordering == DocumentStatus::ApproveJournal)
                            {
                                isSameSourceDocumentHeader = true;
                            }
                        }
                    }
                }
                else
                {
                    isSameSourceDocumentHeader = false;
                }

                if (!isSameSourceDocumentHeader)
                {
                    isValid = GeneralLedgerExtension::checkVoucher(
                        _fiscalCalendarRecId,
                        _reuseVoucher,
                        _skipDuplicateVoucherCheck,
                        _subledgerVoucher,
                        _accountingDate,
                        _checkSubledgerJournalForCustomer,
                        _checkSubledgerJournalForVendor,
                        _subledgerVoucherDataAreaId,
                        _isSubledgerJournalExpectedToExist,
                        voucherLinkCount);
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the voucher is valid for ledger posting.
    /// </summary>
    /// <param name = "_fiscalCalendarRecId">
    /// The foreign key to the fiscal calendar.
    /// </param>
    /// <param name = "_reuseVoucher">
    /// The reuse voucher option.
    /// </param>
    /// <param name = "_skipDuplicateVoucherCheck">
    /// Indicates whether checking for duplicate vouchers won't be performed; optional.
    /// </param>
    /// <param name = "_subledgerVoucher">
    /// The subledger voucher to validate.
    /// </param>
    /// <param name = "_accountingDate">
    /// The accounting date to validate.
    /// </param>
    /// <param name = "_checkSubledgerJournalForCustomer">
    /// Indicates whether to check the customer subledger journal for an allowed duplicate.
    /// </param>
    /// <param name = "_checkSubledgerJournalForVendor">
    /// Indicates whether to check the vendor subledger journal for an allowed duplicate.
    /// </param>
    /// <param name = "_subledgerVoucherDataAreaId">
    /// The data area ID of the subledger voucher.
    /// </param>
    /// <param name = "_isSubledgerJournalExpectedToExist">
    /// Indicates whether to check whether the subledger journal exists or does not exist.
    /// </param>
    /// <param name = "_voucherLinkCount">
    /// Number of <c>SubledgerVoucherGeneralJournalEntry</c> records.
    /// </param>
    /// <returns>
    /// true if the voucher and accounting date is valid; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected static final boolean checkVoucher(
        RecId _fiscalCalendarRecId,
        ReuseVoucher _reuseVoucher,
        boolean _skipDuplicateVoucherCheck,
        Voucher _subledgerVoucher,
        TransDate _accountingDate,
        boolean _checkSubledgerJournalForCustomer,
        boolean _checkSubledgerJournalForVendor,
        CompanyId _subledgerVoucherDataAreaId,
        boolean _isSubledgerJournalExpectedToExist,
        int64 _voucherLinkCount)
    {
        boolean isValid = true;
        GeneralJournalEntry generalJournalEntry;

        switch (_reuseVoucher)
        {
            case ReuseVoucher::WarnDuplicate:
                if (!_skipDuplicateVoucherCheck)
                {
                    warning(strFmt("@SYS573", _subledgerVoucher, date2StrUsr(_accountingDate, DateFlags::FormatAll)));
                }
                break;

            case ReuseVoucher::NoDuplicate:
                if (!_skipDuplicateVoucherCheck)
                {
                    isValid = false;

                    if (_checkSubledgerJournalForCustomer && _voucherLinkCount >= 1)
                    {
                        isValid = CustTrans::existForSubledgerJournal(_subledgerVoucher, _subledgerVoucherDataAreaId, _accountingDate, !_isSubledgerJournalExpectedToExist);
                    }

                    if (_checkSubledgerJournalForVendor && _voucherLinkCount >= 1)
                    {
                        isValid = VendTrans::existForSubledgerJournal(_subledgerVoucher, _subledgerVoucherDataAreaId, _accountingDate, !_isSubledgerJournalExpectedToExist);
                    }

                    if (!isValid)
                    {
                        generalJournalEntry = GeneralLedgerExtension::findBySubledgerVoucher(_subledgerVoucher, _subledgerVoucherDataAreaId);
                        isValid = AifFault::checkFailedLogFault(literalStr("@SYS573"), '', '', [_subledgerVoucher, date2StrUsr(generalJournalEntry.AccountingDate, DateFlags::FormatAll)]);

                        LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorDuplicateVoucher);
                    }
                }
                break;

            case ReuseVoucher::NoDuplicateInYear:
                if (!_skipDuplicateVoucherCheck)
                {
                    isValid = false;

                    if (_checkSubledgerJournalForCustomer && _voucherLinkCount == 1)
                    {
                        isValid = CustTrans::existForSubledgerJournal(_subledgerVoucher, _subledgerVoucherDataAreaId, _accountingDate, !_isSubledgerJournalExpectedToExist);
                    }

                    if (_checkSubledgerJournalForVendor && _voucherLinkCount == 1)
                    {
                        isValid = VendTrans::existForSubledgerJournal(_subledgerVoucher, _subledgerVoucherDataAreaId, _accountingDate, !_isSubledgerJournalExpectedToExist);
                    }

                    if (!isValid)
                    {
                        // Reset incase no duplicates are found and a date outside a calendar is valid until it falls into a calendar
                        isValid = true;

                        TransDate fiscalYearStartDate, fiscalYearEndDate;

                        fiscalYearStartDate = LedgerFiscalCalendar::findOpeningPeriodStartDateByDate(_fiscalCalendarRecId, _accountingDate);
                        fiscalYearEndDate = LedgerFiscalCalendar::findClosingPeriodEndDateByDate(_fiscalCalendarRecId, _accountingDate);

                        if (GeneralLedgerExtension::checkAccountingDateInFiscalYear(fiscalYearStartDate, fiscalYearEndDate, _accountingDate))
                        {
                            FiscalCalendarPeriod fiscalCalendarPeriod;
                            SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;

                            // report all duplicates dates for the fiscal year
                            while select AccountingDate from generalJournalEntry
                                where generalJournalEntry.Ledger == Ledger::current()
                                    exists join subledgerVoucherLink
                                        where subledgerVoucherLink.GeneralJournalEntry == generalJournalEntry.RecId
                                            && subledgerVoucherLink.Voucher == _subledgerVoucher
                                            && subledgerVoucherLink.VoucherDataAreaId == _subledgerVoucherDataAreaId
                                            && subledgerVoucherLink.AccountingDate >= fiscalYearStartDate
                                            && subledgerVoucherLink.AccountingDate <= fiscalYearEndDate
                                        exists join fiscalCalendarPeriod
                                            where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                                                && fiscalCalendarPeriod.Type == FiscalPeriodType::Operating
                            {
                                isValid = AifFault::checkFailedLogFault(literalStr("@SYS573"), '', '', [_subledgerVoucher, date2StrUsr(generalJournalEntry.AccountingDate, DateFlags::FormatAll)]);

                                LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorDuplicateVoucherInYear);
                            }
                        }
                    }
                }
                break;
            default:
                // make new enum values fail by default
                isValid = false;
                break;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAccountingDateInFiscalYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the Accounting date is in between fiscal year start date and end date.
    /// </summary>
    /// <param name = "_fiscalYearStartDate">
    /// The Fiscal year start date.
    /// </param>
    /// <param name = "_fiscalYearEndDate">
    /// The Fiscal year end date.
    /// </param>
    /// <param name = "_accountingDate">
    /// The Accounting date.
    /// </param>
    /// <returns>
    /// Returns true if the Accounting date is in between fiscal year start date and end date; otherwise, false.
    /// </returns>
    protected static boolean checkAccountingDateInFiscalYear(TransDate _fiscalYearStartDate, TransDate _fiscalYearEndDate, TransDate _accountingDate)
    {
        return (_fiscalYearStartDate != dateNull()
			&& _fiscalYearEndDate != dateNull()
			&& _accountingDate >= _fiscalYearStartDate
			&& _accountingDate <= _fiscalYearEndDate);
	}

]]></Source>
			</Method>
			<Method>
				<Name>isSourceDocumentHeaderRelatedToVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether a voucher or voucher data area ID combination is related to a source document header.
    /// </summary>
    /// <param name="_sourceDocumentHeaderRecId">
    /// The record ID of the source document header to check.
    /// </param>
    /// <param name="_subledgerVoucher">
    /// The voucher to check.
    /// </param>
    /// <param name="_subledgerVoucherDataAreaId">
    /// The data area ID that is associated with the voucher to check.
    /// </param>
    /// <returns>
    /// true if source document header is related to voucher; otherwise, false.
    /// </returns>
    public static boolean isSourceDocumentHeaderRelatedToVoucher(SourceDocumentHeaderRecId _sourceDocumentHeaderRecId, Voucher _subledgerVoucher, CompanyId _subledgerVoucherDataAreaId)
    {
        GeneralJournalEntry                 generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        SubledgerJournalAccountEntry        subledgerJournalAccountEntry;
        SubledgerJournalEntry               subledgerJournalEntry;
        AccountingEvent                     accountingEvent;
                
        select firstonly RecId from subledgerVoucherLink
            where subledgerVoucherLink.Voucher == _subledgerVoucher
                && subledgerVoucherLink.VoucherDataAreaId == _subledgerVoucherDataAreaId
        exists join generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherLink.GeneralJournalEntry
        exists join generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
        exists join subledgerJournalAccountEntry
            where subledgerJournalAccountEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
        exists join subledgerJournalEntry
            where subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
        exists join accountingEvent
            where accountingEvent.RecId == subledgerJournalEntry.AccountingEvent
                && accountingEvent.SourceDocumentHeader == _sourceDocumentHeaderRecId;        

        return (subledgerVoucherLink.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBySubledgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified GeneralJournalEntry record.
    /// </summary>
    /// <param name="_subledgerVoucher">
    /// The subledger voucher.
    /// </param>
    /// <param name="_subledgerVoucherDataAreaId">
    /// The data area ID of the subledger voucher.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether the record should be read for update; optional.
    /// </param>
    /// <returns>
    /// A GeneralJournalEntry record; otherwise, an empty record.
    /// </returns>
    /// <remarks>
    /// The record has to be in the current ledger.
    /// </remarks>
    public static GeneralJournalEntry findBySubledgerVoucher(Voucher _subledgerVoucher, DataAreaId _subledgerVoucherDataAreaId, boolean _forUpdate = false)
    {
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        generalJournalEntry.selectForUpdate(_forUpdate);

        if (_subledgerVoucher != '' && _subledgerVoucherDataAreaId != '')
        {
            select firstonly * from generalJournalEntry
                where generalJournalEntry.Ledger == Ledger::current()
            exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId
                    && subledgerVoucherGeneralJournalEntry.Voucher == _subledgerVoucher
                    && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == _subledgerVoucherDataAreaId;
        }

        return generalJournalEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findVoucher_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds voucher information.
    /// </summary>
    /// <param name="ledgerVoucherTypeRefRecId">
    /// The ledger voucher type ref RecId.
    /// </param>
    /// <param name="_voucher_CN">
    /// The voucher information.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <param name="_periodCode">
    /// The period code.
    /// </param>
    /// <returns>
    /// The instance of the <c>GeneralJournalEntry</c> class.
    /// </returns>
    public static GeneralJournalEntry findVoucher_CN(
        LedgerVoucherTypeRefRecId_CN    ledgerVoucherTypeRefRecId,
        Voucher_CN                      _voucher_CN,
        TransDate                       _transDate,
        FiscalPeriodType                _periodCode         = FiscalPeriodType::Operating)
    {
        RefRecId                numberSequenceTableRefRecId;
        boolean                 isRestart;
        GeneralJournalEntry     generalJournalEntry;
        GeneralJournalEntry_W   generalJournalEntry_W;
        FiscalCalendarPeriod    fiscalCalendarPeriod;
        FiscalCalendarYear      fiscalCalendarYear;
        FiscalCalendarRecId     fiscalCalendarRecId = CompanyInfoHelper::fiscalCalendarRecId();
        date                    startDateBasedTransDate = LedgerFiscalCalendar::findPeriodStartDateByDateWithIndex(fiscalCalendarRecId, _transDate);

        numberSequenceTableRefRecId = LedgerVoucherType_CN::find(ledgerVoucherTypeRefRecId).NumberSequenceTable;
        isRestart = NumberPeriod_CN::checkRestartNum(numberSequenceTableRefRecId);

        if (!isRestart)
        {
            select firstonly generalJournalEntry
                exists join generalJournalEntry_W
                    where generalJournalEntry_W.Voucher_CN == _voucher_CN
                        && generalJournalEntry_W.LedgerVoucherType_CN == ledgerVoucherTypeRefRecId
                        && generalJournalEntry_W.GeneralJournalEntry == generalJournalEntry.RecId
                exists join fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                        && fiscalCalendarPeriod.Type == _periodCode;
        }
        else
        {
            select firstonly generalJournalEntry
                exists join generalJournalEntry_W
                    where generalJournalEntry_W.Voucher_CN == _voucher_CN
                        && generalJournalEntry_W.LedgerVoucherType_CN == ledgerVoucherTypeRefRecId
                        && generalJournalEntry_W.GeneralJournalEntry == generalJournalEntry.RecId
            exists join fiscalCalendarPeriod
                where fiscalCalendarPeriod.StartDate            == startDateBasedTransDate
                   && fiscalCalendarPeriod.Type                 == _periodCode
                   && fiscalCalendarPeriod.StartDate            <= generalJournalEntry.AccountingDate
                   && fiscalCalendarPeriod.EndDate              >= generalJournalEntry.AccountingDate
            exists join fiscalCalendarYear
                where fiscalCalendarYear.RecId                  == fiscalCalendarPeriod.FiscalCalendarYear
                   && fiscalCalendarYear.FiscalCalendar         == fiscalCalendarRecId;
        }

        return generalJournalEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the accounting currency amount and reporting currency amount balances.
    /// </summary>
    /// <param name="_subledgerVoucher">
    /// The subledger voucher of the balance.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date of the balance.
    /// </param>
    /// <returns>
    /// The accounting currency amount and reporting currency amount balances in a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// The <paramref name="_subledgerVoucher"/> parameter is empty.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// The <paramref name="_accountingDate"/> parameter is empty.
    /// </exception>
    public static container getBalances(Voucher _subledgerVoucher, TransDate _accountingDate)
    {
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        SubledgerVoucherGeneralJournalEntry voucherLink;

        if (_subledgerVoucher == '')
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (_accountingDate == dateNull())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        select sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount) from generalJournalAccountEntry
            exists join generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()
            exists join voucherLink
                where voucherLink.GeneralJournalEntry == generalJournalEntry.RecId
                    && voucherLink.Voucher == _subledgerVoucher
                    && voucherLink.AccountingDate == _accountingDate;

        return [generalJournalAccountEntry.AccountingCurrencyAmount, generalJournalAccountEntry.ReportingCurrencyAmount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRelated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the records that are related to the <c>GeneralJournalAccountEntry</c> record.
    /// </summary>
    /// <param name="_generalJournalAccountEntryRecId">
    /// The record ID of a <c>GeneralJournalAccountEntry</c> record.
    /// </param>
    /// <returns>
    /// A container that has the <c>GeneralJournalHeader</c>, <c>GeneralJournalAccountEntry</c>,
    /// <c>LedgerEntryJournal</c>, <c>GeneralJournalEntry</c>, and <c>LedgerEntry</c> records; otherwise, a
    /// container of empty records.
    /// </returns>
    /// <remarks>
    /// _entry utility method should not be used for updates.
    /// </remarks>
    public static container findRelated(RecId _generalJournalAccountEntryRecId)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        LedgerEntry ledgerEntry;
        LedgerEntryJournal ledgerEntryJournal;
        GeneralJournalEntry generalJournalEntry;

        if (_generalJournalAccountEntryRecId != 0)
        {
            select firstonly generalJournalAccountEntry
                where generalJournalAccountEntry.RecId == _generalJournalAccountEntryRecId
            join generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry &&
                      generalJournalEntry.Ledger == Ledger::current()
            outer join ledgerEntry
                where ledgerEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
            outer join ledgerEntryJournal
                where ledgerEntryJournal.RecId == generalJournalEntry.LedgerEntryJournal;
        }

        return [generalJournalAccountEntry, ledgerEntryJournal, generalJournalEntry, ledgerEntry];
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByReferenceNumberAccountingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the GeneralJournalEntry table.
    /// </summary>
    /// <param name="_subledgerVoucher">
    /// The subledger voucher associated with the GeneralJournalEntry record.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date associated with the GeneralJournalEntry record.
    /// </param>
    /// <param name="_forupdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model option to use when reading the record; optional.
    /// </param>
    /// <returns>
    /// A record in the GeneralJournalEntry table; otherwise, an empty record.
    /// </returns>
    public static GeneralJournalEntry findByReferenceNumberAccountingDate(
        Voucher _subledgerVoucher,
        TransDate _accountingDate,
        boolean _forupdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry voucherLink;

        generalJournalEntry.selectForUpdate(_forupdate);

        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            generalJournalEntry.concurrencyModel(_concurrencyModel);
        }

        select firstonly * from generalJournalEntry
            exists join voucherLink
                where voucherLink.GeneralJournalEntry == generalJournalEntry.RecId
                    && voucherLink.Voucher == _subledgerVoucher
                    && voucherLink.AccountingDate == _accountingDate;

        return generalJournalEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBySubledgerVoucherAccountingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the GeneralJournalEntry table.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher associated with the GeneralJournalEntry table.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date associated with the GeneralJournalEntry table.
    /// </param>
    /// <param name="_forupdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model option to use when reading the record; optional.
    /// </param>
    /// <returns>
    /// A record in the GeneralJournalEntry table; otherwise, an empty record.
    /// </returns>
    /// <remarks>
    /// _entry utility method should not be used for updates.
    /// </remarks>
    public static GeneralJournalEntry findBySubledgerVoucherAccountingDate(Voucher _voucher,
        AccountingDate _accountingDate,
        boolean _forupdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        generalJournalEntry.selectForUpdate(_forupdate);

        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            generalJournalEntry.concurrencyModel(_concurrencyModel);
        }

        select firstonly * from generalJournalEntry
            exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId &&
                    subledgerVoucherGeneralJournalEntry.Voucher == _voucher &&
                    subledgerVoucherGeneralJournalEntry.AccountingDate == _accountingDate;

        return generalJournalEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBySubledgerVoucherAccountingDateCurrentLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the GeneralJournalEntry table - restricted to only searching the current ledger.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher associated with the GeneralJournalEntry table.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date associated with the GeneralJournalEntry table.
    /// </param>
    /// <param name="_dataAreaId">
    /// The dataAreaId identifies the voucher legal entity associated with the query
    /// </param>
    /// <param name="_forupdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model option to use when reading the record; optional.
    /// </param>
    /// <returns>
    /// A record in the GeneralJournalEntry table; otherwise, an empty record.
    /// </returns>
    /// <remarks>
    /// _entry utility method should not be used for updates.
    /// </remarks>
    public static GeneralJournalEntry findBySubledgerVoucherAccountingDateCurrentLedger(Voucher _voucher,
        AccountingDate _accountingDate,
        CompanyId _dataAreaId,
        boolean _forupdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        generalJournalEntry.selectForUpdate(_forupdate);

        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            generalJournalEntry.concurrencyModel(_concurrencyModel);
        }

        select firstonly generalJournalEntry
            where generalJournalEntry.Ledger == Ledger::current()
            exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId &&
                    subledgerVoucherGeneralJournalEntry.Voucher == _voucher &&
                    subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == _dataAreaId &&
                    subledgerVoucherGeneralJournalEntry.AccountingDate == _accountingDate;

        return generalJournalEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAccountEntryBySubledgerVoucherAccountingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a matching record in the GeneralJournalAccountEntry table.
    /// </summary>
    /// <param name="_subLedgerVoucher">
    /// The subledger voucher.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date.
    /// </param>
    /// <param name="_forupdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model option to use when reading the record; optional.
    /// </param>
    /// <returns>
    /// A record in the GeneralJournalAccountEntry table; otherwise, an empty record.
    /// </returns>
    /// <remarks>
    /// Which GeneralJournalAccountEntry record is returned is undetermined.
    /// </remarks>
    public static GeneralJournalAccountEntry findAccountEntryBySubledgerVoucherAccountingDate(
        Voucher _subLedgerVoucher,
        TransDate _accountingDate,
        boolean _forupdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        generalJournalAccountEntry.selectForUpdate(_forupdate);

        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            generalJournalAccountEntry.concurrencyModel(_concurrencyModel);
        }

        select firstonly * from generalJournalAccountEntry
            exists join generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()
            exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId
                    && subledgerVoucherGeneralJournalEntry.Voucher == _subLedgerVoucher
                    && subledgerVoucherGeneralJournalEntry.AccountingDate == _accountingDate;

        return generalJournalAccountEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findReferenceNumberAccountingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a matching record in the GeneralJournalAccountEntry table.
    /// </summary>
    /// <param name="_subledgerVoucher">
    /// The subledger voucher associated with the GeneralJournalEntry record.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date associated with the GeneralJournalEntry record.
    /// </param>
    /// <param name="_forupdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model option to use when reading the record; optional.
    /// </param>
    /// <returns>
    /// A record in the GeneralJournalAccountEntry table; otherwise, an empty record.
    /// </returns>
    /// <remarks>
    /// Which GeneralJournalAccountEntry record is returned is undetermined.
    /// </remarks>
    public static GeneralJournalAccountEntry findReferenceNumberAccountingDate(
        Voucher _subledgerVoucher,
        TransDate _accountingDate,
        boolean _forupdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;

        generalJournalAccountEntry.selectForUpdate(_forupdate);

        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            generalJournalAccountEntry.concurrencyModel(_concurrencyModel);
        }

        select firstonly * from generalJournalAccountEntry
            exists join generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()
            exists join subledgerVoucherLink
                where subledgerVoucherLink.GeneralJournalEntry == generalJournalEntry.RecId
                    && subledgerVoucherLink.AccountingDate == _accountingDate
                    && subledgerVoucherLink.Voucher == _subledgerVoucher;

        return generalJournalAccountEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findReferenceNumberAccountingDate_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a matching record in the GeneralJournalAccountEntry table.
    /// </summary>
    /// <param name="_voucher">
    /// The reference number of the GeneralJournalEntry record.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date associated with the GeneralJournalEntry record.
    /// </param>
    /// <param name="_isCredit">
    /// The IsCredit sign of the GeneralJournalAccountEntry record.
    /// </param>
    /// <param name="_postingType">
    /// The PostingType of the GeneralJournalAccountEntry record, optional.
    /// </param>
    /// <param name="_forupdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model option to use when reading the record; optional.
    /// </param>
    /// <returns>
    /// A record in the GeneralJournalAccountEntry table; otherwise, an empty record.
    /// </returns>
    /// <remarks>
    /// Which GeneralJournalAccountEntry record is returned is undetermined.
    /// </remarks>
    public static GeneralJournalAccountEntry findReferenceNumberAccountingDate_RU(
        Voucher             _voucher,
        TransDate           _accountingDate,
        NoYes               _isCredit,
        LedgerPostingType   _postingType = LedgerPostingType::None,
        boolean             _forupdate = false,
        ConcurrencyModel    _concurrencyModel = ConcurrencyModel::Auto)
    {
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        GeneralJournalEntry                 generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        generalJournalAccountEntry.selectForUpdate(_forupdate);

        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            generalJournalAccountEntry.concurrencyModel(_concurrencyModel);
        }

        select firstonly generalJournalAccountEntry
            where generalJournalAccountEntry.IsCredit       == _isCredit               &&
                 (generalJournalAccountEntry.PostingType    == _postingType            ||
                  _postingType                              == LedgerPostingType::None)
            exists join generalJournalEntry
                where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId &&
                      generalJournalEntry.Ledger == Ledger::current()
            exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId &&
                      subledgerVoucherGeneralJournalEntry.Voucher             == _voucher                  &&
                      subledgerVoucherGeneralJournalEntry.AccountingDate      == _accountingDate;

        return generalJournalAccountEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByReferenceNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the GeneralJournalEntry table.
    /// </summary>
    /// <param name="_subledgerVoucher">
    /// The subledger voucher associated with the GeneralJournalEntry record.
    /// </param>
    /// <param name="_forupdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model option to use when reading the record; optional.
    /// </param>
    /// <returns>
    /// A record in the GeneralJournalEntry table; otherwise, an empty record.
    /// </returns>
    public static GeneralJournalEntry findByReferenceNumber(
        Voucher _subledgerVoucher,
        boolean _forupdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry voucherLink;

        generalJournalEntry.selectForUpdate(_forupdate);

        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            generalJournalEntry.concurrencyModel(_concurrencyModel);
        }

        select firstonly * from generalJournalEntry
            exists join voucherLink
                where voucherLink.GeneralJournalEntry == generalJournalEntry.RecId
                    && voucherLink.Voucher == _subledgerVoucher;

        return generalJournalEntry;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>