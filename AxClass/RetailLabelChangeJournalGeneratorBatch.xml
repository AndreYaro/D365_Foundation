<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailLabelChangeJournalGeneratorBatch</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>RetailLabelChangeJournalGeneratorBatch</c> class provides the implementaiton for batch job in <c>RetailLabelChangeJournalGenerator</c>.
/// </summary>
class RetailLabelChangeJournalGeneratorBatch extends RetailLabelChangeJournalGenerator implements BatchRetryable
{
    DialogRunbase thisDialog; // We need to have a reference to the dialog in order to pass it as a parameter in the operating unit Id lookup overriden method.

    // Parameters/Options
    DialogField dialogPriceDateInterval;
    DialogField dialogInitWithQtyOnHand;
    DialogField dialogOperatingUnitNumber;
    // Filters
    DialogField dialogIncludeOnlyNewPrices;
    DialogField dialogSinceLastRun;
    DialogField dialogPriceActivatedExpiredAfterInterval;
    DialogField dialogPriceActivatedExpiredAfterDate;
    DialogField dialogPriceChangedAfterInterval;
    DialogField dialogPriceChangedAfterDate;
    DialogField dialogCategoryHierarchyId;
    DialogField dialogCategoryId;
    DialogField dialogIncludeItems;

    // Parameters/Options
    DateCode priceDateInterval;
    NoYes initWithQtyOnHand;
    Set operatingUnitsSet;
    RecId hierarchyRecId;
    OMOperatingUnitRefRecId operatingUnitId;
    OMOperatingUnitNumber operatingUnitNumber;
    // Filters
    NoYes includeOnlyNewPrices;
    NoYes sinceLastRun;
    DateCode priceActivatedExpiredAfterInterval;
    DateCode priceChangedAfterInterval;
    EcoResCategoryHierarchyId categoryHierarchyId;
    EcoResCategoryId categoryId;
    RetailItemQtyFilter includeItems;

    FromDate activatedExpiredFromDate;
    FromDate modifiedFromDate;

    RetailLabelChangeJournalTableBatch journalTableBatch;
    Map storeJournalsMap; // Maps store Id to label change journal Id
    Map storeLinesRSL; // Maps store Id to the lines RSL holding the journal lines for this store
    Map storeParametersMap; // Maps store Id to the store parameters
    Map storeLineNumMap; // Maps store Id to the journal line num
    Set storeFlushSet; // Holds a set of store Ids that were already flushed. In case of flushing in the middle of the operation (due to cache threshold limit excess), we need to check for duplicates not only in the cache, but also in lines already flushed to the database for this store.

    OMOperatingUnitRefRecId givenOperatingUnitId; // Operating unit ID that came from the caller

    int linesInCache; // Keeps track of the current number of lines in cache

    #define.maxLinesInCache(1000) // Defines the maximum number of lines that is stored in cache

    #localmacro.Parameters
        priceDateInterval, initWithQtyOnHand, hierarchyRecId, operatingUnitId, operatingUnitNumber
    #endmacro

    #localmacro.Filters
        includeOnlyNewPrices, sinceLastRun, priceActivatedExpiredAfterInterval, priceChangedAfterInterval, categoryHierarchyId, categoryId, includeItems
    #endmacro

    #localmacro.CurrentList
        #Parameters, #Filters
    #endmacro

    #define.CurrentListContainer([#CurrentList])

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>captureLastStoreParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Capture the Last Store parameters.
    /// </summary>
    /// <param name = "_storeId">The store Id.</param>
    /// <param name = "_operatingUnitId">The OM Operating Unit Id.</param>
    /// <param name = "_generatesItemLabels">generates Item Labels? Yes/No.</param>
    /// <param name = "_generatesShelfLabels">generates shelf Labels? Yes/No.</param>
    protected void captureLastStoreParameters(RetailStoreId _storeId, OMOperatingUnitRefRecId _operatingUnitId, NoYes _generatesItemLabels, NoYes _generatesShelfLabels)
    {
        super(_storeId, _operatingUnitId, _generatesItemLabels, _generatesShelfLabels);

        // Save last store parameters in the store parameters map
        if (!storeParametersMap)
        {
            storeParametersMap = new Map(Types::String, Types::Container);
        }

        storeParametersMap.insert(_storeId, [_operatingUnitId, _generatesItemLabels, _generatesShelfLabels]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryHierarchyLookupReference</Name>
				<Source><![CDATA[
    private Common categoryHierarchyLookupReference(FormReferenceControl _formReferenceControl)
    {
        Common ret;
        EcoResCategory  ecoResCategoryLocal;

        EcoResCategoryHierarchy categoryHierarchy;

        categoryHierarchyId = dialogCategoryHierarchyId.value();

        categoryHierarchy = EcoResCategoryHierarchy::find(categoryHierarchyId);

        ret = EcoResCategory::lookupCategoryHierarchy(_formReferenceControl,
                                                        categoryHierarchy);

        if (ret.TableId == tableNum(EcoResCategory))
        {
            ecoResCategoryLocal = ret.data();

            // update the current Category hierarchy if selected category belongs to another hierarchy.
            if (ecoResCategoryLocal.RecId &&
                categoryHierarchyId != ecoResCategoryLocal.CategoryHierarchy)
            {
                dialogCategoryHierarchyId.value(ecoResCategoryLocal.CategoryHierarchy);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryHierarchyModified</Name>
				<Source><![CDATA[
    private boolean categoryHierarchyModified(FormReferenceGroupControl _caller)
    {
        boolean ret = _caller.modified();
        EcoResCategoryHierarchyId newHierarchyId = _caller.value();
        dialogCategoryId.allowEdit(newHierarchyId != 0);
        if (!newHierarchyId || newHierarchyId != categoryHierarchyId)
        {
            dialogCategoryId.value(0);
        }

        categoryHierarchyId = newHierarchyId;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryHierarchyResolveReference</Name>
				<Source><![CDATA[
    private Common categoryHierarchyResolveReference(FormReferenceControl _formReferenceControl)
    {
        Common ret;
        EcoResCategoryHierarchy categoryHierarchy;

        categoryHierarchyId = dialogCategoryHierarchyId.value();

        categoryHierarchy  = EcoResCategoryHierarchy::find(categoryHierarchyId);

        ret = EcoResCategory::resolveCategoryHierarchy(_formReferenceControl, categoryHierarchy);

        return ret.RecId? ret : null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a Journal
    /// </summary>
    /// <param name = "_storeId">The Store Id for the journal.</param>
    /// <returns>Returns a <c>RetailLabelChangeJournalId</c> with the Journal Id for the journal.</returns>
    protected RetailLabelChangeJournalId createJournal(RetailStoreId _storeId)
    {
        RetailLabelChangeJournalId journalId;
        RetailLabelChangeJournalTable journalTable;

        if (storeJournalsMap.exists(_storeId))
        {
            journalId = storeJournalsMap.lookup(_storeId);
        }
        else
        {
            ttsBegin;
            if (!journalTableBatch)
            {
                journalTableBatch.CategoryId = categoryId;
                journalTableBatch.OperatingUnitId = operatingUnitId;
                journalTableBatch.OMHierarchyType = hierarchyRecId;
                journalTableBatch.PriceDate = priceDate;
                journalTableBatch.ActivatedExpiredFromDate = activatedExpiredFromDate;
                journalTableBatch.ModifiedFromDate = modifiedFromDate;
                journalTableBatch.insert();
            }
            journalTable.SourceType = RetailLabelChangeSourceType::Batch;
            journalTable.initValue();
            journalTable.LabelChangeJournalTableBatch = journalTableBatch.RecId;
            journalTable.JournalNum = this.getJournalId();
            journalTable.Description = strFmt("@SYS312531", "@SYS81927", DateTimeUtil::utcNow());
            journalTable.StoreId = _storeId;
            journalTable.PriceValidOnDate = priceDate;
            journalTable.InitWithQtyOnHand = initWithQtyOnHand;
            journalTable.ItemQtyFilter = includeItems;
            journalTable.insert();
            ttsCommit;
            journalId = journalTable.JournalNum;
            storeJournalsMap.insert(_storeId, journalId);
        }

        return journalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the dialog to assign values to parameters used in the journal.
    /// </summary>
    /// <returns>An Object of type <c>DialogRunbase</c>.</returns>
    public Object dialog()
    {
        DialogRunbase dialog = super();
        DialogGroup dialogGroup, nestedGroup;

        thisDialog = dialog;

        dialogPriceDate.visible(false); // Have to explicitly turn this off as we have a different approach for selecting a Price date for the batch operation
        // Parameters/Options
        dialog.addGroup("@SYS54716");
        dialogPriceDateInterval = dialog.addFieldValue(extendedTypeStr(DateCode), priceDateInterval, "@SYP4880946");
        dialogPriceDateInterval.mandatory_RU(true);
        dialogPriceDateInterval.registerOverrideMethod(methodStr(FormStringControl, modified), methodStr(RetailLabelChangeJournalGeneratorBatch, priceDateIntervalModified), this);
        dialogInitWithQtyOnHand = dialog.addFieldValue(extendedTypeStr(NoYesId), initWithQtyOnHand, "@SYP4880988");
        dialogOperatingUnitNumber = dialog.addFieldValue(extendedTypeStr(OMOperatingUnitNumber), operatingUnitNumber);
        dialogOperatingUnitNumber.registerOverrideMethod(methodStr(FormStringControl, lookup), methodStr(RetailLabelChangeJournalGeneratorBatch, operatingUnitLookup), this);
        // Filters
        dialogGroup = dialog.addGroup("@SYS81048");
        dialogIncludeOnlyNewPrices = dialog.addFieldValue(extendedTypeStr(NoYesId), includeOnlyNewPrices, "@SYP4881084", "@SYP4881085");
        dialogIncludeOnlyNewPrices.registerOverrideMethod(methodStr(FormCheckBoxControl, modified), methodStr(RetailLabelChangeJournalGeneratorBatch, includeOnlyNewPricesModified), this);
        dialogSinceLastRun = dialog.addFieldValue(extendedTypeStr(NoYesId), sinceLastRun, "@SYP4881086", "@SYP4881087");
        dialogSinceLastRun.registerOverrideMethod(methodStr(FormCheckBoxControl, modified), methodStr(RetailLabelChangeJournalGeneratorBatch, sinceLastRunModified), this);
        // Date interval and its satelite date control should go in single line inside a nested group control
        nestedGroup = dialog.addGroup('', dialogGroup);
        nestedGroup.frameType(FormFrameType::None);
        nestedGroup.columns(2);
        dialogPriceActivatedExpiredAfterInterval = dialog.addFieldValue(extendedTypeStr(DateCode), priceActivatedExpiredAfterInterval, "@SYP4881088", "@SYP4881089");
        dialogPriceActivatedExpiredAfterInterval.mandatory_RU(true);
        dialogPriceActivatedExpiredAfterInterval.registerOverrideMethod(methodStr(FormStringControl, modified), methodStr(RetailLabelChangeJournalGeneratorBatch, priceActivatedExpiredAfterModified), this);
        dialogPriceActivatedExpiredAfterDate = dialog.addFieldValue(extendedTypeStr(TransDate), LedgerPeriodCode::find(priceActivatedExpiredAfterInterval).fromDate(), '');
        dialogPriceActivatedExpiredAfterDate.allowEdit(false);
        // Date interval and its satelite date control should go in single line inside a nested group control
        nestedGroup = dialog.addGroup('', dialogGroup);
        nestedGroup.frameType(FormFrameType::None);
        nestedGroup.columns(2);
        dialogPriceChangedAfterInterval = dialog.addFieldValue(extendedTypeStr(DateCode), priceChangedAfterInterval, "@SYP4881090", "@SYP4881091");
        dialogPriceChangedAfterInterval.mandatory_RU(true);
        dialogPriceChangedAfterInterval.registerOverrideMethod(methodStr(FormStringControl, modified), methodStr(RetailLabelChangeJournalGeneratorBatch, priceChangedAfterModified), this);
        dialogPriceChangedAfterDate = dialog.addFieldValue(extendedTypeStr(TransDate), LedgerPeriodCode::find(priceChangedAfterInterval).fromDate(), '');
        dialogPriceChangedAfterDate.allowEdit(false);

        this.setFilterFieldsEnabled();

        nestedGroup = dialog.addGroup('', dialogGroup);
        nestedGroup.frameType(FormFrameType::None);
        dialogCategoryHierarchyId = dialog.addFieldValue(extendedTypeStr(EcoResCategoryHierarchyId), categoryHierarchyId);
        dialogCategoryHierarchyId.registerOverrideMethod(methodStr(FormReferenceGroupControl, modified), methodStr(RetailLabelChangeJournalGeneratorBatch, categoryHierarchyModified), this);
        dialogCategoryId = dialog.addFieldValue(extendedTypeStr(EcoResCategoryId), categoryHierarchyId ? categoryId : 0);
        dialogCategoryId.allowEdit(categoryHierarchyId != 0);
        dialogCategoryId.registerOverrideMethod(methodStr(FormReferenceControl, lookupReference), methodStr(RetailLabelChangeJournalGeneratorBatch, categoryHierarchyLookupReference), this);
        dialogCategoryId.registerOverrideMethod(methodStr(FormReferenceControl, resolveReference), methodStr(RetailLabelChangeJournalGeneratorBatch, categoryHierarchyResolveReference), this);
        dialogIncludeItems = dialog.addFieldValue(extendedTypeStr(RetailItemQtyFilter), includeItems);
        dialogIncludeItems.registerOverrideMethod(methodStr(FormComboBoxControl, enter), methodStr(RetailLabelChangeJournalGeneratorBatch, includeItemsEnter), this);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>flushLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Flush lines from Journal.
    /// </summary>
    /// <param name = "_lastFlush">boolean indicating if this is last flush.</param>
    /// <param name = "_exclusionProvider">The Exclusion Provider.</param>
    /// <param name = "_currentStoreId">The current Store Id.</param>
    protected void flushLines(boolean _lastFlush = false, RetailLabelChangeExclusionProvider _exclusionProvider = null, RetailStoreId _currentStoreId = '')
    {
        RecordSortedList rsl;
        MapEnumerator me;
        RetailStoreId flushStoreId, eraseStoreId;
        Set storeExclusionSet;
        SetEnumerator se;
        int maxLen;
        int len;

        linesRecordSortedList = null;

        this.saveLineNum(_currentStoreId, LineNum);

        if (_exclusionProvider)
        {
            storeExclusionSet = _exclusionProvider.parmStoreExclusionSet();
            if (storeExclusionSet)
            {
                se = storeExclusionSet.getEnumerator();
                while (se.moveNext())
                {
                    eraseStoreId = se.current();
                    this.removeJournal(eraseStoreId);
                }
            }
        }

        // Flush all the caches in case of final flush
        if (_lastFlush)
        {
            if (storeLinesRSL && !storeLinesRSL.empty())
            {
                me = storeLinesRSL.getEnumerator();
                while (me.moveNext())
                {
                    linesRecordSortedList = me.currentValue();
                    if (linesRecordSortedList)
                    {
                        // Restore last store parameters before calling the actual flush
                        flushStoreId = me.currentKey();
                        [lastOperatingUnitId, lastStoreGenerateItemLabels, lastStoreGenerateShelfLabels, lineNum] = storeParametersMap.lookup(flushStoreId);
                        super();
                    }
                }
            }
            else if (journalTableBatch)
            {
                // Remove the batch record in case we finally have created no journals for it
                journalTableBatch.delete();
                journalTableBatch = null; // Set it to null in order for the journalTableBatch ? true : false to work properly
            }
        }
        // Else if the number of lines in cache exceeds the threshold value, we flush the RSL for the store with the maximum number of lines.
        else if (linesInCache > #maxLinesInCache)
        {
            me = storeLinesRSL.getEnumerator();
            while (me.moveNext())
            {
                rsl = me.currentValue();
                len = rsl.len();
                if (len > maxLen)
                {
                    maxLen = len;
                    linesRecordSortedList = rsl;
                    flushStoreId = me.currentKey();
                }
            }

            if (linesRecordSortedList && maxLen && flushStoreId)
            {
                // Restore last store parameters before calling the actual flush
                [lastOperatingUnitId, lastStoreGenerateItemLabels, lastStoreGenerateShelfLabels, lineNum] = storeParametersMap.lookup(flushStoreId);
                super();
                // Substract the number of lines flushed from the total number of lines in cache
                linesInCache -= maxLen;
                storeLinesRSL.remove(flushStoreId);
                if (!storeFlushSet)
                {
                    storeFlushSet = new Set(Types::String);
                }
                storeFlushSet.add(flushStoreId);
            }
        }

        if (_currentStoreId)
        {
            lineNum = this.getLineNum(_currentStoreId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFetcher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a fetcher for the Retail Label Change
    /// </summary>
    /// <returns>An instance of <c>RetailLabelChangeDataFetcherMultiSource</c>.</returns>
    protected RetailLabelChangeDataFetcher getFetcher()
    {
        RetailLabelChangeDataFetcherMultiSource fetcher = new RetailLabelChangeDataFetcherMultiSource();

        fetcher.addFetcher(new RetailLabelChangePriceAdjFetcher(activatedExpiredFromDate, modifiedFromDate, priceDate, hierarchyRecId, operatingUnitId, categoryId, includeItems, initWithQtyOnHand));
        fetcher.addFetcher(new RetailLabelChangeTAJPriceGroupFetcher(activatedExpiredFromDate, modifiedFromDate, priceDate, hierarchyRecId, operatingUnitId, categoryId, includeItems, initWithQtyOnHand));
        fetcher.addFetcher(new RetailLabelChangeTAJAllStoresFetcher(activatedExpiredFromDate, modifiedFromDate, priceDate, hierarchyRecId, operatingUnitId, categoryId, includeItems, initWithQtyOnHand));
        fetcher.addFetcher(new RetailLabelChangeTAJDeletedPriceGroupDF(modifiedFromDate, priceDate, hierarchyRecId, operatingUnitId, categoryId, includeItems, initWithQtyOnHand));
        fetcher.addFetcher(new RetailLabelChangeTAJDeletedALLDF(modifiedFromDate, priceDate, hierarchyRecId, operatingUnitId, categoryId, includeItems, initWithQtyOnHand));
        fetcher.addFetcher(new RetailLabelChangeItemSalesPriceFetcher(activatedExpiredFromDate, dateMax(), priceDate, hierarchyRecId, operatingUnitId, categoryId, includeItems, initWithQtyOnHand));

        return fetcher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the parameter values from the dialog form.
    /// </summary>
    /// <returns>true if the super method call returns true; otherwise, false.</returns>
    public boolean getFromDialog()
    {
        boolean ret;

        ret = super();

        // Parameters/Options
        priceDateInterval = dialogPriceDateInterval.value();
        initWithQtyOnHand = dialogInitWithQtyOnHand.value();
        operatingUnitNumber = dialogOperatingUnitNumber.value();

        // Filters
        includeOnlyNewPrices = dialogIncludeOnlyNewPrices.value();
        sinceLastRun = dialogSinceLastRun.value();
        priceActivatedExpiredAfterInterval = dialogPriceActivatedExpiredAfterInterval.value();
        priceChangedAfterInterval = dialogPriceChangedAfterInterval.value();
        categoryHierarchyId = dialogCategoryHierarchyId.value();
        categoryId = dialogCategoryId.value();
        includeItems = dialogIncludeItems.value();
        if (includeItems == RetailAllNewOnHand::New)
        {
            includeItems = RetailAllNewOnHand::OnHand;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineNum</Name>
				<Source><![CDATA[
    private LineNum getLineNum(RetailStoreId _storeId)
    {
        LineNum ret = 0;

        if (storeLineNumMap && storeLineNumMap.exists(_storeId))
        {
            ret = storeLineNumMap.lookup(_storeId);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasJournalsToShow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verify if there are journals to show.
    /// </summary>
    /// <returns>True if there are journals to show, otherwise false.</returns>
    protected boolean hasJournalsToShow()
    {
        return journalTableBatch ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeItemsEnter</Name>
				<Source><![CDATA[
    private void includeItemsEnter(FormComboBoxControl _caller)
    {
        _caller.enter();
        _caller.delete(enum2str(RetailAllNewOnHand::New));
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeOnlyNewPricesModified</Name>
				<Source><![CDATA[
    private boolean includeOnlyNewPricesModified(FormCheckBoxControl _caller)
    {
        _caller.modified();
        includeOnlyNewPrices = _caller.value();
        this.setFilterFieldsEnabled();

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDateParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the Date parameters.
    /// </summary>
    protected void initDateParameters()
    {
        PriceDate lastRunPriceDate;

        priceDate = LedgerPeriodCode::find(priceDateInterval).fromDate();

        // Get concrete date parameter values for the current run
        if (includeOnlyNewPrices)
        {
            if (sinceLastRun)
            {
                // Find last created journal with same operating unit Id and category Id and initialize dates based on it.
                lastRunPriceDate = RetailLabelChangeJournalTableBatch::getLastPriceDate(operatingUnitId, categoryId);
                if (lastRunPriceDate)
                {
                    modifiedFromDate = lastRunPriceDate;
                    activatedExpiredFromDate = lastRunPriceDate + 1;
                }
                else
                {
                    modifiedFromDate = dateNull();
                    activatedExpiredFromDate = dateNull();
                }
            }
            else
            {
                activatedExpiredFromDate = LedgerPeriodCode::find(priceActivatedExpiredAfterInterval).fromDate();
                modifiedFromDate = LedgerPeriodCode::find(priceChangedAfterInterval).fromDate();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromArgs</Name>
				<Source><![CDATA[
    private void initFromArgs(Args _args)
    {
        RetailLabelChangeJournalTable journalTable;

        if (_args && _args.record() && _args.dataset() == tableNum(RetailLabelChangeJournalTable))
        {
            journalTable = _args.record();
            givenOperatingUnitId = journalTable.operatingUnitID();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an instance of <c>RetailLabelChangeJournalGeneratorBatch</c>.
    /// </summary>
    public void new()
    {
        super();

        storeJournalsMap = new Map(Types::String, Types::String);
    }

]]></Source>
			</Method>
			<Method>
				<Name>operatingUnitLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the operating unit lookup on the dialog.
    /// </summary>
    /// <param name="_caller">
    /// The control event came from.
    /// </param>
    private void operatingUnitLookup(FormStringControl _caller)
    {
        FormRun fr;
        Object objectFr;
        MenuFunction mf = new MenuFunction(menuItemDisplayStr(RetailReportingOperatingUnitPicker), MenuItemType::Display);
        Args args = new Args();
        args.caller(thisDialog);
        fr = mf.create(args);
        fr.init();
        fr.run();
        fr.wait();
        objectFr = fr;
        objectFr.transmitSelectionToCaller();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the current version of the parameters.
    /// </summary>
    /// <returns>Returns a <c>container</c> with Version Number and list of parameters.</returns>
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOMHierarchyRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the Hyerarchy Rec Id.
    /// </summary>
    /// <param name = "_hierarchyRecId">The new value for Hyerarchy RecId.</param>
    /// <returns>The current value for Hyerarchy RecId.</returns>
    public RecId parmOMHierarchyRecId(RecId _hierarchyRecId = hierarchyRecId)
    {
        hierarchyRecId = _hierarchyRecId;
        return hierarchyRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSelectedOMInternalOrgRecIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets a Set of Internal Organization ReciIds
    /// </summary>
    /// <param name = "_operatingUnitsSet">The new Set of Org Unit RecIds.</param>
    /// <returns>The current Set of Org Ids.</returns>
    public Set parmSelectedOMInternalOrgRecIds(Set _operatingUnitsSet = operatingUnitsSet)
    {
        SetEnumerator se;

        if (!prmisDefault(_operatingUnitsSet))
        {
            operatingUnitsSet = _operatingUnitsSet;
            if (operatingUnitsSet && !operatingUnitsSet.empty())
            {
                se = operatingUnitsSet.getEnumerator();
                if (se.moveNext())
                {
                    operatingUnitId = se.current();
                }
                else
                {
                    operatingUnitId = 0;
                }

                dialogOperatingUnitNumber.value(OMOperatingUnit::find(operatingUnitId, OMOperatingUnitType::OMAnyOU).OMOperatingUnitNumber);
            }
        }

        return operatingUnitsSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceActivatedExpiredAfterModified</Name>
				<Source><![CDATA[
    private boolean priceActivatedExpiredAfterModified(FormStringControl _caller)
    {
        boolean ret = _caller.modified();
        DateCode code = _caller.text();
        dialogPriceActivatedExpiredAfterDate.value(LedgerPeriodCode::find(code).fromDate());

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceChangedAfterModified</Name>
				<Source><![CDATA[
    private boolean priceChangedAfterModified(FormStringControl _caller)
    {
        boolean ret = _caller.modified();
        DateCode code = _caller.text();
        dialogPriceChangedAfterDate.value(LedgerPeriodCode::find(code).fromDate());

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceDateIntervalModified</Name>
				<Source><![CDATA[
    private boolean priceDateIntervalModified(FormStringControl _caller)
    {
        boolean ret = _caller.modified();
        priceDateInterval = _caller.text();
        priceDate = LedgerPeriodCode::find(priceDateInterval).fromDate();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the Journal Line.
    /// </summary>
    /// <param name = "_storeId">The store Id.</param>
    /// <param name = "_journalNum">The Journal Id.</param>
    /// <param name = "_itemId">The Item Id.</param>
    /// <param name = "_variantId">The variant Id.</param>
    /// <param name = "_price">The Item Price.</param>
    /// <param name = "_qty">The item quantity.</param>
    /// <param name = "_unitId">The Unit id of the Item.</param>
    protected void processJournalLine(RetailStoreId _storeId, RetailLabelChangeJournalId _journalNum, ItemId _itemId, RetailVariantId _variantId, Price _price, Qty _qty, UnitOfMeasureSymbol _unitId)
    {
        RetailLabelChangeJournalTrans journalTrans;
        RecordSortedList rsl = null;

        // Always lookup RSL from the map, so set it to null at the beginning
        linesRecordSortedList = null;

        if (storeLinesRSL && storeLinesRSL.exists(_storeId))
        {
            rsl = storeLinesRSL.lookup(_storeId);
            linesRecordSortedList = rsl;
            if (linesRecordSortedList)
            {
                journalTrans.JournalNum = _journalNum;
                journalTrans.ItemId = _itemId;
                journalTrans.VariantId = _variantId;
                if (linesRecordSortedList.find(journalTrans))
                {
                    return; // Skip the line if we have one in cache matching by JournalNum + ItemId + VariantId.
                }
            }
        }

        if (storeFlushSet && storeFlushSet.in(_storeId))
        {
            if (RetailLabelChangeJournalTrans::existJournalItemVariant(_journalNum, _itemId, _variantId))
            {
                return; // Skip the line if we have already flushed one to the database having the same combination of JournalNum + ItemId + VariantId.
            }
        }

        super(_storeId, _journalNum, _itemId, _variantId, _price, _qty, _unitId);
        linesInCache++;

        // Add store lines rsl to the map if this was the first line for the store
        if (!rsl && linesRecordSortedList)
        {
            if (!storeLinesRSL)
            {
                storeLinesRSL = new Map(Types::String, Types::Class);
            }

            storeLinesRSL.insert(_storeId, linesRecordSortedList);
        }

        if (linesInCache > #maxLinesinCache)
        {
            this.saveLineNum(_storeId, lineNum);
            this.flushLines(false, null, _storeId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeJournal</Name>
				<Source><![CDATA[
    private void removeJournal(RetailStoreId _storeId)
    {
        RetailLabelChangeJournalId journalNum;
        RetailLabelChangeJournalTable journalTable;
        RecordSortedList rsl;

        if (storeJournalsMap && storeJournalsMap.exists(_storeId))
        {
            journalNum = storeJournalsMap.lookup(_storeId);
            ttsBegin;
            journalTable = RetailLabelChangeJournalTable::find(journalNum, true);
            if (journalTable)
            {
                journalTable.delete();
            }
            ttsCommit;
        }

        if (storeLinesRSL && storeLinesRSL.exists(_storeId))
        {
            rsl = storeLinesRSL.lookup(_storeId);
            if (rsl)
            {
                // Substract the number of lines removed from the total number of lines in cache
                linesInCache -= rsl.len();
            }
            storeLinesRSL.remove(_storeId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// The entry point for the Batch class.
    /// </summary>
    public void run()
    {
        this.initDateParameters();

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveLineNum</Name>
				<Source><![CDATA[
    private void saveLineNum(RetailStoreId _storeId, LineNum _lineNum)
    {
        if (!storeLineNumMap)
        {
            storeLineNumMap = new Map(Types::String, Types::Real);
        }

        storeLineNumMap.insert(_storeId, _lineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDateFieldsEnabled</Name>
				<Source><![CDATA[
    private void setDateFieldsEnabled()
    {
        boolean enabled = (includeOnlyNewPrices && !sinceLastRun);
        dialogPriceActivatedExpiredAfterInterval.enabled(enabled);
        dialogPriceActivatedExpiredAfterDate.enabled(enabled);
        dialogPriceChangedAfterInterval.enabled(enabled);
        dialogPriceChangedAfterDate.enabled(enabled);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFilterFieldsEnabled</Name>
				<Source><![CDATA[
    private void setFilterFieldsEnabled()
    {
        dialogSinceLastRun.enabled(includeOnlyNewPrices);
        this.setDateFieldsEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>showGeneratedJournals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Show the Generated Journals.
    /// </summary>
    /// <returns>Always returns false.</returns>
    protected boolean showGeneratedJournals()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sinceLastRunModified</Name>
				<Source><![CDATA[
    private boolean sinceLastRunModified(FormCheckBoxControl _caller)
    {
        _caller.modified();
        sinceLastRun = dialogSinceLastRun.value();
        this.setDateFieldsEnabled();

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>Common</c> buffer with the Source record of the journal.
    /// </summary>
    /// <param name = "_callerRecord">The caller record.</param>
    /// <returns>A <c>Common</c> buffer containing the source record of the journal.</returns>
    protected Common sourceRecord(Common _callerRecord)
    {
        return journalTableBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unpacks the class.
    /// </summary>
    /// <param name = "packedClass">The packed class.</param>
    /// <returns>true if upack is successful, otherwise false.</returns>
    public boolean unpack(container packedClass)
    {
        OMHierarchyPurpose hierarchyPurpose;
        OMHierarchyRelationship hierarchyRelationship;
        OMOperatingUnit operatingUnit;
        Version version = RunBase::getVersion(packedClass);
        boolean ret = false;

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = packedClass;
                // Override hydrated operating unit ID value with the given value if one is initialized
                // This is required to use the given operating unit ID in client prompt when the operation is executed on server with the given operating unit ID that should be used as initial value
                if (givenOperatingUnitId)
                {
                    operatingUnitId = givenOperatingUnitId;
                    givenOperatingUnitId = 0;
                    // Reset the hierarchy value if we have a given operating unit ID value
                    hierarchyRecId = 0;
                }
                // Resolve operating unit only when the class is running in normal mode (on server by default)
                if (!isSwappedFromServer)
                {
                    // We are unpacking values that came from a dialog, so we need to lookup operating unit ID and hierarchy purpose from the operating unit number that came from the dialog
                    if (inPromptUnpack)
                    {
                        operatingUnitId = 0;
                        // If we have hierarchy ID filled, try to lookup operating Unit ID from the operating unit number that came from the user selection
                        if (hierarchyRecId)
                        {
                            select firstOnly RecId from operatingUnit
                                where operatingUnit.OMOperatingUnitNumber == operatingUnitNumber
                                exists join hierarchyRelationship
                                    where hierarchyRelationship.HierarchyType == hierarchyRecId
                                       && hierarchyRelationship.ChildOrganization == operatingUnit.RecId;
                            if (operatingUnit)
                            {
                                operatingUnitId = operatingUnit.RecId;
                            }
                        }

                        if (!operatingUnitId)
                        {
                            // Last resort is to try to select the operating unit by number associated with any Retail printing hierarchy
                            select firstOnly RecId from operatingUnit
                                where operatingUnit.OMOperatingUnitNumber == operatingUnitNumber
                                join HierarchyType from hierarchyRelationship
                                    where hierarchyRelationship.ChildOrganization == operatingUnit.RecId
                                exists join hierarchyPurpose
                                    where hierarchyPurpose.HierarchyType == hierarchyRelationship.HierarchyType
                                        && hierarchyPurpose.HierarchyPurpose == HierarchyPurpose::RetailReporting;
                            operatingUnitId = operatingUnit.RecId;
                            hierarchyRecId = hierarchyRelationship.HierarchyType;
                        }
                    }
                    // Else we are in the normal unpack and should simply lookup operating unit number by the operating unit ID
                    else
                    {
                        operatingUnitNumber = OMOperatingUnit::find(operatingUnitId, OMOperatingUnitType::OMAnyOU).OMOperatingUnitNumber;
                    }
                }
                // Initialize price date with the value corresponding to the hydrated price date interval
                priceDate = LedgerPeriodCode::find(priceDateInterval).fromDate();
                ret = true;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate all parameters.
    /// </summary>
    /// <param name = "calledFrom">The caller object.</param>
    /// <returns>True if passed all validations, otherwise false.</returns>
    public boolean validate(Object calledFrom = null)
    {
        boolean ret;

        ret = super(calledFrom);

        if (!priceDateInterval)
        {
            ret = checkFailed(strFmt("@SYS50104", "@SYP4880946"));
        }
        else
        {
            ret = LedgerPeriodCode::checkExist(priceDateInterval) && ret;
        }

        if (operatingUnitNumber)
        {
            ret = RetailLabelChangeJournalGeneratorBatch::checkExistOperatingUnitNumber(operatingUnitNumber) && ret;
        }

        if (includeOnlyNewPrices && !sinceLastRun)
        {
            if (!priceActivatedExpiredAfterInterval)
            {
                ret = checkFailed(strFmt("@SYS50104", "@SYP4881088"));
            }
            else
            {
                ret = LedgerPeriodCode::checkExist(priceActivatedExpiredAfterInterval) && ret;
            }

            if (!priceChangedAfterInterval)
            {
                ret = checkFailed(strFmt("@SYS50104", "@SYP4881090"));
            }
            else
            {
                ret = LedgerPeriodCode::checkExist(priceChangedAfterInterval) && ret;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExistOperatingUnitNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the specified operating unit exists and shows warning if doesn't.
    /// </summary>
    /// <param name="_operatinaUnitNumber">
    /// The operating unit number.
    /// </param>
    /// <returns>
    /// true if the operating unit exists; false otherwise.
    /// </returns>
    /// <remarks>
    /// Shows warning if the operating unit does not exist.
    /// </remarks>
    protected static boolean checkExistOperatingUnitNumber(OMOperatingUnitNumber _operatinaUnitNumber)
    {
        if (!RetailLabelChangeJournalGeneratorBatch::existOperatingUnitNumber(_operatinaUnitNumber))
        {
            return checkFailed("@SYS309742");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Batch class description.
    /// </summary>
    /// <returns>
    /// Returns the class description.
    /// </returns>
    public static ClassDescription description()
    {
        return "@SYP4880979";
    }

]]></Source>
			</Method>
			<Method>
				<Name>existOperatingUnitNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the operating unit with the given number exists.
    /// </summary>
    /// <param name="_operatingUnitNumber">
    /// Operating unit number.
    /// </param>
    /// <returns>
    /// true if the operating unit with the specified number exists; false otherwise.
    /// </returns>
    protected static boolean existOperatingUnitNumber(OMOperatingUnitNumber _operatingUnitNumber)
    {
        return _operatingUnitNumber
            && (select firstOnly OMOperatingUnitNumber from OMOperatingUnit
                where OMOperatingUnit.OMOperatingUnitNumber == _operatingUnitNumber).OMOperatingUnitNumber != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromArgs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an initialized instance of the <c>RetailLabelChangeJournalGeneratorBatch</c>.
    /// </summary>
    /// <param name="_args">
    /// Args.
    /// </param>
    /// <returns>
    /// An instance of the <c>RetailLabelChangeJournalGeneratorBatch</c>.
    /// </returns>
    public static RetailLabelChangeJournalGeneratorBatch newFromArgs(Args _args)
    {
        RetailLabelChangeJournalGeneratorBatch generator = new RetailLabelChangeJournalGeneratorBatch();
        generator.initFromArgs(_args);
        return generator;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
		<Method><Name>isRetryable</Name><Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }
]]></Source></Method></Methods>
	</SourceCode>
</AxClass>