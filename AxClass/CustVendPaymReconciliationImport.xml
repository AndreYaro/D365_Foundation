<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendPaymReconciliationImport</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class CustVendPaymReconciliationImport extends RunBaseBatch implements CustVendBankPaymFormat
{
    PaymMode    paymMode;
    StreamIO    file;
    System.IO.Stream fileStream;
    DialogRunbase baseDialog;
    FileUploadBuild dialogFileUpload;
    FileUpload fileUpload;

    container   recordContainer[];
    Counter     numOfRecord;

    // Packed variables
    Filename    filename;
    JournalId   journalId;

    // <GBR>
    boolean                     isFileImportedAlready;
    ConfLayoutGroupId_BR        layoutGroupID;
    ConfLayoutType_BR           layoutType;
    ConfLayoutFields_BR         confLayoutFields_BR;
    str                         delimiterChars;
    int                         fieldcount;
    container                   fieldDimensions[];
    SysModule                   sysModule;
    str                         textQualifier;
    CustVendPaymStatus          paymStatusCur;
    ConfFileStructure_BR        fileStructure;
    container                   datasize[] ;
    int                         fieldCountBatchHeader;
    boolean                     readNextBatch;
    boolean                     saveData;
    boolean                     checkLayoutExists;
    // </GBR>

    #DEFINE.CurrentVersion(2)

    #LOCALMACRO.CurrentListV1
        fileName
    #ENDMACRO

    #LOCALMACRO.CurrentList
        fileName,
        journalId
    #ENDMACRO

    // <GBR>
    #EP_Return_BR
    // </GBR>

    ExchRate                    returnExchRate;
    CurrencyCode                paymCurrencyCode;
    CurrencyCode                invoiceCurrencyCode;
    CurrencyCode                sendersBankCurrencyCode;
    CurrencyCodeISO             paymCurrencyCodeISO;
    CurrencyCodeISO             invoiceCurrencyCodeISO;
    CurrencyCodeISO             sendersBankCurrencyCodeISO;
    CurrencyCode                currencyCodeMST;
    CurrencyCodeISO             currencyCodeMSTISO;
    BankMultiCurrency           sendersBankMultiCurrency;
    BankAccountTable            bankAccountTable;

    ExchRate                    returnExchRateMST;
    date                        returnExchDate;
    VendPaymModeTable           vendPaymModeTable;
    CustPaymModeTable           custPaymModeTable;

    LedgerJournalAC             offsetAccount;
    LedgerJournalACType         offsetAccountType;

    NoYes                       sumBankAmount;
    int                         accountIdx;
    int                         accountIdxMax;
    TransDate                   transDateSum[];
    LedgerJournalAC             offsetAccountSum[];
    LedgerJournalACType         offsetAccountTypeSum[];
    Amount                      accountAmountSum[];
    CurrencyCode                currencyCodeSum[];
    Voucher                     voucherSum[];
    LedgerJournalId             journalIdSum[];

    ExchRate                    exchRateSum[];
    BankTransactionType         bankTransTypeSum[];
    PaymMode                    paymModeSum[];
    LedgerJournalTransTxt       paymTxt;
    RecordSortedList            transferredJournals;

    Amount                      amountCurCharged;
    Amount                      amountCurTransfered;
    Amount                      amountCurChargedSum[];
    Amount                      amountCurTransferedSum[];
    ExchRate                    returnExchRateMSTPaym;
    ExchRate                    returnExchRateBankStdSum[];
    str                         returnExchRateMSTStr;
    str                         returnExchRateStr;
    ExchRate                    returnExchRateMSTCrossRate;

    Name                        newName;
    NoYesId                     deleteEmptyJournals;
    LedgerJournalTable          newLedgerJournalTable;
    LedgerJournalId             newJournalId;
    LedgerJournalId             lastJournalId;
    LedgerJournalNameId         newJournalNameId;

    RefRecId                    numberSeqId;

    Voucher                     voucherNum;

    str 6                       bankReferenceNumberSum[];

    NoYes                       insertExchRates;
    NoYes                       updateExchRates;

    NoYes                       fileArchive;
    PaymMode                    filePaymMode;
    LedgerJournalId             fileArchiveJournalId;

    str                         transTxt;
    NoYes                       paymCurrencyMST;

    LedgerDimensionAccount      feeLedgerDimension;

    Amount                      amountPaymFee;
    Amount                      amountPaymFeeSum[];
    NoYes                       sumPaymFee;

    NoYes                       sumBankInclRef;
    NoYes                       feeInAmountCharged;
    str 1                       feeIndicator;

    boolean                     inverseExchRate;

    NoYes                       rejectionsInSeparateJournal;
    container                   recordRecId;
    boolean                     okTrans;
    NoYes                       fileAnalyze;
    DialogField                 dialogFileAnalyze;
    DialogField                 dialogFileArchive;
    boolean                     paymentStatusSet;
    boolean                     okCompany;
    container                   processedJournalTransRecord;
    container                   newJournalTransRecord;
    LedgerJournalTrans          newLedgerJournalTrans;
    Map                         currencyBaseUnitMap;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns false.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    /// <remarks>
    ///    This method must be in this class because it is called from the <c>dialogRunbase</c> class.
    /// </remarks>
    public boolean canGoBatch()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the class is shown in the list of <c>Journal</c> types.
    /// </summary>
    /// <returns>
    ///    true if the class is shown in the list of <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    A class that can be used in a batch journal is a class where the same parameters can be used
    ///    repeatedly. The dialog can be shown and the parameters can be changed but parameters of some
    ///    classes might build on data that is only valid for a short time. Running a class twice with the
    ///    same parameters is not always possible. If the <see cref="M:RunBaseBatch.canGoBatch" /> method
    ///    returns false, this method will not have any effect.
    /// </remarks>
    public boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVoucher</Name>
				<Source><![CDATA[
    public void checkVoucher(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTable ledgerJournalTable;

        if (sumBankAmount)
        {
            _ledgerJournalTrans.Voucher = voucherSum[accountIdx];
        }
        else
        {
            if (!_ledgerJournalTrans.Voucher || newJournalNameId)
            {
                this.loadVoucherNum();
                _ledgerJournalTrans.Voucher = voucherNum;
            }
        }

        if (_ledgerJournalTrans.JournalNum != lastJournalId)
        {
            lastJournalId      = _ledgerJournalTrans.JournalNum;
            ledgerJournalTable  = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum,true);
            this.transferredJournals().ins(ledgerJournalTable);
        }
        if (newJournalId)
        {
            newLedgerJournalTrans.clear();
            newLedgerJournalTrans               = _ledgerJournalTrans.data();
            newLedgerJournalTrans.JournalNum    = newJournalId;
            newLedgerJournalTrans.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearContainerData_BR</Name>
				<Source><![CDATA[
    void clearContainerData_BR()
    {
        int fieldcountloc;

        for (fieldcountloc = 1; fieldcountloc < 16; fieldcountloc += 1)
        {
            datasize[fieldcountloc] = connull();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearMainContainer_BR</Name>
				<Source><![CDATA[
    void clearMainContainer_BR()
    {
        int fieldcountloc;

        for (fieldcountloc = 1; fieldcountloc < this.parmFieldCount(); fieldcountloc += 1)
        {
            fieldDimensions[fieldcountloc] = connull();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>configurationKey</Name>
				<Source><![CDATA[
    public configurationKeyId configurationKey()
    {
        return configurationkeynum(BankElectronicBanking);
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertAmountTransCurToAmountPaymCur</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts the specified amount from the currency of the open transaction to the currency of the
    ///    payment.
    /// </summary>
    /// <param name="_amountTransCur">
    ///    The amount in transaction currency to convert.
    /// </param>
    /// <param name="_transCompany">
    ///    The company where the transaction exists.
    /// </param>
    /// <param name="_transCurrencyCode">
    ///    The currency the transaction uses.
    /// </param>
    /// <param name="_paymCompany">
    ///    The company where the payment exists.
    /// </param>
    /// <param name="_paymCurrencyCode">
    ///    The payment currency.
    /// </param>
    /// <param name="_exchRateDate">
    ///    The date to use for exchange rate calculations; optional.
    /// </param>
    /// <param name="_crossRate">
    ///    The cross rate to use. The default is 0; optional.
    /// </param>
    /// <param name="_exchRate">
    ///    The exchange rate to use. The default is 0; optional.
    /// </param>
    /// <returns>
    ///    The amount converted to payment currency.
    /// </returns>
    protected AmountCur convertAmountTransCurToAmountPaymCur(
        Amount          _amountTransCur,
        CompanyId       _transCompany,
        CurrencyCode    _transCurrencyCode,
        CompanyId       _paymCompany,
        CurrencyCode    _paymCurrencyCode,
        TransDate       _exchRateDate   = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        ExchRate        _crossRate = 0,
        ExchRate        _exchRate = 0)
    {
        AmountCur amountPaymCur;
        AmountCur interimAmount;
        CurrencyCode transMstCurrency;
        CurrencyCode paymMstCurrency;
        CurrencyExchangeHelper transExchRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_transCompany).RecId), _exchRateDate);
        CurrencyExchangeHelper paymExchRateHelper  = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_paymCompany).RecId), _exchRateDate);

        if (_transCurrencyCode == _paymCurrencyCode)
        {
            // Currencies are the same between the marked transaction & the payment
            amountPaymCur = _amountTransCur;
        }
        else if (_crossRate != 0)
        {
            // Cross rate is specified, convert directly from payment to marked transaction currency
            amountPaymCur = CurrencyExchange::round(CurrencyExchange::calculateAmount(_amountTransCur, _crossRate), _paymCurrencyCode);
        }
        else
        {
            // Convert from transaction currency to transaction company currency
            interimAmount = transExchRateHelper.calculateTransactionToAccounting(_transCurrencyCode, _amountTransCur, false);

            if (_transCompany != _paymCompany)
            {
                // Convert from transaction company currency to payment company currency
                changecompany(_transCompany)
                {
                    // Get trans company currency
                    transMstCurrency = CompanyInfoHelper::standardCurrency();
                }

                changecompany(_paymCompany)
                {
                    // Get paym company currency
                    paymMstCurrency = CompanyInfoHelper::standardCurrency();
                }

                if (transMstCurrency != paymMstCurrency)
                {
                    interimAmount = transExchRateHelper.calculateAccountingToTransaction(paymMstCurrency, interimAmount, false);
                }
            }

            // Convert from payment company currency to payment currency
            if (_exchRate != 0)
            {
                paymExchRateHelper.parmExchangeRate1(_exchRate);
            }

            amountPaymCur = paymExchRateHelper.calculateAccountingToTransaction(_paymCurrencyCode, interimAmount, true);
        }

        return amountPaymCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createExchRate</Name>
				<Source><![CDATA[
    void createExchRate(ExchRate            _exchRate,
                        CurrencyCode        _currencyCode,
                        TransDate           _exchRateDate       = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                        EUROTriangulation   _euroTriangulation  = NoYes::No)
    {
        ExchangeRate::importExchangeRate(
            _currencyCode,
            Ledger::accountingCurrency(),
            Ledger::defaultExchangeRateType(),
            _exchRateDate,
            _exchRate,
            insertExchRates,
            updateExchRates);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymFee</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Create payment fee record in <c>LedgerJournalTrans</c> table.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    ///     A <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <param name = "_amountPaymFee">
    ///     The amount to be debited.
    /// </param>
    void createPaymFee(LedgerJournalTrans _ledgerJournalTrans, Amount _amountPaymFee = amountPaymFee)
    {
        LedgerJournalTrans      ledgerJournalTransFee;
        LedgerJournalEngine     ledgerJournalEngine = new LedgerJournalEngine();

        if (_amountPaymFee && feeLedgerDimension)
        {
            ttsbegin;

            ledgerJournalTransFee = _ledgerJournalTrans.data();
            ledgerJournalEngine.initCustPostingProfile(ledgerJournalTransFee);
            ledgerJournalEngine.initVendPostingProfile(ledgerJournalTransFee);

            ledgerJournalTransFee.AccountType = LedgerJournalACType::Ledger;
            ledgerJournalTransFee.parmLedgerDimension(feeLedgerDimension);

            if (_ledgerJournalTrans.BankAccountId)
            {
                ledgerJournalTransFee.parmOffsetAccount(_ledgerJournalTrans.BankAccountId, LedgerJournalACType::Bank);
            }

            if (!_ledgerJournalTrans.parmOffsetLedgerDimension())
            {
                if (!ledgerJournalTransFee.parmOffsetLedgerDimension())
                {
                    ledgerJournalTransFee.OffsetAccountType = _ledgerJournalTrans.OffsetAccountType;
                    ledgerJournalTransFee.parmOffsetLedgerDimension(_ledgerJournalTrans.LedgerDimension, _ledgerJournalTrans.Company);
                }
            }

            ledgerJournalTransFee.FurtherPostingType    = NoYes::No;
            ledgerJournalTransFee.FurtherPostingRecId   = 0;
            ledgerJournalTransFee.BankPromissoryNoteNum = '';
            ledgerJournalTransFee.PaymentStatus         = _ledgerJournalTrans.PaymentStatus;

            ledgerJournalTransFee.AmountCurDebit        = _amountPaymFee;
            ledgerJournalTransFee.AmountCurCredit       = 0;

            ledgerJournalTransFee.CurrencyCode          = sendersBankCurrencyCode;
            ledgerJournalTransFee.TaxGroup              = '';
            ledgerJournalTransFee.TaxItemGroup          = '';

            ledgerJournalTransFee.SettleVoucher         = this.getSettlementType();

            if (sumBankAmount)
            {
                ledgerJournalTransFee.ExchRate          = returnExchRateBankStdSum[accountIdx];

                if (this.feeInAmountCharged())
                {
                    ledgerJournalTransFee.OffsetLedgerDimension = 0;
                }
            }
            else
            {
                if (_ledgerJournalTrans.CurrencyCode == sendersBankCurrencyCode)
                {
                    ledgerJournalTransFee.ExchRate          = _ledgerJournalTrans.ExchRate;
                }
                else
                {
                    ledgerJournalTransFee.ExchRate          = ExchangeRateHelper::exchRate(ledgerJournalTransFee.CurrencyCode, ledgerJournalTransFee.TransDate);
                }

                ledgerJournalTransFee.LineNum               += 0.0001;
            }

            ledgerJournalTransFee.PaymentNotes  = '';
            ledgerJournalTransFee.insert();

            ttscommit;

            this.fillControlReport(ledgerJournalTransFee);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettlementType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the settlement type.
    /// </summary>
    /// <returns>
    ///     The settlement type.
    /// </returns>
    protected SettlementType getSettlementType()
    {
        return SettlementType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSumBankAmount</Name>
				<Source><![CDATA[
    public void createSumBankAmount(LedgerTransType _ledgerTransType)
    {
        LedgerJournalTrans ledgerJournalTrans;

        for (accountIdx=1;accountIdx<=accountIdxMax;accountIdx++)
        {
            // A new LedgerJournalTrans is created
            ledgerJournalTrans.clear();

            if (newJournalId)
            {
                ledgerJournalTrans.JournalNum        = newJournalId;
            }
            else
            {
                ledgerJournalTrans.JournalNum        = journalIdSum[accountIdx];
            }

            // payment method
            ledgerJournalTrans.PaymMode          = paymModeSum[accountIdx];
            // date of import
            ledgerJournalTrans.LoadingDate       = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
            ledgerJournalTrans.TransDate         = transDateSum[accountIdx];

            ledgerJournalTrans.parmAccount(offsetAccountSum[accountIdx], offsetAccountTypeSum[accountIdx], curext());

            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Bank)
            {
                ledgerJournalTrans.BankAccountId = ledgerJournalTrans.parmAccount();
            }

            ledgerJournalTrans.TransactionType   = _ledgerTransType;
            ledgerJournalTrans.OffsetCompany     = curext();

            bankAccountTable                     = BankAccountTable::findByLedgerDimension(ledgerJournalTrans.LedgerDimension);

            if (bankAccountTable && !bankAccountTable.BankMultiCurrency && returnExchRateBankStdSum[accountIdx] && amountCurChargedSum[accountIdx])
            {
                ledgerJournalTrans.CurrencyCode      = bankAccountTable.CurrencyCode;

                ledgerJournalTrans.ExchRate          = returnExchRateBankStdSum[accountIdx];

                if (amountCurChargedSum[accountIdx] > 0)    //allways > 0
                {
                    ledgerJournalTrans.AmountCurCredit   = amountCurChargedSum[accountIdx];
                    ledgerJournalTrans.AmountCurDebit    = 0;
                }
                else                                    //not possible?
                {
                    ledgerJournalTrans.AmountCurCredit   = 0;
                    ledgerJournalTrans.AmountCurDebit    = -amountCurChargedSum[accountIdx];
                }

                ledgerJournalTrans.Triangulation     = Currency::triangulation(ledgerJournalTrans.CurrencyCode,
                                                                               ledgerJournalTrans.TransDate);
            }
            else
            {
                ledgerJournalTrans.CurrencyCode      = currencyCodeSum[accountIdx];

                ledgerJournalTrans.ExchRate          = exchRateSum[accountIdx];

                if (accountAmountSum[accountIdx] > 0)    //allways > 0
                {
                    ledgerJournalTrans.AmountCurCredit   = accountAmountSum[accountIdx];
                    ledgerJournalTrans.AmountCurDebit    = 0;
                }
                else                                    //not possible?
                {
                    ledgerJournalTrans.AmountCurCredit   = 0;
                    ledgerJournalTrans.AmountCurDebit    = -accountAmountSum[accountIdx];
                }

                ledgerJournalTrans.Triangulation     = Currency::triangulation(ledgerJournalTrans.CurrencyCode,
                                                                               ledgerJournalTrans.TransDate);
            }

            ledgerJournalTrans.ExchRateSecond    = ExchangeRateHelper::exchRateSecond(ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate);
            //ledgerJournalTrans.taxItemGroup      = TaxParameters::find().taxItemGroup;  //No Tax calculations on bank accounts

            ledgerJournalTrans.PaymReference  = bankReferenceNumberSum[accountIdx];

            ledgerJournalTrans.Txt               = this.parmPaymTxt();

            ledgerJournalTrans.Voucher           = voucherSum[accountIdx];

            ledgerJournalTrans.PaymentStatus     = CustVendPaymStatus::Confirmed;
            ledgerJournalTrans.BankTransType     = bankTransTypeSum[accountIdx];

            if (sumPaymFee)
            {
                this.createPaymFee(ledgerJournalTrans,amountPaymFeeSum[accountIdx]);
            }

            ledgerJournalTrans.insert();

            this.fillControlReport(ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyBy100</Name>
				<Source><![CDATA[
    boolean currencyBy100(CurrencyCode _currencyCode)
    {
        boolean retval;

        if (
            _currencyCode == 'NOK' || //Norge
            _currencyCode == 'SEK' || //Sverige
            _currencyCode == 'DKK' || //Danmark
            _currencyCode == 'CHF' || //Sveits
            _currencyCode == 'JPY' || //Japan
            _currencyCode == 'IDR' || //Indonesia
            _currencyCode == 'ISK' || //Island
            _currencyCode == 'CNY' || //Kina
            _currencyCode == 'HRK' || //Kroatia
            _currencyCode == 'LTL' || //Litauen
            _currencyCode == 'MAD' || //Marokko
            _currencyCode == 'SKK' || //Slovakia
            _currencyCode == 'KRW' || //SÃ¸r-Korea
            _currencyCode == 'TZS' || //Tanzania
            _currencyCode == 'CZK' || //Tsjekkia
            _currencyCode == 'TRL' || //Tyrkia
            _currencyCode == 'HUF' || //Ungarn
            _currencyCode == 'EEK' || //Estland
            _currencyCode == 'KES' || //Kenya
            _currencyCode == 'MXN' || //Mexico
            _currencyCode == 'PHP' || //Filippinene
            _currencyCode == 'PLN' || //Polen
            _currencyCode == 'RUB' || //Russland
            _currencyCode == 'LKR' || //Siri Lanka
            _currencyCode == 'TWD' || //Taiwan
            _currencyCode == 'THB' || //Thailand

            //Will be converted to Euro
            _currencyCode == 'GRD' || //Hellas
            _currencyCode == 'DEM' || //Tyskland
            _currencyCode == 'NLG' || //Nederland
            _currencyCode == 'BEF' || //Belgia
            _currencyCode == 'FRF' || //Frankrike
            _currencyCode == 'ITL' || //Italia
            _currencyCode == 'ATS' || //Ã˜sterike
            _currencyCode == 'FIM' || //Finland
            _currencyCode == 'ESP' || //Spania
            _currencyCode == 'PTE'    //Portugal
           )
        {
            retval = true;
        }
        return retval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteEmptyJournals</Name>
				<Source><![CDATA[
    void deleteEmptyJournals(RecordSortedList _transferredJournals = this.transferredJournals())
    {
        LedgerJournalTable  ledgerJournalTable;
        LedgerJournalTrans  ledgerJournalTrans;
        recId               ledgerDimension;

        ledgerJournalTrans.disableCache(true);

        ttsbegin;
        if (_transferredJournals.first(ledgerJournalTable))
        do
        {
            while select count(RecId) from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
            {
                ledgerJournalTable.reread();
                if (ledgerJournalTrans.RecId == 0)
                {
                    ledgerJournalTable.delete();
                }
                //PSSE 7816
                else
                {
                    delete_from ledgerJournalTrans
                        where ledgerJournalTrans.JournalNum       == ledgerJournalTable.JournalNum
                            && ledgerJournalTrans.AmountCurDebit  == 0
                            && ledgerJournalTrans.AmountCurCredit == 0;

                    select count(RecId) from ledgerJournalTrans
                        where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum;

                    if (ledgerJournalTrans.RecId == 0)
                    {
                        ledgerJournalTable.delete();
                    }

                    while select sum(AmountCurDebit), sum(AmountCurCredit) from ledgerJournalTrans
                        where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                    {
                        if ((ledgerJournalTrans.AmountCurDebit == 0)
                            && (ledgerJournalTrans.AmountCurCredit == 0))
                        {
                            while select forupdate ledgerJournalTrans
                                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                            {
                                ledgerJournalTrans.delete(false);
                            }
                            while select count(RecId) from ledgerJournalTrans
                                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                            {
                                if (ledgerJournalTrans.RecId == 0)
                                {
                                    ledgerJournalTable.delete();
                                }
                            }
                        }
                        else
                        {
                            while select LedgerDimension, sum(AmountCurDebit), sum(AmountCurCredit) from ledgerJournalTrans
                                group by LedgerDimension
                                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                            {
                                if ((ledgerJournalTrans.AmountCurDebit == 0)
                                    && (ledgerJournalTrans.AmountCurCredit == 0))
                                {
                                    ledgerDimension = ledgerJournalTrans.parmLedgerDimension();
                                    while select forupdate ledgerJournalTrans
                                        where ledgerJournalTrans.JournalNum      == ledgerJournalTable.JournalNum
                                           && ledgerJournalTrans.LedgerDimension == ledgerDimension
                                    {
                                        ledgerJournalTrans.delete(false);
                                    }
                                    while select count(RecId) from ledgerJournalTrans
                                        where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                                    {
                                        if (ledgerJournalTrans.RecId == 0)
                                        {
                                            ledgerJournalTable.delete();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                //END PSSE 7816
            }
        }
        while (_transferredJournals.next(ledgerJournalTable));
        ttscommit;

        ledgerJournalTrans.disableCache(false);
        Dictionary::dataFlush(tablenum(LedgerJournalTrans));
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be built by using the <c>Dialog</c> class or by using a class that is created in the
    ///    Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogGroup dialogGroup;
        FormBuildControl formBuildControl;

        baseDialog = new DialogRunbase(this.fileUploadGroupName(), this);
        dialogGroup = baseDialog.addGroup(this.fileUploadGroupName());

        formBuildControl = baseDialog.formBuildDesign().control(dialogGroup.name());
        dialogFileUpload = formBuildControl.addControlEx(classstr(FileUpload), 'FileUpload');
        dialogFileUpload.style(FileUploadStyle::MinimalWithFilename);
        dialogFileUpload.baseFileUploadStrategyClassName(classstr(PaymentFileTemporaryStorageStrategy));
        dialogFileUpload.fileNameLabel("@SYS308842");

        return baseDialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fileUploadGroupName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the label for the file upload group.
    /// </summary>
    /// <returns>
    /// The label for the file upload group.
    /// </returns>
    protected str fileUploadGroupName()
    {
        return "@SYS309953";
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Disables the dialog Ok button until the file upload is complete.
    /// </summary>
    /// <param name="_dialog">The <c>Runbase</c> dialog object.</param>
    public void dialogPostRun(DialogRunbase _dialog)
    {
	    fileUpload = _dialog.formRun().control(_dialog.formRun().controlId('FileUpload'));
        fileUpload.notifyUploadCompleted += eventhandler(this.uploadCompleted);
        this.setDialogOkButtonEnabled(_dialog, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>uploadCompleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// After the file has been uploaded, the Ok button is enabled.
    /// </summary>
    public void uploadCompleted()
    {
        filename = fileUpload.fileName();

        this.setDialogOkButtonEnabled(baseDialog, true);

        fileStream = fileUpload.getUploadedFile(true);

        fileUpload.notifyUploadCompleted -= eventhandler(this.UploadCompleted);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDialogOkButtonEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables or disables the dialog Ok button.
    /// </summary>
    /// <param name = "_dialog">The <c>Runbase</c> dialog object.</param>
    /// <param name = "_isEnabled">Indicates to enable or disable the Ok button.</param>
    protected void setDialogOkButtonEnabled(DialogRunbase _dialog, boolean _isEnabled)
    {
        FormControl okButtonControl = _dialog.formRun().control(_dialog.formRun().controlId('OkButton'));

        if (okButtonControl)
        {
            okButtonControl.enabled(_isEnabled);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorText</Name>
				<Source><![CDATA[
    str errorText(Counter statusCode)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>feeInAmountCharged</Name>
				<Source><![CDATA[
    public boolean feeInAmountCharged()
    {
        return feeInAmountCharged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchTransCurrencyCode</Name>
				<Source><![CDATA[
    abstract protected CurrencyCode fetchTransCurrencyCode(
        RefTableId  _refTableId,
        RefRecId    _refRecId,
        CompanyId  _refCompany)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillControlReport</Name>
				<Source><![CDATA[
    protected void fillControlReport(LedgerJournalTrans _ledgerJournalTrans)
    {
        numOfRecord++;
        recordContainer[numOfRecord] =  [_ledgerJournalTrans];
        recordRecId                  += _ledgerJournalTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fromDisk2Journal</Name>
				<Source><![CDATA[
    protected void fromDisk2Journal()
    {
        container   record;

        while (! file.status())
        {
            record = file.read();

            this.processRecord(record);
            // <GBR>
            if (BrazilParameters::isEnabled() && isFileImportedAlready)
            {
                break;
            }
            // </GBR>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fromDisk2JournalComplex_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initiates the process that retrieves the return information from the file sent by the bank and updates the ledger journal transactionts.
    /// </summary>
    /// <returns>
    ///     True if the process went successfully; false otherwise.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///     Exception thrown if there is any problem opening the file.
    /// </exception>
    boolean fromDisk2JournalComplex_BR()
    {
        if (this.parmlayoutType() == ConfLayoutTypesChoice_BR::FixedLength)
        {
            file = this.convertFileStreamToStreamIO();
        }

        if (this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
        {
            file = this.convertFileStreamToStreamIO(StreamType::CommaIo);
        }

        if (file)
        {
            if (file.status())
            {
                throw error("@SYS52680");
            }
            file.inFieldDelimiter('\r\n');
            file.inRecordDelimiter('\r\n');
            if (this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
            {
                file.inFieldDelimiter(delimiterChars);
            }
        }

        this.processRecordComplex_BR();

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountIdx</Name>
				<Source><![CDATA[
    public int getAccountIdx(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalACType _offsetAccountType, LedgerJournalAC _offsetAccount)
    {
        ExchRate    tmpExchRate;

        accountIdx = 0;

        if (!accountIdxMax)
        {
            accountIdxMax = 1;
            accountIdx                          = accountIdxMax;
            transDateSum[accountIdx]            = _ledgerJournalTrans.TransDate;
            offsetAccountTypeSum[accountIdx]    = _offsetAccountType;
            offsetAccountSum[accountIdx]        = _offsetAccount;
            currencyCodeSum[accountIdx]         = _ledgerJournalTrans.CurrencyCode;
            exchRateSum[accountIdx]             = _ledgerJournalTrans.ExchRate;
            journalIdSum[accountIdx]            = _ledgerJournalTrans.JournalNum;
            bankTransTypeSum[accountIdx]        = _ledgerJournalTrans.BankTransType;
            paymModeSum[accountIdx]             = _ledgerJournalTrans.PaymMode;
            bankReferenceNumberSum[accountIdx]  = _ledgerJournalTrans.PaymReference;

            if (CompanyInfoHelper::standardCurrency() == sendersBankCurrencyCode)
            {
                returnExchRateBankStdSum[accountIdx]    = 100;
            }
            else
            {
                if (CompanyInfoHelper::standardCurrency() == currencyCodeMST)
                {
                    if (paymCurrencyMST == NoYes::Yes)
                    {
                        if (sendersBankCurrencyCodeISO == paymCurrencyCodeISO)
                        {
                            returnExchRateBankStdSum[accountIdx]    = returnExchRate;
                        }
                        else
                        {
                            if (this.inverseExchRate())
                            {
                                returnExchRateBankStdSum[accountIdx] = returnExchRateMST / returnExchRate * 100;
                            }
                            else
                            {
                                returnExchRateBankStdSum[accountIdx] = returnExchRateMST * returnExchRate / 100;
                            }
                        }
                    }
                    else
                    {
                        if (sendersBankCurrencyCodeISO == paymCurrencyCodeISO)
                        {
                            returnExchRateBankStdSum[accountIdx]    = returnExchRate;
                        }
                        else
                        {
                            returnExchRateBankStdSum[accountIdx]    = returnExchRateMST;
                        }
                    }
                }
                else
                {
                    tmpExchRate                             = returnExchRateMST * returnExchRateMSTCrossRate;
                    returnExchRateBankStdSum[accountIdx]    = tmpExchRate;
                }
            }

            this.loadVoucherNum();
            voucherSum[accountIdx]              = voucherNum;
        }
        else
        {
            for (accountIdx=1;accountIdx<=accountIdxMax;accountIdx++)
            {
                if (transDateSum[accountIdx]           == _ledgerJournalTrans.TransDate     &&
                    offsetAccountTypeSum[accountIdx]   == _offsetAccountType                &&
                    offsetAccountSum[accountIdx]       == _offsetAccount                    &&
                    currencyCodeSum[accountIdx]        == _ledgerJournalTrans.CurrencyCode  &&
                    exchRateSum[accountIdx]            == _ledgerJournalTrans.ExchRate      &&
                   (sumBankInclRef ?
                    bankReferenceNumberSum[accountIdx] == _ledgerJournalTrans.PaymReference :
                    true))
                {
                    return accountIdx;
                }
            }
            accountIdxMax++;
            accountIdx                          = accountIdxMax;
            transDateSum[accountIdx]            = _ledgerJournalTrans.TransDate;
            offsetAccountTypeSum[accountIdx]    = _offsetAccountType;
            offsetAccountSum[accountIdx]        = _offsetAccount;
            currencyCodeSum[accountIdx]         = _ledgerJournalTrans.CurrencyCode;
            exchRateSum[accountIdx]             = _ledgerJournalTrans.ExchRate;
            journalIdSum[accountIdx]            = _ledgerJournalTrans.JournalNum;
            bankTransTypeSum[accountIdx]        = _ledgerJournalTrans.BankTransType;
            paymModeSum[accountIdx]             = _ledgerJournalTrans.PaymMode;
            bankReferenceNumberSum[accountIdx]  = _ledgerJournalTrans.PaymReference;

            if (CompanyInfoHelper::standardCurrency() == sendersBankCurrencyCode)
            {
                returnExchRateBankStdSum[accountIdx]    = 100;
            }
            else
            {
                if (CompanyInfoHelper::standardCurrency() == currencyCodeMST)
                {
                    if (paymCurrencyMST == NoYes::Yes)
                    {
                        if (sendersBankCurrencyCodeISO == paymCurrencyCodeISO)
                        {
                            returnExchRateBankStdSum[accountIdx]    = returnExchRate;
                        }
                        else
                        {
                            if (this.inverseExchRate())
                            {
                                returnExchRateBankStdSum[accountIdx] = returnExchRateMST / returnExchRate * 100;
                            }
                            else
                            {
                                returnExchRateBankStdSum[accountIdx] = returnExchRateMST * returnExchRate / 100;
                            }
                        }
                    }
                    else
                    {
                        if (sendersBankCurrencyCodeISO == paymCurrencyCodeISO)
                        {
                            returnExchRateBankStdSum[accountIdx]    = returnExchRate;
                        }
                        else
                        {
                            returnExchRateBankStdSum[accountIdx]    = returnExchRateMST;
                        }
                    }
                }
                else
                {
                    tmpExchRate = returnExchRateMST * returnExchRateMSTCrossRate;
                    returnExchRateBankStdSum[accountIdx]    = tmpExchRate;
                }
            }
            this.loadVoucherNum();
            voucherSum[accountIdx]              = voucherNum;
        }

        return accountIdx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyBaseUnit</Name>
				<Source><![CDATA[
    private CurrencyExchangeRate getCurrencyBaseUnit(CurrencyCode _currencyCode)
    {
        ExchangeRateCurrencyPair    exchangeRateCurrencyPair;
        ExchangeRateDisplayFactor   exchangeRateDisplayFactor;
        CurrencyExchangeRate        currencyBaseUnit;

        if (currencyBaseUnitMap)
        {
            if (currencyBaseUnitMap.exists(_currencyCode))
            {
                currencyBaseUnit = currencyBaseUnitMap.lookup(_currencyCode);
            }
        }
        else
        {
            currencyBaseUnitMap = new Map(Types::String, Types::Real);
        }

        if (!currencyBaseUnit)
        {
            select firstonly ExchangeRateDisplayFactor from exchangeRateCurrencyPair
                where exchangeRateCurrencyPair.FromCurrencyCode == _currencyCode
                   && exchangeRateCurrencyPair.ToCurrencyCode   == Ledger::accountingCurrency()
                   && exchangeRateCurrencyPair.ExchangeRateType == Ledger::defaultExchangeRateType();

            exchangeRateDisplayFactor = exchangeRateCurrencyPair.ExchangeRateDisplayFactor;

            if (!exchangeRateDisplayFactor)
            {
                exchangeRateDisplayFactor = this.currencyBy100(_currencyCode) ? ExchangeRateDisplayFactor::Hundred : ExchangeRateDisplayFactor::One;

                if (insertExchRates && _currencyCode != Ledger::accountingCurrency())
                {
                    exchangeRateCurrencyPair.selectForUpdate(true);
                    exchangeRateCurrencyPair.FromCurrencyCode           = _currencyCode;
                    exchangeRateCurrencyPair.ToCurrencyCode             = Ledger::accountingCurrency();
                    exchangeRateCurrencyPair.ExchangeRateType           = Ledger::defaultExchangeRateType();
                    exchangeRateCurrencyPair.ExchangeRateDisplayFactor  = exchangeRateDisplayFactor;
                    exchangeRateCurrencyPair.insert();
                }
            }

            currencyBaseUnit = CurrencyEuroDenomination::displayStoredExchangeRate_Static(100, exchangeRateDisplayFactor);

            currencyBaseUnit = currencyBaseUnit ? currencyBaseUnit : 1;
            currencyBaseUnitMap.insert(_currencyCode, currencyBaseUnit);
        }

        return currencyBaseUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFieldData_BR</Name>
				<Source><![CDATA[
    str getFieldData_BR(str _fieldData)
    {
        str fielddata;

        fielddata = strrem(strltrim(strrtrim(_fieldData)), textQualifier);

        return fielddata;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLayoutGroupID_BR</Name>
				<Source><![CDATA[
    void getLayoutGroupID_BR(PaymMode _paymMode,
                             SysModule _sysModule)
    {
        VendPaymModeTable   localVendPaymModeTable;
        CustPaymModeTable   localCustPaymModeTable;
        ConfLayoutGroups_BR confLayoutGroups_BR;
        ConfLayoutLines_BR  confLayoutLines_BR;
        int                 fieldCountLoc = 1;

        fieldCount            = 0;
        fieldCountBatchHeader = 0;
        readNextBatch         = true;

        switch (_sysModule)
        {
            case SysModule::Vend :
                select firstonly localVendPaymModeTable where localVendPaymModeTable.PaymMode == _paymMode;
                if (localVendPaymModeTable)
                {
                    layoutGroupID = localVendPaymModeTable.ReturnLayoutGroupId_BR;
                }
                break;

            case SysModule::Cust :
                select firstonly localCustPaymModeTable where localCustPaymModeTable.PaymMode == _paymMode;
                if (localCustPaymModeTable)
                {
                    layoutGroupID = localCustPaymModeTable.ReturnLayoutGroupId_BR;
                }
                break;
        }

        if (layoutGroupID)
        {
            confLayoutGroups_BR = ConfLayoutGroups_BR::find(layoutGroupID);

            if (!confLayoutGroups_BR.ConfRegisterType)
            {
                throw error(strFmt("@GLS100038",confLayoutGroups_BR.LayoutGroupId));
            }

            layoutType      = confLayoutGroups_BR.LayoutType;
            this.parmdelimiterChars_BR(confLayoutGroups_BR.ConfDelimitedByAlias);
            this.parmtextQualifier(confLayoutGroups_BR.Textqualifier);
            fileStructure      = confLayoutGroups_BR.FileStructure;

            if (fileStructure == ConfFileStructure_BR::Simple)
            {
                while select LayoutLineNum, LayoutLineType from confLayoutLines_BR
                    where confLayoutLines_BR.LayoutGroupId == layoutGroupID
                {
                    fieldCountLoc = 1;
                    if (this.parmlayoutType() == ConfLayoutTypesChoice_BR::FixedLength)
                    {
                        while select confLayoutFields_BR where confLayoutFields_BR.LayoutGroupId == layoutGroupID
                            && confLayoutFields_BR.LayoutLineNum == confLayoutLines_BR.LayoutLineNum
                        {
                            fieldDimensions[fieldCountLoc] = [confLayoutFields_BR.TableName,
                                                             confLayoutFields_BR.FieldName == "" ? num2char(151) :confLayoutFields_BR.FieldName,
                                                             confLayoutFields_BR.MethodName == "" ? num2char(151) :confLayoutFields_BR.MethodName,
                                                             confLayoutLines_BR.LayoutLineType,
                                                             confLayoutFields_BR.Value == "" ? num2char(151) :confLayoutFields_BR.Value,
                                                             confLayoutFields_BR.Format,
                                                             confLayoutFields_BR.StartPos,confLayoutFields_BR.Size];
                            fieldCountLoc = fieldCountLoc +1;
                        }
                        fieldCount = fieldCountLoc;
                    }

                    if (this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
                    {
                        while select confLayoutFields_BR order by FieldSeq where confLayoutFields_BR.LayoutGroupId == layoutGroupID
                            && confLayoutFields_BR.LayoutLineNum == confLayoutLines_BR.LayoutLineNum
                        {
                            fieldDimensions[fieldCountLoc] = [confLayoutFields_BR.TableName,
                                                              confLayoutFields_BR.FieldName == "" ? num2char(151) :confLayoutFields_BR.FieldName,
                                                              confLayoutFields_BR.MethodName == "" ?num2char(151) :confLayoutFields_BR.MethodName,
                                                              confLayoutLines_BR.LayoutLineType,
                                                              confLayoutFields_BR.Value == "" ? num2char(151) :confLayoutFields_BR.Value,
                                                              confLayoutFields_BR.Format,
                                                              confLayoutFields_BR.FieldSeq];
                            fieldCountLoc = fieldCountLoc +1;
                        }
                        fieldCount = fieldCountLoc;
                    }
                    this.update_EP_BR();
                }
            }
            else
            {
                this.fromDisk2JournalComplex_BR();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interfaceName</Name>
				<Source><![CDATA[
    public PaymInterfaceName interfaceName()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>inverseExchRate</Name>
				<Source><![CDATA[
    public boolean inverseExchRate()
    {
        return inverseExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inverseExchRateCheck</Name>
				<Source><![CDATA[
    public boolean inverseExchRateCheck(ExchRate _exchRate)
    {
        //Inverser currencies
        //We can not trust the banks that they handle this the same and treat the same currencies as inverse
        //so I test on charged amount (AmountCurCharged) and transfered amount (AmountCurTransfered)
        //to figure out if the exchange rate are inverse or not. This handles both the cases described below.

        //Inverse currencies is currencies where the exchange rate are inverse of what is 'normal'
        //Normal currencies are calculated on how many units of a currency you get from one USD e.g CAD approx 1.3
        //Inverse currencies are calculated on how many USD you have to pay for one unit of a currency e.g EUR approx 1.25
        //On one particular date in Feb or Mar 2004 the exchRates was 1 USD equals 1,3272 CAD and 1 EUR equals 1,2594 USD.
        //Inverse currencies are AUD, CYP, EUR, FJD, FKP, GBP, GIP, MTL, NZD og SHP (might be more).

        //What is more is that when USD is not involved there are some kind of priority list that define the direction of the
        //exchange reate. This can be bank dependent.

        //The analyze below is ment to give a correct answer of the direction of the exchange rate in any of these cases.

        boolean     ret;
        AmountCur   amountCurChargedCur;
        AmountCur   amountPaymFeeCur;

        if (sendersBankCurrencyCode == paymCurrencyCode)
        {
            amountCurChargedCur = amountCurCharged;
            amountPaymFeeCur    = amountPaymFee;
        }
        else
        {
            //Must correct the amount for different currency
            amountCurChargedCur = amountCurCharged * _exchRate /100;

            amountPaymFeeCur    = CurrencyExchangeHelper::curAmount2CurAmount(amountPaymFee, sendersBankCurrencyCode, paymCurrencyCode, returnExchDate, true);
        }

        if ((amountCurChargedCur - (this.feeInAmountCharged() ? amountPaymFeeCur : 0)) < amountCurTransfered)
        {
            if (_exchRate >= 100)
            {
                ret = false;
            }
            else
            {
                ret = true;
            }
        }
        else
        {
            if (_exchRate >= 100)
            {
                ret = true;
            }
            else
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalType</Name>
				<Source><![CDATA[
    abstract protected LedgerJournalType journalType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalTrans</Name>
				<Source><![CDATA[
    public LedgerJournalTrans ledgerJournalTrans(Counter _counter)
    {
        return conpeek(recordContainer[_counter],1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadVoucherNum</Name>
				<Source><![CDATA[
    void loadVoucherNum()
    {
        ttsbegin;
        voucherNum = NumberSeq::newGetVoucherFromId(numberSeqId, false).voucher();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfRecord</Name>
				<Source><![CDATA[
    public Counter numOfRecord()
    {
        return  numOfRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openFile</Name>
				<Source><![CDATA[
    abstract protected boolean openFile()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>openFileComplex_BR</Name>
				<Source><![CDATA[
    protected void openFileComplex_BR()
    {
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmdelimiterChars_BR</Name>
				<Source><![CDATA[
    void parmdelimiterChars_BR(ConfDelimitedByAlias_BR _confDelimitedByAlias)
    {
        switch (_confDelimitedByAlias)
        {
            case  '\\s' :
                delimiterChars = num2char(32);
                break;
            default :
                delimiterChars = _confDelimitedByAlias ;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFieldCount</Name>
				<Source><![CDATA[
    int  parmFieldCount()
    {
        return  fieldcount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInverseExchRate</Name>
				<Source><![CDATA[
    public boolean parmInverseExchRate(boolean _inverseExchRate = inverseExchRate)
    {
        inverseExchRate = _inverseExchRate;

        return inverseExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmlayoutGroupID</Name>
				<Source><![CDATA[
    ConfLayoutGroupId_BR  parmlayoutGroupID()
    {
        return  layoutGroupID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmlayoutType</Name>
				<Source><![CDATA[
    ConfLayoutType_BR  parmlayoutType()
    {
        return  layoutType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymentStatus</Name>
				<Source><![CDATA[
    void parmPaymentStatus(ConfLayoutGroupId_BR   _layoutID,
                           EPLayoutReturnOccCode_BR  _layoutReturnOccCode)
    {
        if ( this.parmReturnOccCode_BR(_layoutID,_layoutReturnOccCode))
        {
            switch (this.parmReturnOccCode_BR(_layoutID,_layoutReturnOccCode))
            {
                case #Recieved:
                    paymStatusCur = CustVendPaymStatus::Recieved;
                    break;
                case #Confirmed:
                    paymStatusCur = CustVendPaymStatus::Confirmed;
                    break;
                case #Rejected:
                    paymStatusCur = CustVendPaymStatus::Rejected;
                    break;
                case #Return:
                    paymStatusCur = CustVendPaymStatus::Rejected;
                    break;
                default :
                    paymStatusCur = CustVendPaymStatus::Sent;
            }
        }
        else
        {
            paymStatusCur = CustVendPaymStatus::Sent;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymMode</Name>
				<Source><![CDATA[
    public PaymMode parmPaymMode(PaymMode _paymMode = paymMode)
    {
        paymMode = _paymMode;

        return paymMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymTxt</Name>
				<Source><![CDATA[
    public LedgerJournalTransTxt parmPaymTxt(LedgerJournalTransTxt _paymTxt = paymTxt)
    {
        paymTxt = _paymTxt;

        return paymTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReturnOccCode_BR</Name>
				<Source><![CDATA[
    str parmReturnOccCode_BR(ConfLayoutGroupId_BR _layoutID,
                            EPLayoutReturnOccCode_BR _layoutReturnOccCode)
    {
        EPRetOccCodes_BR    epRetOccCodes_BR;

        select epRetOccCodes_BR where epRetOccCodes_BR.LayoutGroupId == _layoutID
            && epRetOccCodes_BR.LayoutRetOccCode == _layoutReturnOccCode;

        if ( epRetOccCodes_BR)
            return  enum2str(epRetOccCodes_BR.RetOccCode);
        else
            return "";
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSysmodule</Name>
				<Source><![CDATA[
    public SysModule parmSysmodule(SysModule _sysModule = sysModule)
    {
        sysModule = _sysModule;

        return sysModule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmtextQualifier</Name>
				<Source><![CDATA[
    void parmtextQualifier(ConfTextqualifier_BR    _textqualifiertype)
    {
        switch (_textqualifiertype)
        {
            case ConfText_qualifier_BR::DoubleQuotes  :
                textQualifier = num2char(34);
                break;
            case ConfText_qualifier_BR::SingleQuotes :
                textQualifier = num2char(39);
                break;
            case ConfText_qualifier_BR::None :
                textQualifier = "";
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parseDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parses a string containing a date.
    /// </summary>
    /// <param name="_dateString">A string containing the date.</param>
    /// <param name="_format">A string containing the format of the date.</param>
    /// <returns>A <c>date</c> value parsed.</returns>
    public TransDate parseDate(str _dateString, str _format)
    {
        int         dateDay;
        int         dateMonth;
        int         dateYear;
        boolean     ok = true;

        int getValueByMask(str _mask)
        {
            return str2int(substr(_dateString, strscan(_format, _mask, 1, strlen(_format)), strlen(_mask)));
        }

        if (strscan(_format, 'YYYY', 1, strlen(_format)) == 0)
        {
            dateYear = getValueByMask('YY');
            dateYear = str2Int(subStr(int2str(DateTimeUtil::year(DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()))), 1, 2) + int2str(dateYear));
            dateYear = year(mkdate(1,1,dateyear));
        }
        else
        {
            dateYear = getValueByMask('YYYY');
        }
        if (dateYear < year(datenull()) || dateYear > year(datemax()))
        {
            ok = checkFailed(strfmt("@GLS60369", dateYear));
        }

        dateMonth = getValueByMask('MM');
        if (dateMonth < 1 || dateMonth > 12)
        {
            ok = checkFailed(strfmt("@GLS60370", dateMonth));
        }

        dateDay = getValueByMask('DD');
        if (dateDay < 1 || dateDay > 31)
        {
            ok = checkFailed(strfmt("@GLS60371", dateDay));
        }

        if (!ok)
        {
            throw Error("@GLS1191");
        }

        return mkdate(dateDay, dateMonth, dateYear);
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymFee</Name>
				<Source><![CDATA[
    void paymFee(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (sumBankAmount)
        {
            if (!sumPaymFee)
            {
                this.createPaymFee(_ledgerJournalTrans);
            }
        }
        else
        {
            this.createPaymFee(_ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printControlReport</Name>
				<Source><![CDATA[
    protected void printControlReport()
    {
        Args                        args;
        //     CustVendPaymReportJournal   custVendPaymReportJournal;

        args = new Args();
        args.name('CustVendPaymJournal');
        args.object(this);
        args.parm('VendImport');
        /*

        custVendPaymReportJournal = new CustVendPaymReportJournal();
        custVendPaymReportJournal.getLast();
        custVendPaymReportJournal.run();
    */

        new MenuFunction(menuitemoutputstr(custVendPaymReportJournalRun), MenuItemType::Output).run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRecord</Name>
				<Source><![CDATA[
    abstract void processRecord(container record)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRecordComplex_BR</Name>
				<Source><![CDATA[
    protected void processRecordComplex_BR()
    {
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReturnAmount_BR</Name>
				<Source><![CDATA[
    AmountCur processReturnAmount_BR(container _record, int dataSizeCount, ConfLayoutTypesChoice_BR _layoutType)
    {
        #ConfMacros_BR

        AmountCur   paymentAmount;
        str         fieldFormat;
        int         lengthFormat;
        int         numOfdecimals;
        str         amount;
        str         fileLine;

        if (dataSize[dataSizeCount])
        {
            if (_layoutType == ConfLayoutTypesChoice_BR::FixedLength)
            {
                fieldFormat = conpeek(dataSize[dataSizeCount], 4); // format like 9(12)V9(2) or 9(12)9(2)
                if (conpeek(_record, 1))
                {
                    fileLine = conpeek(_record, 1);
                }
                amount = this.getFieldData_BR( substr(fileLine, conpeek(dataSize[dataSizeCount], 1), conpeek(dataSize[dataSizeCount], 2)));
            }
            else
            {
                fieldFormat = conpeek(dataSize[dataSizeCount], 3); // format like 9(12)V9(2) or 9(12)9(2)
                amount = conpeek(_record, conpeek(dataSize[dataSizeCount], 1));
            }

            lengthFormat = strlen(fieldFormat);
            if (strfind(fieldFormat, 'V', 3, lengthFormat))
            {
                paymentAmount = any2real(amount);
            }
            else
            {
                numOfdecimals = str2int(substr(fieldFormat, (strscan(fieldFormat, ')9(', 1, lengthFormat) +3), lengthFormat-1));
                amount = strins(amount, #FullStop, (strlen(amount) - numOfdecimals + 1));
                if (strscan(amount, #hyphen, 1, strlen(amount)))
                {
                    paymentAmount = -1 * str2num(strrem(amount, #hyphen));
                }
                else
                {
                    paymentAmount = str2num(amount);
                }
            }
        }

        return  paymentAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalcJournalBalances</Name>
				<Source><![CDATA[
    void recalcJournalBalances(RecordSortedList _transferredJournals = this.transferredJournals())
    {
        LedgerJournalTable  ledgerJournalTable;
        LedgerJournalTrans  ledgerJournalTrans;
        LedgerJournalEngine_Server ledgerJournalEngine = LedgerJournalEngine_Server::construct();

        ledgerJournalTrans.disableCache(true);

        if (_transferredJournals.first(ledgerJournalTable))
        do
        {
            // Recalculate balances on the old journal
            [ledgerJournalTable.JournalTotalDebit,
             ledgerJournalTable.JournalTotalCredit,
             ledgerJournalTable.JournalTotalOffsetBalance] = ledgerJournalEngine.initBalances(ledgerJournalTable.JournalNum,true);
            ledgerJournalTable.update();
        }
        while (_transferredJournals.next(ledgerJournalTable));

        ledgerJournalTrans.disableCache(false);
        Dictionary::dataFlush(tablenum(LedgerJournalTrans));
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        #OCCRetryCount
        if (! this.validate())
        {
            throw error("");
        }

        try
        {
            ttsbegin;

            this.update();

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBankAccount</Name>
				<Source><![CDATA[
    public void setBankAccount(LedgerJournalTrans _ledgerJournalTrans)
    {
        _ledgerJournalTrans.parmOffsetAccount(offsetAccount, LedgerJournalACType::Bank);
        sendersBankCurrencyCodeISO              = Currency::currencyCodeISO(bankAccountTable.CurrencyCode);
        sendersBankCurrencyCode                 = bankAccountTable.CurrencyCode;
        sendersBankMultiCurrency                = bankAccountTable.BankMultiCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExchangeRates</Name>
				<Source><![CDATA[
    void setExchangeRates()
    {
        ExchRate    paymCurrencyBaseUnit    = this.getCurrencyBaseUnit(paymCurrencyCodeISO);
        ExchRate    bankCurrencyBaseUnit;

        returnExchRate     = str2num(returnExchRateStr) / 1000000;      //Real exchRate with 8 decimals
        returnExchRateMst  = str2num(returnExchRateMSTStr) / 1000000;   //Real exchRate against MST (e.g. NOK) with 8 decimals

        if (sendersBankCurrencyCodeISO == currencyCodeMST)
        {
            returnExchRate      = returnExchRate / paymCurrencyBaseUnit;
            returnExchRateMST   = returnExchRateMST / paymCurrencyBaseUnit;
        }
        else    //Currency account
        {
            bankCurrencyBaseUnit = this.getCurrencyBaseUnit(sendersBankCurrencyCodeISO);
            if (sendersBankCurrencyCodeISO == paymCurrencyCodeISO)  //Payment currency same as bank currency
            {
                returnExchRate = returnExchRate / paymCurrencyBaseUnit;
            }
            else
            {
                //Allways baseunit=1 for returnExchRate when crossrate on currency account and one of the currencies are 1 based
                returnExchRate = returnExchRate / (bankCurrencyBaseUnit < paymCurrencyBaseUnit ? bankCurrencyBaseUnit : paymCurrencyBaseUnit);
            }

            //DnB has returnExchRateNOK on paymCurrency other banks bank Account currency
            returnExchRateMST = returnExchRateMST / (paymCurrencyMST ? paymCurrencyBaseUnit : bankCurrencyBaseUnit);

            if ((!returnExchRate && returnExchRateMST) ||
                ( returnExchRate && returnExchRateMST && (sendersBankCurrencyCodeISO == paymCurrencyCodeISO && returnExchRate == 100)))
            {
                returnExchRate = returnExchRateMST;
            }
        }

        this.parmInverseExchRate(this.inverseExchRateCheck(returnExchRate));

        //Calculate exchRate on MST currency from given exchRates
        if (returnExchRate && returnExchRateMST && (sendersBankCurrencyCodeISO != paymCurrencyCodeISO))
        {
            if (paymCurrencyMST == NoYes::Yes)  //(e.g. DnB in Norway)
            {
                returnExchRateMSTPaym = returnExchRateMST;
            }
            else
            {
                if (this.inverseExchRate())
                {
                    returnExchRateMSTPaym = returnExchRateMST * returnExchRate / 100;
                }
                else
                {
                    returnExchRateMSTPaym = (returnExchRateMST / returnExchRate) * 100;
                }
            }
        }
        else
        {
            returnExchRateMSTPaym = 0;
        }

        //Calculate crossRate if standarCurrency not equal PaymentFormat base currency (e.g. TelePay -> NOK)
        if (CompanyInfoHelper::standardCurrency() != currencyCodeMST)
        {
            returnExchRateMSTCrossRate = ExchangeRateHelper::getCrossRate_Static(
                Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                currencyCodeMST,
                returnExchDate);
        }
        else
        {
            returnExchRateMSTCrossRate = 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInverseExchRate</Name>
				<Source><![CDATA[
    ExchRate setInverseExchRate(ExchRate _exchRate)
    {
        AmountCur   amountCurChargedCur;
        AmountCur   amountPaymFeeCur;

        if (sendersBankCurrencyCode == paymCurrencyCode)
        {
            amountCurChargedCur = amountCurCharged;
            amountPaymFeeCur    = amountPaymFee;
        }
        else
        {
            //Must correct the amount for diffent currency
            amountCurChargedCur = CurrencyExchangeHelper::curAmount2CurAmount(amountCurCharged, sendersBankCurrencyCode, paymCurrencyCode, returnExchDate, true);
            amountPaymFeeCur    = CurrencyExchangeHelper::curAmount2CurAmount(amountPaymFee, sendersBankCurrencyCode, paymCurrencyCode, returnExchDate, true);
        }

        if ((amountCurChargedCur - (this.feeInAmountCharged() ? amountPaymFeeCur : 0)) < amountCurTransfered)
        {
            if (_exchRate >= 100)
            {
                _exchRate = _exchRate;
            }
            else
            {
                _exchRate = 100 * 100 / _exchRate;
            }
        }
        else
        {
            if (_exchRate >= 100)
            {
                _exchRate = 100 * 100 / _exchRate;
            }
            else
            {
                _exchRate = _exchRate;
            }
        }

        return _exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setJournalNum</Name>
				<Source><![CDATA[
    void setJournalNum(Args args)
    {
        LedgerJournalTrans  ledgerJournalTrans;

        if (args.dataset() == tablenum(LedgerJournalTrans))
        {
            ledgerJournalTrans = args.record();
            journalId = ledgerJournalTrans.JournalNum;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNumberSeqId</Name>
				<Source><![CDATA[
    void setNumberSeqId(RefRecId _numberSeqId)
    {
        if (newJournalNameId && !newJournalId)
        {
            if (LedgerJournalName::exist(newJournalNameId))
            {
                numberSeqId = LedgerJournalName::find(newJournalNameId).NumberSequenceTable;
                ttsbegin;
                newLedgerJournalTable.selectForUpdate(true);
                newLedgerJournalTable.clear();
                newLedgerJournalTable.JournalName   = newJournalNameId;
                newLedgerJournalTable.insert();
                newLedgerJournalTable.Name          = newName;
                newLedgerJournalTable.update();
                ttscommit;
                newJournalId                       = newLedgerJournalTable.JournalNum;
            }
            else
            {
                newJournalNameId = '';
                newJournalId  = '';
            }
        }

        if (!newJournalId)
        {
            numberSeqId = _numberSeqId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReturnValues</Name>
				<Source><![CDATA[
    public void setReturnValues(LedgerJournalTrans _ledgerJournalTrans)
    {
        _ledgerJournalTrans.TransDate        = returnExchDate ? returnExchDate : _ledgerJournalTrans.TransDate;

        if ((_ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::Confirmed
        //PS SE 8301
        || (_ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::Sent
            ||  _ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::Recieved) &&
                _ledgerJournalTrans.JournalNum != newJournalId))
        //END PS SE 8301
        {
            if (CompanyInfoHelper::standardCurrency() == currencyCodeMST)         //Standard Currency in Company
            {
                if (sendersBankCurrencyCode == currencyCodeMST)             //Bank Account in e.g. NOK
                {
                    if (paymCurrencyCode == currencyCodeMST)                //Domestic payment
                    {
                        _ledgerJournalTrans.ExchRate = 100;                 //Allready in JournalTrans?
                    }
                    else
                    {
                        _ledgerJournalTrans.ExchRate = returnExchRate ?         //ExchRate between PaymCurrency and BankAccount currency
                                                       returnExchRate :
                                                       _ledgerJournalTrans.ExchRate;

                        if (returnExchRate && returnExchDate)
                        {
                            this.createExchRate(_ledgerJournalTrans.ExchRate,paymCurrencyCode,returnExchDate);
                        }
                    }
                }
                else  //Currency Bank Account
                {
                    if (paymCurrencyCode == currencyCodeMST)        //Payment in Standard currency from currency account
                    {
                        _ledgerJournalTrans.ExchRate = 100;         //Allready in JournalTrans?
                    }
                    else
                    {
                        if (sendersBankCurrencyCode == paymCurrencyCode) //payment in same currency as bankaccount
                        {
                            _ledgerJournalTrans.ExchRate = returnExchRate ?         //ExchRate
                                                           returnExchRate :
                                                           _ledgerJournalTrans.ExchRate;

                            if (returnExchRate && returnExchDate)
                            {
                                this.createExchRate(_ledgerJournalTrans.ExchRate,paymCurrencyCode,returnExchDate);
                            }
                        }
                        else
                        {
                            _ledgerJournalTrans.ExchRate = returnExchRateMSTPaym ?
                                                           returnExchRateMSTPaym :
                                                           returnExchRate ?
                                                           returnExchRate :
                                                           _ledgerJournalTrans.ExchRate;
                            if (returnExchRate && returnExchDate)
                            {
                                this.createExchRate(_ledgerJournalTrans.ExchRate,paymCurrencyCode,returnExchDate);
                                if (returnExchRateMST && paymCurrencyMST == NoYes::No)
                                {
                                    this.createExchRate(returnExchRateMST,sendersBankCurrencyCode,returnExchDate);
                                }
                            }
                        }
                    }
                }
            }
            else    //Standard Currency != Payment format domestic currency e.g. TelePay (NO) -> NOK
            {
                if (CompanyInfoHelper::standardCurrency() == sendersBankCurrencyCode)     //Standar Currency == Bank Account currency
                {
                    if (paymCurrencyCode == sendersBankCurrencyCode)                //Payment Currency == Bank Account currency
                    {
                        _ledgerJournalTrans.ExchRate = 100;
                    }
                    else
                    {
                        if  (this.inverseExchRate())
                        {
                            _ledgerJournalTrans.ExchRate = returnExchRate ?
                                                           returnExchRate :
                                                           _ledgerJournalTrans.ExchRate;
                        }
                        else
                        {
                            _ledgerJournalTrans.ExchRate = returnExchRate ?
                                                           100 * 100 / returnExchRate :
                                                           _ledgerJournalTrans.ExchRate;
                        }
                        if (returnExchRate && returnExchDate)
                        {
                            this.createExchRate(_ledgerJournalTrans.ExchRate,paymCurrencyCode,returnExchDate);
                        }
                    }
                }
                else
                {
                    //standard currency is neither Payment format domestic currency (e.g. NO TelePay -> NOK) nor bank currency
                    _ledgerJournalTrans.ExchRate = returnExchRateMSTPaym && returnExchRateMSTCrossRate ?
                                                   returnExchRateMSTPaym *  returnExchRateMSTCrossRate :
                                                   returnExchRateMST     && returnExchRateMSTCrossRate ?
                                                   returnExchRateMST     *  returnExchRateMSTCrossRate :
                                                   _ledgerJournalTrans.ExchRate;
                    if ((returnExchRateMSTPaym || returnExchRateMST) && returnExchRateMSTCrossRate && returnExchDate)
                    {
                        this.createExchRate(_ledgerJournalTrans.ExchRate,paymCurrencyCode,returnExchDate);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setStatusOnPayment</Name>
				<Source><![CDATA[
    void setStatusOnPayment(PaymId              _paymId,
                            CustVendPaymStatus  _status,
                            ErrorCodePayment    _errorCodePayment = '')
    {
        LedgerJournalTable  ledgerJournalTable;
        LedgerJournalTrans  ledgerJournalTrans;
        #ISOCountryRegionCodes

        ttsbegin;
        while select forupdate ledgerJournalTable
            where   ledgerJournalTable.JournalType  == this.journalType()
        join ledgerJournalTrans
            where   ledgerJournalTrans.JournalNum   == ledgerJournalTable.JournalNum    &&
                    ledgerJournalTrans.PaymId       == _paymId
        {
            if (ledgerJournalTrans.RecId)
            {
                ledgerJournalTrans.PaymentStatus    = _status;
                ledgerJournalTrans.ErrorCodePayment = _errorCodePayment;
                ledgerJournalTrans.update();
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]))
                {
                    this.updateInvoicesFromPayment(ledgerJournalTrans);
                }
            }
            else
            {
                info(strfmt("@SYS68294", _paymId));
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumBank</Name>
				<Source><![CDATA[
    public void sumBank(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (sumBankAmount)
        {
            accountIdx                              =  this.getAccountIdx(_ledgerJournalTrans, offsetAccountType, offsetAccount);
            accountAmountSum[accountIdx]            += _ledgerJournalTrans.AmountCurDebit - _ledgerJournalTrans.AmountCurCredit;
            amountCurChargedSum[accountIdx]         += amountCurCharged;
            amountCurTransferedSum[accountIdx]      += amountCurTransfered;
            _ledgerJournalTrans.OffsetLedgerDimension = 0;

            amountPaymFeeSum[accountIdx]            += amountPaymFee;

            if (offsetAccountType == LedgerJournalACType::Bank)
            {
                _ledgerJournalTrans.BankAccountId = offsetAccount;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferredJournals</Name>
				<Source><![CDATA[
    RecordSortedList transferredJournals(RecordSortedList _transferredJournals = transferredJournals)
    {
        transferredJournals = _transferredJournals;
        return transferredJournals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>trimmedSubString</Name>
				<Source><![CDATA[
    public str trimmedSubString(str _string, int _startPosition, int _length)
    {
        return strLRTrim(substr(_string,_startPosition,_length));
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    void update()
    {
        this.openFile();
        this.fromDisk2Journal();
        this.updatePayments();
    }

]]></Source>
			</Method>
			<Method>
				<Name>update_EP_BR</Name>
				<Source><![CDATA[
    void update_EP_BR()
    {
        this.openFile();
        this.fromDisk2Journal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInvoicesFromPayment</Name>
				<Source><![CDATA[
    void updateInvoicesFromPayment(LedgerJournalTrans _ledgerJournalTrans)
    {
        SpecTrans   specTrans;

        ttsbegin;
        while select forupdate crosscompany specTrans
            where specTrans.SpecTableId == _ledgerJournalTrans.TableId &&
                  specTrans.SpecRecId   == _ledgerJournalTrans.RecId &&
                  specTrans.SpecCompany == _ledgerJournalTrans.company()
        {
            specTrans.PaymentStatus     = _ledgerJournalTrans.PaymentStatus;
            specTrans.ErrorCodePayment  = transTxt;
            changecompany(specTrans.company())
            {
                specTrans.update();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePayments</Name>
				<Source><![CDATA[
    void updatePayments()
    {
        LedgerJournalTable  ledgerJournalTable;
        LedgerJournalTrans  ledgerJournalTrans, ledgerJournalTransRejected;
        SpecTrans           specTrans;
        AmountCur           amountConfirmed,amountRejected;
        boolean             norwayEnabled = false;
        #ISOCountryRegionCodes

        AmountCur calcAmount()
        {
            ExchangeRateHelper  exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(ledgerJournalTrans.Company).RecId), ledgerJournalTrans.CurrencyCode);

            return this.convertAmountTransCurToAmountPaymCur(
                    specTrans.Balance01,
                    specTrans.RefCompany,
                    this.fetchTransCurrencyCode(specTrans.RefTableId, specTrans.RefRecId, specTrans.RefCompany),
                    ledgerJournalTrans.Company,
                    ledgerJournalTrans.CurrencyCode,
                    ledgerJournalTrans.TransDate,
                    specTrans.CrossRate,
                    exchangeRateHelper.prepareExchangeRateForStorage(ledgerJournalTrans.crossrate()));
        }

        norwayEnabled = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]);

        if (norwayEnabled)
        {
            ledgerJournalTransRejected.selectForUpdate(true);
        }

        ttsbegin;
        while select forupdate ledgerJournalTable
            where ledgerJournalTable.JournalType == this.journalType()
        join forupdate ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
        {
            amountConfirmed = 0;
            amountRejected  = 0;

            while select forupdate crosscompany specTrans
                where specTrans.SpecTableId == ledgerJournalTrans.TableId &&
                      specTrans.SpecRecId   == ledgerJournalTrans.RecId &&
                      specTrans.SpecCompany == ledgerJournalTrans.company()
            {
                switch (specTrans.PaymentStatus)
                {
                    case CustVendPaymStatus::Confirmed :
                        ledgerJournalTrans.PaymentStatus = CustVendPaymStatus::Confirmed;

                        amountConfirmed += calcAmount();

                        break;

                    case CustVendPaymStatus::Rejected :
                        if (!ledgerJournalTransRejected.RecId)
                        {
                            ledgerJournalTransRejected.data(ledgerJournalTrans);
                            ledgerJournalTransRejected.PaymentStatus = CustVendPaymStatus::Rejected;
                            ledgerJournalTransRejected.AmountCurCredit = 0;
                            ledgerJournalTransRejected.AmountCurDebit = 0;
                            ledgerJournalTransRejected.insert();
                        }
                        specTrans.SpecRecId = ledgerJournalTransRejected.RecId;
                        changecompany(specTrans.company())
                        {
                            specTrans.update();
                        }

                        amountRejected += calcAmount();

                        break;

                    default :
                }
            }
            if (amountConfirmed)
            {
                if (amountConfirmed < 0)
                {
                    ledgerJournalTrans.AmountCurDebit   = abs(amountConfirmed);
                    ledgerJournalTrans.AmountCurCredit  = 0;
                }
                else
                {
                    ledgerJournalTrans.AmountCurDebit   = 0;
                    ledgerJournalTrans.AmountCurCredit  = abs(amountConfirmed);
                }
                ledgerJournalTrans.update();
            }

            if (amountRejected)
            {
                if (amountRejected < 0)
                {
                    ledgerJournalTransRejected.AmountCurDebit   = abs(amountRejected);
                    ledgerJournalTransRejected.AmountCurCredit  = 0;
                }
                else
                {
                    ledgerJournalTransRejected.AmountCurDebit   = 0;
                    ledgerJournalTransRejected.AmountCurCredit  = abs(amountRejected);
                }
                //if there were no confirmed invoices
                if (!(ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::Confirmed))
                {
                    ledgerJournalTrans.PaymentStatus    = CustVendPaymStatus::Rejected;
                    ledgerJournalTrans.AmountCurCredit  = ledgerJournalTransRejected.AmountCurCredit;
                    ledgerJournalTrans.AmountCurDebit   = ledgerJournalTransRejected.AmountCurDebit;
                    ledgerJournalTrans.update();
                    //move marked invoices back to original LedgerJournalTrans

                    if (norwayEnabled)
                    {
                        while select forupdate crosscompany specTrans
                        where specTrans.SpecTableId == ledgerJournalTransRejected.TableId &&
                              specTrans.SpecRecId   == ledgerJournalTransRejected.RecId &&
                              specTrans.SpecCompany == ledgerJournalTransRejected.company()
                        {
                            specTrans.SpecRecId = ledgerJournalTrans.RecId;
                            changecompany(specTrans.company())
                            {
                                specTrans.update();
                            }
                        }
                    }
                    else
                    {
                        while select forupdate crosscompany specTrans
                        where specTrans.SpecRecId   == ledgerJournalTransRejected.RecId &&
                            specTrans.SpecTableId   == ledgerJournalTransRejected.TableId &&
                            specTrans.SpecCompany   == ledgerJournalTransRejected.company()
                        {
                            specTrans.SpecRecId = ledgerJournalTrans.RecId;
                            changecompany(specTrans.company())
                            {
                                specTrans.update();
                            }
                        }
                    }
                    ledgerJournalTransRejected.delete();
                }
                else
                {
                    if (norwayEnabled)
                    {
                        ledgerJournalTransRejected.Voucher = NumberSeq::newGetVoucherFromId(ledgerJournalTable.ledgerJournalName().NumberSequenceTable,
                          true).voucher();
                    }
                    else
                    {
                        ledgerJournalTransRejected.Voucher = new JournalVoucherNum(JournalTableData::newTable(ledgerJournalTable)).getNew(true);
                    }
                    ledgerJournalTransRejected.update();
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object _calledFrom = null)
    {
        boolean ret = true;
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]) && sumBankAmount && !newJournalNameId)
        {
            ret = checkFailed(strfmt("@SYS120095","@SYS66089","@SYS77392"));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static Object construct(SysModule    _sysModule,
                                   PaymMode     _paymMode)
    {
        DictClass   dictClass;
        Object      action;
        classId     classId;
        Query       infoActionQuery;

        switch (_sysModule)
        {
            case SysModule::Cust :
                classId = CustPaymModeTable::find(_paymMode).ClassIdReturn;

                if (! classId)
                {
                    infoActionQuery = new Query();
                    infoActionQuery.addDataSource(tablenum(CustPaymModeTable)).addRange(fieldnum(CustPaymModeTable,PaymMode)).value(_paymMode);

                    throw error(strfmt("@SYS63358", "@SYS67304", new DictType(extendedtypenum(PaymMode)).label(), _paymMode),
                                SysHelpPath::applForm(formstr(CustPaymMode)),
                                SysInfoAction_FormrunQuery::newFormnameControlnameQuery(formstr(CustPaymMode), 'actionClassNameReturn', infoActionQuery));
                }

                if (! SysDictClass::isSuperclass(classId,classnum(CustPaymReconciliationImport)))
                {
                    throw error(strfmt("@SYS66295",_paymMode));
                }

                break;

            case SysModule::Vend :
                classId = VendPaymModeTable::find(_paymMode).ClassIdReturn;

                if (! classId)
                {
                    infoActionQuery = new Query();
                    infoActionQuery.addDataSource(tablenum(VendPaymModeTable)).addRange(fieldnum(VendPaymModeTable,PaymMode)).value(_paymMode);

                    throw error(strfmt("@SYS63358", "@SYS67304", new DictType(extendedtypenum(PaymMode)).label(), _paymMode),
                                SysHelpPath::applForm(formstr(VendPaymMode)),
                                SysInfoAction_FormrunQuery::newFormnameControlnameQuery(formstr(VendPaymMode), 'actionClassNameReturn', infoActionQuery));
                }

                if (! SysDictClass::isSuperclass(classId,classnum(VendPaymReconciliationImport)))
                {
                    throw error(strfmt("@SYS66295",_paymMode));
                }

                break;
        }

        dictClass   = new DictClass(classId);
        action      = dictClass.makeObject();

        action.parmPaymMode(_paymMode);

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            action.parmSysModule(_sysModule);
        }
        // </GBR>

        return action;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    // Here goes a description of the class
    public static ClassDescription description()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertFileStreamToStreamIO</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens a new stream for reading based on the uploaded file.
    /// </summary>
    /// <param name = "_type">Type of stream to open.</param>
    /// <returns><c>StreamIo</c> object based on the upload file.</returns>
    protected StreamIo convertFileStreamToStreamIO(StreamType  _type = StreamType::AsciiIo)
    {
        StreamIo streamIo;

        switch (_type)
        {
            case StreamType::AsciiIo :
                streamIo = TextStreamIo::constructForRead(fileStream);
                break;

            case StreamType::CommaIo :
                streamIo = CommaTextStreamIo::constructForRead(fileStream);
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return streamIo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>