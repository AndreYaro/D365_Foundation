<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PriceDiscAdmCheckPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class    PriceDiscAdmCheckPost
extends         RunBaseBatch implements BatchRetryable
{
    #DEFINE.CurrentVersion(2)
    PriceDiscJournalNum             journalNum;
    PriceDiscAdmCheckActionType     checkActionType;
    Set                             priceDiscAdmTransSetSelected;
    boolean                         checkOnly;
    boolean                         isPosted;
    Array                           priceDiscAdmTransArrayBuffer;
    boolean                         overlapsFound;
    boolean                         gapsFound;
    // <GEERU>
    boolean                         countryRegion_RU;
    // </GEERU>

    container                       packedSet;
    private TmpRecIdFilter          tmpRecIdFilter;
    #localmacro.CurrentList
        journalNum,
        checkActionType,
        checkOnly,
        packedSet,
        isPosted
    #EndMacro

    #LocalMacro.FieldList
        Agreement,
        ItemCode,
        AccountCode,
        ItemRelation,
        AccountRelation,
        UnitId,
        QuantityAmountFrom,
        QuantityAmountTo,
        GenericCurrency,
        FromDate,
        ToDate,
        Amount,
        Currency,
        Percent1,
        Percent2,
        DisregardLeadTime,
        DeliveryTime,
        SearchAgain,
        PriceUnit,
        Relation,
        Markup,
        AllocateMarkup,
        Module,
        CalendarDays,
        InventDimId,
        AgreementHeaderExt_RU,
        InventBaileeFreeDays_RU
        // <GIN>
        , MaximumRetailPrice_IN
        // </GIN>
        , PDSCalculationId
    #EndMacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>mustCheckForOverlapsAndGaps</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to check for overlaps and gaps.
    /// </summary>
    /// <param name = "_tempPriceDiscAdmTrans">The temp <c>PriceDiscAdmTrans</c> record.</param>
    /// <param name = "_priceDiscAdmTrans">A <c>PriceDiscAdmTrans</c> record.</param>
    /// <returns>true if the overlaps and gaps must be checked; otherwise, false.</returns>
    protected boolean mustCheckForOverlapsAndGaps(PriceDiscAdmTrans _tempPriceDiscAdmTrans, PriceDiscAdmTrans _priceDiscAdmTrans)
    {
        return 
            (_tempPriceDiscAdmTrans.JournalNum != _priceDiscAdmTrans.JournalNum
                || (countryRegion_RU && _tempPriceDiscAdmTrans.AgreementHeaderExt_RU != _priceDiscAdmTrans.AgreementHeaderExt_RU)
                || _tempPriceDiscAdmTrans.Currency != _priceDiscAdmTrans.Currency
                        || _tempPriceDiscAdmTrans.UnitId != _priceDiscAdmTrans.UnitId
                        || _tempPriceDiscAdmTrans.InventDimId != _priceDiscAdmTrans.InventDimId
                        || _tempPriceDiscAdmTrans.Relation != _priceDiscAdmTrans.Relation
                        || _tempPriceDiscAdmTrans.AccountRelation != _priceDiscAdmTrans.AccountRelation
                        || _tempPriceDiscAdmTrans.AccountCode != _priceDiscAdmTrans.AccountCode
                        || _tempPriceDiscAdmTrans.ItemRelation != _priceDiscAdmTrans.ItemRelation
                        || _tempPriceDiscAdmTrans.ItemCode != _priceDiscAdmTrans.ItemCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the log field on the <c>PriceDiscAdmTrans</c> record buffer.
    /// </summary>
    /// <param name = "_priceDiscAdmTrans">
    /// A <c>PriceDiscAdmTrans</c> record buffer.
    /// </param>
    /// <param name = "_hasOverlaps">
    /// A Boolean value that specifies whether there are overlaps.
    /// </param>
    /// <param name = "_hasGaps">
    /// A Boolean value that specifies whether there are gaps.
    /// </param>
    protected void populateLog(PriceDiscAdmTrans _priceDiscAdmTrans, boolean _hasOverlaps, boolean _hasGaps)
    {
        _priceDiscAdmTrans.Log = '';

        if (_hasOverlaps)
        {
            _priceDiscAdmTrans.Log += "@SYS134950";
        }
        if (_hasGaps)
        {
            _priceDiscAdmTrans.Log += "@SYS134952";
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForOverlapsAndGaps</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether there are overlaps or gaps between the trade agreement lines
    /// in the priceDiscAdmTransArrayBuffer and flushes the priceDiscAdmTransArrayBuffer
    /// when <paramref name="_priceDiscAdmTrans"/> is not in the same group (does not have
    /// the same value on all the fields exist in the JournalRelationIdx index) as the
    /// PriceDiscAdmTrans records in the priceDiscAdmTransArrayBuffer. Then, inserts
    /// <paramref name="_priceDiscAdmTrans"/> into the priceDiscAdmTransArrayBuffer.
    /// </summary>
    /// <param name="_priceDiscAdmTrans">
    ///     The record that will be put into the priceDiscAdmTransArrayBuffer.
    /// </param>
    /// <remarks>
    ///     In a single journal validation, all the <paramref name="_priceDiscAdmTrans"/> passed
    /// as a parameter of this method should have already been sorted by the ascending order of
    /// the index JournalRelationIdx, the field AgreementHeaderExt_RU and QuantityAmountFrom.
    ///     Besides, this method should be called with an empty PriceDiscAdmTrans record as the
    /// parameter at the end of the journal validation in order to check the remaining records
    /// in the priceDiscAdmTransArrayBuffer.
    /// </remarks>
    protected void checkForOverlapsAndGaps(PriceDiscAdmTrans _priceDiscAdmTrans)
    {
        int priceDiscAdmTransArrayBufferLastIndex = priceDiscAdmTransArrayBuffer.lastIndex();

        if (priceDiscAdmTransArrayBufferLastIndex)
        {
            PriceDiscAdmTrans tempPriceDiscAdmTrans = priceDiscAdmTransArrayBuffer.value(1);
            if (this.mustCheckForOverlapsAndGaps(tempPriceDiscAdmTrans, _priceDiscAdmTrans))
            {
                boolean hasGaps[];
                boolean hasOverlaps[];
                int i;
                int j;

                for (i = 1; i <= priceDiscAdmTransArrayBufferLastIndex; i++)
                {
                    PriceDiscAdmTrans priceDiscAdmTrans = priceDiscAdmTransArrayBuffer.value(i);
                    priceDiscAdmTrans.Log = '';
                    boolean firstDateOverlap = true;
                    for (j = i + 1; j <= priceDiscAdmTransArrayBufferLastIndex; j++)
                    {
                        tempPriceDiscAdmTrans = priceDiscAdmTransArrayBuffer.value(j);
                        if (priceDiscAdmTrans.dateRangesOverlap(tempPriceDiscAdmTrans))
                        {
                            if (priceDiscAdmTrans.amountQuantitiesOverlap(tempPriceDiscAdmTrans))
                            {
                                hasOverlaps[i] = true;
                                hasOverlaps[j] = true;
                                overlapsFound = true;
                            }
                            else if (firstDateOverlap && tempPriceDiscAdmTrans.QuantityAmountFrom != priceDiscAdmTrans.QuantityAmountTo)
                            {
                                hasGaps[i] = true;
                                hasGaps[j] = true;
                                gapsFound = true;
                            }
                            if (firstDateOverlap)
                            {
                                firstDateOverlap = false;
                            }
                        }
                    }

                    this.populateLog(priceDiscAdmTrans, hasOverlaps[i], hasGaps[i]);

                    if (this.mustUpdateJournalLineForOverlapsAndGaps(priceDiscAdmTrans))
                    {
                        priceDiscAdmTrans.update();
                    }
                }
                priceDiscAdmTransArrayBuffer = new Array(Types::Record);
                priceDiscAdmTransArrayBufferLastIndex = 0;
            }
        }
        priceDiscAdmTransArrayBuffer.value(priceDiscAdmTransArrayBufferLastIndex + 1, _priceDiscAdmTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateJournalLineForOverlapsAndGaps</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the trade agreement journal line must be updated, when overlaps and gaps were found.
    /// </summary>
    /// <param name = "_priceDiscAdmTrans">A trade agreement journal line.</param>
    /// <returns>true if the journal line must be updated, when gaps and overlaps were found.</returns>
    protected boolean mustUpdateJournalLineForOverlapsAndGaps(PriceDiscAdmTrans _priceDiscAdmTrans)
    {
        return _priceDiscAdmTrans.Log != _priceDiscAdmTrans.orig().Log;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryForCheckJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for checking journals.
    /// </summary>
    /// <returns>A <c>Query</c> object</returns>
    protected Query buildQueryForCheckJournal()
    {
        Query query = new Query();

        QueryBuildDataSource priceDiscAdmTransSource = query.addDataSource(tableNum(PriceDiscAdmTrans));
        priceDiscAdmTransSource.update(true);
        QueryBuildRange journalNumRange = priceDiscAdmTransSource.addRange(fieldNum(PriceDiscAdmTrans, JournalNum));
        journalNumRange.value(queryValue(journalNum));

        this.addSelectionFieldsForCheckJournal(priceDiscAdmTransSource);
        this.addOrderByFieldsToPriceDiscAdmTrans(priceDiscAdmTransSource);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSelectionFieldsForCheckJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the selection fields for journal check.
    /// </summary>
    /// <param name = "_priceDiscAdmTransSource">The <c>PriceDiscAdmTrans</c> data source.</param>
    protected void addSelectionFieldsForCheckJournal(QueryBuildDataSource _priceDiscAdmTransSource)
    {
        _priceDiscAdmTransSource.addSelectionField(fieldNum(PriceDiscAdmTrans, JournalNum));
        _priceDiscAdmTransSource.addSelectionField(fieldNum(PriceDiscAdmTrans, Currency));
        _priceDiscAdmTransSource.addSelectionField(fieldNum(PriceDiscAdmTrans, UnitId));
        _priceDiscAdmTransSource.addSelectionField(fieldNum(PriceDiscAdmTrans, InventDimId));
        _priceDiscAdmTransSource.addSelectionField(fieldNum(PriceDiscAdmTrans, Relation));
        _priceDiscAdmTransSource.addSelectionField(fieldNum(PriceDiscAdmTrans, AccountRelation));
        _priceDiscAdmTransSource.addSelectionField(fieldNum(PriceDiscAdmTrans, AccountCode));
        _priceDiscAdmTransSource.addSelectionField(fieldNum(PriceDiscAdmTrans, ItemRelation));
        _priceDiscAdmTransSource.addSelectionField(fieldNum(PriceDiscAdmTrans, ItemCode));
        _priceDiscAdmTransSource.addSelectionField(fieldNum(PriceDiscAdmTrans, AgreementHeaderExt_RU));
        _priceDiscAdmTransSource.addSelectionField(fieldNum(PriceDiscAdmTrans, FromDate));
        _priceDiscAdmTransSource.addSelectionField(fieldNum(PriceDiscAdmTrans, ToDate));
        _priceDiscAdmTransSource.addSelectionField(fieldNum(PriceDiscAdmTrans, QuantityAmountFrom));
        _priceDiscAdmTransSource.addSelectionField(fieldNum(PriceDiscAdmTrans, QuantityAmountTo));
        _priceDiscAdmTransSource.addSelectionField(fieldNum(PriceDiscAdmTrans, Log));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addOrderByFieldsToPriceDiscAdmTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the order by fields for journal check.
    /// </summary>
    /// <param name = "_priceDiscAdmTransSource">The <c>PriceDiscAdmTrans</c> data source.</param>
    protected void addOrderByFieldsToPriceDiscAdmTrans(QueryBuildDataSource _priceDiscAdmTransSource)
    {
        _priceDiscAdmTransSource.addOrderByField(fieldNum(PriceDiscAdmTrans, JournalNum));
        _priceDiscAdmTransSource.addOrderByField(fieldNum(PriceDiscAdmTrans, Currency));
        _priceDiscAdmTransSource.addOrderByField(fieldNum(PriceDiscAdmTrans, UnitId));
        _priceDiscAdmTransSource.addOrderByField(fieldNum(PriceDiscAdmTrans, InventDimId));
        _priceDiscAdmTransSource.addOrderByField(fieldNum(PriceDiscAdmTrans, Relation));
        _priceDiscAdmTransSource.addOrderByField(fieldNum(PriceDiscAdmTrans, AccountRelation));
        _priceDiscAdmTransSource.addOrderByField(fieldNum(PriceDiscAdmTrans, AccountCode));
        _priceDiscAdmTransSource.addOrderByField(fieldNum(PriceDiscAdmTrans, ItemRelation));
        _priceDiscAdmTransSource.addOrderByField(fieldNum(PriceDiscAdmTrans, ItemCode));
        _priceDiscAdmTransSource.addOrderByField(fieldNum(PriceDiscAdmTrans, AgreementHeaderExt_RU));
        _priceDiscAdmTransSource.addOrderByField(fieldNum(PriceDiscAdmTrans, QuantityAmountFrom));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the price and discount agreement journal contains warnings.
    /// </summary>
    /// <param name="_acceptWarnings">
    ///    A Boolean value that specifies whether warnings are accepted; optional.
    /// </param>
    /// <returns>
    ///    true if only warnings are found; otherwise, false.
    /// </returns>
    public boolean checkJournal(boolean _acceptWarnings = true)
    {
        #ISOCountryRegionCodes
        countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        overlapsFound = false;
        gapsFound = false;
        priceDiscAdmTransArrayBuffer = new Array(Types::Record);

        this.checkJournalLines();

        // Check the remaining records in the priceDiscAdmTransArrayBuffer.
        PriceDiscAdmTrans priceDiscAdmTrans;
        this.checkForOverlapsAndGaps(priceDiscAdmTrans);

        if (overlapsFound)
        {
            this.showOverLapsFoundErrorBasedOnActionType();
        }
        if (gapsFound)
        {
            this.showGapsFoundErrorBasedOnActionType();
        }

        return overlapsFound || gapsFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showOverLapsFoundErrorBasedOnActionType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows the corresponding error messages for overlaps found, based on the <c>PriceDiscAdmCheckActionType</c>.
    /// </summary>
    protected void showOverLapsFoundErrorBasedOnActionType()
    {
        switch (checkActionType)
        {
            case PriceDiscAdmCheckActionType::ValidateSelected :
                checkFailed("@SYS4004590");
                break;

            case PriceDiscAdmCheckActionType::ValidateErrorsOrWarnings :
                checkFailed("@SYS4004591");
                break;

            case PriceDiscAdmCheckActionType::ValidateAll :
                checkFailed("@SYS4004586");
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showGapsFoundErrorBasedOnActionType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows the corresponding error messages for gaps found, based on the <c>PriceDiscAdmCheckActionType</c>.
    /// </summary>
    protected void showGapsFoundErrorBasedOnActionType()
    {
        switch (checkActionType)
        {
            case PriceDiscAdmCheckActionType::ValidateSelected :
                checkFailed("@SYS4004587");
                break;

            case PriceDiscAdmCheckActionType::ValidateErrorsOrWarnings :
                checkFailed("@SYS4004588");
                break;

            case PriceDiscAdmCheckActionType::ValidateAll :
                checkFailed("@SYS4004589");
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the journal lines.
    /// </summary>
    protected void checkJournalLines()
    {
        Query queryCheckJournal = this.buildCheckJournalLinesQuery();

        if (!queryCheckJournal)
        {
            return;
        }

        QueryRun queryRun = new QueryRun(queryCheckJournal);
        
        if (tmpRecIdFilter)
        {
            queryRun.setCursor(tmpRecIdFilter);
        }

        while (queryRun.next())
        {
            PriceDiscAdmTrans priceDiscAdmTrans = queryRun.get(tableNum(PriceDiscAdmTrans));
            this.checkForOverlapsAndGaps(priceDiscAdmTrans);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCheckJournalLinesQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for checking journal lines.
    /// </summary>
    /// <returns>A <c>Query</c> object.</returns>
    protected Query buildCheckJournalLinesQuery()
    {
        switch (checkActionType)
        {
            // Check the selected records only.
            case PriceDiscAdmCheckActionType::ValidateSelected :
                return this.buildJournalLinesQuerySelected();

            // Check the records with a non-empty log only.
            case PriceDiscAdmCheckActionType::ValidateErrorsOrWarnings :
                return this.buildJournalLinesQueryErrorsOrWarnings();

            // Check all the records in the journal.
            case PriceDiscAdmCheckActionType::ValidateAll :
                return this.buildJournalLinesQueryAll();
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildJournalLinesQuerySelected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for checking journal lines for the <c>PriceDiscAdmCheckActionType</c> - ValidateSelected.
    /// </summary>
    protected Query buildJournalLinesQuerySelected()
    {        
        Query                   queryCheckJournal = this.buildQueryForCheckJournal();
        SetEnumerator           recIdTempSetEnumerator = priceDiscAdmTransSetSelected.getEnumerator();

        while (recIdTempSetEnumerator.moveNext())
        {
            tmpRecIdFilter.clear();
            tmpRecIdFilter.RefRecId = recIdTempSetEnumerator.current();
            tmpRecIdFilter.doInsert();    
        }

        QueryBuildDataSource tmpRecIdFilterSource = queryCheckJournal.dataSourceTable(tableNum(PriceDiscAdmTrans)).addDataSource(tableNum(tmpRecIdFilter));
        
        tmpRecIdFilterSource.addLink(fieldNum(PriceDiscAdmTrans, RecId), fieldNum(TmpRecIdFilter, RefRecId));
        tmpRecIdFilterSource.fetchMode(QueryFetchMode::One2One);
        tmpRecIdFilterSource.joinMode(JoinMode::ExistsJoin);

        return queryCheckJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildJournalLinesQueryErrorsOrWarnings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for checking journal lines for the <c>PriceDiscAdmCheckActionType</c> - ValidateErrorsOrWarnings.
    /// </summary>
    protected Query buildJournalLinesQueryErrorsOrWarnings()
    {
        Query                   queryCheckJournal = this.buildQueryForCheckJournal();
        QueryBuildDataSource    priceDiscAdmTransSource = queryCheckJournal.dataSourceTable(tableNum(PriceDiscAdmTrans));
        QueryBuildRange         logRange = priceDiscAdmTransSource.addRange(fieldNum(PriceDiscAdmTrans, Log));
        logRange.value(SysQuery::valueNotEmptyString());

        return queryCheckJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildJournalLinesQueryAll</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for checking journal lines for the <c>PriceDiscAdmCheckActionType</c> - ValidateAll.
    /// </summary>
    protected Query buildJournalLinesQueryAll()
    {
        Query                   queryCheckJournal = this.buildQueryForCheckJournal();
        QueryBuildDataSource    priceDiscAdmTransSource = queryCheckJournal.dataSourceTable(tableNum(PriceDiscAdmTrans));
        QueryRun                queryRun = new QueryRun(queryCheckJournal);
       
        return queryCheckJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalCheckForGaps</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the record has warnings because of gaps.
    /// </summary>
    /// <param name="_priceDiscAdmTrans">
    ///     The record that will be checked.
    /// </param>
    /// <param name="_acceptWarnings">
    ///    A Boolean value that specifies whether warnings are accepted.
    /// </param>
    /// <returns>
    ///    true if warnings are found; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The functionality done by this method has been reconstructed and included in the newly introduced checkForOverlapsAndGaps method.
    /// </remarks>
    protected boolean checkJournalCheckForGaps(PriceDiscAdmTrans _priceDiscAdmTrans, boolean _acceptWarnings)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalCheckForOverlaps</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the record has warnings because of overlaps.
    /// </summary>
    /// <param name="_priceDiscAdmTrans">
    ///     The record that will be checked.
    /// </param>
    /// <param name="_acceptWarnings">
    ///    A Boolean value that specifies whether warnings are accepted.
    /// </param>
    /// <returns>
    ///    true if warnings are found; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The functionality done by this method has been reconstructed and included in the newly introduced checkForOverlapsAndGaps method.
    /// </remarks>
    protected boolean checkJournalCheckForOverlaps(PriceDiscAdmTrans _priceDiscAdmTrans, boolean _acceptWarnings)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValidateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the record has errors because of the execution
    /// of <c>PriceDiscAdmTrans.validateWrite</c> method.
    /// </summary>
    /// <param name="_priceDiscAdmTrans">
    ///     The record that will be checked.
    /// </param>
    /// <returns>
    ///    The <c>Log</c> which is empty if no errors are found;
    /// otherwise, the information about the errors.
    /// </returns>
    /// <remarks>
    /// The functionality done by this method has been removed from the journal validation scenario.
    /// </remarks>
    protected str checkValidateWrite(PriceDiscAdmTrans _priceDiscAdmTrans)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCheckActionType</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes the action type.
    /// </summary>
    /// <param name="_checkActionType">
    ///   An action type.
    /// </param>
    protected void initCheckActionType(PriceDiscAdmCheckActionType _checkActionType)
    {
        checkActionType = _checkActionType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initJournalNum</Name>
				<Source><![CDATA[
    void initJournalNum(PriceDiscJournalNum _journalNum)
    {
        journalNum = _journalNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPriceDiscAdmTransSetSelected</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes a set of selected records.
    /// </summary>
    /// <param name="_priceDiscAdmTransSetSelected">
    ///   A <c>Set</c> of selected records.
    /// </param>
    protected void initPriceDiscAdmTransSetSelected(Set _priceDiscAdmTransSetSelected)
    {
        priceDiscAdmTransSetSelected = _priceDiscAdmTransSetSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPosted</Name>
				<Source><![CDATA[
    boolean isPosted()
    {
        return isPosted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(boolean _checkOnly = false)
    {
        super();

        checkOnly = _checkOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container  pack()
    {
        packedSet = priceDiscAdmTransSetSelected.pack();

        return [#CurrentVersion ,#CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournalPost</Name>
				<Source><![CDATA[
    private void postJournalPost()
    {
        ttsbegin;

        PriceDiscAdmTable::deleteMarked(journalNum);

        PriceDiscAdmTable priceDiscAdmTable = PriceDiscAdmTable::find(journalNum, true);

        if (!priceDiscAdmTable.Posted)
        {
            this.createOrUpdatePriceDiscTableRecords();

            this.setPriceDiscAdmTableToPosted(priceDiscAdmTable);
            this.updatePriceDiscAdmTableToPosted(priceDiscAdmTable);

            isPosted = true;
        }

        ttscommit;

        this.trackPriceChangesForJournalAfterPosting(journalNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournal</Name>
				<Source><![CDATA[
    void postJournal()
    {
        #OCCRetryCount

        if (PriceDiscPostHandleExceptionsFlight::instance().isEnabled())
        {
            try
            {
                this.postJournalPost();
            }
            catch (Exception::DuplicateKeyException)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::DuplicateKeyExceptionNotRecovered;
                }
        
                retry;
            }
            catch (Exception::UpdateConflict)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
        
                retry;
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::Deadlock;
                }

                retry;
            }
            catch
            {
                error("@SYS21533");
            }
        }
        else
        {
            this.postJournalPost();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackPriceChangesForJournalAfterPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Track price changes for the trade agreement journal after posting the journal.
    /// </summary>
    /// <param name = "_journalNumber">The journal number posted.</param>
    private void trackPriceChangesForJournalAfterPosting(str _journalNumber)
    {
        if (RetailPriceChangeTrackingHelper::shouldSkipChangeTracking())
        {
            return;
        }

        RetailPriceChangeTrackingTradeAgreementPostJournalHandlerBatch postJournalHandlerBatchJob
            = RetailPriceChangeTrackingTradeAgreementPostJournalHandlerBatch::construct();
        postJournalHandlerBatchJob.parmJournalNumber(_journalNumber);

        BatchHeader batchHeader = BatchHeader::construct();
        batchHeader.parmRuntimeJob(true); // Set runtime then it can be deleted automatically when complete.
        batchHeader.addRuntimeTask(postJournalHandlerBatchJob, 0); // Add rumtime task, then it will be moved to the history tables and then be deleted by the cleanup job.
        batchHeader.save();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdatePriceDiscTableRecords</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates or updates the price agreements for the
    ///     lines of the trade agreement journal being posted.
    /// </summary>
    protected void createOrUpdatePriceDiscTableRecords()
    {
        this.updatePriceDiscTableRecords();

        PriceDiscTableCopyFromPriceDiscAdmTrans::newFromPurchTableVersion(journalNum).execute();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePriceDiscTableRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>PriceDiscTable</c> records for journal posting.
    /// </summary>
    protected void updatePriceDiscTableRecords()
    {
        PriceDiscAdmTrans priceDiscAdmTrans;
        priceDiscAdmTrans.JournalNum  = journalNum;
        priceDiscAdmTrans.MustBeDeleted = NoYes::No;
        PriceDiscAdmCheckPostPriceDiscTableUpdater updater =  PriceDiscAdmCheckPostPriceDiscTableUpdater::construct();
        updater.withPriceDiscAdmTransRange(priceDiscAdmTrans).execute();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPriceDiscAdmTableToPosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the <c>PriceDiscAdmTable</c> to posted.
    /// </summary>
    /// <param name = "_priceDiscAdmTable">A <c>PriceDiscAdmTable</c> record.</param>
    protected void setPriceDiscAdmTableToPosted(PriceDiscAdmTable _priceDiscAdmTable)
    {
        _priceDiscAdmTable.Posted        = NoYes::Yes;
        _priceDiscAdmTable.PostedDate    = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePriceDiscAdmTableToPosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>PriceDiscAdmTable</c> to posted.
    /// </summary>
    /// <param name = "_priceDiscAdmTable">A <c>PriceDiscAdmTable</c> record.</param>
    protected void updatePriceDiscAdmTableToPosted(PriceDiscAdmTable _priceDiscAdmTable)
    {
        _priceDiscAdmTable.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks and posts the price and discount agreement journal.
    /// </summary>
    /// <param name="_acceptWarnings">
    ///    A Boolean value that specifies whether warnings are accepted.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    The journal cannot be posted because it contains errors.
    /// </exception>
    public void run(boolean _acceptWarnings = false)
    {
        boolean         postJournal;
        DialogButton    dialogButton;
        PriceDiscAdmCheckPostOutputContract priceDiscAdmCheckPostOutputContract;
        PriceDiscAdmCheckPostInputContract  priceDiscAdmCheckPostInputContract = PriceDiscAdmCheckPostInputContract::construct();

        priceDiscAdmCheckPostInputContract.parmJournalNum(journalNum);
        priceDiscAdmCheckPostInputContract.parmCheckActionType(checkActionType);
        priceDiscAdmCheckPostInputContract.parmPriceDiscAdmTransSetSelected(priceDiscAdmTransSetSelected);
        priceDiscAdmCheckPostInputContract.parmCheckOnly(checkOnly);
        priceDiscAdmCheckPostInputContract.parmAcceptWarnings(_acceptWarnings);

        // Pass the input contract and validate and post the journal.
        priceDiscAdmCheckPostOutputContract = PriceDiscAdmCheckPostOutputContract::create(PriceDiscAdmCheckPost::runFromContract(priceDiscAdmCheckPostInputContract.pack()));
        postJournal   = priceDiscAdmCheckPostOutputContract.parmPostJournal();
        isPosted      = priceDiscAdmCheckPostOutputContract.parmIsPosted();

        if (postJournal)
        {
            if (checkOnly)
            {
                switch (checkActionType)
                {
                    case PriceDiscAdmCheckActionType::ValidateAll:
                        info("@SYS17146");
                        break;
                    case PriceDiscAdmCheckActionType::ValidateSelected:
                        info("@SYS4000085");
                        break;
                    case PriceDiscAdmCheckActionType::ValidateErrorsOrWarnings:
                        info("@SYS4000086");
                        break;
                }
            }
            else
            {
                info("@SYS5815");
            }
        }
        else
        {
            if (!checkOnly)
            {
                throw error("@SYS24802");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean  unpack(container  packedClass)
    {
        Version     version = RunBase::getVersion(packedClass);

        switch (version)
        {
            case #CurrentVersion:
                [version,#CurrentList] = packedClass;
                priceDiscAdmTransSetSelected = Set::create(packedSet);
                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    private static ClassDescription  description()
    {
        return  "@SYS4004676";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
    {
        Object                      callerForm;
        FormDataSource              dataSource;
        PriceDiscAdmCheckActionType checkActionType;
        Set                         priceDiscAdmTransSetSelected;
        PriceDiscAdmTrans           priceDiscAdmTrans;
        PriceDiscAdmTable           priceDiscAdmTable;
        PriceDiscAdmCheckPost       priceDiscAdmCheck;

        boolean isValidationActivity = true;


        // If the enumeration type is PriceDiscAdmCheckActionType, only checking will be done on the records
        if (args.parmEnumType() == enumNum(PriceDiscAdmCheckActionType))
        {
            priceDiscAdmCheck = new PriceDiscAdmCheckPost(true);
            checkActionType = args.parmEnum();
        }
        else
        {
            isValidationActivity = false;
            priceDiscAdmCheck = new PriceDiscAdmCheckPost(args.parmEnum());
            // The default action type is validate all
            checkActionType = PriceDiscAdmCheckActionType::ValidateAll;
        }

        if (!(args.dataset() == tableNum(PriceDiscAdmTrans)))
        {
            throw error("@SYS18626");
        }

        priceDiscAdmTrans = args.record();
        if (!priceDiscAdmTrans.JournalNum)
        {
            throw error("@SYS59010");
        }

        if (!priceDiscAdmTrans.RecId)
        {
            throw info("@SYS27671");
        }

        if (args.parmEnumType() != enumNum(PriceDiscAdmCheckActionType) && !args.parmEnum())
        {
            priceDiscAdmTable = PriceDiscAdmTable::find(priceDiscAdmTrans.JournalNum);

            if (priceDiscAdmTable.Posted)
            {
                throw error("@SYS21497");
            }
        }

        priceDiscAdmCheck.initJournalNum(priceDiscAdmTrans.JournalNum);

        priceDiscAdmTransSetSelected = new Set(typeName2Type(extendedTypeStr(RecId)));

        if (checkActionType == PriceDiscAdmCheckActionType::ValidateSelected)
        {
            dataSource = FormDataUtil::getFormDataSource(args.record());

            for (priceDiscAdmTrans = getFirstSelection(dataSource); priceDiscAdmTrans; priceDiscAdmTrans = dataSource.getNext())
            {
                priceDiscAdmTransSetSelected.add(priceDiscAdmTrans.RecId);
            }
        }

        priceDiscAdmCheck.initPriceDiscAdmTransSetSelected(priceDiscAdmTransSetSelected);
        priceDiscAdmCheck.initCheckActionType(checkActionType);
        priceDiscAdmCheck.saveLast();

        if (priceDiscAdmCheck.prompt())
        {
            using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContext(args))
            {
                SalesInstrumentationLogger instrumentationLogger = SalesInstrumentationLogger::createLogger(classStr(PriceDiscAdmCheckPost));

                if (isValidationActivity)
                {
                    using (var activity = instrumentationLogger.salesTradeAgreementJournalLineActivities().validate())
                    {
                        priceDiscAdmCheck.runOperation();
                    }
                }
                else
                {
                    using (var activity = instrumentationLogger.salesTradeAgreementJournalLineActivities().post())
                    {
                        priceDiscAdmCheck.runOperation();
                    }
                }
                
            }

            callerForm  = args.caller();

            if (callerForm)
            {
                if (priceDiscAdmCheck.isPosted())
                    callerForm.bookResearch();
                else
                    callerForm.bookRefresh();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the journal line must be checked.
    /// </summary>
    /// <param name = "_checkOnly">A boolean value indicating if the journal must only be checked.</param>
    /// <returns>true if the journal must be checked; otherwise, false.</returns>
    [Replaceable]
    protected boolean mustCheckJournal(boolean _checkOnly)
    {
        return _checkOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runFromContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes code validating and posting the journal.
    /// </summary>
    /// <param name="_packedPriceDiscAdmCheckPostInputContract">
    /// A packed <c>PriceDiscAdmCheckPostInputContract</c> class.
    /// </param>
    /// <returns>
    /// A packed <c>PriceDiscAdmCheckPostOutputContract</c> class.
    /// </returns>
    public static container runFromContract(container _packedPriceDiscAdmCheckPostInputContract)
    {
        PriceDiscAdmCheckPostInputContract  priceDiscAdmCheckPostInputContract  = PriceDiscAdmCheckPostInputContract::create(_packedPriceDiscAdmCheckPostInputContract);
        PriceDiscJournalNum                 journalNum                          = priceDiscAdmCheckPostInputContract.parmJournalNum();
        PriceDiscAdmCheckActionType         checkActionType                     = priceDiscAdmCheckPostInputContract.parmCheckActionType();
        Set                                 priceDiscAdmTransSetSelected        = priceDiscAdmCheckPostInputContract.parmPriceDiscAdmTransSetSelected();
        boolean                             checkOnly                           = priceDiscAdmCheckPostInputContract.parmCheckOnly();
        boolean                             warningsFound;
        boolean                             postJournal;

        PriceDiscAdmCheckPost priceDiscAdmCheck = new PriceDiscAdmCheckPost(checkOnly);
        priceDiscAdmCheck.initJournalNum(journalNum);
        priceDiscAdmCheck.initCheckActionType(checkActionType);
        priceDiscAdmCheck.initPriceDiscAdmTransSetSelected(priceDiscAdmTransSetSelected);

        ttsbegin;

        if (priceDiscAdmCheck.mustCheckJournal(CustParameters::find().CheckForOverlapsAndGaps))
        {
            warningsFound   = priceDiscAdmCheck.checkJournal();
        }

        postJournal = PriceDiscAdmCheckPost::canPostJournal(priceDiscAdmCheck, priceDiscAdmCheckPostInputContract, warningsFound);

        if (postJournal && !checkOnly)
        {
            priceDiscAdmCheck.postJournal();
        }

        ttscommit;
        PriceDiscAdmCheckPostOutputContract priceDiscAdmCheckPostOutputContract = PriceDiscAdmCheckPostOutputContract::construct();

        priceDiscAdmCheckPostOutputContract.parmWarningsFound(warningsFound);
        priceDiscAdmCheckPostOutputContract.parmPostJournal(postJournal);
        priceDiscAdmCheckPostOutputContract.parmIsPosted(priceDiscAdmCheck.isPosted());

        return priceDiscAdmCheckPostOutputContract.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether journal can be posted.
    /// </summary>
    /// <param name = "_priceDiscAdmCheck">Instance of <c>PriceDiscAdmCheckPost</c>.</param>
    /// <param name = "_priceDiscAdmCheckPostInputContract">Instance of the <c>PriceDiscAdmCheckPost</c> class.</param>
    /// <param name = "_warningsFound">Boolean value indicating whether warnings are found.</param>
    /// <returns>true if journal can be posted; otherwise, false.</returns>
    protected static boolean canPostJournal(PriceDiscAdmCheckPost _priceDiscAdmCheck, PriceDiscAdmCheckPostInputContract _priceDiscAdmCheckPostInputContract, boolean _warningsFound)
    {
        return !_warningsFound || _priceDiscAdmCheckPostInputContract.parmAcceptWarnings();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>