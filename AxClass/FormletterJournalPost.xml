<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>FormletterJournalPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>FormletterJournalPost</c> class is the base class used to post journals when updating
///    sales orders, purchase orders, and requests for quotes.
/// </summary>
/// <remarks>
///    The <c>formletterJournalPost</c> class implements the template pattern, and defines how to post a
///    journal with a header and some lines. There will be one child class for each type of journal that
///    can be posted as each journal type has its own set of tables.
/// </remarks>
abstract class FormletterJournalPost
{
    // <GEERU><GIN><GEEU>
    #ISOCountryRegionCodes
    #EECountryRegionCodes
    // </GEEU></GIN></GEERU>
    DocumentStatus              documentStatus;
    RecordInsertList            recordInsertListDocuref;
    RecordSortedList            recordSortedListJournalLines;
    Common                      journalTable;
    Common                      parmTable;
    Common                      journalLine;
    Common                      sourceLine;
    Common                      sourceTable;
    container                   packedLineIdSet;

    SalesPurchLine              salesPurchLine;
    boolean                     onlyOneCashDiscOnInvoice;

    FormletterJournal           formletterJournal;
    FormletterJournalTrans      formletterJournalTrans;

    Markup                      markup;
    Tax                         tax;
    FormletterProvider          formletterProvider;
    boolean                     ledgerVoucherIsSet;
    LedgerVoucher               ledgerVoucher;
    NumberSeq                   numberSeq;
    Voucher                     voucher;
    boolean                     postingInBatch;

    boolean                     printFormletter;
    TmpTaxWorkTrans             journalTmpTaxWorkTrans;
    boolean                     proforma;
    Printout                    printout;
    FormLetter                  formLetter;
    TransactionTxt              transactionTxt;
    InventQty                   updateNowInvent;
    PdsCWInventQty              cwUpdateNow;
    boolean                     recalcTotals;
    WMSShipmentId               shipmentId;
    WHSLoadId                   whsLoadId;
    TransDate                   transDate;

    int                         specQty;
    AccountOrder                sumBy;
    Num                         sumOrderId;
    boolean                     reduceOnHand;
    boolean                     storno;

    Set                         ordersPosted;
    Set                         linesPosted;
    Set                         sourceTableRecIdSet;

    ProjProposalJour            projProposalJour;
    Num                         journalNumber;

    RecordSortedList            recordListInventReportDimHistory;

    Object                      totals;

    boolean                     canEndSummaryPosting;
    Map                         transDateToLedgerVoucherObjectMap;
    Counter                     numberOfOrders;

    // <GIN>
    AmountCur                       withholdTaxAmount;
    TaxWithholdCodeType_IN          taxWithholdType;
    TaxWithholdCalculation_IN   taxWithholdCalculation;
    boolean isLedgerVoucherPosted;
    // </GIN>

    // <GEERU>
    FactureJour_RU              factureJour;
    container                   endDiscAmounts;
    container                   endDiscVrefIDs;
    boolean                     countryRegionIsRU;
    // </GEERU>

    FormLetterContract          chainFormletterContract;

    //<GMX>
    NoYes                       sendByMail_MX;
    //</GMX>

    PurchId                     purchIdPrev;
    boolean                     doCopyDocuRefOnLines;
    // <GBR>
    boolean                     isCountryRegionBR;
    // </GBR>

    boolean                     mcrPreviouslyShipped;
    RecId                       inventTransRecId;
    List                        docuRefRecIdList;

    boolean                     isPrePaymentJournalPost;
                
    Map taxDocumentLedgerVoucherMap;       

    private Set proformaJournalLineSet;
    private Map proformaJournalLineMap;
    private RefTableId journalLineTableId;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addTaxParentReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns the tax parent reference TableId and RecId to the specific implementation's invoice table TableId and RecId.
    /// </summary>
    /// <param name="_ledgerVoucherTransObject">
    /// The object to add the tax parent reference to.
    /// </param>
    /// <remarks>
    /// This method is intended to be overridden by child classes that need to support adding the tax parent reference
    /// to a <c>LedgerVoucherTransObject</c> as part of uptake of the <c>TaxTransGeneralJournalAccountEntry</c> table.
    /// </remarks>
    protected void addTaxParentReference(LedgerVoucherTransObject _ledgerVoucherTransObject)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToInventReportDimHistory</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Adds a record to the <c>InventReportDimHistory</c> table.
    /// </summary>
    /// <param name="_journalline">
    ///   A journal line record.
    /// </param>
    abstract protected void addToInventReportDimHistory(Common _journalline)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustAmountsMST_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adjusts the amount in the accounting currency.
    /// </summary>
    /// <remarks>
    ///     Overridden in descendants.
    /// </remarks>
    protected void adjustAmountsMST_W()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>afterLinePost</Name>
				<Source><![CDATA[
    /// <summary>
    ///   The method is being run before line is posted.
    /// </summary>
    protected void afterLinePost()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>beforeLinePost</Name>
				<Source><![CDATA[
    /// <summary>
    ///   The method is being run before line is posted.
    /// </summary>
    protected void beforeLinePost()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateMarkupAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates markup amount.
    /// </summary>
    public void calculateMarkupAmount_IN()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateVATDefermentTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method overrides in the child classes.
    /// </summary>
    public void calculateVATDefermentTax_IN()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>canEndLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>LedgerVoucher</c> object can be ended.
    /// </summary>
    /// <returns>
    ///    true if the <c>LedgerVoucher</c> can be ended; otherwise, false.
    /// </returns>
    protected boolean canEndLedgerVoucher()
    {
        return !ledgerVoucherIsSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostEndDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether end discounts can be posted.
    /// </summary>
    /// <returns>
    /// true if end discounts can be posted; otherwise, false.
    /// </returns>
    protected boolean canPostEndDisc()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether ledger postings can occur.
    /// </summary>
    /// <returns>
    /// true if ledger postings can occur; otherwise, false.
    /// </returns>

    protected boolean canPostLedger()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostRoundOff</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether end roundings can be posted.
    /// </summary>
    /// <returns>
    ///    true if roundings can be posted; otherwise, false.
    /// </returns>
    protected boolean canPostRoundOff()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether tax can be posted.
    /// </summary>
    /// <returns>
    /// true if tax can be posted; otherwise, false.
    /// </returns>
    protected boolean canPostTax()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostToInventory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether an order line can be inventory posted.
    /// </summary>
    /// <returns>
    ///    true if the order line can be inventory posted; otherwise, false.
    /// </returns>
    protected boolean canPostToInventory()
    {
        return formletterProvider.isStocked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscountAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the cash discount amount.
    /// </summary>
    /// <returns>
    ///   A cash discount amount.
    /// </returns>
    protected AmountCur cashDiscountAmount()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscPercent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the cash discount percentage.
    /// </summary>
    /// <returns>
    /// A cash discount percentage.
    /// </returns>
    protected DiscPct cashDiscPercent()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCashPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the ledger voucher was posted prior to settlement.
    /// </summary>
    /// <returns>
    /// true if the ledger voucher was posted prior to settlement; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Settlement posting requires subledger journal account entries to be created.
    /// If these subledger entries are generated prior to the settlement posting, then this
    /// method should return true.
    /// </remarks>
    protected boolean isCashPayment()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBeforePostingLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Performs validation before posting a line.
    /// </summary>
    protected void checkBeforePostingLine()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedgerPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether posting in the ledger period is allowed.
    /// </summary>
    /// <returns>
    ///    true if posting in the ledger period is allowed; otherwise, false.
    /// </returns>
    protected boolean checkLedgerPeriod()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotStockedLineAfterPosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies the not stocked order lines after posting.
    /// </summary>
    /// <param name="_notStockedPostCheck">
    ///    The <c>TradeNotStockedPostCheck</c> object to use for verification.
    /// </param>
    /// <returns>
    ///    true if the order line could be posted; otherwise, false.
    /// </returns>
    protected boolean checkNotStockedLineAfterPosting(TradeNotStockedPostCheck _notStockedPostCheck)
    {
        return _notStockedPostCheck.checkUpdatePhysicalAfterPosting();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotStockedLineBeforePosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies the not stocked order lines before posting.
    /// </summary>
    /// <param name="_notStockedPostCheck">
    ///    The <c>TradeNotStockedPostCheck</c> object to use for verification.
    /// </param>
    /// <returns>
    ///    true if the order line can be posted; otherwise, false.
    /// </returns>
    protected boolean checkNotStockedLineBeforePosting(TradeNotStockedPostCheck _notStockedPostCheck)
    {
        return _notStockedPostCheck.checkUpdatePhysicalBeforePosting();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Verifies the source line for the journal line.
    /// </summary>
    protected void checkSourceLine()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkRoundingQuantity</Name>
				<Source><![CDATA[
    protected void checkRoundingQuantity()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyDocuRefLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Copies document references to the journal line.
    /// </summary>
    protected void copyDocuRefLine()
    {
        if (doCopyDocuRefOnLines)
        {
            this.docuRefCopy(this.sourceLine(),this.journalLine());
        }

        // Journal line must be added to proforma set even when doCopyDocuRefOnLines set to false
        // as <c>DocuRef</c> table records might be copied to journal line by extensions.
        if (FormLetterProformaJournalRemoveDocuRefOnDocDeletionFlight::instance().isEnabled())
        {
            this.addToProformaJournalLineSet(this.journalLine());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToProformaJournalLineSet</Name>
				<Source><![CDATA[
    private void addToProformaJournalLineSet(Common _journalLine)
    {
        proformaJournalLineSet.add(_journalLine.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyDocuRefTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Copies document references to the journal header.
    /// </summary>
    protected void copyDocuRefTable()
    {
        Common          fromBuffer = this.sourceTable();
        Common          toBuffer = this.parmJournalTable();

        if (this.shouldCopyMultipleDocuRef())
        {
            this.docuRefCopyMultiple(fromBuffer.DataAreaId, fromBuffer.TableId, toBuffer);
        }
        else
        {
            this.docuRefCopy(fromBuffer, toBuffer);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFacture_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method used to create facture after invoice posted
    /// </summary>
    /// <returns>
    /// Created <c>FactureJour_RU</c> record
    /// </returns>
    /// <remarks>
    /// Overridden in <c>SalesFactureJournalPost_RU</c> and <c>PurchFactureJournalPost_RU</c>
    /// </remarks>
    protected FactureJour_RU createFacture_RU()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventReportDimHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a record in the <c>InventReportDimHistory</c> table.
    /// </summary>
    /// <param name="_inventTransId">
    /// An inventory transaction ID.
    /// </param>
    /// <param name="_inventDimId">
    /// An inventory dimension ID.
    /// </param>
    /// <param name="_transRefId">
    /// A reference ID.
    /// </param>
    /// <param name="_transactionQty">
    /// A transaction quantity.
    /// </param>
    /// <param name="_qtyRemain">
    /// The remaining quantity.
    /// </param>
    /// <returns>
    /// An inventory quantity.
    /// </returns>
    protected InventQty createInventReportDimHistory(
        InventTransId _inventTransId,
        InventDimId _inventDimId,
        InventTransRefId _transRefId,
        InventQty _transactionQty,
        InventQty _qtyRemain)
    {
        InventQty               qtyTrans;
        InventReportDimHistory  inventReportDimHistory;

        if (abs(_transactionQty) < abs(_qtyRemain))
        {
            qtyTrans   = -_transactionQty;
            _qtyRemain -= qtyTrans;
        }
        else
        {
            qtyTrans  = _qtyRemain;
            _qtyRemain = 0;
        }

        select firstonly * from inventReportDimHistory
            where inventReportDimHistory.TransactionLogType == this.inventReportDimHistoryLogType()
               && inventReportDimHistory.TransRefId == _transRefId
               && inventReportDimHistory.InventTransId == _inventTransId
               && inventReportDimHistory.InventDimId == _inventDimId;
   
        if (inventReportDimHistory.RecId != 0)
        {
            inventReportDimHistory.selectForUpdate(true);
            inventReportDimHistory.Qty += qtyTrans;
            inventReportDimHistory.update();
        }
        else
        {
            inventReportDimHistory.TransactionLogType = this.inventReportDimHistoryLogType();
            inventReportDimHistory.TransRefId = _transRefId;
            inventReportDimHistory.InventTransId = _inventTransId;
            inventReportDimHistory.InventDimId = _inventDimId;
 
            recordListInventReportDimHistory.find(inventReportDimHistory);
            
            inventReportDimHistory.Qty += qtyTrans; 
 
            this.insertInventReportDimHistory(inventReportDimHistory);
        }

        return _qtyRemain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNotStockedPostCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a <c>TradeNotStockedPostCheck</c> object that is used to verify order lines during
    /// posting.
    /// </summary>
    /// <returns>
    /// A <c>TradeNotStockedPostCheck</c> object that is used to verify order lines during posting.
    /// </returns>
    /// <remarks>
    /// This method can return null if no verification should be performed.
    /// </remarks>
    protected TradeNotStockedPostCheck createNotStockedPostCheck()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentDisbursement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Serves as the blank implementation of method.
    /// </summary>
    protected void createPaymentDisbursement()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentSched</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Creates a payment schedule.
    /// </summary>
    protected void createPaymentSched()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReportData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the data that can be used by the report.
    /// </summary>
    /// <param name="_formletterJournalPrint">
    /// An instance of the <c>FormletterJournalPrint</c> object.
    /// </param>
    /// <returns>
    /// true if the data is created; otherwise false.
    /// </returns>
    /// <remarks>
    /// In the base class it always returns false. It should be overwritten in the child classes that create the report data.
    /// </remarks>
    public boolean createReportData(FormletterJournalPrint _formletterJournalPrint)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether discounts should be credited.
    /// </summary>
    /// <returns>
    /// true if discounts should be credited; otherwise, false.
    /// </returns>
    protected boolean creditDiscount()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the posting is for a credit note.
    /// </summary>
    /// <returns>
    /// true if the posting is for a credit note; otherwise, false.
    /// </returns>
    protected NoYes creditNote()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the currency code for the journal.
    /// </summary>
    /// <returns>
    ///   A currency code.
    /// </returns>
    protected CurrencyCode currencyCode()
    {
        return formletterProvider.currencyCode();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dealQualityOrderLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deals the quality order line.
    /// </summary>
    protected void dealQualityOrderLine_IN()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAlternativeReturnEnabled_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the alternative posting profiles for the return sales order is enabled
    /// </summary>
    /// <returns>
    /// True if the alternative posting profiles for the return sales order is enabled; otherwise, false.
    /// </returns>
    protected boolean isAlternativeReturnEnabled_BR()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultLedgerTransactionText</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the default ledger transaction text.
    /// </summary>
    /// <returns>
    ///   A transaction text.
    /// </returns>
    protected LedgerTransTxt defaultLedgerTransactionText()
    {
        return LedgerTransTxt::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributeSourceDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the creation of distributions
    /// </summary>
    /// <remarks>
    ///    This method should be overridden by transactions that support distributions and subledger journal
    ///    lines.
    /// </remarks>
    protected void distributeSourceDocument()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the type of document.
    /// </summary>
    /// <returns>
    /// A <c>DocumentStatus</c> enumeration value.
    /// </returns>
    abstract protected DocumentStatus documentStatus()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>docuRefCopy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies attachments from a single source document to a single destination document.
    /// </summary>
    /// <param name="_from">
    /// A record representing source document from which attachments are copied.
    /// </param>
    /// <param name="_to">
    /// A record representing destination document to which attachments are copied.
    /// </param>
    protected void docuRefCopy(Common _from, Common _to)
    {
        this.docuRefCopyByRecId(
            _from.DataAreaId,
            _from.TableId,
            _from.RecId,
            _to.DataAreaId,
            _to.TableId,
            _to.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>docuRefCopyByRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies attachments between documents.
    /// </summary>
    /// <param name="_fromDataAreaId">
    /// Data Area ID of the document from which attachments are copied.
    /// </param>
    /// <param name="_fromTableId">
    /// Table ID of the document from which attachments are copied.
    /// </param>
    /// <param name="_fromRecId">
    /// Record ID of the document from which attachments are copied.
    /// </param>
    /// <param name="_toDataAreaId">
    /// Data Area ID of the document to which attachments are copied.
    /// </param>
    /// <param name="_toTableId">
    /// Table ID of the document to which attachments are copied.
    /// </param>
    /// <param name="_toRecId">
    /// Record ID of the document to which attachments are copied.
    /// </param>
    protected void docuRefCopyByRecId(
        DataAreaId _fromDataAreaId,
        TableId _fromTableId,
        RefRecId _fromRecId,
        DataAreaId _toDataAreaId,
        TableId _toTableId,
        RefRecId _toRecId)
    {
        DocuRef             docuRef;
        DocuRef             newDocuRef;
        // <GBR>
        BrazilParameters    brazilParameters;

        if (isCountryRegionBR)
        {
            brazilParameters  = BrazilParameters::find();
        }
        // </GBR>
        while select docuRef
            index RefIdx
            where docuRef.RefCompanyId == _fromDataAreaId
                && docuRef.RefTableId == _fromTableId
                && docuRef.RefRecId == _fromRecId
        {
            // <GBR>
            if (isCountryRegionBR
                && docuRef.TypeId == brazilParameters.FiscalDocumentTextDocuTypeId)
            {
                continue;
            }
            // </GBR>

            newDocuRef.data(docuRef);
            newDocuRef.DocumentId = newGuid();

            this.initializeDocuRef(newDocuRef, docuRef, _toDataAreaId, _toTableId, _toRecId);

            recordInsertListDocuref.add(newDocuRef);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeDocuRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the document reference.
    /// </summary>
    /// <param name = "_targetDocuRef">The document reference to initialize.</param>
    /// <param name = "_sourceDocuRef">The document reference to initialize from.</param>
    /// <param name="_toDataAreaId">
    /// Data Area ID of the document to which attachments are copied.
    /// </param>
    /// <param name="_toTableId">
    /// Table ID of the document to which attachments are copied.
    /// </param>
    /// <param name="_toRecId">
    /// Record ID of the document to which attachments are copied.
    /// </param>
    protected void initializeDocuRef(
        DocuRef     _targetDocuRef,
        DocuRef     _sourceDocuRef,
        DataAreaId  _toDataAreaId,
        TableId     _toTableId,
        RefRecId    _toRecId)
    {
        _targetDocuRef.RefCompanyId = _toDataAreaId;
        _targetDocuRef.RefTableId = _toTableId;
        _targetDocuRef.RefRecId = _toRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>docuRefCopyMultiple</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies attachments from a set of source documents to a destination document.
    /// </summary>
    /// <param name="_fromDataAreaId">
    /// Data Area ID of documents from which attachments are copied.
    /// </param>
    /// <param name="_fromTableId">
    /// Table ID of documents from which attachments are copied.
    /// </param>
    /// <param name="_to">
    /// A record representing document to which attachments are copied.
    /// </param>
    protected void docuRefCopyMultiple(
        DataAreaId _fromDataAreaId,
        TableId _fromTableId,
        Common _to)
    {
        if (!sourceTableRecIdSet.empty())
        {
            this.docuRefCopyMultipleByRecId(
                _fromDataAreaId,
                _fromTableId,
                sourceTableRecIdSet,
                _to.DataAreaId,
                _to.TableId,
                _to.RecId);
        }
        else
        {
            this.docuRefFindAndCopyMultiple(_to);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>docuRefCopyMultipleByRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies attachments from a set of source documents to a destination document.
    /// </summary>
    /// <param name="_fromDataAreaId">
    /// Data Area ID of documents from which attachments are copied.
    /// </param>
    /// <param name="_fromTableId">
    /// Table ID of documents from which attachments are copied.
    /// </param>
    /// <param name="_fromRecIdSet">
    /// Set of Record IDs representing the documents from which attachments are copied.
    /// </param>
    /// <param name="_toDataAreaId">
    /// Data Area ID of the document to which attachments are copied.
    /// </param>
    /// <param name="_toTableId">
    /// Table ID of the document to which attachments are copied.
    /// </param>
    /// <param name="_toRecId">
    /// Record ID of the document to which attachments are copied.
    /// </param>
    protected void docuRefCopyMultipleByRecId(
        DataAreaId _fromDataAreaId,
        TableId _fromTableId,
        Set _fromRecIdSet,
        DataAreaId _toDataAreaId,
        TableId _toTableId,
        RefRecId _toRecId)
    {
        SetEnumerator se = _fromRecIdSet.getEnumerator();

        while (se.moveNext())
        {
            this.docuRefCopyByRecId(
                _fromDataAreaId,
                _fromTableId,
                se.current(),
                _toDataAreaId,
                _toTableId,
                _toRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>docuRefFindAndCopyMultiple</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies attachments from a set of source documents to a destination document.
    /// </summary>
    /// <param name="_to">
    /// A record representing document to which attachments are copied.
    /// </param>
    /// <remarks>
    /// The set of records representing source documents from which attachments are copied
    /// needs to be determined by the subclass when overriding this method.
    /// </remarks>
    protected void docuRefFindAndCopyMultiple(Common _to)
    {
        // Do nothing. Specific document will override
        // knowing how to handle attachments from multiple sources.
    }

]]></Source>
			</Method>
			<Method>
				<Name>doPostNotStocked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts not stocked order lines.
    /// </summary>
    private void doPostNotStocked()
    {
        TradeNotStockedPostCheck notStockedPostCheck = this.createNotStockedPostCheck();

        if (VendInvoiceNonStockRoundingCheckFlight::instance().isEnabled())
        {
            this.checkRoundingQuantity();
        }
        
        if (notStockedPostCheck
            && !this.checkNotStockedLineBeforePosting(notStockedPostCheck))
        {
            throw error("@SYS21533");
        }

        this.postNotStocked();

        if (notStockedPostCheck
            && !this.checkNotStockedLineAfterPosting(notStockedPostCheck))
        {
            throw error("@SYS21533");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Invokes the actual posting process.
    /// </summary>
    protected void endLedgerVoucher()
    {
        if (!this.isCashPayment() && !this.requireGLPostingPriorToSettlement())
        {
            isLedgerVoucherPosted = ledgerVoucher.end();
        }

        if (this.requirePostCustVendAfterLedgerVoucherEnd())
        {
            this.postCustVend();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ends the posting of all journal lines.
    /// </summary>
    protected void endLines()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>endPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Ends the posting.
    /// </summary>
    protected void endPost()
    {
        if (numberSeq)
        {
            numberSeq.used();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endPostLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ends the posting of a journal line.
    /// </summary>
    protected void endPostLine()
    {
        RecId journalLineRecId = this.journalLine().RecId;

        if (journalLineRecId)
        {
            linesPosted.add(journalLineRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Ends the update of selected records.
    /// </summary>
    /// <remarks>
    ///    The <c>endUpdate</c> method in the derived classes contains the code for ending the posting of the
    ///    selected records posted by the derived <c>FormLetter</c> class.For example the <c>endUpdate</c>
    ///    method in the <c>SalesFormLetter</c> class ends the update for the selected sales orders.The
    ///    <c>endUpdate</c> method is added to the <c>FormLetter</c> class so that you can run the
    ///    <c>endUpdate</c> method when you post in batch.The <c>endUpdate</c> method is called from the
    ///    <c>run</c> method in the abstract classes derived from the <c>FormLetter</c> class, and from the
    ///    <c>run</c> method in the <c>FormLetterEndMultiThread</c> class.
    /// </remarks>
    protected void  endUpdate()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRate_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the exchange rate.
    /// </summary>
    /// <returns>
    ///     Always returns zero.
    /// </returns>
    /// <remarks>
    ///     Overridden in descendants.
    /// </remarks>
    protected ExchRate exchRate_W()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSec_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the secondary exchange rate.
    /// </summary>
    /// <returns>
    ///     Always returns zero.
    /// </returns>
    /// <remarks>
    ///     Overridden in descendants.
    /// </remarks>
    protected ExchrateSecondary exchRateSec_W()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>factureJour_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns <c>FactureJour_RU</c> record
    /// </summary>
    /// <returns>
    /// <c>FactureJour_RU</c> record
    /// </returns>
    public FactureJour_RU factureJour_RU()
    {
        return factureJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateLedgerVoucherObject</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds or creates the instance of the specified <c>LedgerVoucherObject</c> class.
    /// </summary>
    /// <param name="_voucher">
    ///    The voucher number of the instance of the <c>LedgerVoucherObject</c> class to find.
    /// </param>
    /// <param name="_accountingDate">
    ///    The accounting date of the instance of the <c>LedgerVoucherObject</c> class to find.
    /// </param>
    /// <returns>
    ///    The instance of the <c>LedgerVoucherObject</c> class found.
    /// </returns>
    protected LedgerVoucherObject findOrCreateLedgerVoucherObject(Voucher _voucher, TransDate _accountingDate)
    {
        LedgerVoucherObject ledgerVoucherObject;
        DocumentDate        documentDate;
        DocumentNum         documentNum;

        ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject(_voucher, _accountingDate);

        if (ledgerVoucherObject == null)
        {
            ledgerVoucherObject = this.getLedgerVoucherObject();
            ledgerVoucherObject.parmVoucher(_voucher);
            ledgerVoucherObject.parmAccountingDate(_accountingDate);

            [documentDate, documentNum] = this.ledgerVoucherObjectDocument(ledgerVoucherObject);
            ledgerVoucherObject.parmDocument(documentDate, documentNum);
            this.ledgerVoucherObjectSetParms(ledgerVoucherObject);

            ledgerVoucher.addVoucher(ledgerVoucherObject);
        }
        else
        {
            ledgerVoucher.lastVoucher(_voucher);
            ledgerVoucher.lastTransDate(_accountingDate);
        }

        // update the transaction text because it defaults to the transactions
        this.updateTransactTxtForLedgerVoucherObject(ledgerVoucherObject);

        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fixedEuroTriangulation</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the fixed euro triangulation value.
    /// </summary>
    /// <returns>
    ///   The fixed euro triangulation value.
    /// </returns>
    protected UnknownNoYes fixedEuroTriangulation()
    {
        return formletterProvider.fixedEuroTriangulation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fixedExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the fixed exchange rate.
    /// </summary>
    /// <returns>
    ///   The fixed exchange rate.
    /// </returns>
    protected VendExchRate fixedExchRate()
    {
        return formletterProvider.fixedExchRate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fixedExchRateSecondary</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the fixed secondary exchange rate.
    /// </summary>
    /// <returns>
    ///   The fixed secondary exchange rate.
    /// </returns>
    protected ExchrateSecondary fixedExchRateSecondary()
    {
        return formletterProvider.fixedExchRateSecondary();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportingCurrencyFixedExchangeRate</Name>
				<Source><![CDATA[
    internal ExchRate reportingCurrencyFixedExchangeRate()
    {
        return formletterProvider.reportingCurrencyFixedExchangeRate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formletterJournalTransRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether journal lines exist.
    /// </summary>
    /// <returns>
    /// true if journal lines exist; otherwise, false.
    /// </returns>
    protected boolean formletterJournalTransRecord()
    {
        return formletterJournalTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formletterProformaPrintToFormletter</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Transfers values from the <c>FormletterProformaPrint</c> class to the <c>Formletter</c> class.
    /// </summary>
    /// <remarks>
    ///    The method must be overridden in the derived classes for transferring values from the
    ///    <c>FormletterProformaPrint</c> class to the <c>Formletter</c> class.The
    ///    <c>formletterProformaPrintToFormletter</c> method is used to transfer specific values from the
    ///    <c>FormletterJournalPost</c> class to reports through the <c>Formletter</c> class when the reports
    ///    are printed.
    /// </remarks>
    protected void formletterProformaPrintToFormletter()
    {
        formLetter.parmFormletterProformaPrintPacked(this.getFormletterProformaPrintPacked());
    }

]]></Source>
			</Method>
			<Method>
				<Name>formletterType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the form letter type.
    /// </summary>
    /// <returns>
    /// A <c>FormletterType</c> enumeration value.
    /// </returns>
    protected FormletterType formletterType()
    {
        return FormletterType::Null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFormletterProformaPrintPacked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a container that contains specific values that are used for printing pro forma reports.
    /// </summary>
    /// <returns>
    ///    A container that contains specific values that are used for printing pro forma reports.
    /// </returns>
    /// <remarks>
    ///    The <c>getFormletterProformaPrintPacked</c> method is used to transfer specific values from the
    ///    <c>FormletterJournalPost</c> class to reports through the <c>Formletter</c> class when the reports
    ///    are printed as pro forma reports.
    /// </remarks>
    public container getFormletterProformaPrintPacked()
    {
        FormletterProformaPrint formletterProformaPrint = FormletterProformaPrint::construct();
        formletterProformaPrint.parmJournalTmpTaxWorkTrans(journalTmpTaxWorkTrans);

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            formletterProformaPrint.parmExchRate_W            (this.exchRate_W());
            formletterProformaPrint.parmExchRateSec_W         (this.exchRateSec_W());
        }
        // </GEERU>

        return formletterProformaPrint.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerVoucherObject</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a new instance of the <c>LedgerVoucherObject</c> class.
    /// </summary>
    /// <returns>
    ///    A new instance of the <c>LedgerVoucherObject</c> class.
    /// </returns>
    protected LedgerVoucherObject getLedgerVoucherObject()
    {
        return LedgerVoucherObject::newVoucher(voucher,
                                               this.updateDate(),
                                               formletterProvider.postingModule(),
                                               formletterProvider.ledgerTransType(),
                                               (this.creditNote() ? this.parmStorno() : NoYes::No));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrdersPosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a set of posted order IDs.
    /// </summary>
    /// <returns>A set of posted order IDs</returns>
    public Set getOrdersPosted()
    {
        return ordersPosted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets a voucher number.
    /// </summary>
    /// <returns>
    ///   A voucher number.
    /// </returns>
    abstract protected Num getVoucher()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasQualityOrder_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether journal line can be dealed.
    /// </summary>
    /// <returns>
    /// true if PurchTable/SalesTable has quality order; otherwise, false.
    /// </returns>
    protected boolean hasQualityOrder_IN()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes the class.
    /// </summary>
    public void init()
    {
        this.initRecordLists();

        if (!this.isProforma() && !this.isOnHold())
        {
            transactionTxt = this.initTransactionTxt(this.defaultLedgerTransactionText());
        }
        if (!voucher)
        {
            voucher = this.getVoucher();
        }
        doCopyDocuRefOnLines = FormletterParmTable::doCopyDocuRefOnLines(this.parmParmTable());
        this.initDocuRefRecId();

        if (FormLetterProformaJournalRemoveDocuRefOnDocDeletionFlight::instance().isEnabled())
        {
            proformaJournalLineSet = new Set(Types::Int64);
            proformaJournalLineMap = new Map(Types::Int64, Types::Class);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDocuRefRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the list <c>docuRefRecIdList</c>
    /// </summary>
    protected void initDocuRefRecId()
    {
        docuRefRecIdList = new List(typeName2Type(extendedTypeStr(recId)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFormletterProvider</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes the <c>FormletterProvider</c> object.
    /// </summary>
    protected void initFormletterProvider()
    {
        formletterProvider = FormletterProvider::newFormletterType(this.formletterType(), this.sourceTable());
        formletterProvider.parmSkipCreditMaxCheck(this.skipCreditMaxCheck());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes the <c>LedgerVoucherObject</c> object.
    /// </summary>
    protected void initLedgerVoucher()
    {
        LedgerVoucherObject ledgerVoucherObject;

        // <GEERU>
        LedgerBondClient_RU ledgerBondClient;
        // </GEERU>

        if (!ledgerVoucherIsSet)
        {
            ledgerVoucher = LedgerVoucher::newLedgerPost(formletterProvider.detailSummary(),
                                                         formletterProvider.postingModule(),
                                                         numberSeq ? numberSeq.parmVoucherSequenceCode() : '');
        }

        ledgerVoucherObject = this.findOrCreateLedgerVoucherObject(voucher, this.updateDate());

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
            if (ledgerBondClient)
            {
                ledgerBondClient.addNewLogObject();
            }
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes the <c>Markup</c> object.
    /// </summary>
    protected void initMarkup()
    {
        markup = new Markup(this.currencyCode());
        markup.setTax(tax);
        markup.parmExchRate(this.fixedExchRate(), this.fixedExchRateSecondary(), this.fixedEuroTriangulation());

        ExchRate exchRateReporting = this.reportingCurrencyFixedExchangeRate();

        if (exchRateReporting)
        {
            markup.setReportingCurrencyExchangeRate(exchRateReporting);
        }

        markup.transDate(this.updateDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRecordLists</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes the record lists.
    /// </summary>
    protected void initRecordLists()
    {
        recordListInventReportDimHistory = new RecordSortedList(tableNum(InventReportDimHistory));

        recordListInventReportDimHistory.sortOrder(fieldNum(InventReportDimHistory, TransactionLogType),
                                                   fieldNum(InventReportDimHistory, TransRefId),
                                                   fieldNum(InventReportDimHistory, InventTransId),
                                                   fieldNum(InventReportDimHistory, InventDimId));

        recordInsertListDocuref = new RecordInsertList(tableNum(DocuRef));
        recordSortedListJournalLines = new RecordSortedList(this.journalLineTableId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRelatedLineTables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the records that are related to the current journal line.
    /// </summary>
    protected void initRelatedLineTables()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes the <c>Tax</c> object.
    /// </summary>
    protected void initTax()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes the <c>TransactionTxt</c> object.
    /// </summary>
    /// <param name="_ledgerTransTxt">
    ///   A ledger transaction text.
    /// </param>
    /// <returns>
    ///   An instance of the <c>TransactionTxt</c> object.
    /// </returns>
    protected TransactionTxt initTransactionTxt(LedgerTransTxt  _ledgerTransTxt)
    {
        return TransactionTxt::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromFormLetterContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>FormletterJournalPost</c> using a <c>SalesFormLetterContract</c> instance.
    /// </summary>
    /// <param name = "_formletterContract">A <c>SalesFormLetterContract</c> instance.</param>
    protected void initFromFormLetterContract(SalesFormLetterContract _formletterContract)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertInventReportDimHistory</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Inserts a record in the <c>InventReportDimHistory</c> object.
    /// </summary>
    /// <param name="_inventReportDimHistory">
    ///   The record to insert.
    /// </param>
    protected void insertInventReportDimHistory(InventReportDimHistory _inventReportDimHistory)
    {
        recordListInventReportDimHistory.ins(_inventReportDimHistory,true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRecordList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts records in the record lists into the database.
    /// </summary>
    protected void insertRecordList()
    {
        recordListInventReportDimHistory.insertDatabase();
        recordInsertListDocuref.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventReportDimHistoryLogType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the inventory report dimension history type.
    /// </summary>
    /// <returns>
    /// A <c>InventReportDimHistoryLogType</c> enumeration value.
    /// </returns>
    protected InventReportDimHistoryLogType inventReportDimHistoryLogType()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoicePostingType_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns <c>SalesInvoicePostingType_RU</c>, overridden in <c>SalesInvoicePostJournal</c>
    /// </summary>
    /// <returns>
    /// Type of posting for invoice created
    /// </returns>
    protected SalesInvoicePostingType_RU invoicePostingType_RU()
    {
        return SalesInvoicePostingType_RU::Standard;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOnHold</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the journal is on hold.
    /// </summary>
    /// <returns>
    /// true if the journal is on hold; otherwise, false.
    /// </returns>
    public boolean isOnHold()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPrepaymentJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Identifies if the <c>FormletterJournalPost</c> is a prepayment journal.
    /// </summary>
    /// <returns>
    /// True if a prepayment journal is being posted; otherwise false.
    /// </returns>
    protected boolean isPrepaymentJournal()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProforma</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the journal is a pro forma journal.
    /// </summary>
    /// <returns>
    /// true if the journal is a pro forma journal; otherwise, false.
    /// </returns>
    public boolean isProforma()
    {
        return proforma;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets or sets the current journal line record.
    /// </summary>
    /// <param name="_journalLine">
    ///   A journal line record.
    /// </param>
    /// <returns>
    ///   A journal line record.
    /// </returns>
    protected Common journalLine(Common _journalLine = journalLine)
    {
        journalLine = _journalLine;
        return journalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalLineTableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the table ID for the journal line table.
    /// </summary>
    /// <returns>
    ///   A table ID.
    /// </returns>
    abstract protected TableId journalLineTableId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerVoucherObjectDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the document values from the <c>LedgervoucherObject</c> object.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    /// A <c>LedgerVoucherObject</c> object.
    /// </param>
    /// <returns>
    /// A container that contains document values.
    /// </returns>
    protected container ledgerVoucherObjectDocument(LedgerVoucherObject _ledgerVoucherObject)
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerVoucherObjectSetParms</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets parameters on the <c>LedgerVoucherObject</c> object.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    /// The <c>LedgerVoucherObject</c> object.
    /// </param>
    protected void ledgerVoucherObjectSetParms(LedgerVoucherObject _ledgerVoucherObject)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineDiscountAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the line discount amount.
    /// </summary>
    /// <param name="_lineDiscount">
    ///   A line discount amount.
    /// </param>
    /// <returns>
    ///   A line discount amount.
    /// </returns>
    protected AmountCur lineDiscountAmount(AmountCur _lineDiscount = 0)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        // <GEERU>
        countryRegionIsRU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // <GEERU>
        // <GBR>
        isCountryRegionBR = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR]);
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextFormletterJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Selects the next journal line.
    /// </summary>
    protected void nextFormletterJournalTrans()
    {
        next formletterJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChainFormletterContract</Name>
				<Source><![CDATA[
    public FormLetterContract parmChainFormletterContract(FormLetterContract _chainFormletterContract = chainFormletterContract)
    {
        chainFormletterContract = _chainFormletterContract;
        return chainFormletterContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocuRefRecId</Name>
				<Source><![CDATA[
    public List parmDocuRefRecId(List _docuRefRecIdList = docuRefRecIdList)
    {
        docuRefRecIdList = _docuRefRecIdList;
        return docuRefRecIdList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFormletter</Name>
				<Source><![CDATA[
    public FormLetter parmFormletter(FormLetter _formLetter = formLetter)
    {
        formLetter = _formLetter;
        return formLetter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalTable</Name>
				<Source><![CDATA[
    public Common parmJournalTable(Common _journalTable = journalTable)
    {
        journalTable = _journalTable;

        return journalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRInventTransRecid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the inventory transaction record ID.
    /// </summary>
    /// <param name="_inventTransRecId">
    /// A record ID of an inventory transaction record; optional.
    /// </param>
    /// <returns>
    /// The inventory transaction record ID.
    /// </returns>
    /// <remarks>
    /// The record ID issued by the unship process during packing slip returns.
    /// </remarks>
    public Recid parmMCRInventTransRecid(Recid _inventTransRecId =  inventTransRecId)
    {
        inventTransRecId = _inventTransRecId;
        return inventTransRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumberOfOrders</Name>
				<Source><![CDATA[
    public Counter parmNumberOfOrders(Counter _numberOfOrders = numberOfOrders)
    {
        numberOfOrders = _numberOfOrders;

        return numberOfOrders;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumberSeq</Name>
				<Source><![CDATA[
    public NumberSeq parmNumberSeq(NumberSeq _numberSeq = numberSeq)
    {
        numberSeq = _numberSeq;
        return numberSeq;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPackedLineIdSet</Name>
				<Source><![CDATA[
    public container parmPackedLineIdSet(container _packedLineIdSet = packedLineIdSet)
    {
        packedLineIdSet = _packedLineIdSet;
        return _packedLineIdSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmTable</Name>
				<Source><![CDATA[
    public Common parmParmTable(Common _parmTable = parmTable)
    {
        parmTable = _parmTable;

        return parmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintFormLetter</Name>
				<Source><![CDATA[
    public boolean  parmPrintFormLetter(boolean  _printFormletter = printFormletter)
    {
        printFormletter = _printFormletter;
        return printFormletter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintout</Name>
				<Source><![CDATA[
    public Printout parmPrintout(Printout _printout = printout)
    {
        printout = _printout;

        return printout;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProforma</Name>
				<Source><![CDATA[
    public boolean parmProforma(boolean _proforma = proforma)
    {
        proforma = _proforma;
        return proforma;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProformaJournalLineMap</Name>
				<Source><![CDATA[
    public Map parmProformaJournalLineMap(Map _proformaJournalLineMap = proformaJournalLineMap)
    {
        proformaJournalLineMap = _proformaJournalLineMap;
        return _proformaJournalLineMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalLineTableId</Name>
				<Source><![CDATA[
    public RefTableId parmJournalLineTableId(RefTableId _journalLineTableId = journalLineTableId)
    {
        journalLineTableId = _journalLineTableId;
        return _journalLineTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjProposalJour</Name>
				<Source><![CDATA[
    public ProjProposalJour parmProjProposalJour(ProjProposalJour _projProposalJour = projProposalJour)
    {
        projProposalJour = _projProposalJour;
        return projProposalJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReduceOnHand</Name>
				<Source><![CDATA[
    public boolean parmReduceOnHand(boolean _reduceOnHand = reduceOnHand)
    {
        reduceOnHand = _reduceOnHand;
        return reduceOnHand;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSendByMail_MX</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets or sets the <paramref name="sendByEmail" /> parameter.
    /// </summary>
    /// <param name="_sendByMail">
    /// The value to set; optional.
    /// </param>
    /// <returns>
    ///     The value of the <paramref name="sendByEmail" /> parameter.
    /// </returns>
    public NoYes parmSendByMail_MX(NoYes _sendByMail = sendByMail_MX)
    {
        sendByMail_MX = _sendByMail;

        return sendByMail_MX;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShipmentId</Name>
				<Source><![CDATA[
    public WMSShipmentId parmShipmentId(WMSShipmentId _shipmentId = shipmentId)
    {
        shipmentId = _shipmentId;

        return shipmentId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSpecQty</Name>
				<Source><![CDATA[
    public int parmSpecQty(int _specQty = specQty)
    {
        specQty = _specQty;
        return specQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStorno</Name>
				<Source><![CDATA[
    public boolean parmStorno(boolean _storno = storno)
    {
        storno = _storno;
        return storno;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSumBy</Name>
				<Source><![CDATA[
    public AccountOrder parmSumBy(AccountOrder _sumBy = sumBy)
    {
        sumBy = _sumBy;
        return sumBy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSumOrderId</Name>
				<Source><![CDATA[
    public Num parmSumOrderId(Num _sumOrderId = sumOrderId)
    {
        sumOrderId = _sumOrderId;
        return sumOrderId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxableDocumentDescriptor</Name>
				<Source><![CDATA[
    public TaxableDocumentDescriptor parmTaxableDocumentDescriptor()
    {
        if (parmTable)
        {
            return TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(parmTable);
        }
        else
        {
            return TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(this.parmParmTable());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTotals</Name>
				<Source><![CDATA[
    public Object parmTotals(Object _totals = totals)
    {
        totals = _totals;
        return totals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWHSLoadId</Name>
				<Source><![CDATA[
    public WHSLoadId parmWHSLoadId(WHSLoadId _whsLoadId = whsLoadId)
    {
        whsLoadId = _whsLoadId;

        return whsLoadId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    private void post()
    {
        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        isPrePaymentJournalPost = this.isPrepaymentJournal();

        ttsbegin;
        ordersPosted = new Set(Types::String);
        linesPosted  = new Set(Types::Int64);
        sourceTableRecIdSet = new Set(typeName2Type(extendedTypeStr(RecId)));

        this.init();
        this.initFormletterProvider();
        this.initMarkup();

        if (!this.isProforma() && !this.isOnHold())
        {
            if (this.canPostLedger())
            {
                this.initLedgerVoucher();
            }

            // TaxTrans must be posted before journalization of source document because
            // journalization requires that TaxTrans records exist in order to
            // properly populate the TaxTransGeneralJournalEntry table.
            if (this.postTaxesBeforeSourceDocument() && this.canPostTax())
            {
                this.postTax(this.postTaxOnUpdate());
            }

            this.processSourceDocument();
        }

        formletterJournal      = this.parmJournalTable();
        formletterJournalTrans = this.journalLine();

        this.postLines();

        if (recalcTotals)
        {
            this.recalcTotals();
        }
        if (this.canPostTax())
        {
            this.writeTmpTaxWorkTrans(this.parmJournalTable().RecId);
            this.writeTmpTaxWorkTransV2(this.parmJournalTable().RecId, this.parmJournalTable().TableId);
        }
        this.updateJournalTable();

        if (this.shouldPostMarkupTable())
        {
            this.postMarkupTable();
        }

        if (this.isProforma() || this.isOnHold())
        {
            if (this.postTaxOnProforma())
            {
                this.postTax(false);
            }

            // <GEERU>
            if (countryRegion_RU)
            {
                this.writeTaxAmount_W();

                this.adjustAmountsMST_W();
            }
            // </GEERU>

            this.copyDocuRefTable();
            this.insertRecordList();

            if (FormLetterProformaJournalRemoveDocuRefOnDocDeletionFlight::instance().isEnabled())
            {
                this.addToProformaJournalLineMap();
            }
        }
        else
        {
            // Taxes must be posted before journalization of source document because
            // journalization requires that TaxTrans records exist in order to
            // properly populate the TaxTransGeneralJournalEntry table.
            if (!this.postTaxesBeforeSourceDocument() && this.canPostTax())
            {
                this.postTax(this.postTaxOnUpdate());
            }

            // <GEERU>
            if (countryRegion_RU)
            {
                this.writeTaxAmount_W();

                this.adjustAmountsMST_W();
            }
            // </GEERU>

            if (this.canPostLedger())
            {
                if (this.canPostEndDisc())
                    this.postEndDiscount();

                if (this.canPostRoundOff())
                    this.postRoundOff();

                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    this.createPaymentDisbursement();
                }
                this.createPaymentSched();

                if (!this.requirePostCustVendAfterLedgerVoucherEnd())
                {
                    this.postCustVend();
                }
                this.postExternalAmounts();
            }

            this.updateSourceTable();
            this.copyDocuRefTable();
            this.insertRecordList();
            this.endPost();

            if (this.canPostLedger() && this.canEndLedgerVoucher())
            {
                this.endLedgerVoucher();
            }
            TransactionLog::create(this.transactionLogType(),this.transactionLogTxt());
        }

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled()
            && TaxSolutionScopeParameters::find().TaxDocumentPostingMode == TaxDocumentPostingMode::Synchronous
            && !(this is ProjInvoiceJournalPost)
            && !(this is ConsignmentReplenishmentOrderFormLetterJournalPost)
            && !this.isProforma()
            && !(TaxNotPostTaxDocumentWhileOnHoldFlight::instance().isEnabled() && this.isOnHold()))
        {
            // Tax document may not be posted because postTax is not called for some transactions, for example, purchase order confirmation.
            TaxBusinessService::postTaxDocument(TaxableDocumentObject::construct(this.parmTaxableDocumentDescriptor()), ledgerVoucher);
        }
        // </GTE>

        // <GEERU>
        if (countryRegion_RU)
        {
            factureJour = this.createFacture_RU();
        }
        // </GEERU>
        // <GEEU>
        if (this.mustUpdateAdvanceInvoiceSettlement_W([#isoRU, #isoCZ, #isoHU, #isoPL]))
        {
            this.updateAdvanceInvoiceSettlement_W();
        }
        // </GEEU>

        this.endUpdate();

        // after posting, tax adjustments get removed.
        TaxWorkRegulation::clearRegulation(sourceTable.TableId, sourceTable.RecId);

        ttscommit;

        if (this.parmFormletter() && this.canPostTax() && (this.isProforma() || this.isOnHold()))
        {
            this.formletterProformaPrintToFormletter();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToProformaJournalLineMap</Name>
				<Source><![CDATA[
    private void addToProformaJournalLineMap()
    {
        if (proformaJournalLineSet && !proformaJournalLineSet.empty())
        {
            proformaJournalLineMap.add(this.parmJournalTable().RecId, proformaJournalLineSet);
            proformaJournalLineSet = new Set(Types::Int64);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateAdvanceInvoiceSettlement_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the collection of country codes applicable for updating invoice settlement.
    /// </summary>
    /// <param name = "_countryCodes">The container with the country codes.</param>
    /// <returns>true if the collection of the countries is valid; otherwise, false.</returns>
    protected boolean mustUpdateAdvanceInvoiceSettlement_W(container _countryCodes)
    {
        return SysCountryRegionCode::isLegalEntityInCountryRegion(_countryCodes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLines</Name>
				<Source><![CDATA[
    protected void postLines()
    {
        boolean isConfigurationkeyRetailEnabled = isConfigurationkeyEnabled(configurationKeyNum(Retail));

        boolean countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        boolean hasQualityOrder;
        boolean isVATEnableIN;
        boolean isExciseEnableIN;
        boolean isCustomsEnableIN;
        boolean isAnyAlternativeReturn_BR;

        if (FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance()))
        {
            KittingClassDelegateHelper::FormletterJournalPost_preparePostJournal(this.formletterType(), chainFormletterContract, formletterJournal);
        }

        // loop over lines
        this.selectFormletterJournalTrans();
        journalLineTableId = formletterJournalTrans.TableId;

        if (countryRegion_IN)
        {
            hasQualityOrder   = this.hasQualityOrder_IN();
            isVATEnableIN     = TaxParameters::isVATEnable_IN();
            isExciseEnableIN  = TaxParameters::isExciseEnable_IN();
            isCustomsEnableIN = TaxParameters::isCustomsEnable_IN();
        }

        this.startLines();
        while (this.formletterJournalTransRecord())
        {
            setPrefix(formletterJournalTrans.FormletterJournalTrans::getLinePrefix());

            if (isCountryRegionBR && !isAnyAlternativeReturn_BR)
            {
                isAnyAlternativeReturn_BR = this.isAlternativeReturnEnabled_BR();
            }
            this.postSingleLine(countryRegion_RU,
                                hasQualityOrder,
                                isExciseEnableIN,
                                isVATEnableIN,
                                isCustomsEnableIN,
                                isConfigurationkeyRetailEnabled);
        }
        this.endLines();
        if (isAnyAlternativeReturn_BR)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceBR00048, funcName());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSingleLine</Name>
				<Source><![CDATA[
    protected void postSingleLine(boolean _countryRegion_RU,
                                  boolean _hasQualityOrder,
                                  boolean _isExciseEnableIN,
                                  boolean _isVATEnableIN,
                                  boolean _isCustomsEnableIN,
                                  boolean _isConfigurationkeyRetailEnabled)
    {
        this.journalLine(formletterJournalTrans);
        this.initRelatedLineTables();
        formletterProvider.parmSourceLine(this.sourceLine());
        this.checkSourceLine();
        this.beforeLinePost();

        if (!_countryRegion_RU
                && !this.isProforma() && !this.isOnHold())
        {
            this.checkBeforePostingLine();
            this.updateSourceLineBeforePosting();

            if (_hasQualityOrder && (_isExciseEnableIN || TaxSolutionScopeIntegrationUtil::isCompanyEnabled()))
            {
                this.dealQualityOrderLine_IN();
            }

            if (this.postMarkupLineBeforeInventory())
            {
                this.postMarkupLine();
            }

            if (_isVATEnableIN && !TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                this.calculateVATDefermentTax_IN();
            }

            if (this.canPostLedger())
            {
                if (_isCustomsEnableIN && !TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
                {
                    this.postToCustomsExpenseAccount_IN();
                }

                if (this.canPostToInventory())
                {
                    this.postInventory();
                }
                else
                {
                    this.doPostNotStocked();
                }
                this.postLineDiscount();
                this.postLine();
                this.tax1099();
            }
            if (!this.postMarkupLineBeforeInventory())
            {
                this.postMarkupLine();
            }

        }
        else if (_countryRegion_RU && !this.isOnHold() )
        {
            if (!this.isProforma())
            {
                this.checkBeforePostingLine();
            }

            if (this.postMarkupLineBeforeInventory())
            {
                this.postMarkupLine();
            }

            if (!this.isProforma()
                    && this.canPostLedger())
            {
                this.postAsset_RU();
                if (this.canPostToInventory())
                {
                    this.postInventory();
                }
                else
                {
                    this.doPostNotStocked();
                }
                this.postLineDiscount();
                this.postLine();
                this.tax1099();
            }
            if (!this.postMarkupLineBeforeInventory())
            {
                this.postMarkupLine();
            }
        }

        if (!this.isProforma() && !this.isOnHold())
        {
            this.updateJournalLine();
            this.updateSourceLine();
            if (_isConfigurationkeyRetailEnabled)
            {
                this.updateCrossdocking();
            }

            if (InventReportDimHistory::canCreateHistory(formletterJournalTrans))
            {
                this.addToInventReportDimHistory(formletterJournalTrans);
            }
            this.endPostLine();
        }
        ordersPosted.add(this.retrieveOrigOrderId());
        this.copyDocuRefLine();
        this.afterLinePost();
        this.nextFormletterJournalTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveOrigOrderId</Name>
				<Source><![CDATA[
    protected Num retrieveOrigOrderId()
    {
        return formletterJournalTrans.OrigOrderId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAsset_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs asset posting for russian fixed assets
    /// </summary>
    protected void postAsset_RU()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postBalanceAsManyLedgerTransactions_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Returns true if balance should be posted as many ledger transactions.
    /// </summary>
    /// <returns>
    ///    true, if balance should be posted as many ledger transactions; otherwise - false;
    /// </returns>
    protected boolean postBalanceAsManyLedgerTransactions_RU()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustVend</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Performs customer and vendor related postings.
    /// </summary>
    protected void postCustVend()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEndDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Posts the end discount.
    /// </summary>
    protected void postEndDiscount()
    {
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        LedgerDimensionAccount      ledgerDimensionMerged;
        LedgerVoucherObject         ledgerVoucherObject;
        CurrencyExchangeHelper      currencyExchHelper;

        int sign = this.creditDiscount() ? -1 : 1;

        if (ledgerVoucher &&
            // <GEERU>
            (
            // </GEERU>
            formletterJournal.EndDisc
            // <GEERU>
            || endDiscAmounts
            )
            // </GEERU>
            )
        {
            transactionTxt = this.initTransactionTxt(formletterProvider.ledgerTransactionTextEndDisc());
            ledgerDimensionMerged   = LedgerDimensionFacade::serviceCreateLedgerDimension(LedgerSystemAccounts::defaultAccount(formletterProvider.postingTypeEndDiscount()), formletterJournal.DefaultDimension);

            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
            currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(
                Ledger::primaryLedger(CompanyInfo::findDataArea(formletterJournal.company()).RecId),
                ledgerVoucherObject.parmAccountingDate());
            currencyExchHelper.parmExchangeRate1(formletterJournal.ExchRate);
            currencyExchHelper.parmExchangeRate2(formletterJournal.ExchrateSecondary);

            ledgerVoucherTransObject =  LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucherObject,
                                                                                                         formletterProvider.postingTypeEndDiscount(),
                                                                                                         ledgerDimensionMerged,
                                                                                                         formletterJournal.CurrencyCode,
                                                                                                         formletterJournal.EndDisc * sign,
                                                                                                         currencyExchHelper);

            ledgerVoucherTransObject.parmSourceRecId(formletterJournal.RecId);
            ledgerVoucherTransObject.parmSourceTableId(formletterJournal.TableId);
            ledgerVoucherTransObject.parmTransTxt(transactionTxt.txt());
            // <GEERU>
            if (countryRegionIsRU && this.postBalanceAsManyLedgerTransactions_RU())
            {
                endDiscVrefIDs = LedgerUtils_RU::postAmountsByTemplate(ledgerVoucherObject,  endDiscAmounts, ledgerVoucherTransObject, currencyExchHelper, sign);
            }
            else
            {
                // <GEERU>
                ledgerVoucher.addTrans(ledgerVoucherTransObject);
                // <GEERU>
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postFailed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when the posting of a journal fails.
    /// </summary>
    /// <param name="_logText">
    /// The error message.
    /// </param>
    public void postFailed(LogText _logText = '')
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts to inventory.
    /// </summary>
    protected void postInventory()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournalPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Runs after posting a journal.
    /// </summary>
    public void postJournalPost()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts a journal line.
    /// </summary>
    protected void postLine()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPostLineAccountDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the line account discount must be posted.
    /// </summary>
    /// <param name = "_salesPurchLine">A <c>SalesPurchLine</c> record.</param>
    /// <param name = "_accountDisc">A <c>LedgerDimensionDefaultAccount</c> value.</param>
    /// <returns>true if the line account discount must be posted; otherwise, false.</returns>
    protected boolean mustPostLineAccountDiscount(SalesPurchLine _salesPurchLine, LedgerDimensionDefaultAccount _accountDisc)
    {
        return this.lineDiscountAmount() && _accountDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerDimensionAccountForPostLineAccountDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>LedgerVoucherTransObject</c> instance for line discount posting.
    /// </summary>
    /// <param name="_ledgerVoucherTransObject">
    /// The <c>LedgerVoucherTransObject</c> instance which is to be initialized.
    /// </param>
    /// <param name="_salesPurchLineInterface">
    /// The <c>SalesPurchLineInterface</c> class which carries information for the initialized object.
    /// </param>
    protected void initializeLedgerDimensionAccountForPostLineAccountDiscount(
        LedgerVoucherTransObject _ledgerVoucherTransObject,
        SalesPurchLineInterface _salesPurchLineInterface)
    {
        this.addTaxParentReference(_ledgerVoucherTransObject);
        _ledgerVoucherTransObject.setTaxTransRelationshipType(TaxTransRelationshipType::LineDiscount);
        _ledgerVoucherTransObject.parmProjLedger(this.projLedger());
        _ledgerVoucherTransObject.parmSourceTableId(salesPurchLine.TableId);
        _ledgerVoucherTransObject.parmSourceRecId(salesPurchLine.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postExternalAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts amounts from metadocuments.
    /// </summary>
    protected void postExternalAmounts()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLineDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts a line discount.
    /// </summary>
    protected void postLineDiscount()
    {
        if (ledgerVoucher && salesPurchLine)
        {
            SalesPurchLineInterface         salesPurchLineInterface = salesPurchLine.salesPurchLineInterface();
            LedgerDimensionDefaultAccount   accountDisc =  formletterProvider.lineDiscountLedgerDimension();
            LedgerVoucherObject             ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
            int                             sign = this.creditDiscount() ? -1 : 1;

            CurrencyExchangeHelper exchangeRateHelper  = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(formletterJournal.company()).RecId),ledgerVoucherObject.parmAccountingDate());
            exchangeRateHelper.parmExchangeRate1(this.fixedExchRate());
            exchangeRateHelper.parmExchangeRate2(this.fixedExchRateSecondary());

            ExchRate exchRateReporting = this.reportingCurrencyFixedExchangeRate();

            if (exchRateReporting)
            {
                exchangeRateHelper.parmReportingExchangeRate1(exchRateReporting);
            }

            if (this.mustPostLineAccountDiscount(salesPurchLine, accountDisc))
            {
                LedgerDimensionAccount ledgerDimensionMergedAccountDisc = LedgerDimensionFacade::serviceCreateLedgerDimension(accountDisc, salesPurchLineInterface.parmDefaultDimension());
                LedgerVoucherTransObject ledgerPostingTransactionAccountDisc = LedgerVoucherTransObject::newTransactionAmountDefault(
                                            ledgerVoucherObject,
                                            formletterProvider.postingTypeLineDiscount(),
                                            ledgerDimensionMergedAccountDisc,
                                            salesPurchLineInterface.parmCurrencyCode(),
                                            this.lineDiscountAmount() * sign,
                                            exchangeRateHelper);

                this.initializeLedgerDimensionAccountForPostLineAccountDiscount(ledgerPostingTransactionAccountDisc, salesPurchLineInterface);

                ledgerVoucher.addTrans(ledgerPostingTransactionAccountDisc);

                this.lineDiscountAmount(ledgerPostingTransactionAccountDisc.parmAmountCur());
            }

            if (this.cashDiscPercent() && onlyOneCashDiscOnInvoice && TaxParameters::canApplyCashDiscOnInvoice_ES())
            {
                onlyOneCashDiscOnInvoice = false;

                LedgerDimensionDefaultAccount cashDiscAccount = formletterProvider.cashDiscountLedgerDimension();

                if (cashDiscAccount)
                {
                    LedgerDimensionAccount ledgerDimensionMergedCashDiscAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(cashDiscAccount, salesPurchLineInterface.parmDefaultDimension());

                    LedgerVoucherTransObject ledgerPostingTransactionCashDiscAccount = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                ledgerVoucherObject,
                                                formletterProvider.postingTypeCashDiscount(),
                                                ledgerDimensionMergedCashDiscAccount,
                                                salesPurchLineInterface.parmCurrencyCode(),
                                                this.cashDiscountAmount() * sign,
                                                exchangeRateHelper);

                    ledgerPostingTransactionCashDiscAccount.parmProjLedger(this.projLedger());
                    ledgerPostingTransactionCashDiscAccount.parmSourceTableId(salesPurchLine.TableId);
                    ledgerPostingTransactionCashDiscAccount.parmSourceRecId(salesPurchLine.RecId);
                    ledgerVoucher.addTrans(ledgerPostingTransactionCashDiscAccount);
                }
                else
                {
                    LedgerSystemAccounts ledgerSystemAccounts = LedgerSystemAccounts::find(formletterProvider.postingTypeCashDiscount());

                    if (ledgerSystemAccounts.LedgerDimension)
                    {
                        LedgerDimensionAccount ledgerDimensionMergedLedgerSystemAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerSystemAccounts.LedgerDimension, salesPurchLineInterface.parmDefaultDimension());

                        LedgerVoucherTransObject ledgerPostingTransactionLedgerSystemAccount = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                    ledgerVoucherObject,
                                                    formletterProvider.postingTypeCashDiscount(),
                                                    ledgerDimensionMergedLedgerSystemAccount,
                                                    salesPurchLineInterface.parmCurrencyCode(),
                                                    this.cashDiscountAmount() * sign,
                                                    exchangeRateHelper);

                        ledgerPostingTransactionLedgerSystemAccount.parmProjLedger(this.projLedger());
                        ledgerPostingTransactionLedgerSystemAccount.parmSourceTableId(salesPurchLine.TableId);
                        ledgerPostingTransactionLedgerSystemAccount.parmSourceRecId(salesPurchLine.RecId);
                        ledgerVoucher.addTrans(ledgerPostingTransactionLedgerSystemAccount);
                    }
                    else
                        throw error("@SYS99049");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the markup for the current journal line.
    /// </summary>
    protected void postMarkupLine()
    {
        this.postMarkupOnTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupLineBeforeInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether markup for a line should be posted before making inventory updates.
    /// </summary>
    /// <returns>
    /// true if line markup should be posted before the inventory is updated; otherwise, false.
    /// </returns>
    protected boolean postMarkupLineBeforeInventory()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupOnTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the markup for the journal lines.
    /// </summary>
    protected void postMarkupOnTrans()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the markup for the journal header.
    /// </summary>
    protected void postMarkupTable()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNotStocked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs posting routines for order lines that cannot be posted to inventory.
    /// </summary>
    protected void postNotStocked()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postRoundOff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts roundings.
    /// </summary>
    protected void postRoundOff()
    {
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        LedgerDimensionAccount      ledgerDimensionMerged;
        CurrencyExchangeHelper      currencyExchHelper;
        LedgerVoucherObject         ledgerVoucherObject;

        if (ledgerVoucher && formletterJournal.RoundOff)
        {
            transactionTxt = this.initTransactionTxt(formletterProvider.ledgerTransactionTextRoundOff());
            ledgerDimensionMerged   = LedgerDimensionFacade::serviceCreateLedgerDimension(LedgerSystemAccounts::defaultAccount(formletterProvider.postingTypeRoundOff()), formletterJournal.DefaultDimension);

            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
            currencyExchHelper      = CurrencyExchangeHelper::newExchangeDate(
                Ledger::primaryLedger(CompanyInfo::findDataArea(formletterJournal.company()).RecId),
                ledgerVoucherObject.parmAccountingDate());
            currencyExchHelper.parmExchangeRate1(formletterJournal.ExchRate);
            currencyExchHelper.parmExchangeRate2(formletterJournal.ExchrateSecondary);

            ledgerVoucherTransObject =  LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucherObject,
                                                                                                         formletterProvider.postingTypeRoundOff(),
                                                                                                         ledgerDimensionMerged,
                                                                                                         formletterJournal.CurrencyCode,
                                                                                                         formletterJournal.RoundOff * this.roundingOffSign(),
                                                                                                         currencyExchHelper);

            ledgerVoucherTransObject.parmSourceRecId(formletterJournal.RecId);
            ledgerVoucherTransObject.parmSourceTableId(formletterJournal.TableId);
            ledgerVoucherTransObject.parmTransTxt(transactionTxt.txt());
            ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs tax postings.
    /// </summary>
    /// <param name="_post">
    /// A Boolean value that indicates whether posting should occur.
    /// </param>
    protected void  postTax(boolean _post)
    {
        TradeCalcTax tradeCalcTax;

        tradeCalcTax = this.tradeCalcTax();
        if (tradeCalcTax)
        {
            tradeCalcTax.tax(this.tax());
            // <GIN>
            if (TaxWithholdParameters_IN::checkTaxParameters())
            {
                tradeCalcTax.taxWithholdCalculation_IN(this.taxWithholdCalculation_IN());
            }
            // </GIN>
            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                tradeCalcTax.parmInvoicePostingType_RU(this.invoicePostingType_RU());
            }
            // </GEERU>
            tradeCalcTax.post(ledgerVoucher, _post);
        }

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && _post)
        {
            this.postTaxGTE();
        }

        if (_post)
        {
            TaxIntegrationBusinessProcess businessProcess =
                TaxIntegrationUtils::getBusinessProcessBySourceHeadingTable(this.parmParmTable().TableId, this.parmParmTable().RecId);

            if (TaxIntegrationUtils::isISVApiActivated(TaxServiceISVApiTypes::PostTax)
                && TaxIntegrationUtils::getTaxSolutionProviderTypeByBusinessProcess(businessProcess) == TaxSolutionProviderType::ISV)
            {
                this.transferPackedTaxCalculationInput();
                TaxModuleType taxModuleType;

                switch (this.parmJournalTable().TableId)
                {
                    case (tableNum(CustInvoiceJour)):
                        taxModuleType = TaxModuleType::Sales;
                        break;
                    case (tableNum(VendInvoiceJour)):
                        taxModuleType = TaxModuleType::Purch;
                        break;
                    case (tableNum(ProjInvoiceJour)):
                        taxModuleType = TaxModuleType::Project;
                        break;
                }

                TaxIntegrationFacade::postTaxToISV(this.parmJournalTable().TableId, this.parmJournalTable().RecId, taxModuleType);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxesBeforeSourceDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether taxes should be posted prior to source document journalization.
    /// </summary>
    /// <returns>
    ///    true if taxes should be posted prior to source document journalization; otherwise, false.
    /// </returns>
    protected boolean postTaxesBeforeSourceDocument()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxOnProforma</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether tax should be considered when you post a pro forma journal.
    /// </summary>
    /// <returns>
    /// true if tax should be considered on pro forma journals; otherwise, false.
    /// </returns>
    protected boolean postTaxOnProforma()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxOnUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines whether tax should be posted on update.
    /// </summary>
    /// <returns>
    ///   true if tax should be posted on update; otherwise, false.
    /// </returns>
    protected boolean postTaxOnUpdate()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToCustomsExpenseAccount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method overrides in the child classes.
    /// </summary>
    protected void postToCustomsExpenseAccount_IN()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSourceDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes the source document.
    /// </summary>
    protected void processSourceDocument()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the <c>ProjLedger</c> object.
    /// </summary>
    /// <returns>
    ///   An instance of the <c>ProjLedger</c> object.
    /// </returns>
    protected ProjLedger projLedger()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalcTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculates the totals.
    /// </summary>
    /// <remarks>
    /// If the quantity is reduced by inventory, use this method.
    /// </remarks>
    protected void recalcTotals()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>requirePostCustVendAfterLedgerVoucherEnd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether automatic settlement for AP/AR should be posted after ledger voucher is posted
    /// </summary>
    /// <returns>
    /// True is automatic settlement for AP/AR is to be posted after ledger voucher is posted; false otherwise
    /// </returns>
    /// <remarks>
    /// The posting of automatic settlement posting requires subledger journal account entries to be created.
    /// If these subledger entries are not generated under after ledger voucher is posted, then this
    /// property should be set to true.
    /// </remarks>
    protected boolean requirePostCustVendAfterLedgerVoucherEnd()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundingOffSign</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the rounding sign
    /// </summary>
    /// <returns>
    ///   The rounding sign.
    /// </returns>
    protected int roundingOffSign()
    {
        return 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Posts a journal.
    /// </summary>
    public void run()
    {
        LogText     logText;
        Counter     origInfologNum = infologLine();

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            taxDocumentLedgerVoucherMap = New Map(Types::AnyType, Types::AnyType);
        }
        try
        {
            this.post();
        }
        catch (Exception::Error)
        {
            logText = Info::infoCon2Str(infolog.copy(origInfologNum + 1, infologLine()));
            this.postFailed(logText);

            throw Exception::Error;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>requireGLPostingPriorToSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the ledger voucher was posted prior to settlement.
    /// </summary>
    /// <returns>
    /// true if the ledger voucher was posted prior to settlement; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Settlement posting requires subledger journal account entries to be created.
    /// If these subledger entries are generated prior to the settlement posting, then this
    /// method should return true.
    /// </remarks>
    protected boolean requireGLPostingPriorToSettlement()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFormletterJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Selects a journal line.
    /// </summary>
    protected void selectFormletterJournalTrans()
    {
        select forupdate formletterJournalTrans
            where formletterJournalTrans.JournalId           == formletterJournal.JournalId
               && formletterJournalTrans.InternalJournalId   == formletterJournal.InternalJournalId
               && formletterJournalTrans.OrderId             == formletterJournal.OrderId
               && formletterJournalTrans.TransDate           == formletterJournal.TransDate
               && formletterJournalTrans.NumberSequenceGroup == formletterJournal.NumberSequenceGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Sets the <c>LedgerVoucher</c> object.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///   An instance of the <c>LedgerVoucher</c> object.
    /// </param>
    public void  setLedgerVoucher(LedgerVoucher  _ledgerVoucher)
    {
        ledgerVoucher       = _ledgerVoucher;
        ledgerVoucherIsSet  = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNumAndVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets journal and voucher number.
    /// </summary>
    /// <param name="_con">
    /// A Container that contains a journal and voucher number.
    /// </param>
    public void  setNumAndVoucher(container _con)
    {
        [journalNumber, voucher] = _con;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRecalcTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the internal value that indicates whether total recalculation is needed.
    /// </summary>
    protected void setRecalcTotals()
    {
        recalcTotals = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCopyMultipleDocuRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether attachments should be copied from multiple source documents.
    /// </summary>
    /// <returns>
    /// true if attachments should be copied from multiple source documents; otherwise, false.
    /// </returns>
    protected boolean shouldCopyMultipleDocuRef()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPostMarkupTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value indicating whether miscellaneous charges for sales order should
    /// be posted.
    /// </summary>
    /// <returns>
    /// true if sales order miscellaneous charges should be posted; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The default behavior is that the miscellaneous charges should always be posted.
    /// </remarks>
    protected boolean shouldPostMarkupTable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipCreditMaxCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a credit max validation should be skipped.
    /// </summary>
    /// <returns>
    /// true if a credit max validation should be skipped; otherwise, false.
    /// </returns>
    protected boolean skipCreditMaxCheck()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the source line record for the current journal line.
    /// </summary>
    /// <returns>
    ///   A source line record.
    /// </returns>
    abstract protected Common sourceLine()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the source header record for the journal header.
    /// </summary>
    /// <returns>
    ///   A source header record.
    /// </returns>
    abstract protected Common sourceTable()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>startLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Starts the posting of all journal lines.
    /// </summary>
    protected void startLines()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>tax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets and gets the <c>Tax</c> object.
    /// </summary>
    /// <param name="_tax">
    /// An instance of the <c>Tax</c> class.
    /// </param>
    /// <returns>
    /// An instance of the <c>Tax</c> class.
    /// </returns>
    protected Tax tax(Tax _tax = tax)
    {
        tax = _tax;
        return tax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tax1099</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Performs tax 1099 postings.
    /// </summary>
    protected void tax1099()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdCalculation_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets tax withhold calculation.
    /// </summary>
    /// <param name="_taxWithholdCalculation">
    /// The tax withhold calculation.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxWithholdCalculation_IN</c> class.
    /// </returns>
    public TaxWithholdCalculation_IN taxWithholdCalculation_IN(TaxWithholdCalculation_IN _taxWithholdCalculation = taxWithholdCalculation)
    {
        taxWithholdCalculation = _taxWithholdCalculation;
        return taxWithholdCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tradeCalcTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instance of the <c>TradeCalcTax</c> class.
    /// </summary>
    /// <returns>
    /// An instance of the <c>TradeCalcTax</c> class.
    /// </returns>
    protected Object tradeCalcTax()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogTxt</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets an instance of the <c>TransTxt</c> object.
    /// </summary>
    /// <returns>
    ///   An instance of the <c>TransTxt</c> object.
    /// </returns>
    abstract protected TransTxt  transactionLogTxt()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the transaction log type.
    /// </summary>
    /// <returns>
    /// A <c>TransactionLogType</c> enumeration value.
    /// </returns>
    abstract protected TransactionLogType  transactionLogType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAdvanceInvoiceSettlement_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the advance invoice marked to settle.
    /// </summary>
    /// <remarks>
    ///     Overridden in descendants.
    /// </remarks>
    protected void updateAdvanceInvoiceSettlement_W()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCrossdocking</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates cross docking information.
    /// </summary>
    //Implemented in Classes\PurchPackingSlipJournalPost and Classes\PurchInvoiceJournalPost
    protected void updateCrossdocking()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the transaction Date.
    /// </summary>
    /// <returns>
    ///   A transaction date.
    /// </returns>
    abstract protected TransDate  updateDate()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Updates the journal line.
    /// </summary>
    protected void updateJournalLine()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Updates the journal header.
    /// </summary>
    protected void updateJournalTable()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Updates the source line for the current journal line.
    /// </summary>
    protected void updateSourceLine()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceLineBeforePosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Updates the source line before the posting starts.
    /// </summary>
    protected void updateSourceLineBeforePosting()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Updates the source table for the journal header.
    /// </summary>
    protected void updateSourceTable()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransactTxtForLedgerVoucherObject</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the transaction text.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    ///    The <c>LedgerVoucherObject</c> instance.
    /// </param>
    protected void updateTransactTxtForLedgerVoucherObject(LedgerVoucherObject _ledgerVoucherObject)
    {
        _ledgerVoucherObject.lastTransTxt(transactionTxt.txt());
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatRegData_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes container of VAT related data.
    /// </summary>
    /// <returns>
    ///     The container of vat related data.
    /// </returns>
    /// <remarks>
    ///     Overridden in descendants.
    /// </remarks>
    protected container vatRegData_W()
    {
        return [ dateNull(), dateNull(), "", "", "", "", "", false, false ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeTaxAmount_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Writes tax amount.
    /// </summary>
    /// <remarks>
    ///     Overridden in descendants.
    /// </remarks>

    protected void writeTaxAmount_W()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeTmpTaxWorkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records into the <c>TmpTaxWorkTrans</c> table.
    /// </summary>
    /// <param name="_headingRecId">
    /// The record ID for the header.
    /// </param>
    [SysObsolete('The method has been deprecated, use the writeTmpTaxWorkTransV2() method instead.', false, 20\7\2020)]
    protected void writeTmpTaxWorkTrans(RecId _headingRecId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeTmpTaxWorkTransV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records into the <c>TmpTaxWorkTrans</c> table.
    /// </summary>
    /// <param name="_headingRecId">
    /// The record ID for the header.
    /// </param>
    /// <param name="_headingTableId">
    /// The Table ID for the header.
    /// </param>
    protected void writeTmpTaxWorkTransV2(RecId _headingRecId, TableId _headingTableId)
    {
        if (this.tax())
        {
            // <GEEU>
            if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
            {
                this.tax().parmVatRegData_W(this.vatRegData_W());
            }
            // </GEEU>
            journalTmpTaxWorkTrans.copyFromTax(
                this.tax(),
                _headingRecId,
                _headingTableId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostProj</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>FormletterJournalPost</c> class by using the specified
    /// <c>FormLetter</c> object that is used to post journal and journal lines for projects.
    /// </summary>
    /// <param name="_formLetter">
    /// The <c>FormLetter</c> object that relates to the journal and journal lines.
    /// </param>
    /// <param name="_journalTable">
    /// The journal header record.
    /// </param>
    /// <param name="_parmTable">
    /// The <c>ProjParmTable</c> record that relates to the journal and journal lines.
    /// </param>
    /// <param name="_proforma">
    /// A Boolean value that indicates whether the journal is a pro forma journal.
    /// </param>
    /// <returns>
    /// An instance of the <c>FormletterJournalPost</c> class.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The function has been incorrectly called.
    /// </exception>
    public static FormletterJournalPost newPostProj(
        FormLetter _formLetter,
        Common _journalTable,
        Common _parmTable,
        boolean _proforma)
    {
        ProjInvoiceJournalPost      formletterPost;
        //<GMX>
        ProjFormLetter_Invoice projFormLetterInvoice;
        //</GMX>

        switch (_formLetter.documentStatus())
        {
            case DocumentStatus::Invoice :
                formletterPost = ProjInvoiceJournalPost::construct();
                //<GMX>
                projFormLetterInvoice = _formLetter as ProjFormLetter_Invoice;
                //</GMX>
                break;
            default : throw error(strFmt("@SYS19306",funcName()));
        }

        formletterPost.parmJournalTable(_journalTable);
        formletterPost.parmParmTable(_parmTable);
        formletterPost.parmProforma(_proforma);
        formletterPost.parmFormletter(_formLetter);

        return formletterPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostConsignment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>FormletterJournalPost</c> class by using the specified
    /// <c>ConsignmentReplenishmentOrderFormletterContract</c> object that is used to post journal and journal lines for consignment replenishment
    /// orders.
    /// </summary>
    /// <param name="_formletterContract">
    /// The <c>ConsignmentReplenishmentOrderFormletterContract</c> object that relates to the journal and journal lines.
    /// </param>
    /// <param name="_journalTable">
    /// The journal header record.
    /// </param>
    /// <param name="_parmTable">
    /// The <c>ConsignmentDraftReplenishementOrderJournalHeader</c> record that relates to the journal and journal lines.
    /// </param>
    /// <returns>
    /// An instance of the <c>FormletterJournalPost</c> class.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The function has been incorrectly called.
    /// </exception>
    public static FormletterJournalPost newPostConsignment(
        ConsignmentReplenishmentOrderFormletterContract _formletterContract,
        Common                  _journalTable,
        Common                  _parmTable)
    {
        FormletterJournalPost formletterJournalPost;
        ConsignmentReplenishmentOrderFormLetterJournalPost consignmentReplenishmentOrderFormLetterJournalPost;

        switch (_formletterContract.getDocumentStatus())
        {
            case DocumentStatus::PackingSlip:
                consignmentReplenishmentOrderFormLetterJournalPost = ConsignmentReplenishmentOrderFormLetterJournalPost::construct();
                formletterJournalPost = consignmentReplenishmentOrderFormLetterJournalPost;
                break;
            default : throw error(strFmt("@SYS19306",funcName()));
        }

        formletterJournalPost.parmJournalTable(_journalTable);
        formletterJournalPost.parmParmTable(_parmTable);

        return formletterJournalPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostPurchNoThrow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>FormletterJournalPost</c> class by using the specified
    /// <c>PurchFormLetterContract</c> object that is used to post journal and journal lines for purchase
    /// orders.
    /// </summary>
    /// <param name="_formletterContract">
    /// The <c>PurchFormletterContract</c> object that relates to the journal and journal lines.
    /// </param>
    /// <returns>
    /// An instance of the <c>FormletterJournalPost</c> class.
    /// </returns>
    protected static FormletterJournalPost newPostPurchNoThrow(PurchFormLetterContract _formletterContract)
    {
        FormletterJournalPost       formletterPost;
        PurchInvoiceJournalPost     invoiceJournalPost;
        PurchParmUpdate             purchParmUpdate = _formletterContract.parmParmUpdate() as PurchParmUpdate;

        switch (_formletterContract.getDocumentStatus())
        {
            case DocumentStatus::ConfirmationRequest    : formletterPost = PurchConfirmationRequestJournalPost::construct(); break;
            case DocumentStatus::PurchaseOrder          : formletterPost = PurchConfirmationJournalPost::construct();        break;
            case DocumentStatus::ReceiptsList           : formletterPost = PurchReceiptsListJournalPost::construct();        break;
            case DocumentStatus::PackingSlip            :
                PurchPackingSlipJournalPost packingSlipJournalPost = PurchPackingSlipJournalPost::construct();
                packingSlipJournalPost.parmPrintSalesFormLetter(_formletterContract.parmPrintSalesFormLetter());
                packingSlipJournalPost.parmVersioningUpdateType(_formletterContract.parmVersioningUpdateType());
                formletterPost = packingSlipJournalPost;
                break;

            // <GEEPL>
            case DocumentStatus::PlSAD                  :
                PurchFormLetterSADContract formletterSADContract = _formletterContract as PurchFormLetterSADContract;
                PurchSADJournalPost sadJournalPost = PurchSADJournalPost::construct();
                sadJournalPost.parmSADCurrencyCode_PL(formletterSADContract.parmSADCurrencyCode_PL());
                sadJournalPost.parmSADExchRate_PL    (formletterSADContract.parmSADExchRate_PL());
                sadJournalPost.parmSADNumberCode_PL  (formletterSADContract.parmSADNumberCode_PL());
                invoiceJournalPost = sadJournalPost;
            // no break; fall through to invoice
            // </GEEPL>

            case DocumentStatus::Invoice                :
                PurchFormLetterInvoiceContract formletterInvoiceContract = _formletterContract as PurchFormLetterInvoiceContract;
                // <GEEPL>
                if (! invoiceJournalPost)
                {
                    // </GEEPL>
                    invoiceJournalPost = PurchInvoiceJournalPost::construct();
                    // <GEEPL>
                }
                // </GEEPL>
                invoiceJournalPost.parmSaveChanges(formletterInvoiceContract.parmSaveChanges());
                invoiceJournalPost.parmPrintSalesFormLetter(formletterInvoiceContract.parmPrintSalesFormLetter());
                invoiceJournalPost.parmPrintFormLetter(formletterInvoiceContract.parmPrintFormletter());
                invoiceJournalPost.parmPrintEuVatInvoice(formletterInvoiceContract.parmPrintEuVatInvoice());
                invoiceJournalPost.parmExecutingPaymentAuthorizationTask(formletterInvoiceContract.parmExecutingPaymentAuthorizationTask());
                invoiceJournalPost.parmPurchParmUpdate(purchParmUpdate);
                // <GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                {
                    invoiceJournalPost.parmPrintFacture(formletterInvoiceContract.parmPrintFacture_RU());
                    invoiceJournalPost.parmPrintAcceptanceReport(formletterInvoiceContract.parmPrintAcceptanceReport_RU());
                }
                // </GEERU>
                formletterPost = invoiceJournalPost;
                break;

            // <GIN>
            case DocumentStatus::BillOfEntry_IN         :
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                {
                    PurchBOEJournalPost_IN purchBOEJournalPost = PurchBOEJournalPost_IN::construct();
                    formletterPost = purchBOEJournalPost;
                }
                break;
            // </GIN>

            case DocumentStatus::ApproveJournal         :
                PurchApproveJournalPost approveJournalPost = PurchApproveJournalPost::construct();
                PurchFormLetterApprovalContract formletterApprovalContract = _formletterContract as PurchFormLetterApprovalContract;
                approveJournalPost.parmLedgerJournalTrans(formletterApprovalContract.parmLedgerJournalTrans());
                approveJournalPost.parmOrigTransDate(formletterApprovalContract.parmOrigTransDate());
                approveJournalPost.parmOrigVoucher(formletterApprovalContract.parmOrigVoucher());
                approveJournalPost.parmPurchParmUpdate(purchParmUpdate);
                formletterPost = approveJournalPost;
                break;

            // <GEERU>
            case DocumentStatus::Invoice4Paym_RU        :
                formletterPost = PurchInvoice4PaymJournalPost_RU::construct();
                break;
            case DocumentStatus::Facture_RU             :
                PurchFormLetterFactureContract_RU factureContract = _formletterContract as PurchFormLetterFactureContract_RU;
                PurchFactureJournalPost_RU facturePost = PurchFactureJournalPost_RU::construct();
                facturePost.parmSaveChanges(factureContract.parmSaveChanges());
                facturePost.parmPrintSalesFormLetter(factureContract.parmPrintSalesFormLetter());
                facturePost.parmPrintFormLetter(factureContract.parmPrintFormletter());
                facturePost.parmPrintEuVatInvoice(factureContract.parmPrintEuVatInvoice());
                facturePost.parmPurchParmUpdate(purchParmUpdate);
                facturePost.parmPrintFacture(factureContract.parmPrintFacture_RU());
                formletterPost = facturePost;
                break;
            // </GEERU>
        }

        return formletterPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostPurch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>FormletterJournalPost</c> class by using the specified
    /// <c>PurchFormLetterContract</c> object that is used to post journal and journal lines for purchase
    /// orders.
    /// </summary>
    /// <param name="_formletterContract">
    /// The <c>PurchFormletterContract</c> object that relates to the journal and journal lines.
    /// </param>
    /// <param name="_journalTable">
    /// The journal header record.
    /// </param>
    /// <param name="_parmTable">
    /// The <c>PurchParmTable</c> record that relates to the journal and journal lines.
    /// </param>
    /// <returns>
    /// An instance of the <c>FormletterJournalPost</c> class.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The function has been incorrectly called.
    /// </exception>
    public static FormletterJournalPost newPostPurch(
        PurchFormLetterContract _formletterContract,
        Common                  _journalTable,
        Common                  _parmTable)
    {
        FormletterJournalPost formletterPost = FormletterJournalPost::newPostPurchNoThrow(_formletterContract);

        if(!formletterPost)
        {
            throw error(strFmt("@SYS19306", funcName()));
        }

        PurchParmUpdate purchParmUpdate = _formletterContract.parmParmUpdate() as PurchParmUpdate;
        formletterPost.parmJournalTable(_journalTable);
        formletterPost.parmParmTable(_parmTable);
        formletterPost.parmProforma(purchParmUpdate.Proforma);
        formletterPost.parmChainFormletterContract(_formletterContract);
        if (_formletterContract.parmLineIdSetPacked())
        {
            container lineIdSetPacked = SysOperationHelper::base64Decode(_formletterContract.parmLineIdSetPacked());
            Set lineIdSet = Set::create(lineIdSetPacked);
            if (lineIdSet.elements())
            {
                formletterPost.parmPackedLineIdSet(lineIdSetPacked);
            }
        }
        formletterPost.parmStorno(purchParmUpdate.Storno);
        return formletterPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostPurchRFQ</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>FormletterJournalPost</c> class by using the specified
    /// <c>PurchRFQFormLetterContract</c> object that is used to post journal and journal lines for request
    /// for quotes.
    /// </summary>
    /// <param name="_formletterContract">
    /// The <c>PurchRFQFormLetterContract</c> object that relates to the journal and journal lines.
    /// </param>
    /// <param name="_journalTable">
    /// The journal header record.
    /// </param>
    /// <param name="_parmTable">
    /// The <c>PurchRFQParmTable</c> record that relates to the journal and journal lines.
    /// </param>
    /// <returns>
    /// An instance of the <c>FormletterJournalPost</c> class.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The function has been incorrectly called.
    /// </exception>
    public static FormletterJournalPost newPostPurchRFQ(PurchRFQFormLetterContract _formletterContract,
                                                        Common             _journalTable,
                                                        Common             _parmTable)
    {
        FormletterJournalPost   formletterPost;
        PurchRFQParmUpdate      purchRFQParmUpdate;

        switch (_formletterContract.getDocumentStatus())
        {
            case DocumentStatus::RFQ        : formletterPost = PurchRFQSendJournalPost::construct();break;
            case DocumentStatus::RFQAccept  : formletterPost = PurchRFQAcceptJournalPost::construct();break;
            case DocumentStatus::RFQReject  : formletterPost = PurchRFQRejectJournalPost::construct();break;
            case DocumentStatus::RFQReSend  : formletterPost = PurchRFQReSendJournalPost::construct();break;//Resend.

            default : throw error(strFmt("@SYS19306",funcName()));
        }

        purchRFQParmUpdate = _formletterContract.parmParmUpdate() as PurchRFQParmUpdate;
        formletterPost.parmJournalTable(_journalTable);
        formletterPost.parmParmTable(_parmTable);
        formletterPost.parmPrintout(_formletterContract.parmPrintOut());
        formletterPost.parmSpecQty(purchRFQParmUpdate.SpecQty);

        return formletterPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostSales</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>FormletterJournalPost</c> class by using the specified
    /// <c>SalesFormLetterContract</c> object that is used to post journal and journal lines for sales
    /// orders.
    /// </summary>
    /// <param name="_formletterContract">
    /// The <c>SalesFormLetterContract</c> object that relates to the journal and journal lines.
    /// </param>
    /// <param name="_journalTable">
    /// The journal header record.
    /// </param>
    /// <param name="_parmTable">
    /// The <c>SalesParmTable</c> record that relates to the journal and journal lines.
    /// </param>
    /// <returns>
    /// An instance of the <c>FormletterJournalPost</c> class.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The function has been incorrectly called.
    /// </exception>
    public static FormletterJournalPost newPostSales(SalesFormLetterContract _formletterContract,
                                                     Common _journalTable,
                                                     Common _parmTable)
    {
        DocumentStatusFactoryAttribute  attribute       = new DocumentStatusFactoryAttribute(_formletterContract.getDocumentStatus());
        FormletterJournalPost           formletterPost  = SysExtensionAppClassFactory::getClassFromSysAttribute(classStr(FormletterJournalPost), attribute) as FormletterJournalPost;

        if (!formletterPost)
        {
            throw error(strfmt("@SYS19306",funcname()));
        }

        formletterPost.initFromFormLetterContract(_formletterContract);

        SalesParmUpdate salesParmUpdate = _formletterContract.parmParmUpdate() as SalesParmUpdate;
        formletterPost.parmJournalTable(_journalTable);
        formletterPost.parmParmTable(_parmTable);
        formletterPost.parmChainFormletterContract(_formletterContract);
        if (_formletterContract.parmLineIdSetPacked())
        {
            container   lineIdSetPacked = SysOperationHelper::base64Decode(_formletterContract.parmLineIdSetPacked());
            Set         lineIdSet       = Set::create(lineIdSetPacked);
            if (lineIdSet.elements())
            {
                formletterPost.parmPackedLineIdSet(lineIdSetPacked);
            }
        }
        formletterPost.parmPrintout(_formletterContract.parmPrintOut());
        formletterPost.parmProforma(salesParmUpdate.Proforma);
        formletterPost.parmReduceOnHand(salesParmUpdate.ReduceOnHand);
        formletterPost.parmSpecQty(enum2int(salesParmUpdate.SpecQty));
        formletterPost.parmStorno(salesParmUpdate.Storno);
        formletterPost.parmSumBy(salesParmUpdate.SumBy);
        formletterPost.parmSumOrderId(salesParmUpdate.SumSalesId);
        formletterPost.parmShipmentId(_formletterContract.parmShipmentId());
        formletterPost.parmWHSLoadId(_formletterContract.parmWHSLoadId());

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            formletterPost.parmMCRInventTransRecid(_formletterContract.parmMCRInventTransRecid());
        }

        return formletterPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingInBatch</Name>
				<Source><![CDATA[
    public boolean parmPostingInBatch(boolean _postingInBatch = postingInBatch)
    {
        postingInBatch = _postingInBatch;
        return postingInBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLinesPosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a set of posted journal line record IDs.
    /// </summary>
    /// <returns>A set of posted lines record IDs</returns>
    public Set getLinesPosted()
    {
        return linesPosted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post current tax document.
    /// </summary>
    /// <param name="_checkLedgerVoucher">
    /// A Boolean value that indicates whether checking the LedgerVoucher; optional.
    /// </param>
    public void postTaxDocument(boolean _checkLedgerVoucher = true)
    {
        boolean runPostTaxDocument = !_checkLedgerVoucher || (ledgerVoucher && (isLedgerVoucherPosted || ledgerVoucher.check()));

        if (runPostTaxDocument)
        {
            Debug::assert(taxDocumentLedgerVoucherMap!= null);

            if (taxDocumentLedgerVoucherMap.empty())
            {
                ITaxableDocument taxableDocument = TaxableDocumentObject::construct(this.parmTaxableDocumentDescriptor());
                TaxBusinessService::postTaxDocument(taxableDocument, ledgerVoucher);
            }
            else
            {
                TableId transactionTableId;
                RecId transactionRecId;
                MapEnumerator enumerator = taxDocumentLedgerVoucherMap.getEnumerator();
                while(enumerator.moveNext())
                {
                    [transactionTableId, transactionRecId] = enumerator.currentKey();

                    DictTable dictTable = new DictTable(transactionTableId);
                    Common common = dictTable.makeRecord();

                    select firstonly common
                        where common.RecId == transactionRecId;

                    if (common.RecId)
                    {
                        TaxBusinessService::postTaxDocument(
                            TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(common)),
                            enumerator.currentValue());
                    }

                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post tax from tax document.
    /// </summary>
    protected void postTaxGTE()
    {
        ITaxableDocument    taxableDocument;

        taxableDocument = TaxableDocumentObject::construct(this.parmTaxableDocumentDescriptor());
        TaxBusinessService::postTax(ledgerVoucher, taxableDocument);

        if (taxDocumentLedgerVoucherMap)
        {
            taxDocumentLedgerVoucherMap.insert([taxableDocument.getTransactionTableId(), taxableDocument.getTransactionRecordId()], ledgerVoucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger voucher.
    /// </summary>
    /// <returns>The ledger voucher.</returns>
    public LedgerVoucher getLedgerVoucher()
    {
        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateParmTableJobStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when updating JobStatus is required outside journal posting scope- Simulation scenario
    /// </summary>
    /// <param name="_startDateTime">
    /// The start date time of the posting
    /// </param>
    internal void updateParmTableJobStatus(StartDateTime _startDateTime = this.getDateTimeNow())
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDateTimeNow</Name>
				<Source><![CDATA[
    protected StartDateTime getDateTimeNow()
    {
        return DateTimeUtil::newDateTime(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),DateTimeUtil::getTimeNow(DateTimeUtil::getUserPreferredTimeZone()),DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferPackedTaxCalculationInput</Name>
				<Source><![CDATA[
    private void transferPackedTaxCalculationInput()
    {
        TaxIntegrationCalculationInputPersisted packedTaxCalculationInput;

        RefTableId headingTableId = this.parmParmTable().TableId;
        RefRecId headingRecId = this.parmParmTable().RecId;

        if (headingTableId == tableNum(ProjInvoiceParmTable))
        {
            headingTableId = this.parmProjProposalJour().TableId;
            headingRecId = this.parmProjProposalJour().RecId;
        }

        update_recordset packedTaxCalculationInput
            setting
                JournalTableId = this.parmJournalTable().TableId,
                JournalRecId = this.parmJournalTable().RecId
            where packedTaxCalculationInput.HeadingTableId == headingTableId
                && packedTaxCalculationInput.HeadingRecId == headingRecId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>