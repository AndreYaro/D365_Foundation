<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReqPlanCopy</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ReqPlanCopy extends RunBaseBatch implements BatchRetryable
{
    ReqPlanId       fromReqPlanId;
    ReqPlanId       toReqPlanId;

    Dialog          dialog;
    DialogField     dialogFromReqPlanId;
    DialogField     dialogToReqPlanId;

    ReqPlanManager  reqPlanManager;
    ReqBackgroundJobService backgroundJobService;
    BatchGroupId batchGroupId;

    private boolean skipCopyLog;
    private boolean reqBatchTasksSchedulingFixToggleEnabled;

    #DEFINE.CurrentVersion(1)
    #LOCALMACRO.CurrentList
        fromReqPlanId,
        toReqPlanId
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>backgroundJobService</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Exposes the instance of the <c>ReqBackgroundJobService</c> class.
    /// </summary>
    /// <returns>
    ///     The instance of the <c>ReqBackgroundJobService</c> class.
    /// </returns>
    public ReqBackgroundJobService backgroundJobService()
    {
        if (!backgroundJobService)
        {
            backgroundJobService = ReqBackgroundJobService::newBatchHeader();
        }
        return backgroundJobService;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the class is shown in the list of <c>Journal</c> types.
    /// </summary>
    /// <returns>
    ///    true if the class is shown in the list of <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    A class that can be used in a batch journal is a class where the same parameters can be used
    ///    repeatedly. The dialog can be shown and the parameters can be changed but parameters of some
    ///    classes might build on data that is only valid for a short time. Running a class two times with the
    ///    same parameters is not always possible. If <see cref="M:RunBaseBatch.canGoBatch" /> is false, this
    ///    method will not have any effect.
    /// </remarks>
    boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>caption</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the description from the current class by calling the static description method on the
    ///    class if there is one.
    /// </summary>
    /// <returns>
    ///    The description from the current class.
    /// </returns>
    /// <remarks>
    ///    This method can be overridden to give a more precise description, for example, when you need some
    ///    internal variables to build the description text. The static <c>RunBase::description </c> method is
    ///    generally used to obtain the description of a class because you do not have to instantiate the
    ///    class to call it. The method speeds up displaying the description in a grid, for example.
    /// </remarks>
    ClassDescription caption()
    {
        return ReqPlanCopy::description();
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyPlan</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies the master plan.
    /// </summary>
    /// <param name="_fromReqPlanId">
    ///    The ID of the source master plan.
    /// </param>
    /// <param name="_toReqPlanId">
    ///    The ID of the target master plan.
    /// </param>
    /// <param name="_useUpdateLockOnTargetPlanVersion">
    ///    A boolean that indicates whether an update lock should be used for locking the target plan version that will finally be cleaned up.
    /// </param>
    /// <remarks>
    ///    The target master plan is deleted before it is updated.
    /// </remarks>
    protected void copyPlan(
        ReqPlanId _fromReqPlanId,
        ReqPlanId _toReqPlanId,
        boolean   _useUpdateLockOnTargetPlanVersion)
    {
        ReqPlan             sourcePlan = ReqPlan::findReqPlanId(_fromReqPlanId);
        ReqPlan             targetPlan = ReqPlan::findReqPlanId(_toReqPlanId);
        ReqPlanVersion      sourcePlanVersion;
        ReqPlanVersion      targetPlanVersion;
        ReqPlanVersion      targetPlanVersionToBeCleanedUp;

        if (_useUpdateLockonTargetPlanVersion)
        {
            targetPlanVersionToBeCleanedUp = this.reqPlanManager().acquireUpdateLockOnActivePlanVersion(targetPlan.ReqPlanId);
        }
        else
        {
            targetPlanVersionToBeCleanedUp = ReqPlan::findReqPlanId(targetPlan.ReqPlanId).findActiveVersion();
            this.reqPlanManager().acquireReaderLockOnPlanVersion(targetPlanVersionToBeCleanedUp);
        }
        
        boolean sourcePlanVersionLockAcquired = false;
        boolean targetPlanVersionLockAcquired = false;
        try
        {
            sourcePlanVersion = sourcePlan.getActiveVersion();
            this.reqPlanManager().acquireReaderLockOnPlanVersion(sourcePlanVersion);
            sourcePlanVersionLockAcquired = true;

            targetPlanVersion = targetPlan.createNewInactiveVersion();
            this.reqPlanManager().acquireUpdateLockOnPlanVersion(targetPlanVersion);
            targetPlanVersionLockAcquired = true;

            ttsbegin;
            this.copyReqTransAndReqTransCov(sourcePlanVersion, targetPlanVersion);
            this.copyReqPO(sourcePlanVersion, targetPlanVersion);
            this.copyReqRoute(sourcePlanVersion, targetPlanVersion);
            this.copyReqRouteJob(sourcePlanVersion, targetPlanVersion);
            this.copyWrkCtrCapRes(sourcePlanVersion, targetPlanVersion);

            if (!this.parmSkipCopyLog())
            {
                this.insertLog(sourcePlan.ReqPlanId, targetPlan.ReqPlanId);
            }

            targetPlan.switchActiveVersionTo(targetPlanVersion);

            if (reqBatchTasksSchedulingFixToggleEnabled)
            {
                if (this.isInBatch())
                {
                    this.backgroundJobService().parmGroupId(this.parmCurrentBatch().GroupId);
                }
            }
            else
            {
                // ReqPlanCopy.parmGroupId method can be deprecated once ReqBatchTasksSchedulingFixToggle flight is removed
                this.backgroundJobService().parmGroupId(this.parmGroupId());
            }

            this.backgroundJobService().parmTriggeredBy(classStr(ReqPlanCopy));
            this.backgroundJobService().startPlanVersionCleanup(targetPlanVersionToBeCleanedUp);
            ttscommit;
        }
        finally
        {
            if (targetPlanVersionLockAcquired) 
            {
                this.reqPlanManager().releaseLockOnPlanVersion(targetPlanVersion);
            }
            if (sourcePlanVersionLockAcquired) 
            {
                this.reqPlanManager().releaseLockOnPlanVersion(sourcePlanVersion);
            }
            this.reqPlanManager().releaseLockOnPlanVersion(targetPlanVersionToBeCleanedUp);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyPreservedPlanData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies approved planned orders and planned orders in freezing time fences into the inactive version
    ///    of the master plan.
    /// </summary>
    /// <param name="_reqPlanVersionFrom">
    ///    The source plan version.
    /// </param>
    /// <param name="_reqPlanVersionTo">
    ///    The target plan version.
    /// </param>
    /// <param name="_reqPlanData">
    ///    An instance of the <c>ReqPlanData</c> class that contains master plan parameters.
    /// </param>
    public void copyPreservedPlanData(
        ReqPlanVersion      _reqPlanVersionFrom,
        ReqPlanVersion      _reqPlanVersionTo,
        ReqPlanData         _reqPlanData)
    {
        try
        {
            this.updateReqTransKeepForApproved(_reqPlanVersionFrom);
            this.updateReqTransKeepInTimeFences(_reqPlanVersionFrom, _reqPlanData);
            this.updateReqTransKeepDerived(_reqPlanVersionFrom);

            this.copyReqTransKeep(         _reqPlanVersionFrom, _reqPlanVersionTo);
            this.copyReqTransCovKeep(      _reqPlanVersionFrom, _reqPlanVersionTo);
            this.copyReqPOForReqTrans(     _reqPlanVersionFrom, _reqPlanVersionTo);
            this.copyReqRouteForReqPO(     _reqPlanVersionFrom, _reqPlanVersionTo);
            this.copyReqRouteJobForReqPO(  _reqPlanVersionFrom, _reqPlanVersionTo);
            this.copyWrkCtrCapResForReqPO( _reqPlanVersionFrom, _reqPlanVersionTo);
        }
        catch (Exception::DuplicateKeyException)
        {
            error("@SCMPlanning:ReqPlanCopyDuplicateKeyException");
            throw;
        }
        catch (Exception::DuplicateKeyExceptionNotRecovered)
        {
            error("@SCMPlanning:ReqPlanCopyDuplicateKeyException");
            throw;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyReqPO</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copies planned orders from the source master plan version to the target master plan version.
    /// </summary>
    /// <param name="_reqPlanVersionFrom">
    ///     The version of the source master plan.
    /// </param>
    /// <param name="_reqPlanVersionTo">
    ///     The version of the target master plan.
    /// </param>    
    protected void copyReqPO(
        ReqPlanVersion           _reqPlanVersionFrom,
        ReqPlanVersion           _reqPlanVersionTo)
    {
        ReqPlanCopyReqPO reqPlanCopyReqPO = ReqPlanCopyReqPO::newFromReqPlanVersions(_reqPlanVersionFrom, _reqPlanVersionTo);
        ttsbegin;
        reqPlanCopyReqPO.execute();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyReqPOForReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copies planned orders from the source master plan version
    ///     related to the requirement profile in the target master plan version.
    /// </summary>
    /// <param name="_reqPlanVersionFrom">
    ///     The version of the source master plan.
    /// </param>
    /// <param name="_reqPlanVersionTo">
    ///     The version of the target master plan.
    /// </param>
    protected void copyReqPOForReqTrans(ReqPlanVersion _reqPlanVersionFrom, ReqPlanVersion _reqPlanVersionTo)
    {
        ReqPlanCopyReqPOForReqTrans reqPlanCopyReqPOForReqTrans = ReqPlanCopyReqPOForReqTrans::newFromReqPlanVersions(_reqPlanVersionFrom, _reqPlanVersionTo);
        ttsbegin;
        reqPlanCopyReqPOForReqTrans.execute();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyReqRoute</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copies routes of planned production orders from the source master plan version
    ///     to the target master plan version.
    /// </summary>
    /// <param name="_reqPlanVersionFrom">
    ///     The version of the source master plan.
    /// </param>
    /// <param name="_reqPlanVersionTo">
    ///     The version of the target master plan.
    /// </param>
    [Hookable]
    public void copyReqRoute(
        ReqPlanVersion           _reqPlanVersionFrom,
        ReqPlanVersion           _reqPlanVersionTo)
    {
        ReqRoute            reqRouteSelect;

        ReqPlanCopyReqRoute reqPlanCopyReqRoute = ReqPlanCopyReqRoute::newFromReqPlanVersions(_reqPlanVersionFrom, _reqPlanVersionTo);

        // Covering nonclustered index seek
        while select OprNum
        from         reqRouteSelect
        group by     OprNum
        where        reqRouteSelect.PlanVersion            == _reqPlanVersionFrom.RecId
        {
            ttsbegin;
            reqPlanCopyReqRoute.oprNumRange(reqRouteSelect.OprNum);
            reqPlanCopyReqRoute.execute();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyReqRouteForReqPO</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copies routes from the source master plan version
    ///     related to planned production orders in the target master plan version.
    /// </summary>
    /// <param name="_reqPlanVersionFrom">
    ///     The version of the source master plan.
    /// </param>
    /// <param name="_reqPlanVersionTo">
    ///     The version of the target master plan.
    /// </param>
    [Hookable]
    public void copyReqRouteForReqPO(ReqPlanVersion _reqPlanVersionFrom, ReqPlanVersion _reqPlanVersionTo)
    {
        ReqPlanCopyReqRouteForReqPO reqPlanCopyReqRouteForReqPO = ReqPlanCopyReqRouteForReqPO::newFromReqPlanVersions(_reqPlanVersionFrom, _reqPlanVersionTo);
        ttsbegin;
        reqPlanCopyReqRouteForReqPO.execute();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyReqRouteJob</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copies route jobs of planned production orders from the source master plan version
    ///     to the target master plan version.
    /// </summary>
    /// <param name="_reqPlanVersionFrom">
    ///     The version of the source master plan.
    /// </param>
    /// <param name="_reqPlanVersionTo">
    ///     The version of the target master plan.
    /// </param>
    protected void copyReqRouteJob(
        ReqPlanVersion           _reqPlanVersionFrom,
        ReqPlanVersion           _reqPlanVersionTo)
    {
        ReqRouteJob         reqRouteJobSelect;

        ReqPlanCopyReqRouteJob reqPlanCopyReqRouteJob = ReqPlanCopyReqRouteJob::newFromReqPlanVersions(_reqPlanVersionFrom, _reqPlanVersionTo);

        // Covering nonclustered index seek
        while select WrkCtrId
        from         reqRouteJobSelect
        group by     WrkCtrId
        where        reqRouteJobSelect.PlanVersion            == _reqPlanVersionFrom.RecId
        {
            ttsbegin;
            reqPlanCopyReqRouteJob.wrkCtrIdRange(reqRouteJobSelect.WrkCtrId);
            reqPlanCopyReqRouteJob.execute();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyReqRouteJobForReqPO</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copies route jobs from the source master plan version
    ///     related to planned production orders in the target master plan version.
    /// </summary>
    /// <param name="_reqPlanVersionFrom">
    ///     The version of the source master plan.
    /// </param>
    /// <param name="_reqPlanVersionTo">
    ///     The version of the target master plan.
    /// </param>
    protected void copyReqRouteJobForReqPO(ReqPlanVersion _reqPlanVersionFrom, ReqPlanVersion _reqPlanVersionTo)
    {
        ReqPlanCopyReqRouteJobForReqPO reqPlanCopyReqRouteJobForReqPO = ReqPlanCopyReqRouteJobForReqPO::newFromReqPlanVersions(_reqPlanVersionFrom, _reqPlanVersionTo);
        ttsbegin;
        reqPlanCopyReqRouteJobForReqPO.execute();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyReqTransAndReqTransCov</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies the requirement profile and the coverage from the source master plan to the target master
    ///    plan.
    /// </summary>
    /// <param name="_reqPlanVersionFrom">
    ///    The version of the source master plan.
    /// </param>
    /// <param name="_reqPlanVersionTo">
    ///    The version of the target master plan.
    /// </param>   
    protected void copyReqTransAndReqTransCov(
        ReqPlanVersion           _reqPlanVersionFrom,
        ReqPlanVersion           _reqPlanVersionTo)
    {
        ReqPlanCopyReqTrans reqPlanCopyReqTrans = ReqPlanCopyReqTrans::newFromReqPlanVersions(_reqPlanVersionFrom, _reqPlanVersionTo);
        ttsbegin;
        reqPlanCopyReqTrans.execute();
        ttscommit;

        ReqPlanCopyReqTransCov reqPlanCopyReqTransCov = ReqPlanCopyReqTransCov::newFromReqPlanVersions(_reqPlanVersionFrom, _reqPlanVersionTo);
        ttsbegin;
        reqPlanCopyReqTransCov.execute();       
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyReqTransKeep</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copies the preserved requirements profile from the source master plan version
    ///     to the target master plan version.
    /// </summary>
    /// <param name="_reqPlanVersionFrom">
    ///     The version of the source master plan.
    /// </param>
    /// <param name="_reqPlanVersionTo">
    ///     The version of the target master plan.
    /// </param>
    /// <remarks>
    ///     The function skips AOS validation methods on table buffers in order to improve performance of
    ///     set-based operations.
    /// </remarks>
    protected void copyReqTransKeep(
        ReqPlanVersion _reqPlanVersionFrom,
        ReqPlanVersion _reqPlanVersionTo)
    {
        ReqPlanCopyReqTransKeep reqPlanCopyReqTransKeep = ReqPlanCopyReqTransKeep::newFromReqPlanVersions(_reqPlanVersionFrom, _reqPlanVersionTo);

        ttsbegin;
        reqPlanCopyReqTransKeep.execute();
        ttscommit;

        ReqTrans reqTransInsert;

        ttsbegin;
        update_recordset reqTransInsert
        setting          OpenStatus = ReqOpenStatus::Neg
        where            reqTransInsert.PlanVersion             == _reqPlanVersionTo.RecId
                         && reqTransInsert.Direction            == InventDirection::Issue;
        ttscommit;

        ttsbegin;
        update_recordset reqTransInsert
        setting          OpenStatus    = ReqOpenStatus::Pos
        where            reqTransInsert.PlanVersion             == _reqPlanVersionTo.RecId
                         && reqTransInsert.Direction            == InventDirection::Receipt;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyWrkCtrCapRes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copies capacity reservations for planned production orders from the source master plan version
    ///     to the target master plan version.
    /// </summary>
    /// <param name="_reqPlanVersionFrom">
    ///     The version of the source master plan.
    /// </param>
    /// <param name="_reqPlanVersionTo">
    ///     The version of the target master plan.
    /// </param>
    [Hookable]
    public void copyWrkCtrCapRes(
        ReqPlanVersion           _reqPlanVersionFrom,
        ReqPlanVersion           _reqPlanVersionTo)
    {
        WrkCtrCapRes        wrkCtrCapResSelect;
   
        ReqPlanCopyWrkCtrCapRes reqPlanCopyWrkCtrCapRes = ReqPlanCopyWrkCtrCapRes::newFromReqPlanVersions(_reqPlanVersionFrom, _reqPlanVersionTo);
        
        while select WrkCtrId
        from         wrkCtrCapResSelect
        group by     WrkCtrId
        where        wrkCtrCapResSelect.PlanVersion            == _reqPlanVersionFrom.RecId
        {
            reqPlanCopyWrkCtrCapRes.wrkCtrIdRange(wrkCtrCapResSelect.WrkCtrId);
            ttsbegin;
            reqPlanCopyWrkCtrCapRes.execute();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyWrkCtrCapResForReqPO</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copies capacity reservations from the source master plan version
    ///     related to planned production orders in the target master plan version.
    /// </summary>
    /// <param name="_reqPlanVersionFrom">
    ///     The version of the source master plan.
    /// </param>
    /// <param name="_reqPlanVersionTo">
    ///     The version of the target master plan.
    /// </param>
    [Hookable]
    public void copyWrkCtrCapResForReqPO(ReqPlanVersion _reqPlanVersionFrom, ReqPlanVersion _reqPlanVersionTo)
    {
        ReqPlanCopyWrkCtrCapResForReqPO reqPlanCopyWrkCtrCapResForReqPO = ReqPlanCopyWrkCtrCapResForReqPO::newFromReqPlanVersions(_reqPlanVersionFrom, _reqPlanVersionTo);

        ttsbegin;
        reqPlanCopyWrkCtrCapResForReqPO.execute();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    ///    in the Application Object Tree (AOT).
    /// </remarks>
    Object dialog()
    {
        dialog = super();

        dialogFromReqPlanId = dialog.addFieldValue(extendedTypeStr(ReqPlanId),fromReqPlanId,"@SYS70662");
        dialogToReqPlanId   = dialog.addFieldValue(extendedTypeStr(ReqPlanId),toReqPlanId  ,"@SYS70663");

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks that the current runtime is in transaction.
    /// </summary>
    /// <returns>true if the transaction level is not zero; otherwise, false.</returns>
    public boolean isInTransaction()
    {
        return (appl.ttsLevel() != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>executePlanCopying</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Performs the plan copying.
    /// </summary>
    /// <param name="_sourceReqPlanId">
    ///     The ID of the source plan.
    /// </param>
    /// <param name="_targetReqPlanId">
    ///     The ID of the target plan.
    /// </param>
    /// <param name="_useUpdateLockOnTargetPlanVersion">
    ///    A boolean that indicates whether an update lock should be used for locking the target plan version that will finally be cleaned up; optional.
    /// </param>
    public void executePlanCopying(
        ReqPlanId _sourceReqPlanId,
        ReqPlanId _targetReqPlanId,
        boolean   _useUpdateLockOnTargetPlanVersion = true
        )
    {
        #OCCRetryCount
        setPrefix(this.caption());

        fromReqPlanId = _sourceReqPlanId;
        toReqPlanId = _targetReqPlanId;

        if (!this.validate())
        {
            throw error("@SYS18447");
        }

        if (this.isInTransaction())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        try
        {
            this.copyPlan(_sourceReqPlanId, _targetReqPlanId, _useUpdateLockonTargetPlanVersion);
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    boolean getFromDialog()
    {
        fromReqPlanId   = dialogFromReqPlanId.value();
        toReqPlanId     = dialogToReqPlanId.value();

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLog</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Inserts the log of copying the master plan.
    /// </summary>
    /// <param name="_fromReqPlanId">
    ///     The ID of the source master plan.
    /// </param>
    /// <param name="_toReqPlanId">
    ///     The ID of the target master plan.
    /// </param>
    protected void insertLog(
        ReqPlanId   _fromReqPlanId,
        ReqPlanId   _toReqPlanId)
    {
        ReqLog      reqLog;

        select reverse firstonly reqLog
            order by ReqPlanId, EndDateTime
            where reqLog.ReqPlanId == _fromReqPlanId;

        this.insertLogCopy(reqLog, _toReqPlanId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLogCopy</Name>
				<Source><![CDATA[
    private void insertLogCopy(
        ReqLog      _reqLog,
        ReqPlanId   _toReqPlanId)
    {
        ReqLog reqLog = _reqLog;

        if (reqLog)
        {
            ttsbegin;

            reqLog.CopyReqPlanId = reqLog.ReqPlanId;
            reqLog.ReqPlanId     = _toReqPlanId;
            reqLog.CopyDateTime  = DateTimeUtil::getSystemDateTime();
            reqLog.ReqLogId      = NumberSeq::newGetNumFromId(ReqPlanData::newReqPlanId(_toReqPlanId).sequenceLogId()).num();
            reqLog.insert();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyLogForProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies the <c>ReqLog</c> record for a specific process id to a different plan.
    /// </summary>
    /// <param name = "_fromReqPlanId">The id of the source plan.</param>
    /// <param name = "_fromReqProcessId">The master planning process id the log was generated for.</param>
    /// <param name = "_toReqPlanId">The id of the target plan.</param>
    public void copyLogForProcess(
        ReqPlanId   _fromReqPlanId,
        ReqProcessId _fromReqProcessId,
        ReqPlanId   _toReqPlanId)
    {
        ReqLog reqLog;

        select reverse firstonly reqLog
            order by EndDateTime
            where reqLog.ReqPlanId == _fromReqPlanId
              && reqLog.ProcessId == _fromReqProcessId;

        this.insertLogCopy(reqLog, _toReqPlanId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        reqBatchTasksSchedulingFixToggleEnabled = ReqBatchTasksSchedulingFixToggle::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    container pack()
    {
        return [#CurrentVersion,#CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFromReqPlanId</Name>
				<Source><![CDATA[
    ReqPlanId parmFromReqPlanId(ReqPlanId _fromReqPlanId = fromReqPlanId)
    {
        fromReqPlanId = _fromReqPlanId;
        return fromReqPlanId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmToReqPlanId</Name>
				<Source><![CDATA[
    ReqPlanId parmToReqPlanId(ReqPlanId _toReqPlanId = toReqPlanId)
    {
        toReqPlanId = _toReqPlanId;
        return toReqPlanId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGroupId</Name>
				<Source><![CDATA[
    /// <remarks>
    /// The batch group specified using this method is no longer respected when flight <c>ReqBatchTasksSchedulingFixToggle</c> 
    /// is enabled and will be depracated once the flight is removed.
    /// </remarks>
    public BatchGroupId parmGroupId(BatchGroupId _batchGroupId = batchGroupId)
    {
        batchGroupId = _batchGroupId;
        return batchGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqPlanManager</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Exposes an instance of the <c>ReqPlanManager</c> class.
    /// </summary>
    /// <returns>
    ///    The instance of the <c>ReqPlanManager</c> class.
    /// </returns>
    public ReqPlanManager reqPlanManager()
    {
        if (!reqPlanManager)
        {
            reqPlanManager = ReqPlanManager::construct();
        }
        return reqPlanManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        this.executePlanCopying(fromReqPlanId, toReqPlanId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the batch task is run on the server or on a client.
    /// </summary>
    /// <returns>
    ///    true if the task is run on the server; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The classes that extend <c>RunBaseBatch</c> must override the <c>runsImpersonated</c> method and
    ///    return false, if those tasks are to run on a client.
    /// </remarks>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReqBackgroundJobService</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes an instance of the <c>ReqBackgroundJobService</c> class.
    /// </summary>
    /// <param name="_backgroundService">
    ///    The instance of the <c>ReqBackgroundJobService</c> class.
    /// </param>
    public void setReqBackgroundJobService(ReqBackgroundJobService _backgroundService)
    {
        backgroundJobService = _backgroundService;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReqPlanManager</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the instance of the <c>ReqPlanManager</c> class.
    /// </summary>
    /// <param name="_reqPlanManager">
    ///     The instance of the <c>ReqPlanManager</c> class.
    /// </param>
    public void setReqPlanManager(ReqPlanManager _reqPlanManager)
    {
        reqPlanManager = _reqPlanManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    boolean unpack(container packedClass)
    {
        Integer         version        = conPeek(packedClass,1);

        switch (version)
        {
            case #CurrentVersion:
                [version,#CurrentList] = packedClass;
                break;

            default:
                return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqTransKeepDerived</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>Keep</c> flag in the <c>ReqTrans</c> table where the parent receipt has already been
    ///    marked.
    /// </summary>
    /// <param name="_reqPlanVersion">
    ///    The version of the master plan.
    /// </param>
    /// <remarks>
    ///    The function skips AOS validation methods on table buffers in order to improve performance of
    ///    set-based operations.
    /// </remarks>
    private void updateReqTransKeepDerived(ReqPlanVersion _reqPlanVersion)
    {
        ReqTrans    reqTrans;
        ReqTrans    reqTransCoProduct;
        ReqTrans    reqTransParent;

        new SkipAOSValidationPermission().assert();

        reqTrans.skipDataMethods(true);
        reqTrans.skipAosValidation(true);

        ttsbegin;

        update_recordset reqTrans
            setting Keep       = NoYes::Yes,
                    OpenStatus = ReqOpenStatus::Zero
            where   reqTrans.PlanVersion == _reqPlanVersion.RecId
        exists join reqTransParent
            where reqTransParent.PlanVersion == _reqPlanVersion.RecId
               && reqTransParent.Keep == true
               && (   (reqTrans.RefType == ReqRefType::BOMLine           && reqTransParent.RefType == ReqRefType::BOMPlannedOrder)
                   || (reqTrans.RefType == ReqRefType::TransferDemand    && reqTransParent.RefType == ReqRefType::TransferPlannedOrder)
                   || (reqTrans.RefType == ReqRefType::PlannedKanbanLine && reqTransParent.RefType == ReqRefType::PlannedKanban)
                   || (reqTrans.RefType == ReqRefType::PmfFormulaLine    && reqTransParent.RefType == ReqRefType::PmfPlannedProdBatch))
               && reqTransParent.RefId == reqTrans.RefId;

        update_recordSet reqTransCoProduct
            setting Keep = NoYes::Yes
            where reqTransCoProduct.PlanVersion == _reqPlanVersion.RecId
               && reqTransCoProduct.RefType     == ReqRefType::PmfCoProduct
        exists join reqTransParent
            where reqTransParent.PlanVersion == _reqPlanVersion.RecId
               && reqTransParent.Keep        == true
               && reqTransParent.RefType     == ReqRefType::PmfPlannedProdBatch
               && reqTransParent.RefId       == reqTransCoProduct.RefId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqTransKeepForApproved</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the requirements profile by setting the <c>Keep</c> field in the <c>ReqTrans</c> table to
    ///    true for the records that are related to the approved planned orders.
    /// </summary>
    /// <param name="_reqPlanVersion">
    ///    The version of the master plan.
    /// </param>
    /// <remarks>
    ///    The function skips AOS validation methods on table buffers in order to improve performance of
    ///    set-based operations.
    /// </remarks>
    protected void updateReqTransKeepForApproved(ReqPlanVersion _reqPlanVersion)
    {
        ReqTrans    reqTransInsert;
        ReqPO       reqPOSelect;

        new SkipAOSValidationPermission().assert();

        reqTransInsert.skipDataMethods(true);
        reqTransInsert.skipAosValidation(true);

        ttsbegin;

        update_recordset reqTransInsert
        setting          Keep = NoYes::Yes
        where            reqTransInsert.PlanVersion             == _reqPlanVersion.RecId
        exists join      reqPOSelect
        where            reqPOSelect.PlanVersion                == _reqPlanVersion.RecId
                            && reqPOSelect.RefId                   == reqTransInsert.RefId
                            && reqPOSelect.ReqPOStatus             == ReqPOStatus::Approved;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqTransKeepInTimeFences</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the requirements profile by setting the <c>Keep</c> field in the <c>ReqTrans</c> table to
    ///    true for the records that are related to the planned orders in freezing time fences.
    /// </summary>
    /// <param name="_reqPlanVersion">
    ///    The version of the master plan.
    /// </param>
    /// <param name="_reqPlanData">
    ///    An instance of a <c>ReqPlanData</c> class that contains master plan parameters.
    /// </param>
    /// <remarks>
    ///    The function skips AOS validation methods on table buffers in order to improve performance of
    ///    set-based operations.
    /// </remarks>
    protected void updateReqTransKeepInTimeFences(ReqPlanVersion _reqPlanVersion, ReqPlanData _reqPlanData)
    {
        new SkipAOSValidationPermission().assert();

        ReqTrans reqTransInsert;
        reqTransInsert.skipDataMethods(true);
        reqTransInsert.skipAosValidation(true);

        ReqPlanSched reqPlanSched;
        select firstonly TimeFenceLocking, TimeFenceLockingFixed
        from             reqPlanSched
        where            reqPlanSched.ReqPlanIdSched == _reqPlanVersion.ReqPlanId;

        ReqPO reqPOSelect;
        if (reqPlanSched.TimeFenceLockingFixed)
        {
            if (reqPlanSched.TimeFenceLocking)
            {
                ttsbegin;

                update_recordset reqTransInsert
                setting          Keep = NoYes::Yes
                where            reqTransInsert.PlanVersion         == _reqPlanVersion.RecId
                exists join      reqPOSelect
                where            reqPOSelect.PlanVersion            == _reqPlanVersion.RecId
                                 && reqPOSelect.RefId               == reqTransInsert.RefId
                                 && reqPOSelect.ReqDate             >= _reqPlanData.todaysdate()
                                 && reqPOSelect.ReqDate             <  _reqPlanData.todaysdate() + reqPlanSched.TimeFenceLocking;

                ttscommit;
            }
        }
        else
        {
            ReqTrans reqTransSelect;

            while select ItemId, CovInventDimId
            from         reqTransSelect
            group by     ItemId, CovInventDimId
            where        reqTransSelect.PlanVersion            == _reqPlanVersion.RecId
            {
                TimeFenceLocking lockingTimeFence = _reqPlanData.newReqSetupDim(
                    _reqPlanData.newReqSetup(reqTransSelect.ItemId),
                    reqTransSelect.CovInventDimId).timeFenceLocking();

                if (lockingTimeFence)
                {
                    ttsbegin;

                    update_recordset reqTransInsert
                    setting          Keep = NoYes::Yes
                    where            reqTransInsert.PlanVersion             == _reqPlanVersion.RecId
                    exists join      reqPOSelect
                    where            reqPOSelect.PlanVersion                == _reqPlanVersion.RecId
									 && reqPOSelect.ItemId                  == reqTransSelect.ItemId
                                     && reqPOSelect.CovInventDimId          == reqTransSelect.CovInventDimId
                                     && reqPOSelect.RefId                   == reqTransInsert.RefId
                                     && reqPOSelect.ReqDate                 >= _reqPlanData.todaysdate()
                                     && reqPOSelect.ReqDate                 <  _reqPlanData.todaysdate() + lockingTimeFence;

                    ttscommit;
                }
                // if (lockingTimeFence)
            }
            // while select ItemId, CovInventDimId
        }
        // else
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    boolean validate(Object _calledFrom = null)
    {
        ReqPlan fromReqPlan;
        ReqPlan toReqPlan;

        if (fromReqPlanId == toReqPlanId)
            return checkFailed("@SYS70668");

        fromReqPlan = ReqPlan::findReqPlanId(this.parmFromReqPlanId());

        if (! fromReqPlan.RecId)
            return checkFailed(strFmt("@SYS25328",this.parmFromReqPlanId()));

        toReqPlan = ReqPlan::findReqPlanId(this.parmToReqPlanId());

        if (! toReqPlan.RecId)
            return checkFailed(strFmt("@SYS25328",this.parmToReqPlanId()));

        if (fromReqPlan.PlanType != toReqPlan.PlanType)
            return checkFailed("@SYS70669");

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipCopyLog</Name>
				<Source><![CDATA[
    public boolean parmSkipCopyLog(boolean _skipCopyLog = skipCopyLog)
    {
        skipCopyLog = _skipCopyLog;
        return skipCopyLog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static ReqPlanCopy construct()
    {
        return new ReqPlanCopy();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static ClassDescription description()
    {
        return "@SYS70661";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
    {
        ReqPlanCopy reqPlanCopy;

        reqPlanCopy = ReqPlanCopy::construct();

        if (!reqPlanCopy.prompt())
            return;

        reqPlanCopy.runOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromToReqPlanId</Name>
				<Source><![CDATA[
    static ReqPlanCopy newFromToReqPlanId(
        ReqPlanId       _fromReqPlanId,
        ReqPlanId       _toReqPlanId,
        ReqBackgroundJobService _backgroundJobService = ReqBackgroundJobService::newBatchHeader(),
        ReqPlanManager  _reqPlanManager = ReqPlanManager::construct())
    {
        ReqPlanCopy  reqPlanCopy = ReqPlanCopy::construct();

        reqPlanCopy.parmFromReqPlanId(_fromReqPlanId);
        reqPlanCopy.parmToReqPlanId(_toReqPlanId);
        reqPlanCopy.setReqBackgroundJobService(_backgroundJobService);
        reqPlanCopy.setReqPlanManager(_reqPlanManager);

        return reqPlanCopy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyReqTransCovKeep</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copies the preserved requirements coverage from the source master plan version
    ///     to the target master plan version.
    /// </summary>
    /// <param name="_reqPlanVersionFrom">
    ///     The version of the source master plan.
    /// </param>
    /// <param name="_reqPlanVersionTo">
    ///     The version of the target master plan.
    /// </param>
    protected void copyReqTransCovKeep(ReqPlanVersion _reqPlanVersionFrom, ReqPlanVersion _reqPlanVersionTo)
    {
        ReqPlanCopyReqTransCovKeep reqPlanCopyReqTransCovKeep = ReqPlanCopyReqTransCovKeep::newFromReqPlanVersions(_reqPlanVersionFrom, _reqPlanVersionTo);
        ttsbegin;
        
        // Copy ReqTransCov of kept ReqTrans records
        reqPlanCopyReqTransCovKeep.execute();

        // Update ReqTransCov.issueRecId to match 'to' plan version's recIds
        // Note: Some ReqTransCov records will be left with IssueRecId from the last plan version,
        // because not all issues has been copied from the 'from' plan.
        ReqTransCov reqTransCovInsert;
        reqTransCovInsert.skipDataMethods(true);
        ReqTrans reqTransIssue;

        update_recordset reqTransCovInsert
        setting          issueRecId                     =  reqTransIssue.RecId
        where            reqTransCovInsert.PlanVersion  == _reqPlanVersionTo.RecId
        join             reqTransIssue
        where            reqTransIssue.PlanVersion      == _reqPlanVersionTo.RecId
            &&           reqTransIssue.LastPlanRecId    == reqTransCovInsert.IssueRecId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>