<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventMov_Sales</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

/// <summary>
/// The <c>InventMov_Sales</c> class is used as a data carrier, together with the <c>inventUpdate</c>
/// class, when the inventory is updated with sales line transactions.
/// </summary>
/// <remarks>
/// This class is used to create a sales order line or to change the buffer.
/// </remarks>
[InventMovementFactoryAttribute(tableStr(SalesLine))]
class InventMov_Sales extends InventMovement
{
    SalesLine               salesOrderLine;
    SalesTable              salesTable;

    LedgerDimensionDefaultAccount   cacheAccountPhysicalRevenue;
    LedgerDimensionDefaultAccount   cacheAccountPhysicalRevenueOffset;

    LedgerDimensionDefaultAccount   cacheAccountPhysicalTax;

    boolean                 physicalTaxCalculated;
    AmountMST               physicalSumTaxMst;

    LedgerDimensionDefaultAccount   accountOperations;
    LedgerPostingType       postingOperations;

    UnknownNoYes            canCommittedCostBeReversed;

    UnknownNoYes            isRetailSale;

    private InventTransChildRefId whsPostingChildRef;

    boolean isFinTagConfigurationSetForCurrent = FinTagConfiguration::isFinTagConfigurationSet(curExt());

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmWHSPostingChildRef</Name>
				<Source><![CDATA[
    internal InventTransChildRefId parmWHSPostingChildRef(InventTransChildRefId _whsPostingChildRef = whsPostingChildRef)
    {
        whsPostingChildRef = _whsPostingChildRef;

        return whsPostingChildRef;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transChildRefId</Name>
				<Source><![CDATA[
    public InventTransChildRefId transChildRefId()
    {
        if (whsPostingChildRef)
        {
            return whsPostingChildRef;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transChildType</Name>
				<Source><![CDATA[
    public InventTransChildType transChildType()
    {
        if (whsPostingChildRef)
        {
            return InventTransChildType::SalesWHSPosting;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertChildBuffer</Name>
				<Source><![CDATA[
    public InventTransChildRefId insertChildBuffer(
        InventDimId     _inventDimId,
        InventQty       _qtyNow,
        UnitQty         _qtyNowUnit,
        boolean         _splitMovement,
        Object          _updateClass = null
        , PdsCWInventQty  _cwQty = 0
        )
    {
        if (whsPostingChildRef)
        {
            if (_splitMovement)
            {
                throw error(error::wrongUseOfFunction(funcName()));
            }

            return whsPostingChildRef;
        }

        return super(_inventDimId, _qtyNow, _qtyNowUnit, _splitMovement, _updateClass, _cwQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLinkToRegisteredReturns</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the movement allows returns to be linked to registered transactions.
    /// </summary>
    /// <returns>true if the movement allow returns to be linked to registered transactions; otherwise, false.</returns>
    public boolean canLinkToRegisteredReturns()
    {
        return this.salesTable().isRetailCashAndCarrySales();
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountBalanceSheet</Name>
				<Source><![CDATA[
    [Replaceable]
    public LedgerDimensionDefaultAccount accountBalanceSheet()
    {
        if (! cacheAccountBalanceSheet)
        {
            cacheAccountBalanceSheet = salesOrderLine.accountIssueLedgerDimension(this.inventTable());
        }

        return cacheAccountBalanceSheet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAutoReserveOnorderChangeInventDim</Name>
				<Source><![CDATA[
    public boolean canAutoReserveOnorderChangeInventDim()
    {
        return this.canBeReserved() && this.mustBeAutoReserved();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateInventTransFields</Name>
				<Source><![CDATA[
    public boolean mustUpdateInventTransFields(InventMovement _movement_orig)
    {
        boolean ret = super(_movement_orig);
        if (!ret
            && SalesLineCTPDeliveryDateControlRecalculateFeature::instance().isEnabled()
            && SalesParameters::find().DeliveryDateCTPRecalculateOnUpdate)
        {
            return (salesOrderLine.hasCTPDeliverySalesLineNoRequirementTransactions());
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a posting account for the current sales order line.
    /// </summary>
    /// <param name="_inventAccountType">
    ///    The posting account type.
    /// </param>
    /// <returns>
    ///    The posting account number for the account type for the current sales order line.
    /// </returns>
    protected LedgerDimensionDefaultAccount accountItem(InventAccountType _inventAccountType)
    {
        // <GEERU>
        if (this.parmCompanyCountryRegion().isCountryRegionRU())
        {
            return InventPosting::accountItemLedgerDimensionFromParameters(
                InventPostingAccountItemLedgerDimensionParameters::newFromSalesLine(
                    salesOrderLine,
                    _inventAccountType,
                    this.itemGroupId(),
                    this.inventdim()));
        }
        // </GEERU>
        return InventPosting::accountItemLedgerDimensionFromParameters(
            InventPostingAccountItemLedgerDimensionParameters::newFromSalesLine(
                salesOrderLine,
                _inventAccountType,
                this.itemGroupId()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountItemExtendParm_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a posting account for the current sales order line with site.
    /// </summary>
    /// <param name="_inventAccountType">
    /// The posting account type.
    /// </param>
    /// <returns>
    /// The posting account number for the account type for the current sales order line.
    /// </returns>
    protected LedgerDimensionDefaultAccount accountItemExtendParm_CN(InventAccountType _inventAccountType)
    {
        return InventPosting::accountItemExtendParmFromParameter_CN(
            InventPostingAccountItemLedgerDimensionParameters::newFromSalesLine(
                salesOrderLine,
                _inventAccountType,
                this.inventTable().itemGroupId(),
                null,
                InventPostingExtendParm_CN::constructInventDim(this.inventdim()).parmInventSiteId()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountOperations</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountOperations()
    {
        if (! cacheAccountOperations)
        {
            if (accountOperations)
            {
                cacheAccountOperations = accountOperations;
            }
            else
            {
                // <GEEU>
                cacheAccountOperations = goodsInRoute ?
                                         salesOrderLine.accountGoodsInRouteOffset_RU(this.inventTable()) :
                                         salesOrderLine.accountConsumptionLedgerDimension(this.inventTable());
                // </GEEU>
            }
        }

        return cacheAccountOperations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountPhysical</Name>
				<Source><![CDATA[
    [Replaceable]
    public LedgerDimensionDefaultAccount accountPhysical()
    {
        if (! cacheAccountPhysical)
        {
            // <GCN>
            if (InventPostingExtendParm_CN::checkExtendParmEnabled())
            {
                cacheAccountPhysical = this.accountItemExtendParm_CN(InventAccountType::SalesPackingSlip);
            }
            else
            {
                // </GCN>
                cacheAccountPhysical = this.accountItem(InventAccountType::SalesPackingSlip);
                // <GCN>
            }
            // </GCN>
        }

        return cacheAccountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountPhysicalRevenue</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountPhysicalRevenue()
    {
        if (! cacheAccountPhysicalRevenue)
        {
            cacheAccountPhysicalRevenue = this.accountItem(InventAccountType::SalesPckSlipRevenue);
        }

        return cacheAccountPhysicalRevenue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountPhysicalRevenueOffset</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountPhysicalRevenueOffset()
    {
        if (! cacheAccountPhysicalRevenueOffset)
        {
            cacheAccountPhysicalRevenueOffset = this.accountItem(InventAccountType::SalesPckSlipRevenueOffsetAccount);
        }

        return cacheAccountPhysicalRevenueOffset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountPhysicalTax</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountPhysicalTax()
    {
        if (! cacheAccountPhysicalTax)
        {
            cacheAccountPhysicalTax = this.accountItem(InventAccountType::SalesPackingSlipTax);
        }
        return cacheAccountPhysicalTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>activityNumber</Name>
				<Source><![CDATA[
    public ProjActivityNumber activityNumber()
    {
        return salesOrderLine.ActivityNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainFinancialUnit</Name>
				<Source><![CDATA[
    public void addRemainFinancialUnit(
        UnitQty     _qtyUnit,
        InventQty   _qty)
    {
        salesOrderLine.RemainInventFinancial += -_qty;

        if (salesOrderLine.RemainInventFinancial)
        {
            salesOrderLine.RemainSalesFinancial += -_qtyUnit;
        }
        else
        {
            salesOrderLine.RemainSalesFinancial = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainPhysical</Name>
				<Source><![CDATA[
    public void  addRemainPhysical(InventQty  _inventQty)
    {
        // RemainInventPhysical should only be updated for inventoried items
        if (salesOrderLine.isStocked())
        {
            salesOrderLine.RemainInventPhysical += -_inventQty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainPhysicalUnit</Name>
				<Source><![CDATA[
    public void  addRemainPhysicalUnit(UnitQty _qtyUnit)
    {
        salesOrderLine.RemainSalesPhysical += -_qtyUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchDispReservationBlockedFieldId</Name>
				<Source><![CDATA[
    public FieldId batchDispReservationBlockedFieldId()
    {
        return fieldNum(PdsDispositionMaster, PdsSalesBlockReserve);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeAutoRepAsFinished</Name>
				<Source><![CDATA[
    public boolean canBeAutoRepAsFinished()
    {
        boolean ret = !salesOrderLine.Scrap && super();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeOnAllInventLocations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the inventory transaction can be on all invent locations.
    /// </summary>
    /// <returns>
    /// true if the inventory transaction can be on all invent locations; otherwise, false.
    /// </returns>
    public boolean canBeOnAllInventLocations()
    {
        return this.isRetailSalesOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeOnAllInventSites</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the inventory transaction can be on all invent sites.
    /// </summary>
    /// <returns>
    /// true if the inventory transaction can be on all invent sites; otherwise, false.
    /// </returns>
    public boolean canBeOnAllInventSites()
    {
        return this.isRetailSalesOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeUpdatedRegistered</Name>
				<Source><![CDATA[
    public boolean canBeUpdatedRegistered()
    {
        if (this.salesTable().InterCompanyDirectDelivery
        &&  salesOrderLine.interCompanySalesLineExist())
        {
            return false;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canChangeStorageConsistentDimWhenFinUpd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the consistent storage dimensions may be changed when inventory transactions are
    ///    financially updated.
    /// </summary>
    /// <returns>
    ///    true if the consistent storage dimensions may be changed; otherwise, false.
    /// </returns>
    protected boolean canChangeStorageConsistentDimWhenFinUpd()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCommittedCostBeReversed</Name>
				<Source><![CDATA[
    public boolean canCommittedCostBeReversed()
    {
        if (canCommittedCostBeReversed)
        {
            return (canCommittedCostBeReversed == UnknownNoYes::Yes ? true : false);
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHaveReservedWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the movement type can have WHS work created that takes over reserving the lower levels of the hierarchy.
    /// </summary>
    /// <returns>
    /// This method return true for this type of movement if the movement item is WHS enabled.
    /// </returns>
    public boolean canHaveReservedWork()
    {
        return this.isItemWHSEnabled() && !WHSReservationHierarchyInventDimUtil::isLocationOrBelowSpecified(this.inventTable(), this.inventdim());
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInventTransBeFinancialUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies whether an inventory transaction can be financially updated.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The inventory transaction to verify.
    /// </param>
    /// <returns>
    ///    true if the inventory transaction can be financially updated; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method is used to determine whether an inventory transaction can be financially updated.For
    ///    item requirements, the inventory transaction can be financially updated if it references an ended
    ///    completed production order with a project posting method of Consumed/Linked to order.
    /// </remarks>
    public boolean canInventTransBeFinancialUpdated(InventTrans _inventTrans)
    {
        boolean canUpdate = this.canUpdateRefProdTable(_inventTrans);

        return canUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInventTransBePhysicalUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies whether an inventory transaction can be physically updated.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The inventory transaction to verify.
    /// </param>
    /// <returns>
    ///    true if the inventory transaction can be physically updated; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method is used to determine whether an inventory transaction can be physically updated.For
    ///    item requirements, the inventory transaction can be physically updated if it references an ended
    ///    production order with a project posting method of Consumed/Linked to order.
    /// </remarks>
    public boolean canInventTransBePhysicalUpdated(InventTrans _inventTrans)
    {
        boolean canUpdate = this.canUpdateRefProdTable(_inventTrans);

        return canUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateInventStatusBlocking</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the movement can update inventory status blocking transactions
    /// </summary>
    /// <returns>
    ///     Returns true if the order line is a return; otherwise, false.
    /// </returns>
    public boolean canUpdateInventStatusBlocking()
    {
        boolean ret = this.transQty() > 0 ? true : false;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateRefProdTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies whether an inventory transaction can be physically or financially updated.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The inventory transaction to verify.
    /// </param>
    /// <returns>
    ///    true if the inventory transaction can be physically or financially updated; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method is used to determine whether an inventory transaction can be physically or financially
    ///    updated.For an item requirement inventory transaction that references a production order that has a
    ///    project posting method of Consumed or Linked to order, the production order should be ended in
    ///    order to physically or financially update the inventory transaction.
    /// </remarks>
    private boolean canUpdateRefProdTable(InventTrans _inventTrans)
    {
        boolean                     canUpdate = true;
        InventTransOrigin           inventTransOriginRef;
        InventTransOriginProdTable  inventTransOriginProdTable;
        ProdTable                   prodTable;

        if (salesOrderLine.SalesType == SalesType::ItemReq && _inventTrans.MarkingRefInventTransOrigin)
        {
            select firstonly RemainInventPhysical from prodTable
                    exists join inventTransOriginProdTable
                            where prodTable.DataAreaId == inventTransOriginProdTable.ProdOrderDataAreaId &&
                                  prodTable.ProdId == inventTransOriginProdTable.ProdOrderId &&
                                  prodTable.ProjPostingType == ProjProdPostingType::ConsumedMethod &&
                                  prodTable.ProjLinkedToOrder == NoYes::Yes &&
                                  inventTransOriginProdTable.InventTransOrigin == _inventTrans.MarkingRefInventTransOrigin;

            if (ProdRouteProjAllowFinUpdateFlight::instance().isEnabled() && prodTable)
            {
                if (_inventTrans.StatusIssue != StatusIssue::Deducted)
                {
                    canUpdate = salesorderline.RemainInventPhysical + _inventTrans.Qty >= prodTable.RemainInventPhysical ? true : false;
                }
            }
            else
            {
                select firstonly RecId from inventTransOriginRef
                    where inventTransOriginRef.RecId == _inventTrans.MarkingRefInventTransOrigin &&
                            inventTransOriginRef.ReferenceCategory == InventTransType::Production
                    exists join inventTransOriginProdTable
                        where inventTransOriginProdTable.InventTransOrigin == inventTransOriginRef.RecId
                    exists join prodTable
                        where prodTable.DataAreaId == inventTransOriginProdTable.ProdOrderDataAreaId &&
                              prodTable.ProdId == inventTransOriginProdTable.ProdOrderId && 
                              prodTable.ProjPostingType == ProjProdPostingType::ConsumedMethod && 
                              prodTable.ProjLinkedToOrder == NoYes::Yes &&
                              prodTable.ProdStatus != ProdStatus::Completed && 
                              prodTable.ProdStatus != ProdStatus::ReportedFinished;

                canUpdate = inventTransOriginRef.RecId ? false : true;
            }
        }
        return canUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowManualMarking</Name>
				<Source><![CDATA[
    public boolean checkAllowManualMarking()
    {
        boolean canUpdate = super();

        if (canUpdate)
        {
            if (salesOrderLine.Reservation == ItemReservation::Explosion)
            {
                return checkFailed("@SYS86901");
            }
        }

        return canUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimFieldsValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the inventory dimension has valid values.
    /// </summary>
    /// <param name = "_inventDim">The <c>InventDim</c> record.</param>
    /// <param name = "_inventDim_orig">The orig <c>InventDim</c> record.</param>
    /// <param name = "_skipProductDimensions">A boolean determining if product dimension should be checked.</param>
    /// <returns>true if the dimensions check passed; otherwise, false.</returns>
    public boolean checkDimFieldsValid(InventDim _inventDim, InventDim _inventDim_orig, boolean _skipProductDimensions = false)
    {
        return super(_inventDim, _inventDim_orig, !SalesLineCreationPolicy::newFromSalesOrderCreationMethod(salesOrderLine.SalesSalesOrderCreationMethod).mustPerformIndividualProductDimensionCheck());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimInventOwnerId_RU</Name>
				<Source><![CDATA[
    public boolean checkDimInventOwnerId_RU(InventDim _inventDim, boolean _showError = true)
    {
        boolean        ret = super(_inventDim, _showError);

        if (this.inventDimGroupSetup().isDimensionActive(fieldNum(InventDim, InventOwnerId_RU)) &&
            _inventDim.InventOwnerId_RU &&
            _inventDim.inventProfile_RU().InventOwnerIdCheckSalesOrder)
        {
            salesTable = salesOrderLine.salesTable();
            InventOwner_RU inventOwner = InventOwner_RU::findCustAccount(salesTable.CustAccount, salesTable.salesTable_RU().AgreementHeaderExt_RU);
            if (inventOwner && inventOwner.InventOwnerId != _inventDim.InventOwnerId_RU)
            {
                ret = _showError ? checkFailed(strFmt("@GLS115707", fieldId2pname(tableNum(InventDim), fieldNum(InventDim, InventOwnerId_RU)))) : false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimPhysical</Name>
				<Source><![CDATA[
    boolean checkDimPhysical(
        InventQty   _qty,
        InventDim   _inventDim,
        boolean     _finalCheck,
        boolean     _showError = true
        )
    {
        boolean ok = super(_qty, _inventDim, _finalCheck, _showError);

        if (ok && _finalCheck && this.inventDimGroupSetup().isDimensionActive(fieldNum(InventDim, InventOwnerId_RU)))
        {
            SalesTable salesTableLoc = salesOrderLine.salesTable();

            if (_inventDim.inventProfile_RU().InventOwnerIdCheckSalesOrder &&
                ! InventOwner_RU::checkSalesOrder(_inventDim.InventOwnerId_RU, salesTableLoc))
            {
                ok = checkFailed(strFmt("@GLS115659",
                                        _inventDim.InventOwnerId_RU,
                                        salesTableLoc.CustAccount,
                                        AgreementHeaderExt_RU::find(salesTableLoc.salesTable_RU().AgreementHeaderExt_RU).AgreementId,
                                        fieldId2pname(tableNum(InventDim), fieldNum(InventDim, InventOwnerId_RU))));
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLocationBlocking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether location inventory dimension if locked for certain operations.
    /// </summary>
    /// <param name="_inventDimLocation">
    /// The <c>InventDim</c> record.
    /// </param>
    /// <returns>
    /// True if location is not locked; otherwise, false.
    /// </returns>
    protected boolean checkLocationBlocking(InventDim _inventDimLocation = null)
    {
        boolean             ret = true;
        InventTrans         inventTrans;

        if (prmisDefault(_inventDimLocation))
        {
            InventDimParm       inventDimParmActive;
            this.inventDimGroupSetup().inventDimParmActive(inventDimParmActive);
            if (!inventDimParmActive.WMSLocationIdFlag)
            {
                return true;
            }

            WMSLocation wmsLocation;
            InventDim   inventDimThis;

            select firstonly wmsLocation
                where (wmsLocation.InputBlockingCauseId  && this.transQty() > 0)
                    ||(wmsLocation.OutputBlockingCauseId && this.transQty() < 0)
                exists join inventDimThis
                    where inventDimThis.InventLocationId    == wmsLocation.InventLocationId
                        && inventDimThis.wMSLocationId       == wmsLocation.wMSLocationId
                exists join inventTrans
                    where inventTrans.inventDimId       == inventDimThis.inventDimId
                        && inventTrans.InventTransOrigin == this.inventTransOriginId();

            ret = this.checkSingleWMSLocationBlocking(wmsLocation, this.transQty());
        }
        else
        {
            ret = super(_inventDimLocation);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onCheckSerialNumFailed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handle any custom logic when serial number check fails.
    /// </summary>
    /// <param name = "_inventDim">The inventory dimension.</param>
    /// <returns>true if final check result should be failed; otherwise false.</returns>
    protected boolean onCheckSerialNumFailed(InventDim _inventDim)
    {
        boolean isFailed = super(_inventDim);

        // The intention here is to generate any warnings for orders from retail statements and return false to ignore failing further
        if (this.isRetailStatementOrder())
        {
            isFailed = checkFailed(strFmt("@SCM:SerialNumberValidationIgnored", _inventDim.InventSerialId));
            CommerceHQEventSource eventSource = CommerceHQEventSource::Log;
            eventSource .EventWriteInventoryPostingSerialNumberReturnValidationIgnored(_inventDim.RecId);
        }
        
        return isFailed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onCheckSerialNumQuantityFailed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handle any custom logic when serial number quantity check fails.
    /// </summary>
    /// <param name = "_inventDim">The inventory dimension.</param>
    /// <returns>true if final check result should be failed; otherwise false.</returns>
    protected boolean onCheckSerialNumQuantityFailed(InventDim _inventDim)
    {
        boolean isFailed = super(_inventDim);

        // The intention here is to generate any warnings for orders from retail statements and return false to ignore failing further
        if (this.isRetailStatementOrder())
        {
            isFailed = checkFailed(strFmt("@SYS68712", _inventDim.InventSerialId));
            checkFailed(strFmt("@SCM:SerialNumberQuantityValidationIgnored", _inventDim.InventSerialId));
            CommerceHQEventSource eventSource = CommerceHQEventSource::Log;
            eventSource.EventWriteInventoryPostingSerialNumberQtyValidationIgnored(_inventDim.RecId);
        }

        return isFailed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateEstimated</Name>
				<Source><![CDATA[
    public boolean checkUpdateEstimated(
        InventUpd_Estimated _updateNow,
        InventMovement      _this_Orig)
    {
        if (_this_Orig && abs(this.transQty())  <  abs(_this_Orig.transQty()) && this.transQty() * _this_Orig.transQty() >= 0 )
        {
            if (_this_Orig.remainPhysicalUnit() == 0 && _this_Orig.remainFinancialUnit() == 0)
            {
                return checkFailed("@SYS25508");
            }
        }

        // For inventoried lines the physical and financial quantities should match.
        if (!salesOrderLine.isStocked())
        {
            return true;
        }

        return super(_updateNow, _this_Orig);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdatePhysical</Name>
				<Source><![CDATA[
    public boolean checkUpdatePhysical(InventUpd_Physical _updateNow)
    {
        boolean ok = true;

        // Check for hold
        if (this.salesTable().MCROrderStopped == NoYes::Yes)
        {
            ok = checkFailed("@MCR10322");
        }

        if (this.transQtyUnit() == 0)
        {
            ok = checkFailed("@SYS12170");
        }

        if (salesOrderLine.Complete && !_updateNow.parmUpdateForSubParmLine() && abs(this.transQtyUnit()) != abs(_updateNow.parmPhysicalUnit()))
        {
            ok = checkFailed("@SYS25384");
        }

        ok = salesOrderLine.checkUpdatePhysical()   && ok;
        ok = super(_updateNow)                      && ok;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPickComplete</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Check if pick is complete for all quantities.
    /// </summary>
    /// <param name="_pickedQty">
    ///  The picked quantities.
    /// </param>
    /// <returns>
    ///  true if complete flag is false or all quantities have been picked; else false.
    /// </returns>
    public boolean checkPickComplete(InventQty _pickedQty)
    {
        boolean ret = true;

        if (salesOrderLine.Complete && abs(this.transQty()) != abs(_pickedQty))
        {
            ret = checkFailed("@SYS25384");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdatePicked</Name>
				<Source><![CDATA[
    public boolean checkUpdatePicked(InventUpd_Picked _updateNow)
    {
        boolean ok = true;

        // Check for hold code
        if (this.salesTable().MCROrderStopped == NoYes::Yes)
        {
            ok = checkFailed("@MCR10322");
        }

        if (this.transQtyUnit() == 0)
        {
            ok = checkFailed("@SYS12170");
        }

        ok = salesOrderLine.checkUpdatePicked() && ok;
        ok = super(_updateNow)                  && ok;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWHSLoadLineInventTransConsistency</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the <c>WHSLoadLine</c> table related to the source line is in sync with the inventory transactions.
    /// </summary>
    /// <param name="_onlyCheckWork">
    /// Determines if we only need to check for conflict with work created quantity instead of doing full check; optional.
    /// </param>
    public void checkWHSLoadLineInventTransConsistency(boolean _onlyCheckWork = false)
    {
        WHSLoadLineInventTransValidator whsLoadLineInventTransValidator = WHSLoadLineInventTransValidator::newFromParameters(this.transId(),this.inventTransOriginId(),WHSLoadLineDataBuilder::construct(),WHSLoadLineUpdater::newFromTransId(this.transId()));
        whsLoadLineInventTransValidator.parmOnlyCheckWork(_onlyCheckWork);
        whsLoadLineInventTransValidator.validateLoadLineDimensionConsistency();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHaveOutboundLoadLine</Name>
				<Source><![CDATA[
    public boolean canHaveOutboundLoadLine()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctionSwapOnItem_RU</Name>
				<Source><![CDATA[
    protected boolean correctionSwapOnItem_RU(Amount _amount)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOriginOwnerRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the relationship between the inventory transactions originator and the owner.
    /// </summary>
    public void createOriginOwnerRelationship()
    {
        InventTransOriginId originId = this.inventTransOriginId();

        if (originId && salesOrderLine)
        {
            InventTransOriginSalesLine::writeOriginOwnerRelationship(salesOrderLine.DataAreaId, salesOrderLine.InventTransId, originId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendAc</Name>
				<Source><![CDATA[
    public CustVendAC custVendAc()
    {
        return salesOrderLine.CustAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteOriginOwnerRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the relationship between the inventory transactions originator and the owner that
    ///    corresponds.
    /// </summary>
    public void deleteOriginOwnerRelationship()
    {
        if (salesOrderLine)
        {
            InventTransOriginSalesLine::deleteOwnerRelationship(salesOrderLine.DataAreaId, salesOrderLine.InventTransId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryPostalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Identifies the postal delivery address of the inventory movement.
    /// </summary>
    /// <returns>
    ///    An ID of a <c>LogisticsPostalAddress</c> record; otherwise, 0.
    /// </returns>
    /// <remarks>
    ///    This method is only used for shipping deliveries such as sales orders and transfer orders.
    /// </remarks>
    protected LogisticsPostalAddressRecId deliveryPostalAddress()
    {
        return salesOrderLine.DeliveryPostalAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dlvMode</Name>
				<Source><![CDATA[
    protected DlvModeId dlvMode()
    {
        return salesOrderLine.DlvMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dlvTerm</Name>
				<Source><![CDATA[
    protected DlvTermId dlvTerm()
    {
        return salesOrderLine.salesTable().DlvTerm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalRevenue</Name>
				<Source><![CDATA[
    protected AmountMSTPhysicalRevenue estimatedPhysicalRevenue(InventTrans _inventTrans)
    {
        if (salesOrderLine.QtyOrdered != 0)
        {
            return CurrencyExchangeHelper::amount(_inventTrans.Qty * salesOrderLine.lineAmountMSTExclTax(_inventTrans.DatePhysical) / salesOrderLine.QtyOrdered);
        }

        return super(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalTax</Name>
				<Source><![CDATA[
    protected AmountMST estimatedPhysicalTax(InventTrans _inventTrans)
    {
        AmountCur   amountCur = 0;
        AmountMST   amountMST = 0;

        if (!this.mustBeBookedPhysicalTax())
        {
            return 0;
        }

        if (!salesOrderLine.QtyOrdered)
        {
            return 0;
        }

        if (!physicalTaxCalculated)
        {
            if (this.salesTable().InclTax)
            {
                amountCur = salesOrderLine.LineAmount - salesOrderLine.lineAmountExclTax(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
            }
            else
            {
                amountCur = Tax::calcTaxAmount(salesOrderLine.TaxGroup,
                                               salesOrderLine.TaxItemGroup,
                                               DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                               salesOrderLine.CurrencyCode,
                                               salesOrderLine.LineAmount,
                                               this.salesTable().taxModuleType(),
                                               salesOrderLine.SalesQty,
                                               salesOrderLine.SalesUnit,
                                               salesOrderLine.ItemId,
                                               TaxDirection::OutgoingTax);
            }

            if (amountCur)
            {
                amountMST = CurrencyExchangeHelper::mstAmount(amountCur, salesOrderLine.CurrencyCode);
            }

            physicalSumTaxMst       = amountMST;
            physicalTaxCalculated   = true;
        }

        return - CurrencyExchangeHelper::amount(physicalSumTaxMst * -_inventTrans.Qty / salesOrderLine.QtyOrdered);
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the estimated physical value for an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// The <c>inventTrans</c> record for which to get the estimated physical value.
    /// </param>
    /// <param name="_inventOnhand">
    /// The <c>InventOnHand</c> object.
    /// </param>
    /// <param name="_updateNow">
    /// The <c>InventUpdate</c> object.
    /// </param>
    /// <returns>
    /// The estimated physical value for the inventory transaction.
    /// </returns>
    protected CostAmount estimatedPhysicalValue(
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand,
        InventUpdate    _updateNow)
    {
        CostAmount  returnValue;
        InventQty   returnQty;

        if (this.inventModelGroup().inventModelType().stdCostBased())
        {
            return InventModelType_StdCost::estimatedPhysicalValueStdCost(this, _inventTrans);
        }

        if (_inventTrans.Qty < 0)
        {
            return super(_inventTrans, _inventOnhand, _updateNow);
        }

        if (_inventTrans.ReturnInventTransOrigin)
        {
            [returnQty,returnValue] = InventTransOrigin::calcReturnCostValue(_inventTrans.ReturnInventTransOrigin, _inventTrans.InventTransOrigin);
            if (!returnQty)
            {
                throw error("@SYS53016");
            }
            return CurrencyExchangeHelper::amount(_inventTrans.Qty * returnValue / returnQty);
        }

        return CurrencyExchangeHelper::amount(salesOrderLine.CostPrice * _inventTrans.Qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalValueSecCur_RU</Name>
				<Source><![CDATA[
    protected CostAmountSecCur_RU estimatedPhysicalValueSecCur_RU(
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand,
        InventUpdate    _updateNow)
    {
        CostAmount          returnValueMST;
        CostAmountSecCur_RU returnValue;
        InventQty           returnQty;

        if (this.inventModelGroup().inventModelTypeSecCur_RU().stdCostBased())
        {
            return InventModelType_StdCost::estimatedPhysicalValueStdCostSecCur_RU(this, _inventTrans);
        }

        if (_inventTrans.Qty >= 0 && _inventTrans.ReturnInventTransOrigin)
        {
            [ returnQty,
              returnValueMST,
              returnValue ] = InventTransOrigin::calcReturnCostValue(_inventTrans.ReturnInventTransOrigin, _inventTrans.InventTransOrigin);

            if (! returnQty)
            {
                throw error("@SYS53016");
            }

            return CurrencyExchangeHelper::amount(_inventTrans.Qty * returnValue / returnQty, CompanyInfoHelper::secondaryCurrency_RU());
        }

        return super(_inventTrans, _inventOnhand, _updateNow);
    }

]]></Source>
			</Method>
			<Method>
				<Name>freightSlipType</Name>
				<Source><![CDATA[
    protected FreightSlipType freightSlipType()
    {
        return salesOrderLine.salesTable().FreightSlipType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>freightZone</Name>
				<Source><![CDATA[
    protected FreightZoneId freightZone()
    {
        return salesOrderLine.salesTable().FreightZone;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExpiryCheckDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the date to check against for the expiry date.
    /// </summary>
    /// <returns>
    /// The date to check against for the expiry date.
    /// </returns>
    public TransDate getExpiryCheckDate()
    {
        return salesOrderLine.getExpiryCheckDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDimForIssueTransFromReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the <c>InventDim</c> that should be put on the issue transaction during a receipt which updates the issue transaction for WHS items.
    /// </summary>
    /// <param name="_inventDimIssue">
    /// The original issue transaction <c>InventDim</c>
    /// </param>
    /// <param name="_inventDimReceipt">
    /// The receipt transaction <c>InventDim</c>
    /// </param>
    /// <returns>
    /// The new issue transaction <c>InventDim</c>
    /// </returns>
    /// <remarks>
    /// By default the issue transaction will keep it's original dimensions.
    /// </remarks>
    public InventDim getInventDimForIssueTransFromReceipt(InventDim _inventDimIssue, InventDim _inventDimReceipt)
    {
        InventDim retInventDim;

        if ( this.canHaveReservedWork()
          && _inventDimReceipt.InventLocationId
          && _inventDimReceipt.inventLocation().whsEnabled)
        {
            retInventDim = InventDim::find(_inventDimReceipt.InventDimId);
            retInventDim.clearLocationAndBelowDim(this.itemId());
            retInventDim = InventDim::findOrCreate(retInventDim);
        }
        else if (salesOrderLine.DeliveryType == TradeLineDlvType::DropShip)
        {
            retInventDim = _inventDimReceipt;
        }
        else
        {
            retInventDim = _inventDimIssue;
        }

        return retInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasBeenFullyPicked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the inventory movement has been fully picked.
    /// </summary>
    /// <returns>
    ///    true if the inventory movement has been fully picked; otherwise, false.
    /// </returns>
    public boolean hasBeenFullyPicked()
    {
        boolean             result;
        InventQty           transQty = this.transQty();

        if (transQty < 0)
        {
            InventTransIdSum inventTransIdSum = this.transIdSum();
            result = inventTransIdSum.deducted() + inventTransIdSum.picked() <= transQty;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initForAutoReservation</Name>
				<Source><![CDATA[
    public void initForAutoReservation()
    {
        if (#PdsBatchAttribEnabled
            && salesOrderLine.Reservation == ItemReservation::Automatic
            && PdsBatchAttribByItem::existItemIdAny(salesOrderLine.ItemId))
        {
            this.parmPdsBatchAttribAutoRes(salesOrderLine.PdsBatchAttribAutoRes);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransFinancial</Name>
				<Source><![CDATA[
    public void initInventTransFinancial(
        InventTrans         _inventTrans,
        TransDate           _dateFinancial,
        InvoiceId           _invoiceId,
        CurrencyCode        _currencyCode)
    {
        super(_inventTrans, _dateFinancial, _invoiceId, _currencyCode);
        this.setProjAdjustRefId(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransFromBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the <c>InventTrans</c> record with data.
    /// </summary>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> record.
    /// </param>
    /// <param name="_movement_orig">
    /// An instance of the <c>InventMovement</c> class.
    /// </param>
    void initInventTransFromBuffer(InventTrans _inventTrans, InventMovement _movement_orig)
    {
        #ISOCountryRegionCodes

        super(_inventTrans, _movement_orig);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoPL, #isoHU, #isoCZ, #isoLT, #isoLV, #isoEE]))
        {
            _inventTrans.InvoiceId = CustInvoiceTrans::findRecId(buffer.(fieldName2id(buffer.TableId, fieldStr(SalesLine, RefReturnInvoiceTrans_W)))).InvoiceId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransPhysical</Name>
				<Source><![CDATA[
    public void initInventTransPhysical(
        InventTrans     _inventTrans,
        TransDate        _datePhysical,
        PackingSlipId    _packingSlipId)
    {
        super(_inventTrans, _datePhysical, _packingSlipId);
        this.setProjAdjustRefId(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyMarkingAllowed</Name>
				<Source><![CDATA[
    public boolean interCompanyMarkingAllowed()
    {
        boolean ret = TradeInterCompany::markingAllowed(salesOrderLine);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyMovement</Name>
				<Source><![CDATA[
    public boolean interCompanyMovement()
    {
        return salesOrderLine.interCompanySalesLineExist();
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyTransaction</Name>
				<Source><![CDATA[
    public boolean interCompanyTransaction()
    {
        if (salesOrderLine.RecId
        &&  salesOrderLine.InterCompanyInventTransId
        &&  salesOrderLine.salesTable().InterCompanyOrder)
        {
            return true;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimId</Name>
				<Source><![CDATA[
    public InventDimId inventDimId()
    {
        return salesOrderLine.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventItemOrderCheckNotStopped</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the specified item is stopped in the inventory.
    /// </summary>
    /// <returns>
    /// true if the item's don't need to be checked for being stopped or are not stopped; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The super method is overridden to enable for the sales return of items stopped for sales in the
    /// inventory.
    /// </remarks>
    public boolean inventItemOrderCheckNotStopped()
    {
        // Retail cash and carry sales have already happened, so whether the item is stopped is no longer relevant.
        if (salesOrderLine.returnItem() || this.shouldSkipProductNotStoppedCheck())
        {
            return true;
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransOriginId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the ID of the inventory transaction originator that corresponds to the movement.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The new value of the ID of the inventory transaction originator.
    /// </param>
    /// <returns>
    ///    The ID of the inventory transaction originator that corresponds to the movement.
    /// </returns>
    public InventTransOriginId inventTransOriginId(InventTransOriginId _inventTransOriginId = inventTransOriginId)
    {
        if (_inventTransOriginId != inventTransOriginId)
        {
            inventTransOriginId = _inventTransOriginId;
        }
        else
        {
            if (!inventTransOriginId)
            {
                inventTransOriginId = InventTransOriginSalesLine::findInventTransOriginId(salesOrderLine.DataAreaId, salesOrderLine.InventTransId);
            }
        }

        return inventTransOriginId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetailSalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether the current <c>SalesTable</c> record is a Retail sales record.
    /// </summary>
    /// <returns>
    ///     true if the <c>SalesTable</c> record is a Retail sales record; otherwise, false.
    /// </returns>
    public boolean isRetailSalesOrder()
    {
        if (isRetailSale == UnknownNoYes::Unknown)
        {
            isRetailSale = (this.salesTable().isRetailSale() == NoYes::Yes) ? UnknownNoYes::Yes : UnknownNoYes::No;
        }

        return isRetailSale == UnknownNoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailSalesOrderType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the RetailSalesOrderType for the SalesTable.
    /// </summary>
    /// <returns>
    ///     CashAndCarry if a sales order from a cash and carry sales, elseif CustomerOrder if a Retail customer order;
    ///     otherwise, None.
    /// </returns>
    public RetailSalesOrderType getRetailSalesOrderType()
    {
        return this.salesTable().getRetailSalesOrderType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReturned</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether this movement represents a return.
    /// </summary>
    /// <param name="_qty">
    ///    The movement quantity.
    /// </param>
    /// <returns>
    ///    true if the movement represents a return; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Adds special handling for the case when the quantity is zero; otherwise, the super method provides
    ///    the result.
    /// </remarks>
    public boolean isReturned(InventQty _qty)
    {
        if (_qty == 0 && salesOrderLine.SalesType == SalesType::ReturnItem)
        {
            // with zero quantity it isn't clear to the super method whether it is a return or not.
            return true;
        }

        boolean ret = super(_qty);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemDescription</Name>
				<Source><![CDATA[
    public ItemFreeTxt itemDescription()
    {
        return salesOrderLine.itemName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemId</Name>
				<Source><![CDATA[
    public ItemId  itemId()
    {
        return salesOrderLine.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markingRefInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the marked transaction origin.
    /// </summary>
    /// <returns>
    ///    Zero if the whole movement is not marked; otherwise, the ID of the transaction origin.
    /// </returns>
    public InventTransOriginId markingRefInventTransOrigin()
    {
        return InventTransOrigin::findByInventTransId(salesOrderLine.InventRefTransId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSetInventDeliverNow</Name>
				<Source><![CDATA[
    void mcrSetInventDeliverNow(InventQtyAvailReservation  _prevReserve,
                                InventQtyAvailReservation  _CurrReserve = 0,
                                InventQtyAvailReservation  _availToReserve = 0)
    {
        if (salesOrderLine.RecId)
        {
            salesOrderLine.InventDeliverNow -= _prevReserve;
            salesOrderLine.InventDeliverNow += _currReserve;

            // If the following is true, a manual entry was created to override salesdelivernow. We want to
            // retain the manual adjustment.
            if (salesOrderLine.InventDeliverNow  > _availToReserve)
            {
                salesOrderLine.InventDeliverNow = _availToReserve;
            }
        }
        else
        {
            salesOrderLine.InventDeliverNow = _CurrReserve;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSetReservation</Name>
				<Source><![CDATA[
    qty mcrSetReservation()
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;

        if (salesOrderLine.RecId)
        {
            select sum(Qty) from inventTrans
                where inventTrans.StatusIssue == StatusIssue::ReservPhysical
                        && inventTrans.StatusReceipt == StatusReceipt::None
                exists join inventTransOrigin
                where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                        && inventTransOrigin.InventTransId == salesOrderLine.InventTransId;
        }
        qty prevReserve = -inventTrans.qty;
        return prevReserve;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSetSalesDeliverNow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the <c>SalesDeliverNow</c> field of the current <c>SalesLine</c>.
    /// </summary>
    /// <param name="_prevReserve">
    /// The previously reserved quantity.
    /// </param>
    /// <param name="_CurrReserve">
    /// The current reserved quantity after the order.
    /// </param>
    /// <param name="_availToReserve">
    /// The total quantity available for reservation.
    /// </param>
    void mcrSetSalesDeliverNow(InventQtyAvailReservation  _prevReserve,
                                InventQtyAvailReservation  _CurrReserve = 0,
                                InventQtyAvailReservation  _availToReserve = 0)
    {
        if (salesOrderLine.RecId)
        {
            salesOrderLine.SalesDeliverNow -= _prevReserve;
            salesOrderLine.SalesDeliverNow += _currReserve;
            // If the following is true, a manual entry was created to override salesdelivernow. We want to
            // retain the manual adjustment.
            if (salesOrderLine.SalesDeliverNow   > _availToReserve)
            {
                salesOrderLine.SalesDeliverNow = _availToReserve;
            }
        }
        else
        {
            salesOrderLine.SalesDeliverNow = _CurrReserve;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>minAllowedBestBeforeDate</Name>
				<Source><![CDATA[
    public PdsBestBeforeDate minAllowedBestBeforeDate()
    {
        return this.hasBestBeforeDateLimit() ? this.getExpiryCheckDate() + this.sellableDays() + 1 : dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>minAllowedExpiryDate</Name>
				<Source><![CDATA[
    public InventBatchExpDate minAllowedExpiryDate()
    {
        return this.hasExpiryDateLimit() ? this.getExpiryCheckDate() + this.sellableDays() : dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>moduleType</Name>
				<Source><![CDATA[
    protected ModuleInventPurchSales moduleType()
    {
        return ModuleInventPurchSales::Sales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeAutoReserved</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the <c>inventMovement</c> must be auto-reserved.
    /// </summary>
    /// <returns>
    /// true if the <c>inventMovement</c> must be auto-reserved; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is often called together with the <c>canBeReserved</c> method which returns a default
    /// Boolean from the <c>inventType</c> class hierarchy.
    /// </remarks>
    public boolean  mustBeAutoReserved()
    {
        if (!this.inventTable().inventItemType().canBeAutoReserved())
        {
            return false;
        }

        this.initForAutoReservation();
 
        return salesOrderLine.Reservation == ItemReservation::Automatic
            || salesOrderLine.Reservation == ItemReservation::Explosion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedPhysically</Name>
				<Source><![CDATA[
    public boolean  mustBeBookedPhysically()
    {
        if (this.inventModelType().mustAlwaysBeBookedPhysically() || SalesParameters::find().PostPackingSlip)
        {
            return super();
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedPhysicalRevenue</Name>
				<Source><![CDATA[
    protected boolean mustBeBookedPhysicalRevenue()
    {
        return this.inventModelGroup().PostPhysicalRevenue && SalesParameters::find().PostPackingSlip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedPhysicalTax</Name>
				<Source><![CDATA[
    protected boolean mustBeBookedPhysicalTax()
    {
        return InventParameters::find().PostPhysicalTax && this.mustBeBookedPhysicalRevenue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeCostControlled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the movement must be cost controlled
    /// </summary>
    /// <returns>true, if the movement must be cost controlled; otherwise, false.</returns>
    /// <remarks>Use a post-method handler for extending the behavior of this method when adding new enum values for <c>SalesType</c> enum.</remarks>
    public boolean mustBeCostControlled()
    {
        switch (salesOrderLine.SalesType)
        {
            case SalesType::Sales:
            case SalesType::ReturnItem:
            case SalesType::Journal:
            case SalesType::Subscription:
                if (this.projId()!='' && ProjParameters::find().TrackCommittedCostSalesOrder)
                {
                    return true;
                }
                return false;
            case SalesType::ItemReq:
                if (this.projId()!='' && ProjParameters::find().TrackCommittedCostItemRequirement)
                {
                    return true;
                }
                return false;
            default:
                return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canItemReqBeCancelled</Name>
				<Source><![CDATA[
    public boolean canItemReqBeCancelled()
    {
        return salesOrderLine.canItemReqBeCancelled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeDeducted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the model group that is associated with the current <c>InventMovement</c> object
    ///    requires a mandatory deduct.
    /// </summary>
    /// <returns>
    ///    A Boolean value that indicates whether the model group that is associated with the current
    ///    <c>InventMovement</c> object requires a mandatory deduct.
    /// </returns>
    public boolean mustBeDeducted()
    {
        if (this.isRetailSalesOrder())
        {
            return false;
        }

        if (salesOrderLine.SalesType == SalesType::ItemReq)
        {
            return false;
        }

        return this.inventModelGroup().MandatoryDeduct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBePicked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the transactions that are related to this movement must be picked.
    /// </summary>
    /// <returns>
    ///    true if the transactions must be picked; otherwise, false.
    /// </returns>
    public boolean mustBePicked()
    {
        if (salesOrderLine.DeliveryType == TradeLineDlvType::DropShip || this.isRetailSalesOrder())
        {
            return false;
        }
        else if (this.ProjId())
        {
            ProjParameters projParameter = ProjParameters::find();
            if (projParameter.CreateItemReqForPO == NoYes::Yes && projParameter.AutomaticItemConsumption == NoYes::Yes)
            {
                return false;
            }
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeQuarantineControlled</Name>
				<Source><![CDATA[
    public boolean mustBeQuarantineControlled()
    {
        if (salesOrderLine.Scrap == NoYes::Yes)
        {
            return false;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeReceived</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the model group that is associated with the current <c>InventMovement</c> object
    ///    requires a mandatory receive.
    /// </summary>
    /// <returns>
    ///    A Boolean value that indicates whether the model group that is associated with the current
    ///    <c>InventMovement</c> object requires a mandatory receive.
    /// </returns>
    public boolean mustBeReceived()
    {
        if (this.isRetailSalesOrder())
        {
            return false;
        }

        if (this.mayScrapBeExpected() && this.doScrap())
        {
            return false;
        }
        else if (this.projId() && this.parmSalesPackingSlipJournalPostProj() && this.isReturned(this.transQty()))
        {
            return super();
        }

        // <GEERU>
        if (this.parmGoodsInRoute_RU())
        {
            return false;
        }
        // </GEERU>

        return this.inventModelGroup().MandatoryReceive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeRegistered</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the transactions that are related to this movement must be registered.
    /// </summary>
    /// <returns>
    /// true if transactions must be registered; otherwise, false.
    /// </returns>
    boolean mustBeRegistered()
    {
        if (this.isRetailSalesOrder())
        {
            return false;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeRemainControlled</Name>
				<Source><![CDATA[
    public boolean  mustBeRemainControlled()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeUnitControlled</Name>
				<Source><![CDATA[
    public boolean  mustBeUnitControlled()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckOverDelivery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current <c>InventMovement</c> object requires checking for over delivery.
    /// </summary>
    /// <param name="_direction">
    /// The <c>InventDirection</c> of the update.
    /// </param>
    /// <returns>
    /// true if over delivery must be checked; otherwise, false.
    /// </returns>
    public NoYes mustCheckOverDelivery(InventDirection _direction)
    {
        InventQty   qty;
        switch (_direction)
        {
            case InventDirection::Issue:
                qty = -1;
                break;
            case InventDirection::Receipt:
                qty = 1;
                break;
            case InventDirection::None:
                qty = 0;
                break;
        }

        if (this.isReturned(qty))
        {
            return NoYes::No;
        }

        return NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateQuarantineOrder</Name>
				<Source><![CDATA[
    public boolean mustCreateQuarantineOrder()
    {
        boolean     ret = super();

        if (ret)
        {
            // When SalesLine has Direct delivery, quarantine order must not be created
            if (salesOrderLine.DeliveryType == TradeLineDlvType::DropShip)
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustRegisterTrackingDimension</Name>
				<Source><![CDATA[
    public boolean mustRegisterTrackingDimension()
    {
        return this.inventTable().isActiveInSalesProcess() && salesOrderLine.Scrap == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSetProjAdjustRefInventTrans</Name>
				<Source><![CDATA[
    public boolean mustSetProjAdjustRefInventTrans()
    {
        return this.projId() ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(
        SalesLine   _salesOrderLine,
        InventType  _inventType = SalesLineType::construct(_salesOrderLine))
    {
        salesOrderLine = _salesOrderLine;

        super(_salesOrderLine,_inventType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMovement_Orig</Name>
				<Source><![CDATA[
    public InventMovement newMovement_Orig()
    {
        if (!salesOrderLine.RecId)
        {
            return null;
        }
        return InventMov_Sales::newFromSalesLine(salesOrderLine.orig());
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccountPhysical</Name>
				<Source><![CDATA[
    [Replaceable]
    public LedgerDimensionDefaultAccount offsetAccountPhysical()
    {
        if (this.canItemReqBeCancelled())
        {
            ProjFundingSourceRefId projFundingSource = salesOrderLine.ProjFundingSource ? salesOrderLine.ProjFundingSource : SalesTable::find(salesOrderLine.SalesId).FundingSource;

            cacheOffsetAccountPhysical = ProjPosting::getLedgerDimension(ProjAccountType::CostAccount,
                                            salesOrderLine.ProjId,
                                            salesOrderLine.ProjCategoryId,
                                            projFundingSource,
                                            false);
        }

        if (! cacheOffsetAccountPhysical)
        {
            cacheOffsetAccountPhysical = this.accountItem(InventAccountType::SalesPackingSlipOffsetAccount);
        }

        return cacheOffsetAccountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsAdjustIntercompanyRemainInventoryQty</Name>
				<Source><![CDATA[
    public void pdsAdjustIntercompanyRemainInventoryQty()
    {
        if (salesOrderLine.salesTable().InterCompanyDirectDelivery)
        {
            PurchLine referencePurchLine = salesOrderLine.referencedPurchLine();
                
            if (referencePurchLine.RecId && referencePurchLine.RemainInventPhysical == 0 && referencePurchLine.RemainInventFinancial == salesOrderLine.RemainInventFinancial
                && this.interCompanyMovement() && this.pdsCWItem() && salesOrderLine.PdsCWRemainInventPhysical == 0 && salesOrderLine.RemainInventPhysical != 0)
            {
                this.pdsAdjustInventoryQuantity(salesOrderLine.RemainInventPhysical);
                this.updateBuffer(this.parmAutoReserveWhenAdjustingCatchWeight());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onlyCheckStorageDimInConsistentCheck</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to check only the storage dimensions when you verify whether consistent
    ///    dimensions can be changed.
    /// </summary>
    /// <param name="_origInventDim">
    ///    An <c>InventDim</c> record that contains the original inventory dimension values.
    /// </param>
    /// <returns>
    ///    true if only storage dimensions must be checked; otherwise, false.
    /// </returns>
    public boolean onlyCheckStorageDimInConsistentCheck(InventDim _origInventDim)
    {
        return InventDim::isInventDimEqualProductDim(this.ecoResProductDimGroupSetup(), this.inventdim(), _origInventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>overDeliveryPct</Name>
				<Source><![CDATA[
    public Percent overDeliveryPct()
    {
        if (! SalesParameters::find().OverDelivery)
        {
            return 0;
        }
        return salesOrderLine.OverDeliveryPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountOperations</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount parmAccountOperations(LedgerDimensionDefaultAccount _accountOperations = accountOperations)
    {
        accountOperations = _accountOperations;
        return accountOperations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanCommittedCostBeReversed</Name>
				<Source><![CDATA[
    public UnknownNoYes parmCanCommittedCostBeReversed(UnknownNoYes _canCommittedCostBeReversed = canCommittedCostBeReversed)
    {
        canCommittedCostBeReversed = _canCommittedCostBeReversed;
        return canCommittedCostBeReversed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPdsBatchAttribAutoRes</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method gets/sets whether to use batch attributes for reservations
    /// </summary>
    /// <param name="_pdsBatchAttribAutoRes">
    /// flag to use batch attribute reservation
    /// </param>
    /// <returns>
    /// returns flag
    /// </returns>
    public PdsBatchAttribAutoRes parmPdsBatchAttribAutoRes(
        PdsBatchAttribAutoRes _pdsBatchAttribAutoRes = false)
    {
        if (!prmisDefault(_pdsBatchAttribAutoRes))
        {
            pdsUseBAForRes = _pdsBatchAttribAutoRes;
        }

        return pdsUseBAForRes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingOperations</Name>
				<Source><![CDATA[
    public LedgerPostingType parmPostingOperations(LedgerPostingType _postingOperations = postingOperations)
    {
        postingOperations = _postingOperations;
        return postingOperations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsConsiderRestrictReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if the batch disposition functionality should be considered reservation.
    /// </summary>
    /// <returns>
    /// Always returns true;
    /// </returns>
    public boolean pdsConsiderRestrictReservation()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAddRemainFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds to the catch weight remain financial.
    /// </summary>
    /// <param name="_qty">
    /// A catch weight quantity to add to remain financial.
    /// </param>
    public void pdsCWAddRemainFinancial(PdsCWInventQty _qty)
    {
        if (this.mustBeUnitControlled()
            && this.mustBeRemainControlled())
        {
            salesOrderLine.PdsCWRemainInventFinancial += -_qty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAddRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds to the catch weight remain physical.
    /// </summary>
    /// <param name="_qty">
    /// A catch weight quantity to add to remain physical.
    /// </param>
    public void pdsCWAddRemainPhysical(PdsCWInventQty _qty)
    {
        // PdsCWRemainInventPhysical should only be updated for inventoried items
        if (salesOrderLine.isStocked())
        {
            salesOrderLine.PdsCWRemainInventPhysical += -_qty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight remain physical quantity.
    /// </summary>
    /// <returns>
    /// The catch weight quantity.
    /// </returns>
    public PdsCWInventQty pdsCWRemainPhysical()
    {
        return -salesOrderLine.PdsCWRemainInventPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWReserveQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight reserve quantity.
    /// </summary>
    /// <returns>
    /// The catch weight quantity.
    /// </returns>
    public PdsCWInventQty pdsCWReserveQty()
    {
        return salesOrderLine.pdsCWReserveQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWSetRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the catch weight remain physical quantity.
    /// </summary>
    /// <param name="_qty">
    /// The value to set.
    /// </param>
    public void pdsCWSetRemainPhysical(PdsCWInventQty _qty)
    {
        // PdsCWRemainInventPhysical should only be updated for inventoried items
        if (salesOrderLine.isStocked())
        {
            salesOrderLine.PdsCWRemainInventPhysical = -_qty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWSetTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the catch weight transaction quantity.
    /// </summary>
    /// <param name="_qty">
    /// The value to set.
    /// </param>
    public void pdsCWSetTransQty(PdsCWInventQty _qty)
    {
        // PdsCWQty should only be updated for inventoried items
        if (salesOrderLine.isStocked())
        {
            salesOrderLine.PdsCWQty = -_qty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight transaction quantity.
    /// </summary>
    /// <returns>
    /// The catch weight quantity.
    /// </returns>
    public PdsCWInventQty pdsCWTransQty()
    {
        // PdsCWQty should only be used for inventoried items.
        if (!salesOrderLine.isStocked())
        {
            return 0;
        }

        return -salesOrderLine.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWUnitId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight unit ID.
    /// </summary>
    /// <returns>
    /// The catch weight unit ID.
    /// </returns>
    public PdsCWUnitId pdsCWUnitId()
    {
        return salesOrderLine.pdsCWUnitId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsMustConsiderBatchAttrib</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether batch attributes should be considered for reservation.
    /// </summary>
    /// <returns>
    /// A <c>PdsBatchAttribAutoRes</c> enumeration value.
    /// </returns>
    public PdsBatchAttribAutoRes pdsMustConsiderBatchAttrib()
    {
        return pdsUseBAForRes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsSameLotOverride</Name>
				<Source><![CDATA[
    /// <summary>
    /// Overrides the same lot feature and sets it not to use this feature for this movement.
    /// </summary>
    /// <remarks>
    /// The method updates the sales order line if it has been saved already.
    /// </remarks>
    public void pdsSameLotOverride()
    {
        salesOrderLine.PdsSameLot           = NoYes::No;
        salesOrderLine.PdsSameLotOverride   = NoYes::Yes;

        if (salesOrderLine.RecId)
        {
            ttsbegin;
            if (salesOrderLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries)
            {
                InventMovement::bufferSetRemainQty(salesOrderLine);
            }
            salesOrderLine.selectForUpdate(true);
            salesOrderLine.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsSameLotReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the same lot reservation feature is turned on for the sales order line.
    /// </summary>
    /// <returns>
    /// true if the same lot batch reservation feature is turned on for the sales line; otherwise, false .
    /// </returns>
    /// <remarks>
    /// The method also considers the same lot configuration key
    /// </remarks>
    public boolean pdsSameLotReservation()
    {
        return #PdsSameLotEnabled && salesOrderLine.PdsSameLot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingBalanceSheet</Name>
				<Source><![CDATA[
    public LedgerPostingType postingBalanceSheet()
    {
        return LedgerPostingType::SalesIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingOffsetPhysical</Name>
				<Source><![CDATA[
    public LedgerPostingType postingOffsetPhysical()
    {
        LedgerPostingType postOffsetPhysical = LedgerPostingType::SalesOffsetAccountPackingSlip;

        if (this.canItemReqBeCancelled())
        {
            postOffsetPhysical = LedgerPostingType::ProjCost;
        }

        return postOffsetPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingOperations</Name>
				<Source><![CDATA[
    public LedgerPostingType postingOperations()
    {
        if (postingOperations)
        {
            return postingOperations;
        }

        // <GEEU>
        return goodsInRoute ?
               salesOrderLine.postingGoodsInRouteOffset_RU() :
               salesOrderLine.postingOperations();
        // </GEEU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysical</Name>
				<Source><![CDATA[
    public LedgerPostingType postingPhysical()
    {
        return LedgerPostingType::SalesPackingSlip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysicalRevenue</Name>
				<Source><![CDATA[
    public LedgerPostingType postingPhysicalRevenue()
    {
        return LedgerPostingType::SalesPckSlipRevenue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysicalRevenueOffset</Name>
				<Source><![CDATA[
    public LedgerPostingType postingPhysicalRevenueOffset()
    {
        return LedgerPostingType::SalesPckSlipRevenueOffsetAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysicalTax</Name>
				<Source><![CDATA[
    public LedgerPostingType postingPhysicalTax()
    {
        return LedgerPostingType::SalesPackingslipTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projCategoryId</Name>
				<Source><![CDATA[
    public ProjCategoryId projCategoryId()
    {
        return salesOrderLine.ProjCategoryId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projId</Name>
				<Source><![CDATA[
    public ProjId projId()
    {
        return salesOrderLine.ProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLedgerOrigin</Name>
				<Source><![CDATA[
    public ProjLedgerOrigin projLedgerOrigin()
    {
        if (this.projId())
        {
            switch (salesOrderLine.SalesType)
            {
                case SalesType::ItemReq:
                    return ProjOrigin::ItemRequirement;
                case SalesType::Sales:
                    return ProjOrigin::SalesOrder;
            }
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLinePropertyId</Name>
				<Source><![CDATA[
    public ProjLinePropertyId projLinePropertyId()
    {
        return salesOrderLine.ProjLinePropertyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projSalesCurrencyId</Name>
				<Source><![CDATA[
    public ProjSalesCurrencyCode projSalesCurrencyId()
    {
        return salesOrderLine.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projSalesPrice</Name>
				<Source><![CDATA[
    public ProjSalesPriceCost projSalesPrice()
    {
        return salesOrderLine.LineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTaxGroupId</Name>
				<Source><![CDATA[
    public ProjTaxGroup projTaxGroupId()
    {
        return salesOrderLine.TaxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTaxItemGroupId</Name>
				<Source><![CDATA[
    public ProjTaxItemGroup projTaxItemGroupId()
    {
        return salesOrderLine.TaxItemGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransactionOrigin</Name>
				<Source><![CDATA[
    public ProjTransactionOrigin projTransactionOrigin()
    {
        if (this.projId())
        {
            switch (salesOrderLine.SalesType)
            {
                case SalesType::ItemReq:
                    return ProjOrigin::ItemRequirement;
                case SalesType::Sales:
                    return ProjOrigin::SalesOrder;
            }
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransId</Name>
				<Source><![CDATA[
    public ProjTransIdBase projTransId()
    {
        return salesOrderLine.ProjTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainFinancialUnit</Name>
				<Source><![CDATA[
    public UnitQty  remainFinancialUnit()
    {
        return -salesOrderLine.RemainSalesFinancial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainPhysical</Name>
				<Source><![CDATA[
    public InventQty   remainPhysical()
    {
        return -salesOrderLine.RemainInventPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainPhysicalUnit</Name>
				<Source><![CDATA[
    public UnitQty  remainPhysicalUnit()
    {
        return -salesOrderLine.RemainSalesPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveQty</Name>
				<Source><![CDATA[
    public InventQty   reserveQty()
    {
        return salesOrderLine.reserveQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Identifies the original transactions.
    /// </summary>
    /// <returns>
    ///    The ID of the original transaction originator if any; otherwise, zero.
    /// </returns>
    public InventTransOriginId returnInventTransOrigin()
    {
        if (!salesOrderLine.InventTransIdReturn)
        {
            return 0;
        }
        return InventTransOrigin::findByInventTransId(salesOrderLine.InventTransIdReturn).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesTable</Name>
				<Source><![CDATA[
    protected SalesTable salesTable()
    {
        if (!salesTable)
        {
            salesTable = salesOrderLine.salesTable();
        }
        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sellableDays</Name>
				<Source><![CDATA[
    private PdsSellableDays sellableDays()
    {
        return PdsCustSellableDays::findValidRec(this.itemId(),
                                                 this.custVendAc(),
                                                 this.inventdim()).SellableDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventDimId</Name>
				<Source><![CDATA[
    public void setInventDimId(InventDimId _dimId)
    {
        salesOrderLine.setInventDimId(_dimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsAdjustInventoryQuantity</Name>
				<Source><![CDATA[
    public void pdsAdjustInventoryQuantity(InventQty _inventQty)
    {
        if (salesOrderLine.creditNoteLine() && this.pdsCWItem())
        {
            InventQtyRegistered qtyRegistered = this.transIdSum().registered();
            if (abs(salesOrderLine.RemainInventPhysical -_inventQty) < qtyRegistered)
            {
                _inventQty = qtyRegistered - abs(salesOrderLine.RemainInventPhysical);
            }
        }
        super(_inventQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventRefFields</Name>
				<Source><![CDATA[
    public boolean setInventRefFields(
        InventRefType           _inventRefType,
        InventRefId             _inventRefId,
        InventTransOriginId     _markingRefInventTransOrigin)
    {
        salesOrderLine.InventRefType        = _inventRefType;
        salesOrderLine.InventRefId          = _inventRefId;
        salesOrderLine.InventRefTransId     = InventTransOrigin::find(_markingRefInventTransOrigin).InventTransId;

        if (_inventRefType == InventRefType::None)
        {
            salesOrderLine.SourcingOrigin = SalesSourcingOrigin::Inventory;
            salesOrderLine.SourcingVendAccount = "";
            salesOrderLine.SourcingCompanyId = "";
            salesOrderLine.SourcingInventSiteId = "";
            salesOrderLine.SourcingInventLocationId = "";

            if (salesOrderLine.DeliveryType == TradeLineDlvType::DropShip)
            {
                // when deleting related drop ship PO it is no longer a direct delivery, but we keep the mark that it has to be drop shipped.
                salesOrderLine.DeliveryType = TradeLineDlvType::None;
                
                MCRDropShipStatusInstrumentationActivities dropShipStatusActivities = MCRDropShipInstrumentationLogger::createLogger(classId2Name(classIdGet(this))).dropShipStatusActivities();

                using (var activityContext = dropShipStatusActivities.setRecordSetInventRefFields(salesOrderLine))
                {
                    ttsBegin;
                    MCRSalesLineDropShipment mcrSalesLineDropShipment;
                    mcrSalesLineDropShipment.skipDataMethods(true);

                    update_recordSet mcrSalesLineDropShipment
                        setting DropShipStatus = MCRDropShipStatus::ToBeDropShipped
                        where mcrSalesLineDropShipment.SalesLine == salesOrderLine.RecId;

                    ttsCommit;
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjAdjustRefId</Name>
				<Source><![CDATA[
    public void setProjAdjustRefId(InventTrans _inventTrans)
    {
        if (_inventTrans.ProjAdjustRefId)
        {
            projAdjustRefId = _inventTrans.ProjAdjustRefId;
            return;
        }

        if (!salesOrderLine.type().mustSetProjAdjustRefInventTrans(_inventTrans.InvoiceId))
        {
            return;
        }

        if (!projAdjustRefId)
        {
            projAdjustRefId = NumberSeq::newGetNum(CompanyInfo::numRefParmId()).num();
        }

        _inventTrans.ProjAdjustRefId = projAdjustRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRemainPhysical</Name>
				<Source><![CDATA[
    public void setRemainPhysical(InventQty  _inventQty)
    {
        // RemainInventPhysical should only be updated for inventoried items
        if (salesOrderLine.isStocked())
        {
            salesOrderLine.RemainInventPhysical= -_inventQty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRemainPhysicalUnit</Name>
				<Source><![CDATA[
    public void setRemainPhysicalUnit(UnitQty _qtyUnit)
    {
        salesOrderLine.RemainSalesPhysical = -_qtyUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransQty</Name>
				<Source><![CDATA[
    public void setTransQty(InventQty _qtyInvent)
    {
        // QtyOrdered should only be updated for inventoried items
        if (salesOrderLine.isStocked())
        {
            salesOrderLine.QtyOrdered= -_qtyInvent;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransQtyUnit</Name>
				<Source><![CDATA[
    public void setTransQtyUnit(UnitQty _qtyUnit)
    {
        salesOrderLine.SalesQty= -_qtyUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shippingDateConfirmed</Name>
				<Source><![CDATA[
    protected SalesShippingDateConfirmed shippingDateConfirmed()
    {
        return salesOrderLine.ShippingDateConfirmed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shippingDateRequested</Name>
				<Source><![CDATA[
    public SalesShippingDateRequested shippingDateRequested()
    {
        return salesOrderLine.ShippingDateRequested;
    }

]]></Source>
			</Method>
			<Method>
				<Name>subDeliveryPct</Name>
				<Source><![CDATA[
    protected Percent subDeliveryPct()
    {
        if (! SalesParameters::find().SubDelivery)
        {
            return 0;
        }
        return salesOrderLine.UnderDeliveryPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDate</Name>
				<Source><![CDATA[
    public TransDate transDate()
    {
        return salesOrderLine.ShippingDateConfirmed ? salesOrderLine.ShippingDateConfirmed : salesOrderLine.ShippingDateRequested;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transId</Name>
				<Source><![CDATA[
    public InventTransId transId()
    {
        return salesOrderLine.InventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transInventRefType</Name>
				<Source><![CDATA[
    public InventRefType transInventRefType()
    {
        return InventRefType::Sales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transQty</Name>
				<Source><![CDATA[
    public InventQty  transQty()
    {
        // QtyOrdered should only be used for inventoried items.
        if (!salesOrderLine.isStocked())
        {
            return 0;
        }

        return -salesOrderLine.QtyOrdered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transQtyUnit</Name>
				<Source><![CDATA[
    public InventQty  transQtyUnit()
    {
        return -salesOrderLine.SalesQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transRefId</Name>
				<Source><![CDATA[
    public InventTransRefId transRefId()
    {
        return salesOrderLine.SalesId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transType</Name>
				<Source><![CDATA[
    public InventTransType transType()
    {
        return InventTransType::Sales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transUnitId</Name>
				<Source><![CDATA[
    public UnitOfMeasureSymbol transUnitId()
    {
        return salesOrderLine.SalesUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBuffer</Name>
				<Source><![CDATA[
    public void updateBuffer(boolean _updateReservation = true)
    {
        InventUpd_Estimated     estimated = InventUpd_Estimated::newInventMovement(this);

        estimated.updateNow();
        salesOrderLine.doUpdate();

        if (estimated && _updateReservation)
        {
            estimated.updateReservation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateGoodsInRoute_RU</Name>
				<Source><![CDATA[
    public void updateGoodsInRoute_RU(InventUpd_Financial _financial)
    {
        InventMov_Vir_GoodsInRoute_RU   movementVirtual;
        InventUpd_Financial             financialVirtual;
        InventUpd_Physical              physicalVirtual;
        InventTrans                     inventTrans;
        InventTransOrigin               inventTransOrigin;

        if (! goodsInRoute || (! inventTransIdTransit && ! inventTransIdDelivery))
        {
            return;
        }

        if (_financial.parmFinancial() > 0)
        {
            while select * from inventTrans
                where inventTrans.DateFinancial     == _financial.parmLedgerVoucher().lastTransDate()   &&
                      inventTrans.Voucher           == _financial.parmLedgerVoucher().lastVoucher()     &&
                      inventTrans.InvoiceId         == _financial.parmInvoiceId()                       &&
                      inventTrans.Qty               >  0                                                &&
                      inventTrans.InvoiceReturned   == NoYes::Yes
            join * from inventTransOrigin
                where inventTransOrigin.RecId         == inventTrans.InventTransOrigin &&
                      inventTransOrigin.InventTransId == this.transId()
            {
                if (inventTrans.InventTransOriginDelivery_RU)
                {
                    // update return 'delivery' inventory transaction and update it physically
                    movementVirtual = InventMov_Vir_GoodsInRoute_Delivery_RU::newParameters(inventTrans.ItemId,
                                                                                            inventTransOrigin.ReferenceCategory,
                                                                                            inventTransOrigin.ReferenceId,
                                                                                            inventTrans.InventDimId,
                                                                                            inventTransOrigin.custVendAC(),
                                                                                            inventTrans.dimensionFinancialDefaultDimension(),
                                                                                            inventTrans.DateFinancial,
                                                                                            -inventTrans.Qty,
                                                                                            salesOrderLine.SalesCategory,
                                                                                            inventTrans.InventTransOrigin,
                                                                                            InventTransOrigin::find(inventTrans.InventTransOriginDelivery_RU).InventTransId);

                    movementVirtual.parmMustBeBookedPhysically(this.mustBeBookedPhysically());
                    movementVirtual.parmAccountPhysical(this.accountPhysical());
                    movementVirtual.parmPostingPhysical(this.postingPhysical());
                    movementVirtual.parmOffsetAccountPhysical(this.offsetAccountPhysical());
                    movementVirtual.parmPostingOffsetPhysical(this.postingOffsetPhysical());

                    movementVirtual.parmMustBeBookedPhysicalRevenue(this.mustBeBookedPhysicalRevenue());
                    movementVirtual.parmAccountPhysicalRevenue(this.accountPhysicalRevenue());
                    movementVirtual.parmPostingPhysicalRevenue(this.postingPhysicalRevenue());
                    movementVirtual.parmAccountPhysicalRevenueOffset(this.accountPhysicalRevenueOffset());
                    movementVirtual.parmPostingPhysicalRevenueOffset(this.postingPhysicalRevenueOffset());

                    movementVirtual.parmMustBeBookedPhysicalTax(this.mustBeBookedPhysicalTax());
                    movementVirtual.parmAccountPhysicalTax(this.accountPhysicalTax());
                    movementVirtual.parmPostingPhysicalTax(this.postingPhysicalTax());

                    movementVirtual.parmEstimatedPhysicalRevenue(this.estimatedPhysicalRevenue(inventTrans));
                    movementVirtual.parmEstimatedPhysicalTax(this.estimatedPhysicalTax(inventTrans));

                    movementVirtual.pdsCWSetTransQty(-inventTrans.PdsCWQty);

                    movementVirtual.parmStorno_RU(this.storno_RU());
                    movementVirtual.parmStornoPhysical_RU(this.parmStornoPhysical_RU());
                    physicalVirtual = InventUpd_Physical::newGoodsInRouteDelivery_RU(movementVirtual,
                                                                                     _financial);
                    physicalVirtual.updateNow(_financial.parmLedgerVoucher());
                }

                if (inventTrans.InventTransOriginTransit_RU)
                {
                    // create 'transit' inventory transaction and update it financially
                    movementVirtual = InventMov_Vir_GoodsInRoute_Transit_RU::newParameters(inventTrans.ItemId,
                                                                                           inventTransOrigin.ReferenceCategory,
                                                                                           inventTransOrigin.ReferenceId,
                                                                                           inventTrans.InventDimId,
                                                                                           inventTransOrigin.custVendAC(),
                                                                                           inventTrans.dimensionFinancialDefaultDimension(),
                                                                                           inventTrans.DateFinancial,
                                                                                           -inventTrans.Qty,
                                                                                           salesOrderLine.SalesCategory,
                                                                                           inventTrans.InventTransOrigin,
                                                                                           InventTransOrigin::find(inventTrans.InventTransOriginTransit_RU).InventTransId);

                    movementVirtual.pdsCWSetTransQty(-inventTrans.PdsCWQty);

                    movementVirtual.parmStorno_RU(this.storno_RU());
                    movementVirtual.parmStornoPhysical_RU(this.parmStornoPhysical_RU());
                    financialVirtual = InventUpd_Financial::newGoodsInRouteTransit_RU(movementVirtual,
                                                                                      _financial,
                                                                                      -inventTrans.CostAmountPosted,
                                                                                      -inventTrans.CostAmountSecCurPosted_RU);
                    financialVirtual.parmInvoiceReturn_RU(NoYes::No);
                    financialVirtual.updateNow();
                }
            }
        }
        else
        {
            setPrefix("@GLS114828");

            while select forupdate * from inventTrans
                where inventTrans.DateFinancial     == _financial.parmLedgerVoucher().lastTransDate()   &&
                      inventTrans.Voucher           == _financial.parmLedgerVoucher().lastVoucher()     &&
                      inventTrans.InvoiceId         == _financial.parmInvoiceId()                       &&
                      inventTrans.Qty               <  0                                                &&
                      (!_financial.parmPackingSlipId()   ||
                       inventTrans.PackingSlipId   == _financial.parmPackingSlipId())                   &&
                      (!_financial.parmVoucherPhysical() ||
                       inventTrans.VoucherPhysical == _financial.parmVoucherPhysical())                 &&
                      !inventTrans.ReturnInventTransOrigin
            join * from inventTransOrigin
                where inventTransOrigin.RecId         == inventTrans.InventTransOrigin &&
                      inventTransOrigin.InventTransId == this.transId()
            {
                if (inventTransIdTransit)
                {
                    // create 'transit' inventory transaction and update it financially
                    movementVirtual = InventMov_Vir_GoodsInRoute_Transit_RU::newParameters(inventTrans.ItemId,
                                                                                           inventTransOrigin.ReferenceCategory,
                                                                                           inventTransOrigin.ReferenceId,
                                                                                           inventTrans.InventDimId,
                                                                                           inventTransOrigin.custVendAC(),
                                                                                           inventTrans.dimensionFinancialDefaultDimension(),
                                                                                           inventTrans.DateFinancial,
                                                                                           -inventTrans.Qty,
                                                                                           salesOrderLine.SalesCategory,
                                                                                           inventTrans.InventTransOrigin,
                                                                                           inventTransIdTransit);

                    movementVirtual.pdsCWSetTransQty(-inventTrans.PdsCWQty);

                    movementVirtual.parmStorno_RU(this.storno_RU());
                    movementVirtual.parmUseEnteredPriceAsCost(true);
                    financialVirtual = InventUpd_Financial::newGoodsInRouteTransit_RU(movementVirtual,
                                                                                      _financial,
                                                                                      -inventTrans.CostAmountPosted,
                                                                                      -inventTrans.CostAmountSecCurPosted_RU);
                    financialVirtual.parmProjCostAmountMST(-inventTrans.CostAmountPosted);
                    financialVirtual.parmProjCostAmountMSTSecCur_RU(-inventTrans.CostAmountSecCurPosted_RU);
                    financialVirtual.parmInvoiceReturn_RU(NoYes::Yes);
                    financialVirtual.updateNow();
                }

                if (inventTransIdDelivery)
                {
                    // create 'delivery' inventory transaction and update it physically
                    movementVirtual = InventMov_Vir_GoodsInRoute_Delivery_RU::newParameters(inventTrans.ItemId,
                                                                                            inventTransOrigin.ReferenceCategory,
                                                                                            inventTransOrigin.ReferenceId,
                                                                                            inventTrans.InventDimId,
                                                                                            inventTransOrigin.custVendAC(),
                                                                                            inventTrans.dimensionFinancialDefaultDimension(),
                                                                                            inventTrans.DateFinancial,
                                                                                            -inventTrans.Qty,
                                                                                            salesOrderLine.SalesCategory,
                                                                                            inventTrans.InventTransOrigin,
                                                                                            inventTransIdDelivery);
                    movementVirtual.parmMustBeBookedPhysically(this.mustBeBookedPhysically());
                    movementVirtual.parmAccountPhysical(this.accountPhysical());
                    movementVirtual.parmPostingPhysical(this.postingPhysical());
                    movementVirtual.parmOffsetAccountPhysical(this.offsetAccountPhysical());
                    movementVirtual.parmPostingOffsetPhysical(this.postingOffsetPhysical());

                    movementVirtual.parmMustBeBookedPhysicalRevenue(this.mustBeBookedPhysicalRevenue());
                    movementVirtual.parmAccountPhysicalRevenue(this.accountPhysicalRevenue());
                    movementVirtual.parmPostingPhysicalRevenue(this.postingPhysicalRevenue());
                    movementVirtual.parmAccountPhysicalRevenueOffset(this.accountPhysicalRevenueOffset());
                    movementVirtual.parmPostingPhysicalRevenueOffset(this.postingPhysicalRevenueOffset());

                    movementVirtual.parmMustBeBookedPhysicalTax(this.mustBeBookedPhysicalTax());
                    movementVirtual.parmAccountPhysicalTax(this.accountPhysicalTax());
                    movementVirtual.parmPostingPhysicalTax(this.postingPhysicalTax());

                    movementVirtual.parmEstimatedPhysicalRevenue(this.estimatedPhysicalRevenue(inventTrans));
                    movementVirtual.parmEstimatedPhysicalTax(this.estimatedPhysicalTax(inventTrans));

                    movementVirtual.pdsCWSetTransQty(-inventTrans.PdsCWQty);

                    movementVirtual.parmStorno_RU(this.storno_RU());

                    physicalVirtual = InventUpd_Physical::newGoodsInRouteDelivery_RU(movementVirtual,
                                                                                     _financial);
                    physicalVirtual.updateNow(_financial.parmLedgerVoucher());
                }

                InventTransOriginId inventTransOriginTransit = InventTransOrigin::findByInventTransId(inventTransIdTransit).RecId;
                InventTransOriginId inventTransOriginDelivery = InventTransOrigin::findByInventTransId(inventTransIdDelivery).RecId;

                InventTrans inventTransLocal = InventTrans::findRecId(inventTrans.RecId, true);
                inventTransLocal.InventTransOriginSales_RU    = inventTrans.InventTransOrigin;
                inventTransLocal.InventTransOriginTransit_RU  = inventTransOriginTransit;
                inventTransLocal.InventTransOriginDelivery_RU = inventTransOriginDelivery;
                inventTransLocal.update();

                // marking 'delivery' and 'transit' transactions
                if (inventTransIdTransit && inventTransIdDelivery)
                {
                    InventTransOrigin::updateMarking(inventTransOriginTransit, inventTransOriginDelivery, -inventTrans.Qty, "", SortOrder::Ascending, false, null, null, -inventTrans.PdsCWQty);
                    InventTransOrigin::updateMarking(inventTransOriginDelivery, inventTransOriginTransit, inventTrans.Qty, "", SortOrder::Ascending, false, null, null, inventTrans.PdsCWQty);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerFinancialSecCur_RU</Name>
				<Source><![CDATA[
    public CostAmountSecCur_RU updateLedgerFinancialSecCur_RU(
        LedgerVoucher       _ledgerVoucher,
        InventUpd_Financial _updateNow,
        boolean             _allowNegative = false)
    {
        CostAmountSecCur_RU  costAmountSecCur;

        if (_updateNow.parmFinancial() > 0)
        {
            if (this.mustBeBookedFinancially() && this.mustBeBookedOnhandSecCur_RU())
            {
                if (!isTelemetryForSecCurSent)
                {
                    GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00111, funcName());
                    isTelemetryForSecCurSent = true;
                }

                LedgerVoucherObject voucherObjectSecCur = _ledgerVoucher.findOrCreateReferenceSecCur_RU();
                LedgerBondClient_RU ledgerBondClient = voucherObjectSecCur.ledgerBondClient_RU();

                if (ledgerBondClient)
                {
                    ledgerBondClient.addNewLogObject();
                }

                if (this.mustBeBookedBalanceSheet())
                {
                    voucherObjectSecCur.addTrans(
                        LedgerVoucherTransObject::newBasicSecondary_RU(
                            voucherObjectSecCur,
                            this.postingBalanceSheet(),
                            LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountBalanceSheet(), this.defaultDimension()),
                            _updateNow.parmCurrencyCode(),
                            _updateNow.parmCostAmountCurSecCur_RU()));

                    costAmountSecCur = _updateNow.parmCostAmountCurSecCur_RU();
                    _updateNow.updCostAmountSecCurLedger_RU(costAmountSecCur);
                }

                if (this.mustBeBookedOperations())
                {
                    voucherObjectSecCur.addTrans(
                        LedgerVoucherTransObject::newBasicSecondary_RU(
                            voucherObjectSecCur,
                            this.postingOperations(),
                            LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountOperations(), this.defaultDimension()),
                            _updateNow.parmCurrencyCode(),
                            -_updateNow.parmCostAmountCurSecCur_RU()));

                    costAmountSecCur = _updateNow.parmCostAmountCurSecCur_RU();
                    _updateNow.updCostAmountSecCurLedger_RU(costAmountSecCur);
                }

                if (ledgerBondClient)
                {
                    if (ledgerBondClient.currentLogLength() == 2)
                    {
                        ledgerBondClient.bondLastVRef2CurrentLog();
                    }

                    ledgerBondClient.removeCurrentLogObject();
                }

                _ledgerVoucher.restoreReferenceSecCur_RU();
            }
        }

        return costAmountSecCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePeggingRequirements</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the pegging requirements of the inventory movement.
    /// </summary>
    /// <remarks>
    ///    It supports implementing the register as empty setting of a kanban rule set to when the source of
    ///    demand is registered.
    /// </remarks>
    public void updatePeggingRequirements()
    {
        if (salesOrderLine.isStocked() && isConfigurationkeyEnabled(configurationKeyNum(LeanManufacturing)))
        {
            if (this.hasBeenFullyPicked())
            {
                LeanRuleEvent::updatePeggingRequirements(salesOrderLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqExplodeReservation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to handle reservations by a master scheduling explosion.
    /// </summary>
    /// <returns>
    ///    true if reservations should be done by master planning explosion; otherwise, false.
    /// </returns>
    public boolean updateReqExplodeReservation()
    {
        // For CTP with Planning Optimization, the auto reservations will run after the master planning run.
        if (salesOrderLine.isDeliveryDateControlTypeMpsCTP())
        {
            return true;
        }

        if (salesOrderLine.isDeliveryDateControlTypeClassicCTP())
        {
            if (!(salesOrderLine.ProjId && salesOrderLine.SalesType == SalesType::ItemReq))
            {
                // an explosion is executed later and will do reservation according to setting
                return true;
            }
        }
        else
        {
            if (salesOrderLine.Reservation == ItemReservation::Explosion)
            {
                // run explosion now and do reservation
                ReqCalcExplodeSales::newMovement(this, true).runOperation();
                return true;
            }
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>InventMov_Sales</c> class based on the specified record.
    /// </summary>
    /// <param name="_salesLine">
    ///    The record in the <c>SalesLine</c> table for which the class is instantiated.
    /// </param>
    /// <returns>
    ///    An instance of the <c>InventMov_Sales</c> class.
    /// </returns>
    public static InventMov_Sales newFromSalesLine(SalesLine _salesLine)
    {
        return new InventMov_Sales(_salesLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedFinancialValue</Name>
				<Source><![CDATA[
    public CostAmount estimatedFinancialValue(
            InventTrans     _inventTrans,
            InventOnhand    _inventOnhand)
    {
        CostAmount estimatedFinancialValue = super(_inventTrans, _inventOnhand);
        
        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            estimatedFinancialValue += this.taxEngineInventMovement().taxInCostPriceCur();
        }
        // </GTE>
        
        return estimatedFinancialValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipProductNotStoppedCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether or not items in this inventory movement need to be skip the validation that the product is not stopped.
    /// </summary>
    /// <returns>True if the products don't need to be validated to ensure that they aren't stopped; otherwise, false.</returns>
    internal boolean shouldSkipProductNotStoppedCheck()
    {
        return !SalesLineCreationPolicy::newFromSalesOrderCreationMethod(salesOrderLine.SalesSalesOrderCreationMethod).mustCheckProductNotStopped();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSyncInventoryBlockingStatusTransType</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean shouldSyncInventoryBlockingStatusTransType()
    {
        return WHSInventoryBlockingStatusSyncReturnOrderFlight::instance().isEnabled() && this.isReturned(this.transQty());
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventBatchReservationPolicy</Name>
				<Source><![CDATA[
    internal WHSInventBatchReservationPolicy inventBatchReservationPolicy()
    {
        WHSInventBatchReservationPolicy policy = new WHSInventBatchReservationPolicy();
        policy.parmMinAllowedBestBeforeDate(this.minAllowedBestBeforeDate());
        policy.parmMinAllowedExpiryDate(this.minAllowedExpiryDate());
        return policy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsShouldRemoveReservationOnReservePhysicalTransIssue</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean whsShouldRemoveReservationOnReservePhysicalTransIssue()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFlexibleWarehouseLevelDimensionReservationEnabled</Name>
				<Source><![CDATA[
    protected boolean isFlexibleWarehouseLevelDimensionReservationEnabled()
    {
        return !this.isRetailSalesOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRemainPhysicalFromBuffer</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void updateRemainPhysicalFromBuffer(InventMovement _movement_Orig)
    {
        PdsCWInventQty cwInventQtyDiff = PdsGlobal::pdsIsCWItem(this.ItemId()) ? this.pdsCWTransQty() - _movement_Orig.pdsCWTransQty() : 0;

        if (this.salesOrderLine.SalesType == SalesType::Sales
            && salesOrderLine.isStocked() && this.isItemWHSEnabled()
            && cwInventQtyDiff > 0 && this.pdsCWTransQty() < 0)
        {
            this.setRemainPhysical(_movement_Orig.remainPhysical());

            PdsCWOnOrder cwOnOrder = salesOrderLine.pdsCWOnOrder();
            InventQtyOnOrder onOrder = salesOrderLine.onOrder();
            InventQty minInventQty = PdsCatchWeight::minInventQty(this.ItemId(), 1);

            if (cwOnOrder * minInventQty == onOrder)
            {
                this.addRemainPhysical(cwInventQtyDiff * minInventQty);
            }
            else if (cwInventQtyDiff >= cwOnOrder)
            {
                this.addRemainPhysical(onOrder + (cwInventQtyDiff - cwOnOrder) * minInventQty);
            }
            else
            {
                this.addRemainPhysical(this.transQty() - _movement_Orig.transQty());
            }
        }
        else
        {
            super(_movement_Orig);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRemainPhysicalUnitFromBuffer</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void updateRemainPhysicalUnitFromBuffer(InventMovement _movement_Orig)
    {
        PdsCWInventQty cwInventQtyDiff = PdsGlobal::pdsIsCWItem(this.ItemId()) ? this.pdsCWTransQty() - _movement_Orig.pdsCWTransQty() : 0;

        if (this.salesOrderLine.SalesType == SalesType::Sales && this.isItemWHSEnabled()
            && cwInventQtyDiff > 0 && this.pdsCWTransQty() < 0)
        {
            this.setRemainPhysicalUnit(_movement_Orig.remainPhysicalUnit());

            PdsCWOnOrder cwOnOrder = salesOrderLine.pdsCWOnOrder();
            InventQtyOnOrder onOrder = salesOrderLine.onOrder();
            InventQty minInventQty = PdsCatchWeight::minInventQty(this.ItemId(), 1);
            
            if (cwOnOrder * minInventQty == onOrder)
            {
                this.addRemainPhysicalUnit(salesOrderLine.unitConvertInvent2Sales(cwInventQtyDiff * minInventQty));
            }
            else if (cwInventQtyDiff >= cwOnOrder)
            {
                this.addRemainPhysicalUnit(salesOrderLine.onOrderInSalesUnit() + salesOrderLine.unitConvertInvent2Sales((cwInventQtyDiff - cwOnOrder) * minInventQty));
            }
            else
            {
                this.addRemainPhysicalUnit(this.transQtyUnit() - _movement_Orig.transQtyUnit());
            }
        }
        else
        {
            super(_movement_Orig);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetailStatementOrder</Name>
				<Source><![CDATA[
    private boolean isRetailStatementOrder()
    {
        return this.salesTable().isRetailCashAndCarrySales();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReturnScrap</Name>
				<Source><![CDATA[
    public boolean isReturnScrap()
    {
        return salesOrderLine.SalesType == SalesType::ReturnItem
            && salesOrderLine.returnCreateScrap();
    }

]]></Source>
			</Method>
			<Method>
				<Name>logUnexpectedLotIdNotSpecified</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void logUnexpectedLotIdNotSpecified(MethodName _fromMethod)
    {
        error(strFmt("@SCM:LotIdNotSpecifiedForSalesLineError", salesOrderLine.SalesId, salesOrderLine.InventTransId, int642Str(salesOrderLine.RecId)));
        super(_fromMethod);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFinTag</Name>
				<Source><![CDATA[
    public FinTagRecId getFinTag()
    {
        return salesOrderLine.FinTag;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFinTag</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Populate the fintag for ledgervouchertransObject if the salesOrderline has 
    ///  fintag populated and SalesOrderFinTagFeature is enabled
    /// </summary>
    protected void updateFinTag(LedgerVoucherTransObject _ledgerVoucherTransObject)
    {
        if (isFinTagConfigurationSetForCurrent && SalesOrderFinTagFeature::isEnabled() && this.getFinTag())
        {
            _ledgerVoucherTransObject.parmFinTag(this.getFinTag());
        }

    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>