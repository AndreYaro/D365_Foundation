<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxWithholdJournal_IN</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// To process Tax withold journal.
/// </summary>
class TaxWithholdJournal_IN extends TaxWithholdCalculation_IN
{
    AccountNum      accountNum;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcTaxWithholdForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calcualtes tax withhold for line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaction.
    /// </param>
    /// <param name="_isOnJewelry">
    /// whether it's on jewelry.
    /// </param>
    /// <param name="_isByCash">
    /// whether it's by cash.
    /// </param>
    /// <param name="_isSettled">
    /// whether it's settled already.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAmountCur</c> class.
    /// </returns>
    public TaxAmountCur calcTaxWithholdForLine(LedgerJournalTrans _ledgerJournalTrans, boolean _isOnJewelry = false, boolean _isByCash = false, boolean _isSettled = false)
    {
        TaxAmountCur                taxWithholdAmountCur;
        TaxWithholdGroup            taxWithholdGroup;
        AmountCur                   grossAmount;
        AmountCur                   grossAmountPaymentCompany;
        boolean                     calculateTaxWithhold;
        SpecTrans                   specTransLoc;
        CustVendAC                  accountNumber;
        AmountCur                   remainPaymentJournalAmountCur;
        Counter                     companyCounter;
        RefRecId                    cpOrigRefRecId;
        CompanyId                   currentCompany;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        // This is when TaxWithholdCode is attached. This is used for lines created using Tax Adjustment journals for direct taxes.
        if (ledgerJournalTransTaxExt.TaxWithholdCode != '')
        {
            taxWithholdAmountCur = this.saveTaxTransfer(taxableLineCurrentlyBeingCalculated);
            return taxWithholdAmountCur;
        }
        if (_ledgerJournalTrans.RecId != 0)
        {
            taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ?  ledgerJournalTransTaxExt.tdsGroup : ledgerJournalTransTaxExt.tcsGroup;

            if (taxWithholdGroup)
            {
                calculateTaxWithhold = this.checkCalculateTaxWHT(_ledgerJournalTrans);
            }

            if (calculateTaxWithhold)
            {
                if (this.checkSettlementVoucherForCalcTaxWithholdForLine(_ledgerJournalTrans)
                    && _ledgerJournalTrans.isDirectSettleForCP_IN())
                {
                    remainPaymentJournalAmountCur = abs(this.getPaymentAmountForCentralizePayment(_ledgerJournalTrans));

                    // Handle payment company first
                    while select sum(Balance01), RefCompany, RefTableId, RefRecId from specTransLoc
                        group by RefCompany, RefTableId, RefRecId
                        where specTransLoc.RefCompany == _ledgerJournalTrans.Company
                            && specTransLoc.SpecRecId  == _ledgerJournalTrans.RecId
                            && specTransLoc.SpecTableId == _ledgerJournalTrans.TableId
                    {
                        if (specTransLoc.RefCompany != currentCompany)
                        {
                            companyCounter++;
                            currentCompany = specTransLoc.RefCompany;
                        }

                        [grossAmount, remainPaymentJournalAmountCur, cpOrigRefRecId] = this.getCPGrossAmountCur(
                            _ledgerJournalTrans,
                            specTransLoc,
                            remainPaymentJournalAmountCur);
                        grossAmountPaymentCompany += grossAmount;

                        if (remainPaymentJournalAmountCur == 0)
                        {
                            break;
                        }
                    }

                    if (grossAmountPaymentCompany)
                    {
                        curTransWHTNotCalculatedBaseCur = grossAmountPaymentCompany;

                        accountNumber = TaxWithholdJournal_IN::setAccountNumber(_ledgerJournalTrans);

                        taxWithholdAmountCur += this.getTotalWithholdAmountCur(
                           accountNumber,
                            grossAmountPaymentCompany,
                            _ledgerJournalTrans,
                            null,
                            taxWithholdGroup,
                            _ledgerJournalTrans.Company);
                    }

                    // Handle invoice settlement.
                    while select specTransLoc
                        order by RefCompany, SpecRecId
                        where specTransLoc.SpecRecId    == _ledgerJournalTrans.RecId
                            && specTransLoc.SpecTableId == _ledgerJournalTrans.TableId
                            && specTransLoc.SpecCompany == curext()
                            && specTransLoc.RefCompany != _ledgerJournalTrans.Company
                    {
                        if (specTransLoc.RefCompany != currentCompany)
                        {
                            companyCounter++;
                            currentCompany = specTransLoc.RefCompany;
                        }

                        [grossAmount, remainPaymentJournalAmountCur, cpOrigRefRecId] = this.getCPGrossAmountCur(
                            _ledgerJournalTrans,
                            specTransLoc,
                            remainPaymentJournalAmountCur);

                        curTransWHTNotCalculatedBaseCur = grossAmount;
                        accountNumber = TaxWithholdJournal_IN::setAccountNumber(_ledgerJournalTrans);

                        taxWithholdAmountCur += this.getTotalWithholdAmountCur(
                            accountNumber,
                            grossAmount,
                            _ledgerJournalTrans,
                            specTransLoc,
                            taxWithholdGroup,
                            specTransLoc.RefCompany,
                            cpOrigRefRecId);

                        if (remainPaymentJournalAmountCur == 0)
                        {
                            break;
                        }
                    }

                    // Handle overpayment for single company CP
                    if (remainPaymentJournalAmountCur > 0
                        && companyCounter == 1)
                    {
                        grossAmount = this.getGrossAmount(_ledgerJournalTrans);
                        accountNumber = TaxWithholdJournal_IN::setAccountNumber(_ledgerJournalTrans);
                        specTransLoc = null;

                        taxWithholdAmountCur += this.getTotalWithholdAmountCur(
                            accountNumber,
                            grossAmount,
                            _ledgerJournalTrans,
                            specTransLoc,
                            taxWithholdGroup,
                            _ledgerJournalTrans.Company);
                    }
                }
                else
                {
                    grossAmount = this.getGrossAmount(_ledgerJournalTrans, _isOnJewelry, _isByCash, _isSettled);
                    accountNumber = TaxWithholdJournal_IN::setAccountNumber(_ledgerJournalTrans);

                    taxWithholdAmountCur = this.getTotalWithholdAmountCur(
                        accountNumber,
                        grossAmount,
                        _ledgerJournalTrans,
                        specTransLoc,
                        taxWithholdGroup,
                        _ledgerJournalTrans.Company,
                        0,
                        _isOnJewelry,
                        _isByCash);
                }
            }
        }

        return taxWithholdAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSettlementVoucherForCalcTaxWithholdForLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the settlement voucher type for tax withhold line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    ///     A <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <returns>
    ///     true if the settlement voucher type is selectedTransact; otherwise, false.
    /// </returns>
    protected boolean checkSettlementVoucherForCalcTaxWithholdForLine(LedgerJournalTrans _ledgerJournalTrans)
    {
        return (_ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSettlementVoucherForCalculateTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the settlement voucher type.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    ///     A <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <returns>
    ///     true if the settlement voucher type is selectedTransact; otherwise, false.
    /// </returns>
    protected boolean checkSettlementVoucherForCalculateTax(LedgerJournalTrans _ledgerJournalTrans)
    {
        return (_ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTmpTransLineWithholdGrossAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates each transaction line and insert to <c>TmpTransLineWithholdGrossAmount_IN</c>
    /// </summary>
    public void calcTmpTransLineWithholdGrossAmount()
    {
        boolean                 linesExist = true;
        LedgerJournalTrans      ledgerJournalTransLoc;
        LedgerJournalTable      ledgerJournalTableLoc;
        AccountType_IN          accountType_IN;
        AccountNum              accountNumLoc;
        AmountCur               amountCur;

        taxableLineCurrentlyBeingCalculated = ledgerJournalTaxWithholdDocument.getCurrentLine();

        while (linesExist)
        {
            ledgerJournalTransLoc = taxableLineCurrentlyBeingCalculated.getSourceLine();
            ledgerJournalTableLoc = LedgerJournalTable::find(ledgerJournalTransLoc.JournalNum);

            accountType_IN = (ledgerJournalTransLoc.AccountType == LedgerJournalACType::Cust || ledgerJournalTransLoc.OffsetAccountType == LedgerJournalACType::Cust) ? AccountType_IN::Cust : AccountType_IN::Vend;
            accountNumLoc  = TaxWithholdJournal_IN::setAccountNumber(ledgerJournalTransLoc);
            amountCur      = this.getGrossAmount(ledgerJournalTransLoc);
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = ledgerJournalTransLoc.ledgerJournalTransTaxExtensionIN();

            ttsBegin;
            tmpTransLineWithholdGrossAmount.clear();
            tmpTransLineWithholdGrossAmount.HeadingTableId      = ledgerJournalTableLoc.TableId;
            tmpTransLineWithholdGrossAmount.HeadingRecId        = ledgerJournalTableLoc.RecId;
            tmpTransLineWithholdGrossAmount.SourceTableId       = ledgerJournalTransLoc.TableId;
            tmpTransLineWithholdGrossAmount.SourceRecId         = ledgerJournalTransLoc.RecId;
            tmpTransLineWithholdGrossAmount.AccountType         = accountType_IN;
            tmpTransLineWithholdGrossAmount.AccountNumber       = accountNumLoc;
            tmpTransLineWithholdGrossAmount.LineGrossAmountCur  = amountCur;
            tmpTransLineWithholdGrossAmount.TransDate           = ledgerJournalTransLoc.TransDate;
            tmpTransLineWithholdGrossAmount.TaxWithholdGroup    = ledgerJournalTransTaxExt.TDSGroup ? ledgerJournalTransTaxExt.TDSGroup : ledgerJournalTransTaxExt.TCSGroup;
            if (FeatureStateProvider::isFeatureEnabled(TaxWithholdCustomerThresholdBasedOnPaymentOnlyFeature::instance())
                && TaxWithholdGroupHeading::find(tmpTransLineWithholdGrossAmount.TaxWithholdGroup).TaxLiabilityOnPayment_IN
                && accountType_IN == AccountType_IN::Cust
                && this.isPriceInclusive(ledgerJournalTransLoc.TableId, ledgerJournalTransLoc.RecId))
            {
                amountCur = abs(curTransWHTNotCalculatedBaseCur);
                tmpTransLineWithholdGrossAmount.LineGrossAmountCur = amountCur;
            }
            tmpTransLineWithholdGrossAmount.AmountOriginMST     = CurrencyExchangeHelper::amountCur2MST(amountCur, ledgerJournalTransLoc.CurrencyCode, ledgerJournalTransLoc.ExchRate, ledgerJournalTransLoc.TransDate);
            tmpTransLineWithholdGrossAmount.Voucher             = ledgerJournalTransLoc.Voucher;
            tmpTransLineWithholdGrossAmount.insert();
            ttsCommit;

            linesExist = ledgerJournalTaxWithholdDocument.getNextLine();
            taxableLineCurrentlyBeingCalculated = ledgerJournalTaxWithholdDocument.getCurrentLine();
        }

        ledgerJournalTaxWithholdDocument.getFirstLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate taxWithhold Amount for Journals.
    /// </summary>
    /// <returns>
    /// The value of the TaxAmountCur.
    /// </returns>
    public TaxAmountCur calculateTax()
    {
        TaxAmountCur            taxWithholdAmountCur;
        boolean                 linesExist = true;
        LedgerJournalTrans      ledgerJournalTransLoc;

        boolean                 isOnJewelry = false;
        boolean                 isByCash = false;
        boolean                 isSettled = false;
        boolean                 isARInvoice = false;
        boolean                 isPayment = false;
        boolean                 tcsCalculatedonInvoice = false;

        Debug::assert(ledgerJournalTaxWithholdDocument != null);

        if (!ledgerJournalTaxWithholdDocument.getFirstLine())
        {
            return 0;
        }

        System.Diagnostics.Stopwatch sw = System.Diagnostics.Stopwatch::StartNew();

        taxWithholdIN = new TaxWithhold_IN();
        this.calcTmpTransLineWithholdGrossAmount();
        taxableLineCurrentlyBeingCalculated = ledgerJournalTaxWithholdDocument.getCurrentLine();

        while (linesExist)
        {
            ledgerJournalTransLoc = taxableLineCurrentlyBeingCalculated.getSourceLine();
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = ledgerJournalTransLoc.ledgerJournalTransTaxExtensionIN();
            
            if (ledgerJournalTransLoc.canCalculateTDSonPaymentFee())
            {
                isOnJewelry = TaxWithholdDesignerTable_IN::isonJewelry(ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup : ledgerJournalTransTaxExt.tcsGroup, ledgerJournalTransLoc.TransDate);
                isByCash    = PaymTerm::isbyCashTermsofPayment_IN(ledgerJournalTransLoc.Payment) || CustPaymModeTable::isbyCashMethodofPayment_IN(ledgerJournalTransLoc.PaymMode);
                if (this.checkSettlementVoucherForCalculateTax(ledgerJournalTransLoc))
                {
                    isSettled = true;
                }
                isARInvoice = this.isARInvoice(ledgerJournalTransLoc);
                isPayment = this.isAdvancePayment(ledgerJournalTransLoc);

                if (isPayment && isSettled && isOnJewelry && isByCash)
                {
                    taxWithholdAmountCur += this.calculateTaxForJewelrybyCash(ledgerJournalTransLoc, isPayment, isSettled);
                }
                else if (isARInvoice && isOnJewelry && isByCash)
                {
                    taxWithholdAmountCur += this.calculateTaxForJewelrybyCash(ledgerJournalTransLoc, false, false);
                    GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIN00054, funcName(), GlobalizationInstrumentationHelper::DefaultFeatureVersion, SysCountryRegionCode::countryInfo(), sw.ElapsedMilliseconds);
                }
                else if (isARInvoice && isOnJewelry && isSettled)
                {
                    taxWithholdAmountCur += this.calculateTaxForJewelrybyCash(ledgerJournalTransLoc, false, isSettled);
                }
                else
                {
                    if (!(isOnJewelry && !isByCash))
                    {
                        taxWithholdAmountCur += this.calcTaxWithholdForLine(ledgerJournalTransLoc);
                    }
                }
            }

            linesExist = ledgerJournalTaxWithholdDocument.getNextLine();
            taxableLineCurrentlyBeingCalculated = ledgerJournalTaxWithholdDocument.getCurrentLine();
        }
        taxableLineCurrentlyBeingCalculated = null;

        this.updateTaxWithholdUncommitted();

        sw.Stop();
        GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIN00050, funcName(), GlobalizationInstrumentationHelper::DefaultFeatureVersion, SysCountryRegionCode::countryInfo(), sw.ElapsedMilliseconds);
        
        return taxWithholdAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTaxForJewelrybyCash</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate taxWithhold Amount for Journals on Jewelry by Cash.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// ledgerJournalTrans buffer.
    /// </param>
    /// <param name="_isPayment">
    /// isPayment buffer.
    /// </param>
    /// <param name="_isSettled">
    /// isSettled buffer.
    /// </param>
    /// <returns>
    /// The value of the TaxAmountCur.
    /// </returns>
    public TaxAmountCur calculateTaxForJewelrybyCash(LedgerJournalTrans _ledgerJournalTrans, boolean _isPayment, boolean _isSettled)
    {
        TaxAmountCur            taxWithholdAmountCur;
        SpecTrans               specTrans;
        CustTransOpen           custTransOpen;
        boolean                 tcsCalculatedonInvoice = false;
        CustTrans               custTransLoc;
        TaxWithholdTrans        taxWithholdTransLoc;
        AmountCur               sumOfPaymentAmountCur;

        if (_isPayment)
        {//Payment
            while select SpecRecId, SpecTableId, RefCompany, RefTableId, RefRecId, Balance01  from specTrans
                where specTrans.SpecRecId   == _ledgerJournalTrans.RecId
                    && specTrans.SpecTableId == _ledgerJournalTrans.TableId
            {
                select firstOnly TableId, RecId, AmountCur, CashDiscDate, DueDate, RefRecId, AccountNum, TransDate from custTransOpen
                    where custTransOpen.TableId == specTrans.RefTableId
                        && custTransOpen.RecId   == specTrans.RefRecId;

                //maybe invoice has been calc tcs already
                if (custTransOpen.RecId)
                {
                    select firstOnly AccountNum,RecId,Voucher from custTransLoc
                        where custTransLoc.RecId       == custTransOpen.RefRecId;
                    if (custTransLoc.RecId)
                    {
                        //the invoice has been clac tcs on invoice
                        select Voucher,RecId from taxWithholdTransLoc
                            where taxWithholdTransLoc.Voucher == custTransLoc.Voucher;
                        if (taxWithholdTransLoc.RecId)
                        {
                            tcsCalculatedonInvoice = true;
                        }

                        //the invoice has been clac tcs on payment
                        select VoucherInvoice,RecId from taxWithholdTransLoc
                            where taxWithholdTransLoc.VoucherInvoice == custTransLoc.Voucher;

                        if (taxWithholdTransLoc.RecId)
                        {
                            tcsCalculatedonInvoice = true;
                        }
                    }

                    //check the situation of select detail lines of invoice
                    if (custTransOpen.SettledTotalAmount_IN != 0)
                    {
                        tcsCalculatedonInvoice = false;
                    }
                }
            }

            //whether tcs has been calculated
            if (!tcsCalculatedonInvoice)
            {
                taxWithholdAmountCur += this.calcTaxWithholdForLine(_ledgerJournalTrans, true, true, true);
            }
        }
        else
        {//AR Invoice
            if (_isSettled)
            {
                // calc Sum Amount of payments - for jewelry
                if (sumOfPaymentAmountCur == 0)
                {
                    while select SpecRecId, SpecTableId, RefCompany, RefTableId, RefRecId, Balance01  from specTrans
                        where specTrans.SpecRecId       == _ledgerJournalTrans.RecId
                            && specTrans.SpecTableId    == _ledgerJournalTrans.TableId
                    {
                        select firstOnly TableId, RecId, AmountCur, CashDiscDate, DueDate, RefRecId, AccountNum, TransDate from custTransOpen
                            where custTransOpen.TableId     == specTrans.RefTableId
                                && custTransOpen.RecId      == specTrans.RefRecId;

                        if (custTransOpen.RecId)
                        {
                            select firstOnly AccountNum,RecId,PaymMode from custTransLoc
                                where custTransLoc.RecId       == custTransOpen.RefRecId;
                            if (custTransLoc.RecId)
                            {
                                //check whether it has calc tcs before on payment
                                select CustTransInvoiceId,RecId from taxWithholdTransLoc
                                    where taxWithholdTransLoc.CustTransInvoiceId == custTransLoc.RecId;

                                if (!taxWithholdTransLoc.RecId)
                                {
                                    if (CustPaymModeTable::isbyCashMethodofPayment_IN(custTransLoc.PaymMode))
                                    {
                                        sumOfPaymentAmountCur += -custTransOpen.AmountCur;
                                    }
                                }
                            }
                        }
                    }
                }

                if (sumOfPaymentAmountCur > 0)
                {
                    taxWithholdAmountCur += this.calcTaxWithholdForLine(_ledgerJournalTrans, true, true);
                }
            }
            else
            {//AR invoice on Jewelry no settlement
                //AR invoice only on Terms of Payment
                if (PaymTerm::isbyCashTermsofPayment_IN(_ledgerJournalTrans.Payment))
                {
                    taxWithholdAmountCur += this.calcTaxWithholdForLine(_ledgerJournalTrans, true, true);
                }
            }
        }

        return taxWithholdAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCalculateWHT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether withholding tax calculation is possible for this <c> LedgerJournalTrans </c>.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The buffer of <c> LedgerJournalTrans </c>.
    /// </param>
    /// <param name="_invoiceCompany">
    /// The invoice company used.
    /// </param>
    /// <param name="_paymentCompany">
    /// The payment company used.
    /// </param>
    /// <param name="_account">
    /// Customer/vendor is used to find the record.
    /// </param>
    /// <returns>
    /// Returns true if withholding tax calculation is possible otherwise false.
    /// </returns>
    protected boolean canCalculateWHT(LedgerJournalTrans           _ledgerJournalTrans,
                                      CompanyId                    _invoiceCompany,
                                      CompanyId                    _paymentCompany,
                                      CustVendAC                   _account)
    {
        boolean                     canCalculateWHT               = false;
        boolean                     canCalculateWHTForInvoiceCust = true;
        boolean                     canCalculateWHTForInvoiceVend = true;
        VendTable                   vendTable;
        CustTable                   custTable;
        TaxWithholdParameters_IN    taxWithholdParameter;
        boolean                     isCrossCompany = true;
        boolean                     offSetAccount;
        LedgerJournalTrans          tmpledgerJournalTrans;
        TaxInformationCustTable_IN      taxInformationCustTableLoc;
        TaxInformationVendTable_IN      taxInformationVendTableLoc;
        LedgerJournalAC                 offsetAcct;

        if (!_ledgerJournalTrans.parmOffsetAccount())
        {
            select sum(AmountCurCredit),sum(AmountCurDebit) from tmpledgerJournalTrans
                where tmpledgerJournalTrans.JournalNum == _ledgerJournalTrans.JournalNum
                   && tmpledgerJournalTrans.Voucher    == _ledgerJournalTrans.Voucher;

            if (tmpledgerJournalTrans.AmountCurCredit == tmpledgerJournalTrans.AmountCurDebit)
            {
                offSetAccount = true;

                offsetAcct = tmpledgerJournalTrans.parmOffsetAccount();

                select sum(AmountCurCredit),sum(AmountCurDebit) from tmpledgerJournalTrans
                    where tmpledgerJournalTrans.JournalNum      == _ledgerJournalTrans.JournalNum   &&
                          tmpledgerJournalTrans.Voucher         == _ledgerJournalTrans.Voucher      &&
                          (tmpledgerJournalTrans.AccountType    == LedgerJournalACType::Cust        ||
                          tmpledgerJournalTrans.AccountType     == LedgerJournalACType::Vend)       &&
                          !offsetAcct;

                        if (tmpledgerJournalTrans.AmountCurCredit && tmpledgerJournalTrans.AmountCurDebit && tmpledgerJournalTrans.AmountCurCredit == tmpledgerJournalTrans.AmountCurDebit)
                        {
                            offSetAccount = false;
                        }
            }
            else
            {
                offSetAccount = false;
            }
        }
        else
        {
            offSetAccount = true;
        }

        changecompany(_paymentCompany)
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

            if ((this.canCalculateTDS(_ledgerJournalTrans.AccountType,
                                                       _ledgerJournalTrans.OffsetAccountType,
                                                       _ledgerJournalTrans.AmountCurDebit,
                                                       _ledgerJournalTrans.AmountCurCredit,
                                                       _ledgerJournalTrans.parmAccount(),
                                                       _ledgerJournalTrans.parmOffsetAccount(),
                                                       _ledgerJournalTrans.ledgerJournalTable().JournalType,
                                                       _ledgerJournalTrans.OffsetLedgerDimension,
                                                       _ledgerJournalTrans.LedgerDimension)
                                                       && ledgerJournalTransTaxExt.tdsGroup && _ledgerJournalTrans.parmAccount() && offSetAccount)
                || (this.canCalculateTCS(_ledgerJournalTrans.AccountType,
                                                       _ledgerJournalTrans.OffsetAccountType,
                                                       _ledgerJournalTrans.AmountCurDebit,
                                                       _ledgerJournalTrans.AmountCurCredit,
                                                       _ledgerJournalTrans.parmAccount(),
                                                       _ledgerJournalTrans.parmOffsetAccount(),
                                                       _ledgerJournalTrans.ledgerJournalTable().JournalType,
                                                       _ledgerJournalTrans.OffsetLedgerDimension,
                                                       _ledgerJournalTrans.LedgerDimension)
                                                       && ledgerJournalTransTaxExt.tcsGroup && _ledgerJournalTrans.parmAccount() && offSetAccount))
            {
                canCalculateWHT = true;
            }

            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                if ((LedgerJournalTrans::isVendorPaymentWithTDSCalculation_IN(_ledgerJournalTrans)
                        && _ledgerJournalTrans.AmountCurDebit <= ledgerJournalTransTaxExt.ExcludedGSTAmountCur)
                    || (LedgerJournalTrans::isCustomerPaymentWithTDSCalculation_IN(_ledgerJournalTrans)
                        && _ledgerJournalTrans.AmountCurCredit <= ledgerJournalTransTaxExt.ExcludedGSTAmountCur))
                {
                    canCalculateWHT = false;
                }
            }
        }

        changecompany(_invoiceCompany)
        {
            taxWithholdParameter            = TaxWithholdParameters_IN::find();
            if (LedgerJournalACType::Vend == _ledgerJournalTrans.AccountType || LedgerJournalACType::Vend == _ledgerJournalTrans.OffsetAccountType)
            {
                vendTable                       = VendTable::find(_account, false);
                taxInformationVendTableLoc      = vendTable.getTaxInformationVendTable_IN();
                canCalculateWHTForInvoiceVend   = (vendTable && ((taxInformationVendTableLoc.TDSGroup && taxWithholdParameter.tdsPayment) ||(taxInformationVendTableLoc.TCSGroup && taxWithholdParameter.tcsPayment))
                                                   && vendTable.TaxWithholdCalculate) ? true : false;
            }

            if (LedgerJournalACType::Cust == _ledgerJournalTrans.AccountType || LedgerJournalACType::Cust == _ledgerJournalTrans.OffsetAccountType)
            {
                custTable                       = CustTable::find(_account, false);
                taxInformationCustTableLoc      = custTable.getTaxInformationCustTable_IN();
                canCalculateWHTForInvoiceCust   = (custTable && ((taxInformationCustTableLoc.TDSGroup && taxWithholdParameter.tdsPayment) ||(taxInformationCustTableLoc.TCSGroup && taxWithholdParameter.tcsPayment))
                                                   && custTable.TaxWithholdCalculate_IN) ? true : false;
            }
        }

        if (_invoiceCompany != curext())
        {
            isCrossCompany =  TaxWithholdParameters_IN::findByCompany(curext()).CrossCompanyPayment;
        }

        canCalculateWHT    = (isCrossCompany && canCalculateWHT && (canCalculateWHTForInvoiceVend || canCalculateWHTForInvoiceCust)) ? true : false;

        return canCalculateWHT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBankStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether it is advance payment and if payment amount is greater than attached invoice amount for the <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record being posted.
    /// </param>
    /// <returns>
    /// Returns true if it is advance payment and payment amount is greater than attached invoice amount; otherwise false.
    /// </returns>
    public boolean checkBankStatus(LedgerJournalTrans   _ledgerJournalTrans)
    {
        AmountCur           paymentAmount;
        AmountCur           invoiceAmount;
        AmountCur           indirectTaxAmount;
        SpecTrans           specTrans;
        CustVendTransOpen   custVendTransOpen;
        CustTransOpen       custTransOpen;
        VendTransOpen       vendTransOpen;
        boolean             bankStatus = false;

        switch (_ledgerJournalTrans.AccountType)
        {
            case LedgerJournalACType::Cust:
                custVendTransOpen = custTransOpen;
                break;

            case LedgerJournalACType::Vend:
                custVendTransOpen = vendTransOpen;
                break;

            default:
                break;
        }

        indirectTaxAmount = TaxUncommitted::getIndirectTaxAmtForWHTSourceBaseCur_IN(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId, _ledgerJournalTrans.TaxItemGroup);

        paymentAmount = (_ledgerJournalTrans.AmountCurDebit + _ledgerJournalTrans.AmountCurCredit + indirectTaxAmount);

        if ((_ledgerJournalTrans.AccountType         == LedgerJournalACType::Cust
            || _ledgerJournalTrans.AccountType       == LedgerJournalACType::Vend)
            && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank)
        {
            while select RefTableId, RefRecId, RefCompany from specTrans
                where specTrans.SpecRecId   == _ledgerJournalTrans.RecId
                    && specTrans.SpecTableId == _ledgerJournalTrans.TableId
            {
                changeCompany(specTrans.RefCompany)
                {
                    custVendTransOpen.clear();
                    select firstOnly TableId, RecId, AmountCur from custVendTransOpen
                        where custVendTransOpen.TableId == specTrans.RefTableId
                            && custVendTransOpen.RecId  == specTrans.RefRecId;

                    invoiceAmount += custVendTransOpen.AmountCur - this.calcCashDisc(custVendTransOpen.TableId,
                                                                                custVendTransOpen.RecId,
                                                                                _ledgerJournalTrans.TransDate);
                }
            }
        }

        if (paymentAmount > abs(invoiceAmount)
            && this.isAdvancePayment(_ledgerJournalTrans)
            && _ledgerJournalTrans.Company == _ledgerJournalTrans.OffsetCompany)
        {
            bankStatus = true;
        }

        return bankStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCalculateTaxWHT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the Withhold taxes is applicable for the account combination of LedgerJournalTrans.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The LedgerJournalTrans buffer.
    /// </param>
    /// <returns>
    /// Returns true, if withhold taxes are applicable otherwise, false.
    /// </returns>
    protected boolean checkCalculateTaxWHT(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxWithholdParameters_IN taxWithHoldParameters = TaxWithholdParameters_IN::find();
        boolean                  calculateTaxWithhold = false;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        if (_ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact)
        {
            if (ledgerJournalTransTaxExt.tdsGroup && taxWithholdParameters.tdsPayment)
            {
                calculateTaxWithhold = true;
            }

            if (ledgerJournalTransTaxExt.tcsGroup && taxWithholdParameters.tcsPayment)
            {
                    calculateTaxWithhold = true;
            }
        }
        else
        {
            if ((_ledgerJournalTrans.AccountType    == LedgerJournalACType::Vend  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.AmountCurDebit  > 0 && ledgerJournalTransTaxExt.tcsGroup)
                || (_ledgerJournalTrans.AccountType  == LedgerJournalACType::Bank  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend  && _ledgerJournalTrans.AmountCurCredit > 0 && ledgerJournalTransTaxExt.tcsGroup)
                ||(_ledgerJournalTrans.AccountType   == LedgerJournalACType::Bank  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust  && _ledgerJournalTrans.AmountCurDebit  > 0 && ledgerJournalTransTaxExt.tcsGroup)
                || (_ledgerJournalTrans.AccountType  == LedgerJournalACType::Cust  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.AmountCurCredit > 0 && ledgerJournalTransTaxExt.tcsGroup))
            {
                if (taxWithholdParameters.tcsPayment)
                {
                        calculateTaxWithhold = true;
                }
            }
            else if ((_ledgerJournalTrans.AccountType   == LedgerJournalACType::Vend  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.AmountCurDebit  > 0 && ledgerJournalTransTaxExt.tdsGroup)
                    || (_ledgerJournalTrans.AccountType  == LedgerJournalACType::Bank  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend  && _ledgerJournalTrans.AmountCurCredit > 0 && ledgerJournalTransTaxExt.tdsGroup)
                    ||(_ledgerJournalTrans.AccountType   == LedgerJournalACType::Bank  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust  && _ledgerJournalTrans.AmountCurCredit > 0 && ledgerJournalTransTaxExt.tdsGroup)
                    || (_ledgerJournalTrans.AccountType  == LedgerJournalACType::Cust  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.AmountCurDebit  > 0 && ledgerJournalTransTaxExt.tdsGroup))
            {
                if (taxWithholdParameters.tdsPayment)
                {
                        calculateTaxWithhold = true;
                }
            }
            else
            {
                if (ledgerJournalTransTaxExt.tdsGroup && taxWithholdParameters.tdsInvoice)
                {
                    calculateTaxWithhold = true;
                }
                if (ledgerJournalTransTaxExt.tcsGroup && taxWithholdParameters.tcsInvoice)
                {
                    calculateTaxWithhold = true;
                }
            }
        }

        return calculateTaxWithhold;
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeGrossAmountForCustJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// The methods gets the grossAmount for customer on which withhold tax must be calculated for specified journal Line.
    /// </summary>
    /// <param name="_tableId">
    /// Journal line tableId.
    /// </param>
    /// <param name="_recId">
    /// Journal line recid.
    /// </param>
    /// <param name="_taxWithholdGroup">
    /// TaxWithholdGroup is used for rate of reduction calculation.
    /// </param>
    /// <param name="_lineAmount">
    /// Journal line amount.
    /// </param>
    /// <param name="_transDate">
    /// Journal line transate.
    /// </param>
    /// <param name="_accountNum">
    /// Customer is used to find the <c>TaxWithholdTrans_IN</c> record.
    /// </param>
    /// <param name="_taxType">
    /// Used to find the <c>TaxWithholdTrans_IN</c> record.
    /// </param>
    /// <param name="_advancePayment">
    /// Used to check if journal is advance payment.
    /// </param>
    /// <param name="_isOnJewelry">
    /// whether it's on jewelry.
    /// </param>
    /// <param name="_isByCash">
    /// whether it's by cash.
    /// </param>
    /// <param name="_isSettled">
    /// whether it's settled already.
    /// </param>
    /// <returns>
    /// returns grossAmount on which withhold tax must be calculated.
    /// </returns>
    public AmountCur finalizeGrossAmountForCustJour(
        RefTableId           _tableId ,
        RefRecId             _recId ,
        TaxWithholdGroup     _taxWithholdGroup,
        AmountCur            _lineAmount,
        TransDate            _transDate,
        AccountNum           _accountNum,
        TaxWithholdCodeType_IN    _taxType,
        boolean              _advancePayment    = false,
        boolean              _isOnJewelry       = false,
        boolean              _isByCash          = false,
        boolean              _isSettled         = false)
    {
        SpecTrans               specTrans;
        CustTransOpen           custTransOpen;
        CustTrans               custTrans;
        TaxWithholdTrans_IN     taxWithholdTransLoc;
        AmountCur               lineRemainSettledAmountCur;
        AmountCur               specLineAmountCur;
        AmountCur               lineWHTSettledAmountCur = 0;
        AmountCur               finalGrossAmountCur;
        AmountCur               cashDisc;
        AmountCur               accumulatedCashDisc;
        real                    rateOfDeduction;
        TaxAmountCur            indirectTaxExcluded;
        CustInvoiceTrans        custInvoiceTrans;
        CustInvoiceJour         custInvoiceJour;

        AmountCur               accumulatedspecLineAmountCur = 0;
        boolean                 settledLinesforpayment = false;
        CurrencyExchangeHelper  exchangeRateHelper;

        real settlementFactor = 1;
        boolean isCustomerPaymentGTEforTDSCalculation_IN = false;
        LedgerJournalTrans ledgerJournalTrans;

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            ledgerJournalTrans = LedgerJournalTrans::findRecId(_recId, false);
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
            isCustomerPaymentGTEforTDSCalculation_IN = LedgerJournalTrans::isCustomerPaymentWithTDSCalculation_IN(ledgerJournalTrans);

            // Address credit customer only
            if (isCustomerPaymentGTEforTDSCalculation_IN && ledgerJournalTrans.AmountCurCredit)
            {
                _lineAmount -= ledgerJournalTransTaxExt.ExcludedGSTAmountCur;
            }
        }

        lineRemainSettledAmountCur = _lineAmount;
        exchangeRateHelper         = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
        exchangeRateHelper.parmExchangeRate1(exchRate);
        exchangeRateHelper.parmExchangeRate2(exchRateSecond);
        exchangeRateHelper.parmExchangeDate(_transDate);

        if (!TaxWithholdGroupHeading::find(_taxWithholdGroup).TaxLiabilityOnPayment_IN)
        {
            while select SpecRecId, SpecTableId, RefCompany, SpecCompany, RefTableId, RefRecId, Balance01 from specTrans
            where specTrans.SpecRecId   == _recId
                && specTrans.SpecTableId == _tableId
            {
                changeCompany(specTrans.RefCompany)
                {
                    custTransOpen.clear();
                    select firstOnly TableId, RecId, AmountCur, CashDiscDate, DueDate, RefRecId, AccountNum, TransDate, SettledTotalAmount_IN from custTransOpen
                    where custTransOpen.TableId == specTrans.RefTableId
                       && custTransOpen.RecId   == specTrans.RefRecId;

                    TaxWithholdTrans_IN taxWithholdTrans_IN;
                    LedgerJournalTrans ledgerJournalTransPrePay;
                    TaxWithholdDesignerTable_IN taxWithholdDesignerTable;

                    custTrans = CustTrans::find(custTransOpen.RefRecId);

                    select firstonly AdjustedBaseAmount from taxWithholdTrans_IN
                    join RecId, JournalNum, Voucher from ledgerJournalTransPrePay
                        where ledgerJournalTransPrePay.RecId == taxWithholdTrans_IN.SourceRecId
                            && ledgerJournalTransPrePay.Voucher == custTrans.Voucher
                            && ledgerJournalTransPrePay.TransDate == custTrans.TransDate
                            && taxWithholdTrans_IN.SourceTableId == tableNum(LedgerJournalTrans)
                    join RecId from taxWithholdDesignerTable
                        where taxWithholdDesignerTable.TaxWithholdGroup == taxWithholdTrans_IN.TaxWithholdGroup
                            && taxWithholdDesignerTable.TaxWithholdCode == taxWithholdTrans_IN.TaxWithholdCode
                            && taxWithholdDesignerTable.Basis           == TaxWithholdBasis_IN::GrossAmount;

                    if (taxWithholdTrans_IN.AdjustedBaseAmount != 0
                        && (!TaxWHTAdjustedBaseAmountFlight::instance().isEnabled() 
                            || LedgerJournalTrans::isCustomerPayment(ledgerJournalTransPrePay)))
                    {
                        specLineAmountCur = sign(custTransOpen.AmountCur) * taxWithholdTrans_IN.AdjustedBaseAmount;
                    }
                    else
                    {
                        specLineAmountCur = custTransOpen.AmountCur;
                    }

                    //user manually select lines to settle
                    if (custTransOpen.SettledTotalAmount_IN != 0)
                    {
                        settledLinesforpayment = true;
                    }

                    cashDisc = this.calcCashDisc(custTransOpen.TableId, custTransOpen.RecId, _transDate);
                    specLineAmountCur -= cashDisc;
                    accumulatedspecLineAmountCur += specLineAmountCur;

                    // <GTE>
                    if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && custTrans.AmountCur)
                    {
                        settlementFactor = abs(specTrans.Balance01) / abs(custTrans.AmountCur);
                    }
                    // </GTE>

                    taxWithholdTransLoc.clear();
                    select firstonly RecId from taxWithholdTransLoc
                    where taxWithholdTransLoc.Voucher               == custTrans.Voucher
                        && taxWithholdTransLoc.TransDate            == custTrans.TransDate
                        && taxWithholdTransLoc.CustAccount          == custTrans.AccountNum
                        && taxWithholdTransLoc.TaxType              == _taxType;

                    select firstOnly TaxItemGroup from custInvoiceTrans
                    join RecId from custInvoiceJour
                        where custInvoiceJour.SalesId               == custInvoiceTrans.SalesId
                                && custInvoiceJour.InvoiceId          == custInvoiceTrans.InvoiceId
                                && custInvoiceJour.InvoiceDate        == custInvoiceTrans.InvoiceDate
                                && custInvoiceJour.numberSequenceGroup == custInvoiceTrans.numberSequenceGroup
                                && custInvoiceJour.LedgerVoucher       == custTrans.Voucher
                                && custInvoiceJour.InvoiceAccount      == custTrans.AccountNum;

                    if (abs(lineRemainSettledAmountCur) > abs(specLineAmountCur))
                    {
                        if (taxWithholdTransLoc.RecId)
                        {
                            lineWHTSettledAmountCur += specLineAmountCur;
                        }
                        else
                        {
                            accumulatedCashDisc += cashDisc;
                            indirectTaxExcluded += TaxTrans::getIndirectTaxAmountExcludedforWHT_IN(custTrans.Voucher, custInvoiceTrans.TaxItemGroup, _taxWithholdGroup);

                            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
                            {
                                if (!(isCustomerPaymentGTEforTDSCalculation_IN && ledgerJournalTrans.AmountCurCredit))
                                {
                                    indirectTaxExcluded += TaxWithholdJournal_IN::getExcludedTaxAmountforGTE(custTrans, _taxWithholdGroup, settlementFactor);
                                }
                            }
                        }
                        lineRemainSettledAmountCur -= specLineAmountCur;
                    }
                    else
                    {
                        if (taxWithholdTransLoc.RecId)
                        {
                            lineWHTSettledAmountCur += lineRemainSettledAmountCur;
                        }
                        else
                        {
                            accumulatedCashDisc += cashDisc;

                            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
                            {
                                if (!(isCustomerPaymentGTEforTDSCalculation_IN && ledgerJournalTrans.AmountCurCredit))
                                {
                                    indirectTaxExcluded += TaxWithholdJournal_IN::getExcludedTaxAmountforGTE(custTrans, _taxWithholdGroup, settlementFactor);
                                }
                            }

                            indirectTaxExcluded += TaxTrans::getIndirectTaxAmountExcludedforWHT_IN(custTrans.Voucher, custInvoiceTrans.TaxItemGroup, _taxWithholdGroup);
                        }
                        lineRemainSettledAmountCur = 0;
                        break;
                    }
                }
            }

            if (settledLinesforpayment)
            {
                curTransWHTNotCalculatedBaseCur = _lineAmount - indirectTaxExcluded;
            }
            else if (_isOnJewelry && _isByCash && _isSettled)
            {
                //payment settled with invoices for jewelry
                curTransWHTNotCalculatedBaseCur = accumulatedspecLineAmountCur;
            }
            else
            {
                //default scenarios
                curTransWHTNotCalculatedBaseCur = _lineAmount - lineWHTSettledAmountCur + accumulatedCashDisc - indirectTaxExcluded;
            }
        }
        else
        {
            while select RefCompany, RefTableId, RefRecId, Balance01 from specTrans
                where specTrans.SpecRecId == _recId
                    && specTrans.SpecTableId == _tableId
            {
                changeCompany(specTrans.RefCompany)
                {
                    custTransOpen.clear();
                    select firstOnly AmountCur from custTransOpen
                        where custTransOpen.TableId == specTrans.RefTableId
                            && custTransOpen.RecId == specTrans.RefRecId
                        join custTrans
                            where custTrans.RecId == custTransOpen.RefRecId;

                    select firstOnly TaxItemGroup from custInvoiceTrans
                        join RecId from custInvoiceJour
                            where custInvoiceJour.SalesId == custInvoiceTrans.SalesId
                                && custInvoiceJour.InvoiceId == custInvoiceTrans.InvoiceId
                                && custInvoiceJour.InvoiceDate == custInvoiceTrans.InvoiceDate
                                && custInvoiceJour.numberSequenceGroup == custInvoiceTrans.numberSequenceGroup
                                && custInvoiceJour.LedgerVoucher == custTrans.Voucher
                                && custInvoiceJour.InvoiceAccount == custTrans.AccountNum;

                    // <GTE>
                    if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && custTrans.AmountCur)
                    {
                        settlementFactor = abs(specTrans.Balance01 / custTrans.AmountCur);

                        indirectTaxExcluded += TaxWithholdJournal_IN::getExcludedTaxAmountforGTE(custTrans, _taxWithholdGroup, settlementFactor);
                    }
                    // </GTE>

                    indirectTaxExcluded += TaxTrans::getIndirectTaxAmountExcludedforWHT_IN(custTrans.Voucher, custInvoiceTrans.TaxItemGroup, _taxWithholdGroup);
                }

            }

            curTransWHTNotCalculatedBaseCur = _lineAmount - indirectTaxExcluded;
        }

        if (_advancePayment)
        {
            rateOfDeduction         = this.rateOfDeductionForThresholdBasedOnPaym(_taxWithholdGroup,
                                        _transDate,
                                        _accountNum,
                                        false,
                                        exchangeRateHelper.calculateTransactionToAccounting(sourceCurrencyCode, _lineAmount, true),
                                        _tableId,
                                        _recId);

            if (FeatureStateProvider::isFeatureEnabled(TaxWithholdCustomerThresholdBasedOnPaymentOnlyFeature::instance())
                && TaxWithholdGroupHeading::find(_taxWithholdGroup).TaxLiabilityOnPayment_IN)
            {
                finalGrossAmountCur = curTransWHTNotCalculatedBaseCur * 100/(100 + rateOfDeduction);
            }
            else
            {
                finalGrossAmountCur = LineRemainSettledAmountCur * 100/(100 + rateOfDeduction) + (curTransWHTNotCalculatedBaseCur - lineRemainSettledAmountCur);
            }
        }
        else
        {
            finalGrossAmountCur = curTransWHTNotCalculatedBaseCur;
        }

        return finalGrossAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeGrossAmountForVendJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// The methods gets the grossAmount for vendor on which withhold tax must be calculated for specified journal Line.
    /// </summary>
    /// <param name="_tableId">
    /// Journal line tableId.
    /// </param>
    /// <param name="_recId">
    /// Journal line recid.
    /// </param>
    /// <param name="_taxWithholdGroup">
    /// TaxWithholdGroup is used for rate of reduction calculation.
    /// </param>
    /// <param name="_lineAmount">
    /// Journal line amount.
    /// </param>
    /// <param name="_transDate">
    /// Journal line transate.
    /// </param>
    /// <param name="_accountNum">
    /// Vendor is used to find the <c>TaxWithholdTrans_IN</c> record.
    /// </param>
    /// <param name="_taxType">
    /// Used to find the <c>TaxWithholdTrans_IN</c> record.
    /// </param>
    /// <param name="_advancePayment">
    /// Used to check if journal is advance payment.
    /// </param>
    /// <returns>
    /// returns grossAmount on which withhold tax must be calculated.
    /// </returns>
    public AmountCur finalizeGrossAmountForVendJour(
        RefTableId           _tableId ,
        RefRecId             _recId ,
        TaxWithholdGroup     _taxWithholdGroup,
        AmountCur            _lineAmount,
        TransDate            _transDate,
        AccountNum           _accountNum,
        TaxWithholdCodeType_IN    _taxType,
        boolean              _advancePayment = false)
    {
        SpecTrans               specTrans;
        VendTransOpen           vendTransOpen;
        VendTrans               vendTrans;
        TaxWithholdTrans_IN     taxWithholdTransloc;
        AmountCur               lineRemainSettledAmountCur;
        AmountCur               specLineAmountCur;
        AmountCur               lineWHTSettledAmountCur = 0;
        AmountCur               finalGrossAmountCur;
        AmountCur               cashDisc;
        AmountCur               accumulatedCashDisc;
        real                    rateOfDeduction;
        CurrencyExchangeHelper  exchangeRateHelper;
        LedgerJournalVoucherChanged ledgerJourVoucherChanged;
        Voucher                     localVoucher;
        TaxAmountCur                indirectTaxExcluded;
        VendInvoiceTrans            vendInvoiceTrans;
        VendInvoiceJour             vendInvoiceJour;

        // <GTE>
        real                        settlementFactor = 1;
        boolean                     isVendorPaymentGTEforTDSCalculation_IN = false;

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::findRecId(_recId, false);
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
            isVendorPaymentGTEforTDSCalculation_IN = LedgerJournalTrans::isVendorPaymentWithTDSCalculation_IN(ledgerJournalTrans);

            if (isVendorPaymentGTEforTDSCalculation_IN)
            {
                _lineAmount -= ledgerJournalTransTaxExt.ExcludedGSTAmountCur;
            }
        }
        //GTE
       
        lineRemainSettledAmountCur = _lineAmount;
            
        exchangeRateHelper         = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
        exchangeRateHelper.parmExchangeRate1(exchRate);
        exchangeRateHelper.parmExchangeRate2(exchRateSecond);
        exchangeRateHelper.parmExchangeDate(_transDate);

        while select SpecRecId, SpecTableId, RefCompany, RefTableId, RefRecId, Balance01 from specTrans
            where specTrans.SpecRecId   == _recId
               && specTrans.SpecTableId == _tableId
        {
            changeCompany(specTrans.RefCompany)
            {
                vendTransOpen.clear();
                select firstOnly AmountCur, CashDiscDate, DueDate, RecId, RefRecId, AccountNum, TransDate, TableId from vendTransOpen
                    where vendTransOpen.TableId    == specTrans.RefTableId
                       && vendTransOpen.RecId      == specTrans.RefRecId;

                cashDisc = this.calcCashDisc(vendTransOpen.TableId, vendTransOpen.RecId, _transDate);

                TaxWithholdTrans_IN taxWithholdTrans_IN;
                LedgerJournalTrans ledgerJournalTransPrePay;
                TaxWithholdDesignerTable_IN taxWithholdDesignerTable;

                vendTrans = vendTrans::find(vendTransOpen.RefRecId);

                select firstonly AdjustedBaseAmount from taxWithholdTrans_IN
                    join RecId, JournalNum, Voucher from ledgerJournalTransPrePay
                        where ledgerJournalTransPrePay.RecId == taxWithholdTrans_IN.SourceRecId
                            && ledgerJournalTransPrePay.Voucher == vendTrans.Voucher
                            && ledgerJournalTransPrePay.TransDate == vendTrans.TransDate
                            && taxWithholdTrans_IN.SourceTableId == tableNum(LedgerJournalTrans)
                    join RecId from taxWithholdDesignerTable
                        where taxWithholdDesignerTable.TaxWithholdGroup == taxWithholdTrans_IN.TaxWithholdGroup
                            && taxWithholdDesignerTable.TaxWithholdCode == taxWithholdTrans_IN.TaxWithholdCode
                            && taxWithholdDesignerTable.Basis           == TaxWithholdBasis_IN::GrossAmount;

                if (taxWithholdTrans_IN.AdjustedBaseAmount != 0
                    && (!TaxWHTAdjustedBaseAmountFlight::instance().isEnabled() 
                        || LedgerJournalTrans::isVendorPayment(ledgerJournalTransPrePay)))
                {
                    specLineAmountCur = taxWithholdTrans_IN.AdjustedBaseAmount;
                }
                else
                {
                    specLineAmountCur = specTrans.Balance01;
                }

                // <GTE>
                if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && vendTrans.AmountCur)
                {
                    settlementFactor = abs(specLineAmountCur) / abs(vendTrans.AmountCur);
                }
                // </GTE>

                //vendTrans is having new voucher to get old voucher; find "LedgerJournalVoucherChanged" using vendTrans.voucher
                select firstOnly FromVoucher from ledgerJourVoucherChanged
                        where ledgerJourVoucherChanged.ToVoucher == vendTrans.Voucher;
        
                if (ledgerJourVoucherChanged.FromVoucher != '')
                {
                    localVoucher = ledgerJourVoucherChanged.FromVoucher;
                }
                else
                {
                    localVoucher = vendTrans.Voucher;
                }

                taxWithholdTransloc.clear();
                select firstonly RecId from taxWithholdTransLoc
                    where taxWithholdTransLoc.Voucher               == localVoucher
                        && taxWithholdTransLoc.TransDate            == vendTrans.TransDate
                        && taxWithholdTransLoc.vendAccount          == vendTrans.AccountNum
                        && taxWithholdTransLoc.TaxType              == _taxType;
                
                select firstOnly TaxItemGroup from vendInvoiceTrans
                    join RecId from vendInvoiceJour
                        where vendInvoiceJour.PurchId                   == vendInvoiceTrans.PurchID
                              && vendInvoiceJour.InvoiceId              == vendInvoiceTrans.InvoiceId
                              && vendInvoiceJour.InvoiceDate            == vendInvoiceTrans.InvoiceDate
                              && vendInvoiceJour.numberSequenceGroup    == vendInvoiceTrans.numberSequenceGroup
                              && vendInvoiceJour.LedgerVoucher          == localVoucher
                              && vendInvoiceJour.InvoiceAccount         == vendTrans.AccountNum;

                if (abs(lineRemainSettledAmountCur) > abs(specLineAmountCur))
                {
                    if (taxWithholdTransLoc.RecId)
                    {
                        lineWHTSettledAmountCur += specLineAmountCur;
                    }
                    else
                    {
                        accumulatedCashDisc += cashDisc;
                        indirectTaxExcluded += TaxTrans::getIndirectTaxAmountExcludedforWHT_IN(vendTrans.Voucher, vendInvoiceTrans.TaxItemGroup, _taxWithholdGroup);

                        // <GTE>
                        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
                        {
                            if (!isVendorPaymentGTEforTDSCalculation_IN)
                            {
                                indirectTaxExcluded += TaxWithholdJournal_IN::getExcludedTaxAmountforGTE(vendTrans, _taxWithholdGroup, settlementFactor);
                            }
                        }
                        // </GTE>
                    }
                    lineRemainSettledAmountCur += specLineAmountCur;
                }
                else
                {
                    if (taxWithholdTransLoc.RecId)
                    {
                        lineWHTSettledAmountCur -= lineRemainSettledAmountCur;
                    }
                    else
                    {
                        accumulatedCashDisc += cashDisc;
                        indirectTaxExcluded += TaxTrans::getIndirectTaxAmountExcludedforWHT_IN(vendTrans.Voucher, vendInvoiceTrans.TaxItemGroup, _taxWithholdGroup);

                        // <GTE>
                        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
                        {
                            if (!isVendorPaymentGTEforTDSCalculation_IN)
                            {
                                indirectTaxExcluded += TaxWithholdJournal_IN::getExcludedTaxAmountforGTE(vendTrans, _taxWithholdGroup, settlementFactor);
                            }
                        }
                        // </GTE>
                    }
                    lineRemainSettledAmountCur = 0;
                    break;
                }
            }
        }
        curTransWHTNotCalculatedBaseCur = _lineAmount + lineWHTSettledAmountCur - accumulatedCashDisc - indirectTaxExcluded;
        if (_advancePayment)
        {
            rateOfDeduction     = this.rateOfDeductionForThresholdBasedOnPaym(_taxWithholdGroup,
                                    _transDate,
                                    _accountNum,
                                    true,
                                    exchangeRateHelper.calculateTransactionToAccounting(sourceCurrencyCode, _lineAmount, true),
                                    _tableId,
                                    _recId);
            finalGrossAmountCur = LineRemainSettledAmountCur * 100/(100 + rateOfDeduction) + (curTransWHTNotCalculatedBaseCur - lineRemainSettledAmountCur);
        }
        else
        {
            finalGrossAmountCur = curTransWHTNotCalculatedBaseCur;
        }

        return finalGrossAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTransTotalExcludedGSTAmountforGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets totally excluded GST amount for GTE, if the journal is customer or vendor payment for TDS calculation.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The buffer of the <c>LedgerJournalTrans</c> </param>
    /// <returns>AmountCur of the excluded GST amount.</returns>
    internal static Amountcur getCustVendTransTotalExcludedGSTAmountforGTE(LedgerJournalTrans _ledgerJournalTrans)
    {
        SpecTrans specTrans;
        CustTransOpen custTransOpen;
        VendTransOpen vendTransOpen;
        CustVendTrans custVendTrans;
        TaxWithholdTrans_IN taxWithholdTransloc;
        AmountCur lineRemainSettledAmountCur;
        AmountCur specLineAmountCur;
        AmountCur lineWHTSettledAmountCur = 0;
        LedgerJournalVoucherChanged ledgerJourVoucherChanged;
        Voucher localVoucher;
        TaxAmountCur taxExcluded;
        TaxAmountCur taxExcludedVendTransCur;
        TaxWithholdCodeType_IN taxWithholdType;
        TaxWithholdGroup taxWithholdGroup;
        real settlementFactor = 1;
        boolean isChangedCurrencyCode;

        CurrencyExchangeHelper helper = CurrencyExchangeHelper::construct();

        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtensionIN = LedgerJournalTransTaxExtensionIN::findByLedgerJournalTrans(_ledgerJournalTrans.RecId);

        boolean isVendTransaction = _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend;
        boolean isCustTransaction = _ledgerJournalTrans.AccountType == LedgerJournalACType::Cust || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust;

        if (ledgerJournalTransTaxExtensionIN.TDSGroup &&
            ((isVendTransaction && _ledgerJournalTrans.AmountCurDebit)
                || (isCustTransaction && _ledgerJournalTrans.AmountCurCredit)))
        {
            taxWithholdType = TaxWithholdCodeType_IN::TDS;
            taxWithholdGroup = ledgerJournalTransTaxExtensionIN.TDSGroup;
            lineRemainSettledAmountCur = isVendTransaction ? _ledgerJournalTrans.AmountCurDebit : _ledgerJournalTrans.AmountCurCredit;
        }
        else
        {
            return 0;
        }

        while select SpecRecId, SpecTableId, RefCompany, RefTableId, RefRecId, Balance01 from specTrans
            where specTrans.SpecRecId == _ledgerJournalTrans.RecId
               && specTrans.SpecTableId == _ledgerJournalTrans.TableId
               && specTrans.SpecCompany == _ledgerJournalTrans.DataAreaId
        {
            changeCompany(specTrans.RefCompany)
            {
                isChangedCurrencyCode = false;

                switch (specTrans.RefTableId)
                {
                    case tableNum(CustTransOpen) :
                        custTransOpen.clear();
                        select firstOnly AmountCur, RefRecId from custTransOpen
                            where custTransOpen.TableId == specTrans.RefTableId
                               && custTransOpen.RecId == specTrans.RefRecId;
                        custVendTrans = CustTrans::find(custTransOpen.RefRecId);
                        break;

                    case tableNum(VendTransOpen) :
                        vendTransOpen.clear();
                        select firstOnly AmountCur, RefRecId from vendTransOpen
                            where vendTransOpen.TableId == specTrans.RefTableId
                               && vendTransOpen.RecId   == specTrans.RefRecId;
                        custVendTrans = VendTrans::find(vendTransOpen.RefRecId);
                        break;

                    default :
                        break;
                }

                specLineAmountCur = specTrans.Balance01;

                if (custVendTrans.CurrencyCode != _ledgerJournalTrans.CurrencyCode)
                {
                    isChangedCurrencyCode = true;
                    lineRemainSettledAmountCur = helper.calculateCurrencyToCurrency(_ledgerJournalTrans.CurrencyCode, custVendTrans.CurrencyCode, lineRemainSettledAmountCur, true);
                }

                if (custTransOpen.AmountCur || vendTransOpen.AmountCur)
                {
                    if (lineRemainSettledAmountCur - abs(specLineAmountCur) >= 0)
                    {
                        settlementFactor = abs(specLineAmountCur) / abs(custVendTrans.AmountCur);
                    }
                    else
                    {
                        settlementFactor = abs(lineRemainSettledAmountCur) / abs(custVendTrans.AmountCur);
                    }
                }

                // CustVendTrans is having new voucher to get old voucher; find "LedgerJournalVoucherChanged" using custVendTrans.voucher
                select firstOnly FromVoucher from ledgerJourVoucherChanged
                    where ledgerJourVoucherChanged.ToVoucher == custVendTrans.Voucher;

                if (ledgerJourVoucherChanged.FromVoucher != '')
                {
                    localVoucher = ledgerJourVoucherChanged.FromVoucher;
                }
                else
                {
                    localVoucher = custVendTrans.Voucher;
                }

                taxWithholdTransloc.clear();
                select firstonly RecId from taxWithholdTransLoc
                    where taxWithholdTransLoc.Voucher == localVoucher
                        && taxWithholdTransLoc.TransDate == custVendTrans.TransDate
                        && taxWithholdTransLoc.vendAccount == custVendTrans.AccountNum
                        && taxWithholdTransLoc.TaxType == taxWithholdType;

                if (abs(lineRemainSettledAmountCur) > abs(specLineAmountCur))
                {
                    if (taxWithholdTransLoc.RecId)
                    {
                        lineWHTSettledAmountCur += specLineAmountCur;
                    }
                    else
                    {
                        if (isChangedCurrencyCode)
                        {
                            taxExcludedVendTransCur = TaxWithholdJournal_IN::getExcludedTaxAmountforGTE(custVendTrans, taxWithholdGroup, settlementFactor);
                            taxExcluded += helper.calculateCurrencyToCurrency(custVendTrans.CurrencyCode, _ledgerJournalTrans.CurrencyCode, taxExcludedVendTransCur, true);
                        }
                        else
                        {
                            taxExcluded += TaxWithholdJournal_IN::getExcludedTaxAmountforGTE(custVendTrans, taxWithholdGroup, settlementFactor);
                        }
                    }

                    lineRemainSettledAmountCur += specLineAmountCur;
                    if (isChangedCurrencyCode)
                    {
                        lineRemainSettledAmountCur = helper.calculateCurrencyToCurrency(custVendTrans.CurrencyCode, _ledgerJournalTrans.CurrencyCode, lineRemainSettledAmountCur, true);
                    }
                }
                else
                {
                    if (taxWithholdTransLoc.RecId)
                    {
                        lineWHTSettledAmountCur -= lineRemainSettledAmountCur;
                    }
                    else
                    {
                        if (isChangedCurrencyCode)
                        {
                            taxExcludedVendTransCur = TaxWithholdJournal_IN::getExcludedTaxAmountforGTE(custVendTrans, taxWithholdGroup, settlementFactor);
                            taxExcluded += helper.calculateCurrencyToCurrency(custVendTrans.CurrencyCode, _ledgerJournalTrans.CurrencyCode, taxExcludedVendTransCur, true);
                        }
                        else
                        {
                            taxExcluded += TaxWithholdJournal_IN::getExcludedTaxAmountforGTE(custVendTrans, taxWithholdGroup, settlementFactor);
                        }
                    }

                    lineRemainSettledAmountCur = 0;
                    break;
                }
            }
        }

        return taxExcluded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCPGrossAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets finalized gross amount, remaining amount per invoice for centralized payment.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// Given <c>LedgerJournalTrans</c> buffer.
    /// </param>
    /// <param name="_specTrans">
    /// Given <c>SpecTrans</c> buffer.
    /// </param>
    /// <param name="_grossAmount">
    /// Initialized gross amount.
    /// </param>
    /// <returns>
    /// Container with finalized gross amount, remaining amount and reference transaction record Id.
    /// </returns>
    protected container getCPGrossAmountCur(
        LedgerJournalTrans  _ledgerJournalTrans,
        SpecTrans           _specTrans,
        AmountCur           _grossAmount)
    {
        VendTrans               vendTrans;
        CustTrans               custTrans;
        CustVendTrans           custVendTrans;

        VendTransOpen           vendTransOpen;
        CustTransOpen           custTransOpen;
        CustVendTransOpen       custVendTransOpen;

        RefRecId                cpOrigRefRecId;
        AmountCur               lineGrossAmount;
        AmountCur               remainTotalAmount;
        AmountCur               specLineAmountCur;
        AmountCur               lineRemainSettledAmountCur;
        AmountCur               finalGrossAmountCur;
        AmountCur               lineWHTSettledAmountCur = 0;
        TaxWithholdTrans_IN     taxWithholdTransLoc;
        TaxWithholdCodeType_IN  taxWithholdType;
        AmountCur               cashDiscCur;
        AmountCur               accumulatedCashDiscCur;
        int                     sign;

        taxWithholdType = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN().TDSGroup ? TaxWithholdCodeType_IN::TDS : TaxWithholdCodeType_IN::TCS;
        remainTotalAmount = _grossAmount;

        changeCompany(_specTrans.RefCompany)
        {
            lineGrossAmount = abs(_specTrans.Balance01);

            if (lineGrossAmount < remainTotalAmount)
            {
                remainTotalAmount -= lineGrossAmount;
                lineRemainSettledAmountCur = lineGrossAmount;
            }
            else
            {
                lineRemainSettledAmountCur = remainTotalAmount;
                lineGrossAmount = remainTotalAmount;
                remainTotalAmount = 0;
            }

            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust
                || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
            {
                custVendTrans = custTrans;
                custVendTransOpen = custTransOpen;
                sign = 1;
            }
            else
            {
                custVendTrans = vendTrans;
                custVendTransOpen = vendTransOpen;
                sign = -1;
            }

            custVendTransOpen.clear();
            select firstOnly AmountCur, TableId, RecId, RefRecId from custVendTransOpen
                where custVendTransOpen.TableId == _specTrans.RefTableId
                    && custVendTransOpen.RecId  == _specTrans.RefRecId;

            cashDiscCur = this.calcCashDisc(custVendTransOpen.TableId, custVendTransOpen.RecId, _ledgerJournalTrans.TransDate);
            specLineAmountCur = custVendTransOpen.AmountCur - cashDiscCur;

            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust
                || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
            {
                custVendTrans = CustTrans::find(custVendTransOpen.RefRecId);
            }
            else
            {
                custVendTrans = VendTrans::find(custVendTransOpen.RefRecId);
            }

            taxWithholdTransLoc.clear();
            select firstonly RecId, TaxWithholdCalculated from taxWithholdTransLoc
                where taxWithholdTransLoc.Voucher              == custVendTrans.Voucher
                    && taxWithholdTransLoc.TransDate           == custVendTrans.TransDate
                    && (taxWithholdTransLoc.CustAccount         == custVendTrans.AccountNum
                        || taxWithholdTransLoc.VendAccount      == custVendTrans.AccountNum)
                    && taxWithholdTransLoc.TaxType             == taxWithholdType;

            if (abs(lineRemainSettledAmountCur) > abs(specLineAmountCur))
            {
                if (taxWithholdTransLoc.RecId)
                {
                    lineWHTSettledAmountCur = specLineAmountCur;
                }
                else
                {
                    accumulatedCashDiscCur += cashDiscCur;
                }
                lineRemainSettledAmountCur -= specLineAmountCur * sign;
            }
            else
            {
                if (taxWithholdTransLoc.RecId)
                {
                    lineWHTSettledAmountCur = lineRemainSettledAmountCur * sign;
                }
                else
                {
                    accumulatedCashDiscCur += cashDiscCur;
                }
                lineRemainSettledAmountCur = 0;
            }

            finalGrossAmountCur = lineGrossAmount - lineWHTSettledAmountCur * sign + accumulatedCashDiscCur * sign;
            cpOrigRefRecId = custVendTrans.RecId;
        }

        return [abs(finalGrossAmountCur), remainTotalAmount, cpOrigRefRecId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGrossAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the gross amount.
    /// </summary>
    /// <param name="_line">
    /// The line information.
    /// </param>
    /// <param name="_isOnJewelry">
    /// whether it's on jewelry.
    /// </param>
    /// <param name="_isByCash">
    /// whether it's by cash.
    /// </param>
    /// <param name="_isSettled">
    /// whether it's settled already.
    /// </param>
    /// <returns>
    /// The instance of the <c>AmountCur</c> class.
    /// </returns>
    protected AmountCur getGrossAmount(Common _line, boolean _isOnJewelry = false, boolean _isByCash = false, boolean _isSettled = false)
    {
        LedgerJournalTrans      tmpledgerJournalTrans;
        AmountCur               indirectTaxAmount;
        AmountCur               grossAmount;
        AmountCur               taxCalculatedPaymentCur;
        TaxWithholdGroup        taxWithholdGroup;
        AccountNum              accountNumloc;
        TaxWithholdCodeType_IN  taxWithholdType;
        boolean                 isAdvancePayment;
        // <GTE>
        AmountCur               lineAmount;
        ITaxDocumentLine        taxDocumentLine;
        TaxWithholdGroupHeading taxWithholdGroupHeading;
        ITaxableDocument        taxableDocument;
        ITaxDocument            taxDocument;
        AmountCur               totalGTETaxAmount;

        Map includeTaxComponentsMap = new Map(Types::String, Types::Container);
        // </GTE>

        tmpledgerJournalTrans = _line as LedgerJournalTrans;

        sourceCurrencyCode    = tmpledgerJournalTrans.CurrencyCode;
        exchRate              = tmpledgerJournalTrans.ExchRate;
        exchRateSecond        = tmpledgerJournalTrans.ExchRateSecond;

        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = tmpledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        taxWithholdGroup = ledgerJournalTransTaxExt.TDSGroup ? ledgerJournalTransTaxExt.TDSGroup : ledgerJournalTransTaxExt.TCSGroup;

        indirectTaxAmount = TaxUncommitted::getIndirectTaxAmtForWHTSourceBaseCur_IN(tmpledgerJournalTrans.TableId,
                                                                                    tmpledgerJournalTrans.RecId,
                                                                                    tmpledgerJournalTrans.TaxItemGroup,
                                                                                    (tmpledgerJournalTrans.AccountType == LedgerJournalACType::Vend) ? tmpledgerJournalTrans.parmAccount()
                                                                                                        : tmpledgerJournalTrans.parmOffsetAccount(),
                                                                                    taxWithholdGroup);

        if (!tmpledgerJournalTrans.isGTAVendorAccount_IN() && tmpledgerJournalTrans.isPaymentJournal_IN())
        {
            indirectTaxAmount -= TaxUncommitted::getServiceTaxAmtForWHTSourceBaseCur_IN(tmpledgerJournalTrans.TableId, tmpledgerJournalTrans.RecId, tmpledgerJournalTrans.TaxItemGroup);
        }

        lineAmount = tmpledgerJournalTrans.AmountCurDebit + tmpledgerJournalTrans.AmountCurCredit;

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {            
            taxWithholdGroupHeading = TaxWithholdGroupHeading::find(taxWithholdGroup);
        
            taxableDocument = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(tmpledgerJournalTrans));
            taxDocument = TaxBusinessService::calculateTax(taxableDocument);
            if (taxDocument)
            {
                taxDocumentLine = taxDocument.findLineBySource(tmpledgerJournalTrans.TableId, tmpledgerJournalTrans.RecId);
                if (taxDocumentLine)
                {
                    if (taxDocumentLine.priceInclTax())
                    {
                        totalGTETaxAmount = taxDocumentLine.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Credit).amountTransactionCurrency();
                        totalGTETaxAmount -= taxDocumentLine.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Debit).amountTransactionCurrency();

                        if (TaxEngineEREnumToEnumUtil::taxDirectionEnum(taxDocumentLine.getFieldValue(TaxEngineModelFrameworkFieldsConstants::TaxDirection)) == TaxDirection::OutgoingTax)
                        {
                            totalGTETaxAmount = -totalGTETaxAmount;
                        }

                        lineAmount -= totalGTETaxAmount;
                    }

                    includeTaxComponentsMap = TaxWithholdIncIndirectTaxComponentsUtil::getIncTaxComponentsForWithholdGroup(taxWithholdGroupHeading.RecId);
                    indirectTaxAmount = taxDocumentLine.getTaxAmountByComponentsAndProvider(includeTaxComponentsMap, TaxAccountingProvider::Party);
                    if (TaxEngineEREnumToEnumUtil::taxDirectionEnum(taxDocumentLine.getFieldValue(TaxEngineModelFrameworkFieldsConstants::TaxDirection)) == TaxDirection::IncomingTax)
                    {
                        indirectTaxAmount = -indirectTaxAmount;
                    }
                }

                // For multiple single side entries of cust or vend journal, sum indirect tax on ledger lines
                if (tmpledgerJournalTrans.AccountType == LedgerJournalACType::Cust || tmpledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                {
                    LedgerJournalTrans relatedTrans;
                    while select RecId from relatedTrans
                        where relatedTrans.JournalNum == tmpledgerJournalTrans.JournalNum
                            && relatedTrans.Voucher == tmpledgerJournalTrans.Voucher
                            && relatedTrans.RecId != tmpledgerJournalTrans.RecId
                    {
                        ITaxDocumentLine relatedTaxDocLine = taxDocument.findLineBySource(relatedTrans.TableId, relatedTrans.RecId);
                        if (relatedTaxDocLine)
                        {
                            if (relatedTaxDocLine.priceInclTax())
                            {
                                var relatedTaxTotal = this.getTotalIndirectTaxAmount(relatedTaxDocLine);
                                lineAmount -= relatedTaxTotal;
                            }
                            var relatedIndirectTaxAmount = this.getIndirectTaxAmount(relatedTaxDocLine, taxWithholdGroupHeading);
                            indirectTaxAmount += relatedIndirectTaxAmount;
                        }
                    }
                }
            }
        }
        // </GTE>
        
        grossAmount = (lineAmount + indirectTaxAmount);

        if (this.isSettledTrans(tmpledgerJournalTrans))
        {
            taxWithholdIN.getTransactionAmount((grossAmount * 100)/(this.rateOfDeductionForThresholdBasedOnPaym(taxWithholdGroup ,DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), '', false, 0, _line.TableId, _line.RecId) + 100));
        }
        else
        {
            taxWithholdIN.getTransactionAmount(grossAmount);
        }

        taxWithholdType = ledgerJournalTransTaxExt.TDSGroup ? TaxWithholdCodeType_IN::TDS : TaxWithholdCodeType_IN::TCS;

        isAdvancePayment = this.isAdvancePayment(tmpledgerJournalTrans);

        if (tmpledgerJournalTrans.AccountType == LedgerJournalACType::Cust || tmpledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
        {
            if (tmpledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                accountNumloc = tmpledgerJournalTrans.parmAccount();
            }

            // This code is for the sign of Invioce Amount and settlement Amount should be different.
            if (tmpledgerJournalTrans.SettleVoucher  == SettlementType::SelectedTransact
                && tmpledgerJournalTrans.AccountType == LedgerJournalACType::Cust
                && tmpledgerJournalTrans.AmountCurDebit > 0)
            {
                grossAmount = -grossAmount;
            }

            taxCalculatedPaymentCur = this.finalizeGrossAmountForCustJour(tmpledgerJournalTrans.TableId,
                                                                                 tmpledgerJournalTrans.RecId,
                                                                                 taxWithholdGroup,
                                                                                 grossAmount,
                                                                                 tmpledgerJournalTrans.TransDate,
                                                                                 accountNumloc,
                                                                                 taxWithholdType,
                                                                                 isAdvancePayment,
                                                                                 _isOnJewelry,
                                                                                 _isByCash,
                                                                                 _isSettled);
            grossAmount = abs(taxCalculatedPaymentCur);
        }
        else
        {
            if (tmpledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                accountNumloc = tmpledgerJournalTrans.parmAccount();
            }

            // This code will execute when post payment journal and settle the payment by selecting thru AP invoice journal.
            if (tmpledgerJournalTrans.SettleVoucher  == SettlementType::SelectedTransact
                && tmpledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                && tmpledgerJournalTrans.AmountCurCredit > 0)
            {
                grossAmount = -grossAmount;
            }

            taxCalculatedPaymentCur = this.finalizeGrossAmountForVendJour(tmpledgerJournalTrans.TableId,
                                                                               tmpledgerJournalTrans.RecId,
                                                                               taxWithholdGroup,
                                                                               grossAmount,
                                                                               tmpledgerJournalTrans.TransDate,
                                                                               accountNumloc,
                                                                               taxWithholdType,
                                                                               isAdvancePayment);
            grossAmount = abs(taxCalculatedPaymentCur);
        }

        return grossAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalIndirectTaxAmount</Name>
				<Source><![CDATA[
    private AmountCur getTotalIndirectTaxAmount(ITaxDocumentLine _taxDocLine)
    {
        AmountCur totalTaxAmount = _taxDocLine.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Credit).amountTransactionCurrency();
        totalTaxAmount -= _taxDocLine.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Debit).amountTransactionCurrency();

        if (TaxEngineEREnumToEnumUtil::taxDirectionEnum(_taxDocLine.getFieldValue(TaxEngineModelFrameworkFieldsConstants::TaxDirection)) == TaxDirection::OutgoingTax)
        {
            totalTaxAmount = -totalTaxAmount;
        }
        
        return totalTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIndirectTaxAmount</Name>
				<Source><![CDATA[
    private AmountCur getIndirectTaxAmount(ITaxDocumentLine _taxDocLine, TaxWithholdGroupHeading taxWithholdGroupHeading)
    {
        Map includeTaxComponentsMap = TaxWithholdIncIndirectTaxComponentsUtil::getIncTaxComponentsForWithholdGroup(taxWithholdGroupHeading.RecId);
        AmountCur indirectTaxAmount = _taxDocLine.getTaxAmountByComponentsAndProvider(includeTaxComponentsMap, TaxAccountingProvider::Party);
        if (TaxEngineEREnumToEnumUtil::taxDirectionEnum(_taxDocLine.getFieldValue(TaxEngineModelFrameworkFieldsConstants::TaxDirection)) == TaxDirection::IncomingTax)
        {
            indirectTaxAmount = -indirectTaxAmount;
        }

        return indirectTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIndirectTaxAmountExcludforGTE</Name>
				<Source><![CDATA[
    // <GTE>
    public static TaxAmountCur getIndirectTaxAmountExcludforGTE(
        CustVendInvoiceJour  _custVendInvoiceJour,
        TaxWithholdGroup     _taxWithholdGroup,
        real                 _factor)
    {
        AmountCur                   taxWithholdBaseFromIndirectTaxAmountCur;
        AmountCur                   indirectTaxAmount;
        AmountCur                   totalIndirectTaxAmount;
        AmountCur                   taxAmountGTE;
        ITaxDocumentLine            taxDocumentLine;
        TaxWithholdGroupHeading     taxWithholdGroupHeading;
        ITaxDocument                taxDocument;
        AmountCur                   totalGTETaxAmount;
        ITaxDocumentLineEnumerator  taxDocumentLines;
        TaxDocumentLineProxy        lineProxy;

        Map includeTaxComponentsMap = new Map(Types::String, Types::Container);
        
        taxWithholdGroupHeading = TaxWithholdGroupHeading::find(_taxWithholdGroup);
        
        taxDocument = TaxBusinessService::getTaxDocumentBySource(_custVendInvoiceJour.TableId, _custVendInvoiceJour.RecId);
        if (taxDocument)
        {
            taxDocumentLines = taxDocument.lines();
            
            while (taxDocumentLines.moveNext())
            {
                taxDocumentLine = taxDocumentLines.current();
                if (taxDocumentLine)
                {
                    lineProxy = taxDocumentLine as TaxDocumentLineProxy;
                    taxAmountGTE = lineProxy.sumByTaxAccountingProviderExcludeSubLines(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Credit).amountTransactionCurrency();
                    taxAmountGTE -= lineProxy.sumByTaxAccountingProviderExcludeSubLines(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Debit).amountTransactionCurrency();
                    if (TaxEngineEREnumToEnumUtil::taxDirectionEnum(taxDocumentLine.getFieldValue(TaxEngineModelFrameworkFieldsConstants::TaxDirection)) == TaxDirection::OutgoingTax)
                    {
                        taxAmountGTE = -taxAmountGTE;
                    }
                    totalGTETaxAmount += taxAmountGTE;
                    
                    includeTaxComponentsMap = TaxWithholdIncIndirectTaxComponentsUtil::getIncTaxComponentsForWithholdGroup(taxWithholdGroupHeading.RecId);
                    indirectTaxAmount = taxDocumentLine.getTaxAmountByComponentsAndProvider(includeTaxComponentsMap, TaxAccountingProvider::Party);
                    if (TaxEngineEREnumToEnumUtil::taxDirectionEnum(taxDocumentLine.getFieldValue(TaxEngineModelFrameworkFieldsConstants::TaxDirection)) == TaxDirection::IncomingTax)
                    {
                        indirectTaxAmount = -indirectTaxAmount;
                    }
                    totalIndirectTaxAmount += indirectTaxAmount;
                }
            }
            
            taxWithholdBaseFromIndirectTaxAmountCur = totalGTETaxAmount - totalIndirectTaxAmount;
        }
        
        return CurrencyExchangeHelper::amount(taxWithholdBaseFromIndirectTaxAmountCur * _factor);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExcludedTaxAmountforGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get excluded tax amount for GTE.
    /// </summary>
    /// <param name = "_custVendTrans">The buffer of <c>custTrans</c> or <c>vendTrans</c>.</param>
    /// <param name = "_taxWithholdGroup">The taxWithHoldGroup</param>
    /// <param name = "_factor">The factor.</param>
    /// <returns>the excluded tax amount.</returns>
    internal static TaxAmountCur getExcludedTaxAmountforGTE(
        CustVendTrans        _custVendTrans,
        TaxWithholdGroup     _taxWithholdGroup,
        real                 _factor)
    {
        AmountCur                   taxWithholdBaseFromIndirectTaxAmountCur;
        AmountCur                   indirectTaxAmount;
        AmountCur                   totalIndirectTaxAmount;
        AmountCur                   taxAmountGTE;
        AmountCur                   totalGTETaxAmount;
        ITaxDocumentLine            taxDocumentLine;
        TaxWithholdGroupHeading     taxWithholdGroupHeading;
        ITaxDocument                taxDocument;
        ITaxDocumentLineEnumerator  taxDocumentLines;
        TaxDocumentLineProxy        lineProxy;
        Common                      taxDocumentTransaction;

        Map includeTaxComponentsMap = new Map(Types::String, Types::Container);
        taxWithholdGroupHeading = TaxWithholdGroupHeading::find(_taxWithholdGroup);
        taxDocumentTransaction = TaxDocumentGeneralJournalEntryLink::findByVoucherAndAccountingDate(_custVendTrans.Voucher, _custVendTrans.TransDate);
        taxDocument = TaxBusinessService::getTaxDocumentBySource(taxDocumentTransaction.TableId, taxDocumentTransaction.RecId);
        
        if (taxDocument)
        {
            taxDocumentLines = taxDocument.lines();
            
            while (taxDocumentLines.moveNext())
            {
                taxDocumentLine = taxDocumentLines.current();
                if (taxDocumentLine)
                {
                    lineProxy = taxDocumentLine as TaxDocumentLineProxy;
                    taxAmountGTE = lineProxy.sumByTaxAccountingProviderExcludeSubLines(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Credit).amountTransactionCurrency();
                    taxAmountGTE -= lineProxy.sumByTaxAccountingProviderExcludeSubLines(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Debit).amountTransactionCurrency();
                    if (TaxEngineEREnumToEnumUtil::taxDirectionEnum(taxDocumentLine.getFieldValue(TaxEngineModelFrameworkFieldsConstants::TaxDirection)) == TaxDirection::OutgoingTax)
                    {
                        taxAmountGTE = -taxAmountGTE;
                    }
                    totalGTETaxAmount += taxAmountGTE;
                    
                    includeTaxComponentsMap = TaxWithholdIncIndirectTaxComponentsUtil::getIncTaxComponentsForWithholdGroup(taxWithholdGroupHeading.RecId);
                    indirectTaxAmount = taxDocumentLine.getTaxAmountByComponentsAndProvider(includeTaxComponentsMap, TaxAccountingProvider::Party);
                    if (TaxEngineEREnumToEnumUtil::taxDirectionEnum(taxDocumentLine.getFieldValue(TaxEngineModelFrameworkFieldsConstants::TaxDirection)) == TaxDirection::IncomingTax)
                    {
                        indirectTaxAmount = -indirectTaxAmount;
                    }
                    totalIndirectTaxAmount += indirectTaxAmount;
                }
            }
            
            taxWithholdBaseFromIndirectTaxAmountCur = totalGTETaxAmount - totalIndirectTaxAmount;
        }
        
        return CurrencyExchangeHelper::amount(taxWithholdBaseFromIndirectTaxAmountCur * _factor);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentAmountForCentralizePayment</Name>
				<Source><![CDATA[
    // </GTE>

    /// <summary>
    ///     Gets payment amount for WHT centralized payment
    /// </summary>
    /// <param name="_line">
    ///     <c>LedgerJournalTrans</c>
    /// </param>
    /// <returns>
    ///     Payment amount
    /// </returns>
    protected AmountCur getPaymentAmountForCentralizePayment(Common _line)
    {
        LedgerJournalTrans      tmpledgerJournalTrans;
        AmountCur               indirectTaxAmount;
        AmountCur               paymentAmountCur;

        tmpledgerJournalTrans = _line as LedgerJournalTrans;

        indirectTaxAmount = TaxUncommitted::getIndirectTaxAmtForWHTSourceBaseCur_IN(tmpledgerJournalTrans.TableId, tmpledgerJournalTrans.RecId, tmpledgerJournalTrans.TaxItemGroup);
        if (tmpledgerJournalTrans.isTransForGTAVendor_IN() || tmpledgerJournalTrans.isPaymentJournal_IN())
        {
            indirectTaxAmount -= TaxUncommitted::getServiceTaxAmtForWHTSourceBaseCur_IN(tmpledgerJournalTrans.TableId, tmpledgerJournalTrans.RecId, tmpledgerJournalTrans.TaxItemGroup);
        }

        paymentAmountCur = (tmpledgerJournalTrans.AmountCurDebit + tmpledgerJournalTrans.AmountCurCredit + indirectTaxAmount);

        return paymentAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalWithholdAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets total withhold tax amount
    /// </summary>
    /// <param name="_accountNumber">
    /// Account number
    /// </param>
    /// <param name="_grossAmount">
    /// Gross Amount
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// Ledger journal trans
    /// </param>
    /// <param name="_specTrans">
    /// Spec trans
    /// </param>
    /// <param name="_taxWithholdGroup">
    /// Tax withhold group
    /// </param>
    /// <param name="_invoiceCompanyId">
    /// Invoice company id
    /// </param>
    /// <param name="_cpOrigRefRecId">
    /// CP orig trans <c>RefRecId</c>
    /// </param>
    /// <param name="_isOnJewelry">
    /// whether it's on jewelry.
    /// </param>
    /// <param name="_isByCash">
    /// whether it's by cash.
    /// </param>
    /// <returns>
    /// Total withhold tax amount
    /// </returns>
    private TaxWithholdAmountCur getTotalWithholdAmountCur(
        CustVendAC          _accountNumber,
        AmountCur           _grossAmount,
        LedgerJournalTrans  _ledgerJournalTrans,
        SpecTrans           _specTrans,
        TaxWithholdGroup    _taxWithholdGroup,
        CompanyId           _invoiceCompanyId,
        RefRecId            _cpOrigRefRecId               = 0,
        boolean             _isOnJewelry                  = false,
        boolean             _isByCash                     = false)
    {
        TaxAmountCur                taxWithholdAmountCur;
        container                   vendorInformation;
        CustVendAC                  accountNumber;
        TaxWithholdGroup            taxWithholdGroup;
        container                   taxWithholdData;
        boolean                     isRecoverableAccount;
        boolean                     isAdvancedPayment;

        if (_grossAmount <= 0)
        {
            return 0;
        }

        if (_specTrans.RecId)
        {
            vendorInformation = this.getVendorInfo(_specTrans, _ledgerJournalTrans);
            accountNumber = conPeek(vendorInformation, 1);
            taxWithholdGroup = conPeek(vendorInformation, 2);
        }
        else
        {
            vendorInformation = this.setCustVendData(_invoiceCompanyId, curext(), _accountNumber, this);
            accountNumber = _accountNumber;
            taxWithholdGroup = _taxWithholdGroup;
        }

        this.setInvoiceCompany(conPeek(vendorInformation, 5));
        this.setPaymentCompany(conPeek(vendorInformation, 6));

        isRecoverableAccount = this.isRecoverableAccount(accountNumber, _ledgerJournalTrans);
        isAdvancedPayment    = this.isAdvancePayment(_ledgerJournalTrans);
        taxWithholdData      = this.setWHTContainerData(_ledgerJournalTrans, _grossAmount);

        // Calculates Withhold taxes and inserts to TmpTaxWithholdWorkTrans_IN and TaxWithholdUncommitted_IN tables.
        if ((this.canCalculateWHT(_ledgerJournalTrans, _invoiceCompanyId, _ledgerJournalTrans.Company, accountNumber))
            || (_isOnJewelry && _isByCash)
        )
        {
            taxWithholdAmountCur = this.totalTaxWithhold(
                conpeek(vendorInformation, 1),
                taxWithholdGroup,
                _ledgerJournalTrans.TransDate,
                taxWithholdData,
                isRecoverableAccount,
                isAdvancedPayment,
                '',
                '',
                _ledgerJournalTrans.JournalNum,
                _ledgerJournalTrans.AmountCurDebit,
                _ledgerJournalTrans.AmountCurCredit,
                _ledgerJournalTrans.AccountType,
                _ledgerJournalTrans.OffsetAccountType,
                vendorInformation,
                false,
                _cpOrigRefRecId,
                _isOnJewelry,
                _isByCash);
        }

        return taxWithholdAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendorInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// To get the vendor information.
    /// </summary>
    /// <param name="_specTranscpy">
    /// Buffer of <c> SpecTrans </c>
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// Buffer of <c> LedgerJournalTrans </c>.
    /// </param>
    /// <param name="_paymentCompany">
    /// Payment company Id.
    /// </param>
    /// <returns>
    /// Container which contains all the vendor information.
    /// </returns>
    public  container getVendorInfo(SpecTrans  _specTranscpy, LedgerJournalTrans _ledgerJournalTrans = null, CompanyId _paymentCompany = '')
    {
        VendTable           vendTableLoc;
        VendTrans           vendTransLoc;
        VendTransOpen       vendTransOpenLoc;
        CustTable           custTableLoc;
        CustTrans           custTransLoc;
        CustTransOpen       custTransOpenLoc;
        container           custVendInformation = connull();
        TaxWithholdGroup    taxWithholdGroup;
        SpecTrans           specTrans;
        CustVendAC          accountNumber;
        AmountCur           grossAmount;
        TaxInformationVendTable_IN      taxInformationVendTableLoc;
        TaxInformationCustTable_IN      taxInformationCustTableLoc;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        container setLocalData(AccountNum  _accountNum, TaxWithholdGroup _taxWithholdGroup, boolean     _isTaxWithholdCalculate,
                               AmountCur   _amount    , CompanyId        _invoiceCompany  , CompanyId   _paymentCompanyLoc,
                               Voucher     _voucher   , recId            _recId)
        {
            container custVendInfo;
            ;

            custVendInfo += _accountNum;
            custVendInfo += _taxWithholdGroup;
            custVendInfo += _isTaxWithholdCalculate;
            custVendInfo += _amount;
            custVendInfo += _invoiceCompany;
            custVendInfo += _paymentCompanyLoc;
            custVendInfo += _voucher;
            custVendInfo += _recId;
            return custVendInfo;
        }

        if (_specTranscpy)
        {
            select  specTrans
                where specTrans.RefCompany     == _specTranscpy.RefCompany
                   && specTrans.SpecRecId    == _ledgerJournalTrans.RecId;

            switch (specTrans.RefTableId)
            {
                case tablenum(VendTransOpen):
                    changecompany(specTrans.RefCompany)
                    {
                        select firstonly RefRecId from vendTransOpenLoc
                            where vendTransOpenLoc.RecId    == specTrans.RefRecId;

                        select firstonly AccountNum from vendTransLoc
                            where vendTransLoc.RecId        == vendTransOpenLoc.RefRecId;

                        select firstonly RecId from vendTableLoc
                            where vendTableLoc.AccountNum   == vendTransLoc.AccountNum;

                        if (specTrans.RefCompany == specTrans.SpecCompany && specTrans.SpecCompany == _ledgerJournalTrans.Company)
                        {
                            taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup  : ledgerJournalTransTaxExt.tcsGroup;
                        }
                        else
                        {
                             taxInformationVendTableLoc = vendTableLoc.getTaxInformationVendTable_IN();
                             taxWithholdGroup = taxInformationVendTableLoc.TDSGroup ? taxInformationVendTableLoc.TDSGroup : taxInformationVendTableLoc.TCSGroup;
                        }
                        custVendInformation = setLocalData(vendTableLoc.AccountNum, taxWithholdGroup,vendTableLoc.TaxWithholdCalculate,
                                                           grossAmount, specTrans.RefCompany,
                                                           _ledgerJournalTrans.OffsetCompany ? _ledgerJournalTrans.OffsetCompany : specTrans.SpecCompany,
                                                           vendTransLoc.Voucher, vendTransLoc.RecId);
                    }
                break;

                case tablenum(CustTransOpen):
                    changecompany(specTrans.RefCompany)
                    {
                        select firstonly RefRecId from custTransOpenLoc
                            where custTransOpenLoc.RecId    == specTrans.RefRecId;

                        select firstonly AccountNum from custTransLoc
                            where custTransLoc.RecId        == custTransOpenLoc.RefRecId;

                        select firstonly RecId from custTableLoc
                            where custTableLoc.AccountNum   == custTransLoc.AccountNum;

                        if (specTrans.RefCompany == specTrans.SpecCompany && specTrans.SpecCompany == _ledgerJournalTrans.Company)
                        {
                            taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup  : ledgerJournalTransTaxExt.tcsGroup;
                        }
                        else
                        {
                             taxInformationCustTableLoc = custTableLoc.getTaxInformationCustTable_IN();
                             taxWithholdGroup = taxInformationCustTableLoc.TDSGroup ? taxInformationCustTableLoc.TDSGroup : taxInformationCustTableLoc.TCSGroup;
                        }
                        custVendInformation = setLocalData(custTableLoc.AccountNum, taxWithholdGroup, custTableLoc.TaxWithholdCalculate_IN,
                                                           grossAmount, specTrans.RefCompany,
                                                           _ledgerJournalTrans.OffsetCompany ? _ledgerJournalTrans.OffsetCompany : specTrans.SpecCompany,
                                                           custTransLoc.Voucher, custTransLoc.RecId);
                    }
                break;

                default:
                break;
            }
        }
        else
        {
            taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup  : ledgerJournalTransTaxExt.tcsGroup;
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend || _ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                accountNumber = _ledgerJournalTrans.parmAccount();
            }
            else
            {
                accountNumber = _ledgerJournalTrans.parmOffsetAccount();
            }
            custVendInformation = setLocalData(accountNumber, taxWithholdGroup, true,
                                            (_ledgerJournalTrans.AmountCurDebit + _ledgerJournalTrans.AmountCurCredit), _ledgerJournalTrans.Company , _paymentCompany,
                                             _ledgerJournalTrans.Voucher, 0);
        }

        return custVendInformation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the <c>TaxWithholdUncommitted_IN</c> records into the <c>TmpTaxWithholdWorkTrans_IN</c> buffer.
    /// </summary>
    /// <param name="_initializationClass">
    ///    The initialization class. The initialization class is a TaxableDocument class for journals.
    /// </param>
    public void init(Object _initializationClass)
    {
        ledgerJournalTaxWithholdDocument = _initializationClass as TaxableDocument;

        if (!ledgerJournalTaxWithholdDocument)
        {
            throw error("@SYS95118");
        }
        voucher = ledgerJournalTaxWithholdDocument.getReferenceNumber();
        headingRecId = ledgerJournalTaxWithholdDocument.getSourceHeader().RecId;
        headingTableId = ledgerJournalTaxWithholdDocument.getSourceHeader().TableId;
        taxModuleType = ledgerJournalTaxWithholdDocument.getModuleType();
        super(_initializationClass);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAdvancePayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether it is an advance payments or not.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// Buffer of <c>LedgerJournalTrans</c> table.
    /// </param>
    /// <returns>
    /// Returns true, if this is advance payments.
    /// </returns>
    protected boolean isAdvancePayment(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ret;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
        if (ledgerJournalTransTaxExt.tcsGroup)
        {
            ret = (_ledgerJournalTrans.AccountType   == LedgerJournalACType::Vend  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.AmountCurDebit  > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend  && _ledgerJournalTrans.AmountCurCredit > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust  && _ledgerJournalTrans.AmountCurDebit  > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.AmountCurCredit > 0);

            if (!ret)
            {
                ret = (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust  && _ledgerJournalTrans.AmountCurDebit  > 0
                        && MainAccount::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension).PostingType == LedgerPostingType::SalesCash)
                    || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger  && _ledgerJournalTrans.AmountCurCredit > 0
                        && MainAccount::findByLedgerDimension(_ledgerJournalTrans.OffsetLedgerDimension).PostingType == LedgerPostingType::SalesCash);
            }
        }

        return ret; 
    }

]]></Source>
			</Method>
			<Method>
				<Name>isARInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the transaction is AR Invoice.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// LedgerJournalTrans buffer.
    /// </param>
    /// <returns>
    /// true is line is AR Invoice, otherwise false.
    /// </returns>
    private boolean isARInvoice(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (
           (_ledgerJournalTrans.AccountType        == LedgerJournalACType::Cust &&
            _ledgerJournalTrans.OffsetAccountType  == LedgerJournalACType::Ledger)
           ||
           (_ledgerJournalTrans.AccountType        == LedgerJournalACType::Ledger &&
            _ledgerJournalTrans.OffsetAccountType  == LedgerJournalACType::Cust)
          )
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the transaction is Payment Journal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// LedgerJournalTrans buffer.
    /// </param>
    /// <returns>
    /// true is line is Payment Journal, otherwise false.
    /// </returns>
    private boolean isCustPayment(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (
           (_ledgerJournalTrans.AccountType        == LedgerJournalACType::Cust &&
            _ledgerJournalTrans.OffsetAccountType  == LedgerJournalACType::Bank &&
            _ledgerJournalTrans.AmountCurCredit    > 0)
         ||
           (_ledgerJournalTrans.AccountType        == LedgerJournalACType::Bank &&
            _ledgerJournalTrans.OffsetAccountType  == LedgerJournalACType::Cust &&
            _ledgerJournalTrans.AmountCurDebit    > 0)
          )
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRecoverableAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if recoverable account.
    /// </summary>
    /// <param name="_account">
    /// In  this  account number posting will be done.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The ledgerJournalTrans buffer.
    /// </param>
    /// <returns>
    /// Returns true if recoverableAccount; otherwise false.
    /// </returns>
    protected boolean isRecoverableAccount(
        CustVendAC          _account,
        LedgerJournalTrans  _ledgerJournalTrans)
    {
        boolean     isRecoverableAccount;

        // If InvoiceCompany is equal to PaymentCompany get isRecoverableAccount using LedgerJournalTrans else get using VendTable/CustTable.
        if (companyId == paymcompanyId)
        {
            isRecoverableAccount = TaxWithholdCalculation_IN::checkRecoverableAccount(_ledgerJournalTrans);
        }
        else
        {
            changecompany(companyId)
            {
                isRecoverableAccount = VendTable::find(_account, false).getTaxInformationVendTable_IN().TCSGroup ? true : false;
                isRecoverableAccount = CustTable::find(_account, false).getTaxInformationCustTable_IN().TDSGroup ? true : false;
            }
        }

        return isRecoverableAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSettledTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether it is related to settlement transaction is exits or not.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// Buffer of <c> LedgerJournalTrans </c>
    /// </param>
    /// <returns>
    /// Returns true if settlement record exists otherwise false.
    /// </returns>
    protected boolean isSettledTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ret;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
        if (ledgerJournalTransTaxExt.tcsGroup && _ledgerJournalTrans.SettleVoucher != SettlementType::SelectedTransact)
        {
            ret = (_ledgerJournalTrans.AccountType   == LedgerJournalACType::Vend  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.AmountCurDebit  > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend  && _ledgerJournalTrans.AmountCurCredit > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust  && _ledgerJournalTrans.AmountCurDebit  > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.AmountCurCredit > 0);

            if (!ret)
            {
                ret = (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust  && _ledgerJournalTrans.AmountCurDebit  > 0
                        && MainAccount::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension).PostingType == LedgerPostingType::SalesCash)
                    || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger  && _ledgerJournalTrans.AmountCurCredit > 0
                        && MainAccount::findByLedgerDimension(_ledgerJournalTrans.OffsetLedgerDimension).PostingType == LedgerPostingType::SalesCash);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromTaxWithholdUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads tax records from the <c>TaxWithholdUncommitted_IN</c> table into the <c>TmpTaxWithholdWorkTrans_IN</c> table.
    /// </summary>
    protected void loadFromTaxWithholdUncommitted()
    {
        taxWithholdWorkTrans.loadFromTaxWHTUncommittedForDocument(headingTableId, headingRecId, voucher, ledgerJournalTaxWithholdDocument.getInvoiceId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(
        Object  _initializationClass,
        boolean _useTaxWithholdUncommitted,
        boolean _loadTaxWithholdUncommittedOnInit,
        boolean _loadTaxWithholdTrans,
        boolean _skipInit = false,
        boolean _maintainExistingTaxWithholdUncommitted = false)
    {
        super();

        maintainExistingTaxWithholdUncommitted = _maintainExistingTaxWithholdUncommitted;
        useTaxWithholdUncommitted           = _useTaxWithholdUncommitted;
        loadTaxWithholdUncommitted  = _loadTaxWithholdUncommittedOnInit;
        loadTaxWithholdTrans        = _loadTaxWithholdTrans;

        if (!_skipInit)
        {
            this.init(_initializationClass);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveTaxTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>TmpTaxWithholdWorkTrans_IN</c> record that represents a tax transfer for Direct tax.
    /// </summary>
    /// <param name="_taxableLine">
    ///    The transaction line that represents this tax transfer for Direct tax.
    /// </param>
    /// <returns>
    ///    The tax amount for this tax transfer for Direct tax.
    /// </returns>
    protected TaxAmountCur saveTaxTransfer(TaxableLine _taxableLine)
    {
        LedgerJournalTaxLine    ledgerJournalTaxLine;
        CurrencyExchangeHelper  currencyExchangeHelper;
        LedgerJournalTrans      ledgerJournalTrans;
        LedgerJournalTransTaxExtensionIN    ledgerJournalTransTaxExtensionIN;
        TaxWithholdTaxJournalTrans_IN       taxWithholdTaxJournalTrans;
        TaxWithholdData                     taxWithHoldDataloc;
        boolean                             isVendTransaction;
        TaxAmountCur                        taxWithholdAmountCur;
        TransTaxInformation                 transTaxInformation;

        currencyExchangeHelper = _taxableLine.getCurrencyExchangeInformation();
        ledgerJournalTaxLine   = _taxableLine as LedgerJournalTaxLine;
        ledgerJournalTrans     = _taxableLine.getSourceLine();
        ledgerJournalTransTaxExtensionIN    = LedgerJournalTransTaxExtensionIN::findByLedgerJournalTrans(ledgerJournalTrans.RecId);
        select firstOnly SourceTaxBaseAmountCur, SourceAmountOriginCur, TaxWithholdGroup, RateOfDeduction,
                        TaxWithholdType, AccountNum, RecId, SourceTransDate, SourceTransVoucher,
                        SourceTransTableId, SourceTransRecId
            from taxWithholdTaxJournalTrans
            where taxWithholdTaxJournalTrans.LedgerJournalTrans == ledgerJournalTrans.RecId;

        select firstonly TaxWithholdCode, TaxWithholdFromDate, TaxWithholdToDate, TaxWithholdValue, panNonAvailableValue_IN from taxWithholdDataLoc
                        where taxWithholdDataLoc.TaxWithholdCode        == ledgerJournalTransTaxExtensionIN.TaxWithholdCode
                           && (!taxWithholdDataLoc.TaxWithholdFromDate
                           || (taxWithholdDataLoc.TaxWithholdFromDate   <= ledgerJournalTrans.TransDate
                           && taxWithholdDataLoc.TaxWithholdToDate      >= ledgerJournalTrans.TransDate));

        if (taxWithholdTaxJournalTrans.RecId != 0)
        {
            taxWithholdWorkTrans.clear();
            taxWithholdWorkTrans.HeadingRecId          = ledgerJournalTaxWithholdDocument.getSourceHeader().RecId;
            taxWithholdWorkTrans.HeadingTableId        = ledgerJournalTaxWithholdDocument.getSourceHeader().TableId;
            taxWithholdWorkTrans.SourceTableId         = ledgerJournalTrans.TableId;
            taxWithholdWorkTrans.SourceRecId           = ledgerJournalTrans.RecId;
            taxWithholdWorkTrans.Voucher               = ledgerJournalTaxWithholdDocument.getReferenceNumber();
            taxWithholdWorkTrans.CalculationDate       = currencyExchangeHelper.parmExchangeDate();
            taxWithholdWorkTrans.TaxWithholdCode       = ledgerJournalTransTaxExtensionIN.TaxWithholdCode;
            taxWithholdWorkTrans.InvoiceId             = ledgerJournalTaxWithholdDocument.getInvoiceId();
            taxWithholdWorkTrans.Source                = ledgerJournalTaxWithholdDocument.getModuleType();
            taxWithholdWorkTrans.TaxAutogenerated      = NoYes::Yes;
            taxWithholdWorkTrans.CompanyAccount        = ledgerJournalTaxLine.getDestinationCompany();
            taxWithholdWorkTrans.LedgerDimensionDefaultAccount = ledgerJournalTrans.LedgerDimension;

            taxWithholdWorkTrans.SourceTaxAmountCur    = ledgerJournalTaxLine.setSignBasedOnAccountType(ledgerJournalTrans, ledgerJournalTrans.amount());
            taxWithholdWorkTrans.SourceCurrencyCode    = ledgerJournalTrans.CurrencyCode;
            taxWithholdWorkTrans.SourceBaseAmountCur   = taxWithholdTaxJournalTrans.SourceTaxBaseAmountCur;

            //
            //  _exchRate & _exchRateSecondary are included in the parameter list to
            //  make sure that the exchange rates used on the transactions are the same
            //  ones used to calculate the tax amounts.
            //
            currencyExchangeHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
            taxWithholdWorkTrans.TaxAmount = currencyExchangeHelper.calculateTransactionToAccounting(ledgerJournalTrans.CurrencyCode, taxWithholdWorkTrans.SourceTaxAmountCur, true);

            taxWithholdWorkTrans.TaxBaseAmount = currencyExchangeHelper.calculateTransactionToAccounting(ledgerJournalTrans.CurrencyCode, taxWithholdWorkTrans.SourceBaseAmountCur, true);

            taxWithholdWorkTrans.TaxCurrencyCode = TaxWithholdTable::find(taxWithholdWorkTrans.TaxWithholdCode).CurrencyCode;

            if (taxWithholdWorkTrans.TaxCurrencyCode == taxWithholdWorkTrans.SourceCurrencyCode)
            {
                taxWithholdWorkTrans.TaxAmountCur = taxWithholdWorkTrans.SourceTaxAmountCur;
                taxWithholdWorkTrans.TaxBaseAmountCur  = taxWithholdTaxJournalTrans.SourceTaxBaseAmountCur;
            }
            else
            {
                //
                //  _exchRate & _exchRateSecondary are not included in the parameter list because those exchange
                //  rates are for Transactional/Master currency - not for the tax code's currency/Master.
                //
                taxWithholdWorkTrans.TaxAmountCur = currencyExchangeHelper.calculateAccountingToTransaction(
                                                                                            taxWithholdWorkTrans.TaxCurrencyCode,
                                                                                            taxWithholdWorkTrans.TaxAmount,
                                                                                            true);

                taxWithholdWorkTrans.TaxBaseAmountCur = currencyExchangeHelper.calculateAccountingToTransaction(
                                                                                            taxWithholdWorkTrans.TaxCurrencyCode,
                                                                                            taxWithholdWorkTrans.TaxBaseAmount,
                                                                                            true);
            }
            taxWithholdWorkTrans.AmountOriginMST   = currencyExchangeHelper.calculateTransactionToAccounting(ledgerJournalTrans.CurrencyCode, taxWithholdTaxJournalTrans.SourceAmountOriginCur, true);
            taxWithholdWorkTrans.TaxWithholdGroup  = taxWithholdTaxJournalTrans.TaxWithholdGroup;
            taxWithholdWorkTrans.IsTaxCalculated   = NoYes::Yes;
            taxWithholdWorkTrans.ExchangeRate      = ledgerJournalTrans.ExchRate;
            taxWithholdWorkTrans.ExchRateSecond    = ledgerJournalTrans.ExchRateSecond;
            taxWithholdWorkTrans.RateOfDeduction   = taxWithholdTaxJournalTrans.RateOfDeduction;
            taxWithholdWorkTrans.TaxWithholdType   = taxWithholdTaxJournalTrans.TaxWithholdType;
            taxWithholdWorkTrans.AccountNumber     = taxWithholdTaxJournalTrans.AccountNum;
            taxWithholdWorkTrans.ExemptTax         = NoYes::No;

            // Fields related to original cust/vend trans fields selected for adjustment.
            taxWithholdWorkTrans.TransactionStatus  = TaxWithholdTransactionstatus_IN::Adjusted;
            taxWithholdWorkTrans.SourceTransDate    = taxWithholdTaxJournalTrans.SourceTransDate;
            taxWithholdWorkTrans.SourceTransVoucher = taxWithholdTaxJournalTrans.SourceTransVoucher;
            taxWithholdWorkTrans.SourceTransTableId = taxWithholdTaxJournalTrans.SourceTransTableId;
            taxWithholdWorkTrans.SourceTransRecId   = taxWithholdTaxJournalTrans.SourceTransRecId;

            isVendTransaction = (taxWithholdTaxJournalTrans.AccountType == LedgerJournalACType::Vend) ? true : false;
            taxWithholdWorkTrans.TaxWithholdValue  = taxWithholdDataLoc.getTaxWithHoldValue_IN(taxWithholdWorkTrans.AccountNumber, isVendTransaction);
            transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(ledgerJournalTrans);
            taxWithholdWorkTrans.AcknowledgermentNumber     = transTaxInformation.TaxWithholdAcknowledgementNumber;
            taxWithholdWorkTrans.CountryRegionToRemittance  = transTaxInformation.TaxWithholdCountryRegionToRemittance;
            taxWithholdWorkTrans.NatureOfRemittance         = transTaxInformation.TaxWithholdNatureOfRemittance;
            taxWithholdWorkTrans.TaxApplicability           = TaxWithholdGroupHeading::find(taxWithholdWorkTrans.TaxWithholdGroup).TaxApplicability_IN;
            taxWithholdWorkTrans.insert();

            taxWithholdAmountCur = taxWithholdWorkTrans.SourceTaxAmountCur;
        }

        return taxWithholdAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustVendData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets customer/vendor infromation in container.
    /// </summary>
    /// <param name="_invoiceCompany">
    /// Invoice company is used to set value in <c>TaxWithholdCalculation_IN</c> instance.
    /// </param>
    /// <param name="_paymentCompany">
    /// Payment company is used to set value in <c>TaxWithholdCalculation_IN</c> instance.
    /// </param>
    /// <param name="_accountNumber">
    /// Account number is used to insert the value in container.
    /// </param>
    /// <param name="_taxWithholdCalculation">
    /// Instance of <c>TaxWithholdCalculation_IN</c> class.
    /// </param>
    /// <returns>
    /// Container which contains customer or vendor information.
    /// </returns>
    protected container setCustVendData(CompanyId                   _invoiceCompany,
                                        CompanyId                   _paymentCompany,
                                        CustVendAC                  _accountNumber,
                                        TaxWithholdCalculation_IN   _taxWithholdCalculation)
    {
        container   custVendInfo = connull();

        _taxWithholdCalculation.setInvoiceCompany(_invoiceCompany);
        _taxWithholdCalculation.setPaymentCompany(_paymentCompany);
        custVendInfo += _accountNumber;
        custVendInfo += '';
        custVendInfo += '';
        custVendInfo += '';
        custVendInfo += _invoiceCompany;
        custVendInfo += _paymentCompany;

        return custVendInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdCheque</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax withhold cheque.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaciton.
    /// </param>
    /// <param name="_grossAmount">
    /// The gross amount.
    /// </param>
    /// <param name="_specTrans">
    /// The spec transaciton.
    /// </param>
    /// <returns>
    /// The tax withhold cheque.
    /// </returns>
    public real  taxWithholdCheque(LedgerJournalTrans _ledgerJournalTrans,
                                   AmountCur          _grossAmount,
                                   SpecTrans          _specTrans = null)
    {
        container                   taxWithholdData;
        TaxWithholdGroup            taxWithholdGroup;
        CustVendAC                  accountNumber;
        CustTable                   custTable;
        VendTable                   vendTable;
        boolean                     isRecoverable = false;
        AmountCur                   taxWithholdAmount;
        SpecTrans                   specTrans;
        TaxInformationCustTable_IN      taxInformationCustTableLoc;
        TaxInformationVendTable_IN      taxInformationVendTableLoc;

        select  specTrans
            where specTrans.SpecRecId    == _specTrans.SpecRecId
               && specTrans.RefRecId     == _specTrans.RefRecId;

        if (specTrans)
        {
            this.setInvoiceAndPaymentData(specTrans, _ledgerJournalTrans);
        }
        if (!specTrans)
        {
            this.setInvoiceAndPaymentData(null, _ledgerJournalTrans, _ledgerJournalTrans.OffsetCompany);
        }

        if (TaxWithholdJournal_IN::validateCheque(_ledgerJournalTrans) && this.canCalculateWHTForCC(_ledgerJournalTrans, invoiceAccount, true))
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

            if (companyId != paymcompanyId || _ledgerJournalTrans.Company != paymcompanyId)
            {
                changeCompany(companyId)
                {
                    accountNumber = invoiceAccount;
                    switch (_ledgerJournalTrans.AccountType)
                    {
                        case LedgerJournalACType::Cust :
                            custTable        = CustTable::findByCompany(companyId, accountNumber, false);
                            taxInformationCustTableLoc = custTable.getTaxInformationCustTable_IN();
                            taxWithholdGroup = taxInformationCustTableLoc.TDSGroup ? taxInformationCustTableLoc.TDSGroup : taxInformationCustTableLoc.TCSGroup;
                            isRecoverable    = taxInformationCustTableLoc.TDSGroup ? true : false;

                            break;

                        case LedgerJournalACType::Vend :
                            vendTable        = vendTable::findByCompany(companyId, accountNumber, false);
                            TaxInformationVendTableLoc = vendTable.getTaxInformationVendTable_IN();
                            taxWithholdGroup = TaxInformationVendTableLoc.TDSGroup ? TaxInformationVendTableLoc.TDSGroup : TaxInformationVendTableLoc.TCSGroup;
                            isRecoverable    = TaxInformationVendTableLoc.TCSGroup ? true : false;
                            break;

                        default:
                            break;
                    }

                    if (!specTrans)
                    {
                        taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup : ledgerJournalTransTaxExt.tcsGroup;
                        isRecoverable = false;
                    }
                }
            }
            else
            {
                accountNumber = TaxWithholdJournal_IN::setAccountNumber(_ledgerJournalTrans);
                taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup : ledgerJournalTransTaxExt.tcsGroup;
                isRecoverable = TaxWithholdCalculation_IN::checkRecoverableAccount(_ledgerJournalTrans);
            }

            taxWithholdData   = TaxWithholdCalculation_IN::setLedgerData(_ledgerJournalTrans, _grossAmount);
            taxWithholdAmount = this.totalTaxWithhold(accountNumber,
                                                      taxWithholdGroup,
                                                      _ledgerJournalTrans.TransDate,
                                                      taxWithholdData,
                                                      TaxWithholdCalculation_IN::checkRecoverableAccount(_ledgerJournalTrans),
                                                      false,
                                                      '',
                                                      '',
                                                      _ledgerJournalTrans.JournalNum,
                                                      _ledgerJournalTrans.AmountCurDebit,
                                                      _ledgerJournalTrans.AmountCurCredit,
                                                      _ledgerJournalTrans.AccountType,
                                                      _ledgerJournalTrans.OffsetAccountType);
        }
        return taxWithholdAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxWithholdUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes all <c>TaxWithholdUncommitted_IN</c> records for the current document, voucher, and invoice.
    /// </summary>
    /// <remarks>
    ///    For the journals, the current document may actually contain multiple tax documents. Therefore, we
    ///    need to override the default behavior so that only one of these tax documents.
    /// </remarks>
    public void updateTaxWithholdUncommitted()
    {
        if (useTaxWithholdUncommitted)
        {
            if (TaxWithholdUncommitted_IN::existByDocumentAndInvoice(ledgerJournalTaxWithholdDocument.getSourceHeader().TableId, ledgerJournalTaxWithholdDocument.getSourceHeader().RecId, ledgerJournalTaxWithholdDocument.getReferenceNumber(), ledgerJournalTaxWithholdDocument.getInvoiceId()))
            {
                TaxWithholdUncommitted_IN::deleteForInvoice(ledgerJournalTaxWithholdDocument.getSourceHeader().TableId, ledgerJournalTaxWithholdDocument.getSourceHeader().RecId, ledgerJournalTaxWithholdDocument.getReferenceNumber(), ledgerJournalTaxWithholdDocument.getInvoiceId());
            }

            TaxWithholdUncommitted_IN::createWithholdTaxUncommitted(this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAndShowWithholdTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and open witholding tax form.
    /// </summary>
    /// <param name="_taxWithholdJournal">
    /// The TaxWithholdJournal_IN class instance.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The ledgerJournalTrans object.
    /// </param>
    /// <param name="_formRun">
    /// The FormRun object.
    /// </param>
    /// <returns>
    /// Returns witholding tax form.
    /// </returns>
    public static FormRun calcAndShowWithholdTax(TaxWithholdJournal_IN     _taxWithholdJournal,
                                                         LedgerJournalTrans        _ledgerJournalTrans = null,
                                                         FormRun                   _formRun    = null)

    {
        return TaxWithhold_IN::showWithholdTaxes(_taxWithholdJournal.taxwithhold(),_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBankAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks Bank Accounts.
    /// </summary>
    /// <param name="_ledgerJournalLoc">
    ///  Buffer of <c> LedgerJournalTrans </c>.
    /// </param>
    /// <returns>
    /// If true if bank accounts exists otherwise false.
    /// </returns>
    public static boolean checkBankAccount(LedgerJournalTrans _ledgerJournalLoc)
    {
        MainAccount mainAccount;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalLoc.ledgerJournalTransTaxExtensionIN();

        select firstOnly PostingType from mainAccount
            where mainAccount.OffsetLedgerDimension == _ledgerJournalLoc.parmOffsetLedgerDimension();

        if ((_ledgerJournalLoc.AccountType    == LedgerJournalACType::Cust  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalLoc.AmountCurDebit  > 0)
           || (_ledgerJournalLoc.AccountType == LedgerJournalACType::Vend  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalLoc.AmountCurDebit  > 0)
           || (_ledgerJournalLoc.AccountType == LedgerJournalACType::Bank  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Cust  && _ledgerJournalLoc.AmountCurCredit > 0)
           || (_ledgerJournalLoc.AccountType == LedgerJournalACType::Bank  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Vend  && _ledgerJournalLoc.AmountCurCredit > 0)
           || (_ledgerJournalLoc.AccountType == LedgerJournalACType::Cust  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalLoc.AmountCurCredit > 0 && ledgerJournalTransTaxExt.tdsGroup)
           || (_ledgerJournalLoc.AccountType == LedgerJournalACType::Bank  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Cust  && _ledgerJournalLoc.AmountCurDebit  > 0 && ledgerJournalTransTaxExt.tdsGroup)
           || (_ledgerJournalLoc.AccountType == LedgerJournalACType::Bank  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Vend  && _ledgerJournalLoc.AmountCurCredit > 0))
        {
            return false;
        }

        if (((_ledgerJournalLoc.AccountType          == LedgerJournalACType::Vend
                    && _ledgerJournalLoc.AmountCurDebit        > 0)
                ||  (_ledgerJournalLoc.AccountType      == LedgerJournalACType::Cust
                    && _ledgerJournalLoc.AmountCurCredit   > 0
                    && ledgerJournalTransTaxExt.TDSGroup))
            && _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Ledger 
            && MainAccount::findByLedgerDimension(_ledgerJournalLoc.OffsetLedgerDimension).PostingType == LedgerPostingType::PurchCash)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMultipleTaxType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for multiple tax.
    /// </summary>
    /// <param name="_ledgerJournalId">
    /// Ledger journal id is used to find the record.
    /// </param>
    /// <param name="_voucher">
    /// Voucher is used to find the record.
    /// </param>
    /// <exception cref="Exception::Error">
    /// If both TDS and TCS taxes exist then throw error.
    /// </exception>
    public static  void checkMultipleTaxType(LedgerJournalId _ledgerJournalId, Voucher _voucher)
    {
        LedgerJournalTrans    ledgerJournalLoc;
        int                   tdS, tcS;

        while select TaxWithholdGroup  from ledgerJournalLoc
            where ledgerJournalLoc.JournalNum == _ledgerJournalId
               && ledgerJournalLoc.Voucher    == _voucher
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = ledgerJournalLoc.ledgerJournalTransTaxExtensionIN();

            if (ledgerJournalTransTaxExt.tcsGroup)
            {
                tcS += 1;
            }
            if (ledgerJournalTransTaxExt.tdsGroup)
            {
                tdS += 1;
            }
            if (tcS && tdS)
            {
                throw error(strfmt("@GLS5856", "@SYS24010"));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>custInvoiceTaxType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for multiple tax.
    /// </summary>
    /// <param name="_recId">
    /// Record id is used to find the record.
    /// </param>
    /// <exception cref="Exception::Error">
    /// If both TDS and TCS taxes exist then throw error.
    /// </exception>
    public static void custInvoiceTaxType(RecId _recId)
    {
        CustInvoiceLine    custInvoiceLine;
        int                tdS, tcS;
        CustInvoiceLineTaxExtensionIN custInvoiceLineTaxExtensionIN;

        while select custInvoiceLine
            where custInvoiceLine.ParentRecId  == _recId
        {
            custInvoiceLineTaxExtensionIN = custInvoiceLine.custInvoiceLineTaxExtensionIN();
            if (custInvoiceLineTaxExtensionIN.tcsGroup)
            {
                tcS += 1;
            }
            if (custInvoiceLineTaxExtensionIN.tdsGroup)
            {
                tdS += 1;
            }
            if (tcS && tdS)
            {
                throw error(strfmt("@GLS5856", "@SYS23028"));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>grossAmountCurForJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// The methods gets the grossAmount for specified journal Line. This methods is only for journals.
    /// </summary>
    /// <param name="_sourceTableId">
    /// Source tableId.
    /// </param>
    /// <param name="_sourceRecId">
    /// Source table recid.
    /// </param>
    /// <returns>
    /// returns grossAmount for specified journal line.
    /// </returns>
    public static AmountCur grossAmountCurForJournalLine(
        RefTableId  _sourceTableId,
        RefRecId    _sourceRecId)
    {
        TaxWithholdUncommitted_IN   taxWithholdUncommitted;
        TaxWithholdDesignerTable_IN taxWithholdDesigner;

        // Get the SourceBaseAmountCur for the taxLine with Basis as GrossAmount.
        select firstOnly TaxWithholdGroup, TaxWithholdCode, SourceRecId, SourceBaseAmountCur
            from  taxWithholdUncommitted
            where taxWithholdUncommitted.SourceTableId == _sourceTableId
               && taxWithholdUncommitted.SourceRecId   == _sourceRecId
        join Basis from taxWithholdDesigner
            where taxWithholdDesigner.TaxWithholdCode  == taxWithholdUncommitted.TaxWithholdCode
               && taxWithholdDesigner.TaxWithholdGroup == taxWithholdUncommitted.TaxWithholdGroup
               && taxWithholdDesigner.Basis            == TaxWithholdBasis_IN::GrossAmount;

        return taxWithholdUncommitted.SourceBaseAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>grossAmountCurForPostedTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// The methods gets the grossAmount for specified journal Line. This methods is only for journals.
    /// </summary>
    /// <param name="_sourceTableId">
    /// Source tableId.
    /// </param>
    /// <param name="_sourceRecId">
    /// Source table recid.
    /// </param>
    /// <returns>
    /// returns grossAmount for specified journal line.
    /// </returns>
    public static AmountCur grossAmountCurForPostedTrans(
        RefTableId  _sourceTableId,
        RefRecId    _sourceRecId)
    {
        TaxWithholdTrans_IN     taxWithholdTrans;
        TaxWithholdDesignerTable_IN taxWithholdDesigner;

        // Get the SourceBaseAmountCur for the taxLine with Basis as GrossAmount.
        select firstOnly TaxWithholdGroup, TaxWithholdCode, SourceRecId, TaxWithholdBaseAmountCur
            from  taxWithholdTrans
            where taxWithholdTrans.SourceTableId == _sourceTableId
               && taxWithholdTrans.SourceRecId   == _sourceRecId
        join Basis from taxWithholdDesigner
            where taxWithholdDesigner.TaxWithholdCode  == taxWithholdTrans.TaxWithholdCode
               && taxWithholdDesigner.TaxWithholdGroup == taxWithholdTrans.TaxWithholdGroup
               && taxWithholdDesigner.Basis            == TaxWithholdBasis_IN::GrossAmount;

        return taxWithholdTrans.TaxWithholdBaseAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAccountNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets Ledger account.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// Buffer of <c> LedgerJournalTrans </c>
    /// </param>
    /// <returns>
    /// Ledger account for this <c> LedgerJournalTrans </c>.
    /// </returns>
    public static LedgerAccount setAccountNumber(LedgerJournalTrans _ledgerJournalTrans)
    {
        MainAccount mainAccount;

        select firstOnly PostingType from mainAccount
            where mainAccount.OffsetLedgerDimension == _ledgerJournalTrans.parmOffsetLedgerDimension();

        if ((_ledgerJournalTrans.AccountType    == LedgerJournalACType::Cust  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger      && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger      && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank        && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank        && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank        && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank        && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger      && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger      && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger      && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger      && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank        && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank        && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::VendPromissoryNoteDraw)
            || (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::CustBillOfExchangeDraw)
            || (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::CustBillOfExchangeProtest)
            || (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::CustBillOfExchangeRedraw)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project     && _ledgerJournalTrans.AmountCurCredit  > 0)
            )
        {
            return _ledgerJournalTrans.parmAccount() ;
        }

        if (_ledgerJournalTrans.AccountType         == LedgerJournalACType::Vend    &&
            _ledgerJournalTrans.OffsetAccountType   == LedgerJournalACType::Ledger  &&
            _ledgerJournalTrans.AmountCurDebit      > 0                             &&
            (MainAccount::findByLedgerDimension(_ledgerJournalTrans.OffsetLedgerDimension).PostingType == LedgerPostingType::PurchCash))
        {
            return _ledgerJournalTrans.parmAccount() ;
        }

        if ((_ledgerJournalTrans.AccountType    == LedgerJournalACType::Ledger      &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust        && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank        &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust        && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger      &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend        && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank        &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend        && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank        &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust        && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank        &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend        && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger      &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend        && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger      &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust        && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend        && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust        && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger      &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank        && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger      &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank        && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank        &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust        && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank        &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend        && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project     &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend        && _ledgerJournalTrans.AmountCurDebit   > 0)
            )
        {
            return _ledgerJournalTrans.parmOffsetAccount() ;
        }

        if (_ledgerJournalTrans.AccountType         == LedgerJournalACType::Ledger  &&
            _ledgerJournalTrans.OffsetAccountType   == LedgerJournalACType::Vend    &&
            _ledgerJournalTrans.AmountCurCredit     > 0                             &&
            (MainAccount::findByLedgerDimension(_ledgerJournalTrans.OffsetLedgerDimension).PostingType == LedgerPostingType::PurchCash))
        {
            return _ledgerJournalTrans.parmOffsetAccount() ;
        }

        return '0' ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDirection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets amount direction.
    /// </summary>
    /// <param name="_amount">
    /// Amount value.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// Buffer of <c>LedgerJournalTrans</c> table.
    /// </param>
    /// <returns>
    /// Amount value set with direction.
    /// </returns>
    public static AmountMST setDirection(AmountMST          _amount,
                                         LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans ledgerJournalTransLoc;
        boolean            calcForVendorType;

        select firstonly AccountType, OffsetAccountType from ledgerJournalTransLoc
            where ledgerJournalTransLoc.RecId == _ledgerJournalTrans.RecId;

        if (ledgerJournalTransLoc.AccountType == LedgerJournalACType::Project
            && ledgerJournalTransLoc.OffsetAccountType == LedgerJournalACType::Vend)
        {
            calcForVendorType = true;
        }

        if ((_ledgerJournalTrans.AccountType   == LedgerJournalACType::Ledger &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend        && _ledgerJournalTrans.AmountCurDebit   != 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger      && _ledgerJournalTrans.AmountCurCredit  != 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank        && _ledgerJournalTrans.AmountCurCredit  != 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust        && _ledgerJournalTrans.AmountCurDebit   != 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger      && _ledgerJournalTrans.AmountCurDebit   != 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust        && _ledgerJournalTrans.AmountCurCredit  != 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank        && _ledgerJournalTrans.AmountCurDebit   > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend        && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger      && _ledgerJournalTrans.AmountCurCredit  != 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (calcForVendorType && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend      && _ledgerJournalTrans.AmountCurDebit  != 0)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend    &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project      && _ledgerJournalTrans.AmountCurCredit  != 0)
            )
        {
            return -_amount;
        }

        return _amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBankAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates bank account.
    /// </summary>
    /// <param name="_ledgerJournalLoc">
    /// Buffer of <c> LedgerJournalTrans </c>.
    /// </param>
    /// <returns>
    /// Return false transaction is related to bank otherwise true.
    /// </returns>
    public static boolean validateBankAccount(LedgerJournalTrans _ledgerJournalLoc)
    {
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalLoc.ledgerJournalTransTaxExtensionIN();

        if ((_ledgerJournalLoc.AccountType     == LedgerJournalACType::Bank  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Cust  && _ledgerJournalLoc.AmountCurDebit  > 0 && ledgerJournalTransTaxExt.tcsGroup)
            || (_ledgerJournalLoc.AccountType  == LedgerJournalACType::Cust  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalLoc.AmountCurCredit > 0 && ledgerJournalTransTaxExt.tcsGroup)
            || (_ledgerJournalLoc.AccountType  == LedgerJournalACType::Bank  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Cust  && _ledgerJournalLoc.AmountCurCredit > 0)
            || (_ledgerJournalLoc.AccountType  == LedgerJournalACType::Bank  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Vend  && _ledgerJournalLoc.AmountCurCredit > 0)
            || (_ledgerJournalLoc.AccountType  == LedgerJournalACType::Vend  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalLoc.AmountCurDebit  > 0 && ledgerJournalTransTaxExt.tcsGroup)
            || (_ledgerJournalLoc.AccountType  == LedgerJournalACType::Bank  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Vend  && _ledgerJournalLoc.AmountCurCredit > 0 && ledgerJournalTransTaxExt.tcsGroup))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBankLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates bank account.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// Buffer of <c> LedgerJournalTrans </c>.
    /// </param>
    /// <returns>
    /// Returns true transaction is related to bank otherwise false.
    /// </returns>
    public static boolean validateBankLedger(LedgerJournalTrans _ledgerJournalTrans)
    {
        if ((_ledgerJournalTrans.AccountType  == LedgerJournalACType::Bank    &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger && _ledgerJournalTrans.AmountCurDebit  > 0)
           ||(_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank   && _ledgerJournalTrans.AmountCurCredit > 0)
           ||(_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank    &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger && _ledgerJournalTrans.AmountCurCredit > 0)
           ||(_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger  &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank   && _ledgerJournalTrans.AmountCurDebit  > 0))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCheque</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether Ledger transaction is related to cheque or not.
    /// </summary>
    /// <param name="_ledgerJournalLoc">
    /// Buffer of <c> LedgerJournalTrans </c>
    /// </param>
    /// <returns>
    /// If transaction is related to cheque returns true otherwise false.
    /// </returns>
    public static boolean validateCheque(LedgerJournalTrans _ledgerJournalLoc)
    {
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalLoc.ledgerJournalTransTaxExtensionIN();

        if ((_ledgerJournalLoc.AccountType                          == LedgerJournalACType::Cust  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalLoc.AmountCurDebit  > 0 && ledgerJournalTransTaxExt.tdsGroup)
            || (_ledgerJournalLoc.AccountType                      == LedgerJournalACType::Vend  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalLoc.AmountCurDebit  > 0 && ledgerJournalTransTaxExt.tdsGroup)
            || (_ledgerJournalLoc.AccountType                      == LedgerJournalACType::Vend  &&  _ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalLoc.AmountCurDebit  > 0 && ledgerJournalTransTaxExt.tcsGroup)
            || (_ledgerJournalLoc.ledgerJournalTable().JournalType == LedgerJournalType::VendPromissoryNoteDraw)
            || (_ledgerJournalLoc.ledgerJournalTable().JournalType == LedgerJournalType::CustBillOfExchangeDraw)
            || (_ledgerJournalLoc.ledgerJournalTable().JournalType == LedgerJournalType::CustBillOfExchangeRedraw))
        {
            return true;
        }

        if ( _ledgerJournalLoc.AccountType         == LedgerJournalACType::Vend        &&
            _ledgerJournalLoc.OffsetAccountType   == LedgerJournalACType::Ledger      &&
            _ledgerJournalLoc.AmountCurDebit      > 0                                 &&
            (ledgerJournalTransTaxExt.tcsGroup || ledgerJournalTransTaxExt.tdsGroup)  &&
            (MainAccount::findByLedgerDimension(_ledgerJournalLoc.OffsetLedgerDimension).PostingType == LedgerPostingType::PurchCash))
        {
            return true;
        }
        else if ( _ledgerJournalLoc.AccountType         == LedgerJournalACType::Ledger      &&
                 _ledgerJournalLoc.OffsetAccountType   == LedgerJournalACType::Vend        &&
                 _ledgerJournalLoc.AmountCurCredit     > 0                                 &&
                 (ledgerJournalTransTaxExt.tcsGroup || ledgerJournalTransTaxExt.tdsGroup)  &&
                 (MainAccount::findByLedgerDimension(_ledgerJournalLoc.LedgerDimension).PostingType == LedgerPostingType::PurchCash))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPriceInclusive</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected boolean isPriceInclusive(RefTableId _transactionLineTableId, RefRecId _transactionLineRecId)
    {
        boolean ret = super(_transactionLineTableId, _transactionLineRecId);

        if (_transactionLineTableId == tableNum(LedgerJournalTrans))
        {
            LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::findRecId(_transactionLineRecId, false);
            ret = this.isAdvancePayment(ledgerJournalTrans);
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>