<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>OxmlExcelReport_INV_5</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Open XML SDK Framework Excel report class for generating the contents of the "Print of counting list (INV-5)" report.
/// </summary>
class OxmlExcelReport_INV_5 extends XMLExcelReport_RU implements InventJournalReportPackable_RU, BatchRetryable, ERIReportPostProcessingSupported
{
    JournalId                   journalId;
    TransDate                   postDate;
    JournalNumOfLines           numofLines;

    TransDate                   creationDate;
    Num                         orderNumValue;
    TransDate                   resolutionDate;
    StartDate                   startDate;
    EndDate                     endDate;

    DialogField                 countingListCreationDate;
    DialogField                 orderNumber;
    DialogField                 orderDateValue;
    DialogField                 inventStartDateValue;
    DialogField                 inventEndDateValue;

    List                        inventReportsList;
    InventJournalReportType_RU  reportType;
    InventJournalProforma_RU    report;

    CompanyInfo         companyInfo;
    int                 counted;
    int                 countofInsertLine;
    int                 countofChairman;
    int                 countofMember;
    int                 countofPersonInCharge;
    int                 insertSheetNo;
    int                 lastInsertSheetNo;
    int                 lineNumOnSheet;
    OfficialsTrans_RU   officialsTrans_RU;
    InventJournalTrans  inventJournalTrans;
    InventDim           inventDim;
    InventOnhand        inventOnhand;
    InventDimParm       inventDimParm;
    InventDimGroupSetup inventDimGroupSetup;
    InventDim           inventDimCriteria;
    InventOwner_RU      inventOwner;
    InventBatch         inventBatch;
    InventTable         inventTable;
    InventProfile_RU    inventProfile;
    CostPrice           costPrice, costPriceCounted;
    Amount              countedAmount;

    InventBaileeReceiptReportId_RU  invoiceId;
    TransDate                       invoiceDate;

    real                countedSum;
    real                costPriceCountedSum;
    real                onhandSum;
    real                costPriceOnhandSum;
    real                countedSum_Page;
    real                costPriceCountedSum_Page;
    real                onhandSum_Page;
    real                costPriceOnhandSum_Page;

    Set                 wareHouseNamesSet;
    int                 lastPageNo;
    int                 interimSheetsCount;
    str                 documentName;

    SysRecordSortedList officialsTransRSL;

    protected const int FirstSheetNo = 1;
    protected const int InterimSheetNo = 2;
    protected const int LastSheetNo = 3;

    protected const str ReportHeader = 'REPORTHEADER';
    protected const str InterimPageHeader = 'INTERIMPAGEHEADER';
    protected const str InterimPageBody = 'INTERIMPAGEBODY';
    protected const str InterimPageFooter = 'INTERIMPAGEFOOTER';
    protected const str LastPageHeader = 'LASTPAGEHEADER';
    protected const str LastPageBody = 'LASTPAGEBODY';
    protected const str ReportFooter = 'REPORTFOOTER';

    str pageHeaderBookmark;
    str pageBodyBookmark;
    str pageFooterBookmark;

    protected const str Company = 'Company';
    protected const str Warehouse = 'Warehouse';
    protected const str OrderNum = 'OrderNum';
    protected const str OrderDate = 'OrderDate';
    protected const str ClassificationbyOKPO = 'ClassificationbyOKPO';
    protected const str InventStartDate = 'InventStartDate';
    protected const str InventEndDate = 'InventEndDate';
    protected const str InventOnHandDateDay = 'InventOnHandDateDay';
    protected const str InventOnHandDateMth = 'InventOnHandDateMth';
    protected const str InventOnHandDateYr = 'InventOnHandDateYr';
    protected const str InventJournalNum = 'InventJournalNum';
    protected const str CountingListCreateDate = 'CountingListCreateDate';
    protected const str PostingDateMth = 'PostingDateMth';
    protected const str PostingDateDay = 'PostingDateDay';
    protected const str PostingDateYr  = 'PostingDateYr';
    protected const int InterimSheetNumOfLines = 18;
    protected const str InterimSheetCountedSum = 'InterimSheetCountedSum';
    protected const str InterimSheetCostPriceCountedSum = 'InterimSheetCostPriceCountedSum';
    protected const str InterimSheetOnhandSum = 'InterimSheetOnhandSum';
    protected const str InterimSheetCostPriceOnhandSum = 'InterimSheetCostPriceOnhandSum';
    protected const int LastSheetNumOfLines = 5;
    protected const str LastSheetCountedSum = 'LastSheetCountedSum';
    protected const str LastSheetCostPriceCountedSum = 'LastSheetCostPriceCountedSum';
    protected const str LastSheetOnhandSum = 'LastSheetOnhandSum';
    protected const str LastSheetCostPriceOnhandSum = 'LastSheetCostPriceOnhandSum';
    protected const str LastSheetCountedSumTotal = 'LastSheetCountedSumTotal';
    protected const str LastSheetCostPriceCountedSumTotal = 'LastSheetCostPriceCountedSumTotal';
    protected const str LastSheetOnhandSumTotal = 'LastSheetOnhandSumTotal';
    protected const str LastSheetCostPriceOnhandSumTotal = 'LastSheetCostPriceOnhandSumTotal';
    protected const int NoOfDigitsOfCostPrice = 2;

    int     actualNumOfLines;

    int     fullInterimSheetsCount;
    int     fullInterimLinesCount;
    boolean hasAdditionalInterimSheet;
    int     additionalInterimSheetLinesCount;
    int     additionalInterimSheetNo;

    boolean isOnLastSheet;

    str sheetCountedSumBookmark;
    str sheetCostPriceCountedSumBookmark;
    str sheetOnHandSumBookmark;
    str sheetCostPriceOnhandSumBookmark;

    protected const str InChargeTitle1First = 'InChargeTitle1First';
    protected const str InChargeName1First  = 'InChargeName1First';
    protected const str InChargeTitle2First = 'InChargeTitle2First';
    protected const str InChargeName2First  = 'InChargeName2First';

    protected const str InChargeTitle1Last  = 'InChargeTitle1Last';
    protected const str InChargeName1Last   = 'InChargeName1Last';
    protected const str InChargeTitle2Last  = 'InChargeTitle2Last';
    protected const str InChargeName2Last   = 'InChargeName2Last';

    protected const str ChairmanTitle = 'ChairmanTitle';
    protected const str ChairmanName = 'ChairmanName';

    protected const str Member1Title = 'Member1Title';
    protected const str Member1Name  = 'Member1Name';
    protected const str Member2Title = 'Member2Title';
    protected const str Member2Name  = 'Member2Name';

    protected const str LineNumInterim = 'LineNumInterim';
    protected const str VendorNameInterim = 'VendorNameInterim';
    protected const str VendorOKPOInterim = 'VendorOKPOInterim';
    protected const str ItemNameInterim = 'ItemNameInterim';
    protected const str ItemIdInterim = 'ItemIdInterim';
    protected const str InventoryLocationNameInterim = 'InventoryLocationNameInterim';
    protected const str ProdDateInterim = 'ProdDateInterim';
    protected const str DocumentNameInterim = 'DocumentNameInterim';
    protected const str InvoiceIdInterim = 'InvoiceIdInterim';
    protected const str InvoiceDateInterim = 'InvoiceDateInterim';
    protected const str UnitNameInterim = 'UnitNameInterim';
    protected const str CodeOKEIInterim = 'CodeOKEIInterim';
    protected const str CountedQtyInterim = 'CountedQtyInterim';
    protected const str CountedAmountInterim = 'CountedAmountInterim';
    protected const str OnHandQtyInterim = 'OnHandQtyInterim';
    protected const str OnHandAmountInterim = 'OnHandAmountInterim';

    protected const str LineNumLast = 'LineNumLast';
    protected const str VendorNameLast = 'VendorNameLast';
    protected const str VendorOKPOLast = 'VendorOKPOLast';
    protected const str ItemNameLast = 'ItemNameLast';
    protected const str ItemIdLast = 'ItemIdLast';
    protected const str InventoryLocationNameLast = 'InventoryLocationNameLast';
    protected const str ProdDateLast = 'ProdDateLast';
    protected const str DocumentNameLast = 'DocumentNameLast';
    protected const str InvoiceIdLast = 'InvoiceIdLast';
    protected const str InvoiceDateLast = 'InvoiceDateLast';
    protected const str UnitNameLast = 'UnitNameLast';
    protected const str CodeOKEILast = 'CodeOKEILast';
    protected const str CountedQtyLast = 'CountedQtyLast';
    protected const str CountedAmountLast = 'CountedAmountLast';
    protected const str OnHandQtyLast = 'OnHandQtyLast';
    protected const str OnHandAmountLast = 'OnHandAmountLast';

    str lineNumBookmark;
    str vendorNameBookmark;
    str vendorOKPOBookmark;
    str itemNameBookmark;
    str itemIdBookmark;
    str inventoryLocationNameBookmark;
    str prodDateBookmark;
    str documentNameBookmark;
    str invoiceIdBookmark;
    str invoiceDateBookmark;
    str unitNameBookmark;
    str codeOkeiBookmark;
    str countedQtyBookmark;
    str countedAmountBookmark;
    str onHandQtyBookmark;
    str onHandAmountBookmark;

    str     vendorName;
    str     vendorOKPO;
    str     itemName;
    str     inventoryLocationName;
    str     prodDateStr;
    str     invoiceDateStr;
    str     unitName;
    str     codeOkei;
    real    countedAmountValue;
    real    onhandAmountValue;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcRangeHeight</Name>
				<Source><![CDATA[
    protected real calcRangeHeight(Bookmark _bookmark)
    {
        const real MinHeight = 15.0;

        return max(document.getNamedRangeHeightWrapped(vendorNameBookmark,              vendorName),
                   document.getNamedRangeHeightWrapped(vendorOKPOBookmark,              vendorOKPO),
                   document.getNamedRangeHeightWrapped(itemNameBookmark,                itemName),
                   document.getNamedRangeHeightWrapped(inventoryLocationNameBookmark,   inventoryLocationName),
                   document.getNamedRangeHeightWrapped(codeOkeiBookmark,                codeOkei),
                   MinHeight);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReport</Name>
				<Source><![CDATA[
    protected void createReport()
    {
        const int WidthInColumns = 40;
        const int InterimSheetCountDefault = 0;
        const int LastSheetNoDefault = 3;
        const int InventJournalTransRSLPos = 1;
        const int InventDimRSLPos = 2;

        int                 linesRemaining;
        VendTable           vendTable;
        SysRecordSortedList inventJournalTransRSL;
        SysRecordSortedList inventDimRSL;
        container           reportData;
        container           packedRSL;
        boolean             hasRecord;

        GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00049, funcName());

        isOnLastSheet               = false;
        hasAdditionalInterimSheet   = false;
        lastPageNo                  = LastSheetNoDefault;
        interimSheetsCount          = InterimSheetCountDefault;

        companyInfo = CompanyInfo::find();

        actualNumOfLines = OXMLExcelReport_INV_5::calcActualNumOfLines(journalId);

        if (actualNumOfLines > 1)
        {
            fullInterimSheetsCount = (actualNumOfLines - 1) div InterimSheetNumOfLines;
            fullInterimLinesCount = fullInterimSheetsCount * InterimSheetNumOfLines;
            linesRemaining = (actualNumOfLines - 1) - fullInterimLinesCount;
            if (linesRemaining > 0)
            {
                if (linesRemaining > 2 * LastSheetNumOfLines - 1)
                {
                    linesRemaining -= LastSheetNumOfLines;
                }
                additionalInterimSheetLinesCount = linesRemaining;
                hasAdditionalInterimSheet = true;
            }
        }

        lastPageNo += fullInterimSheetsCount;

        if (hasAdditionalInterimSheet)
        {
            additionalInterimSheetNo = fullInterimSheetsCount + 1;
            lastPageNo++;
        }

        insertSheetNo = 0;
        lastInsertSheetNo = 0;

        this.initSectionMap();

        this.setCurrentWorksheetNum(FirstSheetNo, WidthInColumns);

        this.execute(ReportHeader);

        this.setPrintArea();

        this.setCurrentWorksheetNum(InterimSheetNo, WidthInColumns);

        pageHeaderBookmark  = InterimPageHeader;
        pageBodyBookmark    = InterimPageBody;
        pageFooterBookmark  = InterimPageFooter;

        sheetCountedSumBookmark             = InterimSheetCountedSum;
        sheetCostPriceCountedSumBookmark    = InterimSheetCostPriceCountedSum;
        sheetOnHandSumBookmark              = InterimSheetOnhandSum;
        sheetCostPriceOnhandSumBookmark     = InterimSheetCostPriceOnhandSum;

        this.setItemBookmarks2InterimSheet();

        // perform single server call for report data retrieval
        reportData = OXMLExcelReport_INV_5::getReportDataPacked(journalId);

        packedRSL = conPeek(reportData, InventJournalTransRSLPos);
        inventJournalTransRSL = new SysRecordSortedList(tableNum(InventJournalTrans));
        inventJournalTransRSL.sortOrder(fieldNum(InventJournalTrans, JournalId), fieldNum(InventJournalTrans, LineNum));
        inventJournalTransRSL.unpack(packedRSL);

        packedRSL = conPeek(reportData, InventDimRSLPos);
        inventDimRSL = new SysRecordSortedList(tableNum(InventDim));
        inventDimRSL.sortOrder(fieldNum(inventDim, InventDimId));
        inventDimRSL.unpack(packedRSL);

        hasRecord = inventJournalTransRSL.first(inventJournalTrans);

        while (hasRecord)
        {
            inventDim.inventDimId = inventJournalTrans.InventDimId;
            inventDimRSL.find(inventDim);

            countofInsertLine ++;

            this.updateSheetNo();

            if (this.sheetNoChanged())
            {
                if (!this.isFirstPrintDataRow())
                {
                    this.execute(pageFooterBookmark);
                    document.insertPageBreak(currentRow, curWorksheetNum);
                    currentHeight = 0;
                    countedSum_Page = 0;
                    costPriceCountedSum_Page = 0;
                    onhandSum_Page = 0;
                    costPriceOnhandSum_Page = 0;
                }
                if (this.isLastSheet())
                {
                    if (!this.isFirstPrintDataRow())
                    {
                        this.setPrintArea();
                    }
                    this.setCurrentWorksheetNum(LastSheetNo, WidthInColumns);
                    pageHeaderBookmark                  = LastPageHeader;
                    pageBodyBookmark                    = LastPageBody;
                    pageFooterBookmark                  = '';
                    sheetCountedSumBookmark             = LastSheetCountedSum;
                    sheetCostPriceCountedSumBookmark    = LastSheetCostPriceCountedSum;
                    sheetOnHandSumBookmark              = LastSheetOnhandSum;
                    sheetCostPriceOnhandSumBookmark     = LastSheetCostPriceOnhandSum;
                    this.setItemBookmarks2LastSheet();
                }
                this.execute(pageHeaderBookmark);
            }

            this.updateLastSheetNo();

            inventDimGroupSetup = InventDimGroupSetup::newInventTable(inventJournalTrans.inventTable());
            inventDimGroupSetup.inventDimParmActiveFinancialInventory(inventDimParm);
            inventOnhand = InventOnhand::newParameters(inventJournalTrans.ItemId, inventDim, inventDimParm);
            costPrice = inventOnhand.costPricePcs(false, inventJournalTrans.TransDate);

            if (inventJournalTrans.Qty > 0)
            {
                costPriceCounted = inventJournalTrans.CostPrice;
                countedAmount    = inventJournalTrans.Qty * costPriceCounted + inventJournalTrans.InventOnHand * costPrice;
            }
            else
            {
                costPriceCounted = costPrice;
                countedAmount    = inventJournalTrans.Counted * costPrice;
            }

            countedSum += inventJournalTrans.Counted;
            countedSum_Page += inventJournalTrans.Counted;
            costPriceCountedSum += countedAmount;
            costPriceCountedSum_Page += countedAmount;

            onhandSum += inventJournalTrans.InventOnHand;
            onhandSum_Page += inventJournalTrans.InventOnHand;
            costPriceOnhandSum += costPrice * inventJournalTrans.InventOnHand;
            costPriceOnhandSum_Page += costPrice * inventJournalTrans.InventOnHand;

            inventOwner = InventOwner_RU::find(inventDim.InventOwnerId_RU);
            if (inventOwner)
            {
                vendTable = inventOwner.vendTable();
            }
            else
            {
                vendTable = null;
            }

            if (vendTable)
            {
                vendorName = vendTable.name();
                vendorOKPO = vendTable.partyOKPOasOfDate_RU();
            }
            else
            {
                vendorName = '';
                vendorOKPO = '';
            }

            inventoryLocationName = inventDim.inventLocation().Name;

            inventBatch = InventBatch::find(inventDim.InventBatchId, inventJournalTrans.ItemId);
            if (inventBatch)
            {
                prodDateStr = date2str(inventBatch.ProdDate, 123, DateDay::Digits2, DateSeparator::Auto, DateMonth::Digits2, DateSeparator::Auto, DateYear::Digits2, DateFlags::None);
            }
            else
            {
                prodDateStr = '';
            }

            if (invoiceDate)
            {
                invoiceDateStr = date2str(invoiceDate, 123, DateDay::Digits2, DateSeparator::Auto, DateMonth::Digits2, DateSeparator::Auto, DateYear::Digits2, DateFlags::None);
            }
            else
            {
                invoiceDateStr = '';
            }

            inventTable = InventTable::find(inventJournalTrans.ItemId);

            UnitOfMeasureSymbol unitOfMeasureSymbol = inventJournalTrans.unitId();
            str unitNameDescription = UnitOfMeasureTranslation::findByTranslation(UnitOfMeasure::findBySymbol(unitOfMeasureSymbol).RecId, companyInfo.LanguageId).Description;
            unitName = unitNameDescription ? unitNameDescription : unitOfMeasureSymbol;
            InventDimCombination inventDimCombination = InventDimCombination::findByInventDim(inventJournalTrans.ItemId, inventDim);
            itemName = inventDimCombination.RecId ? inventDimCombination.defaultProductName() : inventTable.defaultProductName();

            codeOkei = UnitOfMeasure_RU::codeOKEI_RU(UnitOfMeasure::findBySymbol(inventJournalTrans.unitId()));
            countedAmountValue = decRound(countedAmount, NoOfDigitsOfCostPrice);
            onhandAmountValue  = decRound(costPrice * inventJournalTrans.InventOnHand, NoOfDigitsOfCostPrice);

            this.execute(pageBodyBookmark);

            hasRecord = inventJournalTransRSL.next(inventJournalTrans);
        }

        if (insertSheetNo != lastPageNo)
        {
            this.execute(InterimPageFooter);
            this.setPrintArea();
            this.setCurrentWorksheetNum(LastSheetNo, WidthInColumns);
            pageHeaderBookmark                  = LastPageHeader;
            pageBodyBookmark                    = LastPageBody;
            pageFooterBookmark                  = '';
            sheetCountedSumBookmark             = LastSheetCountedSum;
            sheetCostPriceCountedSumBookmark    = LastSheetCostPriceCountedSum;
            sheetOnHandSumBookmark              = LastSheetOnhandSum;
            sheetCostPriceOnhandSumBookmark     = LastSheetCostPriceOnhandSum;
            this.setItemBookmarks2LastSheet();
            this.execute(pageHeaderBookmark);
        }

        this.execute(ReportFooter);
        this.setPrintArea();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    public Object dialog()
    {
        Dialog    dialog = super();

        TransDate defaultActCreateDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

        if (dialog)
        {
            dialog.addTabPage("@GLS104385");
            countingListCreationDate = dialog.addFieldValue(extendedTypeStr(TransDate), defaultActCreateDate, "@GLS113031");

            dialog.addGroup("@GLS102458");
            orderNumber     = dialog.addFieldValue(extendedTypeStr(Num),       orderNumValue,        "@GLS114049");
            orderDateValue       = dialog.addFieldValue(extendedTypeStr(TransDate), resolutionDate,  "@GLS113092");
            inventStartDateValue = dialog.addFieldValue(extendedTypeStr(StartDate), startDate,       "@GLS102456");
            inventEndDateValue   = dialog.addFieldValue(extendedTypeStr(EndDate),   endDate,         "@GLS102457");

            dialog.addMenuItemButton(MenuItemType::Display, menuitemDisplayStr(InventJournalPrint_RU), DialogMenuItemGroup::BottomGrp);
        }
        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fileName</Name>
				<Source><![CDATA[
    protected Filename fileName()
    {
        return 'INV-5';
    }

]]></Source>
			</Method>
			<Method>
				<Name>fileNamePostfix</Name>
				<Source><![CDATA[
    protected Filename fileNamePostfix()
    {
        return '_' + journalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportFileName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the name of the report file.
    /// </summary>
    /// <returns>
    /// The name of the report file.
    /// </returns>
    public str getReportFileName()
    {
        return this.excelFileName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the name of the report.
    /// </summary>
    /// <returns>
    /// Name of the report.
    /// </returns>
    public str getReportName()
    {
        return 'INV5';
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillData</Name>
				<Source><![CDATA[
    protected void fillData(MSOfficeBookMark_RU _bookmark)
    {
        switch (_bookmark)
        {
            case ReportHeader:
                this.fillReportHeader();
                break;
            case pageBodyBookmark:
                this.fillPageBody();
                break;
            case pageFooterBookmark:
                this.fillPageFooter();
                break;
            case ReportFooter:
                this.fillReportFooter();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillPageBody</Name>
				<Source><![CDATA[
    private void fillPageBody()
    {
        this.insertValueToSection(lineNumBookmark,                  countofInsertLine);
        this.insertValueToSection(vendorNameBookmark,               vendorName);
        this.insertValueToSection(vendorOKPOBookmark,               vendorOKPO);
        this.insertValueToSection(itemNameBookmark,                 itemName);
        this.insertValueToSection(itemIdBookmark,                   inventJournalTrans.ItemId);
        this.insertValueToSection(inventoryLocationNameBookmark,    inventoryLocationName);
        this.insertValueToSection(prodDateBookmark,                 prodDateStr);
        [invoiceId, invoiceDate, documentName] = OXMLExcelReport_INV_5::getReceiptInfoCon(inventJournalTrans, inventDimCriteria);
        this.insertValueToSection(documentNameBookmark,             documentName);
        this.insertValueToSection(invoiceIdBookmark,                invoiceId);
        this.insertValueToSection(invoiceDateBookmark,              invoiceDateStr);
        this.insertValueToSection(unitNameBookmark,                 unitName);
        this.insertValueToSection(codeOkeiBookmark,                 codeOkei);
        this.insertValueToSection(countedQtyBookmark,               inventJournalTrans.Counted);
        this.insertValueToSection(countedAmountBookmark,            countedAmountValue);
        this.insertValueToSection(onHandQtyBookmark,                inventJournalTrans.InventOnHand);
        this.insertValueToSection(onHandAmountBookmark,             onhandAmountValue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillPageFooter</Name>
				<Source><![CDATA[
    private void fillPageFooter()
    {
        this.insertValueToSection(sheetCountedSumBookmark,          countedSum_Page);
        this.insertValueToSection(sheetCostPriceCountedSumBookmark, decRound(costPriceCountedSum_Page, NoOfDigitsOfCostPrice));
        this.insertValueToSection(sheetOnhandSumBookmark,           onhandSum_Page);
        this.insertValueToSection(sheetCostPriceOnhandSumBookmark,  decRound(costPriceOnhandSum_Page, NoOfDigitsOfCostPrice));
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillReportFooter</Name>
				<Source><![CDATA[
    private void fillReportFooter()
    {
        Bookmark    inChargeTitleBookmark, inChargeNameBookmark;
        Bookmark    memberTitleBookmark, memberNameBookmark;
        boolean     hasRecord;

        this.fillPageFooter();
        this.insertValueToSection(LastSheetCountedSumTotal,          countedSum);
        this.insertValueToSection(LastSheetCostPriceCountedSumTotal, decRound(costPriceCountedSum, NoOfDigitsOfCostPrice));
        this.insertValueToSection(LastSheetOnhandSumTotal,           onhandSum);
        this.insertValueToSection(LastSheetCostPriceOnhandSumTotal,  decRound(costPriceOnhandSum, NoOfDigitsOfCostPrice));

        if (postDate)
        {
            this.insertValueToSection(PostingDateDay,  dayOfMth(postDate));
            this.insertValueToSection(PostingDateMth,  strLwr(RNumDateInWordConverter::construct().date2strMonth(postDate)));
            this.insertValueToSection(PostingDateYr,   year(postDate));
        }
        else
        {
            this.insertValueToSection(PostingDateDay, '');
            this.insertValueToSection(PostingDateMth, '');
            this.insertValueToSection(PostingDateYr, '');
        }

        countofPersonInCharge = 0;
        countofChairman = 0;
        countofMember = 0;

        inChargeTitleBookmark   = InChargeTitle1Last;
        inChargeNameBookmark    = InChargeName1Last;
        memberTitleBookmark     = Member1Title;
        memberNameBookmark      = Member1Name;

        officialsTransRSL = this.getOfficialsTransRSL();

        hasRecord = officialsTransRSL.first(officialsTrans_RU);

        while (hasRecord)
        {
            switch (officialsTrans_RU.Position)
            {
                case OffPosition_RU::InCharge :
                    if (countOfPersonInCharge < 2)
                    {
                        this.insertValueToSection(inChargeTitleBookmark, officialsTrans_RU.Title);
                        this.insertValueToSection(inChargeNameBookmark, officialsTrans_RU.Name);
                        countofPersonInCharge ++;
                        inChargeTitleBookmark   = InChargeTitle2Last;
                        inChargeNameBookmark    = InChargeName2Last;
                    }
                    break;

                case OffPosition_RU::Chairman :
                    if (! countofChairman)
                    {
                        this.insertValueToSection(ChairmanTitle, officialsTrans_RU.Title);
                        this.insertValueToSection(ChairmanName, officialsTrans_RU.Name);
                        countofChairman ++;
                    }
                    break;

                case OffPosition_RU::Member:
                    if (countofMember < 2)
                    {
                        this.insertValueToSection(memberTitleBookmark, officialsTrans_RU.Title);
                        this.insertValueToSection(memberNameBookmark, officialsTrans_RU.Name);
                        countofMember ++;
                        memberTitleBookmark = Member2Title;
                        memberNameBookmark  = Member2Name;
                    }
                    break;

                default:
                    break;
            }

            hasRecord = officialsTransRSL.next(officialsTrans_RU);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillReportHeader</Name>
				<Source><![CDATA[
    private void fillReportHeader()
    {
        Bookmark inChargeTitleBookmark, inChargeNameBookmark;
        boolean  hasRecord;

        this.insertValueToSection(Company,                 companyInfo.Name);
        this.insertValueToSection(OrderNum,                orderNumValue);
        this.insertValueToSection(OrderDate,               resolutionDate);
        this.insertValueToSection(ClassificationbyOKPO,    CompanyInfoHelper::partyOKPOasOfDate_RU(companyInfo));
        this.insertValueToSection(InventStartDate,         startDate);
        this.insertValueToSection(InventEndDate,           endDate);
        this.insertValueToSection(InventJournalNum,        journalId);
        this.insertValueToSection(InventJournalNum,  creationDate);
        this.insertValueToSection(InventOnHandDateDay,     dayOfMth(endDate));
        this.insertValueToSection(InventOnHandDateMth,     strLwr(RNumDateInWordConverter::construct().date2strMonth(endDate)));
        this.insertValueToSection(InventOnHandDateYr,      year(endDate));

        inChargeTitleBookmark   = InChargeTitle1First;
        inChargeNameBookmark    = InChargeName1First;

        officialsTransRSL = this.getOfficialsTransRSL();

        hasRecord = officialsTransRSL.first(officialsTrans_RU);

        while (hasRecord)
        {
            if (countOfPersonInCharge < 2)
            {
                this.insertValueToSection(inChargeTitleBookmark,
                                          officialsTrans_RU.Title);
                this.insertValueToSection(inChargeNameBookmark,
                                          officialsTrans_RU.Name);

                countofPersonInCharge ++;
                if (countofPersonInCharge >= 2)
                {
                    break;
                }
                inChargeTitleBookmark   = InChargeTitle2First;
                inChargeNameBookmark    = InChargeName2First;
            }
            else
            {
                break;
            }

            hasRecord = officialsTransRSL.next(officialsTrans_RU);
        }

        // Warehouse
        wareHouseNamesSet = Set::create(OXMLExcelReport_INV_5::getWarehouseNamesSetPacked(journalId));

        // 2. WareHouse
        this.insertValueToSection(Warehouse, subStr(wareHouseNamesSet.toString(), 2, strLen(wareHouseNamesSet.toString()) - 2));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        boolean ret;

        ret = super();

        creationDate    = countingListCreationDate.value();
        orderNumValue        = orderNumber.value();
        resolutionDate  = orderDateValue.value();
        startDate       = inventStartDateValue.value();
        endDate         = inventEndDateValue.value();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOfficialsTransRSL</Name>
				<Source><![CDATA[
    private SysRecordSortedList getOfficialsTransRSL()
    {
        container officialsTransPacked;

        if (!officialsTransRSL)
        {
            officialsTransPacked = OXMLExcelReport_INV_5::getOfficialsTransPacked(report.getOffSessionId());
            officialsTransRSL = new SysRecordSortedList(tableNum(OfficialsTrans_RU));
            officialsTransRSL.sortOrder(fieldNum(OfficialsTrans_RU, OffSessionId), fieldNum(OfficialsTrans_RU, Position), fieldNum(OfficialsTrans_RU, RecId));
            officialsTransRSL.unpack(officialsTransPacked);
        }

        return officialsTransRSL;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initReportData</Name>
				<Source><![CDATA[
    private void initReportData(InventJournalTable _inventJournalTable, InventJournalReportType_RU _reportType)
    {
        ;
        reportType         = _reportType;
        inventReportsList  = new List(Types::Class);
        report             = InventJournalProforma_RU::construct(reportType);
        report.initOfficialsDefault(_inventJournalTable.OffSessionId_RU);
        inventReportsList.addEnd(report);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSectionMap</Name>
				<Source><![CDATA[
    protected void initSectionMap()
    {
        this.addSection(ReportHeader);
        this.addSection(InterimPageHeader);
        this.addSection(InterimPageBody, true);
        this.addSection(InterimPageFooter);
        this.addSection(LastPageHeader);
        this.addSection(LastPageBody, true);
        this.addSection(ReportFooter);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFirstPrintDataRow</Name>
				<Source><![CDATA[
    private boolean isFirstPrintDataRow()
    {
        return insertSheetNo && !lastInsertSheetNo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLastSheet</Name>
				<Source><![CDATA[
    private boolean isLastSheet()
    {
        return isOnLastSheet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateNewPage</Name>
				<Source><![CDATA[
    private boolean mustCreateNewPage()
    {
        real    requiredHeight;

        requiredHeight = this.getRangeHeight(pageBodyBookmark);

        if (countofInsertLine == numofLines && countofInsertLine != 1 && pageFooterBookmark)
        {
            requiredHeight += conPeek(mapSections.lookup(pageFooterBookmark), #posSectionHeight);
        }

        return pageHeight - currentHeight < requiredHeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPrintSection</Name>
				<Source><![CDATA[
    /// <summary>
    /// A method determining whether to print a section identified by a bookmark given.
    /// </summary>
    /// <param name="_bookmark">
    /// A bookmark idetifying the section area to print.
    /// </param>
    /// <returns>
    /// A boolean value determining whether or not to print the section.
    /// </returns>
    /// <remarks>
    /// Do not print section identyfied by an empty bookmark.
    /// </remarks>
    protected boolean mustPrintSection(MSOfficeBookMark_RU _bookmark)
    {
        boolean ret;

        if (!_bookmark)
        {
            return false;
        }

        ret = super(_bookmark);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>packReportList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the inventReportsList.
    /// </summary>
    /// <returns>
    /// Packed inventReportsList.
    /// </returns>
    public container packReportList()
    {
        if (inventReportsList)
            return inventReportsList.pack();
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalId</Name>
				<Source><![CDATA[
    public JournalId parmJournalId(JournalId _journalId = journalId)
    {
        ;
        journalId = _journalId;
        return journalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumofLines</Name>
				<Source><![CDATA[
    public JournalNumOfLines parmNumofLines(JournalNumOfLines _numofLines = numofLines)
    {
        ;
        numofLines = _numofLines;
        return numofLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostDate</Name>
				<Source><![CDATA[
    public TransDate parmPostDate(TransDate _postDate = postDate)
    {
        ;
        postDate = _postDate;
        return postDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setItemBookmarks2InterimSheet</Name>
				<Source><![CDATA[
    private void setItemBookmarks2InterimSheet()
    {
        lineNumBookmark                 = LineNumInterim;
        vendorNameBookmark              = VendorNameInterim;
        vendorOKPOBookmark              = VendorOKPOInterim;
        itemNameBookmark                = ItemNameInterim;
        itemIdBookmark                  = ItemIdInterim;
        inventoryLocationNameBookmark   = InventoryLocationNameInterim;
        prodDateBookmark                = ProdDateInterim;
        documentNameBookmark            = DocumentNameInterim;
        invoiceIdBookmark               = InvoiceIdInterim;
        invoiceDateBookmark             = InvoiceDateInterim;
        unitNameBookmark                = UnitNameInterim;
        codeOkeiBookmark                = CodeOKEIInterim;
        countedQtyBookmark              = CountedQtyInterim;
        countedAmountBookmark           = CountedAmountInterim;
        onHandQtyBookmark               = OnhandQtyInterim;
        onHandAmountBookmark            = OnhandAmountInterim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setItemBookmarks2LastSheet</Name>
				<Source><![CDATA[
    private void setItemBookmarks2LastSheet()
    {
        lineNumBookmark                 = LineNumLast;
        vendorNameBookmark              = VendorNameLast;
        vendorOKPOBookmark              = VendorOKPOLast;
        itemNameBookmark                = ItemNameLast;
        itemIdBookmark                  = ItemIdLast;
        inventoryLocationNameBookmark   = InventoryLocationNameLast;
        prodDateBookmark                = ProdDateLast;
        documentNameBookmark            = DocumentNameLast;
        invoiceIdBookmark               = InvoiceIdLast;
        invoiceDateBookmark             = InvoiceDateLast;
        unitNameBookmark                = UnitNameLast;
        codeOkeiBookmark                = CodeOKEILast;
        countedQtyBookmark              = CountedQtyLast;
        countedAmountBookmark           = CountedAmountLast;
        onHandQtyBookmark               = OnhandQtyLast;
        onHandAmountBookmark            = OnhandAmountLast;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sheetNoChanged</Name>
				<Source><![CDATA[
    private boolean sheetNoChanged()
    {
        return insertSheetNo != lastInsertSheetNo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateName</Name>
				<Source><![CDATA[
    protected Filename templateName()
    {
        return resourceStr(INV5_RU);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalCells</Name>
				<Source><![CDATA[
    protected Counter totalCells()
    {
        const Counter OtherCells = 35;
        const Counter LineCells = 16;

        return OtherCells + LineCells * actualNumOfLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLastSheetNo</Name>
				<Source><![CDATA[
    private void updateLastSheetNo()
    {
        lastInsertSheetNo = insertSheetNo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSheetNo</Name>
				<Source><![CDATA[
    private void updateSheetNo()
    {
        if (this.isLastSheet())
        {
            return;
        }
        if (countofInsertLine <= fullInterimLinesCount)
        {
            // interim sheet
            insertSheetNo = ((countofInsertLine-1) div InterimSheetNumOfLines) + 1;
        }
        else if (countofInsertLine - fullInterimLinesCount <= additionalInterimSheetLinesCount)
        {
            // additional interim sheet
            insertSheetNo = additionalInterimSheetNo;
        }
        else
        {
            // last sheet
            insertSheetNo = lastPageNo;
            isOnLastSheet = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcActualNumOfLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the actual number of report lines.
    /// </summary>
    /// <param name="_journalId">
    /// The journal id to calculate the number of lines for.
    /// </param>
    /// <returns>
    /// The actual number of lines for the report.
    /// </returns>
    private static int calcActualNumOfLines(JournalId _journalId)
    {
        InventJournalTrans  inventJournalTrans;
        InventDim           inventDim;
        InventProfile_RU    inventProfile;

        select count (RecId) from inventJournalTrans
            where inventJournalTrans.JournalId    == _journalId
        exists join inventDim
            where inventDim.InventDimId           == inventJournalTrans.InventDimId
        join RecId from inventProfile
            where inventProfile.InventProfileId   == inventDim.InventProfileId_RU &&
                  inventProfile.InventProfileType == InventProfileType_RU::Bailee;

        return int642int(inventJournalTrans.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static OXMLExcelReport_INV_5 construct()
    {
        return new OXMLExcelReport_INV_5();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@GLS115660";
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOfficialsTransPacked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides Officials - report lines data in a form of a packed RecordSortedList.
    /// </summary>
    /// <param name="_offSessionId">
    /// The Official session id to retrieve data for.
    /// </param>
    /// <returns>
    /// Packed RecordSortedList of <c>OfficialsTrans_RU</c> records.
    /// </returns>
    /// <remarks>
    /// This method is used to retrieve all Officials - report lines records in a single server RPC-call.
    /// </remarks>
    private static container getOfficialsTransPacked(OffSessionId_RU _offSessionId)
    {
        SysRecordSortedList officialsRSL;
        OfficialsTrans_RU   officialsTrans_RU;

        officialsRSL = new SysRecordSortedList(tableNum(OfficialsTrans_RU));
        officialsRSL.sortOrder(fieldNum(OfficialsTrans_RU, OffSessionId), fieldNum(OfficialsTrans_RU, Position), fieldNum(OfficialsTrans_RU, RecId));

        while select officialsTrans_RU
            where officialsTrans_RU.ReportType   == OffReportType_RU::InventINV5 &&
                  officialsTrans_RU.OffSessionId == _offSessionId
        {
            officialsRSL.ins(officialsTrans_RU);
        }

        return officialsRSL.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReceiptInfoCon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides recipient info in a for of container.
    /// </summary>
    /// <param name="_inventJournalTrans">
    /// The <c>InventJournalTrans</c> record to provide recipient info for.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The <c>InventDim</c> record to provide recipient info for.
    /// </param>
    /// <returns>
    /// Recipient info packed in a container.
    /// </returns>
    private static container getReceiptInfoCon(InventJournalTrans _inventJournalTrans, InventDim _inventDimCriteria)
    {
        const int InvoiceIdPos = 1;
        const int InvoiceDatePos = 2;
        const str DocumentName = 'МХ-1';

        InventTransOrigin   inventTransOrigin;
        InventTrans         inventTrans;
        InventDim           inventDimLoc;
        InventDimParm       inventDimParmLoc;

        VendInvoiceJour     invoiceJour;
        VendInvoiceTrans    invoiceTrans;

        InventBaileeReceiptReportId_RU  invoiceIdLoc;
        TransDate                       invoiceDateLoc;

        boolean isFirst = true;

        container ret;
        
        inventDimParmLoc.initFromInventDim(_inventDimCriteria);

        while select DateFinancial, DatePhysical, InvoiceId from inventTrans
            where inventTrans.ItemId        == _inventJournalTrans.ItemId &&
                 (inventTrans.StatusReceipt == StatusReceipt::Received ||
                  inventTrans.StatusReceipt == StatusReceipt::Purchased) &&
                  inventTrans.StatusIssue   == StatusIssue::None &&
                  inventTrans.DatePhysical  <= _inventJournalTrans.TransDate
        join ReferenceCategory, InventTransId from inventTransOrigin
            where inventTransOrigin.RecId == inventTrans.InventTransOrigin
        #InventDimJoin(inventTrans.inventDimId, inventDimLoc, _inventDimCriteria, inventDimParmLoc, InventOwnerIdx_RU)
        {
            invoiceTrans = VendInvoiceTrans::find(inventTransOrigin.InventTransId);
            invoiceJour  = invoiceTrans.vendInvoiceJour();

            if (! isFirst)
            {
                invoiceIdLoc   = '';
                invoiceDateLoc = dateNull();

                break;
            }

            if (inventTransOrigin.ReferenceCategory == InventTransType::Purch)
            {
                invoiceIdLoc   = invoiceJour.InventBaileeReceiptReportId_RU;
                invoiceDateLoc = inventTrans.DateFinancial;
            }

            isFirst = false;
        }

        ret = conIns(ret, InvoiceIdPos, invoiceIdLoc);
        ret = conIns(ret, InvoiceDatePos, invoiceDateLoc);

        if (invoiceIdLoc && invoiceDateLoc)
            ret += DocumentName;
        else
            ret += '';

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportDataPacked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides data for the report in a packed container representation.
    /// </summary>
    /// <param name="_journalId">
    /// The Inventory journal id to select lines for.
    /// </param>
    /// <returns>
    /// <c>container</c> consisting of packed <c>InventJournalTrans</c> RSL and packed <c>InventDim</c> RSL.
    /// </returns>
    /// <remarks>
    /// The method is used to eliminate eccessive client-server RPC-calls and allows to select all report data in a single server call.
    /// </remarks>
    private static container getReportDataPacked(JournalId _journalId)
    {
        InventJournalTrans  inventJournalTrans;
        InventDim           inventDim;
        InventProfile_RU    inventProfile;

        SysRecordSortedList inventJournalTransRSL;
        SysRecordSortedList inventDimRSL;

        inventJournalTransRSL = new SysRecordSortedList(tableNum(InventJournalTrans));
        inventJournalTransRSL.sortOrder(fieldNum(InventJournalTrans, JournalId), fieldNum(InventJournalTrans, LineNum));

        inventDimRSL = new SysRecordSortedList(tableNum(InventDim));
        inventDimRSL.sortOrder(fieldNum(InventDim, InventDimId));

        while select inventJournalTrans
            where inventJournalTrans.JournalId    == _journalId
        join inventDim
            where inventDim.InventDimId           == inventJournalTrans.InventDimId
        join RecId from inventProfile
            where inventProfile.InventProfileId   == inventDim.InventProfileId_RU &&
                  inventProfile.InventProfileType == InventProfileType_RU::Bailee
        {
            inventJournalTransRSL.ins(inventJournalTrans);
            inventDimRSL.ins(inventDim);
        }

        return [inventJournalTransRSL.pack(), inventDimRSL.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWarehouseNamesSetPacked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides warehouses names info in a form of a packed <c>Set</c> class.
    /// </summary>
    /// <param name="_journalId">
    /// The journal id to retrieve warehouses names for.
    /// </param>
    /// <returns>
    /// Packed <c>Set</c> of warehouse names.
    /// </returns>
    private static container getWarehouseNamesSetPacked(JournalId _journalId)
    {
        InventJournalTrans  inventJournalTrans;
        InventDim           inventDim;
        Set                 wareHouseNamesSet;

        wareHouseNamesSet = new Set(Types::String);

        while select RecId from inventJournalTrans
            where inventJournalTrans.JournalId == _journalId
        join InventLocationId from inventDim
            where inventDim.InventDimId        == inventJournalTrans.InventDimId
               && inventDim.InventLocationId
        {
            wareHouseNamesSet.add(inventDim.InventLocationId);
        }

        return wareHouseNamesSet.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        OXMLExcelReport_INV_5 report;

        if (! _args || _args.dataset() != tableNum(InventJournalTable))
            throw error(strFmt("@SYS25516", OXMLExcelReport_INV_5::description()));

        report = OXMLExcelReport_INV_5::newFromArgs(_args);

        if (report.prompt())
        {
            report.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromArgs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instsance of the <c>OXMLExcelReport_INV_5</c> class from Args.
    /// </summary>
    /// <param name="_args">
    /// The Args containing the data for the report to be instantiated from.
    /// </param>
    /// <returns>
    /// An instance of the <c>OXMLExcelReport_INV_5</c> class.
    /// </returns>
    public static OXMLExcelReport_INV_5 newFromArgs(Args _args)
    {
        OXMLExcelReport_INV_5   report = OXMLExcelReport_INV_5::construct();
        InventJournalTable      inventJournalTable = _args.record();

        report.parmJournalId (inventJournalTable.JournalId);
        report.parmPostDate  (DateTimeUtil::date(inventJournalTable.PostedDateTime));
        report.parmNumofLines(inventJournalTable.NumOfLines);
        report.initReportData(inventJournalTable, InventJournalReportType_RU::CountingListBailee);

        return report;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls whether the batch task should be retried in case of transient errors.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>