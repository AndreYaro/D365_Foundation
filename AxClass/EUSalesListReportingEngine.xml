<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>EuSalesListReportingEngine</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics365.LocalizationFramework;

/// <summary>
///    The <c>EUSalesListReportingEngine</c> class prompts the user for inputs for reports, file
///    generation and sending files electronically,  and groups the EU sales list data and fills up the
///    dataset that will be used by GER.
/// </summary>
/// <remarks>
///    Country specific implementations of EU sales list can override this class to change the data
///    grouping and presentation logic.
/// </remarks>
public class EuSalesListReportingEngine extends RunBaseBatch implements BatchRetryable
{
    private const str FeatureReference = 'EUR-00011';
    private const str FeatureRefReportingByTaxId = 'EUR-00030';
    private const str erModelName = 'EU Sales list';

    QueryRun                             queryRun;
    FromDate                             fromDate;
    TaxRegistrationRecId                 taxRegistrationRecId;
    ToDate                               toDate;
    Filename                             filename;
    Filename                             reportName;
    NoYesId                              generateFile;
    NoYesId                              generateReport;
    EUSalesListReportingPeriodType       reportingPeriodType;
    NoYesId                              sendElectronically;
    ERIFileDestination                   fileDestination;

    DialogGroup                          dialogGroupDate;
    DialogGroup                          dialogGroupExportOptions;
    DialogField                          dialogFromDate;
    DialogField                          dialogToDate;
    DialogField                          dialogGenerateFile;
    DialogField                          dialogGenerateReport;
    DialogField                          dialogDeclarationType;
    DialogField                          dialogFilename;
    DialogField                          dialogReportName;
    DialogField                          dialogReportingPeriodType;
    DialogField                          dialogSendElectronically;
    FormBuildButtonControl               buildButtonControlDestinations;
    FormButtonControl                    buttonControlDestinations;

    LogisticsAddressCountryRegionId      lastCountryRegionId;
    VATNum                               lastVATNum;
    ModuleSalesPurch                     lastDirection;
    Line                                 lineCount;
    Line                                 amountCount;
    AmountMST                            totalAmountItems;
    AmountMST                            totalAmountServices;
    AmountMST                            totalAmountTriangular;
    RefRecId                             euSalesListReportingHeaderRecId;
    Args                                 args;
    boolean                              dontThrowOnMissingData;

    private ERParametersCustomDialogHandler erParametersHandlerFile, erParametersHandlerReport;
    private ERIFormatMappingRun erFormatMappingFile, erFormatMappingReport;
    private DialogGroup dialogGroupFileFormat, dialogGroupReportFormat;

    #Xml
    #AOT
    #file
    #ISOCountryRegionCodes
    #define.CurrentVersion(2)

    #localmacro.CurrentList
        fromDate,
        toDate,
        reportingPeriodType,
        generatefile,
        filename,
        generateReport,
        reportName,
        sendElectronically
    #endmacro
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes and inserts a record in the <c>EUSalesListReportingGroup</c> table.
    /// </summary>
    /// <param name="_euSalesListReportingHeaderRecId">
    ///    The reference to the header record to which the group belongs.
    /// </param>
    /// <returns>
    ///    A <c>EUSalesListReportingGroup</c> table buffer.
    /// </returns>
    protected EUSalesListReportingGroup addGroup(RefRecId _euSalesListReportingHeaderRecId)
    {
        EUSalesListReportingGroup euSalesListReportingGroup;

        euSalesListReportingGroup.euSalesListReportingHeader = _euSalesListReportingHeaderRecId;
        euSalesListReportingGroup.insert();

        return euSalesListReportingGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes and inserts a record in the <c>EUSalesListReportingHeader</c> table.
    /// </summary>
    /// <returns>
    ///    A <c>EUSalesListReportingHeader</c> table buffer.
    /// </returns>
    protected EUSalesListReportingHeader addHeader()
    {
        EUSalesListReportingHeader euSalesListReportingHeader;
        IntrastatParameters        intrastatParameters = IntrastatParameters::find();
        CompanyInfo                companyInfo = CompanyInfo::find();
        VATNum                     companyVATNum;
        CompanyCoRegNum            companyCoRegNum;
        CompanyBranchId            branchId;
        EUSalesListTax             euSalesListTaxCode;

        if (TaxIntegrationUtils::isMultipleTaxIdEnabledForEUSalesList() || TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            companyVATNum = TaxRegistration::find(taxRegistrationRecId).RegistrationNumber;
            companyCoRegNum = this.getCompanyEnterpriseNumber();
            branchId = this.getCompanyBranchId();
            euSalesListTaxCode = TaxCountryRegionParameters::find(
                MultipleTaxIdReportingHelper::getCountryRegionIDFromTaxRegistrationRecId(taxRegistrationRecId)).SalesTaxCode;

            euSalesListReportingHeader.TaxId = taxRegistrationRecId;
        }
        else
        {
            companyVATNum = TaxRegistration::getCompanyTaxRegNum_W(toDate);
            companyCoRegNum = TaxRegistration::getCompanyTaxRegNum_W(toDate, fieldNum(CompanyInfo, CoRegNum));
            branchId = companyInfo.BranchId;
            euSalesListTaxCode = TaxCountryRegionParameters::getSalesTaxCode(companyInfo);
        }

        euSalesListReportingHeader.BranchId                     = branchId;
        euSalesListReportingHeader.ReportingPeriodType          = reportingPeriodType;
        euSalesListReportingHeader.FromDate                     = fromDate;
        euSalesListReportingHeader.ToDate                       = toDate;
        euSalesListReportingHeader.LegalEntity                  = companyInfo.RecId;
        euSalesListReportingHeader.euSalesListTransferPurchases = intrastatParameters.euSalesListTransferPurchases;
        euSalesListReportingHeader.euSalesListTaxCode           = euSalesListTaxCode;
        euSalesListReportingHeader.StrippedVATNum               = TaxVATNumTable::stripVATNum(companyVATNum, euSalesListReportingHeader.EUSalesListTaxCode);
        euSalesListReportingHeader.CompanyVATNum                = companyVATNum;
        euSalesListReportingHeader.CompanyCoRegNum              = companyCoRegNum;
        euSalesListReportingHeader.insert();

        return euSalesListReportingHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes and inserts a record in the <c>EUSalesListReportingLine</c> table and corresponding
    ///    line amounts in <c>EUSalesListReportingLineAmount</c> .
    /// </summary>
    /// <param name="_euSalesListReportingGroupRecId">
    ///    The reference to the group record to which the line belongs.
    /// </param>
    /// <returns>
    ///    A <c>EUSalesListReportingLine</c> table buffer.
    /// </returns>
    protected EUSalesListReportingLine addLine(RefRecId _euSalesListReportingGroupRecId)
    {
        EUSalesListReportingLine euSalesListReportingLine = this.initializeLine(_euSalesListReportingGroupRecId);

        euSalesListReportingLine.insert();

        return euSalesListReportingLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLineToTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Maintains total amounts and counts by adding amounts from the current <c>EUSalesListReportingLine</c> buffer.
    /// </summary>
    /// <param name="_euSalesListReportingLine">
    /// The buffer with values that need to be added to totals.
    /// </param>
    protected void addLineToTotals(EUSalesListReportingLine _euSalesListReportingLine)
    {
        totalAmountItems       += _euSalesListReportingLine.ItemAmountMST;
        totalAmountTriangular  += _euSalesListReportingLine.TriangularAmountMST;
        totalAmountServices    += _euSalesListReportingLine.ServiceAmountMST;

        amountCount = _euSalesListReportingLine.ItemAmountMST? amountCount+1 : amountCount;
        amountCount = _euSalesListReportingLine.TriangularAmountMST? amountCount+1 : amountCount;
        amountCount = _euSalesListReportingLine.ServiceAmountMST? amountCount+1 : amountCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Drives the calculation and preparation of data that will be used by GER.
    /// </summary>
    /// <returns>
    /// The record ID of the <c>EUSalesListReportingHeader</c> table.
    /// </returns>
    protected RefRecId calculate()
    {
        EUSalesListReportingHeader  euSalesListReportingHeader;
        EUSalesListReportingGroup   euSalesListReportingGroup;
        EUSalesListReportingLine    euSalesListReportingLine;
        EUSalesList                 euSalesList;

        euSalesListReportingHeader  = this.addHeader();
        euSalesListReportingGroup   = this.addGroup(euSalesListReportingHeader.RecId);

        while (queryRun.next())
        {
            euSalesList = queryRun.get(tableNum(EUSalesList));
            this.checkEUSalesList(euSalesList);

            if (this.validateEUSalesListLine(euSalesList)
                && this.isNewLine())
            {
                lineCount++;
                //save previous record
                this.saveLastLineAmounts(euSalesListReportingLine);
                if (this.isNewGroup())
                {
                    euSalesListReportingGroup = this.addGroup(euSalesListReportingHeader.RecId);
                }
                euSalesListReportingLine = this.addLine(euSalesListReportingGroup.RecId);
            }

            this.updateLineAmounts(euSalesListReportingLine);
        }
        //last record
        this.saveLastLineAmounts(euSalesListReportingLine);

        if (!lineCount && !dontThrowOnMissingData)
        {
            throw error("@SYS26947");
        }

        this.calculateGrandTotals(euSalesListReportingHeader);

        return euSalesListReportingHeader.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateGrandTotals</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the totals in the header.
    /// </summary>
    /// <param name="_euSalesListReportingHeader">
    ///    The <c>EUSalesListReportingHeader</c> table buffer.
    /// </param>
    protected void calculateGrandTotals(EUSalesListReportingHeader _euSalesListReportingHeader)
    {
        //save grand totals
        _euSalesListReportingHeader.selectForUpdate(true);
        _euSalesListReportingHeader.TotalAmountItems      = totalAmountItems;
        _euSalesListReportingHeader.TotalAmountServices   = totalAmountServices;
        _euSalesListReportingHeader.TotalAmountTriangular = totalAmountTriangular;
        _euSalesListReportingHeader.LineCount             = lineCount;
        _euSalesListReportingHeader.AmountCount           = amountCount;
        _euSalesListReportingHeader.update();

        this.validateHeader(_euSalesListReportingHeader);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGenerateFile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether file generation is supported.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    /// <remarks>
    /// The return value controls the availability of file generation specific controls on the dialog
    /// box.Descendant classes can override this method and return false if file generation support is not
    /// required.
    /// </remarks>
    protected boolean canGenerateFile()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSendElectronically</Name>
				<Source><![CDATA[
    protected boolean canSendElectronically()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEUSalesList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs validation of a single <c>EUSalesList</c> buffer.
    /// </summary>
    /// <param name="_euSalesList">
    /// The <c>EUSalesList</c> buffer to check.
    /// </param>
    /// <remarks>
    /// Any validation errors occuring at this step is purely informational. They do not prevent the reporting from continuing with the record.
    /// </remarks>
    protected void checkEUSalesList(EUSalesList _euSalesList)
    {
        _euSalesList.check(true, #PreFixField(_euSalesList,AccountNum));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFieldLength</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the length of a field and shows a warning message if it exceeds the maximum allowed length.
    /// </summary>
    /// <param name="_actualLength">
    /// The actual length of the field.
    /// </param>
    /// <param name="_maxlength">
    /// The maximum allowed length.
    /// </param>
    /// <param name="_buffer">
    /// The buffer of the table to which the fields belongs.
    /// </param>
    /// <param name="_fieldId">
    /// The field ID.
    /// </param>
    /// <param name="_txt">
    /// The message to show if the check fails.
    /// </param>
    /// <returns>
    /// true if the check is successful; otherwise, false.
    /// </returns>
    protected boolean checkFieldLength(
        int             _actualLength,
        int             _maxlength,
        Common          _buffer  = null,
        FieldId         _fieldId = 0,
        SysInfoLogStr   _txt     = "")
    {
        boolean         ret = true;
        SysInfoLogStr   infologStr = _txt;

        if (infologStr == "")
        {
            infologStr = strFmt("@SYS339950", new SysDictField(_buffer.TableId, _fieldId).label(), _maxlength);
        }

        if (_actualLength > _maxlength)
        {
            ret = checkFailed(infologStr);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteReportingData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the data in the tables after the data has been sent to GER and also cleans up any
    /// leftover data that is more than a week old.
    /// </summary>
    /// <remarks>
    /// The leftover data in the tables that is used for EU sales list reporting could result from any
    /// crashes or forcefully killing the application while in the middle of generating an EU sales list
    /// report. In order to avoid accumulation of any such old data, it will be cleaned when this
    /// functionality is run again after several days. A logical gap of one week has been used here to
    /// clean up the data.
    /// </remarks>
    protected void deleteReportingData()
    {
        const int daysToKeepLeftOverData = 7;

        EUSalesListReportingHeader euSalesListReportingHeader;
        utcdatetime                dateTimeLastWeek = DateTimeUtil::addDays(DateTimeUtil::utcNow(), -daysToKeepLeftOverData);

        ttsbegin;

        delete_from euSalesListReportingHeader
            where euSalesListReportingHeader.CreatedDateTime < dateTimeLastWeek;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
    /// created in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogRunbase dialog = super();

        // Date group
        dialogGroupDate           = dialog.addGroup("@SYS7402");

        dialogReportingPeriodType = dialog.addFieldValue(enumStr(EUSalesListReportingPeriodType), reportingPeriodType);
        dialogFromDate            = dialog.addFieldValue(extendedTypeStr(FromDate), fromDate);
        dialogToDate              = dialog.addFieldValue(extendedTypeStr(ToDate), toDate);

        dialogToDate.enabled(reportingPeriodType == EUSalesListReportingPeriodType::NotSelected);
        this.setFromAndToDate();

        // Export options group
        dialogGroupExportOptions  = dialog.addGroup("@SYS55059");
        if (this.canGenerateFile())
        {
            dialogGenerateFile    = dialog.addFieldValue(extendedTypeStr(NoYesId), generateFile, "@SYS100854", "@SYS100855");
            dialogFilename        = dialog.addFieldValue(extendedTypeStr(Filename), filename);
        }
        dialogGenerateReport      = dialog.addFieldValue(extendedTypeStr(NoYesId), generateReport, "@EUSalesListCommon:GenerateReport");
        dialogReportName          = dialog.addFieldValue(extendedTypeStr(Filename), reportName, "@EUSalesListCommon:ReportFileName");

        if (this.canSendElectronically())
        {
            dialogSendElectronically = dialog.addFieldValue(extendedTypeStr(NoYesId), sendElectronically, "@SYS335943", "@SYS335944");
            dialogSendElectronically.allowEdit(generateFile);
        }

        // Just a workaround to make country context work on dialog fields.
        // Without a dataSource, client cannot determine the companyInfo for a form/dialog
        dialog.form().addDataSource(tableStr(EUSalesList));

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    public void dialogPostRun(DialogRunbase _dialog)
    {
        super(_dialog);

        this.registerEventHandlers();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fromDate_Modified</Name>
				<Source><![CDATA[
    public boolean fromDate_Modified(FormDateControl _formControl)
    {
        boolean             ret = _formControl.modified();
        FromDate            fromDateNew = dialogFromDate.value();
        reportingPeriodType = dialogReportingPeriodType.value();

        if (ret && fromDateNew)
        {
            ret = this.validateFromDate(fromDateNew, true);
        }

        if (ret)
        {
            this.setToDate(fromDateNew);
        }
        else //reset fromDate value
        {
            dialogFromDate.value(fromDate);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateFile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the output file for EU sales list reporting through ER solution.
    /// </summary>
    /// <param name="_euSalesListReportingHeaderRecId">
    /// The reference to the header record.
    /// </param>
    /// <param name="_euSalesListReportingGroupRecId">
    /// The reference to the reporting group record to add to the query; optional.
    /// </param>
    /// <param name="_filename">
    /// The output file name; optional.
    /// </param>
    /// <remarks>
    /// The <paramref name="_fileName" /> parameter uses the file name that is specified in the dialog box.
    /// </remarks>
    protected void generateFile(RefRecId _euSalesListReportingHeaderRecId,
                                RefRecId _euSalesListReportingGroupRecId = 0,
                                Filename _filename = filename)
    {
        Query salesListERQuery = this.createERQuery(_euSalesListReportingHeaderRecId,
                                              _euSalesListReportingGroupRecId);
        
        if (strLen(filename))
        {
            erFormatMappingFile.parmFileName(_filename);
        }

        this.runER(erFormatMappingFile, salesListERQuery, erParametersHandlerFile);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getERFormatParameters</Name>
				<Source><![CDATA[
    private ERModelDefinitionParamsUIActionComposite getERFormatParameters(ERIFormatMappingRun _formatMappingRun, Query _salesListERQuery, ERParametersCustomDialogHandler _dialogHandler)
    {
        ERModelDefinitionParamsUIActionComposite uiActionComposite = new ERModelDefinitionParamsUIActionComposite()
            .Add(new ERModelDefinitionDatabaseContext().addQuery(tablenum(EUSalesListReportingGroup), _salesListERQuery));

        if (_dialogHandler)
        {
            uiActionComposite = uiActionComposite.Add(_dialogHandler.getModelDefinitionInputParameters());
        }

        return uiActionComposite;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateFile_Modified</Name>
				<Source><![CDATA[
    public boolean generateFile_Modified(FormCheckBoxControl _formControl)
    {
        boolean ret = _formControl.modified();

        if (dialogSendElectronically)
        {
            if (dialogGenerateFile.value() == NoYes::Yes)
            {
                dialogSendElectronically.allowEdit(true);
            }
            else
            {
                dialogSendElectronically.allowEdit(false);
                dialogSendElectronically.value(NoYes::No);
            }
        }

        if (ret && dialogGroupFileFormat)
        {
            dialogGroupFileFormat.visible(dialogGenerateFile.value() == NoYes::Yes);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateFiles</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Generates one or more output files for EU sales list reporting.
    /// </summary>
    /// <param name="_euSalesListReportingHeaderRecId">
    ///     The reference to the header record.
    /// </param>
    /// <remarks>
    ///     The default implementation produces a single file.
    ///     Subclasses may override it to customize the behavior.
    /// </remarks>
    protected void generateFiles(RefRecId _euSalesListReportingHeaderRecId)
    {
        this.generateFile(_euSalesListReportingHeaderRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates report for EU sales list reporting.
    /// </summary>
    protected void generateReport()
    {
        Query salesListERQuery;

        salesListERQuery = this.createERQuery(euSalesListReportingHeaderRecId);

        if(strLen(reportName))
        {
            erFormatMappingReport.parmFileName(reportName);
        }

        this.runER(erFormatMappingReport, salesListERQuery, erParametersHandlerReport);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the values from the dialog box fields and performs the validation.
    /// </summary>
    /// <returns>
    ///    true, if the values are valid; otherwise, false.
    /// </returns>
    public boolean getFromDialog()
    {
        fromDate            = dialogFromDate.value();
        toDate              = dialogToDate.value();
        reportName          = dialogReportName.value();
        generateReport      = dialogGenerateReport.value();

        generateFile        = false;
        reportingPeriodType = dialogReportingPeriodType.value();
        if (this.canGenerateFile())
        {
            filename            = dialogFilename.value();
            generateFile        = dialogGenerateFile.value();
            if (dialogSendElectronically)
            {
                sendElectronically = dialogSendElectronically.value();
            }
        }

        ERParametersHandlerFile.getFormatParameterValuesFromDialog();
        ERParametersHandlerReport.getFormatParameterValuesFromDialog();

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a record of the <c>EUSalesListReportingLine</c> table.
    /// </summary>
    /// <param name="_euSalesListReportingGroupRecId">
    ///    The reference to the group record to which the line belongs.
    /// </param>
    /// <returns>
    ///    A <c>EUSalesListReportingLine</c> table buffer.
    /// </returns>
    protected EUSalesListReportingLine initializeLine(RefRecId _euSalesListReportingGroupRecId)
    {
        EUSalesListReportingLine euSalesListReportingLine;
        EUSalesList euSalesList;

        euSalesList = queryRun.get(tableNum(EUSalesList));

        euSalesListReportingLine.euSalesListReportingGroup  = _euSalesListReportingGroupRecId;
        euSalesListReportingLine.AccountNum                 = euSalesList.AccountNum;
        euSalesListReportingLine.CountryRegionId            = euSalesList.CountryRegionId;
        euSalesListReportingLine.euSalesListTaxCode         = TaxCountryRegionParameters::find(euSalesList.CountryRegionId).SalesTaxCode;
        euSalesListReportingLine.Name                       = TaxVATNumTable::find(euSalesList.vatNum, euSalesList.CountryRegionId).Name;

        if (!euSalesListReportingLine.Name)
        {
            TaxVATNumTable taxVATNumTable;

            select firstonly Name from taxVATNumTable
                where taxVATNumTable.vatNum == euSalesList.vatNum;

            euSalesListReportingLine.Name = taxVATNumTable.Name;
        }

        if (euSalesListReportingLine.Name == '' && euSalesList.vatNum != '')
        {
            euSalesListReportingLine.Name = this.getVATNameFromAddressLocation(euSalesList);
        }

        euSalesListReportingLine.Direction                  = euSalesList.Direction;
        euSalesListReportingLine.DispatchId                 = euSalesList.DispatchId;
        euSalesListReportingLine.Corrected                  = euSalesList.Corrected;
        euSalesListReportingLine.Listcode                   = euSalesList.Listcode;
        euSalesListReportingLine.TaxReportingCurrencyCode   = euSalesList.TaxReportingCurrencyCode;
        euSalesListReportingLine.VATNum_DE                  = euSalesList.VATNum;

        this.fillStrippedVATNum(euSalesListReportingLine, euSalesList.vatNum);

        return euSalesListReportingLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillStrippedVATNum</Name>
				<Source><![CDATA[
    protected void fillStrippedVATNum(EUSalesListReportingLine _euSalesListReportingLine, VATNum _vatNum)
    {
        if (FeatureStateProvider::isFeatureEnabled(IntrastatCountryRegionStateFeature::instance()))
        {
            str prefix = subStr(_vatNum, 1, 2);
            if (prefix)
            {
               if (match('^[a-zA-Z]*$', prefix))
               {
                   _euSalesListReportingLine.TaxExemptNumberPrefix = prefix;
               }
            }
            _euSalesListReportingLine.StrippedVATNum = TaxVATNumTable::stripVATNum(_vatNum, _euSalesListReportingLine.TaxExemptNumberPrefix);
        }
        else
        {
            _euSalesListReportingLine.StrippedVATNum = TaxVATNumTable::stripVATNum(_vatNum, _euSalesListReportingLine.euSalesListTaxCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the internal variables.
    /// </summary>
    /// <remarks>
    /// This method is called when no <c>SysLastValue</c> record can be found when the
    /// <c>SysLastValue.GetLast</c> method is called. Remember to call the <c>super</c> method.
    /// </remarks>
    public void initParmDefault()
    {
        super();
        queryRun      = new QueryRun(queryStr(EUSalesListQuery));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEmptyLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the <paramref name="_euSalesListReportingLine" /> buffer holds any values.
    /// </summary>
    /// <param name="_euSalesListReportingLine">
    /// The buffer to check for contents.
    /// </param>
    /// <returns>
    /// true if the buffer is empty; otherwise, false.
    /// </returns>
    protected boolean isEmptyLine(EUSalesListReportingLine _euSalesListReportingLine)
    {
        return _euSalesListReportingLine.ItemAmountMST       == 0
            && _euSalesListReportingLine.TriangularAmountMST == 0
            && _euSalesListReportingLine.ServiceAmountMST    == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies if the current line contains non-triangular item amount
    /// </summary>
    /// <param name="_euSalesList">
    ///     The <c>EUSalesList</c> table buffer.
    /// </param>
    /// <returns>
    ///    True, if current line describes a non-triangular item amount
    /// </returns>

    protected boolean isItemAmount(EUSalesList _euSalesList)
    {
        boolean isItemAmount = false;

        if (_euSalesList.AmountMST &&
           (_euSalesList.Listcode == Listcode::EUTrade || _euSalesList.Listcode == Listcode::ProductionOnToll))
        {
            isItemAmount = true;
        }

        return isItemAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNewGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether to create a new record in the <c>EUSalesListReportingGroup</c> table.
    /// </summary>
    /// <returns>
    ///    true if a new group is created; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Descendant classes can override this method to support any special or logical grouping logic such
    ///    as the splitting of files.
    /// </remarks>
    protected boolean isNewGroup()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNewLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether to create a new record in the <c>EUSalesListReportingLine</c> table.
    /// </summary>
    /// <returns>
    ///    true if a new line is created; otherwise, false.
    /// </returns>
    protected boolean isNewLine()
    {
        boolean     ret;
        EUSalesList euSalesList;
        euSalesList = queryRun.get(tableNum(EUSalesList));

        if ((euSalesList.AmountMST || euSalesList.ServiceAmountMST)
            && (lastVATNum             != euSalesList.vatNum
                || lastCountryRegionId != euSalesList.CountryRegionId
                || lastDirection       != euSalesList.Direction))
        {
            lastVATNum          = euSalesList.vatNum;
            lastCountryRegionId = euSalesList.CountryRegionId;
            lastDirection       = euSalesList.Direction;
            ret                 = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReportEmpty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Decides if there is information to report, based on the line count.
    /// </summary>
    /// <returns>
    ///    True if there are lines to be printed in the report.
    /// </returns>
    protected boolean isReportEmpty()
    {
        return !lineCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isServiceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies if the current line contains service amount
    /// </summary>
    /// <param name="_euSalesList">
    ///     The <c>EUSalesList</c> table buffer.
    /// </param>
    /// <returns>
    ///    True, if current line describes a service amount
    /// </returns>
    protected boolean isServiceAmount(EUSalesList _euSalesList)
    {
        boolean isServiceAmount = false;

        if (_euSalesList.ServiceAmountMST)
        {
            isServiceAmount = true;
        }

        return isServiceAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTriangularAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies if the current line is a triangular transaction
    /// </summary>
    /// <param name="_euSalesList">
    ///     The <c>EUSalesList</c> table buffer.
    /// </param>
    /// <returns>
    ///    True, if current line describes a triangular transaction
    /// </returns>
    protected boolean isTriangularAmount(EUSalesList _euSalesList)
    {
        if (_euSalesList.AmountMST
            && (_euSalesList.Listcode == Listcode::TriangularEUTrade
                || _euSalesList.Listcode == Listcode::TriangularProductionOnToll))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineHasNoAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if all the lines amounts are 0
    /// </summary>
    /// <param name="_euSalesListReportingLine">
    /// The <c>EUSalesListReportingLine</c> buffer.
    /// </param>
    /// <returns>
    /// Returns true if all the line amounts are 0. Returns false otherwise.
    /// </returns>
    protected boolean lineHasNoAmounts(EUSalesListReportingLine _euSalesListReportingLine)
    {
        if (!_euSalesListReportingLine)
        {
            return true;
        }

        // If the line amounts after grouping come out to be zero, the line can be skipped from the resultant dataset
        if (!this.validateEUSalesListReportingLine(_euSalesListReportingLine)
            || (_euSalesListReportingLine.ItemAmountMST          == 0
                && _euSalesListReportingLine.TriangularAmountMST == 0
                && _euSalesListReportingLine.ServiceAmountMST    == 0))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markTransAsReported</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets Reported status for processed transactions
    /// </summary>
    public void markTransAsReported()
    {
        EUSalesList euSalesList;
        QueryRun localQueryRun;

        ttsbegin;

        localQueryRun = new QueryRun(queryRun.query());
        while (localQueryRun.next())
        {
            euSalesList = localQueryRun.get(tableNum(EUSalesList));
            euSalesList.selectForUpdate(true);
            euSalesList.Status = ListStatus::Reported;
            euSalesList.doUpdate();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        if (TaxIntegrationUtils::isMultipleTaxIdEnabledForEUSalesList())
        {
            GlobalizationInstrumentationHelper::featureRun(FeatureRefReportingByTaxId, funcName());
        }
        else
        {
            GlobalizationInstrumentationHelper::featureRun(FeatureReference, funcName());
        }

        fileDestination = ERObjectsFactory::createFileDestinationBrowser();

        this.initERFormatMapping();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packed = [#CurrentVersion, #CurrentList, super(), queryRun.pack(), args.pack()];
        packed = this.appendVariableToPack(packed, classStr(EUSalesListReportingEngine), varStr(taxRegistrationRecId), taxRegistrationRecId);
        packed = this.appendVariableToPack(packed,
            classStr(EUSalesListReportingEngine),
            varStr(erParametersHandlerFile), 
            erParametersHandlerFile ? erParametersHandlerFile.pack() : conNull());
        packed = this.appendVariableToPack(packed,
            classStr(EUSalesListReportingEngine),
            varStr(erParametersHandlerReport),
            erParametersHandlerReport ? erParametersHandlerReport.pack() : conNull());
        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmArgs</Name>
				<Source><![CDATA[
    public Args parmArgs(Args _args = args)
    {
        args = _args;
        return args;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDontThrowOnMissingData</Name>
				<Source><![CDATA[
    public boolean parmDontThrowOnMissingData(boolean _dontThrowOnMissingData = dontThrowOnMissingData)
    {
        dontThrowOnMissingData = _dontThrowOnMissingData;
        return dontThrowOnMissingData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEUSalesListReportingHeaderRecId</Name>
				<Source><![CDATA[
    public RefRecId parmEUSalesListReportingHeaderRecId(RefRecId _euSalesListReportingHeaderRecId = euSalesListReportingHeaderRecId)
    {
        euSalesListReportingHeaderRecId = _euSalesListReportingHeaderRecId;
        return euSalesListReportingHeaderRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFromDate</Name>
				<Source><![CDATA[
    public FromDate parmFromDate(FromDate _fromDate = fromDate)
    {
        fromDate = _fromDate;
        return fromDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFileDestination</Name>
				<Source><![CDATA[
    public ERIFileDestination parmFileDestination(ERIFileDestination _fileDestination = fileDestination)
    {
        fileDestination = _fileDestination;
        return fileDestination;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmToDate</Name>
				<Source><![CDATA[
    public ToDate parmToDate(ToDate _toDate = toDate)
    {
        toDate = _toDate;
        return toDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGenerateReport</Name>
				<Source><![CDATA[
    public NoYesId parmGenerateReport(NoYesId _generateReport = generateReport)
    {
        generateReport = _generateReport;
        return generateReport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportingPeriodType</Name>
				<Source><![CDATA[
    public EUSalesListReportingPeriodType parmReportingPeriodType(EUSalesListReportingPeriodType _reportingPeriodType = reportingPeriodType)
    {
        reportingPeriodType = _reportingPeriodType;
        return reportingPeriodType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGenerateFile</Name>
				<Source><![CDATA[
    public NoYesId parmGenerateFile(NoYesId _generateFile = generateFile)
    {
        generateFile = _generateFile;
        return generateFile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSendElectronically</Name>
				<Source><![CDATA[
    public NoYesId parmSendElectronically(NoYesId _sendElectronically = sendElectronically)
    {
        sendElectronically = _sendElectronically;
        return sendElectronically;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFilename</Name>
				<Source><![CDATA[
    public Filename parmFilename(Filename _filename = filename)
    {
        filename = _filename;
        return filename;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportName</Name>
				<Source><![CDATA[
    public Filename parmReportName(Filename _reportName = reportName)
    {
        reportName = _reportName;
        return reportName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxRegistrationRecID</Name>
				<Source><![CDATA[
    public TaxRegistrationRecId parmTaxRegistrationRecID(TaxRegistrationRecId _taxRegistrationRecId = taxRegistrationRecId)
    {
        taxRegistrationRecId = _taxRegistrationRecId;

        if (!prmIsDefault(_taxRegistrationRecId))
        {
            this.initERFormatMapping();
        }

        return taxRegistrationRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createERQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates query that filters data from EUSalesListReportingHeader and EUSalesListReportingGroup
    ///     tables for GER export needs
    /// </summary>
    /// <param name="_euSalesListReportingHeaderRecId">
    /// The <c>EuSalesListReportingHeader</c> RecId.
    /// </param>
    /// <param name="_euSalesListReportingGroupRecId">
    /// The <c>EuSalesListReportingGroup</c> RecId.
    /// </param>
    ///<returns><c>Query</c> to <c>EUSalesListReportingGroup</c> depending on reporting header RecId.</returns>
    public Query createERQuery(RefRecId _euSalesListReportingHeaderRecId,
                               RefRecId _euSalesListReportingGroupRecId = 0)
    {
        Query qEuSalesListGroup = new Query();

        QueryBuildDataSource qbdEuSalesListGroup = qEuSalesListGroup.addDataSource(TableNum(EUSalesListReportingGroup));
        QueryBuildRange qbrEuSalesListGroup_header = qbdEuSalesListGroup.addRange(fieldNum(EUSalesListReportingGroup, EUSalesListReportingHeader));

        qbrEuSalesListGroup_header.value(queryValue(_euSalesListReportingHeaderRecId));

        if (_euSalesListReportingGroupRecId)
        {
            QueryBuildRange qbrEuSalesListGroup_recid = qbdEuSalesListGroup.addRange(fieldNum(EUSalesListReportingGroup, RecId));
            qbrEuSalesListGroup_recid.value(queryValue(_euSalesListReportingGroupRecId));
        }

        qbdEuSalesListGroup.addOrderByField(fieldNum(EUSalesListReportingGroup, RecId));

        return qEuSalesListGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Applies any runtime filters on the query for data selection.
    /// </summary>
    protected void prepareQuery()
    {
        queryRun.query().dataSourceTable(tableNum(EUSalesList)).addRange(fieldNum(EUSalesList, TransDate)).value(queryRange(fromDate,toDate));
        if (TaxIntegrationUtils::isMultipleTaxIdEnabledForEUSalesList() || TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            queryRun.query().dataSourceTable(tableNum(EUSalesList)).addRange(fieldNum(EUSalesList, TaxID)).value(queryValue(taxRegistrationRecId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    ///    The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    ///    This method is used if a query prompt is in the dialog and if a select menu item is added to a
    ///    dialog. Do not create the instance of the <c>QueryRun</c> class when the method is called. Do it in
    ///    the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerEventHandlers</Name>
				<Source><![CDATA[
    public void registerEventHandlers()
    {
        dialogReportingPeriodType.control().registerOverrideMethod(
            methodStr(FormComboBoxControl, modified),
            methodStr(EUSalesListReportingEngine, reportingPeriodType_Modified),
            this);

        dialogFromDate.control().registerOverrideMethod(
            methodStr(FormDateControl, modified),
            methodStr(EUSalesListReportingEngine, fromDate_Modified),
            this);

        if (this.canGenerateFile())
        {
            dialogGenerateFile.control().registerOverrideMethod(
                methodStr(FormCheckBoxControl, modified),
                methodStr(EUSalesListReportingEngine, generateFile_Modified),
                this);
        }

        dialogGenerateReport.control().registerOverrideMethod(
            methodStr(FormCheckBoxControl, modified),
            methodStr(EUSalesListReportingEngine, generateReport_Modified),
            this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportingPeriodType_Modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables or disables the from date control depending on the modified value of the Period type control.
    /// This method also sets the from and to dates based on the period type selection.
    /// </summary>
    /// <param name="_formControl">
    /// The form control that triggered the event.
    /// </param>
    /// <returns>
    /// true, if the modified event was handled succesfully; otherwise, false.
    /// </returns>
    public boolean reportingPeriodType_Modified(FormComboBoxControl _formControl)
    {
        boolean             ret = _formControl.modified();
        fromDate            = dialogFromDate.value();
        reportingPeriodType = dialogReportingPeriodType.value();

        if (ret)
        {
            dialogToDate.enabled(reportingPeriodType == EUSalesListReportingPeriodType::NotSelected);

            if (reportingPeriodType != EUSalesListReportingPeriodType::NotSelected)
            {
                if (fromDate && this.validateFromDate(fromDate, false))
                {
                    this.setToDate(fromDate);
                }
                else
                {
                    this.setFromAndToDate();
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        setPrefix("@SYS332706");
        super();

        if (sendElectronically)
        {
            fileDestination = new ERFileDestinationMemory();
        }

        this.initERFormatMapping();

        //apply filters
        this.prepareQuery();
        this.deleteReportingData();
        // fill the datasets
        ttsbegin;
        this.parmEUSalesListReportingHeaderRecId(this.calculate());
        ttscommit;
        try
        {
            // generate file
            if (generateFile)
            {
                this.generateFiles(euSalesListReportingHeaderRecId);
            }

            // generate report
            if (generateReport)
            {
                this.generateReport();
            }

            // send electronically
            if (sendElectronically)
            {
                this.sendElectronically();
            }
        }
        catch(Exception::Error)
        {
            // rethrow error, so that status is reported correctly for batch tasks.
            throw error("@SYS93835");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runER</Name>
				<Source><![CDATA[
    private ERFileName runER(ERIFormatMappingRun _formatMappingRun, Query _salesListERQuery, ERParametersCustomDialogHandler _dialogHandler)
    {
        return _formatMappingRun
            .withParameter(this.getERFormatParameters(_formatMappingRun, _salesListERQuery, _dialogHandler))
            .withFileDestination(fileDestination)
            .withCreatingObjectParameter(erModelName, classStr(EUSalesListReportingEngine), this)
            .withRunInBatchMode(inBatch).run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveLastLineAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the <c>EUSalesListReportingLineAmountItems</c> table buffers with updated amounts.
    /// </summary>
    /// <param name="_euSalesListReportingLine">
    /// The <c>EUSalesListReportingLine</c> table buffer.
    /// </param>
    protected void saveLastLineAmounts(EUSalesListReportingLine _euSalesListReportingLine)
    {
        if (_euSalesListReportingLine)
        {
            // If the line amounts after grouping come out to be zero, the line can be skipped from the resultant dataset
            if (!this.validateEUSalesListReportingLine(_euSalesListReportingLine)
                || this.isEmptyLine(_euSalesListReportingLine))
            {
                _euSalesListReportingLine.delete();
                lineCount--;
            }
            else
            {
                _euSalesListReportingLine.update();
                this.addLineToTotals(_euSalesListReportingLine);
            }
            _euSalesListReportingLine.clear();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendElectronically</Name>
				<Source><![CDATA[
    protected void sendElectronically()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFromAndToDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the from and to dates automatically by using the period type.
    /// </summary>
    protected void setFromAndToDate()
    {
        switch (reportingPeriodType)
        {
            case EUSalesListReportingPeriodType::Monthly:
                fromDate = dateStartMth(dateStartMth(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))-1);
                dialogFromDate.value(fromDate);
                dialogToDate.value(dateEndMth(fromDate));
                break;

            case EUSalesListReportingPeriodType::Quarterly:
                fromDate = dateStartQtr(dateStartQtr(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))-1);
                dialogFromDate.value(fromDate);
                dialogToDate.value(dateEndQtr(fromDate));
                break;

            case EUSalesListReportingPeriodType::BiMonthly:
                fromDate = dateStartQtr(dateStartQtr(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))-1);
                dialogFromDate.value(fromDate);
                dialogToDate.value(dateEndMth(nextMth(fromDate)));
                break;

            case EUSalesListReportingPeriodType::Yearly:
                fromDate = DateTimeUtil::getStartOfYearDate(new Session().preferredLocale(), DateTimeUtil::getStartOfYearDate(new Session().preferredLocale(), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))-1);
                dialogFromDate.value(fromDate);
                dialogToDate.value(DateTimeUtil::getEndOfYearDate(new Session().preferredLocale(), fromDate));
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setToDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the to date by using the period type and from date.
    /// </summary>
    /// <param name="_fromDate">
    ///    The from date value.
    /// </param>
    protected void setToDate(FromDate _fromDate)
    {
        switch (reportingPeriodType)
        {
            case EUSalesListReportingPeriodType::Monthly:
                dialogToDate.value(dateEndMth(_fromDate));
                break;

            case EUSalesListReportingPeriodType::Quarterly:
                dialogToDate.value(dateEndQtr(_fromDate));
                break;

            case EUSalesListReportingPeriodType::BiMonthly:
                dialogToDate.value(dateEndMth(nextMth(dateStartQtr(_fromDate))));
                break;

            case EUSalesListReportingPeriodType::Yearly:
                dialogToDate.value(DateTimeUtil::getEndOfYearDate(new Session().preferredLocale(), _fromDate));
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to add a select button to the dialog box.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    /// <remarks>
    ///    If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    ///    return a valid instance of the <c>QueryRun</c> class.If you change the return value to false, the
    ///    button will no longer be added.
    /// </remarks>
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Integer         version = RunBase::getVersion(packedClass);
        container       packedSuper;
        container       packedQuery;
        container       packedArgs;
        container       packedERParametersHandlerFile;
        container       packedERParametersHandlerReport;
        boolean         ret = true;

        switch (version)
        {
            case #CurrentVersion:
                [version, #currentList, packedSuper, packedQuery, packedArgs] = packedClass;
                if (packedQuery)
                {
                    queryRun      = new QueryRun(packedQuery);
                }

                if (packedArgs)
                {
                    args = Args::create(packedArgs);
                }

                if (packedSuper)
                {
                    ret = super(packedSuper);
                }
                taxRegistrationRecId = this.extractPackedVariable(packedClass, classStr(EUSalesListReportingEngine), varStr(taxRegistrationRecId));
                packedERParametersHandlerFile = this.extractPackedVariable(packedClass, classStr(EUSalesListReportingEngine), varStr(erParametersHandlerFile));
                if (packedERParametersHandlerFile)
                {
                    erParametersHandlerFile = ERParametersCustomDialogHandler::construct(null);
                    erParametersHandlerFile.unpack(packedERParametersHandlerFile);
                }

                packedERParametersHandlerReport = this.extractPackedVariable(packedClass, classStr(EUSalesListReportingEngine), varStr(erParametersHandlerReport));
                if (packedERParametersHandlerReport)
                {
                    erParametersHandlerReport = ERParametersCustomDialogHandler::construct(null);
                    erParametersHandlerReport.unpack(packedERParametersHandlerReport);
                }
               break;
            default:
                return false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLineAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the line amounts and totals by using the current record in query.
    /// </summary>
    /// <param name="_euSalesListReportingLine">
    ///    The <c>EUSalesListReportingLine</c> table buffer.
    /// </param>
    protected void updateLineAmounts(EUSalesListReportingLine _euSalesListReportingLine)
    {
        EUSalesList euSalesList = queryRun.get(tableNum(EUSalesList));

        if (this.isItemAmount(euSalesList))
        {
            _euSalesListReportingLine.selectForUpdate(true);
            _euSalesListReportingLine.ItemAmountMST += euSalesList.AmountMST;
        }

        if (this.isTriangularAmount(euSalesList))
        {
            _euSalesListReportingLine.selectForUpdate(true);
            _euSalesListReportingLine.TriangularAmountMST += euSalesList.AmountMST;
        }

        if (this.isServiceAmount(euSalesList))
        {
            _euSalesListReportingLine.selectForUpdate(true);
            _euSalesListReportingLine.ServiceAmountMST += euSalesList.ServiceAmountMST;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the state of the internal variables.
    /// </summary>
    /// <param name="calledFrom">
    ///     An object which this method has been called from; optional.
    /// </param>
    /// <returns>
    ///    true, or adds warning messages to the Infolog, depending on the state of the internal variables.
    /// </returns>
    public boolean validate(Object calledFrom = null)
    {
        boolean             ret = true;

        if (fromDate && toDate)
        {
            if (fromDate > toDate)
            {
                ret = checkFailed("@SYS120590");
            }
        }

        if (generateFile == NoYes::No && generateReport == NoYes::No)
        {
            ret = checkFailed("@EUSalesListCommon:NeedToPrintReportOrFile");
        }

        if (generateReport && !reportName)
        {
            ret = checkFailed("@EUSalesListCommon:ReportNameIsNotSpecified");
        }

        if (generateFile)
        {
            if (!filename)
            {
                ret = checkFailed("@SYS18624");
            }

            if (fromDate == dateNull())
            {
                ret = checkFailed("@SYS91557");
            }

            if (dialogReportingPeriodType && dialogReportingPeriodType.fieldControl().visible()
                && reportingPeriodType == EUSalesListReportingPeriodType::NotSelected)
            {
                ret = checkFailed("@SYS332707");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEUSalesListLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs validation on the individual EU sales list lines.
    /// </summary>
    /// <param name="_euSalesList">
    /// The <c>EUSalesList</c> table buffer.
    /// </param>
    /// <returns>
    /// true if the validation is successful; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Descendant classes can override this method to perform custom validations, e.g., checking the field
    /// length of the fields.
    /// </remarks>
    protected boolean validateEUSalesListLine(EUSalesList _euSalesList)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEUSalesListReportingLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs validation on the grouped EU sales list reporting lines.
    /// </summary>
    /// <param name="_euSalesListReportingLine">
    /// The <c>EUSalesListReportingLine</c> table buffer.
    /// </param>
    /// <returns>
    /// true if the validation is successful; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Descendant classes can override this method to perform custom validations on the grouped lines,
    /// e.g., checking the field length of the amount fields.
    /// </remarks>
    protected boolean validateEUSalesListReportingLine(EUSalesListReportingLine _euSalesListReportingLine)
    {
        if (generateFile
            && _euSalesListReportingLine
            && _euSalesListReportingLine.StrippedVATNum != ''
            && _euSalesListReportingLine.Name == '')
        {
            setprefix(#PreFixField(_euSalesListReportingLine, AccountNum));

            warning(strFmt("@EUSalesListCommon:VATNameIsEmpty",
                _euSalesListReportingLine.TaxExemptNumberPrefix
                    ? _euSalesListReportingLine.TaxExemptNumberPrefix
                    : _euSalesListReportingLine.EUSalesListTaxCode,
                _euSalesListReportingLine.StrippedVATNum));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFromDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates whether the from date is valid and displays an error message that is based on the
    ///    <paramref name="_showError" /> parameter.
    /// </summary>
    /// <param name="_fromDate">
    ///    The from date value.
    /// </param>
    /// <param name="_showError">
    ///    A Boolean value that indicates whether an error message is displayed.
    /// </param>
    /// <returns>
    ///    true if from date is valid; otherwise, false.
    /// </returns>
    public boolean validateFromDate(FromDate _fromDate, boolean _showError)
    {
        boolean ret = true;
        switch (reportingPeriodType)
        {
            case EUSalesListReportingPeriodType::Monthly:
                if (dayOfMth(_fromDate) != 1)
                {
                    ret = _showError? checkFailed("@SYS312862") : false;
                }
                break;

            case EUSalesListReportingPeriodType::Quarterly:
            //Bi-monthly periods have the same starting dates as quarters
            case EUSalesListReportingPeriodType::BiMonthly:
                if (_fromDate != dateStartQtr(_fromDate))
                {
                    ret = _showError? checkFailed("@SYS332705") : false;
                }
                break;

            case EUSalesListReportingPeriodType::Yearly:
                if (_fromDate != DateTimeUtil::getStartOfYearDate(new Session().preferredLocale(), _fromDate))
                {
                    ret = _showError? checkFailed("@SYS334907") : false;
                }
                break;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs validation on the <c>EUSalesListReportingHeader</c> record.
    /// </summary>
    /// <param name="_euSalesListReportingHeader">
    /// The <c>EUSalesListReportingHeader</c> buffer.
    /// </param>
    /// <returns>
    /// true if the validation is successful; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Descendant classes can override this method to perform custom validations, e.g., checking the field
    /// length of total amounts.
    /// </remarks>
    protected boolean validateHeader(EUSalesListReportingHeader _euSalesListReportingHeader)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>EUSalesListReportingEngine</c> class.
    /// </summary>
    /// <returns>
    ///    A new instance of the <c>EUSalesListReportingEngine</c> class.
    /// </returns>
    /// <remarks>
    ///    When implementing new descendants of the <c>EUSalesListReportingEngine</c> class this method must
    ///    be updated to consider them.
    /// </remarks>
    public static EUSalesListReportingEngine construct()
    {
        return EUSalesListReportingEngine::constructByCountryRegionId(SysCountryRegionCode::countryInfo());
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS332706";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        #OCCRetryCount
        EUSalesListReportingEngine euSalesListReportingEngine = EUSalesListReportingEngine::initReportingEngine(_args);

        euSalesListReportingEngine.getLast(); // this call is used to avoid overwriting of args variable in prompt() method by calling getLast() after parmArgs() method
        euSalesListReportingEngine.parmArgs(Args::createFromArgs(_args)); // this conversion is required, because when run through MenuItem we got xArgs object in main() method
        euSalesListReportingEngine.parmArgs(_args);

        if (euSalesListReportingEngine.prompt())
        {
            try
            {
                euSalesListReportingEngine.runOperation();
            }
            catch (Exception::Deadlock)
            {
                retry;
            }
            catch (Exception::UpdateConflict)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::UpdateConflictNotRecovered;
                    }
                    else
                    {
                        retry;
                    }
                }
                else
                {
                    throw Exception::UpdateConflict;
                }
            }

            catch (Exception::Error)
            {
                throw error("@SYS93835");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCorrectedData</Name>
				<Source><![CDATA[
    protected void addCorrectedData(
        EUSalesListReportingLine _euSalesListReportingLineCorrection,
        EUSalesListReportingLine _euSalesListReportingLine)
    {
        while select _euSalesListReportingLineCorrection
        {
            if (!this.lineHasNoAmounts(_euSalesListReportingLineCorrection))
            {
                _euSalesListReportingLine.data(_euSalesListReportingLineCorrection);
                _euSalesListReportingLine.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCorrectedData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the correction lines.
    /// </summary>
    /// <param name="_euSalesListReportingHeader">
    /// A <c>EUSalesListReportingHeader</c> table buffer.
    /// </param>
    /// <param name="_euSalesListReportingGroup">
    /// A <c>EUSalesListReportingGroup</c> table buffer.
    /// </param>
    /// <param name="_euSalesListReportingLineCorrection">
    /// A <c>EUSalesListReportingLine</c> table buffer.
    /// </param>
    /// <returns>
    /// True, if a new line needed and increment line counters.
    /// </returns>
    /// <remarks>
    /// Correction lines are not supposed to be grouped with generic transaction lines and must be reported
    /// as individual lines.
    /// </remarks>
    protected container updateCorrectedData(
        EUSalesListReportingHeader  _euSalesListReportingHeader,
        EUSalesListReportingGroup   _euSalesListReportingGroup,
        EUSalesListReportingLine    _euSalesListReportingLineCorrection)
    {
        boolean                     newLine = true;
        EUSalesList                 euSalesList;
        boolean                     reportItemCorrections;
        boolean                     reportServiceCorrections;

        Line                        lineCountCorrectionsIncrement = 0,
                                    lineCountIncrement = 0;

        euSalesList =               queryRun.get(tableNum(EUSalesList));
        reportItemCorrections       = (euSalesList.AmountMST || euSalesList.TaxRep349AmountMstPrev) && euSalesList.Corrected;
        reportServiceCorrections    = (euSalesList.ServiceAmountMST || euSalesList.TaxRep349AmountMstPrevServices) && euSalesList.CorrectedServices;

        if (reportItemCorrections || reportServiceCorrections)
        {
            // get default line buffer initialization
            _euSalesListReportingLineCorrection = this.addLine(_euSalesListReportingGroup.RecId);

            _euSalesListReportingLineCorrection.Corrected            = euSalesList.Corrected;
            _euSalesListReportingLineCorrection.CorrectedServices_ES = euSalesList.CorrectedServices;
            _euSalesListReportingLineCorrection.CorrectionCountry_FI = TaxCountryRegionParameters::find(euSalesList.CorrectionCountry_FI).SalesTaxCode;
            _euSalesListReportingLineCorrection.CorrectionVATNum_FI  = euSalesList.CorrectionVATNum_FI;

            if (reportItemCorrections)
            {
                if (euSalesList.Listcode == Listcode::EUTrade || euSalesList.Listcode == Listcode::ProductionOnToll)
                {
                    _euSalesListReportingLineCorrection.ItemAmountMST = euSalesList.AmountMST;
                }
                else if (euSalesList.Listcode == Listcode::TriangularEUTrade || euSalesList.Listcode == Listcode::TriangularProductionOnToll)
                {
                    _euSalesListReportingLineCorrection.TriangularAmountMST = euSalesList.AmountMST;
                }

                _euSalesListReportingLineCorrection.TaxRep349AmountMstPrev_ES    = euSalesList.TaxRep349AmountMstPrev;
                _euSalesListReportingLineCorrection.CorrectionYear_ES            = euSalesList.CorrectionYear;
                _euSalesListReportingLineCorrection.CorrectionPeriod_ES          = euSalesList.CorrectionPeriod;
                _euSalesListReportingLineCorrection.CorrectionMonthOrQuarter_ES  = euSalesList.CorrectionMonthOrQuarter;
                _euSalesListReportingLineCorrection.CorrectionListcode_FI        = euSalesList.CorrectionListcode_FI;
                lineCountCorrectionsIncrement++;
                //update totals
                _euSalesListReportingHeader.TotalAmountCorrections_ES += euSalesList.AmountMST;
            }

            if (reportServiceCorrections)
            {
                _euSalesListReportingLineCorrection.ServiceAmountMST                     = euSalesList.ServiceAmountMST;
                _euSalesListReportingLineCorrection.TaxRep349AmountMstPrevServices_ES    = euSalesList.TaxRep349AmountMstPrevServices;
                _euSalesListReportingLineCorrection.CorrectionYearServices_ES            = euSalesList.CorrectionYearServices;
                _euSalesListReportingLineCorrection.CorrectionPeriodServices_ES          = euSalesList.CorrectionPeriodServices;
                _euSalesListReportingLineCorrection.CorrectionMonthOrQuarterServices_ES  = euSalesList.CorrectionMonthOrQuarterServices;
                lineCountCorrectionsIncrement++;
                //update totals
                _euSalesListReportingHeader.TotalAmountCorrections_ES += euSalesList.ServiceAmountMST;
            }

            lineCountIncrement++;
            _euSalesListReportingLineCorrection.update();

            // if both items and services are marked for correction, a normal line should not be inserted
            if (euSalesList.Corrected &&  euSalesList.CorrectedServices)
            {
                newLine = false;
            }
        }

        return [ newLine, lineCountCorrectionsIncrement, lineCountIncrement ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructByCountryRegionId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>EUSalesListReportingEngine</c> class with Country Region Id parameter.
    /// </summary>
    /// <returns>
    ///    A new instance of the <c>EUSalesListReportingEngine</c> class.
    /// </returns>
    /// <remarks>
    ///    When implementing new descendants of the <c>EUSalesListReportingEngine</c> class this method must
    ///    be updated to consider them.
    /// </remarks>
    public static EUSalesListReportingEngine constructByCountryRegionId(LogisticsAddressCountryRegionISOCode countyRegionId)
    {
        return SysExtensionAppClassFactory::getClassFromSysAttribute(
                                                    classStr(EUSalesListReportingEngine),
                                                    new CountryRegionAttribute(countyRegionId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initReportingEngine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>EUSalesListReportingEngine</c> class to verify that the company is enabled.
    /// </summary>
    /// <returns>
    ///    A new instance of the <c>EUSalesListReportingEngine</c> class.
    /// </returns>
    /// <remarks>
    ///    When implementing new descendants of the <c>EUSalesListReportingEngine</c> class this method must
    ///    be updated to consider them.
    /// </remarks>
    public static EUSalesListReportingEngine initReportingEngine(Args _args)
    {
        EUSalesListReportingEngine euSalesListReportingEngine;

        if ((TaxIntegrationUtils::isMultipleTaxIdEnabledForEUSalesList() || TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            && _args 
            && _args.dataset() == tableNum(TaxIntraCommTable_NL))
        {
            euSalesListReportingEngine = EUSalesListReportingEngine::constructByCountryRegionId(#isoNL);
            euSalesListReportingEngine.parmTaxRegistrationRecID(TaxIntraCommTable_NL::find(_args.record().RecId).TaxID);
        }
        else
        {
            euSalesListReportingEngine = EUSalesListReportingEngine::construct();
        }

        return euSalesListReportingEngine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompanyEnterpriseNumber</Name>
				<Source><![CDATA[
    private TaxRegistrationNumber getCompanyEnterpriseNumber()
    {
        // Get Enterprise number from the tax id country
        TaxRegistrationNumber taxRegistrationNumber = MultipleTaxIdReportingHelper::getTaxRegistrationNumberForTypeOnDate(taxRegistrationRecId, TaxRegistrationTypesList::UID);

        return taxRegistrationNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls whether the batch task should be retried in case of transient errors.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    [Hookable(false)]
    public boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompanyBranchId</Name>
				<Source><![CDATA[
    private TaxRegistrationNumber getCompanyBranchId()
    {
        // Get Branch number from the tax id country
        TaxRegistrationNumber taxRegistrationNumber = MultipleTaxIdReportingHelper::getTaxRegistrationNumberForTypeOnDate(taxRegistrationRecId, TaxRegistrationTypesList::BranchId);

        // If the tax id address doesn't have branch number then take BranchId
        if (!taxRegistrationNumber)
        {
            taxRegistrationNumber =  CompanyInfo::find().BranchId;
        }

        return taxRegistrationNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPost</Name>
				<Source><![CDATA[
    protected void dialogPost(Object dialog)
    {
        erParametersHandlerFile = ERParametersCustomDialogHandler::construct(dialog);

        dialogGroupFileFormat = dialog.addGroup("@AccountsReceivable:FileFormatMapping");
        erParametersHandlerFile.addFormatGenerationParameters(erFormatMappingFile);
        dialogGroupFileFormat.visible(dialogGenerateFile && dialogGenerateFile.value() == NoYes::Yes);

        erParametersHandlerReport = ERParametersCustomDialogHandler::construct(dialog);

        dialogGroupReportFormat = dialog.addGroup("@AccountsReceivable:ReportFormatMapping");
        erParametersHandlerReport.addFormatGenerationParameters(erFormatMappingReport);
        dialogGroupReportFormat.visible(dialogGenerateReport.value() == NoYes::Yes);

        super(dialog);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initERFormatMapping</Name>
				<Source><![CDATA[
    private void initERFormatMapping()
    {
        ERFileFormatMappingId fileERFormatMappingId;
        if (TaxIntegrationUtils::isMultipleTaxIdEnabledForEUSalesList() || TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            fileERFormatMappingId = EUSalesListReportingParameter::findByTaxRegistrationRecID(taxRegistrationRecId).FileERFormatMappingId;//TODO: research if taxRegistrationRecId exists on this stage and below
        }
        else
        {
            fileERFormatMappingId = IntrastatParameters::find().EUSLFileERFormatMappingId;
        }
        erFormatMappingFile = fileERFormatMappingId == 0 ? null: ERObjectsFactory::createFormatMappingRunByFormatMappingId(fileERFormatMappingId);

        ERFileFormatMappingId reportERFormatMappingId;
        if (TaxIntegrationUtils::isMultipleTaxIdEnabledForEUSalesList() || TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            reportERFormatMappingId = EUSalesListReportingParameter::findByTaxRegistrationRecID(taxRegistrationRecId).ReportERFormatMappingId;
        }
        else
        {
            reportERFormatMappingId = IntrastatParameters::find().EUSLReportERFormatMappingId;
        }
        erFormatMappingReport = reportERFormatMappingId == 0 ? null: ERObjectsFactory::createFormatMappingRunByFormatMappingId(reportERFormatMappingId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateReport_Modified</Name>
				<Source><![CDATA[
    private boolean generateReport_Modified(FormCheckBoxControl _formControl)
    {
        boolean ret = _formControl.modified();

        if (ret && dialogGroupReportFormat)
        {
            dialogGroupReportFormat.visible(dialogGenerateReport.value() == NoYes::Yes);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendVariableToPack</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected container appendVariableToPack(container _pack, str _className, str _variableName, anytype _value)
    {
        XppPrePostArgs packArgs = this.createXppPrePostArgsWithPack(_pack);
        SysPackExtensions::pack(packArgs, this.getVariablePackKey(_className, _variableName), [_value]);
        return packArgs.getReturnValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXppPrePostArgsWithPack</Name>
				<Source><![CDATA[
    private XppPrePostArgs createXppPrePostArgsWithPack(container _pack)
    {
        XppPrePostArgs prePostArgs = new XppPrePostArgs(_pack, '',  XppEventHandlerCalledWhen::Post);
        prePostArgs.setReturnValue(_pack);
        return prePostArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVariablePackKey</Name>
				<Source><![CDATA[
    private ClassName getVariablePackKey(str _className, str _variableName)
    {
        return _className + '.' + _variableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>extractPackedVariable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected anytype extractPackedVariable(container _pack, str _className, str _variableName)
    {
        anytype value;
        [value] = SysPackExtensions::unpack(this.createXppPrePostArgsWithPack(_pack), this.getVariablePackKey(_className, _variableName));
        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVATNameFromAddressLocation</Name>
				<Source><![CDATA[
    private Name getVATNameFromAddressLocation(EUSalesList _euSalesList)
    {
        DirPartyRecId party;

        if (_euSalesList.Direction == ModuleSalesPurch::Sales)
        {
            party = CustTable::find(_euSalesList.AccountNum).Party;
        }
        else
        {
            party = VendTable::find(_euSalesList.AccountNum).Party;
        }

        TaxRegistration taxRegistration;
        DirPartyPostalAddressView dirPartyPostalAddressView;
        utcdatetime fromDateTime = DateTimeUtil::newDateTime(fromDate, 0);
        utcdatetime toDateTime = DateTimeUtil::newDateTime(toDate, 0);

        select firstonly validtimestate(fromDateTime, toDateTime) LocationName from dirPartyPostalAddressView
            order by IsPrimary desc, ValidTo desc
            where dirPartyPostalAddressView.Party == party
        exists join taxRegistration
            where taxRegistration.DirPartyLocation == dirPartyPostalAddressView.PartyLocation
                && taxRegistration.RegistrationNumber == _euSalesList.vatNum;

        return dirPartyPostalAddressView.LocationName;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>