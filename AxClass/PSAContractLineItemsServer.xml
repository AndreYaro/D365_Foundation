<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PSAContractLineItemsServer</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class PsaContractLineItemsServer
{
    private PSAContractLineNum m_psaContractLineNum;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(PSAContractLineNum _psaContractLineNum = '')
    {
        this.parmContractLineNum(_psaContractLineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmContractLineNum</Name>
				<Source><![CDATA[
    public PSAContractLineNum parmContractLineNum(PSAContractLineNum _spsaContractLineNum = '')
    {
        if (_spsaContractLineNum != '')
        {
            m_psaContractLineNum = _spsaContractLineNum;
        }

        return m_psaContractLineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCategoryToContractLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Add categories to table PSAContractLineItemsSetup so that they are marked as selected.
    /// </summary>
    /// <param name="_cnProjLines">
    ///     A container containing the list of categories to be marked as selected.
    /// </param>
    /// <param name="_cnCategoryLines">
    ///     The cagetory line for which the categories are to be added.
    /// </param>
    /// <param name="_contractLineNum">
    ///     The billing rule for which the categories are being processed.
    /// </param>
   public static void addCategoryToContractLines(container _cnProjLines,
                                                  container _cnCategoryLines,
                                                  PSAContractLineNum _contractLineNum)
    {
        int                         i, j;
        ProjId                      sProjId;
        ProjCategoryId              sProjCategoryId;
        PSAContractLineItemsSetup   tpsaContractLineItemsSetup;

        ttsbegin;
        for (j = 1; j <= conLen(_cnProjLines); j++)
        {
            sProjId = conPeek(_cnProjLines, j);
            tpsaContractLineItemsSetup.ProjId = sProjId;

            for (i = 1; i <= conLen(_cnCategoryLines); i++)
            {
                sProjCategoryId = conPeek(_cnCategoryLines, i);
                if (sProjCategoryId)
                {
                    tpsaContractLineItemsSetup.ContractLineNum = _contractLineNum;
                    tpsaContractLineItemsSetup.CategoryId = sProjCategoryId;

                    tpsaContractLineItemsSetup.insert();
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addContractValueToContractLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///      Add On-Account transaction(s) to milestone billing rule.
    /// </summary>
    /// <param name="_cnContractValueLines">
    ///     Container containing a list of On-Account transaction IDs.
    /// </param>
    /// <param name="_contractLineNum">
    ///     The billing rule which will recieve the the On-Account transactions.
    /// </param>
    public static void addContractValueToContractLines(container _cnContractValueLines, PSAContractLineNum _contractLineNum)
    {
        int                         i;
        ProjOnAccTransId            projOnAccTransId;
        PSAContractLineItemsSetup   psaContractLineItemsSetup;
        ProjOnAccTrans              projOnAccTrans;
        ProjOnAccTransSale          projOnAccTransSale;
        PSAContractLineItems        contractLineItems;
        boolean                     isUpdate = false;

        ttsbegin;
        for (i = 1; i <= conLen(_cnContractValueLines); i++)
        {
            projOnAccTransId = conPeek(_cnContractValueLines, i);

            psaContractLineItemsSetup.ContractLineNum = _contractLineNum;
            psaContractLineItemsSetup.ProjOnAccTransId = projOnAccTransId;
            
            projOnAccTrans = ProjOnAccTrans::find(projOnAccTransId);

            psaContractLineItemsSetup.ProjId = projOnAccTrans.ProjID;

            select TransStatus from projOnAccTransSale
                where projOnAccTransSale.TransId == projOnAccTrans.TransId;
            if (projOnAccTransSale.TransStatus == ProjTransStatus::Registered)
            {
                psaContractLineItemsSetup.insert();
                isUpdate = true;
            }
            else
            {
                info("@PSA2911");
            }
        }

        if (isUpdate)
        {
            contractLineItems = PSAContractLineItems::find(_contractLineNum, true);
            if (contractLineItems)
            {
                contractLineItems.IsCrossReference = NoYes::Yes;
                contractLineItems.update();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addProjToContractLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds a list of projects to be enabled for a bulling rule.
    /// </summary>
    /// <param name="_cnProjLines">
    ///     Container containing a list of project IDs to be added to the billing rule.
    /// </param>
    /// <param name="_contractLineNum">
    ///     The billing rule to add the projects as selected.
    /// </param>
    public static void addProjToContractLines(container _cnProjLines, PSAContractLineNum _contractLineNum)
    {
        int                         i;
        ProjId                      projId;
        PSAContractLineItemsSetup   psaContractLineItemsSetup;

        ttsbegin;
        for (i = 1; i <= conLen(_cnProjLines); i++)
        {
            projId = conPeek(_cnProjLines, i);

            psaContractLineItemsSetup.ContractLineNum = _contractLineNum;
            psaContractLineItemsSetup.ProjId = projId;

            psaContractLineItemsSetup.insert();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRefCLINToContractLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Add list of fee billing rules to to be applied to another billing rule.
    /// </summary>
    /// <param name="_cnCLINLines">
    ///     Container of Fee billing rules.
    /// </param>
    /// <param name="_contractLineNum">
    ///     The billing rule that the fee billing rules will be applied.
    /// </param>
    public static void addRefCLINToContractLines(container _cnCLINLines, PSAContractLineNum _contractLineNum)
    {
        int                         i;
        PSAContractLineNum          psaContractLineNum;
        PSAContractLineItemsSetup   psaContractLineItemsSetup;
        PSAContractLineItems        contractLineItems;
        boolean                     isUpdate = false;

        ttsbegin;
        for (i = 1; i <= conLen(_cnCLINLines); i++)
        {
            psaContractLineNum = conPeek(_cnCLINLines, i);

            psaContractLineItemsSetup.ContractLineNum = _contractLineNum;
            psaContractLineItemsSetup.ContractLineNumReferred = psaContractLineNum;

            if ((PSAContractLineItems::find(_contractLineNum).LineType == PSAContractLineType::Fee)
                && (PSAContractLineItems::find(psaContractLineNum).LineType == PSAContractLineType::Fee))
            {
                throw error("@PSA11038");
            }

            if (_contractLineNum > psaContractLineNum)
            {
                psaContractLineItemsSetup.insert();
                isUpdate = true;
            }
            else
            {
                info(strFmt("@PSA10212", psaContractLineNum, _contractLineNum));
            }
        }

        if (isUpdate)
        {
            contractLineItems = PSAContractLineItems::find(_contractLineNum, true);
            if (contractLineItems)
            {
                contractLineItems.IsCrossReference = NoYes::Yes;
                contractLineItems.update();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calProjCurrentBudgetEmplAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    //      Calculate project current budget (hour category) amounts
    /// </summary>
    /// <param name="_projId">
    ///     The project ID of the budget.
    /// </param>
    /// <param name="_categoryId">
    ///     The category ID for which the the budgeted amount is computed.
    /// </param>
    /// <returns>
    ///     Returns the budgeted amount for the category specified.
    /// </returns>
    public static Amount calProjCurrentBudgetEmplAmounts(ProjId _projId,
                                                         ProjCategoryId _categoryId)
    {
        Amount                      totalAmount;
        ProjForecastEmpl            projForecastEmpl;
        ProjBudgetLine              projBudgetLine;
        ProjBudget                  projBudget;

        select ProjId,CategoryId from projForecastEmpl
            where projForecastEmpl.ProjId == _projId
               && projForecastEmpl.CategoryId == _categoryId
               && projForecastEmpl.ProjForecastBudgetType == ProjForecastBudgetType::OriginalBudget
        join ProjId,TotalBudget from projBudgetLine
        where projBudgetLine.ProjId == projForecastEmpl.ProjId
           && projBudgetLine.CategoryId == projForecastEmpl.CategoryId
           && projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost
        exists join projBudget
        where projBudget.RootProjId == projBudgetLine.ProjId
        && projBudget.BudgetWorkflowStatus == ProjBudgetWorkflowStatus::Approved;

        totalAmount = projBudgetLine.TotalBudget;

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calProjCurrentBudgetCostAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculate project current budget (cost category) amounts.
    /// </summary>
    /// <param name="_projId">
    ///     The project ID of the budget.
    /// </param>
    /// <param name="_categoryId">
    ///     The category ID for which the the budgeted amount is computed.
    /// </param>
    /// <returns>
    ///     Returns the budgeted amount for the category specified.
    /// </returns>
    public static Amount calProjCurrentBudgetCostAmounts(ProjId _projId,
                                                         ProjCategoryId _categoryId)
    {
        Amount                      totalAmount;
        ProjForecastCost            projForecastCost;
        ProjBudgetLine              projBudgetLine;
        ProjBudget                  projBudget;

        select ProjId,CategoryId from projForecastCost
            where projForecastCost.ProjId == _projId
               && projForecastCost.CategoryId == _categoryId
               && projForecastCost.ProjForecastBudgetType == ProjForecastBudgetType::OriginalBudget
        join ProjId,TotalBudget from projBudgetLine
        where projBudgetLine.ProjId == projForecastCost.ProjId
           && projBudgetLine.CategoryId == projForecastCost.CategoryId
           && projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost
        exists join projBudget
        where projBudget.RootProjId == projBudgetLine.ProjId
        && projBudget.BudgetWorkflowStatus == ProjBudgetWorkflowStatus::Approved;

        totalAmount = projBudgetLine.TotalBudget;

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calProjCurrentBudgetItemAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculate project current budget (item category) amounts.
    /// </summary>
    /// <param name="_projId">
    ///     The project ID of the budget.
    /// </param>
    /// <param name="_categoryId">
    ///     The category ID for which the the budgeted amount is computed.
    /// </param>
    /// <returns>
    ///     Returns the budgeted amount for the category specified.
    /// </returns>
    public static Amount calProjCurrentBudgetItemAmounts(ProjId _projId,
                                                         ProjCategoryId _categoryId)

    {
        Amount                      totalAmount;
        ForecastSales               forecastSales;
        ProjBudgetLine              projBudgetLine;
        ProjBudget                  projBudget;

        select ProjId,ProjCategoryId from forecastSales
            where forecastSales.ProjId == _projId
               && forecastSales.ProjCategoryId == _categoryId
        join ProjId,TotalBudget from projBudgetLine
        where projBudgetLine.ProjId == forecastSales.ProjId
           && projBudgetLine.CategoryId == forecastSales.ProjCategoryId
           && projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost
        exists join projBudget
            where projBudget.RootProjId == projBudgetLine.ProjId
            && projBudget.BudgetWorkflowStatus == ProjBudgetWorkflowStatus::Approved;

        totalAmount = projBudgetLine.TotalBudget;

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>computeQuantityForUOD</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Computes the quantity by using LineValue in PSAContractItems and LineAmount
    ///     for a billing rule of type UOD.
    /// </summary>
    /// <param name="_contractLineNum">
    ///     The billing rule Id to compute amount.
    /// </param>
    /// <param name="_lineAmount">
    ///     The Line Amount in ProjProposalRevenueDetail or ProjProposalRevenueTransSale.
    /// </param>
    /// <param name="_isCreditNote">
    ///     The parameter checks whether the current process is for credit note or not.
    /// </param>
    /// <returns>
    ///     Quantity if the billing rule is Unit of Delivery. Otherwise, it will return a 0.
    /// </returns>
    public static InventQty computeQuantityForUOD(
                        PSAContractLineNum _contractLineNum,
                        AmountCur _lineAmount,
                        boolean _isCreditNote = false)
    {
        InventQty               invoiceQty;
        InventQty               totalUnits;
        real                    percentCompleted;
        PSAContractLineItems    psaContractLineItem;

        psaContractLineItem = PSAContractLineItems::find(_contractLineNum);

        if (psaContractLineItem.LineType == PSAContractLineType::UOD)
        {
            totalUnits = psaContractLineItem.Units;

            if ((_lineAmount > 0.0 || (_lineAmount < 0.0 && _isCreditNote))
                && totalUnits > 0.0
                && psaContractLineItem.LineValue > 0.0)
            {
                percentCompleted = abs(_lineAmount) / psaContractLineItem.LineValue;
                invoiceQty       = totalUnits * percentCompleted;
            }
        }

        return decRound(invoiceQty, 2);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static PSAContractLineItemsServer construct(PSAContractLineNum _psaContractLineNum = '')
    {
        return new PSAContractLineItemsServer(_psaContractLineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteCategoryFromContractLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Remove the categories selectd for a project associated to a billing rule.
    /// <param name="_cnProjLines">
    ///     Container containing a list for project IDs.
    /// </summary>
    /// <param name="_cnCategoryLines">
    ///     Cpmtaomer containing a list of category IDs.
    /// </param>
    /// <param name="_contractLineNum">
    ///     The billing rule to remove categories as being selected.
    /// </param>
   public static void deleteCategoryFromContractLines(container _cnProjLines,
                                                       container _cnCategoryLines,
                                                       PSAContractLineNum _contractLineNum)
    {
        int                         i, j;
        ProjCategoryId              projCategoryId;
        ProjId                      projId;
        PSAContractLineItemsSetup   psaContractLineItemsSetup;

        ttsbegin;
        for (j = 1; j <= conLen(_cnProjLines); j++)
        {
            projId = conPeek(_cnProjLines, j);

            for (i = 1; i <= conLen(_cnCategoryLines); i++)
            {
                projCategoryId = conPeek(_cnCategoryLines, i);
                if (projCategoryId)
                {
                    delete_from psaContractLineItemsSetup
                        where psaContractLineItemsSetup.ContractLineNum == _contractLineNum
                           && psaContractLineItemsSetup.CategoryId == projCategoryId
                           && psaContractLineItemsSetup.ProjId == projId;
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteContractValueFromContractLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///      Remove reference between On-Account transation to a billing rule.
    /// </summary>
    /// <param name="_cnContractValueLines">
    ///     Containter of On-Account transaction IDS.
    /// </param>
    /// <param name="_contractLineNum">
    ///     The billing rule to remove references.
    /// </param>
    public static void deleteContractValueFromContractLines(container _cnContractValueLines, PSAContractLineNum _contractLineNum)
    {
        int                         i;
        ProjOnAccTransId            projOnAccTransId;
        PSAContractLineItemsSetup   psaContractLineItemsSetup;
        PSAContractLineItems        contractLineItems;

        ttsbegin;
        for (i = 1; i <= conLen(_cnContractValueLines); i++)
        {
            projOnAccTransId = conPeek(_cnContractValueLines, i);
            if (projOnAccTransId)
            {
                delete_from psaContractLineItemsSetup
                    where psaContractLineItemsSetup.ContractLineNum == _contractLineNum
                       && psaContractLineItemsSetup.ProjOnAccTransId == projOnAccTransId;
            }
        }

        contractLineItems = PSAContractLineItems::find(_contractLineNum, true);
        if (contractLineItems)
        {
            select firstonly psaContractLineItemsSetup
                where psaContractLineItemsSetup.ContractLineNum == _contractLineNum
                   && psaContractLineItemsSetup.ProjOnAccTransId != '';
            if (!psaContractLineItemsSetup.RecId)
            {
                contractLineItems.IsCrossReference = NoYes::No;
                contractLineItems.update();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteProjFromContractLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Removes selected projects from a billing rule.
    /// </summary>
    /// <param name="_cnProjLines">
    ///     Container containing a list of project IDs.
    /// </param>
    /// <param name="_contractLineNum">
    ///     The billing rule to remove the projects as being selected.
    /// </param>
    public static void deleteProjFromContractLines(container _cnProjLines, PSAContractLineNum _contractLineNum)
    {
        int                         i;
        ProjId                      projId;
        PSAContractLineItemsSetup   psaContractLineItemsSetup;

        ttsbegin;
        for (i = 1; i <= conLen(_cnProjLines); i++)
        {
            projId = conPeek(_cnProjLines, i);
            if (projId)
            {
                delete_from psaContractLineItemsSetup
                    where psaContractLineItemsSetup.ContractLineNum == _contractLineNum
                       && psaContractLineItemsSetup.ProjId == projId;
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRefCLINFromContractLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Remove the relationship of billing rules to another billing rule.
    /// </summary>
    /// <param name="_cnCLINLines">
    ///     Container containing a list of billing rule IDs.
    /// </param>
    /// <param name="_contractLineNum">
    ///     The billing rule to rmmove the reference from.
    /// </param>
    public static void deleteRefCLINFromContractLines(container _cnCLINLines, PSAContractLineNum _contractLineNum)
    {
        int                         i;
        PSAContractLineNum          psaContractLineNum;
        PSAContractLineItemsSetup   psaContractLineItemsSetup;
        PSAContractLineItems        ContractLineItems;

        ttsbegin;
        for (i = 1; i <= conLen(_cnCLINLines); i++)
        {
            psaContractLineNum = conPeek(_cnCLINLines, i);
            if (psaContractLineNum)
            {
                delete_from psaContractLineItemsSetup
                    where psaContractLineItemsSetup.ContractLineNum == _contractLineNum
                       && psaContractLineItemsSetup.ContractLineNumReferred == psaContractLineNum;
            }
        }

        contractLineItems = PSAContractLineItems::find(_contractLineNum, true);
        if (contractLineItems)
        {
            select firstonly psaContractLineItemsSetup
                where psaContractLineItemsSetup.ContractLineNum == _contractLineNum
                   && psaContractLineItemsSetup.ContractLineNumReferred != '';
            if (!psaContractLineItemsSetup.RecId)
            {
                contractLineItems.IsCrossReference = NoYes::No;
                contractLineItems.update();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContractLineInvoicedAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///      Get amo9unt which has been invoiced  for a billing rule.
    /// </summary>
    /// <param name="_contractLineNum">
    ///     The billing rule to return invoiced amounts.
    /// </param>
    /// <param name="_projInvoiceId">
    ///   The contract ID associated with the billng rule.
    /// </param>
    /// <param name="_includeFutureInvoices">
    ///    Include future invoices in the calculation.
    /// </param>
    /// <returns>
    ///     Returnss the invoiced qamount in the contract's currency.
    /// </returns>
    public static Amount getContractLineInvoicedAmounts(PSAContractLineNum _contractLineNum,
                                                        ProjInvoiceId _projInvoiceId = '',
                                                        boolean _includeFutureInvoices = true)
    {
        Amount                  invoicedAmounts;
        ProjInvoiceTable        projInvoiceTable;
        PSAContractLineItems    psaContractLineItems;
        InvoiceDate             invoiceDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

        select firstonly CurrencyId from projInvoiceTable
            exists join psaContractLineItems
                where projInvoiceTable.ProjInvoiceProjId == psaContractLineItems.ProjInvoiceProjId &&
                psaContractLineItems.ContractLineNum == _contractLineNum;

        ProjInvoiceCost         projInvoiceCost;
        ProjInvoiceCostDetail   projInvoiceCostDetail;

        while select CurrencyId, InvoiceDate from projInvoiceCost
            where projInvoiceCost.psaContractLineNum == _contractLineNum
               && (projInvoiceCost.ProjInvoiceId == _projInvoiceId || !_projInvoiceId)
               && (_includeFutureInvoices || projInvoiceCost.InvoiceDate <= invoiceDate)
            join LineAmount from projInvoiceCostDetail
                where projInvoiceCost.RecId==projInvoiceCostDetail.InvoiceRefRecId
        {
            invoicedAmounts += CurrencyExchangeHelper::curAmount2CurAmount(projInvoiceCostDetail.LineAmount,
                                                                            projInvoiceCost.CurrencyId,
                                                                            projInvoiceTable.CurrencyId,
                                                                            projInvoiceCost.InvoiceDate,
                                                                            false);
        }

        ProjInvoiceEmpl         projInvoiceEmpl;
        ProjInvoiceEmplDetail   projInvoiceEmplDetail;
        ProjEmplTransSale       projEmplTransSale;

        while select CurrencyId, InvoiceDate from projInvoiceEmpl
            where projInvoiceEmpl.psaContractLineNum == _contractLineNum
               && (projInvoiceEmpl.ProjInvoiceId == _projInvoiceId || !_projInvoiceId)
               && (_includeFutureInvoices || projInvoiceEmpl.InvoiceDate <= invoiceDate)
            join LineAmount, SaleRefRecId from projInvoiceEmplDetail
                where projInvoiceEmpl.RecId==projInvoiceEmplDetail.InvoiceRefRecId
        {
            invoicedAmounts += CurrencyExchangeHelper::curAmount2CurAmount(projInvoiceEmplDetail.LineAmount,
                                                                            projInvoiceEmpl.CurrencyId,
                                                                            projInvoiceTable.CurrencyId,
                                                                            projInvoiceEmpl.InvoiceDate);

            // add indirect invoice amount
            // this select will filter both by transaction id and funding source
            select psaIndirectInvoice from projEmplTransSale where projEmplTransSale.RecId == projInvoiceEmplDetail.SaleRefRecId;

            invoicedAmounts += CurrencyExchangeHelper::curAmount2CurAmount(projEmplTransSale.psaIndirectInvoice,
                                                                            projInvoiceEmpl.CurrencyId,
                                                                            projInvoiceTable.CurrencyId,
                                                                            projInvoiceEmpl.InvoiceDate);
        }

        ProjInvoiceRevenue          projInvoiceRevenue;
        ProjInvoiceRevenueDetail    projInvoiceRevenueDetail;

        while select CurrencyId, InvoiceDate from projInvoiceRevenue
            where projInvoiceRevenue.psaContractLineNum == _contractLineNum
               && (projInvoiceRevenue.ProjInvoiceId == _projInvoiceId || !_projInvoiceId)
               && (_includeFutureInvoices || projInvoiceRevenue.InvoiceDate <= invoiceDate)
               && projInvoiceRevenue.IsRetained == NoYes::No
               && projInvoiceRevenue.IsReleased == NoYes::No
            join LineAmount from projInvoiceRevenueDetail
                where projInvoiceRevenue.RecId==projInvoiceRevenueDetail.InvoiceRefRecId
        {
            invoicedAmounts += CurrencyExchangeHelper::curAmount2CurAmount(projInvoiceRevenueDetail.LineAmount,
                                                                            projInvoiceRevenue.CurrencyId,
                                                                            projInvoiceTable.CurrencyId,
                                                                            projInvoiceRevenue.InvoiceDate);
        }

        ProjInvoiceItem         projInvoiceItem;
        ProjInvoiceItemDetail   projInvoiceItemDetail;

        while select CurrencyId, InvoiceDate from projInvoiceItem
            where projInvoiceItem.psaContractLineNum == _contractLineNum
               && (projInvoiceItem.ProjInvoiceId == _projInvoiceId || !_projInvoiceId)
               && (_includeFutureInvoices || projInvoiceItem.InvoiceDate <= invoiceDate)
            join LineAmount from projInvoiceItemDetail
                where projInvoiceItem.RecId==projInvoiceItemDetail.InvoiceRefRecId
        {
            invoicedAmounts += CurrencyExchangeHelper::curAmount2CurAmount(projInvoiceItemDetail.LineAmount,
                                                                            projInvoiceItem.CurrencyId,
                                                                            projInvoiceTable.CurrencyId,
                                                                            projInvoiceItem.InvoiceDate);
        }

        ProjInvoiceOnAcc        projInvoiceOnAcc;
        ProjInvoiceOnAccDetail  projInvoiceOnAccDetail;

        while select CurrencyId, InvoiceDate from projInvoiceOnAcc
            where projInvoiceOnAcc.psaContractLineNum == _contractLineNum
               && (projInvoiceOnAcc.ProjInvoiceId == _projInvoiceId || !_projInvoiceId)
               && (_includeFutureInvoices || projInvoiceOnAcc.InvoiceDate <= invoiceDate)
            join Amount from projInvoiceOnAccDetail
                where projInvoiceOnAcc.RecId==projInvoiceOnAccDetail.InvoiceRefRecId
        {
            invoicedAmounts += CurrencyExchangeHelper::curAmount2CurAmount(projInvoiceOnAccDetail.Amount,
                                                                            projInvoiceOnAcc.CurrencyId,
                                                                            projInvoiceTable.CurrencyId,
                                                                            projInvoiceOnAcc.InvoiceDate);
        }

        return invoicedAmounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContractLineInvoicedUnitsForUOD</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Get invoiced units(QTY) for a unit of delivery billing rule.
    /// </summary>
    /// <param name="_contractLineNum">
    ///     The billing rule to get the invoice unit of delivery qty.
    /// </param>
    /// <returns>
    ///     Returns the units which have been invoiced for the specified billing rule.
    /// </returns>
    public static Qty getContractLineInvoicedUnitsForUOD(PSAContractLineNum _contractLineNum)
    {
        PSAUnitsUpdateLog                   psaUnitsUpdateLog;

        select sum(AdditionalUnits) from psaUnitsUpdateLog
            where psaUnitsUpdateLog.ContractLineNum == _contractLineNum
               && psaUnitsUpdateLog.IsProposal == NoYes::Yes
               && psaUnitsUpdateLog.IsInvoiced == NoYes::Yes;

        return psaUnitsUpdateLog.AdditionalUnits;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldInvoiceLogBeSplit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check if a posting an invoice, should cause the record
    ///     in PSAUnitsUpdateLog to split into two records.
    /// </summary>
    /// <param name="_contractLineNum">
    ///     The billing rule, which you want to check for the split.
    /// </param>
    /// <returns>
    ///     true, if the billing rule has a split; otherwise, false.
    /// </returns>
    public static boolean shouldInvoiceLogBeSplit(PSAContractLineNum _contractLineNum)
    {
        ProjRevenueTrans            projRevenueTrans;
        ProjProposalRevenue         projProposalRevenue;
        ProjProposalJour            projProposalJour;

        select count(RecId) from projProposalRevenue
        exists join projRevenueTrans where
               projRevenueTrans.TransId            == projProposalRevenue.TransId &&
               projRevenueTrans.psaContractLineNum == _contractLineNum
        exists join projProposalJour where
               projProposalJour.ProposalId    == projProposalRevenue.ProposalId &&
               projProposalJour.ProjInvoiceId == '';

        if (!projProposalRevenue)
        {
            return false;
        }

        return projProposalRevenue.RecId > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAllOnAccTransAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Total amount for contract line of Lump sum type.
    /// </summary>
    /// <param name="_contractLineNum">
    ///     The lump sum billing rule.
    /// </param>
    /// <returns>
    ///     Returns total lump sum amount.
    /// </returns>
    public static Amount totalAllOnAccTransAmounts(PSAContractLineNum _contractLineNum)
    {
        ProjOnAccTrans              projOnAccTrans;
        ProjOnAccTransSale          projOnAccTransSale;
        PSAContractLineItemsSetup   psaContractLineItemsSetup;

        select sum(Amount) from projOnAccTransSale
            join TransId from projOnAccTrans
            where projOnAccTransSale.TransId == projOnAccTrans.TransId &&
                  projOnAccTransSale.TransStatus != ProjTransStatus::Adjusted
            exists join psaContractLineItemsSetup
            where psaContractLineItemsSetup.ProjOnAccTransId == projOnAccTrans.TransId
               && psaContractLineItemsSetup.ContractLineNum == _contractLineNum;

        return projOnAccTransSale.Amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalContractLineInvoicedAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Total invoiced amount for a contract.
    /// </summary>
    /// <param name="_projInvoiceProjId">
    ///     The contract ID to calculate the invoiced amount.
    /// </param>
    /// <param name="_includeFutureInvoices">
    ///     Include future dated invoices in the calculation.
    /// </param>
    /// <returns>
    ///    Returns the amount which has been invoiced.
    /// </returns>
    public static Amount totalContractLineInvoicedAmounts(ProjInvoiceProjId _projInvoiceProjId, boolean _includeFutureInvoices = true)
    {
        PSAContractLineItems                psaContractLineItems;
        Amount                              totalInvoicedAmount;

        while select ContractLineNum from psaContractLineItems
            index ContractLineNumIdx
            where psaContractLineItems.ProjInvoiceProjId == _projInvoiceProjId
        {
            totalInvoicedAmount += PSAContractLineItemsServer::getContractLineInvoicedAmounts(psaContractLineItems.ContractLineNum, '', _includeFutureInvoices);
        }

        return totalInvoicedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalContractLinePaid</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The total amount which has been paid on a contract.
    /// </summary>
    /// <param name="_projInvoiceProjId">
    ///     The contract ID for paid trainsactions.
    /// </param>
    /// <returns>
    ///     Returns the maount which has benn paid for the contract.
    /// </returns>
    public static Amount totalContractLinePaid(ProjInvoiceProjId _projInvoiceProjId)
    {
        PSAContractLineItems psaContractLineItems;

        select sum(PaidAmount) from psaContractLineItems
            where psaContractLineItems.ProjInvoiceProjId == _projInvoiceProjId;

        return psaContractLineItems.PaidAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalContractLineRetainedAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Get the totall retained amounts for a contract.
    /// </summary>
    /// <param name="_projInvoiceProjId">
    ///     The contract Id to calculate retained amounts.
    /// </param>
    /// <param name="_includeFutureInvoices">
    ///     Include future invoices in the calculation.
    /// </param>
    /// <returns>
    ///     Returns the total amount which has been retained for a contract.
    /// </returns>
    public static Amount totalContractLineRetainedAmounts(ProjInvoiceProjId _projInvoiceProjId, boolean _includeFutureInvoices = true)
    {
        PSAContractLineItems psaContractLineItems;
        Amount  totalRetainedAmount;

        while select ContractLineNum from psaContractLineItems
            index ContractLineNumIdx
            where psaContractLineItems.ProjInvoiceProjId == _projInvoiceProjId
        {
            totalRetainedAmount += PSAContractInvoiceRetain::calcRetainedAmount(psaContractLineItems.ContractLineNum, '',  _includeFutureInvoices);
        }

        return totalRetainedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalContractLineValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Get the total contract amount as defined by the billing rules.
    /// </summary>
    /// <param name="_projInvoiceProjId">
    ///     The contract ID to calclate contract value.
    /// </param>
    /// <returns>
    ///     Returns the total contract amount.
    /// </returns>
    public static Amount totalContractLineValues(ProjInvoiceProjId _projInvoiceProjId)
    {
        PSAContractLineItems psaContractLineItems;

        select sum(LineValue) from psaContractLineItems
            where psaContractLineItems.ProjInvoiceProjId == _projInvoiceProjId;

        return psaContractLineItems.LineValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateContractLineValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Update contract amount for billing rule of type Lump Sum.
    /// </summary>
    /// <param name="_contractLineNum">
    ///     The billing rule ID to be updated.
    /// </param>
    public static void updateContractLineValue(PSAContractLineNum _contractLineNum)
    {
        PSAContractLineItems            tpsaContractLineItems;

        ttsbegin;
        select forupdate firstonly tpsaContractLineItems
            where tpsaContractLineItems.ContractLineNum == _contractLineNum;

        if (tpsaContractLineItems)
        {
            tpsaContractLineItems.LineValue = PSAContractLineItemsServer::totalAllOnAccTransAmounts(_contractLineNum);

            tpsaContractLineItems.update();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProgressPercent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Update percent complete for Progress contract line.
    /// </summary>
    /// <param name="_contractLineNum">
    ///     The billing rule ID to be upated.
    /// </param>
    /// <param name="_updatePercent">
    ///    The new percentage complete value.
    /// </param>
    public static void updateProgressPercent(PSAContractLineNum _contractLineNum, PSAPercent _updatePercent)
    {
        PSAPercentUpdateLog     percentUpdateLog;

        if (_updatePercent == 0)
        {
            return;
        }

        percentUpdateLog = PSAPercentUpdateLog::find(_contractLineNum);
        if ((!percentUpdateLog) || (percentUpdateLog.IsInvoiced && percentUpdateLog.IsProposal))
        {
            ttsbegin;
            percentUpdateLog.ContractLineNum = _contractLineNum;
            percentUpdateLog.RevisedPercent = _updatePercent;
            percentUpdateLog.IsInvoiced = NoYes::No;
            percentUpdateLog.IsProposal = NoYes::No;
            percentUpdateLog.insert();
            ttscommit;
        }
        else
        {
            ttsbegin;
            percentUpdateLog = PSAPercentUpdateLog::find(_contractLineNum, true);
            percentUpdateLog.RevisedPercent = _updatePercent;
            percentUpdateLog.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateUnitsOrPercentInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Set the number of units or percentage complete for an invice.
    /// </summary>
    /// <param name="_contractLineNum">
    ///     The billing rule ID to be updated.
    /// </param>
    /// <param name="_bNoYes">
    ///     The value specified has been invoiced.
    /// </param>
    /// <param name="_invoiceQty">
    ///     The number of units ready to be invoiced for a unit of delivery billing rule.
    /// </param>
    /// <param name="_invoicedAmount">
    ///     The percentage complete for a progress billing rule.
    /// </param>
    /// <param name="_isCreditNote">
    ///    Is this a credit invoice.
    /// </param>
    public static void updateUnitsOrPercentInvoice(
        PSAContractLineNum _contractLineNum,
        NoYesId _bNoYes,
        InventQty _invoiceQty = 0.0,
        Amount _invoicedAmount = 0.0,
        boolean _isCreditNote = false)
    {
        PSAContractLineItems psaContractLineItems;
        PSAUnitsUpdateLog psaUnitsUpdateLog;
        PSAPercentUpdateLog psaPercentUpdateLog;
        InventQty origAmount;

        psaContractLineItems = PSAContractLineItems::find(_contractLineNum);
        if (psaContractLineItems.LineType == PSAContractLineType::Progress)
        {
            psaPercentUpdateLog = PSAPercentUpdateLog::find(psaContractLineItems.ContractLineNum, true);
            if (psaPercentUpdateLog)
            {
                // Rounding the invoiced percent value up to two decimals.
                psaPercentUpdateLog.CurrentPercent += round(100 * _invoicedAmount / psaContractLineItems.LineValue, 0.01);
                if (_invoicedAmount < 0)
                {
                    // Credit note case. We need to set these flags to false to indicate the billing rule is
                    // ready to be invoiced again
                    psaPercentUpdateLog.IsInvoiced = false;
                    psaPercentUpdateLog.IsProposal = false;
                    // Set RevisedPercent back to the original one, so that same percent is picked for new invoice
                    psaPercentUpdateLog.RevisedPercent = - 100 * _invoicedAmount / psaContractLineItems.LineValue;
                }
                else
                {
                    psaPercentUpdateLog.IsInvoiced = _bNoYes;
                    psaPercentUpdateLog.IsProposal = _bNoYes;
                }

                psaPercentUpdateLog.update();
            }
        }
        else if (psaContractLineItems.LineType == PSAContractLineType::UOD)
        {
            if (_isCreditNote)
            {
                select forUpdate firstonly psaUnitsUpdateLog
                    where psaUnitsUpdateLog.ContractLineNum == psaContractLineItems.ContractLineNum &&
                    psaUnitsUpdateLog.AdditionalUnits == _invoiceQty;
            }
            else
            {
                psaUnitsUpdateLog = PSAUnitsUpdateLog::find(psaContractLineItems.ContractLineNum, true);
            }

            if (psaUnitsUpdateLog)
            {
                if (_invoiceQty != 0
                    && psaUnitsUpdateLog.AdditionalUnits - _invoiceQty >= 0.0
                    && _isCreditNote
                    && _bNoYes == NoYes::Yes)
                {
                    origAmount = psaUnitsUpdateLog.AdditionalUnits;

                    if (psaUnitsUpdateLog.AdditionalUnits - _invoiceQty > 0.0)
                    {
                        psaUnitsUpdateLog.AdditionalUnits = _invoiceQty;
                        psaUnitsUpdateLog.IsProposal      = NoYes::Yes;
                        psaUnitsUpdateLog.IsInvoiced      = NoYes::Yes;
                        psaUnitsUpdateLog.update();

                        psaUnitsUpdateLog.clear();
                        psaUnitsUpdateLog.initValue();
                        psaUnitsUpdateLog.ContractLineNum = _contractLineNum;
                        psaUnitsUpdateLog.AdditionalUnits = origAmount - _invoiceQty;
                        psaUnitsUpdateLog.IsProposal      = NoYes::Yes;
                        psaUnitsUpdateLog.IsInvoiced      = NoYes::No;
                        psaUnitsUpdateLog.insert();
                    }
                    else if (_isCreditNote)
                    {
                        psaUnitsUpdateLog.AdditionalUnits = origAmount - _invoiceQty;
                        psaUnitsUpdateLog.IsProposal      = NoYes::No;
                        psaUnitsUpdateLog.IsInvoiced      = NoYes::No;
                        psaUnitsUpdateLog.update();
                    }
                }
                else
                {
                    psaUnitsUpdateLog.AdditionalUnits = _invoiceQty;

                    psaUnitsUpdateLog.IsInvoiced = _bNoYes;
                    psaUnitsUpdateLog.IsProposal = _bNoYes;
                    psaUnitsUpdateLog.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateUnitsOrPercentProposal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Update a contract line itme with updated unit or percentages.
    /// </summary>
    /// <param name="_contractLineNum">
    ///     The billing rule to update unit of delivery or percantage amount.
    /// </param>
    /// <param name="_bNoYes">
    ///     Is this and update for a contract proposal.
    /// </param>
    /// <param name="_additionaUnits">
    ///     The unit of delivery amount or percentage complete for invoicing.
    /// </param>
    /// <param name="_isCreditNote">
    ///     Is this a credit note invoice proposal.
    /// </param>
    public static void updateUnitsOrPercentProposal(
        PSAContractLineNum _contractLineNum,
        NoYesId _bNoYes,
        InventQty _additionaUnits = 0.0,
        boolean _isCreditNote = false)
    {
        PSAContractLineItems tpsaContractLineItems;
        PSAUnitsUpdateLog tpsaUnitsUpdateLog;
        PSAPercentUpdateLog tpsaPercentUpdateLog;

        tpsaContractLineItems = PSAContractLineItems::find(_contractLineNum);
        if (tpsaContractLineItems.LineType == PSAContractLineType::Progress)
        {
            tpsaPercentUpdateLog = PSAPercentUpdateLog::find(tpsaContractLineItems.ContractLineNum, true);
            if (tpsaPercentUpdateLog)
            {
                tpsaPercentUpdateLog.IsProposal = _bNoYes;
                tpsaPercentUpdateLog.update();
            }
        }
        else if (tpsaContractLineItems.LineType == PSAContractLineType::UOD)
        {
            if (_isCreditNote)
            {
                select forUpdate firstonly tpsaUnitsUpdateLog where
                   tpsaUnitsUpdateLog.ContractLineNum == tpsaContractLineItems.ContractLineNum &&
                   tpsaUnitsUpdateLog.AdditionalUnits == _additionaUnits;
            }
            else
            {
                tpsaUnitsUpdateLog = PSAUnitsUpdateLog::find(tpsaContractLineItems.ContractLineNum, true);
            }
            if (tpsaUnitsUpdateLog)
            {
                if (!prmisDefault(_additionaUnits))
                {
                    tpsaUnitsUpdateLog.AdditionalUnits = _additionaUnits;
                }
                tpsaUnitsUpdateLog.IsProposal = _bNoYes;
                tpsaUnitsUpdateLog.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateUODUnits</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Update units for Unit of delivery contract line.
    /// </summary>
    /// <param name="_contractLineNum">
    ///     The billing rule for which the the unit of delivery needs to be computed.
    /// </param>
    /// <param name="_additionalUnits">
    ///     The number of addtional units wich are ready to be invoiced.
    /// </param>
    public static void updateUODUnits(PSAContractLineNum _contractLineNum, Amount _additionalUnits)
    {
        PSAUnitsUpdateLog   unitsUpdateLog;

        unitsUpdateLog = PSAUnitsUpdateLog::find(_contractLineNum);

        if (unitsUpdateLog.IsProposal == NoYes::Yes)
        {
            error("@SYS4000550");
            return;
        }

        if (_additionalUnits == 0)
        {
            ttsbegin;
            delete_from unitsUpdateLog where
                  unitsUpdateLog.ContractLineNum == _contractLineNum &&
                  unitsUpdateLog.IsProposal      == NoYes::No;
            ttscommit;

            return;
        }

        if ((!unitsUpdateLog) || (unitsUpdateLog.IsInvoiced && unitsUpdateLog.IsProposal))
        {
            ttsbegin;

            unitsUpdateLog.ContractLineNum  = _contractLineNum;

            if (unitsUpdateLog)
            {
                unitsUpdateLog.CurrentUnits = unitsUpdateLog.CurrentUnits + unitsUpdateLog.AdditionalUnits;
            }
            else
            {
                unitsUpdateLog.CurrentUnits = 0.0;
            }
            unitsUpdateLog.AdditionalUnits  = _additionalUnits;
            unitsUpdateLog.IsInvoiced       = NoYes::No;
            unitsUpdateLog.IsProposal       = NoYes::No;
            unitsUpdateLog.insert();

            ttscommit;
        }
        else
        {
            ttsbegin;
            unitsUpdateLog                 = PSAUnitsUpdateLog::find(_contractLineNum, true);
            unitsUpdateLog.AdditionalUnits = _additionalUnits;
            unitsUpdateLog.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>