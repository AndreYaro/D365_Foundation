<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>GanttControlVisualization</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class GanttControlVisualization extends GanttVisualization
{
    GanttControl ganttControl;
    str lastSelectedActivityId;
    GanttControlActivityIdCollection allSelectedActivityIds;
    List ganttControlModificationResponseList;
    Map linksMapNextCache;
    Map linksMapPreviousCache;

    protected internal boolean showInUserTZ;

    // Number based on reasonable perf on IE 11 on std desktop machine
    const int maxNumberOfCalendarCells = 20000;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmGanttControl</Name>
				<Source><![CDATA[
    public GanttControl parmGanttControl(GanttControl _ganttControl = ganttControl)
    {
        if (!prmIsDefault(_ganttControl))
        {
            ganttControl = _ganttControl;
        }
        return ganttControl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onActivtySelected</Name>
				<Source><![CDATA[
    public void onActivtySelected(str _activityId, GanttControlActivityIdCollection _allSelectedActivityIds)
    {
        lastSelectedActivityId = _activityId;
        allSelectedActivityIds = _allSelectedActivityIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onActivityDblClick</Name>
				<Source><![CDATA[
    public void onActivityDblClick(str _activityId)
    {
        lastSelectedActivityId = _activityId;
        this.showInfo();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentTimeVerticalMarker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list with a single vertical marker representing the current date and time.
    /// </summary>
    /// <returns>A list with the current time marker.</returns>
    public List getCurrentTimeVerticalMarker()
    {
        List markers = new List(Types::Class);

        if (!ProdGanttApplyUserTimezoneOffsetFlight::instance().isEnabled() || showInUserTZ)
        {
            markers.addEnd(GanttControlVerticalMarker::newStandard(DateTimeUtil::utcNow(),''));
        }
        else
        {
            markers.addEnd(GanttControlVerticalMarker::newStandard(DateTimeUtil::removeTimeZoneOffset(DateTimeUtil::utcNow(), DateTimeUtil::getUserPreferredTimeZone()),''));
        }
        
        return markers;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows the information dialog for the selected activity.
    /// </summary>
    public void showInfo()
    {
        if (lastSelectedActivityId && this.parmGanttDialog())
        {
            RecId recId = str2int64(lastSelectedActivityId);
            this.parmGanttDialog().info(recId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCalendars</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of calendar information to use in the ganttControl.
    /// </summary>
    /// <returns>A list of calendars.</returns>
    public List getCalendars()
    {
        List ganttControlCalendars = new List(Types::Class);
        Timezone userTimeZone = DateTimeUtil::getUserPreferredTimeZone();
        boolean isGanttControlSchedulerTimeZoneFlightEnabled = GanttControlSchedulerTimeZoneFlight::instance().isEnabled();
       
        GanttCalendarCollection calendarCollection = ganttClient.parmGanttData().parmGanttCalendarCollection();
        GanttCalendar ganttCalendar = calendarCollection.findFirst();
        while (ganttCalendar != null)
        {
            GanttControlCalendar ganttControlCalendar = GanttControlCalendar::newParameters(ganttCalendar.parmCalendarName());

            WorkCalendarDateLine workCalendarDateLine = ganttCalendar.parmWorkCalendarDateLine();
            while select workCalendarDateLine
                order by workCalendarDateLine.TransDate, workCalendarDateLine.FromTime
            {
                if (isGanttControlSchedulerTimeZoneFlightEnabled)
                {
                   ganttControlCalendar.addInterval(
                        GanttControlWorkingTimeEffectivityInterval::newParameters(
                            DateTimeUtil::newDateTime(workCalendarDateLine.TransDate, workCalendarDateLine.FromTime),
                            DateTimeUtil::newDateTime(workCalendarDateLine.TransDate, workCalendarDateLine.ToTime),
                            workCalendarDateLine.Effectivity));
                }
                else
                {
                    ganttControlCalendar.addInterval(
                        GanttControlWorkingTimeEffectivityInterval::newParameters(
                            DateTimeUtil::newDateTime(workCalendarDateLine.TransDate, workCalendarDateLine.FromTime, userTimeZone),
                            DateTimeUtil::newDateTime(workCalendarDateLine.TransDate, workCalendarDateLine.ToTime, userTimeZone),
                            workCalendarDateLine.Effectivity
                        )
                    );
                }
            }

            ganttControlCalendars.addEnd(ganttControlCalendar);

            ganttCalendar = calendarCollection.findNext();
        }

        return ganttControlCalendars;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getConfiguration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the gantt control view settings.
    /// </summary>
    /// <returns>A <c>configuration</c> object with values set based on the client and setup information.</returns>
    protected GanttControlConfiguration getConfiguration()
    {
        GanttControlConfiguration configuration = GanttControlConfiguration::construct();

        var ganttSetup = ganttClient.parmGanttSetup();

        configuration.parmTimeScales(GanttControlTimeScale::getTimeScalesFromMinorTimeScale(ganttSetup.parmTimescaleUnit(), ganttSetup.parmTimescaleStep()));

        GanttTimescale timeScale =  ganttSetup.parmTimescaleUnit();

        configuration.parmFromDateTime(GanttControlTimeScaleDateConverter::getStartOfPeriod(DateTimeUtil::newDateTime(ganttClient.parmFromDate(), 0, DateTimeUtil::getUserPreferredTimeZone()), timeScale));
        configuration.parmToDateTime(GanttControlTimeScaleDateConverter::getEndOfPeriod(DateTimeUtil::newDateTime(ganttClient.parmToDate(), 0, DateTimeUtil::getUserPreferredTimeZone()), timeScale));

        boolean useCalendars = ganttSetup.parmLoadCalendar();
        if (useCalendars)
        {
            if (timeScale == GanttTimescale::Months || timeScale == GanttTimescale::Weeks)
            {
                // If the time scale is set to Weeks or Months the availability of the calendars is not relevant
                // so the parameter to use calendars is set to false
                useCalendars = false;
            }
            else
            {
                if (ganttSetup.parmThrottleCalendarPerf())
                {
                    int rows = ganttClient.parmGanttData().parmGanttTableCollection().findFirst().count();
                    int daysInterval = (ganttClient.parmToDate() - ganttClient.parmFromDate()) + 1;

                    real cellsPerDay;
                    switch (timeScale)
                    {
                        case GanttTimescale::Minutes:
                            cellsPerDay = 24 * (60 / ganttSetup.parmTimescaleStep());
                            break;
                        case GanttTimescale::Hours:
                            cellsPerDay = 24 / ganttSetup.parmTimescaleStep();
                            break;
                        case GanttTimescale::Days:
                            cellsPerDay = 1.0 / ganttSetup.parmTimescaleStep();
                            break;
                    }

                    if (rows * daysInterval * cellsPerDay > maxNumberOfCalendarCells)
                    {
                        Message::Add(MessageSeverity::Informational, "@SCM:GanttCalendarNotShown");
                        useCalendars = false;
                    }
                }
            }
        }

        configuration.parmUseCalendars(useCalendars);
        configuration.parmAllowMultiChange(true);

        return configuration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDataModificationFromGanttControlModification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new data modification from a gantt control modification object.
    /// </summary>
    /// <param name = "_modification">The gantt control modification to convert.</param>
    /// <param name = "_newWrkCtrId">A new resource Id to apply; optional.</param>
    /// <returns>A new gantt data modification.</returns>
    protected GanttDataModification createDataModificationFromGanttControlModification(GanttControlActivityModification _modification, WrkCtrId _newWrkCtrId = '')
    {
        // If the gantt control instance supports edit then this method must be overloaded.
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSchedulingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the scheduling date is within the selected time interval.
    /// </summary>
    /// <param name = "_date">The date to validate.</param>
    public void validateSchedulingDate(date _date)
    {
        if (_date < ganttClient.parmFromDate() || _date > ganttClient.parmToDate())
        {
            throw error("@SCM:GanttSchedulingDateOutsideInterval");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleSelectedJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Schedules the currently selected jobs.
    /// </summary>
    /// <param name = "_direction">The direction to schedule.</param>
    /// <param name = "_date">The target start or end date.</param>
    /// <param name = "_time">The target start or end time.</param>
    /// <param name = "_changeResource">Determines if the resource should be changed; optional.</param>
    /// <param name = "_wrkCtrId">The resource to change to if the <c>_changeResource</c> is true; optional.</param>
    public void scheduleSelectedJobs(GanttSchedDirection _direction, date _date, TimeOfDay _time, boolean _changeResource = false, WrkCtrId _wrkCtrId = '')
    {
        this.switchOffModificationResponseList();
        
        ListEnumerator enumerator = allSelectedActivityIds.parmActivityIds().getEnumerator();
        while (enumerator.moveNext())
        {
            GanttControlActivityId selectedActivityId = enumerator.current();
            GanttControlTaskActivity activity = this.getActivity(selectedActivityId.parmId()) as GanttControlTaskActivity;
            if (activity)
            {
                SchedDirection direction;
                utcdatetime scheduleDateTime;
                
                [direction, scheduleDateTime] = this.resolveActivitySchedDateDirection(activity, _direction, _date, _time);
                                
                WrkCtrId newWrkCtrId;
                if (_changeResource)
                {
                    newWrkCtrId = _wrkCtrId;
                    this.updateActivityFromNewWrkCtrId(activity, _wrkCtrId);
                }
                                
                GanttControlActivityModification activityModification = this.scheduleActivity(activity, direction, scheduleDateTime);
                if (activityModification)
                {
                    GanttDataModification ganttDataModification = this.createDataModificationFromGanttControlModification(activityModification, newWrkCtrId);
                    this.validateAndInsertModification(ganttDataModification, false, false);
                }
                else
                {
                    error("@SCM:GanttScheduleError");
                    this.ganttDataModificationCollection().parmAllModificationsPassedValidation(false);
                    break;
                }                
            }
        }

        this.processModificationCollection(_changeResource);
        this.ensureSelectedActivitiesFocus();
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveActivitySchedDateDirection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resolves a requested scheduling date and time based on the <c>GanttSchedDirection</c>.
    /// </summary>
    /// <param name = "_activity">The activity to resolve for.</param>
    /// <param name = "_direction">The given scheduling direction.</param>
    /// <param name = "_date">The given scheduling date.</param>
    /// <param name = "_time">The given scheduling time.</param>
    /// <returns>A container with the format [SchedDirection, schedulingDateTime].</returns>
    protected container resolveActivitySchedDateDirection(GanttControlTaskActivity _activity, GanttSchedDirection _direction, date _date, TimeOfDay _time)
    {
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>switchOffModificationResponseList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Turns off the use of the modification response list.
    /// </summary>
    protected void switchOffModificationResponseList()
    {
        ganttControlModificationResponseList = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onSummaryActivityExpand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handler for expansion of summary activities.
    /// </summary>
    /// <param name = "_activityId">The id of the summary activity that was expanded.</param>
    public void onSummaryActivityExpand(str _activityId)
    {
        GanttControlSummaryActivity summary = this.getActivity(_activityId) as GanttControlSummaryActivity;
        if (summary)
        {
            // Store the state on server side as well
            summary.parmCollapsed(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onSummaryActivityCollapse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handler for collapse of summary activities.
    /// </summary>
    /// <param name = "_activityId">The id of the summary activity that was collapsed.</param>
    public void onSummaryActivityCollapse(str _activityId)
    {
        GanttControlSummaryActivity summary = this.getActivity(_activityId) as GanttControlSummaryActivity;
        if (summary)
        {
            // Store the state on server side as well
            summary.parmCollapsed(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Schedules a single activity.
    /// </summary>
    /// <param name = "_activity">The activity to schedule.</param>
    /// <param name = "_direction">The scheduling direction.</param>
    /// <param name = "_dateTime">The target start/end datetime (depends on the scheduling direction).</param>
    /// <returns>The result of the scheduling given as a modification that should be applied to the activity.</returns>
    public GanttControlActivityModification scheduleActivity(GanttControlTaskActivity _activity, SchedDirection _direction, utcdatetime _dateTime)
    {
        List activities = new List(Types::Class);
        activities.addEnd(_activity);

        List modifications = this.scheduleActivities(activities, _direction, _dateTime);

        ListEnumerator modificationEnumerator = modifications.getEnumerator();
        if (modificationEnumerator.moveNext())
        {
            return modificationEnumerator.current();
        }
        else
        {
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleActivities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Schedules multiple activities.
    /// </summary>
    /// <param name = "_activities">A list containing the <c>GanttControlTaskActivity</c> objects to schedule.</param>
    /// <param name = "_direction">The scheduling direction.</param>
    /// <param name = "_dateTime">The target start/end datetime (depends on the scheduling direction).</param>
    /// <param name = "_links">A list containing the <c>GanttControlLink</c> objects connecting some of the activities.</param>
    /// <param name = "_oppositeDirection">A set of activity IDs that should be scheduled in the opposite direction</param>
    /// <returns>The result of the scheduling given as a list of modifications that should be applied to the activities.</returns>
    /// <remarks>If scheduling fails then the list will be empty.</remarks>
    public List scheduleActivities(List           _activities,
                                   SchedDirection _direction = SchedDirection::Forward,
                                   utcdatetime    _dateTime = DateTimeUtil::minValue(),
                                   List           _links = new List(Types::Class),
                                   Set            _oppositeDirection = new Set(Types::String))
    {

        List calendars = ganttControl.parmCalendars();
        
        if (!calendars || calendars.empty())
        {
            error("@SYS109250");
            return new List(Types::Class);
        }
        
        GanttControlScheduler scheduler = GanttControlScheduler::newGanttScheduler(_activities,
                                                                                 calendars,
                                                                                 _direction,
                                                                                 _dateTime,
                                                                                 _links,
                                                                                 _oppositeDirection);
        scheduler.run();

        if (GanttControlSchedulerTimeZoneFlight::instance().isEnabled())
        {
            Map capacityReservations = this.parmGanttClient().parmGanttData().parmCapacityReservationsByActivityId();
            Map capacityReservationFromScheduler = scheduler.getCapacityReservationsByActivityId();
            MapEnumerator mapEnumerator = capacityReservationFromScheduler.getEnumerator();

            while (mapEnumerator.moveNext())
            {
                capacityReservations.insert(mapEnumerator.currentKey(), mapEnumerator.currentValue());
            }
        }
        
        return scheduler.getModifications();
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleParrallelSSActivitiesWithNoModification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Schedules all parallel activities that has a start/start link and that do not already have a modification.
    /// </summary>
    /// <param name = "_activityId">The id of the activity to schedule.</param>
    /// <param name = "_scheduleFromDateTime">The scheduling from date time.</param>
    /// <returns>true if the scheduling was successful; otherwise, false.</returns>
    protected boolean scheduleParrallelSSActivitiesWithNoModification(str _activityId, utcdatetime _scheduleFromDateTime)
    {
        boolean ok = true;

        List activitiesToSchedule = new List(Types::Class);
                
        // Add all SS linked jobs
        List allLinks = ganttControl.parmLinks();
        ListEnumerator allLinksEnumerator = allLinks.getEnumerator();
        while (allLinksEnumerator && allLinksEnumerator.moveNext())
        {
            GanttControlLink link = allLinksEnumerator.current();
            if (link.parmLinkType() == GanttLinkType::SS)
            {
                str linkedActivityId = '';

                if (link.parmFromActivityId() == _activityId)
                {
                    linkedActivityId = link.parmToActivityId();
                }
                else if (link.parmToActivityId() == _activityId)
                {
                    linkedActivityId = link.parmFromActivityId();
                }

                if (linkedActivityId &&
                    !ganttDataModificationCollection.findModifiedRecId(this.activityIdToRecId(linkedActivityId)))
                {
                    activitiesToSchedule.addEnd(this.getActivity(linkedActivityId));
                }
            }
        }
        
        if (!activitiesToSchedule.empty())
        {
            List ganttControlModifications = this.scheduleActivities(activitiesToSchedule, SchedDirection::Forward, _scheduleFromDateTime);
            ok = this.applyGanttControlModifications(ganttControlModifications);
        }
        
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyGanttControlModifications</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies gantt control modifications.
    /// </summary>
    /// <param name = "_modifications">The list of modifications to apply.</param>
    /// <param name = "_excludeIds">A set of activity IDs for which modifications should not be applied; optional.</param>
    /// <returns>true if modifications is applied; otherwise, false.</returns>
    protected boolean applyGanttControlModifications(List _modifications, Set _excludeIds = null)
    {
        if (_modifications && !_modifications.empty())
        {
            ListEnumerator modificationEnumerator = _modifications.getEnumerator();
            while (modificationEnumerator && modificationEnumerator.moveNext())
            {
                if (!_excludeIds || !_excludeIds.in(modificationEnumerator.current().parmActivityId()))
                {
                    GanttDataModification newGanttDataModification = this.createDataModificationFromGanttControlModification(modificationEnumerator.current() as GanttControlActivityModification);
                    this.validateAndInsertModification(newGanttDataModification, false, false);
                }
            }
        }
        else
        {
            error("@SCM:GanttScheduleError");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLinksMap</Name>
				<Source><![CDATA[
    private Map createLinksMap(boolean _forward)
    {
        Map newLinksMap = new Map(Types::String, Types::Class);
        ListEnumerator linkEnumerator = this.getLinks().getEnumerator();

        while (linkEnumerator.moveNext())
        {
            GanttControlLink link = linkEnumerator.current();
            if (link.parmLinkType() == GanttLinkType::SF)
            {
                link = GanttControlLink::newParameters('', //Id is not used for scheduling.
                                                       link.parmToActivityId(),
                                                       link.parmFromActivityId(),
                                                       GanttLinkType::FS);
            }

            str idx = _forward ? link.parmFromActivityId() : link.parmToActivityId();

            if (newLinksMap.exists(idx))
            {
                newLinksMap.lookup(idx).addEnd(link);
            }
            else
            {
                List mapNode = new List(Types::Class);
                mapNode.addEnd(link);
                newLinksMap.insert(idx, mapNode);
            }
        }

        return newLinksMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLinksMapNext</Name>
				<Source><![CDATA[
    private Map getLinksMapNext()
    {
        if (!linksMapNextCache)
        {
            linksMapNextCache = this.createLinksMap(true);
        }

        return linksMapNextCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLinksMapPrevious</Name>
				<Source><![CDATA[
    private Map getLinksMapPrevious()
    {
        if (!linksMapPreviousCache)
        {
            linksMapPreviousCache = this.createLinksMap(false);
        }

        return linksMapPreviousCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearLinksMap</Name>
				<Source><![CDATA[
    private void clearLinksMap()
    {
        linksMapNextCache = null;
        linksMapPreviousCache = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSelectedOnDifferentOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether all the selected jobs belong to different orders.
    /// </summary>
    /// <returns>true if all the selected jobs belong to different orders; otherwise, false.</returns>
    protected boolean checkSelectedOnDifferentOrders()
    {
        //Not implemented here
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleAroundSelected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Schedules all the jobs in the orders before, after or around the selected jobs.
    /// </summary>
    /// <param name = "_dir">Whether to schedule the jobs before, after or around the selected ones.</param>
    /// <remarks>
    /// GanttScheduleAroundDirection::Next only schedules descendants: if job1 and job2 are both followed by
    /// job3 but are not linked to each other, scheduling next around one of them will not affect the other.
    /// GanttScheduleAroundDirection::All, however, schedules the entire order.
    /// </remarks>
    public void scheduleAroundSelected(GanttScheduleAroundDirection _dir)
    {
        if (!this.checkSelectedOnDifferentOrders())
        {
            error("@SCM:GanttSelectedOnSameOrder");
            return;
        }

        ListEnumerator enumerator = allSelectedActivityIds.parmActivityIds().getEnumerator();
        boolean success = true;
        while (enumerator.moveNext() && success)
        {
            GanttControlTaskActivity activity = this.getActivity(enumerator.current().parmId()) as GanttControlTaskActivity;
            if (activity)
            {
                success = this.scheduleJobsAround(activity.parmId(), _dir);
            }
        }

        if (success && this.processModificationCollection())
        {
            this.renderAllActivities();
            this.refreshControlsOnForm();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleJobsAround</Name>
				<Source><![CDATA[
    private boolean scheduleJobsAround(str _activityId, GanttScheduleAroundDirection _dir)
    {
        boolean success;
        switch (_dir)
        {
            case GanttScheduleAroundDirection::Previous:
                success = this.schedulePreviousJobs(_activityId);
                break;
            case GanttScheduleAroundDirection::Next:
                success = this.scheduleNextJobs(_activityId, false);
                break;
            case GanttScheduleAroundDirection::All:
                success = (this.schedulePreviousJobs(_activityId) && this.scheduleNextJobs(_activityId, true));
                break;
            default:
                success = false;
        }

        if (!success)
        {
            this.rollBackModificationCollection();
            this.resetModificationCollection();
        }

        return success;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRelatedLinksAndActivities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recursively finds all the next or previous activities in an order, including the connecting links, starting from a specific activity.
    /// </summary>
    /// <param name = "_activityId">The ID of the activity to search from.</param>
    /// <param name = "_next">Whether to find the next or the previous activities.</param>
    /// <param name = "_activities">The activities that are found will be appended to this list.</param>
    /// <param name = "_links">The links that are found will be appended to this list.</param>
    /// <param name = "_activityIdsVisited">A set of activities that have already been visited by the recursion or otherwise processed.</param>
    /// <param name = "_potentialIndirectRoots">
    /// If this list is not null (and assuming _next is true), it will be populated by all activities that have more than one incoming link,
    /// indicating that there could be other activities linking to them that were not found in this search.
    /// </param>
    /// <param name = "_addRootActivity">Whether the starting activity should be added to _activities.</param>
    private void findRelatedLinksAndActivities(str     _activityId,
                                               boolean _next,
                                               List    _activities,
                                               List    _links,
                                               Set     _activityIdsVisited,
                                               List    _potentialIndirectRoots = null,
                                               boolean _addRootActivity = true)
    {
        if (!_activityIdsVisited.in(_activityId) || !_addRootActivity)
        {
            GanttControlTaskActivity activity = this.getActivity(_activityId) as GanttControlTaskActivity;
            if (activity)
            {
                if (_addRootActivity)
                {
                    if (_potentialIndirectRoots
                        && this.getLinksMapPrevious().exists(_activityId)
                        && this.getLinksMapPrevious().lookup(_activityId).elements() > 1)
                    {
                        _potentialIndirectRoots.addEnd(_activityId);
                    }

                    _activities.addEnd(activity);
                    _activityIdsVisited.add(_activityId);
                }

                Map linksMap = _next ? this.getLinksMapNext() : this.getLinksMapPrevious();

                if (linksMap.exists(_activityId))
                {
                    ListEnumerator outgoingLinksEnumerator = linksMap.lookup(_activityId).getEnumerator();
                    while (outgoingLinksEnumerator.moveNext())
                    {
                        GanttControlLink link = outgoingLinksEnumerator.current();
                        str nextId = _next ? link.parmToActivityId() : link.parmFromActivityId();
                        if (_addRootActivity || !_activityIdsVisited.in(nextId))
                        {
                            _links.addEnd(link);
                        }
                        this.findRelatedLinksAndActivities(nextId,
                                                           _next,
                                                           _activities,
                                                           _links,
                                                           _activityIdsVisited,
                                                           _potentialIndirectRoots);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSiblingActivities</Name>
				<Source><![CDATA[
    protected Set getSiblingActivities(str _activityId)
    {
        Set siblingActivities = new Set(Types::String);
        siblingActivities.add(_activityId);

        ListEnumerator linkEnumerator = this.getLinks().getEnumerator();
        while (linkEnumerator.moveNext())
        {
            GanttControlLink link = linkEnumerator.current();
            if (link.parmLinkType() == GanttLinkType::SS || link.parmLinkType() == GanttLinkType::FF)
            {
                if (link.parmFromActivityId() == _activityId)
                {
                    siblingActivities.add(link.parmToActivityId());
                }
                else if (link.parmToActivityId() == _activityId)
                {
                    siblingActivities.add(link.parmFromActivityId());
                }
            }
        }

        return siblingActivities;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedulePreviousJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Schedules all the previous jobs in the order before the specified one.
    /// </summary>
    /// <param name = "_activityId">The job to schedule around.</param>
    /// <returns>Whether scheduling was successful</returns>
    private boolean schedulePreviousJobs(str _activityId)
    {
        Set siblingActivities = this.getSiblingActivities(_activityId);
        SetEnumerator siblingEnumerator = siblingActivities.getEnumerator();
        utcdatetime scheduleTo = DateTimeUtil::minValue();
        while (siblingEnumerator.moveNext())
        {
            GanttControlTaskActivity activity = this.getActivity(siblingEnumerator.current()) as GanttControlTaskActivity;
            if (!activity)
            {
                return false;
            }

            if (activity.parmToDateTime() > scheduleTo)
            {
                scheduleTo = activity.parmToDateTime();
            }
        }


        List activitiesToSchedule = new List(Types::Class);
        Set activityIdsVisited = new Set(Types::String);
        List linksToSchedule = new List(Types::Class);

        this.findRelatedLinksAndActivities(_activityId,
                                           false,
                                           activitiesToSchedule,
                                           linksToSchedule,
                                           activityIdsVisited
                                           );

        if (!activitiesToSchedule.empty())
        {
            List result = this.scheduleActivities(activitiesToSchedule,
                                                  SchedDirection::Backward,
                                                  scheduleTo,
                                                  linksToSchedule);

            return this.applyGanttControlModifications(result, siblingActivities);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleNextJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Schedules all the next jobs in the order after the specified one.
    /// </summary>
    /// <param name = "_activityId">The job to schedule around.</param>
    /// <param name = "_scheduleIndirect">Whether to also schedule the previous jobs from each of the next jobs.</param>
    /// <returns>Whether scheduling was successful</returns>
    private boolean scheduleNextJobs(str _activityId, boolean _scheduleIndirect)
    {
        GanttControlTaskActivity activity = this.getActivity(_activityId) as GanttControlTaskActivity;
        if (!activity)
        {
            return false;
        }

        List activitiesToSchedule = new List(Types::Class);
        Set activityIdsVisited = new Set(Types::String);
        List linksToSchedule = new List(Types::Class);
        List potentialIndirectRoots;
        if (_scheduleIndirect)
        {
            potentialIndirectRoots = new List(Types::String);
        }

        Set siblingActivities = this.getSiblingActivities(_activityId);
        SetEnumerator siblingEnumerator = siblingActivities.getEnumerator();
        while (siblingEnumerator.moveNext())
        {
            this.findRelatedLinksAndActivities(siblingEnumerator.current(),
                                               true,
                                               activitiesToSchedule,
                                               linksToSchedule,
                                               activityIdsVisited,
                                               potentialIndirectRoots);
        }


        if (activitiesToSchedule.elements() > siblingActivities.elements())
        {
            Set oppositeDirection = new Set(Types::String);
            if (potentialIndirectRoots && !potentialIndirectRoots.empty())
            {
                // Iterate over all the next jobs that have more than one incoming link,
                // indicating that there could be other jobs linking to them.
                List indirectActivitiesToSchedule = new List(Types::Class);
                ListEnumerator indirectRootsEnumerator = potentialIndirectRoots.getEnumerator();
                while (indirectRootsEnumerator.moveNext())
                {
                    if (!siblingActivities.in(indirectRootsEnumerator.current()))
                    {
                        this.findRelatedLinksAndActivities(indirectRootsEnumerator.current(),
                                                           false,
                                                           indirectActivitiesToSchedule,
                                                           linksToSchedule,
                                                           activityIdsVisited,
                                                           null,
                                                           false);
                    }
                }

                activitiesToSchedule.appendList(indirectActivitiesToSchedule);

                ListEnumerator indirectActivitiesEnumerator = indirectActivitiesToSchedule.getEnumerator();
                while (indirectActivitiesEnumerator.moveNext())
                {
                    oppositeDirection.add(indirectActivitiesEnumerator.current().parmId());
                }
            }

            List result = this.scheduleActivities(activitiesToSchedule,
                                                  SchedDirection::Forward,
                                                  activity.parmFromDateTime(),
                                                  linksToSchedule,
                                                  oppositeDirection);

            return this.applyGanttControlModifications(result, siblingActivities);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandAll</Name>
				<Source><![CDATA[
    /// <summary>
    /// Expands all the summary activities in the Gantt control.
    /// </summary>
    public void expandAll()
    {
        ListEnumerator activityEnumerator = ganttControl.parmActivities().getEnumerator();
        while (activityEnumerator.moveNext())
        {
            GanttControlSummaryActivity summaryActivity = activityEnumerator.current() as GanttControlSummaryActivity;
            if (summaryActivity)
            {
                this.onSummaryActivityExpand(summaryActivity.parmId());
            }
        }

        this.renderAllActivities();
    }

]]></Source>
			</Method>
			<Method>
				<Name>collapseAll</Name>
				<Source><![CDATA[
    /// <summary>
    /// Collapses all the summary activities in the Gantt control.
    /// </summary>
    public void collapseAll()
    {
        ListEnumerator activityEnumerator = ganttControl.parmActivities().getEnumerator();
        while (activityEnumerator.moveNext())
        {
            GanttControlSummaryActivity summaryActivity = activityEnumerator.current() as GanttControlSummaryActivity;
            if (summaryActivity)
            {
                this.onSummaryActivityCollapse(summaryActivity.parmId());
            }
        }

        this.renderAllActivities();
    }

]]></Source>
			</Method>
			<Method>
				<Name>recIdToActivityId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a recId into an activity id.
    /// </summary>
    /// <param name = "_recId">The recId to convert.</param>
    /// <returns>An activity id.</returns>
    protected str recIdToActivityId(RecId _recId)
    {
        return int642Str(_recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>activityIdToRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts an activity id into a RecId.
    /// </summary>
    /// <param name = "_activityId">The activity id to convert.</param>
    /// <returns>A RecId.</returns>
    protected RecId activityIdToRecId(str _activityId)
    {
        if (isInteger(_activityId))
        {
            return str2Int64(_activityId);
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processModificationCollection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes all modifications in the modification collection.
    /// </summary>
    /// <param name = "_hasResourceChange">Determines if the collection contains resource changes; optional.</param>
    /// <returns>true if all modifications can be applied; otherwise, false.</returns>
    protected boolean processModificationCollection(boolean _hasResourceChange = false)
    {
        if (!this.preUpdateModificationCollection())
        {
            this.ganttDataModificationCollection().parmAllModificationsPassedValidation(false);
        }
            
        // validate at data modification collection level that we can process all changes
        if (!this.validateModificationCollection(true))
        {
            this.ganttDataModificationCollection().parmAllModificationsPassedValidation(false);
        }
        
        boolean ret = false;
                                
        // if one of multi-selected nodes failed validation, then all nodes from the current selection must be rolled back
        if (!this.ganttDataModificationCollection().parmAllModificationsPassedValidation())
        {
            if (_hasResourceChange)
            {
                this.reloadActivities();
            }
            else
            {
                this.rollBackModificationCollection();
            }
            this.resetModificationCollection();            
        }
        else
        {
            this.updateModificationCollection();

            if (!ganttControlModificationResponseList)
            {
                if (_hasResourceChange)
                {
                    this.reloadActivities();
                }
                else
                {
                    // Update control
                    this.renderAllActivities();
                }
            
                // Refresh dependent form controls
                this.refreshControlsOnForm();
            }

            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ensureSelectedActivitiesFocus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ensures that the selected activities are still in focus.
    /// </summary>
    public void ensureSelectedActivitiesFocus()
    {
        ganttControl.showActivity(lastSelectedActivityId);        
    }

]]></Source>
			</Method>
			<Method>
				<Name>onActivitiesChangedHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles change of activities done in the GanttControl.
    /// </summary>
    /// <param name = "_modifications">The modification information.</param>
    /// <param name = "_response">A response class for getting any server side changes back into the control.</param>
    public void onActivitiesChangedHandler(List _modifications, GanttControlActivityModificationResponse _response)
    {
        // Make response list available to child classes
        ganttControlModificationResponseList = _response.parmActivitiesToUpdate();

        boolean ok = true;
        WrkCtrId newWrkCtrId;
        const str EmptyParentId = '0';
        
        ListEnumerator modificationEnumerator = _modifications.getEnumerator();
        while (modificationEnumerator.moveNext())
        {
            GanttControlActivityModification modification = modificationEnumerator.current();
            GanttControlTaskActivity activity = this.getActivity(modification.parmActivityId()) as GanttControlTaskActivity;
            
            if (activity)
            {
                if (ok)
                {
                    if (modification.parmNewParentId() && activity.parmParentId() != modification.parmNewParentId())
                    {
                        if (!newWrkCtrId)
                        {
                            if (modification.parmNewParentId() != EmptyParentId || !GanttControlVisualizationUpdateActivityFromNewParentFlight::instance().isEnabled())
                            {
                                newWrkCtrId = this.updateActivityFromNewParent(activity, modification.parmNewParentId());
                            }

                            ok = (newWrkCtrId != '');
                        }
                        else
                        {
                            activity.parmParentId(modification.parmNewParentId());
                            this.updateActivityFromNewWrkCtrId(activity, newWrkCtrId);
                        }
                    }
            
                    if (ok)
                    {
                        GanttControlActivityModification activityModification = this.scheduleActivity(activity, SchedDirection::Forward, modification.parmNewFromDateTime());
                        if (activityModification)
                        {
                            // Convert the GanttControl modification to a GanttDataModification object
                            GanttDataModification ganttDataModification = this.createDataModificationFromGanttControlModification(activityModification, newWrkCtrId);
                            if (ganttDataModification)
                            {
                                // Insert modification and process it with any dependent activities
                                ok = this.validateAndInsertModification(ganttDataModification, true, false);
                            }
                        }
                        else
                        {
                            ok = false;
                            error("@SCM:GanttScheduleError");
                        }
                    }
                }

                if (!ok && !newWrkCtrId)
                {
                    ganttControlModificationResponseList.addEnd(activity);
                }
            }

        }

        if (!ok)
        {
            this.ganttDataModificationCollection().parmAllModificationsPassedValidation(false);
        }
        
        this.processModificationCollection(newWrkCtrId != '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateActivityFromNewParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the activity parent relation.
    /// </summary>
    /// <param name = "_activity">The activity to update.</param>
    /// <param name = "_newParentActivityId">The ID of the new activity parent.</param>
    /// <returns>The ID of the new resource of the activity.</returns>
    protected WrkCtrId updateActivityFromNewParent(GanttControlTaskActivity _activity, str _newParentActivityId)
    {
        // If the gantt control instance supports edit then this method must be overloaded.
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateActivityFromNewWrkCtrId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the resource related field of an activity.
    /// </summary>
    /// <param name = "_activity">The activity to update.</param>
    /// <param name = "_newWrkCtrId">The ID of the new resource.</param>
    protected void updateActivityFromNewWrkCtrId(GanttControlTaskActivity _activity, str _newWrkCtrId)
    {
        // If the gantt control instance supports edit then this method must be overloaded.
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFieldsNotEmpty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks that the field values in the modification are set.
    /// </summary>
    /// <param name = "_ganttDataModification">The modification to check.</param>
    /// <returns>true if all fields are set; otherwise, false.</returns>
    protected boolean checkFieldsNotEmpty(GanttDataModification _ganttDataModification)
    {
        Set setFieldsToBeCheckedIfEmpty = this.getSetFieldsToBeCheckedIfEmpty();
        if (_ganttDataModification == null || setFieldsToBeCheckedIfEmpty == null)
        {
            throw error(strfmt("@SYS27147", classId2Name(classidget(this))));
        }

        Map mapModifiedFields = _ganttDataModification.parmMapModifiedFields();
        if (mapModifiedFields == null || mapModifiedFields.empty())
        {
            return true;
        }

        SetEnumerator setEnumerator = setFieldsToBeCheckedIfEmpty.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            FieldName  fieldName = setEnumerator.current();
            if (mapModifiedFields.exists(fieldName))
            {
                str strFieldValue = mapModifiedFields.lookup(fieldName);
                if (!strFieldValue)
                {
                    return false;
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSetFieldsToBeCheckedIfEmpty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a set of the field names that should be checked on empty value.
    /// </summary>
    /// <returns>A set of the field names that should be checked.</returns>
    protected Set getSetFieldsToBeCheckedIfEmpty()
    {
        // If the gantt control instance supports edit then this method must be overloaded.
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldNameSchedFromDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the name of the field which contains the scheduled from date of the job.
    /// </summary>
    /// <returns>The field name.</returns>    
    protected FieldName fieldNameSchedFromDate()
    {
        // If the gantt control instance supports edit then this method must be overloaded.
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldNameSchedToDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the name of the field which contains the scheduled end date of the job.
    /// </summary>
    /// <returns>The field name.</returns>
    protected FieldName fieldNameSchedToDate()
    {
        // If the gantt control instance supports edit then this method must be overloaded.
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkModificationPartlyLoadedNodes</Name>
				<Source><![CDATA[
    protected boolean checkModificationPartlyLoadedNodes(GanttDataModification _ganttDataModification)
    {
        GanttTableBase          ganttTable;
        GanttDataModification   ganttDataModificationCurrent;
        
        ganttTable = this.parmGanttClient().parmGanttData().getGanttTableByRecId(_ganttDataModification.parmModifiedTableName(),
                                                                                _ganttDataModification.parmModifiedRecId());
        if (ganttTable == null)
        {
            return checkFailed(strfmt("@SYS115240", _ganttDataModification.parmModifiedRecId()));
        }

        ganttDataModificationCurrent = ganttTable.createModificationByFieldNames(_ganttDataModification.getSetModifiedFieldNames());

        if (ganttDataModificationCurrent == null)
        {
            throw error(strfmt("@SYS27147", classId2Name(classidget(this))));
        }

        if (!ganttDataModificationCurrent.isInsideDatesInterval(this.fieldNameSchedFromDate(),
                                                                this.fieldNameSchedToDate(),
                                                                this.parmGanttClient().parmFromDate(),
                                                                this.parmGanttClient().parmToDate()))
        {
            return checkFailed("@SYS113350");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkModificationInsideTimeScaleInterval</Name>
				<Source><![CDATA[
    protected boolean checkModificationInsideTimeScaleInterval(GanttDataModification _ganttDataModification)
    {
        if (!_ganttDataModification.isInsideDatesInterval(this.fieldNameSchedFromDate(),
                                                          this.fieldNameSchedToDate(),
                                                          this.parmGanttClient().parmFromDate(),
                                                          this.parmGanttClient().parmToDate()))
        {
            return checkFailed("@SYS113073");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAndInsertModification</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates and inserts a <c>GanttDataModification</c> object into the modification collection.
    /// </summary>
    /// <param name="_ganttDataModification">
    ///    An object to validate and insert into the collection.
    /// </param>
    /// <param name="_alwaysInsertModification">
    ///    A Boolean value that directs that the <paramref name="_ganttDataModification" /> be inserted even
    ///    if it fails validation; optional.
    /// </param>
    /// <param name="_validateModification">
    ///    A Boolean value that directs that the <paramref name="_ganttDataModification" /> be validated prior
    ///    to insert; optional.
    /// </param>
    /// <returns>
    ///    true if the modification was successfully validated and inserted in the modification collection;
    ///    otherwise false.
    /// </returns>
    /// <remarks>
    ///    If the <paramref name="_validateModification" /> parameter is set to false, the method returns true
    ///    even if the modification is invalid.
    /// </remarks>    
    protected boolean validateAndInsertModification(GanttDataModification    _ganttDataModification,
                                                    boolean                  _alwaysInsertModification   = false,
                                                    boolean                  _validateModification       = true)
    {
        if (_ganttDataModification &&
            (!_validateModification || this.validateModification(_ganttDataModification)))
        {
            this.insertModification(_ganttDataModification);
        }
        else
        {
            this.ganttDataModificationCollection().parmAllModificationsPassedValidation(false);

            if (_alwaysInsertModification)
            {
                this.insertModification(_ganttDataModification);
            }

            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rollBackModification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rolls back a modification.
    /// </summary>
    /// <param name = "_ganttDataModification">The modification to roll back.</param>
    protected void rollBackModification(GanttDataModification _ganttDataModification)
    {
        GanttTableBase ganttTable = this.parmGanttClient().parmGanttData().getGanttTableByRecId(_ganttDataModification.parmModifiedTableName(),
                                                                             _ganttDataModification.parmModifiedRecId());
        GanttDataModification ganttDataModificationCurrent = ganttTable.createModificationByFieldNames(_ganttDataModification.getSetModifiedFieldNames());

        this.updateActivtyFromModification(ganttDataModificationCurrent);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateActivtyFromModification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates an activity object based on a gantt data modification.
    /// </summary>
    /// <param name = "_ganttDataModification">The modification to apply.</param>
    /// <returns>The updated activity.</returns>
    protected GanttControlActivity updateActivtyFromModification(GanttDataModification _ganttDataModification)
    {
        // If the gantt control instance supports edit then this method must be overloaded.
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getColumns</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the columns to display in the gantt control.
    /// </summary>
    /// <returns>A List of gantt column settings.</returns>
    public List getColumns()
    {
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the activities to display in the gantt control.
    /// </summary>
    /// <returns>A List of gantt activities.</returns>
    public List getActivities()
    {
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLinks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the links to display in the gantt control.
    /// </summary>
    /// <returns>A List of gantt links.</returns>
    public List getLinks()
    {      
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>refresh</Name>
				<Source><![CDATA[
    public void refresh()
    {
        ganttControl.parmConfiguration(this.getConfiguration());
        ganttControl.parmColumns(this.getColumns());
        ganttControl.parmActivities(this.getActivities());
        ganttControl.parmLinks(this.getLinks());
        ganttControl.parmCalendars(this.getCalendars());
        ganttControl.parmVerticalMarkers(this.getCurrentTimeVerticalMarker());

        this.clearLinksMap();

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reloadActivities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reloads/regroups all activities. 
    /// </summary>
    public void reloadActivities()
    {
        ganttControl.parmActivities(this.getActivities());
    }

]]></Source>
			</Method>
			<Method>
				<Name>renderAllActivities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ensure that the control will re-render the activities.
    /// </summary>
    public void renderAllActivities()
    {
        // Re-assign activity list to have updates to the content propagated to the control
        ganttControl.parmActivities(ganttControl.parmActivities());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an activity based on the id.
    /// </summary>
    /// <param name = "_activityId">The id of an activity.</param>
    /// <returns>The found activity.</returns>
    public GanttControlActivity getActivity(str _activityId)
    {
        // If the gantt control instance supports edit then this method must be overloaded.
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSingleTaskActivitySelected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if exactly 1 task activity is selected.
    /// </summary>
    /// <returns>True if exactly 1 task activity is selected; otherwise, false.</returns>
    public boolean isSingleTaskActivitySelected()
    {
        if (lastSelectedActivityId && allSelectedActivityIds && allSelectedActivityIds.parmActivityIds().elements() == 1)
        {
            return this.getActivity(lastSelectedActivityId) is GanttControlTaskActivity;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowInUserTZ</Name>
				<Source><![CDATA[
    internal boolean parmShowInUserTZ(boolean _showInUserTZ = showInUserTZ)
    {
        showInUserTZ = _showInUserTZ;

        return showInUserTZ;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>