<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxSourceDocSublineItem</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>CustInvoiceTaxSourceDocumentLine</c> class provides the information that is required to
/// handle the distributions and subledger journal lines of free text invoice tax.
/// </summary>
[
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_ProductOrder), SourceDocumentLine_ProductOrder::PurchaseOrderTaxLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_ProductReceipt), SourceDocumentLine_ProductReceipt::ProductReceiptTaxLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_ProductRequisition), SourceDocumentLine_ProductRequisition::PurchaseRequisitionTaxLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_ExpenseReport), SourceDocumentLine_ExpenseReport::ExpenseReportTaxLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_CustomerInvoice), SourceDocumentLine_CustomerInvoice::CustomerInvoiceTaxLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_VendorInvoice), SourceDocumentLine_VendorInvoice::VendorInvoiceTaxLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_ProjAdvancedJournal), SourceDocumentLine_ProjAdvancedJournal::ProjAdvancedJournalTaxLine)
]
public class TaxSourceDocSublineItem extends SourceDocumentSublineItem implements
    SourceDocumentLineItemITax,
    SourceDocumentLineItemIFinalize
    , SourceDocLineItemICustInvJournalizing
    , SourceDocumentLineItemIInventory
    , SourceDocumentLineItemITaxExchangeRate
    , SourceDocumentLineItemIAccDateUpdateable
{
    TaxMap                          taxMap;
    // <GIN>
    Amount      interimTax;
    Amount      interimExpense;
    boolean     multipleInterimMatchingLevels;
    Percent     interimInvoiceRatio;
    // </GIN>
    // <GEEHU>
    boolean     checkDeferredHungary;
    boolean     isDeferredTaxDocument;
    TaxParameters taxParameters;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calculateLegalEntityRecId</Name>
				<Source><![CDATA[
    protected LegalEntityRecId calculateLegalEntityRecId()
    {
        return CompanyInfo::findDataArea(this.parmTaxDataAreaId()).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSourceDocumentAmountMap</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    protected SourceDocumentAmountMap calculateSourceDocumentAmountMap()
    {
        SourceDocumentAmountMap                     sourceDocumentAmountMap = SourceDocumentAmountMap::construct();
        SourceDocumentAmount                        sourceDocumentAmount;
        SourceDocumentLineMatchingList              localSourceDocumentLineMatchingList;
        SourceDocumentLineMatchingListEnumerator    localSourceDocumentLineMatchingListEnumerator;
        SourceDocumentLineMatching                  localSourceDocumentLineMatching;
        SourceDocumentLineItem                      localParentSourceDocumentLineItem;
        SourceDocumentLineItem                      localGrandParentSourceDocumentLineItem;
        SourceDocumentLineItem                      localMatchedSourceDocumentLineItem;
        Common                                      common;
        VendInvoiceLineMap                          vendInvoiceLineMap;
        PurchLine                                   purchLine;
        Percent                                     invoiceRatio = 1.0;
        SourceDocumentAmountMapEnumerator           matchingAmountMapEnum;
        SourceDocumentAmount                        matchingSourceDocumentAmount;
        Amount                                      expectedServiceTaxNonRecoverableIN;
        Amount                                      expectedTaxNonRecoverable;
        Amount                                      expectedTax;
        Amount                                      actualServiceTaxNonRecoverableIN;
        Amount                                      actualTaxNonRecoverable;
        Amount                                      actualTax;
        Amount                                      varianceServiceTaxNonRecoverableIN;
        Amount                                      varianceTaxNonRecoverable;
        Amount                                      varianceTax;
        boolean                                     matching;
        boolean                                     multipleMatchingLevels;
        MarkupTrans                                 markupTrans;
        Qty                                         invoiceQtyLessVariance;
        RefTableId                                  sourceRelationType;
        boolean                                     skipMatching;
        // <GIN>
        Amount                                      actualEximTax;
        TaxUncommitted_IN                           taxUncommittedIN;
        TaxTrans_IN                                 taxTransIN;
        Percent                                     claimPercentage;
        percent                                     reverseChargePercentIN;
        Amount                                      taxDeferred;
        Amount                                      taxDeferredVariance;
        Amount                                      expectedtaxDeferred;
        boolean                                     excise;
        RefTableId                                  sourceRelationTypeLoc;
        TaxType_IN                                  taxType;
        TaxAmountCur                                taxAmountCurLOIRev;
        Amount                                      expectedServiceTaxExpense;
        Amount                                      actualServiceTaxExpense;
        Amount                                      varianceServiceTaxExpense;
        TransTaxInformation                         transTaxInformation;
        // </GIN>

        // <GEERU>
        #isoCountryRegionCodes
        // </GEERU>

        this.initializeTaxMap();

        // Get the expected amount of tax.
        localSourceDocumentLineMatchingList = this.parmSourceDocumentLineMatchingList();

         // <GIN>
        if (TaxParameters::isExciseEnable_IN()
            && TaxTable::find(taxMap.TaxCode).TaxType_IN == TaxType_IN::Excise)
        {
            excise = true;
            if (taxMap.TableId == tableNum(TaxUncommitted))
            {
                taxUncommittedIN = TaxUncommitted_IN::findByTaxUncommitted(taxMap.RecId);
                claimPercentage = taxUncommittedIN.ClaimPercentage;
            }
            else if (taxMap.TableId == tableNum(TaxTrans))
            {
                taxTransIN = TaxTrans_IN::findRefRecId(taxMap.RecId);
                claimPercentage = taxTransIN.ClaimPercentage;
            }
        }
        // </GIN>

        if (localSourceDocumentLineMatchingList && localSourceDocumentLineMatchingList.elements() > 0)
        {
            localSourceDocumentLineMatchingListEnumerator = localSourceDocumentLineMatchingList.getEnumerator();
            localSourceDocumentLineMatchingListEnumerator.moveNext();
            localSourceDocumentLineMatching = localSourceDocumentLineMatchingListEnumerator.current();
            localMatchedSourceDocumentLineItem = localSourceDocumentLineMatching.parmIndependentSourceDocumentLineItem();

            localParentSourceDocumentLineItem = this.parmParentSourceDocumentLineItem();
            common = localParentSourceDocumentLineItem.parmSourceDocumentLineImplementation();

            switch (common.TableId)
            {
                case tableNum(VendInvoiceInfoLine):
                case tableNum(VendInvoiceTrans):

                    vendInvoiceLineMap = common;

                    // prorate based on qty
                    purchLine = vendInvoiceLineMap.purchLine();

                    if (vendInvoiceLineMap.Qty != 0.0)
                    {
                        invoiceQtyLessVariance = min(abs(vendInvoiceLineMap.Qty), abs((purchLine.PurchQty ? purchLine.PurchQty : vendInvoiceLineMap.Qty)));
                        invoiceRatio = invoiceQtyLessVariance / (purchLine.PurchQty ? abs(purchLine.PurchQty) : invoiceQtyLessVariance);
                    }
                    break;
                case tableNum(CustInvoiceLine):
                case tableNum(CustInvoiceTrans):
                    multipleMatchingLevels = true;
                    // <GIN>
                    multipleInterimMatchingLevels = true;
                    // </GIN>
                    break;
                case tableNum(MarkupTrans):

                    markupTrans = common as MarkupTrans;

                    if (markupTrans.TransTableId == tableNum(VendInvoiceInfoLine) || markupTrans.TransTableId == tableNum(VendInvoiceTrans))
                    {
                        localGrandParentSourceDocumentLineItem = localParentSourceDocumentLineItem.parmParentSourceDocumentLineItem();
                        common = localGrandParentSourceDocumentLineItem.parmSourceDocumentLineImplementation();
                        vendInvoiceLineMap = common;
                        purchLine = vendInvoiceLineMap.purchLine();
                        switch (markupTrans.MarkupCategory)
                        {
                            case MarkupCategory::Fixed:

                                invoiceRatio = 1.0;
                                break;

                            case MarkupCategory::InterCompanyPercent,
                                MarkupCategory::Pcs,
                                MarkupCategory::Percent:

                                if (vendInvoiceLineMap.Qty != 0.0)
                                {
                                    invoiceQtyLessVariance = min(abs(vendInvoiceLineMap.Qty), abs((purchLine.PurchQty ? purchLine.PurchQty : vendInvoiceLineMap.Qty)));
                                    invoiceRatio = invoiceQtyLessVariance / (purchLine.PurchQty ? abs(purchLine.PurchQty) : invoiceQtyLessVariance);
                                }
                                break;

                            case MarkupCategory::Proportional:
                                if (vendInvoiceLineMap.Qty != 0.0)
                                {
                                    invoiceQtyLessVariance = min(abs(vendInvoiceLineMap.Qty), abs((purchLine.PurchQty ? purchLine.PurchQty : vendInvoiceLineMap.Qty)));
                                    invoiceRatio = invoiceQtyLessVariance / (purchLine.PurchQty ? abs(purchLine.PurchQty) : invoiceQtyLessVariance);
                                }
                                break;
                        }
                    }

                    if ((markupTrans.TransTableId == tableNum(CustInvoiceTable)
                        || markupTrans.TransTableId == tableNum(CustInvoiceLine)))
                    {
                        skipMatching = true;
                    }
            }

             // customer invoices may be corrected multiple times and have multiple matching levels but we only match to the first level
            if (!multipleMatchingLevels && !skipMatching)
            {
                matchingAmountMapEnum = localMatchedSourceDocumentLineItem.parmSourceDocumentAmountMap().getEnumerator();

                while (matchingAmountMapEnum.moveNext())
                {
                    matchingSourceDocumentAmount = matchingAmountMapEnum.currentValue();

                    CurrencyCode matchingCurrencyCode = taxMap.SourceCurrencyCode;

                    switch (matchingSourceDocumentAmount.parmMonetaryAmount())
                    {
                        case MonetaryAmount::Tax
                            // <GIN>
                            ,
                            // Incentiveschemetax
                            MonetaryAmount::Incentiveschemetax_IN
                            // </GIN>
                            :
                            expectedTax = CurrencyExchangeHelper::amount(matchingSourceDocumentAmount.parmAmount() * invoiceRatio, matchingCurrencyCode);
                            break;

                        // <GIN>
                        case MonetaryAmount::TaxDeferred_IN:
                            expectedtaxDeferred = CurrencyExchangeHelper::amount(matchingSourceDocumentAmount.parmAmount() * invoiceRatio, matchingCurrencyCode);
                            break;

                        case MonetaryAmount::ServiceTaxNonRecoverable_IN:
                            expectedServiceTaxNonRecoverableIN = CurrencyExchangeHelper::amount(matchingSourceDocumentAmount.parmAmount() * invoiceRatio, matchingCurrencyCode);
                            break;

                        case MonetaryAmount::ServiceTaxExpense_IN:
                            expectedServiceTaxExpense = CurrencyExchangeHelper::amount(matchingSourceDocumentAmount.parmAmount() * invoiceRatio, matchingCurrencyCode);
                            break;
                        // </GIN>

                        case MonetaryAmount::TaxNonRecoverable:
                            expectedTaxNonRecoverable = CurrencyExchangeHelper::amount(matchingSourceDocumentAmount.parmAmount() * invoiceRatio, matchingCurrencyCode);
                            break;
                    }
                }
                matching = true;
            }
        }

        if (this.taxOnFullAmount())
        {
            actualTaxNonRecoverable = taxMap.getTaxAmountBeforeCost();
        }
        else
        {
            // For scenarios where tax is exempt, do not create distributions
            // <GEERU>
            if (taxMap.TaxDirection != TaxDirection::TaxExemptSales    &&
                taxMap.TaxDirection != TaxDirection::TaxExemptPurchase &&
                !(SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) && this.withoutTaxTrans_RU()))
            // </GEERU>
            {
                actualTax = taxMap.getTaxAmountBeforeCost() - taxMap.getTaxInCostPrice();

                // <GIN>
                if (excise && claimPercentage)
                {
                    taxDeferred = Tax::roundDeferredAmount(actualTax - (actualTax * claimPercentage / 100));
                    actualTax = actualTax - taxDeferred;
                }
                // </GIN>
            }

            if (taxMap.getTaxInCostPrice()
            // <GBR>
                && (!BrazilParameters::isEnabled() || !this.isIncludedInPrice_BR())
            // </GBR>
            )
            {
                 actualTaxNonRecoverable = taxMap.getTaxInCostPrice();
                // <GIN>
                if (TaxParameters::isServiceTaxEnable_IN()
                    && TaxTable::find(this.parmTaxCode()).TaxType_IN == TaxType_IN::ServiceTax)
                {
                    if (taxMap.TableId == tableNum(TaxUncommitted))
                    {
                        reverseChargePercentIN = TaxUncommitted_IN::findByTaxUncommitted(taxMap.RecId).ServiceTaxReverseChargePercentage;
                    }
                    else if (taxMap.TableId == tableNum(TaxTrans))
                    {
                        reverseChargePercentIN = TaxTrans_W::findByTaxTrans(taxMap.RecId).ServiceTaxReverseChargePercentage_IN;
                    }

                    if (reverseChargePercentIN > 0 && reverseChargePercentIN <= 100)
                    {
                        if (taxMap.TableId == tableNum(TaxUncommitted) && taxMap.SourceTableId != tableNum(PurchLine))
                        {
                            taxAmountCurLOIRev = TaxUncommitted_IN::findByTaxUncommitted(taxMap.RecId).LoadOnInventoryTax;
                            if (taxAmountCurLOIRev)
                            {
                                actualTaxNonRecoverable = taxAmountCurLOIRev;
                            }
                        }
                        actualServiceTaxNonRecoverableIN = CurrencyExchangeHelper::amount(actualTaxNonRecoverable * reverseChargePercentIN / 100);
                        actualTaxNonRecoverable          = actualTaxNonRecoverable - actualServiceTaxNonRecoverableIN;
                    }
                }
                // </GIN>
            }
        }
        //<GIN>
        if (TaxParameters::isServiceTaxEnable_IN()
            && TaxTable::find(taxMap.TaxCode).TaxType_IN == TaxType_IN::ServiceTax)
        {
            if (this.isExpenseAccount_IN())
            {
                [actualServiceTaxExpense, interimExpense] = taxMap.TaxMap::getServiceTaxAmount2Distribute_IN();
                interimInvoiceRatio = invoiceRatio;
                if (!expectedServiceTaxExpense)
                {
                    expectedServiceTaxExpense = expectedTax;
                    expectedTax = 0;
                }
                actualTax = 0;
            }
            else
            {
                [actualTax, interimTax]  = taxMap.TaxMap::getServiceTaxAmount2Distribute_IN();
                interimInvoiceRatio = invoiceRatio;
            }
        }
        // </GIN>

        if (matching )
        {
            sourceRelationType = this.parmParentSourceDocumentLineItem().parmSourceDocumentLine().SourceRelationType;
            if (sourceRelationType != tableNum(PurchLine) && sourceRelationType != tableNum(PurchTable))
            {
                varianceTaxNonRecoverable = actualTaxNonRecoverable - expectedTaxNonRecoverable;
                varianceTax = actualTax -  expectedTax;

                // <GIN>
                if (TaxParameters::isServiceTaxEnable_IN()
                    && TaxTable::find(taxMap.TaxCode).TaxType_IN == TaxType_IN::ServiceTax)
                {
                    varianceServiceTaxNonRecoverableIN = actualServiceTaxNonRecoverableIN - expectedServiceTaxNonRecoverableIN;
                }

                if (excise
                    && claimPercentage
                    && varianceTax)
                {
                    taxDeferredVariance = taxDeferred - expectedtaxDeferred;
                }
                if (this.isExpenseAccount_IN())
                {
                    varianceServiceTaxExpense = actualServiceTaxExpense - expectedServiceTaxExpense;
                }
                // </GIN>
            }
        }

        // <GIN>
        taxType = TaxTable::find(taxMap.TaxCode).TaxType_IN;

        if (TaxIntegrationUtils::isTaxInformationEnabled())
        {
            transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(purchLine);
        }

        if (TaxParameters::isVATEnable_IN()
            && taxType == TaxType_IN::VAT
            && this.checkVATGoodsType_IN(transTaxInformation.VATGoodsType))
        {
            [actualTax] = this.createSourceDocAmountMapForVAT_IN(sourceDocumentAmountMap, purchLine, matching, sourceRelationType, actualTax, expectedtaxDeferred);
            varianceTax = 0;
        }
        // </GIN>

        if (actualTaxNonRecoverable || varianceTaxNonRecoverable)
        {
            sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), actualTaxNonRecoverable - varianceTaxNonRecoverable, MonetaryAmount::TaxNonRecoverable);
            sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }

        // <GIN>
        if (actualServiceTaxNonRecoverableIN || varianceServiceTaxNonRecoverableIN)
        {
            sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), actualServiceTaxNonRecoverableIN - varianceServiceTaxNonRecoverableIN, MonetaryAmount::ServiceTaxNonRecoverable_IN);
            sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }

        if (TaxParameters::isCustomsEnable_IN()
            && taxType == TaxType_IN::Customs)
        {
            sourceRelationTypeLoc = this.parmParentSourceDocumentLineItem().parmSourceDocumentLine().SourceRelationType;
            if (sourceRelationTypeLoc == tableNum(PurchLine)
                || sourceRelationTypeLoc == tableNum(PurchTable)
                || sourceRelationTypeLoc == tableNum(VendInvoiceInfoLine)
                || sourceRelationTypeLoc == tableNum(VendInvoiceTrans)
                || sourceRelationTypeLoc == tableNum(PurchReqLine)
                || sourceRelationTypeLoc == tableNum(PurchReqTable))
            {
                // if Exim is applicable only then provide the distribtion with Actual and Exim Amount split.
                if (taxMap.TaxMap::isTransactionEximRelated_IN())
                {
                    actualTax = taxMap.TaxMap::getActualTaxExcludingEximTax_IN();
                    actualEximTax = taxMap.TaxMap::getEximTaxFromActualTax_IN();
                }
                else // if exim is not applicable provide only the customs amount with sign change
                {
                    actualTax = actualTax * -1;
                }
                varianceTax = 0;
            }
        }
        // </GIN>

        if (actualTax || varianceTax || this.shouldPostTaxBankExchangeRateDifference(taxMap.TaxDirection))
        {
            sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), actualTax - varianceTax, MonetaryAmount::Tax);
            sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }

        // <GIN>
        if (actualServiceTaxExpense || varianceServiceTaxExpense)
        {
            sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), actualServiceTaxExpense - varianceServiceTaxExpense, MonetaryAmount::ServiceTaxExpense_IN);
            sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }

        if (actualEximTax)
        {
            sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), actualEximTax, MonetaryAmount::Incentiveschemetax_IN);
            sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }
        // </GIN>
        if (varianceTaxNonRecoverable)
        {
            sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), varianceTaxNonRecoverable, MonetaryAmount::TaxNonRecoverableVariance);
            sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }

        if (varianceTax)
        {
            sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), varianceTax, MonetaryAmount::TaxVariance);
            sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }

        // <GIN>
        if (varianceServiceTaxExpense)
        {
            sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), varianceServiceTaxExpense, MonetaryAmount::ServiceTaxExpenseVariance_IN);
            sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }

        if (varianceServiceTaxNonRecoverableIN)
        {
            sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), varianceServiceTaxNonRecoverableIN, MonetaryAmount::ServiceTaxNonRecoverableVariance_IN);
            sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }

        if (excise)
        {
            if (taxDeferred || taxDeferredVariance)
            {
                sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), taxDeferred - taxDeferredVariance, MonetaryAmount::TaxDeferred_IN);
                sourceDocumentAmountMap.insert(sourceDocumentAmount);
            }

            if (taxDeferredVariance)
            {
                sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), taxDeferredVariance, MonetaryAmount::TaxDeferredVariance_IN);
                sourceDocumentAmountMap.insert(sourceDocumentAmount);
            }
        }
        // </GIN>

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            sourceDocumentAmountMap = this.postCalculateSourceDocumentAmountMap_BR(sourceDocumentAmountMap);
        }
        // </GBR>

        return sourceDocumentAmountMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPostTaxBankExchangeRateDifference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if amount should be posted for bank exchange rate. 
    /// </summary>
    /// <returns>
    /// true if amount should be posted; otherwise, false.
    /// </returns>
    private boolean shouldPostTaxBankExchangeRateDifference(TaxDirection _taxDirection)
    {
        return (FeatureStateProvider::isFeatureEnabled(TaxBankExchangeRateDifferenceFlighting::instance())
            || TaxBankExchangeRateDifferenceV2Flight::instance().isEnabled())
            && (_taxDirection == TaxDirection::IncomingTax_W
                || _taxDirection == TaxDirection::OutgoingTax_W
                || this.shouldPostTaxBankExchangeRateDiffererceForUseTax(_taxDirection));
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPostTaxBankExchangeRateDiffererceForUseTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if amount should be posted for bank exchange rate for Use tax direction.
    /// </summary>
    /// <returns>
    /// true if amount should be posted; otherwise, false.
    /// </returns>
    private boolean shouldPostTaxBankExchangeRateDiffererceForUseTax(TaxDirection _taxDirection)
    {
        if (_taxDirection == TaxDirection::UseTax
                //Support use tax difference posting when the bank exchange rate is on.
                && (TaxParameters::isBankExchRateEnabled_W()
                    || this.isTaxSpecificExchRateEnabledByTable())
                && SysDictField::isFieldMapped(tableStr(TaxMap), tableId2Name(tableNum(TaxTrans)), fieldStr(TaxMap, SourceDocumentLine))
                && taxMap.SourceDocumentLine)
        {
            TaxTrans taxTrans = TaxTrans::findBySourceDocumentLine(taxMap.SourceDocumentLine);
            if (taxTrans.TaxAmount
                || (this.isTaxSpecificExchRateEnabledByTable()
                    && taxTrans.TaxAmountRep))
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateAccountingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the accounting date can be updated when it lies in a closed period.
    /// </summary>
    /// <returns>
    /// true if the accounting date can be updated; otherwise, false.
    /// </returns>
    public boolean canUpdateAccountingDate()
    {
        SourceDocumentLineItemIAccDateUpdateable    iAccDateUpdateable;
        boolean                                     finalizeAccountingDate = false;

        if (this.parmParentSourceDocumentLineItem() &&
            this.parmParentSourceDocumentLineItem() is SourceDocumentLineItemIAccDateUpdateable)
        {
            iAccDateUpdateable = this.parmParentSourceDocumentLineItem() as SourceDocumentLineItemIAccDateUpdateable;
            finalizeAccountingDate = iAccDateUpdateable.canUpdateAccountingDate();
        }

        return finalizeAccountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVATGoodsType_IN</Name>
				<Source><![CDATA[
    private boolean checkVATGoodsType_IN(VATGoodsType_IN    _vatGoodsType)
    {
        TransTaxInformation transTaxInformation;

		transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformation(taxMap.SourceTableId, taxMap.SourceRecId);
		_vatGoodsType = transTaxInformation.VATGoodsType;

        return (_vatGoodsType == VATGoodsType_IN::CapitalGoods);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSourceDocAmountMapForVAT_IN</Name>
				<Source><![CDATA[
    private container createSourceDocAmountMapForVAT_IN(
        SourceDocumentAmountMap     _sourceDocumentAmountMap,
        PurchLine                   _purchLine,
        boolean                     _matching,
        RefTableId                  _sourceRelationType,
        Amount                      _actualDeferredTax,
        Amount                      _expectedDeferredTax)
    {
        PurchLine                   purchLineLoc;
        Amount                      taxDeferred;
        Amount                      taxDeferredVariance;
        SourceDocumentAmount        sourceDocumentAmount;

        purchLineLoc = _purchLine;

        if (taxMap.SourceTableId == tableNum(PurchLine))
        {
            purchLineLoc = PurchLine::findRecId(taxMap.SourceRecId);
        }

        taxDeferred = _actualDeferredTax;
        _actualDeferredTax = 0;

        if (purchLineLoc.LineAmount < 0)
        {
            _actualDeferredTax = Tax::getPostedVATDeferredAmount_IN(purchLineLoc.InventRefTransId, taxMap.TaxCode);
        }

        _actualDeferredTax = taxDeferred < 0 ? _actualDeferredTax * -1 : _actualDeferredTax;
        taxDeferred -=  _actualDeferredTax;

        if (_matching && _sourceRelationType != tableNum(PurchLine) && _sourceRelationType != tableNum(PurchTable))
        {
            taxDeferredVariance = taxDeferred - _expectedDeferredTax;
        }

        if (taxDeferred || taxDeferredVariance)
        {
            sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), taxDeferred - taxDeferredVariance, MonetaryAmount::TaxDeferred_IN);
            _sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }

        if (taxDeferredVariance)
        {
            sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), taxDeferredVariance, MonetaryAmount::TaxDeferredVariance_IN);
            _sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }

        return [_actualDeferredTax];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxDifferenceAmountFromTaxMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax difference amount from tax map
    /// </summary>
    /// <returns>
    /// The tax difference amount.
    /// </returns>
    private TaxAmount getTaxDifferenceAmountFromTaxMap()
    {
        #ISOCountryRegionCodes

        TaxAmount originalAccountingCurrencyTaxAmount;

        if (taxMap.TaxAutoGenerated)
        {
            originalAccountingCurrencyTaxAmount = taxMap.TaxAmount;
        }
        else
        {
            // <GEEPL>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]) && this.parmExchangeRate1())
            {
                originalAccountingCurrencyTaxAmount = CurrencyExchangeHelper::amountCur2MST(taxMap.SourceRegulateAmountCur, taxMap.SourceCurrencyCode, this.parmExchangeRate1());
            }
            else
            {
            // <GEEPL>
                originalAccountingCurrencyTaxAmount = CurrencyExchangeHelper::mstAmount(taxMap.SourceRegulateAmountCur, taxMap.SourceCurrencyCode, taxMap.TransDate);
            // <GEEPL>
            }
            // </GEEPL>
        }

        TaxAmount exchangeRateTaxAmount = taxMap.ExchangeRateSourceRegulateAmount ? taxMap.ExchangeRateSourceRegulateAmount : taxMap.ExchangeRateTaxAmount;
        TaxAmount taxDifferenceAmount = exchangeRateTaxAmount - originalAccountingCurrencyTaxAmount;

        return taxDifferenceAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxDifferenceAmountFromTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax difference amount from tax trans.
    /// </summary>
    /// <returns>
    /// The tax difference amount.
    /// </returns>
    private TaxAmount getTaxDifferenceAmountFromTaxTrans()
    {
        TaxAmount taxDifferenceAmount;
        TaxDirection taxDirection = this.parmTaxDifferenceTaxDirection();
        boolean isTaxBankExchangeRateDifferenceEnabled = FeatureStateProvider::isFeatureEnabled(TaxBankExchangeRateDifferenceFlighting::instance()) || TaxBankExchangeRateDifferenceV2Flight::instance().isEnabled();

        if (isTaxBankExchangeRateDifferenceEnabled)
        {
            TaxTrans taxTrans = taxMap as TaxTrans;

            if (taxTrans.ExchRateDiffOrigRecId)
            {
                taxDifferenceAmount = taxTrans.TaxAmount;;
            }
        }
        else
        {
            if (taxDirection == TaxDirection::IncomingTax_W || taxDirection == TaxDirection::OutgoingTax_W)
            {
                TaxTrans taxTrans = TaxTrans::findTaxExchangeRateDifferenceLine(taxMap.SourceTableId,
                        taxMap.SourceRecId,
                        taxMap.TaxCode,
                        taxDirection);

                taxDifferenceAmount = taxTrans.TaxAmount;
            }
        }

        return taxDifferenceAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxDifferenceReportingCurrencyAmountFromTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax difference reporting currency amount from tax uncommitted.
    /// </summary>
    /// <returns>
    /// The tax difference reporting currency amount.
    /// </returns>
    private TaxAmount getTaxDifferenceReportingCurrencyAmountFromTaxUncommitted()
    {
        if (!Ledger::reportingCurrency())
        {
            return 0;
        }

        TaxUncommitted taxUncommitted = taxMap as TaxUncommitted;
        TaxAmount taxDifferenceAmountRep;
        if (taxUncommitted.SourceCurrencyCode != Ledger::reportingCurrency()
            && TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByTable(taxUncommitted.HeadingTableId, taxUncommitted.HeadingRecId))
        {
            taxDifferenceAmountRep = taxUncommitted.ExchangeRateTaxAmountRep - taxUncommitted.TaxAmountRep;
        }
        else
        {
            TaxAmount exchangeRateSourceTaxAmount = taxUncommitted.ExchangeRateSourceRegulateAmount ? taxUncommitted.ExchangeRateSourceRegulateAmount : taxUncommitted.ExchangeRateTaxAmount;

            // Avoid the tax amount difference is too small to round, exchange the currency amount before the difference, instead of exchanging TaxAmount directly, make sure the sum of them is correct.
            TaxAmount exchangeRateSourceTaxAmountRep = CurrencyExchangeHelper::curAmount(exchangeRateSourceTaxAmount, Ledger::reportingCurrency(), taxUncommitted.TransDate);
            taxDifferenceAmountRep = exchangeRateSourceTaxAmountRep - taxUncommitted.TaxAmountRep;
        }

        return taxDifferenceAmountRep;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxDifferenceReportingCurrencyAmountFromTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax difference reporting currency amount from tax trans.
    /// </summary>
    /// <returns>
    /// The tax difference reporting currency amount.
    /// </returns>
    private TaxAmount getTaxDifferenceReportingCurrencyAmountFromTaxTrans()
    {
        TaxAmount taxDifferenceAmountRep;
        TaxDirection taxDirection = this.parmTaxDifferenceTaxDirection();
        boolean isTaxBankExchangeRateDifferenceEnabled = FeatureStateProvider::isFeatureEnabled(TaxBankExchangeRateDifferenceFlighting::instance()) || TaxBankExchangeRateDifferenceV2Flight::instance().isEnabled();

        if (isTaxBankExchangeRateDifferenceEnabled)
        {
            TaxTrans taxTrans = taxMap as TaxTrans;

            if (taxTrans.ExchRateDiffOrigRecId)
            {
                taxDifferenceAmountRep = taxTrans.TaxAmountRep;
            }
        }
        else
        {
            if (taxDirection == TaxDirection::IncomingTax_W || taxDirection == TaxDirection::OutgoingTax_W)
            {
                TaxTrans taxTrans = TaxTrans::findTaxExchangeRateDifferenceLine(taxMap.SourceTableId,
                        taxMap.SourceRecId,
                        taxMap.TaxCode,
                        taxDirection);

                taxDifferenceAmountRep = taxTrans.TaxAmountRep;
            }
        }

        return taxDifferenceAmountRep;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasDimensionDerivationInputChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if dimensions have to be rebuilt.
    /// </summary>
    /// <returns>
    /// True if hungarian deferred tax or if parent logic returns true.
    /// False otherwise.
    /// </returns>
    /// <remarks>
    /// Modified for HungarianDeferredTaxes. This value is modified in the
    /// TaxSourceDocSublineItem class since Deferred Taxes have a different
    /// LedgerDimension Main Account value for the initial transaction
    /// </remarks>
    public boolean hasDimensionDerivationInputChanged()
    {
        boolean                 hasDimensionDerivationInputChanged;

        if (TaxContinuousHUHelper::isTransactionContinuousHU(taxMap.TaxItemGroup) && this.isDeferredTaxDocument() && this.parmParentAccountingDistributionList() == null)
        {
            hasDimensionDerivationInputChanged = true;
        }
        else
        {
            hasDimensionDerivationInputChanged = super();
        }
        return hasDimensionDerivationInputChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>honorMainAccDerivInputChangedInReversal</Name>
				<Source><![CDATA[
    public boolean honorMainAccDerivInputChangedInReversal()
    {
        boolean honorMainAccDerivInputChangedInReversal;

        if (TaxContinuousHUHelper::isTransactionContinuousHU(taxMap.TaxItemGroup) && this.isDeferredTaxDocument())
        {
            honorMainAccDerivInputChangedInReversal = false;
        }
        else
        {
            honorMainAccDerivInputChangedInReversal = super();
        }

        return honorMainAccDerivInputChangedInReversal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeImplementation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the instance variables.
    /// </summary>
    /// <param name="_sourceDocumentLineImplementation">
    ///    A source document line implementation table.
    /// </param>
    /// <param name="_additionalInformation">
    /// A map to hold buffers of pre initiliazed objects need by the framework to the source document.
    /// </param>
    protected void initializeImplementation(SourceDocumentLineImplementation _sourceDocumentLineImplementation, Map _additionalInformation = null)
    {
        taxMap = this.sourceDocumentLineMapToTaxMap(_sourceDocumentLineImplementation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTaxMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>TaxMap</c> map.
    /// </summary>
    /// <remarks>
    /// The initialization only occurs if the <c>TaxMap</c> has not already been initialized.
    /// </remarks>
    private void initializeTaxMap()
    {
        if (!taxMap && sourceDocumentLine)
        {
            sourceDocumentLineImplementation = sourceDocumentLine.getSourceDocumentLineImplementation();
            this.initializeImplementation(sourceDocumentLineImplementation);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSourceDocumentLineMatchingList</Name>
				<Source><![CDATA[
    protected void initSourceDocumentLineMatchingList()
    {
        Common                                      common;
        TaxUncommitted                              matchCandidateTaxUncommitted;
        SourceDocumentLineMatching                  parentSourceDocumentLineMatched;
        SourceDocumentLineMatchingList              linesMatchedToTaxParent;
        SourceDocumentLineMatchingListEnumerator    linesMatchedToTaxParentEnumerator;
        SourceDocumentLine                          taxSourceDocumentLine;
        SourceDocumentLine                          taxParentSourceDocumentLine;
        SourceDocumentLineRecId                     matchedParentSourceDocumentLineItemRecId;
        SourceDocumentLineItem                      matchedSourceDocumentLineItem;

        sourceDocumentLineMatchingList = SourceDocumentLineMatchingList::construct();

        // get parent line
        parentSourceDocumentLineItem = this.parmParentSourceDocumentLineItem();
        // get lines parent is matched to
        linesMatchedToTaxParent = parentSourceDocumentLineItem.parmSourceDocumentLineMatchingList();

        if (linesMatchedToTaxParent)
        {
            common = taxMap;
            linesMatchedToTaxParentEnumerator = linesMatchedToTaxParent.getEnumerator();

            while (linesMatchedToTaxParentEnumerator.moveNext())
            {
                parentSourceDocumentLineMatched = linesMatchedToTaxParentEnumerator.current();
                matchedSourceDocumentLineItem =  parentSourceDocumentLineMatched.parmIndependentSourceDocumentLineItem();
                matchedParentSourceDocumentLineItemRecId = matchedSourceDocumentLineItem.parmSourceDocumentLine().RecId;

                // <GBR>
                if (BrazilParameters::isEnabled())
                {
                    TaxFiscalValue_BR taxMapFiscalValue_BR;
                    TaxTrans taxTransFromTaxMap;

                    switch (taxMap.TableId)
                    {
                        // Table TaxTrans does not have a proper mapping for FiscalValue_BR within TaxMap
                        // Instead, FiscalValue_BR can be fetched via the join table TaxTrans_BR
                        case tableNum(TaxTrans):
                            taxTransFromTaxMap = taxMap.data();
                            taxMapFiscalValue_BR = taxTransFromTaxMap.TaxTrans_BR().FiscalValue_BR;
                            break;
                        default:
                            taxMapFiscalValue_BR = taxMap.FiscalValue_BR;
                            break;
                    }

                    select firstonly matchCandidateTaxUncommitted
                    where  matchCandidateTaxUncommitted.TaxDirection == taxMap.TaxDirection &&
                        matchCandidateTaxUncommitted.TaxCode == taxMap.TaxCode &&
                        !((matchCandidateTaxUncommitted.FiscalValue_BR == TaxFiscalValue_BR::WithCreditDebit && taxMapFiscalValue_BR == TaxFiscalValue_BR::WithoutCreditDebitOther)
                            || (matchCandidateTaxUncommitted.FiscalValue_BR == TaxFiscalValue_BR::WithoutCreditDebitOther && taxMapFiscalValue_BR == TaxFiscalValue_BR::WithCreditDebit))
                    join RecId from taxSourceDocumentLine
                        where taxSourceDocumentLine.RecId == matchCandidateTaxUncommitted.SourceDocumentLine
                    exists join taxParentSourceDocumentLine
                        where taxParentSourceDocumentLine.RecId == taxSourceDocumentLine.ParentSourceDocumentLine &&
                            taxParentSourceDocumentLine.RecId == matchedParentSourceDocumentLineItemRecId;
                }
                else
                {
                    // </GBR>
                    select firstonly matchCandidateTaxUncommitted
                    where  matchCandidateTaxUncommitted.TaxDirection == taxMap.TaxDirection &&
                        matchCandidateTaxUncommitted.TaxCode == taxMap.TaxCode
                    join RecId from taxSourceDocumentLine
                        where taxSourceDocumentLine.RecId == matchCandidateTaxUncommitted.SourceDocumentLine
                    exists join taxParentSourceDocumentLine
                        where taxParentSourceDocumentLine.RecId == taxSourceDocumentLine.ParentSourceDocumentLine &&
                            taxParentSourceDocumentLine.RecId == matchedParentSourceDocumentLineItemRecId;
                    // <GBR>
                }
                // </GBR>

                if (matchCandidateTaxUncommitted != null)
                {
                    sourceDocumentLineMatchingList = SourceDocumentLineMatchingFacade::addSourceDocLineImplementationToList(common, matchCandidateTaxUncommitted, 1, sourceDocumentLineMatchingList);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSourceDocumentLineRelievingList</Name>
				<Source><![CDATA[
    protected void initSourceDocumentLineRelievingList()
    {
        Common                                      common;
        Factor                                      factor;
        TaxUncommitted                              relievingCandidateTaxUncommitted;
        SourceDocumentLineMatching                  parentSourceDocumentLineRelieving;
        SourceDocumentLineMatchingList              relievingLinesForTaxParent;
        SourceDocumentLineMatchingListEnumerator    relievingLinesForTaxParentEnumerator;
        SourceDocumentLine                          taxSourceDocumentLine;
        SourceDocumentLine                          taxParentSourceDocumentLine;
        SourceDocumentLineRecId                     relievingParentSourceDocumentLineItemRecId;
        SourceDocumentLineItem                      relievingSourceDocumentLineItem;

        sourceDocumentLineRelievingList = SourceDocumentLineMatchingList::construct();

        // get parent line
        parentSourceDocumentLineItem = this.parmParentSourceDocumentLineItem();
        // get lines parent is matched to
        relievingLinesForTaxParent = parentSourceDocumentLineItem.parmSourceDocumentLineRelievingList();

        if (relievingLinesForTaxParent)
        {
            common = taxMap;
            relievingLinesForTaxParentEnumerator = relievingLinesForTaxParent.getEnumerator();

            while (relievingLinesForTaxParentEnumerator.moveNext())
            {
                parentSourceDocumentLineRelieving = relievingLinesForTaxParentEnumerator.current();
                relievingSourceDocumentLineItem =  parentSourceDocumentLineRelieving.parmIndependentSourceDocumentLineItem();
                factor = parentSourceDocumentLineRelieving.parmAllocationFactor();
                relievingParentSourceDocumentLineItemRecId = relievingSourceDocumentLineItem.parmSourceDocumentLine().RecId;

                select firstonly relievingCandidateTaxUncommitted
                    where  relievingCandidateTaxUncommitted.TaxDirection == taxMap.TaxDirection &&
                        relievingCandidateTaxUncommitted.TaxCode == taxMap.TaxCode
                    join RecId from taxSourceDocumentLine
                        where taxSourceDocumentLine.RecId == relievingCandidateTaxUncommitted.SourceDocumentLine
                    exists join taxParentSourceDocumentLine
                        where taxParentSourceDocumentLine.RecId == taxSourceDocumentLine.ParentSourceDocumentLine &&
                            taxParentSourceDocumentLine.RecId == relievingParentSourceDocumentLineItemRecId;

                if (relievingCandidateTaxUncommitted != null)
                {
                    sourceDocumentLineRelievingList = SourceDocumentLineMatchingFacade::addSourceDocLineImplementationToList(common, relievingCandidateTaxUncommitted, factor, sourceDocumentLineRelievingList);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDeferredTaxDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the document is valid for deferred Hungarian VAT
    /// </summary>
    /// <returns>
    /// True if Purchase Order Invoice or Free Text Invoice
    /// False otherwise
    /// </returns>
    public boolean isDeferredTaxDocument()
    {
        SourceDocumentLineItem  currentSourceDocumentLineItem;
        SourceDocumentType      sourceDocumentType;

        if (!checkDeferredHungary)
        {
            currentSourceDocumentLineItem = this;

            while (currentSourceDocumentLineItem.parmParentSourceDocumentLineItem())
            {
                currentSourceDocumentLineItem = currentSourceDocumentLineItem.parmParentSourceDocumentLineItem();
            }

            sourceDocumentType = currentSourceDocumentLineItem.parmSourceDocument().parmSourceDocumentType();
            if (sourceDocumentType is CustInvoiceSourceDocType || sourceDocumentType is VendorInvoiceSourceDocType)
            {
                isDeferredTaxDocument = true;
            }
            else
            {
                isDeferredTaxDocument = false;
            }

            checkDeferredHungary = true;
        }

        return isDeferredTaxDocument;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExpenseAccount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if expense account should be hit.
    /// </summary>
    /// <returns>
    /// True if expense account should be hit.
    /// False otherwise.
    /// </returns>
    /// <remarks>
    /// POTBasis + Service category Others make it hit to expense account.
    /// </remarks>
    public boolean isExpenseAccount_IN()
    {
        ServiceTaxBasis_IN                          serviceTaxBasisIN;
        GTAServiceCategory_IN                       gtaServiceCategoryIN;
        TransTaxInformation                         transTaxInformation;

        if (TaxParameters::isServiceTaxEnable_IN()
            && TaxTable::find(taxMap.TaxCode).TaxType_IN == TaxType_IN::ServiceTax)
        {
            serviceTaxBasisIN = TaxItemGroupHeading::find(taxMap.TaxItemGroup).ServiceTaxBasis_IN;

            if (taxMap.SourceTableId == tableNum(PurchLine) || taxMap.SourceTableId == tableNum(VendInvoiceInfoLine))
            {
                transTaxInformation  = TransTaxInformationHelper::findOrCreateTransTaxInformation(taxMap.SourceTableId, taxMap.SourceRecId);
                gtaServiceCategoryIN = transTaxInformation.ServiceTaxGTAServiceCategory;
            }
            return serviceTaxBasisIN == ServiceTaxBasis_IN::POTBasis
                && gtaServiceCategoryIN == GTAServiceCategory_IN::Others;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIncludedInPrice_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns if the tax is included in the price.
    /// </summary>
    /// <returns>True if tax is included.</returns>
    public boolean isIncludedInPrice_BR()
    {
        return taxMap.TaxDirection != TaxDirection::UseTax && TaxTable::find(this.parmTaxCode()).IncludedTax_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetLedgerDimension_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// returns offset ledger dimension for current item
    /// </summary>
    /// <returns>
    /// Offset ledger dimension for current item
    /// </returns>
    public LedgerDimensionAccount offsetLedgerDimension_RU()
    {
        return taxMap.TaxMap::getOffsetLedgerDimension_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingDate</Name>
				<Source><![CDATA[
    public AccountingDate parmAccountingDate()
    {
        // <GEEHU>
        AccountingDate      accountingDate;

        if (TaxContinuousHUHelper::isTransactionContinuousHU(taxMap.TaxItemGroup)
            && taxMap.TaxMap::getVatDueDate()
            && TaxUncommitted_HU::existTaxUncommittedHU(taxMap.SourceDocumentLine))
        {
            accountingDate = taxMap.TaxMap::getVatDueDate();
        }
        else
        {
            // </GEEHU>
            accountingDate = this.parmParentSourceDocumentLineItem().parmAccountingDate();
            // <GEEHU>
        }

        return accountingDate;
        // </GEEHU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChildSourceDocumentLineItemList</Name>
				<Source><![CDATA[
    public SourceDocumentLineItemList parmChildSourceDocumentLineItemList()
    {
        childSourceDocumentLineItemList = SourceDocumentLineItemList::construct();

        return childSourceDocumentLineItemList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCopyDistributionReferenceOfOriginal</Name>
				<Source><![CDATA[
    public boolean parmCopyDistributionReferenceOfOriginal()
    {
        parentSourceDocumentLineItem = this.parmParentSourceDocumentLineItem();

        return parentSourceDocumentLineItem.parmCopyDistributionReferenceOfOriginal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrencyCode</Name>
				<Source><![CDATA[
    public CurrencyCode parmCurrencyCode()
    {
        return taxMap.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustBillingClassification</Name>
				<Source><![CDATA[
    public RefRecId parmCustBillingClassification()
    {
        CustInvoiceTable    custInvoiceTable;
        CustInvoiceLine     custInvoiceLine;
        CustInvoiceTrans    custInvoiceTrans;
        MarkupTrans         markupTrans;
        CustInvoiceJour     custInvoiceJour;

        switch (taxMap.TableId)
        {
            case tableNum(TaxTrans) :
                if (taxMap.SourceTableId == tableNum(CustInvoiceTrans))
                {
                    select firstonly CustBillingClassification from custInvoiceTable
                        join InvoiceId from custInvoiceTrans
                                where custInvoiceTable.InvoiceId == custInvoiceTrans.InvoiceId
                                    && custInvoiceTrans.RecId == taxMap.SourceRecId;
                }
                else if (taxMap.SourceTableId == tableNum(MarkupTrans))
                {
                    select firstonly CustBillingClassification from custInvoiceTable
                        join TransTableId, TransRecId from markupTrans
                        join InvoiceId, InvoiceDate, NumberSequenceGroup from custInvoiceJour
                                where custInvoiceJour.InvoiceId == custInvoiceTable.InvoiceId
                                    && custInvoiceJour.InvoiceDate == custInvoiceTable.InvoiceDate
                                    && custInvoiceJour.NumberSequenceGroup == custInvoiceTable.NumberSequenceGroup
                                    && markupTrans.TransTableId == custInvoiceJour.TableId
                                    && markupTrans.TransRecId == custInvoiceJour.RecId
                                    && markupTrans.RecId == taxMap.SourceRecId;
                }

                break;

            case tableNum(TaxUncommitted) :
                if (taxMap.SourceTableId == tableNum(CustInvoiceLine))
                {
                    select firstonly CustBillingClassification from custInvoiceTable
                        join ParentRecId from custInvoiceLine
                                where custInvoiceTable.RecId == custInvoiceLine.ParentRecId
                                    && custInvoiceLine.RecId == taxMap.SourceRecId;
                }
                else if (taxMap.SourceTableId == tableNum(MarkupTrans))
                {
                    select firstonly CustBillingClassification from custInvoiceTable
                        join RecId from markupTrans
                                where markupTrans.TransTableId == custInvoiceTable.TableId
                                    && markupTrans.TransRecId == markupTrans.TransRecId
                                    && markupTrans.RecId == taxMap.SourceRecId;
                }

                break;
        }

        return custInvoiceTable.CustBillingClassification;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustBillingCode</Name>
				<Source><![CDATA[
    public RefRecId parmCustBillingCode()
    {
        RefRecId            custBillingCodeRecId;
        CustBillingCode     custBillingCode;
        CustInvoiceLine     custInvoiceLine;
        CustInvoiceTrans    custInvoiceTrans;

        switch (taxMap.TableId)
        {
            case tableNum(TaxTrans) :
                if (taxMap.SourceTableId == tableNum(CustInvoiceTrans))
                {
                    select firstonly RecId from custBillingCode
                        join BillingCode from custInvoiceTrans
                            where custBillingCode.BillingCode == custInvoiceTrans.BillingCode
                                && custInvoiceTrans.RecId == taxMap.SourceRecId;

                    custBillingCodeRecId = custBillingCode.RecId;
                }
                break;

            case tableNum(TaxUncommitted) :
                if (taxMap.SourceTableId == tableNum(CustInvoiceLine))
                {
                    select firstonly CustBillingCode from custInvoiceLine
                        where custInvoiceLine.RecId == taxMap.SourceRecId;

                    custBillingCodeRecId = custInvoiceLine.CustBillingCode;
                }
                break;
        }

        return custBillingCodeRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDeferredTaxAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieve the main account for Hungarian Deferred Taxes
    /// </summary>
    /// <param name="_ledgerDimensionAccount">
    /// The default ledger dimension account that the positive distribution will use
    /// </param>
    /// <returns>
    /// The main account based on HungarianDeferredTax rules
    /// </returns>
    /// <remarks>
    /// This value is modified in the TaxSourceDocSublineItem class since Deferred
    /// Taxes have a different LedgerDimension Main Account value for the initial transaction
    /// </remarks>
    public LedgerDimensionAccount parmDeferredTaxAccount(LedgerDimensionAccount _ledgerDimensionAccount)
    {
        LedgerDimensionAccount      ledgerDimension;
        TaxLedgerAccountGroup       taxLedgerAccountGroup;

        ledgerDimension = _ledgerDimensionAccount;
        if (TaxContinuousHUHelper::isTransactionContinuousHU(taxMap.TaxItemGroup) &&
            TaxUncommitted_HU::existTaxUncommittedHU(taxMap.SourceDocumentLine))
        {
            taxLedgerAccountGroup = TaxLedgerAccountGroup::find(TaxTable::find(taxMap.TaxCode).TaxAccountGroup);
            ledgerDimension = taxLedgerAccountGroup.taxLedgerDimension(taxMap.TaxDirection);
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDescription</Name>
				<Source><![CDATA[
    public Description parmDescription()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDistributionTemplate</Name>
				<Source><![CDATA[
    public AccountingDistributionTemplate parmDistributionTemplate()
    {
        AccountingDistributionTemplate      distributionTemplate;

        return distributionTemplate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRate1</Name>
				<Source><![CDATA[
    public ExchRate parmExchangeRate1()
    {
        ExchRate ret;

        // <GBR>
        Object                      dataProvider;
        ChargeSourceDocLineItem     chargeSourceDocLineItem;
        SourceDocumentLineItem      sourceDocumentLineItem;
        // </GBR>

        // <GIN>
        if (TaxParameters::isCustomsEnable_IN()
            && TaxTable::find(taxMap.TaxCode).TaxType_IN == TaxType_IN::Customs)
        {
            ret = taxMap.getCustomsExchRate_IN();
            return ret;
        }
        // </GIN>

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            dataProvider    = this.getDataProvider();

            if (dataProvider is ChargeSourceDocLineItem)
            {
                chargeSourceDocLineItem = dataProvider;

                if (chargeSourceDocLineItem.parmMarkupTrans().MarkupClassification_BR == MarkupClassification_BR::SISCOMEX)
                {
                    sourceDocumentLineItem   = chargeSourceDocLineItem.parmParentSourceDocumentLineItem();

                    if (sourceDocumentLineItem != null)
                    {
                        return sourceDocumentLineItem.parmExchangeRate1();
                    }
                }
            }
        }
        // </GBR>

        ret = super();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRate2</Name>
				<Source><![CDATA[
    public ExchRate parmExchangeRate2()
    {
        // <GBR>
        Object                      dataProvider;
        ChargeSourceDocLineItem     chargeSourceDocLineItem;
        SourceDocumentLineItem      sourceDocumentLineItem;
        // </GBR>

        ExchRate ret;

        if (BrazilParameters::isEnabled())
        {
            dataProvider    = this.getDataProvider();

            if (dataProvider is ChargeSourceDocLineItem)
            {
                chargeSourceDocLineItem = dataProvider;

                if (chargeSourceDocLineItem.parmMarkupTrans().MarkupClassification_BR == MarkupClassification_BR::SISCOMEX)
                {
                    sourceDocumentLineItem   = chargeSourceDocLineItem.parmParentSourceDocumentLineItem();

                    if (sourceDocumentLineItem != null)
                    {
                        return sourceDocumentLineItem.parmExchangeRate2();
                    }
                }
            }
        }

        ret = super();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmForInterestAdjustment</Name>
				<Source><![CDATA[
    public NoYes parmForInterestAdjustment()
    {
        NoYes forInterestAdjustment = NoYes::No;
        CustInvoiceTable localCustInvoiceTable;

        if (taxMap.TableId == tableNum(TaxTrans) && taxMap.SourceTableId == tableNum(CustInvoiceTable))
        {
            localCustInvoiceTable = CustInvoiceTable::findRecId(taxMap.SourceRecId);
            forInterestAdjustment = localCustInvoiceTable.ForInterestAdjustment;
        }

        return forInterestAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventoryDimensionId</Name>
				<Source><![CDATA[
    public InventDimId parmInventoryDimensionId()
    {
        ProductReceiptSourceDocumentLineItem productReceiptSourceDocumentLineItem;
        InventDimId inventDimId;

        if (this.parmParentSourceDocumentLineItem() is ProductReceiptSourceDocumentLineItem)
        {
            productReceiptSourceDocumentLineItem = this.parmParentSourceDocumentLineItem();
            inventDimId = productReceiptSourceDocumentLineItem.parmInventoryDimensionId();
        }

        return inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsDocumentLineEditable</Name>
				<Source><![CDATA[
    public boolean parmIsDocumentLineEditable()
    {
        boolean         editable;

        switch (taxMap.SourceTableId)
        {
            case tableNum(MarkupTrans):
                editable = this.parmParentSourceDocumentLineItem().parmIsDocumentLineEditable();
                break;

            case tableNum(CustInvoiceLine):
                editable = this.parmParentSourceDocumentLineItem().parmIsWorkflowEditable();
                break;

            default:
                editable = super();
        }

        return editable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerDimensionDefaultAccount</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount parmLedgerDimensionDefaultAccount(LegalEntityRecId _legalEntityRecId = this.parmLegalEntityRecId())
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLotId</Name>
				<Source><![CDATA[
    public InventTransId parmLotId()
    {
        ProductReceiptSourceDocumentLineItem productReceiptSourceDocumentLineItem;
        InventDimId inventDimId;

        if (this.parmParentSourceDocumentLineItem() is ProductReceiptSourceDocumentLineItem)
        {
            productReceiptSourceDocumentLineItem = this.parmParentSourceDocumentLineItem();
            inventDimId = productReceiptSourceDocumentLineItem.parmLotId();
        }

        return inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocLineFinalizedDate</Name>
				<Source><![CDATA[
    public AccountingDate parmSourceDocLineFinalizedDate()
    {
        SourceDocumentLineItemIFinalize     iFinalize;
        AccountingDate                      finalizeAccountingDate;

        if (this.parmParentSourceDocumentLineItem() &&
            this.parmParentSourceDocumentLineItem() is SourceDocumentLineItemIFinalize)
        {
            iFinalize = this.parmParentSourceDocumentLineItem() as SourceDocumentLineItemIFinalize;
            finalizeAccountingDate = iFinalize.parmSourceDocLineFinalizedDate();
        }
        else
        {
            throw error (Error::wrongUseOfFunction(funcName()));
        }

        return finalizeAccountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxCode</Name>
				<Source><![CDATA[
    public TaxCode parmTaxCode()
    {
        return taxMap.TaxCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxDataAreaId</Name>
				<Source><![CDATA[
    public SelectableDataArea parmTaxDataAreaId()
    {
        //If tax is from intercompany expense line and tax obligation is set to destination then tax should be posted to destination legal entity.
        //However, the tax amount needs to be paid to the vendor in the source company.
        if ( taxMap.TableId == tableNum(TaxUncommitted) 
             && taxMap.SourceTableId == tableNum(TrvExpTrans)
             && taxParameters.TaxObligationCompany == TaxObligationCompany::Destination
            )
        {
            TrvExpTrans trvExpTrans;

            select firstonly RecId from trvExpTrans
                where trvExpTrans.RecId == taxMap.SourceRecId
                && trvExpTrans.TableId == taxMap.SourceTableId
                && trvExpTrans.ApprovalStatus != TrvAppStatus::Create
                && trvExpTrans.ProjId == '';

            if (trvExpTrans.RecId && trvExpTrans.isIntercompany() && trvExpTrans.taxDistributionExists())
            {
                return CompanyInfo::findRecId(trvExpTrans.LegalEntity).DataArea;
            }
        }

        return taxMap.company();

    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxDifferenceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax differenct amount.
    /// </summary>
    /// <returns>
    /// The tax difference amount.
    /// </returns>
    public TaxAmount parmTaxDifferenceAmount()
    {
        TaxAmount taxDifferenceAmount;
        if (taxMap.SourceCurrencyCode != Ledger::accountingCurrency()
            && (TaxParameters::isBankExchRateEnabled_W()
                // Calculate the difference amount only for accounting currency amount, so transaction currency should be different from accounting currency.
                || this.isTaxSpecificExchRateEnabledByTable()))
        {
            switch (taxMap.TableId)
            {
                case tableNum(TaxUncommitted) :
                    taxDifferenceAmount = this.getTaxDifferenceAmountFromTaxMap();
                    break;

                case tableNum(TaxTrans) :
                    taxDifferenceAmount = this.getTaxDifferenceAmountFromTaxTrans();
                    break;
            }
        }

        return taxDifferenceAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxDifferenceReportingCurrencyAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax differenct reporting currency amount.
    /// </summary>
    /// <returns>
    /// The tax differenct reporting currency amount.
    /// </returns>
    public TaxAmount parmTaxDifferenceReportingCurrencyAmount()
    {
        TaxAmount taxDifferenceAmount;
        if ((TaxParameters::isBankExchRateEnabled_W()
                && taxMap.SourceCurrencyCode != Ledger::accountingCurrency())
            // Calculate the difference amount only for reporting currency amount, so transaction currency should be different from reporting currency.
            || (taxMap.SourceCurrencyCode != Ledger::reportingCurrency()
                && this.isTaxSpecificExchRateEnabledByTable()))
        {
            switch (taxMap.TableId)
            {
                case tableNum(TaxUncommitted) :
                    taxDifferenceAmount = this.getTaxDifferenceReportingCurrencyAmountFromTaxUncommitted();
                    break;

                case tableNum(TaxTrans) :
                    taxDifferenceAmount = this.getTaxDifferenceReportingCurrencyAmountFromTaxTrans();
                    break;
            }
        }

        return taxDifferenceAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxSpecificExchRateEnabledByTable</Name>
				<Source><![CDATA[
    private boolean isTaxSpecificExchRateEnabledByTable()
    {
        boolean isTaxSpecificExchRateEnabledByTable;
        if (TaxSpecificExchangeRateHelper::isTaxSpecificExchangeRateEnabled())
        {
            RefTableId sourceTableId = taxMap.SourceTableId;
            RefRecId sourceRecId = taxMap.SourceRecId;
            if (taxMap.SourceTableId == tableNum(MarkupTrans))
            {
                MarkupTrans markupTrans = MarkupTrans::findRecId(taxMap.SourceRecId);
                sourceTableId = markupTrans.TransTableId;
                sourceRecId = markupTrans.TransRecId;
            }

            isTaxSpecificExchRateEnabledByTable = TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByTable(sourceTableId, sourceRecId);
        }

        return isTaxSpecificExchRateEnabledByTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxDifferenceTaxDirection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax difference amount tax direction.
    /// </summary>
    /// <returns>
    /// The tax difference amount tax direction.
    /// </returns>
    public TaxDirection parmTaxDifferenceTaxDirection()
    {
        TaxDirection taxDirection;
        boolean isTaxBankExchangeRateDifferenceEnabled = FeatureStateProvider::isFeatureEnabled(TaxBankExchangeRateDifferenceFlighting::instance()) || TaxBankExchangeRateDifferenceV2Flight::instance().isEnabled();

        if (taxMap.TaxDirection == TaxDirection::IncomingTax
            || (isTaxBankExchangeRateDifferenceEnabled && taxMap.TaxDirection == TaxDirection::IncomingTax_W))
        {
            taxDirection = TaxDirection::IncomingTax_W;
        }
        else if (taxMap.TaxDirection == TaxDirection::OutgoingTax
            || (isTaxBankExchangeRateDifferenceEnabled && taxMap.TaxDirection == TaxDirection::OutgoingTax_W))
        {
            taxDirection = TaxDirection::OutgoingTax_W;
        }
        else if (taxMap.TaxDirection == TaxDirection::UseTax)
        {
            taxDirection = TaxDirection::UseTax;
        }

        return taxDirection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxDirection</Name>
				<Source><![CDATA[
    public TaxDirection parmTaxDirection()
    {
        return taxMap.TaxDirection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxGroup</Name>
				<Source><![CDATA[
    public TaxGroup parmTaxGroup()
    {
        return taxMap.TaxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxItemGroup</Name>
				<Source><![CDATA[
    public TaxItemGroup parmTaxItemGroup()
    {
        return taxMap.TaxItemGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxMap_IN</Name>
				<Source><![CDATA[
    public TaxMap parmTaxMap_IN(TaxMap _taxMap = taxMap)
    {
        taxMap =  _taxMap;
        return taxMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxReceivableLongTerm_BR</Name>
				<Source><![CDATA[
    public TaxReceivableLongTerm_BR parmTaxReceivableLongTerm_BR()
    {
        return taxMap.TaxMap::getTaxReceivableLongTerm_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionCurrencyCode</Name>
				<Source><![CDATA[
    public CurrencyCode parmTransactionCurrencyCode()
    {
        SourceDocumentLineItem  parentSourceDocLineItem;
        SourceDocumentLineItem  grandParentSourceDocLineItem;

        if (!BrazilParameters::isEnabled())
        {
            return super();
        }

        parentSourceDocLineItem         = this.parmParentSourceDocumentLineItem();
        grandParentSourceDocLineItem    = parentSourceDocLineItem.parmParentSourceDocumentLineItem();

        if (grandParentSourceDocLineItem)
        {
            // markup tax is calculated with the document currency but we can have specific
            // scenarios where the markup currency is different from the document currency.
            // to get the proper currency, we will get from the parent source document of
            // the markup, which is the grand parent source document of the tax.
            return grandParentSourceDocLineItem.parmTransactionCurrencyCode();
        }
        else
        {
            return parentSourceDocLineItem.parmTransactionCurrencyCode();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchTaxOnOperations</Name>
				<Source><![CDATA[
    public NoYes parmPurchTaxOnOperations()
    {
        if (!taxParameters)
        {
            this.initTaxParameters();
        }
        return taxParameters.PurchTaxOnOperations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxParameters</Name>
				<Source><![CDATA[
    private void initTaxParameters()
    {
        taxParameters = TaxParameters::find();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCalculateSourceDocumentAmountMap_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines specifics parameters for Localizarion BR. It is a subscriber to event <c>postCalcSourceDocAmountMapHandler_BR</c> in <c>calculateSourceDocumentAmountMap</c> method.
    /// </summary>
    /// <param name="_sourceDocumentAmountMap">
    /// A <c>SourceDocumentAmountMap</c> passed by the method <c>calculateSourceDocumentAmountMap</c>
    /// </param>
    /// <returns>
    ///  A <c>SourceDocumentAmountMap</c> instance.
    /// </returns>
    protected SourceDocumentAmountMap postCalculateSourceDocumentAmountMap_BR(SourceDocumentAmountMap _sourceDocumentAmountMap = null)
    {
        SourceDocumentAmount                sourceDocumentAmount;
        CustInvoiceLineSourceDocLineItem    custInvoiceLineSourceDocLineItem;
        boolean                             createCustTrans;
        boolean                             createTaxNonRecoverable;
        TaxAmountCur                        sourceOtherTaxAmount;
        TaxTrans                            taxTrans;
        TaxTrans_BR                         taxTrans_BR;

        if (this.parmParentSourceDocumentLineItem() is CustInvoiceLineSourceDocLineItem)
        {
            createTaxNonRecoverable = true;
            custInvoiceLineSourceDocLineItem = this.parmParentSourceDocumentLineItem();
            createCustTrans = custInvoiceLineSourceDocLineItem.createCustTrans_BR();
        }
        else if (this.parmParentSourceDocumentLineItem() is SalesComplementaryInvSourceDocLine)
        {
            createTaxNonRecoverable = true;
            createCustTrans = true;
        }
        else
        {
            createTaxNonRecoverable = false;
        }

        if (createTaxNonRecoverable)
        {
            if (!this.taxOnFullAmount()
                 && createCustTrans
                 && taxMap.TaxDirection == TaxDirection::OutgoingTax
                 && !TaxTable::find(this.parmTaxCode()).RetainedTax_BR
                 && !TaxTable::find(this.parmTaxCode()).IncludedTax_BR)

            {
                if (taxMap.TableId == tableNum(TaxUncommitted) && taxMap.SourceOtherBaseTaxAmount_BR)
                {
                    sourceOtherTaxAmount = taxMap.SourceOtherBaseTaxAmount_BR;
                }
                else if (taxMap.TableId == tableNum(TaxTrans))
                {
                    taxTrans = taxMap;
                    taxTrans_BR = taxTrans.taxTrans_BR();
                    sourceOtherTaxAmount = taxTrans_BR.TaxAmountOther_BR;

                    sourceOtherTaxAmount = CurrencyExchangeHelper::curAmount(sourceOtherTaxAmount, taxMap.SourceCurrencyCode, taxMap.TransDate, 0, this.parmExchangeRate1());
                }

                if (taxMap.getTaxAmountBeforeCost())
                {
                    sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), taxMap.getTaxAmountBeforeCost(),
                                                                                MonetaryAmount::TaxNonRecoverable);
                }
                else if (sourceOtherTaxAmount)
                {
                    sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), sourceOtherTaxAmount,
                                                                                MonetaryAmount::TaxNonRecoverable);
                }

                if (sourceDocumentAmount)
                {
                    _sourceDocumentAmountMap.insert(sourceDocumentAmount);
                }
            }
        }

        return _sourceDocumentAmountMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCalculateSourceDocumentAmountMap_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// In this method we create the Monetary amounts for new value , ie, MonetaryAmount::ServiceTaxInterimAmount_IN
    /// </summary>
    /// <param name="_sourceDocumentAmountMap">
    /// The SourceDocumentMap object passed in.
    /// </param>
    /// <returns>
    /// The modified SourceDocumentMap object.
    /// </returns>

    protected SourceDocumentAmountMap postCalculateSourceDocumentAmountMap_IN(SourceDocumentAmountMap _sourceDocumentAmountMap = null)
    {
        SourceDocumentAmount                        sourceDocumentAmount;
        SourceDocumentLineMatchingList              localSourceDocumentLineMatchingList;
        SourceDocumentAmountMapEnumerator           matchingAmountMapEnum;
        SourceDocumentLineItem                      localMatchedSourceDocumentLineItem;
        SourceDocumentLineMatching                  localSourceDocumentLineMatching;
        SourceDocumentLineMatchingListEnumerator    localSourceDocumentLineMatchingListEnumerator;
        SourceDocumentAmount                        matchingSourceDocumentAmount;
        Amount                                      expectedInterimTax;
        Amount                                      varianceInterimTax;
        Amount                                      expectedInterimExpense;
        Amount                                      varianceInterimExpense;
        boolean                                     matching;
        RefTableId                                  sourceRelationType;

        localSourceDocumentLineMatchingList = this.parmSourceDocumentLineMatchingList();
        if (localSourceDocumentLineMatchingList && localSourceDocumentLineMatchingList.elements() > 0)
        {
            localSourceDocumentLineMatchingListEnumerator = localSourceDocumentLineMatchingList.getEnumerator();
            localSourceDocumentLineMatchingListEnumerator.moveNext();
            localSourceDocumentLineMatching     = localSourceDocumentLineMatchingListEnumerator.current();
            localMatchedSourceDocumentLineItem  = localSourceDocumentLineMatching.parmIndependentSourceDocumentLineItem();

            if (!multipleInterimMatchingLevels)
            {
                matchingAmountMapEnum = localMatchedSourceDocumentLineItem.parmSourceDocumentAmountMap().getEnumerator();

                while (matchingAmountMapEnum.moveNext())
                {
                    matchingSourceDocumentAmount = matchingAmountMapEnum.currentValue();

                    switch (matchingSourceDocumentAmount.parmMonetaryAmount())
                    {
                        case MonetaryAmount::ServiceTaxInterimAmount_IN :
                             expectedInterimTax = CurrencyExchangeHelper::amount(matchingSourceDocumentAmount.parmAmount() * interimInvoiceRatio, taxMap.CurrencyCode);
                             matching = true;
                             break;

                        case MonetaryAmount::ServiceTaxInterimExpense_IN :
                             expectedInterimExpense = CurrencyExchangeHelper::amount(matchingSourceDocumentAmount.parmAmount() * interimInvoiceRatio, taxMap.CurrencyCode);
                             matching = true;
                             break;
                    }
                }
            }
        }
        if (matching )
        {
            sourceRelationType = this.parmParentSourceDocumentLineItem().parmSourceDocumentLine().SourceRelationType;
            if (sourceRelationType != tableNum(PurchLine) && sourceRelationType != tableNum(PurchTable))
            {
                varianceInterimTax = (interimTax - expectedInterimTax);
                if (this.isExpenseAccount_IN())
                {
                    varianceInterimExpense = interimExpense - expectedInterimExpense;
                }
            }
        }
        if (interimTax || varianceInterimTax)
        {
            sourceDocumentAmount    = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), interimTax - varianceInterimTax, MonetaryAmount::ServiceTaxInterimAmount_IN);
            _sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }
        if (varianceInterimTax)
        {
            sourceDocumentAmount    = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), varianceInterimTax, MonetaryAmount::ServiceTaxInterimAmountVariance_IN);
            _sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }
        if (interimExpense || varianceInterimExpense)
        {
            sourceDocumentAmount    = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), interimExpense - varianceInterimExpense, MonetaryAmount::ServiceTaxInterimExpense_IN);
            _sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }
        if (varianceInterimExpense)
        {
            sourceDocumentAmount    = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(), varianceInterimExpense, MonetaryAmount::ServiceTaxInterimExpenseVariance_IN);
            _sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }
        return _sourceDocumentAmountMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceDocumentLineMapToTaxMap</Name>
				<Source><![CDATA[
    private TaxMap sourceDocumentLineMapToTaxMap(SourceDocumentLineImplementation  _lineMap)
    {
        TaxUncommitted      taxUncommitted;
        TaxTrans            taxTrans;

        switch (_lineMap.TableId)
        {
            case tableNum(TaxTrans) :
            taxTrans = _lineMap;
            return taxTrans;
            case tableNum(TaxUncommitted) :
            taxUncommitted = _lineMap;
            return taxUncommitted;
        }

        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxMapToSourceDocumentLineMap</Name>
				<Source><![CDATA[
    private SourceDocumentLineImplementation taxMapToSourceDocumentLineMap(TaxMap  _taxMap)
    {
        TaxUncommitted      taxUncommitted;
        TaxTrans            taxTrans;

        switch (_taxMap.TableId)
        {
            case tableNum(TaxTrans) :
                taxTrans = _taxMap;
                return taxTrans;
            case tableNum(TaxUncommitted) :
                taxUncommitted = _taxMap;
                return taxUncommitted;
        }

        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxOnFullAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether to follow US tax rules when distributions are processed.
    /// </summary>
    /// <returns>
    /// true if following US tax rules; otherwise, false.
    /// </returns>
    public boolean taxOnFullAmount()
    {
        boolean         ok;

        if (!taxParameters)
        {
            this.initTaxParameters();
        }

        ok = ( taxParameters.PurchTaxOnOperations == NoYes::Yes &&
              (taxMap.TaxDirection == TaxDirection::IncomingTax || taxMap.TaxDirection == TaxDirection::UseTax));

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSourceDocumentAmountMatchDist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if matched source document amount accounting distributions can be used
    /// to derive ledger dimensions.
    /// </summary>
    /// <param name="_monetaryAmount">
    /// Monetary amount of accounting distribution
    /// </param>
    /// <returns>
    /// true if matching source document amount accounting distributions can be used; otherwise, false.
    /// </returns>
    public boolean useSourceDocumentAmountMatchDist(MonetaryAmount _monetaryAmount)
    {
        boolean useAmountMatch = true;
        if (_monetaryAmount == MonetaryAmount::TaxDeferred_IN ||
            _monetaryAmount == MonetaryAmount::TaxDeferredVariance_IN)
        {
            useAmountMatch = false;
        }
        return useAmountMatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>withoutTaxTrans_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether <c>TaxTrans</c> record should be created for current item
    /// </summary>
    /// <returns>
    /// A boolean value; if true record should be created
    /// </returns>
    /// <remarks>
    /// Records are not created for specific invent profile types, Invent Bailee for example
    /// </remarks>
    private NoYesId withoutTaxTrans_RU()
    {
        if (taxMap.TableId == tableNum(TaxUncommitted))
        {
            return taxMap.WithoutTaxTrans_RU;
        }
        else
        {
            return NoYes::No;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCalcSourceDocAmountMapHandler_IN</Name>
				<Source><![CDATA[
    [PostHandlerFor(classStr(TaxSourceDocSublineItem), methodStr(TaxSourceDocSublineItem, calculateSourceDocumentAmountMap))]
    /// <summary>
    /// The handler of the posting the calculate source document amount map.
    /// </summary>
    /// <param name="_args">
    /// The xpp pre post arguments.
    /// </param>
    public static void postCalcSourceDocAmountMapHandler_IN(XppPrePostArgs _args)
    {
        anytype returnValue;

        TaxSourceDocSublineItem taxSourceDocSublineItem = _args.getThis();

        if (TaxParameters::isServiceTaxEnable_IN() == false
            || TaxTable::find(taxSourceDocSublineItem.parmTaxCode()).TaxType_IN != TaxType_IN::ServiceTax)
        {
            return;
        }

        returnValue = taxSourceDocSublineItem.postCalculateSourceDocumentAmountMap_IN(
            _args.getReturnValue());

        _args.setReturnValue(returnValue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentsInterCompanyBusinessEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the <c>SourceDocumentLineItem</c> documents an intercompany business event.
    /// </summary>
    /// <returns>
    /// true if the <c>SourceDocumentLineItem</c> documents an intercompany business event; otherwise, false.
    /// </returns>
    public boolean documentsInterCompanyBusinessEvent()
    {
        boolean ret;

        ret = super();

        //if tax is from intercompany expense line
        if (taxMap.TableId == tableNum(TaxUncommitted) && taxMap.SourceTableId == tableNum(TrvExpTrans))
        {
            TrvExpTrans trvExpTrans;

            select firstonly RecId from trvExpTrans
                where trvExpTrans.RecId == taxMap.SourceRecId
                && trvExpTrans.TableId == taxMap.SourceTableId;

            if (trvExpTrans.RecId && trvExpTrans.isIntercompany() && taxParameters.TaxObligationCompany == TaxObligationCompany::Destination)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>