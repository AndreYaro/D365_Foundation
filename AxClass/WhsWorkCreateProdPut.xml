<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWorkCreateProdPut</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WhsWorkCreateProdPut</c> class creates warehouse work for production order put.
/// </summary>
class WhsWorkCreateProdPut extends WHSWorkCreate
{
    WHSWorkCreateId           workCreateId;
    ProdTable                 prodTable;
    ItemId                    itemId;
    InventDim                 inventDim;    
    InventQty                 inventQty;
    InventHandlingQty         inventHandlingQty;
    ProdParmReportFinished    prodParmReportFinishedMainProduct;
    ProdParmReportFinished    prodParmReportFinishedReportedProduct;
    boolean                   reportAsFinished;
    PdsBatchAttribValue       batchPotencyValue;
    PdsBatchDispositionCode   batchDispCode;
    InventBatchExpDate        batchExpDate;
    PmfProductType            pmfProductType;
    InventTransId             inventTransId;
    NoYesId                   acceptError;
    NoYesId                   endJob;
    ProdJournalId             rafJournalId;
    InventTransOriginIdMarked markedTransOriginId;
    
    private WHSTransWeight    catchWeight;
    private InventTable       inventTable;
    private InventDim         coByProductInventDim;
    private ProdRespectFlushingPrincipleForWHSReportedOverproduction respectFlushingPrinciple;
    private TransDate         globalTransDate;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>inventTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the item record that work is being created for.
    /// </summary>
    /// <returns>The item record.</returns>
    protected final InventTable inventTable()
    {
        if (inventTable.ItemId != itemId)
        {
            inventTable = InventTable::find(itemId);
        }
    
        return inventTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeNewBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new batch record.
    /// </summary>
    /// <returns>The initialized batch record.</returns>
    protected InventBatch initializeNewBatch()
    {
        InventBatch inventBatch;

        inventBatch.InventBatchId   = inventBatchId;
        inventBatch.ItemId          = itemId;

        inventBatch.initializeProductionDate();
        inventBatch.ExpDate         = this.inventTable().isShelfLifeItem() ? inventBatch.ProdDate : batchExpDate;

        return inventBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateBatch</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Generates or updates an inventory batch ID for a given item.
    /// </summary>
    public void createOrUpdateBatch()
    {
        InventBatch inventBatch;
        
        if (inventBatchId && itemId)
        {
            ttsbegin;

            if (this.inventTable().whsBatchActive())
            {
                inventBatch = InventBatch::find(inventBatchId, itemId, true);

                if (inventBatch.RecId == 0)
                {
                    inventBatch = this.initializeNewBatch();
                }
                else if (!inventBatch.expDate && batchExpDate)
                {
                    inventBatch.expDate = batchExpDate;
                }

                if (this.mustSetInventBatchShelfLifeDates(inventBatch, this.inventTable()))
                {
                    inventBatch.pdsSetShelfLifeBestBeforeFields(this.inventTable());
                }

                inventBatch.write();

                // Set the potency attribute value
                inventBatch.updateBaseBatchAttribValue(batchPotencyValue);

                // Capture the batch disposition code
                if (batchDispCode && this.inventTable().pdsIsShelfLifeCapable())
                {
                    PdsResetDispositionStatus::setBatchDispositionCode(itemId, inventBatchId, batchDispCode);
                }
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSetInventBatchShelfLifeDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if batch shelf dates must be set.
    /// </summary>
    /// <param name = "_inventBatch">The batch record.</param>
    /// <param name = "_inventTable">The items record.</param>
    /// <returns>true if the batch shelf dates must be set; otherwise, false.</returns>
    [Replaceable]
    protected boolean mustSetInventBatchShelfLifeDates(InventBatch _inventBatch, InventTable _inventTable)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFeedbackQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates Report as finished feedback quantity based on relevant Manufacturing execution feedback validation methods
    /// </summary>
    private void validateFeedbackQuantity()
    {
        JmgProdParametersDim      prodParametersDim = JmgProdParametersDim::find(prodTable.InventDimId);

        if (prodParametersDim.ValidateFeedbackQuantity &&
           (prodParametersDim.FeedbackValidateMethod == JmgFeedbackValidateMethod::ProdPlannedQty ||
            prodParametersDim.FeedbackValidateMethod == JmgFeedbackValidateMethod::ProdStartedQty))
        {
            this.validateQuantity();
        }
        acceptError = prodParametersDim.ReportFinishAcceptError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReportFinished</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts the Report As Finished Journal and creates putaway work if the policy allows it.
    /// </summary>
    /// <returns>
    /// WorkBuildId of the work created
    /// </returns>
    public WHSWorkBuildId createReportFinished()
    {
        WHSWorkBuildId workBuildId;

        ttsbegin;

        this.createOrUpdateBatch();

        this.validateFeedbackQuantity();
        
        this.createReportFinishedParameters();

        WHSWorkTransType workTransTypeLocal;
        ItemId           itemIdLocal;

        [itemIdLocal, workTransTypeLocal] = this.getItemIdWorkTransType();

        WHSCrossDockId crossDockId;

        // Check if inventory should attempt to be cross docked
        if (this.canBeCrossDocked())
        {
            WHSWorkCreationRule workCreationRule = WHSWorkPolicy::findWorkPolicyForCreationMethod(WHSWorkCreationMethod::CrossDock,
                                                                                                  workTransTypeLocal,
                                                                                                  inventDim.InventLocationId,
                                                                                                  inventDim.wMSLocationId,
                                                                                                  itemIdLocal);

            if (workCreationRule)
            {
                WHSCrossDockOpportunityPolicy crossDockPolicy = WHSCrossDockOpportunityPolicy::find(workCreationRule.CrossDockOpportunityPolicyName);

                WHSOpportunisticCrossDockCreator crossDockCreator = WHSOpportunisticCrossDockCreator::newFromParameters(inventTransId, crossDockPolicy.RecId, markedTransOriginId);

                // Find batch from production order if not specified in RF
                if (!workInventDim.inventBatchId)
                {
                    workInventDim.inventBatchId = prodTable.inventDim().inventBatchId;
                }

                InventDim crossDockSupplyDim = InventDim::findOrCreate(workInventDim);

                // Check for available demand, and mark against it
                crossDockId = crossDockCreator.crossDock(inventHandlingQty, crossDockSupplyDim);
            }
        }

        this.processReportAsFinished(prodParmReportFinishedMainProduct);
       
        this.pmfProdCoByReferenceRefresh();

        if (crossDockId)
        {
            InventQty crossDockWorkQty;

            // Build cross dock work
            [workBuildId, crossDockWorkQty] = WHSWorkCreateCrossDock::processOpportunitiesForCrossDock(crossDockId);
            inventHandlingQty -= crossDockWorkQty;
        }

        // If cross docking failed, wasn't attempted, or did not consume the full quantity being RAF'd
        if (this.mustCreateWork(workBuildId))
        {
            boolean workCreationAllowed = this.isPutWorkCreationAllowed(inventDim);
            if (workCreationAllowed)
            {
                if (workBuildId)
                {
                    this.parmWorkCreateId(workBuildId);
                }

                workBuildId = this.createWork();
            }
        }

        ttscommit;

        return workBuildId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReportAsFinished</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process report as finished.
    /// </summary>
    /// <param name = "_prodParmReportFinished">A <c>ProdParmReportFinished</c> buffer.</param>
    [Wrappable(true)]
    internal void processReportAsFinished(ProdParmReportFinished _prodParmReportFinished)
    {
        if (this.mustRegisterProductionOrderHandlingQty())
        {
            rafJournalId = ProdUpdReportFinished::reportFinished(prodParmReportFinishedMainProduct);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work must be created.
    /// </summary>
    /// <param name = "_workBuildId">The work creation number.</param>
    /// <returns>true if the work must be created; otherwise, false.</returns>
    protected boolean mustCreateWork(WHSWorkBuildId _workBuildId)
    {
        return !_workBuildId || inventHandlingQty > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWorkInventDimSerialFromInventTransForCrossDock</Name>
				<Source><![CDATA[
    private void setWorkInventDimSerialFromInventTransForCrossDock()
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;
        InventDim           inventDimLocal;

        select firstOnly InventSerialId from inventDimLocal
            where inventDimLocal.inventSerialId != ''
            exists join inventTrans
                where inventTrans.inventDimId == inventDimLocal.inventDimId
            exists join inventTransOrigin
                where  inventTransOrigin.RecId          == inventTrans.InventTransOrigin
                    && inventTransOrigin.InventTransId  == inventTransId;

        workInventDim.inventSerialId = inventDimLocal.inventSerialId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeCrossDocked</Name>
				<Source><![CDATA[
    private boolean canBeCrossDocked()
    {
        boolean             ret = true;
        InventTrans         markedTransactions;
        InventTransOrigin   markedOrigin;
  
        // If production order has multiple markings if we attempt to cross dock, we could select the incorrect demand transaction.
        select firstonly TableId, ItemId from markedOrigin
            where markedOrigin.InventTransId == inventTransId
            join MarkingRefInventTransOrigin from markedTransactions
                where markedTransactions.InventTransOrigin           == markedOrigin.RecId
                &&    markedTransactions.StatusReceipt               == StatusReceipt::Ordered
                &&    markedTransactions.MarkingRefInventTransOrigin != 0;

        if (PdsGlobal::pdsIsCWItem(markedOrigin.ItemId))
        {
            ret = checkFailed("@WAX:Error_OpportunisticCrossDockingDoesNotSupportCWItems");
        }

        markedTransOriginId = markedTransactions.MarkingRefInventTransOrigin;

        if (markedTransactions.MarkingRefInventTransOrigin)
        {
            markedTransactions.clear();

            select firstonly TableId from markedOrigin
                where markedOrigin.InventTransId == inventTransId
                join MarkingRefInventTransOrigin from markedTransactions
                    where markedTransactions.InventTransOrigin           == markedOrigin.RecId
                    &&    markedTransactions.StatusReceipt               == StatusReceipt::Ordered
                    &&    markedTransactions.MarkingRefInventTransOrigin != 0
                    &&    markedTransactions.MarkingRefInventTransOrigin != markedTransOriginId;

            if (markedTransactions.MarkingRefInventTransOrigin)
            {
                ret = false;
                markedTransOriginId = 0;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfProdCoByReferenceRefresh</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refresh the value of internal class variable <c>InventTransId</c>, which holds the reference to the <c>PmfProdCoBy</c> record.
    /// </summary>
    /// <remarks>
    /// <c>PmfProdCoBy</c> record gets created on the fly for co and by-products reported outside of what is defined on the formula.
    /// That happens after the <c>ProdParmReportFinished</c> has already been inserted.
    /// </remarks>
    protected void pmfProdCoByReferenceRefresh()
    {
        switch (pmfProductType)
        {
            case PmfProductType::By_Product:
            case PmfProductType::Co_Product:
                if (!inventTransId)
                {
                    prodParmReportFinishedReportedProduct.reread();
                    inventTransId = prodParmReportFinishedReportedProduct.InventTransId;
                }
                break;
            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkInventDimQuantityMapFromTrackingAboveDimensions</Name>
				<Source><![CDATA[
    private Map getWorkInventDimQuantityMapFromTrackingAboveDimensions(boolean _batchAboveLocation, boolean _serialAboveLocation)
    {
        Query query = new query();

        QueryBuildDataSource qbrsInventTrans = query.addDataSource(tableNum(InventTrans));
        qbrsInventTrans.addRange(fieldNum(InventTrans, StatusIssue)).value(queryValue(StatusIssue::None));
        qbrsInventTrans.addRange(fieldNum(InventTrans, StatusReceipt)).value(SysQuery::valueNot(StatusReceipt::None));

        QueryBuildDataSource qbrsInventDim = this.initializeInventDimQueryBuildDataSource(qbrsInventTrans);
        qbrsInventDim.relations(true);
        qbrsInventDim.joinMode(JoinMode::ExistsJoin);
            
        QueryBuildDataSource qbrsInventTransOrigin = qbrsInventTrans.addDataSource(tableNum(InventTransOrigin));
        qbrsInventTransOrigin.addRange(fieldNum(InventTransOrigin, InventTransId)).value(inventTransId);
        qbrsInventTransOrigin.relations(true);
        qbrsInventTransOrigin.joinMode(JoinMode::ExistsJoin);
        
        // Join Journal ID for partial RAF.
        if (rafJournalId)
        {
            QueryBuildDataSource qbrsProdJournalProd = qbrsInventTransOrigin.addDataSource(tableNum(ProdJournalProd));
            qbrsProdJournalProd.addRange(fieldNum(ProdJournalProd, JournalId)).value(rafJournalId);
            qbrsProdJournalProd.addLink(fieldNum(InventTransOrigin, InventTransId), fieldNum(ProdJournalProd, InventTransId), qbrsInventTransOrigin.name());
            qbrsProdJournalProd.addLink(fieldNum(InventTrans, VoucherPhysical), fieldNum(ProdJournalProd, Voucher), qbrsInventTrans.name());
            qbrsProdJournalProd.joinMode(JoinMode::ExistsJoin);
        }

        QueryRun queryRun = new QueryRun(query);
            
        Map workInventDimQuantityMap = new Map(Types::Record, Types::Real);

        while (queryRun.next())
        {
            InventTrans localInventTrans = queryRun.get(tableNum(InventTrans));
            
            this.initializeWorkInventDimFromInventTrans(localInventTrans, _batchAboveLocation, _serialAboveLocation);

            InventHandlingQty handlingQty;

            if (PdsGlobal::pdsIsCWItem(localInventTrans.ItemId))
            {
                handlingQty = localInventTrans.PdsCWQty;
            }
            else
            {
                handlingQty = localInventTrans.Qty;
            }

            if (workInventDimQuantityMap.exists(workInventDim))
            {
                workInventDimQuantityMap.insert(workInventDim, workInventDimQuantityMap.lookup(workInventDim) + handlingQty);
            }
            else
            {
                workInventDimQuantityMap.insert(workInventDim, handlingQty);
            }
        }

        return workInventDimQuantityMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkInventDimQuantityMapFromWorkInventDim</Name>
				<Source><![CDATA[
    private Map createWorkInventDimQuantityMapFromWorkInventDim()
    {
        Map workInventDimQuantityMap = new Map(Types::Record, Types::Real);
        workInventDimQuantityMap.insert(workInventDim, inventHandlingQty);

        return workInventDimQuantityMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTempTable</Name>
				<Source><![CDATA[
    void createTempTable()
    {
        ttsbegin;
        
        startLocationId = inventDim.wMSLocationId;

        this.initializeTempWorkLine();

        this.setGlobals();

        WHSWorkBuildId crossDockWorkBuildId = WHSWorkTable::findCrossDockWorkBuildId(targetLicensePlateId);
        WHSWorkBuildId qualityItemSamplingWorkBuildId = WHSWorkTable::findQualityItemSamplingWorkBuildId(targetLicensePlateId);

        boolean isBatchAboveLocation = WHSReservationHierarchyInventDimUtil::isBatchAboveLocation(InventTable::find(itemId));
        boolean isSerialAboveLocation = WHSReservationHierarchyInventDimUtil::isSerialAboveLocation(InventTable::find(itemId));

        if (WHSWorkCreateProdPutDimLoopingV2Flight::instance().isEnabled())
        {
            Map workInventDimQuantityMap = new Map(Types::Record, Types::Real);

            if (isBatchAboveLocation || isSerialAboveLocation)
            {
                workInventDimQuantityMap = this.getWorkInventDimQuantityMapFromTrackingAboveDimensions(isBatchAboveLocation, isSerialAboveLocation);
            }
            else
            {
                workInventDimQuantityMap = this.createWorkInventDimQuantityMapFromWorkInventDim();
            }

            InventQty remainInventQty = inventHandlingQty;

            MapEnumerator enumerator = new MapEnumerator(workInventDimQuantityMap);
            while (enumerator.moveNext())
            {
                workInventDim = enumerator.currentKey();
                InventHandlingQty handlingQty = enumerator.currentValue();
            
                InventQty qtyToCreateWork = this.getWorkCreateQuantityAfterCrossDock(min(remainInventQty, handlingQty),
                                                                                    crossDockWorkBuildId,
                                                                                    tmpWorkLine.ItemId,
                                                                                    targetLicensePlateId,
                                                                                    WHSTmpWorkLineCreator::mergeWorkInventDim(prodTable.inventDim(), workInventDim, tmpWorkLine.ItemId));
                // Store off cross dock quantity to be used when evaluating cross docking later
                InventQty crossDockAdjustedQty = qtyToCreateWork;

                qtyToCreateWork = this.getWorkCreateQuantityAfterQualityItemSampling(qtyToCreateWork,
                                                                                    qualityItemSamplingWorkBuildId,
                                                                                    tmpWorkLine.InventTransId,
                                                                                    targetLicensePlateId,
                                                                                    WHSTmpWorkLineCreator::mergeWorkInventDim(prodTable.inventDim(), workInventDim, tmpWorkLine.ItemId));
  
                tmpWorkLine.WorkCreateId = workCreateId;

                if (qtyToCreateWork > 0)
                {
                    // If marking exists, evaluate and execute cross docking at supply receipt if possible.
                    if (WHSCrossDockingAtSupplyReceipt::validateMarkingExists(prodTable.InventTransId, targetLicensePlateId))
                    {
                        WHSCrossDockingAtSupplyReceipt::crossDock(prodTable, qtyToCreateWork, targetLicensePlateId, tmpWorkLine);
                    }

                    // Recalculate the qty to create work for to account for any cross docking
                    qtyToCreateWork -= (crossDockAdjustedQty - this.adjustQuantityForCrossDock(min(remainInventQty, handlingQty),
                                                                                            targetLicensePlateId,
                                                                                            tmpWorkLine.WorkCreateId,
                                                                                            tmpWorkLine.ItemId,
                                                                                            WHSTmpWorkLineCreator::mergeWorkInventDim(prodTable.inventDim(), workInventDim, tmpWorkLine.ItemId)));

                    if (qtyToCreateWork)
                    {
                        this.createTempLine(tmpWorkLine, qtyToCreateWork);
                    }
                }

                remainInventQty -= handlingQty;
                if (remainInventQty <= 0)
                {
                    break;
                }
            }
        }
        else
        {
            InventQty qtyToCreateWork = this.getWorkCreateQuantityAfterCrossDock(inventHandlingQty,
                                                                                    crossDockWorkBuildId,
                                                                                    tmpWorkLine.ItemId,
                                                                                    targetLicensePlateId,
                                                                                    WHSTmpWorkLineCreator::mergeWorkInventDim(prodTable.inventDim(), workInventDim, tmpWorkLine.ItemId));

            // Store off cross dock quantity to be used when evaluating cross docking later
            InventQty crossDockAdjustedQty = qtyToCreateWork;

            qtyToCreateWork = this.getWorkCreateQuantityAfterQualityItemSampling(qtyToCreateWork,
                                                                                    qualityItemSamplingWorkBuildId,
                                                                                    tmpWorkLine.InventTransId,
                                                                                    targetLicensePlateId,
                                                                                    WHSTmpWorkLineCreator::mergeWorkInventDim(prodTable.inventDim(), workInventDim, tmpWorkLine.ItemId));

  
            tmpWorkLine.WorkCreateId = workCreateId;

            if (qtyToCreateWork > 0)
            {
                // If marking exists, evaluate and execute cross docking at supply receipt if possible.
                if (WHSCrossDockingAtSupplyReceipt::validateMarkingExists(prodTable.InventTransId, targetLicensePlateId))
                {
                    WHSCrossDockingAtSupplyReceipt::crossDock(prodTable, qtyToCreateWork, targetLicensePlateId, tmpWorkLine);
                }

                // Recalculate the qty to create work for to account for any cross docking
                qtyToCreateWork -= (crossDockAdjustedQty - this.adjustQuantityForCrossDock(inventHandlingQty,
                                                                                            targetLicensePlateId,
                                                                                            tmpWorkLine.WorkCreateId,
                                                                                            tmpWorkLine.ItemId,
                                                                                            WHSTmpWorkLineCreator::mergeWorkInventDim(prodTable.inventDim(), workInventDim, tmpWorkLine.ItemId)));

                if (qtyToCreateWork)
                {
                    if (isBatchAboveLocation || isSerialAboveLocation)
                    {
                        this.createTempLineWithBatchSerial(isBatchAboveLocation, isSerialAboveLocation, qtyToCreateWork);
                    }
                    else
                    {
                        // Create the Temp Work Line record(s).
                        this.createTempLine(tmpWorkLine, qtyToCreateWork);
                    }
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBatchOrSerialAbove</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if batch ID or serial is above warehouse location ID in the reservation hierarchy of the item.
    /// </summary>
    /// <param name = "_isBatchAboveLocation">The boolean indicating whether batch ID is above warehouse location in the reservation hierarchy.</param>
    /// <param name = "_isSerialAboveLocation">The boolean indicating whether serial ID is above warehouse location in the reservation hierarchy.</param>
    /// <returns>true if batch or serial is above location in the reservation hierarchy; otherwise, false.</returns>
    protected boolean isBatchOrSerialAbove(boolean _isBatchAboveLocation, boolean _isSerialAboveLocation)
    {
        return _isBatchAboveLocation || _isSerialAboveLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTempWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the temp work line record.
    /// </summary>
    protected void initializeTempWorkLine()
    {
        // Fill the Production specific fields on the Temp Work Line.
        tmpWorkLine.initializeTempWorkLineByPmfProductType(pmfProductType);

        tmpWorkLine.OriginRefId      = prodTable.ProdId;
        tmpWorkLine.WorkType         = WHSWorkType::Put;
        tmpWorkLine.WorkCreateId     = workCreateId;
        tmpWorkLine.InventTransId    = inventTransId;
        tmpWorkLine.ItemId           = itemId;
        tmpWorkLine.RefTableId       = tableNum(ProdTable);
        tmpWorkLine.RefRecId         = prodTable.RecId;
        tmpWorkLine.OrderNum         = prodTable.ProdId;
        tmpWorkLine.StartLocationId  = startLocationId;
        tmpWorkLine.InventBatchId = inventDim.inventBatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTempLineWithBatchSerial</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Create temporary work line for each pair of batch number and serial number.
    /// </summary>
    /// <param name = "_batchAboveLocation">
    ///  A boolean flag. True when batch number is above location; else false.
    /// </param>
    /// <param name = "_serialAboveLocation">
    ///  A boolean flag. True when serial number is above location; else false.
    /// </param>
    /// <param name = "_remainingQtyToCreateWorkFor">The quantity amount work still needs to be created for.
    /// </param>
    private void createTempLineWithBatchSerial(
        boolean     _batchAboveLocation, 
        boolean     _serialAboveLocation,
        InventQty   _remainingQtyToCreateWorkFor)
    {
        InventTrans              localInventTrans;
        InventDim                localInventDim;
        InventQty                remainInventQty = _remainingQtyToCreateWorkFor;

        Query query = new query();

        QueryBuildDataSource qbrsInventTrans = query.addDataSource(tableNum(InventTrans));
        qbrsInventTrans.addRange(fieldNum(InventTrans, StatusIssue)).value(queryValue(StatusIssue::None));
        qbrsInventTrans.addRange(fieldNum(InventTrans, StatusReceipt)).value(SysQuery::valueNot(StatusReceipt::None));

        QueryBuildDataSource qbrsInventDim = this.initializeInventDimQueryBuildDataSource(qbrsInventTrans);

        qbrsInventDim.relations(true);
        qbrsInventDim.joinMode(JoinMode::ExistsJoin);
        QueryBuildDataSource qbrsInventTransOrigin = qbrsInventTrans.addDataSource(tableNum(InventTransOrigin));
        qbrsInventTransOrigin.relations(true);
        qbrsInventTransOrigin.joinMode(JoinMode::ExistsJoin);
        qbrsInventTransOrigin.addRange(fieldNum(InventTransOrigin, InventTransId)).value(inventTransId);
        
        // Join Journal ID for partial RAF.
        if (rafJournalId)
        {
            QueryBuildDataSource qbrsProdJournalProd = qbrsInventTransOrigin.addDataSource(tableNum(ProdJournalProd));
            qbrsProdJournalProd.addRange(fieldNum(ProdJournalProd, JournalId)).value(rafJournalId);
            qbrsProdJournalProd.joinMode(JoinMode::ExistsJoin);
            qbrsProdJournalProd.addLink(fieldNum(InventTransOrigin, InventTransId), fieldNum(ProdJournalProd, InventTransId), qbrsInventTransOrigin.name());
            qbrsProdJournalProd.addLink(fieldNum(InventTrans, VoucherPhysical), fieldNum(ProdJournalProd, Voucher), qbrsInventTrans.name());
        }

        QueryRun    queryRun = new QueryRun(query);
        boolean     groupWorkLinesByWorkInventDim = WHSWorkCreateProdPutGroupTmpWorkLinesV2Flight::instance().isEnabled();
        Map         workInventDimQuantityMap = new Map(Types::Record, Types::Real);

        while (queryRun.next())
        {
            localInventTrans = queryRun.get(tableNum(InventTrans));
            
            this.initializeWorkInventDimFromInventTrans(localInventTrans, _batchAboveLocation, _serialAboveLocation);

            InventHandlingQty handlingQty;

            if (PdsGlobal::pdsIsCWItem(localInventTrans.ItemId))
            {
                handlingQty = localInventTrans.PdsCWQty;
            }
            else
            {
                handlingQty = localInventTrans.Qty;
            }

            if (groupWorkLinesByWorkInventDim)
            {
                if (workInventDimQuantityMap.exists(workInventDim))
                {
                    workInventDimQuantityMap.insert(workInventDim, workInventDimQuantityMap.lookup(workInventDim) + handlingQty);
                }
                else
                {
                    workInventDimQuantityMap.insert(workInventDim, handlingQty);
                }
            }
            else
            {
                // Create the Temp Work Line record(s).
                this.createTempLine(tmpWorkLine, handlingQty);
            }

            remainInventQty -= handlingQty;

            if (remainInventQty <= 0)
            {
                break;
            }
        }

        if (groupWorkLinesByWorkInventDim)
        {
            MapEnumerator enumerator = new MapEnumerator(workInventDimQuantityMap);

            while (enumerator.moveNext())
            {
                workInventDim = enumerator.currentKey();

                this.createTempLine(tmpWorkLine, enumerator.currentValue());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventDimQueryBuildDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Intializes inventory dimension query builder data source.
    /// </summary>
    /// <param name = "_qbrsInventTrans">The data source for inventory transaction.</param>
    /// <returns>The data source for inventory dimension.</returns>
    protected QueryBuildDataSource initializeInventDimQueryBuildDataSource(QueryBuildDataSource _qbrsInventTrans)
    {
        QueryBuildDataSource qbrsInventDim = _qbrsInventTrans.addDataSource(tableNum(InventDim));
        qbrsInventDim.addRange(fieldNum(InventDim, LicensePlateId)).value(targetLicensePlateId);

        if (workInventDim.inventBatchId)
        {
            qbrsInventDim.addRange(fieldNum(inventDim, InventBatchId)).value(queryValue(workInventDim.inventBatchId));
        }

        if (workInventDim.InventSerialId)
        {
            qbrsInventDim.addRange(fieldNum(inventDim, InventSerialId)).value(queryValue(workInventDim.InventSerialId));
        }

        return qbrsInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeWorkInventDimFromInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes work inventory dimensions from inventory transaction.
    /// </summary>
    /// <param name = "_inventTrans">Inventory transaction for temporary work line.</param>
    /// <param name = "_batchAboveLocation">A boolean flag. True when batch number is above location; else false.</param>
    /// <param name = "_serialAboveLocation">A boolean flag. True when serial number is above location; else false.</param>
    protected void initializeWorkInventDimFromInventTrans(InventTrans _inventTrans, boolean _batchAboveLocation, boolean _serialAboveLocation)
    {
        InventDim localInventDim = _inventTrans.inventDim();
        if (_serialAboveLocation)
        {
            workInventDim.InventSerialId = localInventDim.inventSerialId;
        }

        if (_batchAboveLocation)
        {
            workInventDim.inventBatchId = localInventDim.inventBatchId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProdParmforCoByProduct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an entry in Production Parameters table for Batch Order with one co/by product
    /// </summary>
    protected void insertProdParmforCoByProduct()
    {
        InventDim   inventDimLocal;
        ParmId      parmId          = NumberSeq::newGetNum(CompanyInfo::numRefParmId()).num();
        TransDate   transDate       = globalTransDate ? globalTransDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        PmfProdCoBy pmfProdCoBy     = PmfProdCoBy::findByProdIdItemIdInventDim(prodTable.ProdId, itemId, coByProductInventDim);

        ttsbegin;
        if (pmfProdCoBy.RecId)
        {
            inventDimLocal = InventDim::find(pmfProdCoBy.InventDimId);
        }
        else if (coByProductInventDim.InventDimId)
        {
            inventDimLocal = InventDim::find(coByProductInventDim.InventDimId);
        }
        else
        {
            inventDimLocal = InventDim::find(prodTable.InventDimId);
        }

        inventDimLocal.wMSLocationId     = prodTable.defaultOutputLocation(
            pmfProdCoBy.RecId ? pmfProdCoBy.ItemId : prodTable.ItemId, transDate, '', inventDimLocal);
        inventDimLocal.LicensePlateId    = this.parmTargetLicensePlateId();
        inventDimLocal.inventBatchId     = this.parmInventBatchId();
        inventDimLocal                   = InventDim::findOrCreate(inventDimLocal);
        workInventDim.initFromInventDim(inventDimLocal);

        this.initProdParmReportFinishedMainProductForCoByProduct(inventDimLocal, parmId, pmfProdCoBy, transDate);

        this.initProdParmReportFinishedReportedProductForCoByProduct(inventDimLocal, parmId, pmfProdCoBy, transDate);
        prodParmReportFinishedReportedProduct.insert();
        
        prodParmReportFinishedMainProduct.AcceptError = prodParmReportFinishedReportedProduct.AcceptError;
        prodParmReportFinishedMainProduct.insert();

        ttscommit;

        inventDim     = inventDimLocal;
        inventTransId = prodParmReportFinishedReportedProduct.InventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProdParmReportFinishedMainProductForCoByProduct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>ProdParmReportFinished</c> for finished main product record for Batch Order with one co/by product.
    /// </summary>
    /// <param name = "_inventDimLocal">
    /// A <c>InventDim</c> record
    /// </param>
    /// <param name = "_parmId">
    /// The generated <c>ParmId</c>
    /// </param>
    /// <param name = "_pmfProdCoBy">
    /// A <c>PmfProdCoBy</c> record
    /// </param>
    /// <param name = "_transDate">
    /// The current date.
    /// </param>
    protected void initProdParmReportFinishedMainProductForCoByProduct(InventDim _inventDimLocal, ParmId _parmId, PmfProdCoBy _pmfProdCoBy, TransDate _transDate)
    {
        prodParmReportFinishedMainProduct.initParmDefault();
        prodParmReportFinishedMainProduct.initFromProdParametersDim(prodTable.prodParametersDim());
        prodParmReportFinishedMainProduct.initFromProdTable(prodTable);
        prodParmReportFinishedMainProduct.ParmId            = _parmId;
        prodParmReportFinishedMainProduct.ErrorCause        = ProdErrorCause::None;
        prodParmReportFinishedMainProduct.ReportFinishProd  = NoYes::No;
        prodParmReportFinishedMainProduct.QtyGood           = 0;
        prodParmReportFinishedMainProduct.QtyError          = 0;
        prodParmReportFinishedMainProduct.bomAutoConsump    = BOMAutoConsump::Never;
        prodParmReportFinishedMainProduct.EndJob            = false;
        prodParmReportFinishedMainProduct.LineNum           = 1;
        prodParmReportFinishedMainProduct.TransDate         = _transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProdParmReportFinishedReportedProductForCoByProduct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>ProdParmReportFinished</c> for finished reported product record for Batch Order with one co/by product.
    /// </summary>
    /// <param name = "_inventDimLocal">
    /// A <c>InventDim</c> record
    /// </param>
    /// <param name = "_parmId">
    /// The generated <c>ParmId</c>
    /// </param>
    /// <param name = "_pmfProdCoBy">
    /// A <c>PmfProdCoBy</c> record
    /// </param>
    /// <param name = "_transDate">
    /// The current date.
    /// </param>
    protected void initProdParmReportFinishedReportedProductForCoByProduct(InventDim _inventDimLocal, ParmId _parmId, PmfProdCoBy _pmfProdCoBy, TransDate _transDate)
    {
        prodParmReportFinishedReportedProduct.initParmDefault();
        prodParmReportFinishedReportedProduct.pmfInitFromInventTable(InventTable::find(itemId));
        prodParmReportFinishedReportedProduct.AcceptError = acceptError;

        if (_pmfProdCoBy.RecId) // ProdJournalProd.insert will create pmfProdCoBy entry on-the-fly
        {
            prodParmReportFinishedReportedProduct.pmfInitFromProdCoBy(_pmfProdCoBy);
        }
        else
        {
            prodParmReportFinishedReportedProduct.ProdId = prodTable.ProdId;
        }

        prodParmReportFinishedReportedProduct.InventDimId       = _inventDimLocal.InventDimId;
        prodParmReportFinishedReportedProduct.ParmId            = _parmId;
        prodParmReportFinishedReportedProduct.ErrorCause        = ProdErrorCause::None;
        prodParmReportFinishedReportedProduct.ReportFinishProd  = NoYes::No;

        if (PdsGlobal::pdsIsCWItem(prodParmReportFinishedReportedProduct.ItemId))
        {
            prodParmReportFinishedReportedProduct.QtyGood           = this.parmCatchWeight();
            prodParmReportFinishedReportedProduct.PdsCWBatchGood    = this.parmInventHandlingQty();
        }
        else
        {
            prodParmReportFinishedReportedProduct.QtyGood           = this.parmInventHandlingQty();
            prodParmReportFinishedReportedProduct.PdsCWBatchGood    = 0;
        }

        prodParmReportFinishedReportedProduct.QtyError          = 0;
        prodParmReportFinishedReportedProduct.bomAutoConsump    = BOMAutoConsump::Never;
        prodParmReportFinishedReportedProduct.EndJob            = this.parmEndJob();
        prodParmReportFinishedReportedProduct.LineNum           = 2;
        prodParmReportFinishedReportedProduct.TransDate         = _transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProductionParametersInventDimForProductionOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the inventory dimensions for the production parameters for a standard production order.
    /// </summary>
    /// <returns>The initialized inventory dimensions.</returns>
    protected InventDim initializeProductionParametersInventDimForProductionOrder()
    {
        InventDim localInventDim         = InventDim::find(prodTable.InventDimId);
        localInventDim.wMSLocationId     = prodTable.defaultOutputLocation(prodParmReportFinishedMainProduct.ItemId, prodParmReportFinishedMainProduct.TransDate, '', localInventDim);
        localInventDim.LicensePlateId    = this.parmTargetLicensePlateId();
       
        if (this.parmInventBatchId())
        {
            localInventDim.InventBatchId = this.parmInventBatchId();
        }
        
        if (this.parmInventSerialId())
        {
            localInventDim.InventSerialId = this.parmInventSerialId();
        }

        // If receiving in with disposition code, then use the corresponding inventory status.
        if (inventStatusId)
        {
            localInventDim.InventStatusId = inventStatusId;
        }

        return localInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProdParmForProdItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an entry in Production Parameters table for a standard Production Order.
    /// </summary>
    protected void insertProdParmForProdItem()
    {
        ttsbegin;

        this.initProdParmReportFinishedMainProductForProdItem();

        inventDim = this.initializeProductionParametersInventDimForProductionOrder();
        inventDim = InventDim::findOrCreate(inventDim);
        workInventDim.initFromInventDim(inventDim);

        this.setProdParmReportFinishedMainProductFieldsForProdItem();
        if (!prodParmReportFinishedMainProduct.validateWrite())
        {
            throw error(strFmt("@WAX:WHSCannotInsertRecordInTable", tablePName(ProdParmReportFinished)));
        }

        prodParmReportFinishedMainProduct.insert();

        inventTransId                         = prodParmReportFinishedMainProduct.InventTransId;
        prodParmReportFinishedReportedProduct = prodParmReportFinishedMainProduct;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProdParmReportFinishedMainProductForProdItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>ProdParmReportFinished</c> for finished main product record for a standard Production Order.
    /// </summary>
    protected void initProdParmReportFinishedMainProductForProdItem()
    {
        prodParmReportFinishedMainProduct.clear();
        prodParmReportFinishedMainProduct.initParmDefault();
        prodParmReportFinishedMainProduct.initFromProdTable(prodTable);

        if (globalTransDate)
        {
            prodParmReportFinishedMainProduct.TransDate = globalTransDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProdParmReportFinishedMainProductFieldsForProdItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets fields on the <c>ProdParmReportFinished</c> for finished main product record for a standard Production Order.
    /// </summary>
    protected void setProdParmReportFinishedMainProductFieldsForProdItem()
    {
        prodParmReportFinishedMainProduct.InventDimId       = inventDim.InventDimId;
        prodParmReportFinishedMainProduct.InventTransId     = prodTable.InventTransId;
        prodParmReportFinishedMainProduct.ParmId            = NumberSeq::newGetNum(CompanyInfo::numRefParmId()).num();
        if (PdsGlobal::pdsIsCWItem(prodParmReportFinishedMainProduct.ItemId))
        {
            prodParmReportFinishedMainProduct.QtyGood           = this.parmCatchWeight();
            prodParmReportFinishedMainProduct.PdsCWBatchGood    = this.parmInventHandlingQty();
        }
        else
        {
            prodParmReportFinishedMainProduct.QtyGood           = this.parmInventHandlingQty();
        }
        
        prodParmReportFinishedMainProduct.bomAutoConsump    = BOMAutoConsump::FlushingPrincip;
        prodParmReportFinishedMainProduct.AcceptError       = acceptError;
        prodParmReportFinishedMainProduct.ReportFinishProd  = NoYes::No;
        prodParmReportFinishedMainProduct.EndJob            = this.parmEndJob();
        prodParmReportFinishedMainProduct.RespectFlushingPrincipleForWHSReportedOverproduction = this.parmRespectFlushingPrinciple();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustRegisterProductionOrderHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Determines whether the handling quantity must be registered for the production order.
    /// </summary>
    /// <returns>true if the handling quantity must be registered for the production order; otherwise, false.</returns>
    [Wrappable(true)]
    internal boolean mustRegisterProductionOrderHandlingQty()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(Common _common, WHSWorkCreateId _workCreateId = '')
    {
        prodTable = _common;

        workCreateId = _workCreateId ? _workCreateId : NumberSeq::newGetNum(WHSParameters::numRefWHSWorkCreateId()).num();

        reportAsFinished = true;

        super(prodTable, workCreateId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBatchDispCode</Name>
				<Source><![CDATA[
    public PdsBatchDispositionCode parmBatchDispCode(PdsBatchDispositionCode _batchDispCode = batchDispCode)
    {
        batchDispCode = _batchDispCode;

        return batchDispCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBatchExpDate</Name>
				<Source><![CDATA[
    public InventBatchExpDate parmBatchExpDate(InventBatchExpDate _batchExpDate = batchExpDate)
    {
        batchExpDate = _batchExpDate;

        return batchExpDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBatchPotencyValue</Name>
				<Source><![CDATA[
    public PdsBatchAttribValue parmBatchPotencyValue(PdsBatchAttribValue _batchPotencyValue = batchPotencyValue)
    {
        batchPotencyValue = _batchPotencyValue;

        return batchPotencyValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDim</Name>
				<Source><![CDATA[
    public InventDim parmInventDim(InventDim _inventDim)
    {
        inventDim = _inventDim;

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCoByProductInventDim</Name>
				<Source><![CDATA[
    public InventDim parmCoByProductInventDim(InventDim _coByProductInventDim)
    {
        coByProductInventDim = _coByProductInventDim;

        return coByProductInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventQty</Name>
				<Source><![CDATA[
    public InventQty parmInventQty(InventQty _inventQty = inventQty)
    {
        return this.parmInventHandlingQty(_inventQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventHandlingQty</Name>
				<Source><![CDATA[
    public InventHandlingQty parmInventHandlingQty(InventHandlingQty _inventHandlingQty = inventHandlingQty)
    {
        inventHandlingQty = _inventHandlingQty;

        return inventHandlingQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCatchWeight</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WHSTransWeight parmCatchWeight (WHSTransWeight _catchWeight = catchWeight)
    {
        catchWeight = _catchWeight;

        return catchWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemId</Name>
				<Source><![CDATA[
    public ItemId parmItemId(ItemId _itemId = itemId)
    {
        itemId = _itemId;

        return itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportAsFinished</Name>
				<Source><![CDATA[
    public boolean parmReportAsFinished(boolean _reportAsFinished = reportAsFinished)
    {
        reportAsFinished = _reportAsFinished;

        return reportAsFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWorkCreateId</Name>
				<Source><![CDATA[
    public WHSWorkCreateId parmWorkCreateId(WHSWorkCreateId _workCreateId = workCreateId)
    {
        workCreateId = _workCreateId;

        return workCreateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructor method for the class instances.
    /// </summary>
    /// <param name="_common">
    /// Common record to be used to construct instance.
    /// </param>
    /// <param name="_workCreateId">
    /// Work creation id to be used to construct instance.
    /// </param>
    /// <returns>
    /// The <c>WHSWorkCreateProdPut</c> instance.
    /// </returns>
    static WHSWorkCreateProdPut construct(Common _common, WHSWorkCreateId _workCreateId = '')
    {
        WHSWorkCreateProdPut    workCreateProdPut;

        workCreateProdPut = new WHSWorkCreateProdPut(_common, _workCreateId);

        return workCreateProdPut;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReportFinishedParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>ProdParmReportFinished</c> records.
    /// </summary>
    protected void createReportFinishedParameters()
    {
        pmfProductType = InventTable::find(itemId).PmfProductType;

        switch (pmfProductType)
        {
            case PmfProductType::BOM,
            PmfProductType::None,
            PmfProductType::Formula:
                this.insertProdParmForProdItem();
                break;

            case PmfProductType::By_Product,
            PmfProductType::Co_Product:
                this.insertProdParmForCoByProduct();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPutWorkCreationAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if put work creation is allowed.
    /// </summary>
    /// <param name = "_inventDim">The inventory dimension record.</param>
    /// <param name = "_itemId">The item number; optional.</param>
    /// <returns>true if work creation is allowed; otherwise, false.</returns>
    protected boolean isPutWorkCreationAllowed(
        InventDim   _inventDim,
        ItemId      _itemId = '')
    {
        WHSWorkTransType        workTransTypeLocal;
        ItemId                  itemIdLocal;

        [itemIdLocal, workTransTypeLocal] = this.getItemIdWorkTransType();

        if (!prmIsDefault(_itemId))
        {
            itemIdLocal = _itemId;
        }

        boolean isWorkAllowedToBeCreated = WHSWorkPolicy::isWorkAllowedToBeCreated(workTransTypeLocal, _inventDim.InventLocationId, _inventDim.wMSLocationId, itemIdLocal);

        // for project related production supply marked to real (e.g. sales) demand ensure a putaway work is created
        if (isWorkAllowedToBeCreated)
        {
            isWorkAllowedToBeCreated = (!prodTable.ProjId || prodTable.ProjLinkedToOrder);
        }

        return isWorkAllowedToBeCreated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemIdWorkTransType</Name>
				<Source><![CDATA[
    private container getItemIdWorkTransType()
    {
        WHSWorkTransType workTransTypeLocal;
        ItemId           itemIdLocal;

        switch (pmfProductType)
        {
            case PmfProductType::BOM:
            case PmfProductType::None:
            case PmfProductType::Formula:
                workTransTypeLocal = WHSWorkTransType::ProdPut;
                itemIdLocal = prodParmReportFinishedMainProduct.ItemId;
                break;
            case PmfProductType::By_Product:
            case PmfProductType::Co_Product:
                workTransTypeLocal = WHSWorkTransType::ProdProcessPut;
                itemIdLocal = prodParmReportFinishedReportedProduct.ItemId;
                break;
        }

        return [itemIdLocal, workTransTypeLocal];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeWorkForProductionLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes work for a production line
    /// </summary>
    /// <param name = "_itemId">The item id.</param>
    /// <param name = "_pmfProductType">The product type.</param>
    /// <param name = "_inventDim">The inventory dimension.</param>
    /// <param name = "_inventTransId">The inventory transaction id.</param>
    /// <param name = "_inventHandlingQty">The quantity.</param>
    /// <param name = "_catchWeight">The transaction weight.</param>
    protected void initializeWorkForProductionLine(
        ItemId              _itemId,
        PmfProductType      _pmfProductType,
        InventDim           _inventDim,
        InventTransId       _inventTransId,
        InventHandlingQty   _inventHandlingQty,
        WHSTransWeight      _catchWeight)
    {
        if (!createdBy)
        {
            createdBy = curUserId();
        }

        itemId          = _itemId;
        pmfProductType  = _pmfProductType;
        inventDim       = _inventDim;

        workInventDim.initFromInventDim(inventDim);
        inventTransId          = _inventTransId;
        inventHandlingQty      = _inventHandlingQty;
        catchWeight            = _catchWeight;

        if (inventDim.LicensePlateId)
        {
            targetLicensePlateId = inventDim.LicensePlateId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initWorkCreateBatchId</Name>
				<Source><![CDATA[
    private void initWorkCreateBatchId()
    {
        inventBatchId = workInventDim.inventBatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkForProductionLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create work for production put.
    /// </summary>
    /// <returns>The work build id of the created work.</returns>
    protected WHSWorkBuildId createWorkForProductionLine()
    {
        return this.createWork();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkFromProdParmReportFinished</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates putaway work for items that are being reported as finished, if the policy allows it.
    /// </summary>
    /// <param name="_prodParmReportFinished">
    /// <c>ProdParmReportFinished</c> record containing information of items being RAF'ed.
    /// </param>
    /// <returns>
    /// Work Build Id for the work that is created.
    /// </returns>
    public WHSWorkBuildId createWorkFromProdParmReportFinished(ProdParmReportFinished _prodParmReportFinished)
    {
        InventDim       inventDimLocal = InventDim::find(_prodParmReportFinished.InventDimId);
        WHSWorkBuildId  ret = '';

        this.initPmfProductType(_prodParmReportFinished.PmfProductType);

        if (this.isPutWorkCreationAllowed(inventDimLocal, _prodParmReportFinished.ItemId))
        {
            InventHandlingQty handlingQty;
            WHSTransWeight    curCatchWeight;
            if (PdsGlobal::pdsIsCWItem(_prodParmReportFinished.ItemId))
            {
                handlingQty = _prodParmReportFinished.PdsCWBatchGood;
                curCatchWeight = _prodParmReportFinished.QtyGood;
            }
            else
            {
                handlingQty = _prodParmReportFinished.QtyGood;
                curCatchWeight = 0;
            }

            this.initializeWorkForProductionLine(
                _prodParmReportFinished.ItemId,
                _prodParmReportFinished.PmfProductType,
                inventDimLocal,
                _prodParmReportFinished.InventTransId,
                handlingQty,
                curCatchWeight);
            ret = this.createWorkForProductionLine();
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkFromRAFJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates putaway work for RAF journal lines that are being reported as finished, if the policy allows it.
    /// </summary>
    /// <param name="_rafJournalLine">
    /// Journal lines for which work should be created.
    /// </param>
    /// <returns>
    /// Work Build Id of the created work.
    /// </returns>
    public WHSWorkBuildId createWorkFromRAFJournalLine(ProdJournalProd _rafJournalLine)
    {
        InventDim       inventDimLocal = _rafJournalLine.InventDim();
        WHSWorkBuildId  ret = '';

        this.initPmfProductType(_rafJournalLine.PmfProductType);

        if (this.isPutWorkCreationAllowed(inventDimLocal, _rafJournalLine.ItemId))
        {
            InventHandlingQty handlingQty;
            WHSTransWeight    curCatchWeight;
            if (PdsGlobal::pdsIsCWItem(_rafJournalLine.ItemId))
            {
                handlingQty = _rafJournalLine.PdsCWBatchGood;
                curCatchWeight = _rafJournalLine.QtyGood;
            }
            else
            {
                handlingQty = _rafJournalLine.QtyGood;
                curCatchWeight = 0;
            }

            rafJournalId = _rafJournalLine.JournalId;

            this.initializeWorkForProductionLine(
                _rafJournalLine.ItemId,
                _rafJournalLine.PmfProductType,
                inventDimLocal,
                _rafJournalLine.InventTransId,
                handlingQty,
                curCatchWeight);
            this.initWorkCreateBatchId();
            ret = this.createWorkForProductionLine();
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPmfProductType</Name>
				<Source><![CDATA[
    private void initPmfProductType(PmfProductType _pmfProductType)
    {
        pmfProductType = _pmfProductType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs production order quantity validation.
    /// </summary>
    protected void validateQuantity()
    {
        boolean finished = this.parmEndJob();
        JmgProdQuantityValidation::constructFromProdIdAndItem(ProdTable.ProdId, ItemId).validateFeedbackQuantity(this.parmInventHandlingQty(), true, finished, null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEndJob</Name>
				<Source><![CDATA[
    public NoYesId parmEndJob(NoYesId _endJob = endJob)
    {
        endJob = _endJob;

        return endJob;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRAFJournalId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets or sets RAFJournalId.
    /// </summary>
    /// <param name = "_rafJournalId">
    ///     ProdJournalId that sets RAFJournalId, Optional.
    /// </param>
    /// <returns>
    ///     The updated ProdJournalId.
    /// </returns>
    public ProdJournalId parmRAFJournalId(ProdJournalId _rafJOurnalId = rafJournalId)
    {
        rafJournalId = _rafJOurnalId;
        return rafJournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRespectFlushingPrinciple</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal ProdRespectFlushingPrincipleForWHSReportedOverproduction
         parmRespectFlushingPrinciple(ProdRespectFlushingPrincipleForWHSReportedOverproduction _respectFlushingPrinciple = respectFlushingPrinciple)
    {
        respectFlushingPrinciple = _respectFlushingPrinciple;
        return respectFlushingPrinciple;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransDate</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal TransDate parmTransDate(TransDate _transDate = globalTransDate)
    {
        globalTransDate = _transDate;

        return globalTransDate;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>