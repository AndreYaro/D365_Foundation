<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustInterestCreate</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class CustInterestCreate extends RunBaseBatch implements BatchRetryable
{
    //
    // Dialog field values
    //
    NoYes includeInvoices;
    NoYes includeCredits;
    NoYes includePayments;
    NoYes includeInterestTrans;
    TransDate fromDate;
    TransDate toDate;
    AmountCur roundOff;
    InterestCalcAccountChoice postingSpec;
    CustPostingProfile postingProfile;

    //
    // Dialog fields
    //
    DialogField dialogInterestOnInvoices;
    DialogField dialogInterestOnNotes;
    DialogField dialogInterestOnPayments;
    DialogField dialogInterestOnInterest;
    DialogField dialogFromDate;
    DialogField dialogToDate;
    DialogField dialogRoundOff;
    DialogField dialogPostingSpec;
    DialogField dialogPostingProfile;

    QueryRun queryRun;
    private container packedQuery;

    boolean isCompanyCurrencyUsed;
    boolean isCurrencyConversionRequired;

    CustInterest custInterest;
    CustInterestVersion custInterestVersion;
    CustInterestVersionDetail custInterestVersionDetail;
    CustInterestFee custInterestFee;

    RecordSortedList custInterestTransList;

    AmountCur interestSum;
    LineNum lineNum;
    boolean interestFound;
    Set interestCalculationResultSet;
    boolean interestNoteCreated;
    boolean transactionHasValidFilter;
    boolean transactionHasValidVersion;

    FormStringControl dialogBillingClassificationNames;
    int dialogBillingClassificationNamesId;
    DialogField dialogInclTransWithNoBillingClassifications;

    str billingClassificationNames;
    str billingClassificationIds;

    NoYes inclTransWithNoBillingClassifications;
    RefRecId currentCustBillingClassificationId;
    RecordSortedList custInterestTransLineList;

    CustInterestTransLine custInterestTransLine;
    CustInterestCodeSource interestCodeSource;
    Map custInterestTransLineIdRefMap, custInterestTransLineNumMap;
    LineNum custInterestTransLineIdRefLineNum,custInterestTransLineNum;
    CustInterestTransLineIdRef custInterestTransLineIdRef;

    int interestLineReferencePeriodNum;
    Integer interestTransDays;
    Integer interestTransDaysCurr;

    boolean skippedFreeTextInvoice;
    container freeTextInvoiceLineInfoMessage;

    SysLookupMultiSelectCtrl custBillingClassificationLookup;
    boolean isBillingClassificationEnabled;
    LanguageId customerLanguage;

    //
    // Messages and progress
    //
    Counter progressCounter;
    str logPrefix;
    str companyCurrencyMsg;

    //
    // Parameters from args.record() and args.parmEnum()
    //
    Set custAccountsRestriction;
    RefRecId custTransRestriction;
    NoYes interestNoteForSelectedInvoice; // If true, only for selected invoice else for all invoices

    PaymCalendarCustInterest paymCalendarCustInterest;
    DueDate interestStartDate;
    PositiveDays interestGraceDays;

    private const int numberOfTasks = 8;
    private const int RetryInterval = 500;
    private boolean isChildTask = false;
    private boolean isFinalTask = false;
    private guid processId;
    private CustInstrumentationLogger custInstrumentationLogger;

    #DEFINE.CurrentVersion(12)

    #LOCALMACRO.CurrentList
        includeInvoices,
        includeCredits,
        includePayments,
        includeInterestTrans,
        postingSpec,
        fromDate,
        toDate,
        RoundOff,
        PostingProfile,
        custTransRestriction,
        billingClassificationNames,
        billingClassificationIds,
        inclTransWithNoBillingClassifications,
        isBillingClassificationEnabled
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcInterestAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the amount of interest charged for the given transaction amount.
    /// </summary>
    /// <param name="_custTable">
    /// A <c>CustTable</c> record.
    /// </param>
    /// <param name="_custTrans">
    /// A <c>CustTrans</c> record.
    /// </param>
    /// <param name="_calcFrom">
    ///    The start date of the calculation period.
    /// </param>
    /// <param name="_calcTo">
    ///    The end date of the calculation period.
    /// </param>
    /// <param name="_interestDays">
    ///    Cumulative days of interest.
    /// </param>
    /// <param name="_calculationAmount">
    ///    The transaction amount against which to charge the interest.
    /// </param>
    /// <param name="_dueDate">
    ///    The due date of the transaction.
    /// </param>
    /// <returns>
    ///    A container with [calculated interest amount, error value, interestDays, percent, transactionMsg].
    /// </returns>
    protected container calcInterestAmount(CustTable _custTable, CustTrans _custTrans, TransDate _calcFrom, TransDate _calcTo, Integer _interestDays,
        AmountCur _calculationAmount, TransDate _dueDate)
    {
        Counter counter;
        Counter rangeCounter;
        Counter rangeDays;
        AmountCur amountCur;
        CustInterestValue interestValue;
        CurrencyCode currency;
        AmountCur minInterestAmt;
        AmountCur maxInterestAmt;
        CustInterestFeeType custInterestFeeType;
        CustInterestFee custInterestFeeAmount;
        Percent percent = 0;
        TransTxt transactionMsg;

        custInterestFeeType = CustInterestCreate::custInterestFeeType(_calculationAmount);

        customerLanguage = this.getDescriptionLanguage(_custTable);

        [_interestDays, counter] = this.determineInterestDays(_calcFrom, _calcTo, _interestDays);
        
        if (_custTable.CustExcludeInterestCharges)
        {
            return this.getContainerForCalcInterestAmount(0, _interestDays, percent, transactionmsg);
        }

        if (CustInterestCalculateRangeDaysFromDueDateFlight::instance().isEnabled())
        {
            [rangeDays, rangeCounter] = this.determineRangeDays(((_custTrans.DueDate? _custTrans.DueDate: _custTrans.TransDate) + 1),
                                                                _calcTo);
        }
        else
        {
            [rangeDays, rangeCounter] = this.determineRangeDays(_calcFrom, _calcTo);
        }

        if (custInterestVersionDetail.InterestCalcType == CustInterestCalcType::Percentage)
        {
            [percent, currency] = this.determinePercentCurrencyBasedOnCustInterestType(_custTable, _custTrans, _calculationAmount, rangeCounter);

            if (percent == 0 && !custInterestFee.Fee && _calculationAmount != 0)
            {
                return this.getContainerForCalcInterestAmount(0, _interestDays, percent, transactionmsg, CustInterestCreationErrorType::ZeroValueIntCode);
            }

            [amountCur, minInterestAmt, maxInterestAmt, transactionMsg] = this.determineInterestValuesBasedOnCustInterestCalcTypePercentage(_calculationAmount, percent, counter, _calcFrom, _calcTo, currency);
        }
        else if (custInterestVersionDetail.InterestCalcType == CustInterestCalcType::Amount)
        {
            [interestValue, currency] = this.interestValue(_custTable, _custTrans, _calculationAmount, rangeCounter);

            transactionMsg = strFmt("@SYS128235", interestValue, currency, custInterestVersionDetail.InterestInterval, custInterestVersionDetail.InterestCalculate);

            if (interestValue == 0 && !custInterestFee.Fee && _calculationAmount != 0)
            {
                return this.getContainerForCalcInterestAmount(0, _interestDays, percent, transactionmsg, CustInterestCreationErrorType::ZeroValueIntCode);
            }

            amountCur = interestValue * counter;
        }

        if (_calculationAmount < 0)
        {
            amountCur = amountCur * -1;
        }

        amountCur = CustInterestCreate::getAdjustedInterestAmount(amountCur, _custTrans.RecId);

        return this.getContainerForCalcInterestAmount(amountCur, _interestDays, percent, transactionmsg);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContainerForCalcInterestAmount</Name>
				<Source><![CDATA[
    private container getContainerForCalcInterestAmount(AmountCur _calculatedInterestAmount, PositiveDays _interestDays, Percent _percent,
        TransTxt _transactionMsg, CustInterestCreationErrorType _errorType = CustInterestCreationErrorType::ValidTransaction)
    {
        return [_calculatedInterestAmount, _errorType, _interestDays, _percent, _transactionMsg];
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineInterestDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the cumulative number of days of interest.
    /// </summary>
    /// <param name="_calcFrom">The start date of the calculation period.</param>
    /// <param name="_calcTo">The end date of the calculation period.</param>
    /// <param name="_interestDays">Cumulative days of interest.</param>
    /// <returns>A <c>container</c> holding the days of interest and the number of intervals of calculation.</returns>
    protected container determineInterestDays(TransDate _calcFrom, TransDate _calcTo, PositiveDays _interestDays)
    {
        Counter counter = 1;
        while (_calcFrom + _interestDays <= _calcTo)
        {
            if (this.checkUnitIsDay())
            {
                _interestDays += custInterestVersionDetail.InterestInterval;
            }
            else
            {
                if (_calcFrom == endmth(_calcFrom))
                {
                    _interestDays = endmth(dateMthFwd(_calcFrom, counter * custInterestVersionDetail.InterestInterval)) - _calcFrom;
                }
                else
                {
                    _interestDays = dateMthFwd(_calcFrom, counter * custInterestVersionDetail.InterestInterval) - _calcFrom;
                }
            }
            counter++;
        }
        counter--;

        return [_interestDays, counter];
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUnitIsDay</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the unit is a flavor of Day.
    /// </summary>
    /// <returns>
    ///     true if the unit is a flavor of Day; otherwise, false.
    /// </returns>
    protected boolean checkUnitIsDay()
    {
        return custInterestVersionDetail.InterestCalculate == CustInterestTimeUnit::Day ||
               custInterestVersionDetail.InterestCalculate == CustInterestTimeUnit::CalendarDay;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineRangeDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the range of days of interest.
    /// </summary>
    /// <param name="_calcFrom">The start date of the calculation period.</param>
    /// <param name="_calcTo">The end date of the calculation period.</param>
    /// <returns>A <c>container</c> holding the range of days and the number of range day intervals.</returns>
    protected container determineRangeDays(TransDate _calcFrom, TransDate _calcTo)
    {
        Counter rangeCounter = 1;
        Counter rangeDays = 0;

        while (_calcFrom + rangeDays <= _calcTo)
        {
            if (custInterestVersionDetail.InterestByRange == CustInterestByRange::Day)
            {
                rangeDays += custInterestVersionDetail.InterestInterval;
            }
            else
            {
                if (_calcFrom == endmth(_calcFrom))
                {
                    rangeDays = endmth(dateMthFwd(_calcFrom, rangeCounter * custInterestVersionDetail.InterestInterval)) - _calcFrom;
                }
                else
                {
                    rangeDays = dateMthFwd(_calcFrom, rangeCounter * custInterestVersionDetail.InterestInterval) - _calcFrom;
                }
            }
            rangeCounter ++;
        }

        rangeCounter--;

        return [rangeDays, rangeCounter];
    }

]]></Source>
			</Method>
			<Method>
				<Name>determinePercentCurrencyBasedOnCustInterestType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the percent and currency values based on the <c>CustInterestType</c> enumeration value on the <c>CustInterest</c> record.
    /// </summary>
    /// <param name="_custTable">A <c>CustTable</c> record.</param>
    /// <param name="_custTrans">A <c>CustTrans</c> record.</param>
    /// <param name="_calculationAmount">The transaction amount against which to charge the interest.</param>
    /// <param name = "_rangeCounter">The day and month of the transaction.</param>
    /// <returns>A <c>container</c> holding the percent and currency values.</returns>
    protected container determinePercentCurrencyBasedOnCustInterestType(CustTable _custTable, CustTrans _custTrans, AmountCur _calculationAmount, Counter _rangeCounter)
    {
        Percent percent = 0;
        CurrencyCode currency;
        
        if (custInterest.CustInterestType == CustInterestType::SingleRate)
        {
            [percent, currency] = this.interestPercent(_custTable, _custTrans, _calculationAmount, _rangeCounter);
        }
        else
        {
            if (custInterestVersion)
            {
                percent = custInterestVersionDetail.InterestPercent;
                currency = _custTable.Currency;
            }
        }

        return [percent, currency];
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineInterestValuesBasedOnCustInterestCalcTypePercentage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines interest calculation value based on the <c>CustInterestVersionDetail</c> buffer having a <c>CustInterestCalcType</c> enumeration value of percentage.
    /// </summary>
    /// <param name="_calculationAmount">The transaction amount against which to charge the interest.</param>
    /// <param name = "_percent">The interest percentage.</param>
    /// <param name = "_counter">The number of intervals from which to base the calculation.</param>
    /// <param name="_calcFrom">The start date of the calculation period.</param>
    /// <param name="_calcTo">The end date of the calculation period.</param>
    /// <param name="_currency">The currency code for the customer.</param>
    /// <returns>A <c>container</c> containing calculated interest values.</returns>
    protected container determineInterestValuesBasedOnCustInterestCalcTypePercentage(AmountCur _calculationAmount, Percent _percent, Counter _counter,
        TransDate _calcFrom, TransDate _calcTo, CurrencyCode _currency)
    {
        TransTxt transactionMsg;
        
        AmountCur amountCur = this.determineAmountBasedOnCustInterestTimeUnit(_calculationAmount, _percent, _counter, _calcFrom, _calcTo);

        CustInterestFee custInterestFeeAmount = CustInterestFee::findByCustInterestVersionDetail(custInterestVersionDetail.RecId, _currency);

        AmountCur minInterestAmt = custInterestFeeAmount.MinimumInterestAmount;

        AmountCur maxInterestAmt = custInterestFeeAmount.MaximumInterestAmount;

        if (minInterestAmt > amountCur && minInterestAmt != 0)
        {
            amountCur = minInterestAmt;
            minInterestAmt = _calculationAmount < 0 ? minInterestAmt * -1 : minInterestAmt;
            transactionMsg = strFmt("@SYS128236", minInterestAmt, _currency);
            isCurrencyConversionRequired = true;
        }

        if (maxInterestAmt < amountCur && maxInterestAmt != 0)
        {
            amountCur = maxInterestAmt;
            maxInterestAmt = _calculationAmount < 0 ? maxInterestAmt * -1 : maxInterestAmt;
            transactionMsg = strFmt("@SYS128237", maxInterestAmt, _currency);
            isCurrencyConversionRequired = true;
        }

        if (!transactionMsg)
        {
            // Converting the label description to customer language.
            transactionMsg = strFmt(SysLabel::labelId2String(literalStr("@SYS128235"), customerLanguage),
                _percent,
                SysLabel::labelId2String(literalStr("@SYS77046"), customerLanguage),
                custInterestVersionDetail.InterestInterval,
                SysLabel::labelId2String(new DictEnum(enumNum(CustInterestTimeUnit)).index2LabelId(custInterestVersionDetail.InterestCalculate), customerLanguage));
        }

        return [amountCur, minInterestAmt, maxInterestAmt, transactionMsg];
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineAmountBasedOnCustInterestTimeUnit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the amount of the interest based on the <c>CustInterestTimeUnit</c> enumeration value on the <c>CustInterstVersionDetail</c> buffer.
    /// </summary>
    /// <param name="_calculationAmount">The transaction amount against which to charge the interest.</param>
    /// <param name = "_percent">The interest percentage.</param>
    /// <param name = "_counter">The number of intervals from which to base the calculation.</param>
    /// <param name="_calcFrom">The start date of the calculation period.</param>
    /// <param name="_calcTo">The end date of the calculation period.</param>
    /// <returns>The amount of interest.</returns>
    protected AmountCur determineAmountBasedOnCustInterestTimeUnit(AmountCur _calculationAmount, Percent _percent, Counter _counter, TransDate _calcFrom, TransDate _calcTo)
    {
        AmountCur amountCur;

        switch (custInterestVersionDetail.InterestCalculate)
        {
            case CustInterestTimeUnit::Day:
                amountCur = abs(_calculationAmount) * _percent * _counter * (custInterestVersionDetail.InterestInterval / 30) / 100;
                break;
            case CustInterestTimeUnit::CalendarDay:
                // The calendar day calculation assumes the from date is not included as part of
                // the calculation. Since the _calcFrom date passed has already been adjusted for
                // this, it is necessary to subract one day.
                amountCur = abs(_calculationAmount) * _percent * this.percentageWeightFactor(_calcFrom - 1, _calcTo) / 100;
                break;
            case CustInterestTimeUnit::Month:
                amountCur = abs(_calculationAmount) * _percent * _counter / 100;
                break;
        }

        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>percentageWeightFactor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate a weight factor for the monthly percentage rate based on the fractional and full months covered
    /// </summary>
    /// <param name = "_fromDate">Date from</param>
    /// <param name = "_toDate">Date to</param>
    /// <returns>Weight value</returns>
    protected final real percentageWeightFactor(TransDate _fromDate, TransDate _toDate)
    {
        // returns the ceiling (round away from zero) for a given positive value
        real ceiling(real r)
        {
            return trunc(r) + (frac(r) > 0 ? 1 : 0);
        }

        // returns the day number of the last day of the month for the given date
        int lastDayOfMth(date _date)
        {
            return dayOfMth(endmth(_date));
        }

        // Include the last part of the first month
        real weight = 1 - dayOfMth(_fromDate) / lastDayOfMth(_fromDate);

        // The ending date based on full intervals, always rounded up (ceiling)
        TransDate calcToInterval = _fromDate + custInterestVersionDetail.InterestInterval * ceiling((_toDate - _fromDate) / custInterestVersionDetail.InterestInterval);

        // Account for the number of months including the last month
        weight += mthOfYr(calcToInterval) - mthOfYr(_fromDate) + (year(calcToInterval) - year(_fromDate)) * 12;

        // Exclude the last of part of the last month
        weight -= (lastDayOfMth(calcToInterval) - dayOfMth(calcToInterval)) / lastDayOfMth(calcToInterval);

        return weight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPeriod</Name>
				<Source><![CDATA[
    protected boolean calcPeriod(CustTable _custTable, CustTrans _custTrans, CustInterestJour _custInterestJour, TransDate _calcFrom, TransDate _calcTo, TransDate _dueDate, boolean _resetInterestVersion, AmountCur _calculationAmount)
    {
        CustInterestCreationErrorType interestCalculationErrorType;
        TransDate nextFrom;
        TransDate endDate;
        AmountCur interestAmount;
        AmountCur interestAmountCalculated;
        boolean interestCalculationFailed = false;
        Integer interestDays = 0;
        Percent percent;
        TransTxt transactionMsg;

        nextFrom = _calcFrom;
        endDate = _calcTo;

        [_calcTo, interestDays] = this.setCalcTo(_calculationAmount, _calcFrom, _calcTo, endDate, interestDays, _resetInterestVersion);

        if (_calculationAmount)
        {
            while (nextFrom <= endDate)
            {
                [interestAmount, interestCalculationErrorType, interestDays, percent, transactionMsg] = this.calcInterestAmount(_custTable, _custTrans, _calcFrom, _calcTo, interestDays, _calculationAmount
                    // <GEEPL>
                    ,_dueDate
                    // </GEEPL>
                    );

                interestCalculationFailed = this.addToInterestCalculationResultSetBasedOnCustInterestCreationErrorType(interestCalculationErrorType);
                
                if (interestCalculationFailed)
                {
                    break;
                }

                [interestAmount, interestAmountCalculated] = this.calcInterestAmountBasedOnRoundOffAndCurrencyConversion(_custTable, _custTrans, _custInterestJour, interestAmount);
                                
                if (this.shouldInsertCustInterestTrans(interestAmount))
                {
                    lineNum++;
                    this.insertCustInterestTrans(_custInterestJour, interestAmount, _calculationAmount, _dueDate, _custTrans, _calcFrom, interestDays, percent, lineNum, transactionMsg, _custTrans.CurrencyCode);
                    interestSum += CurrencyExchangeHelper::mstAmount(interestAmountCalculated, _custTrans.CurrencyCode);
                    interestFound = true;
                }

                nextFrom = _calcFrom + interestDays;
                _calcFrom = nextFrom;
                [_calcTo, interestDays] = this.setCalcTo(_calculationAmount, _calcFrom, _calcTo, endDate, interestDays, true);
            }

            if (interestCalculationFailed)
            {
                return false;
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToInterestCalculationResultSetBasedOnCustInterestCreationErrorType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a <c>CustInterestCreationErrorType</c> enumeration to the result set if the transaction is not valid.
    /// </summary>
    /// <param name = "_custInterestCreationErrorType">The <c>CustInterestCreationErrorType</c> enumeration value.</param>
    /// <returns>true if the interest calculation failed; otherwise, false.</returns>
    protected boolean addToInterestCalculationResultSetBasedOnCustInterestCreationErrorType(CustInterestCreationErrorType _interestCalculationErrorType)
    {
        boolean interestCalculationFailed;

        if (_interestCalculationErrorType != CustInterestCreationErrorType::ValidTransaction)
        {
            interestCalculationResultSet.add(_interestCalculationErrorType);
            interestCalculationFailed = true;
        }

        return interestCalculationFailed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInterestAmountBasedOnRoundOffAndCurrencyConversion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the interest amount based off of the round off setting and the need for a currency conversion.
    /// </summary>
    /// <param name="_custTable">A <c>CustTable</c> record.</param>
    /// <param name="_custTrans">A <c>CustTrans</c> record.</param>
    /// <param name="_custInterestJour">A <c>CustInterestJour</c> record.</param>
    /// <param name="_originalInterestAmount">The original interest amount to base the calculation off of.</param>
    /// <returns>A <c>container</c> with the calculated interest amounts.</returns>
    protected container calcInterestAmountBasedOnRoundOffAndCurrencyConversion(CustTable _custTable, CustTrans _custTrans, CustInterestJour _custInterestJour, AmountCur _originalInterestAmount)
    {
        AmountCur interestAmount;
        AmountCur interestAmountCalculated;
        
        if (!this.roundOff())
        {
            interestAmount = CurrencyExchangeHelper::amount(_originalInterestAmount, _custTable.Currency);
        }
        else
        {
            interestAmount = round(_originalInterestAmount, this.roundOff());
        }

        interestAmountCalculated = interestAmount;
        _custInterestJour.TaxItemGroup = this.getTaxItemGroup(_custTable, interestAmount);

        if (_custTable.Currency != _custTrans.CurrencyCode && isCurrencyConversionRequired)
        {
            interestAmount = CurrencyExchangeHelper::curAmount2CurAmount(interestAmount, _custTable.Currency, _custTrans.CurrencyCode, this.toDate());
        }

        isCurrencyConversionRequired = false;

        return [interestAmount, interestAmountCalculated];
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldInsertCustInterestTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to insert into the <c>CustInterestTrans</c> table.
    /// </summary>
    /// <param name = "_interestAmount">The interest amount.</param>
    /// <returns>true if insert into the <c>CustInterestTrans</c> table is permitted; otherwise, false.</returns>
    protected boolean shouldInsertCustInterestTrans(AmountCur _interestAmount)
    {
        return _interestAmount || (custInterestFee.Fee && custInterest.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPeriodForInvoiceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates period for Invoice line.
    /// </summary>
    /// <param name="_tmpCustInterestTransLine">
    /// A <c>TmpCustInterestTransLine</c> record.
    /// </param>
    /// <param name="_custTable">
    /// A <c>CustTable</c> record.
    /// </param>
    /// <param name="_custTrans">
    /// A <c>CustTrans</c> record.
    /// </param>
    /// <param name="_custInterestJour">
    /// A <c>CustInterestJour</c> record.
    /// </param>
    /// <param name="_calcFrom">
    /// The start date of the calculation period.
    /// </param>
    /// <param name="_calcTo">
    /// The end date of the calculation period.
    /// </param>
    /// <param name="_dueDate">
    /// The due date of the calculation period.
    /// </param>
    /// <param name="_resetInterestVersion">
    /// A boolean value to reset the interestversion.
    /// </param>
    /// <returns>
    /// False if calculation failed. Otherwise true.
    /// </returns>
    protected boolean calcPeriodForInvoiceLine(TmpCustInterestTransLine _tmpCustInterestTransLine, CustTable _custTable, CustTrans _custTrans, CustInterestJour _custInterestJour, TransDate _calcFrom, TransDate _calcTo, TransDate _dueDate, boolean _resetInterestVersion)
    {
        CustInterestCreationErrorType interestCalculationErrorType;
        TransDate nextFrom;
        TransDate endDate;
        AmountCur interestAmountCalculated;
        boolean interestCalculationFailed = false;
        Integer interestDays = 0;
        Integer interestDaysCurr;
        Percent percent;
        TransTxt transactionMsg;
        AmountCur invoiceAmount = 0;
        AmountCur interestAmount = 0;
        AmountCur interestLineTotal = 0;
        int interestPeriodNumber; //variable to determine the number of interest calculation periods.
        TransDate interestCalcFromDate;
        AmountCur calculationAmount;

        interestTransDays = 0;

        if (!custInterestTransLineNumMap)
        {
            custInterestTransLineNumMap = new Map(Types::Real, Types::Real);
        }

        while select forupdate _tmpCustInterestTransLine
            order by _tmpCustInterestTransLine.RecId asc
                where _tmpCustInterestTransLine.CustTransRefRecId == _custTrans.RecId
        {
            custInterest = CustInterest::find(_tmpCustInterestTransLine.CustInterest);

            nextFrom = _calcFrom;
            interestCalcFromDate = _calcFrom;
            endDate = _calcTo;
            
            if (CustIntNoteStopContinuousCalcWhenLineAmtZeroFlight::instance().isEnabled())
            {
                interestDaysCurr = 0;
                interestTransDaysCurr = 0;
            }
            else
            {
                interestDays = 0;
                interestTransDays = 0;
            }
            
            custInterestTransLineNum++;

            calculationAmount = _tmpCustInterestTransLine.RemainAmount;

            this.setCurrentVersion(CustInterestCreate::custInterestFeeType(calculationAmount), _calcTo, interestCalcFromDate);

            CustInterestVersionDetail.InterestInterval = _tmpCustInterestTransLine.Interval;
            CustInterestVersionDetail.InterestCalculate = _tmpCustInterestTransLine.Method;

            if (CustIntNoteStopContinuousCalcWhenLineAmtZeroFlight::instance().isEnabled())
            {
                [_calcTo, interestDaysCurr] = this.setCalcTo(calculationAmount, interestCalcFromDate, _calcTo, endDate, interestDaysCurr, _resetInterestVersion);
            }
            else
            {
                [_calcTo, interestDays] = this.setCalcTo(calculationAmount, interestCalcFromDate, _calcTo, endDate, interestDays, _resetInterestVersion);
            }

            if (calculationAmount)
            {
                interestAmount = 0;
                interestPeriodNumber = 0;
                invoiceAmount = invoiceAmount + calculationAmount;

                while (nextFrom <= endDate)
                {
                    interestPeriodNumber ++;

                    if (CustIntNoteStopContinuousCalcWhenLineAmtZeroFlight::instance().isEnabled())
                    {
                        [interestAmount, interestCalculationErrorType, interestDaysCurr, percent, transactionMsg] = this.calcInterestAmount(_custTable, _custTrans, interestCalcFromDate, _calcTo, interestDaysCurr, calculationAmount
                            // <GEEPL>
                            , _dueDate
                                // </GEEPL>
                            );
                    }
                    else
                    {
                        [interestAmount, interestCalculationErrorType, interestDays, percent, transactionMsg] = this.calcInterestAmount(_custTable, _custTrans, interestCalcFromDate, _calcTo, interestDays, calculationAmount
                            // <GEEPL>
                            , _dueDate
                            // </GEEPL>
                            );
                    }

                    if (interestCalculationErrorType != CustInterestCreationErrorType::ValidTransaction)
                    {
                        interestCalculationResultSet.add(interestCalculationErrorType);
                        interestCalculationFailed = true;
                        break;
                    }

                    if (!this.roundOff())
                    {
                        interestAmount = CurrencyExchangeHelper::amount(interestAmount, _custTable.Currency);
                    }
                    else
                    {
                        interestAmount = round(interestAmount, this.roundOff());
                    }

                    interestAmountCalculated = interestAmount;
                    _custInterestJour.TaxItemGroup = this.getTaxItemGroup(_custTable, interestAmount);

                    if (_custTable.Currency != _custTrans.CurrencyCode && isCurrencyConversionRequired)
                    {
                        interestAmount = CurrencyExchangeHelper::curAmount2CurAmount(interestAmount, _custTable.Currency, _custTrans.CurrencyCode, this.toDate());
                    }

                    isCurrencyConversionRequired = false;
                    if (interestAmount || (custInterestFee.Fee && custInterest.RecId && calculationAmount))
                    {
                        //Create custInterestTransLine for the invoice
                        if (CustIntNoteStopContinuousCalcWhenLineAmtZeroFlight::instance().isEnabled())
                        {
                            this.insertCustInterestTransLine(interestAmount, calculationAmount, _custTrans, _tmpCustInterestTransLine, _custInterestJour, interestDaysCurr, interestCalcFromDate, percent, transactionMsg, interestPeriodNumber);
                        }
                        else
                        {
                            this.insertCustInterestTransLine(interestAmount, calculationAmount, _custTrans, _tmpCustInterestTransLine, _custInterestJour, interestDays, interestCalcFromDate, percent, transactionMsg, interestPeriodNumber);
                        }
                        //The value of current CustInterestTrans.LineNum will going to be lineNum + 1 so saving in the map after increamenting lineNum by 1.
                        custInterestTransLineNumMap.insert(custInterestTransLineNum, any2int(lineNum) + 1);
                        interestLineTotal = interestLineTotal + interestAmount;
                    }

                    if (CustIntNoteStopContinuousCalcWhenLineAmtZeroFlight::instance().isEnabled())
                    {
                        nextFrom = interestCalcFromDate + interestDaysCurr;
                        interestCalcFromDate = nextFrom;
                        [_calcTo, interestDaysCurr] = this.setCalcTo(calculationAmount, interestCalcFromDate, _calcTo, endDate, interestDaysCurr, true);
                    }
                    else
                    {
                        nextFrom = interestCalcFromDate + interestDays;
                        interestCalcFromDate = nextFrom;
                        [_calcTo, interestDays] = this.setCalcTo(calculationAmount, interestCalcFromDate, _calcTo, endDate, interestDays, true);
                    }
                }
            }
            if (CustIntNoteStopContinuousCalcWhenLineAmtZeroFlight::instance().isEnabled())
            {
                interestDays = max(interestDays, interestDaysCurr);
                interestTransDays = max(interestTransDays, interestTransDaysCurr);
            }
        }

        if (_custTrans.TransType == LedgerTransType::Cust)
        {
            select minof(CalcFrom) from _tmpCustInterestTransLine;
            interestCalcFromDate = _tmpCustInterestTransLine.CalcFrom;
        }

        if (interestLineTotal || (custInterestFee.Fee && custInterest.RecId && calculationAmount && interestPeriodNumber))
        {
            lineNum++;
            this.insertCustInterestTrans(_custInterestJour, interestLineTotal, invoiceAmount, _dueDate, _custTrans, _calcFrom, interestDays, percent, lineNum, transactionMsg, _custTrans.CurrencyCode);
            interestSum += CurrencyExchangeHelper::mstAmount(interestLineTotal, _custTrans.CurrencyCode);
            interestFound = true;
        }

        if (interestCalculationFailed)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the class is shown in the list of <c>Journal</c> types.
    /// </summary>
    /// <returns>
    ///    true if the class is shown in the list of <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    A class that can be used in a batch journal is a class where the same parameters can be used
    ///    repeatedly. The false dialog box can be shown and the parameters can be changed but parameters of
    ///    some classes might build on data that is only valid for a short time. Running a class two times
    ///    with the same parameters is not always possible. If the <see cref="M:RunBaseBatch.canGoBatch" />
    ///    method returns false, this method will not have any effect.
    /// </remarks>
    public boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkOpenTrans</Name>
				<Source><![CDATA[
    protected boolean checkOpenTrans(DueDate _dueDate, CustTrans _custTrans)
    {
        if (!this.checkTrans(_dueDate, _custTrans))
        {
            return false;
        }

        switch (this.fullPay())
        {
            case CustInterestCalc::Open:
                if (_custTrans.AmountCur == _custTrans.SettleAmountCur)
                {
                    return false;
                }
                break;

            case CustInterestCalc::Closed:
            case CustInterestCalc::ClosedIncludingGracePeriod:
                if (_custTrans.AmountCur != _custTrans.SettleAmountCur)
                {
                    return false;
                }
                break;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSettlement</Name>
				<Source><![CDATA[
    protected boolean checkSettlement(DueDate _dueDate, TransDate _transDate, NoYes _canBeReversed, CustTrans _custTrans)
    {
        if (!this.checkTrans(_dueDate, _custTrans))
        {
            return false;
        }

        if (!_canBeReversed)
        {
            // If a settlement record for a transaction can't be reversed it means it has already been reversed.
            // Settlement reversals should not be considered for interest calculations.
            return false;
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
        {
            if (this.fullPay() == CustInterestCalc::ClosedIncludingGracePeriod
                || this.fullPay() == CustInterestCalc::OpenClosedIncludingGracePeriod)
            {
                if(_transDate - interestGraceDays < interestStartDate)
                {
                    return false;
                }
            }
            else
            {
                if (_transDate - interestGraceDays < _dueDate)
                {
                    return false;
                }
            }
        }
        else
        {
            if (_transDate - custInterestVersion.GraceDays < _dueDate)
            {
                return false;
            }
        }

        if (_dueDate)
        {
            switch (this.fullPay())
            {
                case CustInterestCalc::Open:
                    return false;

                case CustInterestCalc::Closed:
                case CustInterestCalc::ClosedIncludingGracePeriod:
                    if (_custTrans.AmountCur != _custTrans.SettleAmountCur)
                    {
                        return false;
                    }
                    break;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTrans</Name>
				<Source><![CDATA[
    protected boolean checkTrans(DueDate _dueDate, CustTrans _custTrans)
    {
        PaymentDueDateUpdatePolicy paymentDueDateUpdatePolicy;

        if (!this.validateCustTrans(_custTrans))
        {
            return false;
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
        {
            paymentDueDateUpdatePolicy = PaymentDueDateUpdatePolicy::Next;
            if (paymCalendarCustInterest.InterestCalculationStart == PaymCalendarInterestCalculationStart::PreviousBusinessDay)
            {
                paymentDueDateUpdatePolicy = PaymentDueDateUpdatePolicy::Previous;
            }

            [interestStartDate, interestGraceDays] = this.getInterestStartDateAndGraceDays(_dueDate, paymentDueDateUpdatePolicy, _custTrans.AccountNum);

            // A minimum of a single grace day is always added to the dueDate by getInterestStartDateAndGraceDays.
            // interestGraceDays = 0 when custInterestVersion.GraceDays <= 1.
            if ((interestGraceDays != 0 && interestStartDate + interestGraceDays >= this.toDate()) || (interestStartDate > this.toDate()))
            {
                return false;
            }
        }
        else
        {
            if (_dueDate + custInterestVersion.GraceDays >= this.toDate())
            {
                return false;
            }
        }

        if (maxDate() - custInterestVersion.GraceDays < this.toDate())
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that an interest note can be created for the given <c>CustTrans</c> record.
    /// </summary>
    /// <param name="_custTrans">
    /// Customer transaction for which to create the interest note.
    /// </param>
    /// <returns>
    /// true if an interest note can be created; otherwise, false.
    /// </returns>
    protected boolean validateCustTrans(CustTrans _custTrans)
    {
        if (_custTrans.Interest == NoYes::No || _custTrans.TransType == LedgerTransType::ExchAdjustment)
        {
            return false;
        }

        if (_custTrans.TransType == LedgerTransType::Interest)
        {
            if (!this.interest())
            {
                return false;
            }
        }
        else if (_custTrans.AmountCur < 0 && _custTrans.Invoice)
        {
            if (!this.creditNote())
            {
                return false;
            }
        }
        else if (_custTrans.AmountCur > 0)
        {
            if (!this.invoice())
            {
                return false;
            }
        }
        else if (!this.payment())
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInterestNote</Name>
				<Source><![CDATA[
    private void createInterestNote(CustInterestJour _custInterestJour)
    {
        CustInterestCreationErrorType custInterestCreationErrorType;

        if (interestFound)
        {
            if (CustInterestCreate::testAmountLimit(custInterestFee.MinAmount, interestSum))
            {
                if (this.checkNegativeInterestAmount(interestSum))
                {
                    this.createJournal(_custInterestJour);
                    interestNoteCreated = true;
                }
                else
                {
                    interestCalculationResultSet.add(CustInterestCreationErrorType::BlockCreationOfNegativeInterest);
                    interestFound = false;
                }
            }
            else
            {
                interestCalculationResultSet.add(CustInterestCreationErrorType::MinimumAmountFailure);
                interestFound = false;
            }
        }

        custInterestCreationErrorType = this.logErrorsByCustomer(interestFound, interestCalculationResultSet);
        transactionHasValidFilter = custInterestCreationErrorType != CustInterestCreationErrorType::InvalidCalculationFilter || transactionHasValidFilter;
        transactionHasValidVersion = custInterestCreationErrorType != CustInterestCreationErrorType::InvalidVersion || transactionHasValidVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an interest note for a customer account.
    /// </summary>
    /// <param name="_custInterestJour">
    /// A <c>CustInterestJour</c> record.
    /// </param>
    protected void createJournal(CustInterestJour _custInterestJour)
    {
        CustInterestTrans custInterestTrans, localCustInterestTrans;
        CustInterestJour custInterestJourPrior;
        AmountCur amountCur;
        NumberSeq numberSeq = NumberSeq::newGetNum(CustParameters::numRefInterestNote());
        MapIterator mapIterator;
        int lineNumber = 0;
        boolean custMultipleInterestRates = false;
        LanguageTxt langTxt;
        // In most cases: [CustTransId, DueDate, InterestDays] -> CustInterestTrans
        // For multiple interest rates: [CustTransId, LineNum] -> CustInterestTrans
        Map custInterestTransMap = new Map(Types::Container, Types::Record);

        _custInterestJour.InterestNote = numberSeq.num();

        if (!_custInterestJour.InterestNote)
        {
            throw error(strFmt("@SYS28626", "@SYS8298"));
        }
        using (SysInstrumentationActivityContext activityContext = this.getActivityContextForRun(CustCreditInstrumentationConstants::CustInterestCreateCreateJournal))
        {
            activityContext.addCustomProperty(CustCreditInstrumentationConstants::CustInterestJourRecId, int642Str(_custInterestJour.RecId));

            _custInterestJour.NumberSequenceTable = numberSeq.parmNumberSequenceId();

            if (custInterestTransList.len() > 0)
            {
                custInterestTransList.first(custInterestTrans);
                do
                {
                    custInterestTrans.InterestNote = _custInterestJour.InterestNote;
                    if (this.isCustPublicSectorTransaction(CustTrans::find(custInterestTrans.CustTransId).TransType))
                    {
                        this.updateCustInterestTransMap(
                            custInterestTransMap,
                            custInterestTrans,
                            this.getCustInterestTransMapDateKey(custInterestTrans));
                    }
                    else
                    {
                        this.updateCustInterestTransMap(
                            custInterestTransMap,
                            custInterestTrans,
                            this.getCustInterestTransMapKey(custInterestTrans));
                    }

                    amountCur += custInterestTrans.InterestAmount;
                }
                while (custInterestTransList.next(custInterestTrans));
            }

            mapIterator = new MapIterator(custInterestTransMap);

            while (mapIterator.more())
            {
                custInterestTrans = mapIterator.value();

                if (!custMultipleInterestRates && (!isConfigurationkeyEnabled(configurationKeyNum(PublicSector))))
                {
                    // Do not renumber the lines in public sector because that can
                    // break the link with the custInterestTransLine

                    lineNumber++;
                    custInterestTrans.LineNum = lineNumber;
                }
                custInterestTrans.insert();
                mapIterator.next();
            }

            //Inserting records in custInterestTransLines table
            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
            {
                while (custInterestTransLineList.next(custInterestTransLine))
                {
                    if (custInterestTransLineNumMap && custInterestTransLineNumMap.exists(custInterestTransLine.LineNum))
                    {
                        select firstonly RecId from localCustInterestTrans
                            where localCustInterestTrans.InterestNote == _custInterestJour.InterestNote
                               && localCustInterestTrans.LineNum == custInterestTransLineNumMap.lookup(custInterestTransLine.LineNum)
                               && localCustInterestTrans.CustTransId == custInterestTransLine.CustTransId;

                        custInterestTransLine.CustInterestTrans = localCustInterestTrans.RecId;
                    }

                    if (!custInterestTransLine.CustInterestTrans)
                    {
                        custInterestTransLine.CustInterestTrans = CustInterestTrans::findByCustTransIdInterestNote(
                                                custInterestTransLine.CustTransId, _custInterestJour.InterestNote, custInterestTransLine.CalcFrom).RecId;
                    }

                    custInterestTransLine.InterestNote = _custInterestJour.InterestNote;
                    // <GEEPL>
                    this.setAdditionalCustInterestTransLineFields(custInterestTransLine);
                    // </GEEPL>
                    custInterestTransLine.insert();
                }

                //Inserting records in CustInterestTransLineIdRef table
                this.insertCustInterestTransLineIdRef(_custInterestJour.InterestNote);
            }
            if (amountCur < 0)
            {
                _custInterestJour.Fee = 0;
            }
        
            langTxt = LanguageTxt::find(tableNum(CustInterestFee), custInterestFee.RecId, _custInterestJour.LanguageId);

            if (langTxt.RecId)
            {
                _custInterestJour.Notes = langTxt.Txt;
            }

            this.postInterestJournalHeaderInitializedDelegate(_custInterestJour);

            this.insertCustInterestJour(_custInterestJour);

            // Save info to display in the InfoLog later. We save it in order to get only one client/server call from the InfoLog.
            this.logInfo(strFmt("@SYS67191", _custInterestJour.InterestNote, _custInterestJour.AccountNum));

            //  Update exisisting interestJournals for cust Account

            custInterestJourPrior = this.getPriorCustInterestJour(_custInterestJour);

            if (this.shouldCancelInterestCreation(custInterestJourPrior))
            {
                custInterestJourPrior.setCancelling();
                custInterestJourPrior.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPriorCustInterestJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the unposted interest note that is related to the particular customer.
    /// </summary>
    /// <param name = "_custInterestJour">The <c>CustIntestJour</c> table buffer to exclude.</param>
    /// <param name = "_useCustomFind">Optional parameter that gives the ability to execute custom lookups.</param>
    /// <returns>
    /// The <c>CustInterestJour</c> buffer.
    /// </returns>
    protected CustInterestJour getPriorCustInterestJour(CustInterestJour _custInterestJour, boolean _useCustomFind = false)
    {
        CustInterestJour custInterestJourPrior;

        if (!_useCustomFind)
        {
            if (isBillingClassificationEnabled)
            {
                custInterestJourPrior = CustInterestJour::findCustUnPostedInterestNote(_custInterestJour.AccountNum, _custInterestJour.RecId, true, _custInterestJour.CustBillingClassification);
            }
            else
            {
                custInterestJourPrior = CustInterestJour::findCustUnPostedInterestNote(_custInterestJour.AccountNum, _custInterestJour.RecId, true);
            }
        }

        return custInterestJourPrior;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustInterestJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the given <c>CustInterestJour</c> table buffer.
    /// </summary>
    /// <param name = "_custInterestJour">The <c>CustIntestJour</c> table buffer to be inserted.</param>
    protected void insertCustInterestJour(CustInterestJour _custInterestJour)
    {
        _custInterestJour.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCancelInterestCreation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether interest creation should be cancelled.
    /// </summary>
    /// <param name = "_custInterestJourPrior">The prior <c>CustInterestJour</c> table buffer.</param>
    /// <returns>true if interest creation should be cancelled; otherwise, false.</returns>
    protected boolean shouldCancelInterestCreation(CustInterestJour _custInterestJourPrior)
    {
        return _custInterestJourPrior.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditNote</Name>
				<Source><![CDATA[
    private boolean creditNote()
    {
        return includeCredits;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
    ///    created in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        FormBuildGroupControl currGroup;
        FormBuildStringControl dialogBuildBillingClassificationNames;
        FormBuildStringControl dialogBillingClassificationIds;
        DialogRunbase dialogRunbase = super();

        isBillingClassificationEnabled = CustParameters::isBillingClassificationEnabled();

        if (isBillingClassificationEnabled)
        {
            // Adding billing classification lookup
            dialogRunbase.addGroup().frameType(FormFrameType::None);

            currGroup = dialogRunbase.form().design().control(dialogRunbase.curFormBuildGroup().name());
            currGroup.columns(2);

            dialogBuildBillingClassificationNames = currGroup.addControl(FormControlType::String, 'billingClassificationNames');
            dialogBuildBillingClassificationNames.helpText("@SPS1010");
            dialogBillingClassificationNamesId = dialogBuildBillingClassificationNames.id();

            dialogBillingClassificationIds = currGroup.addControl(FormControlType::String, 'billingClassificationIds');
            dialogBillingClassificationIds.visible(false);

            dialogRunbase.addGroup().frameType(FormFrameType::None);

            inclTransWithNoBillingClassifications = NoYes::Yes;
            dialogInclTransWithNoBillingClassifications = dialogRunbase.addFieldValue(enumStr(NoYes), inclTransWithNoBillingClassifications, "@SPS691", "@SPS1009");
        }

        includeInvoices = NoYes::Yes;
        dialogInterestOnInvoices = dialogRunbase.addFieldValue(enumStr(NoYes), includeInvoices, "@SYS12128", "@SYS10250");

        dialogInterestOnNotes = dialogRunbase.addFieldValue(enumStr(NoYes), includeCredits, "@SYS8125", "@SYS11610");
        dialogInterestOnPayments = dialogRunbase.addFieldValue(enumStr(NoYes), includePayments, "@SYS828", "@SYS4924");
        dialogInterestOnInterest = dialogRunbase.addFieldValue(enumStr(NoYes), includeInterestTrans, "@SYS10770", "@SYS10444");

        dialogFromDate = dialogRunbase.addFieldValue(extendedTypeStr(TransDate), fromDate, "@SYS5209", "@SYS23192");
        dialogToDate = dialogRunbase.addFieldValue(extendedTypeStr(TransDate), toDate, "@SYS14656", "@SYS23192");

        dialogRoundOff = dialogRunbase.addFieldValue(extendedTypeStr(RoundOff), roundOff, "@SYS8172");

        dialogPostingSpec = dialogRunbase.addFieldValue(enumStr(InterestCalcAccountChoice), postingSpec, "@SYS26617", "@SYS24177");
        dialogPostingProfile = dialogRunbase.addFieldValue(extendedTypeStr(CustPostingProfile), postingProfile, "@SYS21530", "@SYS17924");

        if (this.shouldSetPostingSpecValue())
        {
            dialogPostingSpec.value(this.getInterestCalcAccountChoiceTransaction());
        }

        return dialogRunbase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSetPostingSpecValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the posting spec control should be updated with a value by default.
    /// </summary>
    /// <returns>true if the posting spec control should be updated with a value; otherwise, false.</returns>
    protected boolean shouldSetPostingSpecValue()
    {
        return isConfigurationkeyEnabled(configurationKeyNum(PublicSector));
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is called after dialog() is called, making is possible to add controls after the main dialog()
    /// </summary>
    /// <param name="dialog">
    /// Object for the <c>Dialog</c> from.
    /// </param>
    /// <remarks>
    ///  Adding Mutli-Select lookup for Billing classification.
    /// </remarks>
    public void dialogPostRun(DialogRunbase dialog)
    {
        container billingClassificationIdsLocal;
        container billingClassificationNamesLocal;
        CustTrans custTrans;

        super(dialog);

        if (isBillingClassificationEnabled)
        {
            dialogBillingClassificationNames = dialog.formRun().design().control(dialogBillingClassificationNamesId);
            dialogBillingClassificationNames.label("@SPS371");

            custBillingClassificationLookup = SysLookupMultiSelectCtrl::construct(dialog.formRun(),
                dialogBillingClassificationNames, queryStr(CustBillingClassificationLookup));

            if (custTransRestriction)
            {
                custTrans = CustTrans::find(custTransRestriction);
                custBillingClassificationLookup.set(CustBillingClassification::getCustBillingClassificationContainer(custTrans.CustBillingClassification));
            }
            else
            {
                billingClassificationNamesLocal = str2con(billingClassificationNames);
                billingClassificationIdsLocal = str2con(billingClassificationIds);

                custBillingClassificationLookup.set( [billingClassificationIdsLocal, billingClassificationNamesLocal]);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fromDate</Name>
				<Source><![CDATA[
    protected TransDate fromDate()
    {
        return fromDate ? fromDate : dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fullPay</Name>
				<Source><![CDATA[
    protected CustInterestCalc fullPay()
    {
        return CustParameters::find().CustInterestCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCollectionLetterNum</Name>
				<Source><![CDATA[
    private Num getCollectionLetterNum(CustTrans _custTrans)
    {
        return (select firstonly custCollectionLetterJour
                    where custCollectionLetterJour.LedgerVoucher == _custTrans.Voucher &&
                          custCollectionLetterJour.Updated == _custTrans.TransDate &&
                          custCollectionLetterJour.AccountNum == _custTrans.AccountNum).CollectionLetterNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFeePercentForRangeNone</Name>
				<Source><![CDATA[
    private container getFeePercentForRangeNone(RefRecId _custInterestVersionDetail, CurrencyCode _currency)
    {
        CustInterestFee custInterestFeeLocal = CustInterestFee::findByCustInterestVersionDetail(_custInterestVersionDetail, _currency);

        return [custInterestFeeLocal.RecId, custInterestFeeLocal.InterestValue];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFormRecords</Name>
				<Source><![CDATA[
    void getFormRecords(FormDataSource _ds)
    {
        Common record;
        CustTransOpen custTransOpen;
        CustTable custTable;
        container billingClassificationIdsLocal;
        container billingClassificationNamesLocal;

        if (_ds)
        {
            for (record = getFirstSelection(_ds); record; record = _ds.getNext())
            {
                switch (_ds.table())
                {
                    case tableNum(CustTransOpen):
                        custTransOpen = record;
                        custAccountsRestriction.add(custTransOpen.AccountNum);
                        if (interestNoteForSelectedInvoice) // Should be one, only single select is allowed
                        {
                            custTransRestriction = custTransOpen.RefRecId;
                        }
                        break;
                    case tableNum(CustTable):
                        custTable = record;
                        custAccountsRestriction.add(custTable.AccountNum);
                        break;
                    default:
                        throw error(strFmt("@SYS19306", funcName()));
                }
            }

            if (isBillingClassificationEnabled)
            {
                billingClassificationNames = con2StrUnlimited(billingClassificationNamesLocal);
                billingClassificationIds = con2StrUnlimited(billingClassificationIdsLocal);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the starting date for interest calculation.
    /// </summary>
    /// <param name="_lastInterestDate">
    ///    The date for the most recent interest calculation of the transaction.
    /// </param>
    /// <param name="_dueDate">
    ///    The due date of the invoice.
    /// </param>
    /// <param name="_transDate">
    ///    The invoice date.
    /// </param>
    /// <returns>
    /// The updated calculation period start date.
    /// </returns>
    protected
    TransDate getFromDate(
            CustLastInterestDate _lastInterestDate,
            DueDate _dueDate,
            TransDate _transDate)

    {
        TransDate calcFrom;
        if (FeatureStateProvider::isFeatureEnabled(CustInterestCreateIgnoreLastInterestDateFeature::instance())
            && !CustInterestCalculateRangeDaysFromDueDateFlight::instance().isEnabled())
        {
            calcFrom = _dueDate ? _dueDate : _transDate;
        }
        else
        {
            calcFrom = _lastInterestDate ? _lastInterestDate : (_dueDate ? _dueDate : _transDate);
        }

        // Calculate from the first day after the due date, last interest date, or transaction date. Customers
        // should not be charged interest on the date the transaction is due, nor for the last interest date
        // since it already included an interest charge. This explains the '+ 1'.
        calcFrom = max(calcFrom, this.fromDate()) + 1;

        if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
        {
            // if interest already calced once do not use the adjusted values.
            if (_lastInterestDate)
            {
                interestGraceDays = custInterestVersion.GraceDays;
                interestStartDate = calcFrom;
            }
            else
            {
                calcFrom = interestStartDate;
            }
        }

        return calcFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        includeInvoices = dialogInterestOnInvoices.value();
        includeCredits = dialogInterestOnNotes.value();
        includePayments = dialogInterestOnPayments.value();
        includeInterestTrans = dialogInterestOnInterest.value();

        fromDate = dialogFromDate.value();
        toDate = dialogToDate.value();

        roundOff = dialogRoundOff.value();

        postingSpec = dialogPostingSpec.value();
        postingProfile = dialogPostingProfile.value();

        if (isBillingClassificationEnabled)
        {
            inclTransWithNoBillingClassifications = dialogInclTransWithNoBillingClassifications.value();

            billingClassificationIds = con2Str(custBillingClassificationLookup.get());
            billingClassificationNames = dialogBillingClassificationNames.valueStr();
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInterestNoteNum</Name>
				<Source><![CDATA[
    private Num getInterestNoteNum(CustTrans _custTrans)
    {
        CustInterestJour custInterestJourLocal;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;
        CustInterestTrans custInterestTrans;

        select firstonly InterestNote
            from custInterestJourLocal
            where custInterestJourLocal.Updated == _custTrans.TransDate &&
                    custInterestJourLocal.FeeVoucher == _custTrans.Voucher;

        if (!custInterestJourLocal)
        {
            select firstonly InterestNote
                from custInterestJourLocal
                exists join custInterestTrans
                    where custInterestTrans.InterestNote == custInterestJourLocal.InterestNote &&
                            custInterestJourLocal.AccountNum == _custTrans.AccountNum
                exists join generalJournalEntry
                    where generalJournalEntry.RecId == custInterestTrans.GeneralJournalEntry &&
                            generalJournalEntry.AccountingDate == _custTrans.TransDate &&
                            generalJournalEntry.Ledger == Ledger::current()
                exists join subledgerVoucherLink
                    where subledgerVoucherLink.Voucher == _custTrans.Voucher &&
                            subledgerVoucherLink.VoucherDataAreaId == _custTrans.DataAreaId;
        }

        return custInterestJourLocal.InterestNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInterestStartDateAndGraceDays</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the interest start date and the number of grace days according to the payment calendar.
    /// </summary>
    /// <param name="_dueDate">
    ///    The due date of the invoice.
    /// </param>
    /// <param name="_paymentDueDateUpdatePolicy">
    ///    The update policy to use when adjusting the initial start date.
    /// </param>
    /// <param name="_custAccount">
    ///    The customer account number.
    /// </param>
    /// <returns>
    ///    A container holding the start date and the number of grace days.
    /// </returns>
    protected container getInterestStartDateAndGraceDays(DueDate _dueDate, PaymentDueDateUpdatePolicy _paymentDueDateUpdatePolicy, CustAccount _custAccount)
    {
        boolean isInterestCalendarBased;
        boolean isAdjustGraceDays;
        DueDate startDate;
        PositiveDays graceDays;

        // Reduce the grace days by 1 but not below 0
        if (custInterestVersion.GraceDays <= 1)
        {
            graceDays = 0;
        }
        else
        {
            graceDays = custInterestVersion.GraceDays - 1;
        }

        // Get flags that indicate if a server call is needed
        isInterestCalendarBased = (paymCalendarCustInterest.InterestCalculationStart != PaymCalendarInterestCalculationStart::DueDate);
        isAdjustGraceDays = (paymCalendarCustInterest.IsBusinessDaysGracePeriodApplicable && (graceDays > 0));

        if (isInterestCalendarBased || isAdjustGraceDays)
        {
            [startDate, graceDays] = CustInterestCreate::getInterestStartDateAndGraceDaysServer(
                    _dueDate, _paymentDueDateUpdatePolicy, graceDays, isInterestCalendarBased, isAdjustGraceDays, _custAccount, paymCalendarCustInterest);
        }
        else
        {
            startDate = _dueDate + 1;
        }

        return [startDate, graceDays];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getINTLineForMiscCharges</Name>
				<Source><![CDATA[
    private boolean getINTLineForMiscCharges(TmpCustInterestTransLine _tmpCustInterestTransLine, CustTable _custTable, CustTrans _custTrans, TransDate _calcFrom, TransDate _calcTo, AmountCur _totalInvoiceAmount)
    {
        CustInvoiceJour custInvoiceJour;
        boolean recordFound;
        CustBillingCode custBillingCode;
        MarkupTrans markupTrans;
        AmountCur remainAmount;

        //Add miscellaneous charges lines to the temporary table, if there are miscllenous charges associated with
        //the invoice
        custInvoiceJour = CustInvoiceJour::findFromCustTrans(_custTrans.Invoice, _custTrans.TransDate, _custTrans.AccountNum);

        while select Value, RecId, TaxAmount, SourceDocumentLine from markupTrans
            join InvoiceAmount from custInvoiceJour
            where markupTrans.TransTableId == tableNum(CustInvoiceJour) &&
                  markupTrans.TransRecId == custInvoiceJour.RecId &&
                  custInvoiceJour.InvoiceAccount == _custTrans.AccountNum &&
                  custInvoiceJour.InvoiceId == _custTrans.Invoice &&
                  custInvoiceJour.InvoiceDate == _custTrans.TransDate
        {
            markupTrans.TaxAmount = markupTrans.TaxAmount ? markupTrans.TaxAmount : this.getTaxAmountFromDistribution(markupTrans.SourceDocumentLine, markupTrans.Value);

            //Divide the invoice amount proportionally to the lines, if the there multiple lines associated with the invoice
            //and invoice is partially settled
            if (CustInvoiceTrans::numOfLines(_custTrans.Invoice, _custTrans.TransDate) > 1 || _custTrans.SettleAmountCur)
            {
                remainAmount = this.getPropotionalAmount(markupTrans.Value + markupTrans.TaxAmount, custInvoiceJour.InvoiceAmount, _totalInvoiceAmount);
            }
            else
            {
                remainAmount = markupTrans.Value + markupTrans.TaxAmount;
            }

            if (this.validateInterestLine(_tmpCustInterestTransLine, _custTable.Currency, _custTrans, _calcFrom, _calcTo, remainAmount, custBillingCode.RecId, false))
            {
                this.insertRecordTmpTable(
                                        _tmpCustInterestTransLine,
                                        remainAmount,
                                        markupTrans.RecId,
                                        markupTrans.Value + markupTrans.TaxAmount,
                                        CustInterestLineType::MiscCharges,
                                        0,
                                        custInterestVersionDetail.InterestInterval,
                                        custInterestVersionDetail.InterestCalculate,
                                        _calcFrom,
                                        _custTrans.RecId);

                recordFound = true;
            }
        }

        if ( recordFound)
        {
            this.invoiceFoundWithDiffInterestRatePeriods(_tmpCustInterestTransLine,
                                                                _custTrans,
                                                                _custTrans.Invoice,
                                                                custInterestVersionDetail.InterestInterval,
                                                                custInterestVersionDetail.InterestCalculate,
                                                                false);

            select count(RecId) from _tmpCustInterestTransLine
                where _tmpCustInterestTransLine.CustTransRefRecId == _custTrans.RecId;
        }

        return _tmpCustInterestTransLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getINTLinesFromCustInvoiceTrans</Name>
				<Source><![CDATA[
    private boolean getINTLinesFromCustInvoiceTrans(TmpCustInterestTransLine _tmpCustInterestTransLine, CustTable _custTable, CustTrans _custTrans, TransDate _calcFrom, TransDate _calcTo, AmountCur _totalInvoiceAmount)
    {
        CustInvoiceTrans custInvoiceTrans;
        boolean recordFound;
        CustBillingCode custBillingCode;
        AmountCur remainAmount;
        CustInvoiceJour custInvoiceJour;

        while select custInvoiceTrans
            order by SourceDocumentLine asc
                    join InvoiceAmount from custInvoiceJour
                    where custInvoiceJour.InvoiceId == custInvoiceTrans.InvoiceId &&
                          custInvoiceJour.InvoiceDate == custInvoiceTrans.InvoiceDate &&
                          custInvoiceJour.NumberSequenceGroup == custInvoiceTrans.NumberSequenceGroup &&
                          custInvoiceJour.SalesId == custInvoiceTrans.SalesId &&
                          custInvoiceJour.InvoiceAccount == _custTrans.AccountNum &&
                          custInvoiceJour.InvoiceId == _custTrans.Invoice &&
                          custInvoiceJour.InvoiceDate == _custTrans.TransDate
        {
            custBillingCode = CustBillingCode::findBillingCode(CustInvoiceTrans::findRecId(custInvoiceTrans.RecId).BillingCode);
            custInvoiceTrans.TaxAmount = custInvoiceTrans.TaxAmount ? custInvoiceTrans.TaxAmount : this.getTaxAmountFromDistribution(custInvoiceTrans.SourceDocumentLine, custInvoiceTrans.LineAmount);

            //Divide the invoice amount proportionally to the lines, if there are multiple lines associated with the invoice
            //and invoice is partially settled

            remainAmount = this.getPropotionalAmount(custInvoiceTrans.LineAmount + custInvoiceTrans.TaxAmount, custInvoiceJour.InvoiceAmount, _totalInvoiceAmount);

            if (this.validateInterestLine(_tmpCustInterestTransLine, _custTable.Currency, _custTrans, _calcFrom, _calcTo, remainAmount, custBillingCode.RecId))
            {
                this.insertRecordTmpTable(
                                        _tmpCustInterestTransLine,
                                        remainAmount,
                                        custInvoiceTrans.RecId,
                                        custInvoiceTrans.LineAmount + custInvoiceTrans.TaxAmount,
                                        CustInterestLineType::Customer,
                                        custBillingCode.RecId,
                                        custInterestVersionDetail.InterestInterval,
                                        custInterestVersionDetail.InterestCalculate,
                                        _calcFrom,
                                        _custTrans.RecId);

                recordFound = true;
            }
        }

        if ( recordFound)
        {
            this.invoiceFoundWithDiffInterestRatePeriods(_tmpCustInterestTransLine,
                                                            _custTrans,
                                                            _custTrans.Invoice,
                                                            custInterestVersionDetail.InterestInterval,
                                                            custInterestVersionDetail.InterestCalculate);

            select count(RecId) from _tmpCustInterestTransLine
                where _tmpCustInterestTransLine.CustTransRefRecId == _custTrans.RecId;
        }

        return _tmpCustInterestTransLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getINTLinesFromCustSettlementLines</Name>
				<Source><![CDATA[
    private boolean getINTLinesFromCustSettlementLines(TmpCustInterestTransLine _tmpCustInterestTransLine, CustTable _custTable, CustSettlement _custSettlement, CustTrans _custTrans)
    {
        CustSettlementLine custSettlementLine;
        CustInvoiceTrans custInvoiceTrans;
        CustBillingCode custBillingCode;
        TransDate calcFrom;
        TransDate calcTo;
        boolean recordFound;
        CustInterestLineType custInterestLineType;
        MarkupTrans markupTrans;
        RefRecId transRecId;
        AmountCur transAmount;

        void setTransAmountAndRecordId()
        {
            switch (custInterestLineType)
            {
                case CustInterestLineType::Customer:

                    transRecId = custInvoiceTrans.RecId;
                    transAmount = custInvoiceTrans.LineAmount + custInvoiceTrans.TaxAmount;

                    break;

                case CustInterestLineType::MiscCharges:

                    markupTrans = MarkupTrans::findByCustInvoiceLineRefId(custSettlementLine.CustInvoiceLineIdRef);
                    markupTrans.TaxAmount = markupTrans.TaxAmount ? markupTrans.TaxAmount : this.getTaxAmountFromDistribution(markupTrans.SourceDocumentLine, markupTrans.Value);

                    transRecId = markupTrans.RecId;
                    transAmount = markupTrans.Value + markupTrans.TaxAmount;

                    break;
            }
        }

        calcFrom = this.getFromDate(_custSettlement.LastInterestDate, _custSettlement.DueDate, _custSettlement.TransDate);
        calcTo = min(_custSettlement.TransDate, this.toDate());

        while select CustInvoiceLineIdRef, SettledAmountCur from custSettlementLine
                order by CustInvoiceLineIdRef desc
                    where custSettlementLine.CustSettlement == _custSettlement.RecId
        {
            custInvoiceTrans = CustInvoiceTrans::findByCustInvoiceLineRefId(custSettlementLine.CustInvoiceLineIdRef);
            custInvoiceTrans.TaxAmount = custInvoiceTrans.TaxAmount ? custInvoiceTrans.TaxAmount : this.getTaxAmountFromDistribution(custInvoiceTrans.SourceDocumentLine, custInvoiceTrans.LineAmount);
            custBillingCode = CustBillingCode::findBillingCode(custInvoiceTrans.BillingCode);

            if (this.validateInterestLine(_tmpCustInterestTransLine, _custTable.Currency, _custTrans, calcFrom, calcTo, custSettlementLine.SettledAmountCur, custBillingCode.RecId))
            {
                custInterestLineType = CustInterestTransLine::getInterestLineType(custSettlementLine.CustInvoiceLineIdRef);
                setTransAmountAndRecordId();

                this.insertRecordTmpTable(
                                        _tmpCustInterestTransLine,
                                        custSettlementLine.SettledAmountCur,
                                        transRecId,
                                        transAmount,
                                        custInterestLineType,
                                        custBillingCode.RecId,
                                        custInterestVersionDetail.InterestInterval,
                                        custInterestVersionDetail.InterestCalculate,
                                        calcFrom,
                                        _custTrans.RecId);

                recordFound = true;
            }
        }

        if ( recordFound)
        {
            this.invoiceFoundWithDiffInterestRatePeriods(_tmpCustInterestTransLine,
                                                                _custTrans,
                                                                _custTrans.Invoice,
                                                                custInterestVersionDetail.InterestInterval,
                                                                custInterestVersionDetail.InterestCalculate);

            select count(RecId) from _tmpCustInterestTransLine
                where _tmpCustInterestTransLine.CustTransRefRecId == _custTrans.RecId;
        }

        return recordFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getINTLinesFromCustTransOpenLine</Name>
				<Source><![CDATA[
    private boolean getINTLinesFromCustTransOpenLine(TmpCustInterestTransLine _tmpCustInterestTransLine, CustTable _custTable, CustTransOpen _custTransOpen, CustTrans _custTrans)
    {
        CustTransOpenLine custTransOpenLine;
        CustInvoiceTrans custInvoiceTrans;
        boolean recordFound;
        CustBillingCode custBillingCode;
        TransDate calcFrom;
        TransDate calcTo;
        CustInterestLineType custInterestLineType;
        MarkupTrans markupTrans;
        RefRecId transRecId;
        AmountCur transAmount;
        AmountCur remainAmount;

        void setTransAmountAndRecordId()
        {
            switch (custInterestLineType)
            {
                case CustInterestLineType::Customer:

                    transRecId = custInvoiceTrans.RecId;
                    transAmount = custInvoiceTrans.LineAmount + custInvoiceTrans.TaxAmount;

                    break;

                case CustInterestLineType::MiscCharges:

                    markupTrans = MarkupTrans::findByCustInvoiceLineRefId(custTransOpenLine.CustInvoiceLineIdRef);
                    transRecId = markupTrans.RecId;

                    if (CustIntTransFTINegativeChargeCodesAmountFlight::instance().isEnabled())
                    {
                        markupTrans.TaxAmount = markupTrans.TaxAmount ? markupTrans.TaxAmount : this.getTaxAmountFromDistribution(markupTrans.SourceDocumentLine, markupTrans.CalculatedAmount);

                        transAmount = markupTrans.CalculatedAmount + markupTrans.TaxAmount;
                    }
                    else
                    {
                        markupTrans.TaxAmount = markupTrans.TaxAmount ? markupTrans.TaxAmount : this.getTaxAmountFromDistribution(markupTrans.SourceDocumentLine, markupTrans.Value);

                        transAmount = markupTrans.Value + markupTrans.TaxAmount;
                    }

                    break;
            }
        }

        calcFrom = this.getFromDate(_custTransOpen.LastInterestDate, _custTransOpen.DueDate, _custTransOpen.TransDate);
        calcTo = this.toDate();

        while select CustInvoiceLineIdRef, AmountCur from custTransOpenLine
                order by CustInvoiceLineIdRef desc
                    where custTransOpenLine.CustTransOpen == _custTransOpen.RecId
        {
            custInvoiceTrans = CustInvoiceTrans::findByCustInvoiceLineRefId(custTransOpenLine.CustInvoiceLineIdRef);
            custInvoiceTrans.TaxAmount = custInvoiceTrans.TaxAmount ? custInvoiceTrans.TaxAmount : this.getTaxAmountFromDistribution(custInvoiceTrans.SourceDocumentLine, custInvoiceTrans.LineAmount);
            custBillingCode = CustBillingCode::findBillingCode(custInvoiceTrans.BillingCode);

            if (this.validateInterestLine(_tmpCustInterestTransLine, _custTable.Currency, _custTrans, calcFrom, calcTo, _custTransOpen.AmountCur, custBillingCode.RecId))
            {
                custInterestLineType = CustInterestTransLine::getInterestLineType(custTransOpenLine.CustInvoiceLineIdRef);

                setTransAmountAndRecordId();

                if (CustIntTransFTINegativeChargeCodesAmountFlight::instance().isEnabled() && custInterestLineType == CustInterestLineType::MiscCharges)
                {
                    remainAmount = transAmount;
                }
                else
                {
                    remainAmount = custTransOpenLine.AmountCur;
                }

                this.insertRecordTmpTable(
                                        _tmpCustInterestTransLine,
                                        remainAmount,
                                        transRecId,
                                        transAmount,
                                        custInterestLineType,
                                        custBillingCode.RecId,
                                        custInterestVersionDetail.InterestInterval,
                                        custInterestVersionDetail.InterestCalculate,
                                        calcFrom,
                                        _custTrans.RecId);

                recordFound = true;
            }
        }

        if ( recordFound)
        {
            this.invoiceFoundWithDiffInterestRatePeriods(_tmpCustInterestTransLine,
                                                                _custTrans,
                                                                _custTrans.Invoice,
                                                                custInterestVersionDetail.InterestInterval,
                                                                custInterestVersionDetail.InterestCalculate);

            select count(RecId) from _tmpCustInterestTransLine
                where _tmpCustInterestTransLine.CustTransRefRecId == _custTrans.RecId;
        }

        return recordFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceNum</Name>
				<Source><![CDATA[
    private Num getInvoiceNum(CustTrans _custTrans)
    {
        return _custTrans.Invoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the last choice stored in the last value table.
    /// </summary>
    /// <remarks>
    ///    If no record can be found or the <c>unpack</c> method returns false, the <c>initParmDefault</c>
    ///    method will be called. This method should not typically be overridden.
    /// </remarks>
    public void getLast()
    {
        Set previousAccountsRestriction = custAccountsRestriction;
        RefRecId previousTransRestriction = custTransRestriction;

        super();

        // overwrite restrictions with what was passed in from the list pages.
        custAccountsRestriction = previousAccountsRestriction;
        custTransRestriction = previousTransRestriction;
        this.setRanges(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentVoucherNum</Name>
				<Source><![CDATA[
    private Num getPaymentVoucherNum(CustTrans _custTrans)
    {
        return _custTrans.Voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPercentForRangeAmount</Name>
				<Source><![CDATA[
    private container getPercentForRangeAmount(CustTrans _custTrans, RefRecId _custInterestFee, AmountCur _amountCur, CurrencyCode _currency)
    {
        AmountCur amountCur = CurrencyExchangeHelper::curAmount2CurAmount(_amountCur, _custTrans.CurrencyCode, _currency, this.toDate());
        CustInterestRange custInterestRange = CustInterestRange::findInterestRange(_custInterestFee, real2int(abs(amountCur)));

        return [custInterestRange.RecId, custInterestRange.InterestPct];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPercentForRangeTime</Name>
				<Source><![CDATA[
    private container getPercentForRangeTime(RefRecId _custInterestFee, Counter _counter)
    {
        CustInterestRange custInterestRange = CustInterestRange::findInterestRange(_custInterestFee, _counter);

        return [custInterestRange.RecId, custInterestRange.InterestPct];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPropotionalAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the proportional amount for the invoice line.
    /// </summary>
    /// <param name="_lineAmount">
    /// The invoice line amount.
    /// </param>
    /// <param name="_invoiceTotalAmount">
    /// The invoice total amount.
    /// </param>
    /// <param name="_settledAmount">
    /// The amount to which invoice is settled.
    /// </param>
    /// <returns>
    /// The Proportional ratio with respect to the invoice total amount.
    /// </returns>
    protected AmountCur getPropotionalAmount(AmountCur _lineAmount,
                                              AmountCur _invoiceTotalAmount,
                                              AmountCur _settledAmount)
    {
        return (_lineAmount / _invoiceTotalAmount) * _settledAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmountFromDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the tax amount for given source document line ID by using accounting distributions.
    /// </summary>
    /// <param name="_sourceDocumentLineRecId">
    /// The source document line record ID to be used.
    /// </param>
    /// <param name="_lineAmount">
    /// The line amount of current transaction.
    /// </param>
    /// <returns>
    /// This method will retrieve the tax even if the tax is calculated on the header.
    /// </returns>
    private AmountCur getTaxAmountFromDistribution(
        SourceDocumentLineRecId _sourceDocumentLineRecId,
        AmountCur _lineAmount)
    {
        AccountingDistribution lineAccountingDistribution, taxAccountingDistribution;
        AmountCur taxAmount;

        select sum(TransactionCurrencyAmount) from taxAccountingDistribution
        where taxAccountingDistribution.MonetaryAmount == MonetaryAmount::Tax
            exists join lineAccountingDistribution
            where lineAccountingDistribution.RecId == taxAccountingDistribution.ParentDistribution
                && lineAccountingDistribution.SourceDocumentLine == _sourceDocumentLineRecId;

        if (_lineAmount > 0)
        {
            taxAmount = abs(taxAccountingDistribution.TransactionCurrencyAmount);
        }
        else
        {
            taxAmount = abs(taxAccountingDistribution.TransactionCurrencyAmount) * -1;
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxItemGroup</Name>
				<Source><![CDATA[
    protected final TaxItemGroup getTaxItemGroup(CustTable _custTable, AmountCur _interestAmount)
    {
        CustInterestVersion custInterestVersionLocal;
        CustInterestVersionDetail custInterestVersionDetailLocal;
        CustInterestFee custInterestFeeLocal;

        custInterestVersionLocal = CustInterestVersion::findByDate(custInterest.RecId, this.toDate());
        custInterestVersionDetailLocal = CustInterestVersionDetail::findByFeeType(custInterestVersionLocal.RecId, CustInterestFeeType::Earning);
        custInterestFeeLocal = CustInterestFee::findByCustInterestVersionDetail(custInterestVersionDetailLocal.RecId, _custTable.Currency);

        if (_interestAmount < 0)
        {
            custInterestVersionDetailLocal = CustInterestVersionDetail::findByFeeType(custInterestVersionLocal.RecId, CustInterestFeeType::Payment);
            custInterestFeeLocal = CustInterestFee::findByCustInterestVersionDetail(custInterestVersionDetailLocal.RecId, _custTable.Currency);
        }

        return custInterestFeeLocal.TaxItemGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustInterestCreateFromArgs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a newly created instance of <c>CustInterestCreate</c> class based on the arguments provided.
    /// </summary>
    /// <param name = "_args">Arguments used to initialize the <c>CustInterestCreate</c> class instance.</param>
    protected void initCustInterestCreateFromArgs(Args _args)
    {
        // if records are selected on the calling list page then we will capture the account numbers
        // behind those selections and automatically apply the restrictions.
        if (_args && _args.record())
        {
            if (_args.parmEnumType() == enumNum(InterestCalcCategory))
            {
                this.setInterestCalc(_args.parmEnum());
            }
            this.getFormRecords(FormDataUtil::getFormDataSource(_args.record()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParams</Name>
				<Source><![CDATA[
    protected void initParams(InterestCalcCategory _interestCalcCategory, Set _custAccountsRestriction, RefRecId _custTransRestriction)
    {
        this.setInterestCalc(_interestCalcCategory);
        custAccountsRestriction = _custAccountsRestriction;
        custTransRestriction = _custTransRestriction;
        interestNoteForSelectedInvoice = custTransRestriction != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the internal variables.
    /// </summary>
    /// <remarks>
    ///    This method is called when no <c>SysLastValue</c> record can be found when the
    ///    <c>SysLastValue.GetLast</c> method is called. Remember to call the <c>super</c> method.
    /// </remarks>
    public void initParmDefault()
    {
        super();

        this.queryBuild();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateCustInterestTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates a <c>CustInterestTrans</c> table buffer into a <c>RecordInsertList</c>
    /// </summary>
    /// <param name = "_custInterestJour">
    /// A <c>CustInterestJour</c> table buffer.
    /// </param>
    /// <param name="_amountCur">
    /// The interest amount.
    /// </param>
    /// <param name="_calculationAmount">
    ///  The original amount on which interest was calculated.
    /// </param>
    /// <param name = "_dueDate">
    /// The due date.
    /// </param>
    /// <param name="_custTrans">
    ///  The customer transaction record.
    /// </param>
    /// <param name="_calcFrom">
    /// The date from which interest is calculated.
    /// </param>
    /// <param name="_interestDays">
    ///  The number of days for which interest is calculated.
    /// </param>
    /// <param name="_percent">
    /// The interest percentage.
    /// </param>
    /// <param name = "_lineNum">
    /// The line number.
    /// </param>
    /// <param name="_transactionMsg">
    /// The transaction message associated with the interest code.
    /// </param>
    /// <param name = "_currencyCode">
    /// The currency code.
    /// </param>
    /// <returns>
    /// The populated <c>CustInterestTrans</c> table buffer.
    /// </returns>
    protected CustInterestTrans populateCustInterestTrans(
            CustInterestJour _custInterestJour,
            AmountCur _amountCur,
            AmountCur _calculationAmount,
            DueDate _dueDate,
            CustTrans _custTrans,
            TransDate _calcFrom,
            Integer _interestDays,
            Percent _percent,
            LineNum _lineNum,
            TransTxt _transactionMsg,
            CurrencyCode _currencyCode)
    {
        TransactionTxt transactionTxt;
        LanguageTxt langTxt;
        CustInterestTrans custInterestTrans;

        transactionTxt = TransactionTxt::construct();
        transactionTxt.setType(LedgerTransTxt::CustInterestCust);
        transactionTxt.setLanguage(_custTrans.languageId());
        transactionTxt.setVoucher(_custTrans.Voucher);
        transactionTxt.setFormLetter(_custTrans.Invoice);
        transactionTxt.setKey1(_custTrans.AccountNum);
        transactionTxt.setKey2(_custTrans.Txt);

        custInterestTrans.clear();

        custInterestTrans.InterestNote = _custInterestJour.InterestNote;
        custInterestTrans.CustTransId = _custTrans.RecId;
        custInterestTrans.TransDate = _custTrans.TransDate;
        custInterestTrans.CurrencyCode = _currencyCode;
        custInterestTrans.RemainAmount = _calculationAmount;
        custInterestTrans.InterestAmount = _amountCur;
        custInterestTrans.CalcFrom = _calcFrom;

        if (custInterest.CustInterestType == CustInterestType::MultipleRate)
        {
            if (custInterestVersionDetail.InterestCalcType == CustInterestCalcType::Percentage && custInterestVersionDetail.InterestByRange == CustInterestByRange::None)
            {
                custInterestTrans.InterestPercent = _percent;
            }
        }
        else
        {
            custInterestTrans.InterestPercent = _percent;
        }

        custInterestTrans.Txt = _transactionMsg;

        if (!isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            custInterestTrans.InterestDays = _interestDays;
        }

        custInterestTrans.InvoiceAmount = _custTrans.AmountCur;
        custInterestTrans.Invoice = _custTrans.Invoice;
        custInterestTrans.Voucher = _custTrans.Voucher;
        custInterestTrans.DueDate = _dueDate;
        custInterestTrans.InterestCalculate = NoYes::Yes;
        custInterestTrans.LineNum = _lineNum;

        // <GEEPL>
        this.setAdditionalCustInterestTransFields(custInterestTrans);
        // </GEEPL>

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            //if the customer transaction type is not free text invoice type then fill the interest days value.
            if (_custTrans.TransType != LedgerTransType::Cust)
            {
                custInterestTrans.InterestDays = _interestDays;
            }
            //if the customer transcation transaction type is of free text invoice type,
            //fill the values of the interest transaction on the basis of interest transcation lines.
            else
            {
                custInterestTrans.InterestDays = interestTransDays;

                // Converting the label description to customer language.
                custInterestTrans.Txt = strFmt(SysLabel::labelId2String(literalStr("@SPS636"), customerLanguage), _custTrans.Invoice);
            }
        }

        langTxt = LanguageTxt::find(tableNum(CustInterestVersion), custInterestVersion.RecId, _custInterestJour.LanguageId);

        if (langTxt.RecId != 0)
        {
            custInterestTrans.Notes = langTxt.Txt;
        }
     
        return custInterestTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustInterestTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a <c>CustInterestTrans</c> table buffer into a <c>RecordInsertList</c>
    /// </summary>
    /// <param name = "_custInterestJour">
    /// A <c>CustInterestJour</c> table buffer.
    /// </param>
    /// <param name="_amountCur">
    /// The interest amount.
    /// </param>
    /// <param name="_calculationAmount">
    ///  The original amount on which interest was calculated.
    /// </param>
    /// <param name = "_dueDate">
    /// The due date.
    /// </param>
    /// <param name="_custTrans">
    ///  The customer transaction record.
    /// </param>
    /// <param name="_calcFrom">
    /// The date from which interest is calculated.
    /// </param>
    /// <param name="_interestDays">
    ///  The number of days for which interest is calculated.
    /// </param>
    /// <param name="_percent">
    /// The interest percentage.
    /// </param>
    /// <param name = "_lineNum">
    /// The line number.
    /// </param>
    /// <param name="_transactionMsg">
    /// The transaction message associated with the interest code.
    /// </param>
    /// <param name = "_currencyCode">
    /// The currency code.
    /// </param>
    protected void insertCustInterestTrans(
            CustInterestJour _custInterestJour,
            AmountCur _amountCur,
            AmountCur _calculationAmount,
            DueDate _dueDate,
            CustTrans _custTrans,
            TransDate _calcFrom,
            Integer _interestDays,
            Percent _percent,
            LineNum _lineNum,
            TransTxt _transactionMsg,
            CurrencyCode _currencyCode)
    {
        CustInterestTrans custInterestTrans = this.populateCustInterestTrans(_custInterestJour, _amountCur, _calculationAmount, _dueDate, _custTrans, _calcFrom,
            _interestDays, _percent, _lineNum, _transactionMsg, _currencyCode);

        custInterestTransList.ins(custInterestTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateCustInterestTransLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates <c>CustInterestTransLine</c> records.
    /// </summary>
    /// <param name="_amountCur">
    /// The interest amount.
    /// </param>
    /// <param name="_calculationAmount">
    ///  The original amount on which interest was calculated.
    /// </param>
    /// <param name="_custTrans">
    ///  The customer transaction record.
    /// </param>
    /// <param name="_tmpCustInterestTransLine">
    ///  The temporary table record.
    /// </param>
    /// <param name="_custInterestJour">
    ///  The interest header record.
    /// </param>
    /// <param name="_interestDays">
    ///  The number of days for which interest is calculated.
    /// </param>
    /// <param name="_calcFrom">
    /// The date from which interest is calculated.
    /// </param>
    /// <param name="_percent">
    /// The interest percentage.
    /// </param>
    /// <param name="_transactionMsg">
    /// The transaction message associated with the interest code.
    /// </param>
    /// <param name="_interestPeriodNumber">
    /// The interest period number of a interest line.
    /// </param>
    protected void populateCustInterestTransLine(AmountCur _amountCur,
                                            AmountCur _calculationAmount,
                                            CustTrans _custTrans,
                                            TmpCustInterestTransLine _tmpCustInterestTransLine,
                                            CustInterestJour _custInterestJour,
                                            PositiveDays _interestDays,
                                            TransDate _calcFrom,
                                            Percent _percent,
                                            TransTxt _transactionMsg,
                                            int _interestPeriodNumber = 1)
    {
        TransactionTxt transactionTxt;
        RefRecId interestLineRefRecId;
        LanguageTxt langTxt;

        custInterest = CustInterest::find(_tmpCustInterestTransLine.CustInterest);

        transactionTxt = TransactionTxt::construct();
        transactionTxt.setType(LedgerTransTxt::CustInterestCust);
        transactionTxt.setLanguage(_custTrans.languageId());
        transactionTxt.setVoucher(_custTrans.Voucher);
        transactionTxt.setFormLetter(_custTrans.Invoice);
        transactionTxt.setKey1(_custTrans.AccountNum);
        transactionTxt.setKey2(_custTrans.Txt);

        custInterestTransLine.clear();

        //If there are multiple periods, there can be multiple interest lines for one invoice line or for one misc charges
        //line. For multiple interest lines, there will be multiple line references. These references can
        //be later used to retrieves invoice line or misc charges. The code below, is creating references
        //for those extra interest lines.

        custInterestTransLine.InterestPeriodNumber = _interestPeriodNumber;

        if (_interestPeriodNumber > 1)
        {
            interestLineRefRecId = _tmpCustInterestTransLine.InterestLineRecId;
            custInterestTransLineIdRef.CustInterestLineType = _tmpCustInterestTransLine.CustInterestLineType;

            //Increment decimal value, if the interest line is created due to the multiple periods
            custInterestTransLineIdRefLineNum = custInterestTransLineNum;
            interestLineReferencePeriodNum = _interestPeriodNumber;

            custInterestTransLineIdRefMap.insert([custInterestTransLineIdRefLineNum, interestLineRefRecId, interestLineReferencePeriodNum], custInterestTransLineIdRef);
        }

        custInterestTransLine.LineNum = custInterestTransLineNum;

        custInterestTransLine.InterestNote = _custInterestJour.InterestNote;

        custInterestTransLine.CustTransId = _custTrans.RecId;
        custInterestTransLine.RemainAmount = _calculationAmount;
        custInterestTransLine.InterestAmount = _amountCur;
        custInterestTransLine.LineAmount = _tmpCustInterestTransLine.LineAmount;
        custInterestTransLine.InterestDays = _interestDays;
        custInterestTransLine.Description = _tmpCustInterestTransLine.Description;

        if (custInterest.CustInterestType == CustInterestType::MultipleRate)
        {
            custInterestTransLine.CalcFrom = _calcFrom;

            if (CustIntNoteStopContinuousCalcWhenLineAmtZeroFlight::instance().isEnabled())
            {
                interestTransDaysCurr += _interestDays;
            }
            else
            {
                interestTransDays += _interestDays;
            }

            if (custInterestVersionDetail.InterestCalcType == CustInterestCalcType::Percentage && custInterestVersionDetail.InterestByRange == CustInterestByRange::None)
            {
                custInterestTransLine.TransactionTxt = transactionTxt.txt();

                custInterestTransLine.InterestPercentage = _custTrans.TransType != LedgerTransType::Cust && _percent;
            }
            else
            {
                custInterestTransLine.TransactionTxt = _transactionMsg;
            }
        }
        else
        {
            custInterestTransLine.CalcFrom = _calcFrom;
            custInterestTransLine.TransactionTxt = _transactionMsg;
            custInterestTransLine.InterestPercentage = _custTrans.TransType != LedgerTransType::Cust && _percent;

            if (CustIntNoteStopContinuousCalcWhenLineAmtZeroFlight::instance().isEnabled())
            {
                interestTransDaysCurr = _interestDays;
            }
            else
            {
                interestTransDays = _interestDays;
            }
        }

        custInterestTransLine.InterestCodeSource = _tmpCustInterestTransLine.InterestCodeSource;
        custInterestTransLine.CustInterest = _tmpCustInterestTransLine.CustInterest;
        custInterestTransLine.Invoice = _custTrans.Invoice;

        langTxt = LanguageTxt::find(tableNum(CustInterestVersion), custInterestVersion.RecId, _custInterestJour.LanguageId);
        custInterestTransLine.Notes = langTxt.Txt;

        custInterestTransLine.CustBillingCode = _tmpCustInterestTransLine.CustBillingCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustInterestTransLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create <c>CustInterestTransLine</c> records.
    /// </summary>
    /// <param name="_amountCur">
    /// The interest amount.
    /// </param>
    /// <param name="_calculationAmount">
    ///  The original amount on which interest was calculated.
    /// </param>
    /// <param name="_custTrans">
    ///  The customer transaction record.
    /// </param>
    /// <param name="_tmpCustInterestTransLine">
    ///  The temporary table record.
    /// </param>
    /// <param name="_custInterestJour">
    ///  The interest header record.
    /// </param>
    /// <param name="_interestDays">
    ///  The number of days for which interest is calculated.
    /// </param>
    /// <param name="_calcFrom">
    /// The date from which interest is calculated.
    /// </param>
    /// <param name="_percent">
    /// The interest percentage.
    /// </param>
    /// <param name="_transactionMsg">
    /// The transaction message associated with the interest code.
    /// </param>
    /// <param name="_interestPeriodNumber">
    /// The interest period number of a interest line.
    /// </param>
    protected void insertCustInterestTransLine(AmountCur _amountCur,
                                            AmountCur _calculationAmount,
                                            CustTrans _custTrans,
                                            TmpCustInterestTransLine _tmpCustInterestTransLine,
                                            CustInterestJour _custInterestJour,
                                            PositiveDays _interestDays,
                                            TransDate _calcFrom,
                                            Percent _percent,
                                            TransTxt _transactionMsg,
                                            int _interestPeriodNumber = 1)
    {
        this.populateCustInterestTransLine(_amountCur, _calculationAmount, _custTrans, _tmpCustInterestTransLine,
            _custInterestJour, _interestDays, _calcFrom, _percent, _transactionMsg, _interestPeriodNumber);

        custInterestTransLineList.ins(custInterestTransLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustInterestTransLineIdRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates record in <c>CustInterestTransLineIdRef</c> table.
    /// </summary>
    /// <param name="_interestNote">
    /// The interest note number.
    /// </param>
    /// <remarks>
    /// This method also updates the custInterestTransLineIdRef field of the
    /// <c>custInterestTransLine</c> table
    /// </remarks>
    protected void insertCustInterestTransLineIdRef(InterestNote _interestNote)
    {
        MapIterator mapIterator;
        RefRecId interestLineRefRecId;
        CustnterestTransLineIdRef_Invoice custnterestTransLineIdRef_Invoice;
        CustInterestTransLineIdRef_MarkupTrans custInterestTransLineIdRef_MarkupTrans;
        CustInvoiceLine custInvoiceLine;
        MarkupTrans markupTrans;
        CustInterestTransLine custInterestTransLineLocal;

        mapIterator = new MapIterator(custInterestTransLineIdRefMap);
        while (mapIterator.more())
        {
            custInterestTransLineIdRef = mapIterator.value();
            [custInterestTransLineIdRefLineNum, interestLineRefRecId, interestLineReferencePeriodNum ] = mapIterator.key();

            custInterestTransLineLocal = CustInterestTransLine::findByLineNumInterestNote(custInterestTransLineIdRefLineNum,
                                                                                         _interestNote,
                                                                                         interestLineReferencePeriodNum);
            if (custInterestTransLineLocal)
            {
                custInterestTransLineIdRef.LineNum = custInterestTransLineIdRefLineNum;

                switch (custInterestTransLineIdRef.CustInterestLineType)
                {
                    case CustInterestLineType::Customer:
                        custInvoiceLine = CustInvoiceLine::find(interestLineRefRecId);

                        custnterestTransLineIdRef_Invoice.ParentRecId = custInvoiceLine.ParentRecId;
                        custnterestTransLineIdRef_Invoice.LineNum_Invoice = custInvoiceLine.LineNum;
                        custnterestTransLineIdRef_Invoice.CustInvoiceLine = custInvoiceLine.RecId;
                        custnterestTransLineIdRef_Invoice.CustInterestLineType = custInterestTransLineIdRef.CustInterestLineType;
                        custnterestTransLineIdRef_Invoice.insert();

                        custInterestTransLineLocal.CustInterestTransLineIdRef = custnterestTransLineIdRef_Invoice.RecId;
                        break;

                    case CustInterestLineType::MiscCharges:

                        markupTrans = MarkupTrans::findRecId(interestLineRefRecId);

                        custInterestTransLineIdRef_MarkupTrans.TransRecId = markupTrans.TransRecId;
                        custInterestTransLineIdRef_MarkupTrans.LineNum_MarkupTrans = markupTrans.LineNum;
                        custInterestTransLineIdRef_MarkupTrans.TransTableId = markupTrans.TransTableId;
                        custInterestTransLineIdRef_MarkupTrans.CustInterestLineType = custInterestTransLineIdRef.CustInterestLineType;
                        custInterestTransLineIdRef_MarkupTrans.insert();

                        custInterestTransLineLocal.CustInterestTransLineIdRef = custInterestTransLineIdRef_MarkupTrans.RecId;
                        break;
                }
                custInterestTransLineLocal.update();
            }
            mapIterator.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRecordTmpTable</Name>
				<Source><![CDATA[
    private void insertRecordTmpTable(TmpCustInterestTransLine _tmpCustInterestTransLine,
                                        AmountCur _remainAmount,
                                        RefRecId _invoiceTransRefRecId,
                                        LineAmount _lineAmount,
                                        CustInterestLineType _interestLineType,
                                        BillingCodeRefRecId _billingCodeRecId,
                                        PositiveDays _interval,
                                        CustInterestTimeUnit _method,
                                        TransDate _calcFrom,
                                        RefRecId _custTransRecId)
    {
        RefRecId interestLineRefRecId;

        //The amount on which interest will be calculated
        _tmpCustInterestTransLine.RemainAmount = _remainAmount;

        //Original line amount
        _tmpCustInterestTransLine.LineAmount = _lineAmount;

        //Initializing interest Period number for Interest reference line
        interestLineReferencePeriodNum = 1;

        _tmpCustInterestTransLine.CustTransRefRecId = _custTransRecId;

        //Interval and method varriable settings in temporary table
        _tmpCustInterestTransLine.Interval = _interval;
        _tmpCustInterestTransLine.Method = _method;

        _tmpCustInterestTransLine.InterestCodeSource = interestCodeSource;
        _tmpCustInterestTransLine.CustInterest = custInterest.RecId;
        _tmpCustInterestTransLine.CustInterestLineType = _interestLineType;
        _tmpCustInterestTransLine.CustBillingCode = _billingCodeRecId;
        _tmpCustInterestTransLine.CalcFrom = _calcFrom;

        //Create references for invoice lines and misc charges
        switch (_interestLineType)
        {
            case CustInterestLineType::Customer:
                interestLineRefRecId = CustInvoiceLine::findBySourceDocumentLine(
                                                            CustInvoiceTrans::findRecId(_invoiceTransRefRecId).SourceDocumentLine).RecId;

                custInterestTransLineIdRef.CustInterestLineType = CustInterestLineType::Customer;
                _tmpCustInterestTransLine.Description = CustInvoiceLine::find(interestLineRefRecId).Description;
                _tmpCustInterestTransLine.InterestLineRecId = interestLineRefRecId;
                break;

            case CustInterestLineType::MiscCharges:
                interestLineRefRecId = _invoiceTransRefRecId;
                _tmpCustInterestTransLine.InterestLineRecId = _invoiceTransRefRecId;
                _tmpCustInterestTransLine.Description = MarkupTrans::findRecId(interestLineRefRecId).Txt;
                custInterestTransLineIdRef.CustInterestLineType = CustInterestLineType::MiscCharges;
                break;
        }

        _tmpCustInterestTransLine.insert();

        custInterestTransLineIdRefLineNum ++;
        custInterestTransLineIdRefMap.insert([custInterestTransLineIdRefLineNum, interestLineRefRecId, interestLineReferencePeriodNum], custInterestTransLineIdRef);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interest</Name>
				<Source><![CDATA[
    protected boolean interest()
    {
        return includeInterestTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interestPercent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the percentage of interest that is chargeable on the specified transaction amount.
    /// </summary>
    /// <param name="_custTable">
    /// A <c>CustTable</c> record.
    /// </param>
    /// <param name="_custTrans">
    /// A <c>CustTrans</c> record.
    /// </param>
    /// <param name="_amountCur">
    ///    The transaction amount on which the interest amount is charged.
    /// </param>
    /// <param name="_counter">
    ///    The day and month of the transaction.
    /// </param>
    /// <returns>
    ///    The interest percentage.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The interest amount is defined as zero or is not defined in the interest code.
    /// </exception>
    public container interestPercent(CustTable _custTable, CustTrans _custTrans, AmountCur _amountCur, Counter _counter)
    {
        CustInterestFee custInterestFeeLocal;
        CustInterestValue interestPct;
        RefRecId recId;
        CurrencyCode currencyCode;

        switch (custInterestVersionDetail.InterestByRange)
        {
            case CustInterestByRange::None:
                currencyCode = _custTable.Currency;
                interestPct = custInterestVersionDetail.InterestPercent;
                break;

            case CustInterestByRange::Day:
            case CustInterestByRange::Month:
                currencyCode = Ledger::accountingCurrency();
                interestPct = conPeek(this.getPercentForRangeTime(custInterestFee.RecId, _counter), 2);
                break;

            case CustInterestByRange::Amount:
                custInterestFeeLocal = this.postingSpec() == this.getInterestCalcAccountChoiceTransaction() ?
                    CustInterestFee::findByCustInterestVersionDetail(custInterestVersionDetail.RecId, _custTable.Currency) :
                    custInterestFee;

                currencyCode = _custTable.Currency;
                interestPct = conPeek(this.getPercentForRangeAmount(_custTrans, custInterestFeeLocal.RecId, _amountCur, currencyCode), 2);
                if (!interestPct)
                {
                    currencyCode = Ledger::accountingCurrency();
                    custInterestFeeLocal = CustInterestFee::findByCustInterestVersionDetail(custInterestVersionDetail.RecId, currencyCode);

                    [recId, interestPct] = this.getPercentForRangeAmount(_custTrans, custInterestFeeLocal.RecId, _amountCur, currencyCode);

                    companyCurrencyMsg = strFmt("@SYS128889", _custTable.Currency, currencyCode);
                    isCompanyCurrencyUsed = true;

                    if (!recId && !custInterestFeeLocal.Fee)
                    {
                        throw error(strFmt("@SYS128890", _custTable.Currency, currencyCode, _custTrans.Invoice, _custTrans.AccountNum, custInterest.InterestCode));
                    }
                }
                break;
        }

        return [interestPct, currencyCode];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInterestCalcAccountChoiceTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the transaction enum value of <c>InterestCalcAccountChoice</c>.
    /// </summary>
    /// <returns>
    /// Enum value of transaction of enum <c>InterestCalcAccountChoice</c>.
    /// </returns>
    protected InterestCalcAccountChoice getInterestCalcAccountChoiceTransaction()
    {
        return InterestCalcAccountChoice::Transaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interestValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the interest amount that is chargeable on the specified transaction amount.
    /// </summary>
    /// <param name="_custTable">
    /// A <c>CustTable</c> record.
    /// </param>
    /// <param name="_custTrans">
    /// A <c>CustTrans</c> record.
    /// </param>
    /// <param name="_amountCur">
    ///    The transaction amount on which the interest amount is charged.
    /// </param>
    /// <param name="_counter">
    ///    The day and month of the transaction.
    /// </param>
    /// <returns>
    ///    The interest amount that will be charged.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The interest amount is defined as zero or is not defined in the interest code.
    /// </exception>
    public container interestValue(CustTable _custTable, CustTrans _custTrans, AmountCur _amountCur, Counter _counter)
    {
        CustInterestFee custInterestFeeLocal;
        CustInterestValue interestPct;
        RefRecId recId;
        CurrencyCode currencyCode;

        container findInterestValue(CurrencyCode _currency)
        {
            switch (custInterestVersionDetail.InterestByRange)
            {
                case CustInterestByRange::None:
                    return this.getFeePercentForRangeNone(custInterestVersionDetail.RecId, _currency);
                case CustInterestByRange::Day:
                case CustInterestByRange::Month:
                    return this.getPercentForRangeTime(custInterestFee.RecId, _counter);
                case CustInterestByRange::Amount:
                    return this.getPercentForRangeAmount(_custTrans, custInterestFeeLocal.RecId, _amountCur, _currency);
            }
            return conNull(); // to keep the compiler quiet about returning a value.
        }

        isCurrencyConversionRequired = true;

        custInterestFeeLocal = this.postingSpec() == this.getInterestCalcAccountChoiceTransaction() ?
                    CustInterestFee::findByCustInterestVersionDetail(custInterestVersionDetail.RecId, _custTable.Currency) :
                    custInterestFee;

        currencyCode = _custTable.Currency;
        [recId, interestPct] = findInterestValue(currencyCode);

        if (!interestPct)
        {
            currencyCode = Ledger::accountingCurrency();
            isCompanyCurrencyUsed = true;
            companyCurrencyMsg = strFmt("@SYS128889", _custTable.Currency, currencyCode);

            custInterestFeeLocal = CustInterestFee::findByCustInterestVersionDetail(custInterestVersionDetail.RecId, currencyCode);

            [recId, interestPct] = findInterestValue(currencyCode);

            if (!recId && !custInterestFeeLocal.Fee)
            {
                throw error(strFmt("@SYS128890", _custTable.Currency, currencyCode, _custTrans.Invoice, _custTrans.AccountNum, custInterest.InterestCode));
            }
        }

        return [interestPct, currencyCode];
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoice</Name>
				<Source><![CDATA[
    protected boolean invoice()
    {
        return includeInvoices;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves invoice amount from the <c>CustTransOpen</c> and <c>CustSettlement</c> table.
    /// </summary>
    /// <returns>
    /// The invoice amount if there is an invoice amount associated with the <c>CustTransOpen</c> and <c>CustSettlement</c> record;
    /// otherwise, 0.
    /// </returns>
    protected AmountCur invoiceAmount()
    {
        AmountCur invoiceAmount;
        CustTransOpen custTransOpen;
        CustSettlement custSettlement;

        if (queryRun.changed(tableNum(CustTransOpen)))
        {
            custTransOpen = queryRun.get(tableNum(CustTransOpen));
            invoiceAmount = custTransOpen.AmountCur;
        }

        if (queryRun.changed(tableNum(CustSettlement)))
        {
            custSettlement = queryRun.get(tableNum(CustSettlement));
            invoiceAmount = custSettlement.SettleAmountCur;
        }

        return invoiceAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceFoundWithDiffInterestRatePeriods</Name>
				<Source><![CDATA[
    private boolean invoiceFoundWithDiffInterestRatePeriods(TmpCustInterestTransLine _tmpCustInterestTransLine, CustTrans _custTrans, InvoiceId _invoice, PositiveDays _interval, CustInterestTimeUnit _method, boolean _showErrorMsg = true)
    {
        boolean invoiceFoundWithDifferentInterestRatePeriods;

        // Skip invoice having lines with different interest periods
        select count(RecId) from _tmpCustInterestTransLine
            where _tmpCustInterestTransLine.CustTransRefRecId == _custTrans.RecId &&
                    _tmpCustInterestTransLine.Interval != _interval ||
                    _tmpCustInterestTransLine.Method != _method;

        if (_tmpCustInterestTransLine.RecId > 0)
        {
            this.skipInterestCalculationFreeTextInvoice(_tmpCustInterestTransLine, _custTrans, _tmpCustInterestTransLine.CalcFrom, _showErrorMsg);

            this.logError(strFmt("@SPS521", _invoice));
            invoiceFoundWithDifferentInterestRatePeriods = true;
        }

        return invoiceFoundWithDifferentInterestRatePeriods;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustPublicSectorTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if public sector is enabled and the passed <c>LedgerTransType</c> is a customer transaction.
    /// </summary>
    /// <param name = "_transType">
    /// A <c>LedgerTransType</c> value.
    /// </param>
    /// <returns>
    /// true if public sector is enabled and <c>LedgerTransType</c> is customer transactions; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean isCustPublicSectorTransaction(LedgerTransType _transType)
    {
        return _transType == LedgerTransType::Cust && isConfigurationkeyEnabled(configurationKeyNum(PublicSector));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInterestPublicSectorTransaction</Name>
				<Source><![CDATA[
    private final boolean isInterestPublicSectorTransaction(LedgerTransType _transType)
    {
        return _transType == LedgerTransType::Interest && isConfigurationkeyEnabled(configurationKeyNum(PublicSector));
    }

]]></Source>
			</Method>
			<Method>
				<Name>logDateRecordError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a log error based on field trans type of <c>CustTrans</c> table.
    /// </summary>
    /// <param name = "_custTrans">
    /// A <c>CustTrans</c> table buffer.
    /// </param>
    /// <param name = "_calcFrom">
    /// A date record to consider the period of effective interest code.
    /// </param>
    [Replaceable]
    protected void logDateRecordError(CustTrans _custTrans, TransDate _calcFrom)
    {
        switch (_custTrans.TransType)
        {
            case LedgerTransType::CollectionLetter:
                if (this.postingSpec() == this.getInterestCalcAccountChoiceTransaction())
                {
                    this.logError(strFmt("@SYS330923", this.getCollectionLetterNum(_custTrans), _calcFrom));
                }
                else
                {
                    this.logError(strFmt("@SYS330924", this.getCollectionLetterNum(_custTrans)));
                }
                break;

            case LedgerTransType::Payment:
                if (this.postingSpec() == this.getInterestCalcAccountChoiceTransaction())
                {
                    this.logError(strFmt("@SYS330919", this.getPaymentVoucherNum(_custTrans), _calcFrom));
                }
                else
                {
                    this.logError(strFmt("@SYS330915", this.getPaymentVoucherNum(_custTrans)));
                }
                break;

            case LedgerTransType::Interest:
                if (this.postingSpec() == this.getInterestCalcAccountChoiceTransaction())
                {
                    this.logError(strFmt("@SYS330917", this.getInterestNoteNum(_custTrans), _calcFrom));
                }
                else
                {
                    this.logError(strFmt("@SYS330921", this.getInterestNoteNum(_custTrans)));
                }
                break;

            default:
                if (_custTrans.Invoice)
                {
                    if (_custTrans.isCreditNote())
                    {
                        if (this.postingSpec() == this.getInterestCalcAccountChoiceTransaction())
                        {
                            this.logError(strFmt("@SYS330918", this.getInvoiceNum(_custTrans), _calcFrom));
                        }
                        else
                        {
                            this.logError(strFmt("@SYS330922", this.getInvoiceNum(_custTrans)));
                        }
                    }
                    else
                    {
                        if (this.postingSpec() == this.getInterestCalcAccountChoiceTransaction())
                        {
                            this.logError(strFmt("@SYS330916", this.getInvoiceNum(_custTrans), _calcFrom));
                        }
                        else
                        {
                            this.logError(strFmt("@SYS330920", this.getInvoiceNum(_custTrans)));
                        }
                    }
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logError</Name>
				<Source><![CDATA[
    private void logError(str _message)
    {
        this.logMessage(Exception::Error, _message);
    }

]]></Source>
			</Method>
			<Method>
				<Name>logErrorsByCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves customer level error messages.
    /// </summary>
    /// <param name="_interestNoteCreated">
    /// The flag that indicates that the interest note for the customer was made or not.
    /// </param>
    /// <param name="_interestCalculationResultSet">
    /// The set that keeps tracks of all the errors in the interest transactions.
    /// </param>
    /// <returns>
    /// The interest error type.
    /// </returns>
    public CustInterestCreationErrorType logErrorsByCustomer(boolean _interestNoteCreated, Set _interestCalculationResultSet)
    {
        CustInterestCreationErrorType custInterestCreationErrorType = CustInterestCreationErrorType::InvalidCalculationFilter;

        if (!_interestNoteCreated)
        {
            if (_interestCalculationResultSet.in(CustInterestCreationErrorType::MinimumAmountFailure))
            {
                this.logError("@SYS330228");
                return CustInterestCreationErrorType::InvalidVersion;
            }

            if (_interestCalculationResultSet.elements() == 1)
            {
                if (_interestCalculationResultSet.in(CustInterestCreationErrorType::MissingPostingProfile))
                {
                    if (this.postingSpec() == this.getInterestCalcAccountChoiceTransaction())
                    {
                        this.logError("@SYS330224");
                    }
                    else
                    {
                        this.logError("@SYS330222");
                    }
                    custInterestCreationErrorType = CustInterestCreationErrorType::InvalidVersion;
                }

                if (_interestCalculationResultSet.in(custInterestCreationErrorType::BlockCreationOfNegativeInterest))
                {
                    this.logError("@AccountsReceivable:NegativeInterestChargesDisabled");
                    custInterestCreationErrorType = CustInterestCreationErrorType::InvalidVersion;
                }

                if (_interestCalculationResultSet.in(CustInterestCreationErrorType::MissingARPostingProfileSetupRecord))
                {
                    custInterestCreationErrorType = CustInterestCreationErrorType::InvalidVersion;
                }

                if (_interestCalculationResultSet.in(CustInterestCreationErrorType::InvalidVersion))
                {
                    this.logError("@SYS330224");
                    custInterestCreationErrorType = CustInterestCreationErrorType::InvalidVersion;
                }

                if (_interestCalculationResultSet.in(CustInterestCreationErrorType::ZeroValueIntCode))
                {
                    this.logError("@SYS330227");
                    custInterestCreationErrorType = CustInterestCreationErrorType::InvalidVersion;
                }

                if (_interestCalculationResultSet.in(CustInterestCreationErrorType::NoInterestCode))
                {
                    custInterestCreationErrorType = CustInterestCreationErrorType::InvalidVersion;
                }
            }
        }

        return custInterestCreationErrorType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logInfo</Name>
				<Source><![CDATA[
    private void logInfo(str _message)
    {
        this.logMessage(Exception::Info, _message);
    }

]]></Source>
			</Method>
			<Method>
				<Name>logMessage</Name>
				<Source><![CDATA[
    private void logMessage(Exception _exception, str _message)
    {
        str message = "@AccountsReceivable:InterestCalculationProcessComplete" + '\t' + logPrefix + '\t' + _message;

        switch (_exception)
        {
            case Exception::Error:
                error(message);
                break;

            case Exception::Warning:
                warning(message);
                break;

            case Exception::Info:
                info(message);
                break;

            default:
                error(message);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logPostingProfileErrors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a log error based on field trans type of <c>CustTrans</c> table and posting profile.
    /// </summary>
    /// <param name = "_custTrans">
    /// A <c>CustTrans</c> record.
    /// </param>
    public void logPostingProfileErrors(CustTrans _custTrans)
    {
        if (this.postingSpec() != this.getInterestCalcAccountChoiceTransaction())
        {
            this.logError("@SYS330222");
        }
        else
        {
            this.logPostingProfileErrorsByTransType(_custTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logPostingProfileErrorsByTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a log error based on field trans type of <c>CustTrans</c> table and posting profile.
    /// </summary>
    /// <param name = "_custTrans">
    /// A <c>CustTrans</c> record.
    /// </param>
    [Replaceable]
    protected void logPostingProfileErrorsByTransType(CustTrans _custTrans)
    {
        switch (_custTrans.TransType)
        {
            case LedgerTransType::CollectionLetter:
                this.logError(strFmt("@AccountsReceivable:CollectionLetterPostingProfileMissingInterest", this.getCollectionLetterNum(_custTrans)));
                break;

            case LedgerTransType::Payment:
                this.logError(strFmt("@SYS330949", this.getPaymentVoucherNum(_custTrans)));
                break;

            case LedgerTransType::Interest:
                this.logError(strFmt("@SYS330947", this.getInterestNoteNum(_custTrans)));
                break;

            default:
                    if (_custTrans.Invoice)
                {
                    if (_custTrans.isCreditNote())
                    {
                        this.logError(strFmt("@SYS330948", this.getInvoiceNum(_custTrans)));
                    }
                    else
                    {
                        this.logError(strFmt("@SYS330946", this.getInvoiceNum(_custTrans)));
                    }
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
        custAccountsRestriction = new Set(Types::String);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAndValidatePostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the existence of posting profile.
    /// </summary>
    /// <returns>
    /// A <c>CustPostingProfile</c> table buffer.
    /// </returns>
    protected CustPostingProfile findAndValidatePostingProfile()
    {
        CustPostingProfile custPostingProfile;
        switch (this.postingSpec())
        {
            case InterestCalcAccountChoice::Account:
            case InterestCalcAccountChoice::Transaction:
                custPostingProfile = CustParameters::find().PostingProfile;
                if (!custPostingProfile)
                {
                    throw error("@SYS330515");
                }
                break;

            case InterestCalcAccountChoice::Selection:
                custPostingProfile = this.postingProfile();
                if (!custPostingProfile)
                {
                    throw error("@SYS330516");
                }
                break;
        }
        return custPostingProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the posting profile against <c>CustTable</c> buffer.
    /// </summary>
    /// <param name = "_custTable">
    /// A <c>CustTable</c> record.
    /// </param>
    /// <returns>
    /// A container with posting profile and customer interest error creation type.
    /// </returns>
    protected container newAccount(CustTable _custTable)
    {
        CustPostingProfile custPostingProfile;

        this.setLogPrefix(_custTable);
        custPostingProfile = this.findAndvalidatePostingProfile();

        if (this.postingSpec() != this.getInterestCalcAccountChoiceTransaction() && this.validatePostingProfileCust(_custTable, custPostingProfile) == CustInterestCreationErrorType::MissingPostingProfile)
        {
            queryRun.query().dataSourceTable(tableNum(CustSettlement)).enabled(false);
            queryRun.query().dataSourceTable(tableNum(CustTransOpen)).enabled(false);

            return [CustInterestCreationErrorType::MissingARPostingProfileSetupRecord, custPostingProfile];
        }

        custInterest  = this.retrieveCustInterestForCustomer(_custTable, custPostingProfile);

        if (!custInterest && this.postingSpec() != this.getInterestCalcAccountChoiceTransaction())
        {
            if (!custPostingProfile)
            {
                warning(strFmt("@AccountsReceivable:NoInterestCodeInPostingProfilePublicSector", _custTable.AccountNum));
            }
            else
            {
                warning(strFmt("@AccountsReceivable:NoInterestCodeInPostingProfile", _custTable.AccountNum, custPostingProfile));
            }
        }

        custInterestTransList = new RecordSortedList(tableNum(CustInterestTrans));
        custInterestTransList.sortOrder(fieldNum(CustInterestTrans, CustTransId), fieldNum(CustInterestTrans, LineNum));

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            custInterestTransLineList = new RecordSortedList(tableNum(CustInterestTransLine));
            custInterestTransLineList.sortOrder(fieldNum(CustInterestTransLine,CustInterestTrans),
                                       fieldNum(CustInterestTransLine, LineNum),
                                       fieldNum(CustInterestTransLine, InterestPeriodNumber));

            custInterestTransLineIdRefMap = new Map(Types::Container,Types::Record);
        }

        queryRun.query().dataSourceTable(tableNum(CustSettlement)).enabled(true);
        queryRun.query().dataSourceTable(tableNum(CustTransOpen)).enabled(true);

        return [CustInterestCreationErrorType::InvalidCalculationFilter, custPostingProfile];
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveCustInterestForCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the customer interest related to the particular customer.
    /// </summary>
    /// <param name = "_custTable">The customer table buffer used to find the <c>CustInterest</c> record.</param>
    /// <param name = "_custPostingProfile">The posting profile ID used to find the <c>CustInterest</c> record.</param>
    /// <param name = "_useCustomFind">Optional parameter that gives the ability to execute custom lookups.</param>
    /// <returns>
    /// The customer interest record related to the customer.
    /// </returns>
    protected CustInterest retrieveCustInterestForCustomer(CustTable _custTable, CustPostingProfile _custPostingProfile, boolean _useCustomFind = false)
    {
        CustInterest custInterestLocal;

        if (!_useCustomFind)
        {
            if (isBillingClassificationEnabled
                && currentCustBillingClassificationId
                && this.postingSpec() == this.getInterestCalcAccountChoiceTransaction()
                && isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
            {
                custInterestLocal = CustInterest::findByBillingClassOrPostingProfile(_custTable.AccountNum, currentCustBillingClassificationId, _custPostingProfile);
            }
            else
            {
                custInterestLocal = CustInterest::find(CustLedgerAccounts::custInterest(_custTable.AccountNum, _custPostingProfile));
            }
        }
        return custInterestLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendVariableToPack</Name>
				<Source><![CDATA[
    private container appendVariableToPack(container _pack, str _variableName, anytype _value)
    {
        XppPrePostArgs packArgs = this.createXppPrePostArgsWithPack(_pack);
        SysPackExtensions::pack(packArgs, this.getVariablePackKey(_variableName), [_value]);
        return packArgs.getReturnValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXppPrePostArgsWithPack</Name>
				<Source><![CDATA[
    private XppPrePostArgs createXppPrePostArgsWithPack(container _pack)
    {
        XppPrePostArgs prePostArgs = new XppPrePostArgs(_pack, '',  XppEventHandlerCalledWhen::Post);
        prePostArgs.setReturnValue(_pack);
        return prePostArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVariablePackKey</Name>
				<Source><![CDATA[
    private ClassName getVariablePackKey(str _variableName)
    {
        return classStr(CustInterestCreate) + '.' + _variableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>extractPackedVariable</Name>
				<Source><![CDATA[
    private anytype extractPackedVariable(container _pack, str _variableName)
    {
        anytype value;
        [value] = SysPackExtensions::unpack(this.createXppPrePostArgsWithPack(_pack), this.getVariablePackKey(_variableName));
        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packed = [#CurrentVersion, #CurrentList, queryRun.pack(), custAccountsRestriction.pack()];
        packed = this.appendVariableToPack(packed, varStr(processId), processId);
        packed = this.appendVariableToPack(packed, varStr(isFinalTask), isFinalTask);
        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);
        container packedCustAccountsRestriction;

        #LOCALMACRO.CurrentList_v8
            includeInvoices,
            includeCredits,
            includePayments,
            includeInterestTrans,
            postingSpec,
            fromDate,
            toDate,
            RoundOff,
            PostingProfile
        #ENDMACRO

        #LOCALMACRO.CurrentList_v9
            includeInvoices,
            includeCredits,
            includePayments,
            includeInterestTrans,
            postingSpec,
            fromDate,
            toDate,
            RoundOff,
            PostingProfile,
            custAccountsRestriction
        #ENDMACRO

        #LOCALMACRO.CurrentList_v10
            includeInvoices,
            includeCredits,
            includePayments,
            includeInterestTrans,
            postingSpec,
            fromDate,
            toDate,
            RoundOff,
            PostingProfile,
            custTransRestriction
        #ENDMACRO

        #LOCALMACRO.CurrentList_v11
            includeInvoices,
            includeCredits,
            includePayments,
            includeInterestTrans,
            postingSpec,
            fromDate,
            toDate,
            RoundOff,
            PostingProfile,
            custTransRestriction,
            billingClassificationNames,
            billingClassificationIds,
            inclTransWithNoBillingClassifications
        #ENDMACRO

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList, packedQuery, packedCustAccountsRestriction] = _packedClass;
                processId = this.extractPackedVariable(_packedClass, varStr(processId));
                isFinalTask = this.extractPackedVariable(_packedClass, varStr(isFinalTask));
                isChildTask = processId == emptyGuid() ? false : true;
                queryRun = new QueryRun(packedQuery);
                custAccountsRestriction = Set::create(packedCustAccountsRestriction);
                break;

            case 11:
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    [version, #CurrentList_v11, packedQuery, packedCustAccountsRestriction] = _packedClass;
                    queryRun = new QueryRun(packedQuery);
                    custAccountsRestriction = Set::create(packedCustAccountsRestriction);
                }
                break;

            case 10:
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    [version, #CurrentList_v10, packedQuery, packedCustAccountsRestriction] = _packedClass;
                    queryRun = new QueryRun(packedQuery);
                    custAccountsRestriction = Set::create(packedCustAccountsRestriction);
                }
                break;

            case 9:
                [version, #CurrentList_v9, packedQuery] = _packedClass;
                queryRun = new QueryRun(packedQuery);
                break;

            case 8:
                [version, #CurrentList_v8, packedQuery] = _packedClass;
                queryRun = new QueryRun(packedQuery);
                break;

            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustInterest</Name>
				<Source><![CDATA[
    public CustInterest parmCustInterest(CustInterest _custInterest = custInterest)
    {
        custInterest = _custInterest;

        return custInterest;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustInterestVersion</Name>
				<Source><![CDATA[
    public CustInterestVersion parmCustInterestVersion(CustInterestVersion _custInterestVersion = custInterestVersion)
    {
        custInterestVersion = _custInterestVersion;

        return custInterestVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustInterestVersionDetail</Name>
				<Source><![CDATA[
    public CustInterestVersionDetail parmCustInterestVersionDetail(CustInterestVersionDetail _custInterestVersionDetail = custInterestVersionDetail)
    {
        custInterestVersionDetail = _custInterestVersionDetail;

        return custInterestVersionDetail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterestCodeSource</Name>
				<Source><![CDATA[
    public CustInterestCodeSource parmInterestCodeSource(CustInterestCodeSource _interestCodeSource = interestCodeSource)
    {
        interestCodeSource = _interestCodeSource;

        return interestCodeSource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingProfile</Name>
				<Source><![CDATA[
    public CustPostingProfile parmPostingProfile(CustPostingProfile _postingProfile = postingProfile)
    {
        postingProfile = _postingProfile;

        return postingProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingSpec</Name>
				<Source><![CDATA[
    public InterestCalcAccountChoice parmPostingSpec(InterestCalcAccountChoice _postingSpec = postingSpec)
    {
        postingSpec = _postingSpec;

        return postingSpec;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFromDate</Name>
				<Source><![CDATA[
    public TransDate parmFromDate(TransDate _date = fromDate)
    {
        fromDate = _date;
        return fromDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmToDate</Name>
				<Source><![CDATA[
    public TransDate parmToDate(TransDate _date = toDate)
    {
        toDate = _date;
        return toDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessId</Name>
				<Source><![CDATA[
    internal guid parmProcessId(guid _processId = processId)
    {
        processId = _processId;
        return processId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeInterest</Name>
				<Source><![CDATA[
    public NoYes parmIncludeInterest(NoYes _interest = includeInterestTrans)
    {
        includeInterestTrans = _interest;
        return includeInterestTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeInvoices</Name>
				<Source><![CDATA[
    public NoYes parmIncludeInvoices(NoYes _invoice = includeInvoices)
    {
        includeInvoices = _invoice;
        return includeInvoices;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeCredits</Name>
				<Source><![CDATA[
    public NoYes parmIncludeCredits(NoYes _creditNotes = includeCredits)
    {
        includeCredits = _creditNotes;
        return includeCredits;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludePayments</Name>
				<Source><![CDATA[
    public NoYes parmIncludePayments(NoYes _payment = includePayments)
    {
        includePayments = _payment;
        return includePayments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>payment</Name>
				<Source><![CDATA[
    protected boolean payment()
    {
        return includePayments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingProfile</Name>
				<Source><![CDATA[
    protected CustPostingProfile postingProfile()
    {
        return postingProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingSpec</Name>
				<Source><![CDATA[
    protected InterestCalcAccountChoice postingSpec()
    {
        return postingSpec;
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressTotal</Name>
				<Source><![CDATA[
    protected int progressTotal(QueryRun _queryRun)
    {
        Query queryProgress = new Query();

        SysQuery::mergeRanges(queryProgress, _queryRun.query(), 1);

        return QueryRun::getQueryRowCount(queryProgress, intMax());
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressUpdate</Name>
				<Source><![CDATA[
    protected void progressUpdate(str _text, boolean _updateCounter)
    {
        if (_updateCounter)
        {
            progressCounter++;
            progress.setCount(progressCounter);
        }
        progress.setText(_text);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuild</Name>
				<Source><![CDATA[
    protected void queryBuild()
    {
        queryRun = new QueryRun(queryStr(CustInterestCreate));
        packedQuery = queryRun.pack();
        queryRun.query().title("@SYS21410");
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuildUpdate</Name>
				<Source><![CDATA[
    protected void queryBuildUpdate()
    {
        #define.BillingClassificationSelected(';0')
        #define.NoBillingClassificationSelected('0')

        queryRun.query().dataSourceTable(tableNum(CustTransOpen)).findRange(fieldNum(CustTransOpen, DueDate)).value(strFmt('%1..%2', this.fromDate(), this.toDate()));
        queryRun.query().dataSourceTable(tableNum(CustSettlement)).findRange(fieldNum(CustSettlement, DueDate)).value(strFmt('%1..%2', this.fromDate(), this.toDate()));

        if (isBillingClassificationEnabled)
        {
            if (inclTransWithNoBillingClassifications == NoYes::Yes)
            {
                if (billingClassificationIds != "")
                {
                    billingClassificationIds = billingClassificationIds + #BillingClassificationSelected;
                }
                else
                {
                    billingClassificationIds = billingClassificationIds + #NoBillingClassificationSelected;
                }
            }

            billingClassificationIds = Global::strReplace(billingClassificationIds, ";",",");
            queryRun.query().dataSourceTable(tableNum(CustTrans)).addRange(fieldNum(CustTrans, CustBillingClassification)).value(billingClassificationIds);
            queryRun.query().dataSourceTable(tableNum(CustTrans)).addSortField(fieldNum(CustTrans, CustBillingClassification), SortOrder::Ascending);
        }

        queryRun.query().title("@SYS25863");
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    ///    The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    ///    This method is used if a query prompt is the dialog, and if a Select menu item is added to a dialog
    ///    box. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it in
    ///    the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetCustInterest</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>CustInterest</c> buffer based on the <c>CustTrans</c> posting profile.
    /// </summary>
    /// <param name="_custTrans">
    /// A <c>CustTrans</c> record.
    /// </param>
    /// <param name="_custBillingCodeRecId">
    /// The Billing code record ID; optional.
    /// </param>
    /// <param name="_interestLineType">
    /// The interest line type.
    /// </param>
    /// <returns>
    ///    true if the <c>CustInterest</c> buffer is initialized; otherwise, false.
    /// </returns>
    protected boolean resetCustInterest(
        CustTrans _custTrans,
        BillingCodeRefRecId _custBillingCodeRecId = 0,
        CustInterestLineType _interestLineType = CustInterestLineType::Customer)
    {
        if (this.isCustPublicSectorTransaction(_custTrans.TransType) || this.isInterestPublicSectorTransaction(_custTrans.TransType))
        {
            switch (_interestLineType)
            {
                case CustInterestLineType::MiscCharges:

                    this.resetCustInterestForMiscCharges(_custTrans);

                    break;

                case CustInterestLineType::Customer:

                    this.resetCustInterestForInvoiceLine(_custTrans, _custBillingCodeRecId);

                    break;
            }
        }
        else
        {
            this.resetCustInterestDefault(_custTrans);
        }

        return custInterest.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetCustInterestForInvoiceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>CustInterest</c> buffer for the Free Text invoice line.
    /// </summary>
    /// <param name="_custTrans">
    /// A <c>CustTrans</c> record.
    /// </param>
    /// <param name="_custBillingCodeRecId">
    /// The Billing code record ID; optional.
    /// </param>
    /// <returns>
    /// The interest record associated with the invoice line.
    /// </returns>
    protected CustInterest resetCustInterestForInvoiceLine(CustTrans _custTrans, BillingCodeRefRecId _custBillingCodeRecId = 0)
    {
        RefRecId custInterestRecId;
        CustPostingProfile custPostingProfile;

        if (_custTrans.TransType == LedgerTransType::Cust || this.isInterestPublicSectorTransaction(_custTrans.TransType))
        {
            switch (this.postingSpec())
            {
                case InterestCalcAccountChoice::Selection :

                    custPostingProfile = this.postingProfile();
                    if (!custPostingProfile)
                    {
                        throw error("@SPS2265");
                    }

                    custInterest = this.resetCustInterestForInvoiceLineByCustPostingProfile(_custTrans, custPostingProfile);
                    if (custInterest)
                    {
                        return custInterest;
                    }

                case InterestCalcAccountChoice::Account:

                    custPostingProfile = CustParameters::find().PostingProfile;
                    if (! custPostingProfile)
                    {
                        throw error("@SYS26844");
                    }

                    custInterest = this.resetCustInterestForInvoiceLineByCustPostingProfile(_custTrans, custPostingProfile);
                    break;

                case InterestCalcAccountChoice::Transaction:

                    [custInterestRecId, interestCodeSource] = CustBillingCodeVersion::interestCode(_custTrans, _custBillingCodeRecId);

                    //Re - setting custInterest
                    custInterest = CustInterest::find(custInterestRecId);
                    break;
            }
        }

        return custInterest;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetCustInterestForInvoiceLineByCustPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>CustInterest</c> buffer for the Free Text invoice line based on the customer posting profile ID.
    /// </summary>
    /// <param name="_custTrans">
    /// A <c>CustTrans</c> record.
    /// </param>
    /// <param name="_custPostingProfile">
    /// The posting profile ID used for the lookup.
    /// </param>
    /// <returns>
    /// The interest record associated with the invoice line.
    /// </returns>
    protected CustInterest resetCustInterestForInvoiceLineByCustPostingProfile(CustTrans _custTrans, CustPostingProfile _custPostingProfile, boolean _useCustomFind = false)
    {
        CustInterest custInterestLocal;
        if (!_useCustomFind)
        {
            custInterestLocal = CustInterest::find(CustLedgerAccounts::custInterest(_custTrans.AccountNum, _custPostingProfile, false));
        }
        return custInterestLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetCustInterestForMiscCharges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>CustInterest</c> buffer for the miscellenous charge associated with Free text invoice line.
    /// </summary>
    /// <param name="_custTrans">
    /// A <c>CustTrans</c> record.
    /// </param>
    private void resetCustInterestForMiscCharges(CustTrans _custTrans)
    {
        RefRecId custInterestRecId;
        [custInterestRecId, interestCodeSource] = CustBillingClassification::interestCode(_custTrans);

        //Re-setting custInterest
        custInterest = CustInterest::find(custInterestRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetCustInterestDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>CustInterest</c> buffer.
    /// </summary>
    /// <param name="_custTrans">
    /// A <c>CustTrans</c> record.
    /// </param>
    protected void resetCustInterestDefault(CustTrans _custTrans, boolean _useCustomFind = false)
    {
        if (!_useCustomFind)
        {
            custInterest = CustInterest::find(CustLedgerAccounts::custInterest(_custTrans.AccountNum, _custTrans.PostingProfile, false));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundOff</Name>
				<Source><![CDATA[
    protected AmountCur roundOff()
    {
        return roundOff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        #OCCRetryCount
        #AviFiles
        System.Exception exception;
        Microsoft.Dynamics.Ax.Xpp.DeadlockException deadLockException;
        Microsoft.Dynamics.Ax.Xpp.UpdateConflictException updateConflictException;
        Microsoft.Dynamics.Ax.Xpp.TransientSqlConnectionError transientSqlConnectionError;

        this.progressInit("@SYS19775", this.progressTotal(queryRun), #AviFindFile);

        try
        {
            if (FeatureStateProvider::isFeatureEnabled(CustInterestCreateBatchParallelismFeature::instance()) && this.isInBatch())
            {
                if (isChildTask || isFinalTask)
                {
                    this.executeTask();
                }
                else
                {
                    this.initializeProcess();
                    this.createBatchProcessTasks();
                }
            }
            else
            {
                //Run CustInterestCreate Synchronously
                this.setRanges(true);
                this.runOnce();
            }
        }
        catch (deadLockException)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw deadLockException;
            }
            else
            {
                sleep(RetryInterval * xSession::currentRetryCount());
                retry;
            }
        }
        catch (updateConflictException)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw updateConflictException;
            }
            else
            {
                sleep(RetryInterval * xSession::currentRetryCount());
                retry;
            }
        }
        catch (transientSqlConnectionError)
        {
            // Handled by batch retryable
            throw transientSqlConnectionError;
        }
        catch (exception)
        {
            throw error("@SYS18447");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBatchProcessTasks</Name>
				<Source><![CDATA[
    private void createBatchProcessTasks()
    {
        BatchHeader batchHeader = BatchHeader::getCurrentBatchHeader();

        CustInterestCreate finalProcessTask = this.createFinalProcessTask(batchHeader);

        this.createTopPickTasks(finalProcessTask, batchHeader);
        
        batchHeader.save();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFinalProcessTask</Name>
				<Source><![CDATA[
    private CustInterestCreate createFinalProcessTask(BatchHeader _batchHeader)
    {
        CustInterestCreate finalProcessTask = CustInterestCreate::construct();
        finalProcessTask.unpack(this.pack());
        finalProcessTask.setToFinalTask();
        finalProcessTask.batchInfo().parmGroupId(this.parmCurrentBatch().GroupId);
        finalProcessTask.batchInfo().parmCaption("@AccountsReceivable:CustInterestCreateFinalProcessTask");
        
        _batchHeader.addRuntimeTask(finalProcessTask, this.parmCurrentBatch().RecId);
        
        return finalProcessTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTopPickTasks</Name>
				<Source><![CDATA[
    private void createTopPickTasks(CustInterestCreate _finalProcessTask, BatchHeader _batchHeader)
    {
        for (int i = 1; i <= numberOfTasks; i++)
        {
            CustInterestCreate topPickTask = CustInterestCreate::construct();
            topPickTask.unpack(this.pack());
            topPickTask.setToChildTask();
            topPickTask.batchInfo().parmGroupId(this.parmCurrentBatch().GroupId);
            topPickTask.batchInfo().parmCaption("@AccountsReceivable:CustInterestCreateTopPickTask");

            _batchHeader.addRuntimeTask(topPickTask, this.parmCurrentBatch().RecId);
            _batchHeader.addDependency(_finalProcessTask, topPickTask, BatchDependencyStatus::FinishedOrError);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeTask</Name>
				<Source><![CDATA[
    private void executeTask()
    {
        UserConnection secondConnection;
        try
        {
            secondConnection = new UserConnection();
            this.doProcessTasks(secondConnection);
        }
        finally
        {
            secondConnection.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doProcessTasks</Name>
				<Source><![CDATA[
    private void doProcessTasks(UserConnection _secondConnection)
    {
        System.Exception exception;
        Microsoft.Dynamics.Ax.Xpp.DeadlockException deadLockException;
        Microsoft.Dynamics.Ax.Xpp.UpdateConflictException updateConflictException;
        Microsoft.Dynamics.Ax.Xpp.TransientSqlConnectionError transientSqlConnectionError;

        int rowsProcessedByTask;
        CustInterestCreateWorkItems custInterestCreateWorkItems;
        custInterestCreateWorkItems.setConnection(_secondConnection);
        custInterestCreateWorkItems.readPast(!isFinalTask);

        using (SysInstrumentationActivityContext activityContext = this.getActivityContextForRun(CustCreditInstrumentationConstants::CustInterestCreateExecuteTask))
        {
            this.addBatchContext(activityContext, this.parmCurrentBatch());
            do
            {
                try
                {
                    _secondConnection.ttsbegin();
                    custInterestCreateWorkItems.clear();
                    select firstonly pessimisticlock * from custInterestCreateWorkItems
                                where custInterestCreateWorkItems.ProcessId == processId;

                    if (custInterestCreateWorkItems)
                    {
                        queryRun = new QueryRun(packedQuery);
                        this.setRanges(true);
                        queryRun.query().dataSourceTable(tableNum(CustTrans)).addRange(fieldNum(CustTrans, AccountNum)).value(custInterestCreateWorkItems.AccountNum);

                        this.runOnce();

                        custInterestCreateWorkItems.delete();
                        rowsProcessedByTask++;
                    }

                    _secondConnection.ttscommit();
                }
                catch (deadLockException)
                {
                    // Critical system error handling has been put at the outer scope, re-throw the error to method run()
                    throw deadLockException;
                }
                catch (updateConflictException)
                {
                    throw updateConflictException;
                }
                catch (transientSqlConnectionError)
                {
                    throw transientSqlConnectionError;
                }
                catch (exception)
                {
                    // Business logic error handling at the inner scope
                    if (CustInterestCreateUpdateCatchBlockDeleteFlight::instance().isEnabled())
                    {
                        custInterestCreateWorkItems.delete();

                        _secondConnection.ttscommit();
                    }
                    else
                    {
                        CustInterestCreateWorkItems custInterestCreateWorkItemsToDelete;

                        ttsbegin;

                        delete_from custInterestCreateWorkItemsToDelete
                            where custInterestCreateWorkItemsToDelete.AccountNum == custInterestCreateWorkItems.AccountNum
                                && custInterestCreateWorkItemsToDelete.ProcessId == processId;

                        ttscommit;
                    }

                    throw exception;
                }
            }
            while (custInterestCreateWorkItems);
            
            activityContext.addCustomProperty(CustCreditInstrumentationConstants::NumberOfRowsProcessedByTask, ApplicationCommonInstrumentationMagnitude::log10Magnitude(rowsProcessedByTask));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setToChildTask</Name>
				<Source><![CDATA[
    internal void setToChildTask()
    {
        isChildTask = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setToFinalTask</Name>
				<Source><![CDATA[
    private void setToFinalTask()
    {
        isFinalTask = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityContextForRun</Name>
				<Source><![CDATA[
    private SysInstrumentationActivityContext getActivityContextForRun(str _activityName)
    {
        if (!custInstrumentationLogger) 
        {
            custInstrumentationLogger = CustInstrumentationLogger::newFromInstrumentationNameSpace(CustCreditInstrumentationConstants::CustomerCreditInstrumentationNamespace);
        }
        
        return custInstrumentationLogger.activityContext(custInstrumentationLogger.activity(_activityName, CustCreditInstrumentationConstants::CustomerCreditInstrumentationNamespace));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBatchContext</Name>
				<Source><![CDATA[
    private void addBatchContext(SysInstrumentationActivityContext activityContext, Batch _batch)
    {
        activityContext.addCustomProperty(CustCreditInstrumentationConstants::ProcessId,  guid2Str(processId));
        if (_batch.RecId)
        {
            activityContext.addCustomProperty(CustCreditInstrumentationConstants::Batch, int642Str(_batch.RecId));
            activityContext.addCustomProperty(CustCreditInstrumentationConstants::BatchJobId, int642Str(_batch.BatchJobId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProcess</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void initializeProcess(Query _query = queryRun.query())
    {
        processId = processId ? processId : newGuid();

        // Since Query::insert_recordset could not handle query with both CustTransOpen and CustSettlement together, we have to do the join and insertion separately
        CustInterestCreateWorkItems custSettlementTmpTable;
        custSettlementTmpTable.setTempDB();
        this.fillTargetTempTable(new Query(_query.pack()), custSettlementTmpTable, tableNum(CustTransOpen), tableNum(CustSettlement));
        CustInterestCreateWorkItems custTransOpenTmpTable;
        custTransOpenTmpTable.setTempDB();
        this.fillTargetTempTable(new Query(_query.pack()), custTransOpenTmpTable, tableNum(CustSettlement), tableNum(CustTransOpen));
        this.unionFilteredTmpTable(custSettlementTmpTable, custTransOpenTmpTable, processId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillTargetTempTable</Name>
				<Source><![CDATA[
    private void fillTargetTempTable(Query _query, CustInterestCreateWorkItems _targetTempDB, TableId _excluded, TableId _included)
    {
        this.prepareTargetQuery(_query);

        _query.dataSourceTable(_excluded).enabled(false);
            
        QueryBuildDataSource custTableQBDS = _query.dataSourceTable(tableNum(CustTable));
        custTableQBDS.addGroupByAndSelectionField(fieldNum(CustTable, AccountNum));

        QueryBuildDataSource custTransQBDS = _query.dataSourceTable(tableNum(CustTrans));
        custTransQBDS.addGroupByField(fieldNum(CustTrans, CustBillingClassification));

        if (CustInterestCreateMultithreadQueryFlight::instance().isEnabled())
        {
            custTransQBDS.fetchMode(QueryFetchMode::One2One);

            // '_included' parameter has been added to the method signature to pass CustTransOpen and CustSettlement table ids respectively, so that their fetchMode can be updated each time the method is called in initializeProcess().
            QueryBuildDataSource includedQBDS = _query.dataSourceTable(_included);
            includedQBDS.fetchMode(QueryFetchMode::One2One);
        }

        Map targetToSourceMap = new Map(Types::String, Types::Container);
        targetToSourceMap.insert(fieldStr(CustInterestCreateWorkItems, AccountNum), [custTableQBDS.uniqueId(), fieldStr(CustTable, AccountNum)]);

        Query::insert_recordset(_targetTempDB, targetToSourceMap, _query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareTargetQuery</Name>
				<Source><![CDATA[
    private void prepareTargetQuery(Query _query)
    {
        #define.BillingClassificationSelected(';0')
        #define.NoBillingClassificationSelected('0')

        _query.clearAllFields();
        _query.clearOrderBy();
        _query.clearGroupBy();

        _query.dataSourceTable(tableNum(CustTransOpen)).findRange(fieldNum(CustTransOpen, DueDate)).value(strFmt('%1..%2', this.fromDate(), this.toDate()));
        _query.dataSourceTable(tableNum(CustSettlement)).findRange(fieldNum(CustSettlement, DueDate)).value(strFmt('%1..%2', this.fromDate(), this.toDate()));
    
        if (isBillingClassificationEnabled)
        {
            if (inclTransWithNoBillingClassifications == NoYes::Yes)
            {
                if (billingClassificationIds != "")
                {
                    billingClassificationIds = billingClassificationIds + #BillingClassificationSelected;
                }
                else
                {
                    billingClassificationIds = billingClassificationIds + #NoBillingClassificationSelected;
                }
            }

            billingClassificationIds = Global::strReplace(billingClassificationIds, ";",",");
            _query.dataSourceTable(tableNum(CustTrans)).addRange(fieldNum(CustTrans, CustBillingClassification)).value(billingClassificationIds);
            _query.dataSourceTable(tableNum(CustTrans)).addSortField(fieldNum(CustTrans, CustBillingClassification), SortOrder::Ascending);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unionFilteredTmpTable</Name>
				<Source><![CDATA[
    private void unionFilteredTmpTable(CustInterestCreateWorkItems _custSettlementTmpTable, CustInterestCreateWorkItems _custTransOpenTmpTable, guid _processId)
    {
        CustInterestCreateWorkItems custInterestCreateWorkItems;
        ttsbegin;

        insert_recordset custInterestCreateWorkItems (AccountNum, ProcessId)
            select AccountNum, _processId
            from _custSettlementTmpTable;

        insert_recordset custInterestCreateWorkItems (AccountNum, ProcessId)
            select AccountNum, _processId
                from _custTransOpenTmpTable
            notexists join _custSettlementTmpTable
                where _custSettlementTmpTable.AccountNum == _custTransOpenTmpTable.AccountNum;
    
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runForCustSettlementIncluded</Name>
				<Source><![CDATA[
    private boolean runForCustSettlementIncluded(CustTable _custTable, CustSettlement _custSettlement, CustTrans _custTrans, CustInterestJour _custInterestJour)
    {
        CustTrans offsetCustTrans;
        AmountCur calculationAmount;
        TransDate calcFrom;
        TransDate calcTo;

        boolean calculationCompleted;

        if (this.isCustPublicSectorTransaction(_custTrans.TransType))
        {
            calculationCompleted = this.runForSettledInvoiceLine(_custTable, _custSettlement, _custTrans, _custInterestJour);
        }
        else
        {
            if (_custSettlement.TransDate == _custTrans.TransDate)
            {
                offsetCustTrans = CustTrans::findByCompany(_custSettlement.OffsetCompany, _custSettlement.OffsetRecid);
                _custSettlement.TransDate = max(_custSettlement.TransDate, offsetCustTrans.TransDate);
            }

            calculationAmount = _custSettlement.SettleAmountCur;
            calcFrom = this.getFromDate(_custSettlement.LastInterestDate, _custSettlement.DueDate, _custSettlement.TransDate);
            calcTo = min(_custSettlement.TransDate, this.toDate());

            if (!this.validateTransaction(_custTable.Currency, _custTrans, calcFrom, calcTo, calculationAmount, tableNum(CustSettlement)))
            {
                return false;
            }
        }

        return this.calcPeriod(_custTable, _custTrans, _custInterestJour, calcFrom, calcTo, _custSettlement.DueDate, false, calculationAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runForCustSettlementOther</Name>
				<Source><![CDATA[
    private boolean runForCustSettlementOther(CustTable _custTable, CustSettlement _custSettlement, CustTrans _custTrans, CustInterestJour _custInterestJour)
    {
        AmountCur calculationAmount;
        TransDate calcFrom;
        TransDate calcTo;

        calculationAmount = _custSettlement.SettleAmountCur;
        calcFrom = this.getFromDate(_custSettlement.LastInterestDate, _custSettlement.DueDate, _custSettlement.TransDate);
        calcTo = min(_custSettlement.TransDate, this.toDate());

        return this.calcPeriod(_custTable, _custTrans, _custInterestJour, calcFrom, calcTo, _custSettlement.DueDate, true, calculationAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runForCustTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and creates <c>CustInterestJour</c>record based on <c>CustTable</c> buffer.
    /// </summary>
    /// <param name = "_custTable">
    /// A <c>CustTable</c> table buffer.
    /// </param>
    /// <param name = "_custInterestJour">
    /// A <c>CustInterestJour</c> table buffer.
    /// </param>
    protected void runForCustTable(CustTable _custTable, CustInterestJour _custInterestJour)
    {
        CustInterestCreationErrorType custInterestCreationErrorType;
        CustPostingProfile custPostingProfile;

        this.progressUpdate('', true);

        [custInterestCreationErrorType, custPostingProfile] = this.newAccount(_custTable);

        // Get the fee that will be applied on the note.
        custInterestVersion = CustInterestVersion::findByDate(custInterest.RecId, this.toDate());
        custInterestVersionDetail = CustInterestVersionDetail::findByFeeType(custInterestVersion.RecId, CustInterestFeeType::Earning);
        custInterestFee = CustInterestFee::findByCustInterestVersionDetail(custInterestVersionDetail.RecId, _custTable.Currency);

        if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
        {
            paymCalendarCustInterest = PaymCalendarCustInterest::findByCustInterest(custInterest.RecId);
        }

        _custInterestJour.clear();

        _custInterestJour.initFromCustTable(_custTable);

        _custInterestJour.FromDate = this.fromDate();
        _custInterestJour.ToDate = this.toDate();
        _custInterestJour.Fee = custInterestFee ? CurrencyExchangeHelper::amount(custInterestFee.Fee, _custTable.Currency) : 0;
        _custInterestJour.PostingProfile = custPostingProfile;
        _custInterestJour.InterestCalcAccountChoice = this.postingSpec();

        if (isBillingClassificationEnabled
            && isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            _custInterestJour.CustBillingClassification = currentCustBillingClassificationId;
        }

        interestFound = false;
        interestSum = 0;
        lineNum = 0;
        isCompanyCurrencyUsed = false;
        interestCalculationResultSet = new Set(Types::Enum);

        if (this.postingSpec() != this.getInterestCalcAccountChoiceTransaction() && custInterestCreationErrorType == CustInterestCreationErrorType::MissingARPostingProfileSetupRecord)
        {
            interestCalculationResultSet.add(custInterestCreationErrorType);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCustTransOpen</Name>
				<Source><![CDATA[
    private boolean processCustTransOpen(CustTable _custTable, CustTransOpen _custTransOpen, CustTrans _custTrans, CustInterestJour _custInterestJour)
    {
        AmountCur calculationAmount;
        TransDate calcFrom;
        TransDate calcTo;

        boolean calculationCompleted;

        if (this.isCustPublicSectorTransaction(_custTrans.TransType))
        {
            calculationCompleted = this.runForUnsettledInvoiceLine(_custTable, _custTransOpen, _custTrans, _custInterestJour);

            return calculationCompleted;
        }
        else
        {
            calculationAmount = _custTransOpen.AmountCur;
            calcFrom = this.getFromDate(_custTransOpen.LastInterestDate, _custTransOpen.DueDate, _custTransOpen.TransDate);
            calcTo = this.toDate();

            if (!this.validateTransaction(_custTable.Currency, _custTrans, calcFrom, calcTo, calculationAmount, tableNum(CustTransOpen)))
            {
                return false;
            }

            return this.calcPeriod(_custTable, _custTrans, _custInterestJour, calcFrom, calcTo, _custTransOpen.DueDate, false, calculationAmount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runForSettledInvoiceLine</Name>
				<Source><![CDATA[
    private boolean runForSettledInvoiceLine(CustTable _custTable, CustSettlement _custSettlement, CustTrans _custTrans, CustInterestJour _custInterestJour)
    {
        AmountCur calculationAmount;
        TransDate calcFrom;
        TransDate calcTo;
        TmpCustInterestTransLine tmpCustInterestTransLine;

        delete_from tmpCustInterestTransLine;

        calculationAmount = _custSettlement.SettleAmountCur;
        calcFrom = this.getFromDate(_custSettlement.LastInterestDate, _custSettlement.DueDate, _custSettlement.TransDate);
        calcTo = min(_custSettlement.TransDate, this.toDate());

        if (!this.getINTLinesFromCustSettlementLines(tmpCustInterestTransLine, _custTable, _custSettlement, _custTrans))
        {
            if (!this.getINTLinesFromCustInvoiceTrans(tmpCustInterestTransLine, _custTable, _custTrans, calcFrom, calcTo, calculationAmount))
            {
                return false;
            }

            this.getINTLineForMiscCharges(tmpCustInterestTransLine, _custTable, _custTrans, calcFrom, calcTo, calculationAmount);
        }

        _custInterestJour.CustBillingClassification = _custTrans.CustBillingClassification;

        return this.calcPeriodForInvoiceLine(tmpCustInterestTransLine, _custTable, _custTrans, _custInterestJour, calcFrom, calcTo, _custSettlement.DueDate, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runForUnsettledInvoiceLine</Name>
				<Source><![CDATA[
    private boolean runForUnsettledInvoiceLine(CustTable _custTable, CustTransOpen _custTransOpen, CustTrans _custTrans, CustInterestJour _custInterestJour)
    {
        AmountCur calculationAmount;
        TransDate calcFrom;
        TransDate calcTo;
        TmpCustInterestTransLine tmpCustInterestTransLine;

        delete_from tmpCustInterestTransLine;

        calculationAmount = _custTransOpen.AmountCur;
        calcFrom = this.getFromDate(_custTransOpen.LastInterestDate, _custTransOpen.DueDate, _custTransOpen.TransDate);
        calcTo = this.toDate();

        if (!this.getINTLinesFromCustTransOpenLine(tmpCustInterestTransLine, _custTable, _custTransOpen, _custTrans))
        {
            if (!this.getINTLinesFromCustInvoiceTrans(tmpCustInterestTransLine, _custTable, _custTrans, calcFrom, calcTo, calculationAmount))
            {
                return false;
            }

            this.getINTLineForMiscCharges(tmpCustInterestTransLine, _custTable, _custTrans, calcFrom, calcTo, calculationAmount);
        }

        _custInterestJour.CustBillingClassification = _custTrans.CustBillingClassification;

        return this.calcPeriodForInvoiceLine(tmpCustInterestTransLine, _custTable, _custTrans, _custInterestJour, calcFrom, calcTo, _custTransOpen.DueDate, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runForCustTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if interest creation can be run based on open transactions.
    /// </summary>
    /// <param name = "_custTable">The current <c>CustTable</c> table buffer.</param>
    /// <param name = "_custInterestJour">The current <c>CustInterestJour</c> table buffer.</param>
    /// <returns>true if interest creation can be run based on open transactions; otherwise, false.</returns>
    protected boolean runForCustTransOpen(CustTable _custTable, CustInterestJour _custInterestJour)
    {
        CustTransOpen custTransOpen = queryRun.get(tableNum(CustTransOpen));
        CustTrans custTrans;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            custTrans = queryRun.get(tableNum(CustTrans));
        }
        else
        {
            custTrans = queryRun.getNo(queryRun.query().dataSourceName('CustTrans').id());
        }

        this.progressUpdate(strFmt("@SYS27235", _custTable.AccountNum, custTrans.Voucher), false);

        if (this.checkOpenTrans(custTransOpen.DueDate, custTrans))
        {
            return this.processCustTransOpen(_custTable, custTransOpen, custTrans, _custInterestJour);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runForCustSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if interest creation can be run based on customer settlements.
    /// </summary>
    /// <param name = "_custTable">The current <c>CustTable</c> table buffer.</param>
    /// <param name = "_custInterestJour">The current <c>CustInterestJour</c> table buffer.</param>
    /// <returns>true if interest creation can be run based on customer settlements; otherwise, false.</returns>
    protected boolean runForCustSettlement(CustTable _custTable, CustInterestJour _custInterestJour)
    {
        CustSettlement custSettlement = queryRun.get(tableNum(CustSettlement));
        CustTrans custTrans;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            custTrans = queryRun.get(tableNum(CustTrans));
        }
        else
        {
            custTrans = queryRun.getNo(queryRun.query().dataSourceName('CustTransForSettlement').id());
        }

        if (this.checkSettlement(custSettlement.DueDate, custSettlement.TransDate, custSettlement.CanBeReversed, custTrans))
        {
            return this.runForCustSettlementIncluded(_custTable, custSettlement, custTrans, _custInterestJour);
        }

        if (this.fullPay() != CustInterestCalc::Open && this.creditNote() && custTrans.Interest && custTrans.isCreditNote() && custSettlement.DueDate < custSettlement.TransDate)
        {
            return this.runForCustSettlementOther(_custTable, custSettlement, custTrans, _custInterestJour);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runOnce</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void runOnce()
    {
        CustTable custTable;
        CustInterestJour custInterestJour;
        CustTrans currentCustTrans;
        
        this.queryBuildUpdate();

        while (queryRun.next())
        {
            if (isBillingClassificationEnabled)
            {
                if (queryRun.changed(tableNum(CustTrans)))
                {
                    currentCustTrans = queryRun.get(tableNum(CustTrans));
                }
                if (queryRun.changed(tableNum(CustTable)) || (currentCustTrans.CustBillingClassification != currentCustBillingClassificationId))
                {
                    currentCustBillingClassificationId = currentCustTrans.CustBillingClassification;
                    if (custTable)
                    {
                        this.createInterestNote(custInterestJour);
                        ttscommit;
                    }

                    ttsbegin;
                    custTable.data(queryRun.get(tableNum(CustTable)));

                    this.runForCustTable(custTable, custInterestJour);
                }
            }
            else
            {
                if (queryRun.changed(tableNum(CustTable)))
                {
                    if (custTable)
                    {
                        this.createInterestNote(custInterestJour);
                        ttscommit;
                    }

                    ttsbegin;
                    custTable.data(queryRun.get(tableNum(CustTable)));

                    this.runForCustTable(custTable, custInterestJour);
                }
            }

            if (!this.excludeCustInterestCharges(custTable) && (this.custInterest || this.postingSpec() == this.getInterestCalcAccountChoiceTransaction()))
            {
                if (queryRun.changed(tableNum(CustTransOpen)))
                {
                    if (!this.runForCustTransOpen(custTable, custInterestJour))
                    {
                        continue;
                    }
                }

                if (queryRun.changed(tableNum(CustSettlement)))
                {
                    if (!this.runForCustSettlement(custTable, custInterestJour))
                    {
                        continue;
                    }
                }
            }
        }

        if (custTable)
        {
            this.createInterestNote(custInterestJour);
            ttscommit;
        }

        // Show interest note creation error
        if (!interestNoteCreated)
        {
            if (transactionHasValidFilter)
            {
                if (!transactionHasValidVersion)
                {
                    warning("@SYS330221");
                }
            }
            else
            {
                info("@SYS330220");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>excludeCustInterestCharges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether interest charges are excluded for the given customer.
    /// </summary>
    /// <param name = "_custTable">The current <c>CustTable</c> table buffer.</param>
    /// <returns>true if interest charges are excluded for the given customer; otherwise, false.</returns>
    protected boolean excludeCustInterestCharges(CustTable _custTable)
    {
        return _custTable.CustExcludeInterestCharges;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the batch task is run on the server or on a client.
    /// </summary>
    /// <returns>
    ///    true if the task is run on the server; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Your classes that extend the <c>RunBaseBatch</c> class must override the <c>runsImpersonated</c>
    ///    method and return false if you want those tasks to run on a client.
    /// </remarks>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAdditionalCustInterestTransFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the additional field values for fields related to derived classes.
    /// </summary>
    /// <param name="_custInterestTrans">
    ///    <c>CustInterestTrans</c> record to set fields on.
    /// </param>
    protected void setAdditionalCustInterestTransFields(CustInterestTrans _custInterestTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAdditionalCustInterestTransLineFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the additional field values for fields related to derived classes.
    /// </summary>
    /// <param name="_custInterestTransLine">
    ///    <c>CustInterestTransLine</c> record to set fields on.
    /// </param>
    protected void setAdditionalCustInterestTransLineFields(CustInterestTransLine _custInterestTransLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCalcTo</Name>
				<Source><![CDATA[
    protected container setCalcTo(AmountCur _calculationAmount, TransDate _calcFrom, TransDate _calcTo, TransDate _endDate, Integer _interestDays, boolean _resetInterestVersion)
    {
        if (custInterest.CustInterestType == CustInterestType::MultipleRate)
        {
            if (_calcFrom <= _endDate)
            {
                // Do not reset the CustInterestVersion if the version has already been set by setCurrentVersion(..) method.
                if (_resetInterestVersion)
                {
                    custInterestVersion = CustInterestVersion::findByDate(custInterest.RecId, _calcFrom);
                }

                if (custInterestVersion)
                {
                    custInterestVersionDetail = CustInterestVersionDetail::findByFeeType(
                            custInterestVersion.RecId,
                            CustInterestCreate::custInterestFeeType(_calculationAmount));

                    _interestDays = 0;
                    _calcTo = min(custInterestVersion.ValidTo, _endDate);
                }
            }
        }
        return [_calcTo, _interestDays];
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCurrentVersion</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the version for interest calculation.
    /// </summary>
    /// <param name="_custInterestFeeType">
    ///    The interest fee type.
    /// </param>
    /// <param name="_calcTo">
    ///    The end date of the calculation period.
    /// </param>
    /// <param name="_versionDate">
    ///   The date to be used for the retrieval of interest version.
    /// </param>
    protected void setCurrentVersion(CustInterestFeeType _custInterestFeeType, TransDate _calcTo, TransDate _versionDate)
    {
        custInterestVersion = CustInterestVersion::findByDate(custInterest.RecId, _versionDate);
        custInterestVersionDetail = CustInterestVersionDetail::findByFeeType(custInterestVersion.RecId, _custInterestFeeType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInterestCalc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the instance variables based on the interest calculation category type.
    /// </summary>
    /// <param name="_interestCalcCategory">
    ///    An interest calculation category type.
    /// </param>

    protected void setInterestCalc(InterestCalcCategory _interestCalcCategory)
    {
        switch (_interestCalcCategory)
        {
            // set paramter for interest note generation for a customer
            case InterestCalcCategory::InterestNotePerCustomer:
                includeInvoices = NoYes::Yes;
                break;

            // set paramter for interest note generation for an invoice
            case InterestCalcCategory::InterestNotePerInvoice:
                includeInvoices = NoYes::Yes;
                interestNoteForSelectedInvoice = NoYes::Yes;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLogPrefix</Name>
				<Source><![CDATA[
    protected void setLogPrefix(CustTable _custTable)
    {
        logPrefix = #PreFixField(_custTable, AccountNum, _custTable.AccountNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRange</Name>
				<Source><![CDATA[
    protected void setRange(str _datasourceName, FieldId fieldId, str value, RangeStatus rangeStatus = RangeStatus::Open)
    {
        QueryBuildRange range;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            range = queryRun.query().dataSourceTable(tableName2id(_datasourceName)).addRange(fieldId);
        }
        else
        {
            range = queryRun.query().dataSourceName(_datasourceName).addRange(fieldId);
        }

        range.value(value);
        range.status(rangeStatus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRanges</Name>
				<Source><![CDATA[
    void setRanges(boolean _copyCustTransRanges)
    {
        CustTrans custTrans;
        SetEnumerator accountNumEnum;
        QueryBuildDataSource dsFrom;
        QueryBuildDataSource dsTo;
        QueryBuildRange rangeFrom;
        QueryBuildRange rangeTo;
        int i;

        if (!custAccountsRestriction.empty())
        {
            accountNumEnum = custAccountsRestriction.getEnumerator();

            // Note: Although this is public sector code on fpk but it doesn't need to check for config key
            // because the ranges should be cleared in the same way for both ON and OFF cases on fpk layer.
            queryRun.query().dataSourceTable(tableNum(CustTable)).clearRanges();
            queryRun.query().dataSourceTable(tableNum(CustTrans)).clearRanges();

            while (accountNumEnum.moveNext())
            {
                // set a range for every account number in the restrictions container
                this.setRange('CustTable', fieldNum(CustTable, AccountNum), accountNumEnum.current());
            }
        }

        // set a range for the invoice restriction
        if (custTransRestriction)
        {
            custTrans = CustTrans::find(custTransRestriction);

            if (custTrans.Invoice)
            {
                this.setRange('CustTrans', fieldNum(CustTrans, Invoice), queryValue(custTrans.Invoice));
            }
            else
            {
                this.setRange('CustTrans', fieldNum(CustTrans, Voucher), queryValue(custTrans.Voucher));
            }
        }

        if (_copyCustTransRanges)
        {
            // Find or add CustTrans to CustSettlement
            dsTo = null;
            dsFrom = queryRun.query().dataSourceTable(tableNum(CustSettlement));

            if (!isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) || dsFrom)
            {
                for (i = 1; i < dsFrom.childDataSourceCount(); i++)
                {
                    if (dsFrom.childDataSourceNo(i).table() == tableNum(CustTrans))
                    {
                        dsTo = dsFrom.childDataSourceNo(i);
                        break;
                    }
                }
            }
            else
            {
                return;
            }

            if (!dsTo)
            {
                dsTo = dsFrom.addDataSource(tableNum(CustTrans), 'CustTransForSettlement');
            }
            dsTo.clearLinks();
            dsTo.addLink(fieldNum(CustSettlement, TransRecId), fieldNum(CustTrans, RecId));
            dsTo.relations(true);

            // copy ranges from CustTransOpen->CustTrans to CustSettlement->CustTrans
            dsTo.clearRanges();
            dsFrom = queryRun.query().dataSourceTable(tableNum(CustTrans));

            if (!isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) || dsFrom)
            {
                for (i = 1; i <= dsFrom.rangeCount(); i++)
                {
                    rangeFrom = dsFrom.range(i);
                    rangeTo = dsTo.addRange(rangeFrom.field(), rangeFrom.fieldArrayIndex(), rangeFrom.rangeType());
                    rangeTo.value(rangeFrom.value());
                    rangeTo.status(rangeFrom.status());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showIndexFields</Name>
				<Source><![CDATA[
    public boolean showIndexFields(TableId _id)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQuerySelectButton</Name>
				<Source><![CDATA[
    boolean showQuerySelectButton()
    {
        // List Pages: if restrictions were passed in then we don't want to allow the end user
        // to change what ranges are in place. This is done from the list page - not in this
        // dialog.
        return custAccountsRestriction.empty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether to add a select button to the dialog box.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    /// <remarks>
    ///    If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    ///    return a valid <c>queryRun</c> object.If you change the return value to the button will no longer
    ///    be added.
    /// </remarks>
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipInterestCalculationFreeTextInvoice</Name>
				<Source><![CDATA[
    private void skipInterestCalculationFreeTextInvoice(TmpCustInterestTransLine _tmpCustInterestTransLine, CustTrans _custTrans, TransDate _calcFrom, boolean _showErrorMsg)
    {
        //Skip invoice
        delete_from _tmpCustInterestTransLine;

        //This boolean variable will track this interest calculation failure of invoice and will show error at the end
        //of interest calculation job.
        skippedFreeTextInvoice = true;

        if (_showErrorMsg && _custTrans.Invoice)
        {
            this.logDateRecordError(_custTrans, _calcFrom);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>toDate</Name>
				<Source><![CDATA[
    protected TransDate toDate()
    {
        return toDate ? toDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustInterestTransMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Drives the summation of remain amount and interest amount for the creation of interest journals.
    /// </summary>
    /// <param name="_custInterestTransMap">
    /// The current map instance in the create journal processing.
    /// </param>
    /// <param name="_custInterestTrans">
    /// The incoming <c>CustInterestTrans</c> record to be added to the map or existing map key.
    /// </param>
    /// <param name="_key">
    /// The key used to select existing map values or create new values.
    /// </param>
    [Wrappable(true)]
    protected final void updateCustInterestTransMap(Map _custInterestTransMap, CustInterestTrans _custInterestTrans, container _key)
    {
        CustInterestTrans custInterestTransBuffer;

        if (_custInterestTransMap.exists(_key))
        {
            custInterestTransBuffer = _custInterestTransMap.lookup(_key);

            custInterestTransBuffer.RemainAmount += _custInterestTrans.RemainAmount;
            custInterestTransBuffer.InterestAmount += _custInterestTrans.InterestAmount;

            _custInterestTransMap.insert(_key, custInterestTransBuffer);
        }
        else
        {
            _custInterestTransMap.insert(_key, _custInterestTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustInterestTransMapDateKey</Name>
				<Source><![CDATA[
    private container getCustInterestTransMapDateKey(CustInterestTrans _custInterestTrans)
    {
        return [_custInterestTrans.CustTransId, _custInterestTrans.DueDate, _custInterestTrans.InterestDays];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustInterestTransMapKey</Name>
				<Source><![CDATA[
    private container getCustInterestTransMapKey(CustInterestTrans _custInterestTrans)
    {
        container key;

        if (custInterest.CustInterestType == CustInterestType::MultipleRate)
        {
            key = [_custInterestTrans.CustTransId, _custInterestTrans.LineNum];
        }
        else
        {
            key = this.getCustInterestTransMapDateKey(_custInterestTrans);
        }

        return key;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Drives the validation logic for the <c>CustInterestCreate</c> class parameters.
    /// </summary>
    /// <param name="_calledFrom">
    /// The reference to the caller object.
    /// </param>
    /// <returns>
    /// true if validation passes; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Validates the inclusion of transactions with and without Billing classifciation.
    /// </remarks>
    public boolean validate(Object _calledFrom = null)
    {
        boolean isValid;

        isValid = super(this);

        if (isBillingClassificationEnabled &&
                (inclTransWithNoBillingClassifications == NoYes::No && billingClassificationIds == ""))
        {
            isValid = checkFailed("@SPS686");
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInterestCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the interest code associated with posting profile of the customer or the transaction.
    /// </summary>
    /// <param name="_currency">
    /// A currency code.
    /// </param>
    /// <param name="_custTrans">
    /// A <c>CustTrans</c> record.
    /// </param>
    /// <param name="_calcFrom">
    ///    The start date of the calculation period.
    /// </param>
    /// <param name="_calcTo">
    ///    The end date of the calculation period.
    /// </param>
    /// <param name="_calculationAmount">
    /// The amount on which interest should be calculated.
    /// </param>
    /// <param name="_custBillingCodeRecId">
    /// The billing code record id.
    /// </param>
    /// <returns>
    /// The interest error type.
    /// </returns>

    public CustInterestCreationErrorType validateInterestCode(CurrencyCode _currency, CustTrans _custTrans, TransDate _calcFrom, TransDate _calcTo, AmountCur _calculationAmount, BillingCodeRefRecId _custBillingCodeRecId = 0)
    {
        CustInterestCreationErrorType custInterestCreationErrorType;

        if (this.postingSpec() == this.getInterestCalcAccountChoiceTransaction() && !this.resetCustInterest(_custTrans, _custBillingCodeRecId))
        {
            custInterestCreationErrorType = CustInterestCreationErrorType::NoInterestCode;
        }
        else
        {
            this.setCurrentVersion(CustInterestCreate::custInterestFeeType(_calculationAmount), _calcTo, _calcFrom);

            if (!custInterestVersionDetail ||
                (custInterestVersionDetail.InterestByRange != CustInterestByRange::None && !CustInterestRange::existByCustInterestFee(custInterestFee.RecId)) ||
                (custInterestVersionDetail.InterestByRange == CustInterestByRange::None && custInterestVersionDetail.InterestCalcType == CustInterestCalcType::Amount &&
                    !CustInterestFee::findByCustInterestVersionDetail(custInterestVersionDetail.RecId, _currency)) ||
                custInterestVersionDetail.InterestInterval <= 0)
            {
                if (!this.isCustPublicSectorTransaction(_custTrans.TransType))
                {
                    this.logDateRecordError(_custTrans, _calcFrom);
                }

                custInterestCreationErrorType = CustInterestCreationErrorType::InvalidVersion;
            }
        }

        return custInterestCreationErrorType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInterestLine</Name>
				<Source><![CDATA[
    private boolean validateInterestLine(TmpCustInterestTransLine _tmpCustInterestTransLine, CurrencyCode _currency, CustTrans _custTrans, TransDate _calcFrom, TransDate _calcTo, AmountCur _calculationAmount, BillingCodeRefRecId _custBillingCodeRecId = 0, boolean _showErrorMsg = true)
    {
        boolean validInterestLine = true;
        CustInterestCreationErrorType custInterestCreationErrorType = CustInterestCreationErrorType::ValidTransaction;

        custInterestCreationErrorType = this.validateInterestCode(_currency, _custTrans, _calcFrom, _calcTo, _calculationAmount, _custBillingCodeRecId);

        switch (custInterestCreationErrorType)
        {
            case CustInterestCreationErrorType::InvalidVersion :

                this.skipInterestCalculationFreeTextInvoice(_tmpCustInterestTransLine, _custTrans, _calcFrom, _showErrorMsg);

            case CustInterestCreationErrorType::NoInterestCode:

                interestCalculationResultSet.add(custInterestCreationErrorType);
                validInterestLine = false;

                break;
        }

        return validInterestLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePostingProfileCust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the customer record belongs to any posting profile.
    /// </summary>
    /// <param name = "_custTable">
    /// The customer record.
    /// </param>
    /// <param name="_custPostingProfile">
    /// The posting profile ID used to find the customer record.
    /// </param>
    /// <returns>
    /// The interest error type.
    /// </returns>
    public CustInterestCreationErrorType validatePostingProfileCust(CustTable _custTable, CustPostingProfile _custPostingProfile)
    {
        CustInterestCreationErrorType custInterestCreationErrorType;

        if (!CustLedgerAccounts::existCustomerInPostingProfile(_custTable.AccountNum, _custPostingProfile) && this.postingSpec() != this.getInterestCalcAccountChoiceTransaction())
        {
            this.logError("@SYS330222");
            custInterestCreationErrorType = CustInterestCreationErrorType::MissingPostingProfile;
        }

        return custInterestCreationErrorType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePostingProfileTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the customer record belongs to any posting profile.
    /// </summary>
    /// <param name = "_custTrans">
    /// The customer transaction record.
    /// </param>
    /// <returns>
    /// The interest error type.
    /// </returns>
    public CustInterestCreationErrorType validatePostingProfileTrans(CustTrans _custTrans)
    {
        CustInterestCreationErrorType custInterestCreationErrorType;

        if (!CustLedgerAccounts::existCustomerInPostingProfile(_custTrans.AccountNum, _custTrans.PostingProfile))
        {
            custInterestCreationErrorType = CustInterestCreationErrorType::MissingARPostingProfileSetupRecord;
            this.logPostingProfileErrors(_custTrans);
        }
        else if (!CustInterest::find(CustLedgerAccounts::custInterest(_custTrans.AccountNum, _custTrans.PostingProfile, false)))
        {
            custInterestCreationErrorType = CustInterestCreationErrorType::NoInterestCode;
            this.logPostingProfileErrors(_custTrans);
        }

        return custInterestCreationErrorType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the transaction.
    /// </summary>
    /// <param name = "_currency">Value of type <c>CurrencyCode</c>.</param>
    /// <param name = "_custTrans">A <c>CustTrans</c> table buffer.</param>
    /// <param name = "_calcFrom">From date value. </param>
    /// <param name = "_calcTo">To date value.</param>
    /// <param name = "_calculationAmount">Calculation amount to be validated.</param>
    /// <param name = "_tableId">Value of type table id.</param>
    /// <returns>
    /// true if customer interest creation error type is not missing posting profile or invalid vesion or no interest code; otherwise, false.
    /// </returns>
    private boolean validateTransaction(CurrencyCode _currency, CustTrans _custTrans, TransDate _calcFrom, TransDate _calcTo, AmountCur _calculationAmount, TableId _tableId)
    {
        CustInterestCreationErrorType custInterestCreationErrorType = CustInterestCreationErrorType::ValidTransaction;

        if (this.postingSpec() == this.getInterestCalcAccountChoiceTransaction())
        {
            custInterestCreationErrorType = this.validatePostingProfileTrans(_custTrans);
        }

        if (custInterestCreationErrorType != CustInterestCreationErrorType::NoInterestCode)
        {
            custInterestCreationErrorType = this.validateInterestCode(_currency, _custTrans, _calcFrom, _calcTo, _calculationAmount);
        }

        if (custInterestCreationErrorType == CustInterestCreationErrorType::MissingPostingProfile ||
                custInterestCreationErrorType == CustInterestCreationErrorType::InvalidVersion ||
                custInterestCreationErrorType == CustInterestCreationErrorType::NoInterestCode)
        {
            if (this.postingSpec() != this.getInterestCalcAccountChoiceTransaction())
            {
                queryRun.query().dataSourceTable(_tableId).enabled(false);
            }

            interestCalculationResultSet.add(custInterestCreationErrorType);
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new <c>CustInterestCreate</c> class instance.
    /// </summary>
    /// <returns>An instance of the <c>CustInterestCreate</c> class.</returns>
    protected static CustInterestCreate construct()
    {
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferencePL00011, funcName());
            return new CustInterestCreate_PL();
        }

        return new CustInterestCreate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructWithArgs</Name>
				<Source><![CDATA[
    public static CustInterestCreate constructWithArgs(Args _args)
    {
        CustInterestCreate custInterestCreate =
            // <GEEPL>
            CustInterestCreate::construct();
        // </GEEPL>

        custInterestCreate.initCustInterestCreateFromArgs(_args);

        return custInterestCreate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructWithParams</Name>
				<Source><![CDATA[
    public static CustInterestCreate constructWithParams(InterestCalcCategory _interestCalcCategory, Set _custAccountsRestriction, RefRecId _custTransRestriction = 0)
    {
        CustInterestCreate custInterestCreate =
            // <GEEPL>
            CustInterestCreate::construct();
        // </GEEPL>

        custInterestCreate.initParams(_interestCalcCategory, _custAccountsRestriction, _custTransRestriction);

        return custInterestCreate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custInterestFeeType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the interest category based on the specified transaction amount.
    /// </summary>
    /// <param name="_amountCur">
    ///    The transaction amount.
    /// </param>
    /// <returns>
    ///    An interest category.
    /// </returns>
    protected static CustInterestFeeType custInterestFeeType(AmountCur _amountCur)
    {
        return _amountCur < 0 ? CustInterestFeeType::Payment : CustInterestFeeType::Earning;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS19775";
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInterestStartDateAndGraceDaysServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the interest start date and the number of grace days according to the payment calendar.
    /// </summary>
    /// <param name="_dueDate">
    ///    The due date of the invoice.
    /// </param>
    /// <param name="_paymentDueDateUpdatePolicy">
    ///    The update policy to use when adjusting the initial start date.
    /// </param>
    /// <param name="_graceDays">
    ///    The unadjusted number of grace days.
    /// </param>
    /// <param name="_isInterestCalendarBased">
    ///    true if the interest start date needs to be adjusted according to payment calendar.
    /// </param>
    /// <param name="_isAdjustGraceDays">
    ///    true if the number of grace day needs to be adjusted according to payment calendar.
    /// </param>
    /// <param name="_custAccount">
    ///    The customer account number.
    /// </param>
    /// <param name="_paymCalendarCustInterest">
    ///    A populated payment calendar customer interest table buffer.
    /// </param>
    /// <returns>
    /// A container holding the start date and the number of grace days.
    /// </returns>
    private static container getInterestStartDateAndGraceDaysServer(
        DueDate _dueDate,
        PaymentDueDateUpdatePolicy _paymentDueDateUpdatePolicy,
        PositiveDays _graceDays,
        boolean _isInterestCalendarBased,
        boolean _isAdjustGraceDays,
        CustAccount _custAccount,
        PaymCalendarCustInterest _paymCalendarCustInterest)
    {
        LogisticsPostalAddress postalAddress;
        PaymCalendar paymCalendar;
        PaymCalendarProcessor paymCalendarProcessor;
        DueDate dueDatePlusGrace;
        DueDate startDate;
        PositiveDays graceDays;

        paymCalendar = PaymCalendar::find(_paymCalendarCustInterest.PaymCalendar);
        paymCalendarProcessor = PaymCalendarProcessor::construct();

        // Set initial start date
        startDate = _dueDate;
        if (_isInterestCalendarBased)
        {
            startDate = paymCalendarProcessor.dueDateIncludingGraceDays(startDate, paymCalendar, 0, null, _paymentDueDateUpdatePolicy);
        }

        // Adjust start date to following business day
        startDate += 1;
        if (_isInterestCalendarBased)
        {
            startDate = paymCalendarProcessor.dueDateIncludingGraceDays(startDate, paymCalendar, 0, null, PaymentDueDateUpdatePolicy::Next);
        }

        // Adjust grace days
        graceDays = _graceDays;
        if (_isAdjustGraceDays)
        {
            if (_paymCalendarCustInterest.IncludeStateHoliday)
            {
                postalAddress = CustTable::find(_custAccount).postalAddress();
                dueDatePlusGrace = paymCalendarProcessor.dueDateIncludingGraceDays(startDate, paymCalendar, graceDays, postalAddress);
            }
            else
            {
                dueDatePlusGrace = paymCalendarProcessor.dueDateIncludingGraceDays(startDate, paymCalendar, graceDays);
            }

            graceDays = dueDatePlusGrace - startDate;
        }

        return [startDate, graceDays];
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        CustInterestCreate custInterestCreate = CustInterestCreate::constructWithArgs(_args);
        Object callerForm = _args ? _args.caller() : null;

        if (custInterestCreate.prompt())
        {
            custInterestCreate.runOperation();
        }

        if (formHasMethod(callerForm, identifierStr(setTouched)))
        {
            callerForm.setTouched();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>testAmountLimit</Name>
				<Source><![CDATA[
    protected static boolean testAmountLimit(AmountCur _amountMin, AmountCur _amountTest)
    {
        if (_amountMin == 0)
        {
            return true;
        }
        return abs(_amountTest) > abs(_amountMin);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNegativeInterestAmount</Name>
				<Source><![CDATA[
    private boolean checkNegativeInterestAmount(AmountCur _interestAmount)
    {
        boolean ret = true;

        if (custInterestFee.BlockCreationOfNegativeInterest == NoYes::Yes && _interestAmount < 0)
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowSaveLast</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether SysLastValues should be used to load and save the state of the object.
    /// </summary>
    /// <returns>true if the process was started from a form record context; otherwise, false</returns>
    /// <remarks>
    /// custAccountsRestriction will only be populated if this process was originally called using a record context from a form.
    /// If being called from a form we do not want to load/save last values as the ranges/settings populated from the form may
    /// end up overriding a user's preferred settings. This method is called by RunBaseBatch to determine if last values will
    /// be used on this object. The batch settings are persisted regardless of the return value of this method.
    /// </remarks>
    public boolean allowSaveLast()
    {
        return custAccountsRestriction.empty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDescriptionLanguage</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the <c>LanguageId</c> of <c>CustTable</c> table.
    /// </summary>labelId2String
    /// <param name="_custTable">
    ///    A <c>CustTable</c> record.
    /// <returns>
    ///    returns the customer language.
    /// </returns>
    protected LanguageId getDescriptionLanguage(CustTable _custTable)
    {
        return _custTable.languageId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInterestJournalHeaderInitializedDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    ///  A delegate that is called in the createJournal mwthod before jornal header is inserted.
    /// </summary>
    /// <param name = "_custInterestJour">The buffer of the <c>CustInterestJour</c> table.</param>
    delegate void postInterestJournalHeaderInitializedDelegate(CustInterestJour _custInterestJour){}

]]></Source>
			</Method>
			<Method>
				<Name>getIsChildTask</Name>
				<Source><![CDATA[
    internal boolean getIsChildTask()
    {
        return isChildTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIsFinalTask</Name>
				<Source><![CDATA[
    internal boolean getIsFinalTask()
    {
        return isFinalTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustedInterestAmount</Name>
				<Source><![CDATA[
    private static AmountCur getAdjustedInterestAmount(AmountCur _fullInterestAmount, CustTransRefRecId _custTransRecId)
    {
        AmountCur adjustedAmountCur = _fullInterestAmount;

        // Subtract interest already charged
        if (FeatureStateProvider::isFeatureEnabled(CustInterestCreateIgnoreLastInterestDateFeature::instance())
            && !CustInterestCalculateRangeDaysFromDueDateFlight::instance().isEnabled())
        {
            CustInterestJour interestJour;
            CustInterestTrans interestTrans;

            select sum(InterestAmount) from interestTrans
                where interestTrans.CustTransId == _custTransRecId
            exists join interestJour
                where interestJour.InterestNote == interestTrans.InterestNote
                    && interestJour.Status == PrintPostCancel::Posted;

            adjustedAmountCur = adjustedAmountCur - interestTrans.InterestAmount;
        }

        return adjustedAmountCur;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>