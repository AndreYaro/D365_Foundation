<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BankStatementImportBatch</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics365.LocalizationFramework;
/// <summary>
/// The <c>BankStatementImportBatch</c> provides the interface to do importing.
/// </summary>
public class BankStatementImportBatch extends RunBaseBatch implements BatchRetryable
{
    protected CompanyBankAccountId bankAccount;
    protected BankStatementFormatRefRecId bankStatementFormatRecId;
    protected BankReconciliationMatchAutoAfterImport matchAutoAfterImport;

    private Dialog dialog;
    private DialogGroup groupAutomation;
    private DialogField dialogBankAccount;
    private DialogField dialogFormat;
    private DialogField dialogImportMultipleAccounts;
    private FileUploadBuild dialogBankStatementFileUpload;
    private DialogField dialogMatchAutoAfterImport;
    private DialogField dialogTimeZonePreference;
    private DialogField dialogTimeZone;

    private CompanyBankAccountId currentAccount;
    protected Filename uploadFileName;
    protected str uploadFileURL;
    protected SharedServiceUnitFileID uploadFileID;
    private NoYes importMultipleAccounts;
    private DMFTimeZonePreference timeZonePreference;
    private Timezone timeZone;

    private int successfulStatementNumber;
    private int totalStatementNumber;
    private List executions;

    private const str FileUploadControlLabel = "@GLS221360";
    private const str OkButtonName = 'OkButton';
    private const str ZipFileSuffix = 'zip';

    // No strong-typed way to specify a composite entity
    private const str BankStatementImportEntityName = 'BankStatementImportEntity';

    #define.CurrentVersion(4)
    #localmacro.CurrentList
        bankAccount,
        bankStatementFormatRecId,
        matchAutoAfterImport,
        currentAccount,
        importMultipleAccounts,
        uploadFileName,
        uploadFileURL,
        uploadFileID,
        timeZonePreference,
        timeZone
    #endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isRetryable()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>caption</Name>
				<Source><![CDATA[
    public ClassDescription caption()
    {
        //Import bank statements
        return "@GLS221236";
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    public Object dialog()
    {
        dialog = super();
        
        DialogGroup dialogGroup = dialog.addGroup("@SYS54759");
        FormBuildControl formBuildControl = dialog.formBuildDesign().control(dialogGroup.name());

        dialogImportMultipleAccounts = dialog.addFieldValue(enumStr(NoYes), importMultipleAccounts, "@CashManagement:ImportStatementForMultipleBankAccounts");
        dialogImportMultipleAccounts.registerOverrideMethod(
            methodStr(FormCheckBoxControl, modified),
            methodStr(BankStatementImportBatch, importMultipleBankStatementAccountsModified),
            this);

        dialogBankAccount = dialog.addFieldValue(extendedTypeStr(CompanyBankAccountId), bankAccount);
        dialogBankAccount.fieldControl().mandatory(true);
        dialogBankAccount.registerOverrideMethod(
            methodStr(FormStringControl, lookup),
            methodStr(BankStatementImportBatch, lookUpBankAccount),
            this);
        dialogBankAccount.registerOverrideMethod(
            methodStr(FormStringControl, modified),
            methodStr(BankStatementImportBatch, bankAccountModified),
            this);

        dialogTimeZonePreference = dialog.addFieldValue(enumStr(DMFTimeZonePreference), timeZonePreference, "@CashManagement:TimeZonePreference");
        dialogTimeZonePreference.registerOverrideMethod(
            methodStr(FormComboBoxControl, modified),
            methodStr(BankStatementImportBatch, timeZonePreferenceModified),
            this);

        dialogTimeZone = dialog.addFieldValue(enumStr(Timezone), timeZone, "@CashManagement:TimeZone");
        
        dialogFormat = dialog.addFieldValue(extendedTypeStr(BankStatementFormatRefRecId), bankStatementFormatRecId);
        dialogFormat.registerOverrideMethod(
            methodStr(FormReferenceGroupControl, modified),
            methodStr(BankStatementImportBatch, bankStatementFormatModifiedMethodOverride),
            this);

        dialogBankStatementFileUpload = formBuildControl.addControlEx(classstr(FileUpload), FileUploadControlLabel);
        dialogBankStatementFileUpload.fileNameLabel("@CashManagement:BankStatementFileImport");
        dialogBankStatementFileUpload.baseFileUploadStrategyClassName(classStr(BankStatementFileTemporaryStorageStrategy));

        // Automation
        dialog.addGroup("@GLS222237");
        dialogMatchAutoAfterImport = dialog.addFieldValue(extendedTypeStr(BankReconciliationMatchAutoAfterImport), matchAutoAfterImport);
        dialogMatchAutoAfterImport.registerOverrideMethod(
            methodStr(FormCheckBoxControl, modified),
            methodStr(BankStatementImportBatch, matchAutoAfterImportModified),
            this);

        //initialize local variable
        currentAccount = bankAccount;

        this.dialogActivateFields();
        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>importMultipleBankStatementAccountsModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Disables and clears the bank account field when checked. 
    /// Make the time zone related fields invisible when checked.
    /// </summary>
    /// <param name = "_importMultipleStatementAccounts">The <c>FormCheckBoxControl</c>.</param>
    /// <returns>true if the value was modified; otherwise, false.</returns>
    private boolean importMultipleBankStatementAccountsModified(FormCheckBoxControl _importMultipleStatementAccounts)
    {
        if (_importMultipleStatementAccounts.checked())
        {
            dialogBankAccount.value('');
        }

        dialogBankAccount.enabled(!_importMultipleStatementAccounts.checked());
        
        this.enableTimeZoneControls(_importMultipleStatementAccounts.checked(), false);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>matchAutoAfterImportModified</Name>
				<Source><![CDATA[
    private boolean matchAutoAfterImportModified(FormCheckBoxControl _matchAutoAfterImport)
    {
        boolean validModify = true;

        if (FeatureStateProvider::isFeatureEnabled(BankModernReconciliationFeature::instance()) && !BankModernReconciliationUpgradeWizardTrigger::checkExecutionStatusAndAddWarning())
        {
            validModify = false;
        }
        return validModify;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogActivateFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Dialog activate fields.
    /// </summary>
    public void dialogActivateFields()
    {
        if (importMultipleAccounts == NoYes::Yes)
        {
            dialogBankAccount.value('');
            dialogBankAccount.enabled(false);
        }

        this.enableTimeZoneControls(importMultipleAccounts, true);
        
        // deal with bank account change
        if (dialogBankAccount.value()
            && currentAccount != dialogBankAccount.value())
        {
            currentAccount = dialogBankAccount.value();
            dialogFormat.value(BankAccountTable::find(currentAccount).BankStatementFormat);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableTimeZoneControls</Name>
				<Source><![CDATA[
    private void enableTimeZoneControls(boolean _importMultipleAccounts, boolean _isInitialized)
    {
        if (_importMultipleAccounts)
        {
            dialogTimeZonePreference.visible(false);
            dialogTimeZone.visible(false);
        }
        else
        {
            dialogTimeZonePreference.visible(true);
            if (!_isInitialized || dialogTimeZonePreference.value() == '')
            {
                dialogTimeZonePreference.value(DMFTimeZonePreference::Auto);
                dialogTimeZone.value('');
            }
            dialogTimeZone.visible(dialogTimeZonePreference.value() == DMFTimeZonePreference::Manual);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets data from dialog.
    /// </summary>
    /// <returns>
    /// Returns true if the operation succeed.
    /// </returns>
    public boolean getFromDialog()
    {
        boolean ret = super();

        bankAccount = dialogBankAccount.value();
        bankStatementFormatRecId = dialogFormat.value();
        matchAutoAfterImport = dialogMatchAutoAfterImport.value();
        importMultipleAccounts = dialogImportMultipleAccounts.value();


        timeZonePreference = dialogTimeZonePreference.value();
        timeZone = dialogTimeZone.value();

        FileUpload fileUploadControl = this.getFormControl(dialog, FileUploadControlLabel);
        FileUploadTemporaryStorageResult fileUploadResult = fileUploadControl.getFileUploadResult();

        if (fileUploadResult != null && fileUploadResult.getUploadStatus())
        {
            uploadFileURL = fileUploadResult.getDownloadUrl();
            uploadFileName = fileUploadResult.getFileName();
            uploadFileID = fileUploadResult.getFileId();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookUpBankAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Looks up the bank account.
    /// </summary>
    /// <param name="_control">
    ///     The look up control.
    /// </param>
    public void lookUpBankAccount(FormStringControl _control)
    {
        BankAccountTable::lookupBankReconEnabledBankAccount(_control);
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankAccountModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Default bank statement format, time zone preference setting from bank account.
    /// </summary>
    /// <param name = "_bankAccountControl">bank account field.</param>
    /// <returns>whehter the field value has been modified.</returns>
    public boolean bankAccountModified(FormStringControl _bankAccountControl)
    {
        boolean ret = _bankAccountControl.modified();
        if (_bankAccountControl.valueStr())
        {
            CompanyBankAccountId bankAccountValue = _bankAccountControl.valueStr();
            dialogFormat.value(BankAccountTable::find(bankAccountValue).BankStatementFormat);
            this.updateControlsOnBankStatementFormatChange(dialogFormat.value());

            dialogMatchAutoAfterImport.value(BankAccountTable::find(bankAccountValue).BankReconMatchAutoAfterImport);

            dialogTimeZonePreference.value(BankAccountTable::find(bankAccountValue).TimeZonePreference);
            dialogTimeZone.value(BankAccountTable::find(bankAccountValue).TimeZone);
            dialogTimeZone.visible(dialogTimeZonePreference.value() == DMFTimeZonePreference::Manual);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeZonePreferenceModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Change the visibility of the time zone accroding to time zone preference. 
    /// Only visible when time zone preference is manual.
    /// </summary>
    /// <param name = "_timeZonePreferenceControl">time zone preference field.</param>
    /// <returns>whehter the field value has been modified.</returns>
    public boolean timeZonePreferenceModified(FormComboBoxControl _timeZonePreferenceControl)
    {
        boolean ret = _timeZonePreferenceControl.modified();
        
        dialogTimeZone.visible(_timeZonePreferenceControl.valueStr() == enum2Str(DMFTimeZonePreference::Manual));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookUpBankStatementFile</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Looks up the import file.
    /// </summary>
    /// <param name="_control">
    ///     The file open control.
    /// </param>
    /// <returns>
    ///     The selected file path.
    /// </returns>
    [SysObsoleteAttribute("No longer loads file from local file system", true, 13\10\2022)]
    public str lookUpBankStatementFile(DialogField _control)
    {
        throw error(error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareAutomaticMatchData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds imported bank account to set.
    /// </summary>
    /// <param name="_file">
    /// The imported file.
    /// </param>
    /// <param name="_isImportedSuccess">
    /// Indicates whether the import succeed.
    /// </param>
    /// <param name="_document">
    /// The imported bank statement document.
    /// </param>
    [SysObsolete("No longer loads file from local file system", false, 30\6\2020)]
    public void prepareAutomaticMatchData(
        str                 _file,
        boolean             _isImportedSuccess,
        BankStmtISODocument _document)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        executions = new List(Types::Record);

        List importedBankAccounts = this.importBankStatements();

        if (matchAutoAfterImport
            && importedBankAccounts.elements())
        {
            BankStatementImportAutoMatchHelper autoMatchHelper = new BankStatementImportAutoMatchHelper();
            autoMatchHelper.processAutomaticMatch(importedBankAccounts);
        }

        if (totalStatementNumber == 0 && successfulStatementNumber == 0
            && BankStatementFormat::find(bankStatementFormatRecId).UseGERConfiguration == NoYes::No)
        {
            info("@CashManagement:ImportStatementNoImportsSuccessful");
        }

        if (successfulStatementNumber > 0)
        {
            info(strFmt("@CashManagement:BankStatementImportCount", successfulStatementNumber));
        }

        if (totalStatementNumber - successfulStatementNumber > 0)
        {
            info(strFmt("@CashManagement:BankStatementImportFailCount", totalStatementNumber - successfulStatementNumber));
        }

        this.reportErrors();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSuccessfulStatementNumber</Name>
				<Source><![CDATA[
    public int getSuccessfulStatementNumber()
    {
        return successfulStatementNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalStatementNumber</Name>
				<Source><![CDATA[
    public int getTotalStatementNumber()
    {
        return totalStatementNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getImportMultipleAccounts</Name>
				<Source><![CDATA[
    public NoYes getImportMultipleAccounts()
    {
        return importMultipleAccounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setImportMultipleAccounts</Name>
				<Source><![CDATA[
    public void setImportMultipleAccounts(NoYes _importMultipleAccounts)
    {
        importMultipleAccounts = _importMultipleAccounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportErrors</Name>
				<Source><![CDATA[
    private void reportErrors()
    {
        ListEnumerator listEnumerator = executions.getEnumerator();
        while (listEnumerator.moveNext())
        {
            DMFDefinitionGroupExecution execution = listEnumerator.current();

            DMFStagingValidationLog log;
            while select log
                where log.ExecutionId == execution.ExecutionId
            {
                checkFailed(log.ErrorMessage);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFormControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get form control instance of dialog control.
    /// </summary>
    /// <param name = "_dialog">current dialog.</param>
    /// <param name = "_controlName">name of the control.</param>
    /// <returns>form control instance of the given dialog control.</returns>
    protected FormControl getFormControl(DialogRunbase _dialog, str _controlName)
    {
        return _dialog.formRun().control(_dialog.formRun().controlId( _controlName));
    }

]]></Source>
			</Method>
			<Method>
				<Name>importBankStatements</Name>
				<Source><![CDATA[
    /// <summary>
    /// Import bank statements.
    /// </summary>
    /// <returns>List containing imported bank account records and a related list of bank statements.</returns>
    /// <remarks>
    /// A single file can be a zip file that contains multiple files or just a single file. Then, each file can contain multiple statements and each of
    /// those statements can belong to a different bank account and company.
    /// </remarks>
    protected List importBankStatements()
    {
        Map importedBankAccounts = new Map(Types::String, Types::Class);
        BankStatementFormat format = BankStatementFormat::find(bankStatementFormatRecId);

        List bankFiles = this.findBankFiles();
        ListEnumerator bankFileEnumerators = bankFiles.getEnumerator();
        while (bankFileEnumerators.moveNext())
        {
            if (format.UseGERConfiguration)
            {
                SharedServiceUnitFileID bankStatementToImportFileId = conPeek(bankFileEnumerators.current(), 1);
                Filename fileName = conPeek(bankFileEnumerators.current(), 2);
                this.doImportBankStatementsGER(bankStatementToImportFileId, format.ERModelMappingTable, fileName, importedBankAccounts);
            }

            else
            {
                this.doImportBankStatementsDMF(bankFileEnumerators.current(), format.IsXML, importedBankAccounts);
            }
        }

        SetEnumerator setEnumerator = importedBankAccounts.valueSet().getEnumerator();
        List importedData = new List(Types::Class);
        while(setEnumerator.moveNext())
        {
            importedData.addEnd(setEnumerator.current());
        }

        return importedData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeFileImportProcessor</Name>
				<Source><![CDATA[
    protected BankStatementFileImportProcessor initializeFileImportProcessor()
    {
        BankStatementFileImportProcessor fileImportProcessor = new BankStatementFileImportProcessor();

        return fileImportProcessor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDMFDefinitionGroup</Name>
				<Source><![CDATA[
    private DMFDefinitionGroup findDMFDefinitionGroup()
    {
        DMFDefinitionGroup definitionGroup;

        select firstonly definitionGroup
            where definitionGroup.DefinitionGroupName == BankStatementFormat::find(bankStatementFormatRecId).DMFDefinitionGroupName;

        return definitionGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBankFiles</Name>
				<Source><![CDATA[
    private List findBankFiles()
    {
        #Characters
        List bankFiles;

        if (strEndsWith(uploadFileName, ZipFileSuffix))
        {
            container fileSuffixes= conNull();

            List fileTypesList = strSplit(BankStatementFormat::find(bankStatementFormatRecId).FilenameType, #semicolon);
            ListEnumerator enumerator = fileTypesList.getEnumerator();
            while (enumerator.moveNext())
            {
                fileSuffixes += enumerator.current();
            }

            bankFiles = DataFileImportExportUtils_W::getUnzippedFiles(uploadFileURL, fileSuffixes, classStr(BankStatementFileTemporaryStorageStrategy));

            this.deleteFile(uploadFileID);
        }
        else
        {
            bankFiles = new List(Types::Container);
            bankFiles.addEnd([uploadFileID, uploadFileName]);
        }

        return bankFiles;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFile</Name>
				<Source><![CDATA[
    private void deleteFile(SharedServiceUnitFileID _fileId)
    {
        FileUploadTemporaryStorageResult result = new FileUploadTemporaryStorageResult('', '', true, '', '', _fileId);
        result.deleteResult();
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyTransforms</Name>
				<Source><![CDATA[
    private DMFLocalFilePath applyTransforms(
        SharedServiceUnitFileID _uploadedStatement,
        DMFDefinitionGroup _definitionGroup)
    {
        DMFDefinitionGroupEntity definitionGroupEntity = this.findDMFDefinitionGroupEntity(_definitionGroup);
        DMFExecutionId executionId = DMFUtil::setupNewExecution(_definitionGroup.DefinitionGroupName);

        DMFDefinitionGroupExecution execution = DMFDefinitionGroupExecution::find(
            _definitionGroup.DefinitionGroupName,
            definitionGroupEntity.Entity,
            executionId,
            true);

        execution.IsTransformed = NoYes::No;
        DMFLocalFilePath filePath = execution.applyTransforms(_uploadedStatement);

        DMFExecution e = DMFExecution::find(executionId, true);
        e.delete();

        return filePath;
    }

]]></Source>
			</Method>
			<Method>
				<Name>importSingleStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Import a single bank statement which must be in XML format.
    /// </summary>
    /// <param name = "_singleUploadedStatement">file Id of the bank statement.</param>
    /// <param name = "_definitionGroup">Definition group which will be used for this import.</param>
    /// <returns>List of imported bank statement IDs.</returns>
    public List importSingleStatement(
        SharedServiceUnitFileID _singleUploadedStatement,
        DMFDefinitionGroup _definitionGroup)
    {
        DMFDefinitionGroupEntity definitionGroupEntity = this.findDMFDefinitionGroupEntity(_definitionGroup);
        DMFExecutionId executionId = DMFUtil::setupNewExecution(_definitionGroup.DefinitionGroupName);

        BankStatementImportInfoHolder infoHolder;
        infoHolder.DMFExecutionId = executionId;
        infoHolder.BankAccountId = this.bankAccount;
        infoHolder.insert();

        // Determine if source to target should happen on initial import based on if we are in batch or not.
        boolean executeTargetDuringInitialImport = !this.parmInBatch();

        // Find execution
        DMFDefinitionGroupExecution execution =
            DMFDefinitionGroupExecution::find(_definitionGroup.DefinitionGroupName, definitionGroupEntity.Entity, executionId, true);
        execution.FilePath = _singleUploadedStatement;
        execution.IsTransformed = NoYes::Yes;
        execution.ExecuteTargetStep = executeTargetDuringInitialImport;
        execution.update();

        executions.addEnd(execution.data());
        
        DMFQuickImportExport::doPGImport(_definitionGroup.DefinitionGroupName, executionId, executeTargetDuringInitialImport);

        // If we still need to move from source to target, kick off that process now.
        if (!executeTargetDuringInitialImport)
        {
            DMFDefinitionGroupExecution executionSourceToTarget;

            update_recordset executionSourceToTarget
                setting IsSelected = NoYes::Yes
                where executionSourceToTarget.ExecutionId == executionId;

            DMFWriteExecutionParameters executionParameters = DMFWriteExecutionParameters::construct();
            executionParameters.parmDefinitionGroup(_definitionGroup.DefinitionGroupName);
            executionParameters.parmsourceTarget(DMFSourceTarget::Source);
            executionParameters.parmSelectedData(NoYes::No);
            executionParameters.parmErrorStatus(NoYes::No);
            executionParameters.parmSkipFormNavigation(NoYes::Yes);

            DMFExecution dmfExecution = DMFExecution::find(executionId, true);
            Args args = new Args();
            args.record(dmfExecution);
            args.parmObject(executionParameters);
            args.parmEnum(NoYes::No);

            new MenuFunction(menuItemActionStr(DMFEntityWriterBatch), MenuItemType::Action).run(args);
        }
        
        successfulStatementNumber += BankStatementImportUtils::getCountSuccessfulBankStmtImport(_definitionGroup, executionId);
        totalStatementNumber += BankStatementImportUtils::getCountBankStmtImport(_definitionGroup, executionId);

        this.deleteFile(execution.FilePath);

        return BankStatementImportUtils::getListOfImportedBankStatementIds(_definitionGroup, executionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDMFDefinitionGroupEntity</Name>
				<Source><![CDATA[
    private DMFDefinitionGroupEntity findDMFDefinitionGroupEntity(DMFDefinitionGroup _definitionGroup)
    {
        DMFDefinitionGroupEntity definitionGroupEntity;
        DMFEntity dmfEntity;

        select firstonly RecId, Entity from definitionGroupEntity exists join dmfEntity
            where definitionGroupEntity.DefinitionGroup == _definitionGroup.DefinitionGroupName
                && dmfEntity.EntityName == definitionGroupEntity.Entity
                && dmfEntity.TargetEntity == BankStatementImportEntityName;

        if (!definitionGroupEntity)
        {
            throw error(strFmt("@DMF:DMFNoEntityExists", _definitionGroup.DefinitionGroupName));
        }

        return definitionGroupEntity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = _packedClass;
                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates bank statement import batch.
    /// </summary>
    /// <param name="calledFrom">
    /// The called from object.
    /// </param>
    /// <returns>
    /// Returns true if the validation succeed.
    /// </returns>
    public boolean validate(Object calledFrom = null)
    {
        boolean ret = super(calledFrom);

        if (!bankStatementFormatRecId)
        {
            ret = checkFailed("@GLS221248");
        }

        ret = BankAccountTable::checkIsAdvancedBankReconEnabled(bankAccount) && ret;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// The constructor of the bank statement import batch.
    /// </summary>
    /// <returns>
    /// The instance of the <c>BankStatementImportBatch</c> class.
    /// </returns>
    public static BankStatementImportBatch construct()
    {
        BankStatementImportBatch import = new BankStatementImportBatch();

        return import;
    }

]]></Source>
			</Method>
			<Method>
				<Name>uploadCompleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// After the file has been uploaded, the Ok button is enabled.
    /// </summary>
    protected void uploadCompleted()
    {
        FileUpload fileUpload = this.getFormControl(dialog, FileUploadControlLabel);
        fileUpload.notifyUploadCompleted -= eventhandler(this.UploadCompleted);

        this.setDialogOkButtonEnabled(dialog, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDialogOkButtonEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables or disables the dialog Ok button.
    /// </summary>
    /// <param name = "_dialog">The <c>Runbase</c> dialog object.</param>
    /// <param name = "_isEnabled">Indicates to enable or disable the Ok button.</param>
    protected void setDialogOkButtonEnabled(DialogRunbase _dialog, boolean _isEnabled)
    {
        FormControl okButtonControl = this.getFormControl(_dialog, OkButtonName);

        if (okButtonControl)
        {
            okButtonControl.enabled(_isEnabled);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Disables the dialog Ok button until the file upload is complete.
    /// </summary>
    /// <param name="_dialog">The <c>Runbase</c> dialog object.</param>
    public void dialogPostRun(DialogRunbase _dialog)
    {
        FileUpload fileUpload = this.getFormControl(_dialog, FileUploadControlLabel);
        fileUpload.notifyUploadCompleted += eventhandler(this.uploadCompleted);

        if (!this.shouldSkipFileUpload(dialogFormat.value()))
        {
            this.setDialogOkButtonEnabled(_dialog, false);
            this.setRecurrenceButtonVisibility(_dialog, false);
            this.setFileUploadVisibility(_dialog, true);
        }
        else
        {
            this.setDialogOkButtonEnabled(_dialog, true);
            this.setRecurrenceButtonVisibility(_dialog, true);
            this.setFileUploadVisibility(_dialog, false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        BankStatementImportBatch import = BankStatementImportBatch::construct();

        if (import.prompt())
        {
            import.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// true if the class is designed for executing the operation in a new session; otherwise, false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>gerImportStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Imports bank statements from the file by using GER importing configuration.
    /// </summary>
    /// <param name = "_uploadedStatement">The Field Id of the file to be imported.</param>
    /// <param name = "_erModelMappingId">GER model mapping format.</param>
    /// <param name = "_gerConfigName">The name of GER configuration.</param>
    /// <param name = "_executionID">Unique execution Id wich is used to identify the imported bank document.</param>
    protected void gerImportStatement(
        SharedServiceUnitFileID _uploadedStatement,
        ERModelMappingId _erModelMappingId,
        Name _gerConfigName,
        Description _executionID)
    {
        var integrationPoint = classStr(ERTableDestination) + '#' + tableStr(BankStatementDocumentEntity);
        ERmodelDefinitionInputParametersAction inputParameters = new ERmodelDefinitionInputParametersAction();
        if (FeatureStateProvider::isFeatureEnabled(BankRemoveBAI2StatementIDTimeZoneOffsetFeature::instance())
            && BankStatementGERImportUtils::isDestinationMappingVersionedEqualOrLater(_erModelMappingId, integrationPoint, 3, 16))
        {
            inputParameters.addParameter('$ExecutionID', _executionID)
                .addParameter('$gerConfigName', _gerConfigName)
                .addParameter('$AccountId', bankAccount)
                .addParameter('$ImportMultipleAccounts', importMultipleAccounts)
                .addParameter('$TimeZonePreference', timeZonePreference)
                .addParameter('$OffsetTimeZone', timeZone);
        }
        else
        {
            inputParameters.addParameter('$ExecutionID', _executionID)
                .addParameter('$gerConfigName', _gerConfigName)
                .addParameter('$AccountId', bankAccount);
        }

        var runner = ERObjectsFactory::createMappingDestinationRunByImportFormatMappingId(_erModelMappingId, integrationPoint);
        runner.withParameter(inputParameters);
        runner.init();

        if (runner.promptsContractedModelMapping())
        {
            var parameters = runner.getParameters();
            var traverser = new ERModelDefinitionParametersTraverser(parameters);
            while (traverser.moveNext())
            {
                ERIImportFormatDataSourceWithFileContract dsWithFileContract = ERCast::asObject(traverser.current()) as ERIImportFormatDataSourceWithFileContract;
                if (dsWithFileContract != null)
                {
                    dsWithFileContract.setInputFile(File::UseFileFromURL(DMFStagingWriter::getDownloadURLFromFileId(_uploadedStatement)), uploadFileName);
                }
                else
                {
                    ERIImportFormatDataSourceContract dsContract = ERCast::asObject(traverser.current()) as ERIImportFormatDataSourceContract;
                    if (dsContract)
                    {
                        dsContract.parmInputDataStream(File::UseFileFromURL(DMFStagingWriter::getDownloadURLFromFileId(_uploadedStatement)));
                    }
                }
            }
        }

        runner.runUnattended();
    }

]]></Source>
			</Method>
			<Method>
				<Name>doImportBankStatementsGER</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs import of bank statement file by using GER.
    /// </summary>
    /// <param name = "_bankStatementToImportFileId">The Field Id of the file to be imported.</param>
    /// <param name = "_erModelMappingId">The identification of model mapping to be used for import.</param>
    /// <returns>
    /// List of imported bank statement IDs.
    /// </returns>
    private void doImportBankStatementsGER(
        SharedServiceUnitFileID _bankStatementToImportFileId,
        ERModelMappingId _erModelMappingId,
        Filename _fileName,
        Map _importedBankAccounts)
    {
        Name gerConfigName = ERModelMappingTable::find(_erModelMappingId).Name;
        Description executionID = DMFUtil::generateExecutionId(gerConfigName);

        this.gerImportStatement(_bankStatementToImportFileId, _erModelMappingId, gerConfigName, executionID);

        try
        {
            BankStatementImportUtils::applyTimeZoneChangeForBankStatement(
                gerConfigName,
                executionID,
                timeZonePreference,
                timeZone,
                importMultipleAccounts);
        }
        catch
        {
            BankStatementImportUtils::deleteBankStmtsImported(gerConfigName, executionID);
            error("@CashManagement:BankStmtImportFailTimeZoneUpdateFail");
        }

        try
        {
            BankStatementImportUtils::reverseDebitCreditForBankStatement(gerConfigName, executionID);
        }
        catch
        {
            BankStatementImportUtils::deleteBankStmtsImported(gerConfigName, executionID);
            error(strFmt("@CashManagement:BankStmtImportFailReverseDebitCreditFail", _fileName));
        }

        BankStatementDocumentStaging bankStatementDocumentStaging;
        BankStmtISODocument bankStmtISODocument;
        BankStmtISOAccountStatement bankStmtISOAccountStatement;

        RecordSortedList sortedStmtList;
        if (matchAutoAfterImport)
        {
            sortedStmtList = new RecordSortedList(tableNum(BankStatementImportSortingHelperTable));
            sortedStmtList.sortOrderFromContainer([
                fieldNum(BankStatementImportSortingHelperTable, RefDataAreaId),
                fieldNum(BankStatementImportSortingHelperTable, BankAccountTable),
                fieldNum(BankStatementImportSortingHelperTable, FromDateTime),
                fieldNum(BankStatementImportSortingHelperTable, SeqNumIntValue)]);
        }

        while select crosscompany DataAreaId, BankAccountTable, Identification, RecId, FromDateTime, SequenceNumber from bankStmtISOAccountStatement
        exists join bankStmtISODocument
            where bankStmtISODocument.RecId == bankStmtISOAccountStatement.BankStmtISODocument
        exists join bankStatementDocumentStaging
            where bankStatementDocumentStaging.BankStatementDocumentRecId == bankStmtISODocument.RecId
                && bankStatementDocumentStaging.DefinitionGroup == gerConfigName
                && bankStatementDocumentStaging.ExecutionId == executionID
        {
            if (matchAutoAfterImport)
            {
                this.insertSortedBankStatementList(sortedStmtList, bankStmtISOAccountStatement);
            }
            else
            {
                BankStatementImportData importData = BankStatementImportUtils::getBankStatementImportDataByCompanyAndAccount(
                    _importedBankAccounts,
                    bankStmtISOAccountStatement.DataAreaId,
                    bankStmtISOAccountStatement.BankAccountTable);
                importData.parmImportedStatements().addEnd(bankStmtISOAccountStatement.Identification);
                importData.parmImportedStatementsRecIds().addEnd(bankStmtISOAccountStatement.RecId);
            }
        }

        if (matchAutoAfterImport
            && sortedStmtList
            && sortedStmtList.len())
        {
            this.initImportDataFromSortedStmt(_importedBankAccounts, sortedStmtList);
        }

        select crosscompany count(RecId) from bankStmtISOAccountStatement
        exists join bankStmtISODocument
            where bankStmtISODocument.RecId == bankStmtISOAccountStatement.BankStmtISODocument
        exists join bankStatementDocumentStaging
            where bankStatementDocumentStaging.BankStatementDocumentRecId == bankStmtISODocument.RecId
                && bankStatementDocumentStaging.DefinitionGroup == gerConfigName
                && bankStatementDocumentStaging.ExecutionId == executionID;

        successfulStatementNumber += int642int(bankStmtISOAccountStatement.RecId);
        totalStatementNumber += int642int(bankStmtISOAccountStatement.RecId);

        delete_from bankStatementDocumentStaging
            where bankStatementDocumentStaging.DefinitionGroup == gerConfigName
                && bankStatementDocumentStaging.ExecutionId == executionID;

        if (_bankStatementToImportFileId != '')
        {
            this.deleteFile(_bankStatementToImportFileId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSortedBankStatementList</Name>
				<Source><![CDATA[
    private void insertSortedBankStatementList(RecordSortedList _sortedStmtList, BankStmtISOAccountStatement _bankStmtISOAccountStatement)
    {
        BankStatementImportSortingHelperTable bankStatementImportSortingHelperTable;
        bankStatementImportSortingHelperTable.RefDataAreaId = _bankStmtISOAccountStatement.DataAreaId;
        bankStatementImportSortingHelperTable.BankAccountTable = _bankStmtISOAccountStatement.BankAccountTable;
        bankStatementImportSortingHelperTable.FromDateTime = _bankStmtISOAccountStatement.FromDateTime;
        bankStatementImportSortingHelperTable.SeqNumIntValue = any2Int64(_bankStmtISOAccountStatement.SequenceNumber);
        bankStatementImportSortingHelperTable.RefRecId = _bankStmtISOAccountStatement.RecId;
        if (BankStmtImportDataInitIdentificationFlight::instance().isEnabled())
        {
            bankStatementImportSortingHelperTable.Identification = _bankStmtISOAccountStatement.Identification;
        }

        _sortedStmtList.ins(bankStatementImportSortingHelperTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initImportDataFromSortedStmt</Name>
				<Source><![CDATA[
    private void initImportDataFromSortedStmt(Map _importedBankAccounts, RecordSortedList _sortedStmtList)
    {
        BankStatementImportSortingHelperTable bankStatementImportSortingHelperTable;

        boolean moreRecs = _sortedStmtList.first(bankStatementImportSortingHelperTable);
        while (moreRecs)
        {
            BankStatementImportData importData = BankStatementImportUtils::getBankStatementImportDataByCompanyAndAccount(
                _importedBankAccounts,
                bankStatementImportSortingHelperTable.RefDataAreaId,
                bankStatementImportSortingHelperTable.BankAccountTable);
            importData.parmImportedStatementsRecIds().addEnd(bankStatementImportSortingHelperTable.RefRecId);
            if (BankStmtImportDataInitIdentificationFlight::instance().isEnabled())
            {
                importData.parmImportedStatements().addEnd(bankStatementImportSortingHelperTable.Identification);
            }

            moreRecs = _sortedStmtList.next(bankStatementImportSortingHelperTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doImportBankStatementsDMF</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs import of bank statement file by using DMF.
    /// </summary>
    /// <param name = "_file">The container of Field Id and name of the file to be imported.</param>
    /// <param name = "_isXML">Identifies if the file is an XML file.</param>
    /// <returns>
    /// List of imported bank statement IDs.
    /// </returns>
    private void doImportBankStatementsDMF(
        container _file,
        boolean _isXML,
        Map _importedBankAccounts)
    {
        SharedServiceUnitFileID bankStatementToImportFileId;
        str bankStatementFileName;
        DMFDefinitionGroup definitionGroup = this.findDMFDefinitionGroup();

        [bankStatementToImportFileId, bankStatementFileName] = _file;

        if (bankStatementToImportFileId && !_isXML)
        {
            SharedServiceUnitFileID bankStatementToImportFileIdNonXML = bankStatementToImportFileId;
            bankStatementToImportFileId = DataFileImportExportUtils::reuploadFileAsXmlFile(bankStatementToImportFileIdNonXML, bankStatementFileName, classStr(BankStatementFileTemporaryStorageStrategy));

            this.deleteFile(bankStatementToImportFileIdNonXML);
        }

        DMFLocalFilePath transformedFile = this.applyTransforms(bankStatementToImportFileId, definitionGroup);
        if (this.bankAccount)
        {
            List importedStatements = this.importSingleStatement(transformedFile, definitionGroup);

            BankStatementImportData importData = BankStatementImportUtils::getBankStatementImportDataByBankAccountTable(_importedBankAccounts, BankAccountTable::find(this.bankAccount));
            importData.parmImportedStatements().appendList(importedStatements);

            this.deleteFile(transformedFile);
        }
        else
        {
            SharedServiceUnitURL transformedFileLocation = DMFStagingWriter::getSharedFilePath(transformedFile);
            BankStatementFileImportProcessor fileImportProcessor = this.initializeFileImportProcessor();
            BankStatementFileImportProcessorResult fileImportProcessorResult = fileImportProcessor.process(transformedFileLocation, this.bankAccount);
            List bankStatementsByBankAccountTableAndFileId = fileImportProcessorResult.parmBankStatementsByBankAccountTableAndFileId();

            this.deleteFile(bankStatementToImportFileId);

            ListEnumerator bankStatementsByFileAndBankAccountEnumerator = bankStatementsByBankAccountTableAndFileId.getEnumerator();
            while (bankStatementsByFileAndBankAccountEnumerator.moveNext())
            {
                BankStatementUploadData uploadData = bankStatementsByFileAndBankAccountEnumerator.current();
                BankAccountTable bankAccountTable = uploadData.parmBankAccountTable();
                bankStatementToImportFileId = uploadData.parmFileId();

                changecompany(bankAccountTable.company())
                {
                    List importedStatements = this.importSingleStatement(bankStatementToImportFileId, definitionGroup);

                    BankStatementImportData importData = BankStatementImportUtils::getBankStatementImportDataByBankAccountTable(_importedBankAccounts, bankAccountTable.data());
                    importData.parmImportedStatements().appendList(importedStatements);
                }
                
                this.deleteFile(bankStatementToImportFileId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankStatementFormatModifiedMethodOverride</Name>
				<Source><![CDATA[
    private boolean bankStatementFormatModifiedMethodOverride(FormReferenceGroupControl _bankStatementFormatControl)
    {
        boolean ret = _bankStatementFormatControl.modified();

        this.updateControlsOnBankStatementFormatChange(_bankStatementFormatControl.value());

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateControlsOnBankStatementFormatChange</Name>
				<Source><![CDATA[
    private void updateControlsOnBankStatementFormatChange(RefRecId _bankStatementFormatRecId)
    {
        if (this.shouldSkipFileUpload(_bankStatementFormatRecId))
        {
            this.setDialogOkButtonEnabled(dialog, true);
            this.setRecurrenceButtonVisibility(dialog, true);
            this.setFileUploadVisibility(dialog, false);
        }
        else
        {
            if (!this.isFileUploaded())
            {
                this.setDialogOkButtonEnabled(dialog, false);
            }

            this.setRecurrenceButtonVisibility(dialog, false);
            this.setFileUploadVisibility(dialog, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipFileUpload</Name>
				<Source><![CDATA[
    private boolean shouldSkipFileUpload(RefRecId _bankStatementFormatRecId)
    {
        BankStatementFormat bankStatementFormat = BankStatementFormat::find(_bankStatementFormatRecId);

        return bankStatementFormat
            && bankStatementFormat.UseGERConfiguration == NoYes::Yes
            && ERImportFormatSourceTable::isFormatSourceEnabled(ERSolutionTable::find(ERModelMappingTable::find(bankStatementFormat.ERModelMappingTable).Solution).getFormatTable().RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFileUploaded</Name>
				<Source><![CDATA[
    private boolean isFileUploaded()
    {
        FileUpload fileUpload = this.getFormControl(dialog, FileUploadControlLabel);
        FileUploadTemporaryStorageResult uploadResult = fileUpload.getFileUploadResult();

        return uploadResult && uploadResult.getUploadStatus();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the recurrence button.
    /// </summary>
    /// <param name = "_dialog">The current instance of the <c>Dialog</c> class.</param>
    protected void dialogPost(Object _dialog)
    {
        super(_dialog);

        DialogRunbase dialogRunbase = _dialog as dialogRunbase;

        if (dialogRunbase != null)
        {
            dialogRunbase.disableRecurrenceButton();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRecurrenceButtonVisibility</Name>
				<Source><![CDATA[
    private void setRecurrenceButtonVisibility(DialogRunbase _dialog, boolean _visible)
    {
        if (_dialog != null)
        {
            _dialog.setRecurrenceButtonVisibility(_visible);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFileUploadVisibility</Name>
				<Source><![CDATA[
    private void setFileUploadVisibility(DialogRunbase _dialog, boolean _visible)
    {
        FileUpload fileUpload = this.getFormControl(_dialog, FileUploadControlLabel);

        if (FileUpload)
        {
            fileUpload.visible(_visible);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>