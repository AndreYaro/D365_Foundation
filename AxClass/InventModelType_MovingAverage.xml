<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventModelType_MovingAverage</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>InventModelTyp_MovingAverage</c> class implements the moving average inventory model.
/// </summary>
class InventModelType_MovingAverage extends InventModelType
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowTransactionAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether you can adjust an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> record to adjust.
    /// </param>
    /// <param name="_inventTransOrigin">
    /// The <c>InventTransOrigin</c> record that is related to the <c>inventTrans</c> record.
    /// </param>
    /// <returns>
    /// true if it can adjust an inventory transactions; otherwise, false.
    /// </returns>
    public boolean allowTransactionAdjustment(InventTrans _inventTrans = null, InventTransOrigin _inventTransOrigin = null)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheFinancialOnhandOnFinancialUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the financial update of the inventory transactions should cache the financial
    /// on-hand inventory.
    /// </summary>
    /// <returns>
    /// true if the financial update of the inventory transactions should cache the financial on-hand
    /// inventory; otherwise, false.
    /// </returns>
    public boolean cacheFinancialOnhandOnFinancialUpdate()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheFinancialOnhandOnPhysicalUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the physical update of the inventory transactions should cache the financial
    /// available inventory.
    /// </summary>
    /// <returns>
    /// true if the physical update of the inventory transactions should cache the financial on-hand
    /// inventory; otherwise, false.
    /// </returns>
    public boolean cacheFinancialOnhandOnPhysicalUpdate()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventOnHand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the inventory available is valid.
    /// </summary>
    /// <param name="_inventOnhand">
    /// The <c>inventOnHand</c> object.
    /// </param>
    /// <param name="_checkOnly">
    /// A Boolean value that indicates whether no exceptions will be thrown.
    /// </param>
    /// <returns>
    /// true if the inventory available is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The check is implemented to make sure calculations done in parallel do not conflict.
    /// </remarks>
    /// <exception cref="M:Exception::UpdateConflict">
    /// The inventory available is invalid because of an update conflict.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// The inventory available is invalid because of an error.
    /// </exception>
    public boolean checkInventOnHand(InventOnhand _inventOnhand, boolean _checkOnly = false)
    {
        InventSum   inventSum   = _inventOnhand.inventSumWithoutAvailability(true);
        Qty         postedQty   = inventSum.PostedQty - inventSum.Deducted + inventSum.Received;
        CostAmount  postedValue = inventSum.PostedValue + inventSum.PhysicalValue;
        CostAmount  expectedAmount = CurrencyExchangeHelper::amount(postedQty * this.getExpectedCost(inventSum));

        if (postedValue != 0.0 && sign(postedQty) != sign(postedValue) )
        {
            if (_checkOnly)
            {
                return false;
            }
            CostManagementInstrumentationLogger logger =  CostManagementInstrumentationLogger::createLogger(classStr(InventModelType_MovingAverage));
            using (var inventModelTypeActivityContext = logger.inventModelTypeActivities().checkInventOnHand(
                classStr(InventModelType_MovingAverage),
                inventSum.InventDimId,
                InventTable::find(inventSum.ItemId).RecId,
                postedQty,
                postedValue,
                expectedAmount))
            {
                infolog.add(Exception::UpdateConflict, strFmt("@SCM:ErrorMessage_CheckInventOnHand_NotMatchInventoryQuantity", postedValue, postedQty, inventSum.InventDimId, inventSum.ItemId));
                throw Exception::UpdateConflict;
            }
        }

        RoundOff roundOffunit = abs(this.roundingPrecision());
        if (abs(expectedAmount - postedValue) > roundOffunit)
        {
            if (postedQty != 0.0 && CostMoveAverageOnHandCheckRemoveCacheFlight::instance().isEnabled())
            {
                //The cached cost price may be invalid, so need to clean up the cache price and check on-hand again
                str expectedCostKey = this.getExpectedCostKey(inventSum.ItemId, inventSum.InventDimId);
                if (SysTransactionScopeCache::isSet(classStr(InventModelType_MovingAverage), expectedCostKey))
                {
                    SysTransactionScopeCache::remove(classStr(InventModelType_MovingAverage), expectedCostKey);
                    expectedAmount = CurrencyExchangeHelper::amount(postedQty * this.getExpectedCost(inventSum));

                    if (abs(expectedAmount - postedValue) <= abs(roundOffunit))
                    {
                        return true;
                    }
                }
            }

            if (_checkOnly)
            {
                return false;
            }

            CostManagementInstrumentationLogger logger =  CostManagementInstrumentationLogger::createLogger(classStr(InventModelType_MovingAverage));
            using (var inventModelTypeActivityContext = logger.inventModelTypeActivities().checkInventOnHand(
                classStr(InventModelType_MovingAverage),
                inventSum.InventDimId,
                InventTable::find(inventSum.ItemId).RecId,
                postedQty,
                postedValue,
                expectedAmount))
            {
                infolog.add(Exception::UpdateConflict, strFmt("@SCM:ErrorMessage_CheckInventOnHand_NotExpectedAfterCalculation", postedValue, expectedAmount, inventSum.InventDimId, inventSum.ItemId));
                throw Exception::UpdateConflict;
            }
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundingPrecision</Name>
				<Source><![CDATA[
    protected RoundOff roundingPrecision()
    {
        return Currency::roundingPrecisionAdjusted(Ledger::accountingCurrency());
    }

]]></Source>
			</Method>
			<Method>
				<Name>costPricePcs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the cost for one piece.
    /// </summary>
    /// <param name="_inventSum">
    /// The <c>InventSum</c> record for which to determine the cost.
    /// </param>
    /// <param name="_inventModelGroup">
    /// The <c>InventModelGroup</c> record related to the item.
    /// </param>
    /// <param name="_onHandOnly">
    /// A Boolean value that indicates whether to return 0 if the on-hand quantity or values is less than
    /// or equal zero.
    /// </param>
    /// <param name="_priceDate">
    /// The date for the cost, this is only used for standard cost.
    /// </param>
    /// <returns>
    /// The cost for one piece.
    /// </returns>
    /// <remarks>
    /// The owner dimension is used when retrieving the correct cost price. In case the specified item is owner enabled the owner dimension must be specified.
    /// </remarks>
    public CostPrice costPricePcs(
        InventSum           _inventSum,
        InventModelGroup    _inventModelGroup = null,
        boolean             _onHandOnly = false,
        PriceDate           _priceDate  = maxDate())
    {
        if (!_inventSum.inventDim().isOwnerCurrentLegalEntity())
        {
            return 0;
        }

        CostAmount postedValue = _inventSum.PhysicalValue + _inventSum.PostedValue;
        Qty postedQty =  _inventSum.Received + _inventSum.PostedQty - _inventSum.Deducted;

        if (postedQty != 0)
        {
            return postedValue / postedQty;
        }
        else
        {
            CostMovingAverageUseActiveCostThenItemPriceContext context = CostMovingAverageUseActiveCostThenItemPriceContext::current();
            if (context)
            {
                return this.findActiveCostThenItemPrice(_inventSum, _priceDate);
            }
            else
            {
                return this.getFallBackCostPrice(_inventSum, _priceDate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findActiveCostThenItemPrice</Name>
				<Source><![CDATA[
    private CostPrice findActiveCostThenItemPrice(InventSum _inventSum, PriceDate _priceDate)
    {
        InventPriceMap inventPriceMap = this.findActiveCost(_inventSum, _priceDate);
        if (!inventPriceMap.RecId)
        {
            inventPriceMap = InventTableModule::find(_inventSum.ItemId, ModuleInventPurchSales::Invent);
        }

        return inventPriceMap.pcsPrice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFallBackCostPrice</Name>
				<Source><![CDATA[
    private CostPrice getFallBackCostPrice(InventSum _inventSum, PriceDate _priceDate)
    {
        switch (this.getCostMovingAverageFallbackSequence())
        {
            case CostMovingAverageFallbackSequence::LastIssueThenActiveCostThenItemPrice:
                CostPriceSearchDataContract costPriceSearchDataContract = this.findLatestIssueInventTransCost(_inventSum);
                if (costPriceSearchDataContract.isCostPriceFound)
                {
                    return costPriceSearchDataContract.costPrice;
                }
                else 
                {
                    InventPriceMap inventPriceMap = this.findActiveCost(_inventSum, _priceDate);

                    if (!inventPriceMap.RecId)
                    {
                        inventPriceMap = InventTableModule::find(_inventSum.ItemId, ModuleInventPurchSales::Invent);
                    }
                    return inventPriceMap.pcsPrice();
                }
                break;
                
            case CostMovingAverageFallbackSequence::ActiveCostThenItemPrice:
                InventPriceMap inventPriceMap = this.findActiveCost(_inventSum, _priceDate);
                if (!inventPriceMap.RecId)
                {
                    inventPriceMap = InventTableModule::find(_inventSum.ItemId, ModuleInventPurchSales::Invent);
                }

                return inventPriceMap.pcsPrice();

            case CostMovingAverageFallbackSequence::ActiveCostThenLastIssue:
                InventPriceMap itemPriceMap = this.findActiveCost(_inventSum, _priceDate);

                if (!itemPriceMap.RecId)
                {
                    CostPriceSearchDataContract searchDataContract = this.findLatestIssueInventTransCost(_inventSum);
                    if (searchDataContract.isCostPriceFound)
                    {
                        return searchDataContract.costPrice;
                    }
                }

                return itemPriceMap.pcsPrice();
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLatestIssueInventTransCost</Name>
				<Source><![CDATA[
    private CostPriceSearchDataContract findLatestIssueInventTransCost(InventSum _inventSum)
    {
        CostPriceSearchDataContract costPriceSearchDataContract = CostPriceSearchDataContract::construct();

        if (InventMovingAverageGetLatestIssueCostWithCacheFlight::instance().isEnabled())
        {
            InventDimParm inventDimParmFinancial;

            InventDimGroupSetup inventDimGroupSetup = InventDimGroupSetup::newItemId(_inventSum.ItemId);
            inventDimGroupSetup.inventDimParmActiveFinancialInventory(inventDimParmFinancial);
            InventDim inventDimFinancial = _inventSum.inventDim();
            inventDimFinancial.clearNotSelectedDim(inventDimParmFinancial);
            inventDimFinancial = InventDim::findOrCreate(inventDimFinancial);

            str cacheScope = classStr(InventModelType_MovingAverage) + '#' + methodStr(InventModelType_MovingAverage, findLatestIssueInventTransCost);
            str cacheKey = this.getExpectedCostKey(_inventSum.ItemId, inventDimFinancial.inventDimId);

            if (SysTransactionScopeCache::isSet(cacheScope, cacheKey))
            {
                CostPricePcs cacheValue = SysTransactionScopeCache::get(cacheScope, cacheKey, null);
                costPriceSearchDataContract.costPrice = cacheValue;
                costPriceSearchDataContract.isCostPriceFound = true;
            }
            else
            {
                InventTrans inventTrans = this.getLatestIssueInventTrans(_inventSum);

                if (inventTrans.RecId
                    && inventTrans.Qty)
                {
                    costPriceSearchDataContract.costPrice = inventTrans.CostAmountPhysical / inventTrans.Qty;
                    SysTransactionScopeCache::set(cacheScope, cacheKey, costPriceSearchDataContract.costPrice);
                    costPriceSearchDataContract.isCostPriceFound = true;
                }
            }
        }
        else
        {
            InventTrans inventTrans = this.getLatestIssueInventTrans(_inventSum);

            if (inventTrans.RecId
                && inventTrans.Qty)
            {
                costPriceSearchDataContract.costPrice = inventTrans.CostAmountPhysical / inventTrans.Qty;
                costPriceSearchDataContract.isCostPriceFound = true;
            }
        }

        return costPriceSearchDataContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findActiveCost</Name>
				<Source><![CDATA[
    private InventPriceMap findActiveCost(InventSum _inventSum, PriceDate _priceDate)
    {
        return InventItemPrice::findCurrent(_inventSum.ItemId, CostingVersionPriceType::Cost, _inventSum.InventDimId, _priceDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCostMovingAverageFallbackSequence</Name>
				<Source><![CDATA[
    private CostMovingAverageFallbackSequence getCostMovingAverageFallbackSequence()
    {
        return InventParameters::find().CostMovingAverageFallbackSequence;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLatestIssueInventTrans</Name>
				<Source><![CDATA[
    private InventTrans getLatestIssueInventTrans(InventSum _inventSum)
    {
        InventDimParm           inventDimParmFinancial;

        InventDimGroupSetup inventDimGroupSetup = InventDimGroupSetup::newItemId(_inventSum.ItemId);
        inventDimGroupSetup.inventDimParmActiveFinancialInventory(inventDimParmFinancial);
        InventDim inventDimFinancial = _inventSum.inventDim();
        inventDimFinancial.clearNotSelectedDim(inventDimParmFinancial);
        InventDim               inventDim;
        InventTrans             inventTrans;

        if (InventMovingAverageLatestIssueTransNonWorkFlight::instance().isEnabled() && WHSInventEnabled::exist(_inventSum.ItemId))
        {
            select firstonly RecId, Qty, CostAmountPhysical
                from inventTrans
                order by DateStatus desc, RecId desc
                where inventTrans.ItemId == _inventSum.ItemId
                    && (inventTrans.StatusIssue == StatusIssue::Deducted ||
                        inventTrans.StatusIssue == StatusIssue::Sold)
                    && inventTrans.StatusReceipt == StatusReceipt::None
                    && inventTrans.ValueOpen == InventTransOpen::Yes
                    #inventDimExistsJoin(inventTrans.inventDimId, inventDim, inventDimFinancial, inventDimParmFinancial);
        }
        else
        {
            select firstonly RecId, Qty, CostAmountPhysical
                from inventTrans
                order by DateStatus desc, RecId desc
                where inventTrans.ItemId == _inventSum.ItemId
                    && (inventTrans.StatusIssue == StatusIssue::Deducted ||
                       inventTrans.StatusIssue == StatusIssue::Sold)
                    && inventTrans.StatusReceipt == StatusReceipt::None
                    #inventDimExistsJoin(inventTrans.inventDimId, inventDim, inventDimFinancial, inventDimParmFinancial);
        }

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the estimated physical value for an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> record for which to get the estimated physical value.
    /// </param>
    /// <param name="_inventOnhand">
    /// The <c>InventOnHand</c> object.
    /// </param>
    /// <param name="_updateNow">
    /// The <c>InventUpdate</c> object.
    /// </param>
    /// <returns>
    /// The estimated physical value for the inventory transaction.
    /// </returns>
    public CostAmount estimatedPhysicalValue(InventTrans _inventTrans, InventOnhand _inventOnhand, InventUpdate _updateNow)
    {
        CostAmount              costAmount;

        if (_inventTrans.Qty >= 0)
        {
            costAmount = super(_inventTrans, _inventOnhand, _updateNow);
        }
        else
        {
            InventDimGroupSetup inventDimGroupSetup = InventDimGroupSetup::newItemId(_inventTrans.ItemId);
            InventOnhand financialInventOnHand = this.financialInventOnHand(_inventTrans.ItemId, _inventTrans.InventDimId, inventDimGroupSetup, _inventOnhand);
            InventSum inventSum = financialInventOnHand.inventSumWithoutAvailability(true);

            costAmount = CurrencyExchangeHelper::amount(_inventTrans.Qty * this.costPricePcs(inventSum));
        }

        return costAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialInventOnHand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the financial available inventory.
    /// </summary>
    /// <param name="_itemId">
    /// The <c>ItemId</c> value for the item.
    /// </param>
    /// <param name="_inventDimId">
    /// The physical <c>InventDimId</c> value.
    /// </param>
    /// <param name="_inventDimGroupSetup">
    /// The <c>InventDimGroupSetup</c> value for the item.
    /// </param>
    /// <param name="_inventOnhand">
    /// An <c>InventOnHand</c> object that has the physical on-hand inventory.
    /// </param>
    /// <returns>
    /// An <c>InventOnHand</c> object that has the financial on-hand inventory.
    /// </returns>
    protected InventOnhand financialInventOnHand(
        ItemId              _itemId,
        InventDimId         _inventDimId,
        InventDimGroupSetup _inventDimGroupSetup,
        InventOnhand        _inventOnhand = null)
    {
        InventDimParm   inventDimParmFinancial;
        InventOnhand    financialInventOnHand;

        _inventDimGroupSetup.inventDimParmActiveFinancialInventory(inventDimParmFinancial);

        if (_inventOnhand && InventDimParm::isInventDimParmEqual(_inventOnhand.parmInventDimParm(),inventDimParmFinancial))
        {
            financialInventOnHand = _inventOnhand;
        }
        else
        {
            InventDim inventDimFinancial = InventDim::find(_inventDimId);
            inventDimFinancial.clearNotSelectedDim(inventDimParmFinancial);

            if (inventDimParmFinancial.InventOwnerIdFlag_RU
                    && !inventDimFinancial.InventOwnerId_RU)
            {
                // For owner enabled items where the owner is not set use the legal entity
                inventDimFinancial.InventOwnerId_RU = InventOwner_RU::findOrCreateCurrentLegalEntity().InventOwnerId;
            }

            inventDimFinancial      = InventDim::findOrCreate(inventDimFinancial);
            financialInventOnHand   = InventOnhand::newItemDim(_itemId, inventDimFinancial, inventDimParmFinancial);
        }

        return financialInventOnHand;
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialIssueCostValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the financial issue cost for an inventory transaction.
    /// </summary>
    /// <param name="_inventMovement">
    /// The <c>InventMovement</c> object for which to calculate the issue cost.
    /// </param>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> record for which to calculate the issue cost.
    /// </param>
    /// <param name="_inventOnhand">
    /// An <c>InventOnHand</c> object that has the financial on-hand inventory.
    /// </param>
    /// <returns>
    /// The financial issue cost for the inventory transaction.
    /// </returns>
    public CostAmount financialIssueCostValue(InventMovement _inventMovement, InventTrans _inventTrans, InventOnhand _inventOnhand)
    {
        // The financial issue cost is the cost calculated when the item was physically issued from inventory
        return _inventTrans.CostAmountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExpectedPostedQtyAndValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the posted quantity and value for the item and financial dimension.
    /// </summary>
    /// <param name="_inventSum">
    /// The <c>InventSum</c> record with the financial values, <c>ItemId</c> and financial
    /// <c>InventDimId</c> values to set the expected cost.
    /// </param>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> record.
    /// </param>
    /// <param name="_expense">
    /// The amount that is expensed.
    /// </param>
    /// <returns>
    /// The container with posted quantity and value
    /// </returns>
    protected container getExpectedPostedQtyAndValue(InventSum _inventSum, InventTrans _inventTrans, CostAmount _expense)
    {
        Qty postedQty = _inventSum.Received + _inventSum.PostedQty - _inventSum.Deducted;
        CostAmount postedValue = _inventSum.PhysicalValue + _inventSum.PostedValue + _expense;
    
        if (_inventTrans.StatusReceipt == StatusReceipt::Received)
        {
            postedQty += _inventTrans.Qty;
            postedValue += _inventTrans.CostAmountPhysical;
        }
        else if (_inventTrans.StatusReceipt == StatusReceipt::Purchased)
        {
            postedValue -= _inventTrans.CostAmountPhysical;
            postedValue += _inventTrans.CostAmountPosted;
            postedValue += _inventTrans.CostAmountAdjustment;
        }
    
        return [postedQty, postedValue];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExpectedCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the expected cost for a <c>InventSum</c> record.
    /// </summary>
    /// <param name="_inventSum">
    /// The <c>InventSum</c> record.
    /// </param>
    /// <returns>
    /// The expected cost.
    /// </returns>
    protected CostPricePcs getExpectedCost(InventSum _inventSum)
    {
        CostPricePcs    costPricePcs;

        Qty postedQty = _inventSum.Received + _inventSum.PostedQty - _inventSum.Deducted;
        CostAmount postedValue = _inventSum.PhysicalValue + _inventSum.PostedValue;

        if (postedQty)
        {
            costPricePcs = postedValue / postedQty;
        }

        return SysTransactionScopeCache::get(classStr(InventModelType_MovingAverage), this.getExpectedCostKey(_inventSum.ItemId, _inventSum.InventDimId), costPricePcs);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExpectedCostKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a key that is used to retrieve the expected cost.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID of the item.
    /// </param>
    /// <param name="_inventDimId">
    /// The inventory dimension ID for the inventory dimension.
    /// </param>
    /// <returns>
    /// A key that is used to retrieve the expected cost.
    /// </returns>
    private str getExpectedCostKey(ItemId _itemId, InventDimId _inventDimId)
    {
        return curext() + '#' + _itemId + '#' + _inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostPriceMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the cost for an item.
    /// </summary>
    /// <param name="_inventTable">
    /// The <c>InventTable</c> record for the item.
    /// </param>
    /// <param name="_inventDimId">
    /// The <c>InventDimID</c> value for which to retrieve the cost.
    /// </param>
    /// <param name="_inventTableModuleInvent">
    /// The <c>InventTableModule</c> record to retrieve the cost for; optional.
    /// </param>
    /// <param name="_transDate">
    /// The date to retrieve the cost for; optional.
    /// </param>
    /// <param name="_newSiteId">
    /// The site to retrieve the cost for; optional.
    /// </param>
    /// <param name="_throwError">
    /// A Boolean value that indicates whether to throw an error if no cost is found; optional.
    /// </param>
    /// <returns>
    /// An <c>InventPriceMap</c> buffer that has the cost for the item.
    /// </returns>
    /// <remarks>
    /// The owner dimension is used when retrieving the correct item price. In case the specified item is owner enabled the owner dimension must be specified.
    /// </remarks>
    public InventPriceMap inventCostPriceMap(
        InventTable             _inventTable,
        InventDimId             _inventDimId,
        InventTableModule       _inventTableModuleInvent    = null, // set this parameter for better performance if avail
        TransDate               _transDate                  = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        InventSiteId            _newSiteId                  = '',
        boolean                 _throwError                 = false)
    {
        InventItemPrice     inventItemPrice;

        InventOnhand financialInventOnHand = this.financialInventOnHand(_inventTable.ItemId, _inventDimId, InventDimGroupSetup::newItemId(_inventTable.ItemId));
        InventSum inventSum = financialInventOnHand.inventSumWithoutAvailability(true);

        inventItemPrice.Price = CurrencyExchangeHelper::price(this.costPricePcs(inventSum));
        inventItemPrice.PriceQty = 1;

        return inventItemPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventModel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the inventory model.
    /// </summary>
    /// <returns>
    /// The inventory model.
    /// </returns>
    public InventModel inventModel()
    {
        return InventModel::MovingAverage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventSumOpenTransact</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of a subclass of the <c>InventSumOpenTransact</c> class.
    /// </summary>
    /// <param name="_perDate">
    /// The date to calculate the open transactions.
    /// </param>
    /// <param name="_itemId">
    /// The ID of the item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// An <c>InventDim</c> record with the criteria.
    /// </param>
    /// <param name="_inventDimParm">
    /// An <c>InventDimParm</c> record with the parameters.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventSumOpenTransact</c> class.
    /// </returns>
    public InventSumOpenTransact inventSumOpenTransact(TransDate _perDate, ItemId _itemId, InventDim _inventDimCriteria, InventDimParm _inventDimParm)
    {
        return new InventSumOpenTransactMovingAverage(_perDate, _itemId, _inventDimCriteria, _inventDimParm);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventoryOwnerAllowed</Name>
				<Source><![CDATA[
    public boolean isInventoryOwnerAllowed()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSettled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if the inventory model is settled.
    /// </summary>
    /// <returns>
    /// true if the inventory model is settled; otherwise, false.
    /// </returns>
    public boolean isSettled()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipBackdateCheck</Name>
				<Source><![CDATA[
    protected boolean skipBackdateCheck(InventTrans _inventTrans)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransactionBackdated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a given <c>InventTrans</c> record represents a backdated transaction according to the Moving Average costing method.
    /// </summary>
    /// <param name="_inventTrans">
    /// Record which will be checked.
    /// </param>
    /// <param name="_transactionDate">
    /// Physical update date or financial update date of the <c>InventTrans</c> record depending if the check is happening for a physical update or for a financial update.
    /// </param>
    /// <param name="_inventDimGroupSetup">
    /// Inventory dimension group setup of the transaction; used for finding financially active dimensions of the transaction.
    /// </param>
    /// <returns>
    /// true if transaction is backdated; otherwise, false.
    /// </returns>
    private boolean isTransactionBackdated(
        InventTrans         _inventTrans,
        TransDate           _transactionDate,
        InventDimGroupSetup _inventDimGroupSetup)
    {
        if (this.skipBackdateCheck(_inventTrans)
            && !CostSkipMovAvgBackdateCheckDisableFlight::instance().isEnabled())
        {
            return false;
        }

        InventTrans               futureIssueTransactions;
        InventTrans               receiptTransactions;
        InventTransOriginTransfer inventTransOriginTransfer;
        InventDimParm             inventDimParmFinancial;
        InventDim                 inventDim;

        _inventDimGroupSetup.inventDimParmActiveFinancialInventory(inventDimParmFinancial);
        InventDim inventDimFinancial = _inventTrans.inventDim();
        inventDimFinancial.clearNotSelectedDim(inventDimParmFinancial);

        select firstonly RecId from futureIssueTransactions
            where futureIssueTransactions.DatePhysical      > _transactionDate
                && (futureIssueTransactions.StatusIssue    == StatusIssue::Deducted
                    || futureIssueTransactions.StatusIssue == StatusIssue::Sold)
                && futureIssueTransactions.StatusReceipt   == StatusReceipt::None
                && futureIssueTransactions.ItemId          == _inventTrans.ItemId
            #inventDimExistsJoin(futureIssueTransactions.inventDimId, inventDim, inventDimFinancial, inventDimParmFinancial)
        notexists join inventTransOriginTransfer
                where inventTransOriginTransfer.IssueInventTransOrigin == futureIssueTransactions.InventTransOrigin;

        if (futureIssueTransactions.RecId)
        {
            return true;
        }

        while select sum(Qty), sum(CostAmountPosted), sum(CostAmountAdjustment) from futureIssueTransactions
            where futureIssueTransactions.DatePhysical      > _transactionDate
               && futureIssueTransactions.ItemId           == _inventTrans.ItemId
            join receiptInventTransOrigin from inventTransOriginTransfer
                group by receiptInventTransOrigin
                where inventTransOriginTransfer.IssueInventTransOrigin == futureIssueTransactions.InventTransOrigin
            #inventDimExistsJoin(futureIssueTransactions.inventDimId, inventDim, inventDimFinancial, inventDimParmFinancial)
        {
            select sum(Qty), sum(CostAmountPosted), sum(CostAmountAdjustment) from receiptTransactions
                where receiptTransactions.DatePhysical            > _transactionDate
                   && receiptTransactions.InventTransOrigin      == inventTransOriginTransfer.ReceiptInventTransOrigin
            #inventDimExistsJoin(receiptTransactions.inventDimId, inventDim, inventDimFinancial, inventDimParmFinancial);

            if (futureIssueTransactions.Qty + receiptTransactions.Qty != 0              ||
                futureIssueTransactions.CostAmountPosted + futureIssueTransactions.CostAmountAdjustment + receiptTransactions.CostAmountPosted + receiptTransactions.CostAmountAdjustment != 0)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustAlwaysBeBookedPhysically</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether inventory transactions must be booked physical.
    /// </summary>
    /// <returns>
    /// true if inventory transactions always must be booked physical; otherwise, false.
    /// </returns>
    public boolean mustAlwaysBeBookedPhysically()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeClosed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether inventory transactions must be closed.
    /// </summary>
    /// <returns>
    /// true if inventory transactions must be closed; otherwise, false.
    /// </returns>
    public boolean mustBeClosed()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckInventOnHand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the inventory model has to perform an available validation when the
    /// <c>InventSum</c> record is updated.
    /// </summary>
    /// <param name="_inventSumDelta">
    /// The change that is used to update the <c>InventSum</c> record.
    /// </param>
    /// <returns>
    /// true if the inventory model has to perform a available validation when the <c>InventSum</c> record
    /// is updated; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The validation is implemented in the <c>checkInventOnHand</c> method.
    /// </remarks>
    public boolean mustCheckInventOnHand(InventSumDelta _inventSumDelta)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSplitInventSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if <c>InventSettlement</c> must be split when <c>InventTrans</c> is split.
    /// </summary>
    /// <returns>
    /// true if <c>InventSettlement</c> must be split when <c>InventTrans</c> is split; otherwise, false.
    /// </returns>
    public boolean mustSplitInventSettlement()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateInventJournalCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the cost on the inventory journal must be updated to the current cost before the
    /// journal is posted.
    /// </summary>
    /// <param name="_inventJournalType">
    /// The inventory journal type.
    /// </param>
    /// <returns>
    /// true if the cost on the inventory journal must be updated to the current cost before the journal is
    /// posted; otherwise, false.
    /// </returns>
    public boolean mustUpdateInventJournalCost(InventJournalType _inventJournalType)
    {
        switch (_inventJournalType)
        {
            case InventJournalType::Count:
            case InventJournalType::TagCounting:
                return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalExpense</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns physical expense related to an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The inventory transaction.
    /// </param>
    /// <returns>
    ///    The physical expense related to an inventory transaction.
    /// </returns>
    protected CostAmount physicalExpense(InventTrans _inventTrans)
    {
        InventSettlement    settlement;
        CostAmount          amount;

        ttsbegin;
        boolean more = this.physicalSettlementList(_inventTrans).first(settlement);
        while (more)
        {
            if (settlement.OperationsPosting == LedgerPostingType::InventMovingAveragePriceDifference)
            {
                amount += settlement.CostAmountAdjustment;
            }
            more = this.physicalSettlementList(_inventTrans).next(settlement);
        }
        ttscommit;

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalSettlementList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns physical inventory settlement adjustments related to an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The inventory transaction.
    /// </param>
    /// <returns>
    ///    A record sorted list that has inventory settlement records.
    /// </returns>
    protected RecordSortedList physicalSettlementList(InventTrans _inventTrans)
    {
        if (!physicalSettlementList)
        {
            physicalSettlementList = new RecordSortedList(tableNum(InventSettlement));
            physicalSettlementList.sortOrder(fieldNum(InventSettlement, RecId));

            InventSettlement    inventSettlement;

            while select inventSettlement
            where inventSettlement.TransRecId           == _inventTrans.RecId
               && inventSettlement.Cancelled            == NoYes::No
               && inventSettlement.SettleModel          == InventSettleModel::PhysicalValue
               && (inventSettlement.OperationsPosting   == LedgerPostingType::InventMovingAveragePriceDifference || 
                   inventSettlement.OperationsPosting == LedgerPostingType::InventMovingAverageCostRevaluation)
               // <GEERU>
               && inventSettlement.InventTransCurrency_RU == inventTransCurrency
               // </GEERU>
            {
                physicalSettlementList.ins(inventSettlement);
            }
        }
        return physicalSettlementList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPriceVarianceFinancialAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts an adjustment for the inventory transaction after it is financially updated.
    /// </summary>
    /// <param name="_inventMovement">
    /// The <c>InventMovement</c> object for the transaction.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> object for the transaction.
    /// </param>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> buffer.
    /// </param>
    /// <param name="_adjustment">
    /// The adjustment amount.
    /// </param>
    /// <remarks>
    /// The method must be called after the <c>InventTrans</c> buffer is updated financial.
    /// </remarks>
    public void postPriceVarianceFinancialAdjustment(InventMovement   _inventMovement,
                                                     LedgerVoucher    _ledgerVoucher,
                                                     InventTrans      _inventTrans,
                                                     CostAmount       _adjustment)
    {
        if (_adjustment)
        {
            InventSettlement inventSettlement = _inventTrans.updatePriceVarianceFin(_inventMovement,
                                                                   this.varianceAccountType(),
                                                                   _ledgerVoucher.lastVoucher(),
                                                                   _ledgerVoucher.lastTransDate(),
                                                                   _adjustment);
            if (inventSettlement.CostAmountAdjustment)
            {
                if (_inventMovement.mustBeBookedFinancially())
                {
                    inventSettlement.post(_ledgerVoucher);
                }
                inventSettlement.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdateFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the inventory transaction after it is updated financial.
    /// </summary>
    /// <param name="_inventMovement">
    /// The <c>InventMovement</c> object for the transaction.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> object for the transaction.
    /// </param>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> buffer.
    /// </param>
    /// <param name="_inventOnhand">
    /// The <c>InventOnhand</c> object that has the physical or financial inventory available.
    /// </param>
    /// <remarks>
    /// The method must be called after the <c>InventTrans</c> buffer is updated financial.
    /// </remarks>
    public void postUpdateFinancial(InventMovement _inventMovement, LedgerVoucher _ledgerVoucher, InventTrans _inventTrans, InventOnhand _inventOnhand = null)
    {
        Qty					postedQty;
        CostAmount          expenseAmount;
        CostAmount			postedValue;

        if (_inventTrans.Qty >= 0)
        {
            CostAmount physicalExpenseAmount = this.physicalExpense(_inventTrans);
            this.updateLedgerRedoAdjustments(_inventMovement, _ledgerVoucher, _inventTrans);
            if (!this.isTransactionBackdated(_inventTrans, _inventTrans.DateFinancial, _inventMovement.inventDimGroupSetup()))
            {
                InventOnhand financialInventOnHand = this.financialInventOnHand(_inventTrans.ItemId, _inventTrans.InventDimId, _inventMovement.inventDimGroupSetup(), _inventOnhand);
                InventSum inventSum = financialInventOnHand.inventSumWithoutAvailability(true);

                Qty adjustableQty = max(_inventTrans.Qty + inventSum.PostedQty - inventSum.Deducted, 0);

                if (adjustableQty < _inventTrans.Qty)
                {
                    expenseAmount = CurrencyExchangeHelper::amount((_inventTrans.CostAmountPhysical - _inventTrans.CostAmountPosted) * (1 - adjustableQty / _inventTrans.Qty));
                }
                expenseAmount += physicalExpenseAmount;
                [postedQty, postedValue] = this.getExpectedPostedQtyAndValue(inventSum, _inventTrans, expenseAmount);
                if (postedQty >= 0 && postedValue < 0)
                {
                    // expense the diff and set expected cost to 0
                    expenseAmount -= postedValue;
                }
                this.setExpectedCost(inventSum, _inventTrans, expenseAmount);
            }
            else
            {
                expenseAmount = _inventTrans.CostAmountPhysical - _inventTrans.CostAmountPosted + physicalExpenseAmount;
                // No specific on-hand check is needed because we always expense on backdate
            }

            if (expenseAmount)
            {
                this.postPriceVarianceFinancialAdjustment(_inventMovement, _ledgerVoucher, _inventTrans, expenseAmount);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdateFinancialAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the inventory transaction after it is financially adjusted.
    /// </summary>
    /// <param name="_inventTrans">
    /// The adjusted <c>InventTrans</c> record.
    /// </param>
    /// <param name="_voucher">
    /// The <c>Voucher</c> for the adjustment
    /// </param>
    /// <param name="_postingDate">
    /// The <c>TransDate</c> for the adjustment.
    /// </param>
    /// <param name="_costAmount">
    /// The adjustment amount.
    /// </param>
    /// <remarks>
    /// The method must be called after the <c>InventTrans</c> record is financial adjusted.
    /// </remarks>
    public void postUpdateFinancialAdjustment(
        InventTrans     _inventTrans,
        Voucher         _voucher,
        TransDate       _postingDate,
        CostAmount      _costAmount)
    {
        InventSettlement inventSettlement = _inventTrans.updatePriceVarianceFin(_inventTrans.inventMovement(true),
                                                                                this.varianceAccountType(),
                                                                                _voucher,
                                                                                _postingDate,
                                                                                -_costAmount);

        if (inventSettlement.CostAmountAdjustment)
        {
            inventSettlement.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExpectedCostSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the expected cost for a <c>InventSum</c> record is cached
    /// </summary>
    /// <param name="_inventSum">
    /// The <c>InventSum</c> record for which to determine the cost.
    /// </param>
    /// <returns>
    /// true if the expected cost is cached; otherwise, false
    /// </returns>
    protected boolean isExpectedCostSet(InventSum _inventSum)
    {
        if (SysTransactionScopeCache::get(classStr(InventModelType_MovingAverage), this.getExpectedCostKey(_inventSum.ItemId, _inventSum.InventDimId), null))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdatePhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the inventory transaction after it is updated physical.
    /// </summary>
    /// <param name="_inventMovement">
    /// The <c>InventMovement</c> object for the transaction.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> object for the transaction.
    /// </param>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> record.
    /// </param>
    /// <param name="_financialInventOnhand">
    /// The <c>InventOnhand</c> object that has the financial inventory available.
    /// </param>
    /// <remarks>
    /// The method must be called after the <c>InventTrans</c> buffer is updated physical.
    /// </remarks>
    public void postUpdatePhysical(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventOnhand    _financialInventOnhand = null)
    {
        CostAmount      expenseAmount;

        InventOnhand financialInventOnHand = this.financialInventOnHand(_inventTrans.ItemId, _inventTrans.InventDimId, _inventMovement.inventDimGroupSetup(), _financialInventOnHand);
        InventSum inventSum = financialInventOnHand.inventSumWithoutAvailability(true);
        if (_inventTrans.Qty >= 0)
        {
            if (!inventSum.InventDimId)
            {
                inventSum.InventDimId = _inventTrans.InventDimId;   // The InventSum is summarized, the InventDimId is set to ensure that the costPricePcs API will find the correct cost price.
            }

            if (!this.isTransactionBackdated(_inventTrans, _inventTrans.DatePhysical, _inventMovement.inventDimGroupSetup()))
            {
                Qty adjustableQty =  max(_inventTrans.Qty + inventSum.PostedQty - inventSum.Deducted + inventSum.Received, 0);

                if (adjustableQty < _inventTrans.Qty)
                {
                    expenseAmount = CurrencyExchangeHelper::amount((CurrencyExchangeHelper::amount(_inventTrans.Qty * this.costPricePcs(inventSum)) - _inventTrans.CostAmountPhysical) * (1 - adjustableQty / _inventTrans.Qty));
                }
                this.setExpectedCost(inventSum, _inventTrans, expenseAmount);
            }
            else
            {
                expenseAmount = CurrencyExchangeHelper::amount(_inventTrans.Qty * this.costPricePcs(inventSum)) - _inventTrans.CostAmountPhysical;
                // No specific on-hand check is needed because we always expense on backdate
            }

            if (expenseAmount)
            {
                InventSettlement inventSettlement = _inventTrans.updatePriceVariancePhy(_inventMovement,
                                                                       this.varianceAccountType(),
                                                                       expenseAmount);
                if (_inventMovement.mustBeBookedPhysically())
                {
                    inventSettlement.post(_ledgerVoucher);
                }
                inventSettlement.insert();
            }
        }
        else
        {
            // recalculate expected cost if earlier receipt is posted in the same transaction scope
            if (this.isExpectedCostSet(inventSum))
            {
                this.setExpectedCost(inventSum, _inventTrans, 0);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdatePhysicalReturn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the inventory transaction after it is updated physical for return.
    /// </summary>
    /// <param name="_inventMovement">
    /// The <c>InventMovement</c> object for the transaction.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> object for the transaction.
    /// </param>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> record.
    /// </param>
    /// <param name="_returnInventTrans">
    /// The return <c>InventTrans</c> record.
    /// </param>
    /// <remarks>
    /// The method must be called after the <c>InventTrans</c> buffer is updated physical for return.
    /// </remarks>
    public void postUpdatePhysicalReturn(InventMovement _inventMovement, LedgerVoucher _ledgerVoucher, InventTrans _inventTrans, InventTrans _returnInventTrans)
    {
        CostAmount expenseAmount;

        if (_inventTrans.Qty > 0)
        {
            this.postUpdatePhysical(_inventMovement, _ledgerVoucher, _inventTrans);
            this.preUpdateFinancial(_inventMovement, _ledgerVoucher, _inventTrans);
            expenseAmount = this.physicalExpense(_inventTrans);
            if (expenseAmount)
            {
                this.postPriceVarianceFinancialAdjustment(_inventMovement, _ledgerVoucher, _inventTrans, expenseAmount);
            }
        }

        // physical issue return for receipt origin
        if (_returnInventTrans.Qty > 0)
        {
            InventOnhand    financialInventOnHand = this.financialInventOnHand(_returnInventTrans.ItemId, _returnInventTrans.InventDimId, _inventMovement.inventDimGroupSetup());
            InventSum       inventSum = financialInventOnHand.inventSumWithoutAvailability(true);
            Qty             postedQty   = inventSum.PostedQty - inventSum.Deducted + inventSum.Received;
            CostAmount      postedValue = inventSum.PostedValue + inventSum.PhysicalValue;

            if (postedValue && (postedQty == 0 || (sign(postedQty) != sign(postedValue))))
            {
                expenseAmount = -postedValue;
                this.postPriceVarianceFinancialAdjustment(_inventMovement, _ledgerVoucher, _returnInventTrans, expenseAmount);
                SysTransactionScopeCache::set(classStr(InventModelType_MovingAverage), this.getExpectedCostKey(inventSum.ItemId, inventSum.InventDimId), 0.0);
            }
            else if (this.isExpectedCostSet(inventSum))
            {
                // recalculate expected cost if earlier receipt is posted in the same transaction scope
                this.setExpectedCost(inventSum, _inventTrans, 0);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preUpdateFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reverses the physical value adjustments.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>InventMovement</c> that belongs to the currently processed transaction.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> to which the postings should be added.
    /// </param>
    /// <param name="_inventTrans">
    ///    The inventory transaction that is currently processed.
    /// </param>
    /// <param name="_inventOnhand">
    /// The <c>InventOnhand</c> object that has the physical or financial inventory.
    /// </param>
    public void preUpdateFinancial(InventMovement _inventMovement, LedgerVoucher _ledgerVoucher, InventTrans _inventTrans, InventOnhand _inventOnhand = null)
    {
        if (_inventTrans.Qty >= 0)
        {
            if (_inventOnhand)
            {
                _inventOnhand.inventSumWithoutAvailability(false).subInventTransOnSum(_inventTrans);
            }
            this.updateLedgerReverseAdjustments(_inventMovement, _ledgerVoucher, _inventTrans);
            _inventTrans.update();
            if (_inventOnhand)
            {
                _inventOnhand.inventSumWithoutAvailability(false).addInventTransOnSum(_inventTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>revaluationAccountType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the revaluation account type for the inventory model.
    /// </summary>
    /// <returns>
    /// The revaluation account type for the inventory model.
    /// </returns>
    protected InventAccountType revaluationAccountType()
    {
        return InventAccountType::InventMovingAverageCostRevaluation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExpectedCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the expected cost for the item and financial dimension.
    /// </summary>
    /// <param name="_inventSum">
    /// The <c>InventSum</c> record with the financial values, <c>ItemId</c> and financial
    /// <c>InventDimId</c> values to set the expected cost.
    /// </param>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> record.
    /// </param>
    /// <param name="_expense">
    /// The amount that is expensed.
    /// </param>
    /// <remarks>
    /// The expected cost is validated before the transactions commit.
    /// </remarks>
    protected void setExpectedCost(InventSum _inventSum, InventTrans _inventTrans, CostAmount _expense)
    {
        Qty             postedQty;
        CostAmount      postedValue;
        CostPricePcs    costPricePcs;
        
        [postedQty, postedValue] = this.getExpectedPostedQtyAndValue( _inventSum, _inventTrans, _expense);
        
        if (postedQty)
        {
            costPricePcs = postedValue / postedQty;
        }
        else
        {
            costPricePcs = this.getExpectedCost(_inventSum);
        }
        
        SysTransactionScopeCache::set(classStr(InventModelType_MovingAverage), this.getExpectedCostKey(_inventSum.ItemId, _inventSum.InventDimId), costPricePcs);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerReverseAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reverses a physical value adjustment.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>InventMovement</c> that belongs to the currently processed transaction.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> to which the postings should be added.
    /// </param>
    /// <param name="_inventTrans">
    ///    The inventory transaction that is currently processed.
    /// </param>
    protected void updateLedgerReverseAdjustments(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans)
    {
        InventSettlement    settlement;

        ttsbegin;
        physicalSettlementList = null;
        boolean more = this.physicalSettlementList(_inventTrans).first(settlement);
        while (more)
        {
            this.reversePhysicalSettlement(_inventMovement,_ledgerVoucher,_inventTrans, settlement);
            more = this.physicalSettlementList(_inventTrans).next(settlement);
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerRedoAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Redo physical adjustments from revaluation.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>InventMovement</c> that belongs to the currently processed transaction.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> to which the postings should be added.
    /// </param>
    /// <param name="_inventTrans">
    ///    The inventory transaction that is currently processed.
    /// </param>
    protected void updateLedgerRedoAdjustments(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans)
    {
        InventSettlement    physicalSettlement;
        InventTransOrigin   inventTransOrigin = _inventTrans.inventTransOrigin();

        boolean more = this.physicalSettlementList(_inventTrans).first(physicalSettlement);
        while (more)
        {
            if (physicalSettlement.OperationsPosting == LedgerPostingType::InventMovingAverageCostRevaluation)
            {
                this.advancePhysicalAdjustmentToFinancialAdjustment(_inventMovement, _ledgerVoucher, _inventTrans, physicalSettlement);
            }

            more = this.physicalSettlementList(_inventTrans).next(physicalSettlement);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRevaluationAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates an inventory transaction with a revaluation adjustment.
    /// </summary>
    /// <param name="_inventClosing">
    /// The <c>InventClosing</c> record that is related to the adjustment.
    /// </param>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> record to update with the adjustment.
    /// </param>
    /// <param name="_adjustment">
    /// The adjustment to update the record.
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// A revaluation cannot be done by using this method for the inventory model.
    /// </exception>
    public void updateRevaluationAdjustment(InventClosing _inventClosing, InventTrans _inventTrans, CostAmount _adjustment)
    {
        InventSettlement    inventSettlement;

        if (_inventTrans.isUpdatedPhysical())
        {
            if (InventCostDimensionDefaultingSourceFeature::instance().isEnabled())
            {
                InventCostPriceRevaluationHelper helper = new InventCostPriceRevaluationHelper();
                helper.parmPreInventSettlement(InventSettlement::GetPreInventSettlementAccordingToPreInventCostTrans(_inventTrans.FindPreSTDItemPrice(), _inventTrans));
                inventSettlement = helper.updatePriceRevaluationPhy(_inventTrans, _inventTrans.inventTable(), this.revaluationAccountType(), _inventClosing.Voucher, _adjustment, _inventClosing.TransDate);
            }
            else
            {
                inventSettlement = _inventTrans.updatePriceRevaluationPhy(_inventTrans.inventTable(), this.revaluationAccountType(), _inventClosing.Voucher, _adjustment, _inventClosing.TransDate);
            }
        }
        else
        {
            if (InventCostDimensionDefaultingSourceFeature::instance().isEnabled())
            {
                InventCostPriceRevaluationHelper helper = new InventCostPriceRevaluationHelper();
                helper.parmPreInventSettlement(InventSettlement::GetPreInventSettlementAccordingToPreInventCostTrans(_inventTrans.FindPreSTDItemPrice(), _inventTrans));
                inventSettlement = helper.updatePriceRevaluationFin(_inventTrans, _inventTrans.inventTable(), this.revaluationAccountType(), _inventClosing.Voucher, _adjustment, _inventClosing.TransDate);
            }
            else
            {
                inventSettlement = _inventTrans.updatePriceRevaluationFin(_inventTrans.inventTable(), this.revaluationAccountType(), _inventClosing.Voucher, _adjustment, _inventClosing.TransDate);
            }
        }
        if (inventSettlement.CostAmountAdjustment)
        {
            inventSettlement.insert();
        }
        _inventTrans.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInventModelChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the inventory model group is valid.
    /// </summary>
    /// <param name="_inventModelGroup">
    /// The <c>InventModelGroup</c> record.
    /// </param>
    /// <returns>
    /// true if the inventory model group is valid; otherwise, false.
    /// </returns>
    protected boolean validateInventModelChange(InventModelGroup _inventModelGroup)
    {
        InventSum               inventSum;
        InventModelGroupItem    inventModelGroupItem;

        if (_inventModelGroup.orig().RecId)
        {
            switch (_inventModelGroup.orig().InventModel)
            {
                case InventModel::StdCost:
                case InventModel::NonValuated:

                    select pessimisticlock firstonly RecId
                    from inventSum
                    where inventSum.Closed == NoYes::No
                    exists join inventModelGroupItem
                    where inventModelGroupItem.ItemId == inventSum.ItemId
                       && inventModelGroupItem.ItemDataAreaId == inventSum.DataAreaId
                       && inventModelGroupItem.ModelGroupId == _inventModelGroup.ModelGroupId
                       && inventModelGroupItem.ModelGroupDataAreaId == _inventModelGroup.DataAreaId;

                    if (inventSum.RecId)
                    {
                        return checkFailed(strFmt("@FPK270051",
                                                   _inventModelGroup.orig().InventModel, _inventModelGroup.InventModel));
                    }
                    break;
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInventModelChangeItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the inventory model group item relation is valid.
    /// </summary>
    /// <param name="_inventModelGroupItem">
    /// The <c>InventModelGroupItem</c> record.
    /// </param>
    /// <returns>
    /// true if the inventory model group item relation is valid; otherwise, false.
    /// </returns>
    protected boolean validateInventModelChangeItem(InventModelGroupItem _inventModelGroupItem)
    {
        InventSum       inventSum;

        if (_inventModelGroupItem.orig().RecId)
        {
            InventModel changeFromInventModel = _inventModelGroupItem.orig().modelGroup().InventModel;
            switch (changeFromInventModel)
            {
                case InventModel::StdCost:

                    select pessimisticlock firstonly RecId
                    from inventSum
                    where inventSum.ItemId == _inventModelGroupItem.ItemId
                       && inventSum.DataAreaId == _inventModelGroupItem.ItemDataAreaId
                       && inventSum.Closed == NoYes::No
                       && inventSum.IsExcludedFromInventoryValue == NoYes::No;

                    if (inventSum.RecId)
                    {
                        return checkFailed(strFmt("@FPK270051",
                                                   changeFromInventModel, this.inventModel()));
                    }
                    break;
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteInventModelGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the inventory model group is valid.
    /// </summary>
    /// <param name="_inventModelGroup">
    /// The <c>InventModelGroup</c> record.
    /// </param>
    /// <returns>
    /// true if the inventory model group is valid; otherwise, false.
    /// </returns>
    public boolean validateWriteInventModelGroup(InventModelGroup _inventModelGroup)
    {
        boolean ret = this.validateInventModelChange(_inventModelGroup);
        ret         = this.validatePostOnhandPhysicalEnabled(_inventModelGroup) && ret;
        ret         = this.validatePostOnhandFinancialEnabled(_inventModelGroup) && ret;
        ret         = this.validateInclPhysicalValueInCostDisabled(_inventModelGroup) && ret;
        ret         = this.validateStandardCostDisabled(_inventModelGroup) && ret;
        ret         = this.validateModelGroupHasNoService(_inventModelGroup) && ret;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteInventModelGroupItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the inventory model group item relation is valid.
    /// </summary>
    /// <param name="_inventModelGroupItem">
    /// The <c>InventModelGroupItem</c> record.
    /// </param>
    /// <param name="_inclConvCheck">
    /// A Boolean value that indicates whether the conversion check is included.
    /// </param>
    /// <returns>
    /// true if the inventory model group item relation is valid; otherwise, false.
    /// </returns>
    public boolean validateWriteInventModelGroupItem(InventModelGroupItem _inventModelGroupItem, boolean _inclConvCheck = true)
    {
        boolean ret = this.validateItemTypeIsNotService(_inventModelGroupItem);
        ret = ret && this.validateInventModelChangeItem(_inventModelGroupItem);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>varianceAccountType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the variance account type for the inventory model.
    /// </summary>
    /// <returns>
    /// The variance account type for the inventory model.
    /// </returns>
    protected InventAccountType varianceAccountType()
    {
        return InventAccountType::InventMovingAveragePriceDifference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static InventModelType_MovingAverage construct()
    {
        return new InventModelType_MovingAverage();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>