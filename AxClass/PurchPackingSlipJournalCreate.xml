<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchPackingSlipJournalCreate</Name>
	<SourceCode>
		<Declaration><![CDATA[
class PurchPackingSlipJournalCreate
extends FormLetterVersionableJournalCreate
{
    VendPackingSlipVersion      vendPackingSlipVersion;
    VendPackingSlipJour         vendPackingSlipJour;
    PurchTable                  purchTable;
    PurchParmTable              purchParmTable;
    PurchParmUpdate             purchParmUpdate;

    PurchTotals                 purchTotals;
    RecordSortedList            recordListPurchParmLine;
    NoYes                       creditNote;
    boolean                     useInternalNumber;
    InterCompanyVoucher         interCompanyVoucher;
    Num                         internalNumber;
    RefRecId                    accountingEventRefRecId;
    VendParameters              vendParameters;
    ReceiptListDeviationType_RU receiptListDeviationType;
    boolean                     preserveReceiptStatement;
    boolean                     isJournalHeaderChanged;
    boolean                     isCountryRegion_RU;
    boolean                     isCountryRegion_IN;
    #EECountryRegionCodes
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustAccountingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the accounting date of the journal version.
    /// </summary>
    /// <param name="_showMessage">
    ///     Indicates whether a message should be shown if the original accounting date cannot be used so next available date will be used instead.
    /// </param>
    /// <returns>
    /// The available accounting date.
    /// </returns>
    public AccountingDate adjustAccountingDate(boolean _showMessage)
    {
        Map       dataAreaIds;

        FormLetterContract formLetterContract = this.parmInterCompanyFormletterContract();

        accountingDate = formLetterContract.parmAccountingDate();
        if (!accountingDate)
        {
            dataAreaIds = new Map(Types::String, Types::Record);
            accountingDate = PurchPackingSlipJournalCreate::findAvailableInventoryDate(vendPackingSlipJour, accountingDate, dataAreaIds, _showMessage);

            accountingDate = PurchPackingSlipJournalCreate::findOpenFiscalDate(accountingDate, dataAreaIds, _showMessage);

            formLetterContract.parmAccountingDate(accountingDate);
        }

        return accountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateGRNNumber_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allocates GRN number.
    /// </summary>
    /// <returns>
    /// The instance of the <c>GoodsReceiptNote_IN</c> class.
    /// </returns>
    // When posting packing slip, if Print Goods receipt note check box is selected or for any of the lines
    // accepted quantity field is entered, then generate theGRN number. Called from this.initJournalHeader.
    protected GoodsReceiptNote_IN allocateGRNNumber_IN()
    {
        GoodsReceiptNote_IN grnNumber;
        NumberSequenceCode  grnNumberSeqCode = NumberSequenceTable::find(NumberSequenceReference::findByDatatypeAndScope(extendedTypeNum(GoodsReceiptNote_IN)).NumberSequenceId).NumberSequence;

        if (this.checkGRNAcceptedQuantity_IN() || printGoodsReceiptNote)
        {
            if (grnNumberSeqCode)
            {
                grnNumber =  NumberSeq::newGetNum(PurchParameters::numRefGoodsReceiptNote_IN()).num();
            }
            else
            {
                throw error(strFmt("@SYS53911", "@GLS5545", "@SYS25194"));
            }
        }

        return grnNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateNumAndVoucher</Name>
				<Source><![CDATA[
    protected NumberSeq allocateNumAndVoucher()
    {
        RefRecId  packingSlipNumber;
        RefRecId  packingSlipVoucher;
        NumberSequenceDatatype numberDatatype = NumberSequenceDatatype::find(PurchParameters::numRefPurchPackingSlipId().NumberSequenceDatatype);
        NumberSequenceDatatype voucherDatatype = NumberSequenceDatatype::find(PurchParameters::numRefPurchPackingSlipVoucher().NumberSequenceDatatype);
        RefRecId scopeId = NumberSeqScopeFactory::createDefaultScope().getId();

        NumberSequenceReference voucherSequenceReference;

        boolean             voucherEqualsNumber;

        packingSlipNumber = this.packingSlipNumber_PL();

        if (purchTable.NumberSequenceGroup)
        {
            if (! packingSlipNumber)
            {
            packingSlipNumber = NumberSequenceGroupRef::findNaturalKey(numberDatatype.RecId, scopeId, purchTable.NumberSequenceGroup).NumberSequenceId;
            } //

            if (!packingSlipNumber)
            {
                packingSlipNumber = PurchParameters::numRefPurchPackingSlipId().NumberSequenceId;
            }

            if (PurchParameters::numRefPurchPackingSlipVoucher().AllowSameAs)
            {
                voucherEqualsNumber = true;
                packingSlipVoucher  = packingSlipNumber;
            }
            else
            {
                packingSlipVoucher = NumberSequenceGroupRef::findNaturalKey(voucherDatatype.RecId, scopeId, purchTable.NumberSequenceGroup).NumberSequenceId;

                if (!packingSlipVoucher)
                {
                    packingSlipVoucher = PurchParameters::numRefPurchPackingSlipVoucher().NumberSequenceId;
                }
            }

            if (packingSlipNumber)
            {
                useInternalNumber = true;

                if (isCountryRegion_RU)
                {
                    return NumberSeq::newGetNumAndVoucherFromId(packingSlipNumber,
                                                                packingSlipVoucher,
                                                                voucherEqualsNumber,
                                                                false,
                                                                false,
                                                                UnknownNoYes::No);
                }
                else
                {
                return NumberSeq::newGetNumAndVoucherFromId(packingSlipNumber, packingSlipVoucher, voucherEqualsNumber);
                }
            }
            else
            {
                useInternalNumber = false;

                if (isCountryRegion_RU)
                {
                    return NumberSeq::newGetVoucherFromId(packingSlipVoucher,
                                                          false,
                                                          false,
                                                          UnknownNoYes::No);
                }
                else
                {
                return NumberSeq::newGetVoucherFromId(packingSlipVoucher);
                }
            }
        }
        else
        {
            if (packingSlipNumber &&
                (isCountryRegion_RU || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL])))
            {
                voucherSequenceReference = PurchParameters::numRefPurchPackingSlipVoucher();
                if (voucherSequenceReference.AllowSameAs)
                {
                    voucherEqualsNumber = true;
                    packingSlipVoucher  = packingSlipNumber;
                }

                if (! packingSlipVoucher)
                {
                    packingSlipVoucher = NumberSequenceGroupRef::findNaturalKey(voucherDatatype.RecId,
                                                                                scopeId,
                                                                                purchTable.NumberSequenceGroup).NumberSequenceId;
                }

                if (! packingSlipVoucher)
                {
                    packingSlipVoucher = PurchParameters::numRefPurchPackingSlipVoucher().NumberSequenceId;
                }

                useInternalNumber = true;
                return NumberSeq::newGetNumAndVoucherFromId(packingSlipNumber,
                                                            packingSlipVoucher,
                                                            voucherEqualsNumber,
                                                            false,
                                                            false,
                                                            UnknownNoYes::No);
            }
            else
            {
                if (PurchParameters::numRefPurchPackingSlipId().NumberSequenceId)
                {
                    useInternalNumber = true;

                    if (isCountryRegion_RU)
                    {
                        return NumberSeq::newGetNumAndVoucher(PurchParameters::numRefPurchPackingSlipId(),
                                                              PurchParameters::numRefPurchPackingSlipVoucher(),
                                                              false,
                                                              false,
                                                              UnknownNoYes::No);
                    }
                    else
                    {
                        return NumberSeq::newGetNumAndVoucher(PurchParameters::numRefPurchPackingSlipId(),
                                                              PurchParameters::numRefPurchPackingSlipVoucher());
                    }
                }
                else
                {
                    useInternalNumber = false;

                    if (isCountryRegion_RU)
                    {
                        return NumberSeq::newGetVoucher(PurchParameters::numRefPurchPackingSlipVoucher(),
                                                        false,
                                                        false,
                                                        UnknownNoYes::No);
                    }
                    else
                    {
                        return NumberSeq::newGetVoucher(PurchParameters::numRefPurchPackingSlipVoucher());
                    }
                }
            } //
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>beforePostDocument</Name>
				<Source><![CDATA[
    delegate void beforePostDocument(PurchParmTable _purchParmTable, ChargesArgs _args)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>canWriteTaxAmountLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if tax amount line can be written.
    /// </summary>
    /// <param name="_purchParmLine">
    /// <c>PurchParmLine</c> record.
    /// </param>
    /// <returns>
    /// true if tax amount line can be written; Otherwise, false.
    /// </returns>
    protected boolean canWriteTaxAmountLine(PurchParmLine _purchParmLine)
    {
        return isCountryRegion_RU
            && TaxParameters::find().TaxSpecifyLine
            && _purchParmLine.PreviousReceiveNow != _purchParmLine.ReceiveNow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    protected boolean check()
    {
        boolean     ret;
        ChargesArgs args = new ChargesArgs();

        // Raise event beforePostDocument, and retreive return value
        this.beforePostDocument(purchParmTable, args);
        ret = args.getReturnValue();

        if (ret)
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDiscardLine</Name>
				<Source><![CDATA[
    protected boolean checkDiscardLine(Common _purchParmLine)
    {
        #ISOcountryRegionCodes
        PurchParmLine purchParmLine;
        if (isCountryRegion_RU)
        {
            purchParmLine = _purchParmLine;
            if (purchParmLine.DeviationQty_RU != purchParmLine.PreviousDeviationQty)
            {
                return false;
            }
        }

        return super(_purchParmLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkGRNAcceptedQuantity_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks GRN accepted quantity.
    /// </summary>
    /// <returns>
    /// Returns true if the GRN accepted quantity checked succeed.
    /// </returns>
    // If purchase order contains more than one line and for any of the lines
    // Accepted quantity is entered then GRN report needs to be printed even though the
    // Print Goods receipt note check box is not marked. Called from this.allocateGRNNumber_IN method
    protected boolean checkGRNAcceptedQuantity_IN()
    {
        PurchParmLine purchParmLineLoc;
        PurchParmLine_IN purchParmLine_IN;
        boolean       ret;

        select AcceptedQty from purchParmLine_IN
            exists join purchParmLineLoc
            where purchParmLine_IN.PurchParmLine == purchParmLineLoc.RecId
               && purchParmLineLoc.ParmId         == purchParmTable.ParmId
               && purchParmLineLoc.TableRefId     == purchParmTable.TableRefId
               && purchParmLine_IN.AcceptedQty > 0;
        if (purchParmLine_IN)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the journal can be created.
    /// </summary>
    /// <returns>
    /// true if journal can be created; otherwise, false.
    /// </returns>
    public boolean checkJournal()
    {
        return super()
            && this.checkLedgerPeriod()
            && purchParmTable.vendTable_InvoiceAccount().checkPackingSlip(purchParmTable.Num,purchParmTable.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalLine</Name>
				<Source><![CDATA[
    public void checkJournalLine(Common _journalLine, Common _parmLine)
    {
        VendPackingSlipTrans vendPackingSlipTrans = _journalLine as VendPackingSlipTrans;
        PurchParmLine purchParmLine = _parmLine as PurchParmLine;
        Qty purchQuantityMatched, inventQuantityMatched;
        PdsCWInventQty cwQuantityMatched;

        [purchQuantityMatched, inventQuantityMatched
            , cwQuantityMatched
            ] = VendInvoicePackingSlipQuantityMatch::purchInventoryQuantityMatched(vendPackingSlipTrans.SourceDocumentLine);

        if (purchQuantityMatched)
        {
            if (abs(vendPackingSlipTrans.Qty) < abs(purchQuantityMatched)
                || abs(vendPackingSlipTrans.InventQty) < abs(inventQuantityMatched)
                || abs(vendPackingSlipTrans.PdsCWQty) < abs(cwQuantityMatched)
                )
            {
                // You cannot correct the packing slip below quantity matched by invoice.
                throw error("@SYS324493");
            }
        }

        if (VendInvoiceInfoSubLine::existsUnpostedForPackingSlip(vendPackingSlipTrans.TableId, vendPackingSlipTrans.RecId))
        {
            // One or more vendor invoices are pending for this product receipt.
            throw error("@AccountsPayable:PendingInvoiceExistsForProductReceipt");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedgerPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether posting in the ledger period is allowed.
    /// </summary>
    /// <returns>
    ///    true if posting in the ledger period is allowed; otherwise, false.
    /// </returns>
    protected boolean checkLedgerPeriod()
    {
        boolean ok = true;
        RecId calendarRecId = CompanyInfoHelper::fiscalCalendarRecId();

        if (vendParameters.PostPackingSlip)
        {
            ok = LedgerFiscalCalendar::checkLedgerPeriodDateModule(calendarRecId,this.updateDate(),SysModule::Purch);
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalLine</Name>
				<Source><![CDATA[
    protected void createJournalLine(Common _purchParmLine)
    {
        PurchParmLine purchParmLine = _purchParmLine as PurchParmLine;
        InventQualityManagementBlockHandler::blockPurchaseProductReceipt(purchParmLine.purchLine());
        super(_purchParmLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalLinesHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates journal line history records for all lines.
    /// </summary>
    protected void createJournalLinesHistory()
    {
        VendPackingSlipTransHistory vendPackingSlipTransHistory;
        VendPackingSlipTransHistory previousVendPackingSlipTransHistory;
        VendPackingSlipTrans        vendPackingSlipTrans;
        VersioningTimeStamp         validFrom, validTo;

        validFrom = VendPackingSlipVersion::findLatest(vendPackingSlipJour.RecId).VersionDateTime;
        validTo = DateTimeUtil::maxValue();

        if (VendPackingSlipVersion::numberOfPackingSlipVersions(vendPackingSlipJour.RecId) > 1)
        {
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                insert_recordset vendPackingSlipTransHistory(VendPackingSlipTrans, ValidFrom, ValidTo, Qty, InventQty, Remain, RemainInvent, Weight, ValueMST, ReasonTableRef,
                    PdsCWQty, PdsCWRemain,
                    ExciseValue, VATValue, ExciseAmount, VATAmount, LineAmount, TaxAmount, DeviationQty
                    )
                select
                    RecId, validFrom, validTo, Qty, InventQty, Remain, RemainInvent, Weight, ValueMST, ReasonTableRef,
                    PdsCWQty, PdsCWRemain,
                    ExciseValue_RU, VatValue_RU, ExciseAmount_RU, vatAmount_RU, LineAmount_W, TaxAmount_RU, DeviationQty_RU
                    from vendPackingSlipTrans
                    where vendPackingSlipTrans.VendPackingSlipJour == vendPackingSlipJour.RecId
                notexists join previousVendPackingSlipTransHistory
                    where previousVendPackingSlipTransHistory.VendPackingSlipTrans == vendPackingSlipTrans.RecId
                       && previousVendPackingSlipTransHistory.Qty == vendPackingSlipTrans.Qty
                       && previousVendPackingSlipTransHistory.PdsCWQty == vendPackingSlipTrans.PdsCWQty;
            }
            else
            {
                insert_recordset vendPackingSlipTransHistory(VendPackingSlipTrans, ValidFrom, ValidTo, Qty, InventQty, Remain, RemainInvent, Weight, ValueMST, ReasonTableRef,
                    PdsCWQty, PdsCWRemain, LineAmount
                    )
                select RecId, validFrom, validTo, Qty, InventQty, Remain, RemainInvent, Weight, ValueMST, ReasonTableRef,
                    PdsCWQty, PdsCWRemain, LineAmount_W
                    from vendPackingSlipTrans
                    where vendPackingSlipTrans.VendPackingSlipJour == vendPackingSlipJour.RecId
                notexists join previousVendPackingSlipTransHistory
                    where previousVendPackingSlipTransHistory.VendPackingSlipTrans == vendPackingSlipTrans.RecId
                       && previousVendPackingSlipTransHistory.Qty == vendPackingSlipTrans.Qty
                       && previousVendPackingSlipTransHistory.PdsCWQty == vendPackingSlipTrans.PdsCWQty;
            }
        }
        else
        {
            if (isCountryRegion_RU)
            {
                insert_recordset vendPackingSlipTransHistory(VendPackingSlipTrans, ValidFrom, ValidTo, Qty, InventQty, Remain, RemainInvent, Weight, ValueMST, ReasonTableRef,
                    PdsCWQty, PdsCWRemain,
                    ExciseValue, VATValue, ExciseAmount, VATAmount, LineAmount, TaxAmount, DeviationQty
                    )
                select RecId, validFrom, validTo, Qty, InventQty, Remain, RemainInvent, Weight, ValueMST, ReasonTableRef,
                    PdsCWQty, PdsCWRemain,
                    ExciseValue_RU, VatValue_RU, ExciseAmount_RU, vatAmount_RU, LineAmount_W, TaxAmount_RU, DeviationQty_RU
                    from vendPackingSlipTrans
                    where vendPackingSlipTrans.VendPackingSlipJour == vendPackingSlipJour.RecId;
            }
            else
            {
                insert_recordset vendPackingSlipTransHistory(VendPackingSlipTrans, ValidFrom, ValidTo, Qty, InventQty, Remain, RemainInvent, Weight, ValueMST, ReasonTableRef,
                    PdsCWQty, PdsCWRemain, LineAmount
                    )
                select RecId, validFrom, validTo, Qty, InventQty, Remain, RemainInvent, Weight, ValueMST, ReasonTableRef,
                    PdsCWQty, PdsCWRemain, LineAmount_W
                    from vendPackingSlipTrans
                    where vendPackingSlipTrans.VendPackingSlipJour == vendPackingSlipJour.RecId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the packing slip version.
    /// </summary>
    protected void createJournalVersion()
    {
        FormLetterContract purchFormLetterContract = this.parmInterCompanyFormletterContract();
        [journalNumber, internalNumber, voucher] = this.getNumAndVoucher();

        vendPackingSlipVersion.clear();
        vendPackingSlipVersion.initValue();
        vendPackingSlipVersion.initFromPurchTotals(purchTotals);
        vendPackingSlipVersion.VendPackingSlipJour = vendPackingSlipJour.RecId;

        vendPackingSlipVersion.ParmId           = purchParmUpdate.ParmId;
        vendPackingSlipVersion.VersionDateTime  = (purchFormLetterContract && purchFormLetterContract.parmVersionDateTime()) ?
                                                  purchFormLetterContract.parmVersionDateTime() : DateTimeUtil::utcNow();
        purchFormLetterContract.parmVersionDateTime(vendPackingSlipVersion.VersionDateTime);
        vendPackingSlipVersion.AccountingDate   = this.updateDate();

        vendPackingSlipVersion.LedgerVoucher                = voucher;
        vendPackingSlipVersion.InternalPackingSlipId        = internalNumber;
        vendPackingSlipVersion.InterCompanyLedgerVoucher    = this.parmInterCompanyVoucher();
        vendPackingSlipVersion.CostLedgerVoucher            = this.getCostLedgerVoucher();
        vendPackingSlipVersion.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>endCreate</Name>
				<Source><![CDATA[
    #ISOCountryRegionCodes
    protected void endCreate()
    {
        // <GIN>
        VendPackingSlipTrans vendPackingSlipTransLocal;
        TaxParameters taxParameters;
        TaxTransReversal_IN taxTransReversal;
        VendPackingSlipJourRecId vendPackingSlipJourRecId;
        VendPackingSlipVersion  vendPackingSlipVersionLocal;
        PurchParmTable          purchParmTableCopy = this.parmParmTable();
        PurchTable              purchTableCopy = this.sourceTable();
        PurchParmUpdate         purchParmUpdateCopy = this.parmParmUpdate();
        boolean                 isCustomsMarked = TaxParameters::isCustomsEnable_IN();

        #LocalMacro.VendPackingSlipTransFieldList
        PackingSlipId,
        OrigPurchid,
        DeliveryDate,
        InventTransId,
        recId
        #EndMacro
        // </GIN>

        super();

        if (isCountryRegion_RU)
        {
            PrintoutTableReports_RU::createSlipM4M7(vendPackingSlipJour, this);

            if (this.parmReceiptListDeviationType_RU() == ReceiptListDeviationType_RU::ReceiptListForGoodsTORG2 ||
                this.parmReceiptListDeviationType_RU() == ReceiptListDeviationType_RU::ReceiptListForGoodsTORG3)
            {
                this.parmReceiptListDeviationType_RU(ReceiptListDeviationType_RU::ReceiptListForGoodsTORG1);
                PrintoutTableReports_RU::createSlipM4M7(vendPackingSlipJour, this);
                this.parmReceiptListDeviationType_RU(vendPackingSlipJour.ReceiptListDeviationType_RU);
            }
        }

        // <GIN>
        if (isCountryRegion_IN)
        {
            taxParameters  = TaxParameters::find();

            if (taxParameters.Excise_IN
                && ( taxParameters.VendorCalculationDateType_IN == VendorCalculationDateType_IN::DeliveryDate
                || taxParameters.VendorCalculationDateType_IN == VendorCalculationDateType_IN::DocumentDate))
            {
                vendPackingSlipJourRecId = this.getJournal().RecId;

                select firstonly RecId, AccountingDate, LedgerVoucher from vendPackingSlipVersionLocal
                    order by vendPackingSlipVersionLocal.VersionDateTime desc
                    where vendPackingSlipVersionLocal.VendPackingSlipJour == vendPackingSlipJourRecId
                        && vendPackingSlipVersion.RecId != vendPackingSlipVersionLocal.RecId;

                if  (vendPackingSlipVersionLocal.RecId != 0)
                {
                    taxTransReversal = new TaxTransReversal_IN();
                    taxTransReversal.init();
                    taxTransReversal.reverseExciseRegistration(
                        vendPackingSlipVersionLocal.AccountingDate,
                        vendPackingSlipVersionLocal.LedgerVoucher,
                        vendPackingSlipVersion.AccountingDate,
                        vendPackingSlipVersion.LedgerVoucher);
                }

                journalTmpTaxWorkTrans = this.parmTax().tmpTaxWorkTrans();

                if (vendPackingSlipVersion.Qty != 0)
                {
                    while select vendPackingSlipTransLocal
                        where vendPackingSlipTransLocal.VendPackingSlipJour == vendPackingSlipJourRecId
                    {
                        this.updateExciseRegister_IN(vendPackingSlipTransLocal);
                    }
                }
            }
        }
        // </GIN>

        if (TaxIntegrationUtils::isTransitDocumentEnabled())
        {
            this.transitDocument();
        }

        //<GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            TaxBusinessService::transferTaxDocument(purchParmTable, vendPackingSlipJour);
        }
        //</GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>findJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds an existing journal line based on a parameter line.
    /// </summary>
    /// <param name="_parmLine">
    /// The parameter line on which to find based.
    /// </param>
    /// <returns>
    /// The journal line.
    /// </returns>
    public Common findJournalLine(Common _parmLine)
    {
        VendPackingSlipTrans vendPackingSlipTrans;
        PurchParmLine purchParmLine = _parmLine as PurchParmLine;
        boolean       cancelPackingSlip = false;

        if (documentStatus == DocumentStatus::PackingSlip
        &&  interCompanyFormletterContract.parmVersioningUpdateType() == VersioningUpdateType::Cancel)
        {
            cancelPackingSlip = true;
        }
        if (PurchPackingSlipCorrectionConsiderMultipleBOE_INFlight::instance().isEnabled()
            && TaxParameters::isCustomsEnable_IN()
            && VendDocumentLineMap::isTransactionRelatedToBOE_IN(purchParmLine.purchLine().purchTable(), purchParmLine.purchParmUpdate())
            && formLetterJournalCreateVersioning is FormLetterJournalCreateCorrection)
        {
            CustomsVendPackingSlipBOETransLink_IN customsVendPackingSlipBOETransLink;
            CustomsVendBOETrans_IN customsVendBOETransIN = PurchParmLineVendDocumentLine::getCustomsVendBOETrans_IN(purchParmLine.RecId, purchParmLine.ParmId);

            select firstonly forupdate vendPackingSlipTrans
                where vendPackingSlipTrans.VendPackingSlipJour == vendPackingSlipJour.RecId
                    && vendPackingSlipTrans.InventTransId == purchParmLine.InventTransId
                    && vendPackingSlipTrans.InventDimId         == purchParmLine.InventDimId
                    && (!cancelPackingSlip
                       || (cancelPackingSlip
                           && vendPackingSlipTrans.InventQty  == purchParmLine.PreviousInventNow
                           && vendPackingSlipTrans.Qty        == purchParmLine.PreviousReceiveNow))
                exists join CustomsVendBOETrans_IN, VendPackingSlipTrans from customsVendPackingSlipBOETransLink
                    where vendPackingSlipTrans.RecId == customsVendPackingSlipBOETransLink.VendPackingSlipTrans
                        && customsVendPackingSlipBOETransLink.CustomsVendBOETrans_IN == customsVendBOETransIN.RecId;

            // Pruchase line without tracking dimension is registered with tracking dimensions, and product receipt is posted from purchase order.
            // VendPackingSlipTrans has no tracking dimensions.
            // Corrects the product receipt journal with tracking dimensions, then InventDimId of PurchParmLine has tracking dimensions.
            // VendPackingSlipTrans is not found in the above selection, so it is needed to select VendPackingSlipTrans without inventory dimension again.
            if (!vendPackingSlipTrans)
            {
                select firstonly forupdate vendPackingSlipTrans
                where vendPackingSlipTrans.VendPackingSlipJour == vendPackingSlipJour.RecId
                    && vendPackingSlipTrans.InventTransId == purchParmLine.InventTransId
                    && (!cancelPackingSlip
                       || (cancelPackingSlip
                           && vendPackingSlipTrans.InventQty  == purchParmLine.PreviousInventNow
                           && vendPackingSlipTrans.Qty        == purchParmLine.PreviousReceiveNow))
                exists join CustomsVendBOETrans_IN, VendPackingSlipTrans from customsVendPackingSlipBOETransLink
                    where vendPackingSlipTrans.RecId == customsVendPackingSlipBOETransLink.VendPackingSlipTrans
                        && customsVendPackingSlipBOETransLink.CustomsVendBOETrans_IN == customsVendBOETransIN.RecId;
            }

        }
        else
        {
            select firstonly forupdate vendPackingSlipTrans
            where vendPackingSlipTrans.VendPackingSlipJour == vendPackingSlipJour.RecId
               && vendPackingSlipTrans.InventTransId       == purchParmLine.InventTransId
               && vendPackingSlipTrans.InventDimId         == purchParmLine.InventDimId
               && (!cancelPackingSlip
                   || (cancelPackingSlip
                       && vendPackingSlipTrans.InventQty  == purchParmLine.PreviousInventNow
                       && vendPackingSlipTrans.Qty        == purchParmLine.PreviousReceiveNow));

            // Pruchase line without tracking dimension is registered with tracking dimensions, and product receipt is posted from purchase order.
            // VendPackingSlipTrans has no tracking dimensions.
            // Corrects the product receipt journal with tracking dimensions, then InventDimId of PurchParmLine has tracking dimensions.
            // VendPackingSlipTrans is not found in the above selection, so it is needed to select VendPackingSlipTrans without inventory dimension again.
            if (!vendPackingSlipTrans)
            {
                select firstonly forupdate vendPackingSlipTrans
                where vendPackingSlipTrans.VendPackingSlipJour == vendPackingSlipJour.RecId
                   && vendPackingSlipTrans.InventTransId       == purchParmLine.InventTransId
                   && (!cancelPackingSlip
                       || (cancelPackingSlip
                           && vendPackingSlipTrans.InventQty  == purchParmLine.PreviousInventNow
                           && vendPackingSlipTrans.Qty        == purchParmLine.PreviousReceiveNow));
            }
        }

        return vendPackingSlipTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formletterType</Name>
				<Source><![CDATA[
    protected FormletterType formletterType()
    {
        return FormletterType::Purchase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCatchWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight registered quantity for the specified line.
    /// </summary>
    /// <param name="_localPurchParmLine">
    /// The line being processed.
    /// </param>
    /// <param name="_inventMovement">
    /// The inventory movement related to the line.
    /// </param>
    /// <param name="_vendPackingSlipTrans">
    /// The product slip line being generated.
    /// </param>
    /// <returns>
    /// The weight for the catch weight quantity.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Insufficient inventory transactions with status Registered.
    /// </exception>
    protected InventQty getCatchWeight(
        PurchParmLine               _localPurchParmLine,
        InventMov_Purch             _inventMovement,
        VendPackingSlipTrans        _vendPackingSlipTrans)
    {
        PdsCWInventQty                      cwQtyNotAssigned = _localPurchParmLine.PdsCWReceiveNow;
        InventQty                           qtyAssigned;
        PdsCatchWeightMovementQtyAdjustment pdsCatchWeightMovementQtyAdjustment;

        pdsCatchWeightMovementQtyAdjustment = PdsCatchWeightMovementQtyAdjustment::newPurchPackingSlip(
            _inventMovement,
            _vendPackingSlipTrans);

        // check if related WMSJournalTrans exist, if so use InventDimId from parm line instead.
        WMSJournalTrans wmsJournalTrans = WMSJournalTrans::findInventTransIdTransType(_inventMovement.transId(), InventTransType::Purch);
        using (InventCWPostWithInventDimPhysicalMatchContext context = InventCWPostWithInventDimPhysicalMatchContext::construct())
        {
            if (wmsJournalTrans.RecId && wmsJournalTrans.wmsJournalTable().posted)
            {
                InventDimId inventDimPhysical = _localPurchParmLine.InventDimId;

                if (inventDimPhysical != _inventMovement.inventDimId())
                {
                    pdsCatchWeightMovementQtyAdjustment.parmInventDimCriteria(InventDim::find(inventDimPhysical));
                    InventDimParm inventDimParm;
                    inventDimParm.initPhysicalDimensionsFromInventDim(
                        InventDimGroupSetup::newItemId(_inventMovement.itemId()),
                        pdsCatchWeightMovementQtyAdjustment.parmInventDimCriteria());
                    pdsCatchWeightMovementQtyAdjustment.parmInventDimParm(inventDimParm);
                    pdsCatchWeightMovementQtyAdjustment.parmInventDimPhysicalMatched(inventDimPhysical);
                    context.parmConsiderInventDimPhysicalMatched(true);
                }
            }

            qtyAssigned = pdsCatchWeightMovementQtyAdjustment.purchReceiptQty(
                DocumentStatus::PackingSlip,
                cwQtyNotAssigned);
        }

        if (!pdsCatchWeightMovementQtyAdjustment.isFullCatchWeightQuantityAssigned()
            && !purchTable.isDropShipment())
        {
            warning("@SCM:ItemCatchWeightQuantityNotAssignedAndNotDropShipment");
            Info("@SCM:InventOrderRegisterGeneralGuide");
            throw error(strFmt("@SYS54028", StatusReceipt::Registered));
        }
        return qtyAssigned;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCostLedgerVoucher</Name>
				<Source><![CDATA[
    protected Voucher getCostLedgerVoucher()
    {
        if (SourceDocumentCompletionRule::useSingleVoucher())
        {
            return voucher;
        }
        else
        {
            return NumberSeq::newGetVoucher(NumberSeqReference::findReference(extendedTypeNum(InventPurchReceiptVoucher))).voucher();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournal</Name>
				<Source><![CDATA[
    public Common getJournal()
    {
        return vendPackingSlipJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumAndVoucher</Name>
				<Source><![CDATA[
    protected container getNumAndVoucher()
    {
        container numAndVoucher;

        if (!this.proforma() && journalNumber == '')
        {
            numberSeq     = this.allocateNumAndVoucher();
            if (numberSeq)
            {
                if (useInternalNumber)
                {
                    numAndVoucher = numberSeq.numAndVoucher();
                    numAndVoucher = [internalNumber, conPeek(numAndVoucher,1), conPeek(numAndVoucher,2)];
                }
                else
                {
                    numAndVoucher = [internalNumber, '', numberSeq.voucher()];
                }
            }
        }

        return numAndVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleExciseQuantityRegister_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The excise quantity register handler.
    /// </summary>
    /// <param name="_taxModelExciseTaxable">
    /// The tax model excise taxable information.
    /// </param>
    protected void handleExciseQuantityRegister_IN(TaxModelExciseTaxable_IN _taxModelExciseTaxable)
    {
        TaxExciseQuantityRegister_IN            register;
        TaxTransExtensionRGQuantityHandler_IN   rgQuantityHandler;
        TaxTrans_IN taxTransIN;

        if (_taxModelExciseTaxable)
        {
            if (_taxModelExciseTaxable.getExciseRecordType() != ExciseRecordType_IN::None)
            {
                register = TaxExciseRegisterFacade_IN::updatePartIRegister(_taxModelExciseTaxable);
            }

            if (register.RecId != 0)
            {
                rgQuantityHandler = new TaxTransExtensionRGQuantityHandler_IN();
                rgQuantityHandler.setExciseRegister(register);
                rgQuantityHandler.setTaxModelTaxable(_taxModelExciseTaxable as TaxModelTaxable_IN);
                rgQuantityHandler.init();
                rgQuantityHandler.setData();
                taxTransIN = rgQuantityHandler.post();

                register.selectForUpdate(true);
                register.TaxTrans_IN = taxTransIN.RecId;
                register.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    protected void init()
    {
        accountingDate = purchParmTable.TransDate;
        vendParameters = VendParameters::find();
        isCountryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        isCountryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCatchWeightValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts inventory quantities for catch weight items which have been registered.
    /// </summary>
    protected void initCatchWeightValues()
    {
        PurchParmLine               localPurchParmLine;
        PurchLine                   localPurchLine;
        InventTransOrigin           inventTransOrigin;
        InventTableModule           inventTableModuleInvent;
        InventQty                   qtyAssigned;
        InventQty                   inventQtyDelta;
        SalesQty                    purchQtyDelta;
        InventMov_Purch             inventMovement;
        VendPackingSlipTrans        vendPackingSlipTrans;

        if (!#pdsCatchWeightEnabled)
        { // catch weight not enabled, so no need to try to select
            return;
        }

        while select forupdate localPurchParmLine
            where localPurchParmLine.ParmId     == purchParmUpdate.ParmId
               && localPurchParmLine.TableRefId == purchParmTable.TableRefId
               && localPurchParmLine.PdsCWReceiveNow            > 0        // only select lines with catch weight being reveived
            join RecId from inventTransOrigin
                where inventTransOrigin.InventTransId           == localPurchParmLine.InventTransId
            join UnitId from inventTableModuleInvent
                where inventTableModuleInvent.ItemId            == localPurchParmLine.ItemId
                  &&  inventTableModuleInvent.ModuleType        == ModuleInventPurchSales::Invent
        {
            if (!this.checkDiscardLine(localPurchParmLine))
            {
                setPrefix(localPurchParmLine.FormletterJournalTrans::getLinePrefix());

                localPurchLine = localPurchParmLine.purchLine(true);
                inventMovement = InventMov_Purch::newFromPurchLine(localPurchLine);
                vendPackingSlipTrans = this.initJournalLine(localPurchParmLine);

                // Find the catch weight from the transactions
                qtyAssigned = this.getCatchWeight(localPurchParmLine, inventMovement, vendPackingSlipTrans);

                if (qtyAssigned > 0
                 && localPurchParmLine.InventNow != qtyAssigned)
                { // Update purchParmLine with new values for weight
                    inventQtyDelta = qtyAssigned - localPurchParmLine.InventNow;
                    localPurchLine = localPurchParmLine.purchLine();
                    if (localPurchLine.PurchUnit == inventTableModuleInvent.UnitId)
                    { // Same unit so update purch qty related field too
                        purchQtyDelta = inventQtyDelta;
                        localPurchParmLine.ReceiveNow += purchQtyDelta;
                        localPurchParmLine.RemainBefore = localPurchLine.RemainPurchPhysical;
                        if (localPurchParmLine.PdsCWRemainAfterInvent == 0)
                        {
                            localPurchParmLine.RemainAfter = 0;
                        }
                        else
                        {
                            localPurchParmLine.RemainAfter -= purchQtyDelta;
                        }
                    }
                    else if (UnitOfMeasure::findBySymbol(localPurchLine.PurchUnit).UnitOfMeasureClass
                          == UnitOfMeasure::findBySymbol(inventTableModuleInvent.UnitId).UnitOfMeasureClass)
                    { // Same unit class so update purch qty related field too, but convert to proper unit
                        purchQtyDelta = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(
                                            localPurchLine.ItemId,
                                            localPurchLine.InventDimId,
                                            qtyAssigned,
                                            inventTableModuleInvent.UnitId,
                                            localPurchLine.PurchUnit,
                                            NoYes::No) - localPurchParmLine.ReceiveNow;

                        localPurchParmLine.ReceiveNow += purchQtyDelta;
                        localPurchParmLine.RemainBefore = localPurchLine.RemainPurchPhysical;
                        if (localPurchParmLine.PdsCWRemainAfterInvent == 0)
                        {
                            localPurchParmLine.RemainAfter = 0;
                        }
                        else
                        {
                            localPurchParmLine.RemainAfter -= purchQtyDelta;
                        }
                    }
                    localPurchParmLine.InventNow += inventQtyDelta;
                    localPurchParmLine.RemainBeforeInvent = localPurchLine.RemainInventPhysical;
                    if (localPurchParmLine.PdsCWRemainAfterInvent == 0)
                    {
                        localPurchParmLine.RemainAfterInvent = 0;
                    }
                    else
                    {
                        localPurchParmLine.RemainAfterInvent -= inventQtyDelta;
                    }
                    localPurchParmLine.update();
                    recordListPurchParmLine = null;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes non-correctable fields on the journal header.
    /// </summary>
    public void initHeader()
    {
        vendPackingSlipJour.clear();
        vendPackingSlipJour.initValue();

        vendPackingSlipJour.PackingSlipId = purchParmTable.Num;
        vendPackingSlipJour.DeliveryDate = purchParmTable.TransDate;
        vendPackingSlipJour.initFromPurchTable(purchTable);
        vendPackingSlipJour.InterCompanyPosted = this.parmInterCompanyPosted();
        vendPackingSlipJour.DocumentDate = purchParmTable.DocumentDate;
        vendPackingSlipJour.BankLCImportLine = purchParmTable.BankLCImportLine;

        if (isCountryRegion_IN && TaxParameters::checkTaxParameters_IN())
        {
            vendPackingSlipJour.grnNumber_IN = this.allocateGRNNumber_IN();
        }

        if (isCountryRegion_RU)
        {
            vendPackingSlipJour.InventProfileType_RU        = purchParmTable.InventProfileType_RU;
        }
        this.setDeliveryFields();

        vendPackingSlipJour.InvoiceIssueDueDate_W = LedgerInvoiceIssueDueDateSetup_W::findPostalAddressIssueDate(vendPackingSlipJour.vendTable_OrderAccount().postalAddress(),
                                                                                                            vendPackingSlipJour.DeliveryDate).getInvoiceIssueDueDate(vendPackingSlipJour.DeliveryDate);
        if (Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Purchase))
        {
            TaxTransactionTaxIDHelper::saveTaxIdToCustVendJour(this.parmTax(), vendPackingSlipJour);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initJournalLine</Name>
				<Source><![CDATA[
    public Common initJournalLine(Common _parmLine)
    {
        VendPackingSlipTrans    vendPackingSlipTrans;
        PurchParmLine           purchParmLine       = _parmLine as PurchParmLine;
        PurchLine               purchLine           = purchParmLine.purchLine();
        PurchTable              purchTableCopy      = this.sourceTable();
        PurchParmUpdate         purchParmUpdateCopy = this.parmParmUpdate();
        PurchParmSubLine        purchParmSubLine;
        CustomsVendBOETrans_IN  customsVendBOETrans;
        CustomsVendPackingSlipBOETransLink_IN customsVendPackingSlipBOETransLink;
        // <GIN>
        VendPackingSlipTrans_IN     vendPackingSlipTransIN;
        PurchParmLine_IN           purchParmLineIN;
        // </GIN>

        vendPackingSlipTrans.initFromPurchLine(purchLine);
        vendPackingSlipTrans.initFromPurchParmTable(purchParmTable);
        vendPackingSlipTrans.initFromVendPackingSlipJour(vendPackingSlipJour);
        vendPackingSlipTrans.InventDimId = purchParmLine.InventDimId;
        vendPackingSlipTrans.setLinenum(this.getLineNum());
        vendPackingSlipTrans.CostLedgerVoucher  = vendPackingSlipVersion.CostLedgerVoucher;
        vendPackingSlipTrans.AccountingDate     = vendPackingSlipVersion.AccountingDate;

        if (purchLine.isCategoryBased())
        {
            vendPackingSlipTrans.initFrompurchLineForeignTradeCategory(PurchLineForeignTradeCategory::findpurchLine(purchLine));
        }

        // <GIN>
        if (isCountryRegion_IN)
        {
            if (TaxParameters::checkTaxParameters_IN())
            {
                purchParmLineIN = purchParmLine.purchParmLine_IN();
                vendPackingSlipTrans.ReceivedQty_IN = purchParmLineIN.ReceivedQty;
                vendPackingSlipTrans.AcceptedQty_IN = purchParmLineIN.AcceptedQty;
                vendPackingSlipTrans.RejectedQty_IN = purchParmLineIN.RejectedQty;
            }
            // create link between boe trans and packing slip trans
            if (TaxParameters::isCustomsEnable_IN()
                && VendDocumentLineMap::isTransactionRelatedToBOE_IN(purchTableCopy, purchParmUpdateCopy))
            {
                ttsbegin;
                select firstonly LineRefRecId, JournalRefRecId, JournalRefTableId from purchParmSubLine
                    where purchParmSubLine.LineRefRecId == purchParmLine.RecId
                    join RecId from customsVendBOETrans
                        where purchParmSubLine.JournalRefRecId   == customsVendBOETrans.RecId
                           && purchParmSubLine.JournalRefTableId == customsVendBOETrans.TableId
                           && customsVendBOETrans.Status         != CustomsVendBOEStatus_IN::Canceled;
                if (purchParmSubLine)
                {
                    customsVendPackingSlipBOETransLink.clear();
                    customsVendPackingSlipBOETransLink.CustomsVendBOETrans_IN = customsVendBOETrans.RecId;
                    customsVendPackingSlipBOETransLink.PackingSlipId          = vendPackingSlipTrans.PackingSlipId;
                    customsVendPackingSlipBOETransLink.PurchTable             = vendPackingSlipTrans.OrigPurchid;
                    customsVendPackingSlipBOETransLink.VendTable              = purchParmTable.OrderAccount;
                    customsVendPackingSlipBOETransLink.DeliveryDate           = vendPackingSlipTrans.DeliveryDate;
                    vendPackingSlipTrans.SysExtensionSerializerMap::packExtensionTable(customsVendPackingSlipBOETransLink);
                }
                ttscommit;
            }

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]) && purchParmLine.purchParmLine_IN().InventSiteGateEntryLine)
            {
                vendPackingSlipTransIN = vendPackingSlipTrans.vendPackingSlipTrans_IN();
                vendPackingSlipTransIN.InventSiteGateEntryLine = purchParmLine.purchParmLine_IN().InventSiteGateEntryLine;
                vendPackingSlipTrans.packVendPackingSlipTrans_IN(vendPackingSlipTransIN);
            }
        }
        // </GIN>
        return vendPackingSlipTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initJournalLink</Name>
				<Source><![CDATA[
    public Common initJournalLink(Common _parmLine)
    {
        VendPackingSlipPurchLink    vendPackingSlipPurchLink;

        vendPackingSlipPurchLink.initFromPurchParmLine      (_parmLine as PurchParmLine);
        vendPackingSlipPurchLink.initFromVendPackingSlipJour(vendPackingSlipJour);
        return vendPackingSlipPurchLink;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSourceTable</Name>
				<Source><![CDATA[
    protected void initSourceTable()
    {
        if (vendPackingSlipJour.RecId)
        {
            if (InterCompanyVendPackingSlipJourCheckFlight::instance().isEnabled()
                && vendPackingSlipJour.isIntercompanyOrder()
                && vendPackingSlipJour.PurchId != purchParmTable.purchTable().PurchId)
            {
                VendPackingSlipJour localVendPackingSlipJour;
                select forupdate firstonly localVendPackingSlipJour
                    where localVendPackingSlipJour.PurchId == purchParmTable.purchTable().PurchId
                        && localVendPackingSlipJour.PackingSlipId == vendPackingSlipJour.PackingSlipId;
               
                if (localVendPackingSlipJour)
                {
                    vendPackingSlipJour = localVendPackingSlipJour;
                }
            }
            purchTable = vendPackingSlipJour.purchTable();
        }
        else
        {
            purchTable = purchParmTable.purchTable();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTotals</Name>
				<Source><![CDATA[
    protected void initTotals()
    {
        this.initCatchWeightValues();
        purchTotals = PurchTotals::newParmTable(purchParmTable, purchParmUpdate.SpecQty, purchParmUpdate.ParmId, purchParmUpdate.SumPurchId, DocumentStatus::PackingSlip);
        purchTotals.calc();
        this.parmTax(purchTotals.tax());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isJournalCreated</Name>
				<Source><![CDATA[
    protected boolean isJournalCreated()
    {
        return super() || isJournalHeaderChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalLineTableId</Name>
				<Source><![CDATA[
    protected TableId journalLineTableId()
    {
        return tableNum(VendPackingSlipTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>linksTableId</Name>
				<Source><![CDATA[
    protected TableId linksTableId()
    {
        return tableNum(VendPackingSlipPurchLink);
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSequenceReferenceNum</Name>
				<Source><![CDATA[
    protected NumberSequenceReference numberSequenceReferenceNum()
    {
        return PurchParameters::numRefPurchPackingSlipId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSequenceReferenceVoucher</Name>
				<Source><![CDATA[
    protected NumberSequenceReference numberSequenceReferenceVoucher()
    {
        return PurchParameters::numRefPurchPackingSlipVoucher();
    }

]]></Source>
			</Method>
			<Method>
				<Name>packingSlipNumber_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds packing slip number sequence per warehouse
    /// </summary>
    /// <returns>
    /// Packing slip number sequence per warehouse
    /// </returns>
    public RefRecId packingSlipNumber_PL()
    {
        NumberSequenceCode newNumber;

        // Covers context validation
        if (PurchParameters::find().PackingSlipByInvent_PL)
        {
            if (purchTable.NumberSequenceGroup)
            {
                newNumber = PlNumberSequenceGroupInvent::packingSlip(
                    this.parmInventLocationId_PL(),
                    NumberSequenceDatatype::find(PurchParameters::numRefPurchPackingSlipId().NumberSequenceDatatype).DatatypeId,
                    purchTable.NumberSequenceGroup);
            }

            if (! newNumber)
            {
                newNumber = PlNumberSequenceGroupInvent::packingSlip(
                    this.parmInventLocationId_PL(),
                    NumberSequenceDatatype::find(PurchParameters::numRefPurchPackingSlipId().NumberSequenceDatatype).DatatypeId);
            }
        }

        return newNumber ? NumberSequenceTable::findByNaturalKey(newNumber).RecId : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packingSlipNumber_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to get the Numbering code selected by the user when Purchase packing slip autonumbering is true.
    /// </summary>
    /// <returns>
    /// NumberSequenceCode from the LtInvoiceAutoNumberingTable record that matches the Numbering code selected by the user.
    /// </returns>
    public NumberSequenceCode packingSlipNumber_W()
    {
        NumberSequenceCode newNumber;

        if (purchParmTable.DocAutoNumbering_LT == NoYes::Yes)
        {
            newNumber = LtInvoiceAutoNumberingTable::find(ltDocNumberingCode).NumberSequenceCode;
        }

        return newNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyVoucher</Name>
				<Source><![CDATA[
    InterCompanyVoucher  parmInterCompanyVoucher(InterCompanyVoucher  _interCompanyVoucher = interCompanyVoucher)
    {
        interCompanyVoucher = _interCompanyVoucher;
        return interCompanyVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmTable</Name>
				<Source><![CDATA[
    public Common parmParmTable(Common _parmTable = purchParmTable)
    {
        purchParmTable = _parmTable as PurchParmTable;

        return purchParmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmUpdate</Name>
				<Source><![CDATA[
    public Common parmParmUpdate(Common _parmUpdate = purchParmUpdate)
    {
        purchParmUpdate = _parmUpdate as PurchParmUpdate;

        return purchParmUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreserveReceiptStatement</Name>
				<Source><![CDATA[
    public boolean parmPreserveReceiptStatement(boolean _preserveReceiptStatement = preserveReceiptStatement)
    {
        preserveReceiptStatement = _preserveReceiptStatement;
        return preserveReceiptStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReceiptListDeviationType_RU</Name>
				<Source><![CDATA[
    ReceiptListDeviationType_RU parmReceiptListDeviationType_RU(ReceiptListDeviationType_RU _receiptListDeviationType = receiptListDeviationType)
    {
        receiptListDeviationType = _receiptListDeviationType;
        return receiptListDeviationType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxableDocumentDescriptor</Name>
				<Source><![CDATA[
    public TaxableDocumentDescriptor parmTaxableDocumentDescriptor()
    {
        return TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(purchParmTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the document posting to the general ledger is enabled.
    /// </summary>
    /// <returns>
    /// true if the document is posted to the general ledger; otherwise, false.
    /// </returns>
    protected boolean postingEnabled()
    {
        return vendParameters.PostPackingSlip == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printGRN_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints goods receipt notes.
    /// </summary>
    /// <param name="_printGoodsReceiptNote">
    /// The goods receipt notes.
    /// </param>
    /// <returns>
    /// If 'True', the goods receipt note can be printed.
    /// </returns>
    public boolean printGRN_IN(boolean _printGoodsReceiptNote = printGoodsReceiptNote)
    {
        printGoodsReceiptNote = _printGoodsReceiptNote;

        return printGoodsReceiptNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>proforma</Name>
				<Source><![CDATA[
    protected boolean  proforma()
    {
        return purchParmUpdate.Proforma;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordListParmLine</Name>
				<Source><![CDATA[
    protected RecordSortedList recordListParmLine()
    {
        return purchTotals.recordListPurchParmLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDeliveryFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the delivery related fields on the packing slip journal header.
    /// </summary>
    protected void setDeliveryFields()
    {
        PurchLine           localPurchLine;
        PurchParmLine       purchParmLine;

        if (!purchParmTable.DeliveryName
            || !purchParmTable.DeliveryPostalAddress)
        {
            select firstonly purchParmLine
                where purchParmLine.ParmId     == purchParmTable.ParmId
                &&    purchParmLine.TableRefId == purchParmTable.TableRefId;

            localPurchLine = purchParmLine.purchLine();
        }

        vendPackingSlipJour.DeliveryPostalAddress  = purchParmTable.DeliveryPostalAddress ? purchParmTable.DeliveryPostalAddress
                                                                     : localPurchLine.DeliveryPostalAddress;
        vendPackingSlipJour.DeliveryName           = purchParmTable.DeliveryName    ? purchParmTable.DeliveryName
                                                                     : localPurchLine.DeliveryName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the journal to an existing record.
    /// </summary>
    /// <param name="_journal">
    /// An existing journal record.
    /// </param>
    public void setJournal(Common _journal)
    {
        vendPackingSlipJour = VendPackingSlipJour::findRecId(_journal.RecId, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTable</Name>
				<Source><![CDATA[
    protected Common sourceTable()
    {
        return purchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totals</Name>
				<Source><![CDATA[
    protected Object totals()
    {
        return purchTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>typeParmLine</Name>
				<Source><![CDATA[
    protected Common typeParmLine()
    {
        PurchParmLine   purchParmLine;
        return purchParmLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDate</Name>
				<Source><![CDATA[
    protected TransDate  updateDate()
    {
        return accountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExciseRegister_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the excise register information.
    /// </summary>
    /// <param name="_vendPackingSlipTrans">
    /// The vend packing slip trans information.
    /// </param>
    protected void updateExciseRegister_IN(VendPackingSlipTrans _vendPackingSlipTrans)
    {
        TaxModelExciseTaxable_IN taxModelExciseTaxable;
        TaxTable                 taxTableLocal;
        TaxComponentTable_IN     taxComponentTableLocal;

        select firstonly RecId from journalTmpTaxWorkTrans
            where journalTmpTaxWorkTrans.InventTransId == _vendPackingSlipTrans.InventTransId
            exists join taxTableLocal
                where journalTmpTaxWorkTrans.TaxCode == taxTableLocal.TaxCode
                    && taxTableLocal.TaxType_IN == TaxType_IN::Excise;

        if (!journalTmpTaxWorkTrans.RecId && TaxParameters::isCustomsEnable_IN())
        {
            select firstonly RecId from journalTmpTaxWorkTrans
                where journalTmpTaxWorkTrans.InventTransId == _vendPackingSlipTrans.InventTransId
                exists join taxTableLocal
                    where journalTmpTaxWorkTrans.TaxCode == taxTableLocal.TaxCode
                        && taxTableLocal.TaxType_IN == TaxType_IN::Customs
                exists join taxComponentTableLocal
                    where taxTableLocal.TaxComponentTable_IN == taxComponentTableLocal.RecId
                        && taxComponentTableLocal.ApplyExcise == NoYes::Yes;
        }

        if (journalTmpTaxWorkTrans.RecId)
        {
            taxModelExciseTaxable = TaxModelDocLineFactory::newTaxModelDocLine(_vendPackingSlipTrans) as TaxModelExciseTaxable_IN;

            if (taxModelExciseTaxable)
            {
                if (taxModelExciseTaxable.shouldPostQuantityRegister())
                {
                    this.handleExciseQuantityRegister_IN(taxModelExciseTaxable);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets correctable fields on journal header.
    /// </summary>
    protected void updateJournalHeader()
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU))
        {
            if (vendPackingSlipJour.OffSessionId_RU)
            {
                OfficialsTrans_RU::deleteWithoutUpdate(vendPackingSlipJour.OffSessionId_RU);
            }

            vendPackingSlipJour.OffSessionId_RU = purchParmTable.OffSessionId_RU;
        }

        if (isCountryRegion_RU)
        {
            if (vendPackingSlipJour.ReceiptListDeviationType_RU != this.parmReceiptListDeviationType_RU())
            {
                vendPackingSlipJour.ReceiptListDeviationType_RU = this.parmReceiptListDeviationType_RU();

                isJournalHeaderChanged = formLetterJournalCreateVersioning.mayUpdateIfHeaderChanged();
            }
        }
        else if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLT, #isoLV]))
        {
            if (purchParmTable.DocAutoNumbering_LT == NoYes::Yes)
            {
                if (! LtInvoiceAutoNumberingTable::checkLastDate(ltDocNumberingCode, this.updateDate(), true))
                {
                    throw error("@SYS18447");
                }

                ProductReceiptId packingSlipId = NumberSeq::newGetNumFromCode(LtInvoiceAutoNumberingTable::find(ltDocNumberingCode).NumberSequenceCode).num();
                if (!packingSlipId)
                {
                    throw error(strFmt("@SYS23050", vendPackingSlipJour.PurchId));
                }

                vendPackingSlipJour.PackingSlipId = packingSlipId;
                vendPackingSlipJour.PackingSlipNumberingCode_LT = ltDocNumberingCode;
                LtInvoiceAutoNumberingTable::updateLastDate(ltDocNumberingCode, this.updateDate());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets correctable fields on journal line.
    /// </summary>
    /// <param name="_journalLine">
    /// The journal line to update.
    /// </param>
    /// <param name="_parmLine">
    /// The parameter line that the update based on.
    /// </param>
    public void updateJournalLine(Common _journalLine, Common _parmLine)
    {
        VendPackingSlipTrans vendPackingSlipTrans = _journalLine as VendPackingSlipTrans;
        PurchParmLine        purchParmLine = _parmLine as PurchParmLine;

        vendPackingSlipTrans.Qty                    = purchParmLine.ReceiveNow;
        vendPackingSlipTrans.InventQty              = purchParmLine.InventNow;
        vendPackingSlipTrans.Remain                 = purchParmLine.RemainAfter;
        var remainDiffQty = purchParmLine.RemainBefore - purchParmLine.ReceiveNow;
        if (purchParmLine.RemainBefore > 0 && remainDiffQty > 0)
        {
            vendPackingSlipTrans.CancelledQty      += remainDiffQty - purchParmLine.RemainAfter;
        }
        else
        {
            vendPackingSlipTrans.CancelledQty       = 0;
        }
        
        vendPackingSlipTrans.RemainInvent           = purchParmLine.RemainAfterInvent;
        vendPackingSlipTrans.ReasonTableRef         = purchParmLine.ReasonTableRef;
        vendPackingSlipTrans.ValueMST               = purchParmLine.lineAmountExclTax(vendPackingSlipTrans.DeliveryDate, this.parmTax());
        vendPackingSlipTrans.AccountingDate         = accountingDate;
        vendPackingSlipTrans.PdsCWQty               = purchParmLine.PdsCWReceiveNow;
        vendPackingSlipTrans.PdsCWRemain            = purchParmLine.PdsCWRemainAfterInvent;
        vendPackingSlipTrans.DeviationQty_RU        = purchParmLine.DeviationQty_RU;
        vendPackingSlipTrans.LineAmount_W           = vendPackingSlipTrans.ValueMST; //line amount is currency amount and its not recalculated yet
        vendPackingSlipTrans.CurrencyCode_W         = purchParmLine.CurrencyCode;

        RelationshipBetweenJournalLineAndParmLineSingleton::instance().addRelationshipBetweenParmLineAndJournalLine(_parmLine.RecId,
            JournalLineInformation::construct(vendPackingSlipTrans.VendPackingSlipJour, vendPackingSlipTrans.InventTransId, vendPackingSlipTrans.LineNum));

        if (this.canWriteTaxAmountLine(purchParmLine))
        {
            vendPackingSlipTrans.initFromTaxWorkTrans_RU(
                this.parmTax().tmpTaxWorkTrans(),
                tableNum(PurchLine),
                0,
                vendPackingSlipTrans.InventTransId);
        }

        if (vendPackingSlipTrans.isCategoryBased())
        {
            // if the foreign trade fields have been updated, then they should also take effect in a correction.
            vendPackingSlipTrans.initFrompurchLineForeignTradeCategory(PurchLineForeignTradeCategory::findpurchLine(purchParmLine.purchLine()));
        }

        vendPackingSlipTrans.ValueMST = CurrencyExchangeHelper::mstAmount(vendPackingSlipTrans.ValueMST, purchParmLine.CurrencyCode, vendPackingSlipTrans.DeliveryDate);

        if (formLetterJournalCreateVersioning is FormLetterJournalCreateCorrection)
        {
            // Cancellation or correction.
            if (vendPackingSlipTrans.Qty == 0 || vendPackingSlipTrans.Qty == vendPackingSlipTrans.invoicedPurchQty())
            {
                vendPackingSlipTrans.FullyMatched = NoYes::Yes;
            }

            this.updateRemainForOverUnderDelivery(vendPackingSlipTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRemainForOverUnderDelivery</Name>
				<Source><![CDATA[
    /// <summary>
    /// In case of over- or underdelivery ensure Remain and RemainInvent are set correctly when product receipt is corrected or cancelled.
    /// </summary>
    /// <param name="_vendPackingSlipTrans">
    /// The VendPackingSlipTrans.
    /// </param>
    /// <remarks>
    /// If product receipt was posted with over- or underdelivery, and the product receipt is corrected or cancelled, then deliver remainder
    /// should reflect the original deliver remainder, rather than the Received quantity from the canceled product receipt.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// You cannot generate a packing slip for a quantity that has a different sign than the quantity on the order line.
    /// </exception>
    protected void updateRemainForOverUnderDelivery(VendPackingSlipTrans _vendPackingSlipTrans)
    {
        real convertedRemainingInvent;
        boolean check;
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_vendPackingSlipTrans.ItemId);

        if (sign(_vendPackingSlipTrans.orig().Qty) != sign(_vendPackingSlipTrans.Ordered))
        {
            throw error("@SYS331618");
        }

        VendPackingSlipTrans vendPackingSlipTrans;
        select sum(Qty), sum(PdsCWQty) from vendPackingSlipTrans
            group by InventTransId
            where vendPackingSlipTrans.InventTransId == _vendPackingSlipTrans.InventTransId
                && vendPackingSlipTrans.RecId        != _vendPackingSlipTrans.RecId;
        PurchQty purchQtyReceiptSum = vendPackingSlipTrans.Qty + _vendPackingSlipTrans.Qty;
        PurchQty purchQtyOrdered    = _vendPackingSlipTrans.purchLine().PurchQty;
        PurchQty remain             = _vendPackingSlipTrans.Remain;
        PurchQty cancelledQty       = _vendPackingSlipTrans.CancelledQty;

        // Check if there is received qty by posting invoice directly without packing slip.
        if (abs(purchQtyReceiptSum + remain) != abs(purchQtyOrdered))
        {
            PurchQty invoicedQtyOnPackingSlip = _vendPackingSlipTrans.purchLine().invoicedOnPackingSlipInTotal();
            PurchQty invoicedQty              = _vendPackingSlipTrans.purchLine().invoicedInTotal();

            // Get the received qty which is received by posting invoice directly without packing slip
            if( invoicedQty != invoicedQtyOnPackingSlip)
            {
                PurchQty receivedQtyOnDirectInvoiced = invoicedQty - invoicedQtyOnPackingSlip;
                purchQtyReceiptSum += receivedQtyOnDirectInvoiced;
            }            
        }

        if (isCWItem)
        {
            PurchQty totalReceivedCatchWeightQuantity = vendPackingSlipTrans.PdsCWQty + _vendPackingSlipTrans.PdsCWQty;
            PurchQty orderedCatchWeightQuantity = _vendPackingSlipTrans.purchLine().PdsCWQty;

            check = (abs(totalReceivedCatchWeightQuantity + _vendPackingSlipTrans.PdsCWRemain) > abs(orderedCatchWeightQuantity)
                || (abs(totalReceivedCatchWeightQuantity + _vendPackingSlipTrans.PdsCWRemain) < abs(orderedCatchWeightQuantity) && _vendPackingSlipTrans.orig().PdsCWRemain == 0));
        }
        else
        {
            check = (abs(purchQtyReceiptSum + remain + cancelledQty) > abs(purchQtyOrdered)
                || (abs(purchQtyReceiptSum + remain + cancelledQty) < abs(purchQtyOrdered) && _vendPackingSlipTrans.orig().Remain == 0));
        }

        // Determines whether the purchase line has been overdelivered or underdelivered. 
        if (check)
        {
            remain = purchQtyOrdered - purchQtyReceiptSum - cancelledQty;
            if (purchQtyOrdered > 0)
            {
                _vendPackingSlipTrans.Remain = remain > 0 ? remain : 0;
            }
            else
            {
                _vendPackingSlipTrans.Remain = remain < 0 ? remain : 0;
            }

            if (_vendPackingSlipTrans.purchLine().isStocked())
            {
                if (_vendPackingSlipTrans.Remain)
                {
                    convertedRemainingInvent = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(
                                                   _vendPackingSlipTrans.ItemId,
                                                   _vendPackingSlipTrans.InventDimId,
                                                   _vendPackingSlipTrans.Remain,
                                                   _vendPackingSlipTrans.PurchUnit,
                                                   InventTable::find(_vendPackingSlipTrans.ItemId).inventUnitId(),
                                                   NoYes::Yes);

                    _vendPackingSlipTrans.RemainInvent = decRound(convertedRemainingInvent, InventTable::inventDecimals(_vendPackingSlipTrans.ItemId));
                }
                else
                {
                    _vendPackingSlipTrans.RemainInvent = _vendPackingSlipTrans.Remain;
                }
            }

            if (isCWItem)
            {
                this.calculateCatchWeightRemainingQuantity(_vendPackingSlipTrans, vendPackingSlipTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCatchWeightRemainingQuantity</Name>
				<Source><![CDATA[
    private void calculateCatchWeightRemainingQuantity(VendPackingSlipTrans _vendPackingSlipTrans, VendPackingSlipTrans _vendPackingSlipTransLocal)
    {
        PurchQty totalReceivedCatchWeightQuantity = _vendPackingSlipTransLocal.PdsCWQty + _vendPackingSlipTrans.PdsCWQty;
        PurchQty orderedCatchWeightQuantity = _vendPackingSlipTrans.purchLine().PdsCWQty;
        PurchQty catchweightRemainQuantity = orderedCatchWeightQuantity - totalReceivedCatchWeightQuantity;

        if (orderedCatchWeightQuantity > 0)
        {
            _vendPackingSlipTrans.PdsCWRemain = catchweightRemainQuantity > 0 ? catchweightRemainQuantity : 0;
        }
        else
        {
            _vendPackingSlipTrans.PdsCWRemain = catchweightRemainQuantity < 0 ? catchweightRemainQuantity : 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    protected static PurchPackingSlipJournalCreate construct()
    {
        return new PurchPackingSlipJournalCreate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAvailableInventoryDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the first available inventory date starting from the specified date.
    /// </summary>
    /// <param name="_vendPackingSlipJour">
    /// The <c>VendPackingSlipJour</c> record from which to start to search.
    /// </param>
    /// <param name="_startFromDate">
    /// The date from which to start to search.
    /// </param>
    /// <param name="_dataAreaIds">
    /// The map of the company IDs and related packing slip journals that are already checked.
    /// </param>
    /// <param name="_showMessage">
    /// Indicates whether a message should be shown if the original accounting date cannot be used so next
    /// available date will be used instead.
    /// </param>
    /// <returns>
    /// The available date.
    /// </returns>
    public static AccountingDate findAvailableInventoryDate(
                                                            VendPackingSlipJour _vendPackingSlipJour,
                                                            AccountingDate      _startFromDate,
                                                            Map                 _dataAreaIds,
                                                            boolean             _showMessage
                                                           )
    {
        AccountingDate              accountingDate = _startFromDate;
        TransDate                   inventoryClosingDate;
        VendPackingSlipJour         localVendPackingSlipJour;
        CustPackingSlipJour         custPackingSlipJour;
        TradePackingSlipJourChain   tradePackingSlipJourChain;

        if (!_dataAreaIds.exists(_vendPackingSlipJour.
        company()
        ))
        {
            _dataAreaIds.insert(_vendPackingSlipJour.
            company()
            , _vendPackingSlipJour);

            changecompany(_vendPackingSlipJour.
            company()
            )
            {
                //if it is called from SalesPackingSlipJournalCreate then _startFromDate is already calculated and it is >= than the latest VendPackingSlipVersion.
                //VendPackingSlipVersion.VersionDateTime is the same for all versions in the chain.
                accountingDate = _startFromDate ? _startFromDate : VendPackingSlipVersion::findLatest(_vendPackingSlipJour.RecId).AccountingDate;

                if (_vendPackingSlipJour.existsStockedProduct())
                {
                    inventoryClosingDate = InventClosing::closingDate();

                    if (accountingDate <= inventoryClosingDate)
                    {
                        accountingDate = inventoryClosingDate + 1;

                        if (_showMessage)
                        {
                            info("@SYS328875");
                        }
                    }
                }
            }
        }

        //find the next vendPackingSlipJour in the chain.
        select crossCompany localVendPackingSlipJour
        exists join custPackingSlipJour
        where  localVendPackingSlipJour.PackingSlipId         == custPackingSlipJour.PackingSlipId
            && localVendPackingSlipJour.DeliveryDate          == custPackingSlipJour.DeliveryDate
            && localVendPackingSlipJour.InterCompanyCompanyId == custPackingSlipJour.DataAreaId
            && localVendPackingSlipJour.InterCompanySalesId   == custPackingSlipJour.SalesId
            exists join tradePackingSlipJourChain
                where tradePackingSlipJourChain.VendPackingSlipJour == _vendPackingSlipJour.RecId
                    && tradePackingSlipJourChain.CustPackingSlipJour == custPackingSlipJour.RecId;

        if (localVendPackingSlipJour.RecId)
        {   //recursive call.
            accountingDate = PurchPackingSlipJournalCreate::findAvailableInventoryDate(localVendPackingSlipJour, accountingDate, _dataAreaIds, _showMessage);
        }

        return accountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOpenFiscalDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the first available fiscal date starting from the specified date.
    /// </summary>
    /// <param name="_startFromDate">
    /// The date to start to search from
    /// </param>
    /// <param name="_dataAreaIds">
    /// The map of the company IDs and related packing slip journals that are already checked.
    /// </param>
    /// <param name="_showMessage">
    /// Indicates whether a message should be shown if the original accounting date cannot be used so next
    /// available date will be used instead.
    /// </param>
    /// <returns>
    /// The available date.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The exception is thrown if there is no open fiscal period available.
    /// </exception>
    public static AccountingDate findOpenFiscalDate(
                                                    AccountingDate      _startFromDate,
                                                    Map                 _dataAreaIds,
                                                    boolean             _showMessage
                                                   )
    {
        AccountingDate              accountingDate = _startFromDate;
        AccountingDate              prevAccountingDate;
        MapEnumerator               mapEnumerator = _dataAreaIds.getEnumerator();
        RecId                       calendarRecId;
        str                         dataArea;
        TradePackingSlipJourChain   tradePackingSlipJourChain;
        VendPackingSlipJour         vendPackingSlipJour;

        do
        {
            prevAccountingDate = accountingDate;

            while (mapEnumerator.moveNext())
            {
                dataArea = mapEnumerator.currentKey();
                changecompany(dataArea)
                {
                    if (VendParameters::find().PostPackingSlip)
                    {
                        calendarRecId = CompanyInfoHelper::fiscalCalendarRecId();
                        if (!LedgerFiscalCalendar::checkLedgerPeriodDateModule(calendarRecId, accountingDate, SysModule::Purch, false))
                        {
                            accountingDate = LedgerFiscalCalendar::findFirstOpenStartDateModule(calendarRecId, accountingDate, SysModule::Purch);

                            if (!accountingDate)
                            {
                                throw error("@SYS329190");
                            }

                            if (_showMessage)
                            {
                                info("@SYS329189");
                            }
                        }
                    }

                    vendPackingSlipJour = mapEnumerator.currentValue();

                    select firstonly RecId from tradePackingSlipJourChain
                    where tradePackingSlipJourChain.VendPackingSlipJour == vendPackingSlipJour.RecId;

                    if (tradePackingSlipJourChain.RecId)
                    {
                        accountingDate = SalesPackingSlipJournalCreate::findOpenFiscalDate(accountingDate, _showMessage);
                    }
                }
            }
        }
        while (prevAccountingDate != accountingDate);

        return accountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFormLetter</Name>
				<Source><![CDATA[
    public static PurchPackingSlipJournalCreate newFormLetter(FormLetterContract _formLetterContract)
    {
        PurchPackingSlipJournalCreate purchPackingSlipJournalCreate = PurchPackingSlipJournalCreate::construct();

        purchPackingSlipJournalCreate.parmFormLetterJournalCreateVersioning(
            FormLetterJournalCreateVersioning::newFormLetter(_formLetterContract, purchPackingSlipJournalCreate));

        return purchPackingSlipJournalCreate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transit documents
    /// </summary>
    private void transitDocument()
    {
        TransitDocumentManager_IN   transitManager;
        PurchParmLine               purchParmLineLocal;
        VendPackingSlipTrans        vendPackingSlipTrans;

        transitManager = TransitDocumentManager_IN::newManager();
        transitManager.transit(purchParmTable, vendPackingSlipJour);

        while select vendPackingSlipTrans
                where vendPackingSlipTrans.VendPackingSlipJour == vendPackingSlipJour.RecId
                join purchParmLineLocal
                    where  purchParmLineLocal.InventTransId == vendPackingSlipTrans.InventTransId
                        && purchParmLineLocal.ParmId        == purchParmTable.ParmId
                        && purchParmLineLocal.TableRefId    == purchParmTable.TableRefId
        {
            transitManager.transit(purchParmLineLocal, vendPackingSlipTrans, vendPackingSlipJour);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>