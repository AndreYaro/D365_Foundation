<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RestoredVATCalcAssets_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
class RestoredVATCalcAssets_RU
{
    RAssetTable             rAssetTable;
    RAssetStandards         rAssetStandards;
    RestoredVATLogTable_RU  restoredVATLog;

    RAssetStandardId        standardIdDefault;
    TransDate               taxPeriodFrom, taxPeriodTo;

    RAssetId                parmRAssetId;
    TaxCode                 logTransTaxCode;
    DimensionDefault        logTransDimension;
    InventTransId           logTransInventTransId;
    RefRecId                logTransRecId;
    TransTxt                logTransTxt;
    Factor                  yrFactorExport,
                            yrFactorNotLiable;
    boolean                 updateLogTable;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>assetTransPeriodExist</Name>
				<Source><![CDATA[
    private boolean assetTransPeriodExist(RAssetUse _rAssetUse)
    {
        RAssetTrans rAssetTrans;

        select firstonly RecId from rAssetTrans
            order by TransDate
            where rAssetTrans.AccountNum      == _rAssetUse.AssetId                      &&
                  rAssetTrans.TransDate       >= endmth(prevMth(_rAssetUse.UseDate)) + 1 &&
                  rAssetTrans.TransDate       <= endmth(_rAssetUse.UseDate)              &&
                  rAssetTrans.AssetStandardId == standardIdDefault                       &&
                  rAssetTrans.StornoRecId     == 0;

        return rAssetTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcIncomingVAT</Name>
				<Source><![CDATA[
    protected BookStructSmallVATAmounts_RU calcIncomingVAT(TransDate   _dateTo   = taxPeriodTo,
                                                           TransDate   _dateFrom = dateNull())
    {
        PurchBookVATProcessLogTrans_RU      purchBookVATProcessLogTrans;
        PurchBookVATProcessLogTransOper_RU  purchBookVATProcessLogTransOper;
        FactureJour_RU                      factureJour;
        FactureTrans_RU                     factureTrans;
        VendInvoiceJour                     vendInvoiceJour;
        VendInvoiceTrans                    vendInvoiceTrans;
        RAssetTable                         rAssetTableFactured;

        BookStructSmallVATAmounts_RU        factureAmounts;
        TaxAmount                           taxAmount,
                                            amountLiableToVAT;
        ItemName                            itemName;

        select firstonly * from vendInvoiceJour
            where vendInvoiceJour.InvoiceId             == rAssetTable.VendInvoiceId           &&
                  vendInvoiceJour.InternalInvoiceId     == rAssetTable.PurchInternalInvoiceId  &&
                  vendInvoiceJour.InvoiceAccount        == rAssetTable.VendAccount             &&
                  vendInvoiceJour.PurchId               == rAssetTable.PurchId                 &&
                  vendInvoiceJour.NumberSequenceGroup   == rAssetTable.NumberSequenceGroupId
            join * from vendInvoiceTrans
                where vendInvoiceTrans.InvoiceId            == vendInvoiceJour.InvoiceId            &&
                      vendInvoiceTrans.NumberSequenceGroup  == vendInvoiceJour.NumberSequenceGroup  &&
                      vendInvoiceTrans.InternalInvoiceId    == vendInvoiceJour.InternalInvoiceId    &&
                      vendInvoiceTrans.PurchID              == vendInvoiceJour.PurchId              &&
                      vendInvoiceTrans.InvoiceDate          == vendInvoiceJour.InvoiceDate          &&
                      vendInvoiceTrans.InventTransId        == rAssetTable.InventTransId;

        VendTrans vendTrans = vendInvoiceJour.vendTrans();

        select firstonly * from factureTrans
               where factureTrans.InvoiceLineNum      == vendInvoiceTrans.LineNum             &&
                     factureTrans.InternalInvoiceId   == vendInvoiceTrans.InternalInvoiceId   &&
                     factureTrans.InvoiceDate         == vendInvoiceTrans.InvoiceDate         &&
                     factureTrans.InvoiceId           == vendInvoiceTrans.InvoiceId           &&
                     factureTrans.SalesPurchId        == vendInvoiceTrans.PurchID             &&
                     factureTrans.NumberSequenceGroup == vendInvoiceTrans.NumberSequenceGroup &&
                     factureTrans.Module              == FactureModule_RU::Vend               &&
                     factureTrans.FactureLineType     == FactureLineType_RU::InvoiceLine
            join * from factureJour
               where factureJour.FactureId == factureTrans.FactureId &&
                     factureJour.Module    == factureTrans.Module;

        while select * from purchBookVATProcessLogTrans
                where purchBookVATProcessLogTrans.FactureId       == factureJour.FactureId   &&
                      purchBookVATProcessLogTrans.FactureDate     == factureJour.FactureDate &&
                      purchBookVATProcessLogTrans.InvoiceRecIdRef == vendTrans.RecId         &&
                     (purchBookVATProcessLogTrans.TransType       == SalesPurchBookTransType_RU::Invoice ||
                      purchBookVATProcessLogTrans.TransType       == SalesPurchBookTransType_RU::CreditNote)
            join purchBookVATProcessLogTransOper
                where purchBookVATProcessLogTransOper.RefRecId          == purchBookVATProcessLogTrans.RecId &&
                      purchBookVATProcessLogTransOper.TaxCode           == factureTrans.TaxCode              &&
                      purchBookVATProcessLogTransOper.DefaultDimension  == factureTrans.DefaultDimension     &&
                      purchBookVATProcessLogTransOper.InventTransId     == factureTrans.InventTransId        &&
                      purchBookVATProcessLogTransOper.Blocked           == NoYes::No                         &&
                      purchBookVATProcessLogTransOper.BlockedAuto       == NoYes::No                         &&
                      purchBookVATProcessLogTransOper.TransDate         >= _dateFrom                         &&
                      purchBookVATProcessLogTransOper.TransDate         <= _dateTo                           &&
                     !purchBookVATProcessLogTransOper.CanceledRefRecId
        {
            logTransRecId = purchBookVATProcessLogTrans.RecId;

            taxAmount         += purchBookVATProcessLogTransOper.TaxAmount;
            amountLiableToVAT += purchBookVATProcessLogTransOper.AmountLiableToVAT;
            factureAmounts    = BookStructSmallVATAmounts_RU::create(purchBookVATProcessLogTransOper.FacturedAmounts);

            if (!itemName)
            {
                itemName = factureAmounts.itemName();
            }

            logTransTxt = purchBookVATProcessLogTransOper.TransTxt;
        }

        select count(AssetReplaceCost) from rAssetTableFactured
            index PurchInternalInvoiceIdx
            where rAssetTableFactured.PurchInternalInvoiceId == rAssetTable.PurchInternalInvoiceId &&
                rAssetTableFactured.VendInvoiceId          == rAssetTable.VendInvoiceId          &&
                rAssetTableFactured.InventTransId          == rAssetTable.InventTransId          &&
                rAssetTableFactured.NumberSequenceGroupId  == rAssetTable.NumberSequenceGroupId  &&
                rAssetTableFactured.VendAccount            == rAssetTable.VendAccount;

        Factor assetQty = rAssetTableFactured.AssetReplaceCost;

        if (assetQty)
        {
            taxAmount           = CurrencyExchangeHelper::amount(taxAmount / assetQty);
            amountLiableToVAT   = CurrencyExchangeHelper::amount(amountLiableToVAT / assetQty);
        }

        factureAmounts = new BookStructSmallVATAmounts_RU();
        factureAmounts.addAmounts(amountLiableToVAT + taxAmount, amountLiableToVAT, taxAmount, 1);
        factureAmounts.itemName(itemName);

        logTransTaxCode         = factureTrans.TaxCode;
        logTransDimension       = factureTrans.DefaultDimension;
        logTransInventTransId   = factureTrans.InventTransId;

        return factureAmounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcRestoredVAT</Name>
				<Source><![CDATA[
    protected RestoredVATLogTransOperAsset_RU calcRestoredVAT(TransDate _transDate)
    {
        RestoredVATLogTable_RU          restoredVATLogTable;
        RestoredVATLogTransOper_RU      restoredVATLogTransOperSum;
        RestoredVATLogTransOperAsset_RU restoredOperAssetSum;

        select sum(TaxAmountNotLiable),
               sum(AmountLiableToVAT),
               sum(AmountWrittenOff),
               sum(TaxAmount),
               sum(UseValueExport),
               sum(UseValueNotLiable) from restoredOperAssetSum
            where restoredOperAssetSum.AssetId == rAssetTable.AccountNum
            join RecId from restoredVATLogTransOperSum
                where restoredVATLogTransOperSum.RecId                == restoredOperAssetSum.LogTransOperRefRecId &&
                      restoredVATLogTransOperSum.TransDate            != _transDate                 &&
                      restoredVATLogTransOperSum.Include                                            &&
                      restoredVATLogTransOperSum.Asset
            exists join restoredVATLogTable
                where restoredVATLogTable.TransDate == restoredVATLogTransOperSum.TransDate &&
                      restoredVATLogTable.Approved;

        return restoredOperAssetSum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcYearRevenue</Name>
				<Source><![CDATA[
    public void calcYearRevenue()
    {
        CustInvoiceJour             custInvoiceJour;
        CustInvoiceTrans            custInvoiceTrans;
        TaxTrans                    taxTrans;
        SalesPurchInvoiceLink_RU    salesPurchInvoiceLink;
        RestoredVATLogTable_RU      restoredVATLogTable;
        TaxParameters               taxParameters = TaxParameters::find();

        Amount  exportRevenue, domesticRevenue, revenue, notLiableRevenue,
                totalRevenue, totalNotLiable, totalExport, totalDomestic;
        ;

        while select custInvoiceJour
            where custInvoiceJour.InvoiceDate >= mkDate(1, 1, year(taxPeriodTo)) &&
                    custInvoiceJour.InvoiceDate <= taxPeriodTo
        {
            exportRevenue    = 0;
            domesticRevenue  = 0;
            notLiableRevenue = 0;
            revenue          = 0;

            if (taxParameters.RestoredVATGainCalcMethod_RU == RestoredVATGainCalcMethod_RU::Indirect)
            {
                select firstonly custInvoiceTrans
                    where custInvoiceTrans.SalesId              == custInvoiceJour.SalesId      &&
                            custInvoiceTrans.InvoiceId            == custInvoiceJour.InvoiceId    &&
                            custInvoiceTrans.InvoiceDate          == custInvoiceJour.InvoiceDate  &&
                            custInvoiceTrans.NumberSequenceGroup  == custInvoiceJour.NumberSequenceGroup
                exists join salesPurchInvoiceLink
                    where salesPurchInvoiceLink.SalesTransTableId   == custInvoiceTrans.TableId &&
                            salesPurchInvoiceLink.SalesTransRecId     == custInvoiceTrans.RecId;

                if (custInvoiceTrans)
                {
                    continue;
                }
            }

            while select sum(TaxBaseAmount) from taxTrans
                group by TaxCode
                where taxTrans.Voucher   == custInvoiceJour.LedgerVoucher &&
                      taxTrans.TransDate == custInvoiceJour.InvoiceDate
            {
                TaxTable taxTable = TaxTable::find(taxTrans.TaxCode);
                if (taxTable.TaxType_W == TaxType_W::VATZero && taxTable.DomesticMarketTaxCode_RU)
                {
                    exportRevenue -= taxTrans.TaxBaseAmount;
                }
                else
                {
                    domesticRevenue -= taxTrans.TaxBaseAmount;
                }

                revenue -= taxTrans.TaxBaseAmount;
            }

            notLiableRevenue = custInvoiceJour.InvoiceAmountMST -
                                custInvoiceJour.SumTaxMST        -
                                revenue;
            revenue += notLiableRevenue;

            totalRevenue   += revenue;
            totalNotLiable += notLiableRevenue;
            totalExport    += exportRevenue;
            totalDomestic  += domesticRevenue;
        }

        restoredVATLogTable.TotalGain       = totalRevenue;
        restoredVATLogTable.ExportGain      = totalExport;
        restoredVATLogTable.DomesticGain    = totalDomestic;
        restoredVATLogTable.NotLiableGain   = totalNotLiable;

        yrFactorExport    = restoredVATLogTable.factorExport()    / 100;
        yrFactorNotLiable = restoredVATLogTable.factorNotLiable() / 100;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearValues</Name>
				<Source><![CDATA[
    private void clearValues()
    {
        logTransInventTransId = '';
        logTransDimension     = 0;
        logTransTaxCode       = '';
        logTransRecId         = 0;
        logTransTxt           = '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUpdateLogTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// gets a boolean sign of updated log table
    /// </summary>
    /// <returns>
    /// a boolean sign, true - if the log table was updated
    /// </returns>
    public boolean getUpdateLogTable()
    {
        return updateLogTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getYearFactor</Name>
				<Source><![CDATA[
    public Factor getYearFactor()
    {
        return yrFactorExport + yrFactorNotLiable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    public void init()
    {
        standardIdDefault = RAssetParameters::find().StandardIdDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertJournal</Name>
				<Source><![CDATA[
    protected void insertJournal(Amount                         _amountRestore,
                                 Amount                         _amountNotLiable,
                                 Amount                         _amountWrittenOff,
                                 Amount                         _amountLiableToVAT,
                                 RAssetUseValue                 _useValueExport,
                                 RAssetUseValue                 _useValueNotLiable,
                                 RestoredVATLineType_RU         _lineType,
                                 BookStructSmallVATAmounts_RU   _facturedAmount)
    {
        RestoredVATLogTransOper_RU      logTransOper;
        RestoredVATLogTransOperAsset_RU logTransOperAsset;

        void updateLogTransOper()
        {
            if (RestoredVATLogTrans_RU::find(logTransOper.TransDate, logTransOper.ProcessLogTransRecId))
            {
                logTransOper.update();
            }
            else
            {
                logTransOper.doUpdate();
            }
        }

        if (!this.validateKeyField())
        {
            return;
        }

        ttsbegin;
        logTransOper = RestoredVATLogTransOper_RU::find(taxPeriodTo,
                                                        logTransTaxCode,
                                                        logTransDimension,
                                                        logTransInventTransId,
                                                        logTransRecId,
                                                        RestoredVATLineType_RU::Indirect,
                                                        false,
                                                        true);
        if (logTransOper)
        {
            logTransOperAsset.LogTransOperRefRecId  = logTransOper.RecId;
            logTransOperAsset.AssetId               = rAssetTable.AccountNum;
            logTransOperAsset.TaxAmount             = _amountRestore;
            logTransOperAsset.TaxAmountNotLiable    = _amountNotLiable;
            logTransOperAsset.AmountLiableToVAT     = _amountLiableToVAT;
            logTransOperAsset.AmountWrittenOff      = _amountWrittenOff;
            logTransOperAsset.UseValueExport        = _useValueExport;
            logTransOperAsset.UseValueNotLiable     = _useValueNotLiable;
            logTransOperAsset.insert();

            logTransOper.LineType = _lineType;
            logTransOper.Asset    = NoYes::Yes;
            logTransOper.initFromAssetsSum();
            updateLogTransOper();
        }
        else
        {
            logTransOper = RestoredVATLogTransOper_RU::find(taxPeriodTo,
                                                            logTransTaxCode,
                                                            logTransDimension,
                                                            logTransInventTransId,
                                                            logTransRecId,
                                                            _lineType,
                                                            true,
                                                            true);
            if (logTransOper)
            {
                logTransOperAsset = RestoredVATLogTransOperAsset_RU::find(rAssetTable.AccountNum, logTransOper.RecId, true);

                logTransOperAsset.LogTransOperRefRecId  = logTransOper.RecId;
                logTransOperAsset.AssetId               = rAssetTable.AccountNum;
                logTransOperAsset.TaxAmount             = _amountRestore;
                logTransOperAsset.TaxAmountNotLiable    = _amountNotLiable;
                logTransOperAsset.AmountLiableToVAT     = _amountLiableToVAT;
                logTransOperAsset.AmountWrittenOff      = _amountWrittenOff;
                logTransOperAsset.UseValueExport        = _useValueExport;
                logTransOperAsset.UseValueNotLiable     = _useValueNotLiable;

                if (logTransOperAsset.RecId)
                {
                    logTransOperAsset.update();
                }
                else
                {
                    logTransOperAsset.insert();
                }

                logTransOper.LineType = _lineType;
                logTransOper.initFromAssetsSum();
                logTransOper.Asset    = NoYes::Yes;
                updateLogTransOper();
            }
            else
            {
                if (_amountNotLiable || _amountRestore || _amountWrittenOff)
                {
                    logTransOper.TransDate              = taxPeriodTo;
                    logTransOper.ProcessLogTransRecId   = logTransRecId;
                    logTransOper.TaxCode                = logTransTaxCode;
                    logTransOper.DefaultDimension       = logTransDimension;
                    logTransOper.InventTransId          = logTransInventTransId;
                    logTransOper.LineType               = _lineType;
                    logTransOper.Qty                    = _facturedAmount.qty();
                    logTransOper.QtySettled             = _facturedAmount.qty();
                    logTransOper.DateExecuted           = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    logTransOper.TaxAmount              = _amountRestore;
                    logTransOper.TaxAmountNotLiable     = _amountNotLiable;
                    logTransOper.AmountLiableToVAT      = _amountLiableToVAT;
                    logTransOper.TaxAmountWrittenOff    = _amountWrittenOff;
                    logTransOper.FacturedAmounts        = _facturedAmount.pack();
                    logTransOper.ItemName               = _facturedAmount.itemName();
                    logTransOper.Asset                  = NoYes::Yes;
                    logTransOper.Include                = NoYes::Yes;
                    logTransOper.TransTxt               = logTransTxt;
                    logTransOper.insert();

                    logTransOperAsset.LogTransOperRefRecId  = logTransOper.RecId;
                    logTransOperAsset.AssetId               = rAssetTable.AccountNum;
                    logTransOperAsset.TaxAmount             = _amountRestore;
                    logTransOperAsset.TaxAmountNotLiable    = _amountNotLiable;
                    logTransOperAsset.AmountLiableToVAT     = _amountLiableToVAT;
                    logTransOperAsset.AmountWrittenOff      = _amountWrittenOff;
                    logTransOperAsset.UseValueExport        = _useValueExport;
                    logTransOperAsset.UseValueNotLiable     = _useValueNotLiable;
                    logTransOperAsset.insert();

                    updateLogTable = true;
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOutputRun</Name>
				<Source><![CDATA[
    protected boolean isOutputRun()
    {
        RAssetSumCalc_Trans calcAssetTrans;
        boolean ret = rAssetStandards.assetDeprMethod(taxPeriodTo) == RAssetDeprMethod::Value;
        calcAssetTrans = RAssetSumCalc_Trans::newAssetPeriod(rAssetTable.AccountNum,
                                                             rAssetStandards.AssetStandardId,
                                                             taxPeriodFrom);
        ret = ret && calcAssetTrans.netBookValue() > 0;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWrittenOff</Name>
				<Source><![CDATA[
    private boolean isWrittenOff()
    {
        RAssetSumCalc_Trans calcAssetTrans;
        boolean ret;

        if (rAssetStandards.DisposalDate >= taxPeriodFrom &&
            rAssetStandards.DisposalDate <= taxPeriodTo)
        {
            calcAssetTrans = RAssetSumCalc_Trans::newAssetPeriod(rAssetTable.AccountNum,
                                                                 rAssetStandards.AssetStandardId,
                                                                 rAssetStandards.DisposalDate);
            ret = rAssetStandards.lifeTimeRest(rAssetStandards.DisposalDate) && (calcAssetTrans.disposalDisposedValueMST() != 0);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRAssetId</Name>
				<Source><![CDATA[
    public RAssetId parmRAssetId(RAssetId   _rAssetId = parmRAssetId)
    {
        parmRAssetId = _rAssetId;

        return parmRAssetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processBuilding</Name>
				<Source><![CDATA[
    #define.yearDivisor(10)
    #define.yearsStop(15)
    protected void processBuilding()
    {
        BookStructSmallVATAmounts_RU    factureAmounts;
        RAssetSumCalc_Trans             calcAssetTrans;
        TaxAmount              amountLiableToVAT,
                               restoredTaxAmount,
                               amountNotLiable;

        if (year(taxPeriodTo + 1) > year(taxPeriodTo))
        {
            RAssetTrans rAssetTrans = RAssetTrans::findFirstType(rAssetTable.AccountNum,
                                                                 standardIdDefault,
                                                                 RAssetTransType::Acquisition,
                                                                 false);
            if ((year(taxPeriodTo) - year(rAssetTrans.TransDate) < #yearsStop))
            {
                calcAssetTrans = RAssetSumCalc_Trans::newAssetPeriod(rAssetTable.AccountNum,
                                                                     rAssetStandards.AssetStandardId,
                                                                     taxPeriodFrom);

                rAssetTrans = RAssetTrans::findFirstType(rAssetTable.AccountNum,
                                                         standardIdDefault,
                                                         RAssetTransType::Depreciation,
                                                         false);
                if ((year(taxPeriodTo) - year(rAssetTrans.TransDate)) < #yearDivisor && calcAssetTrans.netBookValue() > 0)
                {
                   factureAmounts = this.calcIncomingVAT();

                    if (factureAmounts.taxAmountVAT())
                    {
                        this.calcYearRevenue();
                        restoredTaxAmount = CurrencyExchangeHelper::amount(factureAmounts.taxAmountVAT() * yrFactorExport / 10);
                        amountNotLiable   = CurrencyExchangeHelper::amount(factureAmounts.taxAmountVAT() * yrFactorNotLiable / 10);
                        amountLiableToVAT = (restoredTaxAmount / factureAmounts.taxAmountVAT() +
                                             amountNotLiable / factureAmounts.taxAmountVAT()) * factureAmounts.amountLiableToVAT();
                    }
                }
            }
        }

        this.insertJournal(restoredTaxAmount,
                          amountNotLiable,
                          0,
                          CurrencyExchangeHelper::amount(amountLiableToVAT),
                          0,
                          0,
                          RestoredVATLineType_RU::Indirect, factureAmounts);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processIndirect</Name>
				<Source><![CDATA[
    protected void processIndirect()
    {
        TaxAmount           amountLiableToVAT,
                            restoredTaxAmount,
                            amountNotLiable;

        BookStructSmallVATAmounts_RU factureAmounts = this.calcIncomingVAT(taxPeriodTo, taxPeriodFrom);
        restoredTaxAmount = factureAmounts.taxAmountVAT() * restoredVATLog.factorExport()    / 100;
        amountNotLiable = factureAmounts.taxAmountVAT() * restoredVATLog.factorNotLiable() / 100;

        if (factureAmounts.taxAmountVAT())
        {
            amountLiableToVAT = (restoredTaxAmount / factureAmounts.taxAmountVAT() +
                                 amountNotLiable / factureAmounts.taxAmountVAT())  *
                                 factureAmounts.amountLiableToVAT();
        }

        this.insertJournal(CurrencyExchangeHelper::amount(restoredTaxAmount),
                           CurrencyExchangeHelper::amount(amountNotLiable),
                           0,
                           CurrencyExchangeHelper::amount(amountLiableToVAT),
                           0,
                           0,
                           RestoredVATLineType_RU::Indirect,
                           factureAmounts);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processOutputRun</Name>
				<Source><![CDATA[
    protected void processOutputRun()
    {
        RAssetUse                       rAssetUse;
        BookStructSmallVATAmounts_RU    factureAmounts;

        TaxAmount               amountLiableToVAT,
                                restoredTaxAmount,
                                amountNotLiable,
                                amountTaxInc;
        RAssetUseValue          useValueExport, useValueNotLiable;
        Factor                  factorTaxAmount, factorNotLiable;

        while select rAssetUse
            where rAssetUse.AssetId           == rAssetTable.AccountNum &&
                  rAssetUse.UseDate           >= taxPeriodFrom          &&
                  rAssetUse.UseDate           <= taxPeriodTo            &&
                 (rAssetUse.UseValueExport    > 0                       ||
                  rAssetUse.UseValueNotliable > 0)
        {
            if (this.assetTransPeriodExist(rAssetUse))
            {
                useValueExport    += rAssetUse.UseValueExport;
                useValueNotLiable += rAssetUse.UseValueNotliable;
            }
        }

        if (rAssetTable.AssetUse)
        {
            factureAmounts = this.calcIncomingVAT();
            RestoredVATLogTransOperAsset_RU restoredOperAssetSum = this.calcRestoredVAT(taxPeriodTo);

            amountTaxInc = factureAmounts.taxAmountVAT() - restoredOperAssetSum.TaxAmount - restoredOperAssetSum.TaxAmountNotLiable;

            if (rAssetTable.AssetUse != restoredOperAssetSum.UseValueExport)
            {
                restoredTaxAmount = amountTaxInc * useValueExport / (rAssetTable.AssetUse - restoredOperAssetSum.UseValueExport);
            }

            if (rAssetTable.AssetUse != restoredOperAssetSum.UseValueNotLiable)
            {
                amountNotLiable = amountTaxInc * useValueNotLiable / (rAssetTable.AssetUse - restoredOperAssetSum.UseValueNotLiable);
            }

            if (factureAmounts.taxAmountVAT())
            {
                factorTaxAmount = amountTaxInc ? restoredTaxAmount / factureAmounts.taxAmountVAT()  : 0;
                factorNotLiable = amountTaxInc ? amountNotLiable   / factureAmounts.taxAmountVAT()  : 0;
            }

            amountLiableToVAT = (factorTaxAmount + factorNotLiable) * factureAmounts.amountLiableToVAT();
        }

        this.insertJournal(CurrencyExchangeHelper::amount(restoredTaxAmount),
                           CurrencyExchangeHelper::amount(amountNotLiable),
                           0,
                           CurrencyExchangeHelper::amount(amountLiableToVAT),
                           useValueExport,
                           useValueNotLiable,
                           RestoredVATLineType_RU::Direct,
                           factureAmounts);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processWrittenOff</Name>
				<Source><![CDATA[
    protected void processWrittenOff()
    {
        RAssetSumCalc_Trans             calcAssetTrans;
        BookStructSmallVATAmounts_RU    factureAmounts;

        TaxAmount   amountLiableToVAT,
                    restoredTaxAmount;

        Factor factor = 0;
        restoredTaxAmount = 0;

        calcAssetTrans = RAssetSumCalc_Trans::newAssetPeriod(rAssetTable.AccountNum,
                                                             rAssetStandards.AssetStandardId,
                                                             taxPeriodTo);
        if (calcAssetTrans.acquisitionValueMST())
        {
            factureAmounts = this.calcIncomingVAT();
            factor = (calcAssetTrans.acquisitionValueMST() - this.virtualDeprAmount())
                      / abs(calcAssetTrans.acquisitionValueMST());
            restoredTaxAmount = CurrencyExchangeHelper::amount(factureAmounts.taxAmountVAT() * factor);
            amountLiableToVAT = CurrencyExchangeHelper::amount(factureAmounts.amountLiableToVAT() * factor);

            if (restoredTaxAmount > factureAmounts.taxAmountVAT())
            {
                restoredTaxAmount = factureAmounts.taxAmountVAT();
            }
        }

        this.insertJournal(0,
                           0,
                           restoredTaxAmount,
                           amountLiableToVAT,
                           0,
                           0,
                           RestoredVATLineType_RU::Direct,
                           factureAmounts);
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        while select rAssetTable
            where rAssetTable.AssetType  != RAssetType::Cloths        &&
                  rAssetTable.AssetType  != RAssetType::Rigging       &&
                  rAssetTable.AssetType  != RAssetType::LowCostAssets &&
                  rAssetTable.VendInvoiceId                           &&
                  rAssetTable.InventTransId                           &&
                  (rAssetTable.AccountNum == this.parmRAssetId() || !this.parmRAssetId())
            join rAssetStandards
                where rAssetStandards.AssetId         == rAssetTable.AccountNum &&
                      rAssetStandards.AssetStandardId == standardIdDefault
        {
            if (rAssetTable.isFixedAssetType())
            {
                this.clearValues();
                switch (true)
                {
                    case this.isWrittenOff():
                        this.processWrittenOff();
                        break;

                    case rAssetTable.AssetType == RAssetType::LandBuilding :
                        this.processBuilding();
                        break;

                    case this.isOutputRun():
                        this.processOutputRun();
                        break;

                    default:
                        this.processIndirect();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVATLogTable</Name>
				<Source><![CDATA[
    void setVATLogTable(RestoredVATLogTable_RU _restoredVATLog)
    {
        restoredVATLog = _restoredVATLog;
        [taxPeriodFrom, taxPeriodTo] = restoredVATLog.datePeriodBook();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateKeyField</Name>
				<Source><![CDATA[
    private boolean validateKeyField()
    {
        boolean ret = true;

        if (logTransInventTransId == "")
        {
            ret = false;
        }

        if (logTransRecId == 0)
        {
            ret = false;
        }

        if (logTransTaxCode == "")
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>virtualDeprAmount</Name>
				<Source><![CDATA[
    private RAssetAmount virtualDeprAmount()
    {
        AmountCur                   amountCur, deprAmountMST;
        RAssetTransDate             transDate,
                                    assetDeprPeriod;
        RAssetDeprAccount           rAssetDeprAccount;
        RassetTableMethodIterator   iterator = RassetTableMethodIterator::construct(rAssetStandards);
        RAssetDepStartDate          depLastDateOrig     = rAssetStandards.LastDepDate;
        RAssetDisposalDate          disposalDateOrig    = rAssetStandards.DisposalDate;

        rAssetStandards.LastDepDate  = dateNull();
        rAssetStandards.DisposalDate = dateNull();
        rAssetStandards.CostLimitDate = dateNull();
  
        iterator.virtualDepStartDate(rAssetStandards.puttingIntoOperationDate());
        iterator.initValue(rAssetStandards, endmth(depLastDateOrig) + 1);

        while (iterator.nextInterval())
        {
            assetDeprPeriod = iterator.parmPostingDate();
            iterator.calculate();
            amountCur = iterator.sumDeprInterval();

            if (amountCur != 0)
            {
                if ((select firstonly rAssetDeprAccount
                         where rAssetDeprAccount.AssetId         == rAssetTable.AccountNum &&
                               rAssetDeprAccount.AssetStandardId == rAssetStandards.AssetStandardId).RecId)
                {
                    while select rAssetDeprAccount
                        where rAssetDeprAccount.AssetId         == rAssetTable.AccountNum &&
                              rAssetDeprAccount.AssetStandardId == rAssetStandards.AssetStandardId
                    {
                        AmountCur amountCurTrans = RAssetProposal::roundAmount(rAssetStandards.AssetStandardId,
                                                                     rAssetTable,
                                                                     transDate,
                                                                     amountCur * rAssetDeprAccount.Percentage/100,
                                                                     CompanyInfoHelper::standardCurrency());

                        if (amountCurTrans >= RAssetGroup::assetDepreciationMin(rAssetStandards.AssetGroup))
                        {
                            deprAmountMST += amountCurTrans;
                        }
                    }
                }
                else
                {
                    amountCur = RAssetProposal::roundAmount(rAssetStandards.AssetStandardId,
                                                            rAssetTable,
                                                            transDate,
                                                            amountCur,
                                                            CompanyInfoHelper::standardCurrency());

                    if (amountCur >= RAssetGroup::assetDepreciationMin(rAssetStandards.AssetGroup))
                    {
                        deprAmountMST += amountCur;
                    }
                }
            }
        }

        return deprAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static RestoredVATCalcAssets_RU construct(RestoredVATLogTable_RU _restoredVATLog)
    {
        RestoredVATCalcAssets_RU   calcAssets = new RestoredVATCalcAssets_RU();

        calcAssets.init();
        calcAssets.setVATLogTable(_restoredVATLog);

        return calcAssets;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOutputRun</Name>
				<Source><![CDATA[
    static void updateOutputRun(RAssetId    _assetId, TransDate   _useDate)
    {
        RestoredVATLogTransOper_RU      logTransOper;
        RestoredVATLogTransOperAsset_RU logTransOperAsset;

        TransDate                       dateFrom, dateTo;
        boolean                         updateLogTable;

        [dateFrom, dateTo] = BookDataCalc_RU::datePeriodBook(_useDate);

        RestoredVATLogTable_RU logTable = RestoredVATLogTable_RU::find(dateTo);

        if (!logTable || logTable.Approved)
        {
            return;
        }

        ttsbegin;

        while select forupdate logTransOper
            where logTransOper.TransDate == dateTo      &&
                  logTransOper.Asset     == NoYes::Yes
            join forupdate logTransOperAsset
                where logTransOperAsset.LogTransOperRefRecId == logTransOper.RecId &&
                      logTransOperAsset.AssetId              == _assetId
        {
            BookStructSmallVATAmounts_RU factureAmounts = BookStructSmallVATAmounts_RU::create(logTransOper.FacturedAmounts);
            factureAmounts.addAmounts(-(logTransOperAsset.TaxAmount + logTransOperAsset.AmountLiableToVAT),
                                      -logTransOperAsset.AmountLiableToVAT,
                                      -logTransOperAsset.TaxAmount);
            logTransOper.TaxAmount              -= logTransOperAsset.TaxAmount;
            logTransOper.AmountLiableToVAT      -= logTransOperAsset.AmountLiableToVAT;
            logTransOper.TaxAmountNotLiable     -= logTransOperAsset.TaxAmountNotLiable;
            logTransOper.TaxAmountWrittenOff    -= logTransOperAsset.AmountWrittenOff;
            logTransOper.FacturedAmounts        =  factureAmounts.pack();

            if (logTransOper.TaxAmount           == 0 &&
                logTransOper.AmountLiableToVAT   == 0 &&
                logTransOper.TaxAmountNotLiable  == 0 &&
                logTransOper.TaxAmountWrittenOff == 0)
            {
                logTransOper.delete();
                updateLogTable = true;
            }
            else
            {
                if (RestoredVATLogTrans_RU::find(logTransOper.TransDate, logTransOper.ProcessLogTransRecId))
                {
                    logTransOper.update();
                }
                else
                {
                    logTransOper.doUpdate();
                }
            }

            logTransOperAsset.delete();
        }

        RestoredVATCalcAssets_RU calcAssets = RestoredVATCalcAssets_RU::construct(logTable);
        calcAssets.parmRAssetId(_assetId);
        calcAssets.run();

        updateLogTable = updateLogTable || calcAssets.getUpdateLogTable();

        if (updateLogTable)
        {
            logTable = RestoredVATLogTable_RU::find(dateTo, true);
            logTable.RecalcIndirect = NoYes::Yes;
            logTable.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>