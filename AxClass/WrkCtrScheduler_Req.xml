<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WrkCtrScheduler_Req</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WrkCtrScheduler_Reg</c> class is a processor that is in charge of loading the planned
/// production orders information and feeding them to the scheduling engine.
/// </summary>
/// <remarks>
/// It also writes the results provided by the scheduling engine back to the Microsoft Dynamics AX
/// database.
/// </remarks>
class WrkCtrScheduler_Req extends WrkCtrScheduler
{
    WrkCtrParameters    wrkCtrParameters;
    ReqPlanData         reqPlanData;
    Map                 jobUpdateCache;

    Map                 schedulingPropertiesCache;

    private boolean     isDoNotUsePesimisticLockIfSchedSingleInstanceToggleEnabled;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addInfologMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds an Infolog entry for an order that failed scheduling.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// An instance of the <c>WrkCtrParmSchedule</c> class that contains the order scheduling parameters.
    /// </param>
    /// <param name="_jobSchedulingError">
    /// A <c>WrkCtrJobSchedulingError</c> value that indicates the error to report; optional.
    /// </param>
    /// <param name="_infologMessage">
    /// A string that should be put in the Infolog as error or information.
    /// </param>
    /// <param name="_common">
    /// A <c>Common</c> table buffer that identifies the record that triggered the failure.
    /// </param>
    /// <param name="_throwError">
    /// true if an error should be thrown; false if the message should be added as information.
    /// </param>
    protected void addInfologMessage(WrkCtrParmSchedule         _wrkCtrParmSchedule,
                                     WrkCtrJobSchedulingError   _jobSchedulingError = WrkCtrJobSchedulingError::None,
                                     str                        _infologMessage     = '',
                                     Common                     _common             = null,
                                     boolean                    _throwError         = true)
    {
        if (masterData && masterData.exists(_wrkCtrParmSchedule.schedNumId()))
        {
            ReqTrans reqTrans = masterData.lookup(_wrkCtrParmSchedule.schedNumId());

            setPrefix(fieldLabelValue(tableNum(InventTable), fieldNum(InventTable,ItemId), reqTrans.ItemId));
        }

        super(_wrkCtrParmSchedule,
              _jobSchedulingError,
              strFmt("@SYS134389", _wrkCtrParmSchedule.schedNumId()),
              _common,
              false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToUpdatedOrdersMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a new order to the map of updated orders.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> table buffer that contains all the scheduling parameters needed for
    /// scheduling the order.
    /// </param>
    /// <param name="_order">
    /// The order to add.
    /// </param>
    /// <param name="_bomCalcData">
    /// The BOM data to add.
    /// </param>
    protected void addToUpdatedOrdersMap(WrkCtrParmSchedule             _wrkCtrParmSchedule,
                                         Common                         _order,
                                         BOMCalcData                    _bomCalcData)
    {
        ReqPO                           reqPO;
        ReqJobUpdate                    jobUpdate;
        ReqTrans                        reqTrans = _order as ReqTrans;

        reqPO     = reqTrans.getReqPo(reqPlanData, true);

        if (    !reqPO.RouteJobsUpdated
            ||  reqPO.SchedMethod != _wrkCtrParmSchedule.schedMethod())
        {
            jobUpdate = ReqJobUpdate::newReqPo(reqPO, _bomCalcData, false, jobUpdateCache);

            jobUpdate.parmScheduleAllJobs(_wrkCtrParmSchedule.schedMethod() == SchedMethod::Detail);

            jobUpdate.run();

            if (reqPO.SchedMethod != _wrkCtrParmSchedule.schedMethod())
            {
                reqPO.SchedMethod = _wrkCtrParmSchedule.schedMethod();
                reqPO.update();
            }

            mapUpdatedOrders.insert(reqTrans, _wrkCtrParmSchedule);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>blankRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a blank <c>ProdRoute</c> record.
    /// </summary>
    /// <returns>
    /// A <c>Common</c> table buffer that contains a blank <c>ProdRoute</c> record.
    /// </returns>
    public Common blankRoute()
    {
        ReqRoute    reqRoute;

        return reqRoute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if a planned production order can be scheduled.
    /// </summary>
    /// <param name="_reqTrans">
    ///    A <c>ReqTrans</c> table buffer that contains the planned production order record.
    /// </param>
    /// <returns>
    ///    true if the order meets all requirements to be scheduled; otherwise, false.
    /// </returns>
    protected boolean canSchedule(Common _reqTrans)
    {
        boolean     ret;

        ret = super(_reqTrans);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>capacityRefType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the capacity reservation type.
    /// </summary>
    /// <returns>
    ///    A <c>WrkCtrCapRefType</c> enumeration value with the capacity reservation type.
    /// </returns>
    public WrkCtrCapRefType capacityRefType()
    {
        return WrkCtrCapRefType::PlannedOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Cleans up the order data when a scheduling fails.
    /// </summary>
    /// <param name="_reqTrans">
    ///    A <c>ReqTrans</c> record with the planned production order data.
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that contains the scheduling parameters.
    /// </param>
    protected void cleanUpOrder(Common              _reqTrans,
                                WrkCtrParmSchedule  _wrkCtrParmSchedule)
    {
        ReqTrans reqTrans = _reqTrans as ReqTrans;
        ReqRouteJob reqRouteJob;
        ReqPO       reqPO;

        super(_reqTrans, _wrkCtrParmSchedule);

        if (!mapOrderData.exists(this.keyOrder(reqTrans)))
        {
            reqPO = reqTrans.getReqPo(reqPlanData, true);

            delete_from reqRouteJob
                where   reqRouteJob.ReqPOId     == reqPO.RefId &&
                        reqRouteJob.PlanVersion == reqPO.PlanVersion;

            reqPO.RouteJobsUpdated = NoYes::No;
            reqPO.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBOMCalcData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>BOMCalcData</c> class for a given order.
    /// </summary>
    /// <param name="_order">
    /// The order for which BOM calculation data is needed.
    /// </param>
    /// <returns>
    /// An instance of the <c>BOMCalcData</c> class that is used for runtime computation.
    /// </returns>
    protected BOMCalcData createBOMCalcData(Common _order)
    {
        ReqTrans reqTrans = _order as ReqTrans;

        return BOMCalcData::newInventTable(reqTrans.Qty,InventTable::find(reqTrans.ItemId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTmpRoute</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a temporary <c>ReqRoute</c> route record and returns it as a <c>Common</c> table buffer.
    /// </summary>
    /// <param name="_refId">
    ///    The order ID to create the temporary operation for.
    /// </param>
    /// <returns>
    ///    A <c>Common</c> table buffer that contains the temporary production operation data.
    /// </returns>
    public Common createTmpRoute(InventRefId _refId)
    {
        ReqRoute reqRoute;

        reqRoute.setTmp();
        reqRoute.setTmpData(tmpRoute);
        reqRoute.RefId = _refId;
        reqRoute.doInsert();

        temporaryOperations.add(reqRoute.RecId);

        routeData.insert(this.keyRoute(reqRoute.RefId, reqRoute.OprNum,  RouteOprPriority::Primary), reqRoute);

        return reqRoute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTmpRouteJob</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a temporary production job record and returns it as a <c>Common</c> table buffer.
    /// </summary>
    /// <param name="_refId">
    ///    The order ID to create the temporary job record for.
    /// </param>
    /// <returns>
    ///    A <c>Common</c> table buffer that contains the temporary job information.
    /// </returns>
    public Common createTmpRouteJob(InventRefId _refId)
    {
        ReqRouteJob reqRouteJob;

        reqRouteJob.ReqPOId = _refId;
        reqRouteJob.doInsert();

        jobData.insert(reqRouteJob.RecId, reqRouteJob);

        temporaryJobs.add(reqRouteJob.RecId);

        reqRouteJob.selectForUpdate();

        return reqRouteJob;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTemporaryJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a temporary job.
    /// </summary>
    /// <param name="_recId">
    /// The identifier of the job to delete.
    /// </param>
    protected void deleteTemporaryJob(recId _recId)
    {
        ReqRouteJob  reqRouteJob;

        delete_from reqRouteJob where reqRouteJob.RecId == _recId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findJobWrkCtrParmSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the <c>WrkCtrParmSchedule</c> object for the order that a specific job belongs to.
    /// </summary>
    /// <param name="_jobId">
    ///    A record ID that identifies the job for which the scheduling parameters are being looked up.
    /// </param>
    /// <returns>
    ///    A <c>WrkCtrParmSchedule</c> instance that contains the scheduling parameters for the order of the
    ///    specified job.
    /// </returns>
    protected WrkCtrParmSchedule findJobWrkCtrParmSchedule(recId _jobId)
    {
        ReqRouteJob reqRouteJob;

        reqRouteJob = jobData.lookup(_jobId);

        return masterDataParms.lookup(reqRouteJob.ReqPOId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRefId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a <c>ReqTrans</c> record in the master data.
    /// </summary>
    /// <param name="_refId">
    /// The order ID.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether the record is to be selected for update; optional.
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    /// <returns>
    /// A <c>ReqTrans</c> record that contains the production order data.
    /// </returns>
    protected Common findRefId(InventRefId        _refId,
                               boolean            _forUpdate = false,
                               WrkCtrParmSchedule _wrkCtrParmSchedule = null)
    {
        ReqTrans    reqTrans;

        if (_wrkCtrParmSchedule==null)
        {
            throw error(strfmt("@SYS22828",funcname()));
        }

        select firstonly forupdate reqTrans
               where
                    (
                        reqTrans.RefType                    == ReqRefType::BOMPlannedOrder
                            ||  reqTrans.RefType            == ReqRefType::PmfPlannedProdBatch)
                    &&
                  reqTrans.RefId            == _refId &&
                  reqTrans.PlanVersion      == _wrkCtrParmSchedule.parmReqPlanVersionRefRecId();

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRouteAndOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the route and operation.
    /// </summary>
    /// <param name="_routeJobMap">
    /// The current job.
    /// </param>
    /// <param name="_routeMap">
    /// The current route.
    /// </param>
    /// <param name="_routeOprMap">
    /// The current route operation.
    /// </param>
    /// <returns>
    /// A container that contains the new route and operation.
    /// </returns>
    private container getRouteAndOperation(RouteJobMap _routeJobMap, RouteMap _routeMap, RouteOprMap _routeOprMap)
    {
        RouteMap    routeMap    = _routeMap;
        RouteOprMap routeOprMap = _routeOprMap;
        ReqRoute    reqRoute;

        if (_routeJobMap.OprPriority != RouteOprPriority::Primary || _routeJobMap.NumPrimary != 1)
        {
            reqRoute = _routeJobMap.reqRoute();
            routeMap = reqRoute;
            routeOprMap =  RouteOpr::findRecId(reqRoute.RouteOprRefRecId);
        }

        return [routeMap, routeOprMap];
    }

]]></Source>
			</Method>
			<Method>
				<Name>infologPrefixOprNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the prefix to display in the Infolog specified by the job ID.
    /// </summary>
    /// <param name="_common">
    ///    A <c>Common</c> table buffer that identifies the job for which to compute the message prefix.
    /// </param>
    /// <returns>
    ///    A string value that contains the Infolog prefix.
    /// </returns>
    protected str infologPrefixOprNum(Common _common)
    {
        ReqRouteJob reqRouteJob = _common as ReqRouteJob;
        str         result = '';

        if (reqRouteJob)
        {
            result = strFmt("@SYS302657",
                            reqRouteJob.OprNum,
                            reqRouteJob.OprPriority);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the scheduling engine caches.
    /// </summary>
    public void initCache()
    {
        super();

        schedulingPropertiesCache = new Map(Types::String, Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCapacityReservationData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Fill the capacity reservation record with the appropriate scheduler data.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters.
    /// </param>
    /// <param name="_wrkCtrCapRes">
    ///    A <c>WrkCtrCapRes</c> record that identifies the capacity reservation.
    /// </param>
    /// <param name="_jobId">
    ///    A record ID that identifies the job that the capacity reservation belongs to.
    /// </param>
    protected void initCapacityReservationData(WrkCtrParmSchedule   _wrkCtrParmSchedule,
                                               WrkCtrCapRes         _wrkCtrCapRes,
                                               recId                _jobId)
    {
        ReqRouteJob reqRouteJob;

        reqRouteJob = jobData.lookup(_jobId);

        // set order ID
        _wrkCtrCapRes.RefId           = reqRouteJob.ReqPOId;
        _wrkCtrCapRes.OprNum          = reqRouteJob.OprNum;

        _wrkCtrCapRes.OprPriority     = reqRouteJob.OprPriority;
        _wrkCtrCapRes.JobType         = reqRouteJob.JobType;
        _wrkCtrCapRes.PropertyId      = reqRouteJob.PropertyId;

        if (_wrkCtrParmSchedule.schedMethod() == SchedMethod::Detail)
        {
            _wrkCtrCapRes.JobId       = strFmt('%1',reqRouteJob.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initReqPlanData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the plan data cache.
    /// </summary>
    protected void initReqPlanData()
    {
        if (!reqPlanData || reqPlanData.parmReqPlanVersionRefRecId() != this.parmReqPlanVersionRefRecId())
        {
            reqPlanData = ReqPlanData::newReqPlanVersion(this.parmReqPlanVersionRefRecId());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inputWarehouse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the input warehouse ID for a specific operation record.
    /// </summary>
    /// <param name="_routeMap">
    /// A record that contains the planned production order operation data.
    /// </param>
    /// <returns>
    /// The input warehouse ID assigned to the BOM line connected to the operation.
    /// </returns>
    protected InventLocationIdInput inputWarehouse(RouteMap _routeMap)
    {
        ReqTrans                reqTransDerived;
        BOM                     bom;
        InventLocationIdInput   inputWarehouse = '';
        InventDim               inventDim;
        ReqRoute                reqRoute = _routeMap;

        // for secondary operations nothing is done regarding input warehouse filtering
        if (reqRoute.OprPriority != RouteOprPriority::Primary)
        {
            return '';
        }

        while select forupdate reqTransDerived
            where   reqTransDerived.PlanVersion   == reqRoute.PlanVersion
                &&  reqTransDerived.RefType       == ReqRefType::BOMLine
                &&  reqTransDerived.RefId         == reqRoute.RefId
                &&  (reqTransDerived.OprNum       == reqRoute.OprNum
                ||   (reqTransDerived.OprNum       == 0 &&
                      reqRoute.isFirstOpr()))
        join bom
            where bom.RecId == reqTransDerived.bomRefRecId
        {
            if (bom.WrkCtrConsumption)
            {
                inventDim = InventDim::find(reqTransDerived.CovInventDimId);

                if (inventDim.InventLocationId)
                {
                    if (inputWarehouse &&
                        inventDim.InventLocationId != inputWarehouse)
                    {
                        info(strFmt("@SYS302189",
                                    reqRoute.RefId,
                                    ReqPlanVersion::find(reqRoute.PlanVersion).ReqPlanId));

                        break;
                    }
                    else
                    {
                        inputWarehouse = inventDim.InventLocationId;
                    }
                }
            }
        }

        return inputWarehouse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts order information for scheduling.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters for the order that
    ///    the job belongs to.
    /// </param>
    /// <param name="_reqTrans">
    ///    A <c>ReqTrans</c> table buffer with the planned production order information.
    /// </param>
    /// <param name="_reqTransNext">
    ///    A <c>ReqTrans</c> table buffer with the next planned production order information.
    /// </param>
    /// <param name="_oprNum">
    ///    The number of the operation for the next job.
    /// </param>
    /// <param name="_startCollectRefLevel">
    ///    The BOM level that will be used to determine the job goals.
    /// </param>
    /// <param name="_maxCollectRefLevel">
    ///    The maximal BOM level that will be used to determine the job goals.
    /// </param>
    protected void insertOrder(WrkCtrParmSchedule   _wrkCtrParmSchedule,
                               ReqTrans             _reqTrans,
                               ReqTrans             _reqTransNext,
                               OprNum               _oprNum,
                               BOMLevel             _startCollectRefLevel,
                               BOMLevel             _maxCollectRefLevel = 0)
    {
        // Load data for single planned production order
        masterData.insert(_reqTrans.RefId, _reqTrans);
        
        var wrkCtrParmSchedule = _wrkCtrParmSchedule;

        if (_reqTrans.IsDerivedDirectly)
        {
            wrkCtrParmSchedule = _wrkCtrParmSchedule.clone();
            wrkCtrParmSchedule.schedNumId(_reqTrans.RefId);
            wrkCtrParmSchedule.itemId(_reqTrans.ItemId);
            wrkCtrParmSchedule.parmInventDimId(_reqTrans.CovInventDimId);
		}

        masterDataParms.insert(_reqTrans.RefId, wrkCtrParmSchedule);

        this.loadRoute(wrkCtrParmSchedule, _reqTrans, _reqTrans.inventDim().InventSiteId, _reqTransNext,_oprNum,_reqTrans.Level,_reqTrans.Level);
    }

]]></Source>
			</Method>
			<Method>
				<Name>keyOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a value that can be used in maps that have as a key the production order ID.
    /// </summary>
    /// <param name="_reqTrans">
    ///    A <c>ReqTrans</c> table buffer that contains the production order data.
    /// </param>
    /// <returns>
    ///    A string that contains the production order ID that is used as a key for the speficied production
    ///    order record.
    /// </returns>
    protected str keyOrder(Common _reqTrans)
    {
        ReqTrans reqTrans = _reqTrans as ReqTrans;
        return reqTrans.RefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>leadTimeParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes the lead time parameters for a given order.
    /// </summary>
    /// <param name="_order">
    /// The order for which to retrieve the lead time parameters.
    /// </param>
    /// <returns>
    /// A container that contains the parameters in lead time format.
    /// </returns>
    /// <remarks>
    /// The lead time format uses calendar days.
    /// </remarks>
    protected container leadTimeParameters(Common _order)
    {
        ReqTrans    reqTrans = _order as ReqTrans;
        ReqPO       reqPO = reqTrans.getReqPo(reqPlanData);

        return [reqPO.LeadTime, reqPO.CalendarDays];
    }

]]></Source>
			</Method>
			<Method>
				<Name>limitCapProd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether capacity reservations that are derived from production orders will be included in
    /// the calculation of available capacity when executing scheduling.
    /// </summary>
    /// <param name="_inventDimId">
    /// The <c>InventDimId</c> object specifies the dimension that will be used to look up the parameters.
    /// </param>
    /// <returns>
    /// true if the capacity reservations derived from production orders are considered in the calculation;
    /// otherwise, false.
    /// </returns>
    public boolean limitCapProd(InventDimId _inventDimId)
    {
        return WrkCtrParameters::find().LimitCapPOProd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>limitCapProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether capacity reservations that are derived from project hour forecasts will be
    /// included in the calculation of available capacity when executing scheduling.
    /// </summary>
    /// <param name="_inventDimId">
    /// The <c>InventDimId</c> object identifies the dimension by which to retrieve the option to use the
    /// project hour forecast capacity reservations.
    /// </param>
    /// <returns>
    /// true if the capacity reservations derived from project hour forecasts are considered in the
    /// calculation; otherwise, false.
    /// </returns>
    public boolean limitCapProject(InventDimId _inventDimId)
    {
        return WrkCtrParameters::find().LimitCapPOProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>limitedCapacityToDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes the capacity time fence  for an order and a specific resource.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> object that contains order scheduling parameters.
    /// </param>
    /// <param name="_wrkCtrTable">
    /// A <c>WrkCtrTable</c> record that contains the resource details.
    /// </param>
    /// <param name="_workTimeToDate">
    /// A maximal date up to which limited capacity can be used.
    /// </param>
    /// <returns>
    /// A <c>Date</c> value with the limited capacity fence.
    /// </returns>
    protected TransDate limitedCapacityToDate(WrkCtrParmSchedule    _wrkCtrParmSchedule,
                                               WrkCtrTable           _wrkCtrTable,
                                               TransDate             _workTimeToDate)
    {
        TransDate finiteDate = dateNull();

        if (_wrkCtrParmSchedule.capacityLimited() &&
            _wrkCtrTable.CapLimited)
        {
            finiteDate = _wrkCtrParmSchedule.finiteCapFenceDate();

            if (_wrkCtrParmSchedule.bottleneckCapFenceDate() &&
                _wrkCtrTable.BottleneckResource)
            {
                finiteDate = max(finiteDate, _wrkCtrParmSchedule.bottleneckCapFenceDate());
            }

            // Add one day to use the entire day when calculating with time (ie < 5/2/2008 00:00)
            if ( finiteDate > dateNull() )
            {
                finiteDate = finiteDate + 1;
            }

            finiteDate = min(finiteDate,_workTimeToDate);
        }

        return finiteDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDerived</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the derived requirements.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    /// <param name="_reqTrans">
    /// The <c>ReqTrans</c> record.
    /// </param>
    public void loadDerived(WrkCtrParmSchedule _wrkCtrParmSchedule,
                            ReqTrans           _reqTrans)
    {
        

        ReqTrans            reqTransBOM;
        ReqTrans            reqTransDerived;
        ReqTransCov         reqTransCov;

        while select forupdate reqTransBOM
            where reqTransBOM.PlanVersion            == _reqTrans.PlanVersion            &&
                  reqTransBOM.RefType                == ReqRefType::BOMLine              &&
                  reqTransBOM.RefId                  == _reqTrans.RefId
        {
            if (reqTransBOM.IsDerivedDirectly)
            {
                reqTransCov = reqTransBOM.selectCovJoinTransDerived(true);
                if (reqTransCov.RecId)
                {
                    reqTransDerived = reqTransCov.joinChild();

                    if (reqTransDerived.RefType == ReqRefType::BOMPlannedOrder
                        || reqTransDerived.RefType == ReqRefType::PmfPlannedProdBatch
                        )
                    {
                        OprNum oprNum = reqTransBOM.OprNum;

                        if (!oprNum)
                        {
                            oprNum = this.getFirstOprNum(_reqTrans);
                        }

                        this.insertOrder(   _wrkCtrParmSchedule,
                                            reqTransDerived,
                                            _reqTrans,
                                            oprNum,
                                            _reqTrans.Level,
                                            reqTransBOM.Level);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstOprNum</Name>
				<Source><![CDATA[
    private OprNum getFirstOprNum(ReqTrans _reqTrans)
    {
        ReqRoute reqRoute;

        if (_reqTrans.RefType == ReqRefType::BOMPlannedOrder || _reqTrans.RefType == ReqRefType::PmfPlannedProdBatch)
        {
            select firstonly OprNum from reqRoute
                order by OprNum
                where reqRoute.RefId == _reqTrans.RefId
                   && reqRoute.PlanVersion == _reqTrans.PlanVersion
                   && reqRoute.isFirstOpr();
        }

        return reqRoute.OprNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadJobsDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads job information for the jobs of one operation into the scheduling engine.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> table buffer that contains every scheduling parameter that is needed
    /// for the scheduling of the order.
    /// </param>
    /// <param name="_order">
    /// A record with the data for the order that is being scheduled.
    /// </param>
    /// <param name="_bomCalcData">
    /// A <c>BomCalcData</c> instance to use to calculate the runtime of the job.
    /// </param>
    /// <param name="_routeMap">
    /// A <c>RouteMap</c> map with the operation data.
    /// </param>
    /// <param name="_siteId">
    /// The ID of the site stamped on the order.
    /// </param>
    /// <param name="_orderNext">
    /// A record with the data for the next order.
    /// </param>
    /// <param name="_startCollectRefLevel">
    /// The start BOM level to use to determine the job goals.
    /// </param>
    /// <param name="_maxCollectRefLevel">
    /// The maximal BOM level to use to determine the job goals.
    /// </param>
    /// <param name="_jobNumNextOprFirst">
    /// The record ID of the first job of the next operation.
    /// </param>
    /// <param name="_jobNumNextOprLast">
    /// The record ID of the last job of the next operation.
    /// </param>
    /// <returns>
    /// A container that contains the record IDs for the first and last job.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The resource specified as the target resource for an operation is already in the scheduling for
    /// that operation.
    /// </exception>
    protected container loadJobsDetail(WrkCtrParmSchedule           _wrkCtrParmSchedule,
                                       Common                       _order,
                                       BOMCalcData                  _bomCalcData,
                                       RouteMap                     _routeMap,
                                       InventSiteId                 _siteId,
                                       Common                       _orderNext,
                                       BOMLevel                     _startCollectRefLevel,
                                       BOMLevel                     _maxCollectRefLevel,
                                       recId                        _jobNumNextOprFirst,
                                       recId                        _jobNumNextOprLast)
    {
        ProdJobType                     prodJobType;
        ReqRouteJob                     reqRouteJob;

        SchedJobLink                    primaryLink;
        SchedJobLinkType                primaryLinkType;

        boolean                         isFirstJob = true;

        RouteGroup                      routeGroup;

        str                             sequenceId;
        recId                           jobNum;
        recId                           jobNumPrev;
        recId                           jobNumFirst;

        Map                             mapJobNumPrevNumPrimSec = new Map(Types::String,Types::Int64); //key=numPrimary#numSecondary, value=JobNum
        RouteJobType                    jobTypePrev;
        Map                             jobTimes;
        List                            resourceList;
        MapEnumerator                   mapEnumerator;
        recId                           lastactivityRequirementSetRecId;
        ProdUnitId                      prodUnitId;
        InventLocationIdInput           inputWarehouse;
        recId                           prevReqRouteRecId;
        real                            jobTimeForAllResources;
        Map                             requirementProperties;
        boolean                         useFastSetup;
        real                            primaryJobTime;
        WrkCtrId                        resourceId;

        ReqRoute                        reqRoute;
        RouteOpr                        routeOpr;
        Route                           route;
        WrkCtrRouteOprActivity          wrkCtrRouteOprActivity;
        WrkCtrActivityRequirementSet    wrkCtrActivityRequirementSet;
        ReqTrans                        reqTrans = _order as ReqTrans;

        // Local cache of property information and applicable resources.
        Map                             mapOprPriorityToRequirementProperties = new Map(Types::Enum, Types::Class);

        RouteJobNumType                 prevNumType = -1;
        RecId                           primaryJobRecId;

        container                       keyContainer;
        Map                             mapPrimaryRouteJobToJobTimes = new Map(Types::Container, Types::Container);

        this.initParallelJobsMap();

        //Loop through all jobs in the operation
        while select forupdate reqRouteJob
            order by PlanVersion, ReqPOId, OprNum, NumType, NumPrimary, OprPriority, NumSecondary, RecId
            where reqRouteJob.PlanVersion   == _routeMap.PlanVersion  &&
                  reqRouteJob.ReqPOId       == _routeMap.RefId      &&
                  reqRouteJob.OprNum        == _routeMap.OprNum
        join reqRoute
            where   reqRoute.PlanVersion    == reqRouteJob.PlanVersion
            &&      reqRoute.OprNum         == reqRouteJob.OprNum
            &&      reqRoute.OprPriority    == reqRouteJob.OprPriority
            &&      reqRoute.RefId          == reqRouteJob.ReqPOId
        join route
            where route.RecId == reqRoute.RouteRefRecId
        join routeOpr
            where routeOpr.RecId == reqRoute.RouteOprRefRecId
        join wrkCtrRouteOprActivity
            where   wrkCtrRouteOprActivity.RouteOpr             == reqRoute.RouteOprRefRecId
            &&      wrkCtrRouteOprActivity.RouteOprDataAreaId   == routeOpr.DataAreaId
        join wrkCtrActivityRequirementSet
            where wrkCtrActivityRequirementSet.Activity         == wrkCtrRouteOprActivity.Activity
        join routeGroup
            where routeGroup.RouteGroupId == routeOpr.RouteGroupId
        {
            //Identifiers for this job
            sequenceId = reqTrans.RefId;
            jobNum = reqRouteJob.RecId;

            this.addJobToOverlapJobList(reqRouteJob, reqRoute.OprNumNext);

            prodJobType    = ProdJobType::construct(reqRouteJob.JobType);

            // Overlap job need to run backward scheduling again as it may cause big overlap time between jobs
            if (reqRouteJob.JobType == RouteJobType::Overlap)
            {
                this.parmHasOverlapJob(true);
            }

            this.updateRequirementSetAndPropertiesMaps(mapOprPriorityToRequirementProperties,
                                                       reqRouteJob,
                                                       wrkCtrActivityRequirementSet,
                                                       _siteId,
                                                       _wrkCtrParmSchedule.schedMethod());

            requirementProperties = mapOprPriorityToRequirementProperties.lookup(reqRouteJob.OprPriority);

            [prevReqRouteRecId, prodUnitId, inputWarehouse] = this.getProductionUnitAndWarehouse(
                                                                                                 reqRoute.RecId,
                                                                                                 prevReqRouteRecId,
                                                                                                 _wrkCtrParmSchedule,
                                                                                                 prodUnitId,
                                                                                                 inputWarehouse,
                                                                                                 reqRoute);

            // Fast setup applies when
            // - scheduling is executed with infinite capacity
            // - only site and resource group requirements exists
            // - the job is not locked
            // - job scheduling is used
            // - runtimes are resource independent (formula0)
            // - not doing property limited scheduling

            useFastSetup = !_wrkCtrParmSchedule.capacityLimited() &&
                           !_wrkCtrParmSchedule.propertyLimited() &&
                           (_wrkCtrParmSchedule.schedMethod() == SchedMethod::Detail) &&
                           this.requirementsAllowFastSetup(requirementProperties) &&
                           prodJobType.isWrkCtrHoursResourceIndependent(routeOpr);

            if (useFastSetup)
            {
                if (reqRouteJob.OprPriority == RouteOprPriority::Primary && reqRouteJob.NumPrimary == 1)
                {
                    jobTimeForAllResources = this.computeJobTime(_wrkCtrParmSchedule,
                                                                 reqRouteJob,
                                                                 route,
                                                                 routeOpr,
                                                                 reqRouteJob.JobType,
                                                                 _bomCalcData,
                                                                 true,
                                                                 prodJobType,
                                                                 false,
                                                                 reqTrans.ItemId,
                                                                 reqTrans.CovInventDimId);
                    primaryJobTime = jobTimeForAllResources;
                }
                else
                {
                    jobTimeForAllResources = primaryJobTime;
                }
            }
            else
            {
                // only get the resource list if the requirement activity set has changed
                if (lastactivityRequirementSetRecId != wrkCtrActivityRequirementSet.RecId || !resourceList)
                {
                    resourceList = wrkCtrApplicableResourceListCache.applicableResourceList(wrkCtrActivityRequirementSet,
                                                                                            _siteId,
                                                                                            _wrkCtrParmSchedule.todaysdate(),
                                                                                            _wrkCtrParmSchedule.schedMethod()==SchedMethod::Detail,
                                                                                            _wrkCtrParmSchedule.schedMethod()==SchedMethod::Rough,
                                                                                            _wrkCtrParmSchedule.schedMethod()==SchedMethod::Rough);

                    // operations scheduling is done on resource groups
                    if (_wrkCtrParmSchedule.schedMethod()==SchedMethod::Rough)
                    {
                         // operations scheduling with specific resource requirement
                        resourceId = this.getResourceRequirement(requirementProperties);
                        if (resourceId != '')
                        {
                            resourceList.addEnd(resourceId);
                        }
                    }

                    lastactivityRequirementSetRecId = wrkCtrActivityRequirementSet.RecId;

                    if (resourceList.elements() == 0)
                    {
                        this.addInfologMessage(_wrkCtrParmSchedule,
                                               WrkCtrJobSchedulingError::NoMatchingResources,
                                               '',
                                               reqRouteJob);
                    }

                    this.checkForHighNumberOfResourceCombinations(_wrkCtrParmSchedule,
                                                                  wrkCtrActivityRequirementSet,
                                                                  resourceList);
                }

                if (reqRouteJob.OprPriority == RouteOprPriority::Primary)
                {
                    // Set common values for all parallel jobs
                    prodJobType    = ProdJobType::construct(reqRouteJob.JobType);
                    keyContainer   = [reqRouteJob.NumType, resourceList.pack()];

                    if (!mapPrimaryRouteJobToJobTimes.exists(keyContainer))
                {
                    jobTimes = this.computeJobTimes(_wrkCtrParmSchedule,
                                                    reqRouteJob,
                                                    route,
                                                    routeOpr,
                                                    reqRouteJob.JobType,
                                                    resourceList,
                                                    _bomCalcData,
                                                    true,
                                                    prodJobType,
                                                    false,
                                                    reqTrans.ItemId,
                                                        reqTrans.CovInventDimId,
                                                        wrkCtrActivityRequirementSet.Quantity);

                        mapPrimaryRouteJobToJobTimes.insert(keyContainer, jobTimes.pack());
                    }
                    else
                    {
                        jobTimes = Map::create(mapPrimaryRouteJobToJobTimes.lookup(keyContainer));
                    }

                    primaryJobTime = 0;
                    if (jobTimes.elements() > 0)
                    {
                        primaryJobTime = realMax();
                        mapEnumerator = jobTimes.getEnumerator();
                        while (mapEnumerator && mapEnumerator.moveNext())
                        {
                            if (primaryJobTime > mapEnumerator.currentValue())
                            {
                                primaryJobTime = mapEnumerator.currentValue();
                            }
                        }
                    }
                }
                else
                {
                    jobTimes = this.fixedJobTimesForResources(resourceList,
                                                              primaryJobTime);
                }
            }

            if (reqRouteJob.NumType != prevNumType)
            {
                primaryJobRecId = reqRouteJob.RecId;
                prevNumType     = reqRouteJob.NumType;
            }

            [primaryLink, primaryLinkType, jobNumFirst, isFirstJob, jobNumPrev, jobTypePrev] = this.insertJobAndConstraints(
                                                                                                                            reqRouteJob,
                                                                                                                            _wrkCtrParmSchedule,
                                                                                                                            prodUnitId,
                                                                                                                            inputWarehouse,
                                                                                                                            requirementProperties,
                                                                                                                            jobTimes,
                                                                                                                            wrkCtrActivityRequirementSet,
                                                                                                                            reqRoute.OprNumNext,
                                                                                                                            prodJobType,
                                                                                                                            routeGroup,
                                                                                                                            this.computeJobGoal(_wrkCtrParmSchedule),
                                                                                                                            useFastSetup,
                                                                                                                            jobTimeForAllResources,
                                                                                                                            jobNumPrev,
                                                                                                                            mapJobNumPrevNumPrimSec,
                                                                                                                            resourceList,
                                                                                                                            isFirstJob,
                                                                                                                            jobTypePrev,
                                                                                                                            primaryLink,
                                                                                                                            primaryLinkType,
                                                                                                                            jobNumFirst,
                                                                                                                            primaryJobRecId);
        }

        // insert constraints for parallel jobs for a specific job type
        this.insertParallelJobsConstraints(jobTypePrev,
                                           _jobNumNextOprFirst,
                                           SchedJobLink::FS,
                                           primaryLinkType,
                                           _wrkCtrParmSchedule.schedMethod());

        //Return the first job and last job of this operation, which will be used in the next loop
        //for linking the previous operation to this operation
        return [jobNumFirst, jobNum];
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads data for one order that is scheduled.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> record that contains order scheduling parameters.
    /// </param>
    /// <param name="_reqTrans">
    /// A <c>ReqTrans</c> record that contains the production order data.
    /// </param>
    protected void loadOrder(WrkCtrParmSchedule _wrkCtrParmSchedule,
                             Common             _reqTrans)
    {
        ReqTrans reqTrans = _reqTrans as ReqTrans;
        super(_wrkCtrParmSchedule, _reqTrans);

        this.initReqPlanData();

        this.insertOrder(_wrkCtrParmSchedule, reqTrans, null, 0, reqTrans.Level);

        if (_wrkCtrParmSchedule.schedReference() )
        {
            this.loadDerived(_wrkCtrParmSchedule, reqTrans);
        }

        if (isDoNotUsePesimisticLockIfSchedSingleInstanceToggleEnabled)
        {
            wrkCtrCapResHandler.parmUsePessimisticReadLock(_wrkCtrParmSchedule.schedMethod() == SchedMethod::Rough
                                                       && this.parmIsRunningMultipleWrkCtrSchedulerInstances()
                                                       && ReqParameters::find().AccurateOpSchedFiniteCapacity);
        }
        else 
        {
            wrkCtrCapResHandler.parmUsePessimisticReadLock(_wrkCtrParmSchedule.schedMethod() == SchedMethod::Rough
                                                       && this.parmIsRunningMultipleWrkCtrSchedulerInstances()
                                                       && ReqParameters::find().AccurateOpSchedFiniteCapacity);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        this.parmRouteRefIdField(fieldNum(ReqRoute, RefId ));
        this.parmRefIdField(fieldNum(ReqTrans, RefId));
        this.parmRouteOprNumField(fieldNum(ReqRouteJob, OprNum));

        jobUpdateCache = new Map(Types::String, Types::Class);
        usePlanVersion = true;

        isDoNotUsePesimisticLockIfSchedSingleInstanceToggleEnabled =
            WrkCtrSchedReqDoNotUsePesimisticLockIfSchedSingleInstanceToggle::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processLastJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a constraint on the last job.
    /// </summary>
    /// <param name="_order">
    /// A record with the data for the order begin scheduled.
    /// </param>
    /// <param name="_jobNumRouteLast">
    /// The ID of the last job of the route.
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters.
    /// </param>
    /// <param name="_refIdOrig">
    /// The original order ID.
    /// </param>
    /// <param name="_startCollectRefLevel">
    /// A starting route level determining the order of the operations.
    /// </param>
    /// <param name="_maxCollectRefLevel">
    /// A maximal route level determining the order of the operations.
    /// </param>
    /// <param name="_currentCollectRefLevel">
    /// A current route level.
    /// </param>
    protected void processLastJob(Common                _order,
                                  RecId                 _jobNumRouteLast,
                                  WrkCtrParmSchedule    _wrkCtrParmSchedule,
                                  InventRefId           _refIdOrig,
                                  BOMLevel              _startCollectRefLevel,
                                  BOMLevel              _maxCollectRefLevel,
                                  BOMLevel              _currentCollectRefLevel
                                  )
    {
        ReqTrans    reqTrans = _order;
        ReqTransCov reqTransCov;
        ReqTrans    reqTransIssue;
        ReqDate     maxIssueNeededDate;
        ReqDate     maxReceiptEndDate;
        RecId       emptyJobRecId;

        if (!_jobNumRouteLast)
        {
            return;
        }

        if (reqTrans.PdsExpiryDate)
        {
            // Find the maximum needed date (ReqDate + pdsSellableDays) of the issues that this receipt is used for
            while select reqTransIssue
                exists join ReqTransCov
                    where reqTransIssue.RecId      == reqTransCov.IssueRecId
                       && reqTransCov.ReceiptRecId == reqTrans.RecId
            {
                maxIssueNeededDate = max(maxIssueNeededDate, reqTransIssue.pdsNeedByDate());
            }

            if (maxIssueNeededDate)
            {
                maxReceiptEndDate = maxIssueNeededDate - reqTrans.inventTable().pdsExpiryDays();
                if (maxReceiptEndDate < reqPlanData.todaysdate())
                {
                    maxReceiptEndDate = reqPlanData.todaysdate();
                }

                // Create a job with zero time having a EndStart link to the last job
                emptyJobRecId = this.insertEmptyJob(_wrkCtrParmSchedule, _refIdOrig, _startCollectRefLevel, _currentCollectRefLevel, maxReceiptEndDate);

                if (WrkCtrSchedulerReqShelfLifeJobAfterLastJobToggle::instance().isEnabled())
                {
                    //The planned order should be ended not earlier than the maxReceiptEndDate date. Otherwise the item from the planned order will expire before the demand.
                    //Since there is no EndAfter job constraint, create a new job with zero time having a EndStart Hard link afther the last job.
                    //Set the StartAfter constaint for the new job with the maxReceiptEndDate value.
                    scheduleEngine.addJobLink(_jobNumRouteLast, emptyJobRecId, any2int(SchedJobLink::FS), any2int(SchedJobLinkType::Hard));
                }
                else
                {
                    scheduleEngine.addJobLink(emptyJobRecId, _jobNumRouteLast, any2int(SchedJobLink::FS), any2int(SchedJobLinkType::Soft));
                }

            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refLineType</Name>
				<Source><![CDATA[
    /// <summary>
    /// The reference line type that is on a <c>ReqTrans</c> record for the current order.
    /// </summary>
    /// <param name="_order">
    /// A record that contains the data for the order that is being scheduled.
    /// </param>
    /// <returns>
    /// A <c>ReqRefType</c> enumeration value.
    /// </returns>
    protected ReqRefType refLineType(
        Common _order
        )
    {
        ReqTrans reqTrans = _order;

        if (reqTrans.inventTable().isFormulaAllowed())
        {
            return ReqRefType::PmfFormulaLine;
        }
        else
        {
            return ReqRefType::BOMLine;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refId</Name>
				<Source><![CDATA[
    protected InventTransRefId refId(WrkCtrParmSchedule	_wrkCtrParmSchedule, Common _order)
    {
        ReqTrans reqTrans = _order;

        return reqTrans.RefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveDerived</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves derived planned orders.
    /// </summary>
    /// <param name="_reqTrans">
    /// A <c>ReqTrans</c> record that contains the order master data.
    /// </param>
    /// <param name="_updateReqDateDlv">
    /// A Boolean value that indicates whether the <c>ReqDateDlv</c> object should be updated.
    /// </param>
    /// <param name="_fromDate">
    /// The start date.
    /// </param>
    /// <param name="_fromTime">
    /// The start time.
    /// </param>
    /// <param name="_toDate">
    /// The end date.
    /// </param>
    /// <param name="_toTime">
    /// The end time.
    /// </param>
    /// <param name="_reqPO">
    /// The planned order.
    /// </param>
    public void saveDerived(    ReqTrans    _reqTrans,
                                boolean     _updateReqDateDlv,
                                SchedDate   _fromDate,
                                SchedTime   _fromTime,
                                SchedDate   _toDate,
                                SchedTime   _toTime,
                                ReqPO       _reqPO
                            )
    {
        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::WrkCtrSchedulerSaveDerived, 'Saving derived');

        WrkCtrScheduler_Req::saveDerivedTransactions(reqPlanData, _reqTrans, _updateReqDateDlv, _fromDate, _fromTime, _toDate, _toTime, _reqPO);

        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::WrkCtrSchedulerSaveDerived, 'Saved derived');
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the scheduling results for an operation to the database.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    /// <param name="_reqRoute">
    /// A <c>ReqRoute</c> table buffer that contains the operation record.
    /// </param>
    /// <param name="_operationData">
    /// A container that contains the start and end dates for the operation.
    /// </param>
    protected void saveOperation(WrkCtrParmSchedule _wrkCtrParmSchedule,
                                 Common             _reqRoute,
                                 container          _operationData)
    {
        ReqRoute        reqRoute = _reqRoute as ReqRoute;
        SchedFromDate   prodFromDate;
        SchedFromTime   prodFromTime;
        SchedToDate     prodToDate;
        SchedToTime     prodToTime;

        SchedFromDate   fromDate;
        SchedFromTime   fromTime;
        SchedToDate     toDate;
        SchedToTime     toTime;

        super(_wrkCtrParmSchedule,_reqRoute,_operationData);

        [fromDate, fromTime, toDate, toTime] = _operationData;

        // Aggregate times on production level
        if (!mapOrderData.exists(_wrkCtrParmSchedule.schedNumId()))
        {
            prodFromDate = fromDate;
            prodFromTime = fromTime;
            prodToDate = toDate;
            prodToTime = toTime;
        }
        else
        {
            [prodFromDate, prodFromTime, prodToDate, prodToTime] = mapOrderData.lookup(_wrkCtrParmSchedule.schedNumId());

            if ((fromDate < prodFromDate) || (fromDate == prodFromDate && fromTime < prodFromTime))
            {
                prodFromDate = fromDate;
                prodFromTime = fromTime;
            }

            if ((toDate > prodToDate) || (toDate == prodToDate && toTime > prodToTime))
            {
                prodToDate = toDate;
                prodToTime = toTime;
            }
        }

        mapOrderData.insert(_wrkCtrParmSchedule.schedNumId(),
                            [prodFromDate,prodFromTime,prodToDate, prodToTime]);

        if (!temporaryOperations.in(reqRoute.RecId))
        {
            reqRoute.FromDate  = fromDate;
            reqRoute.FromTime  = this.schedStatus(_wrkCtrParmSchedule) == ProdSchedStatus::OperationScheduled? 0 : fromTime;
            reqRoute.ToDate    = toDate;
            reqRoute.ToTime    = this.schedStatus(_wrkCtrParmSchedule) == ProdSchedStatus::OperationScheduled? 0 : toTime;

            reqRoute.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the scheduling results for a production order.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    /// <param name="_reqTrans">
    /// A <c>ReqTrans</c> table buffer that contains the order master data.
    /// </param>
    /// <param name="_orderData">
    /// A container with the start and end dates for the order.
    /// </param>
    protected void saveOrder(WrkCtrParmSchedule _wrkCtrParmSchedule,
                             Common             _reqTrans,
                             container          _orderData)
    {
        ReqTrans            reqTrans = _reqTrans as ReqTrans;
        SchedDate           fromDate;
        SchedTime           fromTime;
        SchedDate           toDate;
        SchedTime           toTime;

        boolean             updateReqFuturesDate;

        ReqSetup            setup;
        ReqSetupDim         setupDim;

        ReqPO               reqPO;
        ReqTrans            reqTransExtern          = _wrkCtrParmSchedule.reqTransExtern();
        ReqPO               reqPoExtern             = _wrkCtrParmSchedule.reqPoExtern();
        WorkCalendarSched   workCalendarSched       = new WorkCalendarSched();

        super(_wrkCtrParmSchedule, _reqTrans, _orderData);

        [fromDate, fromTime, toDate, toTime] = _orderData;

        setup = reqPlanData.newReqSetup(reqTrans.ItemId);
        setupDim = reqPlanData.newReqSetupDim(setup, reqTrans.CovInventDimId);

        reqPO = reqTrans.getReqPo(reqPlanData, true);
        if (!reqPO.RecId)
        {            
            reqPO.insertFromReqTrans(reqTrans, setup, setupDim);
        }

        updateReqFuturesDate        = _wrkCtrParmSchedule.updateReqFuturesDate();

        reqPO.SchedFromDate         = fromDate;
        reqPO.SchedToDate           = toDate;
        reqPO.ReqDate               = workCalendarSched.schedDate(SchedDirection::Forward,
                                                                  reqPO.SchedToDate,
                                                                  setupDim.marginReceipt(),
                                                                  ReqParameters::find().marginCalendarDays,
                                                                  setupDim.reqCalendarId());

        reqPO.ReqTime               = toTime;
        reqPO.ReqDateOrder          = workCalendarSched.schedDate(SchedDirection::Backward,
                                                                  reqPO.SchedFromDate,
                                                                  setupDim.marginOrder(),
                                                                  ReqParameters::find().marginCalendarDays,
                                                                  setupDim.reqCalendarId());

        reqPO.ReqTimeOrder          = fromTime;

        //If scheduling start date is not allowed to be earlier than today, then adjust the order date to the current day.
        if (!reqPO.allowsSchedulingStartDateBeforeToday(reqPlanData, setupDim)
                             && reqPO.ReqDateOrder < reqPlanData.todaysdate())
        {
            reqPO.ReqDateOrder = reqPlanData.todaysdate();
            reqPO.ReqTimeOrder = reqPlanData.reqTimePoDefault();
        }
        reqPO.ReqDateDlv            = reqPO.SchedToDate;

        // routeless job, need schedule deliery date to working day
        if (routeLessRecordSet && routeLessRecordSet.in(_reqTrans.RecId))
        {
            reqPO.ReqDateDlv = workCalendarSched.schedDate(_wrkCtrParmSchedule.schedDirection(),
                                                          reqPO.ReqDateDlv,
                                                          0,
                                                          setupDim.leadTimeCalendarDays(reqPO.RefType),
                                                          setupDim.reqCalendarId());
        }

        if (this.capacityTypeReservation(_wrkCtrParmSchedule) == WrkCtrCapacityType::OperationSched && reqPO.RouteJobsUpdated)
        {
            reqPO.RouteJobsUpdated = NoYes::No;

            ReqRouteJob::deletePO(reqTrans.PlanVersion,reqTrans.RefId);
        }

        reqTrans.ReqDate            = reqPO.ReqDate;
        reqTrans.ReqTime            = reqPO.ReqTime;

        // If an expiry date has already been applied then it must be updated based on the new requirement (=inventory) date
        if (reqTrans.PdsExpiryDate)
        {
            reqTrans.PdsExpiryDate = reqTrans.inventTable().pdsEffectExpiryDate(reqTrans.ReqDate);
        }

        if (updateReqFuturesDate)
        {
            reqTrans.FuturesDate        = toDate;
            reqTrans.FuturesTime        = toTime;
            reqTrans.FuturesDate        = workCalendarSched.schedDate(SchedDirection::Forward,
                                                                      reqTrans.FuturesDate,
                                                                      0,
                                                                      ReqParameters::find().marginCalendarDays,
                                                                      setupDim.reqCalendarId());
            reqTrans.FuturesCalculated  = NoYes::Yes;
        }

        this.updateBOMLineInputWarehouse(reqTrans);

        this.saveDerived(reqTrans,
                         _wrkCtrParmSchedule.updateReqDateDlv(),
                         fromDate,
                         fromTime,
                         toDate,
                         toTime,
                         reqPO );

        reqPO.doUpdate();
        reqTrans.update();

        if (reqTrans.RefType == ReqRefType::PmfPlannedProdBatch)
        {
            reqTrans.pmfUpdateCoProductDates();
        }

        if (reqTransExtern.RecId == reqTrans.RecId)
        {
            reqTransExtern.data(reqTrans);
        }

        if (reqPoExtern.RecId == reqPO.RecId)
        {
            reqPoExtern.data(reqPO);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedulingProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the scheduling properties for a given activity requirement set, site and scheduling
    /// method.
    /// </summary>
    /// <param name="_wrkCtrActivityRequirementSet">
    /// A <c>WrkCtrActivityRequirementSet</c> record that contains the activity requirement set data.
    /// </param>
    /// <param name="_siteId">
    /// The site ID.
    /// </param>
    /// <param name="_schedMethod">
    /// The scheduling method.
    /// </param>
    /// <returns>
    /// A map that contains the scheduling properties.
    /// </returns>
    protected Map schedulingProperties(WrkCtrActivityRequirementSet    _wrkCtrActivityRequirementSet,
                                        InventSiteId                    _siteId,
                                        SchedMethod                     _schedMethod)
    {
        str propertiesCacheKey;
        Map properties;

        propertiesCacheKey = strFmt('%1#%2#%3', _wrkCtrActivityRequirementSet.RecId, _siteId, _schedMethod);
        if (schedulingPropertiesCache.exists(propertiesCacheKey))
        {
            properties = schedulingPropertiesCache.lookup(propertiesCacheKey);
        }
        else
        {
            properties = _wrkCtrActivityRequirementSet.schedulingProperties(_siteId, _schedMethod == SchedMethod::Detail, _schedMethod ==SchedMethod::Rough);
            schedulingPropertiesCache.insert(propertiesCacheKey, properties);
        }

        return properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReqPlanData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets a <c>ReqPlanData</c> object that can be used as an item coverage cache.
    /// </summary>
    /// <param name="_reqPlanData">
    /// The <c>ReqPlanData</c> object that can be used as an item coverage cache.
    /// </param>
    public void setReqPlanData(ReqPlanData _reqPlanData)
    {
        reqPlanData = _reqPlanData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferBatchTimeToProcessTimeRatio</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the ratio between the time that is required to process one transferrable batch and the
    /// total time of the specified operation.
    /// </summary>
    /// <param name="_operationReference">
    /// A record that contains a reference to the operation for which to calculate the ratio.
    /// </param>
    /// <param name="_order">
    /// The order to which the operation belongs.
    /// </param>
    /// <returns>
    /// The ratio between the time that is required to process one transferrable batch and the total time
    /// of the specified operation; otherwise, 1.
    /// </returns>
    /// <remarks>
    /// If there is no transfer batch quantity on the specified operation, the return value will be 1.
    /// </remarks>
    protected real transferBatchTimeToProcessTimeRatio(RouteMap _operationReference, Common _order)
    {
        ReqTrans reqTrans;
        ReqRoute reqRoute;
        RouteOpr routeOpr;

        reqTrans = _order as ReqTrans;

        select firstonly RouteOprRefRecId from reqRoute
            where   reqRoute.RefId          == _operationReference.RefId
                &&  reqRoute.PlanVersion    == _operationReference.PlanVersion
                &&  reqRoute.OprNum         == _operationReference.OprNum
                &&  reqRoute.OprPriority    == RouteOprPriority::Primary
            join TransferBatch from routeOpr
                where routeOpr.RecId == reqRoute.RouteOprRefRecId;

        if (!reqTrans || !routeOpr)
        {
            throw error("@SCM:PlannedProductChangeError");
        }

        if (    routeOpr.TransferBatch <= 0
            ||  routeOpr.TransferBatch >= reqTrans.Qty
            ||  reqTrans.Qty == 0)
        {
            return 1;
        }

        return routeOpr.TransferBatch / reqTrans.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBOMLineInputWarehouse</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the picking warehouse on the bills of material (BOM) lines with the input warehouses of the
    ///    selected resources.
    /// </summary>
    /// <param name="_reqTrans">
    ///    A <c>ReqTrans</c> record that contains the order information.
    /// </param>
    protected void updateBOMLineInputWarehouse(ReqTrans _reqTrans)
    {
        InventDim               inventDim;
        WrkCtrResourceGroup     wrkCtrResourceGroup;
        ReqTrans                reqTransDerived;
        ReqRoute                reqRoute;
        BOM                     bom;
        InventLocationIdInput   inputWarehouse;
        TransDate               startDate;
        timeOfDay               startTime;
        TransDate               endDate;
        timeOfDay               endTime;
        WrkCtrId                resourceId;
        ReqSetup                setup;

        // Loop through BOM lines to set the picking warehouse
        while select forupdate reqTransDerived
            where   reqTransDerived.PlanVersion     == _reqTrans.PlanVersion
                &&  (reqTransDerived.RefType        == ReqRefType::BOMLine
                ||   reqTransDerived.RefType        == ReqRefType::PmfFormulaLine)
                &&  reqTransDerived.RefId           == _reqTrans.RefId
        join bom
            where   reqTransDerived.bomRefRecId     == bom.RecId
                &&  bom.WrkCtrConsumption           == NoYes::Yes
        {
            setup  = reqPlanData.newReqSetup(reqTransDerived.ItemId);
            if (!setup.isInventLocationNotCovPlanned())
            {
                while select reqRoute
                    order by OprNum
                where   reqRoute.RefId              == _reqTrans.RefId
                    &&  reqRoute.PlanVersion        == _reqTrans.PlanVersion
                    &&  (reqRoute.OprNum            == reqTransDerived.OprNum
                    ||   reqTransDerived.OprNum     == 0)
                {
                    if (    reqRoute.OprNum         == reqTransDerived.OprNum
                        ||  (reqTransDerived.OprNum == 0
                        &&   reqRoute.isFirstOpr()))
                    {
                        if (mapOperationData.exists(this.keyRoute(reqRoute.RefId, reqRoute.OprNum, reqRoute.OprPriority)))
                        {
                            [startDate, startTime, endDate, endTime, resourceId] = mapOperationData.lookup(this.keyRoute(reqRoute.RefId, reqRoute.OprNum, reqRoute.OprPriority));
                            wrkCtrResourceGroup = WrkCtrTable::resourceGroup(resourceId,
                                                                             startDate,
                                                                             startDate);
                            if (wrkCtrResourceGroup)
                            {
                                // update the picking warehouse
                                inputWarehouse = wrkCtrResourceGroup.inputInventLocationIdFallback();

                                inventDim = InventDim::find(reqTransDerived.CovInventDimId);
                                if (inputWarehouse != inventDim.InventLocationId)
                                {
                                    inventDim.InventLocationId = inputWarehouse;
                                    reqTransDerived.CovInventDimId = InventDim::findOrCreate(inventDim).InventDimId;
                                    reqTransDerived.update();
                                }

                                break;
                            }
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static WrkCtrScheduler_Req construct()
    {
        return new WrkCtrScheduler_Req();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCheckLockingTTSLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>WrkCtrScheduler_Req</c> class.
    /// </summary>
    /// <param name="_checkLockingTTSLevel">
    /// A Boolean value that indicates whether the TTS level check is performed when locking is performed
    /// for capacity reservations saving.
    /// </param>
    /// <returns>
    /// A new <c>WrkCtrScheduler_Req</c> instance.
    /// </returns>
    public static WrkCtrScheduler_Req newCheckLockingTTSLevel(boolean _checkLockingTTSLevel = true)
    {
        WrkCtrScheduler_Req scheduler = new WrkCtrScheduler_Req();

        scheduler.parmCheckLockingTTSLevel(_checkLockingTTSLevel);

        return scheduler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveDerivedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates derived requirement transactions.
    /// </summary>
    /// <param name="_reqPlanData">
    /// The plan settings.
    /// </param>
    /// <param name="_reqTrans">
    /// A <c>ReqTrans</c> record that contains the order master data.
    /// </param>
    /// <param name="_updateReqDateDlv">
    /// A Boolean value that indicates whether the <c>ReqDateDlv</c> object should be updated.
    /// </param>
    /// <param name="_fromDate">
    /// The start date.
    /// </param>
    /// <param name="_fromTime">
    /// The start time.
    /// </param>
    /// <param name="_toDate">
    /// The end date.
    /// </param>
    /// <param name="_toTime">
    /// The end time.
    /// </param>
    /// <param name="_reqPO">
    /// The planned order.
    /// </param>
    public static void saveDerivedTransactions(
                    ReqPlanData _reqPlanData,
                    ReqTrans    _reqTrans,
                    boolean     _updateReqDateDlv,
                    SchedDate   _fromDate,
                    SchedTime   _fromTime,
                    SchedDate   _toDate,
                    SchedTime   _toTime,
                    ReqPO       _reqPO)
    {
        ReqTrans            reqTransDerived;
        ReqSetup            setup;
        ReqSetupDim         setupDim;
        ReqRoute            reqRoute;
        ReqTrans            reqTransChild;
        ReqPO               reqPoChild;
        WorkCalendarSched   workCalendarSched  = new WorkCalendarSched();
        CalendarDays        marginCalendarDays = ReqParameters::find().MarginCalendarDays;

        while select forupdate reqTransDerived
            where reqTransDerived.PlanVersion  == _reqTrans.PlanVersion   &&
                  (
                  reqTransDerived.RefType      == ReqRefType::BOMLine
                    || reqTransDerived.RefType      == ReqRefType::PmfFormulaLine)
                  && reqTransDerived.RefId        == _reqTrans.RefId
            outer join reqRoute
                    where reqRoute.PlanVersion   == reqTransDerived.PlanVersion &&
                          reqRoute.RefId       == reqTransDerived.RefId &&
                          reqRoute.OprNum      == reqTransDerived.OprNum &&
                          reqRoute.OprPriority == RouteOprPriority::Primary
        {
            setup           = _reqPlanData.newReqSetup(reqTransDerived.ItemId);
            setupDim        = _reqPlanData.newReqSetupDim(setup, reqTransDerived.CovInventDimId);

            if (reqTransDerived.Qty >= 0)
            {
                Days marginReceipt;

                marginReceipt = _reqPlanData.marginReceipt(setupDim);

                if (reqTransDerived.OprNum && reqRoute)
                {
                    if (_updateReqDateDlv)
                        reqTransDerived.ReqDateDlvOrig  = reqRoute.ToDate;

                    reqTransDerived.ReqDate     = workCalendarSched.schedDate(SchedDirection::Forward,
                                                                              reqRoute.ToDate,
                                                                              marginReceipt,
                                                                              marginCalendarDays,
                                                                              setupDim.reqCalendarId());

                    reqTransDerived.ReqTime     = reqRoute.ToTime;
                }
                else
                {
                    if (_updateReqDateDlv)
                        reqTransDerived.ReqDateDlvOrig     = _toDate;

                    reqTransDerived.ReqDate     = workCalendarSched.schedDate(SchedDirection::Forward,
                                                                              _toDate,
                                                                              marginReceipt,
                                                                              marginCalendarDays,
                                                                              setupDim.reqCalendarId());
                    reqTransDerived.ReqTime     = _toTime;
                }
            }
            else
            {
                Days marginIssue;
                
                marginIssue = _reqPlanData.marginIssue(setupDim);

                if (reqTransDerived.OprNum && reqRoute)
                {
                    if (BOM::findRecId(reqTransDerived.bomRefRecId).EndSchedConsump)
                    {
                        if (_updateReqDateDlv)
                            reqTransDerived.ReqDateDlvOrig  = reqRoute.ToDate;

                        reqTransDerived.ReqDate     = workCalendarSched.schedDate(SchedDirection::Backward,
                                                                                  reqRoute.ToDate,
                                                                                  marginIssue,
                                                                                  marginCalendarDays,
                                                                                  setupDim.reqCalendarId());

                        reqTransDerived.ReqTime     = reqRoute.ToTime;
                    }
                    else
                    {
                        if (_updateReqDateDlv)
                            reqTransDerived.ReqDateDlvOrig  = reqRoute.FromDate;

                        reqTransDerived.ReqDate     = workCalendarSched.schedDate(SchedDirection::Backward,
                                                                                  reqRoute.FromDate,
                                                                                  marginIssue,
                                                                                  marginCalendarDays,
                                                                                  setupDim.reqCalendarId());
                        reqTransDerived.ReqTime     = reqRoute.FromTime;
                    }
                }
                else
                {
                    if (_updateReqDateDlv)
                        reqTransDerived.ReqDateDlvOrig  = _fromDate;

                    reqTransDerived.ReqDate     =workCalendarSched.schedDate(SchedDirection::Backward,
                                                                             _fromDate,
                                                                             marginIssue,
                                                                             marginCalendarDays,
                                                                             setupDim.reqCalendarId());
                    reqTransDerived.ReqTime     = _fromTime;
                }
            }

            reqTransDerived.update();

            if (reqTransDerived.IsDerivedDirectly)
            {
                reqTransChild = reqTransDerived.reqTransDirectlyDerived();
                if (reqTransChild.RecId && (reqTransChild.RefType == ReqRefType::BOMPlannedOrder || reqTransChild.RefType == ReqRefType::PmfPlannedProdBatch) && reqTransChild.IsDerivedDirectly)
                {
                    reqPoChild = ReqPO::find(reqTransChild.PlanVersion,reqTransChild.RefId,true);
                    if (reqPoChild.RecId)
                    {
                        if (_reqPO.ReqDateOrder >  reqPoChild.ReqDateOrder ||
                           (_reqPO.ReqDateOrder == reqPoChild.ReqDateOrder && _reqPO.ReqTimeOrder > reqPoChild.ReqTimeOrder))
                        {
                            _reqPO.ReqDateOrder = reqPoChild.ReqDateOrder;
                            _reqPO.ReqTimeOrder = reqPoChild.ReqTimeOrder;
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>