<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxReport_IT</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// This class is used for Italian tax report.
/// </summary>
class TaxReport_IT extends TaxReport implements BatchRetryable
{
    AmountMST               salesVAT;
    AmountMST               salesVATOnEUPurchase;
    AmountMST               salesVATTotal;
    AmountMST               salesVATRounding;
    AmountMST               salesVATRounded;

    AmountMST               purchaseVAT;
    AmountMST               purchaseVATOnEUPurchase;
    AmountMST               purchaseVATTotal;
    AmountMST               purchaseVATRounding;
    AmountMST               purchaseVATRounded;

    AmountMST               prevVATCredit;
    AmountMST               prevVATDebit;
    AmountMST               vatCompensation;
    AmountMST               vatPrePayment;

    TransDate               paymentDate;
    AmountMST               vatPaymentAmount;
    CompanyBankAccountId    bankAccountId;
    str                     bankRef1;
    str                     bankRef2;
    container               extraVariable;
    boolean                 dialogPaymentIsOK = true;

    private UnknownNoYes    reportUseVatDueDate = UnknownNoYes::Unknown;

    private boolean includeZeroLines;
    private boolean includeReverseTrans;

    #localMacro.CurrentListIT
        salesVATRounded,
        purchaseVATRounded,
        prevVATCredit,
        prevVATDebit,
        vatCompensation,
        vatPrePayment,
        paymentDate,
        vatPaymentAmount,
        bankAccountId,
        bankRef1,
        bankRef2,
        taxPeriod,
        fromDate,
        toDate
    #endMacro


}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if this class can be executed in batch.
    /// </summary>
    /// <returns>
    ///    True if can run this class in batch; otherwise false.
    /// </returns>
    /// <remarks>
    ///    This method must be in this class because it is called from the <c>DialogRunBase</c> class.
    /// </remarks>
    public boolean canGoBatch()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxReportPayment</Name>
				<Source><![CDATA[
    internal void createTaxReportPayment()
    {
        TaxReportPayment_IT taxReportPayment_IT;

        if (this.taxReportPeriodOpen())
        {
            ttsbegin;

            taxReportPayment_IT = TaxReportPayment_IT::findByTaxPeriod(taxPeriod, toDate, true);

            taxReportPayment_IT.EndDate           = this.toDate();
            taxReportPayment_IT.TaxPeriod         = this.taxPeriod();
            taxReportPayment_IT.PrevVATCredit     = this.parmPrevVATCredit();
            taxReportPayment_IT.vatCompensation   = this.parmVATCompensation();
            taxReportPayment_IT.PrevVATDebit      = this.parmPrevVATDebit();
            taxReportPayment_IT.vatPrePayment     = this.parmVATPrePayment();
            taxReportPayment_IT.vatBalance        = this.vatBalance();
            taxReportPayment_IT.vatPaymentAmount  = this.parmVATPaymentAmount();
            taxReportPayment_IT.PaymentDate       = this.parmPaymentDate();
            taxReportPayment_IT.BankAccountId     = this.parmBankAccountId();
            taxReportPayment_IT.BankRef1          = this.parmBankRef1();
            taxReportPayment_IT.BankRef2          = this.parmBankRef2();

            taxReportPayment_IT.write();

            this.updateNextPeriods();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    ///    in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogRunbase dialog = new DialogRunbase("@SYS79395", this);

        updateNow  = false;

        dialogTaxPeriod   = dialog.addField(extendedTypeStr(TaxPeriod));
        dialogTaxPeriod.value(taxPeriod);

        dialogFromDate= dialog.addField(extendedTypeStr(TaxPeriodDate),"@SYS5209","@SYS12292");

        dialogTransDate =  dialog.addFieldValue(extendedTypeStr(TransDate),DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),"@SYS67","@SYS60729");

        dialogUpdate    = dialog.addField(enumStr(NoYes),"@SYS2934","@SYS17200");

        dialogPrintReport = dialog.addFieldValue(
            enumStr(NoYes),
            printReport,
            "@Tax_ReportSalesTaxForSettlementPeriod:PrintReport",
            "@Tax_ReportSalesTaxForSettlementPeriod:PrintReportHelpText");
        this.updatePrintReportControl(taxPeriod);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the header of this dialog.
    /// </summary>
    /// <returns>
    /// Returns the header of this dialog.
    /// </returns>
    protected Caption dialogHeader()
    {
        return "@SYS79395";
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a dialog for tax report payment.
    /// </summary>
    /// <returns>True if the payment is created, false otherwise.</returns>
    private boolean dialogPayment()
    {
        boolean ret = false;
        FormRun formRun;
        Args    args;

        this.initTaxReportPayment();

        args = new Args();
        args.name(formStr(TaxReportPayment_IT));
        args.caller(this);

        formRun = classfactory.formRunClass(args);
        formRun.init();
        formRun.run();
        formRun.wait();

        ret = formRun.closedOk();

        if (ret)
        {
            this.createTaxReportPayment();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDialogValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets values from the dialog.
    /// </summary>
    /// <param name = "_updateNow">Parameter of updateNow.</param>
    /// <param name = "_taxPeriod">Parameter of taxPeriod.</param>
    /// <param name = "_fromDate">Parameter of fromDate.</param>
    /// <param name = "_transactionDate">Parameter of transactionDate.</param>
    void getDialogValues(NoYes                  _updateNow,
                         TaxPeriod              _taxPeriod,
                         TaxPeriodDate          _fromDate,
                         TransDate              _transactionDate)
    {
        updateNow        = _updateNow;
        taxPeriod        = _taxPeriod;
        fromDate         = _fromDate;
        transactionDate  = _transactionDate;
        taxRepVersion    = TaxRepVersion::Original;

        taxReportPeriod  = TaxReportPeriod::find(taxPeriod, fromDate);
        if (taxReportPeriod)
        {
            fromDate         = taxReportPeriod.FromDate;
            toDate           = taxReportPeriod.ToDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets values from dialog.
    /// </summary>
    /// <returns>True.</returns>
    public boolean getFromDialog()
    {
        updateNow       = dialogUpdate.value();
        taxPeriod       = dialogTaxPeriod.value();
        fromDate        = dialogFromDate.value();
        transactionDate = dialogTransDate.value();
        printReport     = dialogPrintReport.value();

        taxRepVersion = TaxRepVersion::Original;

        taxReportPeriod = TaxReportPeriod::find(taxPeriod, fromDate);
        if (taxReportPeriod)
        {
            fromDate    = taxReportPeriod.FromDate;
            toDate      = taxReportPeriod.ToDate;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxReportPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize report payment.
    /// </summary>
    public void initTaxReportPayment()
    {
        TaxReportPayment_IT taxReportPayment_IT;

        taxReportPayment_IT = TaxReportPayment_IT::findByTaxPeriod(taxPeriod, toDate);

        if (taxReportPayment_IT)
        {
            this.parmPrevVATCredit(taxReportPayment_IT.PrevVATCredit);
            this.parmPrevVATDebit(taxReportPayment_IT.PrevVATDebit);

            this.parmVATCompensation(taxReportPayment_IT.vatCompensation);
            this.parmVATPrePayment(taxReportPayment_IT.vatPrePayment);

            this.parmPaymentDate(taxReportPayment_IT.PaymentDate);
            this.parmVATPaymentAmount(taxReportPayment_IT.vatPaymentAmount);

            this.parmBankAccountId(taxReportPayment_IT.BankAccountId);
            this.parmBankRef1(taxReportPayment_IT.BankRef1);
            this.parmBankRef2(taxReportPayment_IT.BankRef2);
        }
        else
        {
            taxReportPayment_IT = TaxReportPayment_IT::findPrevious(taxPeriod, toDate);

            if (taxReportPayment_IT)
            {
                if (taxReportPayment_IT.vatBalance < 0)
                {
                    this.parmPrevVATCredit(- taxReportPayment_IT.vatBalance);
                }
                else
                {
                    this.parmPrevVATDebit(taxReportPayment_IT.vatBalance - taxReportPayment_IT.vatPaymentAmount);
                }

                this.parmBankAccountId(taxReportPayment_IT.BankAccountId);
                this.parmBankRef1(taxReportPayment_IT.BankRef1);
                this.parmBankRef2(taxReportPayment_IT.BankRef2);
            }
        }

        this.sumUpTaxes();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankAccountId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets bank account id.
    /// </summary>
    /// <param name = "_bankAccountId">The bank account id.</param>
    /// <returns>The bank account id.</returns>
    public CompanyBankAccountId parmBankAccountId(CompanyBankAccountId _bankAccountId = bankAccountId)
    {
        BankAccountTable bankAccountTable;

        if (bankAccountId != _bankAccountId)
        {
            bankAccountId = _bankAccountId;

            bankAccountTable = BankAccountTable::find(_bankAccountId);

            if (bankAccountTable.RegistrationNum)
            {
                this.parmBankRef1(subStr(bankAccountTable.RegistrationNum,1,5));
                this.parmBankRef2(subStr(bankAccountTable.RegistrationNum,6,5));
            }
        }
        return bankAccountId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankRef1</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets bank reference1.
    /// </summary>
    /// <param name = "_bankRef1">The bank reference1.</param>
    /// <returns>The bank reference1.</returns>
    public BankReference_IT parmBankRef1(BankReference_IT _bankRef1 = bankRef1)
    {
        bankRef1 = _bankRef1;

        return bankRef1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankRef2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets bank reference2.
    /// </summary>
    /// <param name = "_bankRef2">The bank reference2.</param>
    /// <returns>The bank reference2.</returns>
    public BankReference_IT parmBankRef2(BankReference_IT _bankRef2 = bankRef2)
    {
        bankRef2 = _bankRef2;

        return bankRef2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFromDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets from date.
    /// </summary>
    /// <param name = "_fromDate">The from date.</param>
    /// <returns>The from date.</returns>
    public FromDate parmFromDate(FromDate _fromDate = fromDate)
    {
        fromDate = _fromDate;

        return fromDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymentDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets payment date.
    /// </summary>
    /// <param name = "_paymentDate">The payment date.</param>
    /// <returns>The payment date.</returns>
    public TransDate parmPaymentDate(TransDate _paymentDate = paymentDate)
    {
        paymentDate = _paymentDate;

        return paymentDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrevVATCredit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets preVAT credit.
    /// </summary>
    /// <param name = "_prevVATCredit">The preVAT credit.</param>
    /// <returns>The preVAT credit.</returns>
    public AmountMST parmPrevVATCredit(AmountMST   _prevVATCredit = prevVATCredit)
    {
        prevVATCredit = _prevVATCredit;

        return prevVATCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrevVATDebit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets preVAT debit.
    /// </summary>
    /// <param name = "_prevVATDebit">The preVAT debit.</param>
    /// <returns>The preVAT debit.</returns>
    public AmountMST parmPrevVATDebit(AmountMST _prevVATDebit = prevVATDebit)
    {
        prevVATDebit = _prevVATDebit;

        return prevVATDebit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets tax period.
    /// </summary>
    /// <param name = "_taxPeriod">The tax period.</param>
    /// <returns>The tax period.</returns>
    TaxPeriod parmTaxPeriod(TaxPeriod _taxPeriod = taxPeriod)
    {
        taxPeriod = _taxPeriod;

        return taxPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmToDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets to date.
    /// </summary>
    /// <param name = "_toDate">The to date.</param>
    /// <returns>The to date.</returns>
    ToDate parmToDate(ToDate _toDate = toDate)
    {
        toDate = _toDate;

        return toDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVATBalancePeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets VAT balance period.
    /// </summary>
    /// <returns>The VAT balance period.</returns>
    public AmountMST parmVATBalancePeriod()
    {
        return salesVATRounded - purchaseVATRounded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVATCompensation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets VAT compensation.
    /// </summary>
    /// <param name = "_vatCompensation">The VAT compensation.</param>
    /// <returns>The VAT compensation.</returns>
    public AmountMST parmVATCompensation(AmountMST _vatCompensation = vatCompensation)
    {
        vatCompensation = _vatCompensation;

        return vatCompensation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVATPaymentAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets VAT payment amount.
    /// </summary>
    /// <param name = "_vatPaymentAmount">The VAT payment amount.</param>
    /// <returns>The VAT payment amount.</returns>
    public AmountMST parmVATPaymentAmount(AmountMST _vatPaymentAmount = vatPaymentAmount)
    {
        vatPaymentAmount = _vatPaymentAmount;

        return vatPaymentAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVATPrePayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets VAT prePayment.
    /// </summary>
    /// <param name = "_vatPrePayment">The VAT prePayment.</param>
    /// <returns>The VAT prePayment.</returns>
    public AmountMST parmVATPrePayment(AmountMST _vatPrePayment = vatPrePayment)
    {
        vatPrePayment = _vatPrePayment;

        return vatPrePayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printout</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes the report.
    /// </summary>
    void printout()
    {
        Args  args;

        args = new Args();
        args.caller(this);
        args.record(taxReportPeriod);

        if (TaxReportERHelper_IT::isERReportShouldBeUsed(
            TaxPeriodHead::find(taxPeriod).TaxAuthority))
        {
            if (!updateNow || printReport)
            {
                new MenuFunction(menuitemOutputStr(TaxReportER_IT), MenuItemType::Output).run(args);
            }
        }
        else
        {
            new MenuFunction(menuitemOutputStr(TaxReport_IT), MenuItemType::Output).run(args);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchaseVAT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the purchase VAT amount.
    /// </summary>
    /// <returns>The purchase VAT amount</returns>
    public AmountMST purchaseVAT()
    {
        return purchaseVAT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchaseVATOnEUPurchase</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the purchase VAT on Europe purchase.
    /// </summary>
    /// <returns>The purchase VAT on EUPurchase.</returns>
    public AmountMST purchaseVATOnEUPurchase()
    {
        return purchaseVATOnEUPurchase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchaseVATRounded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the purchase VAT rounded.
    /// </summary>
    /// <returns>The purchase VAT rounded.</returns>
    public AmountMST purchaseVATRounded()
    {
        return purchaseVATRounded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchaseVATTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the purchase VAT total.
    /// </summary>
    /// <returns>The purchase VAT total.</returns>
    public AmountMST purchaseVATTotal()
    {
        return purchaseVATTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIT00019, funcName());

        #OCCRetryCount
        TaxTrans         taxTrans;
        TaxReportVoucher taxReportVoucher;
        TaxReportPeriod  previousTaxReportPeriod;
        TaxBookStatus    taxBookStatus;
        TaxBook          taxBook;
        TaxReportPeriodLock taxReportPeriodLock;

        Microsoft.Dynamics.Ax.Xpp.ErrorException errorEx;
        Microsoft.Dynamics.Ax.Xpp.DeadlockException deadLockEx;
        Microsoft.Dynamics.Ax.Xpp.UpdateConflictException updateConflictEx;
        Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
        System.Diagnostics.Stopwatch stopWatch;
        guid identifier;
        boolean success = true;

        if (!this.validate())
        {
            throw Exception::Error;
        }

        if (dialogPaymentIsOK)
        {
            // The super() call is replaced with the code of method run()
            // of class TaxReport because this.printout() must be called
            // before this.updateNow(). The report must be printed at first
            // because the page numbers printed are necessary for the update.
            try
            {
                taxReportPeriodLock = new TaxReportPeriodLock();

                if (taxReportPeriod.Closed)
                {
                    warning("@SYS62092");
                }

                if (taxReportPeriod && !taxReportPeriod.Closed)
                {
                    taxReportPeriodLock.lockSettlementPeriod(taxReportPeriod.RecId);
                }

                previousTaxReportPeriod  = TaxReportPeriod::find(taxReportPeriod.TaxPeriod,
                                                                     taxReportPeriod.FromDate - 1);

                if (previousTaxReportPeriod && !previousTaxReportPeriod.Closed && updateNow)
                {
                    warning("@SYS107602");
                    updateNow = false;
                }
                if (TaxAuthorityAddress::find(TaxPeriodHead::find(taxReportPeriod.TaxPeriod).TaxAuthority).SeparateTaxSummary)
                {
                    taxBookStatus = TaxBookStatus::findByPeriodDateBookId(taxReportPeriod.TaxPeriod,
                                                                              taxReportPeriod.FromDate,
                                                                              taxReportPeriod.ToDate);
                    if (!taxBookStatus || (taxBookStatus && taxBookStatus.TaxBookStatusType != TaxBookStatusType::TaxSummary))
                    {
                        throw error("@SYS107603");
                    }
                }
                else
                {
                    select firstOnly RecId from taxBook
                            where taxBook.TaxPeriod == taxReportPeriod.TaxPeriod
                               && taxBook.PrintEndSections;

                    if (!taxBook.RecId)
                    {
                        throw error("@SYS107603");
                    }
                }

                this.printout();

                stopWatch = new System.Diagnostics.Stopwatch();
                identifier = newGuid();
                taxEventSourceLog.PaymentTaxStart(identifier);
                stopWatch.Start();

                ttsbegin;

                if (updateNow && !taxReportPeriod.Closed)
                {
                    numberSeq   = NumberSeq::newGetVoucher(TaxParameters::numRefTaxReportingVoucher(),false);
                    voucher     = numberSeq.voucher();
                    this.updateNow();

                    if (this.parmIncludeZeroLines() || this.parmIncludeReverseTrans())
                    {
                        select firstonly forupdate taxReportVoucher
                            where taxReportVoucher.TaxPeriod == taxPeriod
                                && taxReportVoucher.Voucher == voucher
                                && taxReportVoucher.TransDate == transactionDate;

                        taxReportVoucher.IncludeZeroLines_IT = this.parmIncludeZeroLines();
                        taxReportVoucher.IncludeReverseTrans_IT = this.parmIncludeReverseTrans();
                        taxReportVoucher.update();
                    }

                    if (taxTransactions)
                    {
                        if (!transactions)
                        {
                            while select forupdate Voucher
                                    from taxTrans
                                    where taxTrans.Voucher    == voucher &&
                                        taxTrans.TransDate  == transactionDate
                            {
                                taxTrans.Voucher= '';
                                taxTrans.update();
                            }
                            numberSeq.abort();
                        }
                        TransactionLog::create(TransactionLogType::TaxReport, voucher);
                    }
                    else
                    {
                        select firstonly forupdate taxReportVoucher
                            where taxReportVoucher.TaxPeriod == taxPeriod &&
                                    taxReportVoucher.Voucher   == voucher   &&
                                    taxReportVoucher.TransDate == transactionDate;
                        taxReportVoucher.Voucher = '';
                        taxReportVoucher.update();
                        numberSeq.abort();
                    }
                }

                ttscommit;

            }
            catch (deadLockEx)
            {
                success = false;

                taxEventSourceLog.UpdateTaxReportPeriodError(guid2Str(newGuid()),
                                                         deadLockEx.Message,
                                                         deadLockEx.StackTrace,
                                                         taxReportPeriod.SettlementPeriodInProcessBy);
                // Unlock tax report period.
                this.unlockTaxPeriodBeforeRetry(taxReportPeriodLock, taxReportPeriod);
                retry;
            }
            catch (updateConflictEx)
            {
                success = false;

                taxEventSourceLog.UpdateTaxReportPeriodError(guid2Str(newGuid()),
                                                         updateConflictEx.Message,
                                                         updateConflictEx.StackTrace,
                                                         taxReportPeriod.SettlementPeriodInProcessBy);

                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::UpdateConflictNotRecovered;
                    }
                    else
                    {
                        // Unlock tax report period.
                        this.unlockTaxPeriodBeforeRetry(taxReportPeriodLock, taxReportPeriod);
                        retry;
                    }
                }
                else
                {
                    throw Exception::UpdateConflict;
                }
            }
            // catch exception in order not to get stack trace when settlement period doesn't exist
            catch (errorEx)
            {
                success = false;

                taxEventSourceLog.TaxProcessError(guid2Str(newGuid()),
                                              errorEx.Message,
                                              errorEx.StackTrace,
                                              methodStr(TaxReport, run));

                exceptionTextFallThrough();
                // When thrown from inside a catch a stack trace is not generated. Exception is rethrown to have this correctly marked as Error when run in batch.
                throw Exception::Error;
            }
            finally
            {
                taxReportPeriodLock.unlockSettlementPeriod(taxReportPeriod.RecId);

                if (stopWatch)
                {
                    stopWatch.Stop();
                    taxEventSourceLog.PaymentTaxStop(identifier, SysCountryRegionCode::countryInfo(), enum2Str(taxRepVersion), isPreview, taxTransactions, stopWatch.ElapsedMilliseconds, success);
                }
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>salesVAT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the sales VAT.
    /// </summary>
    /// <returns>The sales VAT.</returns>
    public AmountMST salesVAT()
    {
        return salesVAT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesVATOnEUPurchase</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the sales VAT on Europe purchase.
    /// </summary>
    /// <returns>The sales VAT on Europe purchase.</returns>
    public AmountMST salesVATOnEUPurchase()
    {
        return salesVATOnEUPurchase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesVATRounded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the sales VAT Rounded.
    /// </summary>
    /// <returns>The sales VAT Rounded.</returns>
    public AmountMST salesVATRounded()
    {
        return salesVATRounded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesVATTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the sales VAT total.
    /// </summary>
    /// <returns>The sales VAT total.</returns>
    public AmountMST salesVATTotal()
    {
        return salesVATTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleOtherAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Settles other amounts.
    /// </summary>
    /// <param name = "_defaultDimension">The default dimension.</param>
    /// <returns>The settled tax amount.</returns>
    TaxAmount settleOtherAmounts(DimensionDefault _defaultDimension)
    {
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        TaxAmount                   taxAmountRoundDiff;
        TaxAuthorityAddress         taxAuthority;
        LedgerDimensionAccount      roundOffLedgerDimension;

        taxAuthority = TaxAuthorityAddress::find(TaxPeriodHead::find(taxPeriod).TaxAuthority);

        taxAmountRoundDiff = taxAmountSales - taxAmountUseTax + taxAmountPurchase  -
                             taxAuthority.roundOffTaxAmount(taxAmountSales - taxAmountUseTax) -
                             taxAuthority.roundOffTaxAmount(taxAmountPurchase);

        if (taxAmountRoundDiff)
        {
            roundOffLedgerDimension = taxAmountRoundDiff < 0 ? taxAuthority.RoundOffLossLedgerDimension : taxAuthority.RoundOffGainLedgerDimension;
            roundOffLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(roundOffLedgerDimension, _defaultDimension);
            ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                                            ledgerVoucher.findLedgerVoucherObject(),
                                            LedgerPostingType::VATRoundOff,
                                            roundOffLedgerDimension,
                                            Ledger::accountingCurrency(CompanyInfo::current()),
                                           -taxAmountRoundDiff,
                                            0, // This is an adjustment. Passing 0 is Ok.
                                            0);
            ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::Detail);
            ledgerVoucher.addTrans(ledgerVoucherTransObject);
            totalClearingAmountTaxAuthorityCur += taxAmountRoundDiff;
        }
        return taxAmountRoundDiff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumUpTaxes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sums up all taxes.
    /// </summary>
    private void sumUpTaxes()
    {
        Counter              versionMin;
        Counter              versionMax;
        TaxAuthorityAddress  taxAuthority;
        TaxTrans             taxTrans;
        TmpTaxReport_IT      tmpTable;
        TransDate            oldTransDate        = dateNull();
        Voucher              oldVoucher          = '';
        TaxCode              oldTaxCode          = '';
        boolean              initFromTrans;
        Query               query;
        QueryRun            queryRun;
        ReportInTaxCurrency_IT reportInTaxCurrency = TaxPeriodHead::find(taxPeriod).ReportInTaxCurrency_IT;

        salesVAT                = 0;
        purchaseVAT             = 0;
        salesVATOnEUPurchase    = 0;
        purchaseVATOnEUPurchase = 0;

        versionMin      = TaxReport::counterMin(taxRepVersion, taxPeriod, fromDate);
        versionMax      = TaxReport::counterMax(taxRepVersion, taxPeriod, fromDate);

        query = this.getTaxTransQuery(taxPeriod, fromDate, toDate, versionMin, versionMax);
        query.dataSourceTable(tableNum(TaxTrans)).addRange(fieldNum(TaxTrans, TaxDirection)).value(queryNotValueCon_W([TaxDirection::TaxExemptPurchase,
                                                                                                                       TaxDirection::TaxExemptSales,
                                                                                                                       TaxDirection::TaxTransaction]));
        query.dataSourceTable(tableNum(TaxTrans)).addRange(fieldNum(TaxTrans, TaxBookSection)).value(SysQuery::valueNot(0));

        queryRun = new QueryRun(query);
        while (queryRun.next())
        {
            taxTrans = queryRun.get(tableNum(TaxTrans));

            if (!TmpTaxReport_IT::checkTaxTrans(taxTrans))
            {
                continue;
            }

            if (reportInTaxCurrency)
            {
                TaxReportERHelper_IT::switchTaxTransAmounts(taxTrans);
            }

            if (taxTrans.TaxOrigin == TaxOrigin::Payment)
            {
                voucher = LedgerTransVoucherLink::find(LedgerTransVoucherLink::findVoucherGroupId(taxTrans.Voucher, taxTrans.TransDate)).Voucher;

                tmpTable.clear();
                tmpTable.Voucher = voucher ? voucher : taxTrans.Voucher;

                if (oldTransDate != taxTrans.TransDate || oldVoucher != voucher || oldTaxCode != taxTrans.TaxCode)
                {
                    if (   taxTrans.TaxDirection == TaxDirection::OutgoingTax
                        || taxTrans.TaxDirection == TaxDirection::TaxExemptSales)
                    {
                        initFromTrans = tmpTable.initCust(taxTrans);
                    }
                    else
                    {
                        initFromTrans = tmpTable.initVend(taxTrans);
                    }

                    oldTransDate = taxTrans.TransDate;
                    oldVoucher   = taxTrans.Voucher;
                    oldTaxCode   = taxTrans.TaxCode;
                }

                if (initFromTrans)
                {
                    tmpTable.initFromTableIdRecId(taxTrans.SourceTableId, taxTrans.SourceRecId);
                }

                tmpTable.TaxAmount = -taxTrans.TaxAmount;
                tmpTable.initFromCustVendTable(taxTrans);

                if (tmpTable.TaxAmount == 0)
                {
                    taxTrans.TaxAmount = 0;
                }
            }

            switch (taxTrans.TaxDirection)
            {
                case TaxDirection::OutgoingTax:
                    salesVAT   += -(taxTrans.TaxAmount - taxTrans.TaxInCostPriceMST);
                    break;
                case TaxDirection::UseTax:
                    purchaseVATOnEUPurchase += (taxTrans.TaxAmount - taxTrans.TaxInCostPriceMST);
                    salesVATOnEUPurchase += taxTrans.TaxAmount;
                    break;
                default:
                    purchaseVAT += (taxTrans.TaxAmount - taxTrans.TaxInCostPriceMST);
                    break;
            }
        }

        salesVATTotal       = salesVAT      + salesVATOnEUPurchase;
        purchaseVATTotal    = purchaseVAT   + purchaseVATOnEUPurchase;

        taxAuthority = TaxAuthorityAddress::find(TaxPeriodHead::find(taxPeriod).TaxAuthority);

        salesVATRounded     = taxAuthority.roundOffTaxAmount( salesVATTotal);
        salesVATRounding    = salesVATRounded - salesVATTotal;

        purchaseVATRounded  = taxAuthority.roundOffTaxAmount( purchaseVATTotal);
        purchaseVATRounding = purchaseVATRounded - purchaseVATTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxReportPeriodOpen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the tax report period opens or not.
    /// </summary>
    /// <returns>True if opened, false otherwise.</returns>
    public boolean taxReportPeriodOpen()
    {
        boolean ret = false;

        if (taxReportPeriod.VersionNum == 0)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAndPostTaxtrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates and posts tax trans.
    /// </summary>
    /// <param name = "_fromDate">The from date.</param>
    /// <param name = "_toDate">The to date.</param>
    /// <param name = "_versionMin">The minimum version.</param>
    /// <param name = "_versionMax">The maximum version.</param>
    /// <returns>The version.</returns>
    public Counter updateAndPostTaxtrans(
        FromDate _fromDate,
        ToDate   _toDate,
        Counter  _versionMin,
        Counter  _versionMax)
    {
        TaxTrans    taxTrans;
        Counter     transactionsInTax;
        CurrencyExchangeHelper      currencyExchangeHelper;

        TaxTransGeneralJournalAccountEntryView taxTransGeneralJournalAccountEntryView;
        TaxTransGeneralJournalAccountEntryView useTaxTransGeneralJournalAccountEntryView;
        TaxTransGeneralJournalAccountEntryView taxInCostPriceTaxTransGeneralJournalAccountEntryView;

        Query       query;
        QueryRun    queryRun;

        Amount TotalTaxAmount;
        Amount TotalUseTaxAmount;
        Amount TotalTaxInCostPrice;
        Amount TotalUseTaxTaxInCostPrice;

        Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;

        if (!isPopulateDimensionForExchGainLossAccount && isTaxReportCombineVoucherForGainLoss)
        {
            currencyExchRateGainAmtMap = new Map(Types::String, Types::Container);
            currencyExchRateLossAmtMap = new Map(Types::String, Types::Container);
        }

        overridenForMethodUpdateAndPostTaxTrans = false;
        query = this.getTaxTransQuery(taxPeriod, _fromDate, _toDate, _versionMin, _versionMax);
        query = this.getTaxLinkLedgerDimensionsForNonZeroAmounts(query);

        queryRun = new QueryRun(query);


        if (isTaxSettlementStateCollectionFlightEnabled)
        {
            sqlStatement = '';
            processedCount = 0;
            postedV2Count = 0;
            postedV2UseTaxCount = 0;
            processMessage = '';
            totalCount = SysQuery::countLoops(queryRun);
            sqlStatement = query.dataSourceNo(1).toString();
        }

        while (queryRun.next())
        {
            taxTrans = queryRun.get(tableNum(TaxTrans));

            if (!TmpTaxReport_IT::checkTaxTrans(taxTrans))
            {
                if (isTaxSettlementStateCollectionFlightEnabled)
                {
                    totalCount--;
                }
                continue;
            }

            if (isTaxSettlementStateCollectionFlightEnabled)
            {
                processedCount++;
                TotalTaxAmount += taxTrans.TaxAmount;
                TotalTaxInCostPrice += taxTrans.TaxInCostPriceMST;

                if (taxTrans.TaxDirection == TaxDirection::UseTax)
                {
                    TotalUseTaxAmount += taxTrans.TaxAmount;
                    TotalUseTaxTaxInCostPrice += taxTrans.TaxInCostPriceMST;
                }
            }

            transactionsInTax++;
            taxPurchaseTaxPost.sumPurchaseTax(taxTrans);
            currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                Ledger::primaryLedger(CompanyInfo::findDataArea(taxTrans.company()).RecId),
                taxTrans.TransDate);

            taxTransGeneralJournalAccountEntryView = queryRun.get(tableNum(TaxTransGeneralJournalAccountEntryView), 1);
            useTaxTransGeneralJournalAccountEntryView = queryRun.get(tableNum(TaxTransGeneralJournalAccountEntryView), 2);
            taxInCostPriceTaxTransGeneralJournalAccountEntryView = queryRun.get(tableNum(TaxTransGeneralJournalAccountEntryView), 3);
                

            this.taxInCostPriceLedgerDimension = taxInCostPriceTaxTransGeneralJournalAccountEntryView.LedgerDimension;

            this.saveAndPostRetrieveAccountsAndAmounts(taxTrans,
                currencyExchangeHelper,
                taxTransGeneralJournalAccountEntryView.LedgerDimension,
                useTaxTransGeneralJournalAccountEntryView.LedgerDimension);
        }

        if (isTaxReportPerfImprovByVoucherTransCombineFlightEnabled)
        {
            taxReportVoucherTransCombine.addTransToVoucher(
                ledgerPostingController,
                transactionDate);
        }

        if (!isPopulateDimensionForExchGainLossAccount && isTaxReportCombineVoucherForGainLoss)
        {
            // Posts combined voucher for exchange rate loss account.
            this.postCombinedLedgerVoucherTransObjectForExchRateGainLoss(currencyExchRateLossAmtMap, LedgerPostingType::ExchRateLoss, lossLedgerDimension);

            // Posts combined voucher for exchange rate gain account.
            this.postCombinedLedgerVoucherTransObjectForExchRateGainLoss(currencyExchRateGainAmtMap, LedgerPostingType::ExchRateGain, gainLedgerDimension);
        }

        if (isTaxSettlementStateCollectionFlightEnabled)
        {
            processMessage += '|All Total Amount: ' + num2Str(TotalTaxAmount, 1, 6, 1, 0);
            processMessage += '|All Total Tax In Cost Price: ' + num2Str(TotalTaxInCostPrice, 1, 6, 1, 0);
            processMessage += '|Use Tax Total Amount: ' + num2Str(TotalUseTaxAmount, 1, 6, 1, 0);
            processMessage += '|Use Tax Total Tax In Cost Price: ' + num2Str(TotalUseTaxTaxInCostPrice, 1, 6, 1, 0);

            processMessage += '|IT Total TaxTrans: ' + int642Str(totalCount);
            processMessage += '|IT Processed TaxTrans: ' + int642Str(processedCount);
            processMessage += '|IT Processed PostV2: ' + int642Str(postedV2Count);
            processMessage += '|IT Processed PostV2 for Use Tax: ' + int642Str(postedV2UseTaxCount);
            taxEventSourceLog.LogTaxSettlementState(voucher, processMessage, sqlStatement);

            if (TaxSettlementInconsistentStateBlockingFlight::instance().isEnabled() && (totalCount != processedCount))
            {
                printout = NoYes::No;
                throw error("@Tax:SettlementTaxTransCountInconsistency");
            }
        }

        return transactionsInTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxLinkLedgerDimensionsForNonZeroAmounts</Name>
				<Source><![CDATA[
    private Query getTaxLinkLedgerDimensionsForNonZeroAmounts(Query _query)
    {
        QueryBuildDataSource qbdsTaxTrans = _query.dataSourceTable(tableNum(TaxTrans));
        QueryBuildRange qbr = qbdsTaxTrans.addRange(fieldNum(TaxTrans, TaxAmountCur));
        // taxTrans.TaxAmountCur != 0 || taxTrans.TaxBaseQty != 0 || taxTrans.TaxBaseAmount != 0 || taxTrans.TaxBaseAmountCur != 0 || taxTrans.TaxInCostPrice != 0 || taxTrans.TaxInCostPriceMST != 0 || taxTrans.TaxInCostPriceCur != 0
        qbr.value(strFmt(
            '(%1 != 0) || (%2 != 0) || (%3 != 0) || (%4 != 0) || (%5 != 0) || (%6 != 0) || (%7 != 0)',
            fieldNum(TaxTrans, TaxAmountCur),
            fieldNum(TaxTrans, TaxBaseQty),
            fieldNum(TaxTrans, TaxBaseAmount),
            fieldNum(TaxTrans, TaxBaseAmountCur),
            fieldNum(TaxTrans, TaxInCostPrice),
            fieldNum(TaxTrans, TaxInCostPriceMST),
            fieldNum(TaxTrans, TaxInCostPriceCur))
            );

        //select LedgerDimension from taxTransGeneralJournalAccountEntryView
        //    where taxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
        //        && taxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::Tax;
        QueryBuildDataSource qbdsTaxLink_Tax;
        qbdsTaxLink_Tax = qbdsTaxTrans.addDataSource(tableNum(TaxTransGeneralJournalAccountEntryView), 'TaxLink_Tax', false);
        qbdsTaxLink_Tax.addSelectionField(fieldNum(TaxTransGeneralJournalAccountEntryView, LedgerDimension));
        qbdsTaxLink_Tax.joinMode(JoinMode::OuterJoin);
        qbdsTaxLink_Tax.fetchMode(QueryFetchMode::One2One);
        qbdsTaxLink_Tax.addLink(fieldNum(TaxTrans, RecId), fieldNum(TaxTransGeneralJournalAccountEntryView, TaxTrans));
        qbdsTaxLink_Tax.addRange(fieldNum(TaxTransGeneralJournalAccountEntryView, TaxTransRelationship)).value(SysQuery::value(TaxTransRelationshipType::Tax));

        //select LedgerDimension from useTaxTransGeneralJournalAccountEntryView
        //    where useTaxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
        //        && useTaxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::UseTaxPayable;
        QueryBuildDataSource qbdsTaxLink_UseTax;
        qbdsTaxLink_UseTax = qbdsTaxTrans.addDataSource(tableNum(TaxTransGeneralJournalAccountEntryView), 'TaxLink_UseTax', false);
        qbdsTaxLink_UseTax.addSelectionField(fieldNum(TaxTransGeneralJournalAccountEntryView, LedgerDimension));
        qbdsTaxLink_UseTax.joinMode(JoinMode::OuterJoin);
        qbdsTaxLink_UseTax.fetchMode(QueryFetchMode::One2One);
        qbdsTaxLink_UseTax.addLink(fieldNum(TaxTrans, RecId), fieldNum(TaxTransGeneralJournalAccountEntryView, TaxTrans));
        qbdsTaxLink_UseTax.addRange(fieldNum(TaxTransGeneralJournalAccountEntryView, TaxTransRelationship)).value(SysQuery::value(TaxTransRelationshipType::UseTaxPayable));

        //select LedgerDimension from taxInCostPriceTaxTransGeneralJournalAccountEntryView
        //   where taxInCostPriceTaxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
        //        && taxInCostPriceTaxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::TaxInCostPrice;
        QueryBuildDataSource qbdsTaxLink_TaxInCostPrice;
        qbdsTaxLink_TaxInCostPrice = qbdsTaxTrans.addDataSource(tableNum(TaxTransGeneralJournalAccountEntryView), 'TaxLink_TaxInCostPrice', false);
        qbdsTaxLink_TaxInCostPrice.addSelectionField(fieldNum(TaxTransGeneralJournalAccountEntryView, LedgerDimension));
        qbdsTaxLink_TaxInCostPrice.joinMode(JoinMode::OuterJoin);
        qbdsTaxLink_TaxInCostPrice.fetchMode(QueryFetchMode::One2One);
        qbdsTaxLink_TaxInCostPrice.addLink(fieldNum(TaxTrans, RecId), fieldNum(TaxTransGeneralJournalAccountEntryView, TaxTrans));
        qbdsTaxLink_TaxInCostPrice.addRange(fieldNum(TaxTransGeneralJournalAccountEntryView, TaxTransRelationship)).value(SysQuery::value(TaxTransRelationshipType::TaxInCostPrice));

        return _query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the ledger or the vendor transactions and inserts a record in the <c>TaxReportVoucher</c>
    ///    table.
    /// </summary>
    void updateNow()
    {
        super();

        TaxBookStatus::updateTaxPayment(taxReportPeriod);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates tax period and dates.
    /// </summary>
    /// <param name = "calledFrom">The caller object.</param>
    /// <returns>True if valid, false otherwise.</returns>
    public boolean validate(Object calledFrom = null)
    {
        if (! taxPeriod)
        {
            return checkFailed(strFmt("@SYS26332", "@SYS60050"));
        }

        if (! fromDate)
        {
            return checkFailed(strFmt("@SYS26332", "@SYS5209"));
        }

        if (! taxReportPeriod)
        {
            return checkFailed(strFmt("@VatDueDate:PeriodIntervalForTheDateDoesNotExist",
                                date2StrUsr(fromDate, DateFlags::FormatAll), taxPeriod));
        }

        if (taxRepVersion != TaxRepVersion::Original)
        {
            return checkFailed(strFmt("@ExtendedItallianLocalization:SettlementPeriodIsAssosiatedWithItaly", TaxRepVersion::Original));
        }

        if (updateNow)
        {
            if (taxReportPeriod.Closed)
            {
                return checkFailed("@SYS79397");
            }

            if (TaxReportPeriod::find(taxPeriod,toDate+1).Closed)
            {
                return checkFailed("@SYS79398");
            }

            if (this.useVatDueDate() && this.taxTransWithoutVatDueDateExist())
            {
                return checkFailed(strFmt("@VatDueDate:EmptyDateOfVATRegisterWarning",
                                    "@Tax:TaxReportSettle",
                                    fieldPName(TaxParameters, ReportUseVatDueDate_W),
                                    fieldPName(Taxtrans_W, VatDueDate_W),
                                    date2StrUsr(taxReportPeriod.FromDate, DateFlags::FormatAll),
                                    date2StrUsr(taxReportPeriod.ToDate, DateFlags::FormatAll),
                                    taxReportPeriod.TaxPeriod,
                                    "@GLS109146"));
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets value added tax balance.
    /// </summary>
    /// <returns>The value added tax balance.</returns>
    public AmountMST vatBalance()
    {
        AmountMST vatBalance = this.parmVATBalancePeriod() -
                               this.parmPrevVATCredit()    +
                               this.parmPrevVATDebit()     -
                               this.parmVATCompensation()  -
                               this.parmVATPrePayment();

        return vatBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    /// <summary>
    /// The main method of <c>TaxReport_IT</c> class.
    /// </summary>
    /// <param name = "_args">The args.</param>
    static void  main(Args  _args)
    {
        TaxReport_IT    taxReport_IT  = new TaxReport_IT();

        if (taxReport_IT.runDialogParametersAndParseArgs(_args))
        {
            if (taxReport_IT.canRunBatch())
            {
                taxReport_IT.runBatch();
            }
            else
            {
                taxReport_IT.runOperation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxTransQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the query of TaxTrans table.
    /// </summary>
    /// <param name = "_taxPeriod">The tax period.</param>
    /// <param name = "_fromDate">The from date.</param>
    /// <param name = "_toDate">The to date.</param>
    /// <param name = "_versionMin">The minimum version.</param>
    /// <param name = "_versionMax">The maximum version.</param>
    /// <returns>The query.</returns>
    protected Query getTaxTransQuery(
        TaxPeriod   _taxPeriod,
        FromDate    _fromDate,
        ToDate      _toDate,
        Counter     _versionMin,
        Counter     _versionMax)
    {
        Query query = new Query();
        QueryBuildDataSource qbdsTaxTrans, qbdsTaxTable, qbdsTaxBook, qbdsTaxTrans_IT;
        QueryBuildRange qbrTaxTrans_IT;

        qbdsTaxTrans = query.addDataSource(tableNum(TaxTrans));
        qbdsTaxTrans.addRange(fieldNum(TaxTrans, TaxPeriod)).value(queryValue(_taxPeriod));

        if (this.useVatDueDate())
        {
            QueryBuildDataSource qbdsTaxTrans_W = TaxTransCustomization_W::addDataSource(qbdsTaxTrans, tableNum(TaxTrans_W));
            QueryBuildRange qbr = qbdsTaxTrans.addRange(fieldNum(TaxTrans, DataAreaId));
            qbr.value(strFmt(
                '(((%1.%2 >= %5) && (%1.%2 <= %6)) || ((%1.%2 == %7) && (%3.%4 >= %5) && (%3.%4 <= %6)))',
                query.dataSourceTable(tableNum(TaxTrans_W)).name(),
                fieldStr(TaxTrans_W, VatDueDate_W),
                query.dataSourceTable(tableNum(TaxTrans)).name(),
                fieldStr(TaxTrans, TransDate),
                Date2StrXpp(_fromDate),
                Date2StrXpp(_toDate),
                Date2StrXpp(dateNull())));
        }
        else
        {
            qbdsTaxTrans.addRange(fieldNum(TaxTrans, TransDate)).value(queryRange(_fromDate, _toDate));
        }

        qbdsTaxTrans.addRange(fieldNum(TaxTrans, TaxRepCounter)).value(queryRange(_versionMin, _versionMax));
        qbdsTaxTrans.addRange(fieldNum(TaxTrans, Source)).value(SysQuery::valueNot(TaxModuleType::Tax));

        qbdsTaxTable = qbdsTaxTrans.addDataSource(tableNum(TaxTable));
        qbdsTaxTable.joinMode(JoinMode::ExistsJoin);
        qbdsTaxTable.relations(true);
        qbdsTaxTable.addRange(fieldNum(TaxTable, PaymentTaxCode)).value(SysQuery::valueEmptyString());

        qbdsTaxBook = qbdsTaxTrans.addDataSource(tableNum(TaxBook));
        qbdsTaxBook.joinMode(JoinMode::ExistsJoin);
        qbdsTaxBook.relations(true);
        qbdsTaxBook.addRange(fieldNum(TaxBook, TaxBookType)).value(SysQuery::valueNot(TaxBookType::NotIncluded));

        qbdsTaxTrans_IT = qbdsTaxTrans.addDataSource(tableNum(TaxTrans_IT));
        qbdsTaxTrans_IT.joinMode(JoinMode::NoExistsJoin);
        qbdsTaxTrans_IT.fetchMode(QueryFetchMode::One2One);
        qbdsTaxTrans_IT.addLink(fieldNum(TaxTrans, RecId), fieldNum(TaxTrans_IT, TaxTrans));

        qbrTaxTrans_IT = qbdsTaxTrans_IT.addRange(fieldNum(TaxTrans_IT, DataAreaId));
        qbrTaxTrans_IT.value(strFmt('((%1 == %3) || (%2 == %3))',
            fieldStr(TaxTrans_IT, SplitPaymDirect),
            fieldStr(TaxTrans_IT, SplitPaymReverse),
            any2int(NoYes::Yes)));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNextPeriods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates next periods in TaxReportPayment_IT table.
    /// </summary>
    private void updateNextPeriods()
    {
        TaxReportPayment_IT taxReportPaymentNext;

        while select forUpdate taxReportPaymentNext
            order by taxReportPaymentNext.EndDate asc
            where taxReportPaymentNext.TaxPeriod == taxPeriod
                && taxReportPaymentNext.EndDate > toDate
        {
            TaxReportPayment_IT taxReportPaymentPrev = TaxReportPayment_IT::findPrevious(taxPeriod, taxReportPaymentNext.EndDate);

            if (taxReportPaymentPrev.VATBalance < 0)
            {
                taxReportPaymentNext.PrevVATCredit = - taxReportPaymentPrev.VATBalance;
                taxReportPaymentNext.PrevVATDebit = 0;
            }
            else
            {
                taxReportPaymentNext.PrevVATDebit = taxReportPaymentPrev.VATBalance - taxReportPaymentPrev.VATPaymentAmount;
                taxReportPaymentNext.PrevVATCredit = 0;
            }

            TaxReport_IT taxReport = new TaxReport_IT();
            taxReport.parmTaxPeriod(taxReportPaymentNext.TaxPeriod);
            TaxReportPeriod taxReportPeriodNext = TaxReportPeriod::find(taxReportPaymentNext.TaxPeriod, taxReportPaymentNext.EndDate);
            taxReport.parmFromDate(taxReportPeriodNext.FromDate);
            taxReport.parmToDate(taxReportPeriodNext.ToDate);
            taxReport.initTaxReportPayment();

            taxReport.parmPrevVATCredit(taxReportPaymentNext.PrevVATCredit);
            taxReport.parmPrevVATDebit(taxReportPaymentNext.PrevVATDebit);

            taxReportPaymentNext.VATBalance = taxReport.vatBalance();

            taxReportPaymentNext.write();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useVatDueDate</Name>
				<Source><![CDATA[
    private boolean useVatDueDate(boolean _useVatDueDate = false)
    {
        if (prmIsDefault(_useVatDueDate))
        {
            if (reportUseVatDueDate == UnknownNoYes::Unknown)
            {
                if (TaxParameters::reportUseVatDueDate_W())
                {
                    reportUseVatDueDate = UnknownNoYes::Yes;
                }
                else
                {
                    reportUseVatDueDate = UnknownNoYes::No;
                }
            }
        }
        else
        {
            if (_useVatDueDate)
            {
                reportUseVatDueDate = UnknownNoYes::Yes;
            }
            else
            {
                reportUseVatDueDate = UnknownNoYes::No;
            }
        }

        return reportUseVatDueDate == UnknownNoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTransWithoutVatDueDateExist</Name>
				<Source><![CDATA[
    private boolean taxTransWithoutVatDueDateExist()
    {
        Counter versionMin = TaxReport::counterMin(TaxRepVersion::Original, taxReportPeriod.TaxPeriod, taxReportPeriod.FromDate);
        Counter versionMax = TaxReport::counterMax(TaxRepVersion::Original, taxReportPeriod.TaxPeriod, taxReportPeriod.FromDate);

        boolean reportUseVatDueDateCurrent = this.useVatDueDate();
        this.useVatDueDate(false);
        Query query = this.getTaxTransQuery(taxReportPeriod.TaxPeriod, taxReportPeriod.FromDate, taxReportPeriod.ToDate, versionMin, versionMax);
        this.useVatDueDate(reportUseVatDueDateCurrent);

        QueryBuildDataSource qbdsTaxTrans_W = TaxTransCustomization_W::addDataSource(query.dataSourceTable(tableNum(TaxTrans)), tableNum(TaxTrans_W), JoinMode::NoExistsJoin);
        boolean taxTransWithoutVatDueDateExist = (QueryRun::getQueryRowCount(query, 1) > 0);

        query.dataSourceTable(tableNum(TaxTrans_W)).joinMode(JoinMode::ExistsJoin);
        qbdsTaxTrans_W.addRange(fieldNum(TaxTrans_W, VatDueDate_W)).value(SysQuery::value(dateNull()));
        taxTransWithoutVatDueDateExist = taxTransWithoutVatDueDateExist || (QueryRun::getQueryRowCount(query, 1) > 0);

        return taxTransWithoutVatDueDateExist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packed = super();

        extraVariable = [#CurrentListIT];
        packed = this.appendVariableToPack(packed, varStr(extraVariable), extraVariable);

        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendVariableToPack</Name>
				<Source><![CDATA[
    private container appendVariableToPack(container _pack, str _variableName, anytype _value)
    {
        XppPrePostArgs packArgs = this.createXppPrePostArgsWithPack(_pack);
        SysPackExtensions::pack(packArgs, this.getVariablePackKey(_variableName), [_value]);
        return packArgs.getReturnValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXppPrePostArgsWithPack</Name>
				<Source><![CDATA[
    private XppPrePostArgs createXppPrePostArgsWithPack(container _pack)
    {
        XppPrePostArgs prePostArgs = new XppPrePostArgs(_pack, '',  XppEventHandlerCalledWhen::Post);
        prePostArgs.setReturnValue(_pack);
        return prePostArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVariablePackKey</Name>
				<Source><![CDATA[
    private ClassName getVariablePackKey(str _variableName)
    {
        return classStr(TaxReport_IT) + '.' + _variableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Version version = conPeek(packedClass, 1);

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = packedClass;
                [#CurrentListIT] = this.extractPackedVariable(packedClass, varStr(extraVariable));
                break;

            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>extractPackedVariable</Name>
				<Source><![CDATA[
    private anytype extractPackedVariable(container _pack, str _variableName)
    {
        anytype value;
        [value] = SysPackExtensions::unpack(this.createXppPrePostArgsWithPack(_pack), this.getVariablePackKey(_variableName));
        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executePreRunOperations</Name>
				<Source><![CDATA[
    public void executePreRunOperations()
    {
        super();

        TaxPeriodHead taxPeriodHead = TaxPeriodHead::find(taxPeriod);
        boolean showDialogPayment = !TaxReportERHelper_IT::isERReportShouldBeUsed(taxPeriodHead.TaxAuthority)
            || (updateNow
                && taxPeriodHead.UseBatch
                && printReport);

        if (showDialogPayment)
        {
            dialogPaymentIsOK = this.dialogPayment();
        }
        else
        {
            this.initTaxReportPayment();
            dialogPaymentIsOK = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunBatch</Name>
				<Source><![CDATA[
    public boolean canRunBatch()
    {
        return super() && dialogPaymentIsOK;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls whether the batch task should be retried in case of transient errors.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeZeroLines</Name>
				<Source><![CDATA[
    public boolean parmIncludeZeroLines(boolean _includeZeroLines = includeZeroLines)
    {
        includeZeroLines = _includeZeroLines;
        return includeZeroLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeReverseTrans</Name>
				<Source><![CDATA[
    public boolean parmIncludeReverseTrans(boolean _includeReverseTrans = includeReverseTrans)
    {
        includeReverseTrans = _includeReverseTrans;
        return includeReverseTrans;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>