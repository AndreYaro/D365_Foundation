<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailBarcodeManagement</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// This <c>RetailBarcodeManagement</c> class manages the barcode creation or updation for the items.
/// </summary>
class RetailBarcodeManagement
{
    BarcodeSetup    barcodeSetup;
    char    Ichar,Xchar,Mchar,Zchar,Cchar,Schar,Lchar,Pchar,Qchar,Echar,Uchar,Achar,Nchar;

    // The charPositionMap is a map where the key is an expected character example IChar,XChar, etc
    // And the value is the first position that its observed in.
    Map charPositionMap        = new  Map(Types::String, Types::Integer);

    // The charOccurenceCountMap is a map where the key is an expected character example IChar,XChar, etc
    // And the value is the number of times the key is observed in the barcode string.
    Map charOccurenceCountMap  = new  Map(Types::String, Types::Integer);

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcMask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Intializes the mask characters and increments the maps based on the barcode mask.
    /// </summary>
    /// <param name="_mask">
    /// The mask character.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Throws an exception if the retail parameters are not setup.
    /// </exception>
    void calcMask(RetailBarcodeMask _mask)
    {
        int     maskCharacterIndex;
        char    char;

        if (!RetailParameters::find())
        {
            throw error("@RET4092");
        }

        this.initMaskCharacters();

        for (maskCharacterIndex = 1; maskCharacterIndex<= strlen(_mask); maskCharacterIndex++)
        {
            char = substr(_mask, maskCharacterIndex, 1);

            // If a mask character exists in the charOccurenceCountMap, update the occurance counter.
            // If not present; the character is NOT expected to be tracked.
            if (charOccurenceCountMap.exists(char))
            {
                charOccurenceCountMap.insert(char, charOccurenceCountMap.lookup(char) + 1);
            }

            // If a mask character exists in the charPositionMap AND initialized to zero; update the position index.
            // If not present; the character is NOT expected to be tracked.
            // If present and NOT zero; Then its already been observed earlier or has some special casing. Example 'M'.
            if (charPositionMap.exists(char) && charPositionMap.lookup(char) == 0)
            {
                charPositionMap.insert(char, maskCharacterIndex);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBarcodeForItemVariant</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a barcode for the variant item and returns the item barcode.
    /// </summary>
    /// <param name="_barcodeMask">
    /// The barcode mask of the item.
    /// </param>
    /// <param name="_inventDimCombination">
    /// The dimension combination code of the item.
    /// </param>
    /// <param name="_unitId">
    /// The unit of measure code for the item.
    /// </param>
    /// <param name="_useItemId">
    /// A boolean value that indicates whether to use the itemID or not.
    /// </param>
    /// <returns>
    /// The calculated item barcode.
    /// </returns>
    itemBarcode createBarcodeForItemVariant(RetailBarcodeMask _barcodeMask, InventDimCombination _inventDimCombination, UnitOfMeasureSymbol _unitId, ItemId _useItemId)
    {
        #Retail

        str                     tempBarcode;
        str                     maskChar;
        RetailBarcodeMask       BarcodeNo;
        int                     barcodeMaskIndex,j;
        char                    c;
        boolean                 isBarcodeNoStrLengthLessThanBarcodeMask = false;
        RetailBarcodeMask       barcodeMaskWithoutPrefix;
        RetailBarcodeMaskPrefix prefix = this.getPrefixForBarcodeMask();

        BarcodeNo = _inventDimCombination.ItemId;

        // Stripping the prefix from the barcode mask to avoid parsing of masked characters in prefix if they exist.
        // Prefix will be added back to the generated barcode after completion of parsing barcode mask.
        barcodeMaskWithoutPrefix = strDel(_barcodeMask, 1, strLen(prefix));

        if (_useItemId != "")
            BarcodeNo = _useItemId;

        if (!RetailParameters::find())
        {
            error("@RET4092");
            return '';
        }

        this.calcMask(barcodeMaskWithoutPrefix);
        tempBarcode = "";

        if (strlen(BarcodeNo) > strlen(barcodeMaskWithoutPrefix))
        {
            error("@RET4095");
            return '';
        }

        // If barcode's length is less than the mask length then we need to adjust the widget and clamp down the flapper.
        isBarcodeNoStrLengthLessThanBarcodeMask = (strlen(BarcodeNo) < strlen(barcodeMaskWithoutPrefix));
        barcodeMaskIndex = 1;

        do
        {
            maskChar = subStr(barcodeMaskWithoutPrefix, barcodeMaskIndex, 1);
            c = int2Str(strFind("0123456789", maskChar, 1, 10) - 1); // ATH

            switch(maskChar)
            {
                case Lchar:
                    if (isBarcodeNoStrLengthLessThanBarcodeMask)
                    {
                        tempBarcode = tempBarcode + RetailParameters::find().EANLicenseNo;
                        barcodeMaskIndex = barcodeMaskIndex + charOccurenceCountMap.lookup(Lchar);
                    }
                    else
                    {
                        if (substr(BarcodeNo, barcodeMaskIndex, 1) != Lchar)
                        {
                            if (RetailParameters::find().EANLicenseNo != substr(BarcodeNo, barcodeMaskIndex, charOccurenceCountMap.lookup(Lchar)))
                            {
                                error(strfmt("@RET4099",RetailParameters::find().EANLicenseNo));
                                return '';
                            }

                            tempBarcode = tempBarcode + substr(BarcodeNo, barcodeMaskIndex, charOccurenceCountMap.lookup(Lchar));
                            barcodeMaskIndex = barcodeMaskIndex + charOccurenceCountMap.lookup(Lchar);
                        }
                        else
                        {
                            for (j = 1; j <= charOccurenceCountMap.lookup(Lchar); j++)
                            {
                                if (substr(BarcodeNo, j, 1) != Lchar)
                                {
                                    error(strfmt("@RET4100", charOccurenceCountMap.lookup(Lchar)));
                                    return '';
                                }
                            }

                            tempBarcode = tempBarcode + RetailParameters::find().EANLicenseNo;
                            barcodeMaskIndex = barcodeMaskIndex + charOccurenceCountMap.lookup(Lchar);
                        }
                    }

                    break;

                case Ichar:
                    if (isBarcodeNoStrLengthLessThanBarcodeMask)
                    {
                        if (strlen(BarcodeNo) > charOccurenceCountMap.lookup(Ichar))
                        {
                            error(strfmt("@RET4096", charOccurenceCountMap.lookup(Ichar)));
                            return '';
                        }

                        tempBarcode = tempBarcode + strrep(#ZERO, charOccurenceCountMap.lookup(Ichar) - STRLEN(BarcodeNo)) + BarcodeNo;
                        barcodeMaskIndex = barcodeMaskIndex + charOccurenceCountMap.lookup(Ichar);
                        BarcodeNo = "";
                    }
                    else
                    {
                        tempBarcode = tempBarcode + substr(BarcodeNo, barcodeMaskIndex, 1);
                        barcodeMaskIndex++;
                    }

                    break;

                case Xchar:
                    if (isBarcodeNoStrLengthLessThanBarcodeMask)
                    {
                        error( strfmt("@RET4097",Xchar,Zchar,Cchar,Schar));
                        return '';
                    }
                    else
                    {
                        tempBarcode = tempBarcode + substr(BarcodeNo, barcodeMaskIndex, 1);
                        barcodeMaskIndex++;
                    }
                    break;

                case Mchar:
                    if (!isBarcodeNoStrLengthLessThanBarcodeMask)
                    {
                        tempBarcode = tempBarcode + substr(BarcodeNo, barcodeMaskIndex, 1);
                    }

                    barcodeMaskIndex++;
                    break;

                case Schar:
                case Zchar:
                case Cchar:
                case Uchar:
                    tempBarcode = tempBarcode + maskChar;
                    barcodeMaskIndex++;
                    break;

                case c:
                    if (isBarcodeNoStrLengthLessThanBarcodeMask)
                    {
                        tempBarcode = tempBarcode + maskChar;
                        barcodeMaskIndex++;
                    }
                    else
                    {
                        if (substr(BarcodeNo, barcodeMaskIndex, 1) != maskChar)
                        {
                            error(strfmt("@RET4101", barcodeMaskIndex, maskChar));
                            return'';
                        }

                        tempBarcode = tempBarcode + substr(BarcodeNo, barcodeMaskIndex, 1);
                        barcodeMaskIndex++;
                    }
                    break;

                default:
                    RetailProcessUnsupportedBarcodeMaskCharacterRequest processBarcodeMaskCharacter = new RetailProcessUnsupportedBarcodeMaskCharacterRequest();
                    
                    processBarcodeMaskCharacter.paramBarcodeNo(BarcodeNo);
                    processBarcodeMaskCharacter.paramTempBarcodeId(tempBarcode);
                    processBarcodeMaskCharacter.paramMaskChar(maskChar);
                    processBarcodeMaskCharacter.paramBarcodeMaskIndex(barcodeMaskIndex);

                    RetailProcessUnsupportedBarcodeMaskCharacterResponse processBarcodeMaskResponse;
                    processBarcodeMaskResponse = this.processUnSupportedBarcodeMaskCharacter(processBarcodeMaskCharacter);

                    if (processBarcodeMaskResponse.paramIsSuccessfull())
                    {
                        tempBarcode = processBarcodeMaskResponse.paramTempBarcodeId();
                        barcodeMaskIndex++;
                    }
                    else
                    {
                        error(strfmt("@RET4098",maskChar));
                        return '';
                    }
                    break;
            }
        }
        while(barcodeMaskIndex != strLen(barcodeMaskWithoutPrefix) + 1);

        BarcodeNo = this.returnBarcForItemVariant(
                    tempBarcode,
                    _inventDimCombination,
                    barcodeMaskWithoutPrefix,
                    charPositionMap.lookup(Zchar),
                    charPositionMap.lookup(Cchar),
                    charPositionMap.lookup(Schar),
                    charOccurenceCountMap.lookup(Zchar),
                    charOccurenceCountMap.lookup(Cchar),
                    charOccurenceCountMap.lookup(Schar),
                    charPositionMap.lookup(Uchar),
                    charOccurenceCountMap.lookup(Uchar),
                    _unitId);

        // Adding back the prefix to barcode 
        BarcodeNo = prefix + BarcodeNo;

        // Need to pass length of mask + 1 because the check digit has been previously stripped from the mask.
        if (this.hasCheckDigit(barcodeSetup)) // true when check-digit is required for barcode setup and apply the check-digit calculation
        {
            BarcodeNo = Barcode::insertModulo10CheckDigit(BarcodeNo,strlen(_BarcodeMask) + 1);
        }

        return BarcodeNo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processUnsupportedBarcodeMaskCharacter</Name>
				<Source><![CDATA[
    /// <summary>
    ///  This method checks whether it is replaceable and returns <c>processBarcodeMaskResponse</c>.
    /// </summary>
    /// <param name = "processBarcodeMaskCharacter">
    /// Class RetailProcessUnsupportedBarcodeMaskCharacterRequest.
    /// </param>
    /// <returns>
    /// processBarcodeMaskResponse with temp barcode id.
    /// </returns>
    [Replaceable]
    public RetailProcessUnsupportedBarcodeMaskCharacterResponse processUnsupportedBarcodeMaskCharacter(RetailProcessUnsupportedBarcodeMaskCharacterRequest processBarcodeMaskCharacter)
    {
        RetailProcessUnsupportedBarcodeMaskCharacterResponse processBarcodeMaskResponse = new RetailProcessUnsupportedBarcodeMaskCharacterResponse();

        processBarcodeMaskResponse.paramIsSuccessfull(false);
        processBarcodeMaskResponse.paramTempBarcodeId(processBarcodeMaskCharacter.paramTempBarcodeId());

        return processBarcodeMaskResponse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBarcodeNoDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a barcode for the item with no dimensions.
    /// </summary>
    /// <param name="_barcodeMask">
    /// The barcode mask of the item.
    /// </param>
    /// <param name="_itemID">
    /// The item number of the specified item.
    /// </param>
    /// <param name="_unitId">
    /// The unit of measure code for the item.
    /// </param>
    /// <param name="_useItemId">
    ///  A boolean value that indicates whether to use the itemID or not.
    /// </param>
    /// <returns>
    /// The calculated item barcode.
    /// </returns>
    itemBarcode createBarcodeNoDim(RetailBarcodeMask _barcodeMask, ItemId _itemID, UnitOfMeasureSymbol _unitId, ItemId _useItemId)
    {
        str                     tempBarcode;
        str                     checkStr;
        RetailBarcodeMask       barcodeNo;
        int                     barcodeMaskIndex;
        RetailBarcodeMask       barcodeMaskWithoutPrefix;
        RetailBarcodeMaskPrefix prefix = this.getPrefixForBarcodeMask();

        // Stripping the prefix from the barcode mask to avoid parsing of masked characters in prefix if they exist.
        // Prefix will be added back to the generated barcode after completion of parsing barcode mask.
        barcodeMaskWithoutPrefix = strDel(_barcodeMask, 1, strLen(prefix));

        if (!RetailParameters::find())
        {
            error("@RET4092");
            return '';
        }

        barcodeNo = _ItemId;

        if (_useItemId != '')
        {
            barcodeNo = _useItemId;
        }

        if (strlen(barcodeNo) > strlen(barcodeMaskWithoutPrefix))
        {
            error("@RET4095");
            return '';
        }

        this.calcMask(barcodeMaskWithoutPrefix);
        tempBarcode = '';

        if (strlen(barcodeNo) < strlen(barcodeMaskWithoutPrefix))
        {
            barcodeMaskIndex = 1;
            do
            {
                str maskChar = subStr(barcodeMaskWithoutPrefix, barcodeMaskIndex, 1);
                boolean itemBarcode, isMaskChar;

                [tempBarcode, barcodeMaskIndex, barcodeNo, itemBarcode, isMaskChar] = this.getBarcode(
                    barcodeMaskWithoutPrefix,
                    barcodeMaskIndex,
                    tempBarcode,
                    barcodeNo,
                    maskChar);

                if (!isMaskChar)
                {
                    error(strfmt("@RET4098", maskChar));
                    return '';
                }

                if (!itemBarcode)
                {
                    return '';
                }
            }

            While (barcodeMaskIndex != strLen(barcodeMaskWithoutPrefix) + 1);

            barcodeNo = tempBarcode;
        }

        // Adding back the prefix to barcode
        barcodeNo = prefix + barcodeNo;

        if (this.hasCheckDigit(barcodeSetup))// true, If check-digit is required for barcode setup.
        {
            barcodeNo = Barcode::insertModulo10CheckDigit(barcodeNo, strLen(_BarcodeMask) + 1);
        }

        return barcodeNo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBarcode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the barcode based on barcode mask.
    /// </summary>
    /// <param name = "_barcodeMask">
    /// The barcode mask of the item.
    /// </param>
    /// <param name = "_barcodeMaskIndex">
    /// The barcode mask index.
    /// </param>
    /// <param name = "_tempBarcode">
    /// The temporary barcode.
    /// </param>
    /// <param name = "_barcodeNo">
    /// The barcode of the item.
    /// </param>
    /// <param name = "_maskChar">
    /// The sub string of the barcode mask.
    /// </param>
    /// <returns>
    /// The container containing barcode number, temporary barcode and barcode mask index values.
    /// </returns>
    [Wrappable(true)]
    protected final container getBarcode(
        RetailBarcodeMask _barcodeMask,
        int _barcodeMaskIndex,
        str _tempBarcode,
        RetailBarcodeMask _barcodeNo,
        str _maskChar)
    {
        #Retail

        int barcodeMaskIndex = _barcodeMaskIndex;
        str tempBarcode = _tempBarcode;
        RetailBarcodeMask barcodeNo = _barcodeNo;
        boolean itemBarcode = true;
        boolean isMaskChar = true;

        char c = int2str(strFind("0123456789", _maskChar, 1, 10) - 1);

        switch (_maskChar)
        {
            case Lchar:
                tempBarcode = _tempBarcode + RetailParameters::find().EANLicenseNo;
                barcodeMaskIndex += charOccurenceCountMap.lookup(Lchar);
                break;

            case Ichar:
                if (strLen(_barcodeNo) > charOccurenceCountMap.lookup(Ichar))
                {
                    error(strfmt("@RET4096", charOccurenceCountMap.lookup(Ichar)));
                    itemBarcode = false;
                    break;
                }

                tempBarcode = _tempBarcode + strrep(#ZERO, charOccurenceCountMap.lookup(Ichar) - strLen(_barcodeNo)) + _barcodeNo;
                barcodeMaskIndex += charOccurenceCountMap.lookup(Ichar);
                barcodeNo = '';
                break;

            case Xchar:
                error(strfmt("@RET4097", Xchar, Zchar, Cchar, Schar));
                itemBarcode = false;
                break;

            case Schar:
            case Zchar:
            case Cchar:
            case Uchar:
                tempBarcode = _tempBarcode + _maskChar;
                barcodeMaskIndex++;
                break;

            case c:
                tempBarcode = _tempBarcode + _maskChar;
                barcodeMaskIndex++;
                break;

            case Mchar:
                barcodeMaskIndex++;
                break;

            case Nchar:
                if (strLen(_barcodeNo) > charOccurenceCountMap.lookup(Nchar))
                {
                    error(strfmt("@RET4096", charOccurenceCountMap.lookup(Nchar)));
                    itemBarcode = false;
                    break;
                }

                tempBarcode = _tempBarcode + strRep(#ZERO, charOccurenceCountMap.lookup(Nchar) - strLen(_barcodeNo)) + _barcodeNo;
                barcodeMaskIndex += charOccurenceCountMap.lookup(Nchar);
                barcodeNo = '';
                break;

            case Pchar:
                tempBarcode = _tempBarcode + strRep(#ZERO, charOccurenceCountMap.lookup(Pchar));
                barcodeMaskIndex += charOccurenceCountMap.lookup(Pchar);
                break;

            case Qchar:
                tempBarcode = _tempBarcode + strRep(#ZERO, charOccurenceCountMap.lookup(Qchar));
                barcodeMaskIndex += charOccurenceCountMap.lookup(Qchar);
                break;

            default:
                isMaskChar = false;
        }

        return [tempBarcode, barcodeMaskIndex, barcodeNo, itemBarcode, isMaskChar];
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasCheckDigit</Name>
				<Source><![CDATA[
    /// <summary>
    ///  This method checks whether check-digit is required for specific setups.
    /// </summary>
    /// <param name="_barcodeSetup">
    ///  A buffer of table <c>BarcodeSetup</c>.
    /// </param>
    /// <returns>
    ///  A boolean true if check-digit is required otherwise, false.
    /// </returns>
    public boolean hasCheckDigit(BarcodeSetup _barcodeSetup)
    {
        boolean ret = false;

        if (_barcodeSetup.barcodeType == BarcodeType::EAN13 ||
                _barcodeSetup.barcodeType == BarcodeType::EAN8 ||
                _barcodeSetup.barcodeType == BarcodeType::UPCA ||
                _barcodeSetup.barcodeType == BarcodeType::UPCE)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMaskCharacters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Intializes all the mask characters.
    /// </summary>
    void initMaskCharacters()
    {
        Ichar = RetailBarcodeMaskCharacter::find(RetailBarcodeMaskCharacterTypeBase::ItemId).Character;
        Xchar = RetailBarcodeMaskCharacter::find(RetailBarcodeMaskCharacterTypeBase::AnyNumber).Character;
        Mchar = RetailBarcodeMaskCharacter::find(RetailBarcodeMaskCharacterTypeBase::CheckDigit).Character;
        Zchar = RetailBarcodeMaskCharacter::find(RetailBarcodeMaskCharacterTypeBase::SizeDigit).Character;
        Cchar = RetailBarcodeMaskCharacter::find(RetailBarcodeMaskCharacterTypeBase::ColorDigit).Character;
        Schar = RetailBarcodeMaskCharacter::find(RetailBarcodeMaskCharacterTypeBase::StyleDigit).Character;
        Lchar = RetailBarcodeMaskCharacter::find(RetailBarcodeMaskCharacterTypeBase::EANLicenseCode).Character;
        Pchar = RetailBarcodeMaskCharacter::find(RetailBarcodeMaskCharacterTypeBase::Price).Character;
        Qchar = RetailBarcodeMaskCharacter::find(RetailBarcodeMaskCharacterTypeBase::Quantity).Character;
        Echar = RetailBarcodeMaskCharacter::find(RetailBarcodeMaskCharacterTypeBase::Employee).Character;
        Uchar = RetailBarcodeMaskCharacter::find(RetailBarcodeMaskCharacterTypeBase::Customer).Character;
        Achar = RetailBarcodeMaskCharacter::find(RetailBarcodeMaskCharacterTypeBase::DataEntry).Character;
        Nchar = RetailBarcodeMaskCharacter::find(RetailBarcodeMaskCharacterTypeBase::CouponCode).Character;

        charPositionMap.insert( Lchar, 0);
        charPositionMap.insert( Ichar, 0);
        charPositionMap.insert( Mchar, 13);
        charPositionMap.insert( Cchar, 0);
        charPositionMap.insert( Zchar, 0);
        charPositionMap.insert( Schar, 0);
        charPositionMap.insert( Pchar, 0);
        charPositionMap.insert( Qchar, 0);
        charPositionMap.insert( Echar, 0);
        charPositionMap.insert( Uchar, 0);
        charPositionMap.insert( Achar, 0);
        charPositionMap.insert( Nchar, 0);

        charOccurenceCountMap.insert(Lchar, 0);
        charOccurenceCountMap.insert(Ichar, 0);
        charOccurenceCountMap.insert(Cchar, 0);
        charOccurenceCountMap.insert(Zchar, 0);
        charOccurenceCountMap.insert(Schar, 0);
        charOccurenceCountMap.insert(Pchar, 0);
        charOccurenceCountMap.insert(Qchar, 0);
        charOccurenceCountMap.insert(Echar, 0);
        charOccurenceCountMap.insert(Uchar, 0);
        charOccurenceCountMap.insert(Achar, 0);
        charOccurenceCountMap.insert(Nchar, 0);

        this.initMaskCharactersDelegate(charPositionMap, charOccurenceCountMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMaskCharactersDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to allow initialization of all mask characters.
    /// </summary>
    /// <param name = "_charPositionMap">Stores the position of the occurance of a character in a barcode string.</param>
    /// <param name = "_charOccurenceCountMap">Stores the number of occurances of a character in a barcode string.</param>
    delegate void initMaskCharactersDelegate(Map _charPositionMap, Map _charOccurenceCountMap)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the parameter is a number.
    /// </summary>
    /// <param name="_letter">
    /// The string to be checked.
    /// </param>
    /// <returns>
    /// A boolean value, true if the string is a number.Otherwise false.
    /// </returns>
    boolean isNum(str _letter)
    {
        int j = 0;

        j = strFind(strupr(_letter), '0123456789', 1, strLen(_letter));

        if (j == 0)
            return false;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBarcodeSetup</Name>
				<Source><![CDATA[
    public BarcodeSetup parmBarcodeSetup(BarcodeSetup _barcodeSetup = barcodeSetup)
    {
        barcodeSetup = _barcodeSetup;

        return barcodeSetup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnBarcForItemVariant</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates barcode mask from the item variants.
    /// </summary>
    /// <param name="_barcodeNo">
    /// The barcode of the item.
    /// </param>
    /// <param name="_iDCombination">
    /// The inventory dimensions combination code.
    /// </param>
    /// <param name="_barcodeMask">
    /// The barcode mask of the item.
    /// </param>
    /// <param name="sizePos">
    /// An integer that gives the size variant position in the dimension barcode.
    /// </param>
    /// <param name="colorPos">
    /// An integer that gives the color variant position in the dimension barcode.
    /// </param>
    /// <param name="stylePos">
    /// An integer that gives the stlye variant position in the dimension barcode.
    /// </param>
    /// <param name="sizeNum">
    /// An integer that gives the size variant number in the dimension barcode.
    /// </param>
    /// <param name="colorNum">
    /// An integer that gives the color variant number in the dimension barcode.
    /// </param>
    /// <param name="styleNum">
    /// An integer that gives the style variant number in the dimension barcode.
    /// </param>
    /// <param name="IUOMPos">
    /// An integer that gives the unit of measure position in the dimension barcode.
    /// </param>
    /// <param name="UOMNum">
    /// An integer that gives the unit of measure number in the dimension barcode.
    /// </param>
    /// <param name="UOMCode">
    /// The unit of measure code in the deimension barcode.
    /// </param>
    /// <returns>
    /// The barcode mask of the item.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// throws exception if the variants are not available in their respective tables.
    /// </exception>
    RetailBarcodeMask returnBarcForItemVariant(RetailBarcodeMask _barcodeNo,
                                            InventDimCombination _iDCombination,
                                            RetailBarcodeMask _barcodeMask,
                                            int sizePos,
                                            int colorPos,
                                            int stylePos,
                                            int sizeNum,
                                            int colorNum,
                                            int styleNum,
                                            int IUOMPos,
                                            int UOMNum,
                                            UnitOfMeasureSymbol UOMCode)
    {
        RetailBarcodeMask  DimBarcode;
        EcoResProductMaster ecoResProductMaster;

        RetailSizeGroupTrans   sizeGroupTrans;
        RetailColorGroupTrans  colorGroupTrans;
        RetailStyleGroupTrans  styleGroupTrans;
        EcoResProductMasterSize ecoResProductMasterSize;
        EcoResProductMasterColor ecoResProductMasterColor;
        EcoResProductMasterStyle ecoResProductMasterStyle;
        EcoResSize  ecoResSize;
        EcoResColor ecoResColor;
        EcoResStyle ecoResStyle;

        DimBarcode = _barcodeNo;

        ecoResProductMaster = EcoResProductMaster::find(EcoResDistinctProductVariant::find(_iDCombination.DistinctProductVariant).ProductMaster);
        if (sizePos > 0)
        {
            sizeGroupTrans = RetailSizeGroupTrans::find(ecoResProductMaster.RetailSizeGroupId,_iDCombination.InventDim().InventSizeId);

            // Fetching ecoResize and ecoresProductMasterSize buffer to check the variants from product master dimensions.
            select firstonly RecId from ecoResSize
                where ecoResSize.Name == _iDCombination.InventDim().InventSizeId;

            select firstonly ecoResProductMasterSize
                where ecoResProductMasterSize.SizeProductMaster == ecoResProductMaster.RecId
                   && ecoResProductMasterSize.Size == ecoResSize.RecId;

            // If the both tables sizeGroupTrans and ecoResProductMasterSize are null then only allowing to throw error.
            if (!sizeGroupTrans && !ecoResProductMasterSize)
            {
                error(strfmt("@RET4102",_iDCombination.InventDim().InventSizeId,ecoResProductMaster.RetailSizeGroupId));
                return '';
            }

            if (sizeGroupTrans && strlen(sizeGroupTrans.noInBarcode) > SizeNum)
            {
                error(strfmt("@RET4103",SizeNum) +
                            strfmt("@RET4104",
                            _iDCombination.InventDim().InventSizeId,ecoResProductMaster.RetailSizeGroupId,strlen(sizeGroupTrans.noInBarcode),sizeGroupTrans.noInBarcode));
                return '';
            }

            if (ecoResProductMasterSize && strlen(ecoResProductMasterSize.noInBarcode) > SizeNum)
            {
                error(strfmt("@RET4103",SizeNum) +
                            strfmt("@RET4104",
                            _iDCombination.InventDim().InventSizeId,ecoResProductMaster.RetailSizeGroupId,strlen(ecoResProductMasterSize.noInBarcode),ecoResProductMasterSize.noInBarcode));
                return '';
            }

            // Fetching barcode only when there is value in sizGroupTrans and ecoResProductMasterSize\noInBarcode.
            if (sizeGroupTrans)
            {
                DimBarcode = substr(DimBarcode,1,SizePos - 1) +
                             substr('0000000000',1,SizeNum - strlen(sizeGroupTrans.noInBarcode)) +
                             sizeGroupTrans.noInBarcode +
                             substr(DimBarcode,SizePos + SizeNum,strlen(DimBarcode) - SizePos - SizeNum + 1);
            }
            else if (ecoResProductMasterSize.noInBarcode)
            {
                DimBarcode = substr(DimBarcode,1,SizePos - 1) +
                             substr('0000000000',1,SizeNum - strlen(ecoResProductMasterSize.noInBarcode)) +
                             ecoResProductMasterSize.noInBarcode +
                             substr(DimBarcode,SizePos + SizeNum,strlen(DimBarcode) - SizePos - SizeNum + 1);
            }
        }
        if (colorPos > 0)
        {
            colorGroupTrans = RetailColorGroupTrans::find(ecoResProductMaster.RetailColorGroupId, _iDCombination.InventDim().InventColorId);

            // Fetching ecoResColor and ecoresProductMasterColor buffer to check the variants from product master dimensions.
            select firstonly RecId from ecoResColor
                where ecoResColor.Name == _iDCombination.InventDim().InventColorId;

            select firstonly ecoResProductMasterColor
                where ecoResProductMasterColor.ColorProductMaster == ecoResProductMaster.RecId
                   && ecoResProductMasterColor.Color == ecoResColor.RecId;

            // If the both tables colorGroupTrans and ecoResProductMasterColor are null then only allowing to throw error.
            if (!colorGroupTrans && !ecoResProductMasterColor)
            {
                error(strfmt("@RET4105",_iDCombination.InventDim().InventColorId, ecoResProductMaster.RetailColorGroupId));
                return '';
            }

            if (colorGroupTrans && strlen(colorGroupTrans.noInBarcode) > ColorNum)
            {
                error(strfmt("@RET4106",ColorNum) +
                            strfmt("@RET4107",
                            _iDCombination.InventDim().InventColorId,ecoResProductMaster.RetailColorGroupId,strlen(colorGroupTrans.noInBarcode),colorGroupTrans.noInBarcode));
                return '';
            }
            if (ecoResProductMasterColor && strlen(ecoResProductMasterColor.noInBarcode) > ColorNum)
            {
                error(strfmt("@RET4106",ColorNum) +
                            strfmt("@RET4107",
                            _iDCombination.InventDim().InventColorId,ecoResProductMaster.RetailColorGroupId,strlen(ecoResProductMasterColor.noInBarcode),ecoResProductMasterColor.noInBarcode));
                return '';
            }

            // Fetching barcode only when there is value in colorGroupTrans and ecoResProductMasterColor\noInBarcode.
            if (colorGroupTrans)
            {
                DimBarcode = substr(DimBarcode,1,ColorPos - 1) +
                         substr('0000000000',1,ColorNum - strlen(colorGroupTrans.noInBarcode)) +
                         colorGroupTrans.noInBarcode +
                         substr(DimBarcode,ColorPos + ColorNum,strlen(DimBarcode) - ColorPos - ColorNum + 1);
            }
            else if(ecoResProductMasterColor.noInBarcode)
            {
                DimBarcode = substr(DimBarcode,1,ColorPos - 1) +
                         substr('0000000000',1,ColorNum - strlen(ecoResProductMasterColor.noInBarcode)) +
                         ecoResProductMasterColor.noInBarcode +
                         substr(DimBarcode,ColorPos + ColorNum,strlen(DimBarcode) - ColorPos - ColorNum + 1);
            }
        }

        if (charPositionMap.lookup(Schar) > 0)
        {
            styleGroupTrans = RetailStyleGroupTrans::find(ecoResProductMaster.RetailStyleGroupId,_iDCombination.inventDim().InventStyleId);

            // Fetching ecoResStyle and ecoResProductMasterStyle buffer to check the variants from product master dimensions.
            select firstonly RecId from ecoResStyle
                where ecoResStyle.Name == _iDCombination.InventDim().InventStyleId;

            select firstonly ecoResProductMasterStyle
                where ecoResProductMasterStyle.StyleProductMaster == ecoResProductMaster.RecId
                   && ecoResProductMasterStyle.Style == ecoResStyle.RecId;

            // If the both tables styleGroupTrans and ecoResProductMasterStyle are null then only allowing to throw error.
            if (!styleGroupTrans && !ecoResProductMasterStyle)
                error(strfmt("@RET4108",_iDCombination.InventDim().InventStyleId,ecoResProductMaster.RetailStyleGroupId));

            if (styleGroupTrans && strlen(styleGroupTrans.noInBarcode) > StyleNum)
            {
                error(strfmt("@RET4109",StyleNum) +
                            strfmt("@RET4110",
                            _iDCombination.inventDim().InventStyleId,ecoResProductMaster.RetailStyleGroupId,strlen(styleGroupTrans.noInBarcode),styleGroupTrans.noInBarcode));
            }

            if (ecoResProductMasterStyle && strlen(ecoResProductMasterStyle.noInBarcode) > StyleNum)
            {
                error(strfmt("@RET4109",StyleNum) +
                            strfmt("@RET4110",
                            _iDCombination.inventDim().InventStyleId,ecoResProductMaster.RetailStyleGroupId,strlen(ecoResProductMasterStyle.noInBarcode),ecoResProductMasterStyle.noInBarcode));
            }

            // Fetching barcode only when there is value in styleGroupTrans and ecoResProductMasterStyle\noInBarcode.
            if (styleGroupTrans)
            {
                DimBarcode = substr(DimBarcode,1,StylePos - 1) +
                         substr('0000000000',1,StyleNum - strlen(styleGroupTrans.noInBarcode)) +
                         styleGroupTrans.noInBarcode +
                         substr(DimBarcode,StylePos + StyleNum,strlen(DimBarcode) - StylePos - StyleNum + 1);
            }
            else if(ecoResProductMasterStyle.noInBarcode)
            {
                DimBarcode = substr(DimBarcode,1,StylePos - 1) +
                         substr('0000000000',1,StyleNum - strlen(ecoResProductMasterStyle.noInBarcode)) +
                         ecoResProductMasterStyle.noInBarcode +
                         substr(DimBarcode,StylePos + StyleNum,strlen(DimBarcode) - StylePos - StyleNum + 1);
            }
        }

        if (charPositionMap.lookup(Uchar) > 0)
        {
            if (UOMCode == "")
            {
                error(strfmt("@RET4111",_iDCombination.ItemId));
                return '';
            }
        }
        return DimBarcode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBarcodeJpegImageAsBase64String</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an image of the bacode as base64string.
    /// </summary>
    /// <param name="barcodeStr">
    /// The barcode string of the item.
    /// </param>
    /// <param name="fontName">
    /// The name of font used.
    /// </param>
    /// <param name="fontSize">
    /// The size of the font used.
    /// </param>
    /// <returns>
    /// The string that represents an image.
    /// </returns>
    public static str getBarcodeJpegImageAsBase64String(str barcodeStr, str fontName, int fontSize)
    {
        System.Drawing.Bitmap barcode;
        System.Drawing.SizeF dataSize;
        System.Drawing.Font barcodeFont;
        System.Drawing.Graphics graphics;
        System.IO.MemoryStream memoryStream;
        System.String base64Image;

        // Surrounding by *'s tells the barcode to render
        barcodeStr = System.String::Format("*{0}*", barcodeStr);
        barcode = new System.Drawing.Bitmap(1, 1);
        barcodeFont = new System.Drawing.Font(fontName, fontSize, System.Drawing.FontStyle::Regular, System.Drawing.GraphicsUnit::Point);

        // Get graphics object from the bitmap
        graphics = System.Drawing.Graphics::FromImage(barcode);

        // measure out the size of the string when rendered as a barcode
        dataSize = graphics.MeasureString(barcodeStr, barcodeFont);

        // Updating the image to the new size
        barcode = new System.Drawing.Bitmap(barcode, dataSize.ToSize());

        // Updating the graphics with the current size
        graphics = System.Drawing.Graphics::FromImage(barcode);

        graphics.Clear(System.Drawing.Color::get_White());

        //Smoother rendering for scanning
        graphics.set_TextRenderingHint(System.Drawing.Text.TextRenderingHint::SingleBitPerPixel);

        //Draw out the barcode
        graphics.DrawString(barcodeStr, barcodeFont, new System.Drawing.SolidBrush(System.Drawing.Color::get_Black()), 0, 0);

        // Save the barcode to a base 64 string
        memoryStream = new System.IO.MemoryStream();
        barcode.Save(memoryStream, System.Drawing.Imaging.ImageFormat::get_Jpeg());
        base64Image = System.Convert::ToBase64String(memoryStream.ToArray());

        // Clean up
        graphics.Flush();
        barcodeFont.Dispose();
        graphics.Dispose();
        memoryStream.Dispose();

        return base64Image;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSeq</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a new number sequence value for the item barcode.
    /// </summary>
    /// <param name="_makeDecisionLater">
    /// A boolean value in Number sequence table.
    /// </param>
    /// <param name="_dontThrowOnMissingRefSetUp">
    /// A boolean value in Number sequence table.
    /// </param>
    /// <returns>
    /// The generated number sequence value.
    /// </returns>

    static NumberSeq numberSeq(
        boolean _makeDecisionLater              = FALSE,
        boolean _dontThrowOnMissingRefSetUp     = FALSE
        )
    {
        return NumberSeq::newGetNum(NumberSeqReference::findReference(Extendedtypenum(ItemBarCode)),
            _makeDecisionLater,
            _dontThrowOnMissingRefSetUp);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrefixForBarcodeMask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the prefix from <c>RetailCreateBarcodesWithPrefixContext</c> if available,
    /// otherwise will initialize as an empty string and return it.
    /// </summary>
    /// <returns>Barcode mask prefix.</returns>
    private RetailBarcodeMaskPrefix getPrefixForBarcodeMask()
    {
        RetailCreateBarcodesWithPrefixContext currentInstance = RetailCreateBarcodesWithPrefixContext::current();
        RetailBarcodeMaskPrefix prefix = currentInstance ? currentInstance.parmBarcodeMaskPrefix() : '';

        return prefix;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>