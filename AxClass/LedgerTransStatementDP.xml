<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerTransStatementDP</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LedgerTransStatementDP</c> class is the data provider for the <c>LedgerTransStatement</c> report.
/// </summary>
/// <remarks>
///    The base class of this class changed in Microsoft Dynamics AX 2012 R3. Please review the new
///    base class for more information.
/// </remarks>
[SRSReportQuery(queryStr(LedgerTransStatement))]
[SRSReportParameterAttribute(classStr(LedgerTransStatementContract))]
public class LedgerTransStatementDP extends SRSReportDataProviderPreProcessTempDB
{
    LedgerTransStatementTmp ledgerTransStatementTmp;
    recId primaryFocusRecId;
    recId secondaryFocusRecId;
    str mainFocusName, secondaryFocusName;

    public static const str 1 OffsetAccountSeparator = ',';

    protected PreferredLocale locale = new Session().preferredLocale();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calculateEndingBalanceInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the ending balance for the ledger accounts.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_endDate">
    /// The end date for the report date range.
    /// </param>
    /// <param name="_dimensionsTransTableType">
    /// The <c>DimensionsTransTableType</c> type for which the report is run.
    /// </param>
    private void calculateEndingBalanceInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, TransDate _endDate, DimensionsTransTableType _dimensionsTransTableType)
    {
        LedgerTransStatementStagingTmp sourceTrans;
        FiscalPeriodType endingBalancePeriodType = 4; // One more than closing transactions
        TransTxt closingText;
        NoYes endingBalance = NoYes::Yes;
        CurrentOperationsTax currentLayer = CurrentOperationsTax::Current;

        // Ending balance
        closingText = "@SYS50986";

        try
        {

            this.setUserConnection(sourceTrans);
            sourceTrans.linkPhysicalTableInstance(_ledgerTransStatementTmp);

            insert_recordset _ledgerTransStatementTmp
                (PostingLayer,
                PeriodCode,
                TransDate,
                AmountCredit,
                AmountDebit,
                ReportingCurrencyAmountCredit,
                ReportingCurrencyAmountDebit,
                MainFocusValue,
                MainFocusDescription,
                GeneralJournalEntryDataArea,
                TransTxt,
                IsEndingBalance)
            select
                currentLayer,
                endingBalancePeriodType,
                _endDate,
                sum(AmountCredit),
                sum(AmountDebit),
                sum(ReportingCurrencyAmountCredit),
                sum(ReportingCurrencyAmountDebit),
                MainFocusValue,
                MainFocusDescription,
                GeneralJournalEntryDataArea,
                closingText,
                endingBalance
            from sourceTrans
            group by sourceTrans.MainFocusValue, sourceTrans.MainFocusDescription, sourceTrans.GeneralJournalEntryDataArea
            where sourceTrans.RecordType != DimensionsTransRecordType::Aggregate; // Filter out the sub-total records so that amounts are not considered twice

            update_recordSet _ledgerTransStatementTmp setting
                AccumulatedMST = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
                ReportingAccumulatedMST = _ledgerTransStatementTmp.ReportingCurrencyAmountDebit - _ledgerTransStatementTmp.ReportingCurrencyAmountCredit,
                AmountMSTDebCred = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
                AmountCredit = 0, // Set this to 0 to avoid double-counting in the report total
                AmountDebit = 0,  // Set this to 0 to avoid double-counting in the report total
                ReportingCurrencyAmountCredit = 0,
                ReportingCurrencyAmountDebit = 0
            where _ledgerTransStatementTmp.PeriodCode == endingBalancePeriodType;
        }
        finally
        {
            this.disposeTempTable(sourceTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyToReportTable</Name>
				<Source><![CDATA[
    private void copyToReportTable(LedgerTransStatementStagingTmp _ledgerTransStmtStagingTmp)
    {
        NoYes isFinalTrue = NoYes::Yes;

        insert_recordset ledgerTransStatementTmp
        (
            MainFocusValue,
            MainFocusName,
            MainFocusDescription,
            PeriodCode,
            TransDate,
            Voucher,
            AmountDebit,
            AmountCredit,
            AccumulatedMST,
            ReportingCurrencyAmountDebit,
            ReportingCurrencyAmountCredit,
            ReportingAccumulatedMST,
            AmountCur,
            TransactionCurrencyAmountDebit,
            TransactionCurrencyAmountCredit,
            AmountMSTDebCred,
            CurrencyCode,
            GeneralJournalAccountEntry,
            GeneralJournalEntry,
            GeneralJournalEntryDataArea,
            PreviousCreditTotal,
            PreviousDebitTotal,
            Reversed,
            SecondaryFocus,
            SecondaryFocusName,
            TaxAmount,
            TaxCode,
            TraceNum,
            TransTxt,
            OffsetAccount,
            IsFinalRecord,
            BudgetModelId,
            LedgerPostingType,
            RecordType,
            BudgetTransactionStatus,
            IsEndingBalance,
            GroupRowNum
        )
        select
            MainFocusValue,
            MainFocusName,
            MainFocusDescription,
            PeriodCode,
            TransDate,
            Voucher,
            AmountDebit,
            AmountCredit,
            AccumulatedMST,
            ReportingCurrencyAmountDebit,
            ReportingCurrencyAmountCredit,
            ReportingAccumulatedMST,
            AmountCur,
            TransactionCurrencyAmountDebit,
            TransactionCurrencyAmountCredit,
            AmountMSTDebCred,
            CurrencyCode,
            GeneralJournalAccountEntry,
            GeneralJournalEntry,
            GeneralJournalEntryDataArea,
            PreviousCreditTotal,
            PreviousDebitTotal,
            Reversed,
            SecondaryFocus,
            SecondaryFocusName,
            TaxAmount,
            TaxCode,
            TraceNum,
            TransTxt,
            OffsetAccount,
            isFinalTrue,
            BudgetModelId,
            LedgerPostingType,
            RecordType,
            BudgetTransactionStatus,
            IsEndingBalance,
            GroupRowNum from _ledgerTransStmtStagingTmp
        // Re-order the records since the report prints in recid order and the opening transactions were calculated
        // after some initial operating records were created
        order by MainFocusValue, IsEndingBalance, SecondaryFocus, GeneralJournalEntryDataArea, PeriodCode, RecordType, TransDate, Voucher, TaxCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerTransStatementTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets data from the <c>LedgerTransStatementTmp</c> temporary table.
    /// </summary>
    /// <returns>
    /// Data from the <c>LedgerTransStatementTmp</c> table.
    /// </returns>
    [SRSReportDataSetAttribute(tableStr(LedgerTransStatementTmp))]
    public LedgerTransStatementTmp getLedgerTransStatementTmp()
    {
        select ledgerTransStatementTmp;

        return ledgerTransStatementTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipReportTransaction</Name>
				<Source><![CDATA[
    public boolean parmSkipReportTransaction(boolean _skipReportTransaction = skipReportTransaction)
    {
        if (FeatureStateProvider::isFeatureEnabled(LedgerSSRSReportSkipReportTransactionParmFlight::instance()))
        {
            skipReportTransaction = true;
        }

        return skipReportTransaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupByDayInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups the transactions by day.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The from date.
    /// </param>
    /// <param name="_toDate">
    /// The to date.
    /// </param>
    /// <param name="_generateEmptyPeriods">
    /// A boolean value indicating whether empty periods must be generated.
    /// </param>
    private void groupByDayInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, FromDate _fromDate, ToDate _toDate, boolean _generateEmptyPeriods)
    {
        TransDate currentDate = _fromDate;

        this.groupTransactionsForDayInStaging(_ledgerTransStatementTmp);

        // Loop until all days have been summarized
        while (currentDate <= _toDate)
        {
            if (_generateEmptyPeriods)
            {
                // When grouping by day, we don't need to set day name as transaction text so pass empty string
                this.insertEmptyPeriodInStaging(_ledgerTransStatementTmp, currentDate, '');
            }

            // Move to the next day
            currentDate = currentDate + 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupByMonthInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups the transactions by month.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The from date.
    /// </param>
    /// <param name="_toDate">
    /// The to date.
    /// </param>
    /// <param name="_generateEmptyPeriods">
    /// A boolean value indicating whether empty periods must be generated.
    /// </param>
    private void groupByMonthInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, FromDate _fromDate, ToDate _toDate, boolean _generateEmptyPeriods)
    {
        int month;
        FromDate monthStart;
        ToDate monthEnd;
        TransTxt transTxt;

        // Summarize by month
        monthStart = dateStartMth(_fromDate);
        monthEnd = dateEndMth(_fromDate);

        // Loop until all months have been summarized
        while (monthStart <= _toDate)
        {
            month = mthOfYr(monthStart);
            transTxt = mthName(month);

            this.groupTransactionsByRangeInStaging(_ledgerTransStatementTmp, monthStart, monthEnd, transTxt);

            if (_generateEmptyPeriods)
            {
                this.insertEmptyPeriodInStaging(_ledgerTransStatementTmp, monthStart, transTxt);
            }

            // Move to the next month
            monthStart = dateStartMth(monthEnd + 1);
            monthEnd = dateEndMth(monthStart);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupByPeriodInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups the transactions by the fiscal calendar period.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The from date.
    /// </param>
    /// <param name="_toDate">
    /// The to date.
    /// </param>
    /// <param name="_generateEmptyPeriods">
    /// A boolean value indicating whether empty periods must be generated.
    /// </param>
    private void groupByPeriodInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, FromDate _fromDate, ToDate _toDate, boolean _generateEmptyPeriods)
    {
        FiscalCalendarPeriod period;
        FromDate periodStart;
        ToDate periodEnd;
        FiscalCalendarRecId fiscalCalendar = Ledger::fiscalCalendar(CompanyInfo::current());
        TransTxt transTxt;

        // Summarize by period
        periodStart = LedgerFiscalCalendar::findFirstDayofPeriod(fiscalCalendar, _fromDate);
        periodEnd = LedgerFiscalCalendar::findLastDayofPeriod(fiscalCalendar, _fromDate);

        // Loop until all periods have been summarized
        while (periodStart <= _toDate)
        {
            period = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(fiscalCalendar, periodStart);
            transTxt = period.Name;

            this.groupTransactionsByRangeInStaging(_ledgerTransStatementTmp, periodStart, periodEnd, transTxt);

            if (_generateEmptyPeriods)
            {
                this.insertEmptyPeriodInStaging(_ledgerTransStatementTmp, periodStart, transTxt);
            }

            // Move to the next period
            periodStart = LedgerFiscalCalendar::findFirstDayofPeriod(fiscalCalendar, periodEnd + 1);
            periodEnd = LedgerFiscalCalendar::findLastDayofPeriod(fiscalCalendar, periodStart);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupByQuarterInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups the transactions by quarter.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The from date.
    /// </param>
    /// <param name="_toDate">
    /// The to date.
    /// </param>
    /// <param name="_generateEmptyPeriods">
    /// A boolean value indicating whether empty periods must be generated.
    /// </param>
    private void groupByQuarterInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, FromDate _fromDate, ToDate _toDate, boolean _generateEmptyPeriods)
    {
        int quarter;
        FromDate quarterStart;
        ToDate quarterEnd;
        FiscalCalendarRecId fiscalCalendar = Ledger::fiscalCalendar(CompanyInfo::current());
        TransTxt transTxt;

        // Summarize by quarter
        quarterStart = FiscalCalendars::findFirstDayOfQuarter(fiscalCalendar, _fromDate);
        quarterEnd = FiscalCalendars::findLastDayOfQuarter(fiscalCalendar, _fromDate);

        // Loop until all quarters have been summarized
        while (quarterStart <= _toDate)
        {
            quarter = LedgerFiscalCalendar::findQuarterByDate(fiscalCalendar, quarterStart);
            transTxt = strFmt("@SYS24735", quarter);

            this.groupTransactionsByRangeInStaging(_ledgerTransStatementTmp, quarterStart, quarterEnd, transTxt);

            if (_generateEmptyPeriods)
            {
                this.insertEmptyPeriodInStaging(_ledgerTransStatementTmp, quarterStart, transTxt);
            }

            // Move to the next quarter
            quarterStart = FiscalCalendars::findFirstDayOfQuarter(fiscalCalendar, quarterEnd + 1);
            quarterEnd = FiscalCalendars::findLastDayOfQuarter(fiscalCalendar, quarterStart);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupByWeekInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups the transactions by week.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The from date.
    /// </param>
    /// <param name="_toDate">
    /// The to date.
    /// </param>
    /// <param name="_generateEmptyPeriods">
    /// A boolean value indicating whether empty periods must be generated.
    /// </param>
    private void groupByWeekInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, FromDate _fromDate, ToDate _toDate, boolean _generateEmptyPeriods)
    {
        int week;
        FromDate weekStart;
        ToDate weekEnd;
        TransTxt transTxt;

        // Summarize by week
        weekStart = DateTimeUtil::getStartOfWeekDate(locale, _fromDate);
        weekEnd = DateTimeUtil::getEndOfWeekDate(locale, weekStart);

        // Loop until all weeks have been summarized
        while (weekStart <= _toDate)
        {
            week = DateTimeUtil::getWeekOfYear(new Session().preferredLocale(), weekStart);
            transTxt = strFmt("@SYS24734", week);

            this.groupTransactionsByRangeInStaging(_ledgerTransStatementTmp, weekStart, weekEnd, transTxt);

            if (_generateEmptyPeriods)
            {
                this.insertEmptyPeriodInStaging(_ledgerTransStatementTmp, weekStart, transTxt);
            }

            // Move to the next week
            weekStart = DateTimeUtil::getStartOfWeekDate(locale, weekEnd + 1);
            weekEnd = DateTimeUtil::getEndOfWeekDate(locale, weekStart);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupTransactionsByRangeInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups the transactions by date range.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The start date of the date range.
    /// </param>
    /// <param name="_toDate">
    /// The end date of the date range.
    /// </param>
    /// <param name="_txt">
    /// The transaction text to be used for the grouped transactions.
    /// </param>
    private void groupTransactionsByRangeInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, FromDate _fromDate, ToDate _toDate, TransTxt _txt)
    {
        LedgerTransStatementStagingTmp  tmpTransGrouped;
        NoYes                           yes = NoYes::Yes;
        AmountCur                       transactionCurrencyAmount = 0.0;

        try
        {
            this.setUserConnection(tmpTransGrouped);
            tmpTransGrouped.linkPhysicalTableInstance(_ledgerTransStatementTmp);

            // Group the operating transactions within the date range, updating their text
            insert_recordset tmpTransGrouped
            (
                MainFocusValue,
                MainFocusDescription,
                SecondaryFocus,
                GeneralJournalEntryDataArea,
                PeriodCode,
                TransDate,
                AmountDebit,
                AmountCredit,
                ReportingCurrencyAmountDebit,
                ReportingCurrencyAmountCredit,
                TransactionCurrencyAmountDebit,
                TransactionCurrencyAmountCredit,
                AmountCur,
                AmountMSTDebCred,
                PreviousCreditTotal,
                PreviousDebitTotal,
                TransTxt,
                IsFinalRecord)
            select
                MainFocusValue,
                MainFocusDescription,
                SecondaryFocus,
                GeneralJournalEntryDataArea,
                PeriodCode,
                _fromDate,
                sum(AmountDebit),
                sum(AmountCredit),
                sum(ReportingCurrencyAmountDebit),
                sum(ReportingCurrencyAmountCredit),
                transactionCurrencyAmount,
                transactionCurrencyAmount,
                transactionCurrencyAmount,
                sum(AmountMSTDebCred),
                sum(PreviousCreditTotal),
                sum(PreviousDebitTotal),
                _txt,
                yes
            from _ledgerTransStatementTmp
            group by MainFocusValue, MainFocusDescription, SecondaryFocus, GeneralJournalEntryDataArea, PeriodCode
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating
                && _ledgerTransStatementTmp.TransDate >= _fromDate
                && _ledgerTransStatementTmp.TransDate <= _toDate;

            // Fill in the summation
            update_recordSet _ledgerTransStatementTmp setting
                AccumulatedMST = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
                ReportingAccumulatedMST = _ledgerTransStatementTmp.ReportingCurrencyAmountDebit - _ledgerTransStatementTmp.ReportingCurrencyAmountCredit
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating
                && _ledgerTransStatementTmp.TransDate >= _fromDate
                && _ledgerTransStatementTmp.TransDate <= _toDate
                && _ledgerTransStatementTmp.IsFinalRecord == NoYes::Yes;

            // Delete the source transactions
            delete_from _ledgerTransStatementTmp
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating
                && _ledgerTransStatementTmp.TransDate >= _fromDate
                && _ledgerTransStatementTmp.TransDate <= _toDate
                && _ledgerTransStatementTmp.IsFinalRecord == NoYes::No;

            // Update the transactions that were copied to mark them as non-final
            update_recordSet _ledgerTransStatementTmp setting
                IsFinalRecord = NoYes::No
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating
                && _ledgerTransStatementTmp.TransDate >= _fromDate
                && _ledgerTransStatementTmp.TransDate <= _toDate
                && _ledgerTransStatementTmp.IsFinalRecord == NoYes::Yes;
        }
        finally
        {
            this.disposeTempTable(tmpTransGrouped);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupTransactionsForDayInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups the transactions by day.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    private void groupTransactionsForDayInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp)
    {
        LedgerTransStatementStagingTmp  tmpTransGrouped;
        NoYes                           yes = NoYes::Yes;
        AmountCur                       transactionCurrencyAmount = 0.0;

        try
        {
            this.setUserConnection(tmpTransGrouped);
            tmpTransGrouped.linkPhysicalTableInstance(_ledgerTransStatementTmp);

            // Group the operating transactions by date
            insert_recordset tmpTransGrouped
            (
                MainFocusValue,
                MainFocusDescription,
                SecondaryFocus,
                GeneralJournalEntryDataArea,
                PeriodCode,
                TransDate,
                AmountDebit,
                AmountCredit,
                ReportingCurrencyAmountDebit,
                ReportingCurrencyAmountCredit,
                TransactionCurrencyAmountDebit,
                TransactionCurrencyAmountCredit,
                AmountCur,
                AmountMSTDebCred,
                PreviousCreditTotal,
                PreviousDebitTotal,
                IsFinalRecord)
            select
                MainFocusValue,
                MainFocusDescription,
                SecondaryFocus,
                GeneralJournalEntryDataArea,
                PeriodCode,
                TransDate,
                sum(AmountDebit),
                sum(AmountCredit),
                sum(ReportingCurrencyAmountDebit),
                sum(ReportingCurrencyAmountCredit),
                transactionCurrencyAmount,
                transactionCurrencyAmount,
                transactionCurrencyAmount,
                sum(AmountMSTDebCred),
                sum(PreviousCreditTotal),
                sum(PreviousDebitTotal),
                yes
            from _ledgerTransStatementTmp
            group by MainFocusValue, MainFocusDescription, SecondaryFocus, GeneralJournalEntryDataArea, PeriodCode, TransDate
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating;

            // Fill in the summation
            update_recordSet _ledgerTransStatementTmp setting
                AccumulatedMST = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
                ReportingAccumulatedMST = _ledgerTransStatementTmp.ReportingCurrencyAmountDebit - _ledgerTransStatementTmp.ReportingCurrencyAmountDebit
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating
                && _ledgerTransStatementTmp.IsFinalRecord == NoYes::Yes;

            // Delete the source transactions
            delete_from _ledgerTransStatementTmp
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating
                && _ledgerTransStatementTmp.IsFinalRecord == NoYes::No;

            // Update the transactions that were copied to mark them as non-final
            update_recordSet _ledgerTransStatementTmp setting
                IsFinalRecord = NoYes::No
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating
                && _ledgerTransStatementTmp.IsFinalRecord == NoYes::Yes;
        }
        finally
        {
            this.disposeTempTable(tmpTransGrouped);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertEmptyPeriodInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts periods for dates that do not have operating transactions.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <param name="_txt">
    /// The transaction text.
    /// </param>
    private void insertEmptyPeriodInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, TransDate _transDate, TransTxt _txt = '')
    {
        LedgerTransStatementStagingTmp tmpTransGrouped;
        NoYes yes = NoYes::Yes;
        AmountCur amount = 0.0;
        FiscalPeriodType operating = FiscalPeriodType::Operating;

        try
        {

            this.setUserConnection(tmpTransGrouped);
            tmpTransGrouped.linkPhysicalTableInstance(_ledgerTransStatementTmp);

            // Insert empty transactions for all combinations that don't have an operating or opening transaction
            // for the given date
            insert_recordset tmpTransGrouped
            (
                MainFocusValue,
                MainFocusDescription,
                SecondaryFocus,
                GeneralJournalEntryDataArea,
                PeriodCode,
                TransDate,
                AmountDebit,
                AmountCredit,
                TransactionCurrencyAmountDebit,
                TransactionCurrencyAmountCredit,
                ReportingCurrencyAmountDebit,
                ReportingCurrencyAmountCredit,
                AmountMSTDebCred,
                PreviousCreditTotal,
                PreviousDebitTotal,
                TransTxt,
                IsFinalRecord)
            select
                MainFocusValue,
                MainFocusDescription,
                SecondaryFocus,
                GeneralJournalEntryDataArea,
                operating,
                _transDate,
                amount,
                amount,
                amount,
                amount,
                amount,
                amount,
                amount,
                amount,
                amount,
                _txt,
                yes
            from _ledgerTransStatementTmp
            group by MainFocusValue, MainFocusDescription, SecondaryFocus, GeneralJournalEntryDataArea
            notExists join tmpTransGrouped
            where tmpTransGrouped.MainFocusValue == _ledgerTransStatementTmp.MainFocusValue
                && tmpTransGrouped.MainFocusDescription == _ledgerTransStatementTmp.MainFocusDescription
                && tmpTransGrouped.SecondaryFocus == _ledgerTransStatementTmp.SecondaryFocus
                && tmpTransGrouped.GeneralJournalEntryDataArea == _ledgerTransStatementTmp.GeneralJournalEntryDataArea
                && (tmpTransGrouped.PeriodCode == FiscalPeriodType::Operating
                // Consider only opening transactions, not opening balance line
                || (tmpTransGrouped.PeriodCode == FiscalPeriodType::Opening
                        && tmpTransGrouped.TransTxt != "@SYS53035"))
                && tmpTransGrouped.TransDate == _transDate;

            // Update the transactions that were copied to mark them as non-final
            update_recordSet _ledgerTransStatementTmp setting
                IsFinalRecord = NoYes::No
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating &&
                _ledgerTransStatementTmp.TransDate == _transDate &&
                _ledgerTransStatementTmp.IsFinalRecord == NoYes::Yes;
        }
        finally
        {
            this.disposeTempTable(tmpTransGrouped);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateDimensionInformationInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates dimension focus values and descriptions.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_dimensionFocusName">
    /// The main dimension focus name.
    /// </param>
    /// <param name="_secondaryDimensionFocusName">
    /// The secondary dimension focus name.
    /// </param>
    /// <remarks>
    /// This method generates focus values based on <c>LedgerDimension</c> values.
    /// </remarks>
    private void populateDimensionInformationInStaging(
        LedgerTransStatementStagingTmp _ledgerTransStatementTmp,
        Name _dimensionFocusName,
        Name _secondaryDimensionFocusName = '')
    {
        DimensionFocusNameTmp dimNameTmpMainValue;
        LedgerTransStatementStagingTmp querySource;
        DimensionFocusNameTmp dimNameTmpSecondaryValue;

        try
        {
            this.setUserConnection(dimNameTmpMainValue);

            Query focusNameQuery = new Query();
            SysQuery::findOrCreateDataSource(focusNameQuery, tableNum(LedgerTransStatementStagingTmp));

            // Add a link to DimensionAttributeValueCombination, which is required to populate the dimension values
            QueryBuildDataSource davcDS = SysQuery::findOrCreateDataSource(focusNameQuery, tableNum(DimensionAttributeValueCombination), tableNum(LedgerTransStatementStagingTmp));
            davcDS.addLink(fieldNum(LedgerTransStatementStagingTmp, LedgerDimension), fieldNum(DimensionAttributeValueCombination, RecId));

            // Generate a distinct list of ledger dimensions to generate values for
            this.setUserConnection(querySource);

            insert_recordset querySource
                (LedgerDimension)
            select LedgerDimension from _ledgerTransStatementTmp
            group by LedgerDimension;

            // Set temp table as the source of the query using QueryRun because it supports TempDB tables
            QueryRun focusNameQueryRun = new QueryRun(focusNameQuery);
            focusNameQueryRun.setRecord(querySource);
            focusNameQuery = focusNameQueryRun.query();

            // Generate the main focus values
            DimensionFocusNameTmp::generateFocusNames(dimNameTmpMainValue, focusNameQuery, _dimensionFocusName, this.parmUserConnection());

            // Update _ledgerTransStatementTmp with the main focus value
            update_recordset _ledgerTransStatementTmp setting
                MainFocusValue = dimNameTmpMainValue.FocusValue,
                MainFocusName = _dimensionFocusName,
                SecondaryFocusName = _secondaryDimensionFocusName
            join dimNameTmpMainValue
                where dimNameTmpMainValue.LedgerDimension == _ledgerTransStatementTmp.LedgerDimension;

            // Do the same thing for the secondary focus (if specified)
            if (_secondaryDimensionFocusName)
            {
                this.setUserConnection(dimNameTmpSecondaryValue);

                DimensionFocusNameTmp::generateFocusNames(dimNameTmpSecondaryValue, focusNameQuery, _secondaryDimensionFocusName, this.parmUserConnection());

                // Update _ledgerTransStatementTmp with the secondary focus value
                update_recordset _ledgerTransStatementTmp setting
                    SecondaryFocus = dimNameTmpSecondaryValue.FocusValue
                join dimNameTmpSecondaryValue
                    where dimNameTmpSecondaryValue.LedgerDimension == _ledgerTransStatementTmp.LedgerDimension;
            }

            // Generate main focus descriptions
            // The original table instance can be reused since we've already copied the contents out.
            DimensionFocusNameTmp::generateFocusDescriptions(dimNameTmpMainValue, _dimensionFocusName, this.parmUserConnection());

            // Update _ledgerTransStatementTmp with the main focus descriptions
            update_recordset _ledgerTransStatementTmp setting
                MainFocusDescription = dimNameTmpMainValue.FocusValue
            join dimNameTmpMainValue
                where dimNameTmpMainValue.LedgerDimension == _ledgerTransStatementTmp.LedgerDimension;
        }
        finally
        {
            if (_secondaryDimensionFocusName)
            {
                this.disposeTempTable(dimNameTmpSecondaryValue);
            }

            this.disposeTempTable(dimNameTmpMainValue);
            this.disposeTempTable(querySource);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTempTableBudgetInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the temp table for budget transaction type.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> buffer.
    /// </param>
    /// <param name="_query">
    /// The query to use for generating data.
    /// </param>
    /// <param name="_startDate">
    /// The report start date.
    /// </param>
    /// <param name="_endDate">
    /// The report end date.
    /// </param>
    private void populateTempTableBudgetInStaging(
        LedgerTransStatementStagingTmp _ledgerTransStatementTmp,
        Query _query,
        FromDate _startDate,
        ToDate _endDate)
    {
        boolean                 hasRangesOrFilters = SysQuery::queryHasRangesOrFilters(_query);
        RecordInsertList        recordInsertList;
        TransDate               periodStartDate;
        QueryBuildDataSource    qbdsBTL, qbdsBTH, qbds;
        QueryRun                queryRun;
        BudgetTransactionLine   budgetTransactionLine;
        BudgetTransactionHeader budgetTransactionHeader;
        CurrentOperationsTax    current = CurrentOperationsTax::Current;
        FiscalPeriodType        opening = FiscalPeriodType::Opening;
        FiscalPeriodType        operating = FiscalPeriodType::Operating;
        int                     i;

        periodStartDate = LedgerFiscalCalendar::findOpeningStartDateByDate(CompanyInfoHelper::fiscalCalendarRecId(), _startDate);

        if (hasRangesOrFilters)
        {
            // The query has multiple top level data sources all of which get run when the quer is run. We are interested in only
            // Budget records so disable the other top level data sources.
            for (i = 1; i <= _query.childDataSourceCount(); i++)
            {
                qbds = _query.childDataSourceNo(i);
                if (qbds.table() != tableNum(BudgetTransactionLine))
                {
                    qbds.enabled(false);
                }
            }

            // Ranges or filters exist, so the BudgetTransactionLine records to process must
            // be looped over individually. Group by RecId and include other
            // fields that are in the select list to populate the trans list.
            qbdsBTL = _query.dataSourceTable(tableNum(BudgetTransactionLine));

            // Filter to the current date range
            qbdsBTH = _query.dataSourceTable(tableNum(BudgetTransactionHeader));
            if (qbdsBTH == null)
            {
                qbdsBTH = qbdsBTL.addDataSource(tableNum(BudgetTransactionHeader));
                qbdsBTH.fetchMode(QueryFetchMode::One2One);
                qbdsBTH.joinMode(JoinMode::InnerJoin);
                qbdsBTH.addLink(fieldNum(BudgetTransactionLine, BudgetTransactionHeader), fieldNum(BudgetTransactionHeader, RecId));
            }

            qbdsBTH.addRange(fieldNum(BudgetTransactionHeader, Date)).value(SysQuery::range(periodStartDate, _endDate, true));
            qbdsBTH.addRange(fieldNum(BudgetTransactionHeader, PrimaryLedger)).value(queryValue(Ledger::current()));

            // Group by BudgetTransactionLine.RecId to prevent the cardinality of the result set from increasing
            // due to other data sources added by the user in the SysQuery form
            qbdsBTL.addGroupByField(fieldNum(BudgetTransactionLine, RecId));
            qbdsBTL.addGroupByField(fieldNum(BudgetTransactionLine, BudgetTransactionHeader));
            qbdsBTL.addGroupByField(fieldNum(BudgetTransactionLine, LedgerDimension));
            qbdsBTL.addGroupByField(fieldNum(BudgetTransactionLine, Comment));
            qbdsBTL.addGroupByField(fieldNum(BudgetTransactionLine, TransactionCurrency));
            qbdsBTH.addGroupByField(fieldNum(BudgetTransactionHeader, Date));
            qbdsBTH.addGroupByField(fieldNum(BudgetTransactionHeader, TransactionNumber));
            qbdsBTH.addGroupByField(fieldNum(BudgetTransactionHeader, TransactionStatus));

            // Fill the staging table with the set of budget records to process
            new SkipAOSValidationPermission().assert();
            recordInsertList = new RecordInsertList(tableNum(LedgerTransStatementStagingTmp), true, true, true, true, true, _ledgerTransStatementTmp);
            queryRun = new queryRun(_query);

            while (queryRun.next())
            {
                _ledgerTransStatementTmp.clear();

                budgetTransactionLine = queryRun.get(tableNum(BudgetTransactionLine)) as BudgetTransactionLine;
                _ledgerTransStatementTmp.GeneralJournalAccountEntry = budgetTransactionLine.RecId;
                _ledgerTransStatementTmp.GeneralJournalEntry = budgetTransactionLine.GeneralJournalEntry;
                _ledgerTransStatementTmp.LedgerDimension = budgetTransactionLine.LedgerDimension;
                _ledgerTransStatementTmp.TransTxt = budgetTransactionLine.Comment;
                _ledgerTransStatementTmp.CurrencyCode = budgetTransactionLine.TransactionCurrency;

                budgetTransactionHeader = queryRun.get(tableNum(BudgetTransactionHeader)) as BudgetTransactionHeader;
                _ledgerTransStatementTmp.TransDate = budgetTransactionHeader.Date;
                _ledgerTransStatementTmp.Voucher = budgetTransactionHeader.TransactionNumber;
                _ledgerTransStatementTmp.BudgetModelId = budgetTransactionHeader.BudgetModelId;
                _ledgerTransStatementTmp.BudgetTransactionStatus = budgetTransactionHeader.TransactionStatus;

                // All budget transactions are operating
                _ledgerTransStatementTmp.PeriodCode = FiscalPeriodType::Operating;

                if (budgetTransactionHeader.Date < _startDate)
                {
                    // Special case where start date of the report is after the start of the period, so operating
                    // transactions should be treated as opening to include them in the opening balance
                    _ledgerTransStatementTmp.PeriodCode = FiscalPeriodType::Opening;
                }

                recordInsertList.add(_ledgerTransStatementTmp);
            }

            recordInsertList.insertDatabase();
            CodeAccessPermission::revertAssert();

            // Re-enable the data sources to prevent problems in future runs
            for (i = 1; i <= _query.childDataSourceCount(); i++)
            {
                qbds = _query.childDataSourceNo(i);
                if (qbds.table() != tableNum(BudgetTransactionLine))
                {
                    qbds.enabled(true);
                }
            }
        }
        else
        {
            // No filters or ranges were added, so instead populate the table with a simple set-based insert
            insert_recordset _ledgerTransStatementTmp
                (GeneralJournalAccountEntry,
                GeneralJournalEntry,
                LedgerDimension,
                TransTxt,
                CurrencyCode,
                TransDate,
                PostingLayer,
                PeriodCode,
                Voucher,
                BudgetModelId,
                BudgetTransactionStatus)
                select
                    RecId,
                    BudgetTransactionHeader,
                    LedgerDimension,
                    Comment,
                    TransactionCurrency
                from budgetTransactionLine
                join
                    @Date,
                    current,
                    operating,
                    TransactionNumber,
                    BudgetModelId,
                    TransactionStatus
                from budgetTransactionHeader
                    where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                        && budgetTransactionHeader.Date >= _startDate
                        && budgetTransactionHeader.Date <= _endDate
                        && budgetTransactionHeader.PrimaryLedger == Ledger::current();

            // Add any additional operating transactions between the period opening
            // and the start of the report and treat them as opening transactions
            // so that opening + operating == current balance
            if (_startDate > periodStartDate)
            {
                insert_recordset _ledgerTransStatementTmp
                    (GeneralJournalAccountEntry,
                    GeneralJournalEntry,
                    LedgerDimension,
                    TransTxt,
                    CurrencyCode,
                    TransDate,
                    PostingLayer,
                    PeriodCode,
                    Voucher,
                    BudgetModelId,
                    BudgetTransactionStatus)
                select
                    RecId,
                    BudgetTransactionHeader,
                    LedgerDimension,
                    Comment,
                    TransactionCurrency
                from budgetTransactionLine
                    join @Date, current, opening, TransactionNumber, BudgetModelId, TransactionStatus from budgetTransactionHeader where
                        budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader &&
                        budgetTransactionHeader.Date >= periodStartDate &&
                        budgetTransactionHeader.Date < _startDate &&
                        budgetTransactionHeader.PrimaryLedger == Ledger::current();
            }
        }

        // Fill in the credit amount
        update_recordSet _ledgerTransStatementTmp setting
            AmountCredit = budgetTransactionLine.AccountingCurrencyAmount * -1,
            PreviousCreditTotal = budgetTransactionLine.AccountingCurrencyAmount * -1,
            TransactionCurrencyAmountCredit = budgetTransactionLine.TransactionCurrencyAmount * -1,
            AmountCur = budgetTransactionLine.TransactionCurrencyAmount
            join budgetTransactionLine where
                budgetTransactionLine.RecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry &&
                budgetTransactionLine.AccountingCurrencyAmount < 0;

        // Fill in the debit amount
        update_recordSet _ledgerTransStatementTmp setting
            AmountDebit = budgetTransactionLine.AccountingCurrencyAmount,
            PreviousDebitTotal = budgetTransactionLine.AccountingCurrencyAmount,
            TransactionCurrencyAmountDebit = budgetTransactionLine.TransactionCurrencyAmount,
            AmountCur = budgetTransactionLine.TransactionCurrencyAmount
            join budgetTransactionLine where
                budgetTransactionLine.RecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry &&
                budgetTransactionLine.AccountingCurrencyAmount > 0;

        // Fill in the summation
        update_recordSet _ledgerTransStatementTmp setting
            AccumulatedMST = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
            AmountMSTDebCred = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTempTableLedgerInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the temp table for ledger transaction type.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> buffer.
    /// </param>
    /// <param name="_query">
    /// The query to use for generating data.
    /// </param>
    /// <param name="_startDate">
    /// The report start date.
    /// </param>
    /// <param name="_endDate">
    /// The report end date.
    /// </param>
    /// <param name="_includeOpening">
    /// A boolean value indicating whether opening transactions must be treated as operating transactions.
    /// </param>
    /// <param name="_includeClosing">
    /// A boolean value indicating whether closing transactions must be considered.
    /// </param>
    /// <param name="_dimensionFocusName">
    /// The dimension focus name.
    /// </param>
    /// <param name="_includeIntercompanyTaxVoucher">
    /// A boolean value indicating whether to look for voucher data associated with intercompany tax posting.
    /// </param>
    [Wrappable(true)]
    protected final void populateTempTableLedgerInStaging(
        LedgerTransStatementStagingTmp _ledgerTransStatementTmp,
        Query _query,
        FromDate _startDate,
        ToDate _endDate,
        boolean _includeOpening,
        boolean _includeClosing,
        Name _dimensionFocusName,
        boolean _includeIntercompanyTaxVoucher,
        List _postingLayers = null)
    {
        TransDate                           periodStartDate;
        QueryBuildDataSource                qbdsGJAE, qbdsGJE, qbdsFCP, qbds, qbdsLedger, qbdsCompanyInfo;
        QueryRun                            queryRun;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        GeneralJournalEntry                 generalJournalEntry;
        Ledger                              ledger;
        CompanyInfo                         companyInfo;
        FiscalCalendarPeriod                fiscalCalendarPeriod;
        FiscalPeriodType                    opening = FiscalPeriodType::Opening;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry, subledgerVoucherGeneralJournalEntry2;
        int                                 i;
        TaxTransGeneralJournalAccountEntry  taxTransGeneralJournalAccountEntryForTax, taxTransGeneralJournalAccountEntryForVoucher;
        TaxTrans                            taxTrans;
        LedgerTransStatementStagingTmp      localLedgerTransStatmentTmp;
        LedgerPostingLayerTmp postingLayersTmp;

        try
        {
            this.setUserConnection(localLedgerTransStatmentTmp);
            localLedgerTransStatmentTmp.linkPhysicalTableInstance(_ledgerTransStatementTmp);

            periodStartDate = LedgerFiscalCalendar::findOpeningStartDateByDate(CompanyInfoHelper::fiscalCalendarRecId(), _startDate);

            // The query has multiple top level data sources all of which get run when the query is run. We are interested in only
            // Ledger records so disable the other top level data sources.
            for (i = 1; i <= _query.childDataSourceCount(); i++)
            {
                qbds = _query.childDataSourceNo(i);
                if (qbds.table() != tableNum(GeneralJournalAccountEntry))
                {
                    qbds.enabled(false);
                }
            }

            // Ranges or filters exist, so the GeneralJournalAccountEntry records to process must
            // be looped over individually. Group by RecId and include other
            // fields that are in the select list to populate the trans list.
            qbdsGJAE = _query.dataSourceTable(tableNum(GeneralJournalAccountEntry));

            // Filter to the current date range
            if (!_query.datasourcetable(tablenum(GeneralJournalEntry)))
            {
                qbdsGJE = qbdsGJAE.addDataSource(tableNum(GeneralJournalEntry));
            }
            else
            {
                qbdsGJE = _query.dataSourceTable(tableNum(GeneralJournalEntry));
            }
    
            qbdsGJE.fetchMode(QueryFetchMode::One2One);
            qbdsGJE.joinMode(JoinMode::InnerJoin);
            qbdsGJE.addLink(fieldNum(GeneralJournalAccountEntry, GeneralJournalEntry), fieldNum(GeneralJournalEntry, RecId));
            qbdsGJE.addRange(fieldNum(GeneralJournalEntry, AccountingDate)).value(SysQuery::range(_startDate, _endDate, true));
            qbdsGJE.addRange(fieldNum(GeneralJournalEntry, Ledger)).value(queryValue(Ledger::current()));

            // Get the fiscal period type
            qbdsFCP = qbdsGJE.addDataSource(tableNum(FiscalCalendarPeriod));
            qbdsFCP.fetchMode(QueryFetchMode::One2One);
            qbdsFCP.joinMode(JoinMode::InnerJoin);
            qbdsFCP.addLink(fieldNum(GeneralJournalEntry, FiscalCalendarPeriod), fieldnum(FiscalCalendarPeriod, RecId));

            // Get the company
            qbdsLedger = qbdsGJE.addDataSource(tableNum(Ledger));
            qbdsLedger.fetchMode(QueryFetchMode::One2One);
            qbdsLedger.joinMode(JoinMode::InnerJoin);
            qbdsLedger.addSelectionField(fieldNum(Ledger, PrimaryForLegalEntity));
            qbdsLedger.addLink(fieldNum(GeneralJournalEntry, Ledger), fieldnum(Ledger, RecId));
            qbdsCompanyInfo = qbdsLedger.addDataSource(tableNum(CompanyInfo));
            qbdsCompanyInfo.fetchMode(QueryFetchMode::One2One);
            qbdsCompanyInfo.joinMode(JoinMode::InnerJoin);
            qbdsCompanyInfo.addSelectionField(fieldNum(CompanyInfo, DataArea));
            qbdsCompanyInfo.addLink(fieldNum(Ledger, PrimaryForLegalEntity), fieldnum(CompanyInfo, RecId));

            // Filter out closing transactions if necessary
            if (!_includeClosing)
            {
                qbdsFCP.addRange(fieldNum(FiscalCalendarPeriod, Type)).value(SysQuery::valueNot(FiscalPeriodType::Closing));
            }

            // Build a temporary table containing all the posting layers we are reporting on which can be joined into the query that populates the opening transactions
            this.setUserConnection(postingLayersTmp);

            if (_postingLayers != null)
            {
                ListEnumerator postingLayerLE = _postingLayers.getEnumerator();
                while (postingLayerLE.moveNext())
                {
                    qbdsGJE.addRange(fieldNum(GeneralJournalEntry, PostingLayer)).value(postingLayerLE.current());

                    postingLayersTmp.PostingLayer = postingLayerLE.current();
                    postingLayersTmp.insert();
                }
            }

            Map insertRecordsetMap = new Map(Types::String, Types::Container);
            this.buildFieldMap(_query, insertRecordsetMap);

            // Group by GeneralJournalAccountEntry.RecId to prevent the cardinality of the result set from increasing
            // due to other data sources added by the user in the SysQuery form
            qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntry, RecId));
            qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntry, LedgerDimension));
            qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntry, Text));
            qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntry, TransactionCurrencyCode));
            qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntry, PostingType));
            qbdsGJE.addGroupByField(fieldNum(GeneralJournalEntry, AccountingDate));
            qbdsGJE.addGroupByField(fieldNum(GeneralJournalEntry, PostingLayer));
            qbdsGJE.addGroupByField(fieldNum(GeneralJournalEntry, RecId));
            qbdsFCP.addGroupByField(fieldNum(FiscalCalendarPeriod, Type));
            qbdsCompanyInfo.addGroupByField(fieldNum(CompanyInfo, DataArea));

            // Execute the query into the staging table
            Query::insert_recordset(_ledgerTransStatementTmp, insertRecordsetMap, _query);

            // Re-enable the data sources
            for (i = 1; i <= _query.childDataSourceCount(); i++)
            {
                qbds = _query.childDataSourceNo(i);
                if (qbds.table() != tableNum(GeneralJournalAccountEntry))
                {
                    qbds.enabled(true);
                }
            }

            // Update for the special case of opening transactions being included in the date range and includeOpening being specified
            // so those transactions should be treated as regular operating transactions
            if (_includeOpening && periodStartDate == _startDate)
            {
                update_recordSet _ledgerTransStatementTmp setting
                    PeriodCode = FiscalPeriodType::Operating
                where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Opening;
            }

            this.insertOpeningAndOperatingBalances(
                _ledgerTransStatementTmp,
                _postingLayers,
                _query,
                _startDate,
                periodStartDate,
                _dimensionFocusName);

            // Include revenue/expense posting entry(s) associated with intercompany tax postings
            if (_includeIntercompanyTaxVoucher)
            {
                insert_recordset localLedgerTransStatmentTmp
                    (GeneralJournalAccountEntry,
                    GeneralJournalEntry,
                    LedgerDimension,
                    LedgerPostingType,
                    TransTxt,
                    CurrencyCode,
                    TransDate,
                    PostingLayer,
                    PeriodCode,
                    GeneralJournalEntryDataArea)
                select _ledgerTransStatementTmp
                    where _ledgerTransStatementTmp.LedgerPostingType == LedgerPostingType::Tax
                join taxTransGeneralJournalAccountEntryForTax
                    where taxTransGeneralJournalAccountEntryForTax.GeneralJournalAccountEntry == _ledgerTransStatementTmp.GeneralJournalAccountEntry &&
                        taxTransGeneralJournalAccountEntryForTax.TaxTransRelationship == TaxTransRelationshipType::Tax
                join taxTrans
                    where taxTrans.RecId == taxTransGeneralJournalAccountEntryForTax.TaxTrans &&
                        taxTrans.TaxObligationCompany == TaxObligationCompany::Source
                join taxTransGeneralJournalAccountEntryForVoucher
                    where taxTransGeneralJournalAccountEntryForVoucher.TaxTrans == taxTrans.RecId &&
                        taxTransGeneralJournalAccountEntryForVoucher.TaxTransRelationship == TaxTransRelationshipType::TransactionLineAccount
                join RecId, GeneralJournalEntry, LedgerDimension, PostingType, Text, TransactionCurrencyCode
                    from generalJournalAccountEntry
                    where generalJournalAccountEntry.RecId == taxTransGeneralJournalAccountEntryForVoucher.GeneralJournalAccountEntry
                join AccountingDate, PostingLayer
                    from generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                join Type
                    from fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod &&
                        fiscalCalendarPeriod.Type != FiscalPeriodType::Closing
                join ledger
                    where ledger.RecId == generalJournalEntry.Ledger
                join DataArea
                    from companyInfo
                    where companyInfo.RecId == ledger.PrimaryForLegalEntity &&
                        companyInfo.DataArea != taxTrans.dataAreaId;       // ignore entries from the same company as they will already be included

                // Identify revenue/expense posting entry(s) associated with intercompany tax postings opening balance transactions
                if (_startDate > periodStartDate)
                {
                    update_recordSet localLedgerTransStatmentTmp setting
                        PeriodCode = opening
                    where localLedgerTransStatmentTmp.GeneralJournalEntryDataArea != taxTrans.dataAreaId &&
                        localLedgerTransStatmentTmp.TransDate < _startDate;
                }
            }

            // Fill in the credit amount
            update_recordSet _ledgerTransStatementTmp setting
                AmountCredit = generalJournalAccountEntry.AccountingCurrencyAmount * -1,
                PreviousCreditTotal = generalJournalAccountEntry.AccountingCurrencyAmount * -1,
                TransactionCurrencyAmountCredit = generalJournalAccountEntry.TransactionCurrencyAmount * -1,
                ReportingCurrencyAmountCredit = generalJournalAccountEntry.ReportingCurrencyAmount * -1
            join generalJournalAccountEntry where
                generalJournalAccountEntry.RecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry &&
                generalJournalAccountEntry.IsCredit == true;

            // Fill in the debit amount
            update_recordSet _ledgerTransStatementTmp setting
                AmountDebit = generalJournalAccountEntry.AccountingCurrencyAmount,
                PreviousDebitTotal = generalJournalAccountEntry.AccountingCurrencyAmount,
                TransactionCurrencyAmountDebit = generalJournalAccountEntry.TransactionCurrencyAmount,
                ReportingCurrencyAmountDebit = generalJournalAccountEntry.ReportingCurrencyAmount
            join generalJournalAccountEntry where
                generalJournalAccountEntry.RecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry &&
                generalJournalAccountEntry.IsCredit == false;

            // Fill in the summation
            update_recordSet _ledgerTransStatementTmp setting
                AccumulatedMST = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
                AmountMSTDebCred = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
                ReportingAccumulatedMST = _ledgerTransStatementTmp.ReportingCurrencyAmountDebit - _ledgerTransStatementTmp.ReportingCurrencyAmountCredit;

            // Fill in voucher information
            update_recordSet _ledgerTransStatementTmp setting
                Voucher = subledgerVoucherGeneralJournalEntry.Voucher
            join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == _ledgerTransStatementTmp.GeneralJournalEntry
            notExists join subledgerVoucherGeneralJournalEntry2
                // Only fill in voucher if summarization didn't happen
                where  subledgerVoucherGeneralJournalEntry2.GeneralJournalEntry == _ledgerTransStatementTmp.GeneralJournalEntry
                    && subledgerVoucherGeneralJournalEntry2.RecId != subledgerVoucherGeneralJournalEntry.RecId;

            // Fill in the voucher information for summarized records
            update_recordSet _ledgerTransStatementTmp setting
                Voucher = "@SYS342661" // This label is the text "Summarized"
            where _ledgerTransStatementTmp.Voucher == '';
        }
        finally
        {
            this.disposeTempTable(localLedgerTransStatmentTmp);
            this.disposeTempTable(postingLayersTmp);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertOpeningAndOperatingBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add any additional operating transactions between the period opening and the start of the report and treat them as
    /// opening transactions so that opening + operating == current balance
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> buffer.
    /// </param>
    /// <param name="_postingLayers">
    /// The posting layer criteria to filter the report by.
    /// </param>
    /// <param name="_query">
    /// The original query containing the Main account ranges.
    /// </param>
    /// <param name="_startDate">
    /// The report start date.
    /// </param>
    /// <param name="_periodStartDate">
    /// The period start date.
    /// </param>
    /// <param name="_dimensionFocusName">
    /// The dimension focus name.
    /// </param>
    private void insertOpeningAndOperatingBalances(
        LedgerTransStatementStagingTmp _ledgerTransStatementTmp,
        List _postingLayers,
        Query _query,
        FromDate _startDate,
        FromDate _periodStartDate,
        Name _dimensionFocusName)
    {
        if (_startDate > _periodStartDate)
        {
            DimensionHierarchy focusDimensionHierarchy = DimensionHierarchy::findByTypeAndName(DimensionHierarchyType::Focus, _dimensionFocusName);
            RefRecId mainAccountDimensionAttributeRecId = DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount);
            DimensionHierarchyLevel mainAccountLevel = DimensionHierarchyLevel::findByDimensionHierarchyAndDimAttribute(focusDimensionHierarchy.RecId, mainAccountDimensionAttributeRecId);
            Map dimensionFilterMap = this.getQueryTableFieldFilter(this.parmQuery(), tableNum(DimensionAttributeValueCombination));            
            Map mainAccountFilterMap;

            if (mainAccountLevel)
            {
                mainAccountFilterMap = this.getQueryTableFieldFilter(this.parmQuery(), tableNum(MainAccount));
            }

            if (Dynamics.AX.Application.FeatureStateProvider::IsFeatureEnabled(GeneralLedgerBalanceFeature::instance()))
            {
                LedgerTransStatementOpeningBalance openingBalance = LedgerTransStatementOpeningBalance::newForLedgerTransStatementDP(
                    this.parmUserConnection(),
                    _ledgerTransStatementTmp,
                    _startDate,
                    _periodStartDate,
                    _postingLayers,
                    focusDimensionHierarchy,
                    mainAccountFilterMap,
                    dimensionFilterMap);

                openingBalance.insertOpeningAndOperatingBalancesV2();
            }
            else
            {
                Query operatingAsOpening = new Query();
            
                QueryBuildDataSource dimensionFocusBalanceQBDS = operatingAsOpening.addDataSource(tableNum(DimensionFocusBalance));
                dimensionFocusBalanceQBDS.fields().dynamic(NoYes::No);
                dimensionFocusBalanceQBDS.addGroupByField(fieldNum(DimensionFocusBalance, FocusLedgerDimension));
                dimensionFocusBalanceQBDS.addGroupByField(fieldNum(DimensionFocusBalance, PostingLayer));
            
                dimensionFocusBalanceQBDS.addRange(fieldNum(DimensionFocusBalance, AccountingDate)).value(
                    strFmt('(%1.%2 >= %3) && (%4.%5 < %6)',
                        dimensionFocusBalanceQBDS.name(),
                        fieldStr(DimensionFocusBalance, AccountingDate),
                        date2StrXpp(_periodStartDate),
                        dimensionFocusBalanceQBDS.name(),
                        fieldStr(DimensionFocusBalance, AccountingDate),
                        date2StrXpp(_startDate)
                    ));

                dimensionFocusBalanceQBDS.addRange(fieldNum(DimensionFocusBalance, FiscalCalendarPeriodType)).value(
                    SysQuery::range(
                        queryValue(FiscalPeriodType::Opening),
                        queryValue(FiscalPeriodType::Operating),
                        true));
            
                dimensionFocusBalanceQBDS.addRange(fieldNum(DimensionFocusBalance, Ledger)).value(queryValue(Ledger::current()));
                dimensionFocusBalanceQBDS.addRange(fieldNum(DimensionFocusBalance, FocusDimensionHierarchy)).value(queryValue(focusDimensionHierarchy.RecId));
            
                if (_postingLayers != null)
                {
                    ListEnumerator postingLayerLE = _postingLayers.getEnumerator();

                    while (postingLayerLE.moveNext())
                    {
                        dimensionFocusBalanceQBDS.addRange(fieldNum(DimensionFocusBalance, PostingLayer)).value(postingLayerLE.current());
                    }
                }
            
                QueryBuildDataSource dimensionFocusLedgerQBDS = dimensionFocusBalanceQBDS.addDataSource(tableNum(Ledger));
                dimensionFocusLedgerQBDS.fetchMode(QueryFetchMode::One2One);
                dimensionFocusLedgerQBDS.joinMode(JoinMode::InnerJoin);
                dimensionFocusLedgerQBDS.addLink(fieldNum(DimensionFocusBalance, Ledger), fieldNum(Ledger, RecId));
                dimensionFocusLedgerQBDS.fields().dynamic(NoYes::No);
            
                QueryBuildDataSource dimensionFocusCompanyQBDS = dimensionFocusLedgerQBDS.addDataSource(tableNum(CompanyInfo));
                dimensionFocusCompanyQBDS.fetchMode(QueryFetchMode::One2One);
                dimensionFocusCompanyQBDS.joinMode(JoinMode::InnerJoin);
                dimensionFocusCompanyQBDS.addLink(fieldNum(Ledger, PrimaryForLegalEntity), fieldNum(CompanyInfo, RecId));
                dimensionFocusCompanyQBDS.addGroupByField(fieldNum(CompanyInfo, DataArea));
                dimensionFocusCompanyQBDS.fields().dynamic(NoYes::No);

                QueryBuildDataSource davcQBDS = dimensionFocusBalanceQBDS.addDataSource(tableNum(DimensionAttributeValueCombination));
                davcQBDS.joinMode(JoinMode::ExistsJoin);
                davcQBDS.addLink(fieldNum(DimensionFocusBalance, FocusLedgerDimension), fieldNum(DimensionAttributeValueCombination, RecId));
                davcQBDS.fields().dynamic(NoYes::No);
            
                if (mainAccountFilterMap)
                {
                    QueryBuildDataSource mainAccountQBDS;
                    mainAccountQBDS = davcQBDS.addDataSource(tableNum(MainAccount));
                    mainAccountQBDS.joinMode(JoinMode::ExistsJoin);
                    mainAccountQBDS.addLink(fieldNum(DimensionAttributeValueCombination, MainAccount), fieldNum(MainAccount, RecId));
                    mainAccountQBDS.fields().dynamic(NoYes::No);
                    
                    MapEnumerator mainAccountFilterEnumerator = mainAccountFilterMap.getEnumerator();

                    while (mainAccountFilterEnumerator.moveNext())
                    {
                        mainAccountQBDS.addRange(fieldname2id(tableNum(MainAccount), mainAccountFilterEnumerator.currentKey())).value(mainAccountFilterEnumerator.currentValue());
                    }
                }
                
                MapEnumerator dimensionFilterEnumerator = dimensionFilterMap.getEnumerator();

                while (dimensionFilterEnumerator.moveNext())
                {
                    davcQBDS.addRange(fieldname2id(tableNum(DimensionAttributeValueCombination), dimensionFilterEnumerator.currentKey())).value(dimensionFilterEnumerator.currentValue());
                }
            
                operatingAsOpening.clearAllFields();

                Map insertMap = new Map(Types::String, Types::Container);
                int dimensionFocusBalanceQBDSID = dimensionFocusBalanceQBDS.uniqueId();

                QueryBuildFieldList dimensionFocusFieldList = dimensionFocusBalanceQBDS.fields();

                dimensionFocusFieldList.addField(fieldNum(DimensionFocusBalance, FocusLedgerDimension));
                insertMap.insert(fieldStr(LedgerTransStatementStagingTmp, LedgerDimension), [dimensionFocusBalanceQBDSID, fieldStr(DimensionFocusBalance, FocusLedgerDimension)]);
            
                dimensionFocusFieldList.addField(fieldNum(DimensionFocusBalance, AccountingDate), SelectionField::Min);
                insertMap.insert(fieldStr(LedgerTransStatementStagingTmp, TransDate), [dimensionFocusBalanceQBDSID, SysComputedColumn::min(fieldStr(DimensionFocusBalance, AccountingDate))]);
            
                dimensionFocusFieldList.addField(fieldNum(DimensionFocusBalance, PostingLayer));
                insertMap.insert(fieldStr(LedgerTransStatementStagingTmp, PostingLayer), [dimensionFocusBalanceQBDSID, fieldStr(DimensionFocusBalance, PostingLayer)]);

                dimensionFocusFieldList.addField(fieldNum(DimensionFocusBalance, CreditAccountingCurrencyAmount), SelectionField::Sum);
                insertMap.insert(fieldStr(LedgerTransStatementStagingTmp, AmountCredit), [dimensionFocusBalanceQBDSID, SysComputedColumn::sum(fieldStr(DimensionFocusBalance, CreditAccountingCurrencyAmount))]);
            
                dimensionFocusFieldList.addField(fieldNum(DimensionFocusBalance, DebitAccountingCurrencyAmount), SelectionField::Sum);
                insertMap.insert(fieldStr(LedgerTransStatementStagingTmp, AmountDebit), [dimensionFocusBalanceQBDSID, SysComputedColumn::sum(fieldStr(DimensionFocusBalance, DebitAccountingCurrencyAmount))]);

                dimensionFocusFieldList.addField(fieldNum(DimensionFocusBalance, CreditReportingCurrencyAmount), SelectionField::Sum);
                insertMap.insert(fieldStr(LedgerTransStatementStagingTmp, ReportingCurrencyAmountCredit), [dimensionFocusBalanceQBDSID, SysComputedColumn::sum(fieldStr(DimensionFocusBalance, CreditReportingCurrencyAmount))]);
            
                dimensionFocusFieldList.addField(fieldNum(DimensionFocusBalance, DebitReportingCurrencyAmount), SelectionField::Sum);
                insertMap.insert(fieldStr(LedgerTransStatementStagingTmp, ReportingCurrencyAmountDebit), [dimensionFocusBalanceQBDSID, SysComputedColumn::sum(fieldStr(DimensionFocusBalance, DebitReportingCurrencyAmount))]);

                int companyQBDSID = dimensionFocusCompanyQBDS.uniqueId();
                QueryBuildFieldList companyFieldList = dimensionFocusCompanyQBDS.fields();

                companyFieldList.addField(fieldNum(CompanyInfo, DataArea));
                insertMap.insert(fieldStr(LedgerTransStatementStagingTmp, GeneralJournalEntryDataArea), [companyQBDSID, fieldStr(CompanyInfo, DataArea)]);
            
                Query::insert_recordset(_ledgerTransStatementTmp, insertMap, operatingAsOpening);
            }
            
            // Update other opening balance related fields
            update_recordSet _ledgerTransStatementTmp
                setting PeriodCode = FiscalPeriodType::Opening,
                    TransactionCurrencyAmountCredit = _ledgerTransStatementTmp.AmountCredit,
                    PreviousCreditTotal = _ledgerTransStatementTmp.AmountCredit,
                    TransactionCurrencyAmountDebit = _ledgerTransStatementTmp.AmountDebit,
                    PreviousDebitTotal = _ledgerTransStatementTmp.AmountDebit
                where _ledgerTransStatementTmp.GeneralJournalAccountEntry == 0;

            update_recordSet _ledgerTransStatementTmp
                setting AmountCredit = _ledgerTransStatementTmp.AmountCredit * -1,
                    ReportingCurrencyAmountCredit = _ledgerTransStatementTmp.ReportingCurrencyAmountCredit * -1,
                    TransactionCurrencyAmountCredit = _ledgerTransStatementTmp.TransactionCurrencyAmountCredit * -1,
                    PreviousCreditTotal = _ledgerTransStatementTmp.PreviousCreditTotal * -1
                where _ledgerTransStatementTmp.GeneralJournalAccountEntry == 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryTableFieldFilter</Name>
				<Source><![CDATA[
    private Map getQueryTableFieldFilter(Query _query, int _tableNumber)
    {
        Map fieldValueFilterMap = new Map(Types::String, Types::String);

        int queryFilterCount = _query.queryFilterCount();
                
        for (int j = 1; j <= queryFilterCount; j++)
        {
            QueryFilter dynamicQueryFilter = _query.queryFilter(j);

            QueryBuildDataSource queryFilterDataSource = dynamicQueryFilter.datasource();

            if (dynamicQueryFilter != null && dynamicQueryFilter.value() != '')
            {
                if (queryFilterDataSource.table() == _tableNumber)
                {
                    fieldValueFilterMap.add(dynamicQueryFilter.field(), dynamicQueryFilter.value());
                }
            }
        }

        return fieldValueFilterMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFieldMap</Name>
				<Source><![CDATA[
    private void buildFieldMap(Query _reportQuery, Map _fieldMap)
    {
        QueryBuildDataSource gjaeDS = _reportQuery.dataSourceTable(tableNum(GeneralJournalAccountEntry));
        QueryBuildDataSource gjeDS = _reportQuery.dataSourceTable(tableNum(GeneralJournalEntry));
        QueryBuildDataSource fcpDS = _reportQuery.dataSourceTable(tableNum(FiscalCalendarPeriod));
        QueryBuildDataSource companyInfoDS = _reportQuery.dataSourceTable(tableNum(CompanyInfo));

        if (!companyInfoDS || !gjeDS || !gjaeDS || !fcpDS)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        _reportQuery.clearAllFields();

        // General journal entry fields
        int gjeUniqueId = gjeDS.uniqueId();
        QueryBuildFieldList gjeFL = gjeDS.fields();

        gjeFL.addField(fieldNum(GeneralJournalEntry, AccountingDate));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, TransDate), [gjeUniqueId, fieldStr(GeneralJournalEntry, AccountingDate)]);

        gjeFL.addField(fieldNum(GeneralJournalEntry, PostingLayer));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, PostingLayer), [gjeUniqueId, fieldStr(GeneralJournalEntry, PostingLayer)]);

        gjeFL.addField(fieldNum(GeneralJournalEntry, RecId));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, GeneralJournalEntry), [gjeUniqueId, fieldStr(GeneralJournalEntry, RecId)]);

        // General journal account entry fields
        int gjaeUniqueId = gjaeDS.uniqueId();
        QueryBuildFieldList gjaeFL = gjaeDS.fields();

        gjaeFL.addField(fieldNum(GeneralJournalAccountEntry, RecId));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, GeneralJournalAccountEntry), [gjaeUniqueId, fieldStr(GeneralJournalAccountEntry, RecId)]);

        gjaeFL.addField(fieldNum(GeneralJournalAccountEntry, LedgerDimension));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, LedgerDimension), [gjaeUniqueId, fieldStr(GeneralJournalAccountEntry, LedgerDimension)]);

        gjaeFL.addField(fieldNum(GeneralJournalAccountEntry, Text));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, TransTxt), [gjaeUniqueId, fieldStr(GeneralJournalAccountEntry, Text)]);

        gjaeFL.addField(fieldNum(GeneralJournalAccountEntry, TransactionCurrencyCode));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, CurrencyCode), [gjaeUniqueId, fieldStr(GeneralJournalAccountEntry, TransactionCurrencyCode)]);

        gjaeFL.addField(fieldNum(GeneralJournalAccountEntry, PostingType));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, LedgerPostingType), [gjaeUniqueId, fieldStr(GeneralJournalAccountEntry, PostingType)]);

        // Fiscal calendar period fields
        int fcpUniqueId = fcpDS.uniqueId();
        QueryBuildFieldList fcpFL = fcpDS.fields();

        fcpFL.addField(fieldNum(FiscalCalendarPeriod, Type));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, PeriodCode), [fcpUniqueId, fieldStr(FiscalCalendarPeriod, Type)]);

        // Company info fields
        int companyInfoUniqueId = companyInfoDS.uniqueId();
        QueryBuildFieldList companyInfoFL = companyInfoDS.fields();

        companyInfoFL.addField(fieldNum(CompanyInfo, DataArea));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, GeneralJournalEntryDataArea), [companyInfoUniqueId, fieldStr(CompanyInfo, DataArea)]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processGroupPerSecondaryDimInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates sub-totals by grouping per secondary dimension.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> buffer.
    /// </param>
    private void processGroupPerSecondaryDimInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp)
    {
        LedgerTransStatementStagingTmp sourceTrans;

        try
        {
            DimensionsTransRecordType aggregateRecordType = DimensionsTransRecordType::Aggregate;
            TransTxt subTotal = "@SYS7470";

            // Use Closing type for transactions containing sub-total since we want the sub-totals
            // to appear at the end of the transaction list
            FiscalPeriodType closing = FiscalPeriodType::Closing;

            this.setUserConnection(sourceTrans);
            sourceTrans.linkPhysicalTableInstance(_ledgerTransStatementTmp);

            insert_recordset _ledgerTransStatementTmp
                (MainFocusValue,
                MainFocusDescription,
                SecondaryFocus,
                GeneralJournalEntryDataArea,
                TransTxt,
                PeriodCode,
                RecordType,
                AmountDebit,
                AmountCredit,
                ReportingCurrencyAmountDebit,
                ReportingCurrencyAmountCredit)
            select
                MainFocusValue,
                MainFocusDescription,
                SecondaryFocus,
                GeneralJournalEntryDataArea,
                subTotal,
                closing,
                aggregateRecordType,
                sum(AmountDebit),
                sum(AmountCredit),
                sum(ReportingCurrencyAmountDebit),
                sum(ReportingCurrencyAmountCredit)
            from sourceTrans
                group by MainFocusValue, MainFocusDescription, SecondaryFocus, GeneralJournalEntryDataArea
                where sourceTrans.PeriodCode == FiscalPeriodType::Operating;

            // Update the summation
            update_recordSet _ledgerTransStatementTmp setting
                AmountMSTDebCred = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit;
        }
        finally
        {
            this.disposeTempTable(sourceTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processOffsetAccountInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts and updates <c>LedgerTransStatementOffsetAccountTmp</c> buffer with appropriate offset account.
    /// </summary>
    /// <param name = "_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> buffer.
    /// </param>
    [Wrappable(true)]
    protected final void processOffsetAccountInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp)
    {
        LedgerTransStatementOffsetAccountTmp    offsetAccountTmp;
        MainAccount                             mainAccount;
        GeneralJournalAccountEntry              generalJournalAccountEntry;
        DimensionAttributeValueCombination      dimensionAttributeValueCombination;

        try
        {
            this.setUserConnection(offsetAccountTmp);

            // Start by pushing all data to process into a seperate temp table where
            // the individual account values can be dropped into individual columns
            insert_recordset offsetAccountTmp (GeneralJournalEntry, GeneralJournalAccountEntry)
                select GeneralJournalEntry, GeneralJournalAccountEntry from _ledgerTransStatementTmp;

            update_recordSet offsetAccountTmp
                setting OffsetAccountReference1 = generalJournalAccountEntry.MainAccount
            join MainAccount from generalJournalAccountEntry
                where generalJournalAccountEntry.GeneralJournalEntry == offsetAccountTmp.GeneralJournalEntry
                    && generalJournalAccountEntry.RecId != offsetAccountTmp.GeneralJournalAccountEntry;

            update_recordSet offsetAccountTmp
                setting OffsetAccountReference2 = generalJournalAccountEntry.MainAccount
            join MainAccount from generalJournalAccountEntry
                where generalJournalAccountEntry.MainAccount != offsetAccountTmp.OffsetAccountReference1
                    && generalJournalAccountEntry.GeneralJournalEntry == offsetAccountTmp.GeneralJournalEntry
                    && generalJournalAccountEntry.RecId != offsetAccountTmp.GeneralJournalAccountEntry;

            update_recordSet offsetAccountTmp
                setting OffsetAccountReference3 = generalJournalAccountEntry.MainAccount
            join MainAccount from generalJournalAccountEntry
                where generalJournalAccountEntry.MainAccount != offsetAccountTmp.OffsetAccountReference1
                    && generalJournalAccountEntry.MainAccount != offsetAccountTmp.OffsetAccountReference2
                    && generalJournalAccountEntry.GeneralJournalEntry == offsetAccountTmp.GeneralJournalEntry
                    && generalJournalAccountEntry.RecId != offsetAccountTmp.GeneralJournalAccountEntry;

            // Use a label for all cases where more than three accounts exist
            update_recordSet offsetAccountTmp setting
                IsMoreThanThree = NoYes::Yes,
                OffsetDescription = "@SYS78137" // Multiple
            exists join generalJournalAccountEntry
                where generalJournalAccountEntry.GeneralJournalEntry == offsetAccountTmp.GeneralJournalEntry
                    && generalJournalAccountEntry.RecId != offsetAccountTmp.GeneralJournalAccountEntry
                    && generalJournalAccountEntry.MainAccount != offsetAccountTmp.OffsetAccountReference1
                    && generalJournalAccountEntry.MainAccount != offsetAccountTmp.OffsetAccountReference2
                    && generalJournalAccountEntry.MainAccount != offsetAccountTmp.OffsetAccountReference3;

            update_recordset offsetAccountTmp setting
                OffsetDescription = mainAccount.MainAccountId
            join MainAccountId from mainAccount
                where offsetAccountTmp.OffsetAccountReference1
                    && offsetAccountTmp.IsMoreThanThree == NoYes::No
                    && offsetAccountTmp.OffsetAccountReference1 == mainAccount.RecId;

            update_recordset offsetAccountTmp setting
                OffsetDescription = offsetAccountTmp.OffsetDescription + OffsetAccountSeparator + mainAccount.MainAccountId
            join MainAccountId from mainAccount
                where offsetAccountTmp.OffsetAccountReference2
                    && offsetAccountTmp.IsMoreThanThree == NoYes::No
                    && offsetAccountTmp.OffsetAccountReference2 == mainAccount.RecId;

            update_recordset offsetAccountTmp setting
                OffsetDescription = offsetAccountTmp.OffsetDescription + OffsetAccountSeparator + mainAccount.MainAccountId
            join MainAccountId from mainAccount
                where offsetAccountTmp.OffsetAccountReference3
                    && offsetAccountTmp.IsMoreThanThree == NoYes::No
                    && offsetAccountTmp.OffsetAccountReference3 == mainAccount.RecId;

            // Copy the descriptions back to the source table
            update_recordSet _ledgerTransStatementTmp setting
                OffsetAccount = offsetAccountTmp.OffsetDescription
            join offsetAccountTmp
                where offsetAccountTmp.GeneralJournalAccountEntry == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                    && offsetAccountTmp.GeneralJournalEntry == _ledgerTransStatementTmp.GeneralJournalEntry;
        }
        finally
        {
            this.disposeTempTable(offsetAccountTmp);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processOpeningTransactionsInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the opening transactions.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The report start date.
    /// </param>
    /// <param name="_generateOpeningForNormalAccounts">
    /// A boolean value indicating whether accounts with transactions within the date range should have opening transactions.
    /// </param>
    private void processOpeningTransactionsInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, TransDate _fromDate, boolean _generateOpeningForNormalAccounts)
    {
        LedgerTransStatementStagingTmp sourceTrans;
        LedgerTransStatementStagingTmp sourceTransNotExists;
        NoYes yes = NoYes::Yes;
        FiscalPeriodType opening = FiscalPeriodType::Opening;
        TransTxt openingText = "@SYS53035";
        CurrentOperationsTax currentLayer = CurrentOperationsTax::Current;

        try
        {
            this.setUserConnection(sourceTrans);
            sourceTrans.linkPhysicalTableInstance(_ledgerTransStatementTmp);

            this.setUserConnection(sourceTransNotExists);
            sourceTransNotExists.linkPhysicalTableInstance(_ledgerTransStatementTmp);

            if (!_generateOpeningForNormalAccounts)
            {
                delete_from _ledgerTransStatementTmp
                where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Opening
                exists join sourceTrans
                    where sourceTrans.MainFocus == _ledgerTransStatementTmp.MainFocus
                        && sourceTrans.MainFocusName == _ledgerTransStatementTmp.MainFocusValue
                        && sourceTrans.GeneralJournalEntryDataArea == _ledgerTransStatementTmp.GeneralJournalEntryDataArea
                        && sourceTrans.MainFocusValue == _ledgerTransStatementTmp.MainFocusDescription
                        && sourceTrans.PeriodCode == FiscalPeriodType::Operating;
            }

            // Sum up all transactions by main focus and insert one opening transaction per combination
            insert_recordset _ledgerTransStatementTmp
                (IsGroupedOpeningTrans,
                PostingLayer,
                PeriodCode,
                AmountCredit,
                AmountDebit,
                TransactionCurrencyAmountCredit,
                TransactionCurrencyAmountDebit,
                ReportingCurrencyAmountCredit,
                ReportingCurrencyAmountDebit,
                MainFocusValue,
                MainFocusDescription,
                TransTxt,
                TransDate,
                GeneralJournalEntryDataArea)
            select
                yes,
                currentLayer,
                opening,
                sum(AmountCredit),
                sum(AmountDebit),
                sum(TransactionCurrencyAmountCredit),
                sum(TransactionCurrencyAmountDebit),
                sum(ReportingCurrencyAmountCredit),
                sum(ReportingCurrencyAmountDebit),
                MainFocusValue,
                MainFocusDescription,
                openingText,
                _fromDate,
                GeneralJournalEntryDataArea
            from sourceTrans
            group by sourceTrans.MainFocusValue, sourceTrans.MainFocusDescription, sourceTrans.GeneralJournalEntryDataArea
            where sourceTrans.PeriodCode == FiscalPeriodType::Opening;

            if (_generateOpeningForNormalAccounts)
            {
                // Insert zero balance opening records for those without any opening transactions
                insert_recordset _ledgerTransStatementTmp
                    (IsGroupedOpeningTrans,
                    PostingLayer,
                    PeriodCode,
                    MainFocusValue,
                    GeneralJournalEntryDataArea,
                    MainFocusDescription,
                    TransTxt,
                    TransDate)
                select
                    yes,
                    currentLayer,
                    opening,
                    MainFocusValue,
                    GeneralJournalEntryDataArea,
                    MainFocusDescription,
                    openingText,
                    _fromDate
                from sourceTrans
                group by sourceTrans.MainFocusValue, sourceTrans.MainFocusDescription, sourceTrans.GeneralJournalEntryDataArea
                notExists join sourceTransNotExists
                    where sourceTransNotExists.MainFocusValue == sourceTrans.MainFocusValue
                        && sourceTransNotExists.IsGroupedOpeningTrans == true;
            }

            // Delete the source records
            delete_from _ledgerTransStatementTmp
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Opening
                && _ledgerTransStatementTmp.IsGroupedOpeningTrans == false;
        }
        finally
        {
            this.disposeTempTable(sourceTrans);
            this.disposeTempTable(sourceTransNotExists);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the report business logic.
    /// </summary>
    public void processReport()
    {
        LedgerTransStatementContract contract;
        DimensionsTransTableType dimensionsTransTableType;
        FromDate fromDate;
        ToDate toDate;
        LedgerTransStatementStagingTmp ledgerTransStatementStagingTmp;

        try
        {
            contract = this.parmDataContract() as LedgerTransStatementContract;
            mainFocusName = contract.parmPrimaryDimensionFocus();
            secondaryFocusName = contract.parmSecondaryDimensionFocus();
            dimensionsTransTableType = contract.parmTransaction();
            fromDate = contract.parmFromDate();
            toDate = contract.parmToDate();

            primaryFocusRecId   = DimensionHierarchy::findByTypeAndName(DimensionHierarchyType::Focus, mainFocusName).RecId;
            secondaryFocusRecId = DimensionHierarchy::findByTypeAndName(DimensionHierarchyType::Focus, secondaryFocusName).RecId;

            this.setUserConnection(ledgerTransStatementTmp);
            this.setUserConnection(ledgerTransStatementStagingTmp);

            using (SysInstrumentationActivityContext activityContext = this.logProcessReport())
            {
                this.addActivityContextForReport(
                    activityContext,
                    contract);

                // Populate the base processing table with data from the appropriate source table
                switch (dimensionsTransTableType)
                {
                    case DimensionsTransTableType::LedgerBudget:
                        this.populateTempTableBudgetInStaging(ledgerTransStatementStagingTmp, this.parmQuery(), fromDate, toDate);

                        // Fill in the focus names and descriptions
                        this.populateDimensionInformationInStaging(ledgerTransStatementStagingTmp, mainFocusName, secondaryFocusName);

                        break;

                    case DimensionsTransTableType::LedgerTrans:
                        this.populateTempTableLedgerInStaging(
                            ledgerTransStatementStagingTmp,
                            this.parmQuery(),
                            fromDate,
                            toDate,
                            contract.parmOpeningTrans(),
                            contract.parmClosingTrans(),
                            contract.parmPrimaryDimensionFocus(),
                            contract.parmDisplayCompanyForLedgerAccount(),
                            contract.parmPostingLayers());

                        // Fill in the focus names and descriptions
                        this.populateDimensionInformationInStaging(ledgerTransStatementStagingTmp, mainFocusName, secondaryFocusName);

                        break;
                }

                // Process reversed transaction values
                this.processReversedTransactionsInStaging(ledgerTransStatementStagingTmp, contract.parmIncludeReversed());

                // Process "without trans" parameter. Run this after processReversedTransactions because that might delete
                // records if "Include reversed" is unmarked. processWithoutTrans should
                // run after unwanted records have been removed so that all accounts without operating transactions
                // are removed by processWithoutTrans
                this.processWithoutTransInStaging(ledgerTransStatementStagingTmp,
                        contract.parmWithoutTrans(),
                        contract.parmOpeningTrans(),
                        contract.parmFromDate());

                // Group opening transactions
                if (dimensionsTransTableType == DimensionsTransTableType::LedgerTrans
                        || dimensionsTransTableType == DimensionsTransTableType::LedgerBudget)
                {
                    this.processOpeningTransactionsInStaging(ledgerTransStatementStagingTmp, fromDate, true);
                }

                // Sales tax specification
                if (contract.parmSalesTaxSpec())
                {
                    this.processSalesTaxSpecificationInStaging(ledgerTransStatementStagingTmp, fromDate, toDate);
                }

                // Set offset account
                if (contract.parmOffsetAccount())
                {
                    this.processOffsetAccountInStaging(ledgerTransStatementStagingTmp);
                }

                // Group by specification and generate records for empty periods if needed
                this.processSpecificationGroupingInStaging(
                        ledgerTransStatementStagingTmp,
                        contract.parmSpecification(),
                        fromDate,
                        toDate,
                        contract.parmEmptyPeriods());

                // Group by secondary dimension set - Subtotals are inserted as Closing transactions
                if (contract.parmGroupPerSec())
                {
                    this.processGroupPerSecondaryDimInStaging(ledgerTransStatementStagingTmp);
                }

                // Calculate ending balance
                this.calculateEndingBalanceInStaging(ledgerTransStatementStagingTmp, toDate, dimensionsTransTableType);

                // Populate the accumulated and balance amounts for opening transactions
                this.updateOpeningAmountsInStaging(ledgerTransStatementStagingTmp);

                this.copyToReportTable(ledgerTransStatementStagingTmp);

                ledgerTransStatementStagingTmp = null;

                // Log the customer activity properties after the report data has been generated
                // because the query is adjusted based on the dimensionsTransTableType
                this.addActivityQueryContextForReport(
                    activityContext,
                    contract,
                    this.parmQuery());
            }
        }
        finally
        {
            this.disposeTempTable(ledgerTransStatementStagingTmp);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReversedTransactionsInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes reversed transactions.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_includeReversed">
    /// A boolean value indicating whether reversed transactions must be included.
    /// </param>
    private void processReversedTransactionsInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, boolean _includeReversed)
    {
        TransactionReversalTrans transactionReversalTrans;

        if (_includeReversed)
        {
            // Set the trace number and reversed flag for reversed transactions
            // Reversed transactions so TransactionReversalTrans.Reversed flag will be true. Show "R" next to Trace number
            update_recordset _ledgerTransStatementTmp setting
                TraceNum = transactionReversalTrans.TraceNum,
                Reversed = "@SYS321480"
            join transactionReversalTrans
                where transactionReversalTrans.RefTableId == tableNum(GeneralJournalAccountEntry)
                    && transactionReversalTrans.RefRecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                    && transactionReversalTrans.Reversed == NoYes::Yes;

            // Revoked transactions so TransactionReversalTrans.Reversed flag will be false. Don't show "R"
            update_recordset _ledgerTransStatementTmp setting
                TraceNum = transactionReversalTrans.TraceNum
            join transactionReversalTrans
                where transactionReversalTrans.RefTableId == tableNum(GeneralJournalAccountEntry)
                    && transactionReversalTrans.RefRecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                    && transactionReversalTrans.Reversed == NoYes::No;
        }
        else
        {
            // Delete transactions which have been reversed. The original transaction is treated as
            // unreversed and needs to stay
            delete_from _ledgerTransStatementTmp
                exists join transactionReversalTrans
                    where transactionReversalTrans.RefTableId == tableNum(GeneralJournalAccountEntry)
                        && transactionReversalTrans.RefRecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                        && transactionReversalTrans.Reversed == NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSalesTaxSpecificationInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates sales tax codes and amounts.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The start date.
    /// </param>
    /// <param name="_ToDate">
    /// The end date.
    /// </param>
    public void processSalesTaxSpecificationInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, FromDate _fromDate, ToDate _ToDate)
    {
        LedgerTransStatementStagingTmp tmpTransSalesTax;
        TaxTrans taxTrans;
        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;
        Statement statement;
        str updateRowNumSql;
        TableName taxTableName;
        UserConnection userConn = this.parmUserConnection();

        try
        {
            this.setUserConnection(tmpTransSalesTax);

            // Insert new records for transactions that have associated tax details
            insert_recordset tmpTransSalesTax
                (GeneralJournalAccountEntry, GeneralJournalEntry, GeneralJournalEntryDataArea, MainFocusDescription, MainFocusValue,
                PeriodCode, PostingLayer, SecondaryFocus, TransDate, Voucher, TaxCode, TaxAmount)
                select
                    GeneralJournalAccountEntry, GeneralJournalEntry, GeneralJournalEntryDataArea, MainFocusDescription, MainFocusValue,
                    PeriodCode, PostingLayer, SecondaryFocus, TransDate, Voucher
                from _ledgerTransStatementTmp
                group by _ledgerTransStatementTmp.MainFocusValue, _ledgerTransStatementTmp.MainFocusDescription, _ledgerTransStatementTmp.SecondaryFocus,
                    _ledgerTransStatementTmp.PostingLayer, _ledgerTransStatementTmp.PeriodCode, _ledgerTransStatementTmp.GeneralJournalEntry, _ledgerTransStatementTmp.GeneralJournalEntryDataArea,
                    _ledgerTransStatementTmp.GeneralJournalAccountEntry, _ledgerTransStatementTmp.TransDate, _ledgerTransStatementTmp.Voucher, taxTrans.TaxCode
                    where _ledgerTransStatementTmp.TransDate >= _fromDate
                        && _ledgerTransStatementTmp.TransDate <= _ToDate
                join taxTransGeneralJournalAccountEntry
                    where taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                        && (taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::TransactionLineAccount ||
                            taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::CashDiscount)
                        && taxTransGeneralJournalAccountEntry.MonetaryAmountType != MonetaryAmount::TaxVariance
                        && taxTransGeneralJournalAccountEntry.MonetaryAmountType != MonetaryAmount::PriceVariance
                join TaxCode, sum(TaxAmount) from taxTrans
                    where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans;

            // The Tempdb table isn't created until either a record is inserted or this select call is made, and therefore doesn't have a physical table name.
            // Because we aren't 100% sure an insert has occurred, execute a select call to ensure a physical table exists.
            select firstOnly RecId from tmpTransSalesTax;
            taxTableName = tmpTransSalesTax.getPhysicalTableName();

            // Update table with tax records to add the sorted GroupRowNum per GeneralJournalAccountEntry
            // Using Direct SQL here so that the ROW_NUMBER function of SQL can be utilized
            updateRowNumSql = 'UPDATE TAXTMP ';
            updateRowNumSql += 'SET GROUPROWNUM = X.ROWNUM ';
            updateRowNumSql += strFmt('FROM (SELECT RECID, ROW_NUMBER() OVER (PARTITION BY GENERALJOURNALACCOUNTENTRY ORDER BY TAXCODE) AS ROWNUM FROM %1) X ', taxTableName);
            updateRowNumSql += strFmt('INNER JOIN %1 TAXTMP ON X.RECID = TAXTMP.RECID ', taxTableName);

            new SqlStatementExecutePermission(updateRowNumSql).assert();
            statement = userConn.createStatement();
            statement.executeUpdateWithParameters(updateRowNumSql, SqlParams::create());
            CodeAccessPermission::revertAssert();

            // Update processing table with TaxCode and TaxAmount with values from first TaxCode record per GJAE
            update_recordSet _ledgerTransStatementTmp setting
                GroupRowNum = tmpTransSalesTax.GroupRowNum,
                TaxCode = tmpTransSalesTax.TaxCode,
                TaxAmount = tmpTransSalesTax.TaxAmount
            join GroupRowNum, TaxCode, TaxAmount
            from tmpTransSalesTax
                where tmpTransSalesTax.GeneralJournalAccountEntry == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                    && tmpTransSalesTax.GroupRowNum <= 1;

            // Insert remaining records
            insert_recordset _ledgerTransStatementTmp
                (GeneralJournalAccountEntry, GeneralJournalEntry, GeneralJournalEntryDataArea, MainFocusDescription, MainFocusValue,
                PeriodCode, PostingLayer, SecondaryFocus, TransDate, Voucher, TaxCode, TaxAmount, GroupRowNum)
            select
                GeneralJournalAccountEntry, GeneralJournalEntry, GeneralJournalEntryDataArea, MainFocusDescription, MainFocusValue,
                PeriodCode, PostingLayer, SecondaryFocus, TransDate, Voucher, TaxCode, TaxAmount, GroupRowNum
            from tmpTransSalesTax
                where tmpTransSalesTax.GroupRowNum > 1;
        }
        finally
        {
            this.disposeTempTable(tmpTransSalesTax);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSpecificationGroupingInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups records based on the given specification.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_specification">
    /// The <c>DimensionsLedgerTransSpecDim</c> specification type.
    /// </param>
    /// <param name="_fromDate">
    /// The start date.
    /// </param>
    /// <param name="_toDate">
    /// The end date.
    /// </param>
    /// <param name="_generateEmptyPeriods">
    /// A boolean value indicating whether records must be inserted for periods that do not have operating transactions.
    /// </param>
    private void processSpecificationGroupingInStaging(
        LedgerTransStatementStagingTmp _ledgerTransStatementTmp,
        DimensionsLedgerTransSpecDim _specification,
        FromDate _fromDate,
        ToDate _toDate,
        boolean _generateEmptyPeriods)
    {
        switch (_specification)
        {
            case DimensionsLedgerTransSpecDim::Day:
                this.groupByDayInStaging(_ledgerTransStatementTmp, _fromDate, _toDate, _generateEmptyPeriods);
                break;
            case DimensionsLedgerTransSpecDim::Month:
                this.groupByMonthInStaging(_ledgerTransStatementTmp, _fromDate, _toDate, _generateEmptyPeriods);
                break;
            case DimensionsLedgerTransSpecDim::Period:
                this.groupByPeriodInStaging(_ledgerTransStatementTmp, _fromDate, _toDate, _generateEmptyPeriods);
                break;
            case DimensionsLedgerTransSpecDim::Quarter:
                this.groupByQuarterInStaging(_ledgerTransStatementTmp, _fromDate, _toDate, _generateEmptyPeriods);
                break;
            case DimensionsLedgerTransSpecDim::Total:
                // Group everything to one record with no description
                this.groupTransactionsByRangeInStaging(_ledgerTransStatementTmp, _fromDate, _toDate, '');
                break;
            case DimensionsLedgerTransSpecDim::Transaction:
                // No grouping, leave as is
                break;
            case DimensionsLedgerTransSpecDim::Week:
                this.groupByWeekInStaging(_ledgerTransStatementTmp, _fromDate, _toDate, _generateEmptyPeriods);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processWithoutTransInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes records for ledger accounts that do not have any transactions within the date range.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_withoutTrans">
    /// A boolean value indicating whether ledger accounts without transactions within the date range must be added.
    /// </param>
    /// <param name="_includeOpening">
    /// A boolean value indicating whether opening transactions must be treated as operating transactions.
    /// </param>
    /// <param name="_startDate">
    /// The report start date.
    /// </param>
    private void processWithoutTransInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, boolean _withoutTrans, boolean _includeOpening, FromDate _startDate)
    {
        LedgerTransStatementStagingTmp  sourceTrans;
        TransDate                       periodStartDate;
        FiscalCalendarPeriod            fiscalCalendarPeriod;
        GeneralJournalEntry             generalJournalEntry;
        SkipAOSValidationPermission     perm;

        try
        {
            perm = new SkipAOSValidationPermission();
            perm.assert();
        
            this.setUserConnection(sourceTrans);
            sourceTrans.linkPhysicalTableInstance(_ledgerTransStatementTmp);

            periodStartDate = LedgerFiscalCalendar::findOpeningStartDateByDate(CompanyInfoHelper::fiscalCalendarRecId(), _startDate);

            if (!_withoutTrans)
            {
                // If withoutTrans and includeOpening are both not selected, the the opening transactions from the last fiscal period
                // should not be deleted.
                if (!_includeOpening && _startDate == periodStartDate)
                {
                    UserConnection userCon = this.parmUserConnection();

                    userCon.ttsBegin();

                    while select forUpdate _ledgerTransStatementTmp
                        join FiscalCalendarPeriod from generalJournalEntry
                            where generalJournalEntry.RecId == _ledgerTransStatementTmp.GeneralJournalEntry
                        join Type from fiscalCalendarPeriod
                            where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                        notExists join sourceTrans
                            where sourceTrans.MainFocus == _ledgerTransStatementTmp.MainFocus
                                && sourceTrans.MainFocusName == _ledgerTransStatementTmp.MainFocusName
                                && sourceTrans.MainFocusValue == _ledgerTransStatementTmp.MainFocusValue
                                && sourceTrans.GeneralJournalEntryDataArea == _ledgerTransStatementTmp.GeneralJournalEntryDataArea
                                && sourceTrans.PeriodCode == FiscalPeriodType::Operating
                    {
                        if (fiscalCalendarPeriod.Type == FiscalPeriodType::Opening)
                        {
                            continue;
                        }
                        _ledgerTransStatementTmp.doDelete();
                    }

                    userCon.ttsCommit();
                }
                else
                {
                    // If withoutTrans is not selected, delete the transactions that have no operating transactions in the given date range
                    delete_from _ledgerTransStatementTmp
                        notExists join sourceTrans
                            where sourceTrans.MainFocus == _ledgerTransStatementTmp.MainFocus
                                && sourceTrans.MainFocusName == _ledgerTransStatementTmp.MainFocusName
                                && sourceTrans.MainFocusValue == _ledgerTransStatementTmp.MainFocusValue
                                && sourceTrans.PeriodCode == FiscalPeriodType::Operating
                                && sourceTrans.GeneralJournalEntryDataArea == _ledgerTransStatementTmp.GeneralJournalEntryDataArea;
                }
            }
            CodeAccessPermission::revertAssert();
        }
        finally
        {
            this.disposeTempTable(sourceTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUserConnection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the user connection on the table buffer.
    /// </summary>
    /// <param name="_common">
    /// The table buffer.
    /// </param>
    private void setUserConnection(Common _common)
    {
        UserConnection con = this.parmUserConnection();

        if (con)
        {
            _common.setConnection(con);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>disposeTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Disposes temp table buffer after the process is completed.
    /// </summary>
    /// <param name="_common">
    /// The temp table buffer.
    /// </param>
    private void disposeTempTable(Common _common)
    {
        if (FeatureStateProvider::isFeatureEnabled(LedgerSSRSReportDisposeTempTableFlight::instance()))
        {
            _common.dispose();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAccumulatedAmountsInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates accumulated amounts.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    private void updateAccumulatedAmountsInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp)
    {
        LedgerTransStatementTmpAccumulated tmpAccumulated;
        LedgerTransStatementStagingTmp sourceTrans;

        try
        {
            this.setUserConnection(sourceTrans);
            sourceTrans.linkPhysicalTableInstance(_ledgerTransStatementTmp);

            this.setUserConnection(tmpAccumulated);

            insert_recordset tmpAccumulated (LedgerTransStatementTmp, AccumulatedDebit, AccumulatedCredit, ReportingAccumulatedDebit, ReportingAccumulatedCredit)
            select RecId from _ledgerTransStatementTmp
                group by _ledgerTransStatementTmp.RecId
            join sum(AmountDebit), sum(AmountCredit), sum(ReportingCurrencyAmountDebit), sum(ReportingCurrencyAmountCredit) from sourceTrans
                where sourceTrans.MainFocusValue == _ledgerTransStatementTmp.MainFocusValue
                    && sourceTrans.RecId <= _ledgerTransStatementTmp.RecId
                    // Don't include accumulated amounts from sub-totals because that would
                    // result in amounts getting considered twice
                    && sourceTrans.RecordType != DimensionsTransRecordType::Aggregate;

            update_recordSet _ledgerTransStatementTmp setting
                AccumulatedMST = tmpAccumulated.AccumulatedDebit - tmpAccumulated.AccumulatedCredit,
                ReportingAccumulatedMST = tmpAccumulated.ReportingAccumulatedDebit - tmpAccumulated.ReportingAccumulatedCredit,
                PreviousDebitTotal = tmpAccumulated.AccumulatedDebit,
                PreviousCreditTotal = tmpAccumulated.AccumulatedCredit
            join tmpAccumulated
                where tmpAccumulated.LedgerTransStatementTmp == _ledgerTransStatementTmp.RecId;

            // Clear out the AmountDebit and AmountCredit from opening transactions
            update_recordSet _ledgerTransStatementTmp setting
                AmountMSTDebCred = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
                AmountDebit = 0.0,
                AmountCredit = 0.0,
                ReportingCurrencyAmountDebit = 0.0,
                ReportingCurrencyAmountCredit = 0.0
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Opening;
        }
        finally
        {
            this.disposeTempTable(sourceTrans);
            this.disposeTempTable(tmpAccumulated);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOpeningAmountsInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates amounts for opening transactions.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <remarks>
    /// This is the last step in the process to populate the <c>LedgerTransStatementStagingTmp</c> table.
    /// The clearing of the debit and credit amounts cannot be done until they are no longer needed by any other calculation.
    /// </remarks>
    private void updateOpeningAmountsInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp)
    {
        update_recordSet _ledgerTransStatementTmp setting
            AccumulatedMST = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
            ReportingAccumulatedMST = _ledgerTransStatementTmp.ReportingCurrencyAmountDebit - _ledgerTransStatementTmp.ReportingCurrencyAmountCredit,
            AmountMSTDebCred = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
            AmountDebit = 0.0,
            AmountCredit = 0.0,
            ReportingCurrencyAmountDebit = 0.0,
            ReportingCurrencyAmountCredit = 0.0
        where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Opening;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logProcessReport</Name>
				<Source><![CDATA[
    private SysInstrumentationActivityContext logProcessReport()
    {
        const str InstrumentationNamespace = 'LedgerTransStatement';

        SysInstrumentationLogger instrumentationLogger = SysInstrumentationLoggerFactory::CreateLogger(InstrumentationNamespace);

        const str MetricName = methodStr(LedgerTransStatementDP, processReport);

        SysInstrumentationActivity activityContext = SysInstrumentationActivity::construct(
            MetricName,
            InstrumentationNamespace);

        return instrumentationLogger.activityContextWithCustomProperties(activityContext);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addActivityContextForReport</Name>
				<Source><![CDATA[
    private void addActivityContextForReport(
        SysInstrumentationActivityContext _activityContext,
        LedgerTransStatementContract _reportContract)
    {
        _activityContext.addCustomProperty('LedgerRecId', int642Str(Ledger::current()));
        _activityContext.addCustomProperty('DimensionHierarchyId', int642Str(primaryFocusRecId));
        _activityContext.addCustomProperty('SecondaryDimensionHierarchyId', int642Str(secondaryFocusRecId));
        _activityContext.addCustomProperty('Transactions', enum2Str(_reportContract.parmTransaction()));
        _activityContext.addCustomProperty('CurrencySelection', enum2Str(_reportContract.parmCurrencySelection()));
        _activityContext.addCustomProperty('GroupPerSec', _reportContract.parmGroupPerSec() ? 'Yes' : 'No');
        _activityContext.addCustomProperty('FromDate', date2StrXpp(_reportContract.parmFromDate()));
        _activityContext.addCustomProperty('ToDate', date2StrXpp(_reportContract.parmToDate()));
        _activityContext.addCustomProperty('NewPage', _reportContract.parmNewPage() ? 'Yes' : 'No');
        _activityContext.addCustomProperty('Specification', enum2Str(_reportContract.parmSpecification()));
        _activityContext.addCustomProperty('SalesTaxSpec', _reportContract.parmSalesTaxSpec() ? 'Yes' : 'No');
        _activityContext.addCustomProperty('OffsetAccount', _reportContract.parmOffsetAccount() ? 'Yes' : 'No');
        _activityContext.addCustomProperty('CurrencyTotal', _reportContract.parmCurrencyTotal() ? 'Yes' : 'No');
        _activityContext.addCustomProperty('EmptyPeriods', _reportContract.parmEmptyPeriods() ? 'Yes' : 'No');
        _activityContext.addCustomProperty('WithoutTrans', _reportContract.parmWithoutTrans() ? 'Yes' : 'No');
        _activityContext.addCustomProperty('OpeningTrans', _reportContract.parmOpeningTrans() ? 'Yes' : 'No');
        _activityContext.addCustomProperty('ClosingTrans', _reportContract.parmClosingTrans() ? 'Yes' : 'No');
        _activityContext.addCustomProperty('IncludeReversed', _reportContract.parmIncludeReversed() ? 'Yes' : 'No');
    }

]]></Source>
			</Method>
			<Method>
				<Name>addActivityQueryContextForReport</Name>
				<Source><![CDATA[
    private void addActivityQueryContextForReport(
        SysInstrumentationActivityContext _activityContext,
        LedgerTransStatementContract _reportContract,
        Query _query)
    {
        int rowCount = QueryRun::getQueryRowCount(_query, maxInt());
        _activityContext.addCustomProperty('RowCountForReport', int2Str(rowCount));
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>