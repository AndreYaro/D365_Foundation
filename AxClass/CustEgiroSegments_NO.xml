<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustEgiroSegments_NO</Name>
	<SourceCode>
		<Declaration><![CDATA[
class CustEgiroSegments_NO
{
    Counter segmentsInMessage;

    container   segmentCont[];

    container   gr_00_BGM;
    container   gr_27_CNT;
    container   gr_00_DTM;
    container   gr_00_UNA;
    container   gr_00_UNB;
    container   gr_00_UNH;
    container   gr_28_UNT;
    container   gr_99_UNZ;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>cleanStr</Name>
				<Source><![CDATA[
    private str  cleanStr(str _s)
    {
        #define.cleanchars(":+'")
        ;
        // this method cleans the string by removing ':', '+' and '''
        return strrem (_s, #cleanchars);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBGMsegment</Name>
				<Source><![CDATA[
    public str  createBGMsegment(str 3  _messageName,
                                 str 35 _messageNumber)
    {
        // BGM = Beginning of message segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'BGM';
        // MESSAGE NAME (C002)
        // Message name, coded (1001)
        segment += '+' + this.cleanStr(_messageName);   //452 Multiple payment order
                                                        //213 Request for financial cancelation
        // MESSAGE NUMBER (1004)
        segment += '+' + this.cleanStr(_messageNumber);
        // MESSAGE FUNCTION, CODED (1225)
        // segment += '+9';     // 9 = original //Not used by BBS (or optional and only original allowed)

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBUSsegment</Name>
				<Source><![CDATA[
    public str  createBUSsegment(str 3 _busFunction,
                                 str 2 _environment)
    {
        // BUS = Business function segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'BUS';
        segment += '+';
        // BUSINESS FUNCTION (C521)
        if (_busFunction)
        {
            // Business function qualifier (4027) and coded (4025) (only used in PAYMUL)
            segment += '1:' + this.cleanStr(_busFunction);  // PEN = Pension
                                                            // SAL = Salary
                                                            // ZZZ = Mutually defined
                                                            // If BBS receives another code than above,
                                                            // it will be converted to and threat like ZZz
        }
        // GEOGRAPHIC ENVIRONMENT, CODED (3279)
        segment += '+' + this.cleanStr(_environment);       // DO = Domestic payment
                                                            // IN = International payment

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCNTsegment</Name>
				<Source><![CDATA[
    public str  createCNTsegment(int _value)
    {
        // CNT = Control total segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'CNT';
        // CONTROL (C270)
        // Control qualifier (6069)
        segment += '+LI';
        // Control value (6066)
        segment += ':' + int2str(_value);   // PAYMUL: Total number of LIN-segments
                                            // FINCAN: Total number of level b

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCOMsegment</Name>
				<Source><![CDATA[
    public str  createCOMsegment(str 25 _comNumber,
                                 str 3  _comChannel)
    {
        // COM = Communication contact segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'COM';
        // CONTACT COMMUNICATION (C076)
        // Communication number (3148)
        segment += '+' + this.cleanStr(_comNumber);
        // Communication channel qualifier (3155)
        segment += ':' + this.cleanStr(_comChannel);    // EI = EDI transmission
                                                        // FX = Telefax
                                                        // SW = SWIFt
                                                        // TE = Telephone
                                                        // TL = Telex
                                                        // MA = Mail

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCTAsegment</Name>
				<Source><![CDATA[
    public str  createCTAsegment(str 3             _contactFunction,
                                 ContactPersonName _contactPerson)
    {
        // CTA = Contact information segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'CTA';
        // Contact function (3139)
        segment += '+' + this.cleanStr(_contactFunction);      // BC = Bank contact
        // DEPARTMENT OR EMPLOYEE IDENTIFICATION (C056)
        // Contact person (3412)
        segment += '+' + this.cleanStr(_contactPerson);

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCUXsegment</Name>
				<Source><![CDATA[
    public str  createCUXsegment(CurrencyCode _invoiceCurrencyCode,
                                 CurrencyCode _paymentCurrencyCode,
                                 ExchRate     _exchRate = 0)
    {
        // CUX = Currency segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'CUX';
        // CURRENCY DETAILS (C504)
        // Invoice currency (6347 og 6345)
        segment += '+2:' + strupr(this.cleanStr(Currency::currencyCodeISO(_invoiceCurrencyCode)));
        // CURRENCY DETAILS (C504)
        // Payment currency (6347 og 6345)
        segment += '+3:' + strupr(this.cleanStr(Currency::currencyCodeISO(_paymentCurrencyCode)));
        if (_exchRate)
        {
            // EXCHANGERATE (5402)
            segment += '+' + num2str(_exchRate,0,4,2,0);
        }

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDOCsegment</Name>
				<Source><![CDATA[
    public str  createDOCsegment(str 3  _messageName,
                                 str 35 _messageNumber)
    {
        // DOC = Document/message details segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'DOC';
        // DOCUMENT/MESSAGE NAME (C002)
        // Document/message name, coded (1001)
        segment += '+' + this.cleanStr(_messageName);   // One of the following codes must be used:
                                                        // 999 = OCR payment
                                                        // 380 = Commercial invoice
                                                        // 381 = Credit note
        // DOCUMENT/MESSAGE DETAILS (C503)
        // Document/message number (1004) (Customer identification)
        segment += '+' + this.cleanStr(_messageNumber);

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDTMsegment</Name>
				<Source><![CDATA[
    public str  createDTMsegment(str 3      _qualifier,
                                 date       _date,
                                 str 3      _formatQualifier,
                                 timeOfDay  _time = DateTimeUtil::getTimeNow(DateTimeUtil::getUserPreferredTimeZone()))
    {
        // DTM = Date/time/period segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'DTM';
        // DATE/TIME/PERIOD (C507)
        // Date/time/period qualifier (2005)
        segment += '+' + _qualifier;    //137 Message date
                                        //138 Payment date
                                        //203 Requested execution date/time or date for receiving payment order
                                        //209 Value date
                                        //171 Date/time of reference in RFF segment (invoice date)

        // Date/time/period (2380)
        switch (_formatQualifier)
        {
            case '102' :   // 102 = YYYYMMDd
            {
                segment += ':' + date2str(_date,321,2,0,2,0,4,DateFlags::None);
                break;
            }
            case '203' :   // 203 = YYYYMMDDHHMm
            {
                segment += ':' + date2str(_date,321,2,0,2,0,4,DateFlags::None)+ substr(time2str(_time,1,1),1,2) +
                                 substr(time2str(_time,1,1),4,2);
                break;
            }
    //        case '204' :   // 204 = YYYYMMDDHHMMSs
    //        {
    //            segment += ':' + date2str(_date,321,2,0,2,0,4,DateFlags::None)+ subStr(time2str(_time,1,1),1,2) +
    //                             subStr(time2str(_time,1,1),4,2) + subStr(time2str(_time,1,1),7,2);
    //            break;
    //        }
        }

        // Date/time/period format qualifier (2379)
        segment += ':' + _formatQualifier;

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFCAsegment</Name>
				<Source><![CDATA[
    public str  createFCAsegment(int _settlement)
    {
        // FCA = Financial charges allocation segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'FCA';
        // Settlement coded (4471)
        segment += '+' + int2str(_settlement); // 13 = All charges borne by payee (beneficiary)
                                               // 14 = Each pay own cost
                                               // 15 = All charges borne by payor (order placer)
        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFIIsegment</Name>
				<Source><![CDATA[
    public str  createFIIsegment(str 3                       _partyQualifier,
                                 BankAccount                 _bankAccount,
                                 Name                        _nameAccountHolder           = '',
                                 CurrencyCode                _currencyCode                = '',
                                 str 11                      _swiftCode                   = '',
                                 str 17                      _bankBranchNum               = '',
                                 str 3                       _bankBranchQualifier         = '',
                                 str 3                       _bankBranchResponsible       = '',
                                 Name                        _bankName                    = '',
                                 AddressCountryRegionISOCode _countryISOCodeBank          = '',
                                 boolean                     _international               = false)
    {
        // FII = Financial institution segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'FII';
        // PARTY QUALIFIER (3035)
        segment += '+' + this.cleanStr(_partyQualifier);    // OR = Ordering bank
                                                            // RB = Receiving financial institution - only international
                                                            // BF = Beneficiary's bank
                                                            // MR = Message receiver (FINCAN)

        // ACCOUNT IDENTIFICATION (C078)
        if (_partyQualifier != 'MR')
        {
            // Account number (3194)
            segment += '+' + this.cleanStr(_bankAccount);

            // Name of the account holder (3192) and currency (6345)
            if (_nameAccountHolder)
            {
                segment += ':' + _nameAccountHolder;
                if (_currencyCode && _partyQualifier == 'BF')
                {
                    segment += '::' + strupr(this.cleanStr(Currency::currencyCodeISO(_currencyCode)));
                }
            }
            else if (_currencyCode && _partyQualifier == 'BF')
            {
                segment += ':::' + strupr(this.cleanStr(Currency::currencyCodeISO(_currencyCode)));
            }
        }
        else
        {
            segment += '+';
        }

        // INSTITUTION IDENTIFICATION (C088)
        if (_partyQualifier != 'OR')
        {
            if (_swiftCode)
            {
                // Institution name identification (SWIFT) (3433) and Code list qualifier (1131)/responsible agency (3055)
                segment += '+' + this.cleanStr(_swiftCode) + ':25:5';
            }
            else if (_partyQualifier == 'MR' || _international)
            {
                error(strfmt("@SYS89866","@SYS23725"));
            }
            if (_partyQualifier == 'BF' && _international)
            {
                if (_bankBranchNum)
                {
                    if (_bankBranchQualifier && _bankBranchResponsible)
                    {
                        // Institution branch number (3434)
                        segment += ':' + this.cleanStr(_bankBranchNum);
                        // Institution branch Code list qualifier (1131)
                        segment += ':' + this.cleanStr(_bankBranchQualifier);   // 25  = Fedwire Id
                                                                                // 25  = US ABa
                                                                                // 25  = German Bankleitzahl
                                                                                // 154 = GB Bank Sort Code
                                                                                // 25  = Austrian Bankleitzahl
                        // Institution branch Code list responsible agency (3055)
                        segment += ':' + this.cleanStr(_bankBranchResponsible); // 19  = Fedwire Id
                                                                                // 114 = US ABa
                                                                                // 131 = German Bankleitzahl
                                                                                // 133 = GB Bank Sort Code
                                                                                // 137 = Austrian Bankleitzahl
                        if (_bankName)
                        {
                            // Institution name (3432)
                            segment += ':' + this.cleanStr(_bankName);
                        }
                    }
                    else
                    {
                        error(strfmt("@SYS89866","@SYS119617"));
                    }
                }
                else if (_bankName)
                {
                    // Institution name (3432)
                    segment += '::::' + this.cleanStr(_bankName);
                }
            }
        }

        // ISO COUNTRY CODE OF THE BANK (3207)
        if (_partyQualifier == 'BF' && _countryISOCodeBank)
        {
            segment += '+' + this.cleanStr(_countryISOCodeBank);
        }

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFTXsegment</Name>
				<Source><![CDATA[
    public str  createFTXsegment(str 3 _qualifier,
                                 Array _text,
                                 str 3 _textCoded = '')
    {
        // FTX = Free text segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        int i = 1;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'FTX';
        // TEXT SUBJECT QUALIFIER (4451)
        segment += '+' + this.cleanStr(_qualifier); // AAG = Party instructions
                                                    // REG = Regularity information
                                                    // PMD = Payment detail/remittance information
                                                    // ABO = Discrepancy information/Information about differencies
        if (_qualifier == 'REG')
        {
            // TEXT REFERENCE (C107)
            // Free text, coded (4441)
            segment += '++' + this.cleanStr(_textCoded);
            // TEXT LITERAL (C108)
            // Free text 1 (4440)
            segment += '+' + this.cleanStr(_text.value(1));
        }
        else
        {
            // TEXT LITERAL (C108)
            // Free text 1 (4440)
            segment += '+++' + this.cleanStr(_text.value(i));
            i++;
            while (_text.exists(i) && _qualifier != 'AAG' && i <= 5)
            {
                // Free text 2-5 (4440)
                segment += ':' + this.cleanStr(_text.value(i));
                i++;
            }
        }

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createGISsegment</Name>
				<Source><![CDATA[
    public str  createGISsegment(int _indicator)
    {
        // GIS = General indicator segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'GIS';
        // PROCESSING INDICATOR (C529)
        // Processing indicator, coded (7365)
        segment += '+' + int2str(_indicator);   // 10 = International payments exceeding NOK 100.000,-
                                                // 37 = Complete information

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createINPsegment</Name>
				<Source><![CDATA[
    public str  createINPsegment(str 2  _partyQualifier,
                                 str 3  _instruction)
    {
        // INP = Instruction to parties segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'INP';
        // PARTIES TO INSTRUCTION (C849)
        // Party enacting instruction identification (3301)
        segment += '+' + this.cleanStr(_partyQualifier);    // OR = Ordered bank
                                                            // BF = Beneficiary's bank
        // Recipient of the instruction identification (3285)
        segment += ':BE';    // BE = Beneficiary

        // INSTRUCTION (C522)
        // Instruction qualifier (4403)
        segment += '+1';
        // Instruction, coded (4401)
        segment += ':' + this.cleanStr(_instruction);   // AD = Advice
                                                        // SI = Information to beneficiary’s statement
                                                        // EI = EDI – Advice via EDIFACT CREMUl
                                                        // Following codes are only for international use:
                                                        // AJ = Advice by fax
                                                        // AP = Advice by phone
                                                        // AT = Advice by telex

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLINsegment</Name>
				<Source><![CDATA[
    public str  createLINsegment(Counter _liNinMessage)
    {
        // LIN = Line item segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'LIN';
        // LINE ITEM NUMBER (1082)
        segment += '+' + int2str(_liNinMessage);

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMOAsegment</Name>
				<Source><![CDATA[
    public str  createMOAsegment(int          _qualifier,
                                 Amount       _paymentAmount,
                                 CurrencyCode _currencyCode)
    {
        // MOA = Monetary amount segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'MOA';
        //  MONETARY AMOUNT (C516)
        //  Monetary amount type qualifier (5025)
        segment += '+' + int2str(_qualifier);   // 9   = Amount due/amount payable - only domestic
                                                // 57  = Equivalent amount - only international
                                                // 347 = Sum of all underlaying C´s - domestic and international
                                                // 165 = Indicates adjusted amount
                                                // 128 = Indicates total adjusted amount
        // Monetary amount (5004)
        segment += ':' + num2str(_paymentAmount,0,2,2,0);   //Ex: 12345,67
        // Currency (6345)
        if (_qualifier != 9)
        {
            segment += ':' + strupr(this.cleanStr(Currency::currencyCodeISO(_currencyCode)));
        }

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNADsegment</Name>
				<Source><![CDATA[
    public str  createNADsegment(str 3  _partyQualifier,
                                 str 35 _partyId,
                                 str 35 _street     = '',
                                 str 35 _city       = '',
                                 str 9  _zipCode    = '',
                                 str 3  _country    = '')
    {
        // NAD = Name and address segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'NAD';
        // PARTY QUALIFIER (3035)
        segment += '+' + this.cleanStr(_partyQualifier);    // MS = message sender
                                                            // OY = Ordering customer –identifies the originator of the instruction.
                                                            //      This is normally the account holder
                                                            // PL = Payor - identifies the debit party
                                                            //      when other than the ordering customer
                                                            // BE = Beneficiary – the ultimate recipient of the funds
                                                            // PE = Payee – identifies the credit party when other than the beneficiary
                                                            // IV = Receiver of invoice
                                                            // MA = Party for whom item is ultimately intended
                                                            // PO = Ordering party
                                                            // II = Issuer of invoice
                                                            // SU = Supplier

        if (_city && _zipCode)
        {
            // PARTY NAME (C080)
            // Party name (3036)
            segment += '+++' + this.cleanStr(_partyId);
            // STREET (C059)
            segment += '+';
            if (_street)
            {
                // Street (3042)
                segment += this.cleanStr(_street);
            }
            // CITY NAME (3164)
            segment += '+' + this.cleanStr(_city);
            // ZIPCODE (3251)
            segment += '+' + this.cleanStr(_zipCode);
            // COUNTRY (3207)
            if (_country)
            {
                segment += '+' + this.cleanStr(_country);
            }
        }
        else
        {
            // party Id, Organisation Number(= agreement number in BBS) (3039)
            segment += '+' + this.cleanStr(_partyId);
        }

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPAIsegment</Name>
				<Source><![CDATA[
    public str  createPAIsegment(str 3 _paymentMethod,
                                 str 3 _paymentChannel = '')
    {
        // PAI = Payment instructions segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'PAI';
        // PAYMENT INSTRUCTIONS DETAILS (C534)
        // Payment means (4461)
        segment += '+::' + this.cleanStr(_paymentMethod);   // 8  = Hold (Await payment until beneficiary personally has
                                                            //      identified himself as told in FTX, group 14) Only international
                                                            // 21 = Banker ´s draft/Giro Utbetaling
                                                            //      (Issue Banker´s draft/Giro Utbetaling) Only domestic
                                                            // 23 = Bank Cheque (Issue a cheque) Only international
                                                            // 26 = Local Cheque (Indicates that the cheque shall be issued by
                                                            //      a local bank/financial institution in the recipient´s country)
                                                            //      Only international
                                                            // ZZ = Urgent payment For domestic and international use
        // Payment channel (4435)
        if (_paymentChannel)
        {
            segment += ':::' + this.cleanStr(_paymentChannel);  // 5 = SWIFT (Payment shall be transfered via SWIFT) Only international
                                                                // 6 = NORDPAY/SBP (Payment shall be transfered via NORDPAy
                                                                //     or SBP (bank-dependent) Only international
        }

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPRCsegment</Name>
				<Source><![CDATA[
    public str  createPRCsegment(int _identification)
    {
        // PRC = Process identification segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'PRC';
        // PROCESS TYPE AND DESCRIPTION (C242)
        // Process type identification (7187)
        segment += '+'+ int2str(_identification);  //  8 = information in structured form (segment group 17 ff. follows)
                                                   // 11 = information in unstructured form (FTX segment follows)
        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRFFsegment</Name>
				<Source><![CDATA[
    public str  createRFFsegment(str 3  _qualifier,
                                 str 35 _number)
    {
        // RFF = Reference data segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'RFF';
        // REFERENCE (C506)
        // Reference qualifier (1153)
        segment += '+' + this.cleanStr(_qualifier);     // AEK = Payment order number - payor’s B-level reference
                                                        // CR  = Payor's reference to the debit instruction
                                                        // ACX = Banker's acceptance - reference to person in the bank
                                                        //       with whom the agreement has been made
                                                        // FX  = Foreign Exchange Contract Number
                                                        // AFO = Beneficiary’s reference
                                                        // AGN = Payor’s C-level reference
                                                        // RA  = Remittance advice number
                                                        // DM  = FINCAN: Message nummer - Ref to BGM dataelement 1004 (in PAYMUL)
                                                        // AAK = Despatch Advice Number
                                                        // AEL = Delivery Number
                                                        // CO  = Byer´s Order Number
                                                        // CT  = Contrac Number
                                                        // IV  = Invoice Number
        // Reference number (1154)
        segment += ':' + this.cleanStr(_number);

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSEQsegment</Name>
				<Source><![CDATA[
    public str  createSEQsegment(Counter _seQinLIN)
    {
        // SEQ = Sequence details segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'SEQ';

        // SEQUENCE INFORMATION (C286)
        // Sequence number (1050)
        segment += '++' + int2str(_seQinLIN);

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createUNBsegment</Name>
				<Source><![CDATA[
    public str  createUNBsegment(str    _sender,
                                 str    _recipient,
                                 str    _interchangeReference,
                                 NoYes  _test = NoYes::No)
    {
        // UNB = Interchange header segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        // Segment name
        segment = 'UNB';
        // SYNTAX IDENTIFICATION (S001)
        // Syntax identifier (0001) and syntax version number (0002)
        segment += '+UNOC:3';
        // INTERCHANGE SENDER (S002)
        // Sender identification (0004)
        segment += '+' + this.cleanStr(_sender);
        // INTERCHANGE RECIPIENT (S003)
        //Recipient identification (0010)
        segment += '+' + this.cleanStr(_recipient);
        // DATE/TIME OF PREPARATION (S004)
        // Date ÅÅMMDD (0017)
        segment += '+' + date2str(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),321,2,0,2,0,2,DateFlags::None);
        // Time TTMM (0019)
        segment += ':' + substr(time2str(DateTimeUtil::getTimeNow(DateTimeUtil::getUserPreferredTimeZone()),1,1),1,2) + substr(time2str(DateTimeUtil::getTimeNow(DateTimeUtil::getUserPreferredTimeZone()),1,1),4,2);
        // INTERCHANGE REFERENCE (0020)
        segment += '+' + this.cleanStr(_interchangeReference);
        // TESTINDICATOR (0035)
        if (_test)
        {
            segment += '++++++1';
        }

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createUNHsegment</Name>
				<Source><![CDATA[
    public str  createUNHsegment(str 14 _messageReferenceNumber,
                                 str 6  _messageType)
    {
        // UNH = Message header segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage = 1;

        // Segment name
        segment = 'UNH';
        // MESSAGE REFERENCE NUMBER (0062).
        segment += '+' + this.cleanStr(_messageReferenceNumber);    //_messageReferenceNumber must be numeric in BBS' system.
        // MESSAGE IDENTIFIER (S009)
        // Message type (0065), version number (0052), release number (0054) and Controlling agency (0051)
        segment += '+' + this.cleanStr(_messageType) + ':D:96A:UN';

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createUNTsegment</Name>
				<Source><![CDATA[
    public str  createUNTsegment(str 14 _messageReferenceNumber)
    {
        // UNT = Message trailer segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        segmentsInMessage += 1;

        // Segment name
        segment = 'UNT';
        // NUMBER OF SEGMENTS IN THE MESSAGE (0074)
        segment += '+' + int2str(segmentsInMessage);
        // MESSAGE REFERENCE NUMBER (0062). Same as in UNh
        segment += '+' + this.cleanStr(_messageReferenceNumber);

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createUNZsegment</Name>
				<Source><![CDATA[
    public str  createUNZsegment(Counter _messageNo,
                                 str     _interchangeReference)
    {
        // UNZ = Interchange trailer segment
        // + = segment data element seperator
        // : = segment sub-element seperator
        // ' = segment delimiter
        str segment;
        ;
        // Segment name
        segment = 'UNZ';
        // INTERCHANGE CONTROL COUNT = NUMBER OF MESSAGES (0036)
        segment += '+' + int2str(_messageNo);
        // INTERCHANGE REFERENCE (0020) (Same as in UNB)
        segment += '+' + this.cleanStr(_interchangeReference);

        segment += '\'';

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>gr_00_BGM</Name>
				<Source><![CDATA[
    container gr_00_BGM(container _segment = gr_00_BGM)
    {
        ;
        gr_00_BGM = _segment;
        return gr_00_BGM;
    }

]]></Source>
			</Method>
			<Method>
				<Name>gr_00_DTM</Name>
				<Source><![CDATA[
    container gr_00_DTM(container _segment = gr_00_DTM)
    {
        ;
        gr_00_DTM = _segment;
        return gr_00_DTM;
    }

]]></Source>
			</Method>
			<Method>
				<Name>gr_00_UNA</Name>
				<Source><![CDATA[
    container gr_00_UNA(container _segment = gr_00_UNA)
    {
        ;
        gr_00_UNA = _segment;
        return gr_00_UNA;
    }

]]></Source>
			</Method>
			<Method>
				<Name>gr_00_UNB</Name>
				<Source><![CDATA[
    container gr_00_UNB(container _segment = gr_00_UNB)
    {
        ;
        gr_00_UNB = _segment;
        return gr_00_UNB;
    }

]]></Source>
			</Method>
			<Method>
				<Name>gr_00_UNH</Name>
				<Source><![CDATA[
    container gr_00_UNH(container _segment = gr_00_UNH)
    {
        ;
        gr_00_UNH = _segment;
        return gr_00_UNH;
    }

]]></Source>
			</Method>
			<Method>
				<Name>gr_27_CNT</Name>
				<Source><![CDATA[
    container gr_27_CNT(container _segment = gr_27_CNT)
    {
        ;
        gr_27_CNT = _segment;
        return gr_27_CNT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>gr_28_UNT</Name>
				<Source><![CDATA[
    container gr_28_UNT(container _segment = gr_28_UNT)
    {
        ;
        gr_28_UNT = _segment;
        return gr_28_UNT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>gr_99_UNZ</Name>
				<Source><![CDATA[
    container gr_99_UNZ(container _segment = gr_99_UNZ)
    {
        ;
        gr_99_UNZ = _segment;
        return gr_99_UNZ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>segmentGet</Name>
				<Source><![CDATA[
    container segmentGet(int _segmGroup,
                         str _segmType,
                         int _occ = 1,
                         str _qualifier='@@@')  //'@@@@@XYZ123' = When no qualifier
    {
        container groupCont;
        container cont;
        int       i;
        int       segmentTypeIndex;

        segmentTypeIndex = confind(segmentCont[_segmGroup], _segmType);

        if (segmentTypeIndex > 0)
        {
            groupCont = conpeek(segmentCont[_segmGroup], segmentTypeIndex + 1);
            i         = confind(groupCont,_qualifier,_occ);
            if (i)
            {
                cont = conpeek(groupCont, i+2);
            }
        }

        return cont;
    }

]]></Source>
			</Method>
			<Method>
				<Name>segmentGetGroup</Name>
				<Source><![CDATA[
    container segmentGetGroup(int _segmGroup,
                              str _segmType)
    {
        container groupCont;
        int       segmentTypeIndex;

        segmentTypeIndex = confind(segmentCont[_segmGroup], _segmType);

        if (segmentTypeIndex > 0)
        {
            groupCont = conpeek(segmentCont[_segmGroup], segmentTypeIndex + 1);
        }

        return groupCont;
    }

]]></Source>
			</Method>
			<Method>
				<Name>segmentSet</Name>
				<Source><![CDATA[
    void segmentSet(int       _segmGroup,
                    container _segment,
                    int       _occ = 1,
                    str       _qualifier='@@@')  //'@@@@@XYZ123' when no qualifier
    {
        container   groupCont;
        str         segmType    = conpeek(_segment,1);
        int         posGroup;
        int         posQualifier;
        ;

        posGroup                = conlen(segmentCont[_segmGroup]) ?
                                  confind(segmentCont[_segmGroup],segmType) :
                                  0;

        if (posGroup)
        {
            groupCont = conpeek(segmentCont[_segmGroup],posGroup+1);
        }
        else
        {
            groupCont = connull();
        }

        posQualifier            = conlen(groupCont) ?
                                  confind(groupCont,_qualifier,_occ) :
                                  0;
    //    posQualifier            = conLen(groupCont) ?
    //                              conFind(groupCont,_qualifier) :
    //                              0;

        groupCont               = posQualifier ?
                                  conpoke(groupCont, posQualifier,          _qualifier, _occ, _segment) :
                                  conins(groupCont,  conlen(groupCont) + 1, _qualifier, _occ, _segment);

        segmentCont[_segmGroup] = posGroup ?
                                  conpoke(segmentCont[_segmGroup], posGroup,                            segmType, groupCont) :
                                  conins(segmentCont[_segmGroup],  conlen(segmentCont[_segmGroup]) + 1, segmType, groupCont);
    }

]]></Source>
			</Method>
			<Method>
				<Name>segmentZeroLIN</Name>
				<Source><![CDATA[
    boolean segmentZeroLIN()
    {
        ;
        segmentCont[4] = connull();
        segmentCont[5] = connull();
        segmentCont[6] = connull();
        segmentCont[7] = connull();
        segmentCont[8] = connull();
        segmentCont[9] = connull();
        this.segmentZeroSEQ();
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>segmentZeroSEQ</Name>
				<Source><![CDATA[
    boolean segmentZeroSEQ()
    {
        ;
        segmentCont[10] = connull();
        segmentCont[11] = connull();
        segmentCont[12] = connull();
        segmentCont[13] = connull();
        segmentCont[14] = connull();
        segmentCont[15] = connull();
        segmentCont[16] = connull();
        segmentCont[17] = connull();
        segmentCont[18] = connull();
        segmentCont[19] = connull();
        segmentCont[20] = connull();
        segmentCont[21] = connull();
        segmentCont[22] = connull();
        segmentCont[23] = connull();
        segmentCont[24] = connull();
        segmentCont[25] = connull();
        segmentCont[26] = connull();
        segmentCont[27] = connull();
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>valuesCon</Name>
				<Source><![CDATA[
    container valuesCon(str _value)
    {
        container   c;
        int         i = 1;
        str         tmpValue = _value;
        ;

        while (strscan(tmpValue,':',1,999999))
        {
            c = conins(c,i,substr(tmpValue,1,strscan(tmpValue,':',1,999999)-1));
            i++;
            tmpValue = strdel(tmpValue,1,strscan(tmpValue,':',1,999999));
        }

        if (! strscan(tmpValue,':',1,999999) && tmpValue)
        {
            c = conins(c,i,tmpValue);
        }

        return c;
    }

]]></Source>
			</Method>
			<Method>
				<Name>valuesConSegm</Name>
				<Source><![CDATA[
    anytype valuesConSegm(int _pos, int _element, int _segmGroup,  str _segmType, int _occ = 1, str _qualifier='@@@')
    {
        container segment;
        container valuesCon;
        container values;
        ;
        segment   = this.segmentGet(_segmGroup,_segmType,_occ,_qualifier);
        if (conlen(segment))
        {
            if (_element)
            {
                valuesCon = this.valuesCon(conpeek(segment,_pos));
                values    = conins(values,1,conpeek(valuesCon,_element));
            }
            else
            {
                values    = conins(values,1,conpeek(segment,_pos));
            }
        }
        else
        {
            values    = conins(values,1,'');
        }
        return conpeek(values,1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getValuesCon</Name>
				<Source><![CDATA[
    static container getValuesCon(str _value)
    {
        CustEgiroSegments_NO  segments = new CustEgiroSegments_NO();
        ;

        return segments.valuesCon(_value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getValuesConSegm</Name>
				<Source><![CDATA[
    static anytype getValuesConSegm(container _segment, int _pos, int _element)
    {
        container   valuesCon;
        container   values;
        anytype     anyTypeNull;
        ;
        if (conlen(_segment))
        {
            if (_element)
            {
                valuesCon = CustEgiroSegments_NO::getValuesCon(conpeek(_segment,_pos));
                values     = conins(values,1,conpeek(valuesCon,_element));
            }
            else
            {
                values     = conins(values,1,conpeek(_segment,_pos));
            }
        }
        else
        {
            values     = conins(values,1,'');
        }
        return conlen(values) ? conpeek(values,1) : anyTypeNull;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>