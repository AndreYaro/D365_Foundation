<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>MCRCustPaym_CreditCard</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

/// <summary>
///     The <c>MCRCustPaym_CreditCard</c> class that
///     handles customer payments of type "credit card".
/// </summary>
public class McrCustPaym_CreditCard extends MCRCustPaym
{
    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

    MCROrderParameters  orderParameters;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowEditCreditCard</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if it is allowable to update the credit card number and credit
    ///     card vendor fields.
    /// </summary>
    /// <returns>
    ///     true if credit card and credit card vendor field are able to be updated;
    ///     otherwise, false.
    /// </returns>
    /// <remarks>
    ///     The fields are not allowed to be updated if any it is poted in any way.
    /// </remarks>
    public boolean allowEditCreditCard()
    {
        if (mcrCustPaymTable.PostedAmount)
        {
            return false;
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the currency should be allowed to be modified for this
    ///     payment.
    /// </summary>
    /// <returns>
    ///     true if the currency is allowed to be modified; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     Overridden to disallow changing the currency if any authorization or
    ///     settlement records exist for the payment.  This is necessary because the
    ///     currency is used on authorization and settlement records.
    /// </remarks>
    public boolean allowEditCurrency()
    {
        boolean allowEdit;

        allowEdit = super();

        if (allowEdit)
        {
            allowEdit = !this.existAuthOrSettlementRecords();
        }

        return allowEdit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditInvoiceAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the invoice account should be allowed to be modified for this
    ///     payment.
    /// </summary>
    /// <returns>
    ///     true if the invoice account is allowed to be modified; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     Overridden to disallow changing the invoice account if any authorization or
    ///     settlement records exist for the payment.  This is necessary because the
    ///     address used on authorization and settlement records is the address for the
    ///     invoice account.
    /// </remarks>
    public boolean allowEditInvoiceAccount()
    {
        boolean allowEdit;

        allowEdit = super();

        if (allowEdit)
        {
            allowEdit = !this.existAuthOrSettlementRecords();
        }

        return allowEdit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>authorizeCharge</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initiates authorization for a credit card charge (debit to the card).
    /// </summary>
    /// <returns>
    ///     The <c>MCRCustPaymStatus</c> after the payment is submitted for authorization.
    /// </returns>
    private MCRCustPaymStatus authorizeCharge()
    {
        CreditCardAuthTrans creditCardAuthTrans;
        MCROrderParameters   mcrOrderParameters;
        boolean             preAuthResult;

        // unable to re-use existing authorization -- create new record

        if (mcrCustPaymTable.RefTableId == tableNum(SalesTable))
        {
            creditCardAuthTrans = CreditCardAuthTrans::mcrFindLatest(mcrCustPaymTable.RecId);
        }

        if (RetailPaymentsCvvPromptFlight::instance().isEnabled() && this.parmCreditCardCvv())
        {
            SalesTable salesTableLocal = SalesTable::findRecId(mcrCustPaymTable.RefRecId);

            if (CreditCardProcessCvvHelper::isCvvRequired(mcrCustPaymTable, salesTableLocal))
            {
                CreditCardProcess process = CreditCardProcess::construct(CreditCardOperation::Authorize, mcrCustPaymTable);
                process.parmCardVerificationValue(this.parmCreditCardCvv());

                preAuthResult = CreditCardProcess::mcrDoPreAuthWithPassedProcess(mcrCustPaymTable, true, null, process);
            }
        }
        else
        {
            preAuthResult = CreditCardProcess::mcrDoPreAuth(mcrCustPaymTable);
        }

        if (!preAuthResult)
        {
            mcrOrderParameters = MCROrderParameters::find();
            int numberOfRetries = mcrOrderParameters.mcrNumCCAuthRetry - mcrCustPaymTable.NumAuthRetry;
            if (mcrOrderParameters.MCRRetryOnSubmit == NoYes::Yes && numberOfRetries > 0)
            {
                // Display warning - Credit card was not authorized, # of remaining retries left for this card = <numberOfRetries>
                info(strFmt("@Retail:CreditCardNotAuthRemainingRetries", numberOfRetries));
            }
        }

        // Find the latest credit card authorization record
        creditCardAuthTrans = CreditCardAuthTrans::mcrFindLatest(mcrCustPaymTable.RecId);

        // In Payments Sevices form, When ["AVS Check"] is enabled and ["Void transaction when no results are availble"] is also enabled,
        // The system will void the original auth in case of AVS check failure, and the latest creditcardauthtrans will now be the
        // "Void" record instead of the voided "authorization" record.
        // Note: When the latest credit card operation on this MCRCustpaymTable is a "Void", query for the original voided "authorization" instead.
        if (!creditCardAuthTrans || creditCardAuthTrans.ApprovalType == CreditCardOperation::Void)
        {
            creditCardAuthTrans = CreditCardAuthTrans::mcrFindLatestVoidedApproval(mcrCustPaymTable.RecId);
        }

        // Reread MCRCustPaymTable record if this is non-recurring payment
        if (mcrCustPaymTable.IsNonRecurring == NoYes::Yes)
        {
            mcrCustPaymTable.reread();
        }

        // calculate resulting payment status
        return MCRCustPaym_CreditCard::calculateChargePaymStatus(creditCardAuthTrans, mcrCustPaymTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>authorizeChargeManually</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Authorizes this credit card payment manually.
    /// </summary>
    /// <param name="_creditCardAuthorization">
    ///     Credit card authorization code, obtained from the credit card processor.
    /// </param>
    /// <returns>
    ///     The new payment status.  The payment should be updated with this new
    ///     status.
    /// </returns>
    /// <remarks>
    ///     Related authorization records are updated, but the payment record is not.
    ///
    ///     In some cases, it is not appropriate to simply update the currently
    ///     active authorization record, because it would overwrite data that should
    ///     be retained for tracking purposes.  Instead, old authorization records
    ///     are deleted or made inactive, and a new authorization record is created.
    ///     The new record is then updated to be manually authorized.
    /// </remarks>
    public MCRCustPaymStatus authorizeChargeManually(CreditCardAuthorization _creditCardAuthorization)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        // payment must be a charge (positive amount) for manual authorization
        if (mcrCustPaymTable.getUnpostedAmount() <= 0.0)
        {
            throw error("@MCR10754");
        }

        // update the authorization to be manually authorized
        ttsbegin;
        creditCardAuthTrans = CreditCardAuthTrans::mcrFindLatest(mcrCustPaymTable.RecId, true);

        if (creditCardAuthTrans)
        {
            creditCardAuthTrans.mcrManuallyAuthorize(_creditCardAuthorization);
            if (creditCardAuthTrans.validateWrite())
            {
                creditCardAuthTrans.update();
            }
            else
            {
                throw error("@SYS104318");
            }
        }
        ttscommit;

        return MCRCustPaym_CreditCard::calculateChargePaymStatus(creditCardAuthTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>authorizeRefund</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initiates authorization for a credit card refund (credit to the card).
    /// </summary>
    /// <returns>
    ///     The mcrCustPaymStatus of the payment after authorization initiation.
    /// </returns>
    /// <remarks>
    ///     Currently, authorizations of refunds are tracked by using
    ///     the mcrCustPaymStatus of a settlement record.  It would be preferable to
    ///     use a separate concept (a new table?) for tracking refund
    ///     authorizations.
    /// </remarks>
    private MCRCustPaymStatus authorizeRefund()
    {
        MCRCustPaymStatus       mcrCustPaymStatus;
        Amount                  refundApprovalAmount;
        Amount                  unpostedAmount;

        refundApprovalAmount = MCROrderParameters::find().mcrCreditCardApprovalAmount;

        // Check if a refund amount has been setup, if it has compare unposted to the
        // parameter, otherwise return authorized
        if (refundApprovalAmount)
        {
            unpostedAmount = abs(mcrCustPaymTable.getUnpostedAmount());
            // If the unposted amount is greater than the parameter, refund requires
            // approval
            if (unpostedAmount > refundApprovalAmount)
            {
                mcrCustPaymStatus = MCRCustPaymStatus::NotSubmitted;
            }
            else if (mcrCustPaymTable.IsPrepay)
            {
                mcrCustPaymStatus = MCRCustPaymStatus::Posted;
            }
            else
            {
                mcrCustPaymStatus = MCRCustPaymStatus::Authorized;
            }
        }
        else if (mcrCustPaymTable.IsPrepay)
        {
            mcrCustPaymStatus = MCRCustPaymStatus::Posted;
        }
        else
        {
            mcrCustPaymStatus = MCRCustPaymStatus::Authorized;
        }

        return mcrCustPaymStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if posting is possible.
    /// </summary>
    /// <param name="_postAmount">
    ///     The amount to check of posting is possible.
    /// </param>
    /// <returns>
    ///     true if posting is possible; otherwise, false.
    /// </returns>
    public boolean canPost(AmountCur _postAmount)
    {
        boolean canPost = false;

        if (_postAmount != 0)
        {
            switch (mcrCustPaymTable.RefTableId)
            {
                case tableNum(SalesTable):
                case tableNum(LedgerJournalTrans):
                case tableNum(CustInvoiceTable):
                case tableNum(CustPaymSchedLine):
                case tableNum(MCRCustCreditTable):
                    if (mcrCustPaymTable.Status != MCRCustPaymStatus::NotSubmitted)
                    {
                        canPost = true;
                    }
                break;
                default:
                    throw error("@SYS89176");
            }
        }
        return canPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCreditCardEvents</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a credit card event.
    /// </summary>
    /// <remarks>
    ///     If the new payment status is 'declined' due to one or more declined credit
    ///     cards, record an event so a customer letter will be sent.  Same thing for
    ///     orders being held due to one or more credit cards being held.
    /// </remarks>
    private void createCreditCardEvents()
    {
        CreditCardAuthTrans creditCardAuthTrans;
        SalesTable          salesTable;

        if (mcrCustPaymTable)
        {
            creditCardAuthTrans = CreditCardAuthTrans::mcrFindLatest(mcrCustPaymTable.RecId);

            // When the payment is related to any other table other than
            // the sales table there is no need to raise an event.
            if (mcrCustPaymTable
                    && mcrCustPaymTable.RefTableId == tableNum(SalesTable))
            {
                if (creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Declined)
                {
                    salesTable = SalesTable::findRecId(mcrCustPaymTable.RefRecId);
                    RetailEventNotificationAction::insertRetailOENAction(RetailEventNotificationType::PaymentFailed,
                            creditCardAuthTrans.RecId,
                            salesTable);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>declineChargeManually</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Declines this credit card payment manually.
    /// </summary>
    /// <param name="_responseCode">
    ///     The response code indicating the reason for declining the credit card authorization.
    /// </param>
    /// <returns>
    ///     The new payment status after the payment has ben declined.
    /// </returns>
    /// <remarks>
    ///     Related authorization records are updated, but the payment record is not.
    ///     In some cases, it is not appropriate to simply update the currently
    ///     active authorization record, because it would overwrite data that should
    ///     be retained for tracking purposes.  Instead, old authorization records
    ///     are deleted or made inactive, and a new authorization record is created.
    ///     The new record is then updated to be manually declined.
    /// </remarks>
    public MCRCustPaymStatus declineChargeManually(str _responseCode)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        if (!_responseCode)
        {
            throw error("@MCR27548");
        }
        // Payment must be a charge (positive amount) for manual authorization.
        if (mcrCustPaymTable.getUnpostedAmount() <= 0.0)
        {
            throw error("@MCR10754");
        }

        ttsbegin;
        creditCardAuthTrans = CreditCardAuthTrans::mcrFindLatest(mcrCustPaymTable.RecId, true);

        if (creditCardAuthTrans)
        {
            //if a credit card auth record exists, manually decline the transaction
            creditCardAuthTrans.mcrManuallyDecline(_responseCode);
            if (creditCardAuthTrans.validateWrite())
            {
                creditCardAuthTrans.update();
            }
            else
            {
                throw error("@SYS104318");
            }
        }
        ttscommit;

        return MCRCustPaym_CreditCard::calculateChargePaymStatus(creditCardAuthTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine a status of a CallCenter MCRCustPaymTable record
    /// </summary>
    /// <param name = "isRefund">is this a refund?</param>
    /// <param name = "isPost">is this called from post? If false, it is a payment authorization, otherwise it is a payment capture.</param>
    /// <returns>Returns the calculated status for the payment.</returns>
    public MCRCustPaymStatus determineStatus(boolean isRefund = false, boolean isPost = false)
    {
        MCRCustPaymStatus       retStatus       = mcrCustPaymTable.Status;
        CreditCardAuthTrans     creditCardAuthTrans  = CreditCardAuthTrans::mcrFindLatest(mcrCustPaymTable.RecId);
        AmountCur               settledAmount   = CreditCardAuthTrans::mcrFindCharge(mcrCustPaymTable.RecId).ApprovalAmountCur;
        AmountCur               totalSettledAmount = CreditCardAuthTrans::mcrFindTotalCapturedAmount(mcrCustPaymTable.RecId);

        if (settledAmount == mcrCustPaymTable.Amount || (totalSettledAmount == mcrCustPaymTable.Amount
            && RetailIncrementalCaptureFeatureExposure::isEnabledAndSupported(mcrCustPaymTable)))
        {
            retStatus = MCRCustPaymStatus::Paid;
        }
        else if (mcrCustPaymTable.PostedAmount == mcrCustPaymTable.Amount)
        {
            retStatus = MCRCustPaymStatus::Posted;
        }
        else
        {
            if (creditCardAuthTrans)
            {
                if (creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Declined)
                {
                    retStatus = MCRCustPaymStatus::Declined;
                }
                else if (creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved)
                {
                    if (mcrCustPaymTable.IsPrepay)
                    {
                        retStatus = MCRCustPaymStatus::Posted;
                    }
                    else
                    {
                        if (isRefund)
                        {
                            retStatus = MCRCustPaymStatus::Posted;
                        }
                        else
                        {
                            if (isPost)
                            {
                                if(RetailIncrementalCaptureFeatureExposure::isEnabledAndSupported(creditCardAuthTrans))
                                {
                                    // continue to have payment status set to Authorized for incremental captures.
                                    retStatus = MCRCustPaymStatus::Authorized;
                                }
                                else
                                {
                                    retStatus = MCRCustPaymStatus::Paid;
                                }
                            }
                            else
                            {
                                retStatus = MCRCustPaymStatus::Authorized;
                            }
                        }
                    }
                }
            }
        }

        return retStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existAuthOrSettlementRecords</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if one or more authorization or settlement records exist for
    ///     the payment.
    /// </summary>
    /// <returns>
    ///     true if one or more authorization or settlement records exist; otherwise, false.
    /// </returns>
    private boolean existAuthOrSettlementRecords()
    {
        CreditCardAuthTrans    creditCardAuthTrans;

        select firstonly RecId from creditCardAuthTrans
            where creditCardAuthTrans.mcrPaymRecId == mcrCustPaymTable.RecId
            && (creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::NA
                || creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved
                || creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Settled);

        if (creditCardAuthTrans)
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultValue</Name>
				<Source><![CDATA[
    public  anytype getDefaultValue(FieldId _fieldId)
    {
        MCRCustPaymTotals   mcrCustPaymTotals;
        SalesTable          salesTable;
        LedgerJournalTrans  ledgerJournalTrans;

        Percent             totalPercentAmount = 0.0;

        switch (_fieldId)
        {
            case fieldNum(MCRCustPaymTable, IsPrepay):
                // Returns
                if (mcrCustPaymTable.RefTableId == tableNum(SalesTable))
                {
                    salesTable = SalesTable::findRecId(mcrCustPaymTable.RefRecId);
                }
                // Returns merge - look at SalesTable instead of ReturnTable
                if (salesTable.SalesType == SalesType::ReturnItem
                    && salesTable.mcrReturnSalesTable().AdvanceCredit )
                {
                    return NoYes::Yes;
                }

                return NoYes::No;

            case fieldNum(MCRCustPaymTable, PercentAmount):
                if (mcrCustPaymTable.RefTableId == tableNum(MCRContinuityCustHeader))
                {
                    return 0.0;
                }
                else
                {
                    // default to remaining balance
                    mcrCustPaymTotals =
                        MCRCustPaymTotals::construct(mcrCustPaymTable.RefTableId,
                                                    mcrCustPaymTable.RefRecId);

                    if (mcrCustPaymTotals)
                    {
                        totalPercentAmount = mcrCustPaymTotals.getTotalPercentAmount();
                    }

                    return max(100.0 - totalPercentAmount, 0.0);
                }
            case fieldNum(MCRCustPaymTable, Amount):
                // If this is related to a journal line it is being created through
                //      the journal form, force amount to the journal line.
                if (mcrCustPaymTable.RefTableId == tableNum(LedgerJournalTrans))
                {
                    ledgerJournalTrans = LedgerJournalTrans::findRecId(mcrCustPaymTable.RefRecId, false);
                    return (ledgerJournalTrans.AmountCurCredit ? ledgerJournalTrans.AmountCurCredit : -ledgerJournalTrans.AmountCurDebit);
                }
                else
                {
                    return 0.0;
                }
        }

        return super(_fieldId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the payment account and account type.
    /// </summary>
    /// <returns>
    /// The account type <c>LedgerJournalACType</c> and the account <c>LedgerJournalAC</c>
    /// </returns>
    /// <remarks>
    /// By default, the account type and account are determined by the payment method.
    /// </remarks>
    public container getPaymAccount()
    {
        RetailStoreTenderTypeCardTable      retailStoreTenderTypeCardTable;
        LedgerJournalACType                 offsetType;
        LedgerDimensionDefaultAccount       offsetAccount;

        retailStoreTenderTypeCardTable = RetailStoreTenderTypeCardTable::find(mcrCustPaymTable.Channel,
                                                                                mcrCustPaymTable.TenderTypeId,
                                                                                mcrCustPaymTable.CardTypeId);

        if (retailStoreTenderTypeCardTable)
        {
            switch (retailStoreTenderTypeCardTable.AccountType)
            {
                case RetailLedgerBank::Bank:
                    offsetType = LedgerJournalACType::Bank;
                break;
                case RetailLedgerBank::Ledger:
                    offsetType = LedgerJournalACType::Ledger;
                break;
            }
            offsetAccount = retailStoreTenderTypeCardTable.LedgerDimension;
        }
        else
        {
            throw error(strFmt("@MCR40426",enum2str(mcrCustPaymTable.CustPaymType)));
        }

        return [offsetType, offsetAccount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymReference</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the masked credit card number.
    /// </summary>
    /// <returns>
    ///     The masked credit card number.
    /// </returns>
    /// <remarks>
    ///     Returns an identifier for this payment.  The payment reference is
    ///     written to the ledger journal during posting, and is intended to
    ///     identify this payment on a bank deposit slip or for other financial
    ///     records.
    ///     For a credit card payment, the return value is the masked credit card
    ///     number.
    /// </remarks>
    protected PaymReference getPaymReference()
    {
        return mcrCustPaymTable.getCCNumMasked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPaymTypeData</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the payment record has an associated credit card record.
    /// </summary>
    /// <returns>
    ///     true if an associated credit card is present; otherwise, false.
    /// </returns>
    public boolean hasPaymTypeData()
    {
        boolean valid = true;

        if ((!mcrCustPaymTable.PaymInfoRecId
            || !mcrCustPaymTable.PaymInfoTableId)
            && mcrCustPaymTable.IsNonRecurring == NoYes::No)
        {
            valid = checkFailed("@SYS116746");
        }

        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Constructs a new customer payment of type "credit card".
    /// </summary>
    /// <param name="_custPaymTable">
    ///     Customer payment record for which this instance is a wrapper.
    /// </param>
    /// <param name="_allowUserInput">
    ///     Specifies whether user interaction is allowed during operations on this payment.
    /// </param>
    /// <param name="_creditCardAuthTransReversal">
    ///     A boolean that denotes the reversal of the credit card authorization; optional.
    /// </param>
    public void new(MCRCustPaymTable _custPaymTable,
                    boolean _allowUserInput,
                    CreditCardAuthTrans _creditCardAuthTransReversal = null)
    {
        if (_custPaymTable.CustPaymType != MCRCustPaymType::CreditCard)
        {
            throw error(strFmt("@MCR32269", funcName(),
                               enum2str(MCRCustPaymType::CreditCard)));
        }

        super(_custPaymTable, _allowUserInput, _creditCardAuthTransReversal);
        orderParameters = MCROrderParameters::find();
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymentChanged</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a credit card event if the status has changed.
    /// </summary>
    /// <param name="_mcrCustPaymTable_Old">
    ///     The old <c>MCRCustPaymTable</c> record to check for status changes.
    /// </param>
    /// <remarks>
    ///     This method is called when a payment is changed in any way, and is
    ///     only called from the update method of the payment table.
    /// </remarks>
    public void paymentChanged(MCRCustPaymTable _mcrCustPaymTable_Old)
    {
        if (mcrCustPaymTable.Status != _mcrCustPaymTable_Old.Status)
        {
            if (mcrCustPaymTable.Status == MCRCustPaymStatus::Declined)
            {
                this.createCreditCardEvents();
            }
        }

        super(_mcrCustPaymTable_Old);
    }

]]></Source>
			</Method>
			<Method>
				<Name>performBalanceCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Perform balance for the payment method.
    /// </summary>
    /// <returns>The balance.</returns>
    [Hookable(false)]
    protected real performBalanceCheck()
    {
        return 0.0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performAuth</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Performs authorization on this payment, for the unposted amount.
    /// </summary>
    /// <returns>
    ///     The resulting payment status, which is one of the following:
    ///     * MCRCustPaymStatus::Posted.
    ///     * MCRCustPaymStatus::Authorized.
    ///     * MCRCustPaymStatus::Declined.
    /// </returns>
    /// <remarks>
    ///     If the unposted amount is 0.00, then this payment is automatically
    ///     authorized.
    ///     If the unposted amount is positive, then an authorization request is sent
    ///     to the credit card processor.  If online authorization is configured,
    ///     then online authorization is performed.  Otherwise, this payment is
    ///     prepared for batch authorization.
    ///     If the unposted amount is negative, then the payment is submitted to the
    ///     credit card refund authorization queue.
    /// </remarks>
    protected MCRCustPaymStatus performAuth()
    {
        Amount               unpostedAmount;
        CreditCardAuthTrans  creditCardAuthTrans;
        MCROrderParameters   mcrOrderParameters;

        unpostedAmount = mcrCustPaymTable.getUnpostedAmount();

        if (unpostedAmount == 0.0)
        {
            //  If the payment is zero, need to check if there
            //      are pending auth records.
            if (mcrCustPaymTable.Amount == 0)
            {
                creditCardAuthTrans = CreditCardAuthTrans::mcrFindLatest(mcrCustPaymTable.RecId, true);

                if (creditCardAuthTrans)
                {
                    // When <c>RetailSkipDeletingVoidAuthorizationWhenPaymentAmountChangesToZeroFlight</c> flight is enabled.
                    // Skip deleting latest void transaction which is created on canceling sales line.
                    if (RetailSkipDeletingVoidAuthorizationWhenPaymentAmountChangesToZeroFlight::instance().isEnabled())
                    {
                        if (creditCardAuthTrans.ApprovalType != CreditCardOperation::Void)
                        {
                            ttsbegin;
                            creditCardAuthTrans.delete();
                            ttscommit;
                        }
                    }
                    else
                    {
                        ttsbegin;
                        creditCardAuthTrans.delete();
                        ttscommit;
                    }
                }
            }
            else
            {
                ttsbegin;
                mcrCustPaymTable.Status =  this.determineStatus();
                mcrCustPaymTable.update();
                ttscommit;
            }
        }
        // Only execute if there is something to process
        else
        {
            if (unpostedAmount > 0.0)
            {
                mcrCustPaymTable.Status = this.authorizeCharge();
            }
            else if (unpostedAmount < 0.0)
            {
                mcrCustPaymTable.Status = this.authorizeRefund();
            }
            mcrOrderParameters = MCROrderParameters::find();
            ttsbegin;
            if (mcrCustPaymTable.Status == MCRCustPaymStatus::Declined
                && mcrOrderParameters.mcrNumCCAuthRetry > 0
                && mcrCustPaymTable.NumAuthRetry < mcrOrderParameters.mcrNumCCAuthRetry)
            {
                mcrCustPaymTable.NumAuthRetry++;
                mcrCustPaymTable.Status = MCRCustPaymStatus::NotSubmitted;
            }
            if (mcrCustPaymTable.validateWrite())
            {
                mcrCustPaymTable.update();
            }
            ttscommit;
        }
        return mcrCustPaymTable.Status;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates or creates a credit card settlement record to
    ///     settle for the specified amount.
    /// </summary>
    /// <param name="_amount">
    ///     The specified amount for which this method updates or creates a
    ///     settlement record.
    /// </param>
    /// <remarks>
    ///     Invoked to perform posting operations after posting records to the
    ///     ledger journal.
    /// </remarks>
    protected void performPost(Amount _amount)
    {
        boolean successful = false;

        if (_amount > 0.0)
        {
            successful = this.postCharge(_amount);
        }
        else if (_amount < 0.0)
        {
            successful = this.postRefund(abs(_amount));
        }

        mcrCustPaymTable.reread();

        ttsbegin;
        mcrCustPaymTable.Status = this.determineStatus(_amount < 0, true);
        mcrCustPaymTable.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Posts the payment for the amount passed.
    /// </summary>
    /// <param name="_amount">
    ///     The amount of the payment being postd.
    /// </param>
    /// <param name="_isPrepay">
    ///     A boolean determining if they payment is a prepay or not.
    /// </param>
    public void post(Amount _amount, boolean _isPrepay)
    {
        setPrefix(strFmt("@MCR10793",
                         enum2str(mcrCustPaymTable.CustPaymType),
                         num2str(_amount, 1, 2, 1, 2)));

        if (!this.validatePost(_amount, true))
        {
            throw error("@MCR10794");
        }

        ttsbegin;

        // perform any posting operations for specific payment types
        this.performPost(_amount);

        // create ledger journal records
        if (mcrCustPaymTable.isPaymentStatusValidForPosting())
        {
            this.postToLedgerJournal(_amount, mcrCustPaymTable.IsPrepay);
            mcrCustPaymTable.updatePostedAmount(_amount);

            // Find the latest LedgerJournalTrans created for the current call center payment
            LedgerJournalTrans ledgerJournalTrans;
            select firstonly forupdate ledgerJournalTrans
                order by ledgerJournalTrans.RecId desc
                where ledgerJournalTrans.MCRRefPaymID == mcrCustPaymTable.RecId;

            CreditCardAuthTrans creditCardAuthTransForLinks = CreditCardAuthTrans::mcrFindLatest(mcrCustPaymTable.RecId);

            // Create Retail Payment Links
            RetailTransactionPaymentsHelper::createPaymentLinks(
                SalesTable::findRecId(mcrCustPaymTable.RefRecId, true).SalesId,
                mcrCustPaymTable.CardTypeId,
                mcrCustPaymTable.TenderTypeId,
                ledgerJournalTrans.RecId,
                creditCardAuthTransForLinks);

            if (mcrCustCreditTable.CcSettlementRecId == 0)
            {
                mcrCustCreditTable.CcSettlementRecId = creditCardAuthTransForLinks.RecId;
            }
        }

        mcrCustPaymTable.reread();

        CreditCardAuthTrans::setFinalAuthorizationStatusForIncrementalCapture(mcrCustPaymTable);

        ttscommit;

        if (mcrCustPaymTable.getUnpostedAmount() > 0 && mcrCustPaymTable.Status != MCRCustPaymStatus::Declined)
        {
            // Perform the authorization for the remaining amount
            // (Only if the Total posted amount is lower than the Total sales amount)
            boolean wasAuthorizationSuccessful = false;
            MCRCustPaymTotals mcrCustPaymTotals =
                        MCRCustPaymTotals::construct(mcrCustPaymTable.RefTableId,
                                                    mcrCustPaymTable.RefRecId);

            // [FLIGHT-BUG]
            // Bug 784789: Update to Sales order balance that is less than the original Credit card authorization
            //             creates a rogue authorization that never gets removed.
            // The flight below is responsible to revert the changes introduced by this Bug 784789 fix.
            if (!RetailPaymentsRevertOverPaymAuthSupressionFlight::instance().isEnabled())
            {
                if (mcrCustPaymTotals.getTotalPostedPaymAmount() < mcrCustPaymTotals.getTotalSalesAmount())
                {
                    // Authorize the remaining unposted amount of the credit card payment
                    wasAuthorizationSuccessful = CreditCardProcess::mcrDoPreAuth(mcrCustPaymTable);
                }
                else
                {
                    // Supress credit card authorization for overpayment and
                    // adjust the call center payment amount to match the credit card payment posted amount
                    ttsbegin;
                    mcrCustPaymTable.selectForUpdate();
                    mcrCustPaymTable.Amount = mcrCustPaymTable.PostedAmount;
                    mcrCustPaymTable.update();
                    ttscommit;
                    mcrCustPaymTable.reread();

                    // Set authorization as successful, as it is not required for payments that exceed the Sales Total amount.
                    wasAuthorizationSuccessful = true;
                }
            }
            // [END-FLIGHT]
            else
            {
                // Authorize the remaining unposted amount of the credit card payment
                wasAuthorizationSuccessful = CreditCardProcess::mcrDoPreAuth(mcrCustPaymTable);
            }

            boolean isAdvancedDeclinedAuthorizationsFeatureEnabled = FeatureStateProvider::isFeatureEnabled(RetailPaymentsAdvancedDeclinedAuthorizationsFeature::instance());

            // In case the re-authorization fails and the RetailPaymentsAdvancedDeclinedAuthorizationsFeature is enabled,
            // Proceed with setting the sales order to on-hold with underpaid status.
            if (!wasAuthorizationSuccessful && isAdvancedDeclinedAuthorizationsFeatureEnabled)
            {
                // Update the amount field on the original payment line.
                ttsbegin;
                mcrCustPaymTable.selectForUpdate();
                mcrCustPaymTable.Amount = mcrCustPaymTable.PostedAmount;
                mcrCustPaymTable.update();

                // Set the sales order on hold.
                SalesTable salesTable = SalesTable::findRecId(mcrCustPaymTable.RefRecId, true);
                salesTable.MCROrderStopped = NoYes::Yes;
                salesTable.update();

                // Set the sales order in underpaid status.
                MCRSalesTable mcrSalesTable = MCRSalesTable::findSalesId(salesTable.SalesId, true);
                mcrSalesTable.PaymOutOfBalance = MCRPaymOutOfBalance::Underpaid;
                mcrSalesTable.update();
                ttscommit;

                mcrCustPaymTable.reread();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCharge</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Capture a credit card amount on the credit card payment.
    /// </summary>
    /// <param name="_amount">
    ///     The postivie amount to post.
    /// </param>
    /// <returns>
    /// true if the amount has been captured; otherwise, false.
    /// </returns>
    internal boolean postCharge(Amount _amount)
    {
        CreditCardAuthTrans creditCardAuthTrans;
        SalesTable          salesTable;
        boolean             captureSuccess = false;
        boolean             isFoundOrphanCaptureRecord = false;
        creditCardAuthTrans orphanCaptureRecord;
        boolean             isPaymentDuplicationProtectionFeatureEnabled = CreditCardAuthTrans::isPaymentDuplicationProtectionFeatureEnabled();

        if (mcrCustPaymTable.RefTableId == tableNum(SalesTable))
        {
            salesTable = SalesTable::findRecId(mcrCustPaymTable.RefRecId);

            // When a previous invoicing request fails after capturing a payment, its invoiceid gets stamped into
            // the CreditCardAuthTrans capture record, but since the invoice was aborted, this invoiceid is orphan.
            orphanCaptureRecord = CreditCardAuthTrans::findOrphanOrDuplicateCreditCardAuthTransCaptureRecord(
            salesTable.SalesId,
            custInvoiceJour,
            _amount);

            // Recover original orphan capture, Stamping the current invoiceId on it
            if (isPaymentDuplicationProtectionFeatureEnabled)
            {
                if (orphanCaptureRecord)
                {
                    ttsbegin;
                    orphanCaptureRecord.selectForUpdate();
                    orphanCaptureRecord.SalesInvoiceId = salesInvoiceId;
                    orphanCaptureRecord.update();
                    ttscommit;

                    eventSource.EventWritePaymentDuplicationDetectedWarning(
                        funcName(),
                        salesTable.retailSalesTable().RetailChannel,
                        salesTable.SalesId,
                        salesInvoiceId,
                        0);
                }
            }
        }

        if (orphanCaptureRecord)
        {
            // Capture is already processed. Return Success...
            captureSuccess = true;

            eventSource.EventWritePaymentDuplicationFixedWarning(
                    funcName(),
                    salesTable.retailSalesTable().RetailChannel,
                    salesTable.SalesId,
                    salesInvoiceId,
                    mcrCustPaymTable.RecId);
        }
        else
        {
            AmountCur capturedAmount = CreditCardAuthTrans::calculateCapturedAmount(mcrCustPaymTable.RecId);

            if (capturedAmount >= mcrCustPaymTable.Amount && isPaymentDuplicationProtectionFeatureEnabled)
            {
                // Skip capturing any more payments.
                eventSource.EventWritePaymentsMcrPaymentLineCaptureSkipped(mcrCustPaymTable.RecId);
                return captureSuccess;
            }
            else
            {
                if (_amount + capturedAmount > mcrCustPaymTable.Amount && isPaymentDuplicationProtectionFeatureEnabled)
                {
                    // Lower the capture amount
                    _amount = mcrCustPaymTable.Amount - capturedAmount;
                    eventSource.EventWritePaymentsMcrPaymentLineCaptureAmountReduced(mcrCustPaymTable.RecId);
                }

                if (RetailAllowVoidingofStaleAuthorizationsFeatureExposure::isEnabled())
                {
                    creditCardAuthTrans = CreditCardAuthTrans::mcrFindAvailablePreApproval(mcrCustPaymTable.RecId);

                    if(creditCardAuthTrans)
                    {
                        if(creditCardAuthTrans.ApprovalExpired)
                        {
                            // void pre-auth with processor since its stale
                            CreditCardProcess::mcrDoVoidPreAuth(mcrCustPaymTable);
                        
                            // Re-authorize expired authorizations
                            if (RetailIncrementalCaptureFeatureExposure::isEnabled() &&
                                RetailPaymentsReAuthorizeExpiredPreAuthorizationsFlight::instance().isEnabled())
                            {
                                CreditCardProcess::mcrDoPreAuth(mcrCustPaymTable);
                            }
                        }
                    }
                }
                else
                {
                    creditCardAuthTrans = CreditCardAuthTrans::mcrFindValidPreApproval(mcrCustPaymTable.RecId);
                }

                // No capture processed for the invoice. Call processor and capture amount.
                captureSuccess = CreditCardProcess::mcrDoCapture(mcrCustPaymTable,
                                                            salesInvoiceId,
                                                            custInvoiceJour,
                                                            _amount);
                if (!captureSuccess)
                {
                    warning(strFmt("@MCR4410040", mcrCustPaymTable.displayOrderID()));
                }
            }
        }

        return captureSuccess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postRefund</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates or creates a credit card settlement record to settle for a credit
    ///     card refund.
    /// </summary>
    /// <param name="_amount">
    ///     The positvice amount to post.
    /// </param>
    /// <returns>
    ///     true if refund successfully posted; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     Currently, authorizations of refunds are tracked by using
    ///     the status of a settlement record.  It would be preferable to
    ///     use a separate concept (a new table?) for tracking refund
    ///     authorizations.
    /// </remarks>
    private boolean postRefund(Amount _amount)
    {
        boolean   refundSuccess = false;
        const int exitCount = 3;
        int       retryCount = 0;

        try
        {
            boolean isRefundsOverMultipleCaptureEnabled = RetailTransactionPaymentsHelper::isRefundsOverMultipleCapturesEnabled();
            SalesTable salesTable = SalesTable::findRecId(mcrCustPaymTable.RefRecId);
            boolean isPaymentDuplicationProtectionFeatureEnabled = CreditCardAuthTrans::isPaymentDuplicationProtectionFeatureEnabled();
            CreditCard_ExtendedParameters creditCard_ExtendedParameters = CreditCard::getDefaultExtendedParameters();
            CreditCardProcess_ExtendedParameters creditCardProcess_ExtendedParameters = CreditCardProcess::getDefaultExtendedParameters();
            Amount amountToRefund = _amount;

            // For customer order credits, check if a payment record does not exist for a valid refund token.
            // If so, create the record and link the token with the new record.
            if (mcrCustCreditTable.RecId != 0 && CreditCardAuthTrans::isCustomerOrderCreditPaymentRecordLinkRestored(mcrCustCreditTable, salesTable))
            {
                // A missing customer payment for an order credit was found and restored by the system.
                // Please review the customer payments for the sales order %1 to validate the refund amount.
                info(strFmt('@Retail:PaymentRecordForOrderCreditRestored', mcrCustCreditTable.OrigSalesId));
            }

            // Check if duplicate protection is enabled.
            if (isPaymentDuplicationProtectionFeatureEnabled)
            {
                amountToRefund = this.getUnprocessedRefundAmount(amountToRefund, salesTable);
            }

            if (amountToRefund == 0)
            {
                // Refund is already processed. Return Success...
                refundSuccess = true;

                eventSource.EventWritePaymentDuplicationSkippedProcessingInfo(
                                funcName(),
                                salesTable.retailSalesTable().RetailChannel,
                                salesTable.RecId,
                                salesInvoiceId,
                                mcrCustPaymTable.RecId);
            }
            else
            {
                if (isRefundsOverMultipleCaptureEnabled)
                {
                    // Search charges creater or equal the refund charge
                    ttsbegin;

                    while (amountToRefund > 0)
                    {
                        // Set max amount to refund
                        creditCard_ExtendedParameters.parmRecordRefund_RefundAmount(amountToRefund);
                        creditCard_ExtendedParameters.parmRecordRefund_RefundedAmount(0.00);
                        creditCardProcess_ExtendedParameters.parmRecordRefund_SalesInvoiceId(salesInvoiceId);

                        // do refund linked to charge found
                        refundSuccess = CreditCardProcess::mcrDoRefund(mcrCustPaymTable);

                        // Update refund amount and reset refunded amount
                        amountToRefund += creditCard_ExtendedParameters.parmRecordRefund_RefundedAmount();
                        creditCard_ExtendedParameters.parmRecordRefund_RefundedAmount(0.00);
                        creditCardProcess_ExtendedParameters.parmRecordRefund_SalesInvoiceId('');

                        // If No refund charge is executed
                        if (!refundSuccess)
                        {
                            break;
                        }
                    }
                    ttscommit;
                }
                else
                {
                    // Set amount to refund
                    creditCard_ExtendedParameters.parmRecordRefund_RefundAmount(amountToRefund);
                    creditCardProcess_ExtendedParameters.parmRecordRefund_SalesInvoiceId(salesInvoiceId);

                    ttsbegin;
                    // do refund linked to charge found
                    refundSuccess = CreditCardProcess::mcrDoRefund(mcrCustPaymTable);
                    ttscommit;

                    // Update refund amount and reset refunded amount
                    creditCard_ExtendedParameters.parmRecordRefund_RefundAmount(0.00);
                    creditCardProcess_ExtendedParameters.parmRecordRefund_SalesInvoiceId('');
                }
            }
        }
        catch (Exception::Deadlock)
        {
            if (retryCount >= exitCount)
            {
                throw;
            }
            else
            {
                // Sleep 100mS 1000mS and 10000mS
                sleep(100 * power(10.0, retryCount));
                retryCount++;
                retry;
            }
        }

        return refundSuccess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnprocessedRefundAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method will find all refunds that match the headers unique credit card token and does not exceed the refund total amount.
    /// The refunds will have their SalesInvoiceId unpdated with the current SalesInvoiceId and return any outstanding amount.
    /// </summary>
    /// <param name = "_amountToRefund">The total amount to be refunded.</param>
    /// <param name = "_salesTable">The sales table the refund is applied to.</param>
    /// <returns>The remaining amount to be refunded.</returns>
    private Amount getUnprocessedRefundAmount(Amount _amountToRefund, SalesTable _salesTable)
    {
        CreditCardAuthTrans successfulRefundRecord;
        CustInvoiceJour notFoundCustInvoiceJour;

        Amount amountToRefund = _amountToRefund;

        // Get all approved refund credit card auth trans for this sales order or MCRCustPaymTable and reference that don't have a custInvoiceJour
        while select forupdate SalesId, SalesInvoiceId, ApprovalAmountCur, UniqueCardId from successfulRefundRecord
                where successfulRefundRecord.SalesId == _salesTable.SalesId &&
                    successfulRefundRecord.ApprovalType == CreditCardOperation::Refund &&
                    successfulRefundRecord.RefundStatus == CreditCardRefundStatus::Processed &&
                    successfulRefundRecord.ProcessorStatus == CreditCardProcessorStatus::Approved &&
                    successfulRefundRecord.SalesInvoiceId != '' &&
                    // Switch between MCR reference and A/R just having sales order reference
                    ((successfulRefundRecord.MCRPaymRecId != 0 && successfulRefundRecord.MCRPaymRecId == mcrCustPaymTable.RecId) ||
                        successfulRefundRecord.MCRPaymRecId == 0)
                    // Failed invoicing will rollback journal
                    notexists join InvoiceId from notFoundCustInvoiceJour
                        where successfulRefundRecord.SalesId == notFoundCustInvoiceJour.SalesId
                            && successfulRefundRecord.SalesInvoiceId == notFoundCustInvoiceJour.InvoiceId
        {
            // Record details of record to be migrated to new sales invoice id, some setting sales invoice id will not change
            eventSource.EventWritePaymentDuplicationDetectedWarning(
                                funcName(),
                                _salesTable.retailSalesTable().RetailChannel,
                                _salesTable.SalesId,
                                successfulRefundRecord.SalesInvoiceId,
                                mcrCustPaymTable.RecId);

            // Make sure the credit card tokens match
            CreditCardCust tokenFromRefundTrans = CreditCardCust::findByUniqueCardId(successfulRefundRecord.UniqueCardId);
            CreditCardCust tokenFromHeaderRefund = CreditCardCust::find(_salesTable.mcrIsCallCenter() ? mcrCustPaymTable.PaymInfoRecId : _salesTable.CreditCardCustRefId);

            // Only use the same credit card assigned to (sales header or MCRCustPaymTable) and don't over refund
            if (tokenFromRefundTrans.RecId == tokenFromHeaderRefund.RecId)
            {
                if (0 <= (amountToRefund + successfulRefundRecord.ApprovalAmountCur))
                {
                    // For every record found reduce the required amount by the negative approved transaction amount
                    amountToRefund += successfulRefundRecord.ApprovalAmountCur;

                    // Migrate to new sales invoice id.
                    ttsbegin;
                    successfulRefundRecord.SalesInvoiceId = salesInvoiceId;
                    successfulRefundRecord.update();
                    ttscommit;

                    // Record migrated record.
                    eventSource.EventWritePaymentDuplicationFixedWarning(
                                funcName(),
                                _salesTable.retailSalesTable().RetailChannel,
                                _salesTable.SalesId,
                                salesInvoiceId,
                                mcrCustPaymTable.RecId);
                }
                else
                {
                    // Record skipped due to exceeds refund amount.
                    eventSource.EventWritePaymentDuplicationSkipExceedsAmountWarning(
                                funcName(),
                                _salesTable.retailSalesTable().RetailChannel,
                                _salesTable.RecId,
                                salesInvoiceId,
                                mcrCustPaymTable.RecId);
                }
            }
            else
            {
                // Record skipped due to credit card tokens not matching.
                eventSource.EventWritePaymentDuplicationSkipTokenMismatchWarning(
                                funcName(),
                                _salesTable.retailSalesTable().RetailChannel,
                                _salesTable.RecId,
                                salesInvoiceId,
                                mcrCustPaymTable.RecId);
            }
        }

        return amountToRefund;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToLedgerJournal</Name>
				<Source><![CDATA[
    public void postToLedgerJournal(Amount _amount, boolean _isPrepay)
    {
        // If a sales order has been canceled and it is a prepay,
        // check if the amount has not been settled in such a case do
        // not post the unposted amount.
        if (_isPrepay
            && mcrCustPaymTable.Amount == 0)
        {
            if (CreditCardAuthTrans::mcrFindCharge(mcrCustPaymTable.RecId))
            {
                super(_amount, _isPrepay);
            }
            else
            {
                return;
            }
        }
        // Posting is handled by the journal itself
        if (mcrCustPaymTable.RefTableId == tableNum(LedgerJournalTrans))
        {
            return;
        }
        super(_amount, _isPrepay);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAuthorize</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates this payment for authorization.
    /// </summary>
    /// <param name="_showErrors">
    ///     A boolean that determines whether to write errors to an infolog; optional.
    /// </param>
    /// <returns>
    ///     true if all data for this payment is valid and the payment should
    ///     be allowed to be submitted for authorization; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     If the return value is false, then this payment should not be submitted
    ///     for authorization.
    /// </remarks>
    boolean validateAuthorize(boolean _showErrors = true)
    {
        boolean isValid = true;

        // credit card data is required
        if (!this.hasPaymTypeData())
        {
            isValid = false;

            if (_showErrors)
            {
                error("@MCR10658");
            }
        }
        if (!isValid)
        {
            ttsbegin;
            mcrCustPaymTable.selectForUpdate(true);
            mcrCustPaymTable.reread();
            mcrCustPaymTable.Status = MCRCustPaymStatus::Declined;
            mcrCustPaymTable.update();
            ttscommit;
        }
        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePost</Name>
				<Source><![CDATA[
    public boolean validatePost(Amount _amount, boolean _showErrors = true)
    {
        boolean isValid = true;

        Amount unpostedAmount = mcrCustPaymTable.getUnpostedAmount();

        if (mcrCustPaymTable.IsPrepay)
        {
            isValid = super(_amount, _showErrors);
        }
        else
        {
            // this payment must be Posted/Paid
            if (mcrCustPaymTable.Status == MCRCustPaymStatus::NotSubmitted)
            {
                isValid = false;

                if (_showErrors)
                {
                    error(strFmt("@MCR30348", enum2str(mcrCustPaymTable.Status)));
                }
            }

            // must be a non-zero amount
            if (_amount == 0.0)
            {
                isValid = false;

                if (_showErrors)
                {
                    error(strFmt("@MCR10796", num2str(_amount, 1, 2, -1, -1)));
                }
            }

            // the amount must have the same sign as the unposted payment amount
            if (isValid && sign(_amount) != sign(unpostedAmount))
            {
                isValid = false;

                if (_showErrors)
                {
                    error(strFmt("@MCR10796", num2str(_amount, 1, 2, -1, -1)));
                }
            }

            // the amount may not be greater than the unposted payment amount
            if (isValid && abs(_amount) > abs(unpostedAmount))
            {
                isValid = false;

                if (_showErrors)
                {
                    error(strFmt("@MCR10796", num2str(_amount, 1, 2, -1, -1)));
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates this payment for an insert or update for credit card
    ///         payments.
    /// </summary>
    /// <param name="_showErrors">
    ///     A boolean determing whether to write errors to the infolog; optional.
    /// </param>
    /// <param name="_validateAccountSetup">
    ///     A boolean determing whether to validate if an account is
    ///     setup on the <c>RetailStoreTenderTypeTable</c>; optional.
    /// </param>
    /// <returns>
    ///     true if all data for this payment is valid and should be allowed
    ///     to be saved to the database; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     If the return value is false, then this payment should not be saved to
    ///     the database.
    /// </remarks>
    public boolean validateWrite(boolean _showErrors = true,
                                 boolean _validateAccountSetup = true)
    {
        boolean isValid;
        RetailStoreTenderTypeCardTable retailStoreTenderTypeCardTable;
        RetailTenderTypeCardTable      retailTenderTypeCardTable;

        // Cards use account on the <c>RetailStoreTenderTypeCardTable</c>, so skip account
        //  validation in parent class
        isValid = super(_showErrors, false);

        retailStoreTenderTypeCardTable = RetailStoreTenderTypeCardTable::find(mcrCustPaymTable.Channel,
                                                                              mcrCustPaymTable.TenderTypeId,
                                                                              mcrCustPaymTable.CardTypeId);

        if (retailStoreTenderTypeCardTable)
        {
            retailTenderTypeCardTable = RetailTenderTypeCardTable::find(retailStoreTenderTypeCardTable.CardTypeId);
            if (this.isCorporateAndInternationalCreditCardTypes(retailTenderTypeCardTable))
            {
                isValid = false;
                if (_showErrors)
                {
                    error(strFmt("@MCR40420",
                            retailTenderTypeCardTable.CardTypes,
                            RetailChannelTable::findByOperatingUnitId(mcrCustPaymTable.Channel).ChannelType));
                }
            }
            // payment account is required if parameter is true
            if (this.isPaymentAccountRequired(retailStoreTenderTypeCardTable, _validateAccountSetup))
            {
                isValid = false;
                if (_showErrors)
                {
                    error(strFmt("@MCR10845", mcrCustPaymTable.TenderTypeId));
                }
            }
        }
        else
        {
            isValid = false;
            if (_showErrors)
            {
                error(strFmt("@MCR40422",
                        mcrCustPaymTable.CardTypeId,
                        RetailChannelTable::findByRecId(mcrCustPaymTable.Channel).name()));
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCorporateAndInternationalCreditCardTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the <c>CardTypes</c> field of <c>RetailTenderTypeCardTable</c> is not one of supported types.
    /// </summary>
    /// <param name = "_retailTenderTypeCardTable"> The record buffer of <c>RetailTenderTypeCardTable</c> table.</param>
    /// <returns>True if <c>CardTypes</c> field of <c>RetailTenderTypeCardTable</c> is not equal to Corporate, InternationalKredit or Wallet; otherwise, false.</returns>
    protected boolean isCorporateAndInternationalCreditCardTypes(RetailTenderTypeCardTable _retailTenderTypeCardTable)
    {
        return (_retailTenderTypeCardTable.CardTypes != RetailCardTypesBase::CorporateCard
                && _retailTenderTypeCardTable.CardTypes != RetailCardTypesBase::InternationalKreditcard
                && _retailTenderTypeCardTable.cardTypes != RetailCardTypesBase::Wallet
                && _retailTenderTypeCardTable.cardTypes != RetailCardTypesBase::InternationalDebitcard);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPaymentAccountRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the payment account is not required.
    /// </summary>
    /// <param name = "_retailStoreTenderTypeCardTable">The record buffer of <c>RetailStoreTenderTypeCardTable</c> table.</param>
    /// <param name = "_validateAccountSetup"> A boolean determing whether to validate if an account is setup on the <c>RetailStoreTenderTypeCardTable</c></param>
    /// <returns>True if payment account is not required; otherwise, false.</returns>
    protected boolean isPaymentAccountRequired(RetailStoreTenderTypeCardTable _retailStoreTenderTypeCardTable, boolean _validateAccountSetup)
    {
        return (_validateAccountSetup
                && _retailStoreTenderTypeCardTable.LedgerDimension == 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateChargePaymStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates what the status of this payment should be based upon the
    ///     status of the active credit card authorization record.
    /// </summary>
    /// <param name="_creditCardAuthTrans">
    ///     The <c>CreditCardAuthTrans</c> record from which the status is updated.
    /// </param>
    /// <param name="_mcrCustPaymTable">
    ///     The <c>MCRCustPaymTable</c> record being updated; optional.
    /// </param>
    /// <returns>
    ///     The updated status of the <c>MCRCustPaymTable</c> record.
    /// </returns>
    /// <remarks>
    ///     If there is no active credit card authorization record for this
    ///     payment, then the return value is MCRCustPaymStatus::NotSubmitted.
    ///     This method is intended to be called only for credit card charges
    ///     (positive unposted amount).
    /// </remarks>
    public static MCRCustPaymStatus calculateChargePaymStatus(CreditCardAuthTrans _creditCardAuthTrans,
                                                        MCRCustPaymTable _mcrCustPaymTable = null)
    {
        MCRCustPaymStatus status;

        if (!_mcrCustPaymTable)
        {
            _mcrCustPaymTable = MCRCustPaymTable::findByRecID(_creditCardAuthTrans.mcrPaymRecId);
        }

        if (_creditCardAuthTrans)
        {
            switch (_creditCardAuthTrans.ProcessorStatus)
            {
                case CreditCardProcessorStatus::Approved:
                    // Moving reversed to an authorized status
                    // Else reversed records won't get picked up by picking
                    if (_mcrCustPaymTable.IsPrepay)
                    {
                        status = MCRCustPaymStatus::Posted;
                    }
                    else
                    {
                        status = _creditCardAuthTrans.ApprovalVoid ? MCRCustPaymStatus::NotSubmitted : MCRCustPaymStatus::Authorized;
                    }
                    break;
                case CreditCardProcessorStatus::TimedOut:
                    if (_creditCardAuthTrans.MCRTrackingId != '')
                    {
                        status = MCRCustPaymStatus::NotSubmitted;
                    }
                    else
                    {
                        status = MCRCustPaymStatus::Declined;
                    }
                    break;
                // If it's not authorized, treat it as declined
                default:
                    status = MCRCustPaymStatus::Declined;
            }
        }
        else
        {
            status = MCRCustPaymStatus::NotSubmitted;
        }

        return status;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wrapReRead</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allow reread to be mockable from unit test
    /// </summary>
    /// <param name = "_mcrCustPaymTable">The <c>MCRCustPaymTable</c> record being reread.</param>
    protected void wrapReRead(MCRCustPaymTable _mcrCustPaymTable)
    {
        _mcrCustPaymTable.reread();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>