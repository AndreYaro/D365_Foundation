<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BookDataCalc_Purch_Process_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
final class BookDataCalc_Purch_Process_RU extends BookDataCalc_Purch_RU implements BatchRetryable
{
    FactureJour_RU                          factureJour;
    QueryRun                                queryRun;

    DialogField                             fieldOperationRecId;
    PurchBookVATProcessParametersRecId_RU   operationRecId;

    Integer                                 numOfMonths;
    TmpRestoredVATLogTrans_RU               tmpRestoredVATLogTrans;
    TransDate                               closingDate;

    protected const str dsVendTransInvoiceName = 'dsVendTransInvoice';
    protected const str dsFactureJourName = 'dsFactureJour';
    protected const str dsVendInvoiceJourName = 'dsVendInvoiceJour';
    protected const str dsVendSettlementName = 'dsVendSettlement';

    protected const str dsCustTransPaymentName = 'dsCustTransPayment';
    protected const str dsCustSettlementName = 'dsCustSettlement';

    protected const str OR = '||';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>begin</Name>
				<Source><![CDATA[
    protected void begin()
    {
        TransDate startDate;
        TransDate endDate;
        const int MonthsInYear = 12;

        // there is no super() call

        [startDate, endDate] = BookDataCalc_RU::datePeriodBook(toDate);

        numOfMonths = MonthsInYear * (year(endDate) - year(startDate)) + mthOfYr(endDate) - mthOfYr(startDate) + 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLineData</Name>
				<Source><![CDATA[
    protected void calcLineData()
    {
        super();

        if (factureJour.existsRDeferralsStorno(fromDate, toDate))
        {
            bookTransCalc = this.initBookTransCalcClass(true);

            if (bookTransCalc)
            {
                bookTransCalc.calc();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    public boolean canGoBatch()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyFactureJourRanges</Name>
				<Source><![CDATA[
    protected void copyFactureJourRanges(Query _queryDestination)
    {
        QueryBuildDataSource    dsDestination, dsSource;
        QueryBuildRange         rangeDestination, rangeSource;
        QueryFilter             queryFilter;
        int                     cx;

        FieldName               fieldName;

        dsSource      = queryRun.query().dataSourceTable(tableNum(FactureJour_RU));
        dsDestination = _queryDestination.dataSourceTable(tableNum(FactureJour_RU));

        for (cx = 1; cx <= dsSource.rangeCount(); cx++)
        {
            rangeSource = dsSource.range(cx);

            rangeDestination = dsDestination.addRange(rangeSource.field());
            rangeDestination.value(rangeSource.value());
        }

        for (cx = 1; cx <= queryRun.query().queryFilterCount(); cx++)
        {
            queryFilter = queryRun.query().queryFilter(cx);

            fieldName = queryFilter.field();

            rangeDestination = dsDestination.addRange(fieldName2id(tableNum(FactureJour_RU), queryFilter.field()));
            rangeDestination.value(queryFilter.value());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    public Object dialog()
    {
        Dialog      dialog;

        closingDate = PurchBookTable_RU::getLastClosedBook().ClosingDate;

        if (closingDate)
        {
            [fromDate, toDate] = BookDataCalc_RU::datePeriodBook(closingDate + 1);
        }

        dialog = super();

        fieldOperationRecId = dialog.addFieldValue(extendedTypeStr(PurchBookVATProcessParametersRecId_RU), operationRecId);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>end</Name>
				<Source><![CDATA[
    protected void end()
    {
        // there is no super() call
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchNextRecord</Name>
				<Source><![CDATA[
    protected boolean fetchNextRecord()
    {
        return recordSortedList.next(factureJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        boolean ret = super();

        if (ret)
        {
            operationRecId = fieldOperationRecId.value();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInfologPrefix</Name>
				<Source><![CDATA[
    protected InfologText getInfologPrefix()
    {
        return BookDataCalc_Purch_Process_RU::description();
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    public boolean init()
    {
        TmpPurchBookVATProcessLogTrans_RU logTrans;

        processMode = PurchBookVATProcessCancelType_RU::Process;

        this.initRecordSortedList();

        salesPurchBookData = logTrans;

        GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00021, funcName());

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAmountAdjust</Name>
				<Source><![CDATA[
    private void initAmountAdjust()
    {
        FactureJour_RU                      fJour;
        PurchBookVATProcessLogTrans_RU      purchLogTrans;
        PurchBookVATProcessLogTransOper_RU  purchLogTransOper;

        while select fJour
            where fJour.FactureType == FactureType_RU::ExchAdj &&
                  fJour.Module      == FactureModule_RU::Vend  &&
                  fJour.AmountAdjustment                       &&
                 (fJour.FactureDate <= toDate                  ||
                 (fJour.ReverseDate                            &&
                  fJour.ReverseDate <= toDate))
        exists join purchLogTrans
            where purchLogTrans.InvoiceRecIdRef == fJour.ExchAdjInvoiceRecId           &&
                 (purchLogTrans.TransType       == SalesPurchBookTransType_RU::Invoice ||
                  purchLogTrans.TransType       == SalesPurchBookTransType_RU::CreditNote)
        exists join purchLogTransOper
            where purchLogTransOper.RefRecId         == purchLogTrans.RecId &&
                  purchLogTransOper.CanceledRefRecId == 0                   &&
                  purchLogTransOper.TransDate        >= fromDate            &&
                  purchLogTransOper.TransDate        <= toDate
        {
            if ( ! recordSortedList.find(fJour))
            {
                recordSortedList.ins(fJour);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBookTransCalcClass</Name>
				<Source><![CDATA[
    protected BookTransCalc_RU initBookTransCalcClass(boolean _existRDeferralsStrono = false)
    {
        progress.setText(strFmt("@GLS111360", factureJour.CustVendInvoiceAccount, factureJour.FactureExternalId));

        return BookTransCalc_Purch_RU::newTransCalc(factureJour,
                                                    fromDate,
                                                    toDate,
                                                    salesPurchBookData,
                                                    tmpProcessLogTransOper,
                                                    tmpRestoredVATLogTrans,
                                                    operationRecId,
                                                    false,
                                                    checkTransForProcess,
                                                    false,
                                                    numOfMonths,
                                                    closingDate ? closingDate : PurchBookTable_RU::getLastClosedBook().ClosingDate,
                                                    _existRDeferralsStrono,
                                                    fullCheck);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOnDelivery</Name>
				<Source><![CDATA[
    private void initOnDelivery()
    {
        QueryBuildDataSource    dsFactureJour;
        Query                   query;
        container               factureModuleValue;
        boolean                 factureModuleInRange;

        str factureDateValue = 
        '((' + fieldstr(FactureJour_RU, FactureReportDate) + '>= \%1)  && ('  +
               fieldstr(FactureJour_RU, FactureReportDate) + '<= \%2)) || ((' +
               fieldstr(FactureJour_RU, ReverseDate)       + ') && ('         +
               fieldstr(FactureJour_RU, ReverseDate)       + '>= \%1)  && ('  +
               fieldstr(FactureJour_RU, ReverseDate)       + '<= \%2))';

        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Module), FactureModule_RU::Vend))
        {
            factureModuleInRange = true;
            factureModuleValue += FactureModule_RU::Vend;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Module), FactureModule_RU::TaxCorrectionPurch))
        {
            factureModuleInRange = true;
            factureModuleValue += FactureModule_RU::TaxCorrectionPurch;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Module), FactureModule_RU::TaxCorrectionPurch_Cust))
        {
            factureModuleInRange = true;
            factureModuleValue += FactureModule_RU::TaxCorrectionPurch_Cust;
        }

        if (factureModuleInRange)
        {
            query = new Query();

            dsFactureJour = query.addDataSource(tableNum(FactureJour_RU), dsFactureJourName);
            this.copyFactureJourRanges(query);

            findOrCreateRange_W(dsFactureJour,
                                fieldNum(FactureJour_RU, Module),
                                con2Str(factureModuleValue));

            findOrCreateRange_W(dsFactureJour,
                                fieldNum(FactureJour_RU, FactureDate),
                                strFmt(factureDateValue, date2StrXpp(fromDate), date2StrXpp(toDate)));

            findOrCreateRange_W(dsFactureJour,
                                fieldNum(FactureJour_RU, FactureType),
                                strFmt('((%1 != %2) && (%1 != %3))',
                                fieldStr(FactureJour_RU, FactureType),
                                enum2int(FactureType_RU::GTD),
                                enum2int(FactureType_RU::CustomCorrection)));

            findOrCreateRange_W(dsFactureJour,
                                fieldNum(FactureJour_RU, InventProfileType),
                                con2Str([InventProfileType_RU::General, InventProfileType_RU::NotSpecified]));

            this.insertIntoRecordsetList(new QueryRun(query));
        }

        this.insertIntoRecordsetList(this.qrBlockedFactures());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOnPayment</Name>
				<Source><![CDATA[
    private void initOnPayment()
    {
        NoYes amountDiffInBook = VendParameters::find().AmountDiffBookCorrection_RU;

        if (RestoredVATLogTable_RU::checkApproved(toDate) && ! checkTransForProcess)
        {
            this.insertIntoRecordsetList(this.qrRestoredVATFactures());
        }
        else
        {
            if (processAmountAdj && amountDiffInBook)
            {
                this.initAmountAdjust();
                return;
            }

            this.insertIntoRecordsetListEx(this.qrSettlementDependent());
            this.insertIntoRecordsetList(this.qrSettlementInDependent());
            this.insertIntoRecordsetList(this.qrBlockedFactures());
            this.insertIntoRecordsetList(this.qrOldPrepaymSettled());

            if (amountDiffInBook)
            {
                this.insertIntoRecordsetList(this.qrAmountAdjFactures());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    public void initParmDefault()
    {
        Query                query;
        QueryBuildDataSource dsFactureJour;
        ;

        super();

        if (! queryRun)
        {
            query  = new Query();
            dsFactureJour = query.addDataSource(tableNum(FactureJour_RU));
            dsFactureJour.addRange(fieldNum(FactureJour_RU, FactureDate)).status(RangeStatus::Hidden);
            queryRun = new QueryRun(query);
        }

        operationRecId = PurchBookVATProcessParameters_RU::defaultParms().RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRecordSortedList</Name>
				<Source><![CDATA[
    protected void initRecordSortedList()
    {
        recordSortedList = new RecordSortedList(tableNum(FactureJour_RU));
        recordSortedList.sortOrder(fieldNum(FactureJour_RU, RecId));

        this.initOnPayment();

        if ((fromDate >= #TransitionStartDate || toDate >= #TransitionStartDate) && ! processAmountAdj)
        {
            this.initOnDelivery();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTmpRestoredTransExp</Name>
				<Source><![CDATA[
    private TmpRestoredVATLogTrans_RU initTmpRestoredTransExp()
    {
        RestoredVATLogTable_RU          restoredVATLogTable;
        RestoredVATLogTrans_RU          restoredVATLogTrans;
        RestoredVATLogTransOper_RU      restoredVATLogTransOper;
        RestoredVATLogTransOperLink_RU  restoredVATLogTransOperLink;
        RestoredVATSalesTaxTrans_RU     restoredVATSalesTaxTrans;
        RestoredVATSalesTaxTrans_RU     vatSalesTaxTrans;
        CustInvoiceTrans                custInvoiceTrans;
        CustInvoiceTrans                custInvoiceTransExists;
        RestoredVATSalesTaxTrans_RU     vatSalesTaxTransExists;
        FactureJour_RU                  factureJourExport;
        FactureJour_RU                  factureJourExp;
        VendTrans                       vendTrans;
        VendInvoiceJour                 vendInvoiceJour;
        Factor                          factor, ratio;
        container                       key;
        AmountMST                       amountLiableToVAT;
        TaxAmountVAT_RU                 taxAmount, totalTaxAmount;
        BookStructSmallVATAmounts_RU    restoredAmounts;
        MapEnumerator                   mapEnumerator;
        Map                             mapRestoredAmounts;
        Map                             mapFactureFactor;
        Map                             mapMapPeriodFactor = new Map(Types::Date, Types::Class);

        void addRestoredAmounts()
        {
            if (factor && taxAmount)
            {
                totalTaxAmount = restoredVATLogTransOper.TaxAmount          +
                                 restoredVATLogTransOper.TaxAmountNotLiable +
                                 restoredVATLogTransOper.TaxAmountWrittenOff;

                ratio = taxAmount / totalTaxAmount;

                restoredAmounts.addAmounts(CurrencyExchangeHelper::amount(factor * ratio * amountLiableToVAT) +
                                           CurrencyExchangeHelper::amount(factor * taxAmount),
                                           CurrencyExchangeHelper::amount(factor * ratio * amountLiableToVAT),
                                           CurrencyExchangeHelper::amount(factor * taxAmount),
                                           factor * restoredVATLogTransOper.QtySettled);

                mapRestoredAmounts.insert(key, restoredAmounts.pack());
            }
        }

        void updateRestoredAmounts()
        {
            if (tmpRestoredVATLogTrans && mapRestoredAmounts)
            {
                tmpRestoredVATLogTrans.RestoredAmounts = mapRestoredAmounts.pack();
                tmpRestoredVATLogTrans.update();
            }
        }

        void calcRestoredAmounts()
        {
            if (tmpRestoredVATLogTrans.FactureId    != restoredVATLogTrans.FactureId     ||
                tmpRestoredVATLogTrans.Module       != restoredVATLogTrans.FactureModule ||
                tmpRestoredVATLogTrans.InvoiceRecId != restoredVATLogTrans.InvoiceRecId)
            {
                updateRestoredAmounts();

                select firstonly forupdate tmpRestoredVATLogTrans
                    where tmpRestoredVATLogTrans.FactureId    == restoredVATLogTrans.FactureId     &&
                          tmpRestoredVATLogTrans.Module       == restoredVATLogTrans.FactureModule &&
                          tmpRestoredVATLogTrans.InvoiceRecId == restoredVATLogTrans.InvoiceRecId;

                vendTrans = VendTrans::find(restoredVATLogTrans.InvoiceRecId);
                vendInvoiceJour =
                    restoredVATLogTrans.factureType() == FactureType_RU::Invoice ?
                    VendInvoiceJour::findFromVendTrans(vendTrans.Invoice, vendTrans.TransDate, vendTrans.AccountNum, false, vendTrans.Voucher) :
                    null;

                if (tmpRestoredVATLogTrans)
                {
                    mapRestoredAmounts = Map::create(tmpRestoredVATLogTrans.RestoredAmounts);
                }
                else
                {
                    mapRestoredAmounts = new Map(Types::Container, Types::Container);

                    tmpRestoredVATLogTrans.FactureId    = restoredVATLogTrans.FactureId;
                    tmpRestoredVATLogTrans.Module       = restoredVATLogTrans.FactureModule;
                    tmpRestoredVATLogTrans.InvoiceRecId = restoredVATLogTrans.InvoiceRecId;
                    tmpRestoredVATLogTrans.insert();
                }
            }

            amountLiableToVAT = restoredVATLogTransOper.AmountLiableToVAT;
            taxAmount         = restoredVATLogTransOper.TaxAmount;

            if (restoredVATLogTransOper.LineType == RestoredVATLineType_RU::Direct)
            {
                factor = restoredVATLogTransOperLink.SettledQty < restoredVATLogTransOper.QtySettled ?
                         restoredVATLogTransOperLink.SettledQty / restoredVATLogTransOper.QtySettled :
                         1;

                taxAmount += restoredVATLogTransOper.TaxAmountNotLiable;

                key = [restoredVATLogTransOper.TaxCode,
                       restoredVATLogTransOper.DefaultDimension,
                       restoredVATLogTransOper.InventTransId,
                       vendInvoiceJour.InternalInvoiceId,
                       vendInvoiceJour.InvoiceId,
                       vendInvoiceJour.NumberSequenceGroup,
                       factureJourExp.FactureId];

                restoredAmounts = mapRestoredAmounts.exists(key)                                        ?
                                  BookStructSmallVATAmounts_RU::create(mapRestoredAmounts.lookup(key))  :
                                  new BookStructSmallVATAmounts_RU();

                addRestoredAmounts();
            }
            else
            {
                if (! mapMapPeriodFactor.exists(restoredVATLogTrans.TransDate))
                {
                    mapFactureFactor = new Map(Types::String, Types::Real);

                    while select * from vatSalesTaxTrans
                        where  vatSalesTaxTrans.TransDate == restoredVATLogTrans.TransDate
                    join factureJourExp
                        where  factureJourExp.FactureId        == vatSalesTaxTrans.FactureId     &&
                               factureJourExp.Module           == vatSalesTaxTrans.FactureModule &&
                             ((factureJourExp.StatusChangeDate >= fromDate                                                 &&
                               factureJourExp.StatusChangeDate <= toDate                                                   &&
                               (factureJourExp.ProcessingType  == SalesBookFactureProcessingType_RU::VATZero               ||
                                factureJourExp.ProcessingType  == SalesBookFactureProcessingType_RU::VATZeroCorrection     ||
                                factureJourExp.ProcessingType  == SalesBookFactureProcessingType_RU::OverdueConfirmation)) ||
                              (! factureJourExp.ConfirmationDate                                                           &&
                               (factureJourExp.ProcessingType  == SalesBookFactureProcessingType_RU::VATStandard           ||
                                factureJourExp.ProcessingType  == SalesBookFactureProcessingType_RU::VATStandardCorrection)))
                    {
                        if ((factureJourExp.ProcessingType  == SalesBookFactureProcessingType_RU::VATStandard            ||
                             factureJourExp.ProcessingType  == SalesBookFactureProcessingType_RU::VATStandardCorrection) &&
                            (factureJourExp.expirationDate() < fromDate                                                  ||
                             factureJourExp.expirationDate() > toDate))
                        {
                            continue;
                        }

                        factor = mapFactureFactor.exists(vatSalesTaxTrans.FactureId)           ?
                                 any2real(mapFactureFactor.lookup(vatSalesTaxTrans.FactureId)) :
                                 0;

                        mapFactureFactor.insert(vatSalesTaxTrans.FactureId, factor + vatSalesTaxTrans.Factor);
                    }

                    mapMapPeriodFactor.insert(restoredVATLogTrans.TransDate, mapFactureFactor);
                }

                mapFactureFactor = mapMapPeriodFactor.lookup(restoredVATLogTrans.TransDate);
                mapEnumerator = mapFactureFactor.getEnumerator();

                while (mapEnumerator.moveNext())
                {
                    key = [restoredVATLogTransOper.TaxCode,
                           restoredVATLogTransOper.DefaultDimension,
                           restoredVATLogTransOper.InventTransId,
                           vendInvoiceJour.InternalInvoiceId,
                           vendInvoiceJour.InvoiceId,
                           vendInvoiceJour.NumberSequenceGroup,
                           mapEnumerator.currentKey()];

                    factor = mapEnumerator.currentValue();

                    restoredAmounts = mapRestoredAmounts.exists(key)                                        ?
                                      BookStructSmallVATAmounts_RU::create(mapRestoredAmounts.lookup(key))  :
                                      new BookStructSmallVATAmounts_RU();

                    addRestoredAmounts();
                }
            }
        }

        ttsBegin;

        while select restoredVATLogTrans
        join restoredVATLogTransOper
            where  restoredVATLogTransOper.TransDate            == restoredVATLogTrans.TransDate                &&
                   restoredVATLogTransOper.ProcessLogTransRecId == restoredVATLogTrans.ProcessLogTransRecId     &&
                   restoredVATLogTransOper.LineType             == RestoredVATLineType_RU::Direct               &&
                   restoredVATLogTransOper.Include                                                              &&
                  !restoredVATLogTransOper.Asset
        join restoredVATLogTransOperLink
            where  restoredVATLogTransOperLink.TransDate            == restoredVATLogTransOper.TransDate        &&
                   restoredVATLogTransOperLink.TaxCode              == restoredVATLogTransOper.TaxCode          &&
                   restoredVATLogTransOperLink.DefaultDimension     == restoredVATLogTransOper.DefaultDimension &&
                   restoredVATLogTransOperLink.InventTransId        == restoredVATLogTransOper.InventTransId    &&
                   restoredVATLogTransOperLink.ProcessLogTransRecId == restoredVATLogTransOper.ProcessLogTransRecId
        exists join custInvoiceTrans
            where  custInvoiceTrans.RecId             == restoredVATLogTransOperLink.CustInvoiceTransRecId
        exists join restoredVATSalesTaxTrans
            where  custInvoiceTrans.InventTransId     == restoredVATSalesTaxTrans.InventTransId
        exists join factureJourExport
            where  factureJourExport.FactureId        == restoredVATSalesTaxTrans.FactureId     &&
                   factureJourExport.Module           == restoredVATSalesTaxTrans.FactureModule &&
                 ((factureJourExport.StatusChangeDate >= fromDate                                                 &&
                   factureJourExport.StatusChangeDate <= toDate                                                   &&
                   (factureJourExport.ProcessingType  == SalesBookFactureProcessingType_RU::VATZero               ||
                    factureJourExport.ProcessingType  == SalesBookFactureProcessingType_RU::VATZeroCorrection     ||
                    factureJourExport.ProcessingType  == SalesBookFactureProcessingType_RU::OverdueConfirmation)) ||
                  (! factureJourExport.ConfirmationDate                                                           &&
                   (factureJourExport.ProcessingType  == SalesBookFactureProcessingType_RU::VATStandard           ||
                    factureJourExport.ProcessingType  == SalesBookFactureProcessingType_RU::VATStandardCorrection)))
        exists join restoredVATLogTable
            where  restoredVATLogTable.TransDate      == restoredVATLogTrans.TransDate &&
                   restoredVATLogTable.Approved
        {
            select firstonly factureJourExp
            where ((factureJourExp.StatusChangeDate >= fromDate                                                 &&
                    factureJourExp.StatusChangeDate <= toDate                                                   &&
                    (factureJourExp.ProcessingType  == SalesBookFactureProcessingType_RU::VATZero               ||
                     factureJourExp.ProcessingType  == SalesBookFactureProcessingType_RU::VATZeroCorrection     ||
                     factureJourExp.ProcessingType  == SalesBookFactureProcessingType_RU::OverdueConfirmation)) ||
                  (! factureJourExp.ConfirmationDate                                                           &&
                    (factureJourExp.ProcessingType  == SalesBookFactureProcessingType_RU::VATStandard           ||
                     factureJourExp.ProcessingType  == SalesBookFactureProcessingType_RU::VATStandardCorrection)))
            exists join custInvoiceTransExists
                where  custInvoiceTransExists.RecId == restoredVATLogTransOperLink.CustInvoiceTransRecId
            exists join vatSalesTaxTransExists
                where  vatSalesTaxTransExists.InventTransId == custInvoiceTransExists.InventTransId &&
                       vatSalesTaxTransExists.FactureId     == factureJourExp.FactureId             &&
                       vatSalesTaxTransExists.FactureModule == factureJourExp.Module;

            if ((factureJourExp.ProcessingType  == SalesBookFactureProcessingType_RU::VATStandard            ||
                 factureJourExp.ProcessingType  == SalesBookFactureProcessingType_RU::VATStandardCorrection) &&
                (factureJourExp.expirationDate() < fromDate                                                  ||
                 factureJourExp.expirationDate() > toDate))
            {
                continue;
            }

            calcRestoredAmounts();
        }

        updateRestoredAmounts();

        factureJourExp.clear();
        factureJourExport.clear();

        while select restoredVATLogTrans
        join restoredVATLogTransOper
            where  restoredVATLogTransOper.TransDate            == restoredVATLogTrans.TransDate             &&
                   restoredVATLogTransOper.ProcessLogTransRecId == restoredVATLogTrans.ProcessLogTransRecId  &&
                   restoredVATLogTransOper.LineType             == RestoredVATLineType_RU::Indirect          &&
                   restoredVATLogTransOper.Include                                                           &&
                  !restoredVATLogTransOper.Asset
        exists join restoredVATLogTable
            where  restoredVATLogTable.TransDate      == restoredVATLogTrans.TransDate &&
                   restoredVATLogTable.Approved
        exists join restoredVATSalesTaxTrans
            where  restoredVATSalesTaxTrans.TransDate == restoredVATLogTrans.TransDate
        exists join factureJourExport
            where  factureJourExport.FactureId        == restoredVATSalesTaxTrans.FactureId                       &&
                   factureJourExport.Module           == restoredVATSalesTaxTrans.FactureModule                   &&
                 ((factureJourExport.StatusChangeDate >= fromDate                                                 &&
                   factureJourExport.StatusChangeDate <= toDate                                                   &&
                   (factureJourExport.ProcessingType  == SalesBookFactureProcessingType_RU::VATZero               ||
                    factureJourExport.ProcessingType  == SalesBookFactureProcessingType_RU::VATZeroCorrection     ||
                    factureJourExport.ProcessingType  == SalesBookFactureProcessingType_RU::OverdueConfirmation)) ||
                  (! factureJourExport.ConfirmationDate                                                           &&
                   (factureJourExport.ProcessingType  == SalesBookFactureProcessingType_RU::VATStandard           ||
                    factureJourExport.ProcessingType  == SalesBookFactureProcessingType_RU::VATStandardCorrection)))
        {
            calcRestoredAmounts();
        }

        updateRestoredAmounts();

        ttsCommit;

        return tmpRestoredVATLogTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inRangeIntoQueryRun</Name>
				<Source><![CDATA[
    protected boolean inRangeIntoQueryRun(fieldId _fieldId, anytype _value)
    {
        QueryBuildDataSource    queryBuildDataSource;
        QueryBuildRange         queryBuildRange;
        boolean                 ret = true;
        ;

        queryBuildDataSource = queryRun.query().dataSourceNo(1);

        queryBuildRange = queryBuildDataSource.findRange(_fieldId);

        if (queryBuildRange)
        {
            ret = inRange(queryBuildRange.value(), _value, false);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoRecordsetList</Name>
				<Source><![CDATA[
    private void insertIntoRecordsetList(QueryRun _queryRun)
    {
        FactureJour_RU fJour;
        Integer        factureIssuePeriod = VendParameters::find().FactureIssuePeriod_RU;

        if (_queryRun)
        {
            while (_queryRun.next())
            {
                fJour = _queryRun.get(tableNum(FactureJour_RU));

                if ( ! recordSortedList.find(fJour) && ! fJour.isBlockedForBookFacture() && ! fJour.isPuchaseCommission())
                {
                    if (fJour.FactureType == FactureType_RU::Prepayment && fJour.Module == FactureModule_RU::Vend && factureIssuePeriod)
                    {
                        if (fJour.FactureDate_External - fJour.vendPrepaymentTransDate() >= factureIssuePeriod)
                        {
                            continue;
                        }
                    }
                    recordSortedList.ins(fJour);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoRecordsetListEx</Name>
				<Source><![CDATA[
    private void insertIntoRecordsetListEx(QueryRun _queryRun)
    {
        FactureJour_RU      fJour;
        VendSettlement      vendSettlement;
        TransDate           transDate;

        if (_queryRun)
        {
            while (_queryRun.next())
            {
                fJour           = _queryRun.get(tableNum(FactureJour_RU));
                vendSettlement  = _queryRun.get(tableNum(VendSettlement));

                transDate = max(fJour.FactureReportDate, vendSettlement.TransDate);

                if (transDate > toDate)
                {
                    continue;
                }

                if (! recordSortedList.find(fJour) && ! fJour.isBlockedForBookFacture() && ! fJour.isPuchaseCommission())
                {
                    recordSortedList.ins(fJour);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [currentVersion, operationRecId, queryRun.query().pack(), super()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOperationRecId</Name>
				<Source><![CDATA[
    public PurchBookVATProcessParametersRecId_RU parmOperationRecId(PurchBookVATProcessParametersRecId_RU _operationRecID = operationRecID)
    {
        operationRecID = _operationRecID;
        return operationRecID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>previousPolicy</Name>
				<Source><![CDATA[
    protected CustTaxation_RU previousPolicy()
    {
        PurchBookTable_RU purchBookTable;

        if (year(fromDate) == year(#TransitionEndDate) + 1)
        {
            select firstonly RecId from purchBookTable
                where purchBookTable.ClosingDate > #TransitionEndDate;

            if (! purchBookTable)
            {
                return CustTaxation_RU::OnPayment;
            }
        }

        return CustTaxation_RU::OnDelivery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qrAmountAdjFactures</Name>
				<Source><![CDATA[
    protected QueryRun qrAmountAdjFactures()
    {
        QueryBuildDataSource    dsFactureJour;
        Query                   query;
        container               factureTypeValue, factureModuleValue;
        boolean                 factureTypeInRange, factureModuleInRange, reversedInRange, amountAdjInRange;

        str factureDateValue =
        '((' + fieldstr(FactureJour_RU, FactureDate) + '>= \%1)  && ('  +
               fieldstr(FactureJour_RU, FactureDate) + '<= \%2)) || ((' +
               fieldstr(FactureJour_RU, ReverseDate) + ') && ('         +
               fieldstr(FactureJour_RU, ReverseDate) + '>= \%1)  && ('  +
               fieldstr(FactureJour_RU, ReverseDate) + '<= \%2))';

        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, FactureType), FactureType_RU::ExchAdj))
        {
            factureTypeInRange = true;
            factureTypeValue += FactureType_RU::ExchAdj;
        }

        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Module), FactureModule_RU::Vend))
        {
            factureModuleInRange = true;
            factureModuleValue += FactureModule_RU::Vend;
        }

        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Reversed), NoYes::No))
        {
            reversedInRange = true;
        }

        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, AmountAdjustment), NoYes::Yes))
        {
            amountAdjInRange = true;
        }

        if (! factureTypeInRange || ! factureModuleInRange || ! reversedInRange || ! amountAdjInRange)
        {
            return null;
        }

        query = new Query();

        dsFactureJour = query.addDataSource(tableNum(FactureJour_RU), dsFactureJourName);
        this.copyFactureJourRanges(query);

        findOrCreateRange_W(dsFactureJour,
                            fieldNum(FactureJour_RU, FactureType),
                            con2Str(factureTypeValue));

        findOrCreateRange_W(dsFactureJour,
                            fieldNum(FactureJour_RU, Module),
                            con2Str(factureModuleValue));

        findOrCreateRange_W(dsFactureJour,
                            fieldNum(FactureJour_RU, AmountAdjustment),
                            queryValue(NoYes::Yes));

        findOrCreateRange_W(dsFactureJour,
                            fieldNum(FactureJour_RU, FactureDate),
                            strFmt(factureDateValue, date2StrXpp(fromDate), date2StrXpp(toDate)));

        return new QueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qrBlockedFactures</Name>
				<Source><![CDATA[
    protected QueryRun qrBlockedFactures()
    {
        QueryBuildDataSource    dsFactureJour, dsProcessLogTrans, dsProcessLogTransOper;
        Query                   query;
        container               factureModuleValue;
        boolean                 factureModuleInRange;
        ;

        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Module), FactureModule_RU::Vend))
        {
            factureModuleInRange = true;
            factureModuleValue += FactureModule_RU::Vend;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Module), FactureModule_RU::Empl))
        {
            factureModuleInRange = true;
            factureModuleValue += FactureModule_RU::Empl;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Module), FactureModule_RU::TaxCorrectionPurch))
        {
            factureModuleInRange = true;
            factureModuleValue += FactureModule_RU::TaxCorrectionPurch;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Module), FactureModule_RU::TaxCorrectionPurch_Cust))
        {
            factureModuleInRange = true;
            factureModuleValue += FactureModule_RU::TaxCorrectionPurch_Cust;
        }

        if (! factureModuleInRange)
        {
            return null;
        }

        query = new Query();

        dsFactureJour = query.addDataSource(tableNum(FactureJour_RU), dsFactureJourName);
        this.copyFactureJourRanges(query);

        findOrCreateRange_W(dsFactureJour,
                            fieldNum(FactureJour_RU, Module),
                            con2Str(factureModuleValue));

        dsProcessLogTrans = dsFactureJour.addDataSource(tableNum(PurchBookVATProcessLogTrans_RU));
        dsProcessLogTrans.addSelectionField(fieldNum(PurchBookVATProcessLogTrans_RU, RecId));
        dsProcessLogTrans.joinMode(JoinMode::ExistsJoin);
        dsProcessLogTrans.addLink(fieldNum(FactureJour_RU, FactureId), fieldNum(PurchBookVATProcessLogTrans_RU, FactureId));

        dsProcessLogTransOper = dsProcessLogTrans.addDataSource(tableNum(PurchBookVATProcessLogTransOper_RU));
        dsProcessLogTransOper.addSelectionField(fieldNum(PurchBookVATProcessLogTransOper_RU, RecId));
        dsProcessLogTransOper.joinMode(JoinMode::ExistsJoin);
        dsProcessLogTransOper.addLink(fieldNum(PurchBookVATProcessLogTrans_RU, RecId), fieldNum(PurchBookVATProcessLogTransOper_RU, RefRecId));

        findOrCreateRange_W(dsProcessLogTransOper,
                            fieldNum(PurchBookVATProcessLogTransOper_RU, Blocked),
                            queryValue(NoYes::Yes));

        findOrCreateRange_W(dsProcessLogTransOper,
                            fieldNum(PurchBookVATProcessLogTransOper_RU, CanceledRefRecId),
                            queryValue(0));

        findOrCreateRange_W(dsProcessLogTransOper,
                            fieldNum(PurchBookVATProcessLogTransOper_RU, TransDate),
                            queryRange(dateNull(), toDate));

        return new QueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qrOldPrepaymSettled</Name>
				<Source><![CDATA[
    protected QueryRun qrOldPrepaymSettled()
    {
        QueryBuildDataSource    dsFactureJour, dsCustTransPayment, dsCustSettlement;
        QueryBuildDataSource    dsCustTrans_W;
        Query                   query;
        str                     rangeTxt;
        str                     dsName1, dsName2;

        str transDateValue =
            '(\%1.'             + fieldstr(CustSettlement, TransDate) +
            ' >= \%2) && (\%1.' + fieldstr(CustSettlement, TransDate) +
            ' <= \%3)';

        str canBeReversedValue =
            '(\%1.'             + fieldstr(CustSettlement, CanBeReversed) +
            ')' + OR + '(\%1.'  + fieldstr(CustSettlement, ReversedRecId_RU) + ')';

        str transDateLink =
            '((\%1.'    + fieldstr(CustTrans, TransDate) +
            ' == \%2.'  + fieldstr(FactureJour_RU, FactureDate) + ')' +
            ' || '      +
            '(\%1.'     + fieldstr(CustTrans, TransDate) +
            ' == \%2.'  + fieldstr(FactureJour_RU, FactureDate_External) + '))';

        str factureIDRange = 
            '(\%1.\%2 \%3 \%4.\%5)';

        const str equal = '==';

        if (! this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, FactureType), FactureType_RU::Prepayment) ||
           ! this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Module), FactureModule_RU::Cust))
        {
            return null;
        }

        query = new Query();

        // FactureJour_RU
        dsFactureJour = query.addDataSource(tableNum(FactureJour_RU), dsFactureJourName);
        this.copyFactureJourRanges(query);

        findOrCreateRange_W(dsFactureJour,
                            fieldNum(FactureJour_RU, FactureType),
                            queryValue(FactureType_RU::Prepayment));

        findOrCreateRange_W(dsFactureJour,
                            fieldNum(FactureJour_RU, Module),
                            queryValue(FactureModule_RU::Cust));

        findOrCreateRange_W(dsFactureJour,
                        fieldnum(FactureJour_RU, InventProfileType),
                        con2Str([InventProfileType_RU::General, InventProfileType_RU::NotSpecified]));
        // CustTrans
        dsCustTransPayment = dsFactureJour.addDataSource(tableNum(CustTrans), dsCustTransPaymentName);
        dsCustTransPayment.addSelectionField(fieldNum(CustTrans, RecId));
        dsCustTransPayment.joinMode(JoinMode::ExistsJoin);

        dsCustTransPayment.addLink(fieldNum(FactureJour_RU, CustVendInvoiceAccount), fieldNum(CustTrans, AccountNum));
        dsCustTransPayment.addLink(fieldNum(FactureJour_RU, Voucher),                fieldNum(CustTrans, Voucher));
        dsCustTransPayment.addLink(fieldNum(FactureJour_RU, CurrencyCode),           fieldNum(CustTrans, CurrencyCode));

        //CustTrans_W
        dsCustTrans_W = CustTrans_W::addToQuery(dsCustTransPayment, JoinMode::InnerJoin);

        dsName1 = dsFactureJour.name();
        dsName2 = dsCustTrans_W.name();
        rangeTxt = strFmt(
            factureIDRange,
            dsName1,
            fieldId2name(tableNum(FactureJour_RU), fieldNum(FactureJour_RU, FactureId)),
            equal,
            dsName2,
            fieldId2name(tableNum(CustTrans_W), fieldNum(CustTrans_W, PrepaymentFactureId_W)));

        dsCustTrans_W.addRange(fieldNum(CustTrans_W, PrepaymentFactureId_W)).value(rangeTxt);

        findOrCreateRange_W(dsCustTransPayment,
                            fieldNum(CustTrans, TransDate),
                            strFmt(transDateLink, dsCustTransPayment.name(), dsFactureJour.name()));

        findOrCreateRange_W(dsCustTransPayment,
                            fieldNum(CustTrans, Prepayment),
                            queryValue(NoYes::Yes));

        dsCustSettlement = dsCustTransPayment.addDataSource(tableNum(CustSettlement), dsCustSettlementName);
        dsCustSettlement.addSelectionField(fieldNum(CustSettlement, RecId));
        dsCustSettlement.joinMode(JoinMode::ExistsJoin);

        dsCustSettlement.addLink(fieldNum(CustTrans, RecId), fieldNum(CustSettlement, OffsetRecid));
        dsCustSettlement.addLink(fieldNum(CustTrans, DataAreaId), fieldNum(CustSettlement, OffsetCompany));

        findOrCreateRange_W(dsCustSettlement,
                            fieldNum(CustSettlement, TransDate),
                            strFmt(transDateValue, dsCustSettlement.name(), date2StrXpp(fromDate), date2StrXpp(toDate)));

        findOrCreateRange_W(dsCustSettlement,
                            fieldNum(CustSettlement, CanBeReversed),
                            strFmt(canBeReversedValue, dsCustSettlement.name()));

        return new QueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qrRestoredVATFactures</Name>
				<Source><![CDATA[
    protected QueryRun qrRestoredVATFactures()
    {
        QueryBuildDataSource    dsFactureJour;
        QueryBuildDataSource    dsRestoredVATLogTrans;
        Query                   query;
        QueryRun                queryRunLocal;
        ;

        query = new Query();

        dsFactureJour = query.addDataSource(tableNum(FactureJour_RU), dsFactureJourName);
        this.copyFactureJourRanges(query);

        dsFactureJour.addSortField(fieldNum(FactureJour_RU, FactureDate));

        dsRestoredVATLogTrans = dsFactureJour.addDataSource(tableNum(TmpRestoredVATLogTrans_RU));
        dsRestoredVATLogTrans.joinMode(JoinMode::ExistsJoin);

        dsRestoredVATLogTrans.addLink(fieldNum(FactureJour_RU, FactureId), fieldNum(TmpRestoredVATLogTrans_RU, FactureId));
        dsRestoredVATLogTrans.addLink(fieldNum(FactureJour_RU, Module),    fieldNum(TmpRestoredVATLogTrans_RU, Module));

        queryRunLocal = new QueryRun(query);
        queryRunLocal.setCursor(this.initTmpRestoredTransExp());

        return queryRunLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qrSettlementDependent</Name>
				<Source><![CDATA[
    protected QueryRun qrSettlementDependent()
    {
        QueryBuildDataSource    dsFactureJour, dsFactureTrans, dsVendInvoiceJour;
        QueryBuildDataSource    dsVendTransInvoice, dsVendSettlement;
        Query                   query;

        str invoiceAccountValue =
            '(\%1.'   + fieldstr(VendInvoiceJour, InvoiceAccount) +
            '== \%2.' + fieldstr(FactureJour_RU, CustVendInvoiceAccount) + ')';

        str transDateValue =
            '((\%1.'                     + fieldstr(FactureJour_RU, FactureReportDate) +
            ' >= \%3) && (\%1.'          + fieldstr(FactureJour_RU, FactureReportDate) +
            ' <= \%4))' + OR + '((\%2.'  + fieldstr(VendSettlement, TransDate)         +
            ' >= \%3) && (\%2.'          + fieldstr(VendSettlement, TransDate)         +
            ' <= \%4))';

        str canBeReversedValue =
            '(\%1.'             + fieldstr(VendSettlement, CanBeReversed) +
            ')' + OR + '(\%1.'  + fieldstr(VendSettlement, ReversedRecId_RU) + ')';

        if (! this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, FactureType), FactureType_RU::Invoice) ||
            ! this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Module), FactureModule_RU::Vend))
        {
            return null;
        }

        query = new Query();

        dsFactureJour = query.addDataSource(tableNum(FactureJour_RU), dsFactureJourName);
        this.copyFactureJourRanges(query);

        findOrCreateRange_W(dsFactureJour, fieldNum(FactureJour_RU, FactureType), queryValue(FactureType_RU::Invoice));
        findOrCreateRange_W(dsFactureJour, fieldNum(FactureJour_RU, Module), queryValue(FactureModule_RU::Vend));

        findOrCreateRange_W(dsFactureJour, fieldNum(FactureJour_RU, vatOnPayment), queryValue(NoYes::Yes));
        query.forceSelectOrder(true);
        query.forceNestedLoop(true);

        findOrCreateRange_W(dsFactureJour,
                            fieldNum(FactureJour_RU, InventProfileType),
                            con2Str([InventProfileType_RU::General, InventProfileType_RU::NotSpecified]));

        dsFactureTrans = dsFactureJour.addDataSource(tableNum(FactureTrans_RU));
        dsFactureTrans.addSelectionField(fieldNum(FactureTrans_RU, RecId));
        dsFactureTrans.joinMode(JoinMode::InnerJoin);
        dsFactureTrans.relations(true);

        dsVendInvoiceJour = dsFactureTrans.addDataSource(tableNum(VendInvoiceJour), dsVendInvoiceJourName);
        dsVendInvoiceJour.addSelectionField(fieldNum(VendInvoiceJour, RecId));
        dsVendInvoiceJour.joinMode(JoinMode::InnerJoin);

        dsVendInvoiceJour.addLink(fieldNum(FactureTrans_RU, InternalInvoiceId),   fieldNum(VendInvoiceJour, InternalInvoiceId));
        dsVendInvoiceJour.addLink(fieldNum(FactureTrans_RU, InvoiceId),           fieldNum(VendInvoiceJour, InvoiceId));
        dsVendInvoiceJour.addLink(fieldNum(FactureTrans_RU, InvoiceDate),         fieldNum(VendInvoiceJour, InvoiceDate));
        dsVendInvoiceJour.addLink(fieldNum(FactureTrans_RU, SalesPurchId),        fieldNum(VendInvoiceJour, PurchId));
        dsVendInvoiceJour.addLink(fieldNum(FactureTrans_RU, NumberSequenceGroup), fieldNum(VendInvoiceJour, NumberSequenceGroup));

        findOrCreateRange_W(dsVendInvoiceJour,
                            fieldNum(VendInvoiceJour, InvoiceAccount),
                            strFmt(invoiceAccountValue, dsVendInvoiceJour.name(), dsFactureJour.name()));

        dsVendTransInvoice = dsVendInvoiceJour.addDataSource(tableNum(VendTrans), dsVendTransInvoiceName);
        dsVendTransInvoice.addSelectionField(fieldNum(VendInvoiceJour, RecId));
        dsVendTransInvoice.joinMode(JoinMode::InnerJoin);

        dsVendTransInvoice.addLink(fieldNum(VendInvoiceJour, LedgerVoucher), fieldNum(VendTrans, Voucher));
        dsVendTransInvoice.addLink(fieldNum(VendInvoiceJour, InvoiceDate), fieldNum(VendTrans, TransDate));
        dsVendTransInvoice.addLink(fieldNum(VendInvoiceJour, InvoiceAccount), fieldNum(VendTrans, AccountNum));
        dsVendTransInvoice.addLink(fieldNum(VendInvoiceJour, InvoiceId), fieldNum(VendTrans, Invoice));

        dsVendSettlement = dsVendTransInvoice.addDataSource(tableNum(VendSettlement), dsVendSettlementName);
        dsVendSettlement.addSelectionField(fieldNum(VendSettlement, TransDate));
        dsVendSettlement.joinMode(JoinMode::InnerJoin);

        dsVendSettlement.addLink(fieldNum(VendTrans, RecId), fieldNum(VendSettlement, TransRecId));
        dsVendSettlement.addLink(fieldNum(VendTrans, DataAreaId), fieldNum(VendSettlement, TransCompany));

        findOrCreateRange_W(dsVendSettlement,
                            fieldNum(VendSettlement, TransDate),
                            strFmt(transDateValue,
                                   dsFactureJour.name(),
                                   dsVendSettlement.name(),
                                   date2StrXpp(fromDate), date2StrXpp(toDate)));

        findOrCreateRange_W(dsVendSettlement,
                            fieldNum(VendSettlement, CanBeReversed),
                            strFmt(canBeReversedValue, dsVendSettlement.name()));

        return new QueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qrSettlementInDependent</Name>
				<Source><![CDATA[
    protected QueryRun qrSettlementInDependent()
    {
        QueryBuildDataSource    dsFactureJour;
        Query                   query;
        container               factureTypeValue, factureModuleValue;
        boolean                 factureTypeInRange, factureModuleInRange, reversedInRange, amountAdjInRange;

        str factureDateValue = 
        '((' + fieldstr(FactureJour_RU, FactureReportDate) + '>= \%1)  && ('  +
               fieldstr(FactureJour_RU, FactureReportDate) + '<= \%2)) || ((' +
               fieldstr(FactureJour_RU, ReverseDate)       + ') && ('         +
               fieldstr(FactureJour_RU, ReverseDate)       + '>= \%1)  && ('  +
               fieldstr(FactureJour_RU, ReverseDate)       + '<= \%2))';

        str factureProcessingTypeValue =
        '((' + fieldstr(FactureJour_RU, Module)         + '= \%1)  && ('  +
               fieldstr(FactureJour_RU, ProcessingType) + '= \%2)) || ((' +
               fieldstr(FactureJour_RU, Module)         + '!= \%1) && ('  +
               fieldstr(FactureJour_RU, ProcessingType) + '= \%3))';

        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, FactureType), FactureType_RU::AmoutDifference))
        {
            factureTypeInRange = true;
            factureTypeValue += FactureType_RU::AmoutDifference;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, FactureType), FactureType_RU::ExchAdj))
        {
            factureTypeInRange = true;
            factureTypeValue += FactureType_RU::ExchAdj;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, FactureType), FactureType_RU::AdvanceAdjustment))
        {
            factureTypeInRange = true;
            factureTypeValue += FactureType_RU::AdvanceAdjustment;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, FactureType), FactureType_RU::AdvanceReport))
        {
            factureTypeInRange = true;
            factureTypeValue += FactureType_RU::AdvanceReport;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, FactureType), FactureType_RU::TaxCorrection))
        {
            factureTypeInRange = true;
            factureTypeValue += FactureType_RU::TaxCorrection;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, FactureType), FactureType_RU::Facture))
        {
            factureTypeInRange = true;
            factureTypeValue += FactureType_RU::Facture;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, FactureType), FactureType_RU::GTD))
        {
            factureTypeInRange = true;
            factureTypeValue += FactureType_RU::GTD;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, FactureType), FactureType_RU::CustomCorrection))
        {
            factureTypeInRange = true;
            factureTypeValue += FactureType_RU::CustomCorrection;
        }

        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Module), FactureModule_RU::Vend))
        {
            factureModuleInRange = true;
            factureModuleValue += FactureModule_RU::Vend;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Module), FactureModule_RU::Empl))
        {
            factureModuleInRange = true;
            factureModuleValue += FactureModule_RU::Empl;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Module), FactureModule_RU::TaxCorrectionPurch))
        {
            factureModuleInRange = true;
            factureModuleValue += FactureModule_RU::TaxCorrectionPurch;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Module), FactureModule_RU::TaxCorrectionPurch_Cust))
        {
            factureModuleInRange = true;
            factureModuleValue += FactureModule_RU::TaxCorrectionPurch_Cust;
        }
        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Module), FactureModule_RU::Cust))
        {
            factureModuleInRange = true;
            factureModuleValue += FactureModule_RU::Cust;
        }

        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, Reversed), NoYes::No))
        {
            reversedInRange = true;
        }

        if (this.inRangeIntoQueryRun(fieldNum(FactureJour_RU, AmountAdjustment), NoYes::No))
        {
            amountAdjInRange = true;
        }

        if (! factureTypeInRange || ! factureModuleInRange || ! reversedInRange || ! amountAdjInRange)
        {
            return null;
        }

        query = new Query();

        dsFactureJour = query.addDataSource(tableNum(FactureJour_RU), dsFactureJourName);
        this.copyFactureJourRanges(query);

        findOrCreateRange_W(dsFactureJour,
                            fieldNum(FactureJour_RU, FactureType),
                            con2Str(factureTypeValue));

        findOrCreateRange_W(dsFactureJour,
                            fieldNum(FactureJour_RU, Module),
                            con2Str(factureModuleValue));

        findOrCreateRange_W(dsFactureJour,
                            fieldNum(FactureJour_RU, FactureDate),
                            strFmt(factureDateValue, date2StrXpp(fromDate), date2StrXpp(toDate)));

        findOrCreateRange_W(dsFactureJour,
                            fieldNum(FactureJour_RU, ProcessingType),
                            strFmt(factureProcessingTypeValue,
                                   enum2int(FactureModule_RU::Cust),
                                   enum2int(SalesBookFactureProcessingType_RU::VATStandardCancellation),
                                   enum2int(SalesBookFactureProcessingType_RU::None)));

        if (VendParameters::find().AmountDiffBookCorrection_RU)
        {
            findOrCreateRange_W(dsFactureJour,
                                fieldNum(FactureJour_RU, AmountAdjustment),
                                queryValue(NoYes::No));
        }

        return new QueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInfologPrefix</Name>
				<Source><![CDATA[
    protected void setInfologPrefix()
    {
        setPrefix(BookDataCalc_Purch_Process_RU::description());
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Integer     version = RunBase::getVersion(_packedClass);
        container   con, conQuery;
        Query       query;

        switch (version)
        {
            case currentVersion:
                [version, operationRecId, conQuery, con] = _packedClass;
                super(con);
                query    = new Query(conQuery);
                queryRun = new QueryRun(query);
                break;

            default:
                return false;
        }

        operationRecId = PurchBookVATProcessParameters_RU::defaultParms().RecId;
        bookTableMode  = false;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object _calledFrom = null)
    {
        boolean                                 ret = super(_calledFrom);
        int                                     iCntDS;
        TransDate                               startDate;
        TransDate                               endDate;
        PurchBookVATProcessParameters_RU        purchBookVATProcessParameters;

        if (_calledFrom && ! operationRecId)
        {
            ret = checkFailed("@GLS101587");
        }

        if (operationRecId)
        {
            purchBookVATProcessParameters = PurchBookVATProcessParameters_RU::find(operationRecId);

            if (! purchBookVATProcessParameters)
            {
                ret = false;

                error("@GLS101587",
                      '',
                      SysInfoAction_Formrun::newFormnameControlnameDesc(formStr(PurchBookVATProcessParameters_RU),
                                                                        fieldStr(PurchBookVATProcessParameters_RU, OperationCode),
                                                                        "@GLS104955"));
            }
        }

        iCntDS = queryRun.query().dataSourceCount();

        if (iCntDS > 1)
        {
            warning(strFmt("@GLS106969", 1, iCntDS));
            ret = false;
        }

        if (ret && ! PurchBookTable_RU::canProcessDate(fromDate))
        {
            ret = checkFailed("@GLS104874");
        }

        if (ret && (fromDate >= #TransitionStartDate || toDate >= #TransitionStartDate))
        {
            [startDate, endDate] = BookDataCalc_RU::datePeriodBook(fromDate);
            if (fromDate && fromDate <= #TransitionEndDate && (fromDate != startDate || toDate != endDate))
            {
                ret = checkFailed("@SYS15885");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@GLS101145" + "@GLS116883" + strLwr("@GLS101168");
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromBookTable</Name>
				<Source><![CDATA[
    public static BookDataCalc_Purch_Process_RU newFromBookTable(TransDate _fromDate, TransDate _toDate)
    {
        BookDataCalc_Purch_Process_RU bookDataCalc_Purch_Process;
        ;

        bookDataCalc_Purch_Process = new BookDataCalc_Purch_Process_RU();
        bookDataCalc_Purch_Process.parmFromDate(_fromDate);
        bookDataCalc_Purch_Process.parmToDate(_toDate);
        bookDataCalc_Purch_Process.parmBookTableMode(false);

        return bookDataCalc_Purch_Process;
    }

]]></Source>
			</Method>
		<Method><Name>isRetryable</Name><Source><![CDATA[
    /// <summary>
    /// Controls whether the batch task should be retried in case of transient errors.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable() 
    {
        return false;
    }
]]></Source></Method></Methods>
	</SourceCode>
</AxClass>