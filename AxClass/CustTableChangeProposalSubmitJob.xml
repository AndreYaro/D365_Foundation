<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustTableChangeProposalSubmitJob</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// This class handles periodic automatic submition of customer change proposals to workflow.
/// </summary>
public class CustTableChangeProposalSubmitJob extends RunBaseBatch implements BatchRetryable
{
    QueryRun queryRun;
    NoYes autoGeneratedOnly;
    DialogField dialogAutoGeneratedOnly;
    
    private const int CurrentVersion = 3;
    #localmacro.CurrentList
        autoGeneratedOnly
    #endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    public Object dialog()
    {
        DialogRunbase dialog = super();
        
        dialogAutoGeneratedOnly = dialog.addFieldValue(enumStr(NoYes), autoGeneratedOnly, "@AccountsReceivable:CustChangeProposalSubmit_AutogeneratedOnlyDialogToggle");

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns the dialog values to the class variables.
    /// </summary>
    /// <returns>
    /// True on successful execution of the method.
    /// </returns>
    public boolean getFromDialog()
    {
        boolean ret = super();

        if (ret)
        {
            autoGeneratedOnly = dialogAutoGeneratedOnly.value();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the query for this class.
    /// </summary>
    public void initParmDefault()
    {
        Query query = new Query(queryStr(CustTableChangeProposalWorkflowQuery));
        
        QueryBuildDataSource qbdsCustomer = query.dataSourceTable(tableNum(CustTable));
        // Other datasource: QueryBuildDataSource qbdsProposal = query.dataSourceTable(tableNum(CustTableChangeProposal));

        QueryBuildRange allowedStatesRange = qbdsCustomer.addRange(fieldNum(CustTable, WorkflowState));
        allowedStatesRange.value(queryValue(CustTableChangeProposalWorkflowState::NotSubmitted));
        const int HideFromUsers = 2;
        allowedStatesRange.status(HideFromUsers);

        queryRun = new QueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [CurrentVersion, #CurrentList, queryRun.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        while (queryRun.next())
        {
            CustTableChangeProposal proposal = queryRun.get(tablenum(CustTableChangeProposal));

            if (!autoGeneratedOnly || proposal.IsAutogenerated)
            {
                // submit to workflow
                ttsbegin;
                CustTable::updateWorkflowState(proposal.custTable, CustTableChangeProposalWorkflowState::Submitted);

                // Activate the workflow.
                Workflow::activateFromWorkflowType(workFlowTypeStr(CustTableChangeProposalWorkflow), proposal.custTable, "@AccountsReceivable:CustChangeProposalSubmit_SubmittedMessage", NoYes::No);
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Integer version = conpeek(_packedClass, 1);
        container packedQuery;

        switch (version)
        {
            case CurrentVersion:
                [version, #CurrentList, packedQuery] = _packedClass;
                if (packedQuery)
                {
                    queryRun = new QueryRun(packedQuery);
                }
                break;
            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@AccountsReceivable:CustChangeProposalSubmitJob_Title";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        CustTableChangeProposalSubmitJob job = new CustTableChangeProposalSubmitJob();

        if (job.prompt())
        {
            job.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>