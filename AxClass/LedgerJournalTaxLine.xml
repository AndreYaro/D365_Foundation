<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalTaxLine</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LedgerJournalTaxLine</c> class is used to feed data to tax to support tax calculations and
/// tax posting.
/// </summary>
class LedgerJournalTaxLine implements TaxableLine
{
    LedgerJournalTrans          ledgerJournalTrans;
    LedgerJournalTable          ledgerJournalTable;
    LedgerJournalTaxDocument    taxDocument;
    boolean                     taxOnPrepayment;

    // <GIN><GJP>
    #ISOCountryRegionCodes
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>defaultExchangeRateDate</Name>
				<Source><![CDATA[
    // </GIN></GJP>

    /// <summary>
    ///    Retrieves the default exchange rate date based on the journal defaulting rules.
    /// </summary>
    /// <returns>
    ///    The exchange rate date to use for tax.
    /// </returns>
    [Wrappable(true)]
    protected final TransDate defaultExchangeRateDate()
    {
        return ledgerJournalTrans.TransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findChargeAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the appropriate charge account to use based on the account types and the account numbers.
    /// </summary>
    /// <param name="_taxObligationCompany">
    ///    The company we have a tax obligation to.
    /// </param>
    /// <returns>
    ///    The charge account.
    /// </returns>
    protected LedgerDimensionAccount findChargeAccount(SelectableDataArea _taxObligationCompany)
    {
        LedgerDimensionAccount   ledgerAccount;
        LedgerJournalTrans_Asset ledgerJournalTrans_Asset;

        // if this ledger journal trans record is unsaved then don't attempt to
        // find a charge account.  Not all required information will be
        // present until LedgerJournalTrans is saved.
        if (!ledgerJournalTrans.RecId)
        {
            return 0;
        }

        changecompany (_taxObligationCompany)
        {
            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend ||
                ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
                ledgerJournalTrans.AccountType == LedgerJournalACType::Bank)
            {
                switch (ledgerJournalTrans.OffsetAccountType)
                {
                    case LedgerJournalACType::Ledger :
                        ledgerAccount = ledgerJournalTrans.OffsetLedgerDimension;
                        break;
                    case LedgerJournalACType::Project :
                        if (ProjRevRecHelper::getCostLedgerStatus(ProjTable::findByLedgerDimension(ledgerJournalTrans.parmOffsetLedgerDimension())) == ProjLedgerStatus::Operations)
                        {
                            ledgerAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(ProjTrans::newLedgerJournalTrans(ledgerJournalTrans).costAccountLedgerDimension(0, false), ledgerJournalTrans.OffsetDefaultDimension);
                        }
                        else
                        {
                            ledgerAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(ProjTrans::newLedgerJournalTrans(ledgerJournalTrans).statusAccountLedgerDimension(0), ledgerJournalTrans.OffsetDefaultDimension);
                        }
                        break;
                    case LedgerJournalACType::FixedAssets :

                        if (ledgerJournalTrans.isFixedAssetsTransaction() && ledgerJournalTrans.RecId)
                        {
                            // This is a fixed assets transaction, so setup up the LedgerJournalTrans_Asset buffer
                            ledgerJournalTrans_Asset = ledgerJournalTrans.findLedgerJournalTransAssetSibling();
                        }

                        // If called prior to persistence of the LedgerJournalTrans_Asset subtype, not
                        // enough information is available to obtain the account
                        if (!ledgerJournalTrans_Asset)
                        {
                            return 0;
                        }

                        // The asset defined by ledgerJournalTrans.AccountNum exists in the company defined by ledgerJournalTrans.OffsetCompany so perform
                        // a change company before doing the account lookup.
                        changecompany (ledgerJournalTrans.OffsetCompany)
                        {
                            ledgerAccount = AssetTable::findByLedgerDimension(ledgerJournalTrans.OffsetLedgerDimension).assetLedgerDimension(ledgerJournalTrans.PostingProfile,
                                AssetPost::assetTransTypeJournal2AssetTransType(ledgerJournalTrans_Asset.TransType),ledgerJournalTrans_Asset.BookId);

                            ledgerAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerAccount, ledgerJournalTrans.DefaultDimension);
                        }
                        break;
                    case LedgerJournalACType::Bank :
                        if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
                        {
                            ledgerAccount = CustLedgerAccounts::summaryLedgerDimension(ledgerJournalTrans.parmAccount(), ledgerJournalTrans.PostingProfile);
                        }
                        else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                        {
                            ledgerAccount = VendLedgerAccounts::summaryLedgerDimension(ledgerJournalTrans.parmAccount(), ledgerJournalTrans.PostingProfile);
                        }
                        else
                        {
                            ledgerAccount = 0;
                        }
                        break;
                    default :
                        ledgerAccount = 0;
                }
            }
            else
            {
                switch (ledgerJournalTrans.AccountType)
                {
                    case LedgerJournalACType::Ledger :
                        ledgerAccount = ledgerJournalTrans.LedgerDimension;
                        break;
                    case LedgerJournalACType::Project :
                        if (ProjRevRecHelper::getCostLedgerStatus(ProjTable::findByLedgerDimension(ledgerJournalTrans.parmLedgerDimension())) == ProjLedgerStatus::Operations)
                        {
                            ledgerAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(ProjTrans::newLedgerJournalTrans(ledgerJournalTrans).costAccountLedgerDimension(0, false), ledgerJournalTrans.DefaultDimension);
                        }
                        else
                        {
                            ledgerAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(ProjTrans::newLedgerJournalTrans(ledgerJournalTrans).statusAccountLedgerDimension(0), ledgerJournalTrans.DefaultDimension);
                        }
                        break;
                    case LedgerJournalACType::FixedAssets :
                        // The asset defined by ledgerJournalTrans.AccountNum exists in the company defined by ledgerJournalTrans.Company so perform
                        // a change company before doing the account lookup.
                        changecompany (ledgerJournalTrans.Company)
                        {
                            if (ledgerJournalTrans.isFixedAssetsTransaction() && ledgerJournalTrans.RecId)
                            {
                                // This is a fixed assets transaction, so setup up the LedgerJournalTrans_Asset buffer
                                ledgerJournalTrans_Asset = ledgerJournalTrans.findLedgerJournalTransAssetSibling();
                            }

                            // early on, LedgerJournalTrans_Asset may not exist yet
                            // so just return an empty account until it does.
                            if (ledgerJournalTrans_Asset.RecId)
                            {
                                ledgerAccount = AssetTable::findByLedgerDimension(ledgerJournalTrans.parmLedgerDimension()).assetLedgerDimension(ledgerJournalTrans.PostingProfile,
                                        AssetPost::assetTransTypeJournal2AssetTransType(ledgerJournalTrans_Asset.TransType),ledgerJournalTrans_Asset.BookId);

                                ledgerAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerAccount, ledgerJournalTrans.DefaultDimension);
                            }
                            else
                            {
                                ledgerAccount = 0;
                            }
                        }
                        break;
                    default :
                        ledgerAccount = 0;
                }
            }
        }
        return ledgerAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOperationsAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the operation account to use based on the ledger journal account type on the journal line for
    ///    the account and the offset account.
    /// </summary>
    /// <param name="_taxObligationCompany">
    ///    The company we have a tax obligation to.
    /// </param>
    /// <returns>
    ///    The operation account.
    /// </returns>
    public LedgerDimensionAccount findOperationsAccount(SelectableDataArea _taxObligationCompany)
    {
        if (ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
        {
            return ledgerJournalTrans.LedgerDimension;
        }

        if (this.isPrimaryBeingCalculated())
        {
            if (ledgerJournalTrans.AccountType    == LedgerJournalACType::Project
                || ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets
                || ledgerJournalTrans.AccountType == LedgerJournalACType::Cust
                || ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                return this.findChargeAccount(_taxObligationCompany);
            }
        }
        else
        {
            if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project ||
                ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets)
            {
                return this.findChargeAccount(_taxObligationCompany);
            }
        }

        if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger &&
            ledgerJournalTrans.parmOffsetLedgerDimension())
        {
            return ledgerJournalTrans.OffsetLedgerDimension;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscountAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the cash discount amount.
    /// </summary>
    /// <returns>
    ///    The cash discount amount.
    /// </returns>
    /// <remarks>
    ///    If both the cash discount amount and the cash discount percentage are supplied, tax calculations
    ///    will always use the cash discount amount instead of the cash discount percentage.
    /// </remarks>
    public AmountCur getCashDiscountAmount()
    {
        return this.setSignBasedOnAccountType(ledgerJournalTrans, ledgerJournalTrans.CashDiscAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscountPercent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the cash discount percentage.
    /// </summary>
    /// <returns>
    ///    The cash discount percentage.
    /// </returns>
    /// <remarks>
    ///    If both the cash discount amount and the cash discount percentage are supplied, tax calculations
    ///    will always use the cash discount amount instead of the cash discount percentage.
    /// </remarks>
    public Percent getCashDiscountPercent()
    {
        if (!ledgerJournalTrans.CashDiscAmount && !ledgerJournalTrans.CashDiscPercent && ledgerJournalTrans.CashDiscCode)
        {
            return CashDisc::find(ledgerJournalTrans.CashDiscCode, false).Percent;
        }
        else
        {
            return ledgerJournalTrans.CashDiscPercent;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyExchangeInformation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets an instance of the <c>CurrencyExchHelper</c> class that represents the transaction line.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>CurrencyExchHelper</c> class.
    /// </returns>
    /// <remarks>
    ///    The currency, exchange date, exchange rate, secondary exchange rate, and triangulation should be
    ///    set on the instance of the <c>CurrencyExchHelper</c> class.If the exchange rate and triangulation
    ///    are not set, default values will be used.
    /// </remarks>
    public CurrencyExchangeHelper getCurrencyExchangeInformation()
    {
        CurrencyExchangeHelper currencyExchangeHelper;

        currencyExchangeHelper = CurrencyExchangeHelper::construct();
        currencyExchangeHelper.parmExchangeRate1(ledgerJournalTrans.ExchRate);
        currencyExchangeHelper.parmExchangeRate2(ledgerJournalTrans.ExchRateSecond);
        currencyExchangeHelper.parmExchangeDate(this.defaultExchangeRateDate());

        return currencyExchangeHelper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentMiscellaneousCharge</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the current miscellaneous charge line.
    /// </summary>
    /// <returns>
    ///    An object which implements the <c>TaxableLine</c> interface.
    /// </returns>
    /// <remarks>
    ///    If miscellaneous charges do not exist or if the transaction does not support miscellaneous charges
    ///    null may be returned.
    /// </remarks>
    public TaxableLine getCurrentMiscellaneousCharge()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the default dimension from the transaction line.
    /// </summary>
    /// <returns>
    ///    The default dimension.
    /// </returns>
    /// <remarks>
    ///    The default dimension will be combined with the default accounts that are loaded from the tax setup.
    /// </remarks>
    public DimensionDefault getDefaultDimension()
    {
        if (ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger  && ledgerJournalTrans.LedgerDimension)
        {
            return LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(ledgerJournalTrans.LedgerDimension);
        }

        if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger && this.isOffsetBeingCalculated())
        {
            return LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(ledgerJournalTrans.OffsetLedgerDimension);
        }

        if (this.isPrimaryBeingCalculated())
        {
            return ledgerJournalTrans.DefaultDimension;
        }

        if (this.isOffsetBeingCalculated())
        {
            return ledgerJournalTrans.OffsetDefaultDimension;
        }

        return ledgerJournalTrans.DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultTaxDirection</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the default tax direction for the transaction.
    /// </summary>
    /// <param name="_taxGroupData">
    ///    The <c>TaxGroupData</c> table buffer that represents the tax code that is being considered.
    /// </param>
    /// <param name="_taxObligationCompany">
    ///    The company we have a tax obligation to.
    /// </param>
    /// <returns>
    ///    The default tax direction.
    /// </returns>
    /// <remarks>
    ///    A customer transaction will typically have the tax direction value set to Sales Tax Payable.A
    ///    vendor-facing transaction will typically have the tax direction value set to Sales Tax Receivable.
    /// </remarks>
    public TaxDirection getDefaultTaxDirection(TaxGroupData   _taxGroupData, SelectableDataArea _taxObligationCompany)
    {
        LedgerJournalACType          ledgerJournalACType;
        TaxDirection                 taxDirection;
        LedgerDimensionAccount       ledgerAccount;
        #ISOCountryRegionCodes

        if (ledgerJournalTrans.TaxCode)
        {
            return this.vatTransactionDirection();
        }

        if (ledgerJournalTrans.TaxDirectionControl)
        {
            if (this.isPrimaryBeingCalculated())
            {
                if (ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
                {
                    return this.ledgerDirection(ledgerJournalTrans.LedgerDimension, _taxGroupData, ledgerJournalTrans, _taxObligationCompany);
                }
            }
            else
            {
                if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
                {
                    return this.ledgerDirection(ledgerJournalTrans.OffsetLedgerDimension, _taxGroupData, ledgerJournalTrans, _taxObligationCompany);
                }
            }
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#IsoPL]))
        {
            // In Poland, use the account type from the actual transaction if possible.
            ledgerJournalACType = ledgerJournalTrans.mainAccountType_PL();
            if (ledgerJournalACType == LedgerJournalACType::Ledger)
            {
                ledgerJournalACType = taxDocument.getMainAccountType(ledgerJournalTrans.Voucher);
            }
        }
        else
        {
            ledgerJournalACType = taxDocument.getMainAccountType(ledgerJournalTrans.Voucher);
        }

        if (ledgerJournalACType == LedgerJournalACType::Ledger && !ledgerJournalTrans.RecId)
        {
            ledgerJournalACType = ledgerJournalTrans.AccountType;
        }

        switch (ledgerJournalACType)
        {
            case LedgerJournalACType::Cust :
                if (_taxGroupData.ExemptTax == NoYes::No)
                {
                    taxDirection = TaxDirection::OutgoingTax;

                    // <GBR>
                    if (BrazilParameters::isEnabled()
                        && TaxTable::find(_taxGroupData.TaxCode).RetainedTax_BR)
                    {
                        taxDirection = TaxDirection::IncomingTax;
                    }
                    // </GBR>
                }
                else
                {
                    if (_taxGroupData.ReverseCharge_W)
                    {
                        taxDirection = TaxDirection::OutgoingTax;
                    }
                    else
                    {
                        taxDirection = TaxDirection::TaxExemptSales;
                    }
                }
                break;

            case LedgerJournalACType::Vend :
                if (_taxGroupData.UseTax == NoYes::Yes)
                {
                    taxDirection = TaxDirection::UseTax;
                }
                else
                {
                    if (_taxGroupData.ExemptTax == NoYes::No)
                    {
                        changecompany(_taxObligationCompany)
                        {
                            if ((_taxGroupData.IntracomVAT == NoYes::Yes && VendParameters::find().IntracomVAT)
                                || (_taxGroupData.ReverseCharge_W
                                    && TaxTable::find(_taxGroupData.TaxCode).NegativeTax == NoYes::Yes))
                            {
                                taxDirection = TaxDirection::OutgoingTax;
                            }
                            else
                            {
                                taxDirection = TaxDirection::IncomingTax;

                                // <GBR>
                                if (BrazilParameters::isEnabled()
                                    && TaxTable::find(_taxGroupData.TaxCode).RetainedTax_BR)
                                {
                                    taxDirection = TaxDirection::OutgoingTax;
                                }
                                // </GBR>
                            }
                        }
                    }
                    else
                    {
                        taxDirection = TaxDirection::TaxExemptPurchase;
                    }
                }
                break;

            case LedgerJournalACType::Project :
                if (_taxGroupData.UseTax == NoYes::Yes)
                {
                    taxDirection = TaxDirection::UseTax;
                }
                else
                {
                    if (_taxGroupData.ExemptTax    == NoYes::Yes)
                    {
                        taxDirection = TaxDirection::TaxExemptPurchase;
                    }
                    else
                    {
                        changecompany(_taxObligationCompany)
                        {
                            if ((_taxGroupData.IntracomVAT == NoYes::Yes && VendParameters::find().IntracomVAT)
                                || (_taxGroupData.ReverseCharge_W
                                    && TaxTable::find(_taxGroupData.TaxCode).NegativeTax == NoYes::Yes))
                            {
                                taxDirection = TaxDirection::OutgoingTax;
                            }
                            else
                            {
                                taxDirection = TaxDirection::IncomingTax;
                            }
                        }
                    }
                }
                break;

            case LedgerJournalACType::Ledger :
                if (ledgerJournalTrans.AccountType == LedgerJournalACType::Bank)
                {
                    ledgerAccount = ledgerJournalTrans.OffsetLedgerDimension;
                }
                else
                {
                    ledgerAccount = ledgerJournalTrans.LedgerDimension;
                }
                taxDirection = this.ledgerDirection(ledgerAccount, _taxGroupData, ledgerJournalTrans, _taxObligationCompany);
                break;

            case LedgerJournalACType::FixedAssets :
                if (ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::PurchaseLedger)
                {
                    if (_taxGroupData.ExemptTax    == NoYes::No)
                    {
                        taxDirection = TaxDirection::IncomingTax;
                    }
                    else
                    {
                        taxDirection = TaxDirection::TaxExemptPurchase;
                    }
                }
                else
                {
                    if (ledgerJournalTrans.AmountCurDebit)
                    {
                        if (_taxGroupData.UseTax == NoYes::Yes)
                        {
                            taxDirection = TaxDirection::UseTax;
                        }
                        else
                        {
                            if (_taxGroupData.ExemptTax == NoYes::No)
                            {
                                taxDirection = TaxDirection::IncomingTax;
                            }
                            else
                            {
                                taxDirection = TaxDirection::TaxExemptPurchase;
                            }
                        }
                    }
                    else
                    {
                        if (ledgerJournalTrans.AmountCurCredit)
                        {
                            if (_taxGroupData.ExemptTax    == NoYes::No)
                            {
                                taxDirection = TaxDirection::OutgoingTax;
                            }
                            else
                            {
                                taxDirection = TaxDirection::TaxExemptSales;
                            }
                        }
                    }
                }
                break;
            // <GEERU>
            case LedgerJournalACType::RCash:
                taxDirection = _taxGroupData.ExemptTax ? TaxDirection::TaxExemptSales : (
                    (ledgerJournalTrans.AmountCurCredit && !ledgerJournalTrans.AmountCurDebit) ?
                        TaxDirection::IncomingTax:
                        TaxDirection::OutgoingTax
                );
                break;
            // </GEERU>

            default :
                if (_taxGroupData.ExemptTax    == NoYes::No)
                {
                    taxDirection = TaxDirection::IncomingTax;
                }
                else
                {
                    taxDirection = TaxDirection::TaxExemptPurchase;
                }
        }
        return taxDirection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDestinationCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines the destination company for an intercompany line.
    /// </summary>
    /// <returns>
    ///   The destination company.
    /// </returns>
    /// <remarks>
    ///   The destination company is company indicated on the source line that
    ///   contains the ledger account (usually an expense or revenue account).
    /// </remarks>
    public SelectableDataArea getDestinationCompany()
    {
        if (this.isPrimaryBeingCalculated())
        {
            // If taxes are being calculated on the primary account, return that company.
            if (ledgerJournalTrans.Company)
            {
                return ledgerJournalTrans.Company;
            }
        }

        if (this.isOffsetBeingCalculated())
        {
            // if taxes are being calculated on the offset account, return the offset company.
            if (ledgerJournalTrans.OffsetCompany)
            {
                return ledgerJournalTrans.OffsetCompany;
            }
        }

        // For multi-line transactions, it is possible, that taxes aren't calculating on either
        // side of the transaction.  If this is the case, return the current company or the
        // primary company.
        if (ledgerJournalTrans.Company == '')
        {
            return curext();
        }
        else
        {
            return ledgerJournalTrans.Company;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstMiscellaneousCharge</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reads the first miscellaneous charge.
    /// </summary>
    /// <returns>
    ///    true if a miscellaneous charge was found; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    If miscellaneous charges do not exist or the transaction does not support miscellaneous charges
    ///    false may be returned.
    /// </remarks>
    public boolean getFirstMiscellaneousCharge()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGSTHSTTaxType_CA</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the default GST or HST line amount type.
    /// </summary>
    /// <returns>
    /// The default GST or HST line amount type.
    /// </returns>
    public GSTHSTTaxType_CA getGSTHSTTaxType_CA()
    {
        return ledgerJournalTrans.gsthstTaxType_CA;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalizedLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the table buffer that represents the journalized line for the transaction.
    /// </summary>
    /// <returns>
    ///    A table buffer for the journalized line.
    /// </returns>
    /// <remarks>
    ///    For example, this return value would typically be the <c>VendInvoiceTrans</c> table if the
    ///    transaction is Purchase Order Invoice. This is used to set the parent of the <c>TaxTrans</c>
    ///    record.The table buffer must have a <c>RecId</c> value= assigned to it.
    /// </remarks>
    public Common getJournalizedLine()
    {
        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextMiscellaneousCharge</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reads the next miscellaneous charge.
    /// </summary>
    /// <returns>
    ///    true if a miscellaneous charge was found; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    If miscellaneous charges do not exist or the transaction does not support miscellaneous charges
    ///    then false may be returned.
    /// </remarks>
    public boolean getNextMiscellaneousCharge()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOperationLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the operation ledger dimension.
    /// </summary>
    /// <param name="_taxObligationCompany">
    ///    The company we have a tax obligation to.
    /// </param>
    /// <returns>
    ///    The operation ledger dimension.
    /// </returns>
    /// <remarks>
    ///    The operation ledger dimension is usually the primary ledger dimension from the transaction line.
    /// </remarks>
    public LedgerDimensionAccount getOperationLedgerDimension(SelectableDataArea _taxObligationCompany)
    {
        return this.findOperationsAccount(_taxObligationCompany);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostingType</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the default posting type.
    /// </summary>
    /// <returns>
    ///   The default posting type.
    /// </returns>
    public LedgerPostingType getPostingType()
    {
        return LedgerPostingType::Tax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the quantity from the transaction line.
    /// </summary>
    /// <returns>
    ///    The quantity.
    /// </returns>
    /// <remarks>
    ///    If the transaction does not support quantities, 0 may be returned as the quantity. This will be
    ///    used to calculate taxes by unit.
    /// </remarks>
    public Qty getQuantity()
    {
        return ledgerJournalTrans.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the transaction line from the source document.
    /// </summary>
    /// <returns>
    ///    The table buffer for the transaction line.
    /// </returns>
    /// <remarks>
    ///    This method is used before the document is journalized to determine the parent of the
    ///    <c>TaxUncommitted</c> record.A <c>RecId</c> value must be assigned to it.
    /// </remarks>
    public Common getSourceLine()
    {
        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxableInventoriedLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets an object that representing the inventoried transaction line.
    /// </summary>
    /// <returns>
    ///    A <c>TaxableInventoriedLine</c> object if the current line is inventoried; otherwise, null.
    /// </returns>
    /// <remarks>
    ///    This method is used to calculate taxes based on the amounts per unit.If this interface is not
    ///    implemented, taxes based on the amounts per unit will calculate zero amounts.
    /// </remarks>
    public TaxableInventoriedLine getTaxableInventoriedLine()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the tax code for the transaction line.
    /// </summary>
    /// <returns>
    ///    The tax code.
    /// </returns>
    /// <remarks>
    ///    Passing in a tax code on a transaction line implies that this transaction line is a direct tax
    ///    adjustment. No tax calculations will occur; instead the transaction amount is treated as the tax
    ///    amount and will be applied to this tax code. Pass an empty string if this functionality is not
    ///    desired.
    /// </remarks>
    public TaxCode getTaxCode()
    {
        return ledgerJournalTrans.TaxCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the tax group for the transaction line.
    /// </summary>
    /// <returns>
    ///   The tax group.
    /// </returns>
    public TaxGroup getTaxGroup()
    {
        return ledgerJournalTrans.TaxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxItemGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the item tax group for the transaction line.
    /// </summary>
    /// <returns>
    ///   The item tax group.
    /// </returns>
    public TaxItemGroup getTaxItemGroup()
    {
        return ledgerJournalTrans.TaxItemGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxRateDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the date to use with the tax to look up tax rates.
    /// </summary>
    /// <param name="_taxObligationCompany">
    ///    The company we have a tax obligation to.
    /// </param>
    /// <returns>
    ///    The tax rate date.
    /// </returns>
    public TransDate getTaxRateDate(SelectableDataArea _taxObligationCompany)
    {
        TaxCalculationDateType  taxCalculationDateType;
        TransDate               taxCalculationDate;

        // <GEEPL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]) && taxDocument.parmTaxRateDateOverride())
        {
            taxCalculationDate = taxDocument.parmTaxRateDateOverride();
        }
        else
        {
        // </GEEPL>
            changecompany(_taxObligationCompany)
            {
                taxCalculationDateType = TaxParameters::find().TaxCalculationDateType;
            }

            if (ledgerJournalTrans.DocumentDate &&
                taxCalculationDateType == TaxCalculationDateType::DocumentDate)
            {
                taxCalculationDate = ledgerJournalTrans.DocumentDate;
            }
            else if (taxCalculationDateType == TaxCalculationDateType::InvoiceDate)
            {
                taxCalculationDate = this.determineInvoiceDate();
            }
            else
            {
                taxCalculationDate = this.defaultExchangeRateDate();
            }
        // <GEEPL>
        }
        // </GEEPL>

        return taxCalculationDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxWithholdCode_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the taxWithhold code for the transaction line.
    /// </summary>
    /// <returns>
    ///    The taxWithhold code.
    /// </returns>
    public TaxWithholdCode getTaxWithholdCode_IN()
    {
        return ledgerJournalTrans.ledgerJournalTransTaxExtensionIN().TaxWithholdCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionAmount</Name>
				<Source><![CDATA[
/// <summary>
    ///   Gets the transaction line amount.
    /// </summary>
    /// <returns>
    ///   The transaction line amount.
    /// </returns>
    public TaxBase getTransactionAmount()
    {
        return this.setSignBasedOnAccountType(ledgerJournalTrans, ledgerJournalTrans.amount());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the transaction line currency.
    /// </summary>
    /// <returns>
    ///   The transaction line currency.
    /// </returns>
    public CurrencyCode getTransactionCurrency()
    {
        return ledgerJournalTrans.displayCurrencyCode();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionText</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the transaction text for the transaction line.
    /// </summary>
    /// <returns>
    ///   The transaction text.
    /// </returns>
    public TransactionTextLarge getTransactionText()
    {
        return ledgerJournalTrans.Txt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnitAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the amount per unit for the transaction line.
    /// </summary>
    /// <returns>
    ///    The amount per unit.
    /// </returns>
    /// <remarks>
    ///    This value is used by the tax for the amount per unit tax calculations.
    /// </remarks>
    public PriceCur getUnitAmount()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOffsetBeingCalculated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the offset account type of a <c>LedgerJournalTrans</c> record is eligible for tax
    ///    calculations.
    /// </summary>
    /// <returns>
    ///    true if taxes can be calculated on the offset; otherwise, false.
    /// </returns>
    public boolean isOffsetBeingCalculated()
    {
        if (ledgerJournalTrans.TaxCode)
        {
            // In a tax transfer scenario, the line amount is the tax amount
            // so the calculation engine should not calculate taxes on this line.
            return false;
        }

        if (this.isPrimaryBeingCalculated())
        {
            return false;
        }

        if (ledgerJournalTrans.parmOffsetLedgerDimension() &&
           (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger ||
            ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project ||
            ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets ||
            (taxOnPrepayment && ledgerJournalTrans.Prepayment)))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPrePayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the transaction line is a prepayment.
    /// </summary>
    /// <returns>
    ///    true if this is a prepayment; otherwise, false.
    /// </returns>
    public boolean isPrePayment()
    {
        return taxOnPrepayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPrimaryBeingCalculated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the primary account type of a <c>LedgerJournalTrans</c> record is eligible for
    ///    tax calculations.
    /// </summary>
    /// <returns>
    ///    true if taxes can be calculated on the primary account type.
    /// </returns>
    public boolean isPrimaryBeingCalculated()
    {
        // <GEERU>
        #isoCountryRegionCodes
        // </GEERU>
        if (ledgerJournalTrans.TaxCode)
        {
            // In a tax transfer scenario, the line amount is the tax amount
            // so the calculation engine should not calculate taxes on this line.
            return false;
        }

        if (ledgerJournalTrans.LedgerDimension &&
            (ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger ||
             ledgerJournalTrans.AccountType == LedgerJournalACType::Project ||
             ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets ||
             (taxOnPrepayment && ledgerJournalTrans.Prepayment)))
        {
            return true;
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) && this.isVatTaxAgentPrepayment_RU())
        {
            return true;
        }
        // </GEERU>

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVatTaxAgentPrepayment_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether current line is vat tax agent prepayment
    /// </summary>
    /// <returns>
    /// True if current line is vat tax agent prepayment; otherwise false
    /// </returns>
    public boolean isVatTaxAgentPrepayment_RU()
    {
        return ledgerJournalTrans.isVatTaxAgentPrepayment_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDirection</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the tax direction.
    /// </summary>
    /// <param name="_accountNum">
    ///    The account number.
    /// </param>
    /// <param name="_taxGroupData">
    ///    A <c>TaxGroupData</c> value.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record that is currently undergoing tax calculations.
    /// </param>
    /// <param name="_taxObligationCompany">
    ///    The company we have a tax obligation to.
    /// </param>
    /// <returns>
    ///    A
    ///    <c>
    ///       TaxDirection
    ///    </c>
    ///     value.The tax direction may be one of the following directions:
    ///    <list type="bullet">
    ///       <item>
    ///          <description>
    ///             <c>IncomingTax</c>
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>OutgoingTax</c>
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>TaxExemptSales</c>
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>TaxExemptPurchase</c>
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>UseTax</c>
    ///          </description>
    ///       </item>
    ///    </list>
    /// </returns>
    protected TaxDirection ledgerDirection(LedgerDimensionAccount _accountNum,
                                           TaxGroupData           _taxGroupData,
                                           LedgerJournalTrans     _ledgerJournalTrans,
                                           SelectableDataArea     _taxObligationCompany)
    {
        LedgerJournalTrans  originalLedgerJournalTrans;
        SalesPurch          salesPurch;
        TaxDirection        taxDirection;

        LedgerDimensionAccount  accountNum = _accountNum;

        changecompany (_taxObligationCompany)
        {
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
            {
                accountNum = _ledgerJournalTrans.getLedgerDimensionForJournalAccount(_ledgerJournalTrans.ledgerJournalTable(), false);
            }

            salesPurch = MainAccountLegalEntity::findByMainAccountLegalEntity(LedgerDimensionFacade::getMainAccountFromLedgerDimension(accountNum).RecId,
                CompanyInfo::current()).TaxDirection;
        }

        if (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Approval && !_ledgerJournalTrans.TaxDirectionControl)
        {
            salesPurch = SalesPurch::Purch;
        }

        switch (salesPurch)
        {
            case SalesPurch::Sales :
                if (_taxGroupData.ExemptTax == NoYes::No)
                {
                    taxDirection = TaxDirection::OutgoingTax;
                }
                else
                {
                    taxDirection = TaxDirection::TaxExemptSales;
                }
                break;

            case SalesPurch::Purch :
                if (_taxGroupData.UseTax == NoYes::Yes)
                {
                    taxDirection = TaxDirection::UseTax;
                }
                else
                {
                    if (_taxGroupData.ExemptTax == NoYes::No)
                    {
                        changecompany (_taxObligationCompany)
                        {
                            TaxTable taxTableLocal = TaxTable::find(_taxGroupData.TaxCode);

                            if ((_taxGroupData.IntracomVAT == NoYes::Yes && VendParameters::find().IntracomVAT) ||
                                (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoGB]) &&
                                taxTableLocal.NegativeTax == NoYes::Yes &&
                                taxTableLocal.TaxCountryRegionType == CountryRegionType::Domestic) ||
                                (_taxGroupData.ReverseCharge_W && taxTableLocal.NegativeTax == NoYes::Yes))
                            {
                                taxDirection = TaxDirection::OutgoingTax;
                            }
                            else
                            {
                                taxDirection = TaxDirection::IncomingTax;
                            }
                        }
                    }
                    else
                    {
                        taxDirection = TaxDirection::TaxExemptPurchase;
                    }
                }
                break;

            case SalesPurch::None :
                originalLedgerJournalTrans = ledgerJournalTrans.orig();
                if (!originalLedgerJournalTrans)
                {
                    // When field changed in buffer, but not updated to DB yet,
                    // orig() method of copy of the changed buffer returns empty.
                    // Use the current one instead.
                    originalLedgerJournalTrans = ledgerJournalTrans;
                }

                // Bank treats tax direction opposite of how a Vendor transaction would treat it.
                if ((originalLedgerJournalTrans.AmountCurDebit  && originalLedgerJournalTrans.AccountType != LedgerJournalACType::Bank) ||
                    (originalLedgerJournalTrans.AmountCurCredit && originalLedgerJournalTrans.AccountType == LedgerJournalACType::Bank))
                {
                    if (_taxGroupData.UseTax == NoYes::Yes)
                    {
                        taxDirection = TaxDirection::UseTax;
                    }
                    else
                    {
                        if (_taxGroupData.ExemptTax == NoYes::No)
                        {
                            taxDirection = TaxDirection::IncomingTax;
                        }
                        else
                        {
                            taxDirection = TaxDirection::TaxExemptPurchase;
                        }
                    }
                }

                // Bank treats tax direction opposite of how a Vendor transaction would treat it.
                if ((originalLedgerJournalTrans.AmountCurCredit && originalLedgerJournalTrans.AccountType != LedgerJournalACType::Bank) ||
                    (originalLedgerJournalTrans.AmountCurDebit  && originalLedgerJournalTrans.AccountType == LedgerJournalACType::Bank))
                {
                    if (_taxGroupData.UseTax == NoYes::Yes)
                    {
                        taxDirection = TaxDirection::UseTax;
                    }
                    else
                    {
                        if (_taxGroupData.ExemptTax)
                        {
                            taxDirection = TaxDirection::TaxExemptSales;
                        }
                        else
                        {
                            if (VendPaymFeeUtil_JP::isVendorPaymFeeEnabled()
                                && originalLedgerJournalTrans.TaxGroup
                                && originalLedgerJournalTrans.TaxItemGroup)
                            {
                                CustVendPaymJournalFee  custVendPaymJournalFee;

                                select firstOnly RecId, TaxDirection_JP from custVendPaymJournalFee
                                    where custVendPaymJournalFee.feeTransRecId == originalLedgerJournalTrans.RecId
                                        && custVendPaymJournalFee.IsPaymFeeCoveredByVendor_JP == NoYes::Yes;

                                if (custVendPaymJournalFee.RecId)
                                {
                                    switch (custVendPaymJournalFee.TaxDirection_JP)
                                    {
                                        case VendPaymFeeTaxDirection_JP::IncomingTax:
                                            taxDirection = TaxDirection::IncomingTax;
                                            break;

                                        case VendPaymFeeTaxDirection_JP::Automatic:
                                        case VendPaymFeeTaxDirection_JP::OutgoingTax:
                                            taxDirection = TaxDirection::OutgoingTax;
                                            break;

                                        default:
                                            taxDirection = TaxDirection::OutgoingTax;
                                            break;
                                    }
                                }
                                else
                                {
                                    taxDirection = TaxDirection::OutgoingTax;
                                }
                            }
                            else
                            {
                                taxDirection = TaxDirection::OutgoingTax;
                            }
                        }
                    }
                }
                break;

            default :
                if (_taxGroupData.ExemptTax == NoYes::No)
                {
                    taxDirection = TaxDirection::OutgoingTax;
                }
                else
                {
                    taxDirection = TaxDirection::TaxExemptSales;
                }
        }
        return taxDirection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(LedgerJournalTaxDocument _taxDocument, LedgerJournalTrans _ledgerJournalTrans, boolean _taxOnPrepayment)
    {
        ledgerJournalTrans  = _ledgerJournalTrans;
        ledgerJournalTable  = ledgerJournalTrans.ledgerJournalTable();
        taxDocument         = _taxDocument;
        taxOnPrepayment     = _taxOnPrepayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSignBasedOnAccountType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the tax sign by according to the side of the line on which taxes will be calculated on and the
    ///    account type.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record that is being calculated.
    /// </param>
    /// <param name="journalAmount">
    ///    The amount to which the sign will be applied.
    /// </param>
    /// <returns>
    ///    The amount with the correct sign.
    /// </returns>
    public TaxBase setSignBasedOnAccountType(LedgerJournalTrans _ledgerJournalTrans, TaxBase journalAmount)
    {
        // <GIN>
        boolean isPurchaseCash;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            isPurchaseCash = _ledgerJournalTrans.isPurchaseCashAccount_IN();
        }
        // </GIN>

        if (((_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger ||
              _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project ||
              _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets) &&
             _ledgerJournalTrans.parmLedgerDimension() &&
             (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
              _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend ||
              // <GEERU>
              _ledgerJournalTrans.AccountType == LedgerJournalACType::RCash ||
              // </GEERU>
              _ledgerJournalTrans.AccountType == LedgerJournalACType::Bank) &&
              !taxOnPrepayment
              // <GIN>
              && !isPurchaseCash
              // </GIN>
              ) ||
            (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger &&
             (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project &&
              _ledgerJournalTrans.parmLedgerDimension()))
              // <GEERU>
              || ( _ledgerJournalTrans.AccountType          == LedgerJournalACType::RCash &&
                   _ledgerJournalTrans.OffsetAccountType    == LedgerJournalACType::Cust)
              // </GEERU>
              )
        {
            return -journalAmount;
        }

        boolean independentSalesTaxCalculationOfGeneralJournalEnable = TaxLedgerIndependentFromProjectEnableFeatureExposure::isEnabled();

        if (!independentSalesTaxCalculationOfGeneralJournalEnable
            && _ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger
            && !this.shouldTaxSignKeepSameToLineAmountForApprovalJournal(_ledgerJournalTrans))
        {
            LedgerJournalTrans identicalVoucher;
            select firstonly RecId from identicalVoucher
                where identicalVoucher.Voucher == _ledgerJournalTrans.Voucher
                    && identicalVoucher.JournalNum == _ledgerJournalTrans.JournalNum
                    && (identicalVoucher.OffsetLedgerDimension != 0
                        || (identicalVoucher.AccountType != LedgerJournalACType::Project
                            && identicalVoucher.AccountType != LedgerJournalACType::Ledger));

            if (!identicalVoucher.RecId)
            {
                identicalVoucher.clear();

                select firstonly RecId from identicalVoucher
                    where (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Daily
                            || ((identicalVoucher.AmountCurCredit > 0 || identicalVoucher.AmountCurDebit < 0) && _ledgerJournalTrans.AmountCurCredit <= 0)
                            || ((identicalVoucher.AmountCurDebit > 0 || identicalVoucher.AmountCurCredit < 0) && _ledgerJournalTrans.AmountCurDebit <= 0))
                        && identicalVoucher.Voucher == _ledgerJournalTrans.Voucher
                        && identicalVoucher.JournalNum == _ledgerJournalTrans.JournalNum
                        && identicalVoucher.AccountType == LedgerJournalACType::Project
                        && identicalVoucher.LedgerDimension;
                if (identicalVoucher.RecId)
                {
                    return -journalAmount;
                }
            }
        }

        return journalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>supportAmountByUnit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the tax calculation engine should calculate tax for the tax code Origin of
    /// Amount Per Unit.
    /// </summary>
    /// <returns>
    /// false.
    /// </returns>
    /// <remarks>
    /// Journals do not support amount by unit calculations. Therefore, this method always returns false.
    /// </remarks>
    public boolean supportAmountByUnit()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useAndConsumption_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns if the operation is for a final user (or use and consumption) or not.
    /// </summary>
    /// <returns>True if is a final user (or use and consumption) otherwise false</returns>
    public boolean useAndConsumption_BR()
    {
        LedgerJournalACType          ledgerJournalACType;

        ledgerJournalACType = taxDocument.getMainAccountType(ledgerJournalTrans.Voucher);

        switch (ledgerJournalACType)
        {
            case LedgerJournalACType::Cust :
                return CustTable::find(ledgerJournalTrans.accountDisplay()).CustFinalUser_BR;
            case LedgerJournalACType::Vend :
                return VendTable::find(ledgerJournalTrans.accountDisplay()).VendConsumption_BR;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatTransactionDirection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the appropriate <c>TaxDirection</c> enumeration value, depending on the journal rules.
    /// </summary>
    /// <returns>
    /// The appropriate value for the <c>TaxDirection</c> enumeration type.
    /// </returns>
    protected TaxDirection vatTransactionDirection()
    {
        TaxLedgerAccountGroup taxLedgerAccountGroup;
        TaxTable taxTable;
        MainAccountNum ledgerJournalTransMainAccount;

        if (ledgerJournalTrans.TaxDirectionControl &&
            ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
        {
            changecompany(ledgerJournalTrans.Company)
            {
                switch (MainAccountLegalEntity::findByMainAccountLegalEntity(LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerJournalTrans.parmLedgerDimension()).RecId,
                                                                     CompanyInfo::current()).TaxDirection)
                {
                    case SalesPurch::Purch:
                        return TaxDirection::IncomingTax;

                    case SalesPurch::Sales:
                        return TaxDirection::OutgoingTax;
                }
            }
        }

        switch (ledgerJournalTrans.displayMainAccountType())
        {
            case LedgerJournalACType::Cust :
                if (ledgerJournalTrans.TransactionType == LedgerTransType::WriteOff && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoGB]))
                {
                    return TaxDirection::IncomingTax;
                }
                else
                {
                    return TaxDirection::OutgoingTax;
                }

            case LedgerJournalACType::Vend :
                return TaxDirection::IncomingTax;

            case LedgerJournalACType::Project:
                return TaxDirection::IncomingTax;

            case LedgerJournalACType::Ledger :
                taxTable = TaxTable::find(ledgerJournalTrans.TaxCode);
                if (taxTable)
                {
                    taxLedgerAccountGroup = TaxLedgerAccountGroup::find(taxTable.TaxAccountGroup, false);
                    if (taxLedgerAccountGroup)
                    {
                        ledgerJournalTransMainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerJournalTrans.LedgerDimension).MainAccountId;
                        if (LedgerDimensionFacade::getMainAccountFromLedgerDimension(taxLedgerAccountGroup.TaxIncomingLedgerDimension).MainAccountId == ledgerJournalTransMainAccount)
                        {
                            return TaxDirection::IncomingTax;
                        }
                        if (LedgerDimensionFacade::getMainAccountFromLedgerDimension(taxLedgerAccountGroup.TaxOutgoingLedgerDimension).MainAccountId == ledgerJournalTransMainAccount)
                        {
                            return TaxDirection::OutgoingTax;
                        }
                        if (LedgerDimensionFacade::getMainAccountFromLedgerDimension(taxLedgerAccountGroup.TaxUseTaxLedgerDimension).MainAccountId == ledgerJournalTransMainAccount)
                        {
                            return TaxDirection::UseTax;
                        }
                        if (LedgerDimensionFacade::getMainAccountFromLedgerDimension(taxLedgerAccountGroup.TaxOffsetUseTaxLedgerDimension).MainAccountId == ledgerJournalTransMainAccount)
                        {
                            return TaxDirection::UseTax;
                        }
                        return TaxDirection::TaxTransaction;
                    }
                }
        }
        return TaxDirection::TaxTransaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLineBeCalculated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the current line is eligible for tax calculations.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record to check.
    /// </param>
    /// <param name="_taxOnPrepayment">
    ///    true if the document is a payment and if the parameter tax on prepayments is enabled; otherwise, false.
    /// </param>
    /// <returns>
    ///    true if taxes can be calculated for the <c>LedgerJournalTrans</c> record; otherwise, false.
    /// </returns>
    public static boolean canLineBeCalculated(LedgerJournalTrans _ledgerJournalTrans, boolean _taxOnPrepayment)
    {
        LedgerJournalTaxLine ledgerJournalTaxLine = new LedgerJournalTaxLine(
            LedgerJournalTaxDocument::construct(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice),
            _ledgerJournalTrans,
            _taxOnPrepayment);

        if (ledgerJournalTaxLine.isPrimaryBeingCalculated() || ledgerJournalTaxLine.isOffsetBeingCalculated())
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVatTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the account type or the offset account type of the journal line is ledger and
    ///    whether a tax account exists based on the ledger account posting group for tax.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record that is being checked.
    /// </param>
    /// <returns>
    ///    true if one of the accounts is a ledger account and a tax account; otherwise, false.
    /// </returns>
    static boolean checkVatTransaction(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean                 ret;
        LedgerDimensionAccount  accountNum;
        CompanyId               companyId;
        // <GEERU>
        #isoCountryRegionCodes
        // </GEERU>

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
        {
            accountNum = _ledgerJournalTrans.LedgerDimension;
            companyId = _ledgerJournalTrans.Company;
        }
        else if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
        {
            accountNum = _ledgerJournalTrans.OffsetLedgerDimension;
            companyId = _ledgerJournalTrans.OffsetCompany;
        }

        if (!accountNum)
        {
            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) && _ledgerJournalTrans.isVatTaxAgentAuthorityPayment_RU())
            {
                ret = true;
            }
            else
            {
            // </GEERU>
                ret = checkFailed("@SYS67898");
            // <GEERU>
            }
            // </GEERU>
        }
        else
        {
            changecompany(companyId)
            {
                // <GIN>
                if (TaxParameters::checkTaxParameters_IN()
                    && (TaxTable::find(_ledgerJournalTrans.TaxCode).TaxType_IN != TaxType_IN::None))
                {
                    ret = true;
                }
                else
                {
                // </GIN>
                    ret = TaxLedgerAccountGroup::verifyVATAccountNum(accountNum,_ledgerJournalTrans.TaxCode);
                // <GIN>
                }
                // </GIN>
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs an instance of the <c>LedgerJournalTaxLine</c> class.
    /// </summary>
    /// <param name="_taxDocument">
    ///    The document that contains this tax line.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_taxOnPrepayment">
    ///    true if the document is a payment and if the parameter tax on prepayments is enabled; otherwise,
    ///    false.
    /// </param>
    /// <returns>
    ///    An instance of the <c>LedgerJournalTaxLine</c> class.
    /// </returns>
    public static LedgerJournalTaxLine construct(LedgerJournalTaxDocument _taxDocument, LedgerJournalTrans _ledgerJournalTrans, boolean _taxOnPrepayment)
    {
        return new LedgerJournalTaxLine(_taxDocument, _ledgerJournalTrans, _taxOnPrepayment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineInvoiceDate</Name>
				<Source><![CDATA[
    private TransDate determineInvoiceDate()
    {
        TransDate taxCalculationDate;
        switch (ledgerJournalTable.JournalType)
        {
            case LedgerJournalType::VendInvoiceRegister:
            case LedgerJournalType::PurchaseLedger:
            case LedgerJournalType::Approval:
                if (ledgerJournalTrans.DocumentDate && VendParameters::find().UseDocumentDate)
                {
                    taxCalculationDate = ledgerJournalTrans.DocumentDate;
                }
                else
                {
                    taxCalculationDate = ledgerJournalTrans.TransDate;
                }
                break;
            default:
                taxCalculationDate = this.defaultExchangeRateDate();
        }

        return taxCalculationDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldTaxSignKeepSameToLineAmountForApprovalJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the tax sign should keep same to the line amount of given approval journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The approval journal line.</param>
    /// <returns>true if tax sign should be same to the line amount; otherwise, false.</returns>
    private boolean shouldTaxSignKeepSameToLineAmountForApprovalJournal(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ret;

        if (TaxFlightingBase::isEnabled(TaxSignDependsProjectLedgerTypeApprovalJournalFlighting::keepTaxSignSameToLineAmountForApprovalJournalWithProjectAndLedgerType)
            && _ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Approval)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>