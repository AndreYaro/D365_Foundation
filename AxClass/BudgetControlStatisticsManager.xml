<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BudgetControlStatisticsManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>BudgetControlStatisticsManager</c> class manages budget control statistics inquiries.
/// </summary>
public class BudgetControlStatisticsManager
{
    BudgetControlConfiguration budgetControlConfiguration;
    BudgetTmpControlStatistics budgetTmpControlStatistics;

    // key : ledgertAccount + budget modelid + period option + fiscal year recid.
    // value: List containing BudgetPeriodBalance instance's for each of the periods/year
    // defined for the fiscal Calendar year/ fiscal calendar.
    Map budgetPeriodBalanceListCache;

    AmountMST accumulatedActualBudget;
    AmountMST accumulatedRevisedBudget;
    AmountMST accumulatedEncumbrances;
    AmountMST accumulatedPreEncumbrances;
    AmountMST accumulatedTotalBudgetFundsAvailable;

    AmountMST accumulatedApportionmentAmount;

    private const str notSign = '!';
    private const str comma = ',';

    private boolean isApportionmentBudgetEnabled;
    private boolean isPreliminaryBudgetEnabled;

    private BudgetControlIStatisticsViewType statisticsViewType;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addBudgetBudgetPeriodBalancesListToCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a list of instances of the <c>BudgetPeriodBalance</c> class to the cache.
    /// </summary>
    /// <param name="_primaryLedgerRecId">
    /// The ID for the primary <c>Ledger</c> record to use as part of the key for the budget control
    /// statistics cache.
    /// </param>
    /// <param name="_budgetModelId">
    /// A budget model ID to use as part of the key for the budget control statistics cache.
    /// </param>
    /// <param name="_periodOption">
    /// A <c>BudgetControlStatisticsPeriodOption</c> enumeration value to use as part of the key for the
    /// budget control statistics cache.
    /// </param>
    /// <param name="_budgetCycleRecId">
    /// The record ID of the selected budget cycle to use as part of the key for the budget control
    /// statistics cache.
    /// </param>
    /// <param name="_budgetPeriodBalances">
    /// A list of instances of the <c>BudgetPeriodBalance</c> class that must be added to the cache if they
    /// are not already present.
    /// </param>
    /// <param name="_ledgerDimensionBudgetControl">
    /// A <c>LedgerDimensionBudgetControl</c> value to use as part of the key for the budget control
    /// statistics cache; optional.
    /// </param>
    /// <param name="_budgetGroupRecId">
    /// The record ID of the selected budget group to use as part of the key for the budget control
    /// statistics cache; optional.
    /// </param>
    /// <param name="_mainAccountRecId">
    /// A record ID of the main account to use as part of the key for the budget control statistics cache;
    /// optional.
    /// </param>
    /// <param name="_includeAllAccounts">
    /// A Boolean value that indicates whether to include all the main accounts for the specified ledger
    /// dimension; optional.
    /// </param>
    /// <param name="_includeCarryForward">
    /// A Boolean value that indicates whether to include the carry forward amount for the specified ledger
    /// dimension; optional.
    /// </param>
    /// <remarks>
    /// This method adds the list of <c>BudgetPeriodBalance</c> objects to the cache if they are not in the
    /// cache.
    /// </remarks>
    protected void addBudgetBudgetPeriodBalancesListToCache(recId _primaryLedgerRecId,
                                                            BudgetModelId _budgetModelId,
                                                            BudgetControlStatisticsPeriodOption _periodOption,
                                                            recId   _budgetCycleRecId,
                                                            List _budgetPeriodBalances,
                                                            LedgerDimensionBudgetControl _ledgerDimensionBudgetControl = 0,
                                                            recId   _budgetGroupRecId = 0,
                                                            recId _mainAccountRecId = 0,
                                                            boolean _includeAllAccounts = true,
                                                            boolean _includeCarryForward = false)
    {
        str cacheKey = this.getCacheKey(
            _primaryLedgerRecId,
            _budgetModelId,
            _periodOption,
            _budgetCycleRecId,
            _ledgerDimensionBudgetControl,
            _budgetGroupRecId,
            _mainAccountRecId,
            _includeAllAccounts,
            _includeCarryForward);

        // Insert the period balance list to add it to the cache or update the existing cache for the cache key.
        budgetPeriodBalanceListCache.insert(cacheKey, _budgetPeriodBalances);
    }

]]></Source>
			</Method>
			<Method>
				<Name>apportionmentBudgetStatisticsAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the apportionment <c>AmountMST</c> aggregation based on the <c>BudgetParameters</c> table.
    /// </summary>
    /// <param name="_budgetTmpControlStatistics">
    /// A <c>BudgetTmpControlStatistics</c> table buffer which is used in calculation of <c>AmountMST</c>.
    /// </param>
    /// <returns>
    /// An aggregated <c>AmountMST</c> that is used as a part in Budget remaining amount calculation.
    /// </returns>
    /// <remarks>
    /// This method aggregates the <c>AmountMST</c> in supplied <c>BudgetTmpControlStatistics</c> buffer
    /// based on the <c>Apportionment</c> budget parameter values.
    /// </remarks>
    private AmountMST apportionmentBudgetStatisticsAmount(BudgetTmpControlStatistics _budgetTmpControlStatistics)
    {
        AmountMST apportionmentBudgetAmount;

        if (budgetControlConfiguration.UseApportionedAmount)
        {
            apportionmentBudgetAmount += _budgetTmpControlStatistics.ApportionmentAmountMST;
        }

        return apportionmentBudgetAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyBudgetPeriodBalanceToTmpTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instance of the <c>BudgetPeriodBalance</c> class and copies the aggregated <c>AmountMST</c>
    /// values to a <c>BudgetTmpControlStatistics</c> buffer.
    /// </summary>
    /// <param name="_budgetPeriodBalance">
    /// An instance of the <c>BudgetPeriodBalance</c> class that acts a source for a
    /// <c>BudgetTmpControlStatistics</c> buffer.
    /// </param>
    /// <returns>
    /// A <c>BudgetTmpControlStatistics</c> table buffer that contains all of the aggregated
    /// <c>AmountMST</c> values set in their respective fields.
    /// </returns>
    /// <remarks>
    /// This method copies all of the aggregated <c>AmountMST</c> values from an instance of the
    /// <c>BudgetPeriodBalance</c> class to the <c>BudgetTmpControlStatistics</c> table buffer.
    /// </remarks>
    protected BudgetTmpControlStatistics copyBudgetPeriodBalanceToTmpTable(BudgetPeriodBalance _budgetPeriodBalance)
    {
        budgetTmpControlStatistics.PeriodStartDate = _budgetPeriodBalance.parmStartDate();
        budgetTmpControlStatistics.PeriodEndDate = _budgetPeriodBalance.parmEndDate();

        budgetTmpControlStatistics.OriginalBudgetAmountMST = _budgetPeriodBalance.parmOriginalBudgetMST();
        budgetTmpControlStatistics.ActualAmountMST = _budgetPeriodBalance.parmActualAmountMST();
        budgetTmpControlStatistics.AmendmentAmountMST = _budgetPeriodBalance.parmAmendmentAmountMST();
        budgetTmpControlStatistics.EncumbranceAmountMST = _budgetPeriodBalance.parmEncumbranceAmountMST();
        budgetTmpControlStatistics.PreEncumbranceAmountMST = _budgetPeriodBalance.parmPreEncumbranceAmountMST();
        budgetTmpControlStatistics.CarryForwardBudgetAmountMST = _budgetPeriodBalance.parmCarryForwardBudgetAmountMST();
        budgetTmpControlStatistics.TransferAmountMST = _budgetPeriodBalance.parmTransferAmountMST();

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            budgetTmpControlStatistics.ApportionmentAmountMST = _budgetPeriodBalance.parmApportionmentAmountMST();
            budgetTmpControlStatistics.PreliminaryAmountMST = _budgetPeriodBalance.parmPreliminaryAmountMST();
        }

        budgetTmpControlStatistics.CarryForwardActualExpenditureAmountMST = _budgetPeriodBalance.parmCarryForwardActualAmountMST();
        budgetTmpControlStatistics.CarryForwardEncumbranceAmountMST = _budgetPeriodBalance.parmCarryForwardEncumbranceAmountMST();
        budgetTmpControlStatistics.DraftEncumbranceReductionAmountMST = _budgetPeriodBalance.parmDraftEncumbranceReductionAmountMST();

        budgetTmpControlStatistics.UnpostedActualAmountMST = _budgetPeriodBalance.parmUnpostedActualAmountMST();
        budgetTmpControlStatistics.UnpostedCarryForwardActualAmountMST = _budgetPeriodBalance.parmUnpostedCarryForwardActualAmountMST();
        budgetTmpControlStatistics.DraftAmendmentAmountMST = _budgetPeriodBalance.parmDraftAmendmentAmountMST();
        budgetTmpControlStatistics.DraftEncumbranceAmountMST = _budgetPeriodBalance.parmDraftEncumbranceAmountMST();
        budgetTmpControlStatistics.DraftPreEncumbranceAmountMST = _budgetPeriodBalance.parmDraftPreEncumbranceAmountMST();
        budgetTmpControlStatistics.DraftTransferInAmountMST = _budgetPeriodBalance.parmDraftTransferInAmountMST();
        budgetTmpControlStatistics.DraftTransferOutAmountMST = _budgetPeriodBalance.parmDraftTransferOutAmountMST();

        budgetTmpControlStatistics.EncumbranceReliefAmountMST = _budgetPeriodBalance.parmEncumbranceReliefAmountMST();
        budgetTmpControlStatistics.PreEncumbranceReliefAmountMST = _budgetPeriodBalance.parmPreEncumbranceReliefAmountMST();
        budgetTmpControlStatistics.CarryForwardEncumbranceReliefAmountMST = _budgetPeriodBalance.parmCarryForwardEncumbReliefAmountMST();
        budgetTmpControlStatistics.EncumbranceReductionReliefAmountMST = _budgetPeriodBalance.parmEncumbranceReductionReliefAmountMST();

        budgetTmpControlStatistics.DraftCarryForwardEncumbranceAmtMST = _budgetPeriodBalance.parmDraftCarryForwardEncumbranceAmtMST();
        budgetTmpControlStatistics.DraftCFEncumbranceReductionAmtMST = _budgetPeriodBalance.parmDraftCFEncumbranceReductionAmtMST();

        budgetTmpControlStatistics.BudgetModel = _budgetPeriodBalance.parmBudgetModelId();
        return budgetTmpControlStatistics;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillBudgetTmpControlStatistics</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills the <c>BudgetTmpControlStatistics</c> table buffer with the aggregated <c>AmountMST</c>
    /// values that are present in an instance of the <c>BudgetPeriodBalance</c> class.
    /// </summary>
    /// <param name="_primaryLedgerRecId">
    /// The record ID of for the primary ledger record for which to obtain the budget control statistics
    /// inquiry data.
    /// </param>
    /// <param name="_budgetModelId">
    /// The budget model ID for which to obtain the budget control statistics inquiry data.
    /// </param>
    /// <param name="_periodOption">
    /// A <c>BudgetControlStatisticsPeriodOption</c> value for which to obtain the period start dates and
    /// end dates.
    /// </param>
    /// <param name="_balanceType">
    /// A <c>BudgetControlStatisticsBalanceType</c> value for which to calculate the <c>AmountMST</c>
    /// values for each period.
    /// </param>
    /// <param name="_budgetCycleRecId">
    /// The record ID of the selected budget cycle.
    /// </param>
    /// <param name="_ledgerDimensionBudgetControl">
    /// A <c>LedgerDimensionBudgetControl</c> value for which to obtain the budget control statistics
    /// inquiry data; optional.
    /// </param>
    /// <param name="_budgetGroupRecId">
    /// The record ID of the budget group for which to obtain the budget control statistics inquiry data;
    /// optional.
    /// </param>
    /// <param name="_mainAccountRecId">
    /// The record ID of the main account to use as an additional filter on the ledger dimension value to
    /// calculate amounts; optional.
    /// </param>
    /// <param name="_includeAllAccounts">
    /// A Boolean value that indicates whether to include all the main accounts for the specified ledger
    /// dimension; optional.
    /// </param>
    /// <param name="_includeCarryforward">
    /// A <c>NoYes</c> enumeration value that specifies whether to include the carry forward amount in
    /// amount calculation; optional.
    /// </param>
    /// <param name="_getBudgetPeriodBalanceFromCache">
    /// A Boolean value that indicates whether the budget period balances can be obtained from cache;
    /// optional.
    /// </param>
    /// <returns>
    /// A <c>BudgetTmpControlStatistics</c> table buffer.
    /// </returns>
    public BudgetTmpControlStatistics fillBudgetTmpControlStatistics(recId _primaryLedgerRecId,
                                                                    BudgetModelId _budgetModelId,
                                                                    BudgetControlStatisticsPeriodOption _periodOption,
                                                                    BudgetControlStatisticsBalanceType _balanceType,
                                                                    recId _budgetCycleRecId,
                                                                    LedgerDimensionBudgetControl _ledgerDimensionBudgetControl = 0,
                                                                    recId _budgetGroupRecId = 0,
                                                                    recId _mainAccountRecId = 0,
                                                                    boolean _includeAllAccounts = true,
                                                                    NoYes _includeCarryforward = NoYes::No,
                                                                    boolean _getBudgetPeriodBalanceFromCache = true)

    {
        List budgetPeriodBalancesList = new List(Types::Class);
        ListEnumerator enumerator;
        BudgetPeriodBalance budgetPeriodBalance;
        budgetTmpControlStatistics = null;

        if (_getBudgetPeriodBalanceFromCache)
        {
            budgetPeriodBalancesList = this.getBudgetPeriodBalancesFromCache(_primaryLedgerRecId,
                                                                             _budgetModelId,
                                                                             _periodOption,
                                                                             _budgetCycleRecId,
                                                                             _ledgerDimensionBudgetControl,
                                                                             _budgetGroupRecId,
                                                                             _mainAccountRecId,
                                                                             _includeAllAccounts,
                                                                             _includeCarryforward);
        }
        else
        {
            // Reset the cache before getting the balance data.
            this.initializeBudgetPeriodBalanceListCache();
        }

        if (budgetPeriodBalancesList.elements() <= 0)
        {
            // If the key is not present in the cache then
            // the getBudgetControlStatisticsData(parameters) is called with required parameters to get the
            // list containing BudgetPeriodBalance instances with aggregated AmountMST.
            budgetPeriodBalancesList = this.getBudgetControlStatisticsData(_primaryLedgerRecId,
                                                                             _budgetModelId,
                                                                             _periodOption,
                                                                             _budgetCycleRecId,
                                                                             _ledgerDimensionBudgetControl,
                                                                             _budgetGroupRecId,
                                                                             _mainAccountRecId,
                                                                             _includeAllAccounts);

            // The obtained list is added to the cache.
            this.addBudgetBudgetPeriodBalancesListToCache(_primaryLedgerRecId,
                                                            _budgetModelId,
                                                            _periodOption,
                                                            _budgetCycleRecId,
                                                            budgetPeriodBalancesList,
                                                            _ledgerDimensionBudgetControl,
                                                            _budgetGroupRecId,
                                                            _mainAccountRecId,
                                                            _includeAllAccounts,
                                                            _includeCarryforward);
        }

        if (budgetPeriodBalancesList.elements() == 0)
        {
            // When there is no budget control statistics inquiry data, then add a BudgetPeriodBalance instance in order to show '0' for all the amounts.
            budgetPeriodBalance = new BudgetPeriodBalance();
            budgetPeriodBalancesList.addEnd(budgetPeriodBalance);
        }

        // delete the contents of the BudgetTmpControlStatistics table.
        delete_from budgetTmpControlStatistics;

        enumerator = budgetPeriodBalancesList.getEnumerator();

        this.resetAccumulatedValues();

        while (enumerator.moveNext())
        {
            budgetPeriodBalance = enumerator.current();

            budgetTmpControlStatistics = this.copyBudgetPeriodBalanceToTmpTable(budgetPeriodBalance);
            budgetTmpControlStatistics.PrimaryLedger = _primaryLedgerRecId;
            budgetTmpControlStatistics.BudgetModelSubModel = _budgetModelId;
            budgetTmpControlStatistics.BudgetModelType = HeadingSub::Heading;
            budgetTmpControlStatistics.BudgetControlLedgerDimension = _ledgerDimensionBudgetControl;
            budgetTmpControlStatistics.MainAccount = _mainAccountRecId;
            budgetTmpControlStatistics.IncludeAllAccounts = (_includeAllAccounts == true? NoYes::Yes : NoYes::No);
            budgetTmpControlStatistics.IncludeCarryforward = (_includeCarryforward == true? NoYes::Yes : NoYes::No);
            budgetTmpControlStatistics.BudgetCycle = _budgetCycleRecId;
            budgetTmpControlStatistics.BudgetGroup = _budgetGroupRecId;
            this.setBudgetTmpControlStatisticsAmount(budgetTmpControlStatistics, _balanceType);

            budgetTmpControlStatistics.insert();
        }

        return budgetTmpControlStatistics;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetAvailableExpression</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Budget available expression by calling the <c>budgetFundsAvailalbleCalculationText</c>
    /// method in the <c>BudgetParameters</c> table.
    /// </summary>
    public str getBudgetAvailableExpression()
    {
        return budgetControlConfiguration.budgetFundsAvailableCalculationText();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetControlStatisticsData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the list that contains the instances of the <c>BudgetPeriodBalance</c> class.
    /// </summary>
    /// <param name="_primaryLedgerRecId">
    ///    The ID for the primary ledger record for which to obtain the budget control statistics inquiry data.
    /// </param>
    /// <param name="_budgetModelId">
    ///    A budget model ID for which to obtain the budget control statistics inquiry data.
    /// </param>
    /// <param name="_periodOption">
    ///    A <c>BudgetControlStatisticsPeriodOption</c> value for which to obtain the period start dates and
    ///    end dates.
    /// </param>
    /// <param name="_budgetCycleRecId">
    ///    The record ID of the selected budget cycle.
    /// </param>
    /// <param name="_ledgerDimensionBudgetControl">
    ///    A <c>LedgerDimensionBudgetControl</c> value for which to obtain the budget control statistics
    ///    inquiry data.
    /// </param>
    /// <param name="_budgetGroupRecId">
    ///    The record ID of the budget group for which to obtain the budget control statistics inquiry data.
    /// </param>
    /// <param name="_mainAccountRecId">
    ///    The record ID of the main account to use as an additional filter on the ledger dimension value to
    ///    calculate amounts.
    /// </param>
    /// <param name="_includeAllAccounts">
    ///    A Boolean value that indicates whether to include all the main accounts for the ledger dimension.
    /// </param>
    /// <returns>
    ///    A list that contains instances of the <c>BudgetPeriodBalance</c> class that contain all the
    ///    aggregated <c>AmountMST</c> values.
    /// </returns>
    protected List getBudgetControlStatisticsData(recId _primaryLedgerRecId,
                                                BudgetModelId _budgetModelId,
                                                BudgetControlStatisticsPeriodOption _periodOption,
                                                recId _budgetCycleRecId,
                                                LedgerDimensionBudgetControl _ledgerDimensionBudgetControl = 0,
                                                recId _budgetGroupRecId = 0,
                                                recId _mainAccountRecId = 0,
                                                boolean _includeAllAccounts = true)
    {
        List                            budgetBalancesList = new List(Types::Class);
        BudgetPeriodBalance             budgetPeriodBalance;
        BudgetAvailableBalanceGroup     budgetAvailableBalanceGroup;

        BudgetModel                     budgetModel;
        BudgetCycle                     budgetCycle;
        BudgetCycleTimeSpan             budgetCycleTimeSpan;

        boolean                         includeDefaultBudgetModel = true;

        BudgetControlBudgetCycle        budgetControlBudgetCycle;
        FiscalCalendarYear              fiscalCalendarYear;
        FiscalCalendarPeriod            fiscalCalendarPeriod;

        StartDate                       periodStartDate;
        EndDate                         periodEndDate;

        BudgetAvailableBalanceLedgerDimension budgetAvailableLedgerDim;

        void getBudgetPeriodBalancesByFiscalPeriod()
        {
            budgetCycle = BudgetCycle::find(_budgetCycleRecId);

            budgetCycleTimeSpan = BudgetCycleTimeSpan::find(budgetCycle.BudgetCycleTimeSpan);

            // Get the first FiscalCalendarPeriod in the BudgetCycle
            periodStartDate = budgetCycle.getStartDate();
            periodEndDate = budgetCycle.getEndDate();

            while select StartDate, EndDate
                from fiscalCalendarPeriod
                order by fiscalCalendarPeriod.StartDate
                exists join fiscalCalendarYear where fiscalCalendarYear.RecId == fiscalCalendarPeriod.FiscalCalendarYear &&
                    fiscalCalendarYear.FiscalCalendar == budgetCycleTimeSpan.FiscalCalendar &&
                    fiscalCalendarPeriod.StartDate >= periodStartDate &&
                    fiscalCalendarPeriod.EndDate <= periodEndDate&&
                    fiscalCalendarPeriod.Type == FiscalPeriodType::Operating
            {
                periodStartDate = fiscalCalendarPeriod.StartDate;
                periodEndDate = fiscalCalendarPeriod.EndDate;

                if (_ledgerDimensionBudgetControl != 0)
                {
                    budgetAvailableLedgerDim = BudgetAvailableBalanceLedgerDimension::construct(_primaryLedgerRecId, _ledgerDimensionBudgetControl, periodStartDate, periodEndDate);
                    budgetPeriodBalance = budgetAvailableLedgerDim.getBudgetControlCategorySumAll(budgetModel, includeDefaultBudgetModel, _mainAccountRecId, _includeAllAccounts);
                }
                else
                {
                    budgetAvailableBalanceGroup = BudgetAvailableBalanceGroup::construct(_primaryLedgerRecId, _budgetGroupRecId, periodStartDate, periodEndDate);
                    budgetPeriodBalance = budgetAvailableBalanceGroup.getBudgetControlCategorySumAll(budgetModel, includeDefaultBudgetModel, _mainAccountRecId, _includeAllAccounts);
                }

                budgetPeriodBalance.parmBudgetModelId(budgetModel.ModelId);
                budgetBalancesList.addEnd(budgetPeriodBalance);
            }
        }

        void getBudgetPeriodBalancesByBudgetCycle()
        {
            budgetCycle = BudgetCycle::find(_budgetCycleRecId);

            budgetCycleTimeSpan = BudgetCycleTimeSpan::find(budgetCycle.BudgetCycleTimeSpan);

            // Get the first FiscalCalendarPeriod in the BudgetCycle
            periodStartDate = budgetCycle.getStartDate();
            periodEndDate = budgetCycle.getEndDate();

            if (_ledgerDimensionBudgetControl != 0)
            {
                budgetAvailableLedgerDim = BudgetAvailableBalanceLedgerDimension::construct(_primaryLedgerRecId, _ledgerDimensionBudgetControl, periodStartDate, periodEndDate);
                budgetPeriodBalance = budgetAvailableLedgerDim.getBudgetControlCategorySumAll(budgetModel, includeDefaultBudgetModel, _mainAccountRecId, _includeAllAccounts);
            }
            else
            {
                budgetAvailableBalanceGroup = BudgetAvailableBalanceGroup::construct(_primaryLedgerRecId, _budgetGroupRecId, periodStartDate, periodEndDate);
                budgetPeriodBalance = budgetAvailableBalanceGroup.getBudgetControlCategorySumAll(budgetModel, includeDefaultBudgetModel, _mainAccountRecId, _includeAllAccounts);
            }

            budgetPeriodBalance.parmBudgetModelId(budgetModel.ModelId);
            budgetBalancesList.addEnd(budgetPeriodBalance);
        }

        if (hasTableAccess(tablenum(CompanyInfo)) &&
            hasTableAccess(tablenum(MainAccount)) &&
            hasTableAccess(tablenum(BudgetModel)) &&
            hasTableAccess(tablenum(BudgetCycleTimeSpan)) &&
            hasTableAccess(tablenum(FiscalCalendarPeriod)) &&
            hasTableAccess(tablenum(FiscalCalendarYear)) &&
            hasTableAccess(tablenum(BudgetControlConfiguration)) &&
            hasTableAccess(tablenum(BudgetCycleTimeSpan)) &&
            hasTableAccess(tablenum(BudgetControlBudgetCycle)) &&
            hasTableAccess(tablenum(BudgetCycle)))
        {
            budgetModel = BudgetModel::find(HeadingSub::Heading, _budgetModelId);

            select firstonly RecId from budgetControlBudgetCycle
                where budgetControlBudgetCycle.BudgetModelId == budgetModel.ModelId
                    && budgetControlBudgetCycle.BudgetModelSubModelId == budgetModel.SubModelId
                    && budgetControlBudgetCycle.BudgetModelType == budgetModel.Type
                    && budgetControlBudgetCycle.BudgetModelDataAreaId == budgetModel.DataAreaId
                    && budgetControlBudgetCycle.BudgetControlConfiguration == BudgetControlConfiguration::findActiveByPrimaryLedger(_primaryLedgerRecId).RecId;

            if ((budgetModel.RecId != 0) && (budgetControlBudgetCycle.RecId != 0))
            {
                // Account budget model is available for budget control.
                switch (_periodOption)
                {
                    case BudgetControlStatisticsPeriodOption::FiscalPeriod:
                        getBudgetPeriodBalancesByFiscalPeriod();
                        break;

                    case BudgetControlStatisticsPeriodOption::BudgetCycle:
                        getBudgetPeriodBalancesByBudgetCycle();
                        break;

                    default:
                        // Not implemented.
                        Debug::assert(false);
                        break;
                }
            }
        }

        return budgetBalancesList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetControlStatisticsDataForReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list that contains instances of the <c>BudgetPeriodBalance</c> class.
    /// </summary>
    /// <param name="_primaryLedgerRecId">
    /// The ID for the primary <c>Ledger</c> record for which the budget control statistics inquiry data
    /// will be obtained.
    /// </param>
    /// <param name="_ledgerDimension">
    /// A <c>LedgerDimensionBudgetControl</c> value for which the budget control statistics inquiry data
    /// will be obtained.
    /// </param>
    /// <param name="_budgetCycleTimeSpan">
    /// The record ID of the selected budget cycle time span for which the budget funds available report
    /// will be obtained.
    /// </param>
    /// <param name="_fiscalPeriodStartDate">
    /// A <c>FiscalPeriodStart</c> value which is used to get the starting fiscal calendar period.
    /// </param>
    /// <param name="_fiscalPeriodEndDate">
    /// A <c>FiscalPeriodEnd</c> value which is used to get the ending fiscal calendar period.
    /// </param>
    /// <param name="_sysQuery">
    /// A query that gives information about the dynamic ranges set using an advanced filter; optional.
    /// </param>
    /// <returns>
    /// A list that contains instances of the <c>BudgetPeriodBalance</c> class that contain all of the
    /// aggregated <c>AmountMST</c> values.
    /// </returns>
    protected List getBudgetControlStatisticsDataForReport(recId _primaryLedgerRecId,
                                                        LedgerDimensionBudgetControl _ledgerDimension,
                                                        RefRecId _budgetCycleTimeSpan,
                                                        FiscalPeriodStart _fiscalPeriodStartDate,
                                                        FiscalPeriodEnd _fiscalPeriodEndDate,
                                                        Query _sysQuery = null)
    {
        QueryBuildDataSource        budgetModel_qbds;
        QueryBuildDataSource        budgetSourceTracking_qbds;
        QueryBuildDataSource        budgetSourceTrackingSysQuery_qbds;
        QueryBuildRange             budgeModel_qbdr;
        Query                       queryBudgetModel;
        QueryRun                    queryRun;
        QueryFilter                 queryFilter;
        QueryFilter                 budgetModelQueryFilter;

        BudgetModel                 budgetModel;
        BudgetPeriodBalance         budgetPeriodBalance;

        FiscalCalendarYear          fiscalCalendarYear;
        FiscalCalendarPeriod        fiscalCalendarPeriod;
        recId                       fiscalCalendarRecId;

        BudgetCycleTimeSpan         budgetCycleTimeSpan;
        BudgetCycle                 budgetCycle;
        StartDate                   budgetCycleStartDate;
        EndDate                     budgetCycleEndDate;
        List                        budgetBalancesList = new List(Types::Class);

        BudgetAvailableBalanceLedgerDimension budgetAvailableLedgerDim;

        void getPeriodBalancesForDates()
        {
            while select StartDate, EndDate
                    from fiscalCalendarPeriod
                    order by fiscalCalendarPeriod.StartDate
                    exists join fiscalCalendarYear
                        where fiscalCalendarYear.RecId == fiscalCalendarPeriod.FiscalCalendarYear
                            && fiscalCalendarYear.FiscalCalendar == fiscalCalendarRecId
                            && fiscalCalendarPeriod.StartDate >= budgetCycleStartDate
                            && fiscalCalendarPeriod.EndDate <= budgetCycleEndDate
                            && fiscalCalendarPeriod.Type == FiscalPeriodType::Operating
            {
                budgetAvailableLedgerDim = BudgetAvailableBalanceLedgerDimension::construct(_primaryLedgerRecId, _ledgerDimension, fiscalCalendarPeriod.StartDate, fiscalCalendarPeriod.EndDate);
                budgetPeriodBalance = budgetAvailableLedgerDim.getBudgetControlCategorySumAll(budgetModel, true, 0, false, _sysQuery);
                budgetPeriodBalance.parmBudgetModelId(budgetModel.ModelId);
                budgetBalancesList.addEnd(budgetPeriodBalance);
            }
        }

        void getPeriodBalancesForAllBudgetCycles()
        {
            // Generate the set of period balance records for each BudgetCycle in the specified BudgetCycleTimeSpan.

            while select StartFiscalCalendarPeriod, EndFiscalCalendarPeriod from budgetCycle
                where budgetCycle.BudgetCycleTimeSpan == _budgetCycleTimeSpan
            {
                budgetCycleStartDate = budgetCycle.getStartDate();
                budgetCycleEndDate = budgetCycle.getEndDate();
                getPeriodBalancesForDates();
            }
        }

        queryBudgetModel = new Query();

        if (hasTableAccess(tablenum(CompanyInfo)) &&
            hasTableAccess(tablenum(BudgetModel)) &&
            hasTableAccess(tablenum(FiscalCalendarYear)) &&
            hasTableAccess(tablenum(BudgetSourceTracking)) &&
            hasTableAccess(tablenum(BudgetSourceTrackingDetail)) &&
            hasTableAccess(tablenum(FiscalCalendarPeriod)) &&
            hasTableAccess(tablenum(BudgetControlConfiguration)) &&
            hasTableAccess(tablenum(BudgetCycleTimeSpan)) &&
            hasTableAccess(tablenum(BudgetControlBudgetCycle)) &&
            hasTableAccess(tablenum(BudgetCycle)))
        {
            budgetModel_qbds = queryBudgetModel.addDataSource(tablenum(BudgetModel));
            budgetModel_qbds.addRange(fieldnum(BudgetModel, Type)).value(SysQuery::value(enum2int(HeadingSub::Heading)));

            // Add a join to the query for BudgetModel records that ensures the BudgetModel is used in at least one BudgetSourceTracking record.
            budgetSourceTracking_qbds = budgetModel_qbds.addDataSource(tablenum(BudgetSourceTracking));
            budgetSourceTracking_qbds.relations(true);
            budgetSourceTracking_qbds.joinMode(JoinMode::ExistsJoin);

            budgetCycleTimeSpan = BudgetCycleTimeSpan::find(_budgetCycleTimeSpan);
            fiscalCalendarRecId = FiscalCalendar::find(budgetCycleTimeSpan.FiscalCalendar).RecId;
            budgetCycleStartDate = _fiscalPeriodStartDate;
            budgetCycleEndDate = _fiscalPeriodEndDate;

            if (_sysQuery != null)
            {
                // Get the range on budget model if specified as part of dynamic sys query from parameter form.
                // otherwise, calculate statistics data for all budget models.
                budgetSourceTrackingSysQuery_qbds = _sysQuery.dataSourceTable(tablenum(BudgetSourceTracking));
                budgeModel_qbdr = budgetSourceTrackingSysQuery_qbds.findRange(fieldnum(BudgetSourceTracking, BudgetModelId));
                queryFilter = _sysQuery.findQueryFilter(budgetSourceTrackingSysQuery_qbds, fieldStr(BudgetSourceTracking, BudgetModelId));

                if (queryFilter && queryFilter.value())
                {
                    // When there is a budget model filter present in the sysquery.
                    budgetModelQueryFilter = queryBudgetModel.addQueryFilter(budgetModel_qbds, fieldStr(BudgetModel, ModelId));
                    budgetModelQueryFilter.value(queryFilter.value());
                }
                else if (budgeModel_qbdr != null && budgeModel_qbdr.value() != '')
                {
                    // When there is a budget model range present in the sysquery.
                    budgetModel_qbds.addRange(fieldnum(BudgetModel, ModelId)).value(budgeModel_qbdr.value());
                }
            }

            queryRun = new QueryRun(queryBudgetModel);

            while (queryRun.next())
            {
                budgetModel = queryRun.get(tablenum(BudgetModel));

                if (_fiscalPeriodStartDate != dateNull() && _fiscalPeriodEndDate != dateNull())
                {
                    // Start and end dates were specified; generate the period records for that date range.
                    getPeriodBalancesForDates();
                }
                else
                {
                    // No dates and no budget cycle has been specified. Include the dates from all budget cycles for the specified budget cycle time span.
                    getPeriodBalancesForAllBudgetCycles();
                }
            }
        }

        return budgetBalancesList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetPeriodBalancesFromCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list that contains instances of the <c>BudgetPeriodBalance</c> class from the cache.
    /// </summary>
    /// <param name="_primaryLedgerRecId">
    /// The record ID of the primary <c>Ledger</c> record to use as part of the key for the budget control
    /// statistics cache.
    /// </param>
    /// <param name="_budgetModelId">
    /// A budget model ID to use as part of the key for the budget control statistics cache.
    /// </param>
    /// <param name="_periodOption">
    /// A <c>BudgetControlStatisticsPeriodOption</c> value to use as part of the key for the budget control
    /// statistics cache.
    /// </param>
    /// <param name="_budgetCycleRecId">
    /// The record ID of the selected budget cycle to use as part of the key for the budget control
    /// statistics cache.
    /// </param>
    /// <param name="_ledgerDimensionBudgetControl">
    /// A <c>LedgerDimensionBudgetControl</c> value to use as part of the key for the budget control
    /// statistics cache; optional.
    /// </param>
    /// <param name="_budgetGroupRecId">
    /// The record ID of the selected budget group to use as a part of the key for the budget control
    /// statistics cache; optional.
    /// </param>
    /// <param name="_mainAccountRecId">
    /// The record ID of the main account to use to use as part of the key for the budget control
    /// statistics cache; optional.
    /// </param>
    /// <param name="_includeAllAccounts">
    /// A Boolean value that indicates whether to include all the main accounts of the ledger dimension;
    /// optional.
    /// </param>
    /// <param name="_includeCarryForward">
    /// A Boolean value that indicates whether to include the carry forward amount for the specified ledger
    /// dimension; optional.
    /// </param>
    /// <returns>
    /// A list that contains instances of the <c>BudgetPeriodBalance</c> class that contain all of the
    /// aggregated <c>AmountMST</c> values.
    /// </returns>
    /// <remarks>
    /// This method retrieves the list of instances of the <c>BudgetPeriodBalance</c> class from the cache
    /// if they are in the cache.
    /// </remarks>
    private List getBudgetPeriodBalancesFromCache(recId _primaryLedgerRecId,
                                                BudgetModelId _budgetModelId,
                                                BudgetControlStatisticsPeriodOption _periodOption,
                                                recId   _budgetCycleRecId,
                                                LedgerDimensionBudgetControl _ledgerDimensionBudgetControl = 0,
                                                recId   _budgetGroupRecId = 0,
                                                recId _mainAccountRecId = 0,
                                                boolean _includeAllAccounts = true,
                                                boolean _includeCarryForward = false)
    {
        List budgetPeriodBalances = new List(Types::Class);

        str cacheKey = this.getCacheKey(
            _primaryLedgerRecId,
            _budgetModelId,
            _periodOption,
            _budgetCycleRecId,
            _ledgerDimensionBudgetControl,
            _budgetGroupRecId,
            _mainAccountRecId,
            _includeAllAccounts,
            _includeCarryForward);

        if (budgetPeriodBalanceListCache.exists(cacheKey))
        {
            budgetPeriodBalances = budgetPeriodBalanceListCache.lookup(cacheKey);
        }

        return budgetPeriodBalances;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCacheKey</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the cache key to access the <c>BudgetPeriodBalance</c> objects cache.
    /// </summary>
    /// <param name="_primaryLedgerRecId">
    ///    The ID of the primary <c>Ledger</c> record to use as part of the key for the budget control
    ///    statistics cache.
    /// </param>
    /// <param name="_modelId">
    ///    A budget model ID to use as part of the key for the budget control statistics cache.
    /// </param>
    /// <param name="_periodOption">
    ///    A <c>BudgetControlStatisticsPeriodOption</c> enumeration value to use as part of the key for the
    ///    budget control statistics cache.
    /// </param>
    /// <param name="_budgetCycleRecId">
    ///    The record ID of the selected budget cycle.
    /// </param>
    /// <param name="_ledgerDimensionBudgetControl">
    ///    A <c>LedgerDimensionBudgetControl</c> value for which to obtain the budget control statistics
    ///    inquiry data.
    /// </param>
    /// <param name="_budgetGroupRecId">
    ///    A record ID of the budget group for which to obtain the budget control statistics inquiry data.
    /// </param>
    /// <param name="_mainAccountRecId">
    ///    The record ID of the main account to use as part of the key for the budget control statistics cache.
    /// </param>
    /// <param name="_includeAllAccounts">
    ///    A Boolean value that indicates whether to include all the main accounts for the specified ledger
    ///    dimension.
    /// </param>
    /// <param name="_includeCarryForward">
    ///    A Boolean value that indicates whether to include the carry forward amount for the specified ledger
    ///    dimension.
    /// </param>
    /// <returns>
    ///    The cache key to use to access the <c>BudgetPeriodBalance</c> objects cache.
    /// </returns>
    protected str getCacheKey(recId _primaryLedgerRecId,
                            BudgetModelId _modelId,
                            BudgetControlStatisticsPeriodOption _periodOption,
                            recId   _budgetCycleRecId,
                            LedgerDimensionBudgetControl _ledgerDimensionBudgetControl,
                            recId   _budgetGroupRecId,
                            recId   _mainAccountRecId,
                            boolean _includeAllAccounts,
                            boolean _includeCarryForward)
    {
        return strfmt('%1%2%3%4%5%6%7%8',
                    _primaryLedgerRecId,
                    _modelId,
                    _periodOption,
                    _budgetCycleRecId,
                    _ledgerDimensionBudgetControl,
                    _budgetGroupRecId,
                    _mainAccountRecId,
                    _includeAllAccounts,
                    _includeCarryForward) ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeBudgetPeriodBalanceListCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the class-level map variable.
    /// </summary>
    protected void initializeBudgetPeriodBalanceListCache()
    {
        budgetPeriodBalanceListCache = new Map(Types::String, Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeStatisticsViewType</Name>
				<Source><![CDATA[
    private void initializeStatisticsViewType()
    {
        this.statisticsViewType = new BudgetControlStatisticsViewV2Type();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        budgetControlConfiguration = BudgetControlConfiguration::findActiveByPrimaryLedger(Ledger::current());
        this.initializeStatisticsViewType();
        this.initializeBudgetPeriodBalanceListCache();
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetAccumulatedValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets all local variables that hold accumulated values.
    /// </summary>
    public void resetAccumulatedValues()
    {
        accumulatedActualBudget = 0.0;
        accumulatedRevisedBudget = 0.0;
        accumulatedEncumbrances = 0.0;
        accumulatedPreEncumbrances = 0.0;
        accumulatedTotalBudgetFundsAvailable = 0.0;
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            accumulatedApportionmentAmount = 0.0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBudgetTmpControlStatisticsAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the values of various total amounts and sets those values in the specified temporary
    /// table reference.
    /// </summary>
    /// <param name="_budgetTmpControlStatistics">
    /// A <c>BudgetTmpControlStatistics</c> reference in which the calculated <c>AmountMST</c> values must
    /// be set.
    /// </param>
    /// <param name="_balanceType">
    /// A <c>BudgetControlStatisticsBalanceType</c> type, which is used to calculate the net change amount
    /// and the accumulated amount.
    /// </param>
    public void setBudgetTmpControlStatisticsAmount(BudgetTmpControlStatistics _budgetTmpControlStatistics, BudgetControlStatisticsBalanceType _balanceType)
    {
        budgetControlConfiguration = BudgetControlConfiguration::findActiveByPrimaryLedger(_budgetTmpControlStatistics.PrimaryLedger);

        switch (_balanceType)
        {
            case BudgetBalanceType::Accumulated :

                // calculate all the accumulated values when the balance type selected by the user is 'Accumulated'.
                accumulatedActualBudget +=_budgetTmpControlStatistics.totalActuals();
                accumulatedRevisedBudget += _budgetTmpControlStatistics.totalRevisedBudget();
                accumulatedEncumbrances += _budgetTmpControlStatistics.totalEncumbrances();
                accumulatedPreEncumbrances += _budgetTmpControlStatistics.totalPreEncumbrances();
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    accumulatedApportionmentAmount += _budgetTmpControlStatistics.totalApportionments(budgetControlConfiguration);
                }

                accumulatedTotalBudgetFundsAvailable += _budgetTmpControlStatistics.getBudgetFundsAvailableAmount(budgetControlConfiguration.RecId);

                _budgetTmpControlStatistics.TotalFundsAvailableAmountMST = accumulatedTotalBudgetFundsAvailable;
                _budgetTmpControlStatistics.TotalActualAmountMST = accumulatedActualBudget;
                _budgetTmpControlStatistics.TotalEncumbrancesAmountMST = accumulatedEncumbrances;
                _budgetTmpControlStatistics.TotalPreEncumbranceAmountMST = accumulatedPreEncumbrances;
                _budgetTmpControlStatistics.TotalRevisedBudgetAmountMST = accumulatedRevisedBudget;
                _budgetTmpControlStatistics.TotalApportionmentAmountMST = accumulatedApportionmentAmount;

                break;

            case BudgetBalanceType::NetChange:

                _budgetTmpControlStatistics.TotalFundsAvailableAmountMST = _budgetTmpControlStatistics.getBudgetFundsAvailableAmount(budgetControlConfiguration.RecId);
                _budgetTmpControlStatistics.TotalActualAmountMST = _budgetTmpControlStatistics.totalActuals();
                _budgetTmpControlStatistics.TotalEncumbrancesAmountMST = _budgetTmpControlStatistics.totalEncumbrances();
                _budgetTmpControlStatistics.TotalPreEncumbranceAmountMST = _budgetTmpControlStatistics.totalPreEncumbrances();
                _budgetTmpControlStatistics.TotalRevisedBudgetAmountMST = _budgetTmpControlStatistics.totalRevisedBudget();
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    _budgetTmpControlStatistics.TotalApportionmentAmountMST = _budgetTmpControlStatistics.totalApportionments(budgetControlConfiguration);
                }
                break;

            default:

                _budgetTmpControlStatistics.TotalFundsAvailableAmountMST = 0.0;
                _budgetTmpControlStatistics.TotalActualAmountMST = 0.0;
                _budgetTmpControlStatistics.TotalEncumbrancesAmountMST = 0.0;
                _budgetTmpControlStatistics.TotalPreEncumbranceAmountMST = 0.0;
                _budgetTmpControlStatistics.TotalRevisedBudgetAmountMST = 0.0;

                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    _budgetTmpControlStatistics.TotalApportionmentAmountMST = 0.0;
                }

                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionFocus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the dimension focus display value, depending on the specified ledger dimension and focus name.
    /// </summary>
    /// <param name="_ledgerDimension">
    ///    A <c>LedgerDimensionBase</c> value for which to obtain the dimension focus value.
    /// </param>
    /// <param name="_dimensionFocusName">
    ///    The focus name that is used to get the dimension display value for a passed in ledger dimension.
    /// </param>
    /// <returns>
    ///    A <c>DimensionDisplayValue</c> value for the ledger dimension.
    /// </returns>
    /// <remarks>
    ///    It uses the <c>getDisplayValueForFocusName</c> method on the <c>DimensionStorage</c> class to get
    ///    the focus display value.
    /// </remarks>
    public static DimensionDisplayValue getDimensionFocus(LedgerDimensionBase _ledgerDimension, Name _dimensionFocusName)
    {
        return DimensionSet::getDisplayValueForDimensionSetName(_ledgerDimension, _dimensionFocusName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionBudgetControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the first ledger dimension that matches the dimension display value where the ledger dimension
    /// type is <c>BudgetControl</c> and where budget source tracking details exist for the current primary
    /// ledger.
    /// </summary>
    /// <param name="_displayValue">
    /// The <c>DimensionDisplayValue</c> value for which to obtain the ledger dimension.
    /// </param>
    /// <returns>
    /// The ledger dimension for the dimension display value.
    /// </returns>
    public static DimensionAttributeValueCombination getLedgerDimensionBudgetControl(DimensionDisplayValue _displayValue)
    {
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        BudgetSourceTrackingDetail budgetSourceTrackingDetail;

        select firstonly dimensionAttributeValueCombination
            order by RecId desc
            where dimensionAttributeValueCombination.DisplayValue == _displayValue &&
                dimensionAttributeValueCombination.LedgerDimensionType == LedgerDimensionType::BudgetControl
            exists join budgetSourceTrackingDetail
                where budgetSourceTrackingDetail.PrimaryLedger == Ledger::current() &&
                    budgetSourceTrackingDetail.BudgetControlLedgerDimension == dimensionAttributeValueCombination.RecId;

        return dimensionAttributeValueCombination;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareQueryForControlStatsDrillDown</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the <c>DimensionAttributeValueCombination</c> and <c>BudgetGroupLedgerDimension</c> table data
    ///    sources to the passed in query, which is based on the <c>BudgetTmpControlStatistics</c> record
    ///    values.
    /// </summary>
    /// <param name="_query">
    ///    The <c>Query</c> instance in to which the data sources and ranges have to be added.
    /// </param>
    /// <param name="_budgetTmpControlStatisticsCaller">
    ///    The <c>BudgetTmpControlStatistics</c> record from which the values have to be obtained and added as
    ///    range values to the passed in query.
    /// </param>
    public static void prepareQueryForControlStatsDrillDown(Query _query , BudgetTmpControlStatistics _budgetTmpControlStatisticsCaller)
    {
        Query                       query;
        QueryBuildDataSource        budgetSourceTrackingDetail_qbds;
        QueryBuildDataSource        davcBudgetSourceLedgerDim_qbds;
        QueryBuildDataSource        budgetGroupLedgerDimension_qbds;

        BudgetTmpControlStatistics  budgetTmpControlStatisticsCaller = _budgetTmpControlStatisticsCaller;

        #DEFINE.dimensionAttributeValueComb_SourceLedgerDim('DimensionAttributeValueComb_Source')
        #DEFINE.RecId_0(0)

        query = _query;

        budgetSourceTrackingDetail_qbds = query.dataSourceTable(tablenum(BudgetSourceTrackingDetail));

        if (budgetSourceTrackingDetail_qbds != null)
        {
            budgetSourceTrackingDetail_qbds.clearRanges();
            budgetSourceTrackingDetail_qbds.addRange(fieldnum(BudgetSourceTrackingDetail, PrimaryLedger)).value(SysQuery::value(Ledger::current()));
            budgetSourceTrackingDetail_qbds.addRange(fieldNum(BudgetSourceTrackingDetail, IsDeletePending)).value(int2str(enum2int(NoYes::No)));
            budgetSourceTrackingDetail_qbds.addRange(fieldNum(BudgetSourceTrackingDetail, IsSummarized)).value(int2str(enum2int(NoYes::Yes)));

            if (budgetTmpControlStatisticsCaller.BudgetControlLedgerDimension != 0)
            {
                // When a dimension value filter is present in the statistics form then add a
                // range on control ledger dimension.
                budgetSourceTrackingDetail_qbds.clearRange(fieldnum(BudgetSourceTrackingDetail, BudgetControlLedgerDimension));
                budgetSourceTrackingDetail_qbds.addRange(fieldnum(BudgetSourceTrackingDetail, BudgetControlLedgerDimension)).value(SysQuery::value(budgetTmpControlStatisticsCaller.BudgetControlLedgerDimension));

                budgetGroupLedgerDimension_qbds = query.dataSourceTable(tablenum(BudgetGroupLedgerDimension));

                if (budgetGroupLedgerDimension_qbds != null)
                {
                    // When the user changes option from budget group to dimension values in the statistics form
                    // we need to clear the ranges if there is any for the budget group ledger dimension table.
                    budgetGroupLedgerDimension_qbds.clearRanges();
                }
            }
            else if (budgetTmpControlStatisticsCaller.BudgetGroup != 0)
            {
                // When a budget group filter is present in the statistics form then add a budget group ledger dimension datasource and link it
                // with control ledger dimension.

                budgetGroupLedgerDimension_qbds = query.dataSourceTable(tablenum(BudgetGroupLedgerDimension));

                if (budgetGroupLedgerDimension_qbds == null)
                {
                    // If the group ledger dimension datasource is not present in the query then add it.
                    // This is used to filter the grid based on the budget group name specified in the the budgetTmpControlStatistics record.
                    budgetGroupLedgerDimension_qbds = budgetSourceTrackingDetail_qbds.addDataSource(tablenum(BudgetGroupLedgerDimension));
                }

                budgetGroupLedgerDimension_qbds.fetchMode(QueryFetchMode::One2One);
                budgetGroupLedgerDimension_qbds.joinMode(JoinMode::InnerJoin);
                budgetGroupLedgerDimension_qbds.addLink(fieldnum(BudgetSourceTrackingDetail, BudgetControlLedgerDimension), fieldnum(BudgetGroupLedgerDimension, BudgetControlLedgerDimension));
                budgetGroupLedgerDimension_qbds.clearRange(fieldnum(BudgetGroupLedgerDimension, BudgetGroup));
                budgetGroupLedgerDimension_qbds.addRange(fieldnum(BudgetGroupLedgerDimension, BudgetGroup)).value(SysQuery::value(budgetTmpControlStatisticsCaller.BudgetGroup));
            }
            else
            {
                // When neither of the values were picked then display empty grid by adding a Range on the RecId field.
                budgetSourceTrackingDetail_qbds.clearRange(fieldnum(BudgetSourceTrackingDetail, BudgetControlLedgerDimension));
                budgetSourceTrackingDetail_qbds.addRange(fieldnum(BudgetSourceTrackingDetail, RecId)).value(SysQuery::value(#RecId_0));
            }

            if (budgetTmpControlStatisticsCaller.MainAccount != 0)
            {
                // When a main account filter is present in the statistics form then add a davc datasource and link it
                // with source ledger dimension.
                davcBudgetSourceLedgerDim_qbds = query.dataSourceName(#dimensionAttributeValueComb_SourceLedgerDim);

                if (davcBudgetSourceLedgerDim_qbds == null)
                {
                    // If the source ledger davc datasource is not present in the query then add it.
                    davcBudgetSourceLedgerDim_qbds = budgetSourceTrackingDetail_qbds.addDataSource(tablenum(DimensionAttributeValueCombination), #dimensionAttributeValueComb_SourceLedgerDim);
                }

                davcBudgetSourceLedgerDim_qbds.fetchMode(QueryFetchMode::One2One);
                davcBudgetSourceLedgerDim_qbds.joinMode(JoinMode::InnerJoin);
                davcBudgetSourceLedgerDim_qbds.addLink(fieldnum(BudgetSourceTrackingDetail, BudgetSourceLedgerDimension), fieldnum(DimensionAttributeValueCombination, RecId));
                davcBudgetSourceLedgerDim_qbds.clearRange(fieldnum(DimensionAttributeValueCombination, MainAccount));
                davcBudgetSourceLedgerDim_qbds.addRange(fieldnum(DimensionAttributeValueCombination, MainAccount)).value(SysQuery::value(budgetTmpControlStatisticsCaller.MainAccount));
            }
            else
            {
                // Clear the ranges if the main account filter is not present.
                davcBudgetSourceLedgerDim_qbds = query.dataSourceName(#dimensionAttributeValueComb_SourceLedgerDim);

                if (davcBudgetSourceLedgerDim_qbds != null)
                {
                    davcBudgetSourceLedgerDim_qbds.clearRanges();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDestinationFieldToFieldMapping</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the field mapping between the specified source field name and the specified destination field name.
    /// </summary>
    /// <param name = "_fieldMapping">
    /// The <c>Map</c> of field mappings.
    /// </param>
    /// <param name = "_dataSourceUniqueId">
    /// The unique ID of the originating data source.
    /// </param>
    /// <param name = "_sourceFieldName">
    /// The field name from the originating data source.
    /// </param>
    /// <param name = "_destinationFieldName">
    /// The field name from the destination data source.
    /// </param>
    private void addDestinationFieldToFieldMapping(Map _fieldMapping, int _dataSourceUniqueId, FieldName _sourceFieldName, FieldName _destinationFieldName)
    {
        _fieldMapping.insert(_destinationFieldName, [_dataSourceUniqueId, _sourceFieldName]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getViewQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a query on the <c>BudgetControlStatisticsView</c> table.
    /// </summary>
    /// <param name = "_request">
    /// The <c>BudgetControlStatisticsRequest</c> object that contains information about how to construct the query.
    /// </param>
    /// <returns>
    /// The constructed query.
    /// </returns>
    private Query getViewQuery(BudgetControlStatisticsRequest _request)
    {
        Query query = new Query();
        QueryBuildDataSource budgetControlStatisticsView_qbds = query.addDataSource(statisticsViewType.getBudgetControlStatisticsViewId());
        query.clearAllFields();

        QueryBuildRange primaryLedgerQBR = SysQuery::findOrCreateRange(budgetControlStatisticsView_qbds, statisticsViewType.getPrimaryLedgerFieldNumber());
        primaryLedgerQBR.value(queryValue(_request.parmPrimaryLedgerRecId()));

        if (_request.parmIncludeCarryForward() == BudgetControlStatisticsCarryForwardOption::NotIncluded)
        {
            QueryBuildRange isCarryForwardQBR = SysQuery::findOrCreateRange(budgetControlStatisticsView_qbds, statisticsViewType.getIsCarryForwardFieldNumber());
            isCarryForwardQBR.value(queryValue(0));
        }

        QueryBuildRange trackingDateQBR = SysQuery::findOrCreateRange(budgetControlStatisticsView_qbds, statisticsViewType.getTrackingDateFieldNumber());
        str dateRange = SysQuery::range(_request.parmStartDate(), _request.parmEndDate());
        trackingDateQBR.value(dateRange);

        this.addBudgetControlStatisticsDateRange(_request, budgetControlStatisticsView_qbds);

        if (_request.parmBudgetCycleRecId())
        {
            // Add a range for the active budget cycle time span setting for the budget control configuration rules or groups.
            QueryBuildRange budgetCycleTimeSpanQBR;

            if (_request.parmBudgetControlStatisticsValueOption() == BudgetControlStatisticsValueOption::DimensionValues)
            {
                budgetCycleTimeSpanQBR = SysQuery::findOrCreateRange(budgetControlStatisticsView_qbds, statisticsViewType.getBudgetControlRuleBudgetCycleTimeSpanFieldNumber());
            }
            else if (_request.parmBudgetControlStatisticsValueOption() == BudgetControlStatisticsValueOption::BudgetGroup)
            {
                budgetCycleTimeSpanQBR = SysQuery::findOrCreateRange(budgetControlStatisticsView_qbds, statisticsViewType.getBudgetGroupBudgetCycleTimeSpanFieldNumber());
            }

            if (budgetCycleTimeSpanQBR)
            {
                BudgetCycle budgetCycle = BudgetCycle::find(_request.parmBudgetCycleRecId());

                budgetCycleTimeSpanQBR.value(queryValue(budgetCycle.BudgetCycleTimeSpan));
            }
        }

        if (_request.parmBudgetModelId())
        {
            QueryBuildRange budgetModelIdQBR = SysQuery::findOrCreateRange(budgetControlStatisticsView_qbds, statisticsViewType.getBudgetModelIdFieldNumber());
            BudgetModel budgetModel = BudgetModel::find(HeadingSub::Heading, _request.parmBudgetModelId());
            budgetModelIdQBR.value(this.getBudgetModelQueryRangeValue(budgetModel));
        }

        if (_request.parmBudgetControlLedgerDimension())
        {
            QueryBuildRange budgetControlLedgerDimensionQBR = SysQuery::findOrCreateRange(budgetControlStatisticsView_qbds, statisticsViewType.getBudgetControlLedgerDimensionFieldNumber());
            budgetControlLedgerDimensionQBR.value(queryValue(_request.parmBudgetControlLedgerDimension()));
        }

        if (_request.parmBudgetGroupName())
        {
            QueryBuildRange budgetGroupNameQBR = SysQuery::findOrCreateRange(budgetControlStatisticsView_qbds, statisticsViewType.getBudgetGroupNameFieldNumber());
            budgetGroupNameQBR.value(queryValue(_request.parmBudgetGroupName()));
        }

        if (_request.parmForceGroupByBudgetSourceLedgerDimension())
        {
            // If grouping by source ledger dimension, exclude categories that contribute to revised budget.
            QueryBuildRange categoryQBR = SysQuery::findOrCreateRange(budgetControlStatisticsView_qbds, statisticsViewType.getCategoryFieldNumber());
            categoryQBR.value(notSign + queryValue(BudgetControlCategory::Original)
                + comma + notSign + queryValue(BudgetControlCategory::Amendment)
                + comma + notSign + queryValue(BudgetControlCategory::TransferIn)
                + comma + notSign + queryValue(BudgetControlCategory::TransferOut)
                + comma + notSign + queryValue(BudgetControlCategory::CarryForwardBudget));
        }

        FieldId groupByFieldNumber = this.getGroupByFieldNumber(_request);

        SysQuery::findOrCreateGroupByField(query, budgetControlStatisticsView_qbds, groupByFieldNumber);

        // Define the fields selected by the query as not all fields in the view are selected.
        // Use of the min functions allows inclusion of strings in the select statement even though they are not in a 'group by' statement.
        budgetControlStatisticsView_qbds.addSelectionField(statisticsViewType.getBudgetGroupNameFieldNumber(), SelectionField::Min);
        budgetControlStatisticsView_qbds.addSelectionField(statisticsViewType.getBudgetControlLedgerDimensionFieldNumber(), SelectionField::Min);

        if (isPreliminaryBudgetEnabled)
        {
            budgetControlStatisticsView_qbds.addSelectionField(statisticsViewType.getTotalRevisedBudgetForPreliminaryBudgetFieldNumber(), SelectionField::Sum);
        }
        else
        {
            budgetControlStatisticsView_qbds.addSelectionField(statisticsViewType.getTotalRevisedBudgetFieldNumber(), SelectionField::Sum);
        }

        budgetControlStatisticsView_qbds.addSelectionField(statisticsViewType.getTotalPreEncumbrancesFieldNumber(), SelectionField::Sum);
        budgetControlStatisticsView_qbds.addSelectionField(statisticsViewType.getTotalEncumbrancesFieldNumber(), SelectionField::Sum);
        budgetControlStatisticsView_qbds.addSelectionField(statisticsViewType.getTotalActualExpendituresFieldNumber(), SelectionField::Sum);

        if (isApportionmentBudgetEnabled)
        {
            budgetControlStatisticsView_qbds.addSelectionField(statisticsViewType.getTotalBudgetFundsAvailableForApportionmentFieldNumber(), SelectionField::Sum);
            budgetControlStatisticsView_qbds.addSelectionField(statisticsViewType.getTotalApportionmentFieldNumber(), SelectionField::Sum);
        }
        else if (isPreliminaryBudgetEnabled)
        {
            budgetControlStatisticsView_qbds.addSelectionField(statisticsViewType.getTotalBudgetFundsAvailableForPreliminaryBudgetFieldNumber(), SelectionField::Sum);
        }
        else
        {
            budgetControlStatisticsView_qbds.addSelectionField(statisticsViewType.getTotalBudgetFundsAvailableFieldNumber(), SelectionField::Sum);
        }

        budgetControlStatisticsView_qbds.addSelectionField(statisticsViewType.getBudgetSourceLedgerDimensionFieldNumber(), SelectionField::Min);
        budgetControlStatisticsView_qbds.addSelectionField(statisticsViewType.getTrackingDateFieldNumber(), SelectionField::Min);
        budgetControlStatisticsView_qbds.addSelectionField(statisticsViewType.getPrimaryLedgerFieldNumber(), SelectionField::Min);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBudgetControlStatisticsDateRange</Name>
				<Source><![CDATA[
    private void addBudgetControlStatisticsDateRange(BudgetControlStatisticsRequest _request, QueryBuildDataSource _budgetControlStatisticsView_qbds)
    {
        BudgetControlIStatisticsDateRange dateRangeType = statisticsViewType as BudgetControlIStatisticsDateRange;
        if (dateRangeType)
        {
            // Only BudgetControlIStatisticsViewTypes that implement BudgetControlIStatisticsDateRange need this optional range set.
            // All others do not require it.
            BudgetControlStatisticsDateRange parameter = BudgetControlStatisticsDateRange::findOrCreate(_request.parmStartDate(), _request.parmEndDate());
            QueryBuildRange dateRangeRange = SysQuery::findOrCreateRange(_budgetControlStatisticsView_qbds, dateRangeType.getDateRangeFieldNumber());
            dateRangeRange.value(queryValue(parameter.RecId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGroupByFieldNumber</Name>
				<Source><![CDATA[
    private FieldId getGroupByFieldNumber(BudgetControlStatisticsRequest _request)
    {
        FieldId fieldNumber;

        if (_request.parmForceGroupByBudgetSourceLedgerDimension())
        {
            // If the request indicates that results should be grouped by budget source ledger dimension,
            // apply the group by on this field regardless of other parameters set.
            fieldNumber = statisticsViewType.getBudgetSourceLedgerDimensionFieldNumber();
        }
        else
        {
            if (_request.parmBudgetControlStatisticsValueOption() == BudgetControlStatisticsValueOption::DimensionValues)
            {
                if (_request.parmBudgetControlLedgerDimension())
                {
                    // If the request indicates that results should be shown by display value and the control ledger dimension is set,
                    // show impact on the control ledger dimension by source ledger dimension.
                    fieldNumber = statisticsViewType.getBudgetSourceLedgerDimensionFieldNumber();
                }
                else
                {
                    // If the request indicates that results should be shown by display value and the control ledger dimension is not set,
                    // show budget totals grouped by control ledger dimension.
                    fieldNumber = statisticsViewType.getBudgetControlLedgerDimensionFieldNumber();
                }
            }
            else
            {
                // If the request indicates that results should be shown by budget group,
                // show budget totals grouped by budget group name.
                fieldNumber = statisticsViewType.getBudgetGroupNameFieldNumber();
            }
        }

        return fieldNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetModelQueryRangeValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Prepares the query range value for <c>BudgetModel</c>.
    /// </summary>
    /// <param name="_budgetModel">
    ///     A <c>BudgetModel</c> record.
    /// </param>
    /// <returns>
    ///     The query range compatible string value for the <c>BudgetModel</c> field in budget control tracking.
    /// </returns>
    private str getBudgetModelQueryRangeValue(BudgetModel _budgetModel)
    {
        // Include the default budget model in the query results.
        str queryRangeValueStr = strfmt('(((%1 == \"%5\") && (%2 == \"%6\") && (%3 == %7) && (%4 == \"%8\")) || ((%1 == %9) && (%2 == %9) && (%3 == %7) && (%4 == %9)))',
            fieldstr(BudgetControlStatisticsView, BudgetModelId),
            fieldstr(BudgetControlStatisticsView, BudgetModelSubModelId),
            fieldstr(BudgetControlStatisticsView, BudgetModelType),
            fieldstr(BudgetControlStatisticsView, BudgetModelDataAreaId),
            SysQuery::value(_budgetModel.ModelId),
            SysQuery::value(_budgetModel.SubModelId),
            int2str(enum2int(_budgetModel.Type)),
            SysQuery::value(_budgetModel.DataAreaId),
            SysQuery::valueEmptyString());

        return queryRangeValueStr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldsToMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs an instance of the <c>Map<c> class that defines the field mapping between the <c>BudgetControlStatisticsView</c> view and <c>BudgetTmpControlStatisticsByDimension</c> table.
    /// </summary>
    /// <param name = "_budgetControlStatisticsViewUniqueId">
    /// The unique id of a <c>BudgetControlStatisticsView</c> data source.
    /// </param>
    /// <returns>
    /// An instance of the <c>Map</c> class that defines the field mappings.
    /// </returns>
    private Map addFieldsToMap(int _budgetControlStatisticsViewUniqueId)
    {
        Map insertRecordsetMap = new Map(Types::String, Types::Container);

        // The mapping for insert_recordSet does not directly support aggregate functions on an originating data source.
        // The strings below that contain aggregation function names were added as a workaround.
        this.addDestinationFieldToFieldMapping(
            insertRecordsetMap,
            _budgetControlStatisticsViewUniqueId,
            'MIN(' + fieldStr(BudgetControlStatisticsView, BudgetControlLedgerDimension) + ')',
            fieldStr(BudgetTmpControlStatisticsByDimension, BudgetControlLedgerDimension));

        this.addDestinationFieldToFieldMapping(
            insertRecordsetMap,
            _budgetControlStatisticsViewUniqueId,
            'MIN(' + fieldStr(BudgetControlStatisticsView, BudgetGroupName) + ')',
            fieldStr(BudgetTmpControlStatisticsByDimension, BudgetGroupName));

        this.addDestinationFieldToFieldMapping(
            insertRecordsetMap,
            _budgetControlStatisticsViewUniqueId,
            'SUM(' + fieldStr(BudgetControlStatisticsView, TotalActualExpenditures) + ')',
            fieldStr(BudgetTmpControlStatisticsByDimension, TotalActualExpenditures));

        if (isPreliminaryBudgetEnabled)
        {
            this.addDestinationFieldToFieldMapping(
                insertRecordsetMap,
                _budgetControlStatisticsViewUniqueId,
                'SUM(' + fieldStr(BudgetControlStatisticsView, TotalRevisedBudgetForPreliminaryBudget) + ')',
                fieldStr(BudgetTmpControlStatisticsByDimension, TotalRevisedBudget));
        }
        else
        {
            this.addDestinationFieldToFieldMapping(
                insertRecordsetMap,
                _budgetControlStatisticsViewUniqueId,
                'SUM(' + fieldStr(BudgetControlStatisticsView, TotalRevisedBudget) + ')',
                fieldStr(BudgetTmpControlStatisticsByDimension, TotalRevisedBudget));
        }

        this.addDestinationFieldToFieldMapping(
            insertRecordsetMap,
            _budgetControlStatisticsViewUniqueId,
            'SUM(' + fieldStr(BudgetControlStatisticsView, TotalEncumbrances) + ')',
            fieldStr(BudgetTmpControlStatisticsByDimension, TotalEncumbrances));

        this.addDestinationFieldToFieldMapping(
            insertRecordsetMap,
            _budgetControlStatisticsViewUniqueId,
            'SUM(' + fieldStr(BudgetControlStatisticsView, TotalPreEncumbrances) + ')',
            fieldStr(BudgetTmpControlStatisticsByDimension, TotalPreEncumbrances));

        if (isApportionmentBudgetEnabled)
        {
            this.addDestinationFieldToFieldMapping(
                insertRecordsetMap,
                _budgetControlStatisticsViewUniqueId,
                'SUM(' + fieldStr(BudgetControlStatisticsView, TotalBudgetFundsAvailableForApportionment) + ')',
                fieldStr(BudgetTmpControlStatisticsByDimension, TotalBudgetFundsAvailable));

            this.addDestinationFieldToFieldMapping(
                insertRecordsetMap,
                _budgetControlStatisticsViewUniqueId,
                'SUM(' + fieldStr(BudgetControlStatisticsView, TotalApportionment) + ')',
                fieldStr(BudgetTmpControlStatisticsByDimension, TotalApportionment));
        }
        else if (isPreliminaryBudgetEnabled)
        {
            this.addDestinationFieldToFieldMapping(
                insertRecordsetMap,
                _budgetControlStatisticsViewUniqueId,
                'SUM(' + fieldStr(BudgetControlStatisticsView, TotalBudgetFundsAvailableForPreliminaryBudget) + ')',
                fieldStr(BudgetTmpControlStatisticsByDimension, TotalBudgetFundsAvailable));
        }
        else
        {
            this.addDestinationFieldToFieldMapping(
                insertRecordsetMap,
                _budgetControlStatisticsViewUniqueId,
                'SUM(' + fieldStr(BudgetControlStatisticsView, TotalBudgetFundsAvailable) + ')',
                fieldStr(BudgetTmpControlStatisticsByDimension, TotalBudgetFundsAvailable));
        }

        this.addDestinationFieldToFieldMapping(
            insertRecordsetMap,
            _budgetControlStatisticsViewUniqueId,
            'MIN(' + fieldStr(BudgetControlStatisticsView, TrackingDate) + ')',
            fieldStr(BudgetTmpControlStatisticsByDimension, TrackingDate));

        this.addDestinationFieldToFieldMapping(
            insertRecordsetMap,
            _budgetControlStatisticsViewUniqueId,
            'MIN(' + fieldStr(BudgetControlStatisticsView, BudgetSourceLedgerDimension) + ')',
            fieldStr(BudgetTmpControlStatisticsByDimension, BudgetSourceLedgerDimension));

        this.addDestinationFieldToFieldMapping(
            insertRecordsetMap,
            _budgetControlStatisticsViewUniqueId,
            'MIN(' + fieldStr(BudgetControlStatisticsView, PrimaryLedger) + ')',
            fieldStr(BudgetTmpControlStatisticsByDimension, PrimaryLedger));

        return insertRecordsetMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateBudgetTmpControlStatisticsByDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates a <c>BudgetTmpControlStatisticsByDimension</c> instance with budget balances grouped by budget group, control dimension, or ledger dimension.
    /// </summary>
    /// <param name = "_request">
    /// The <c>BudgetControlStatisticsRequest</c> with the information available for populating the <c>BudgetTmpControlStatisticsByDimension</c> table.
    /// </param>
    /// <returns>
    /// The <c>BudgetTmpControlStatisticsByDimension</c> instance.
    /// </returns>
    public BudgetTmpControlStatisticsByDimension populateBudgetTmpControlStatisticsByDimension(BudgetControlStatisticsRequest _request)
    {
        BudgetTmpControlStatisticsByDimension budgetTmpControlStatisticsByDimension;

        isApportionmentBudgetEnabled    = BudgetControlConfiguration::isApportionmentBudgetEnabled(_request.parmPrimaryLedgerRecId());
        isPreliminaryBudgetEnabled      = BudgetControlConfiguration::isPreliminaryBudgetEnabled(_request.parmPrimaryLedgerRecId());

        Query query = this.getViewQuery(_request);
        QueryBuildDataSource budgetControlStatisticsView_qbds = query.dataSourceTable(statisticsViewType.getBudgetControlStatisticsViewId());
        int budgetControlStatisticsViewUniqueId = budgetControlStatisticsView_qbds.uniqueId();

        Map insertRecordsetMap = this.addFieldsToMap(budgetControlStatisticsViewUniqueId);

        Query::insert_recordset(budgetTmpControlStatisticsByDimension, insertRecordsetMap, query);

        if (!BudgetControlStatisticsByDimensionCarryForwardEncumbranceFlight::instance().isEnabled()
            && _request.parmIncludeCarryForward() == BudgetControlStatisticsCarryForwardOption::NotIncluded
            && budgetControlConfiguration.IncludeCarryforwardAmounts)
        {
            // Although carry-forward amounts were not a chosen request parameter, the budget funds available calculation
            // includes them when the configuration is set up to include them.
            budgetControlStatisticsView_qbds.clearRange(statisticsViewType.getIsCarryForwardFieldNumber());

            BudgetTmpControlStatisticsByDimension budgetTmpControlStatisticsByDimensionIncludeCarryForward;

            Query::insert_recordset(budgetTmpControlStatisticsByDimensionIncludeCarryForward, insertRecordsetMap, query);

            switch (this.getGroupByFieldNumber(_request))
            {
                case fieldNum(BudgetControlStatisticsView, BudgetSourceLedgerDimension):
                    update_recordset budgetTmpControlStatisticsByDimension
                        setting
                            TotalBudgetFundsAvailable = budgetTmpControlStatisticsByDimensionIncludeCarryForward.TotalBudgetFundsAvailable
                        join budgetTmpControlStatisticsByDimensionIncludeCarryForward
                            where budgetTmpControlStatisticsByDimensionIncludeCarryForward.BudgetSourceLedgerDimension == budgetTmpControlStatisticsByDimension.BudgetSourceLedgerDimension
                                && budgetTmpControlStatisticsByDimensionIncludeCarryForward.TotalBudgetFundsAvailable != budgetTmpControlStatisticsByDimension.TotalBudgetFundsAvailable;
                    break;

                case fieldNum(BudgetControlStatisticsView, BudgetControlLedgerDimension):
                    update_recordset budgetTmpControlStatisticsByDimension
                        setting
                            TotalBudgetFundsAvailable = budgetTmpControlStatisticsByDimensionIncludeCarryForward.TotalBudgetFundsAvailable
                        join budgetTmpControlStatisticsByDimensionIncludeCarryForward
                            where budgetTmpControlStatisticsByDimensionIncludeCarryForward.BudgetControlLedgerDimension == budgetTmpControlStatisticsByDimension.BudgetControlLedgerDimension
                                && budgetTmpControlStatisticsByDimensionIncludeCarryForward.TotalBudgetFundsAvailable != budgetTmpControlStatisticsByDimension.TotalBudgetFundsAvailable;
                    break;

                case fieldNum(BudgetControlStatisticsView, BudgetGroupName):
                    update_recordset budgetTmpControlStatisticsByDimension
                        setting
                            TotalBudgetFundsAvailable = budgetTmpControlStatisticsByDimensionIncludeCarryForward.TotalBudgetFundsAvailable
                        join budgetTmpControlStatisticsByDimensionIncludeCarryForward
                            where budgetTmpControlStatisticsByDimensionIncludeCarryForward.BudgetGroupName == budgetTmpControlStatisticsByDimension.BudgetGroupName
                                && budgetTmpControlStatisticsByDimensionIncludeCarryForward.TotalBudgetFundsAvailable != budgetTmpControlStatisticsByDimension.TotalBudgetFundsAvailable;
                    break;
            }
        }

        if (!_request.parmForceGroupByBudgetSourceLedgerDimension())
        {
            if (BudgetControlConfiguration::isApportionmentBudgetEnabled(Ledger::current()))
            {
                update_recordset budgetTmpControlStatisticsByDimension
                    setting PercentUsed =
                    (((budgetTmpControlStatisticsByDimension.TotalActualExpenditures +
                    budgetTmpControlStatisticsByDimension.TotalEncumbrances +
                    budgetTmpControlStatisticsByDimension.TotalPreEncumbrances) /
                    budgetTmpControlStatisticsByDimension.TotalApportionment) * 100)
                    where budgetTmpControlStatisticsByDimension.TotalApportionment != 0;

                update_recordset budgetTmpControlStatisticsByDimension
                    setting PercentUsed = 100
                    where budgetTmpControlStatisticsByDimension.TotalApportionment == 0;
            }
            else
            {
                update_recordset budgetTmpControlStatisticsByDimension
                    setting PercentUsed =
                    (((budgetTmpControlStatisticsByDimension.TotalActualExpenditures +
                    budgetTmpControlStatisticsByDimension.TotalEncumbrances +
                    budgetTmpControlStatisticsByDimension.TotalPreEncumbrances) /
                    budgetTmpControlStatisticsByDimension.TotalRevisedBudget) * 100)
                    where budgetTmpControlStatisticsByDimension.TotalRevisedBudget != 0;

                update_recordset budgetTmpControlStatisticsByDimension
                    setting PercentUsed = 100
                    where budgetTmpControlStatisticsByDimension.TotalRevisedBudget == 0;
            }
        }

        return budgetTmpControlStatisticsByDimension;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>