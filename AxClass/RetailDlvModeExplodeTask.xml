<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailDlvModeExplodeTask</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

/// <summary>
/// This class <c>RetailDlvModeExplodeTask</c> is used to push data from DlvMode to TempTable
/// and from TempTable to Normal Tables.
/// </summary>
public final class RetailDlvModeExplodeTask extends RunBaseBatch implements BatchRetryable
{
    private TmpRetailDlvModeChannelExploded tmpChannelExploded;
    private TmpRetailDlvModeProductExploded tmpProductExploded;
    private TmpRetailDlvModeExclusions      exclusions;
    private RetailDlvModeAddressExploded    tmpAddressExploded;
    private TmpRetailDlvModeAddressExclusions   addressExclusions;
    private int64                           numItemsExploded, numItemsSkipped, numItemsError;
    private RefRecId                                refRecIdCategory;
    private TmpRetailDlvModeExplodeAllCategories    tmpExplodeAllCategories; // table contains data for all retail categories.
    private TmpRetailDlvModeExplodeAllCategories    tmpExploded;
    private TmpRetailDlvModeExplodeAllCategories    tmpExplodedSupplementalCategoryExclusion; // temp table contains data for supplemental categories
    private ItemId                                  itemId;
    private int64                                   numItemsExploded1, numItemsSkipped1, numItemsExploded2, numItemsSkipped2;

    private const int MaximumRetryNum = 5;
    private const int RetryWaitTime = 3000;  // in ms. 3 seconds for retry.

    // The DlvMode RecId that is packed and unpacked.
    private RefRecId dlvModeRecId;

    #DEFINE.CurrentVersion(1)
    #LOCALMACRO.CurrentList
        dlvModeRecId
    #ENDMACRO

    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of <c>RetailDlvModeExplodeTask</c> class with specified delivery mode record identifier.
    /// </summary>
    /// <param name="_dlvModeRecId">
    /// The record id of the delivery mode.
    /// </param>
    /// <returns>A RetailDlvModeExplodeTask instance.</returns>
    public static RetailDlvModeExplodeTask construct(RefRecId _dlvModeRecId)
    {
        RetailDlvModeExplodeTask task = new RetailDlvModeExplodeTask();
        task.dlvModeRecId = _dlvModeRecId;

        return task;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// This routine initiate the tasks to be executed.
    /// </summary>
    public void run()
    {
        RefRecId _dlvModeRecId = this.getDlvModeRecId();

        boolean isManagedExecution = Microsoft.Dynamics.Ax.Xpp.DataAccess.Helper::IsManagedDataAccess();

        eventSource.EventWriteProcessDeliveryModesProcessBegin(_dlvModeRecId, isManagedExecution);

        System.Diagnostics.Stopwatch stopWatch = new System.Diagnostics.Stopwatch();
        stopWatch.Start();

        boolean isSuccess = false;

        try
        {
            this.process();
            isSuccess = true;
        }
        finally
        {
            stopWatch.Stop();
            eventSource.EventWriteProcessDeliveryModesProcessEnd(_dlvModeRecId, stopWatch.ElapsedMilliseconds, isSuccess, isManagedExecution);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls whether batch task should retry in case of transient errors.
    /// </summary>
    /// <returns>true if task should be retried; otherwise, false.</returns>
    [Hookable(false)]
    public boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDlvModeRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get delivery mode identifier of the current task.
    /// The task will be processing this delivery mode.
    /// </summary>
    /// <returns>
    /// delivery mode identifier.
    /// </returns>
    private RefRecId getDlvModeRecId()
    {
        return dlvModeRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    /// <summary>
    /// overriding the pack routine.
    /// </summary>
    /// <returns>packed container</returns>
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    /// <summary>
    /// overriding the unpack routine.
    /// </summary>
    /// <param name = "packedClass">container</param>
    /// <returns>true/false</returns>
    public boolean unpack(container packedClass)
    {
        Version version = RunBase::getVersion(packedClass);

        switch (version)
        {
            case #CurrentVersion:
                [version,#CurrentList] = packedClass;
                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@Retail:DlvModeExplodeTask";    // "Process delivery mode task";
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method returns a value indicating if the <c>RetailDlvModeExplodeTask</c>
    /// class can be run in a new session.
    /// </summary>
    /// <returns>true if the the class <c>RetailDlvModeExplodeTask</c> can
    ///  be run in a new session; otherwise, false.</returns>
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailHierarchyIfExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the category RecId for highest level of hierarchy.
    /// </summary>
    /// <returns>Category identifier.</returns>
    public static EcoResCategoryHierarchy getRetailHierarchyIfExists()
    {
        EcoResCategoryHierarchyRole retailHierarchyRole = EcoResCategoryHierarchyRole::getHierarchiesByRole(EcoResCategoryNamedHierarchyRole::Retail);

        if (!retailHierarchyRole)
        {
            retailHierarchyRole = EcoResCategoryHierarchyRole::getHierarchiesByRole(EcoResCategoryNamedHierarchyRole::RetailSpecialGroup);
        }

        return EcoResCategoryHierarchy::find(retailHierarchyRole.CategoryHierarchy);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCategoryToTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the category-delivery mode associations to the temporary staging explosion table.
    /// Explodes the category to the product/variant level.
    /// </summary>
    /// <param name="_dlvMode">
    /// Delivery mode that needs to be added to the temporary table.
    /// </param>
    /// <param name="_categoryRecId">
    /// Category association that needs to be exploded to the temporary table.
    /// </param>
    /// <param name="_productExplodedSet">
    /// The set of product exploded records.
    /// </param>
    /// <param name="_productExplodedRecordInsertList">
    /// The collection of product exploded records that must be inserted into the database.
    /// </param>
    private void addCategoryToTempTable(DlvMode _dlvMode, RefRecId _categoryRecId, Set _productExplodedSet, RecordInsertList _productExplodedRecordInsertList)
    {
        const int CommitSize = 1000;
        int i = 0;
        Query           query;
        QueryRun        productsQueryRun;
        EcoResProduct   ecoResProduct;
        InventTable     inventTable;
        SetEnumerator   containedCategories;
        RefRecId        ecoResCategoryId;

        // Process all the products for this category and its sub categories
        containedCategories = RetailCategoryContainmentLookup::findContainedCategories(_categoryRecId);
        while (containedCategories.moveNext())
        {
            ecoResCategoryId = containedCategories.current();
            // Continue only if the category is not excluded
            if (!exclusions.isCategoryExcluded(ecoResCategoryId))
            {
                query = RetailGroupMemberLineQueryProvider::containedProductsQuery(ecoResCategoryId, false /*don't include SubCategories*/, _dlvMode.dataAreaId);
                productsQueryRun = new QueryRun(query);

                while (productsQueryRun.next())
                {
                    ecoResProduct = productsQueryRun.get(tableNum(EcoResProduct));
                    inventTable = productsQueryRun.get(tableNum(InventTable));
                    if (!ecoResProduct)
                    {
                        // The product was not found under the specified category.
                        continue;
                    }

                    try
                    {
                        // this bulky operation has to be committed at some point, e.g. after 1K products
                        if (i == 0)
                        {
                            ttsbegin;
                        }

                        // Add the product if it is not explicitly excluded.
                        if (!exclusions.isProductExcluded(ecoResProduct.RecId))
                        {
                            this.addProductToTempTable(_dlvMode, ecoResProduct.RecId, _productExplodedSet, _productExplodedRecordInsertList, inventTable);
                        }

                        i++;
                        if (i >= CommitSize)
                        {
                            ttscommit;
                            i = 0;
                        }
                    }
                    catch (Exception::UpdateConflict)
                    {
                        // No chance to get this, but
                        // try to resolve update conflict
                        str axCallStack = con2Str(xSession::xppCallStack());
                        if (appl.ttsLevel() == 0)
                        {
                            this.logCatchExceptionWithRetries(funcName(), axCallStack, xSession::currentRetryCount());

                            if (xSession::currentRetryCount() >= MaximumRetryNum)
                            {
                                throw Exception::UpdateConflictNotRecovered;
                            }
                            else
                            {
                                // Retry after update conflict in processing channels.
                                this.warningTimestamped("@Retail:DeliveryModeExplodeJobUpdateConflictRetryProductsAndVariants");

                                retry;
                            }
                        }
                        else
                        {
                            this.logCatchExceptionWithUnbalancedTts(funcName(), axCallStack, appl.ttsLevel());

                            throw Exception::UpdateConflict;
                        }
                    }
                    catch  // any transaction exception like Exception::Deadlock, etc will come here for retry
                    {
                        str axCallStack = con2Str(xSession::xppCallStack());
                        this.logCatchExceptionWithRetries(funcName(), axCallStack, xSession::currentRetryCount());

                        if (xSession::currentRetryCount() >= MaximumRetryNum)
                        {
                            throw error("@Retail:DeliveryModeExplodeJobFailedAtProductsAndVariants"); // non-recoverable
                        }
                        else
                        {
                            // wait 5 seconds, 25 seconds in total with retries
                            sleep(RetryWaitTime);

                            // Retry after deadlock in processing products and variants.
                            this.warningTimestamped("@Retail:DeliveryModeExplodeJobDeadlockRetryProductsAndVariants");

                            retry;
                        }
                    }
                }

                if (i > 0)
                {
                    // if there is anything left uncommitted in this category, commit now
                    i = 0;
                    ttscommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCountryToTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the Country-delivery mode associations to the temporary staging explosion table.
    /// </summary>
    /// <param name="_countryRegion">
    /// Country association that needs to be added to the temporary table.
    /// </param>
    private void addCountryToTempTable(LogisticsAddressCountryRegionId _countryRegion)
    {
        LogisticsAddressState logisticsAddressState;
        RefRecId _dlvModeRecId = this.getDlvModeRecId();

        if (!LogisticsAddressCountryRegion::exist(_countryRegion))
        {
            // Country doesn't exist
            error(strFmt("@RET490083", _countryRegion, this.getDeliveryModeCode(_dlvModeRecId)));
            return;
        }

        // Process if country is not already excluded
        if (!addressExclusions.isCountryExcluded(_dlvModeRecId, _countryRegion))
        {
            select firstOnly tmpAddressExploded
            where tmpAddressExploded.DlvMode == _dlvModeRecId
                && tmpAddressExploded.CountryRegion == _countryRegion
                && tmpAddressExploded.State == "";

            if (!tmpAddressExploded)
            {
                // Insert the exploded state into temp table, if it is not already excluded
                // and hasn't been already inserted
                tmpAddressExploded.DlvMode = _dlvModeRecId;
                tmpAddressExploded.CountryRegion = _countryRegion;
                tmpAddressExploded.State = "";
                tmpAddressExploded.doInsert();
            }

            while select StateId from logisticsAddressState
                where logisticsAddressState.CountryRegionId == _countryRegion
            {
                this.addStateToTempTable(_countryRegion, logisticsAddressState.StateId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addProductToTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the product-delivery mode associations to the temporary staging explosion table.
    /// Explodes the product to the variant level.
    /// </summary>
    /// <param name="_dlvMode">
    /// Delivery mode that needs to be added to the temporary table.
    /// </param>
    /// <param name="_productRecId">
    /// Product association that needs to be exploded to the temporary table.
    /// </param>
    /// <param name="_productExplodedSet">
    /// The set of product exploded records.
    /// </param>
    /// <param name="_productExplodedRecordInsertList">
    /// The collection of product exploded records that must be inserted into the database.
    /// </param>
    /// <param name="_inventTable">
    /// Released product that needs to be exploded to the temporary table.
    /// </param>
    private void addProductToTempTable(DlvMode _dlvMode, RefRecId _productRecId, Set _productExplodedSet, RecordInsertList _productExplodedRecordInsertList, InventTable _inventTable = null)
    {
        InventTable inventTable = _inventTable;

        // Stores the variants to be added for a partially excluded product.
        Set productVariantsList = new Set(Types::Int64);
        SetEnumerator productVariantsListEnumator;

        if (!inventTable)
        {
            inventTable = InventTable::findByProduct(_productRecId);
        }

        if (!inventTable)
        {
            // Skipping as item was not released to the legal entity.
            numItemsSkipped++;
            return;
        }

        numItemsExploded++;

        tmpProductExploded.DlvMode = _dlvMode.RecId;
        tmpProductExploded.ItemId = inventTable.ItemId;

        // Check if this product has at least one variant excluded. If so,
        // we need to insert all variants of this product except those that
        // have been specifically excluded.
        try
        {
            if (exclusions.isProductPartiallyExcluded(_productRecId))
            {
                productVariantsList = this.getVariantsByItemId(inventTable.ItemId);
                productVariantsListEnumator = productVariantsList.getEnumerator();
                ttsbegin;
                while (productVariantsListEnumator.moveNext())
                {
                    tmpProductExploded.InventDim = productVariantsListEnumator.current();
                    this.addTmpProductExploded(_productExplodedSet, _productExplodedRecordInsertList);
                }
                ttscommit;
            }
            else
            {
                // Reset the variant flag to ensure we include all variants of this product.
                tmpProductExploded.InventDim = "";
                ttsbegin;
                this.addTmpProductExploded(_productExplodedSet, _productExplodedRecordInsertList);
                ttscommit;
            }
        }
        catch (Exception::UpdateConflict)
        {
            str axCallStack = con2Str(xSession::xppCallStack());
            if (appl.ttsLevel() == 0)
            {
                this.logCatchExceptionWithRetries(funcName(), axCallStack, xSession::currentRetryCount());

                if (xSession::currentRetryCount() >= MaximumRetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    this.warningTimestamped("@Retail:DeliveryModeExplodeJobUpdateConflictRetryProductsAndVariants");

                    retry;
                }
            }
            else
            {
                this.logCatchExceptionWithUnbalancedTts(funcName(), axCallStack, appl.ttsLevel());

                throw Exception::UpdateConflict;
            }
        }
        catch  // any transaction exception like Exception::Deadlock, etc will come here for retry
        {
            str axCallStack = con2Str(xSession::xppCallStack());
            this.logCatchExceptionWithRetries(funcName(), axCallStack, xSession::currentRetryCount());

            if (xSession::currentRetryCount() >= MaximumRetryNum)
            {
                throw error("@Retail:DeliveryModeExplodeJobFailedAtProductsAndVariants"); // non-recoverable
            }
            else
            {
                // wait 5 seconds, 25 seconds in total with retries
                sleep(RetryWaitTime);

                // Retry after deadlock in processing products and variants.
                this.warningTimestamped("@Retail:DeliveryModeExplodeJobDeadlockRetryProductsAndVariants");

                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addAllCategoryToTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds all category-delivery mode associations to the table once.
    /// Explodes the category to the product/variant level.
    /// </summary>
    /// <param name="_categoryRecId">
    /// Category association that needs to be exploded to the temporary table.
    /// </param>
    /// <param name="_productExplodedSet">
    /// The set of product exploded records.
    /// </param>
    /// <param name="_productExplodedRecordInsertList">
    /// The collection of product exploded records that must be inserted into the database.
    /// </param>
    /// <param name="tmpExplodeCategoryTableToAdd">
    /// The collection of TmpRetailDlvModeExplodeAllCategories records to track the include/exclude list.
    /// </param>
    private void addAllCategoryToTempTable(RefRecId _categoryRecId, Set _productExplodedSet, RecordInsertList _productExplodedRecordInsertList, TmpRetailDlvModeExplodeAllCategories  tmpExplodeCategoryTableToAdd = tmpExplodeAllCategories)
    {
        const int CommitSize = 1000;
        int i = 0;
        Query           query;
        QueryRun        productsQueryRun;
        EcoResProduct   ecoResProduct;
        InventTable     inventTable;
        SetEnumerator   containedCategories;
        RefRecId        ecoResCategoryId;

        // Process all the products for this category and its sub categories
        containedCategories = RetailCategoryContainmentLookup::findContainedCategories(_categoryRecId);
        while (containedCategories.moveNext())
        {
            ecoResCategoryId = containedCategories.current();

            query = RetailGroupMemberLineQueryProvider::containedProductsQuery(ecoResCategoryId, false /*don't include SubCategories*/, curExt());
            productsQueryRun = new QueryRun(query);

            while (productsQueryRun.next())
            {
                ecoResProduct = productsQueryRun.get(tableNum(EcoResProduct));
                inventTable = productsQueryRun.get(tableNum(InventTable));
                if (!ecoResProduct)
                {
                    // The product was not found under the specified category.
                    continue;
                }

                // this bulky operation has to be committed at some point, e.g. after 1K products
                if (i == 0)
                {
                    ttsbegin;
                }

                this.addProductToTempTableOnceForAllCategories(ecoResProduct.RecId, ecoResCategoryId, _productExplodedSet, _productExplodedRecordInsertList, inventTable, tmpExplodeCategoryTableToAdd);
                i++;

                if (i >= CommitSize)
                {
                    ttscommit;
                    i = 0;
                }
            }

            if (i > 0)
            {
                // if there is anything left uncommitted in this category, commit now
                i = 0;
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addProductToTempTableOnceForAllCategories</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the product-delivery mode associations to the temporary explosion table for all categories.
    /// Explodes the product to the variant level.
    /// </summary>
    /// <param name="_productRecId">
    /// Product association that needs to be exploded to the temporary table.
    /// </param>
    /// <param name="_categoryRecId">
    /// Category association that needs to be exploded to the temporary table.
    /// </param>
    /// <param name="_productExplodedSet">
    /// The set of product exploded records.
    /// </param>
    /// <param name="_productExplodedRecordInsertList">
    /// The collection of product exploded records that must be inserted into the database.
    /// </param>
    /// <param name="_inventTable">
    /// Released product that needs to be exploded to the temporary table.
    /// </param>
    /// <param name="_tmpExplodeCategoryTableToAdd">
    /// The collection of TmpRetailDlvModeExplodeAllCategories records to track the include/exclude list.
    /// </param>
    private void addProductToTempTableOnceForAllCategories(RefRecId _productRecId, RefRecId _categoryRecId, Set _productExplodedSet, RecordInsertList _productExplodedRecordInsertList, InventTable _inventTable = null,
        TmpRetailDlvModeExplodeAllCategories  _tmpExplodeCategoryTableToAdd = tmpExplodeAllCategories)
    {
        InventTable inventTable = _inventTable;

        if (!inventTable)
        {
            inventTable = InventTable::findByProduct(_productRecId);
        }

        if (!inventTable)
        {
            // Skipping as item was not released to the legal entity.
            numItemsSkipped++;
            return;
        }

        numItemsExploded++;

        _tmpExplodeCategoryTableToAdd.DlvMode = 0;
        _tmpExplodeCategoryTableToAdd.ItemId = inventTable.ItemId;
        _tmpExplodeCategoryTableToAdd.RefRecIdProduct = _productRecId;
        _tmpExplodeCategoryTableToAdd.RefRecIdCategory = _categoryRecId;
        _tmpExplodeCategoryTableToAdd.RefRecIdVariant = 0;

        _tmpExplodeCategoryTableToAdd.InventDim = "";
        this.addTmpProductExplodedAllCategories(_productExplodedSet, _productExplodedRecordInsertList, _tmpExplodeCategoryTableToAdd);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTmpProductExploded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the product-delivery mode associations records to the <c>productExplodedRecordInsertList</c> RecordInsertList.
    /// </summary>
    /// <param name="_productExplodedSet">
    /// The set of product exploded records.
    /// </param>
    /// <param name="_productExplodedRecordInsertList">
    /// The collection of product exploded records that must be inserted into the database.
    /// </param>
    private void addTmpProductExploded(Set _productExplodedSet, RecordInsertList _productExplodedRecordInsertList)
    {
        if (_productExplodedSet.add([tmpProductExploded.DlvMode, tmpProductExploded.ItemId, tmpProductExploded.InventDim]))
        {
            _productExplodedRecordInsertList.add(tmpProductExploded);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTmpProductExplodedAllCategories</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the product-delivery mode associations records to the <c>productExplodedAllCategoriesRecordInsertList</c> RecordInsertList.
    /// </summary>
    /// <param name="_productExplodedSet">
    /// The set of product exploded records.
    /// </param>
    /// <param name="_productExplodedRecordInsertList">
    /// The collection of product exploded records that must be inserted into the database.
    /// </param>
    /// <param name="_tmpExplodeCategoryTableToAdd">
    /// The collection of TmpRetailDlvModeExplodeAllCategories records to track the include/exclude list.
    /// </param>
    private void addTmpProductExplodedAllCategories(Set _productExplodedSet, RecordInsertList _productExplodedRecordInsertList, TmpRetailDlvModeExplodeAllCategories  _tmpExplodeCategoryTableToAdd = tmpExplodeAllCategories)
    {
        if (_productExplodedSet.add([_tmpExplodeCategoryTableToAdd.DlvMode, _tmpExplodeCategoryTableToAdd.ItemId, _tmpExplodeCategoryTableToAdd.InventDim,
            _tmpExplodeCategoryTableToAdd.RefRecIdCategory, _tmpExplodeCategoryTableToAdd.RefRecIdProduct, _tmpExplodeCategoryTableToAdd.RefRecIdVariant]))
        {
            _productExplodedRecordInsertList.add(_tmpExplodeCategoryTableToAdd);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addStateToTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the Address-delivery mode associations to the temporary staging explosion table.
    /// </summary>
    /// <param name="_countryRegion">
    /// Country association that needs to be added to the temporary table.
    /// </param>
    /// <param name="_state">
    /// State association that needs to be added to the temporary table.
    /// </param>
    private void addStateToTempTable(LogisticsAddressCountryRegionId _countryRegion, AddressStateId _state)
    {
        RefRecId _dlvModeRecId = this.getDlvModeRecId();

        if (!LogisticsAddressState::exist(_countryRegion, _state))
        {
            // State doesn't exist
            error(strFmt("@RET490082", _countryRegion, _state, this.getDeliveryModeCode(_dlvModeRecId)));
            return;
        }

        if (!addressExclusions.isStateExcluded(_dlvModeRecId, _countryRegion, _state))
        {
            select firstOnly tmpAddressExploded
            where tmpAddressExploded.DlvMode == _dlvModeRecId
                && tmpAddressExploded.CountryRegion == _countryRegion
                && tmpAddressExploded.State == _state;

            if (!tmpAddressExploded)
            {
                // Insert the exploded state into temp table, if it is not already excluded
                // and hasn't been already inserted
                tmpAddressExploded.DlvMode = _dlvModeRecId;
                tmpAddressExploded.CountryRegion = _countryRegion;
                tmpAddressExploded.State = _state;
                tmpAddressExploded.doInsert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addVariantToTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the variant-delivery mode associations to the temporary staging explosion table.
    /// </summary>
    /// <param name="_dlvMode">
    /// Delivery mode that needs to be added to the temporary table.
    /// </param>
    /// <param name="_variantRecId">
    /// Variant association that needs to be added to the temporary table.
    /// </param>
    /// <param name="_productExplodedSet">
    /// The set of product exploded records.
    /// </param>
    /// <param name="_productExplodedRecordInsertList">
    /// The collection of product exploded records that must be inserted into the database.
    /// </param>
    private void addVariantToTempTable(DlvMode _dlvMode, RefRecId _variantRecId, Set _productExplodedSet, RecordInsertList _productExplodedRecordInsertList)
    {
        InventTable                     inventTable;
        InventDimCombination            inventDimCombination;

        inventDimCombination = InventDimCombination::findByDistinctProductVariant(_variantRecId);
        if (!inventDimCombination)
        {
            // Skipping as variant was not released to this legal entity.
            return;
        }

        inventTable = InventTable::find(inventDimCombination.ItemId);
        if (!inventTable)
        {
            // Skipping as item was not released to this legal entity.
            numItemsSkipped++;
            return;
        }

        numItemsExploded++;

        try
        {
            // Insert the exploded variant into temp table.
            tmpProductExploded.DlvMode = _dlvMode.RecId;
            tmpProductExploded.ItemId = inventDimCombination.ItemId;
            tmpProductExploded.InventDim = inventDimCombination.InventDimId;
            ttsbegin;
            this.addTmpProductExploded(_productExplodedSet, _productExplodedRecordInsertList);
            ttscommit;
        }
        catch (Exception::UpdateConflict)
        {
            str axCallStack = con2Str(xSession::xppCallStack());
            if (appl.ttsLevel() == 0)
            {
                this.logCatchExceptionWithRetries(funcName(), axCallStack, xSession::currentRetryCount());

                if (xSession::currentRetryCount() >= MaximumRetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    // Retry after update conflict in processing channels.
                    this.warningTimestamped("@Retail:DeliveryModeExplodeJobUpdateConflictRetryProductsAndVariants");

                    retry;
                }
            }
            else
            {
                this.logCatchExceptionWithUnbalancedTts(funcName(), axCallStack, appl.ttsLevel());

                throw Exception::UpdateConflict;
            }
        }
        catch  // any transaction exception like Exception::Deadlock, etc will come here for retry
        {
            str axCallStack = con2Str(xSession::xppCallStack());
            this.logCatchExceptionWithRetries(funcName(), axCallStack, xSession::currentRetryCount());

            if (xSession::currentRetryCount() >= MaximumRetryNum)
            {
                throw error("@Retail:DeliveryModeExplodeJobFailedAtProductsAndVariants"); // non-recoverable
            }
            else
            {
                // wait 5 seconds, 25 seconds in total with retries
                sleep(RetryWaitTime);

                // Retry after deadlock in processing products and variants.
                this.warningTimestamped("@Retail:DeliveryModeExplodeJobDeadlockRetryProductsAndVariants");

                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deltaSyncAddresses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies only changed records from <c>tmpRetailDlvModeAddressExploded</c> to the
    /// <c>RetailDlvModeAddressExploded</c> table. This ensures that only the changes are
    /// captured by the PREACTION overrides.
    /// </summary>
    private void deltaSyncAddresses()
    {
        RetailDlvModeAddressExploded    exploded;
        int                             countRecordsVisited;
        int                             countRecordsUpdated;

        // The set of recIds to keep (we delete all others).
        Set recordsToKeep = new Set(Types::Int64);

        countRecordsVisited = 0;
        countRecordsUpdated = 0;

        RefRecId _dlvModeRecId = this.getDlvModeRecId();

        while select tmpAddressExploded
            where tmpAddressExploded.DlvMode == _dlvModeRecId
        {
            ++countRecordsVisited;
            select firstOnly RecId from exploded
            where
                exploded.DlvMode == tmpAddressExploded.DlvMode &&
                exploded.CountryRegion == tmpAddressExploded.CountryRegion &&
                exploded.State == tmpAddressExploded.State;

            if (!exploded)
            {
                // No matching record found; this is the insert case.
                exploded.DlvMode = tmpAddressExploded.DlvMode;
                exploded.CountryRegion = tmpAddressExploded.CountryRegion;
                exploded.State = tmpAddressExploded.State;
                exploded.insert();

                ++countRecordsUpdated;
            }

            recordsToKeep.add(exploded.RecId);
        }

        while select forUpdate RecId
            from exploded
            where exploded.DlvMode == _dlvModeRecId
        {
            if (!recordsToKeep.in(exploded.RecId))
            {
                ++countRecordsUpdated;
                exploded.delete();
            }
        }

        eventSource.EventWriteProcessDeliveryModesDeltaSyncAddressesInfo(_dlvModeRecId, countRecordsVisited, countRecordsUpdated);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deltaSyncChannels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies only changed records from <c>tmpRetailDlvModeChannelExploded</c> to the
    /// <c>RetailDlvModeChannelExploded</c> table. This ensures that only the changes are
    /// captured by the PREACTION overrides.
    /// </summary>
    private void deltaSyncChannels()
    {
        RetailDlvModeChannelExploded    exploded;
        int                             countRecordsVisited;
        int                             countRecordsUpdated;

        // The set of recIds to keep (we delete all others).
        Set recordsToKeep = new Set(Types::Int64);

        countRecordsVisited = 0;
        countRecordsUpdated = 0;

        RefRecId _dlvModeRecId = this.getDlvModeRecId();

        // In-Memory tables cannot be joined in X++.
        while select tmpChannelExploded
            where tmpChannelExploded.DlvMode == _dlvModeRecId
        {
            ++countRecordsVisited;
            select firstOnly RecId from exploded
            where
                exploded.DlvMode == tmpChannelExploded.DlvMode &&
                exploded.OMOperatingUnit == tmpChannelExploded.OMOperatingUnit;

            if (!exploded)
            {
                // No matching record found; this is the insert case.
                exploded.DlvMode = tmpChannelExploded.DlvMode;
                exploded.OMOperatingUnit = tmpChannelExploded.OMOperatingUnit;
                exploded.insert();

                ++countRecordsUpdated;
            }

            recordsToKeep.add(exploded.RecId);
        }

        while select forUpdate RecId
            from exploded
            where exploded.DlvMode == _dlvModeRecId
        {
            if (!recordsToKeep.in(exploded.RecId))
            {
                ++countRecordsUpdated;
                exploded.delete();
            }
        }

        eventSource.EventWriteProcessDeliveryModesDeltaSyncChannelsInfo(_dlvModeRecId, countRecordsVisited, countRecordsUpdated);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deltaSyncProductsAndVariants</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies only changed records from <c>tmpRetailDlvModeProductExploded</c> to the
    /// <c>RetailDlvModeProductExploded</c> table. This ensures that only the changes are
    /// captured by the PREACTION overrides.
    /// </summary>
    private void deltaSyncProductsAndVariants()
    {
        RetailDlvModeProductExploded    exploded;
        RetailDlvModeProductExploded    checkExploded;
        RetailDlvModeProductExploded    supplementalExcluded;

        RefRecId _dlvModeRecId = this.getDlvModeRecId();

        // Ensure set based operations are not downgraded to record-by-record operations
        exploded.skipDatabaseLog(true);
        exploded.skipEvents(true);

        delete_from exploded
            where exploded.DlvMode == _dlvModeRecId
            notexists join tmpProductExploded
                where tmpProductExploded.DlvMode == exploded.DlvMode
                    && tmpProductExploded.ItemId == exploded.ItemId
                    && tmpProductExploded.InventDim == exploded.InventDim;
        int64 countRecordsDeleted = exploded.RowCount();
        
        insert_recordset exploded(DlvMode, ItemId, InventDim)
        select DlvMode, ItemId, InventDim from tmpProductExploded
        notexists join checkExploded
            where checkExploded.DlvMode == tmpProductExploded.DlvMode
                && checkExploded.ItemId == tmpProductExploded.ItemId
                && checkExploded.InventDim == tmpProductExploded.InventDim;
        int64 countRecordsInserted = exploded.RowCount();

        if(RetailDlvModeExplodeSupplementalExclusionToggle::instance().isEnabled())
        {
            // Handle excluded products from supplemental category
            delete_from supplementalExcluded
                where supplementalExcluded.DlvMode == _dlvModeRecId
                exists join tmpExplodedSupplementalCategoryExclusion
                where supplementalExcluded.ItemId == tmpExplodedSupplementalCategoryExclusion.ItemId;
        }

        eventSource.EventWriteProcessDeliveryModesDeltaSyncProductsAndVariantsInfo(_dlvModeRecId, countRecordsInserted, countRecordsDeleted);
    }

]]></Source>
			</Method>
			<Method>
				<Name>explodeAddresses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Explodes the Address-delivery mode associations to the temporary staging explosion table.
    /// </summary>
    private void explodeAddresses()
    {
        RetailDlvModeAddressLine addressLine;
        RefRecId _dlvModeRecId = this.getDlvModeRecId();

        tmpAddressExploded.setTmp();

        addressExclusions.clear();

        while select addressLine
            order by addressLine.DlvMode, addressLine.LineType // Process Exclusions first
            where addressLine.DlvMode == _dlvModeRecId
        {
            if (addressLine.LineType == RetailDlvModeExcludeIncludeType::Exclude)
            {
                // Populate the exclusion list
                addressExclusions.addExclusion(addressLine.DlvMode, addressLine.CountryRegion, addressLine.State);
            }
            else // The address line is being included
            {
                if (addressLine.State)
                {
                    this.addStateToTempTable(addressLine.CountryRegion, addressLine.State);
                }
                else
                {
                    this.addCountryToTempTable(addressLine.CountryRegion);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>explodeChannels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Explodes the channel associations for the delivery modes
    /// </summary>
    private void explodeChannels()
    {
        RetailDlvModeChannelLine        channel;

        OMOperatingUnit                 omOperatingUnit;
        Set                             omOperatingUnits;
        SetEnumerator                   omOperatingUnitsEnumerator;

        Set organizationTypes           = new Set(Types::Enum);

        // Used to filter the organization model to include only operating units.
        organizationTypes.add(OMInternalOrganizationType::OperatingUnit);

        RefRecId _dlvModeRecId = this.getDlvModeRecId();
        while select channel
            where channel.DlvMode == _dlvModeRecId
        {
            // Filter the organization model to include only operating units effective as of right now.
            omOperatingUnits = OMInternalOrganization::getDescendantsAndSelf(channel.OMInternalOrganization, channel.OMHierarchyType, DateTimeUtil::utcNow(), organizationTypes);
            omOperatingUnitsEnumerator = omOperatingUnits.getEnumerator();
            while (omOperatingUnitsEnumerator.moveNext())
            {
                omOperatingUnit = OMOperatingUnit::find(omOperatingUnitsEnumerator.current(), OMOperatingUnitType::RetailChannel);
                if (!omOperatingUnit)
                {
                    // The operating unit was not a retail channel. No need to explode it.
                    continue;
                }

                // Insert the delivery mode and channel association in the temporary exploded table
                tmpChannelExploded.DlvMode = _dlvModeRecId;
                tmpChannelExploded.OMOperatingUnit = omOperatingUnit.RecId;
                tmpChannelExploded.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>explodeProductsAndVariants</Name>
				<Source><![CDATA[
    /// <summary>
    /// Explodes the products and variant associations for the delivery mode
    /// </summary>
    private void explodeProductsAndVariants()
    {
        DlvMode                         dlvMode;
        RetailDlvModeProductLine        product, productLine;
        RetailGroupMemberLine           groupMemberLine;

        RefRecId                        ecoResCategoryId;
        EcoResCategory                  ecoResCategory;
        EcoResProduct                   ecoResProduct;
        EcoResDistinctProductVariant    ecoResDistinctProductVariant;
        SetEnumerator                   containedCategories;
        EcoResCategoryHierarchy         categoryHierarchy;
        // Stores the variants to be added for a partially excluded product.
        InventDimCombination            inventDimCombination;
        boolean                         isAllCategoriesExploded = false;
        boolean                         isAllCategoryInDlvMode = false;

        // Reset the counters.
        numItemsExploded = 0;
        numItemsSkipped = 0;
        numItemsError = 0;
        numItemsExploded2 = 0;
        numItemsSkipped2 = 0;

        delete_from tmpExplodeAllCategories;
        delete_from exclusions;

        Set productExplodedSet = new Set(Types::Container);
        RecordInsertList productExplodedRecordInsertList = new RecordInsertList(
            tableNum(TmpRetailDlvModeProductExploded),
            true, // skip insert
            true, // skip database log
            true, // skip events
            true, // skip aos validation
            true, // skip RLS validation
            tmpProductExploded); // buffer where records will be inserted

        Set productExplodedSetAllCategories = new Set(Types::Container);
        RecordInsertList productExplodedAllCategoriesRecordInsertList = new RecordInsertList(
            tableNum(TmpRetailDlvModeExplodeAllCategories),
            true, // skip insert
            true, // skip database log
            true, // skip events
            true, // skip aos validation
            true, // skip RLS validation
            tmpExplodeAllCategories); // buffer where records will be inserted

        Set productExplodedSupplenmantalExclusion = new Set(Types::Container);
        RecordInsertList productExplodedSupplenmantalExclusionRecordInsertList = new RecordInsertList(
            tableNum(TmpRetailDlvModeExplodeAllCategories),
            true, // skip insert
            true, // skip database log
            true, // skip events
            true, // skip aos validation
            true, // skip RLS validation
            tmpExplodedSupplementalCategoryExclusion); // buffer where records will be inserted

        EcoResCategoryHierarchy retailHierarchy = RetailDlvModeExplodeTask::getRetailHierarchyIfExists();

        RefRecId _dlvModeRecId = this.getDlvModeRecId();

        using (var timer = RetailDlvModeExplodeStageTimer::construct(_dlvModeRecId, 'ExplodeProductsAndVariants/isAllCategoriesExploded'))
        {
            if (!isAllCategoriesExploded)
            {
                select firstonly Category, RecId from groupMemberLine
                    join ecoResCategory
                where groupMemberLine.Category == ecoResCategory.RecId
                && ecoResCategory.CategoryHierarchy == retailHierarchy.RecId
                && ecoResCategory.IsActive == NoYes::Yes
                && ecoResCategory.Level == 1; // Search for category that has the highest level in retail category hierarchy.
   
                if (groupMemberLine)
                {
                    dlvMode = DlvMode::findRecId(_dlvModeRecId);
                    refRecIdCategory = groupMemberLine.Category;
                    this.addAllCategoryToTempTable(refRecIdCategory, productExplodedSetAllCategories, productExplodedAllCategoriesRecordInsertList, tmpExplodeAllCategories);
                    int recordCount = productExplodedAllCategoriesRecordInsertList.insertDatabase();
                    eventSource.EventWriteProcessDeliveryModesExplodeAllCategoriesStatistics(_dlvModeRecId, recordCount);

                    isAllCategoriesExploded = true;
                }
            }
        }

        select firstonly Variant, RecId, Category, Product from groupMemberLine
            join productLine
            where groupMemberLine.RecId == productLine.RetailGroupMemberLine
            && productLine.DlvMode == _dlvModeRecId
            && groupMemberLine.Category == ecoResCategory.RecId
            && groupMemberLine.Product == 0;

        if (!isAllCategoryInDlvMode && !groupMemberLine)
        {
            isAllCategoryInDlvMode = true; // if current delivery mode doesn't have All categories specified in Products tab then perform earlier behaviour.
        }

        if (isAllCategoriesExploded && !isAllCategoryInDlvMode)
        {
            delete_from tmpExploded;
            insert_recordset tmpExploded(DlvMode, ItemId, InventDim, RefRecIdCategory, RefRecIdProduct, RefRecIdVariant)
                select DlvMode, ItemId, InventDim, RefRecIdCategory, RefRecIdProduct, RefRecIdVariant
                    from tmpExplodeAllCategories; // insert products for All categories into TmpRetailDlvModeExplodeAllCategories table for manipulation.

            numItemsExploded2 = numItemsExploded1;
            numItemsSkipped2 = numItemsSkipped1;

            update_recordset tmpExploded
                setting DlvMode = _dlvModeRecId; // update the current delivery mode in the staging table.
        }

        using (var allIterationsTimer = RetailDlvModeExplodeStageTimer::construct(_dlvModeRecId, 'ExplodeProductsAndVariants/ProductsWhileLoop'))
        {
            QueryRun queryRun = new QueryRun(this.getDlvModeProductsQuery(_dlvModeRecId));
            while (queryRun.next())
            {
                dlvMode = queryRun.get(tableNum(DlvMode));
                product = queryRun.get(tableNum(RetailDlvModeProductLine));
                groupMemberLine = queryRun.get(tableNum(RetailGroupMemberLine));

                str loopKey = strFmt('ExplodeProductsAndVariants/ProductsWhileLoop/%1-%2', product.RecId, groupMemberLine.RecId);

                using (var innerTimer = RetailDlvModeExplodeStageTimer::construct(_dlvModeRecId, loopKey))
                {
                    if (product.LineType == RetailDlvModeExcludeIncludeType::Exclude)
                    {
                        // Here we need to check from the bottom up (variants, products and then categories).
                        if (groupMemberLine.Variant)
                        {
                            ecoResDistinctProductVariant = EcoResDistinctProductVariant::find(groupMemberLine.Variant);
                            if (!ecoResDistinctProductVariant)
                            {
                                numItemsError++;
                                error(strFmt("@RET261118", groupMemberLine.Variant, dlvMode.Code));
                                continue;
                            }

                            tmpExploded = TmpRetailDlvModeExplodeAllCategories::findByProduct(tmpExploded, groupMemberLine, _dlvModeRecId);
                            // If not already excluded, add the variant to the exclusion list.
                            if (!exclusions.isVariantExcluded(ecoResDistinctProductVariant.RecId) && isAllCategoryInDlvMode)
                            {
                                exclusions.addVariantExclusion(ecoResDistinctProductVariant.RecId);

                                // If not already included, add the product to the list of
                                // partially excluded products. A partially excluded product
                                // is a product which has one or more of its variants excluded.
                                ecoResProduct = EcoResProduct::find(ecoResDistinctProductVariant.ProductMaster);
                                if (!ecoResProduct)
                                {
                                    numItemsError++;
                                    error(strFmt("@RET261119", groupMemberLine.Variant, dlvMode.Code, ecoResDistinctProductVariant.ProductMaster));
                                    continue;
                                }

                                if (!exclusions.isProductPartiallyExcluded(ecoResProduct.RecId))
                                {
                                    exclusions.addPartialProductExclusion(ecoResProduct.RecId);
                                }
                            }
                            else if (!tmpExploded.InventDim && tmpExploded.RefRecIdProduct && isAllCategoriesExploded && !isAllCategoryInDlvMode)
                            {
                                itemId = tmpExploded.ItemId;

                                delete_from tmpExploded
                                where tmpExploded.ItemId == itemId
                                && tmpExploded.RefRecIdProduct == groupMemberLine.Product
                                && tmpExploded.RefRecIdCategory == groupMemberLine.Category
                                && tmpExploded.DlvMode == _dlvModeRecId; // delete the product and include its variant.

                                numItemsExploded2--;

                                Set productExplodedSetStaging = new Set(Types::Container);
                                RecordInsertList productExplodedInStagingRecordInsertList = new RecordInsertList(
                                    tableNum(TmpRetailDlvModeExplodeAllCategories),
                                    true, // skip insert
                                    true, // skip database log
                                    true, // skip events
                                    true, // skip aos validation
                                    true, // skip RLS validation
                                    tmpExploded); // buffer where records will be inserted

                                // Since, All categories is included
                                // then identify the product for which variant is excluded.
                                // insert rest of the variants.
                                ttsbegin;
                                while select InventDimId, DistinctProductVariant
                                from inventDimCombination
                                where inventDimCombination.ItemId == itemId
                                {
                                    if (groupMemberLine.Variant != inventDimCombination.DistinctProductVariant)
                                    {
                                        tmpExploded = TmpRetailDlvModeExplodeAllCategories::findByVariant(tmpExploded, inventDimCombination.DistinctProductVariant, groupMemberLine, _dlvModeRecId);

                                        if (!tmpExploded)
                                        {
                                            tmpExploded.InventDim = inventDimCombination.InventDimId;
                                            tmpExploded.ItemId = itemId;
                                            tmpExploded.DlvMode = dlvMode.RecId;
                                            tmpExploded.RefRecIdCategory = groupMemberLine.Category;
                                            tmpExploded.RefRecIdProduct = groupMemberLine.Product;
                                            tmpExploded.RefRecIdVariant = inventDimCombination.DistinctProductVariant;
                                            productExplodedInStagingRecordInsertList.add(tmpExploded);
                                            numItemsExploded2++;
                                        }
                                    }
                                }
                                productExplodedInStagingRecordInsertList.insertDatabase();
                                ttscommit;
                            }
                            else if (TmpRetailDlvModeExplodeAllCategories::existVariant(tmpExploded, groupMemberLine, _dlvModeRecId) && isAllCategoriesExploded && !isAllCategoryInDlvMode)
                            {
                                delete_from tmpExploded
                                where tmpExploded.RefRecIdVariant == groupMemberLine.Variant
                                && tmpExploded.RefRecIdProduct == groupMemberLine.Product
                                && tmpExploded.RefRecIdCategory == groupMemberLine.Category
                                && tmpExploded.DlvMode == _dlvModeRecId;
                            }
                        }
                        else if (groupMemberLine.Product)
                        {
                            ecoResProduct = EcoResProduct::find(groupMemberLine.Product);
                            if (!ecoResProduct)
                            {
                                numItemsError++;
                                error(strFmt("@RET261120", groupMemberLine.Product, dlvMode.Code));
                                continue;
                            }

                            // If not already excluded, add the product to the exclusion list.
                            if (!exclusions.isProductExcluded(ecoResProduct.RecId) && isAllCategoryInDlvMode)
                            {
                                exclusions.addProductExclusion(ecoResProduct.RecId);
                            }
                            else if (isAllCategoriesExploded && !isAllCategoryInDlvMode)
                            {
                                // Since, All categories have the product that needs to be excluded.
                                // Identify the record and delete it.
                                tmpExploded = TmpRetailDlvModeExplodeAllCategories::findByProduct(tmpExploded, groupMemberLine, _dlvModeRecId);
                                if (tmpExploded)
                                {
                                    delete_from tmpExploded
                                        where tmpExploded.RefRecIdProduct == ecoResProduct.RecId
                                        && tmpExploded.RefRecIdCategory == groupMemberLine.Category
                                        && tmpExploded.DlvMode == _dlvModeRecId;

                                    numItemsExploded2--;
                                }
                            }
                        }
                        else if (groupMemberLine.Category)
                        {
                            ecoResCategory = EcoResCategory::find(groupMemberLine.Category);
                            if (!ecoResCategory)
                            {
                                numItemsError++;
                                error(strFmt("@RET261121", groupMemberLine.Category, dlvMode.Code));
                                continue;
                            }

                            EcoResCategoryHierarchyRole ecoResCategoryHierarchyRoleTemp = null;
                            select firstonly ecoResCategoryHierarchyRoleTemp where ecoResCategoryHierarchyRoleTemp.CategoryHierarchy == ecoResCategory.CategoryHierarchy;

                            if(RetailDlvModeExplodeSupplementalExclusionToggle::instance().isEnabled() && ecoResCategoryHierarchyRoleTemp.NamedCategoryHierarchyRole == EcoResCategoryNamedHierarchyRole::RetailSpecialGroup)
                            {
                                // category is a supplemental category containing a list of excluded products.
                                this.addAllCategoryToTempTable(ecoResCategory.RecId, productExplodedSupplenmantalExclusion, productExplodedSupplenmantalExclusionRecordInsertList, tmpExplodedSupplementalCategoryExclusion);
                                int recordCount = productExplodedSupplenmantalExclusionRecordInsertList.insertDatabase();
                                eventSource.EventWriteOrdersDeltaSyncProductsAndVariantsInfo(funcName(), recordCount, 0);
                            }
                            else
                            {
                                // If not already excluded, add the category and all of its contained
                                // categories to the exclusion list.
                                containedCategories = RetailCategoryContainmentLookup::findContainedCategories(ecoResCategory.RecId);
                                while (containedCategories.moveNext())
                                {
                                    ecoResCategoryId = containedCategories.current();
                                    if (!exclusions.isCategoryExcluded(ecoResCategoryId) && isAllCategoryInDlvMode)
                                    {
                                        exclusions.addCategoryExclusion(ecoResCategoryId);
                                    }
                                    else if (isAllCategoriesExploded && !isAllCategoryInDlvMode)
                                    {
                                        // Since, All categories have the category that needs to be excluded.
                                        // Identify the record and delete it.
                                        tmpExploded = TmpRetailDlvModeExplodeAllCategories::findByCategory(tmpExploded, ecoResCategoryId, _dlvModeRecId);
                                        if (tmpExploded)
                                        {
                                            select count(RecId) from tmpExploded
                                        where tmpExploded.RefRecIdCategory == ecoResCategoryId
                                            && tmpExploded.DlvMode == _dlvModeRecId;

                                            numItemsExploded2 = numItemsExploded2 - tmpExploded.RecId;

                                            delete_from tmpExploded
                                        where tmpExploded.RefRecIdCategory == ecoResCategoryId
                                            && tmpExploded.DlvMode == _dlvModeRecId;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else // A group member line is being included.
                    {
                        // Here we need to check from the bottom up (variants, products and then categories).
                        if (groupMemberLine.Variant)
                        {
                            ecoResDistinctProductVariant = EcoResDistinctProductVariant::find(groupMemberLine.Variant);
                            if (!ecoResDistinctProductVariant)
                            {
                                numItemsError++;
                                error(strFmt("@RET261118", groupMemberLine.Variant, dlvMode.Code));
                                continue;
                            }

                            ecoResProduct = EcoResProduct::find(ecoResDistinctProductVariant.ProductMaster);
                            if (!ecoResProduct)
                            {
                                numItemsError++;
                                error(strFmt("@RET261119", groupMemberLine.Variant, dlvMode.Code, ecoResDistinctProductVariant.ProductMaster));
                                continue;
                            }

                            // If the product and variant have not been excluded, check whether the
                            // product belongs to an excluded category.
                            if (!exclusions.isProductExcluded(ecoResProduct.RecId) &&
                        !exclusions.isVariantExcluded(ecoResDistinctProductVariant.RecId) && isAllCategoryInDlvMode)
                            {
                                if (!groupMemberLine.Category)
                                {
                                    groupMemberLine.Category = this.getEcoResCategoryIdByProduct(groupMemberLine.Product);
                                }

                                // Find the category to check whether it has been excluded.
                                ecoResCategory = EcoResCategory::find(groupMemberLine.Category);

                                // If this product variant is not a member of an excluded category,
                                // insert this record into the staging table.
                                if (!exclusions.isCategoryExcluded(ecoResCategory.RecId))
                                {
                                    this.addVariantToTempTable(dlvMode, groupMemberLine.Variant, productExplodedSet, productExplodedRecordInsertList);
                                }
                            }
                        }
                        else if (groupMemberLine.Product)
                        {
                            ecoResProduct = EcoResProduct::find(groupMemberLine.Product);
                            if (!ecoResProduct)
                            {
                                numItemsError++;
                                error(strFmt("@RET261120", groupMemberLine.Product, dlvMode.Code));
                                continue;
                            }

                            // If this product has not been excluded, check whether the product
                            // belongs to an excluded category.
                            if (!exclusions.isProductExcluded(ecoResProduct.RecId))
                            {
                                if (!groupMemberLine.Category)
                                {
                                    groupMemberLine.Category = this.getEcoResCategoryIdByProduct(groupMemberLine.Product);
                                }

                                // Find the category to check whether it has been excluded.
                                ecoResCategory = EcoResCategory::find(groupMemberLine.Category);

                                // If this product is not a member of an excluded category,
                                // insert this record into the staging table.
                                if (!exclusions.isCategoryExcluded(ecoResCategory.RecId) && (isAllCategoryInDlvMode || groupMemberLine.Category == 0))
                                {
                                    this.addProductToTempTable(dlvMode, ecoResProduct.RecId, productExplodedSet, productExplodedRecordInsertList);
                                }
                            }
                        }
                        else if (groupMemberLine.Category)
                        {
                            ecoResCategory = EcoResCategory::find(groupMemberLine.Category);
                            if (!ecoResCategory)
                            {
                                numItemsError++;
                                error(strFmt("@RET261121", groupMemberLine.Category, dlvMode.Code));
                                continue;
                            }

                            // If the category has not been excluded, expand the node to find all products.
                            if (!exclusions.isCategoryExcluded(ecoResCategory.RecId) && isAllCategoryInDlvMode)
                            {
                                this.addCategoryToTempTable(dlvMode, ecoResCategory.RecId, productExplodedSet, productExplodedRecordInsertList);
                            }
                            else if (isAllCategoriesExploded && !isAllCategoryInDlvMode)
                            {
                                // Since, All categories is already included.
                                // Skip the condition.
                                continue;
                            }
                        }
                    }
                }
            }
        }

        try
        {

            if (!isAllCategoryInDlvMode)
            {
                productExplodedRecordInsertList.insertDatabase();

                // Insert the staging records into TmpRetailDlvModeProductExploded table for the current delivery mode.
                insert_recordset tmpProductExploded(DlvMode, ItemId, InventDim)
                select DlvMode, ItemId, InventDim from tmpExploded;

                numItemsExploded = numItemsExploded + numItemsExploded2;
                numItemsSkipped = numItemsSkipped + numItemsSkipped2;
            }
            else
            {
                // flushes records to the database whenever it will speed up performance.
                productExplodedRecordInsertList.insertDatabase();
            }
        }
        catch (Exception::DuplicateKeyExceptionNotRecovered)
        {
            // log the exception
            this.logCatchExceptionWithRetries(funcName(), con2Str(xSession::xppCallStack()), xSession::currentRetryCount());

            // log the duplicate error occured
            error(infolog.text(infologLine()));
            this.warningTimestamped("@Retail:DeliveryModeExplodeJobDuplicateKeyExceptionNotRecoveredProductsAndVariants");

            throw;
        }
        catch (Exception::UpdateConflict)
        {
            str axCallStack = con2Str(xSession::xppCallStack());
            if (appl.ttsLevel() == 0)
            {
                this.logCatchExceptionWithRetries(funcName(), axCallStack, xSession::currentRetryCount());

                if (xSession::currentRetryCount() >= MaximumRetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    // Retry after update conflict.
                    this.warningTimestamped("@Retail:DeliveryModeExplodeJobUpdateConflictRetryProductsAndVariants");

                    retry;
                }
            }
            else
            {
                this.logCatchExceptionWithUnbalancedTts(funcName(), axCallStack, appl.ttsLevel());

                throw Exception::UpdateConflict;
            }
        }
        catch  // any transaction exception like Exception::Deadlock, etc will come here for retry
        {
            str axCallStack = con2Str(xSession::xppCallStack());
            this.logCatchExceptionWithRetries(funcName(), axCallStack, xSession::currentRetryCount());

            if (xSession::currentRetryCount() >= MaximumRetryNum)
            {
                throw error("@Retail:DeliveryModeExplodeJobFailedAtProductsAndVariants"); // non-recoverable
            }
            else
            {
                // wait 5 seconds, 25 seconds in total with retries
                sleep(RetryWaitTime);

                // Retry after deadlock in processing products and variants.
                this.warningTimestamped("@Retail:DeliveryModeExplodeJobDeadlockRetryProductsAndVariants");

                retry;
            }
        }

        this.infoTimestamped(strFmt("@RET261122", this.getDeliveryModeCode(_dlvModeRecId), numItemsExploded, numItemsSkipped, numItemsError));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDeliveryModeCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the code of the current delivery mode.
    /// </summary>
    /// <param name="_dlvModeId">
    /// Id of the delivery mode.
    /// </param>
    /// <returns>
    /// The code for delivery mode. If none could be found, we return the RecId.
    /// </returns>
    private str getDeliveryModeCode(RefRecId _dlvModeId)
    {
        DlvMode dlvMode;

        select firstOnly Code
            from dlvMode
            where dlvMode.RecID == _dlvModeId;

        if (!dlvMode)
        {
            return int642str(_dlvModeId);
        }

        return dlvMode.Code;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDlvModeProductsQuery</Name>
				<Source><![CDATA[
    private Query getDlvModeProductsQuery(RefRecId _dlvModeId)
    {
        Query                       query = new Query();
        QueryBuildDataSource        queryBuildDataSource;
        QueryBuildRange             queryBuildRange;
        ;

        // select from DlvMode table
        queryBuildDataSource = query.addDataSource(tableNum(DlvMode));
        queryBuildRange = queryBuildDataSource.addRange(fieldNum(DlvMode, RecId));
        queryBuildRange.value(queryValue(_dlvModeId));

        // join RetailDlvModeProductLine, order by line type to process excludes first
        queryBuildDataSource = queryBuildDataSource.addDataSource(tableNum(RetailDlvModeProductLine));
        queryBuildDataSource.relations(false);
        queryBuildDataSource.addLink(fieldNum(DlvMode, RecId), fieldNum(RetailDlvModeProductLine, DlvMode));
        queryBuildDataSource.addOrderByField(fieldNum(RetailDlvModeProductLine, LineType));

        // join RetailGroupMemberLine
        queryBuildDataSource = queryBuildDataSource.addDataSource(tableNum(RetailGroupMemberLine));
        queryBuildDataSource.relations(false);
        queryBuildDataSource.addLink(fieldNum(RetailDlvModeProductLine, RetailGroupMemberLine), fieldNum(RetailGroupMemberLine, RecId));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEcoResCategoryIdByProduct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resolves the specified product to the category.
    /// </summary>
    /// <param name="_productId">
    /// The product identifier.
    /// </param>
    /// <returns>
    /// The category identifier.
    /// </returns>
    /// <remarks>
    /// We assume that the product comes from the Retail category hierarchy.
    /// </remarks>
    private EcoResCategoryId getEcoResCategoryIdByProduct(EcoResProductRecId _productId)
    {
        EcoResCategoryHierarchyRole ecoResCategoryHierarchyRole;

        ecoResCategoryHierarchyRole = EcoResCategoryHierarchyRole::getHierarchiesByRole(EcoResCategoryNamedHierarchyRole::Retail);
        return EcoResProductCategory::findCategoryByProduct(_productId, ecoResCategoryHierarchyRole.CategoryHierarchy).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVariantsByItemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves all variants for a specific item while respecting the exclusion rules.
    /// </summary>
    /// <param name="_itemId">
    /// The ItemId for the product.
    /// </param>
    /// <returns>
    /// A set of InventDimCombination.InventDimId.
    /// </returns>
    private Set getVariantsByItemId(ItemId _itemId)
    {
        InventDimCombination    inventDimCombination;
        Set records             = new Set(Types::String);

        if (_itemId)
        {
            while select InventDimId, DistinctProductVariant
                from inventDimCombination
                where
                    inventDimCombination.ItemId == _itemId
            {
                if (!exclusions.isVariantExcluded(inventDimCombination.DistinctProductVariant))
                {
                    records.add(inventDimCombination.InventDimId);
                }
            }
        }

        return records;
    }

]]></Source>
			</Method>
			<Method>
				<Name>process</Name>
				<Source><![CDATA[
    private void process()
    {
        RefRecId _dlvModeRecId = this.getDlvModeRecId();

        // Explode the delivery mode and channel pairs
        try
        {
            ttsBegin;

            // Explode the channels to a temporary staging table.
            using (var timer = RetailDlvModeExplodeStageTimer::construct(_dlvModeRecId, 'ExplodeChannels'))
            {
                this.explodeChannels();
            }

            // Delta sync the exploded results for channels.
            using (var timer = RetailDlvModeExplodeStageTimer::construct(_dlvModeRecId, 'DeltaSyncChannels'))
            {
                this.deltaSyncChannels();
            }

            ttsCommit;
        }
        catch (Exception::Deadlock)
        {
            str axCallStack = con2Str(xSession::xppCallStack());
            if (appl.ttsLevel() == 0)
            {
                this.logCatchExceptionWithRetries(funcName(), axCallStack, xSession::currentRetryCount());

                if (xSession::currentRetryCount() >= MaximumRetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    // Retry after deadlock in processing channels.
                    this.warningTimestamped("@Retail:DeliveryModeExplodeJobDeadlockRetryChannels");

                    retry;
                }
            }
            else
            {
                this.logCatchExceptionWithUnbalancedTts(funcName(), axCallStack, appl.ttsLevel());
                
                throw Exception::Deadlock;
            }
        }
        catch (Exception::UpdateConflict)
        {
            str axCallStack = con2Str(xSession::xppCallStack());
            if (appl.ttsLevel() == 0)
            {
                this.logCatchExceptionWithRetries(funcName(), axCallStack, xSession::currentRetryCount());

                if (xSession::currentRetryCount() >= MaximumRetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    // Retry after update conflict in processing channels.
                    this.warningTimestamped("@Retail:DeliveryModeExplodeJobUpdateConflictRetryChannels");

                    retry;
                }
            }
            else
            {
                this.logCatchExceptionWithUnbalancedTts(funcName(), axCallStack, appl.ttsLevel());

                throw Exception::UpdateConflict;
            }
        }

        // Explode the products and variants associated with the delivery mode.
        // transaction wrappers are inside, designed for batch data, since data change could be very big for commit or rollback.
        using (var timer = RetailDlvModeExplodeStageTimer::construct(_dlvModeRecId, 'ExplodeProductsAndVariants'))
        {
            this.explodeProductsAndVariants();
        }

        try
        {
            ttsBegin;

            // Delta sync the exploded results for products and variants.
            using (var timer = RetailDlvModeExplodeStageTimer::construct(_dlvModeRecId, 'DeltaSyncProductsAndVariants'))
            {
                this.deltaSyncProductsAndVariants();
            }

            ttsCommit;
        }
        catch (Exception::Deadlock)
        {
            str axCallStack = con2Str(xSession::xppCallStack());

            // Retry after deadlock in processing products and variants.
            this.warningTimestamped("@Retail:DeliveryModeExplodeJobDeadlockRetryProductsAndVariants");
            this.logCatchExceptionWithRetries(funcName(), axCallStack, xSession::currentRetryCount());

            retry;
        }
        catch (Exception::UpdateConflict)
        {
            str axCallStack = con2Str(xSession::xppCallStack());
            if (appl.ttsLevel() == 0)
            {
                this.logCatchExceptionWithRetries(funcName(), axCallStack, xSession::currentRetryCount());

                if (xSession::currentRetryCount() >= MaximumRetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    // Retry after update conflict in processing products and variants.
                    this.warningTimestamped("@Retail:DeliveryModeExplodeJobUpdateConflictRetryProductsAndVariants");

                    retry;
                }
            }
            else
            {
                this.logCatchExceptionWithUnbalancedTts(funcName(), axCallStack, appl.ttsLevel());

                throw Exception::UpdateConflict;
            }
        }

        // Explode the Country and states associated with the delivery modes.
        try
        {
            ttsBegin;

            // Explode the addresses to a temporary staging table.
            using (var timer = RetailDlvModeExplodeStageTimer::construct(_dlvModeRecId, 'ExplodeAddresses'))
            {
                this.explodeAddresses();
            }

            // Delta sync the exploded results for addresses.
            using (var timer = RetailDlvModeExplodeStageTimer::construct(_dlvModeRecId, 'DeltaSyncAddresses'))
            {
                this.deltaSyncAddresses();
            }

            ttsCommit;
        }
        catch (Exception::Deadlock)
        {
            str axCallStack = con2Str(xSession::xppCallStack());
            if (appl.ttsLevel() == 0)
            {
                this.logCatchExceptionWithRetries(funcName(), axCallStack, xSession::currentRetryCount());

                if (xSession::currentRetryCount() >= MaximumRetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    // Retry after deadlock in processing addresses.
                    this.warningTimestamped("@Retail:DeliveryModeExplodeJobDeadlockRetryAddresses");

                    retry;
                }
            }
            else
            {
                this.logCatchExceptionWithUnbalancedTts(funcName(), axCallStack, appl.ttsLevel());
                
                throw Exception::Deadlock;
            }
        }
        catch (Exception::UpdateConflict)
        {
            str axCallStack = con2Str(xSession::xppCallStack());
            if (appl.ttsLevel() == 0)
            {
                this.logCatchExceptionWithRetries(funcName(), axCallStack, xSession::currentRetryCount());

                if (xSession::currentRetryCount() >= MaximumRetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    // Retry after update conflict in processing addresses.
                    this.warningTimestamped("@Retail:DeliveryModeExplodeJobUpdateConflictRetryAddresses");

                    retry;
                }
            }
            else
            {
                this.logCatchExceptionWithUnbalancedTts(funcName(), axCallStack, appl.ttsLevel());
                
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>infoTimestamped</Name>
				<Source><![CDATA[
    private void infoTimestamped(str _message)
    {
        info(this.timestamp(_message));
    }

]]></Source>
			</Method>
			<Method>
				<Name>warningTimestamped</Name>
				<Source><![CDATA[
    private void warningTimestamped(str _message)
    {
        warning(this.timestamp(_message));
    }

]]></Source>
			</Method>
			<Method>
				<Name>timestamp</Name>
				<Source><![CDATA[
    private str timestamp(str _message)
    {
        return strFmt('%1 %2', DateTimeUtil::toStr(DateTimeUtil::utcNow()), _message);
    }

]]></Source>
			</Method>
			<Method>
				<Name>logCatchExceptionWithRetries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Log an exception with retry count.
    /// </summary>
    /// <param name = "methodName">The method's name.</param>
    /// <param name = "callStack">callStack.</param>
    /// <param name = "retryCount">The current retry count.</param>
    private void logCatchExceptionWithRetries(str methodName, str callStack, int retryCount)
    {
        // Message = "[DlvMode RecId: {0}] - {1}: error occurred at retry {2} out of {3}. Callstack: {4}"
        eventSource.EventWriteProcessDeliveryModesCatchExceptionWithRetries(this.getDlvModeRecId(),
                                                                            methodName,
                                                                            retryCount,
                                                                            MaximumRetryNum,
                                                                            callStack);
    }

]]></Source>
			</Method>
			<Method>
				<Name>logCatchExceptionWithUnbalancedTts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Log an exception with unblanced tts level.
    /// </summary>
    /// <param name = "methodName">The method's name.</param>
    /// <param name = "callStack">callStack.</param>
    /// <param name = "ttsLevel">The tts level.</param>
    private void logCatchExceptionWithUnbalancedTts(str methodName, str callStack, int ttsLevel)
    {
        // Message = "[DlvMode RecId: {0}] - {1}: error occurred, with unblanced tts (level={2}). Callstack: {3}"
        eventSource.EventWriteProcessDeliveryModesCatchExceptionWithUnbalancedTts(this.getDlvModeRecId(),
                                                                            methodName,
                                                                            ttsLevel,
                                                                            callStack);
    }

]]></Source>
			</Method>
			<Method>
				<Name>caption</Name>
				<Source><![CDATA[
    public ClassDescription caption()
    {
        str mainTitle = "@Retail:DlvModeExplodeTask";
        str dlvModeId = DlvMode::findRecId(this.getDlvModeRecId()).Code;

        return strFmt('%1 - %2', mainTitle, dlvModeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustGoBatch</Name>
				<Source><![CDATA[
    public boolean mustGoBatch()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>