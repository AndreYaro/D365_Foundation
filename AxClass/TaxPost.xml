<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Tax.Instrumentation;

/// <summary>
/// The <c>TaxPost</c> class is the tax calculation and posting class.
/// </summary>
abstract class TaxPost extends Tax
{
    TaxableDocument taxableDocument;

    TaxUncommittedTaxTransTmp taxUncommittedTaxTransTmp;
    boolean                   enableTaxUncommittedToTaxTransTmp;

    // <GIN>
    CurrencyExchangeHelper  exchangeRateHelperloc;
    TaxAmount               serviceTaxAmount;
    TaxTable                taxTableLoc;
    Counter                 taxLines;
    TaxAmountCur            vatDeferredAmount;
    #ISOCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>newForSourceTypeDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Delegate for retrieving a newly derived <c>TaxPost</c> record based on the transaction.
    /// </summary>
    /// <param name="_sourceType">
    ///    The type of the transaction posting taxes.
    /// </param>
    /// <param name="_initializationClass">
    ///    The initialization class for the specified transaction.
    /// </param>
    /// <param name="_post">
    ///    True if the <c>TaxTrans</c> and <c>Ledger</c> records will be created; false if it will not post.
    /// </param>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide the creation result.</param>
    public static void newForSourceTypeDelegate(TaxSourceType _sourceType, Object _initializationClass, NoYes _post, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForSourceTypeWithTaxCalculationDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Delegate for retrieving a newly derived <c>TaxPost</c> record based on the transaction.
    /// </summary>
    /// <param name="_sourceType">
    ///    The type of the transaction posting taxes.
    /// </param>
    /// <param name="_initializationClass">
    ///    The initialization class for the given transaction.
    /// </param>
    /// <param name="_post">
    ///    A Boolean value that specifies whether the <c>TaxTrans</c> and <c>Ledger</c> entries will be made.
    /// </param>
    /// <param name="_taxCalculation">
    ///    The tax will post using the tax lines in the table that are specified by the <paramref
    ///    name="_taxCalculation" /> parameter.
    /// </param>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide the creation result.</param>
    public static void newForSourceTypeWithTaxCalculationDelegate(TaxSourceType _sourceType, Object _initializationClass, NoYes _post, TaxCalculation _taxCalculation, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPostingReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a reference to a <c>LedgerPostingController</c> object.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_voucher">
    /// The voucher to use when the reference is added.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date to use when the reference is being added.
    /// </param>
    /// <param name="_sourceTableId">
    /// The source table ID to use when the reference is being added.
    /// </param>
    /// <param name="_sourceRecId">
    /// The source record ID to use when the reference is being added.
    /// </param>
    protected void addPostingReference(
        LedgerPostingController _ledgerPostingController,
        Voucher _voucher,
        TransDate _transDate,
        TableId _sourceTableId = 0,
        RecId _sourceRecId = 0)
    {
        LedgerVoucherObject ledgerVoucherObject;

        ledgerVoucherObject = LedgerVoucherObject::newVoucher(
            _voucher,
            _transDate,
            SysModule::Ledger);

        _ledgerPostingController.addReference(ledgerVoucherObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowTaxAdjustmentDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether tax posting will delete tax adjustments.
    /// </summary>
    /// <returns>
    /// true if tax posting will delete <c>TaxWorkRegulation</c> records; otherwise, false.
    /// </returns>
    protected boolean allowTaxAdjustmentDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowTaxUncommittedDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether tax posting will delete the <c>TaxUncommitted</c> records.
    /// </summary>
    /// <returns>
    /// true if tax will delete <c>TaxUncommitted</c> records; otherwise, false.
    /// </returns>
    protected boolean allowTaxUncommittedDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canChargeBePostedByTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the sales tax charge can be posted by tax.
    /// </summary>
    /// <returns>
    /// true if tax will post the sales tax charge; otherwise, false.
    /// </returns>
    protected boolean canChargeBePostedByTax()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canFindPostingReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if we can find a posting reference by given arguments.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_voucher">
    /// The voucher to use when finding the reference.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date to use when finding the reference.
    /// </param>
    /// <returns>
    /// True if the posting reference can be found. False otherwise.
    /// </returns>
    /// <remarks>
    /// Ovverride this method for customizations.
    /// </remarks>
    protected boolean canFindPostingReference(LedgerPostingController _ledgerPostingController,
                                              Voucher _voucher,
                                              TransDate _transDate)
    {
        boolean didFindReference;

        didFindReference = _transDate && _ledgerPostingController.findReference(_voucher, _transDate);

        return didFindReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies parameters.
    /// </summary>
    /// <returns>
    ///    true if the parameters are valid; otherwise, false.
    /// </returns>
    public boolean checkParameters()
    {
        boolean ok      = true;

        if (!this.getInitializationClass())
            throw error(strFmt("@SYS22533",funcName(),classId2Name(classIdGet(this.getInitializationClass()))));

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDefermentSchedule_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the deferment shedule records for VAT.
    /// </summary>
    /// <param name="_ledgerJournalTransRecIdSet">
    /// Set buffer to get LedgerJounrnalTrans record Id.
    /// </param>
    public void createDefermentSchedule_IN(Set _ledgerJournalTransRecIdSet)
    {
        SetIterator             ledgerJournalTransSetIt;
        TaxAmount               loadAmt;
        LedgerJournalTrans      journalTransOrig;
        LedgerJournalType       ledgerJournalType;
        AmountCur               taxAmountCur;
        TaxUncommitted          taxUncommittedVAT;
        TaxTable                taxTableVAT;

        CurrencyExchangeHelper  exchangeRateHelper;
        TaxUncommitted_IN       taxUncommittedIN;
        LedgerJournalTrans      ledgerJournalTransLocal;
        TaxTrans_IN             taxTransIN;

        ledgerJournalTransSetIt = new SetIterator(_ledgerJournalTransRecIdSet);
        while (ledgerJournalTransSetIt.more())
        {
            vatDeferredAmount = 0;
            ledgerJournalTransLocal = LedgerJournalTrans::findRecId(ledgerJournalTransSetIt.value(), false);
            ledgerJournalType = ledgerJournalTransLocal.ledgerJournalTable().JournalType;
            journalTransOrig  = ledgerJournalTransLocal.orig();
            exchangeRateHelper = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));

            while select SourceCurrencyCode,
                SourceTaxAmountCur,
                SourceRegulateAmountCur,
                RecId,
                ExchRate,
                ExchRateSecond,
                TransDate from taxUncommittedVAT
                where taxUncommittedVAT.SourceTableId   == ledgerJournalTransLocal.TableId
                    && taxUncommittedVAT.SourceRecId    == ledgerJournalTransLocal.RecId
                join TaxType_IN, TaxCode from taxTableVAT
                    where taxTableVAT.TaxType_IN    == TaxType_IN::VAT
                        && taxTableVAT.TaxCode      == taxUncommittedVAT.TaxCode
            {
                taxUncommittedIN = TaxUncommitted_IN::findByTaxUncommitted(taxUncommittedVAT.RecId);
                exchangeRateHelper.parmExchangeRate1(taxUncommittedVAT.ExchRate);
                exchangeRateHelper.parmExchangeRate2(taxUncommittedVAT.ExchRateSecond);
                exchangeRateHelper.parmExchangeDate(taxUncommittedVAT.TransDate);

                taxAmountCur = (taxUncommittedVAT.SourceRegulateAmountCur == taxUncommittedVAT.SourceTaxAmountCur) ? taxUncommittedVAT.SourceTaxAmountCur :taxUncommittedVAT.SourceRegulateAmountCur;
                loadAmt = exchangeRateHelper.calculateAccountingToTransaction(taxUncommittedVAT.SourceCurrencyCode, taxUncommittedIN.LoadOnInventoryTax, true);
                // In 6.0 by default the Regulated & Auto generated taxes are same unless its adjusted to a diffrent value. Priority goes to regulated tax.
                vatDeferredAmount += taxAmountCur - loadAmt;
            }

            createDeferment = vatDeferredAmount > 0;

            // DefermentScheduleTrans_IN should have only 1 record per journal line.
            if (createDeferment
                && ((ledgerJournalType == LedgerJournalType::Approval
                        && ledgerJournalTransLocal.PurchLedgerPosting == ArrivalPostingType::None)
                    || (ledgerJournalType != LedgerJournalType::PurchaseLedger
                        && ((journalTransOrig.AccountType == LedgerJournalACType::Vend
                                && ledgerJournalTransLocal.AmountCurCredit != 0)
                            || (journalTransOrig.OffsetAccountType == LedgerJournalACType::Vend
                                && ledgerJournalTransLocal.AmountCurDebit != 0)))))
            {
                DefermentScheduleTrans_IN::createDefermentScheduleTrans(ledgerJournalTransLocal, vatDeferredAmount);

                update_recordset taxTransIN
                    setting vatDefermentExtRecId = ledgerJournalTransLocal.RecId,
                            vatDeferementExtTableId = ledgerJournalTransLocal.TableId
                    where taxTransIN.SourceTableId == ledgerJournalTransLocal.TableId
                       && taxTransIN.SourceRecId   == ledgerJournalTransLocal.RecId;
            }

            ledgerJournalTransSetIt.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxRegulation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes the tax adjustments for the current document.
    /// </summary>
    /// <param name="_companyToPost">
    ///    The company to post; optional.
    /// </param>
    protected void deleteTaxRegulation(SelectableDataArea _companyToPost = curext())
    {
        TaxWorkRegulation taxWorkRegulation;

        delete_from taxWorkRegulation
        where taxWorkRegulation.HeadingTableId == this.getOriginalHeadingTableId()
           && taxWorkRegulation.HeadingRecId == this.getOriginalHeadingRecId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPostingReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the correct posting reference.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_voucher">
    /// The voucher to use when finding the reference.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date to use when finding the reference.
    /// </param>
    /// <param name="_sourceTableId">
    /// The source table ID to use when finding the reference.
    /// </param>
    /// <param name="_sourceRecId">
    /// The source record ID to use when finding the reference.
    /// </param>
    protected void findPostingReference(
        LedgerPostingController _ledgerPostingController,
        Voucher _voucher,
        TransDate _transDate,
        TableId _sourceTableId = 0,
        RecId _sourceRecId = 0
    )
    {
        boolean isFound;

        if (this.postFindPostingReference())
        {
            isFound = _ledgerPostingController.findReference(_voucher, _transDate);

            if (!isFound)
            {
                if (_ledgerPostingController.getJournal().lastTransDate())
                {
                    // When tax is using document date, the date tax has will differ from the date the Journals use.
                    // This behavoir can be overriden.
                    isFound = this.canFindPostingReference(_ledgerPostingController, _voucher, _ledgerPostingController.getJournal().lastTransDate());
                }

                if (!isFound)
                {
                    this.addPostingReference(_ledgerPostingController, _voucher, _transDate, _sourceTableId, _sourceRecId);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInitializationClass</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the initialization class as an object.
    /// </summary>
    /// <returns>
    ///    The initialization class.
    /// </returns>
    /// <remarks>
    ///    The initialization class is of a different type for each subclass.
    /// </remarks>
    protected abstract Object getInitializationClass()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginalHeadingRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the original document ID.
    /// </summary>
    /// <returns>
    ///    The original <c>RecId</c> of the transaction header.
    /// </returns>
    /// <remarks>
    ///    The parent tax lines sometimes changes during posting. This method will return the original
    ///    document ID.
    /// </remarks>
    protected abstract RefRecId getOriginalHeadingRecId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginalHeadingTableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the original transaction heading table ID.
    /// </summary>
    /// <returns>
    ///    The original table ID of the transaction header.
    /// </returns>
    /// <remarks>
    ///    The parenting of tax lines sometimes changes during posting. This method will return the original
    ///    transaction heading table ID.
    /// </remarks>
    protected abstract RefTableId getOriginalHeadingTableId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxObligationCompany</Name>
				<Source><![CDATA[
    protected TaxObligationCompany getTaxObligationCompany()
    {
        if (taxableDocument)
        {
            return taxableDocument.getTaxObligationCompany();
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxUncommittedTaxTransTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>TaxUncommittedTaxTransTmp</c> table.
    /// </summary>
    /// <returns>
    /// The <c>TaxUncommittedTaxTransTmp</c> table.
    /// </returns>
    public TaxUncommittedTaxTransTmp getTaxUncommittedTaxTransTmp()
    {
        return taxUncommittedTaxTransTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxTable_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize tax table.
    /// </summary>
    /// <param name="_taxCode">
    /// The tax code information.
    /// </param>
    protected void initTaxTable_IN(TaxCode _taxCode)
    {
        taxTableLoc = TaxTable::find(_taxCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveSourceDocumentLineOwnerToTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Changes the owner of the source document line records from <c>TaxUncommitted</c> to <c>TaxTrans</c>.
    /// </summary>
    private void moveSourceDocumentLineOwnerToTaxTrans()
    {
        SourceDocumentLine sourceDocumentLine;
        TaxUncommitted     taxUncommitted;
        int                taxTransTableNum;

        if (!this.useSubLedgerJournalLines())
        {
            // if the calling transaction isn't using SubLedger then we don't
            // need to do this.
            return;
        }

        // the new owner of the source document line records will be TaxTrans.
        taxTransTableNum = tableNum(TaxTrans);

        // update the owner for all records as a set.
        update_recordset sourceDocumentLine
        setting
            SourceRelationType = taxTransTableNum
        join taxUncommitted
        where
            taxUncommitted.HeadingRecId == this.headingRecId() &&
            taxUncommitted.HeadingTableId == this.headingTableId() &&
            taxUncommitted.SourceDocumentLine == sourceDocumentLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveTaxLineToNewOwner</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Moves all of the tax lines for the given document to a new document.
    /// </summary>
    /// <param name="_oldParentTableId">
    ///    Original table ID for the transaction line.
    /// </param>
    /// <param name="_oldParentRecId">
    ///    Original <c>RecId</c> for the transaction header.
    /// </param>
    /// <param name="_companyToPost">
    ///    The company to post; optional.
    /// </param>
    protected void moveTaxLineToNewOwner(RefTableId         _oldParentTableId,
                                         RefRecId           _oldParentRecId,
                                         SelectableDataArea _companyToPost = curext())
    {
        TaxUncommitted taxUncommitted;

        update_recordset taxWorkTrans
        setting
            HeadingRecId    = headingRecId,
            SourceTableId   = this.sourceTableId(),
            SourceRecId     = this.sourceRecId(),
            HeadingTableId  = this.headingTableId()
        where
            taxWorkTrans.SourceTableId == _oldParentTableId &&
            taxWorkTrans.SourceRecId   == _oldParentRecId &&
            taxWorkTrans.Company       == _companyToPost;

        if (this.useTaxUncommitted()
            && (headingRecId != this.getOriginalHeadingRecId()
                || this.sourceTableId() != _oldParentTableId
                || this.sourceRecId() != _oldParentRecId
                || this.headingTableId() != this.getOriginalHeadingTableId()))
        {
            update_recordset taxUncommitted
            setting
                HeadingRecId    = headingRecId,
                SourceTableId   = this.sourceTableId(),
                SourceRecId     = this.sourceRecId(),
                HeadingTableId  = this.headingTableId()
            where
                taxUncommitted.SourceRecId   == _oldParentRecId &&
                taxUncommitted.SourceTableId == _oldParentTableId &&
                taxUncommitted.HeadingTableId == this.getOriginalHeadingTableId() &&
                taxUncommitted.HeadingRecId == this.getOriginalHeadingRecId() &&
                taxUncommitted.Company       == _companyToPost;
        }

        // move manually inserted tax lines to new owner.
        if (headingRecId != this.getOriginalHeadingRecId() || this.headingTableId() != this.getOriginalHeadingTableId())
        {
            update_recordset taxWorkTrans
            setting
                HeadingRecId    = headingRecId,
                HeadingTableId  = this.headingTableId()
            where
                taxWorkTrans.HeadingTableId == this.getOriginalHeadingTableId() &&
                taxWorkTrans.HeadingRecId   == this.getOriginalHeadingRecId() &&
                taxWorkTrans.ManualInsertedTax == true &&
                taxWorkTrans.Company       == _companyToPost;
        }
        
        if (this.useTaxUncommitted()
            && (headingRecId != this.getOriginalHeadingRecId()
                || this.headingTableId() != this.getOriginalHeadingTableId()))
        {
            update_recordset taxUncommitted
            setting
                HeadingRecId    = headingRecId,
                HeadingTableId  = this.headingTableId()
            where
                taxUncommitted.HeadingTableId   == this.getOriginalHeadingTableId() &&
                taxUncommitted.HeadingRecId == this.getOriginalHeadingRecId() &&
                taxUncommitted.ManualInsertedTax == true &&
                taxUncommitted.Company       == _companyToPost;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>overrideVoucherOnPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether posting should override the voucher when it posts to the <c>TaxTrans</c> table.
    /// </summary>
    /// <returns>
    ///    true if posting should override the voucher; otherwise, false.
    /// </returns>
    protected boolean overrideVoucherOnPost()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEnableTaxUncommittedToTaxTransTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets whether the TaxUncommittedToTaxTransTmp table should be populated during posting.
    /// </summary>
    /// <param name="_enableTaxUncommittedToTaxTransTmp">
    /// true if the table should be populated; otherwise, false.
    /// </param>
    /// <returns>
    /// true if the TaxUncommittedToTaxTransTmp table should be populated during posting.
    /// </returns>
    public boolean parmEnableTaxUncommittedToTaxTransTmp(boolean _enableTaxUncommittedToTaxTransTmp = enableTaxUncommittedToTaxTransTmp)
    {
        enableTaxUncommittedToTaxTransTmp = _enableTaxUncommittedToTaxTransTmp;
        return enableTaxUncommittedToTaxTransTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The post method of the <c>TaxPost</c> class.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller.
    /// </param>
    /// <param name="_taxTrans">
    /// The tax transaciton information.
    /// </param>
    /// <param name="_taxAmount">
    /// The tax amount.
    /// </param>
    /// <param name="_chargeAmount">
    /// The charge amount.
    /// </param>
    /// <param name="_exchRateHelper">
    /// The exchange rate helper.
    /// </param>
    /// <param name="_ledgerDetailLevel">
    /// The ledger detail level.
    /// </param>
    /// <param name="_operationLedgerDimension">
    /// The operation ledger dimension.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal trans.
    /// </param>
    protected void post_IN(
        LedgerPostingController _ledgerPostingController,
        TaxTrans                _taxTrans,
        TaxAmount               _taxAmount,
        TaxAmount               _chargeAmount,
        CurrencyExchangeHelper  _exchRateHelper,
        LedgerDetailLevel       _ledgerDetailLevel = LedgerDetailLevel::AsDefault,
        LedgerDimensionAccount  _operationLedgerDimension = 0,
        LedgerJournalTrans      _ledgerJournalTrans = null)
    {
        LedgerVoucherTransObject            ledgerVoucherTransObject;
        AmountMST                           amountMST;
        CustomsExchangeRate_IN              customsExchRate;
        TaxAmount                           deferredAmt;
        TmpTaxWorkTrans                     taxWorkTransLoc;
        TaxAmountCur                        serviceTaxPostingAmount;
        LedgerDimensionAccount              ledgerDimensionLoc;
        LedgerDimensionDefaultAccount       defaultAccount;
        TaxLedgerAccounts_IN                taxLedgerAccounts;
        TaxLedgerAccountGroup_IN            taxLedgerAccountGroupLoc;
        TaxTable                            taxTableExcLoc;
        RefRecId                            indirectTaxLedgerDimension;
        TransTaxInformation                 transTaxInformation;

        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_ledgerJournalTrans);
        ledgerDimensionLoc = TaxTransGeneralJournalAccountEntry::getTaxLedgerDimensionForTaxTrans(_taxTrans.RecId);
        defaultAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(ledgerDimensionLoc);
        if (isTaxParametersEnabled)
        {
            taxWorkTransLoc = taxWorkTrans;
        }

        _ledgerPostingController.getReference().parmGeneralJournalEntry();

        if ((_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
            || (_ledgerJournalTrans.AmountCurDebit && _ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger  && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger))
        {
            if ((isExciseEnabled
                && TaxTable::find(_taxTrans.TaxCode).TaxType_IN == TaxType_IN::Excise
                && _taxTrans.TaxDirection == TaxDirection::IncomingTax)
                || taxTableExcise.TaxCode)
            {
                if ((transTaxInformation.ExciseRecordType == ExciseRecordType_IN::RG23A) || (transTaxInformation.ExciseRecordType == ExciseRecordType_IN::RG23C))
                {
                    deferredAmt    = this.exciseDeferredAmt_IN(_taxTrans.taxTrans_W().ClaimPercentage_IN, _taxAmount, transTaxInformation.ExciseRecordType, transTaxInformation.ExciseType);
                    taxTableExcLoc = TaxTable::find(_taxTrans.TaxCode);
                    taxLedgerAccountGroupLoc = TaxLedgerAccountGroup_IN::find(TaxTable::find(_taxTrans.TaxCode).TaxLedgerAccountGroup_IN);

                    if (transTaxInformation.ExciseRecordType == ExciseRecordType_IN::RG23A)
                    {
                        select firstonly LedgerDimension from taxLedgerAccounts
                            where taxLedgerAccounts.TaxComponentTable     == taxTableExcLoc.TaxComponentTable_IN
                                && taxLedgerAccounts.AccountType          == TaxAccountType_IN::ExciseDeferredRG23AAccount;
                        indirectTaxLedgerDimension =  LedgerDimensionFacade::serviceCreateLedgerDimension(taxLedgerAccounts.LedgerDimension);
                    }
                    else
                    {
                        select firstonly LedgerDimension from taxLedgerAccounts
                            where taxLedgerAccounts.TaxComponentTable     == taxTableExcLoc.TaxComponentTable_IN
                                && taxLedgerAccounts.AccountType          == TaxAccountType_IN::ExciseDeferredRG23CAccount;
                        indirectTaxLedgerDimension =  LedgerDimensionFacade::serviceCreateLedgerDimension(taxLedgerAccounts.LedgerDimension);
                    }
                }
                if (indirectTaxLedgerDimension && deferredAmt && taxTableExcise.TaxCode)
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                            LedgerPostingType::Excise_IN,
                                                                                            indirectTaxLedgerDimension,
                                                                                            _taxTrans.SourceCurrencyCode,
                                                                                            deferredAmt,
                                                                                            _exchRateHelper);

                    // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                    if (_taxTrans)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                    }

                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }
            }
        }
        if (! this.taxParameters().PurchTaxOnOperations || _taxTrans.TaxDirection == TaxDirection::OutgoingTax)
        {
            if (isTaxParametersEnabled      &&
                taxPostingType != LedgerPostingType::Tax &&
                TaxTable::find(_taxTrans.TaxCode).TaxType_IN != TaxType_IN::Customs)
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                        LedgerPostingType::Tax,
                                                                                        _operationLedgerDimension,
                                                                                        _taxTrans.SourceCurrencyCode,
                                                                                        _taxAmount - _chargeAmount - deferredAmt,
                                                                                        _exchRateHelper);

                // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                if (_taxTrans)
                {
                    // TaxTrans will not exist in the case where a transaction is only being validated,
                    // and in that case the tax trans relationship should not be created
                    ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                }

                ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                _ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }
            else if (isCustomsEnabled &&
                    (taxWorkTransLoc.SourceTaxAmountCur || taxWorkTransLoc.SourceRegulateAmountCur)  &&
                     TaxTable::find(taxWorkTransLoc.TaxCode).TaxType_IN == TaxType_IN::Customs)
            {
                customsExchRate = TaxExchangeRateHelper::getCustomsExchangeRate_IN(taxWorkTransLoc.SourceCurrencyCode, CustomsTariffCodeTable_IN::find(transTaxInformation.CustomsTariffCode).Direction, taxWorkTransLoc.TransDate);
                if (taxTableExcise.TaxCode)
                {
                    amountMST       = CurrencyExchangeHelper::amount(deferredAmt * customsExchRate / 100) ;
                    if (deferredAmt)
                    {
                        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                        LedgerPostingType::Tax,
                                                                                        exciseDeferredAccount,
                                                                                        sourceCurrencyCode,
                                                                                        deferredAmt,
                                                                                        _exchRateHelper);

                        // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                        if (_taxTrans)
                        {
                            // TaxTrans will not exist in the case where a transaction is only being validated,
                            // and in that case the tax trans relationship should not be created
                            ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                        }
                        ledgerVoucherTransObject.parmAccountingCurrencyAmount(amountMST);
                        ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                        _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                    }

                    amountMST       = CurrencyExchangeHelper::amount((_taxAmount - deferredAmt) * customsExchRate / 100) ;
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                        LedgerPostingType::Excise_IN,
                                                                                        ledgerDimensionLoc,
                                                                                        sourceCurrencyCode,
                                                                                        _taxAmount - deferredAmt,
                                                                                        _exchRateHelper);

                    // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                    if (_taxTrans)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                    }
                    ledgerVoucherTransObject.parmAccountingCurrencyAmount(amountMST);
                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }
                else
                {
                    amountMST       = CurrencyExchangeHelper::amount((_taxAmount - _chargeAmount) * customsExchRate / 100);
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                        taxPostingType,
                                                                                        ledgerDimensionLoc,
                                                                                        sourceCurrencyCode,
                                                                                        _taxAmount - _chargeAmount,
                                                                                        _exchRateHelper);

                    // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                    if (_taxTrans)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                    }
                    ledgerVoucherTransObject.parmAccountingCurrencyAmount(amountMST);
                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }
            }
            else
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                    LedgerPostingType::Tax,
                                                                                    ledgerDimensionLoc,
                                                                                    sourceCurrencyCode,
                                                                                    _taxAmount - _chargeAmount,
                                                                                    _exchRateHelper);

                // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                if (_taxTrans)
                {
                    // TaxTrans will not exist in the case where a transaction is only being validated,
                    // and in that case the tax trans relationship should not be created
                    ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                }

                ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                _ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }
        }

        if (isServiceTaxEnabled &&
            taxWorkTransLoc.LedgerDimension_IN          &&
            TaxTable::find(_taxTrans.TaxCode).TaxType_IN == TaxType_IN::ServiceTax)
        {
            if (((_ledgerJournalTrans.orig().AccountType == LedgerJournalACType::Bank ||
                 _ledgerJournalTrans.orig().OffsetAccountType == LedgerJournalACType::Bank) &&
                (_ledgerJournalTrans.orig().AccountType == LedgerJournalACType::Vend ||
                 _ledgerJournalTrans.orig().OffsetAccountType == LedgerJournalACType::Vend)) &&
                 !_ledgerJournalTrans.isGTAVendorAccount_IN()                                &&
                 !_ledgerJournalTrans.isForeignVendorAccount_IN())
            {
                serviceTaxPostingAmount = (_taxAmount - _chargeAmount);
            }
            else
            {
                serviceTaxPostingAmount = _taxAmount;
            }
            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                    taxPostingType,
                                                                                    taxWorkTransLoc.LedgerDimension_IN,
                                                                                    sourceCurrencyCode,
                                                                                    -serviceTaxPostingAmount,
                                                                                    _exchRateHelper);

            // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
            if (_taxTrans)
            {
                // TaxTrans will not exist in the case where a transaction is only being validated,
                // and in that case the tax trans relationship should not be created
                ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
            }

            ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
            _ledgerPostingController.addTrans(ledgerVoucherTransObject);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postFindPostingReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether tax posting will attempt to find the correct posting reference by using the
    /// voucher and transaction date value on the tax line.
    /// </summary>
    /// <returns>
    /// true if the tax posting will attempt to find the posting reference; otherwise, false.
    /// </returns>
    protected boolean postFindPostingReference()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postServiceTaxfromLedger_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the service tax from ledger.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller.
    /// </param>
    /// <param name="_taxTrans">
    /// The tax transaction.
    /// </param>
    /// <param name="_exchangeRateHelper">
    /// The exchange rate helper.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    /// <param name="_operationLedgerDimension">
    /// The operation ledger dimension.
    /// </param>
    /// <param name="_taxOffsetUseTaxLedgerDimension">
    /// The tax offset use tax ledger dimension.
    /// </param>
    /// <param name="_subledgerJournalAccountEntry">
    /// The sub ledger journal account entry.
    /// </param>
    /// <param name="_sourceTableID">
    /// The source table id.
    /// </param>
    /// <param name="_sourceRecID">
    /// The source rec id.
    /// </param>
    public  void postServiceTaxfromLedger_IN(LedgerPostingController _ledgerPostingController,
                                          TaxTrans _taxTrans,
                                          CurrencyExchangeHelper _exchangeRateHelper,
                                          LedgerDimensionAccount  _ledgerDimension,
                                          LedgerDimensionAccount  _operationLedgerDimension,
                                          LedgerDimensionAccount  _taxOffsetUseTaxLedgerDimension,
                                          SubledgerJournalAccountEntry _subledgerJournalAccountEntry = null
                                          ,RefTableId                    _sourceTableID                = 0,
                                          RefRecId                       _sourceRecID                  = 0
                                            )
    {
        TaxTrans                        taxTransLoc;
        LedgerJournalTrans              ledgerJournalTrans;
        LedgerJournalTrans              ledgerJournalServiceFst;
        boolean                         gtaVendor;
        TaxTrans_W                      taxTransLoc_W;

        ledgerJournalTrans = LedgerJournalTrans::findRecId(taxUnCommittedbuffer.SourceRecId, false);

        if ((ledgerJournalTrans.AccountType       == LedgerJournalACType::Bank  ||
                ledgerJournalTrans.OffsetAccountType  == LedgerJournalACType::Bank) &&
                (ledgerJournalTrans.AccountType       == LedgerJournalACType::Vend  ||
                ledgerJournalTrans.OffsetAccountType  == LedgerJournalACType::Vend))
        {
            _taxTrans.TaxOrigin = TaxOrigin::Tax;
            _taxTrans.update();

            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                gtaVendor = VendTable::find(ledgerJournalTrans.parmAccount()).isGTA();
            }
            else if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
            {
                gtaVendor = VendTable::find(ledgerJournalTrans.parmOffsetAccount()).isGTA();
            }
            if (gtaVendor)
            {
                _taxTrans.TaxDirection       = TaxDirection::OutgoingTax;
                _taxTrans.TaxOrigin          = TaxOrigin::TaxReversed;
                _taxTrans.update();
                taxTransLoc.TaxDirection    = TaxDirection::OutgoingTax;
                _taxTrans.TaxOrigin          = TaxOrigin::Tax;
            }
        }

        select firstonly ledgerJournalServiceFst where
                ledgerJournalServiceFst.Voucher == ledgerJournalTrans.Voucher;

        if ((ledgerJournalTrans.AccountType       == LedgerJournalACType::Ledger  &&
                    ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger) &&
                    ledgerJournalTrans.ForeignCompany    != ''                           &&
                    VendTable::find(ledgerJournalServiceFst.parmAccount()).isGTA())
        {
            _taxTrans.TaxDirection       = TaxDirection::OutgoingTax;
            _taxTrans.TaxOrigin          = TaxOrigin::TaxReversed;
            _taxTrans.update();
            taxTransLoc.TaxDirection    = TaxDirection::OutgoingTax;
            _taxTrans.TaxOrigin          = TaxOrigin::Tax;
        }

        taxTransLoc.data(_taxTrans);
        taxTransLoc_W = taxTransLoc.taxTrans_W();
        taxTransLoc.TaxBaseAmount            =  -_taxTrans.TaxBaseAmount;
        taxTransLoc.TaxAmount                =  -_taxTrans.TaxAmount;
        taxTransLoc.TaxInCostPrice           =  -_taxTrans.TaxInCostPrice;
        taxTransLoc.TaxInCostPriceMST        =  -_taxTrans.TaxInCostPriceMST;
        taxTransLoc.TaxBaseAmountCur         =  -_taxTrans.TaxBaseAmountCur;
        taxTransLoc.TaxAmountCur             =  -_taxTrans.TaxAmountCur;
        taxTransLoc.TaxInCostPriceCur        =  -_taxTrans.TaxInCostPriceCur;
        taxTransLoc.SourceBaseAmountCur      =  -_taxTrans.SourceBaseAmountCur;
        taxTransLoc.SourceTaxAmountCur       =  -_taxTrans.SourceTaxAmountCur;
        taxTransLoc.SourceRegulateAmountCur  =  -_taxTrans.SourceRegulateAmountCur;
        taxTransLoc.TaxOrigin                =  TaxOrigin::Tax;
        taxTransLoc_W.TaxRegistrationNumberTable_IN = _taxTrans.taxTrans_W().TaxRegistrationNumberTable_IN;
        taxTransLoc.packTaxTrans_W(taxTransLoc_W);

        if ((ledgerJournalTrans.AccountType      != LedgerJournalACType::Bank   &&
                ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Bank)  &&
                ledgerJournalTrans.ForeignCompany    == '')
        {
            taxTransLoc.TaxDirection    = TaxDirection::OutgoingTax;
        }
        else if (!gtaVendor)
        {
            taxTransLoc.TaxOrigin        =  TaxOrigin::TaxReversed;
        }
        if (taxTransLoc.TaxDirection == TaxDirection::OutgoingTax)
        {
            taxTransLoc.TaxInCostPrice = 0;
            taxTransLoc.TaxInCostPriceCur = 0;
            taxTransLoc.TaxInCostPriceMST = 0;
            taxTransLoc.TaxInCostPriceRegulated = 0;
        }
        taxTransLoc.insert();

        if (taxTransLoc)
        {
            salesPurchJournalLineLoc    = this.getSalesPurchJournalLineFromTaxTrans_IN(taxTransLoc);
        }

        this.insertTaxTrans_IN(taxTransLoc, salesPurchJournalLineLoc);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts to the ledger using either the subledger or the legacy method of posting.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_taxTrans">
    ///    The transaction line being posted.
    /// </param>
    /// <param name="_exchangeRateHelper">
    ///    The <c>CurrencyExchHelper</c> instance for the <c>TaxTrans</c> record being posted.
    /// </param>
    /// <param name="_ledgerDimension">
    ///    The <c>LedgerDimensionAccount</c> data type that represents the tax amount.
    /// </param>
    /// <param name="_operationLedgerDimension">
    ///    The <c>LedgerDimensionAccount</c> data type that represents the transaction line amount.
    /// </param>
    /// <param name="_taxOffsetUseTaxLedgerDimension">
    ///    The <c>LedgerDimensionAccount</c> data type that represents the use tax payable amount.
    /// </param>
    /// <param name="_subledgerJournalAccountEntry">
    ///    The <c>SubLedgerJournalAccountEntry</c> record being posted; optional.
    /// </param>
    /// <param name="_sourceTableID">
    ///    The source TableId of the record being Posted; optinal.
    /// </param>
    /// <param name="_sourceRecID">
    ///    The RecordID of the  record being posted; optional.
    /// </param>
    [Hookable(true)]
    private void postToLedger(LedgerPostingController _ledgerPostingController,
                              TaxTrans _taxTrans,
                              CurrencyExchangeHelper _exchangeRateHelper,
                              LedgerDimensionAccount  _ledgerDimension,
                              LedgerDimensionAccount  _operationLedgerDimension,
                              LedgerDimensionAccount  _taxOffsetUseTaxLedgerDimension,
                              SubledgerJournalAccountEntry _subledgerJournalAccountEntry = null
                              ,RefTableId                    _sourceTableID                = 0,
                              RefRecId                       _sourceRecID                  = 0
                              )
    {
        TaxAmountCur        taxAmountCur;
        TaxAmountCur        taxInCostPrice;

        if (!_taxTrans.TaxAutogenerated)
        {
            taxAmountCur = _taxTrans.SourceRegulateAmountCur;
            taxInCostPrice = _taxTrans.TaxInCostPriceRegulated;
        }
        else
        {
            taxInCostPrice         = _taxTrans.TaxInCostPrice;
            taxAmountCur = _taxTrans.SourceTaxAmountCur;
        }

        // use the legacy posting.
        if (_taxTrans.ExemptTax == NoYes::No && taxAmountCur && _taxTrans.TaxOrigin != TaxOrigin::Transfer)
        {
            // <GIN>
            if (isCustomsEnabled
                &&  _taxTrans.taxTrans_W().TaxType_IN == TaxType_IN::Customs)
            {
                this.postToLedgerCustomsEximTrans_IN(_taxTrans, taxAmountCur, _ledgerPostingController, taxInCostPrice, _exchangeRateHelper);
            }
            else
            {
                if (isExciseEnabled
                    && post
                    && _taxTrans.taxTrans_W().TaxType_IN == TaxType_IN::Excise
                    && taxModuleType        == TaxModuleType::Voucher) // Check to see the filter on Voucher is correct.
                {
                    this.post_IN(_ledgerPostingController, _taxTrans, taxAmountCur, taxInCostPrice, _exchangeRateHelper, LedgerDetailLevel::AsDefault, _ledgerDimension, LedgerJournalTrans::findRecId(_sourceRecID, true));
                }
                else
                {
                    // </GIN>
                    this.post(_ledgerPostingController, _taxTrans, taxAmountCur, taxInCostPrice, _exchangeRateHelper, _ledgerDimension, _operationLedgerDimension, _taxOffsetUseTaxLedgerDimension);
                    // <GIN>
                }
            }
            // </GIN>
            if (this.canChargeBePostedByTax())
            {
                this.postCharge(_ledgerPostingController, _taxTrans, taxInCostPrice, _exchangeRateHelper, _operationLedgerDimension);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts a TaxTrans record.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_taxTrans">
    ///    Transaction line being posted.
    /// </param>
    /// <param name="_exchangeRateHelper">
    ///    An instance of <c>CurrencyExchHalper</c> with the currency, exchange rates, and triangulation values set.
    /// </param>
    /// <param name="_voucher">
    ///    Voucher for the document.
    /// </param>
    /// <param name="_ledgerDimension">
    ///    The LedgerDimension used for Posting; Optional.
    /// </param>
    /// <param name="_operationLedgerDimension">
    ///    The OperationLedgerDimension used for Posting; Optional.
    /// </param>
    /// <param name="_taxOffsetUseTaxLedgerDimension">
    ///     The TaxOffsetUseTaxLedgerDimension used for Posting; Optional.
    /// </param>
    protected void postToTaxTrans(LedgerPostingController _ledgerPostingController,
                                  TaxTrans _taxTrans,
                                  CurrencyExchangeHelper _exchangeRateHelper,
                                  Voucher                 _voucher
                                  ,
                                  LedgerDimensionAccount  _ledgerDimension = 0,
                                  LedgerDimensionAccount  _operationLedgerDimension = 0,
                                  LedgerDimensionAccount  _taxOffsetUseTaxLedgerDimension = 0
                                  )
    {
        TaxAmountCur        taxAmountCur;
        TaxAmountCur        taxInCostPrice;
        // <GIN>
        TaxAmount                   vatPayableAmount;
        LedgerDimensionAccount      vatAccount;
        VATGoodsType_IN             goodsType;
        TaxTrans_W                  taxTrans_W;
        // </GIN>

        _taxTrans.euroTriangulation = triangulation;
        _taxTrans.JournalNum        = this.journalNum();
        if (this.overrideVoucherOnPost())
        {
            _taxTrans.Voucher = voucher;
        }

        if (!_taxTrans.TaxAutogenerated)
        {
            taxRegulationExist = true;
            taxAmountCur = _taxTrans.SourceRegulateAmountCur;
            taxInCostPrice = _taxTrans.TaxInCostPriceRegulated;
            this.taxAmountRegulation(_taxTrans,
                                     _taxTrans.SourceRegulateAmountCur,
                                     _exchangeRateHelper.parmExchangeRate1(),
                                     _exchangeRateHelper.parmExchangeRate2());

            if (this.useAdjustedBaseAmountForBaseAmount())
            {
                this.taxBaseAmountRegulation(_taxTrans,
                                     _taxTrans.SourceBaseAmountCurRegulated,
                                     _exchangeRateHelper.parmExchangeRate1(),
                                     _exchangeRateHelper.parmExchangeRate2());
            }

            this.taxInCostPriceReporting(_taxTrans,
                                         _taxTrans.TaxInCostPriceRegulated,
                                         _exchangeRateHelper.parmExchangeRate1(),
                                         _exchangeRateHelper.parmExchangeRate2());
        }
        else
        {
            taxAmountCur           = _taxTrans.SourceTaxAmountCur;
            taxInCostPrice         = _taxTrans.TaxInCostPrice;
        }

        this.initTaxTrans(_taxTrans, _ledgerPostingController.getJournal().parmVoucherSeriesCode());
        // <GIN>
        // add Indian specific taxTrans fields.
        if (isTaxParametersEnabled
            && taxTableLoc.TaxType_IN != TaxType_IN::None)
        {
            taxTrans_W = _taxTrans.taxTrans_W();
            taxTrans_W.TaxRegistrationNumberTable_IN = this.getTaxRegistrationNumber_IN(taxTableLoc.TaxType_IN, salesPurchJournalLineLoc);
            _taxTrans.packTaxTrans_W(taxTrans_W);
        }

        if (isExciseEnabled &&
            taxTableLoc.TaxType_IN == TaxType_IN::Excise
            )
        {
            taxTrans_W = _taxTrans.taxTrans_W();
            taxTrans_W.TaxType_IN = taxTableLoc.TaxType_IN;
            _taxTrans.packTaxTrans_W(taxTrans_W);
        }

        if (isVATEnabled && taxTableLoc.TaxType_IN == TaxType_IN::VAT)
        {
            [vatPayableAmount,vatAccount,goodsType] = this.getVATPayableAmount_IN(_taxTrans);
            if (goodsType == VATGoodsType_IN::CapitalGoods
                && vatPayableAmount
                && vatAccount)
            {
                if (abs(taxAmountCur) > abs(vatPayableAmount))
                {
                    if (!_taxTrans.TaxAutogenerated)
                    {
                        _taxTrans.SourceRegulateAmountCur = -vatPayableAmount;
                    }
                    else
                    {
                        _taxTrans.SourceTaxAmountCur = -vatPayableAmount;
                    }

                    _taxTrans.TaxAmount     = -vatPayableAmount;
                    _taxTrans.TaxAmountCur  = -vatPayableAmount;
                    _taxTrans.insert();

                    this.insertTaxTrans_IN(_taxTrans, salesPurchJournalLineLoc, vatAccount);

                    taxAmountCur = taxAmountCur + vatPayableAmount;

                    if (!_taxTrans.TaxAutogenerated)
                    {
                        _taxTrans.SourceRegulateAmountCur = taxAmountCur;
                    }
                    else
                    {
                        _taxTrans.SourceTaxAmountCur      = taxAmountCur;
                    }

                    _taxTrans.TaxAmount    = taxAmountCur;
                    _taxTrans.TaxAmountCur = taxAmountCur;
                }
                else
                {
                    _ledgerDimension =  vatAccount;
                    taxAmountCur = 0;
                }
            }
        }
        // </GIN>

        // <GMY>
        TaxGSTTaxInformation_MY::createGAFInformation(_taxTrans);
        // </GMY>

        _taxTrans.insert();
        // <GIN>
        // Post Indian specific transactions.

        if (isTaxParametersEnabled
            && taxTableLoc.TaxType_IN != TaxType_IN::None)
        {
            this.insertTaxTrans_IN(
                _taxTrans,
                salesPurchJournalLineLoc,
                _ledgerDimension,
                _operationLedgerDimension);
        }

        if (isExciseEnabled
            && taxTableLoc.TaxType_IN == TaxType_IN::Excise)
        {
            this.updateExciseRegister_IN(_taxTrans, salesPurchJournalLineLoc);
        }

        if (isServiceTaxEnabled
            && taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax)
        {
            this.insertTaxTransOffset_serviceTax_IN(_taxTrans, taxAmountCur,taxInCostPrice , _taxOffsetUseTaxLedgerDimension);
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method is the main entry point to post to TaxTrans and to post
    ///    tax amounts to the Ledger.
    /// </summary>
    /// <param name="_ledgerPostingController">
    ///     The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_companyToPost">
    ///    The company to post.
    /// </param>
    public void saveAndPost(LedgerPostingController _ledgerPostingController, SelectableDataArea _companyToPost = curext())
    {
        this.calcTaxableDocumentLineCount();

        TaxEventSource taxEventSourceLog = TaxEventSource::Log;
        guid identifier = newGuid();
        taxEventSourceLog.PostTaxStart(identifier);

        System.Diagnostics.Stopwatch stopWatch = new System.Diagnostics.Stopwatch();
        stopWatch.Start();

        this.initLedgerPosting(_ledgerPostingController);

        select count(RecId) from taxWorkTrans;

        if (taxWorkTrans.RecId > 0 && !this.useSubLedgerJournalLines())
        {
            this.saveAndPostFromTmpTaxWorkTrans(_ledgerPostingController, _companyToPost);
        }
        else
        {
            if (this.useSubLedgerJournalLines())
            {
                this.saveAndPostSubLedgerJournalLines(_ledgerPostingController, _companyToPost);
            }
            else
            {
                this.saveAndPostFromTaxUncommitted(_ledgerPostingController, _companyToPost);
            }
        }
        // <GIN>
        if (isServiceTaxEnabled &&
           ((this.headingTableId() == tableNum(VendInvoiceJour) &&
            PaymTerm::isCashAccount(VendInvoiceJour::findRecId(this.headingRecId()).Payment)) ||
            (this.headingTableId() == tableNum(VendInvoiceInfoTable) &&
            PaymTerm::isCashAccount(VendInvoiceInfoTable::findRecId(this.headingRecId()).Payment)) ||
            (this.headingTableId() == tableNum(CustInvoiceJour) &&
            PaymTerm::isCashAccount(CustInvoiceJour::findRecId(this.headingRecId()).Payment))))
        {
            this.taxServiceSettlement_IN(_ledgerPostingController);
        }

        stopWatch.Stop();
       
        taxEventSourceLog.PostTaxStop(identifier, SysCountryRegionCode::countryInfo(), stopWatch.ElapsedMilliseconds, tableId2Name(headingTableId), headingTableId, headingRecId, taxableDocumentLines);
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostFromTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method is the main entry point to post to TaxTrans and to post
    ///    tax amounts to the Ledger using TaxUncommitted.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_companyToPost">
    ///    The company to post; optional.
    /// </param>
    protected void saveAndPostFromTaxUncommitted(LedgerPostingController _ledgerPostingController, SelectableDataArea _companyToPost = curext())
    {
        TaxUncommitted          taxUncommitted;
        TaxTrans                taxTrans;
        CurrencyExchangeHelper  exchangeRateHelper;

        TaxObligationCompany    taxObligationCompany = TaxObligationCompany::Destination;
        RecordInsertList        taxUncommittedTaxTransTmpInsertList;

        RecordInsertList        insertList;
        TaxTable                taxTable;
        List                    codesList = new List(Types::String);
        TransDate               transDateOrig;
        // <GIN>
        TaxAccountType_IN         taxAccountTypeLoc;
        int                       sign;
        AmountCur                 invoiceAmount;
        AmountCur                 ledgerAmount;
        TaxTrans_IN               taxTransIN;
        boolean                   canCreateTaxTrans;
        TaxUncommitted_IN         taxUncommittedIN;
        Set                       ledgerJournalTransRecIdSet = new Set(Types::Int64);
        TransTaxInformation       transTaxInformation;
        TransTaxInformationHelper helper_IN;
        // </GIN>
        Map voucherVatDueDateMap = new Map(Types::String, Types::Date);
        Map voucherNeedCheckVatDueDateMap = new Map(Types::String, Types::AnyType);

        SelectableDataArea  currentCompany = curext();
        #ISOCountryRegionCodes

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            helper_IN = TransTaxInformationHelper::newHelper();
        }
        // </GIN>

        taxObligationCompany = this.getTaxObligationCompany();

        this.validateForPost();

        if (enableTaxUncommittedToTaxTransTmp)
        {
            taxUncommittedTaxTransTmpInsertList = new RecordInsertList(tableNum(taxUncommittedTaxTransTmp), false, false, false, false, true, taxUncommittedTaxTransTmp);
        }

        exchangeRateHelper = CurrencyExchangeHelper::construct();

        insertList = new RecordInsertList(taxSourceLineSummaryTmp.TableId, false, false, false, false, true, taxSourceLineSummaryTmp);

        ttsbegin;
        // <GIN>
        if (isServiceTaxEnabled)
        {
            //If advancepayment and Invoice amount is more than the payment amount exist it will split the TaxUncommitted for Servicetax POT basis
            TaxPost::serviceTaxPOTAdvVoucher_IN(this.headingTableId(), this.headingRecId(), exchRate, exchRateSecond);
        }
        // </GIN>
        this.parmDataAreaIdPost(_companyToPost);
        while select *
        from taxUncommitted
            order by taxUncommitted.SourceRecId
            where taxUncommitted.HeadingRecId   == this.headingRecId() &&
                  taxUncommitted.HeadingTableId == this.headingTableId() &&
                  taxUncommitted.Company        == _companyToPost  &&
                  taxUncommitted.TaxOrigin      != TaxOrigin::TaxReversed &&
                  taxUncommitted.IsDeleted      == NoYes::No
        {
            changecompany(_companyToPost)
            {
                taxTable = TaxTable::find(taxUncommitted.TaxCode);
            }

            if (this.needCheckVATDueDateConsistencyInVoucher(taxUncommitted, voucherNeedCheckVatDueDateMap))
            {
                this.checkVATDueDateConsistencyInVoucher(taxUncommitted, voucherVatDueDateMap);
            }

            // <GIN>
            canCreateTaxTrans = true;
            if (isTaxParametersEnabled)
            {
                salesPurchJournalLineLoc = this.getSalePurchJourLineFrmTaxUnCommitted_IN(taxUncommitted);
                this.initTaxTable_IN(taxUncommitted.TaxCode);
                if (post && this is TaxPostJournal)
                {
                    taxUncommittedIN   = TaxUncommitted_IN::findByTaxUncommitted(taxUncommitted.RecId);
                    ledgerJournalTransLoc = LedgerJournalTrans::findRecId(taxUncommitted.SourceRecId, false);
                    if (taxUncommittedIN.ServiceTaxReverseChargePercentage != 0
                        && taxTable.TaxType_IN == TaxType_IN::ServiceTax)
                    {
                        canCreateTaxTrans = false;
                    }
                }
            }
            // </GIN>
            if (taxUncommitted.TaxCode)
            {
                this.validateWarningsForPost(taxUncommitted.Warning, taxUncommitted.TaxCode, true);

                if (taxSourceLineSummaryTmp.SourceRecId != taxUncommitted.SourceRecId)
                {
                    taxSourceLineSummaryTmp.PrintCode = strList2str(codesList, ', ');
                    if (taxSourceLineSummaryTmp.PrintCode)
                    {
                        insertList.add(taxSourceLineSummaryTmp);
                    }

                    taxSourceLineSummaryTmp.SourceRecId = taxUncommitted.SourceRecId;
                    taxSourceLineSummaryTmp.SourceTableId = taxUncommitted.SourceTableId;
                    taxSourceLineSummaryTmp.ActualTransactionTaxAmount = 0;

                    // <GBR>
                    taxSourceLineSummaryTmp.TaxBaseAmountOther_BR = 0;
                    // </GBR>

                    codesList = new List(Types::String);
                }

                // <GEEHU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU]))
                {
                    codesList.addEnd(TaxData::find(taxUncommitted.TaxCode, taxUncommitted.TransDate, taxUncommitted.TaxBaseAmountCur).PrintCode);
                }
                else
                {
                    // </GEEHU>
                    if (taxTable.PrintCode)
                    {
                        codesList.addEnd(taxTable.PrintCode);
                    }

                    taxSourceLineSummaryTmp.ActualTransactionTaxAmount += taxUncommitted.SourceRegulateAmountCur;

                    // <GBR>
                    if (BrazilParameters::isEnabled())
                    {
                        TaxSourceLineSummaryTmp.TaxBaseAmountOther_BR += taxUncommitted.SourceOtherBaseTaxAmount_BR;
                    }
                    // </GBR>
                    // <GEEHU>
                }
                // </GEEHU>

                taxDate = taxUncommitted.TransDate;
                changecompany (taxUncommitted.Company)
                {
                    if (currentCompany == taxUncommitted.Company)
                    {
                        this.findPostingReference(_ledgerPostingController, taxUncommitted.Voucher, taxUncommitted.TransDate, taxUncommitted.SourceTableId, taxUncommitted.SourceRecId);
                        _ledgerPostingController.getReference().lastTransTxt(taxUncommitted.Txt);
                    }

                    taxTrans.clear();
                    this.initFromTaxUncommitted(taxTrans, taxUncommitted, this.taxOrigin(taxUncommitted.TaxOrigin));
                    taxTrans.TaxObligationCompany = taxObligationCompany;

                    // <GIN>
                    if (isTaxParametersEnabled)
                    {
                        this.parmTaxUncommited(taxUncommitted);
                        this.getPostingType_IN(taxTrans.taxTrans_W().TaxType_IN);
                        totLOIAmount     = taxTrans.TaxInCostPrice;
                        abatementAmount  = TaxUncommitted_IN::findByTaxUncommitted(taxUncommitted.RecId).AbatementAmount;
                    }
                    if (taxTableLoc.TaxType_IN == TaxType_IN::Customs
                    && isCustomsEnabled)
                    {
                        if ((taxUncommitted.TaxDirection      == TaxDirection::OutgoingTax
                        && this.sourceTableId()         == tableNum(CustomsShippingBillTrans_IN))
                        || taxUncommitted.TaxDirection    == TaxDirection::IncomingTax
                        || (taxUncommitted.TaxDirection   == TaxDirection::OutgoingTax
                            && (((this.sourceTableId()          == tableNum(CustInvoiceTrans)
                                    || this.sourceTableId()          == tableNum(SalesLine))
                                  && SalesTable::find(salesPurchJournalLineLoc.SourceId).CustomsExportOrder_IN == NoYes::No)
                                || (taxUncommitted.SourceTableId  == tableNum(LedgerJournalTrans)
                                        && taxUncommitted.Source == TaxModuleType::Voucher))))
                        {
                            if (taxUncommitted.TaxDirection == TaxDirection::OutgoingTax)
                            {
                                taxAccountTypeLoc = TaxAccountType_IN::CustomsExportDutyExpenseAccount;
                            }
                            else if (taxUncommitted.TaxDirection == TaxDirection::IncomingTax)
                            {
                                taxAccountTypeLoc = TaxAccountType_IN::CustomsImportDutyPayableAccount;
                            }
                            this.setCustomsAccNum_IN(taxUncommitted.LedgerDimension_IN, taxAccountTypeLoc);
                        }
                    }
                    // </GIN>

                    exchangeRateHelper.parmLedgerRecId(Ledger::current());

                    transDateOrig = LedgerJournalTrans::getTransDateByReverse(taxTrans.SourceRecId);
                    if (transDateOrig)
                    {
                        // There is an original ledger journal trans for the current ledger journal trans - set the exchange rate date to the original
                        exchangeRateHelper.parmExchangeDate(transDateOrig);
                    }
                    else
                    {
                        exchangeRateHelper.parmExchangeDate(taxTrans.TransDate);
                    }
                    if (taxUncommitted.Company == currentCompany)
                    {
                        // exchange rates from TaxUncommitted are for the logged in company only
                        // and do not apply to intercompany scenarios.  Intercompany scenarios
                        // will look up the exchange rates from the other company.
                        exchangeRateHelper.parmExchangeRate1(taxUncommitted.ExchRate);
                        exchangeRateHelper.parmExchangeRate2(taxUncommitted.ExchRateSecond);
                        exchangeRateHelper.parmReportingExchangeRate1(taxUncommitted.ReportingCurrencyExchRate);
                        exchangeRateHelper.parmReportingExchangeRate2(taxUncommitted.ReportingCurrencyExchRateSecondary);
                    }

                    // <GIN>
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                    {
                        transTaxInformation = helper_IN.getTransTaxInformationByRecord(ledgerJournalTransLoc);
                    }

                    if (isVATEnabled
                   && post
                   && this is TaxPostJournal
                   && taxTableLoc.TaxType_IN == TaxType_IN::VAT
                   && transTaxInformation.VATGoodsType == VATGoodsType_IN::CapitalGoods)
                    {
                        ledgerJournalTransRecIdSet.add(ledgerJournalTransLoc.RecId);
                    }
                    // </GIN>
                    if (canCreateTaxTrans)
                    {
                        this.postToTaxTrans(_ledgerPostingController,
                                        taxTrans,
                                        exchangeRateHelper,
                                        taxUncommitted.Voucher
                                       // <GIN>
                                       ,taxUncommitted.LedgerDimension,
                                        taxUncommitted.OperationLedgerDimension,
                                        taxUncommitted.LedgerDimension_IN
                                       // </GIN>
                                       );
                    }

                    if (enableTaxUncommittedToTaxTransTmp)
                    {
                        taxUncommittedTaxTransTmp.TaxUncommitted = taxUncommitted.RecId;
                        taxUncommittedTaxTransTmp.TaxTrans = taxTrans.RecId;
                        taxUncommittedTaxTransTmp.Company = taxUncommitted.Company;
                        taxUncommittedTaxTransTmpInsertList.add(taxUncommittedTaxTransTmp);
                    }

                    if (currentCompany != taxUncommitted.Company)
                    {
                        this.findPostingReference(_ledgerPostingController, taxTrans.Voucher, taxTrans.TransDate, taxTrans.SourceTableId, taxTrans.SourceRecId);
                        _ledgerPostingController.getReference().lastTransTxt(taxUncommitted.Txt);
                    }

                    // <GEERU>
                    if (! taxUncommitted.WithoutTaxTrans_RU)
                    {
                        // </GEERU>
                        this.postToLedger(_ledgerPostingController, taxTrans, exchangeRateHelper, taxUncommitted.LedgerDimension, taxUncommitted.OperationLedgerDimension, taxUncommitted.TaxOffsetUseTaxLedgerDimension
                                 // <GIN>
                                 , null,
                                taxUncommitted.SourceTableId,
                                taxUncommitted.SourceRecId
                                // </GIN>
                                );
                        // <GEERU>
                    }
                    // </GEERU>
                    // <GIN>
                    if (isCustomsEnabled
                    && post
                    && this is TaxPostJournal
                    && taxTableLoc.TaxType_IN == TaxType_IN::Customs
                    && taxUncommitted.Source == TaxModuleType::Voucher
                    && TaxOnItem::find(taxUncommitted.TaxItemGroup, taxUncommitted.TaxCode).CustomsChargeAsExpensePercent_IN
                    && (transTaxInformation.CustomsTariffDirection == Direction_IN::Import && transTaxInformation.CustomsTariffCode)
                    &&
                    ((ledgerJournalTransLoc.AccountType == LedgerJournalACType::Vend
                        && (ledgerJournalTransLoc.OffsetAccountType == LedgerJournalACType::Ledger
                            || ledgerJournalTransLoc.OffsetAccountType == LedgerJournalACType::Project))
                        ||
                     (ledgerJournalTransLoc.OffsetAccountType == LedgerJournalACType::Vend
                        && (ledgerJournalTransLoc.AccountType == LedgerJournalACType::Ledger
                            || ledgerJournalTransLoc.AccountType == LedgerJournalACType::Project))
                    ))
                    {
                        TaxPost::PostToExpenseAccount_IN(taxUncommitted, _ledgerPostingController.getReference());
                    }
                    // </GIN>
                    // <GEEHU><GEECZ>
                    if (TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByTable(this.headingTableId(), this.headingRecId()))
                    {
                        TaxSepcificExchangeRateAmountParameters taxSepcificExchangeRateAmountParameters = TaxSepcificExchangeRateAmountParameters::construct(
                            taxUncommitted.ExchangeRateTaxAmount,
                            taxUncommitted.ExchangeRateTaxBaseAmount,
                            taxUncommitted.ExchangeRateSourceRegulateAmount,
                            taxUncommitted.ExchangeRateSourceBaseAmountRegulated,
                            taxUncommitted.ExchangeRateTaxAmountRep,
                            taxUncommitted.ExchangeRateTaxBaseAmountRep,
                            taxUncommitted.ExchangeRateTaxAmountCur,
                            taxUncommitted.ExchangeRateTaxBaseAmountCur,
                            taxUncommitted.ExchangeRateRegulateAmountCur,
                            taxUncommitted.ExchangeRateBaseAmountCurRegulated);

                        this.processTaxSpecificExchangeRateDifferenceAmount(
                            taxTrans,
                            _ledgerPostingController,
                            exchangeRateHelper,
                            taxUncommitted.LedgerDimension,
                            taxSepcificExchangeRateAmountParameters);
                    }
                    else if (this.parmUseTaxExchangeRate() && this.parmAccountingCurrency() != taxUncommitted.SourceCurrencyCode)
                    {
                        this.processTaxExchangeRateDifferenceAmount(taxTrans, _ledgerPostingController, exchangeRateHelper,
                        taxUncommitted.LedgerDimension, taxUncommitted.ExchangeRateTaxBaseAmount, taxUncommitted.ExchangeRateSourceBaseAmountRegulated,
                        taxUncommitted.ExchangeRateTaxAmount, taxUncommitted.ExchangeRateSourceRegulateAmount);
                    }
                    // </GEECZ></GEEHU>
                }
            }
        }
        
        if (taxSourceLineSummaryTmp.SourceRecId && taxSourceLineSummaryTmp.SourceTableId)
        {
            taxSourceLineSummaryTmp.PrintCode = strList2str(codesList, ', ');
            if (taxSourceLineSummaryTmp.PrintCode)
            {
                insertList.add(taxSourceLineSummaryTmp);
            }
        }

        insertList.insertDatabase();

        // <GIN>
        if (!ledgerJournalTransRecIdSet.empty())
        {
            this.createDefermentSchedule_IN(ledgerJournalTransRecIdSet);
        }
        // /GIN>

        // <GIN>
        if (isTaxParametersEnabled
           && ledgerJournalTransLoc.RecId   != 0
           && ledgerJournalTransLoc.Invoice != '')
        {
            ledgerAmount = ledgerJournalTransLoc.amount();
            if (ledgerAmount != 0)
            {
                sign = ledgerAmount > 0 ? 1 : -1;
                invoiceAmount = sign * (abs(ledgerAmount) + abs(TaxTrans::getTaxAmountIncludedInInvoice_IN(ledgerJournalTransLoc.TableId, ledgerJournalTransLoc.RecId)));
                update_recordset taxTransIN
                    setting InvoiceAmount = invoiceAmount
                        where taxTransIN.SourceTableId == taxTrans.SourceTableId
                           && taxTransIN.SourceRecId   == taxTrans.SourceRecId;
            }
        }
        // </GIN>

        if (enableTaxUncommittedToTaxTransTmp)
        {
            taxUncommittedTaxTransTmpInsertList.insertDatabase();
        }

        if (this.allowTaxAdjustmentDelete())
        {
            // delete any tax adjustments
            this.deleteTaxRegulation(_companyToPost);
        }

        if (this.allowTaxUncommittedDelete())
        {
            // after posting, TaxUncommitted records get removed.
            TaxUncommitted::deleteForDocumentHeader(this.headingTableId(), headingRecId, false);
        }

        ttscommit;

        if (MultipleTaxIdReportingHelper::isLegalEntityOrTaxCodeInCountryRegion(
            taxTrans.TaxCode, [#isoIT], MultipleTaxIdScope::VATDeclaration))
        {
            info(strFmt("@SYS75076", taxTrans.Voucher));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>needCheckVATDueDateConsistencyInVoucher</Name>
				<Source><![CDATA[
    private boolean needCheckVATDueDateConsistencyInVoucher(TaxUncommitted _taxUncommitted, Map _voucherNeedCheckVatDueDateMap)
    {
        boolean needCheck;

        if (_taxUncommitted.SourceTableId == tableNum(LedgerJournalTrans)
            && TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            if (_voucherNeedCheckVatDueDateMap.exists(_taxUncommitted.Voucher))
            {
                needCheck = _voucherNeedCheckVatDueDateMap.lookup(_taxUncommitted.Voucher);
            }
            else
            {
                LedgerJournalTable ledgerJournalTable = LedgerJournalTrans::findRecId(_taxUncommitted.SourceRecId, false).ledgerJournalTable();
                needCheck = ledgerJournalTable.isTaxIntegrationEnabled();
                _voucherNeedCheckVatDueDateMap.insert(_taxUncommitted.Voucher, needCheck);
            }
        }
        return needCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVATDueDateConsistencyInVoucher</Name>
				<Source><![CDATA[
    private void checkVATDueDateConsistencyInVoucher(TaxUncommitted _taxUncommitted, Map _voucherVatDueDateMap)
    {
        if (_voucherVatDueDateMap.exists(_taxUncommitted.Voucher))
        {
            VatDueDate_W vatDueDate_W = _voucherVatDueDateMap.lookup(_taxUncommitted.Voucher);
            if (_taxUncommitted.VatDueDate_W != vatDueDate_W)
            {
                this.throwErrorMessageForVATDueDateInconsistency(_taxUncommitted);
            }
        }
        else
        {
            _voucherVatDueDateMap.insert(_taxUncommitted.Voucher, _taxUncommitted.VatDueDate_W);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwErrorMessageForVATDueDateInconsistency</Name>
				<Source><![CDATA[
    private void throwErrorMessageForVATDueDateInconsistency(TaxUncommitted _taxUncommitted)
    {
        setPrefix(strFmt("@TaxVATDueDate:MessagePrefixForVATDueDateInconsistentInJournal", _taxUncommitted.Voucher));

        TaxUncommitted taxUncommitted;
        while select SourceRecId from taxUncommitted
            group by taxUncommitted.SourceRecId
            where taxUncommitted.HeadingRecId == _taxUncommitted.HeadingRecId
                && taxUncommitted.HeadingTableId == _taxUncommitted.HeadingTableId
                && taxUncommitted.Voucher == _taxUncommitted.Voucher
                && taxUncommitted.Company == _taxUncommitted.Company
                && taxUncommitted.TaxOrigin != TaxOrigin::TaxReversed
                && taxUncommitted.IsDeleted == NoYes::No
                && taxUncommitted.SourceTableId == tableNum(LedgerJournalTrans)
        {
            LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::findRecId(taxUncommitted.SourceRecId, false);
            LedgerJournalAC mainAccount = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(ledgerJournalTrans.LedgerDimension);
            Message::Add(
                MessageSeverity::Error,
                strFmt(
                    "@TaxVATDueDate:MessageDetailForVATDueDateInconsistentInJournal",
                    ledgerJournalTrans.TransDate,
                    enum2Str(ledgerJournalTrans.AccountType),
                    mainAccount,
                    ledgerJournalTrans.amount(),
                    ledgerJournalTrans.VatDueDate_W));
        }

        throw Exception::Error;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostFromTmpTaxWorkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method is the main entry point to post to TaxTrans
    ///    and to post tax amounts to the Ledger using TmpTaxWorkTrans.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_companyToPost">
    ///    The company to post; optional.
    /// </param>
    protected void saveAndPostFromTmpTaxWorkTrans(LedgerPostingController _ledgerPostingController, SelectableDataArea _companyToPost = curext())
    {
        TaxTrans                taxTrans;
        boolean                 vatBookEnabled;
        CurrencyExchangeHelper  exchangeRateHelper;
        SelectableDataArea      currentCompany = curext();
        TaxObligationCompany    taxObligationCompany = TaxObligationCompany::Destination;

        RecordInsertList        insertList;
        TaxTable                taxTable;
        List                    codesList = new List(Types::String);
        #ISOCountryRegionCodes

        // <GIN>
        TaxAmountCur                    deferredAmountLoc;
        boolean                         isNumSeqGenerated = false;
        InventTransId                   inventTransId = '';
        RefRecId                        postingAccount;
        CustomsVendBOESubTrans_IN       customsVendBOESubTrans;
        TaxTransGeneralJournalAccountEntry  taxTransGeneralJournalAccountEntry;
        TaxTrans_W taxTrans_W;
        // </GIN>

        insertList = new RecordInsertList(taxSourceLineSummaryTmp.TableId, false, false, false, false, true, taxSourceLineSummaryTmp);

        vatBookEnabled = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]);

        taxObligationCompany = this.getTaxObligationCompany();

        this.validateForPost();

        exchangeRateHelper = CurrencyExchangeHelper::construct();

        // <GIN>
        if (isTaxParametersEnabled)
        {
            tmpTaxWorkTransLoc.setTmpData(taxWorkTrans);
        }
        // </GIN>

        ttsbegin;

        while select * from taxWorkTrans
            order by taxWorkTrans.SourceRecId
            where taxWorkTrans.HeadingRecId   == this.headingRecId() &&
                taxWorkTrans.HeadingTableId == this.headingTableId() &&
                taxWorkTrans.Company        == _companyToPost &&
                taxWorkTrans.TaxOrigin      != TaxOrigin::TaxReversed &&
                taxWorkTrans.IsDeleted      == NoYes::No
        {
            // <GIN>
            if (isTaxParametersEnabled)
            {
                salesPurchJournalLineLoc = this.getSalesPurchJournalLineFromInventId_IN();
                this.initTaxTable_IN(taxWorkTrans.TaxCode);
            }
            // </GIN>

            if (taxWorkTrans.TaxCode)
            {
                this.validateWarningsForPost(taxWorkTrans.Warning, taxWorkTrans.TaxCode, true);

                if (taxSourceLineSummaryTmp.SourceRecId != taxWorkTrans.SourceRecId)
                {
                    taxSourceLineSummaryTmp.PrintCode = strList2str(codesList, ', ');
                    if (taxSourceLineSummaryTmp.PrintCode)
                    {
                        insertList.add(taxSourceLineSummaryTmp);
                    }

                    taxSourceLineSummaryTmp.SourceRecId = taxWorkTrans.SourceRecId;
                    taxSourceLineSummaryTmp.SourceTableId = taxWorkTrans.SourceTableId;
                    taxSourceLineSummaryTmp.ActualTransactionTaxAmount = 0;

                    // <GBR>
                    taxSourceLineSummaryTmp.TaxBaseAmountOther_BR = 0;
                    // </GBR>

                    codesList = new List(Types::String);
                }

                // <GEEHU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU]))
                {
                    codesList.addEnd(TaxData::find(taxWorkTrans.TaxCode, taxWorkTrans.TransDate, taxWorkTrans.TaxBaseAmountCur).PrintCode);
                }
                else
                {
                    // </GEEHU>
                    taxTable = TaxTable::find(taxWorkTrans.TaxCode);
                    if (taxTable.PrintCode)
                    {
                        codesList.addEnd(taxTable.PrintCode);
                    }

                    taxSourceLineSummaryTmp.ActualTransactionTaxAmount += taxWorkTrans.SourceRegulateAmountCur;

                    // <GBR>
                    if (BrazilParameters::isEnabled())
                    {
                        TaxSourceLineSummaryTmp.TaxBaseAmountOther_BR += taxWorkTrans.SourceOtherBaseTaxAmount_BR;
                    }
                    // </GBR>
                    // <GEEHU>
                }
                // </GEEHU>

                taxDate = taxWorkTrans.TransDate;
                changecompany (taxWorkTrans.Company)
                {
                    if (currentCompany == taxWorkTrans.Company)
                    {
                        this.findPostingReference(_ledgerPostingController, taxWorkTrans.Voucher, taxWorkTrans.TransDate, taxWorkTrans.SourceTableId, taxWorkTrans.SourceRecId);
                        _ledgerPostingController.getReference().lastTransTxt(taxWorkTrans.Txt);
                    }

                    taxTrans.clear();
                    this.initFromTaxWorkTrans(taxTrans, taxWorkTrans, this.taxOrigin(taxWorkTrans.TaxOrigin));
                    taxTrans.TaxObligationCompany = taxObligationCompany;

                    // <GIN>
                    if (isTaxParametersEnabled)
                    {
                        deferredAmountLoc = 0;
                        deferredInvAcc    = 0;
                        select firstonly LedgerDimension from taxTransGeneralJournalAccountEntry
                            where taxTransGeneralJournalAccountEntry.TaxTrans == taxTrans.RecId;
                    }
                    // </GIN>
                    exchangeRateHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
                    exchangeRateHelper.parmExchangeDate(taxTrans.TransDate);
                    if (taxWorkTrans.Company == currentCompany)
                    {
                        // exchange rates are for the logged in company only
                        // and do not apply to intercompany scenarios.  Intercompany scenarios
                        // will look up the exchange rates from the other company.
                        exchangeRateHelper.parmExchangeRate1(exchRate);
                        exchangeRateHelper.parmExchangeRate2(exchRateSecond);
                    }

                    // <GIN>
                    if (isTaxParametersEnabled
                        && taxTableLoc.TaxType_IN != TaxType_IN::None)
                    {
                        taxTrans_W = taxTrans.taxTrans_W();
                        abatementAmount             = taxWorkTrans.AbatementAmount_IN;
                        salesPurchJournalLineLoc    = this.getSalesPurchJournalLineFromInventId_IN();
                        taxTrans.TaxValue           = taxWorkTrans.showTaxValue_IN(salesPurchJournalLineLoc);
                        taxTrans_W.TaxComponentTable_IN    = taxTableLoc.TaxComponentTable_IN;
                        taxTrans.packTaxTrans_W(taxTrans_W);
                    }

                    if (isTaxParametersEnabled)
                    {
                        if (taxModuleType    == TaxModuleType::PurchInvoice
                            || taxModuleType == TaxModuleType::Purch
                            || taxModuleType == TaxModuleType::StockTransfer_IN)
                        {
                            if (taxTableLoc.TaxType_IN != TaxType_IN::None
                                && ((taxTableLoc.TaxType_IN == TaxType_IN::Customs          && isCustomsEnabled)
                                    || (taxTableLoc.TaxType_IN == TaxType_IN::Excise        && isExciseEnabled)
                                    || (taxTableLoc.TaxType_IN == TaxType_IN::SalesTax      && isSalesTaxEnabled)
                                    || (taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax    && isServiceTaxEnabled)
                                    || (taxTableLoc.TaxType_IN == TaxType_IN::VAT           && isVATEnabled)))
                            {
                                totLOIAmount = taxTrans.TaxInCostPrice;
                            }
                        }

                        if (taxModuleType == TaxModuleType::StockTransfer_IN )
                        {
                            taxTrans.Voucher = voucher;
                        }
                        this.getPostingType_IN(taxTableLoc.TaxType_IN);
                    }

                    if (isExciseEnabled
                        && taxTableLoc.TaxType_IN == TaxType_IN::Excise)
                    {
                        postingAccount      = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(this.getSettledExcisePayableAcc_IN(taxTrans),
                                                                                                               taxTransGeneralJournalAccountEntry.LedgerDimension);
                        taxTransGeneralJournalAccountEntry.LedgerDimension = postingAccount ? postingAccount : taxTransGeneralJournalAccountEntry.LedgerDimension;
                    }

                    // </GIN>
                    this.postToTaxTrans(_ledgerPostingController,
                                        taxTrans,
                                        exchangeRateHelper,
                                        taxWorkTrans.Voucher
                                       // <GIN>
                                       , taxWorkTrans.LedgerDimension,
                                          taxWorkTrans.OperationLedgerDimension,
                                          taxWorkTrans.LedgerDimension_IN
                                       // </GIN>
                                       );
                    // <GEERU>
                    if (! taxWorkTrans.WithoutTaxTrans_RU)
                    {
                        // </GEERU>
                        this.postToLedger(_ledgerPostingController, taxTrans, exchangeRateHelper, taxWorkTrans.LedgerDimension, taxWorkTrans.OperationLedgerDimension, taxWorkTrans.TaxOffsetUseTaxLedgerDimension);
                        // <GEERU>
                    }
                    // </GEERU>

                    // <GIN>
                    if (isCustomsEnabled
                        && taxWorkTrans.TaxDirection == TaxDirection::IncomingTax
                        && taxTrans.taxTrans_W().TaxType_IN       == TaxType_IN::Customs)
                    {
                        select firstonly ExchangeRate from customsVendBOESubTrans
                            where customsVendBOESubTrans.InventTransId == taxWorkTrans.InventTransId
                               && customsVendBOESubTrans.TaxCode       == taxWorkTrans.TaxCode;
                        exchangeRateHelper.parmExchangeRate1(customsVendBOESubTrans.ExchangeRate);
                    }
                    // </GIN>
                }
            }
        }

        if (taxSourceLineSummaryTmp.SourceRecId && taxSourceLineSummaryTmp.SourceTableId)
        {
            taxSourceLineSummaryTmp.PrintCode = strList2str(codesList, ', ');
            if (taxSourceLineSummaryTmp.PrintCode)
            {
                insertList.add(taxSourceLineSummaryTmp);
            }
        }

        insertList.insertDatabase();

        if (this.allowTaxAdjustmentDelete())
        {
            this.deleteTaxRegulation(_companyToPost);
        }

        ttscommit;

        if (MultipleTaxIdReportingHelper::isLegalEntityOrTaxCodeInCountryRegion(
            taxTrans.TaxCode, [#isoIT], MultipleTaxIdScope::VATDeclaration))
        {
            info(strFmt("@SYS75076", taxTrans.Voucher));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostSubLedgerJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts tax amounts to <c>TaxTrans</c> and the ledger using <c>TaxUncommitted</c> and
    ///    <c>SubLedgerJournalLines</c>.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_companyToPost">
    ///    The company to post; optional.
    /// </param>
    protected void saveAndPostSubLedgerJournalLines(LedgerPostingController _ledgerPostingController, SelectableDataArea _companyToPost = curext())
    {
        TaxUncommitted          taxUncommitted;
        TaxTrans                taxTrans;
        boolean                 vatBookEnabled;
        CurrencyExchangeHelper  exchangeRateHelper;
        SelectableDataArea      currentCompany = curext();
        boolean                 isTaxTransCreated;
        SourceDocumentHeader    sourceDocumentHeader;
        SourceDocumentLine      sourceDocumentLine;
        SourceDocumentLineRecId taxTransSourceDocumentLineId;
        TaxObligationCompany    taxObligationCompany = TaxObligationCompany::Destination;
        RecordInsertList        taxUncommittedTaxTransTmpInsertList;
        RecordInsertList        insertList;
        TaxTable                taxTable;
        List                    codesList = new List(Types::String);

        // <GIN>
        EximTaxTrans_IN           eximTaxTrans;
        EximExportImport_IN       direction;
        TaxUncommitted_IN         taxUncommittedIN;
        TaxAccountType_IN         taxAccountTypeLoc;
        TransDate                 customsBillOfEntryDate;
        TaxTrans_W                taxTrans_W;
        // </GIN>

        #ISOCountryRegionCodes

        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        insertList = new RecordInsertList(taxSourceLineSummaryTmp.TableId, false, false, false, false, true, taxSourceLineSummaryTmp);

        vatBookEnabled = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]);

        taxObligationCompany = this.getTaxObligationCompany();

        this.validateForPost();

        taxUncommittedTaxTransTmpInsertList = new RecordInsertList(taxUncommittedTaxTransTmp.TableId, false, false, false, false, true, taxUncommittedTaxTransTmp);

        exchangeRateHelper = CurrencyExchangeHelper::newLedger(Ledger::current());

        ttsbegin;
        // <GIN>
        if (TaxParameters::isServiceTaxEnable_IN())
        {// Only POT time Purchase order
            if ((this.headingTableId() == tableNum(PurchTable))
                 || (this.headingTableId() == tableNum(VendInvoiceInfoTable))
                 || (this.headingTableId() == tableNum(VendInvoiceJour)))
            {
                TaxPost::serviceTaxReverseChargeVoucher_IN(this.headingTableId(), this.headingRecId(), exchRate, exchRateSecond);
            }
            else// Only POT time FTI
            {
                //If advancepayment and Invoice amount is more than the payment amount exist it will split the TaxUncommitted for Servicetax POT basis
                TaxPost::serviceTaxPOTAdvVoucher_IN(this.headingTableId(), this.headingRecId(), exchRate, exchRateSecond);
            }
        }
        // </GIN>
        while select * from taxUncommitted
           order by taxUncommitted.SourceRecId
           where taxUncommitted.HeadingRecId    == this.headingRecId() &&
                  taxUncommitted.HeadingTableId == this.headingTableId() &&
                  taxUncommitted.TaxOrigin      != TaxOrigin::TaxReversed &&
                  taxUncommitted.Company        == _companyToPost &&
                  taxUncommitted.IsDeleted      == NoYes::No
           join PrintCode from taxTable
                where taxTable.TaxCode              == taxUncommitted.TaxCode
        {
            // <GIN>
            if (isTaxParametersEnabled)
            {
                salesPurchJournalLineLoc = this.getSalePurchJourLineFrmTaxUnCommitted_IN(taxUncommitted);
                this.initTaxTable_IN(taxUncommitted.TaxCode);
                taxUncommittedIN = TaxUncommitted_IN::findByTaxUncommitted(taxUncommitted.RecId);
                //taxworkTrans values buffer is lost during this method called where some other values are updated in the below code
                select firstonly taxWorkTrans
                    where taxWorkTrans.SourceTableId == taxUncommitted.SourceTableId
                       && taxWorkTrans.SourceRecId   == taxUncommitted.SourceRecId
                       && taxWorkTrans.InventTransId == taxUncommitted.InventTransId
                       && taxWorkTrans.TaxCode       == taxUncommitted.TaxCode;
            }
            // </GIN>
            if (taxUncommitted.TaxCode)
            {
                this.validateWarningsForPost(taxUncommitted.Warning, taxUncommitted.TaxCode, true);

                if (taxSourceLineSummaryTmp.SourceRecId != taxUncommitted.SourceRecId)
                {
                    taxSourceLineSummaryTmp.PrintCode = strList2str(codesList, ', ');
                    if (taxSourceLineSummaryTmp.PrintCode)
                    {
                        insertList.add(taxSourceLineSummaryTmp);
                    }

                    taxSourceLineSummaryTmp.SourceRecId = taxUncommitted.SourceRecId;
                    taxSourceLineSummaryTmp.SourceTableId = taxUncommitted.SourceTableId;
                    taxSourceLineSummaryTmp.ActualTransactionTaxAmount = 0;

                    // <GBR>
                    taxSourceLineSummaryTmp.TaxBaseAmountOther_BR = 0;
                    // </GBR>

                    codesList = new List(Types::String);
                }

                // <GEEHU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU]))
                {
                    codesList.addEnd(TaxData::find(taxUncommitted.TaxCode, taxUncommitted.TransDate, taxUncommitted.TaxBaseAmountCur).PrintCode);
                }
                else
                {
                    // </GEEHU>
                    if (taxTable.PrintCode)
                    {
                        codesList.addEnd(taxTable.PrintCode);
                    }

                    taxSourceLineSummaryTmp.ActualTransactionTaxAmount += taxUncommitted.SourceRegulateAmountCur;

                    // <GBR>
                    if (BrazilParameters::isEnabled())
                    {
                        TaxSourceLineSummaryTmp.TaxBaseAmountOther_BR += taxUncommitted.SourceOtherBaseTaxAmount_BR;
                    }
                    // </GBR>

                    // <GEEHU>
                }
                // </GEEHU>

                taxDate = taxUncommitted.TransDate;
                if (currentCompany == taxUncommitted.Company)
                {
                    this.findPostingReference(_ledgerPostingController, taxUncommitted.Voucher, taxUncommitted.TransDate, taxUncommitted.SourceTableId, taxUncommitted.SourceRecId);
                    _ledgerPostingController.getReference().lastTransTxt(taxUncommitted.Txt);
                }

                exchangeRateHelper.parmExchangeDate(taxUncommitted.TransDate);
                if (taxUncommitted.Company == currentCompany)
                {
                    // exchange rates from TaxUncommitted are for the logged in company only
                    // and do not apply to intercompany scenarios.  Intercompany scenarios
                    // will look up the exchange rates from the other company.
                    exchangeRateHelper.parmExchangeRate1(taxUncommitted.ExchRate);
                    exchangeRateHelper.parmExchangeRate2(taxUncommitted.ExchRateSecond);
                    exchangeRateHelper.parmReportingExchangeRate1(taxUncommitted.ReportingCurrencyExchRate);
                    exchangeRateHelper.parmReportingExchangeRate2(taxUncommitted.ReportingCurrencyExchRateSecondary);
                }

                taxTrans.clear();
                this.initFromTaxUncommitted(taxTrans, taxUncommitted, this.taxOrigin(taxUncommitted.TaxOrigin));
                taxTrans.TaxObligationCompany = taxObligationCompany;

                if (tableNum(TrvExpTrans) == this.headingTableId())
                {
                    taxTrans.TransDate = TrvExpenseTransHelper::getUpdatedAccountingDate(this.headingRecId());
                }

                // <GIN>
                if (isTaxParametersEnabled
                    && (taxTableLoc.TaxType_IN != TaxType_IN::None))
                {
                    taxTrans_W = taxTrans.taxTrans_W();
                    if (taxWorkTrans.RecId != 0)
                    {
                        taxTrans.TaxValue                       = taxWorkTrans.showTaxValue_IN(salesPurchJournalLineLoc);
                    }
                    else if (taxUncommitted.RecId != 0)
                    {
                        taxTrans.TaxValue                       = taxUncommitted.showTaxValue();
                    }
                    taxTrans_W.TaxComponentTable_IN         = taxTableLoc.TaxComponentTable_IN;
                    abatementAmount                         = taxUncommittedIN.AbatementAmount;
                    if (isCustomsEnabled
                        && taxTableLoc.TaxType_IN == TaxType_IN::Customs)
                    {
                        direction = CurrencyHelper_IN::sourceTable2CustomsDirection_New_IN(taxUncommitted.SourceTableId, taxUncommitted.SourceRecId);
                        taxTrans_W.CustomsDuty_IN      = taxUncommittedIN.CustomsDuty;
                        taxTrans.TaxAmount           = taxUncommittedIN.CustomsDuty;
                        customsBillOfEntryDate = CustomsVendBOETrans_IN::getCustomsBillOfEntryDate_IN(taxUncommitted.SourceTableId, taxUncommitted.SourceRecId);
                        taxTrans_W.TaxAmountCustoms_IN = CurrencyHelper_IN::customsMSTAmount_IN(taxUncommitted.SourceRegulateAmountCur,
                                                                                        taxUncommitted.SourceCurrencyCode,
                                                                                        direction,
                                                                                        customsBillOfEntryDate ? customsBillOfEntryDate : taxUncommitted.TransDate);
                    }
                    taxTrans.packTaxTrans_W(taxTrans_W);
                }

                if (isTaxParametersEnabled
                    && (taxModuleType    == TaxModuleType::PurchInvoice
                        || taxModuleType == TaxModuleType::Purch
                        || taxModuleType == TaxModuleType::StockTransfer_IN))
                {
                    if (taxTableLoc.TaxType_IN != TaxType_IN::None
                        && ((taxTableLoc.TaxType_IN == TaxType_IN::Customs          && isCustomsEnabled)
                            || (taxTableLoc.TaxType_IN == TaxType_IN::Excise        && isExciseEnabled)
                            || (taxTableLoc.TaxType_IN == TaxType_IN::SalesTax      && isSalesTaxEnabled)
                            || (taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax    && isServiceTaxEnabled)
                            || (taxTableLoc.TaxType_IN == TaxType_IN::VAT           && isVATEnabled)))
                    {
                        totLOIAmount = taxTrans.TaxInCostPrice;
                    }
                }
                if (taxTableLoc.TaxType_IN == TaxType_IN::Customs
                    && isCustomsEnabled)
                {
                    if (taxUncommitted.TaxDirection == TaxDirection::OutgoingTax)
                    {
                        taxAccountTypeLoc = TaxAccountType_IN::CustomsExportDutyExpenseAccount;
                    }
                    else if (taxUncommitted.TaxDirection == TaxDirection::IncomingTax)
                    {
                        taxAccountTypeLoc = TaxAccountType_IN::CustomsImportDutyPayableAccount;
                    }

                    this.setCustomsAccNum_IN(taxUncommitted.LedgerDimension_IN, taxAccountTypeLoc);
                }
                // </GIN>

                this.postToTaxTrans(_ledgerPostingController,
                                    taxTrans,
                                    exchangeRateHelper,
                                    taxUncommitted.Voucher
                                    //<GIN>
                                    ,taxUncommitted.LedgerDimension,
                                    taxUncommitted.OperationLedgerDimension,
                                    taxUncommitted.LedgerDimension_IN
                                    // </GIN>
                                    );

                if (enableTaxUncommittedToTaxTransTmp)
                {
                    taxUncommittedTaxTransTmp.TaxUncommitted = taxUncommitted.RecId;
                    taxUncommittedTaxTransTmp.TaxTrans = taxTrans.RecId;
                    taxUncommittedTaxTransTmp.Company = taxUncommitted.Company;
                    taxUncommittedTaxTransTmpInsertList.add(taxUncommittedTaxTransTmp);
                }

                // <GEEHU><GEECZ>
                if (this.parmUseTaxExchangeRate())
                {
                    if (TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByTable(this.headingTableId(), this.headingRecId()))
                    {
                        TaxSepcificExchangeRateAmountParameters taxSepcificExchangeRateAmountParameters = TaxSepcificExchangeRateAmountParameters::construct(
                            taxUncommitted.ExchangeRateTaxAmount,
                            taxUncommitted.ExchangeRateTaxBaseAmount,
                            taxUncommitted.ExchangeRateSourceRegulateAmount,
                            taxUncommitted.ExchangeRateSourceBaseAmountRegulated,
                            taxUncommitted.ExchangeRateTaxAmountRep,
                            taxUncommitted.ExchangeRateTaxBaseAmountRep,
                            taxUncommitted.ExchangeRateTaxAmountCur,
                            taxUncommitted.ExchangeRateTaxBaseAmountCur,
                            taxUncommitted.ExchangeRateRegulateAmountCur,
                            taxUncommitted.ExchangeRateBaseAmountCurRegulated);

                        this.saveTaxSpecificExchangeRateDifferenceAmount(
                            taxSepcificExchangeRateAmountParameters,
                            taxTrans);
                    }
                    else if (this.parmAccountingCurrency() != this.getTransactionalCurrency())
                    {
                        this.saveTaxExchangeRateDifferenceAmount(
                            taxUncommitted.ExchangeRateSourceBaseAmountRegulated,
                            taxUncommitted.ExchangeRateTaxBaseAmount,
                            taxUncommitted.ExchangeRateSourceRegulateAmount,
                            taxUncommitted.ExchangeRateTaxAmount,
                            taxTrans);
                    }
                }
                // </GEECZ></GEEHU>
                // <GEERU>
                if (countryRegion_RU)
                {
                    this.createOrphanLinkInsteadPost_RU(taxTrans,
                                                        taxUncommitted.LedgerDimension,
                                                        taxUncommitted.OperationLedgerDimension,
                                                        taxUncommitted.TaxOffsetUseTaxLedgerDimension,
                                                        taxUncommitted.OffsetLedgerDimension_RU);
                }
                // </GEERU>

                // <GIN>
                if (isCustomsEnabled
                    && taxTableLoc.TaxType_IN == TaxType_IN::Customs)
                {
                    // Below code handles ApplyExcise for PO side only.
                    if (isExciseEnabled
                        && (taxTrans.Source == TaxModuleType::Purch
                        || taxTrans.Source  == TaxModuleType::PurchInvoice)
                        && TaxComponentTable_IN::find(taxTableLoc.TaxComponentTable_IN).ApplyExcise
                        && taxUncommittedIN.EximIncentiveScheme == EximIncentiveScheme_IN::None)
                    {
                        // Customs duty ExpenseVoucher Voucher is replaced by Excise recoverable here, for Apply Excise.
                        this.postApplyExciseTaxCodes_IN(_ledgerPostingController,
                                                        taxTrans,
                                                        (taxTrans.SourceTaxAmountCur - loadOnInventry),
                                                        taxTrans.TaxInCostPrice,
                                                        exchangeRateHelper,
                                                        LedgerDetailLevel::AsDefault,
                                                        taxUncommitted
                                                        );
                    }
                }

                if (isTaxParametersEnabled
                    && taxTableLoc.TaxType_IN != TaxType_IN::None)
                {
                    if (taxTableLoc.TaxType_IN == TaxType_IN::Customs)
                    {
                        eximTaxTrans.AssessableValue = CurrencyHelper_IN::customsMSTAmount_IN(taxUncommitted.SourceBaseAmountCur,
                                                                                        taxUncommitted.SourceCurrencyCode,
                                                                                        direction,
                                                                                        customsBillOfEntryDate ? customsBillOfEntryDate : taxUncommitted.TransDate);
                        if (taxUncommittedIN.EximIncentiveScheme != EximIncentiveScheme_IN::None)
                        {
                            eximTaxTrans.IncentiveScheme    = taxUncommittedIN.EximIncentiveScheme;
                            eximTaxTrans.AuthorizationId    = taxUncommittedIN.EximAuthorizationId;
                            eximTaxTrans.TaxAmount          = taxUncommittedIN.EximTaxAmount;
                            eximTaxTrans.TaxCorrectedAmount = taxUncommittedIN.EximTaxCorrectedAmount;
                            eximTaxTrans.depbAmount         = taxUncommittedIN.EximDEPBAmount;
                            eximTaxTrans.depbAmountCur      = taxUncommittedIN.EximDEPBAmountCur;
                            eximTaxTrans.BalanceTaxAmount   = taxUncommittedIN.EximBalanceTaxAmount;
                            eximTaxTrans.BalanceTaxCorrectedAmount = taxUncommittedIN.EximBalanceTaxCorrectedAmount;
                        }
                        eximTaxTrans.TaxTransRecId   = taxTrans.RecId;
                        eximTaxTrans.insert();
                        eximTaxTrans.clear();
                    }
                }
                // </GIN>
                if (!isTaxTransCreated)
                {
                    taxTransSourceDocumentLineId = taxTrans.SourceDocumentLine;
                    isTaxTransCreated = true;
                }
            }
        }

        if (taxSourceLineSummaryTmp.SourceRecId && taxSourceLineSummaryTmp.SourceTableId)
        {
            taxSourceLineSummaryTmp.PrintCode = strList2str(codesList, ', ');
            if (taxSourceLineSummaryTmp.PrintCode)
            {
                insertList.add(taxSourceLineSummaryTmp);
            }
        }

        insertList.insertDatabase();

        // the SourceRelationshipType on the source document line records needs to change from
        // TaxUncommitted to TaxTrans.
        this.moveSourceDocumentLineOwnerToTaxTrans();

        taxUncommittedTaxTransTmpInsertList.insertDatabase();

        if (this.allowTaxUncommittedDelete())
        {
            // after posting, TaxUncommitted records get removed.
            TaxUncommitted::deleteForDocumentHeader(this.headingTableId(), this.headingRecId(), false);
        }

        if (this.allowTaxAdjustmentDelete())
        {
            // delete any tax adjustments
            this.deleteTaxRegulation(_companyToPost);
        }

        if (isTaxTransCreated)
        {
            // Attempts to create relationship between TaxTrans and GeneralJournalAccountEntry after taxTrans is created
            // because the subledger journal account entries might have been transferred to the ledger prior to the
            // taxTrans records for the source document are created.

            select firstonly RecId from sourceDocumentHeader
                join RecId from sourceDocumentLine
                    where sourceDocumentLine.SourceDocumentHeader == sourceDocumentHeader.RecId
                        && sourceDocumentLine.RecId == taxTransSourceDocumentLineId;

            TaxTransGeneralJournalAccountEntryGenerator::generateTaxTransGeneralJournalAccEntry(sourceDocumentHeader.RecId);
        }

        ttscommit;

        if (MultipleTaxIdReportingHelper::isLegalEntityOrTaxCodeInCountryRegion(
            taxTrans.TaxCode, [#isoIT], MultipleTaxIdScope::VATDeclaration))
        {
            info(strFmt("@SYS75076", taxTrans.Voucher));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the <c>RecId</c> of the transaction line that is currently being posted.
    /// </summary>
    /// <returns>
    ///    The <c>RecId</c> of the transaction line being posted.
    /// </returns>
    /// <remarks>
    ///    This method is overridden by derived classes.
    /// </remarks>
    abstract public RecId sourceRecId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the <c>TableId</c> of the transaction that is to be taxed.
    /// </summary>
    /// <returns>
    ///    The ID of the transaction to be taxed.
    /// </returns>
    /// <remarks>
    ///    This method is overridden by derived classes.
    /// </remarks>
    abstract public TableId sourceTableId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpTaxWorkTrans</Name>
				<Source><![CDATA[
    TmpTaxWorkTrans tmpTaxWorkTrans(TmpTaxWorkTrans _tmpTaxWorkTrans = taxWorkTrans)
    {
        taxWorkTrans = _tmpTaxWorkTrans;
        return _tmpTaxWorkTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferSubLedgerToGeneralLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether can transfer subledger to genernal ledger.
    /// </summary>
    /// <returns>true if the validation is correct; otherwise false.</returns>
    public boolean transferSubLedgerToGeneralLedger()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAndPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method is the main entry point to execute transaction specific logic and to
    ///    post to TaxTrans and to post tax amounts to the Ledger.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_companyToPost">
    ///    The company to post; optional.
    /// </param>
    /// <returns>
    ///    The total tax amount.
    /// </returns>
    abstract public TaxAmount updateAndPost(LedgerPostingController _ledgerPostingController, SelectableDataArea _companyToPost = curext())
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>useAdjustedBaseAmountForBaseAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a value that indicates whether the adjusted base amount should be used instead of the base
    ///    amount, when set.
    /// </summary>
    /// <returns>
    ///    true if the adjusted base amount should replace the base amount; otherwise, false.
    /// </returns>
    protected boolean useAdjustedBaseAmountForBaseAmount()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSubLedgerJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a Boolean value that indicates whether the current transaction being posted supports the
    ///    <c>SubLedgerDistributions</c> or <c>SubLedgerJournalLines</c>. By default, the base implementation
    ///    is that the transactions do not support sub-ledgers. If the individual transactions support
    ///    sub-ledgers, they will have to override this and return true.
    /// </summary>
    /// <returns>
    ///    true if the current transaction supports sub-ledgers; otherwise, false.
    /// </returns>
    public boolean useSubLedgerJournalLines()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>Tax</c> class should use the <c>TaxUncommitted</c> table.
    /// </summary>
    /// <returns>
    ///    true if the <c>Tax</c> class should use the <c>TaxUncommitted</c> table; otherwise, false.
    /// </returns>
    public boolean useTaxUncommitted()
    {
        if (taxableDocument)
        {
            return taxableDocument.useTaxUncommitted();
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForSourceType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a newly derived <c>TaxPost</c> record based on the transaction.
    /// </summary>
    /// <param name="_sourceType">
    ///    The type of the transaction posting taxes.
    /// </param>
    /// <param name="_initializationClass">
    ///    The initialization class for the specified transaction.
    /// </param>
    /// <param name="_post">
    ///    True if the <c>TaxTrans</c> and <c>Ledger</c> records will be created; false if it will not post.
    /// </param>
    /// <returns>
    ///    The appropriate <c>TaxPost</c> instance based on the calling transaction.
    /// </returns>
    public static TaxPost newForSourceType(TaxSourceType _sourceType, Object _initializationClass, NoYes _post)
    {
        TaxFreeInvoice_Invoice  taxFreeInvoice;
        TaxPurchInvoice         taxPurchInvoice;
        TaxPostJournal          taxPostJournal;
        TrvTaxExpensePost       trvTaxExpensePost;
        TaxPostBankStatement    taxPostBankStatement;

        switch (_sourceType)
        {
            case TaxSourceType::FreeTextInvoice :
                taxFreeInvoice = new TaxFreeInvoice_Invoice(_post, _initializationClass);
                return taxFreeInvoice;

            case TaxSourceType::PurchaseOrder :
                taxPurchInvoice = new TaxPurchInvoice(_post, _initializationClass);
                return taxPurchInvoice;

            case TaxSourceType::Journals :
                taxPostJournal = new TaxPostJournal(_post, _initializationClass);
                return taxPostJournal;

            case TaxSourceType::Expense :
                trvTaxExpensePost = new TrvTaxExpensePost(_post, _initializationClass);
                return trvTaxExpensePost;

            case TaxSourceType::ProjAdvancedJournal :
                TaxPostProjAdvancedJournal taxPostProjAdvancedJournal = new TaxPostProjAdvancedJournal(_post, _initializationClass);
                return taxPostProjAdvancedJournal;

            // <GBR>
            case TaxSourceType::ComplementaryInvoice:
                return new TaxPostComplementaryInvoice(_post, _initializationClass);
            // </GBR>

            case TaxSourceType::BankAccountReconcile:
                taxPostBankStatement = new TaxPostBankStatement(_post, _initializationClass);
                return taxPostBankStatement;
            default:
                var eventHandlerResult = new EventHandlerResult();
                TaxPost::newForSourceTypeDelegate(_sourceType, _initializationClass, _post, eventHandlerResult);

                if (eventHandlerResult.hasResult())
                {
                    return eventHandlerResult.result();
                }

                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForSourceTypeWithTaxCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a new derived <c>TaxPost</c> record that is based on the transaction.
    /// </summary>
    /// <param name="_sourceType">
    ///    The type of the transaction posting taxes.
    /// </param>
    /// <param name="_initializationClass">
    ///    The initialization class for the given transaction.
    /// </param>
    /// <param name="_post">
    ///    A Boolean value that specifies whether the <c>TaxTrans</c> and <c>Ledger</c> entries will be made.
    /// </param>
    /// <param name="_taxCalculation">
    ///    The tax will post using the tax lines in the table that are specified by the <paramref
    ///    name="_taxCalculation" /> parameter.
    /// </param>
    /// <returns>
    ///    The appropriate <c>TaxPost</c> record that is based on the calling transaction.
    /// </returns>
    /// <remarks>
    ///    The instance uses the <c>TaxUncommitted</c> records to post.
    /// </remarks>
    public static TaxPost newForSourceTypeWithTaxCalculation(TaxSourceType _sourceType, Object _initializationClass, NoYes _post, TaxCalculation _taxCalculation)
    {
        TaxFreeInvoice_Invoice  taxFreeInvoice;
        TaxPurchInvoice         taxPurchInvoice;
        TaxPostJournal          taxPostJournal;
        TaxPostBankStatement    taxPostBankStatement;

        switch (_sourceType)
        {
            case TaxSourceType::FreeTextInvoice :
                taxFreeInvoice = new TaxFreeInvoice_Invoice(_post, _initializationClass, _taxCalculation.tmpTaxWorkTrans());
                return taxFreeInvoice;

            case TaxSourceType::PurchaseOrder :
                taxPurchInvoice = new TaxPurchInvoice(_post, _initializationClass, _taxCalculation.tmpTaxWorkTrans());
                return taxPurchInvoice;

            case TaxSourceType::Journals :
                taxPostJournal = new TaxPostJournal(_post, _initializationClass, _taxCalculation.tmpTaxWorkTrans());
                return taxPostJournal;

            // <GBR>
            case TaxSourceType::ComplementaryInvoice:
                return new TaxPostComplementaryInvoice(_post, _initializationClass, _taxCalculation.tmpTaxWorkTrans());
            // </GBR>
            case TaxSourceType::BankAccountReconcile:
                taxPostBankStatement = new TaxPostBankStatement(_post, _initializationClass, _taxCalculation.tmpTaxWorkTrans());
                return taxPostBankStatement;

            case TaxSourceType::ProjAdvancedJournal:
                TaxPostProjAdvancedJournal taxPostProjAdvancedJournal = new TaxPostProjAdvancedJournal(_post, _initializationClass, _taxCalculation.tmpTaxWorkTrans());
                return taxPostProjAdvancedJournal;

            default:
                var eventHandlerResult = new EventHandlerResult();
                TaxPost::newForSourceTypeWithTaxCalculationDelegate(_sourceType, _initializationClass, _post, _taxCalculation, eventHandlerResult);

                if (eventHandlerResult.hasResult())
                {
                    return eventHandlerResult.result();
                }

                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToExpenseAccount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the expense amount for the given tax amount and voucher are created.
    /// </summary>
    /// <param name="_taxUncommitted">
    /// Tax Uncommited buffer is used to post the expense amount.
    /// </param>
    /// <param name="_ledgerVoucherObjectForChargeAsExpense">
    /// LedgerVoucher Object which is used for Posting Expense Account.
    /// </param>
    /// <remarks>
    /// Calculates the expense amount for the given tax amount and voucher are created.
    /// </remarks>
    public static void postToExpenseAccount_IN(
        TaxUncommitted  _taxUncommitted,
        LedgerVoucherObject _ledgerVoucherObjectForChargeAsExpense)
    {
        TaxUncommitted_IN       taxUncommittedINLoc;
        CurrencyExchangeHelper  exchangeRateHelperCopy;

        LedgerJournalTrans      ledgerJournalTransCopy;
        LedgerPostingType       ledgerPostingType;
        LedgerDimensionAccount  purchExpforProductledgerDimension;
        TaxUncommitted          taxUncommittedCopy = _taxUncommitted;
        TaxOnItem               taxOnItem;
        CustomsAmount_IN        customsExpenseAmount; // Expense Amount for each Invoice Line taxes.
        CustomsAmount_IN        customsAmountForCalculation; // Base Tax Amount which is used to Bifurcate.
        CurrencyExchangeRate    billOfEntryExchRate;

        LedgerVoucherTransObject ledgerVoucherTransObject;

        if (_ledgerVoucherObjectForChargeAsExpense)
        {
            _ledgerVoucherObjectForChargeAsExpense.parmTrackTransactionAmountsByCurrency(true);
        }

        ledgerJournalTransCopy = LedgerJournalTrans::findRecId(_taxUncommitted.SourceRecId, false);
        if (ledgerJournalTransCopy)
        {
            ledgerPostingType = LedgerPostingType::LedgerJournal;
        }
        if (ledgerJournalTransCopy)
        {
            if (ledgerJournalTransCopy.AccountType == LedgerJournalACType::Vend)
            {
                switch (ledgerJournalTransCopy.OffsetAccountType)
                {
                    case LedgerJournalACType::Ledger :
                        purchExpforProductledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerJournalTransCopy.OffsetLedgerDimension, ledgerJournalTransCopy.OffsetDefaultDimension);
                        break;

                    case LedgerJournalACType::Project :
                        purchExpforProductledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ProjTrans::newLedgerJournalTrans(ledgerJournalTransCopy).costAccountLedgerDimension(0, false), ledgerJournalTransCopy.OffsetDefaultDimension);
                        break;
                }
            }

            if (ledgerJournalTransCopy.OffsetAccountType == LedgerJournalACType::Vend)
            {
                switch (ledgerJournalTransCopy.AccountType)
                {
                    case LedgerJournalACType::Ledger :
                        purchExpforProductledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerJournalTransCopy.LedgerDimension, ledgerJournalTransCopy.DefaultDimension);
                        break;

                    case LedgerJournalACType::Project :
                        purchExpforProductledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ProjTrans::newLedgerJournalTrans(ledgerJournalTransCopy).costAccountLedgerDimension(0, false), ledgerJournalTransCopy.DefaultDimension);
                        break;
                }
            }

            exchangeRateHelperCopy = CurrencyExchangeHelper::newLedger(Ledger::current());
        }

        select  EximBalanceTaxCorrectedAmountCur,
                EximBalanceTaxAmountCur,
                EximTaxAmountCur,
                EximTaxCorrectedAmountCur,
                EximIncentiveScheme,
                SourceRegulateAmountCustoms,
                CustomsDuty,
                RecId
            from taxUncommittedINLoc
            where taxUncommittedINLoc.TaxUncommitted == taxUncommittedCopy.RecId;

        if (taxUncommittedINLoc.SourceRegulateAmountCustoms || taxUncommittedINLoc.CustomsDuty)
        {
            taxOnItem = TaxOnItem::find(taxUncommittedCopy.TaxItemGroup, taxUncommittedCopy.TaxCode);
            exchangeRateHelperCopy.parmExchangeDate(taxUncommittedCopy.TransDate);

            billOfEntryExchRate = TaxExchangeRateHelper::getCustomsExchangeRate_IN((taxUncommittedCopy.CurrencyCode == CompanyInfoHelper::standardCurrency()) ? taxUncommittedCopy.CurrencyCode : CompanyInfoHelper::standardCurrency(),
                                                            Direction_IN::Import,
                                                            taxUncommittedCopy.TransDate);

            exchangeRateHelperCopy.parmExchangeRate1(billOfEntryExchRate);

            billOfEntryExchRate = TaxExchangeRateHelper::getCustomsExchangeRate_IN(taxUncommittedCopy.SourceCurrencyCode,
                                                            Direction_IN::Import,
                                                            taxUncommittedCopy.TransDate);
            exchangeRateHelperCopy.parmExchangeRate2(billOfEntryExchRate);

            customsAmountForCalculation = taxUncommittedINLoc.SourceRegulateAmountCustoms ? taxUncommittedINLoc.SourceRegulateAmountCustoms : taxUncommittedINLoc.CustomsDuty;

            if (taxOnItem.CustomsChargeAsExpensePercent_IN)
            {
                customsExpenseAmount = customsAmountForCalculation - (customsAmountForCalculation * (100 - taxOnItem.CustomsChargeAsExpensePercent_IN)/ 100);
            }

            if (customsExpenseAmount && _ledgerVoucherObjectForChargeAsExpense)
            {
                customsExpenseAmount = exchangeRateHelperCopy.calculateAccountingToTransaction(taxUncommittedCopy.SourceCurrencyCode, customsExpenseAmount, true);

                // Expence Account posting debit entry
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerVoucherObjectForChargeAsExpense,
                                                                                                LedgerPostingType::Customs_IN,
                                                                                                taxUncommittedCopy.LedgerDimension,
                                                                                                taxUncommittedCopy.SourceCurrencyCode,
                                                                                                customsExpenseAmount,
                                                                                                exchangeRateHelperCopy);
                ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::AsDefault);
                _ledgerVoucherObjectForChargeAsExpense.addTrans(ledgerVoucherTransObject);

                // Purchase expenditure for Product posting credit entry
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerVoucherObjectForChargeAsExpense,
                                                                                                ledgerPostingType,
                                                                                                purchExpforProductledgerDimension,
                                                                                                taxUncommittedCopy.SourceCurrencyCode,
                                                                                                -customsExpenseAmount,
                                                                                                exchangeRateHelperCopy);
                ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::AsDefault);
                _ledgerVoucherObjectForChargeAsExpense.addTrans(ledgerVoucherTransObject);
            }
        }
        if (_ledgerVoucherObjectForChargeAsExpense)
        {
            _ledgerVoucherObjectForChargeAsExpense.parmTrackTransactionAmountsByCurrency(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFixedOffsetTransfer_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Processes transfer to GL of SubLedgerJournalLine related to Fixed Tax Offset Account
    /// </summary>
    /// <param name="_taxTrans">
    ///  tax transaction
    /// </param>
    /// <param name="_transObject">
    ///  LedgerVoucherTransObject
    /// </param>
    /// <returns>
    ///  true, if _transOject reflects fixed offset account, othewize false
    /// </returns>
    /// <remarks>
    ///  If offset account posting detected - adds taxTransaction relationship to _transObject
    /// </remarks>
    public static boolean processFixedOffsetTransfer_RU(TaxTrans _taxTrans, LedgerVoucherTransObject _transObject)
    {
        boolean ret =   _taxTrans.taxTrans_RU().OffsetLedgerDimension_RU &&
                        sign(_taxTrans.TaxBaseAmountCur) != sign(_transObject.parmTransactionCurrencyAmount());
        if (ret)
        {
            _transObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Offset_RU);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>serviceTaxPOTAdvVoucher_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The service tax POT advance voucher information.
    /// </summary>
    /// <param name="_headingTableId">
    /// The heading table id.
    /// </param>
    /// <param name="_headingRecId">
    /// The heading rec id.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate.
    /// </param>
    /// <param name="_exchRateSecond">
    /// The second exchange rate.
    /// </param>
    public static void serviceTaxPOTAdvVoucher_IN(
        TableId  _headingTableId,
        RefRecId _headingRecId,
        ExchRate _exchRate,
        ExchRate _exchRateSecond)
    {
        Sign                            taxSign = 1;
        TaxAmountCur                    advanceSourceTaxAmountCur;
        TaxAmountCur                    advanceSourceBaseAmountCur;
        TaxItemGroupHeading             taxItemGroup;
        TaxUncommitted                  taxUncommitted;
        TaxUncommitted                  taxUncommittedLoc;
        Set                             advanceTmptaxUncommitted = new Set(Types::Int64);
        LedgerJournalTrans              ledgerJournalTrans;
        TaxUncommitted_IN               taxUnCommittedIN;
        RecId                           taxLedgerAccountsetupRecId;
        TaxAccountType_IN               serviceTaxAccountType;
        LedgerDimensionDefaultAccount   defaultAccount;
        TaxTable                        taxTableLoc;

        while select forupdate taxUncommitted
            where taxUncommitted.HeadingTableId   == _headingTableId
                && taxUncommitted.HeadingRecId    == _headingRecId
                && taxUncommitted.TaxOrigin       != TaxOrigin::TaxReversed
                join taxTableLoc
                    where taxTableLoc.TaxCode     == taxUncommitted.TaxCode
                        && taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax
                join taxItemGroup
                    where taxItemGroup.TaxItemGroup        == taxUncommitted.TaxItemGroup
                        && taxItemGroup.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis

        {
            if (taxUncommitted.Source == TaxModuleType::Voucher)
            {
                select firstonly ledgerJournalTrans
                    where ledgerJournalTrans.TableId == taxUncommitted.SourceTableId
                        && ledgerJournalTrans.RecId  == taxUncommitted.SourceRecId;
            }
            if (!advanceTmptaxUncommitted.in(taxUncommitted.RecId))
            {// Newly inserted records are never visited again, else will result in infinite loop.
                [advanceSourceBaseAmountCur, advanceSourceTaxAmountCur] = Tax::getAdvanceAmount_IN(taxUncommitted.TaxCode, _headingTableId, _headingRecId, ledgerJournalTrans, taxUncommitted);
                taxSign = taxUncommitted.SourceRegulateAmountCur < 0 ? -1 : 1;
                if (advanceSourceTaxAmountCur != 0
                    && (abs(advanceSourceTaxAmountCur) - abs(taxUncommitted.SourceRegulateAmountCur) < 0))
                {
                    ttsbegin;
                    taxUncommittedLoc.data(taxUncommitted);
                    if (taxUncommitted.SourceRegulateAmountCur)
                    {
                        taxUncommittedLoc.SourceTaxAmountCur = CurrencyExchangeHelper::amount(taxSign * abs(abs(advanceSourceTaxAmountCur) - abs(taxUncommittedLoc.SourceRegulateAmountCur)), taxUncommittedLoc.SourceCurrencyCode);
                        // By default 'Adjusted amnt = actual amnt' in AX 6.0, if not manually adjusted to different amnt.
                        taxUncommittedLoc.SourceRegulateAmountCur  = taxUncommittedLoc.SourceTaxAmountCur;
                    }

                    if (taxUncommitted.SourceBaseAmountCurRegulated)
                    {
                        taxUncommittedLoc.SourceBaseAmountCur = CurrencyExchangeHelper::amount(taxSign * abs(abs(advanceSourceBaseAmountCur) - abs(taxUncommittedLoc.SourceBaseAmountCurRegulated)), taxUncommittedLoc.SourceCurrencyCode);

                        taxUncommittedLoc.SourceBaseAmountCurRegulated = 0;
                    }

                    if (taxUncommittedLoc.SourceCurrencyCode == Ledger::accountingCurrency())
                    {
                        taxUncommittedLoc.TaxAmount     = taxUncommittedLoc.SourceTaxAmountCur;
                        taxUncommittedLoc.TaxBaseAmount = taxUncommittedLoc.SourceBaseAmountCur;
                    }
                    else
                    {
                        taxUncommittedLoc.TaxAmount = CurrencyExchangeHelper::mstAmount(taxUncommittedLoc.SourceRegulateAmountCur, taxUncommittedLoc.SourceCurrencyCode, taxUncommittedLoc.TransDate, taxUncommittedLoc.euroTriangulation ? UnknownNoYes::Unknown : UnknownNoYes::No, _exchRate, _exchRateSecond);
                        taxUncommittedLoc.TaxBaseAmount = CurrencyExchangeHelper::mstAmount(taxUncommittedLoc.SourceBaseAmountCur, taxUncommittedLoc.SourceCurrencyCode, taxUncommittedLoc.TransDate, taxUncommittedLoc.euroTriangulation ? UnknownNoYes::Unknown : UnknownNoYes::No, _exchRate, _exchRateSecond);
                    }

                    if (taxUncommitted.TaxDirection == TaxDirection::OutgoingTax)
                    {
                        serviceTaxAccountType = TaxAccountType_IN::ServiceTaxPayableAccount;
                    }
                    else if (taxUncommitted.TaxDirection == TaxDirection::IncomingTax)
                    {
                        serviceTaxAccountType =  TaxAccountType_IN::ServiceTaxRecoverableAccount;
                    }

                    taxUnCommittedIN = TaxUncommitted_IN::findByTaxUncommitted(taxUncommitted.RecId);

                    taxUncommittedLoc.SourceTaxAmountCurReal = taxUncommittedLoc.SourceTaxAmountCur;
                    taxUncommittedLoc.TaxAmountCur           = taxUncommittedLoc.SourceTaxAmountCur;

                    taxLedgerAccountsetupRecId = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTableLoc.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All, taxUnCommittedIN.TaxRegistrationNumberTable_IN).RecId;
                    defaultAccount             = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId, serviceTaxAccountType, taxTableLoc.TaxComponentTable_IN);

                    taxUncommittedLoc.LedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount);

                    taxUncommittedLoc.insert();
                    advanceTmptaxUncommitted.add(taxUncommittedLoc.RecId);
                    // After creating the entry to post to ServiceTaxPayable A/C, modify the amount to be posted to InterimPayableA/C, to nullify the same
                    // w.r.t the advance payment entry made during payment.
                    taxUncommitted.SourceBaseAmountCur       = advanceSourceBaseAmountCur;
                    taxUncommitted.SourceTaxAmountCur        = advanceSourceTaxAmountCur;
                    taxUncommitted.SourceTaxAmountCurReal    = taxUncommitted.SourceTaxAmountCur;
                    taxUncommitted.SourceRegulateAmountCur   = taxUncommitted.SourceTaxAmountCur;
                    taxUncommitted.TaxAmountCur              = advanceSourceTaxAmountCur;

                    if (taxUncommitted.SourceCurrencyCode == Ledger::accountingCurrency())
                    {
                        taxUncommitted.TaxAmount     = taxUncommittedLoc.SourceTaxAmountCur;
                        taxUncommitted.TaxBaseAmount = taxUncommittedLoc.SourceBaseAmountCur;
                    }
                    else
                    {
                        taxUncommitted.TaxAmount = CurrencyExchangeHelper::mstAmount(taxUncommittedLoc.SourceRegulateAmountCur, taxUncommittedLoc.SourceCurrencyCode, taxUncommittedLoc.TransDate, taxUncommittedLoc.euroTriangulation ? UnknownNoYes::Unknown : UnknownNoYes::No, _exchRate, _exchRateSecond);
                        taxUncommitted.TaxBaseAmount = CurrencyExchangeHelper::mstAmount(taxUncommittedLoc.SourceBaseAmountCur, taxUncommittedLoc.SourceCurrencyCode, taxUncommittedLoc.TransDate, taxUncommittedLoc.euroTriangulation ? UnknownNoYes::Unknown : UnknownNoYes::No, _exchRate, _exchRateSecond);
                    }
                    taxUncommitted.update();
                    ttscommit;
                }
            }
        }// End
    }

]]></Source>
			</Method>
			<Method>
				<Name>serviceTaxReverseChargeVoucher_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The service tax POT Reverse charge TaxUncommitted and taxTrans entries for PO side.
    /// </summary>
    /// <param name="_headingTableId">
    /// The heading table id.
    /// </param>
    /// <param name="_headingRecId">
    /// The heading rec id.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate.
    /// </param>
    /// <param name="_exchRateSecond">
    /// The second exchange rate.
    /// </param>
    public static void serviceTaxReverseChargeVoucher_IN(
        TableId  _headingTableId,
        RefRecId _headingRecId,
        ExchRate _exchRate,
        ExchRate _exchRateSecond)
    {
        TaxItemGroupHeading             taxItemGroup;
        TaxUncommitted                  taxUncommitted;
        TaxUncommitted                  taxUncommittedInterim;
        TaxUncommitted                  taxUncommittedOrig;
        Set                             advanceTmpTaxUncommitted = new Set(Types::Int64);
        TaxUncommitted_IN               taxUncommittedIN;
        TaxTable                        taxTableLoc;

        while select forupdate taxUncommitted
            where taxUncommitted.HeadingTableId   == _headingTableId
                && taxUncommitted.HeadingRecId    == _headingRecId
                && taxUncommitted.TaxOrigin       != TaxOrigin::TaxReversed
                join taxTableLoc
                    where taxTableLoc.TaxCode     == taxUncommitted.TaxCode
                        && taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax
                join taxItemGroup
                    where taxItemGroup.TaxItemGroup        == taxUncommitted.TaxItemGroup
                        && taxItemGroup.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis
                        && taxItemGroup.ReverseChargePercentage_IN > 0
        {
            if (!advanceTmpTaxUncommitted.in(taxUncommitted.RecId))
            {// Newly inserted records are never visited again, else will result in infinite loop.
                ttsbegin;
                taxUncommittedInterim.data(taxUncommitted);
                taxUncommittedOrig.data(taxUncommitted);

                if (taxUncommitted.SourceRegulateAmountCur)
                {
                    taxUncommitted.SourceTaxAmountCur             = CurrencyExchangeHelper::amount(taxUncommittedOrig.SourceTaxAmountCur * (100 - taxItemGroup.ReverseChargePercentage_IN) / 100);
                    // By default 'Adjusted amnt = actual amnt' in AX 6.0, if not manually adjusted to different amnt.
                    taxUncommitted.SourceRegulateAmountCur        = CurrencyExchangeHelper::amount(taxUncommittedOrig.SourceRegulateAmountCur * (100 - taxItemGroup.ReverseChargePercentage_IN) / 100);
                    taxUncommitted.TaxAmountCur                   = CurrencyExchangeHelper::amount(taxUncommittedOrig.TaxAmountCur * (100 - taxItemGroup.ReverseChargePercentage_IN) / 100);
                    taxUncommitted.TaxAmount                      = CurrencyExchangeHelper::amount(taxUncommittedOrig.TaxAmount * (100 - taxItemGroup.ReverseChargePercentage_IN) / 100);
                    taxUncommitted.TaxInCostPrice                 = CurrencyExchangeHelper::amount(taxUncommittedOrig.TaxInCostPrice * (100 - taxItemGroup.ReverseChargePercentage_IN) / 100);
                    taxUncommitted.TaxInCostPriceCur              = CurrencyExchangeHelper::amount(taxUncommittedOrig.TaxInCostPriceCur * (100 - taxItemGroup.ReverseChargePercentage_IN) / 100);
                    taxUncommitted.TaxInCostPriceMST              = CurrencyExchangeHelper::amount(taxUncommittedOrig.TaxInCostPriceMST * (100 - taxItemGroup.ReverseChargePercentage_IN) / 100);
                    taxUncommitted.TaxInCostPriceRegulated        = CurrencyExchangeHelper::amount(taxUncommittedOrig.TaxInCostPriceRegulated * (100 - taxItemGroup.ReverseChargePercentage_IN) / 100);

                    taxUncommittedInterim.SourceRegulateAmountCur = taxUncommittedOrig.SourceRegulateAmountCur - taxUncommitted.SourceRegulateAmountCur;
                    taxUncommittedInterim.SourceTaxAmountCur      = taxUncommittedOrig.SourceTaxAmountCur - taxUncommitted.SourceTaxAmountCur;
                    taxUncommittedInterim.TaxAmountCur            = taxUncommittedOrig.TaxAmountCur - taxUncommitted.TaxAmountCur;
                    taxUncommittedInterim.TaxAmount               = taxUncommittedOrig.TaxAmount - taxUncommitted.TaxAmount;
                    taxUncommittedInterim.TaxInCostPrice          = taxUncommittedOrig.TaxInCostPrice - taxUncommitted.TaxInCostPrice;
                    taxUncommittedInterim.TaxInCostPriceCur       = taxUncommittedOrig.TaxInCostPriceCur - taxUncommitted.TaxInCostPriceCur;
                    taxUncommittedInterim.TaxInCostPriceMST       = taxUncommittedOrig.TaxInCostPriceMST - taxUncommitted.TaxInCostPriceMST;
                    taxUncommittedInterim.TaxInCostPriceRegulated = taxUncommittedOrig.TaxInCostPriceRegulated - taxUncommitted.TaxInCostPriceRegulated;
                }

                taxUncommittedInterim.LedgerDimension             = taxUncommitted.LedgerDimensionRev_IN;
                taxUncommittedInterim.LedgerDimension_IN          = taxUncommitted.LedgerDimension_IN;
                taxUncommittedInterim.LedgerDimensionRev_IN       = 0;
                if (taxItemGroup.ReverseChargePercentage_IN != 100)
                {
                    // IR & IP uses below Accounts. Its generated using "taxUncommittedInterim" buffer. So we need to blank out them for Recoverable buffer.
                    taxUncommitted.LedgerDimension_IN                 = 0;
                    taxUncommitted.LedgerDimensionRev_IN              = 0;
                    taxUncommittedInterim.insert();

                    // Populate extension table TaxUncommitted_IN.
                    taxUnCommittedIN.data(TaxUncommitted_IN::findByTaxUncommitted(taxUncommitted.RecId));
                    taxUnCommittedIN.TaxUncommitted = taxUncommittedInterim.RecId;
                    taxUnCommittedIN.insert();
                    advanceTmpTaxUncommitted.add(taxUncommittedInterim.RecId);
                }
                else
                {
                    taxUncommitted.data(taxUncommittedInterim);
                }
                taxUncommitted.update();
                ttscommit;
            }
        }// End
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>