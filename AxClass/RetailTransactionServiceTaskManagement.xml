<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailTransactionServiceTaskManagement</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Runtime.DataModel;
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

/// <summary>
/// The <c>RetailTransactionServiceTaskManagement</c> implements the task management related methods of the service interface exposed by the <c>RetailTransactionService</c> class to the retail channels.
/// </summary>
internal class RetailTransactionServiceTaskManagement
{
    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getChecklists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the checklists.
    /// </summary>
    /// <param name="_checklistSearchCriteriaJson">
    /// The JSON string of the ChecklistSearchCriteria.
    /// </param>
    /// <param name="_queryResultSettingsJson">
    /// The JSON string of the QueryResultSettings.
    /// </param>
    /// <returns>
    /// A container with 3 elements. The 3rd element is the serialized JSON string of an array of Microsoft.Dynamics.Commerce.Runtime.DataModel.Checklist.
    /// </returns>
    internal static container getChecklists(str _checklistSearchCriteriaJson, str _queryResultSettingsJson)
    {
        container                                   checklistIds;
        container                                   statuses;
        QueryResultSettings                         queryResultSettings;
        RetailChannelRecId                          channelId;
        HcmPersonnelNumberId                        personnelNumber;
        RetailBusinessProcessWorkerRecId            workerId;
        RetailStoreTable                            store;
        HcmWorker                                   worker;
        Microsoft.Dynamics.Ax.Xpp.ErrorException    xppEx;
        System.Exception                            netEx;

        container checklistsResult = [true,''];

        // Parse parameters
        try
        {
            ChecklistSearchCriteria searchCriteria = RetailTransactionServiceJsonHelper::DeserializeChecklistSearchCriteriaFromJSON(_checklistSearchCriteriaJson);
            queryResultSettings = RetailTransactionServiceJsonHelper::DeserializeQueryResultSettingsFromJSON(_queryResultSettingsJson);

            System.Nullable<int64> nullableChannelId = searchCriteria.ChannelId;
            if (nullableChannelId.get_HasValue())
            {
                channelId = nullableChannelId.get_Value();
            }

            personnelNumber = searchCriteria.PersonnelNumber;

            if (searchCriteria.statuses != null)
            {
                System.Collections.IEnumerator statusesEnumerator = searchCriteria.statuses.GetEnumerator();
                while (statusesEnumerator.MoveNext())
                {
                    ChecklistStatus status = statusesEnumerator.get_Current();
                    statuses += RetailTransactionServiceTaskManagement::dotnetChecklistStatus2XppChecklistStatus(status);
                }
            }

            if (searchCriteria.ChecklistIds != null)
            {
                System.Collections.IEnumerator checklistIdsEnumerator = searchCriteria.ChecklistIds.GetEnumerator();
                while (checklistIdsEnumerator.MoveNext())
                {
                    str checklistId = checklistIdsEnumerator.get_Current();
                    checklistIds += checklistId;
                }
            }
        }
        catch (xppEx)
        {
            str errorMessage = xppEx.ToString();
            eventSource.EventWriteGetChecklistsParameterError(_queryResultSettingsJson, errorMessage);
            checklistsResult = [false, "@RET2382"];
            return checklistsResult;
        }
        catch (netEx)
        {
            str errorMessage = netEx.ToString();
            eventSource.EventWriteGetChecklistsParameterError(_queryResultSettingsJson, errorMessage);
            checklistsResult = [false, "@RET2382"];
            return checklistsResult;
        }

        // If there is any checklist id, use result of getChecklistsByIds instead, try-catch are already done in it
        if (conLen(checklistIds) > 0)
        {
            return RetailTransactionServiceTaskManagement::getChecklistsByIds(checklistIds);
        }

        // Validate parameters
        try
        {
            store = RetailStoreTable::findRecId(channelId);
            worker = HcmWorker::findByPersonnelNumber(personnelNumber);
            workerId = worker.RecId;

            eventSource.EventWriteGetChecklistsStart(channelId, workerId, con2Str(statuses), queryResultSettings.Paging.Skip, queryResultSettings.Paging.Top);

            if (store.RecId == 0)
            {
                eventSource.EventWriteGetChecklistsParameterError(_queryResultSettingsJson, "@RetailTaskManagement:RetailTaskManagementChannelNotFound");
                return [false, "@RetailTaskManagement:RetailTaskManagementChannelNotFound"];
            }
            if (workerId == 0)
            {
                eventSource.EventWriteGetChecklistsParameterError(_queryResultSettingsJson, "@RetailTaskManagement:RetailTaskManagementWorkerNotFound");
                return [false, "@RetailTaskManagement:RetailTaskManagementWorkerNotFound"];
            }
        }
        catch (xppEx)
        {
            str errorMessage = xppEx.ToString();
            eventSource.EventWriteGetChecklistsError(channelId, workerId, con2Str(statuses), queryResultSettings.Paging.Skip, queryResultSettings.Paging.Top, errorMessage);
            checklistsResult = [false, "@RET2382"];
            return checklistsResult;
        }
        catch (netEx)
        {
            str errorMessage = netEx.ToString();
            eventSource.EventWriteGetChecklistsError(channelId, workerId, con2Str(statuses), queryResultSettings.Paging.Skip, queryResultSettings.Paging.Top, errorMessage);
            checklistsResult = [false, "@RET2382"];
            return checklistsResult;
        }

        // Core logic
        try
        {

            System.Collections.ArrayList checklistList = new System.Collections.ArrayList();
            BusinessProcessHeader checklistTable;
            Checklist checklist;

            Query checklistQuery = new Query();
            QueryBuildDataSource qbds= RetailTransactionServiceTaskManagement::addChecklistDataSource(checklistQuery, channelId, workerId, statuses, true, true);
            // Order by
            System.Collections.IEnumerable sortColumns = queryResultSettings.Sorting.get_Columns();
            int sortColumnsCount = queryResultSettings.Sorting.get_Count();
            boolean targetDateTimeSorted = false;
            System.Collections.IEnumerator sortColumnEnumerator = sortColumns.GetEnumerator();
            while (sortColumnEnumerator.MoveNext())
            {
                SortColumn sortColumn = sortColumnEnumerator.get_Current();
                str name = sortColumn.get_ColumnName();
                boolean isDescending = sortColumn.get_IsDescending();
                SortOrder sortOrder = isDescending ? SortOrder::Descending : SortOrder::Ascending;
                switch (name)
                {
                    case 'Status':
                        qbds.addOrderByField(fieldNum(BusinessProcessHeader, Status), sortOrder);
                        break;
                    case 'TargetDateTime':
                        qbds.addOrderByField(fieldNum(BusinessProcessHeader, TargetDate), sortOrder);
                        targetDateTimeSorted = true;
                        break;
                }
            }
            // Order by TargetDate and RecId at last, to ensure the consistency of the sequence
            if (!targetDateTimeSorted)
            {
                qbds.addOrderByField(fieldNum(BusinessProcessHeader, TargetDate));
            }

            qbds.addOrderByField(fieldNum(BusinessProcessHeader, RecId));

            QueryRun checklistQueryRun = RetailTransactionServiceTaskManagement::getQueryRunWithPaging(checklistQuery, queryResultSettings.Paging);

            Map checklistMap = new Map(Types::Int64, Types::AnyType);

            while (checklistQueryRun.next())
            {
                checklistTable = checklistQueryRun.get(tableNum(BusinessProcessHeader));
                checklist = RetailTransactionServiceTaskManagement::createChecklistFromChecklistTable(checklistTable);
                checklistList.Add(checklist);
                checklistMap.insert(checklistTable.RecId, checklist);
            }

            // Get the tasks of the checklists
            int taskCount = RetailTransactionServiceTaskManagement::fillChecklistTasks(checklistMap);

            eventSource.EventWriteGetChecklistsStop(channelId, workerId, con2Str(statuses), queryResultSettings.Paging.Skip, queryResultSettings.Paging.Top, checklistList.get_Count(), taskCount);

            // Serialize
            System.Type[] typeArray = new System.Type[1]();
            System.Type checklistType = new Checklist().GetType();
            typeArray.SetValue(checklistType, 0);
            checklistsResult += RetailTransactionServiceJsonHelper::SerializeToJson(checklistList, typeArray);

            return checklistsResult;
        }
        catch (xppEx)
        {
            str errorMessage = xppEx.ToString();
            eventSource.EventWriteGetChecklistsError(channelId, workerId, con2Str(statuses), queryResultSettings.Paging.Skip, queryResultSettings.Paging.Top, errorMessage);
            checklistsResult = [false, "@RET2382"];
            return checklistsResult;
        }
        catch (netEx)
        {
            str errorMessage = netEx.ToString();
            eventSource.EventWriteGetChecklistsError(channelId, workerId, con2Str(statuses), queryResultSettings.Paging.Skip, queryResultSettings.Paging.Top, errorMessage);
            checklistsResult = [false, "@RET2382"];
            return checklistsResult;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateChecklists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the checklists.
    /// </summary>
    /// <param name="_checklistListJson">
    /// The JSON string of an array of Microsoft.Dynamics.Commerce.Runtime.DataModel.Checklist.
    /// </param>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker who did the operation.
    /// </param>
    /// <returns>
    /// A container with 3 elements. The 3rd element is the serialized JSON string of an array of Microsoft.Dynamics.Commerce.Runtime.DataModel.Checklist.
    /// </returns>
    internal static container updateChecklists(str _checklistListJson, HcmPersonnelNumberId _personnelNumber)
    {
        System.Collections.ArrayList                requestChecklistList;
        str                                         errorMessage;
        Microsoft.Dynamics.Ax.Xpp.ErrorException    xppEx;
        System.Exception                            netEx;
        HcmWorker                                   hcmWorker;
        RetailBusinessProcessWorkerRecId            workerId;

        // Parse parameters
        try
        {
            hcmWorker = HcmWorker::findByPersonnelNumber(_personnelNumber);
            if (hcmWorker.RecId == 0)
            {
                return [false, "@RetailTaskManagement:RetailTaskManagementWorkerNotFound"];
            }
            workerId = hcmWorker.RecId;
            requestChecklistList = RetailTransactionServiceJsonHelper::DeserializeChecklistListFromJSON(_checklistListJson);
        }
        catch (xppEx)
        {
            errorMessage = xppEx.ToString();
            eventSource.EventWriteUpdateChecklistsParameterError(hcmWorker.RecId, errorMessage);
            return [false, "@RET2382"];
        }
        catch (netEx)
        {
            errorMessage = netEx.ToString();
            eventSource.EventWriteUpdateChecklistsParameterError(hcmWorker.RecId, errorMessage);
            return [false, "@RET2382"];
        }

        // Core logic
        int checklistCount;
        try
        {
            checklistCount = requestChecklistList.get_Count();
            eventSource.EventWriteUpdateChecklistsStart(hcmWorker.RecId, checklistCount);
            BusinessProcessTask taskTable;
            System.Collections.ArrayList responseChecklistList = new System.Collections.ArrayList();

            // Update
            ttsbegin;
            Map checklistMap = new Map(Types::Int64, Types::AnyType);
            System.Collections.IEnumerator checklistEnumerator = requestChecklistList.GetEnumerator();
            while (checklistEnumerator.MoveNext())
            {
                Checklist checklist = checklistEnumerator.get_Current();
                BusinessProcessHeader checklistTable;
                select forupdate checklistTable where checklistTable.ProcessId == str2Guid(checklist.ProcessId);

                // Validations for known issues
                if (checklistTable.RecId == 0)
                {
                    errorMessage = "@RetailTaskManagement:RetailTaskManagementChecklistNotFound";
                    break;
                }
                if (checklistTable.RecVersion != str2Int(checklist.Version))
                {
                    errorMessage = "@RetailTaskManagement:RetailTaskManagementChecklistVersionMismatch";
                    break;
                }
                if (checklistTable.HcmWorker != workerId)
                {
                    if (!RetailTransactionServiceTaskManagement::hasAllowTaskManagementPermission(workerId))
                    {
                        errorMessage = "@RetailTaskManagement:RetailTaskManagementChecklistNotAllowedToUpdate";
                        break;
                    }
                }

                // Set the properties in DB
                boolean isNewChecklist = false;
                RetailTransactionServiceTaskManagement::setChecklistProperties(checklistTable, checklist, workerId, isNewChecklist);

                // Generate the response payload
                Checklist responseChecklist = RetailTransactionServiceTaskManagement::createChecklistFromChecklistTable(checklistTable);
                responseChecklistList.Add(responseChecklist);
                checklistMap.insert(checklistTable.RecId, responseChecklist);
            }

            // Abort and return the error message if it's known issue
            if (errorMessage != '')
            {
                ttsabort;
                eventSource.EventWriteUpdateChecklistsError(hcmWorker.RecId, checklistCount, errorMessage);
                return [false, errorMessage];
            }

            // Get the tasks of the checklists and commit if no issues found
            int taskCount = RetailTransactionServiceTaskManagement::fillChecklistTasks(checklistMap);
            ttscommit;

            // Serialize
            System.Type[] typeArray = new System.Type[1]();
            System.Type checklistType = new Checklist().GetType();
            typeArray.SetValue(checklistType, 0);
            str serializedJson = RetailTransactionServiceJsonHelper::SerializeToJson(responseChecklistList, typeArray);

            eventSource.EventWriteUpdateChecklistsStop(hcmWorker.RecId, checklistCount, taskCount);

            return [true, '', serializedJson];
        }
        catch (xppEx)
        {
            errorMessage = xppEx.ToString();
            eventSource.EventWriteUpdateChecklistsError(hcmWorker.RecId, checklistCount, errorMessage);
            return [false, "@RET2382"];
        }
        catch (netEx)
        {
            errorMessage = netEx.ToString();
            eventSource.EventWriteUpdateChecklistsError(hcmWorker.RecId, checklistCount, errorMessage);
            return [false, "@RET2382"];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tasks.
    /// </summary>
    /// <param name="_taskSearchCriteriaJson">
    /// The JSON string of the TaskSearchCriteria.
    /// </param>
    /// <param name="_queryResultSettingsJson">
    /// The JSON string of the QueryResultSettings.
    /// </param>
    /// <returns>
    /// A container with 3 elements. The 3rd element is the serialized JSON string of an array of Microsoft.Dynamics.Commerce.Runtime.DataModel.ChecklistTask.
    /// </returns>
    internal static container getTasks(str _taskSearchCriteriaJson, str _queryResultSettingsJson)
    {
        container                                   taskIds;
        container                                   statuses;
        boolean                                     isMyTasks;
        boolean                                     isDueTasks;
        boolean                                     isAllTasks;
        QueryResultSettings                         queryResultSettings;
        RetailChannelRecId                          channelId;
        HcmPersonnelNumberId                        personnelNumber;
        RetailBusinessProcessWorkerRecId            workerId;
        RetailStoreTable                            store;
        HcmWorker                                   worker;
        Microsoft.Dynamics.Ax.Xpp.ErrorException    xppEx;
        System.Exception                            netEx;

        container tasksResult = [true,''];

        // Parse parameters
        try
        {
            TaskSearchCriteria searchCriteria = RetailTransactionServiceJsonHelper::DeserializeTaskSearchCriteriaFromJSON(_taskSearchCriteriaJson);
            queryResultSettings = RetailTransactionServiceJsonHelper::DeserializeQueryResultSettingsFromJSON(_queryResultSettingsJson);
            personnelNumber = searchCriteria.PersonnelNumber;
            isMyTasks = searchCriteria.FilterMyTasks;
            isDueTasks = searchCriteria.FilterOverdueTasks;
            isAllTasks = !isMyTasks && !isDueTasks;

            System.Nullable<int64> nullableChannelId = searchCriteria.ChannelId;
            if (nullableChannelId.get_HasValue())
            {
                channelId = nullableChannelId.get_Value();
            }

            if (searchCriteria.Statuses != null)
            {
                System.Collections.IEnumerator statusesEnumerator = searchCriteria.Statuses.GetEnumerator();
                while (statusesEnumerator.MoveNext())
                {
                    ChecklistTaskStatus status = statusesEnumerator.get_Current();
                    statuses += RetailTransactionServiceTaskManagement::dotnetTaskStatus2XppTaskStatus(status);
                }
            }

            if (searchCriteria.TaskIds != null)
            {
                System.Collections.IEnumerator taskIdsEnumerator = searchCriteria.TaskIds.GetEnumerator();
                while (taskIdsEnumerator.MoveNext())
                {
                    str taskId = taskIdsEnumerator.get_Current();
                    taskIds += taskId;
                }
            }
        }
        catch (xppEx)
        {
            str errorMessage = xppEx.ToString();
            eventSource.EventWriteGetTasksParameterError(_queryResultSettingsJson, errorMessage);
            tasksResult = [false, "@RET2382"];
            return tasksResult;
        }
        catch (netEx)
        {
            str errorMessage = netEx.ToString();
            eventSource.EventWriteGetTasksParameterError(_queryResultSettingsJson, errorMessage);
            tasksResult = [false, "@RET2382"];
            return tasksResult;
        }

        // If there is any task ID, use result of getTasksByIds instead, try-catch are already done in it
        if (conLen(taskIds) > 0)
        {
            return RetailTransactionServiceTaskManagement::getTasksByIds(taskids);
        }

        // Validate parameters
        try
        {
            store = RetailStoreTable::findRecId(channelId);
            worker = HcmWorker::findByPersonnelNumber(personnelNumber);
            workerId = worker.RecId;

            eventSource.EventWriteGetTasksStart(channelId, workerId, con2Str(statuses), isMyTasks, isDueTasks, isAllTasks, queryResultSettings.Paging.Skip, queryResultSettings.Paging.Top);

            if (store.RecId == 0)
            {
                eventSource.EventWriteGetTasksParameterError(_queryResultSettingsJson, "@RetailTaskManagement:RetailTaskManagementChannelNotFound");
                return [false, "@RetailTaskManagement:RetailTaskManagementChannelNotFound"];
            }
            if (workerId == 0)
            {
                eventSource.EventWriteGetTasksParameterError(_queryResultSettingsJson, "@RetailTaskManagement:RetailTaskManagementWorkerNotFound");
                return [false, "@RetailTaskManagement:RetailTaskManagementWorkerNotFound"];
            }
        }
        catch (xppEx)
        {
            str errorMessage = xppEx.ToString();
            eventSource.EventWriteGetTasksError(channelId, workerId, con2Str(statuses), isMyTasks, isDueTasks, isAllTasks, queryResultSettings.Paging.Skip, queryResultSettings.Paging.Top, errorMessage);
            tasksResult = [false, "@RET2382"];
            return tasksResult;
        }
        catch (netEx)
        {
            str errorMessage = netEx.ToString();
            eventSource.EventWriteGetTasksError(channelId, workerId, con2Str(statuses), isMyTasks, isDueTasks, isAllTasks, queryResultSettings.Paging.Skip, queryResultSettings.Paging.Top, errorMessage);
            tasksResult = [false, "@RET2382"];
            return tasksResult;
        }

        // Core logic
        try
        {
            System.Collections.ArrayList checklistTaskList = new System.Collections.ArrayList();

            BusinessProcessHeader checklistTable;
            BusinessProcessTask taskTable;
            HcmWorker assignedToHcmWorker;

            Query query = RetailTransactionServiceTaskManagement::getBaseTaskQuery(statuses, isMyTasks, isDueTasks, worker.RecId, store.RecId, false);
            RetailTransactionServiceTaskManagement::addOrderByToBaseTaskQuery(query, queryResultSettings);
            QueryRun qr = RetailTransactionServiceTaskManagement::getQueryRunWithPaging(query, queryResultSettings.Paging);

            while (qr.next())
            {
                checklistTable = qr.get(tableNum(BusinessProcessHeader));
                taskTable = qr.get(tableNum(BusinessProcessTask));
                assignedToHcmWorker = qr.get(tableNum(HcmWorker));
                checklistTaskList.Add(RetailTransactionServiceTaskManagement::createChecklistTaskFromTables(
                    checklistTable,
                    taskTable,
                    assignedToHcmWorker
                    ));
            }

            eventSource.EventWriteGetTasksStop(channelId, workerId, con2Str(statuses), isMyTasks, isDueTasks, isAllTasks, queryResultSettings.Paging.Skip, queryResultSettings.Paging.Top, ChecklistTaskList.get_Count());

            // Serialize
            System.Type[] typeArray = new System.Type[1]();
            System.Type checklistTaskType = new ChecklistTask().GetType();
            typeArray.SetValue(checklistTaskType, 0);
            tasksResult += RetailTransactionServiceJsonHelper::SerializeToJson(checklistTaskList, typeArray);

            return tasksResult;
        }
        catch (xppEx)
        {
            str errorMessage = xppEx.ToString();
            eventSource.EventWriteGetTasksError(channelId, workerId, con2Str(statuses), isMyTasks, isDueTasks, isAllTasks, queryResultSettings.Paging.Skip, queryResultSettings.Paging.Top, errorMessage);
            tasksResult = [false, "@RET2382"];
            return tasksResult;
        }
        catch (netEx)
        {
            str errorMessage = netEx.ToString();
            eventSource.EventWriteGetTasksError(channelId, workerId, con2Str(statuses), isMyTasks, isDueTasks, isAllTasks, queryResultSettings.Paging.Skip, queryResultSettings.Paging.Top, errorMessage);
            tasksResult = [false, "@RET2382"];
            return tasksResult;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the tasks.
    /// </summary>
    /// <param name="_checklistTaskListJson">
    /// The JSON string of an array of Microsoft.Dynamics.Commerce.Runtime.DataModel.ChecklistTask.
    /// </param>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker who did the operation.
    /// </param>
    /// <returns>
    /// A container with 3 elements. The 3rd element is the serialized JSON string of an array of Microsoft.Dynamics.Commerce.Runtime.DataModel.ChecklistTask.
    /// </returns>
    internal static container updateTasks(str _checklistTaskListJson, HcmPersonnelNumberId _personnelNumber)
    {
        System.Collections.ArrayList                requestChecklistTaskList;
        str                                         errorMessage;
        Microsoft.Dynamics.Ax.Xpp.ErrorException    xppEx;
        System.Exception                            netEx;
        HcmWorker                                   hcmWorker;
        RetailBusinessProcessWorkerRecId            workerId;

        // Parse parameters
        try
        {
            hcmWorker = HcmWorker::findByPersonnelNumber(_personnelNumber);
            if (hcmWorker.RecId == 0)
            {
                return [false, "@RetailTaskManagement:RetailTaskManagementWorkerNotFound"];
            }
            workerId = hcmWorker.RecId;
            requestChecklistTaskList = RetailTransactionServiceJsonHelper::DeserializeChecklistTaskListFromJSON(_checklistTaskListJson);
        }
        catch (xppEx)
        {
            errorMessage = xppEx.ToString();
            eventSource.EventWriteUpdateTasksParameterError(hcmWorker.RecId, errorMessage);
            return [false, "@RET2382"];
        }
        catch (netEx)
        {
            errorMessage = netEx.ToString();
            eventSource.EventWriteUpdateTasksParameterError(hcmWorker.RecId, errorMessage);
            return [false, "@RET2382"];
        }

        int taskCount;

        // Core logic
        try
        {
            taskCount = requestChecklistTaskList.get_Count();
            eventSource.EventWriteUpdateTasksStart(hcmWorker.RecId, taskCount);
            BusinessProcessHeader checklistTable;
            System.Collections.ArrayList responseChecklistTaskList = new System.Collections.ArrayList();

            // Update
            ttsbegin;
            System.Collections.IEnumerator taskEnumerator = requestChecklistTaskList.GetEnumerator();
            while (taskEnumerator.MoveNext())
            {
                ChecklistTask checklistTask = taskEnumerator.get_Current();
                BusinessProcessTask taskTable;
                select forupdate taskTable where taskTable.TaskId == str2Guid(checklistTask.Id);

                // Validations for known issues
                if (taskTable.RecId == 0)
                {
                    errorMessage = "@RetailTaskManagement:RetailTaskManagementTaskNotFound";
                    break;
                }
                if (taskTable.RecVersion != str2Int(checklistTask.Version))
                {
                    errorMessage = "@RetailTaskManagement:RetailTaskManagementTaskVersionMismatch";
                    break;
                }

                if (checklistTask.DeepLinkTypeValue == any2Int(ChecklistTaskDeepLinkType::CustomerAccount))
                {
                    CustTable customer = CustTable::find(ChecklistTask.DeepLink);
                    if (customer.RecId == 0)
                    {
                        errorMessage = "@RetailTaskManagement:RetailTaskManagementCustomerNotFound";
                        break;
                    }
                }

                // Set the properties in DB
                boolean isNewTask = false;
                RetailTransactionServiceTaskManagement::setTaskProperties(taskTable, checklistTask, workerId, isNewTask, 0);

                // Generate the response payload
                checklistTable = BusinessProcessHeader::find(taskTable.ProcessHeader);
                select firstonly hcmWorker where hcmWorker.RecId == taskTable.AssignedWorker;
                responseChecklistTaskList.Add(RetailTransactionServiceTaskManagement::createChecklistTaskFromTables(
                        checklistTable,
                        taskTable,
                        hcmWorker
                        ));
            }

            if (errorMessage != '')
            {
                // Abort and return the error message if it's known issue
                ttsabort;
                eventSource.EventWriteUpdateTasksError(hcmWorker.RecId, taskCount, errorMessage);
                return [false, errorMessage];
            }

            // Commit if no issues found
            ttscommit;

            // Serialize
            System.Type[] typeArray = new System.Type[1]();
            System.Type checklistTaskType = new ChecklistTask().GetType();
            typeArray.SetValue(checklistTaskType, 0);
            str serializedJson = RetailTransactionServiceJsonHelper::SerializeToJson(responseChecklistTaskList, typeArray);

            eventSource.EventWriteUpdateTasksStop(hcmWorker.RecId, taskCount);

            return [true, '', serializedJson];
        }
        catch (xppEx)
        {
            errorMessage = xppEx.ToString();
            eventSource.EventWriteUpdateTasksError(hcmWorker.RecId, taskCount, errorMessage);
            return [false, "@RET2382"];
        }
        catch (netEx)
        {
            errorMessage = netEx.ToString();
            eventSource.EventWriteUpdateTasksError(hcmWorker.RecId, taskCount, errorMessage);
            return [false, "@RET2382"];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create task.
    /// </summary>
    /// <param name="_checklistTaskJson">
    /// The JSON string of a Microsoft.Dynamics.Commerce.Runtime.DataModel.ChecklistTask
    /// </param>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker who did the operation.
    /// </param>
    /// <returns>
    /// A container with 3 elements. The 3rd element is the serialized JSON string of a Microsoft.Dynamics.Commerce.Runtime.DataModel.ChecklistTask
    /// </returns>
    internal static container createTask(str _checklistTaskJson, HcmPersonnelNumberId _personnelNumber, int64 _channelId, boolean isAdhoc)
    {
        container taskResult = [true,''];

        ChecklistTask                               requestChecklistTask;
        Microsoft.Dynamics.Ax.Xpp.ErrorException    xppEx;
        System.Exception                            netEx;
        HcmWorker                                   hcmWorker;
        RetailBusinessProcessWorkerRecId            workerId;

        // Parse parameters and validation
        try
        {
            if (_personnelNumber != null && _personnelNumber != '')
            {
                hcmWorker = HcmWorker::findByPersonnelNumber(_personnelNumber);
                if (hcmWorker.RecId == 0)
                {
                    return [false, "@RetailTaskManagement:RetailTaskManagementWorkerNotFound"];
                }

                workerId = hcmWorker.RecId;
            }

            requestChecklistTask = RetailTransactionServiceJsonHelper::DeserializeChecklistTaskFromJSON(_checklistTaskJson);
            
            if (isAdhoc)
            {
                // for adhoc task creation, check channel id exists
                RetailChannelTable channel = RetailChannelTable::findByRecId(_channelId);
                if (channel.RecId == 0)
                {
                    return [false, "@RetailTaskManagement:RetailTaskManagementChannelNotFound"];
                }
            }
            else
            {
                // for non-adhoc task creation, check checklist id exists
                BusinessProcessHeader header;
                select firstonly header where header.ProcessId == str2Guid(requestChecklistTask.ChecklistId);
                if (header.RecId == 0)
                {
                    return [false, "@RetailTaskManagement:RetailTaskManagementChecklistNotFound"];
                }
            }

            if (requestChecklistTask.DeepLinkTypeValue == any2Int(ChecklistTaskDeepLinkType::CustomerAccount))
            {
                CustTable customer = CustTable::find(requestChecklistTask.DeepLink);
                if (customer.RecId == 0)
                {
                    return [false, "@RetailTaskManagement:RetailTaskManagementCustomerNotFound"];
                }
            }
        }
        catch (xppEx)
        {
            str errorMessage = xppEx.ToString();
            eventSource.EventWriteCreateTaskParameterError(workerId, errorMessage);
            taskResult = [false, "@RET2382"];
            return taskResult;
        }
        catch (netEx)
        {
            str errorMessage = netEx.ToString();
            eventSource.EventWriteCreateTaskParameterError(workerId, errorMessage);
            taskResult = [false, "@RET2382"];
            return taskResult;
        }

        // Core logic
        try
        {
            eventSource.EventWriteCreateTaskStart(workerId);

            ttsbegin;

            // Create record
            BusinessProcessTask taskTable;
            boolean isNewTask = true;
            RetailTransactionServiceTaskManagement::setTaskProperties(taskTable, requestChecklistTask, workerId, isNewTask, _channelId);

            // Get more properties for the response
            BusinessProcessHeader checklistTable = BusinessProcessHeader::find(taskTable.ProcessHeader);
            HcmWorker assignedToHcmWorker;
            select firstonly assignedToHcmWorker where assignedToHcmWorker.RecId == taskTable.AssignedWorker;
            ChecklistTask responseChecklistTask = RetailTransactionServiceTaskManagement::createChecklistTaskFromTables(
                        checklistTable,
                        taskTable,
                        assignedToHcmWorker
                        );

            ttscommit;

            // Serialize
            System.Type[] typeArray = new System.Type[1]();
            System.Type checklistTaskType = new ChecklistTask().GetType();
            typeArray.SetValue(checklistTaskType, 0);
            taskResult += RetailTransactionServiceJsonHelper::SerializeToJson(responseChecklistTask, typeArray);

            eventSource.EventWriteCreateTaskStop(workerId);

            return taskResult;
        }
        catch (xppEx)
        {
            str errorMessage = xppEx.ToString();
            eventSource.EventWriteCreateTaskError(workerId, errorMessage);
            taskResult = [false, "@RET2382"];
            return taskResult;
        }
        catch (netEx)
        {
            str errorMessage = netEx.ToString();
            eventSource.EventWriteCreateTaskError(workerId, errorMessage);
            taskResult = [false, "@RET2382"];
            return taskResult;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaskManagementNotificationLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets notification counts based on task management tasks.
    /// </summary>
    /// <param name = "_channelId">The channel ID.</param>
    /// <param name = "_staffId">The staff ID.</param>
    /// <returns>A container that has list of notification lines for given channel.</returns>
    internal static System.Object getTaskManagementNotificationLines(RetailChannelRecId _channelId, RetailStaffId _staffId)
    {
        NotificationDetailCollection result = new NotificationDetailCollection();

        HcmWorker hcmWorker = HcmWorker::findByPersonnelNumber(_staffId);

        // Get notification lines for task management
        System.Object myTasks       = RetailTransactionServiceTaskManagement::getMyActiveTasksNotificationDetailInfo(_channelId, hcmWorker.RecId);
        System.Object overdueTasks  = RetailTransactionServiceTaskManagement::getOverdueTasksNotificationDetailInfo(_channelId, hcmWorker.RecId);
        System.Object allTasks      = RetailTransactionServiceTaskManagement::getAllActiveTasksNotificationDetailInfo(_channelId, hcmWorker.RecId);

        result.Add(myTasks);
        result.Add(overdueTasks);
        result.Add(allTasks);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrCreateAdhocChecklist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the adhoc checklist by channel id if exists, otherwise, create a new one
    /// </summary>
    /// <param name = "_channelId">channel id where the checklist belongs to</param>
    /// <returns>the adhoc checklist associated with the channel</returns>
    private static BusinessProcessHeader getOrCreateAdhocChecklist(RetailChannelRecId _channelId)
    {
        ttsbegin;
        
        BusinessProcessHeader header = BusinessProcessHeader::hasAdhocTaskList(_channelId);

        if (!header)
        {
            header.Name = "@RetailTaskManagement:AdhocTasklistName";
            header.Description = "@RetailTaskManagement:AdhocTasklistDescription";
            header.RetailChannel = _channelId;
            header.IsAdhoc = NoYes::Yes;
            header.ProcessType = BusinessProcessType::Generic;
            header.GenericSubtype = BusinessProcessGenericSubtype::Retail;
            header.StartDateTime = DateTimeUtil::utcNow();
            header.TargetDate = dateMax();
            header.Status = BusinessProcessHeaderStatus::InProgress;
            header.insert();

            BusinessProcessGenericProcessHeader genericHeader;
            genericHeader.ProcessHeader = header.RecId;
            genericHeader.GenericSubtype = BusinessProcessGenericSubtype::Retail;
            genericHeader.insert();
        }
        ttscommit;

        return header;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateQueryForChecklistTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the query to get the tasks of the checklists.
    /// </summary>
    /// <param name="_checklistRecIds">
    /// A container which holds the record ids of the checklists.
    /// </param>
    /// <returns>
    /// The query to get the tasks of the checklists.
    /// </returns>
    private static Query generateQueryForChecklistTasks(container _checklistRecIds)
    {
        Query query = new Query();
        QueryBuildDataSource qbds = query.addDataSource(tableNum(BusinessProcessTask));
        int i;
        for (i = 1; i <= conLen(_checklistRecIds); ++i)
        {
            qbds.addRange(fieldNum(BusinessProcessTask, ProcessHeader)).value(queryValue(conPeek(_checklistRecIds, i)));
        }
        qbds.addSelectionField(fieldNum(BusinessProcessTask, ProcessHeader));
        qbds.addSelectionField(fieldNum(BusinessProcessTask, TaskId));
        qbds.addSelectionField(fieldNum(BusinessProcessTask, Name));
        qbds.addSelectionField(fieldNum(BusinessProcessTask, Status));
        qbds.addSelectionField(fieldNum(BusinessProcessTask, DueDate));
        qbds.addSelectionField(fieldNum(BusinessProcessTask, CompletionDateTime));
        qbds.addSelectionField(fieldNum(BusinessProcessTask, Instructions));
        qbds.addSelectionField(fieldNum(BusinessProcessTask, ContactWorker));
        qbds.addSelectionField(fieldNum(BusinessProcessTask, ResolvedBy));
        qbds.addSelectionField(fieldNum(BusinessProcessTask, MenuItemType));
        qbds.addSelectionField(fieldNum(BusinessProcessTask, MenuItem));
        
        qbds.addOrderByField(fieldNum(BusinessProcessTask, ProcessHeader));
        qbds.addOrderByField(fieldNum(BusinessProcessTask, DueDate));
        qbds.addOrderByField(fieldNum(BusinessProcessTask, RecId));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>utcDateTime2SystemDateTimeOffset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parses an x++ utcdatetime to c# System.DateTimeOffset.
    /// </summary>
    /// <param name="_utcDateTime">
    /// The utcdatetime.
    /// </param>
    /// <returns>
    /// The System.DateTimeOffset which doesn't contain timezone information.
    /// </returns>
    private static System.DateTimeOffset utcDateTime2SystemDateTimeOffset(utcdatetime _utcDateTime)
    {
        System.DateTime dateTime = Global::utcDateTime2SystemDateTime(_utcDateTime);
        System.DateTimeOffset dateTimeOffset = new System.DateTimeOffset(dateTime, new System.TimeSpan(0, 0, 0));
        return dateTimeOffset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>date2SystemDateTimeOffset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parses an x++ date to c# System.DateTimeOffset.
    /// </summary>
    /// <param name="_date">
    /// The input date value.
    /// </param>
    /// <returns>
    /// The System.DateTimeOffset which doesn't contain timezone information.
    /// </returns>
    private static System.DateTimeOffset date2SystemDateTimeOffset(date _date)
    {
        System.DateTime dateTime = Global::utcDateTime2SystemDateTime(DateTimeUtil::newDateTime(_date, 0));
        System.DateTimeOffset dateTimeOffset = new System.DateTimeOffset(dateTime, new System.TimeSpan(0, 0, 0));
        return dateTimeOffset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>systemDateTimeOffset2utcDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parses a c# System.DateTimeOffset to x++ utcdatetime
    /// </summary>
    /// <param name="_dateTimeOffset">
    /// The c# System.DateTimeOffset
    /// </param>
    /// <returns>
    /// The utcdatetime
    /// </returns>
    private static utcdatetime systemDateTimeOffset2utcDateTime(System.DateTimeOffset _dateTimeOffset)
    {
        System.DateTimeOffset universalTime = _dateTimeOffset.ToUniversalTime();
        return Global::CLRSystemDateTime2UtcDateTime(universalTime.DateTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addChecklistDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the first QueryBuildDataSource which is for checklist into the query.
    /// </summary>
    /// <param name="_query">
    /// The query.
    /// </param>
    /// <param name="_channelId">
    /// The record ID of the channel.
    /// </param>
    /// <param name="_workerId">
    /// The record ID of the worker.
    /// </param>
    /// <param name="_statuses">
    /// The statuses of checklists to include.
    /// </param>
    /// <param name="_filterAssignedTo">
    /// Whether only includes the checklists assigned to specific channel or worker.
    /// </param>
    /// <param name="_excludeAdhoc">
    /// Whether the query excludes adhoc checklists.
    /// </param>
    /// <returns>
    /// The newly added QueryBuildDataSource for BusinessProcessHeader.
    /// </returns>

    private static QueryBuildDataSource addChecklistDataSource(Query _query, RetailChannelRecId _channelId, RetailBusinessProcessWorkerRecId _workerId, container _statuses, boolean _filterAssignedTo, boolean _excludeAdhoc)
    {
        QueryBuildDataSource qbds = _query.addDataSource(tableNum(BusinessProcessHeader));

        qbds.addRange(fieldNum(BusinessProcessHeader, GenericSubtype)).value(queryValue(BusinessProcessGenericSubtype::Retail));

        if (_excludeAdhoc)
        {
            qbds.addRange(fieldNum(BusinessProcessHeader, IsAdhoc)).value(SysQuery::value(NoYes::No));
        }

        int statusesLength = conLen(_statuses);
        for (int i = 1; i <= statusesLength; ++i)
        {
            qbds.addRange(fieldNum(BusinessProcessHeader, Status)).value(queryValue(conPeek(_statuses, i)));
        }
        if (_filterAssignedTo)
        {
            // If it's for checklist, only include the checklists assigned to the channel or to the worker
            qbds.addRange(fieldNum(BusinessProcessHeader, RetailChannel)).value(
            strFmt(
                // If it's for tasks, also need to include the checklists which are not assigned to any channel.
            '((%1 == %2) || (%3 == %4))',
                fieldStr(BusinessProcessHeader, RetailChannel),
                _channelId,
                fieldStr(BusinessProcessHeader, HcmWorker),
                _workerId
            )
            );
        }
        return qbds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>joinTaskTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Joins current query with BusinessProcessTask.
    /// </summary>
    /// <param name="_checklistQueryBuildDataSource">
    /// QueryBuildDataSource for BusinessProcessHeader.
    /// </param>
    /// <returns>
    /// The newly added QueryBuildDataSource for BusinessProcessTask.
    /// </returns>
    private static QueryBuildDataSource joinTaskTable(QueryBuildDataSource _checklistQueryBuildDataSource)
    {
        QueryBuildDataSource qbds = _checklistQueryBuildDataSource.addDataSource(tableNum(BusinessProcessTask));
        qbds.relations(true);
        return qbds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>joinHcmWorker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Joins current query with HcmWorker. Used to get the personnel number.
    /// </summary>
    /// <param name="_taskQueryBuildDataSource">
    /// QueryBuildDataSource for BusinessProcessTask.
    /// </param>
    /// <returns>
    /// The newly added QueryBuildDataSource for HcmWorker.
    /// </returns>
    private static QueryBuildDataSource joinHcmWorker(QueryBuildDataSource _taskQueryBuildDataSource)
    {
        QueryBuildDataSource qbds = _taskQueryBuildDataSource.addDataSource(tableNum(HcmWorker));
        qbds.relations(false);
        qbds.joinMode(joinmode::OuterJoin);
        qbds.addSelectionField(fieldNum(HcmWorker, PersonnelNumber));
        qbds.addLink(fieldNum(BusinessProcessTask,AssignedWorker),fieldNum(HcmWorker,RecId));
        return qbds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>joinDirPerson</Name>
				<Source><![CDATA[
    /// <summary>
    /// Joins current query with DirPerson. Used to get the name of the worker.
    /// </summary>
    /// <param name="_workerQueryBuildDataSource">
    /// QueryBuildDataSource for HcmWorker.
    /// </param>
    /// <returns>
    /// The newly added QueryBuildDataSource for DirPerson.
    /// </returns>
    private static QueryBuildDataSource joinDirPerson(QueryBuildDataSource _workerQueryBuildDataSource)
    {
        QueryBuildDataSource qbds = _workerQueryBuildDataSource.addDataSource(tableNum(DirPerson));
        qbds.relations(true);
        qbds.joinMode(joinmode::OuterJoin);
        qbds.addSelectionField(fieldNum(DirPerson, Name));
        return qbds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryRunWithPaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the query with given paging information.
    /// </summary>
    /// <param name="_query">
    /// The query.
    /// </param>
    /// <param name="_pagingInfo">
    /// The paging information.
    /// </param>
    /// <returns>
    /// The query run.
    /// </returns>
    private static QueryRun getQueryRunWithPaging(Query _query, PagingInfo _pagingInfo)
    {
        QueryRun qr = new QueryRun(_query);
        qr.enablePositionPaging(true);
        qr.addPageRange(_pagingInfo.Skip + 1, _pagingInfo.Top);
        return qr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createChecklistFromChecklistTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the Checklist object from a BusinessProcessHeader object.
    /// </summary>
    /// <param name="_checklistTable">
    /// The BusinessProcessHeader object.
    /// </param>
    /// <returns>
    /// The Checklist object.
    /// </returns>
    private static Checklist createChecklistFromChecklistTable(BusinessProcessHeader _checklistTable)
    {
        Checklist checklist = new Checklist();
        checklist.Version = int2Str(_checklistTable.RecVersion);
        checklist.RecordId = _checklistTable.RecId;
        checklist.ProcessId = guid2Str(_checklistTable.ProcessId);
        checklist.Name = _checklistTable.Name;
        checklist.Description = _checklistTable.Description;

        checklist.Status = RetailTransactionServiceTaskManagement::xppChecklistStatus2DotnetChecklistStatus(_checklistTable.Status);
        if (_checklistTable.StartDateTime != DateTimeUtil::minValue())
        {
            checklist.StartDateTime = RetailTransactionServiceTaskManagement::utcDateTime2SystemDateTimeOffset(_checklistTable.StartDateTime);
        }
        if (_checklistTable.endDateTime != DateTimeUtil::minValue())
        {
            checklist.EndDateTime = RetailTransactionServiceTaskManagement::utcDateTime2SystemDateTimeOffset(_checklistTable.endDateTime);
        }

        checklist.TargetDateTime                  = RetailTransactionServiceTaskManagement::date2SystemDateTimeOffset(_checklistTable.TargetDate);
        checklist.AssignedToWorkerPersonnelNumber = RetailTransactionServiceTaskManagement::getChecklistAssignedToWorkerPersonnelNumber(_checklistTable);

        if (_checklistTable.RetailChannel != 0)
        {
            System.Nullable<int64> nullableChannelId = _checklistTable.RetailChannel;
            checklist.AssignedToChannelId            = nullableChannelId;
        }

        return checklist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChecklistAssignedToWorkerPersonnelNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the personnel number for the "AssignedToWorkerPersonnelNumber" field of a Checklist object for Channel.
    /// </summary>
    /// <param name="_checklistTable">
    /// The BusinessProcessHeader object.
    /// </param>
    /// <returns>
    /// The personnel number for the "AssignedToWorkerPersonnelNumber" field of a Checklist object for Channel.
    /// </returns>
    private static str getChecklistAssignedToWorkerPersonnelNumber(BusinessProcessHeader _checklistTable)
    {
        if (_checklistTable.HcmWorker != 0)
        {
            return HcmWorker::find(_checklistTable.HcmWorker).PersonnelNumber;
        }
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>createChecklistTaskFromTables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the ChecklistTask object from multiple tables, BusinessProcessHeader, BusinessProcessTask, and HcmWorker.
    /// </summary>
    /// <param name="_checklistTable">
    /// The BusinessProcessHeader object.
    /// </param>
    /// <param name="_taskTable">
    /// The BusinessProcessTask object.
    /// </param>
    /// <param name="_hcmWorker">
    /// The HcmWorker object.
    /// </param>
    /// <param name="_simplified">
    /// Whether the result is simplified. If it's simplified, only set the fields used by getChecklists.
    /// </param>
    /// <returns>
    /// The ChecklistTask object.
    /// </returns>
    private static ChecklistTask createChecklistTaskFromTables(BusinessProcessHeader _checklistTable, BusinessProcessTask _taskTable, HcmWorker _hcmWorker, boolean _simplified = false)
    {
        ChecklistTask checklistTask = new ChecklistTask();
        checklistTask.Name = _taskTable.Name;
        checklistTask.Id = guid2Str(_taskTable.TaskId);
        checklistTask.DueDateTime = RetailTransactionServiceTaskManagement::date2SystemDateTimeOffset(_taskTable.DueDate);
        checklistTask.Status = RetailTransactionServiceTaskManagement::xppTaskStatus2DotnetTaskStatus(_taskTable.Status);
        if (_taskTable.CompletionDateTime != DateTimeUtil::minValue())
        {
            checklistTask.CompletionDateTime = RetailTransactionServiceTaskManagement::utcDateTime2SystemDateTimeOffset(_taskTable.CompletionDateTime);
        }

        if (!_simplified)
        {
            checklistTask.Version       = int2Str(_taskTable.RecVersion);
            checklistTask.Description   = _taskTable.Description;
            checklistTask.DeepLinkType  = RetailTransactionServiceTaskManagement::xppTaskMenuItemType2DotnetTaskDeepLinkType(_taskTable.MenuItemType);
            checklistTask.DeepLink      = _taskTable.MenuItem;
            if (_taskTable.MenuItemType == BusinessProcessTaskEditor::PosOperationMenuItemType)
            {
                checklistTask.DeepLinkPosOperationName = RetailOperations::find(str2Int(_taskTable.MenuItem)).OperationName;
            }

            if (_taskTable.MenuItemType == BusinessProcessTaskEditor::CustomerAccountMenuItemType)
            {
                var companyId = curExt();
                CustTable customer;
                select firstonly crosscompany customer where customer.RecId == str2Int64(_taskTable.MenuItem);
                if (customer.dataareaid == companyId)
                {
                    checklistTask.DeepLink = customer.AccountNum;
                }
                else
                {
                    checklistTask.DeepLink = "";
                }
            }

            if (_taskTable.ContactWorker != 0)
            {
                HcmWorker contactWorker = HcmWorker::find(_taskTable.ContactWorker);
                if (contactWorker.RecId != 0)
                {
                    checklistTask.ContactPersonPersonnelNumber = contactWorker.PersonnelNumber;
                }
            }

            checklistTask.Instructions = _taskTable.Instructions;

            CLRObject assignedToPersonnelNumbers = checklistTask.AssignedToPersonnelNumbers;
            assignedToPersonnelNumbers.Add(_hcmWorker.PersonnelNumber);

            if (_taskTable.ResolvedBy != 0)
            {
                HcmWorker resolvedBy                    = HcmWorker::find(_taskTable.ResolvedBy);
                checklistTask.ResolvedByPersonnelNumber = resolvedBy.PersonnelNumber;
            }

            checklistTask.ChecklistId = guid2Str(_checklistTable.ProcessId);
        }

        return checklistTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setChecklistProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set sthe properties of the BusinessProcessHeader according to the given instance of Checklist.
    /// </summary>
    /// <param name="_businessProcessHeader">
    /// The instance of BusinessProcessHeader.
    /// </param>
    /// <param name="_checklist">
    /// The instance of Checklist.
    /// </param>
    /// <param name="_workerId">
    /// The worker id of the worker who did the operation.
    /// </param>
    /// <param name="_isNewChecklist">
    /// Whether it's a new checklist.
    /// </param>
    private static void setChecklistProperties(BusinessProcessHeader _businessProcessHeader, Checklist _checklist, RetailBusinessProcessWorkerRecId _workerId, boolean _isNewChecklist)
    {
        // Status
        BusinessProcessHeaderStatus newStatus = RetailTransactionServiceTaskManagement::dotnetChecklistStatus2XppChecklistStatus(_checklist.Status);

        if (_businessProcessHeader.Status != newStatus)
        {
            _businessProcessHeader.updateStatusByWorker(newStatus, _workerId);
        }

        // Simple string/int fields
        _businessProcessHeader.Name           = _checklist.Name == null ? '' : _checklist.Name;
        _businessProcessHeader.Description    = _checklist.Description == null ? '' : _checklist.Description;

        // DateTimeOffset
        _businessProcessHeader.TargetDate = datetimeUtil::date(RetailTransactionServiceTaskManagement::systemDateTimeOffset2utcDateTime(_checklist.TargetDateTime));

        // Special handling for nullable DateTimeOffset
        System.Nullable<System.DateTimeOffset> startDateTime = _checklist.StartDateTime;
        if (startDateTime.get_HasValue())
        {
            _businessProcessHeader.StartDateTime = RetailTransactionServiceTaskManagement::systemDateTimeOffset2utcDateTime(startDateTime.get_Value());
        }

        if (_isNewChecklist)
        {
            _businessProcessHeader.insert();
        }
        else
        {
            _businessProcessHeader.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaskProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the properties of the BusinessProcessTask according to the given instance of ChecklistTask.
    /// </summary>
    /// <param name="_task">
    /// The instance of BusinessProcessTask.
    /// </param>
    /// <param name="_checklistTask">
    /// The instance of ChecklistTask.
    /// </param>
    /// <param name="_workerId">
    /// The worker ID of the worker who did the operation.
    /// </param>
    /// <param name="_isNewTask">
    /// Whether it's a new task.
    /// </param>
    private static void setTaskProperties(BusinessProcessTask _task, ChecklistTask _checklistTask, RetailBusinessProcessWorkerRecId _workerId, boolean _isNewTask, int64 _channelId)
    {
        boolean updateTaskAssignment = false;

        // Checklist id. Only set it if it's new task.
        if (_isNewTask)
        {
            BusinessProcessHeader header;
            if (_checklistTask.ChecklistId == '')
            {
                header = RetailTransactionServiceTaskManagement::getOrCreateAdhocChecklist(_channelId);
            }
            else
            {
                select firstonly header where header.ProcessId == str2Guid(_checklistTask.ChecklistId);
            }
            
            _task.ProcessHeader = header.RecId;
        }

        // Status
        BusinessProcessTaskStatus newStatus = RetailTransactionServiceTaskManagement::dotnetTaskStatus2XppTaskStatus(_checklistTask.Status);

        if (_task.Status != newStatus)
        {
            _task.updateStatusByWorker(newStatus, _workerId);
        }

        // Simple string/int fields
        _task.Name           = _checklistTask.Name == null ? '' : _checklistTask.Name;
        _task.Description    = _checklistTask.Description == null ? '' : _checklistTask.Description;
        _task.Instructions   = _checklistTask.Instructions == null ? '' : _checklistTask.Instructions;
        _task.MenuItemType   = RetailTransactionServiceTaskManagement::dotnetTaskDeepLinkType2XppTaskMenuItemType(_checklistTask.DeepLinkType);
        _task.MenuItem       = _checklistTask.DeepLink == null ? '' : _checklistTask.DeepLink;
        if (_task.MenuItemType == BusinessProcessTaskEditor::CustomerAccountMenuItemType)
        {
            CustTable customer = CustTable::find(_checklistTask.DeepLink);
            _task.MenuItem = int642Str(customer.RecId);
        }

        // Update people by personnel number
        _task.ContactWorker =
                _checklistTask.ContactPersonPersonnelNumber == null ?
                0
                :
                RetailTransactionServiceTaskManagement::getRecIdFromPersonnelNumber(_checklistTask.ContactPersonPersonnelNumber);

        if (_checklistTask.AssignedToPersonnelNumbers != null)
        {
            System.Collections.IEnumerator taskAssignedToEnumerator = _checklistTask.AssignedToPersonnelNumbers.GetEnumerator();

            if (taskAssignedToEnumerator.MoveNext())
            {
                str taskAssignedTo = taskAssignedToEnumerator.get_Current();
                _task.AssignedWorker = RetailTransactionServiceTaskManagement::getRecIdFromPersonnelNumber(taskAssignedTo);
                updateTaskAssignment = true;
            }
        }

        // Special handling for nullable DateTimeOffset
        System.Nullable<System.DateTimeOffset> dueDate = _checklistTask.DueDateTime;

        if (dueDate.get_HasValue())
        {
            _task.DueDate = datetimeUtil::date(RetailTransactionServiceTaskManagement::systemDateTimeOffset2utcDateTime(dueDate.get_Value()));

        }

        // Insert or update
        if (_isNewTask)
        {
            _task.insert();
        }
        else
        {
            _task.update();
        }

        // If the AssignedWorker has been changed, also call the updateTaskAssignment to maintain the task assignment table
        if (updateTaskAssignment)
        {
            BusinessProcessTask::updateTaskAssignment(_task.RecId, BusinessProcessAssignmentType::Worker);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRecIdFromPersonnelNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the worker's record ID from the personnel number.
    /// </summary>
    /// <param name="_personnelNumber">
    /// The worker's personnel number.
    /// </param>
    /// <returns>
    /// The worker's record ID.
    /// </returns>
    private static int64 getRecIdFromPersonnelNumber(str _personnelNumber)
    {
        if (_personnelNumber != '')
        {
            HcmWorker worker = HcmWorker::findByPersonnelNumber(_personnelNumber);
            return worker.RecId;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasAllowTaskManagementPermission</Name>
				<Source><![CDATA[
    private static boolean hasAllowTaskManagementPermission(RetailBusinessProcessWorkerRecId _workerId)
    {
        boolean hasPermission = true;

        // look for override permission first
        RetailPositionPosPermission positionPermission;
        HcmPosition                 position;
        HcmPositionWorkerAssignment assignment;
        HcmWorker                   worker;
        RetailStaffTable            staff;

        // refer to the stored proc in channel database view
        // [crt].[EMPLOYEEPERMISSIONOVERRIDESVIEW]
        select maxof(AllowTaskManagement) from positionPermission
            group by staff.staffId
            exists join position where positionPermission.Position == position.RecId
            exists join assignment where position.RecId == assignment.Position
            exists join worker where assignment.Worker == worker.RecId && worker.RecId == _workerId
            exists join staff where worker.PersonnelNumber == staff.staffId;
        
        if (positionPermission)
        {
            hasPermission = positionPermission.AllowTaskManagement;
        }
        else
        {
            HcmPositionDetail           positionDetail;
            RetailJobPosPermissionGroup jobPermissionGroup;
            RetailPosPermissionGroup    posPermissionGroup;

            select posPermissionGroup
                    exists join jobPermissionGroup
                        where
                            jobPermissionGroup.RetailPosPermissionGroup == posPermissionGroup.RecId
                    exists join positionDetail
                        where
                            positionDetail.Job  == jobPermissionGroup.Job
                    exists join assignment
                        where
                            assignment.Position == positionDetail.Position
                        &&  assignment.Worker   == _workerId;

            hasPermission = posPermissionGroup.AllowTaskManagement;
        }

        return hasPermission;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMyActiveTasksNotificationDetailInfo</Name>
				<Source><![CDATA[
    private static System.Object getMyActiveTasksNotificationDetailInfo(RetailChannelRecId _channelId, HcmWorkerRecId _workerRecId)
    {
        Query       query       = RetailTransactionServiceTaskManagement::getBaseTaskQuery(RetailTransactionServiceTaskManagement::getActiveTaskStatuses(), true, false, _workerRecId, _channelId, false);
        QueryRun    queryRun    = new QueryRun(query);

        BusinessProcessTask businessProcessTask = RetailTransactionServiceTaskManagement::getTasksQueryAggregationResult(queryRun);

        NotificationDetail result = new NotificationDetail();

        result.DisplayText               = 'string_7705';
        result.ActionProperty            = 'MyTasks';
        result.ItemCount                 = businessProcessTask.RecId;
        result.LastUpdatedDateTimeStr    = DateTimeUtil::toStr(businessProcessTask.ModifiedDateTime);
        result.IsSuccess                 = true;

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOverdueTasksNotificationDetailInfo</Name>
				<Source><![CDATA[
    private static System.Object getOverdueTasksNotificationDetailInfo(RetailChannelRecId _channelId, HcmWorkerRecId _workerRecId)
    {
        Query       query       = RetailTransactionServiceTaskManagement::getBaseTaskQuery(RetailTransactionServiceTaskManagement::getActiveTaskStatuses(), false, true, _workerRecId, _channelId, false);
        QueryRun    queryRun    = new QueryRun(query);

        BusinessProcessTask businessProcessTask = RetailTransactionServiceTaskManagement::getTasksQueryAggregationResult(queryRun);

        NotificationDetail result = new NotificationDetail();

        result.DisplayText               = 'string_7707';
        result.ActionProperty            = 'OverdueTasks';
        result.ItemCount                 = businessProcessTask.RecId;
        result.LastUpdatedDateTimeStr    = DateTimeUtil::toStr(businessProcessTask.ModifiedDateTime);
        result.IsSuccess                 = true;

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllActiveTasksNotificationDetailInfo</Name>
				<Source><![CDATA[
    private static System.Object getAllActiveTasksNotificationDetailInfo(RetailChannelRecId _channelId, HcmWorkerRecId _workerRecId)
    {
        Query       query       = RetailTransactionServiceTaskManagement::getBaseTaskQuery(RetailTransactionServiceTaskManagement::getActiveTaskStatuses(), false, false, _workerRecId, _channelId, false);
        QueryRun    queryRun    = new QueryRun(query);

        BusinessProcessTask businessProcessTask = RetailTransactionServiceTaskManagement::getTasksQueryAggregationResult(queryRun);

        NotificationDetail result = new NotificationDetail();

        result.DisplayText               = 'string_7706';
        result.ActionProperty            = 'AllTasks';
        result.ItemCount                 = businessProcessTask.RecId;
        result.LastUpdatedDateTimeStr    = DateTimeUtil::toStr(businessProcessTask.ModifiedDateTime);
        result.IsSuccess                 = true;

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTasksQueryAggregationResult</Name>
				<Source><![CDATA[
    private static BusinessProcessTask getTasksQueryAggregationResult(QueryRun queryRun)
    {
        queryRun.query().dataSourceTable(tableNum(BusinessProcessTask)).fields().clearFieldList();
        queryRun.query().dataSourceTable(tableNum(BusinessProcessTask)).addSelectionField(fieldNum(BusinessProcessTask, RecId), SelectionField::Count);
        queryRun.query().dataSourceTable(tableNum(BusinessProcessTask)).addSelectionField(fieldNum(BusinessProcessTask, ModifiedDateTime), SelectionField::Max);
        queryRun.next();
        
        return queryRun.get(tableNum(BusinessProcessTask));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBaseTaskQuery</Name>
				<Source><![CDATA[
    private static Query getBaseTaskQuery(container _statuses, boolean _isMyTasks, boolean _isDueTasks, HcmWorkerRecId _workerRecId, RetailChannelRecId _channelRecId, boolean _excludeAdhocChecklist)
    {
        Query query = new Query();

        // If it's for tasks, only include the checklists which are active
        QueryBuildDataSource checklistQueryBuildDataSource = RetailTransactionServiceTaskManagement::addChecklistDataSource(query, _channelRecId, _workerRecId, RetailTransactionServiceTaskManagement::getActiveChecklistStatuses(), false, _excludeAdhocChecklist);

        checklistQueryBuildDataSource.addSelectionField(fieldNum(BusinessProcessHeader, RetailChannel));
        checklistQueryBuildDataSource.addSelectionField(fieldNum(BusinessProcessHeader, HcmWorker));
        checklistQueryBuildDataSource.addSelectionField(fieldNum(BusinessProcessHeader, Name));
        checklistQueryBuildDataSource.addSelectionField(fieldNum(BusinessProcessHeader, ProcessId));

        QueryBuildDataSource    taskQueryBuildDataSource    = RetailTransactionServiceTaskManagement::joinTaskTable(checklistQueryBuildDataSource);
        QueryBuildDataSource    workerQueryBuildDataSource  = RetailTransactionServiceTaskManagement::joinHcmWorker(taskQueryBuildDataSource);
        QueryBuildDataSource    personQueryBuildDataSource  = RetailTransactionServiceTaskManagement::joinDirPerson(workerQueryBuildDataSource);

        // Status
        int statusLength = conLen(_statuses);
        for (int i = 1; i <= statusLength; ++i)
        {
            taskQueryBuildDataSource.addRange(fieldNum(BusinessProcessTask, Status)).value(queryValue(conPeek(_statuses, i)));
        }

        if (_isMyTasks)
        {
            // Task assigned to the worker
            taskQueryBuildDataSource.addRange(fieldNum(BusinessProcessTask, AssignedWorker)).value(queryValue(_workerRecId));
        }
        else
        {
            // For all tasks or due tasks
            //   1. Include tasks assigned to the worker
            //   2. Include tasks belong to a checklist which is assigned to the store
            //   3. Include tasks belong to a checklist which is assigned to the worker
            taskQueryBuildDataSource.addRange(fieldNum(BusinessProcessTask, AssignedWorker)).value(
                    strFmt(
                        '((%1.%2 == %5) || (%3.%4 == %5) || (%3.%6 == %7))',
                        taskQueryBuildDataSource.name(),
                        fieldStr(BusinessProcessTask, AssignedWorker),
                        checklistQueryBuildDataSource.name(),
                        fieldStr(BusinessProcessHeader, HcmWorker),
                        _workerRecId,
                        fieldStr(BusinessProcessHeader, RetailChannel),
                        _channelRecId
                    ));

            if (_isDueTasks)
            {
                // Due date check for due tasks
                taskQueryBuildDataSource.addRange(fieldNum(BusinessProcessTask, DueDate)).value(SysQueryRangeUtil::lessThanDate(0));
            }
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addOrderByToBaseTaskQuery</Name>
				<Source><![CDATA[
    private static void addOrderByToBaseTaskQuery(Query _query, QueryResultSettings _queryResultSettings)
    {
        // Order by
        System.Collections.IEnumerable sortColumns          = _queryResultSettings.Sorting.get_Columns();
        System.Collections.IEnumerator sortColumnEnumerator = sortColumns.GetEnumerator();

        int     sortColumnsCount    = _queryResultSettings.Sorting.get_Count();
        boolean dueDateSorted       = false;

        QueryBuildDataSource taskQueryBuildDataSource       = _query.dataSourceTable(tableNum(BusinessProcessTask));
        QueryBuildDataSource checklistQueryBuildDataSource  = _query.dataSourceTable(tableNum(BusinessProcessHeader));
        QueryBuildDataSource personQueryBuildDataSource     = _query.dataSourceTable(tableNum(DirPerson));

        while (sortColumnEnumerator.MoveNext())
        {
            SortColumn sortColumn = sortColumnEnumerator.get_Current();
            str name = sortColumn.get_ColumnName();
            boolean isDescending = sortColumn.get_IsDescending();
            SortOrder sortOrder = isDescending ? SortOrder::Descending : SortOrder::Ascending;
            switch (name)
            {
                case 'AssignedWorkerName':
                    personQueryBuildDataSource.addOrderByField(fieldNum(DirPerson, Name), sortOrder);
                    break;
                case 'Status':
                    taskQueryBuildDataSource.addOrderByField(fieldNum(BusinessProcessTask, Status), sortOrder);
                    break;
                case 'DueDateTime':
                    taskQueryBuildDataSource.addOrderByField(fieldNum(BusinessProcessTask, DueDate), sortOrder);
                    dueDateSorted = true;
                    break;
                case 'Checklist':
                    checklistQueryBuildDataSource.addOrderByField(fieldNum(BusinessProcessHeader, Name), sortOrder);
                    break;
            }
        }

        // Order by DueDate and RecId at last, to ensure the consistency of the sequence
        if (!dueDateSorted)
        {
            taskQueryBuildDataSource.addOrderByField(fieldNum(BusinessProcessTask, DueDate), SortOrder::Ascending);
        }

        taskQueryBuildDataSource.addOrderByField(fieldNum(BusinessProcessTask, Name), SortOrder::Ascending);
    }

]]></Source>
			</Method>
			<Method>
				<Name>xppTaskStatus2DotnetTaskStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parse the x++ BusinessProcessTaskStatus to c# ChecklistTaskStatus
    /// </summary>
    /// <param name="_taskStatus">
    /// The BusinessProcessTaskStatus
    /// </param>
    /// <returns>
    /// The ChecklistTaskStatus
    /// </returns>
    private static ChecklistTaskStatus xppTaskStatus2DotnetTaskStatus(BusinessProcessTaskStatus _taskStatus)
    {
        switch (_taskStatus)
        {
            case BusinessProcessTaskStatus::NotStarted:
                return ChecklistTaskStatus::NotStarted;
            case BusinessProcessTaskStatus::InProgress:
                return ChecklistTaskStatus::InProgress;
            case BusinessProcessTaskStatus::Completed:
                return ChecklistTaskStatus::Completed;
            default:
                return ChecklistTaskStatus::None;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dotnetTaskStatus2XppTaskStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parse the c# ChecklistTaskStatus to x++ BusinessProcessTaskStatus
    /// </summary>
    /// <param name="_taskStatus">
    /// The ChecklistTaskStatus
    /// </param>
    /// <returns>
    /// The BusinessProcessTaskStatus
    /// </returns>
    private static BusinessProcessTaskStatus dotnetTaskStatus2XppTaskStatus(ChecklistTaskStatus _taskStatus)
    {
        switch (_taskStatus)
        {
            case ChecklistTaskStatus::NotStarted:
                return BusinessProcessTaskStatus::NotStarted;
            case ChecklistTaskStatus::InProgress:
                return BusinessProcessTaskStatus::InProgress;
            case ChecklistTaskStatus::Completed:
                return BusinessProcessTaskStatus::Completed;
            default:
                return BusinessProcessTaskStatus::NotStarted;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>xppChecklistStatus2DotnetChecklistStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parse the x++ BusinessProcessHeaderStatus to c# ChecklistStatus
    /// </summary>
    /// <param name="_checklistStatus">
    /// The BusinessProcessHeaderStatus
    /// </param>
    /// <returns>
    /// The ChecklistStatus
    /// </returns>
    private static ChecklistStatus xppChecklistStatus2DotnetChecklistStatus(BusinessProcessHeaderStatus _checklistStatus)
    {
        switch (_checklistStatus)
        {
            case BusinessProcessHeaderStatus::NotStarted:
                return ChecklistStatus::NotStarted;
            case BusinessProcessHeaderStatus::InProgress:
                return ChecklistStatus::InProgress;
            case BusinessProcessHeaderStatus::Completed:
                return ChecklistStatus::Completed;
            default:
                return ChecklistStatus::None;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dotnetChecklistStatus2XppChecklistStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parse the c# ChecklistStatus to x++ BusinessProcessHeaderStatus
    /// </summary>
    /// <param name="_checklistStatus">
    /// The ChecklistStatus
    /// </param>
    /// <returns>
    /// The BusinessProcessHeaderStatus
    /// </returns>
    private static BusinessProcessHeaderStatus dotnetChecklistStatus2XppChecklistStatus(ChecklistStatus _checklistStatus)
    {
        switch (_checklistStatus)
        {
            case ChecklistStatus::NotStarted:
                return BusinessProcessHeaderStatus::NotStarted;
            case ChecklistStatus::InProgress:
                return BusinessProcessHeaderStatus::InProgress;
            case ChecklistStatus::Completed:
                return BusinessProcessHeaderStatus::Completed;
            default:
                return BusinessProcessHeaderStatus::NotStarted;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>xppTaskMenuItemType2DotnetTaskDeepLinkType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parse the x++ BusinessProcessActionType to c# ChecklistTaskDeepLinkType
    /// </summary>
    /// <param name="_menuItemType">
    /// The BusinessProcessActionType
    /// </param>
    /// <returns>
    /// The ChecklistTaskDeepLinkType
    /// </returns>
    /// <remarks>
    /// The BusinessProcessActionType may be 255 it's defined at BusinessProcessTaskEditor::UrlMenuItemType.
    /// And you can find related comments in BusinessProcessIActionLookupCaller.
    /// The BusinessProcessActionType may be 254 it's defined in BusinessProcessTaskEditor_AppSuite_Extension.
    /// </remarks>
    private static ChecklistTaskDeepLinkType xppTaskMenuItemType2DotnetTaskDeepLinkType(BusinessProcessActionType _menuItemType)
    {
        switch (_menuItemType)
        {
            case MenuItemType::Display:
                return ChecklistTaskDeepLinkType::Display;
            case MenuItemType::Output:
                return ChecklistTaskDeepLinkType::Output;
            case MenuItemType::Action:
                return ChecklistTaskDeepLinkType::Action;
            case BusinessProcessTaskEditor::UrlMenuItemType:
                return ChecklistTaskDeepLinkType::Url;
            case BusinessProcessTaskEditor::PosOperationMenuItemType:
                return ChecklistTaskDeepLinkType::PosOperation;
            case BusinessProcessTaskEditor::CustomerAccountMenuItemType:
                return ChecklistTaskDeepLinkType::CustomerAccount;
            case BusinessProcessTaskEditor::PosOperationWithParametersMenuItemType:
                return ChecklistTaskDeepLinkType::PosOperationWithParameters;
            default:
                return ChecklistTaskDeepLinkType::None;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dotnetTaskDeepLinkType2XppTaskMenuItemType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parse the c# ChecklistTaskDeepLinkType to x++ BusinessProcessActionType
    /// </summary>
    /// <param name="_deepLinkType">
    /// The ChecklistTaskDeepLinkType
    /// </param>
    /// <returns>
    /// The BusinessProcessActionType
    /// </returns>
    /// <remarks>
    /// The BusinessProcessActionType may be 255 it's defined at BusinessProcessTaskEditor::UrlMenuItemType.
    /// And you can find related comments in BusinessProcessIActionLookupCaller.
    /// </remarks>
    private static BusinessProcessActionType dotnetTaskDeepLinkType2XppTaskMenuItemType(ChecklistTaskDeepLinkType _deepLinkType)
    {
        switch (_deepLinkType)
        {
            case ChecklistTaskDeepLinkType::Display:
                return MenuItemType::Display;
            case ChecklistTaskDeepLinkType::Output:
                return MenuItemType::Output;
            case ChecklistTaskDeepLinkType::Action:
                return MenuItemType::Action;
            case ChecklistTaskDeepLinkType::Url:
                return BusinessProcessTaskEditor::UrlMenuItemType;
            case ChecklistTaskDeepLinkType::PosOperation:
                return BusinessProcessTaskEditor::PosOperationMenuItemType;
            case ChecklistTaskDeepLinkType::CustomerAccount:
                return BusinessProcessTaskEditor::CustomerAccountMenuItemType;
            case ChecklistTaskDeepLinkType::PosOperationWithParameters:
                return BusinessProcessTaskEditor::PosOperationWithParametersMenuItemType;
            default:
                return MenuItemType::Display;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActiveChecklistStatuses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a container which contains all the active checklist statuses.
    /// </summary>
    /// <returns>
    /// A container which contains all the active checklist statuses.
    /// </returns>
    private static container getActiveChecklistStatuses()
    {
        return [BusinessProcessHeaderStatus::NotStarted, BusinessProcessHeaderStatus::InProgress];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActiveTaskStatuses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a container which contains all the active task statuses.
    /// </summary>
    /// <returns>
    /// A container which contains all the active task statuses.
    /// </returns>
    private static container getActiveTaskStatuses()
    {
        return [BusinessProcessTaskStatus::NotStarted, BusinessProcessTaskStatus::InProgress];
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillChecklistTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills the Tasks properties of the checklists.
    /// </summary>
    /// <param name="_checklistMap">
    /// A map of the checklists. Key is the checklist ID, value is the checklist instance.
    /// </param>
    /// <returns>
    /// Number of tasks retrieved.
    /// </returns>
    private static int fillChecklistTasks(Map _checklistMap)
    {
        int                    taskCount = 0;
        Query                  tasksQuery;
        QueryRun               tasksQueryRun;
        BusinessProcessTask    taskTable;
        Checklist              checklist;

        if (_checklistMap.elements() > 0)
        {
            container checklistRecIds;
            MapEnumerator checklistEnumerator = _checklistMap.getEnumerator();
            while (checklistEnumerator.moveNext())
            {
                checklistRecIds += checklistEnumerator.currentKey();
            }

            tasksQuery = RetailTransactionServiceTaskManagement::generateQueryForChecklistTasks(checklistRecIds);
            tasksQueryRun = new QueryRun(tasksQuery);
            while (tasksQueryRun.next())
            {
                CLRObject tasks;
                taskTable = tasksQueryRun.get(tableNum(BusinessProcessTask));

                if (checklist == null || checklist.get_RecordId() != taskTable.ProcessHeader)
                {
                    checklist = _checklistMap.lookup(taskTable.ProcessHeader);
                }

                tasks = checklist.get_Tasks();
                tasks.Add(RetailTransactionServiceTaskManagement::createChecklistTaskFromTables(null, taskTable, null, true));
                ++taskCount;
            }
        }
        return taskCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChecklistsByIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the checklists by ids.
    /// </summary>
    /// <param name="_requestChecklistIds">
    /// The container which contains the checklist ids.
    /// </param>
    /// <returns>
    /// A container with 3 elements. The 3rd element is the serialized JSON string of an array of Microsoft.Dynamics.Commerce.Runtime.DataModel.Checklist.
    /// </returns>
    /// <remarks>
    /// Used by Channel to get the latest information of the checklists to do validations before updating checklists.
    /// </remarks>
    private static container getChecklistsByIds(container _requestChecklistIds)
    {
        Microsoft.Dynamics.Ax.Xpp.ErrorException    xppEx;
        System.Exception                            netEx;

        container checklistsResult = [true,''];

        // Core logic
        try
        {
            eventSource.EventWriteGetChecklistsByIdsStart(con2Str(_requestChecklistIds));

            System.Collections.ArrayList checklistList = new System.Collections.ArrayList();

            Query query = new Query();
            // Don't have any filters for assigned to or status
            container checklistStatuses = [BusinessProcessHeaderStatus::NotStarted, BusinessProcessHeaderStatus::InProgress, BusinessProcessHeaderStatus::Completed, BusinessProcessHeaderStatus::Canceled];
            QueryBuildDataSource checklistQueryBuildDataSource = RetailTransactionServiceTaskManagement::addChecklistDataSource(query, 0, 0, checklistStatuses, false, false);

            // Filter and sort by checklist id
            for (int i = 1; i <= conLen(_requestChecklistIds); ++i)
            {
                guid checklistId = str2Guid(conPeek(_requestChecklistIds, i));
                checklistQueryBuildDataSource.addRange(fieldNum(BusinessProcessHeader, ProcessId)).value(queryValue(checklistId));
            }
            checklistQueryBuildDataSource.addOrderByField(fieldNum(BusinessProcessHeader, ProcessId), SortOrder::Ascending);

            Map checklistMap = new Map(Types::Int64, Types::AnyType);
            QueryRun checklistQueryRun = new QueryRun(query);
            BusinessProcessHeader checklistTable;
            Checklist checklist;
            while (checklistQueryRun.next())
            {
                checklistTable = checklistQueryRun.get(tableNum(BusinessProcessHeader));
                checklist = RetailTransactionServiceTaskManagement::createChecklistFromChecklistTable(checklistTable);
                checklistList.Add(checklist);
                checklistMap.insert(checklistTable.RecId, checklist);
            }

            // Get the tasks of the checklists
            int taskCount = RetailTransactionServiceTaskManagement::fillChecklistTasks(checklistMap);

            eventSource.EventWriteGetChecklistsByIdsStop(con2Str(_requestChecklistIds), checklistList.get_Count(), taskCount);

            // Serialize
            System.Type[] typeArray = new System.Type[1]();
            System.Type checklistType = new Checklist().GetType();
            typeArray.SetValue(checklistType, 0);
            checklistsResult += RetailTransactionServiceJsonHelper::SerializeToJson(checklistList, typeArray);

            return checklistsResult;
        }
        catch (xppEx)
        {
            str errorMessage = xppEx.ToString();
            eventSource.EventWriteGetChecklistsByIdsParameterError(con2Str(_requestChecklistIds), errorMessage);
            checklistsResult = [false, "@RET2382"];
            return checklistsResult;
        }
        catch (netEx)
        {
            str errorMessage = netEx.ToString();
            eventSource.EventWriteGetChecklistsByIdsParameterError(con2Str(_requestChecklistIds), errorMessage);
            checklistsResult = [false, "@RET2382"];
            return checklistsResult;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTasksByIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tasks by ids.
    /// </summary>
    /// <param name="_requestTaskIds">
    /// The container which contains the task ids.
    /// </param>
    /// <returns>
    /// A container with 3 elements. The 3rd element is the serialized JSON string of an array of Microsoft.Dynamics.Commerce.Runtime.DataModel.ChecklistTask.
    /// </returns>
    /// <remarks>
    /// Used by Channel to get the latest information of the tasks to do validations before updating tasks.
    /// </remarks>
    private static container getTasksByIds(container _requestTaskIds)
    {
        container tasksResult = [true,''];

        Microsoft.Dynamics.Ax.Xpp.ErrorException    xppEx;
        System.Exception                            netEx;

        // Core logic
        try
        {
            eventSource.EventWriteGetTasksByIdsStart(con2Str(_requestTaskIds));

            System.Collections.ArrayList checklistTaskList = new System.Collections.ArrayList();

            Query query = new Query();
            // Don't have any filters for assigned to or status
            container checklistStatuses = [BusinessProcessHeaderStatus::NotStarted, BusinessProcessHeaderStatus::InProgress, BusinessProcessHeaderStatus::Completed, BusinessProcessHeaderStatus::Canceled];
            QueryBuildDataSource checklistQueryBuildDataSource = RetailTransactionServiceTaskManagement::addChecklistDataSource(query, 0, 0, checklistStatuses, false, false);

            checklistQueryBuildDataSource.addSelectionField(fieldNum(BusinessProcessHeader, RetailChannel));
            checklistQueryBuildDataSource.addSelectionField(fieldNum(BusinessProcessHeader, HcmWorker));
            checklistQueryBuildDataSource.addSelectionField(fieldNum(BusinessProcessHeader, Name));
            checklistQueryBuildDataSource.addSelectionField(fieldNum(BusinessProcessHeader, ProcessId));

            QueryBuildDataSource    taskQueryBuildDataSource    = RetailTransactionServiceTaskManagement::joinTaskTable(checklistQueryBuildDataSource);
            QueryBuildDataSource    workerQueryBuildDataSource  = RetailTransactionServiceTaskManagement::joinHcmWorker(taskQueryBuildDataSource);
            QueryBuildDataSource    personQueryBuildDataSource  = RetailTransactionServiceTaskManagement::joinDirPerson(workerQueryBuildDataSource);

            // Filter and sort by task ID
            for (int i = 1; i <= conLen(_requestTaskIds); ++i)
            {
                guid taskId = str2Guid(conPeek(_requestTaskIds, i));
                taskQueryBuildDataSource.addRange(fieldNum(BusinessProcessTask, TaskId)).value(queryValue(taskId));
            }
            taskQueryBuildDataSource.addOrderByField(fieldNum(BusinessProcessTask, TaskId), SortOrder::Ascending);

            QueryRun qr = new QueryRun(query);
            BusinessProcessTask taskTable;
            BusinessProcessHeader checklistTable;
            HcmWorker hcmWorker;
            while (qr.next())
            {
                checklistTable = qr.get(tableNum(BusinessProcessHeader));
                taskTable = qr.get(tableNum(BusinessProcessTask));
                hcmWorker = qr.get(tableNum(HcmWorker));
                checklistTaskList.Add(RetailTransactionServiceTaskManagement::createChecklistTaskFromTables(
                    checklistTable,
                    taskTable,
                    hcmWorker
                    ));
            }

            eventSource.EventWriteGetTasksByIdsStop(con2Str(_requestTaskIds), checklistTaskList.get_Count());

            // Serialize
            System.Type[] typeArray = new System.Type[1]();
            System.Type checklistTaskType = new ChecklistTask().GetType();
            typeArray.SetValue(checklistTaskType, 0);
            tasksResult += RetailTransactionServiceJsonHelper::SerializeToJson(checklistTaskList, typeArray);

            return tasksResult;
        }
        catch (xppEx)
        {
            str errorMessage = xppEx.ToString();
            eventSource.EventWriteGetTasksByIdsError(con2Str(_requestTaskIds), errorMessage);
            tasksResult = [false, "@RET2382"];
            return tasksResult;
        }
        catch (netEx)
        {
            str errorMessage = netEx.ToString();
            eventSource.EventWriteGetTasksByIdsError(con2Str(_requestTaskIds), errorMessage);
            tasksResult = [false, "@RET2382"];
            return tasksResult;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>