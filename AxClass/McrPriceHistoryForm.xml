<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>MCRPriceHistoryForm</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>MCRPriceHistoryForm</c> class handles the logic to populate
/// the price details form with the appropriate values.
/// </summary>
class McrPriceHistoryForm
{
    MCRPriceHistoryLine     mcrPriceHistoryLine;

    MCRPriceHistory         mcrPriceHistoryItemPrice;

    // Temp tables
    MCRPriceHistory         mcrPriceHistory;
    MCRPriceHistory         mcrPriceHistoryPotential;
    MCRPriceHistory         tradePrices;
    TmpMCRAgreementLine     tmpMCRAgreementLine;

    // Maps for display methods
    Map                     mapHistoryToExtendedAmount;
    Map                     mapHistoryToActualDisc;
    Map                     mapHistoryToActualDiscPercent;
    Map                     mapPotentialToExtendedAmount;
    Map                     mapMerchIdToPromotionId;
    Map                     mapMerchIdToMerchDescription;
    Map                     mapMerchIdToPromotionDescription;
    Map                     mapQtyToPrice;

    // General line information
    SalesId                 salesId;
    PurchId                 purchId;
    QuotationId             quotationId;
    Qty                     qty;
    UnitOfMeasureSymbol     unitId;
    PriceUnit               priceUnit;
    PriceCur                itemPrice;

    // Discount combination
    DiscAmount              lineDiscAmount;
    DiscAmount              multilineDiscAmount;
    DiscPct                 lineDiscPct;
    DiscPct                 lineDiscPct1;
    DiscPct                 lineDiscPct2;
    DiscPct                 multilineDiscPct;
    DiscPct                 multilineDiscPct1;
    DiscPct                 multilineDiscPct2;

    // Base values for price calculation
    PriceCur                unitPrice;
    PriceMarkup             priceMarkup;

    // Extended unit price for price calculation
    PriceCur                unitPriceExtendedUnitPrice;
    PriceCur                discAmountExtendedUnitPrice;
    PriceCur                markupExtendedUnitPrice;
    PriceCur                discPctExtendedUnitPrice;
    PriceCur                perciseDiscPctExtendedUnitPrice;

    // Extended amount for price calculation
    AmountCur               unitPriceExtendedAmount;
    AmountCur               discAmountExtendedAmount;
    AmountCur               preciseDiscAmountExtendedAmount;
    AmountCur               markupExtendedAmount;
    AmountCur               discPctExtendedAmount;
    AmountCur               preciseDiscPctExtendedAmount;

    private MCRPriceInstrumentationLogger instrumentationLogger;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates price per unit and extended amount for every trade agreement.
    /// </summary>
    /// <remarks>
    ///     Main calc method that should be called from elsewhere in class.
    ///     Calculate amounts for showing steps in amount calculation on form (e.g, DiscAmount,
    ///     PricePerUnitDiscAmount, ExtendedAmountDiscAmount).
    ///     Calculate potential trade agreements.
    /// </remarks>
    private void calc()
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().priceHistoryActivities().calc())
        {
            // Initialize qty and unit
            this.setQty(mcrPriceHistoryLine.parmQty());
            this.setUnitId(mcrPriceHistoryLine.parmUnitId());

            // Initialize linked agreement line if exists
            this.initTmpMCRAgreementLine(tmpMCRAgreementLine);
            if (tmpMCRAgreementLine.AgreementId)
            {
                tmpMCRAgreementLine.insert();
            }

            // Initialize list with found trade agreements
            this.insertPriceHistory();

            // Calculate base item price
            this.calcItem();

            // Set the starting price to use as beginning point for trade agreements
            this.setUnitPrice(this.retrieveInitialUnitPrice());

            this.updateExtendedAmount();

            this.setExtendedAmountAndDiscounts();

            if (!this.shouldSkipCalcPotential())
            {
                // Calculate potential. Must come after calculation of trade price and discounts.
                this.calcPotential();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipCalcPotential</Name>
				<Source><![CDATA[
    private boolean shouldSkipCalcPotential()
    {
        return McrPriceHistoryLineSkipCalcPotentialContextFlight::instance().isEnabled()
            && McrPriceHistoryLineSkipCalcPotentialContext::current();
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveInitialUnitPrice</Name>
				<Source><![CDATA[
    private PriceCur retrieveInitialUnitPrice()
    {
        PriceCur linePrice;
        PriceCur baseItemPrice;
        PriceCur initialUnitPrice;
        boolean  tradePriceFound;
        boolean  priceFound;

        linePrice     = mcrPriceHistoryLine.parmPrice();
        baseItemPrice = this.getItemPrice();

        priceFound = false;

        // If a price override, then the line price is the one to use.
        if (mcrPriceHistoryLine.parmPriceOverride())
        {
            initialUnitPrice = linePrice;
            priceFound       = true;
        }

        // If the base price is the same as the line's price, then no trade agreement
        // price was used.  Can initialize unit price to base price.
        if (!priceFound && linePrice == baseItemPrice)
        {
            initialUnitPrice = baseItemPrice;
            priceFound       = true;
        }

        // If the line's price is non-zero, but is not equal to base item price, then
        // compare to found trade agreements.
        if (!priceFound && linePrice)
        {
            tradePriceFound = false;
            while select mcrPriceHistory
                where mcrPriceHistory.PriceHistoryType == MCRPriceHistoryType::TradePrice
            {
                if (mcrPriceHistory.price() == linePrice)
                {
                    tradePriceFound = true;
                }
            }

            if (tradePriceFound)
            {
                // If price comes from a trade agreement, then initialize the unit price
                // to the base item price.  Price will be updated as trade agreements are
                // processed.
                initialUnitPrice = baseItemPrice;
            }
            else
            {
                // If no equivalent trade price found, then assume the price was manually
                // overridden and use the line price.
                initialUnitPrice = linePrice;
            }
        }

        EventHandlerResult initialUnitPriceResult = EventHandlerResult::newSingleResponse();
        this.retrieveInitialUnitPriceDelegate(mcrPriceHistoryLine, initialUnitPrice, this, initialUnitPriceResult);
        if (initialUnitPriceResult.hasResult())
        {
            return initialUnitPriceResult.result();
        }
        else
        {
            return initialUnitPrice;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcExtendedAmount</Name>
				<Source><![CDATA[
    private AmountCur calcExtendedAmount()
    {
        DiscPct             discPct;
        AmountCur extendedAmount;

        discPct = PriceDisc::discPercent(
                mcrPriceHistoryLine.parmLineMultiLn(),
                this.combineDiscPct(this.parmLineDiscPct1(), this.parmLineDiscPct2()),
                this.combineDiscPct(this.parmMultiLineDiscPct1(), this.parmMultiLineDiscPct2()));

        extendedAmount = this.price2Amount(
                this.getUnitPrice(),
                this.getDiscAmount(),
                this.getMarkup(),
                discPct);

        return extendedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveExtendedAmount</Name>
				<Source><![CDATA[
    private AmountCur retrieveExtendedAmount(MCRPriceHistory _mcrPriceHistory)
    {
        AmountCur extendedAmount;
        Qty absQty = abs(this.getQty());

        switch (_mcrPriceHistory.PriceHistoryType)
        {
            case MCRPriceHistoryType::TradePrice:
                extendedAmount = this.calcPriceAmount(
                    absQty,
                    _mcrPriceHistory.price(),
                    _mcrPriceHistory.priceUnit(),
                    _mcrPriceHistory.markup());

                this.setUnitPrice(_mcrPriceHistory.price());
                this.setPriceUnit(_mcrPriceHistory.priceUnit());
                this.setMarkup(_mcrPriceHistory.markup());

                // Also save price trade agreements in a separate table for finding prices later.
                tradePrices.data(_mcrPriceHistory);
                tradePrices.insert();
                extendedAmount = this.calcExtendedAmount();
                break;

            case MCRPriceHistoryType::LineDisc:
                this.setLineDiscAmount(this.getLineDiscAmount() + mcrPriceHistory.Amount);
                this.parmLineDiscPct1(this.parmLineDiscPct1() + mcrPriceHistory.Percent1);
                this.parmLineDiscPct2(this.parmLineDiscPct2() + mcrPriceHistory.Percent2);
                extendedAmount = this.calcExtendedAmount();
                break;

            case MCRPriceHistoryType::MultiLineDisc:
                this.setMultilineDiscAmount(this.getMultilineDiscAmount() + mcrPriceHistory.Amount);
                this.parmMultiLineDiscPct1(this.parmMultiLineDiscPct1() + mcrPriceHistory.Percent1);
                this.parmMultiLineDiscPct2(this.parmMultiLineDiscPct2() + mcrPriceHistory.Percent2);
                extendedAmount = this.calcExtendedAmount();
                break;

            default:
                EventHandlerResult result = EventHandlerResult::newSingleResponse();
                this.retrieveExtendedAmountDelegate(this, _mcrPriceHistory, result);
                if (result.hasResult())
                {
                    extendedAmount = result.result();
                }
                else
                {
                    extendedAmount = 0;
                }
                break;
        }

        return extendedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExtendedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates extended amount and price per unit
    /// </summary>
    private void updateExtendedAmount()
    {
        Qty absQty = abs(this.getQty());
        AmountCur extendedAmount;


        // mcrPriceHistory is a temp table
        while select mcrPriceHistory
            order by QuantityAmount, PriceHistoryType asc
        {
            extendedAmount = this.retrieveExtendedAmount(mcrPriceHistory);

            // Update extended amount and price per unit
            PriceCur pricePerUnit;
            if (absQty)
            {
                pricePerUnit = extendedAmount / absQty;
                mcrPriceHistory.PriceHistoryUnitPrice = pricePerUnit;
                mcrPriceHistory.update();
            }
            this.storeAmounts(mcrPriceHistory.RecId,
                              extendedAmount,
                              false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveExtendedAmountDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for calculating item price from history and convert to line's currency.
    /// </summary>
    /// <param name = "_mcrPriceHistory">The <c>MCRPriceHistory</c> record.</param>
    /// <param name = "_mcrPriceHistoryForm">The <c>MCRPriceHistoryForm</c> instance.</param>
    /// <param name = "_result">Subscribers can use this class to provide the result.</param>
    delegate void retrieveExtendedAmountDelegate(MCRPriceHistoryForm _mcrPriceHistoryForm, MCRPriceHistory _mcrPriceHistory, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExtendedAmountAndDiscounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the extended amount and discounts.
    /// </summary>
    private void setExtendedAmountAndDiscounts()
    {
        this.setInitialAmountDisc();

        // Calculate trade price extended amount (don't include markup or any discounts)
        this.setUnitPriceExtendedAmount(this.price2Amount(this.getUnitPrice(), 0, 0, 0));

        // Calculate discount amount extended amount (don't include markup or discount percentage).
        this.setDiscAmountExtendedAmount(this.price2Amount(
            this.getUnitPrice(),
            this.getDiscAmount(),
            0,
            0));

        // Calculate markup extended amount.  Includes everything except discount percent.
        this.setMarkupExtendedAmount(this.price2Amount(
            this.getUnitPrice(),
            this.getDiscAmount(),
            this.getMarkup(),
            0));

        // Calculate discount percent extended amount (final amount).  Use combined line percentages.
        this.setDiscPctExtendedAmount(this.price2Amount(
            this.getUnitPrice(),
            this.getDiscAmount(),
            this.getMarkup(),
            PriceDisc::discPercent(
                this.getLineMultiLn(),
                this.getLineDiscPct(),
                this.getMultilineDiscPct())));

        // Calculate precise discount percent extended amount (final amount) .  Use combined line percentages.
        this.setPreciseDiscPctExtendedAmount(
            McrPriceHistoryForm::precisePrice2Amount(
                this.getUnitPrice(),
                this.getPriceUnit(),
                this.getDiscAmount(),
                this.getQty(),
                0,
                this.getMarkup(),
                PriceDisc::discPercent(
                    this.getLineMultiLn(),
                    this.getLineDiscPct(),
                    this.getMultilineDiscPct()),
                this.getCurrencyCode(),
                0,
                true));

        // Calculate price per unit
        Qty  absQty  = abs(this.getQty());
        if (absQty)
        {
            this.setUnitPriceExtendedUnitPrice(this.getUnitPriceExtendedAmount()   / absQty);
            this.setDiscAmountExtendedUnitPrice(this.getDiscAmountExtendedAmount() / absQty);
            this.setMarkupExtendedUnitPrice(this.getMarkupExtendedAmount()         / absQty);
            this.setDiscPctExtendedUnitPrice(this.getDiscPctExtendedAmount()       / absQty);

            this.setPreciseDiscPctExtendedUnitPrice(this.getPreciseDiscPctExtendedAmount() / absQty);
        }

        this.settingExtendedAmountAndDiscounts(this, mcrPriceHistory, mcrPriceHistoryLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>settingExtendedAmountAndDiscounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for calculating item price from history and convert to line's currency.
    /// </summary>
    /// <param name = "_mcrPriceHistoryForm">The <c>MCRPriceHistoryForm</c> instance.</param>
    /// <param name = "_mcrPriceHistory">The <c>MCRPriceHistory</c> record.</param>
    /// <param name = "_mcrPriceHistoryLine">The <c>MCRPriceHistoryLine</c> record.</param>
    delegate void settingExtendedAmountAndDiscounts(MCRPriceHistoryForm _mcrPriceHistoryForm, MCRPriceHistory _mcrPriceHistory, MCRPriceHistoryLine _mcrPriceHistoryLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInitialAmountDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the price, units and discounts from the history <c>MCRPriceHistoryLine</c>.
    /// </summary>
    private void setInitialAmountDisc()
    {
        // After the trade agreement values for price per unit and extended amount are calculated,
        // the final header values should use actual price history line values. 
        // This ensures that the header has correct values, in case the amounts are not added up correctly from trade agreements.
        this.setUnitPrice(mcrPriceHistoryLine.parmPrice());
        this.setPriceUnit(mcrPriceHistoryLine.parmPriceUnit());
        this.setMarkup(mcrPriceHistoryLine.parmMarkup());
        this.setLineDiscAmount(mcrPriceHistoryLine.parmLineDiscAmount());
        this.setLineDiscPct(mcrPriceHistoryLine.parmLineDiscPct());
        this.setMultilineDiscAmount(mcrPriceHistoryLine.parmMultilineDiscAmount());
        this.setMultilineDiscPct(mcrPriceHistoryLine.parmMultilineDiscPct());

        this.settingInitialAmountDisc(this, mcrPriceHistoryLine);

    }

]]></Source>
			</Method>
			<Method>
				<Name>settingInitialAmountDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for calculating item price from history and convert to line's currency.
    /// </summary>
    /// <param name = "_mcrPriceHistoryForm">The <c>MCRPriceHistoryForm</c> instance.</param>
    /// <param name = "_mcrPriceHistoryLine">The <c>MCRPriceHistoryLine</c> record.</param>
    /// <param name = "_result">Subscribers can use this class to provide the result.</param>
    delegate void settingInitialAmountDisc(MCRPriceHistoryForm _mcrPriceHistoryForm, MCRPriceHistoryLine _mcrPriceHistoryLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcItem</Name>
				<Source><![CDATA[
    private void calcItem()
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().priceHistoryActivities().calcItem())
        {
            // Set item price from history and convert to line's currency
            EventHandlerResult itemPriceResult = EventHandlerResult::newSingleResponse();
            this.calcItemPriceFromHistoryDelegate(mcrPriceHistoryItemPrice, mcrPriceHistoryLine, itemPriceResult);
            if (itemPriceResult.hasResult())
            {
                this.setItemPrice(itemPriceResult.result());
            }
        
            // Set markup from history and convert to line's currency
            EventHandlerResult markUpResult = EventHandlerResult::newSingleResponse();
            this.calcMarkupFromHistoryDelegate(mcrPriceHistoryItemPrice, mcrPriceHistoryLine, markUpResult);
            if (markUpResult.hasResult())
            {
                this.setMarkup(markUpResult.result());
            }
        
            // Set price unit from history
            this.setPriceUnit(mcrPriceHistoryItemPrice.priceUnit());

            // Convert from base unit to line's unit.
            // Note that given parameter names of method the units appear backwards.  See PriceDisc findItemPrice for similar call.
            Qty absQty = abs(this.getQty());
            InventTableModule   inventTableModule;
            // Find unit defined for line's module
            select UnitId from inventTableModule
                where inventTableModule.ItemId     == this.getItemId()
                   && inventTableModule.ModuleType == mcrPriceHistoryLine.parmModuleType();

            EcoResProductUnitConverter ecoResProductUnitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(this.getItemId(),
                                                                                                                                      this.getInventDim().inventDimId,
                                                                                                                                      this.getUnitId(),
                                                                                                                                      inventTableModule.UnitId,
                                                                                                                                      NoYes::Yes);

            this.setItemPrice(ecoResProductUnitConverter.convertValue(this.getItemPrice()));
            this.setMarkup(ecoResProductUnitConverter.convertValue(this.getMarkup()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcItemPriceFromHistoryDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for calculating item price from history and convert to line's currency.
    /// </summary>
    /// <param name = "_mcrPriceHistory">The <c>MCRPriceHistory</c> record.</param>
    /// <param name = "_mcrPriceHistoryLine">The <c>MCRPriceHistoryLine</c> instance.</param>
    /// <param name = "_eventHandlerResult">Subscribers can use this class to provide the result.</param>
    delegate void calcItemPriceFromHistoryDelegate(MCRPriceHistory _mcrPriceHistory, MCRPriceHistoryLine _mcrPriceHistoryLine, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcItemPriceFromHistoryDelegateHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the item price from history and convert to line's currency.
    /// </summary>
    /// <param name = "_mcrPriceHistory">The <c>MCRPriceHistory</c> record.</param>
    /// <param name = "_mcrPriceHistoryLine">The <c>MCRPriceHistoryLine</c> instance.</param>
    /// <param name = "_eventHandlerResult">Subscribers can use this class to provide the result.</param>
    [SubscribesTo(classStr(McrPriceHistoryForm), delegateStr(McrPriceHistoryForm, calcItemPriceFromHistoryDelegate))]
    public static void calcItemPriceFromHistoryDelegateHandler(MCRPriceHistory _mcrPriceHistory, MCRPriceHistoryLine _mcrPriceHistoryLine, EventHandlerResult _eventHandlerResult)
    {
        PriceCur itemPrice;

        itemPrice = ExchangeRateHelper::curPrice2CurPrice(_mcrPriceHistory.price(), _mcrPriceHistory.Currency, _mcrPriceHistoryLine.parmCurrencyCode());
        itemPrice = CurrencyExchangeHelper::price(itemPrice, _mcrPriceHistoryLine.parmCurrencyCode());

        _eventHandlerResult.result(itemPrice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMarkupFromHistoryDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for calculating markup from history and convert to line's currency.
    /// </summary>
    /// <param name = "_mcrPriceHistory">The <c>MCRPriceHistory</c> record.</param>
    /// <param name = "_mcrPriceHistoryLine">The <c>MCRPriceHistoryLine</c> instance.</param>
    /// <param name = "_eventHandlerResult">Subscribers can use this class to provide the result.</param>
    delegate void calcMarkupFromHistoryDelegate(MCRPriceHistory _mcrPriceHistory, MCRPriceHistoryLine _mcrPriceHistoryLine, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMarkupFromHistoryDelegateHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the item price from history and convert to line's currency.
    /// </summary>
    /// <param name = "_mcrPriceHistory">The <c>MCRPriceHistory</c> record.</param>
    /// <param name = "_mcrPriceHistoryLine">The <c>MCRPriceHistoryLine</c> instance.</param>
    /// <param name = "_eventHandlerResult">Subscribers can use this class to provide the result.</param>
    [SubscribesTo(classStr(McrPriceHistoryForm), delegateStr(McrPriceHistoryForm, calcMarkupFromHistoryDelegate))]
    public static void calcMarkupFromHistoryDelegateHandler(MCRPriceHistory _mcrPriceHistory, MCRPriceHistoryLine _mcrPriceHistoryLine, EventHandlerResult _eventHandlerResult)
    {
        PriceMarkup markup;

        markup = ExchangeRateHelper::curPrice2CurPrice(_mcrPriceHistory.markup(), Ledger::accountingCurrency(CompanyInfo::current()), _mcrPriceHistoryLine.parmCurrencyCode());
        markup = CurrencyExchangeHelper::price(markup, _mcrPriceHistoryLine.parmCurrencyCode());

        _eventHandlerResult.result(markup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPotential</Name>
				<Source><![CDATA[
    private void calcPotential()
    {
        ModuleInventPurchSales  module;
        AmountCur               extendedAmount;
        PriceCur                pricePerUnit;
        DiscAmount              localDiscAmount;
        DiscPct                 localDiscPct;
        PriceMarkup             localMarkup;
        PriceCur                localPrice;
        PriceUnit               localPriceUnit;
        Qty                     localQty;

        MCRPriceHistory         mcrPriceHistoryPotentialTmpLocal;
        RefRecId                refRecId;
        MCRPriceHistory         mcrPriceHistoryPrice;
        
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().priceHistoryActivities().calcPotential())
        {
            if (this.mustInsertPotentialTradeAgreements())
            {
                // Find potential trade agreements and add them to potential temp table.
                this.insertPotentialTradeAgreements();
            }

            // Find potential merchandising event and add them to potential temp table.
            if (mcrPriceHistoryLine.parmCanFindTAMMerchEventPricing())
            {
                this.insertPotentialMerchEventPricing();
            }

            module = mcrPriceHistoryLine.parmModuleType();

            refRecId = this.insertPotentialEndRanges(mcrPriceHistoryPotentialTmpLocal);

            // Clear class potential table.  Will fill in next loop using local table.
            delete_from mcrPriceHistoryPotential;

            MCRPriceHistoryPotentialDiscount mcrPriceHistoryPotentialDiscount = MCRPriceHistoryPotentialDiscount::construct();

            // Iterate through local table that contains two records for each agreement, one
            // for from quantity and one for to quantity
            while select mcrPriceHistoryPotentialTmpLocal
                order by QuantityAmount asc, PriceHistoryPotentialType desc
            {
                // Save current quantity break.  Possible that several trade agreements have same
                // from/to quantity breaks.  In this case need to take lowest price but still add discounts
                localQty = mcrPriceHistoryPotentialTmpLocal.QuantityAmount;

                this.updateMCRPriceHistoryPotentialDiscount(mcrPriceHistoryPotentialTmpLocal, mcrPriceHistoryPotentialDiscount);

                localDiscAmount = PriceDisc::discAmount(
                    this.getLineMultiLn(),
                    mcrPriceHistoryPotentialDiscount.totalDiscAmount,
                    mcrPriceHistoryPotentialDiscount.totalMultiLnDiscAmount);
                localDiscPct = PriceDisc::discPercent(
                    this.getLineMultiLn(),
                    this.combineDiscPct(mcrPriceHistoryPotentialDiscount.totalDiscPct1, mcrPriceHistoryPotentialDiscount.totalDiscPct2),
                    this.combineDiscPct(mcrPriceHistoryPotentialDiscount.totalMultiLnDiscPct1, mcrPriceHistoryPotentialDiscount.totalMultiLnDiscPct2));

                if (mcrPriceHistoryLine.parmQty() < 0)
                {
                    localQty = localQty * -1;
                }

                // Find the price, unit, and markup for the current quantity.
                mcrPriceHistoryPrice    = this.findPotentialPrice(localQty, mcrPriceHistoryPotentialTmpLocal.PriceHistoryPotentialType);
                localPrice              = mcrPriceHistoryPrice.price();
                localPriceUnit          = mcrPriceHistoryPrice.priceUnit();
                localMarkup             = mcrPriceHistoryPrice.markup();

                mcrPriceHistoryPotential.data(mcrPriceHistoryPotentialTmpLocal);

                // Calculate the total amount and price per unit.
                extendedAmount = PriceDisc::price2Amount(
                    localPrice,
                    localPriceUnit,
                    localDiscAmount,
                    localQty,
                    0,
                    localMarkup,
                    localDiscPct,
                    this.getCurrencyCode(),
                    0,
                    true);
                if (mcrPriceHistoryPotential.QuantityAmount)
                {
                    pricePerUnit = extendedAmount / mcrPriceHistoryPotential.QuantityAmount;
                    mcrPriceHistoryPotential.PriceHistoryUnitPrice = pricePerUnit;
                }

                // To allow sorting in order
                mcrPriceHistoryPotential.RefRecId = refRecId;
                refRecId++;

                mcrPriceHistoryPotential.insert();

                this.storeAmounts(mcrPriceHistoryPotential.RecId,
                                  extendedAmount,
                                  true);

                if (this.mustStorePotentialDiscounts(mcrPriceHistoryPotential.RecId, mcrPriceHistoryPotentialTmpLocal))
                {
                    this.storePotentialDiscounts(mcrPriceHistoryPotential.RecId, localDiscAmount, localDiscPct);
                }
            }

            this.removeDuplicatePotential();

            this.combineIdenticalEndRanges();

            this.insertPotentialForHighestToQty(refRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustInsertPotentialTradeAgreements</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Determines whether the potential trade agreements must be inserted.
    /// </summary>
    /// <returns>
    ///		true if potential trade agreements must be inserted; otherwise, false.
    /// </returns>
    protected boolean mustInsertPotentialTradeAgreements()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustStorePotentialDiscounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Determines whether the price per unit and extended amounts must be stored.
    /// </summary>
    /// <param name="_mcrPriceHistoryRecId">
    ///     The <c>RecId</c> of the price history record.
    /// </param>
    /// <param name="_mcrPriceHistoryPotentialTmpLocal">
    ///     The temporary potential record.
    /// </param>
    /// <returns>
    ///		true if the price per unit and extended amounts must be stored; otherwise, false.
    /// </returns>
    protected boolean mustStorePotentialDiscounts(RecId _mcrPriceHistoryRecId, MCRPriceHistory _mcrPriceHistoryPotentialTmpLocal)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMCRPriceHistoryPotentialDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the discount based on the temporary potential record.
    /// </summary>
    /// <param name = "_mcrPriceHistoryPotentialTmpLocal">
    ///     The temporary potential record.
    /// </param>
    /// <param name = "_mcrPriceHistoryPotentialDiscount">
    ///     An instance of the <c>MCRPriceHistoryPotentialDiscount</c> class.
    /// </param>
    protected void updateMCRPriceHistoryPotentialDiscount(
        MCRPriceHistory                     _mcrPriceHistoryPotentialTmpLocal, 
        MCRPriceHistoryPotentialDiscount    _mcrPriceHistoryPotentialDiscount)
    {
        switch (_mcrPriceHistoryPotentialTmpLocal.PriceHistoryPotentialType)
        {
            case MCRPriceHistoryPotentialType::LineDiscFrom:
                _mcrPriceHistoryPotentialDiscount.totalDiscAmount += _mcrPriceHistoryPotentialTmpLocal.Amount;
                _mcrPriceHistoryPotentialDiscount.totalDiscPct1   += _mcrPriceHistoryPotentialTmpLocal.Percent1;
                _mcrPriceHistoryPotentialDiscount.totalDiscPct2   += _mcrPriceHistoryPotentialTmpLocal.Percent2;
                break;

            case MCRPriceHistoryPotentialType::LineDiscTo:
                // if a quantityTo and discount, then subtract discounts so on next unique
                // quantity break they will no longer exist
                _mcrPriceHistoryPotentialDiscount.totalDiscAmount -= _mcrPriceHistoryPotentialTmpLocal.Amount;
                _mcrPriceHistoryPotentialDiscount.totalDiscPct1   -= _mcrPriceHistoryPotentialTmpLocal.Percent1;
                _mcrPriceHistoryPotentialDiscount.totalDiscPct2   -= _mcrPriceHistoryPotentialTmpLocal.Percent2;
                break;

            case MCRPriceHistoryPotentialType::MultiLineDiscFrom:
                _mcrPriceHistoryPotentialDiscount.totalMultiLnDiscAmount += _mcrPriceHistoryPotentialTmpLocal.Amount;
                _mcrPriceHistoryPotentialDiscount.totalMultiLnDiscPct1   += _mcrPriceHistoryPotentialTmpLocal.Percent1;
                _mcrPriceHistoryPotentialDiscount.totalMultiLnDiscPct2   += _mcrPriceHistoryPotentialTmpLocal.Percent2;
                break;

            case MCRPriceHistoryPotentialType::MultiLineDiscTo:
                // Same subtraction logic for multiline
                _mcrPriceHistoryPotentialDiscount.totalMultiLnDiscAmount -= _mcrPriceHistoryPotentialTmpLocal.Amount;
                _mcrPriceHistoryPotentialDiscount.totalMultiLnDiscPct1   -= _mcrPriceHistoryPotentialTmpLocal.Percent1;
                _mcrPriceHistoryPotentialDiscount.totalMultiLnDiscPct2   -= _mcrPriceHistoryPotentialTmpLocal.Percent2;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPriceAmount</Name>
				<Source><![CDATA[
    private AmountCur calcPriceAmount(
        Qty         _absQty,
        PriceCur    _price,
        PriceUnit   _priceUnit,
        PriceMarkup _priceMarkup)
    {
        return CurrencyExchangeHelper::amount(_absQty * _price / _priceUnit + abs(_priceMarkup), this.getCurrencyCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>combineDiscPct</Name>
				<Source><![CDATA[
    private DiscPct combineDiscPct(DiscPct _percent1, DiscPct _percent2)
    {
        return (100 * (1 - (1 - _percent1 / 100) * (1 - _percent2 / 100)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>combineIdenticalEndRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Combines end range potential records into a single combined range if the quantity is identical.
    /// </summary>
    private void combineIdenticalEndRanges()
    {
        MCRPriceHistory         mcrPriceHistoryPotentialTmpLocal;

        mcrPriceHistoryPotentialTmpLocal.setTmp();
        mcrPriceHistoryPotentialTmpLocal.setTmpData(mcrPriceHistoryPotential);

        // For identical end ranges, keep the highest unit price as lower unit prices may have been calculated
        // before all discounts were removed.
        while select forupdate mcrPriceHistoryPotential
            order by PriceHistoryUnitPrice desc
            where mcrPriceHistoryPotential.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::LineDiscTo
               || mcrPriceHistoryPotential.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::MultiLineDiscTo
               || mcrPriceHistoryPotential.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::TradePriceTo
            join mcrPriceHistoryPotentialTmpLocal
                where (mcrPriceHistoryPotentialTmpLocal.PriceHistoryPotentialType    == MCRPriceHistoryPotentialType::LineDiscTo
                       || mcrPriceHistoryPotentialTmpLocal.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::MultiLineDiscTo
                       || mcrPriceHistoryPotentialTmpLocal.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::TradePriceTo)
                      && mcrPriceHistoryPotentialTmpLocal.QuantityAmount == mcrPriceHistoryPotential.QuantityAmount
                      && mcrPriceHistoryPotentialTmpLocal.RecId          != mcrPriceHistoryPotential.RecId
        {
            if (mcrPriceHistoryPotential.PriceHistoryPotentialType != MCRPriceHistoryPotentialType::EndRange)
            {
                // Since it's a combined end, clear out amounts and discounts
                mcrPriceHistoryPotential.PriceHistoryPotentialType = MCRPriceHistoryPotentialType::EndRange;
                mcrPriceHistoryPotential.Amount   = 0;
                mcrPriceHistoryPotential.Percent1 = 0;
                mcrPriceHistoryPotential.Percent2 = 0;
                this.storePotentialDiscounts(mcrPriceHistoryPotential.RecId, 0, 0);
                mcrPriceHistoryPotential.update();
            }
            mcrPriceHistoryPotentialTmpLocal.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCumulativeDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the discount amount for the passed price history record.
    /// </summary>
    /// <param name="_mcrPriceHistory">
    /// The price history record used to get the discount amount.
    /// </param>
    /// <returns>
    /// The discount amount for the price history record.
    /// </returns>
    public DiscPct displayCumulativeDiscAmount(MCRPriceHistory _mcrPriceHistory)
    {
        DiscAmount discAmount;
        if (mapHistoryToActualDisc.exists(_mcrPriceHistory.RecId))
        {
            discAmount = mapHistoryToActualDisc.lookup(_mcrPriceHistory.RecId);
        }
        return discAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCumulativeDiscPercent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the discount percent for the passed price history record.
    /// </summary>
    /// <param name="_mcrPriceHistory">
    /// The price history record used to get the discount percent.
    /// </param>
    /// <returns>
    /// The discount percent for the price history record.
    /// </returns>
    public DiscPct displayCumulativeDiscPercent(MCRPriceHistory _mcrPriceHistory)
    {
        DiscPct discPct;
        if (mapHistoryToActualDiscPercent.exists(_mcrPriceHistory.RecId))
        {
            discPct = mapHistoryToActualDiscPercent.lookup(_mcrPriceHistory.RecId);
        }
        return discPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayExtendedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the extended amount stored in the map for the passed
    /// record.
    /// </summary>
    /// <param name="_mcrPriceHistory">
    /// The price history record used to get the extended amount.
    /// </param>
    /// <param name="_potential">
    /// A <c>boolean</c> value that determines whether or not to return
    /// the potential amount or thie history amount.
    /// </param>
    /// <returns>
    /// The potential extended amount if _potential
    /// is true; otherwise, thie history extended amount.
    /// </returns>
    public AmountCur displayExtendedAmount(
        MCRPriceHistory  _mcrPriceHistory,
        boolean         _potential)
    {
        AmountCur extendedAmount;

        if (_potential)
        {
            if (mapPotentialToExtendedAmount.exists(_mcrPriceHistory.RecId))
            {
                extendedAmount = mapPotentialToExtendedAmount.lookup(_mcrPriceHistory.RecId);
            }
        }
        else
        {
            if (mapHistoryToExtendedAmount.exists(_mcrPriceHistory.RecId))
            {
                extendedAmount = mapHistoryToExtendedAmount.lookup(_mcrPriceHistory.RecId);
            }
        }
        return extendedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayMerchandisingEventDescription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the description for the passed merchandising event.
    /// </summary>
    /// <param name="_merchandisingEventID">
    /// The ID of the merchandising event.
    /// </param>
    /// <returns>
    /// The description of the merchandising event.
    /// </returns>
    public Description displayMerchandisingEventDescription(
        MCRMerchandisingEventID _merchandisingEventID)
    {
        Description description;

        if (_merchandisingEventID)
        {
            // If doesn't exist in map then fill map
            if (!mapMerchIdToMerchDescription.exists(_merchandisingEventID))
            {
                this.storePromotionInfo(_merchandisingEventID);
            }

            // If exists in map then return map value, otherwise find and store
            if (mapMerchIdToMerchDescription.exists(_merchandisingEventID))
            {
                description = mapMerchIdToMerchDescription.lookup(_merchandisingEventID);
            }
        }
        return description;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayPriceAtQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the price based on the quantity passed in.
    /// </summary>
    /// <param name="_qty">
    /// The quantity used to determine the potential price.
    /// </param>
    /// <returns>
    /// The potential price based on the quantity.
    /// </returns>
    public PriceCur displayPriceAtQty(Qty _qty)
    {
        PriceCur        price;
        MCRPriceHistory mcrPriceHistoryLocal;

        if (!mapQtyToPrice.exists(_qty))
        {            
            mcrPriceHistoryLocal = this.findPotentialPrice(_qty, MCRPriceHistoryPotentialType::TradePriceFrom);
            mapQtyToPrice.insert(_qty, mcrPriceHistoryLocal.Amount);
        }

        price = mapQtyToPrice.lookup(_qty);

        return price;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayPromotionDescription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the description of the promotion that relates to the
    /// passed merchandising event ID.
    /// </summary>
    /// <param name="_merchandisingEventID">
    /// The ID of the merchandising event that is used
    /// to get the promotion description.
    /// </param>
    /// <returns>
    /// The description of the promotion that relates to the merchandising
    /// event.
    /// </returns>
    public Description displayPromotionDescription(
        MCRMerchandisingEventID _merchandisingEventID)
    {
        Description description;

        if (_merchandisingEventID)
        {
            // If doesn't exist in map then fill map
            if (!mapMerchIdToPromotionDescription.exists(_merchandisingEventID))
            {
                this.storePromotionInfo(_merchandisingEventID);
            }

            // If exists in map then return map value, otherwise find and store
            if (mapMerchIdToPromotionDescription.exists(_merchandisingEventID))
            {
                description = mapMerchIdToPromotionDescription.lookup(_merchandisingEventID);
            }
        }
        return description;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayPromotionId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the ID of the promotion that relates to the
    /// passed merchandising event ID.
    /// </summary>
    /// <param name="_merchandisingEventID">
    /// The ID of the merchandising event that is used
    /// to get the promotion ID.
    /// </param>
    /// <returns>
    /// The ID of the promotion that relates to the merchandising
    /// event.
    /// </returns>
    public TAMPromotionID displayPromotionId(MCRMerchandisingEventID _merchandisingEventID)
    {
        TAMPromotionID promotionId;

        if (_merchandisingEventID)
        {
            // If doesn't exist in map then fill map
            if (!mapMerchIdToPromotionId.exists(_merchandisingEventID))
            {
                this.storePromotionInfo(_merchandisingEventID);
            }

            // If exists in map then return map value, otherwise find and store
            if (mapMerchIdToPromotionId.exists(_merchandisingEventID))
            {
                promotionId = mapMerchIdToPromotionId.lookup(_merchandisingEventID);
            }
        }
        return promotionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findHighestQty</Name>
				<Source><![CDATA[
    private Qty findHighestQty()
    {
        Qty largestQtyFound;

        select maxof(QuantityAmountTo) from mcrPriceHistoryPotential;
        largestQtyFound = mcrPriceHistoryPotential.QuantityAmountTo;

        return largestQtyFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPotentialPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the price history record that has the correct price information for a given quantity.
    /// </summary>
    /// <param name="_qty">
    /// The quantity to use to find the correct price history record.
    /// </param>
    /// <param name="_potentialType">
    /// The price history potential type that is associated with the quantity used to find the price.
    /// </param>
    /// <returns>
    /// A price history record with the correct price, price unit, and markup for the quantity.
    /// </returns>
    /// <remarks>
    /// Note this returns price information and is not applicable for discounts.
    /// </remarks>
    private MCRPriceHistory findPotentialPrice(
        Qty                             _qty,
        MCRPriceHistoryPotentialType    _potentialType)
    {
        AmountCur       price;
        boolean         qtyFallsWithinEndRange;
        MCRPriceHistory ret;       

        // Begin using base item price
        ret.data(mcrPriceHistoryItemPrice);
        price = this.getItemPrice();

        if(MCRPriceFindPotentialChangeQueryFlight::instance().isEnabled())
        {
            RecId tradePricesRecId;

            while select tradePrices
            order by QuantityAmount asc, Amount desc
            where tradePrices.QuantityAmount <= _qty
            {        
                // Quantity qualifies given the from range
                // The price is either better than found so far or haven't found non-zero price yet.
                // Check the to range using less than or less than greater than depending on what
                // kind of range checking.
                qtyFallsWithinEndRange = false;
                if (tradePrices.QuantityAmountTo == 0)
                {
                    qtyFallsWithinEndRange = true;
                }
                else if (_potentialType    == MCRPriceHistoryPotentialType::LineDiscTo
                         || _potentialType == MCRPriceHistoryPotentialType::MultiLineDiscTo
                         || _potentialType == MCRPriceHistoryPotentialType::TradePriceTo)
                {
                    if (_qty < tradePrices.QuantityAmountTo)
                    {
                        qtyFallsWithinEndRange = true;
                    }
                }
                else if (_qty <= tradePrices.QuantityAmountTo)
                {
                    qtyFallsWithinEndRange = true;
                }

                if (qtyFallsWithinEndRange)
                {
                    tradePricesRecId = tradePrices.RecId;
                }
            }

            if (tradePricesRecId != 0)
            {
                select firstonly * from tradePrices
                where tradePrices.RecId == tradePricesRecId;
                
                price = tradePrices.Amount;
                ret.data(tradePrices);                              
            }
        }
        else
        {
            while select tradePrices
            order by QuantityAmount asc, Amount desc
            {
                if (tradePrices.QuantityAmount <= _qty)
                {
                    // Quantity qualifies given the from range
                    // The price is either better than found so far or haven't found non-zero price yet.
                    // Check the to range using less than or less than greater than depending on what
                    // kind of range checking.
                    qtyFallsWithinEndRange = false;
                    if (tradePrices.QuantityAmountTo == 0)
                    {
                        qtyFallsWithinEndRange = true;
                    }
                    else if (_potentialType    == MCRPriceHistoryPotentialType::LineDiscTo
                         || _potentialType == MCRPriceHistoryPotentialType::MultiLineDiscTo
                         || _potentialType == MCRPriceHistoryPotentialType::TradePriceTo)
                    {
                        if (_qty < tradePrices.QuantityAmountTo)
                        {
                            qtyFallsWithinEndRange = true;
                        }
                    }
                    else if (_qty <= tradePrices.QuantityAmountTo)
                    {
                        qtyFallsWithinEndRange = true;
                    }

                    if (qtyFallsWithinEndRange)
                    {
                        price = tradePrices.Amount;
                        ret.data(tradePrices);
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the account ID.
    /// </summary>
    /// <returns>
    /// The account ID.
    /// </returns>
    public AccountNum getAccountId()
    {
        return mcrPriceHistoryLine.parmAccountId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the currency code.
    /// </summary>
    /// <returns>
    /// The currency code.
    /// </returns>
    public CurrencyCode getCurrencyCode()
    {
        return mcrPriceHistoryLine.parmCurrencyCode();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total discount amount.
    /// </summary>
    /// <returns>
    /// The discount amount.
    /// </returns>
    public DiscAmount getDiscAmount()
    {
        DiscAmount discAmount;

        discAmount = PriceDisc::discAmount(this.getLineMultiLn(),
                                           this.getLineDiscAmount(),
                                           this.getMultilineDiscAmount());
        return discAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDiscAmountExtendedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the extended discount amount.
    /// </summary>
    /// <returns>
    /// The extended discount amount.
    /// </returns>
    public AmountCur getDiscAmountExtendedAmount()
    {
        return discAmountExtendedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDiscAmountExtendedUnitPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the extended unit price.
    /// </summary>
    /// <returns>
    /// The extended unit price.
    /// </returns>
    public PriceCur getDiscAmountExtendedUnitPrice()
    {
        return discAmountExtendedUnitPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDiscPct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total discount percent.
    /// </summary>
    /// <returns>
    /// The discount percent.
    /// </returns>
    public DiscPct getDiscPct()
    {
        DiscPct discPct;
        discPct = PriceDisc::discPercent(
            this.getLineMultiLn(),
            this.getLineDiscPct(),
            this.getMultilineDiscPct());
        return discPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDiscPctExtendedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the extended discount percent.
    /// </summary>
    /// <returns>
    /// The extended discount percent.
    /// </returns>
    public AmountCur getDiscPctExtendedAmount()
    {
        return discPctExtendedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPreciseDiscPctExtendedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the precise value of extended discount percent.
    /// </summary>
    /// <returns>
    /// The extended discount percent.
    /// </returns>
    public AmountCur getPreciseDiscPctExtendedAmount()
    {
        return preciseDiscPctExtendedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDiscPctExtendedUnitPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the extended discount percent.
    /// </summary>
    /// <returns>
    /// The extended discount percent.
    /// </returns>
    public PriceCur getDiscPctExtendedUnitPrice()
    {
        return discPctExtendedUnitPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPreciseDiscPctExtendedUnitPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the extended discount percent.
    /// </summary>
    /// <returns>
    /// The extended discount percent.
    /// </returns>
    public PriceCur getPreciseDiscPctExtendedUnitPrice()
    {
        return perciseDiscPctExtendedUnitPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the inventory dimension.
    /// </summary>
    /// <returns>
    /// The inventory dimension.
    /// </returns>
    public InventDim getInventDim()
    {
        return mcrPriceHistoryLine.parmInventDim();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventTransId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the inventory transaction ID..
    /// </summary>
    /// <returns>
    /// The inventory transaction ID.
    /// </returns>
    public InventTransId getInventTransId()
    {
        return mcrPriceHistoryLine.parmInventTransId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the item ID.
    /// </summary>
    /// <returns>
    /// The item ID.
    /// </returns>
    public ItemId getItemId()
    {
        return mcrPriceHistoryLine.parmItemId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the price of the item.
    /// </summary>
    /// <returns>
    /// The price of the item.
    /// </returns>
    public PriceCur getItemPrice()
    {
        return itemPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the line discount amount.
    /// </summary>
    /// <returns>
    /// The line discount amount.
    /// </returns>
    public DiscAmount getLineDiscAmount()
    {
        return lineDiscAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineDiscPct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the line discount percent.
    /// </summary>
    /// <returns>
    /// The line discount percent.
    /// </returns>
    public DiscPct getLineDiscPct()
    {
        return lineDiscPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineMultiLn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the multiline discount amount.
    /// </summary>
    /// <returns>
    /// The multiline discount amount.
    /// </returns>
    public LineMultiLn getLineMultiLn()
    {
        return mcrPriceHistoryLine.parmLineMultiLn();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the misc charge amount.
    /// </summary>
    /// <returns>
    /// The misc charge amount.
    /// </returns>
    public PriceMarkup getMarkup()
    {
        return priceMarkup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkupPerUnit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the misc charge amount per unit.
    /// </summary>
    /// <returns>
    /// The misc charge amount per unit.
    /// </returns>
    public PriceMarkup getMarkupPerUnit()
    {
        return this.getQty() ? priceMarkup / this.getQty() : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkupExtendedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the extended misc charge amount.
    /// </summary>
    /// <returns>
    /// The extended misc charge amount.
    /// </returns>
    public AmountCur getMarkupExtendedAmount()
    {
        return markupExtendedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkupExtendedUnitPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the extended misc charge unit price.
    /// </summary>
    /// <returns>
    /// The extended misc charge unit price.
    /// </returns>
    public PriceCur getMarkupExtendedUnitPrice()
    {
        return markupExtendedUnitPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMultilineDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the multiline discount amount.
    /// </summary>
    /// <returns>
    /// The multiline discount amount.
    /// </returns>
    public DiscAmount getMultilineDiscAmount()
    {
        return multilineDiscAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMultilineDiscPct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the multiline discount percent.
    /// </summary>
    /// <returns>
    /// The multiline discount percent.
    /// </returns>
    public DiscPct getMultilineDiscPct()
    {
        return multilineDiscPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMultilineDiscPercentage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the multiline discount percentage.
    /// </summary>
    /// <returns>
    /// The multiline discount percentage.
    /// </returns>
    public DiscPct getMultilineDiscPercentage()
    {
        return this.getMarkupExtendedUnitPrice() - this.getPreciseDiscPctExtendedUnitPrice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMultilineDiscPercentageNet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the multiline discount percentage net.
    /// </summary>
    /// <returns>
    /// The multiline discount percentage.
    /// </returns>
    public DiscPct getMultilineDiscPercentageNet()
    {
        return this.getMarkupExtendedAmount() - this.getDiscPctExtendedAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPriceUnit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the unit price.
    /// </summary>
    /// <returns>
    /// The unit price.
    /// </returns>
    public PriceUnit getPriceUnit()
    {
        return priceUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the purchase order ID.
    /// </summary>
    /// <returns>
    /// The purchase order ID.
    /// </returns>
    public PurchId getPurchId()
    {
        return mcrPriceHistoryLine.parmPurchId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the quantity.
    /// </summary>
    /// <returns>
    /// The quantity.
    /// </returns>
    public Qty getQty()
    {
        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the sales order ID.
    /// </summary>
    /// <returns>
    /// The sales order ID.
    /// </returns>
    public SalesId getSalesId()
    {
        return mcrPriceHistoryLine.parmSalesId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnitId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the unit ID.
    /// </summary>
    /// <returns>
    /// The unit ID.
    /// </returns>
    public UnitOfMeasureSymbol getUnitId()
    {
        return unitId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnitPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the unit price.
    /// </summary>
    /// <returns>
    /// The unit price.
    /// </returns>
    public PriceCur getUnitPrice()
    {
        return unitPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnitPriceExtendedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the extended amount.
    /// </summary>
    /// <returns>
    /// The extended amount.
    /// </returns>
    public AmountCur getUnitPriceExtendedAmount()
    {
        return unitPriceExtendedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnitPriceExtendedUnitPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the extended discount amount.
    /// </summary>
    /// <returns>
    /// The extended discount amount.
    /// </returns>
    public PriceCur getUnitPriceExtendedUnitPrice()
    {
        return unitPriceExtendedUnitPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTmpMCRAgreementLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the price history line from the agreement line.
    /// </summary>
    /// <param name="_tmpMCRAgreementLine">
    /// A temporary table record used to initialize the price history line.
    /// </param>
    public void initTmpMCRAgreementLine(TmpMCRAgreementLine _tmpMCRAgreementLine)
    {
        mcrPriceHistoryLine.initTmpMCRAgreementLine(_tmpMCRAgreementLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveInitialUnitPriceDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for calculating the initial unit price.
    /// </summary>
    /// <param name = "_mcrPriceHistory">The <c>MCRPriceHistory</c> record.</param>
    /// <param name = "_mcrPriceHistoryLine">The <c>MCRPriceHistoryLine</c> instance.</param>
    /// <param name = "_eventHandlerResult">Subscribers can use this class to provide the result.</param>
    delegate void retrieveInitialUnitPriceDelegate(MCRPriceHistoryLine _mcrPriceHistoryLine, PriceCur _initialUnitPrice, MCRPriceHistoryForm _mcrPriceHistoryForm, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPotentialEndRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts potential records that correspond to the end range (the quantity to value)
    /// for each potential record.
    /// </summary>
    /// <param name="_mcrPriceHistoryPotentialTmpLocal">
    /// The temporary table to which to add the end ranges.
    /// </param>
    /// <returns>
    /// Updated reference record Id (to maintain unique records).
    /// </returns>
    private RefRecId insertPotentialEndRanges(MCRPriceHistory _mcrPriceHistoryPotentialTmpLocal)
    {
        RefRecId                refRecId;
        Set                     setCarryOverAlreadyInserted = new Set(Types::Int64);

        // Create records that include both quantityFrom and quantityTo calculations
        // in separate local table
        _mcrPriceHistoryPotentialTmpLocal.setTmp();

        // Note that class variable mcrPriceHistoryPotential is a temp table
        // For each price history record, insert a second record with the QuantityAmountTo value
        // and all the same price/discount values
        while select mcrPriceHistoryPotential
            order by QuantityAmount, PriceHistoryType asc
        {
            // To allow duplicate records to be inserted into temp table
            refRecId += 1;

            _mcrPriceHistoryPotentialTmpLocal.data(mcrPriceHistoryPotential);
            _mcrPriceHistoryPotentialTmpLocal.RefRecId = refRecId;
            _mcrPriceHistoryPotentialTmpLocal.PriceHistoryPotentialType =
                MCRPriceHistory::mcrPriceHistoryTypeToPotential(_mcrPriceHistoryPotentialTmpLocal.PriceHistoryType, true);

            _mcrPriceHistoryPotentialTmpLocal.insert();

            // Not inserting quantity to records for open ended agreements
            if (mcrPriceHistoryPotential.QuantityAmountTo)
            {
                refRecId += 1;
                _mcrPriceHistoryPotentialTmpLocal.data(mcrPriceHistoryPotential);
                _mcrPriceHistoryPotentialTmpLocal.RefRecId = refRecId;
                _mcrPriceHistoryPotentialTmpLocal.PriceHistoryPotentialType =
                    MCRPriceHistory::mcrPriceHistoryTypeToPotential(_mcrPriceHistoryPotentialTmpLocal.PriceHistoryType, false);

                _mcrPriceHistoryPotentialTmpLocal.QuantityAmount = _mcrPriceHistoryPotentialTmpLocal.QuantityAmountTo;

                _mcrPriceHistoryPotentialTmpLocal.insert();
            }
        }

        return refRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPotentialForHighestToQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a final potential record to show the prices after quantity goes higher than
    /// the highest to quantity of all trade agreements.
    /// </summary>
    /// <param name="_refRecId">
    /// The reference record ID to insure record will be unique.
    /// </param>
    /// <returns>
    /// Updated reference record Id for insuring no duplicate records are inserted.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Thrown if record to be inserted is not valid.
    /// </exception>
    private RefRecId insertPotentialForHighestToQty(RefRecId _refRecId)
    {
        PriceDisc           priceDisc;
        PriceDisc           priceDiscMultiLine;
        AmountCur           extendedAmount;
        DiscAmount          combinedDiscAmount;
        DiscPct             combinedDiscPct;
        Qty                 largestToQtyFound;

        largestToQtyFound = this.findHighestQty();

        if (largestToQtyFound)
        {
            // If there are already end range records for the largest to quantity, then delete it.
            delete_from mcrPriceHistoryPotential
                where mcrPriceHistoryPotential.QuantityAmount == largestToQtyFound
                   && (mcrPriceHistoryPotential.PriceHistoryPotentialType    == MCRPriceHistoryPotentialType::LineDiscTo
                       || mcrPriceHistoryPotential.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::MultiLineDiscTo
                       || mcrPriceHistoryPotential.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::TradePriceTo
                       || mcrPriceHistoryPotential.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::EndRange);

            // If there is an open-ended trade agreement with a from quantity greater or equal, then do not insert an end range
            select firstonly RecId from mcrPriceHistoryPotential
                where mcrPriceHistoryPotential.QuantityAmountTo == 0
                   && mcrPriceHistoryPotential.QuantityAmount   >= largestToQtyFound
                   && (mcrPriceHistoryPotential.PriceHistoryPotentialType    == MCRPriceHistoryPotentialType::LineDiscFrom
                       || mcrPriceHistoryPotential.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::MultiLineDiscFrom
                       || mcrPriceHistoryPotential.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::TradePriceFrom);
            if (!mcrPriceHistoryPotential.RecId)
            {
                priceDisc = mcrPriceHistoryLine.priceDisc(largestToQtyFound);

                // Find prices and discounts.
                priceDisc.findPrice(mcrPriceHistoryLine.parmPriceGroupId());
                if (mcrPriceHistoryLine.parmCanFindLineDisc())
                {
                    priceDisc.findLineDisc(mcrPriceHistoryLine.parmItemLineDiscCode(),
                                            mcrPriceHistoryLine.parmLineDiscCode());
                }

                priceDiscMultiLine = mcrPriceHistoryLine.priceDisc(largestToQtyFound);
                priceDiscMultiLine.findMultiLineDisc(
                    mcrPriceHistoryLine.parmItemMultilineDiscCode(),
                    mcrPriceHistoryLine.parmAccountMultilineDiscCode(),
                    largestToQtyFound);

                combinedDiscAmount = PriceDisc::discAmount(
                    mcrPriceHistoryLine.parmLineMultiLn(),
                    priceDisc.getDiscAmount(),
                    priceDiscMultiLine.getDiscAmount());
                combinedDiscPct = PriceDisc::discPercent(
                    mcrPriceHistoryLine.parmLineMultiLn(),
                    priceDisc.getDiscPercent(),
                    priceDiscMultiLine.getDiscPercent());

                mcrPriceHistoryPotential.clear();
                mcrPriceHistoryPotential.PriceHistoryPotentialType = MCRPriceHistoryPotentialType::EndRange;
                mcrPriceHistoryPotential.QuantityAmount            = largestToQtyFound;
                mcrPriceHistoryPotential.RefTableId                = tableNum(PriceDiscTable);
                mcrPriceHistoryPotential.Version                   = 1;
                mcrPriceHistoryPotential.Amount                    = priceDisc.price();
                mcrPriceHistoryPotential.InventDimId               = InventDim::inventDimIdBlank();
                mcrPriceHistoryPotential.UnitId                    = mcrPriceHistoryLine.parmUnitId();
                _refRecId++;
                mcrPriceHistoryPotential.RefRecId                  = _refRecId;
                extendedAmount = PriceDisc::price2Amount(
                    priceDisc.price(),
                    priceDisc.priceUnit(),
                    combinedDiscAmount,
                    largestToQtyFound,
                    0,
                    priceDisc.markup(),
                    combinedDiscPct,
                    this.getCurrencyCode(),
                    0,
                    true);

                mcrPriceHistoryPotential.PriceHistoryUnitPrice = extendedAmount / largestToQtyFound;
                mapQtyToPrice.insert(largestToQtyFound, priceDisc.price());

                if (mcrPriceHistoryPotential.validateWrite())
                {
                    mcrPriceHistoryPotential.insert();
                }
                else
                {
                    throw error("@SYS104318");
                }

                this.storePotentialDiscounts(
                    mcrPriceHistoryPotential.RecId,
                    combinedDiscAmount,
                    combinedDiscPct);

                this.storeAmounts(
                    mcrPriceHistoryPotential.RecId,
                    extendedAmount,
                    true);
            }
        }
        return _refRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPotentialMerchEventPricing</Name>
				<Source><![CDATA[
    private void insertPotentialMerchEventPricing()
    {
        TAMMerchEventPricing        tamMerchEventPricing;
        TAMTradePromotion           tamTradePromotion;
        TAMMerchandisingEvent       tamMerchEvents;
        TAMPromotionCust            tamPromotionCust;
        MCRPriceDiscGroupItem       priceDiscGroupItems;
        TAMPromotionItem            tamPromotionItem;
        InventDim                   inventDimPrice;
        InventDimId                 blankInventDim = InventDim::findOrCreateBlank().InventDimId;
        InventDim                   inventDim;
        Qty                         qtyCurrent;
        ItemId                      itemId;
        CurrencyCode                curCode;
        CustVendAC                  account;
        TransDate                   discDate;
        Set                         alreadyInserted = new Set(Types::Int64);

        qtyCurrent  = abs(this.getQty());
        itemId      = this.getItemId();
        inventDim   = this.getInventDim();
        curCode     = this.getCurrencyCode();
        account     = this.getAccountId();
        discDate    = mcrPriceHistoryLine.parmPriceDate();

        InventDimParm productDims = InventDimParm::allProductDim();
        InventDimParm dimParmNoBlanksAllowed;

        while select RecId from priceDiscGroupItems
            where priceDiscGroupItems.ItemId == itemId
            join InventDimId from inventDimPrice
                where ((inventDimPrice.InventDimId      == priceDiscGroupItems.InventDimId
                        && #InventDimRanges(inventDimPrice, inventDim, productDims, dimParmNoBlanksAllowed))
                      || inventDimPrice.InventDimId == blankInventDim)
            join RecId from tamPromotionItem
                where tamPromotionItem.ItemID               == itemId
                   && tamPromotionItem.MerchandisingEventID == priceDiscGroupItems.GroupId
                   && tamPromotionItem.InventDimID          == priceDiscGroupItems.InventDimId
            join RecId from tamPromotionCust
                where tamPromotionCust.PromotionID == tamPromotionItem.PromotionID
                   && tamPromotionCust.CustAccount == account
            join tamMerchEventPricing
                where tamMerchEventPricing.MerchandisingEventID == tamPromotionItem.MerchandisingEventID
                   && (qtyCurrent >= tamMerchEventPricing.Quantity
                   && (qtyCurrent <  tamMerchEventPricing.QuantityTo
                       || tamMerchEventPricing.QuantityTo == 0))
            join RecId from tamMerchEvents
                where tamMerchEvents.MerchandisingEventID       == tamPromotionItem.MerchandisingEventID
                   && tamMerchEvents.MerchandisingEventCategory == MCRMerchandisingEventCategory::OffInvoice
                   && (! (tamMerchEventPricing.DiscountAmt != 0
                          && tamMerchEventPricing.DiscountPercent != 0))
            exists join tamTradePromotion
                where tamTradePromotion.PromotionID     == tamMerchEvents.PromotionID
                   && tamTradePromotion.PromotionStatus == TAMStatus::CustomerApproved
                   && tamTradePromotion.OrdersStartDate <= discDate
                   && discDate                          <= tamTradePromotion.OrdersEndDate
        {
            if (! alreadyInserted.in(tamMerchEventPricing.RecId))
            {
                mcrPriceHistoryPotential.clear();
                mcrPriceHistoryPotential.initFromMerchEventPricing(tamMerchEventPricing);
                mcrPriceHistoryPotential.InventDimId       = inventDimPrice.InventDimId;
                mcrPriceHistoryPotential.ItemRelation      = this.getItemId();
                mcrPriceHistoryPotential.AccountRelation   = this.getAccountId();
                if (tamMerchEventPricing.DiscountAmt != 0)
                {
                    mcrPriceHistoryPotential.Amount = CurrencyExchangeHelper::amountCur2MST(tamMerchEventPricing.DiscountAmt, curCode);
                }
                mcrPriceHistoryPotential.insert();
                alreadyInserted.add(tamMerchEventPricing.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPotentialTradeAgreements</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds all possible trade agreements that match quantity greater than current quantity.
    /// </summary>
    /// <remarks>
    ///     Create temporary price history records from those possible trade agreements.
    /// </remarks>
    private void insertPotentialTradeAgreements()
    {
        // Find prices and discounts
        // Can't use realMax for potentialQty because PriceDisc won't match price agreements because they will not seem cheaper.
        Qty qtyPotential = 999999999999999.00;
        PriceDisc priceDisc = mcrPriceHistoryLine.priceDisc(qtyPotential);
        priceDisc.parmMCRPriceHistoryPotentialCalc(true);

        this.findingPriceDisc(this, priceDisc, McrPriceHistoryLine);

        // Get PriceDiscTable records found by PriceDisc
        RecordSortedList recordSortedListPriceDisc = priceDisc.parmMCRPriceDiscTableList();

        PriceDiscTable priceDiscTable;
        boolean loop = recordSortedListPriceDisc.first(priceDiscTable);
        while (loop)
        {
            mcrPriceHistoryPotential.clear();
            mcrPriceHistoryPotential.initFromPriceDiscTable(priceDiscTable);
            mcrPriceHistoryPotential.insert();

            // Also save price trade agreements in a separate table for finding prices later.
            if (mcrPriceHistoryPotential.PriceHistoryType == MCRPriceHistoryType::TradePrice)
            {
                tradePrices.clear();
                tradePrices.initFromPriceDiscTable(priceDiscTable);
                tradePrices.insert();
            }

            loop = recordSortedListPriceDisc.next(priceDiscTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findingPriceDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for finding the prices and discounts.
    /// </summary>
    /// <param name = "_mcrPriceHistoryForm">The <c>MCRPriceHistoryForm</c> instance.</param>
    /// <param name = "_priceDisc">The <c>PriceDisc</c> instance.</param>
    /// <param name = "_mcrPriceHistoryLine">The <c>MCRPriceHistoryLine</c> instance.</param>
    delegate void findingPriceDisc(MCRPriceHistoryForm _mcrPriceHistoryForm, PriceDisc _priceDisc, MCRPriceHistoryLine _mcrPriceHistoryLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findingPriceDiscEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the prices and discounts.
    /// </summary>
    /// <param name = "_mcrPriceHistoryForm">The <c>MCRPriceHistoryForm</c> instance.</param>
    /// <param name = "_priceDisc">The <c>PriceDisc</c> instance.</param>
    /// <param name = "_mcrPriceHistoryLine">The <c>MCRPriceHistoryLine</c> instance.</param>
    [SubscribesTo(classStr(McrPriceHistoryForm), delegateStr(McrPriceHistoryForm, findingPriceDisc))]
    public static void findingPriceDiscEventHandler(MCRPriceHistoryForm _mcrPriceHistoryForm, PriceDisc _priceDisc, MCRPriceHistoryLine _mcrPriceHistoryLine)
    {
        // Find prices, line discounts, and multiline
        _priceDisc.findPrice(_mcrPriceHistoryLine.parmPriceGroupId());

        if (_mcrPriceHistoryLine.parmCanFindLineDisc())
        {
            _priceDisc.findLineDisc(_mcrPriceHistoryLine.parmItemLineDiscCode(),
                                    _mcrPriceHistoryLine.parmLineDiscCode());
        }

        // If multiline quantity and current quantity are equal then no other lines contribute
        // so therefore don't find potential multiline
        if (_mcrPriceHistoryLine.parmQtyMultiline() != abs(_mcrPriceHistoryForm.getQty()))
        {
            _priceDisc.findMultiLineDisc(_mcrPriceHistoryLine.parmItemMultilineDiscCode(),
                                         _mcrPriceHistoryLine.parmAccountMultilineDiscCode(),
                                         _priceDisc.parmPriceDiscParameters().parmQty());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPriceHistory</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a temporary price history records from existing history.
    /// </summary>
    /// <remarks>
    ///     Gets history records from MCRPriceHistoryLine.  Puts all records except itemPrice
    ///     in list.
    /// </remarks>
    private void insertPriceHistory()
    {
        MCRPriceHistory     mcrPriceHistoryLocal;
        RecordSortedList    recordSortedListAllPriceHistory;
        boolean             loop;

        // Only insert a trade agreement line if not linked to agreement.
        if (! tmpMCRAgreementLine.RecId)
        {
            recordSortedListAllPriceHistory = mcrPriceHistoryLine.findHistory();
            loop = recordSortedListAllPriceHistory.first(mcrPriceHistoryLocal);
            while (loop)
            {
                this.updateMCRPriceHistoryBasedOnType(mcrPriceHistoryLocal);
                loop = recordSortedListAllPriceHistory.next(mcrPriceHistoryLocal);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMCRPriceHistoryBasedOnType</Name>
				<Source><![CDATA[
    protected void updateMCRPriceHistoryBasedOnType(MCRPriceHistory _mcrPriceHistoryLocal)
    {
        switch (_mcrPriceHistoryLocal.PriceHistoryType)
        {
            case MCRPriceHistoryType::ItemPrice:
                mcrPriceHistoryItemPrice.data(_mcrPriceHistoryLocal);
                break;
            case MCRPriceHistoryType::TradePrice:
            case MCRPriceHistoryType::LineDisc:
            case MCRPriceHistoryType::MultiLineDisc:
                mcrPriceHistory.data(_mcrPriceHistoryLocal);

                if (mcrPriceHistory.MerchandisingEventID)
                {
                    mcrPriceHistory.ItemRelation = this.getItemId();
                    mcrPriceHistory.InventDimId  = this.getInventDim().InventDimId;
                    mcrPriceHistory.AccountRelation = this.getAccountId();
                }

                mcrPriceHistory.insert();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOverride</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the price was overridden.
    /// </summary>
    /// <returns>
    /// true if the price was overridden; otherwise, false.
    /// </returns>
    public boolean isOverride()
    {
        boolean isOverride;
        isOverride = mcrPriceHistoryLine.parmPriceOverride();
        return isOverride;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMarginAlert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and returns a <c>MCRMarginAlert</c> object
    /// </summary>
    /// <returns>
    /// A new <c>MCRMarginAlert</c> object.
    /// </returns>
    public MCRMarginAlert mcrMarginAlert()
    {
        return mcrPriceHistoryLine.mcrMarginAlert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a new instance of the <c>MCRPriceHistory</c> form class, using the specified buffer.
    /// </summary>
    /// <param name="_common">
    ///     The record for the <c>MCRPriceHistoryLine</c>.
    /// </param>
    /// <remarks>
    ///     This method should not be called directly; call the construct instead.
    /// </remarks>
    protected void new(Common _common)
    {
        mcrPriceHistoryLine = MCRPriceHistoryLine::construct(_common);

        // Initialize maps
        mapHistoryToExtendedAmount = new Map(
            typeName2Type(extendedTypeStr(RecId)),
            typeName2Type(extendedTypeStr(AmountCur)));
        mapPotentialToExtendedAmount = new Map(
            typeName2Type(extendedTypeStr(RecId)),
            typeName2Type(extendedTypeStr(AmountCur)));
        mapMerchIdToPromotionId = new Map(
            typeName2Type(extendedTypeStr(MCRMerchandisingEventID)),
            typeName2Type(extendedTypeStr(TAMPromotionID)));
        mapMerchIdToMerchDescription = new Map(
            typeName2Type(extendedTypeStr(MCRMerchandisingEventID)),
            typeName2Type(extendedTypeStr(Description)));
        mapMerchIdToPromotionDescription = new Map(
            typeName2Type(extendedTypeStr(MCRMerchandisingEventID)),
            typeName2Type(extendedTypeStr(Description)));
        mapQtyToPrice = new Map(Types::Real, Types::Real);

        mapHistoryToActualDisc = new Map(typeName2Type(extendedTypeStr(RecId)), typeName2Type(extendedTypeStr(DiscAmount)));
        mapHistoryToActualDiscPercent = new Map(typeName2Type(extendedTypeStr(RecId)), typeName2Type(extendedTypeStr(DiscPct)));

        mcrPriceHistory.setTmp();

        mcrPriceHistoryPotential.setTmp();

        tradePrices.setTmp();

        // Only calculate if price history viewable.  If calc not called, form will be blank.
        if (mcrPriceHistoryLine.allowView())
        {
            // Calculate figures (e.g., price per unit).  This must come after map initializations
            this.calc();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAgreementId</Name>
				<Source><![CDATA[
    public Num parmAgreementId()
    {
        return mcrPriceHistoryLine.parmAgreementId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineDiscPct1</Name>
				<Source><![CDATA[
    private DiscPct parmLineDiscPct1(DiscPct _lineDiscPct1 = lineDiscPct1)
    {
        lineDiscPct1 = _lineDiscPct1;
        return lineDiscPct1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineDiscPct2</Name>
				<Source><![CDATA[
    private DiscPct parmLineDiscPct2(DiscPct _lineDiscPct2 = lineDiscPct2)
    {
        lineDiscPct2 = _lineDiscPct2;
        return lineDiscPct2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMultiLineDiscPct1</Name>
				<Source><![CDATA[
    private DiscPct parmMultiLineDiscPct1(DiscPct _multilineDiscPct1 = multilineDiscPct1)
    {
        multilineDiscPct1 = _multilineDiscPct1;
        return multilineDiscPct1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMultiLineDiscPct2</Name>
				<Source><![CDATA[
    private DiscPct parmMultiLineDiscPct2(DiscPct _multilineDiscPct2 = multilineDiscPct2)
    {
        multilineDiscPct2 = _multilineDiscPct2;
        return multilineDiscPct2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>price2Amount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Converts the specified price to an amount.
    /// </summary>
    /// <param name="_price">
    ///     The price to convert to amount.
    /// </param>
    /// <param name="_discAmount">
    ///     The discount amount.
    /// </param>
    /// <param name="_markup">
    ///     The markup amount.
    /// </param>
    /// <param name="_discPercent">
    ///     The discount percentage.
    /// </param>
    /// <returns>
    ///     The total amount.
    /// </returns>
    /// <remarks>
    ///     Some parameters remain constant for all calls.
    ///     Convenience method for calling PriceDisc::price2Amount.
    /// </remarks>
    private AmountCur price2Amount(AmountCur       _price,
                                   DiscAmount      _discAmount,
                                   MarkupAmount    _markup,
                                   DiscPct         _discPercent)
    {
        AmountCur amount;
        amount = PriceDisc::price2Amount(_price,
                                         this.getPriceUnit(),
                                         _discAmount,
                                         this.getQty(),
                                         0,
                                         _markup,
                                         _discPercent,
                                         this.getCurrencyCode(),
                                         0,
                                         true);
        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryMCRRoyaltyVendTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a royalty table query that will be returned to the price history form.
    /// </summary>
    /// <param name="_mcrRoyaltyVendTableTmp">
    /// The royalty table buffer that will hold the temporary royalty records.
    /// </param>
    /// <returns>
    /// The royalty table query that will be returned to the price history form.
    /// </returns>
    /// <remarks>
    /// This method also fills the passed in royalty table buffer with the temporary royalty records
    /// that will be used by the form to calculate the price discounts for the order line related to royalties.
    /// </remarks>
    public Query queryMCRRoyaltyVendTable(MCRRoyaltyVendTable _mcrRoyaltyVendTableTmp)
    {
        Query                   query;
        QueryBuildDataSource    queryBuildDataSource;

        if (!_mcrRoyaltyVendTableTmp.isTmp())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        mcrPriceHistoryLine.fillMCRRoyaltyVendTableTmp(_mcrRoyaltyVendTableTmp);

        query = new Query();
        queryBuildDataSource = query.addDataSource(tableNum(MCRRoyaltyVendTable));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryPdsRebateTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a rebate table query that will be returned to the price history form.
    /// </summary>
    /// <param name="_pdsRebateTableTmp">
    /// The rebate table buffer that will hold the temporary rebate records.
    /// </param>
    /// <returns>
    /// The rebate table query that will be returned to the price history form.
    /// </returns>
    /// <remarks>
    /// This method also fills the passed in rebate table buffer with the temporary rebate records
    /// that will be used by the form to calculate the price discounts for the order line related to rebates.
    /// </remarks>
    public Query queryPdsRebateTable(PdsRebateTable _pdsRebateTableTmp)
    {
        Query                   query;
        QueryBuildDataSource    queryBuildDataSource;

        if (!_pdsRebateTableTmp.isTmp())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        mcrPriceHistoryLine.fillPdsRebateTableTmp(_pdsRebateTableTmp);

        query = new Query();
        queryBuildDataSource = query.addDataSource(tableNum(PdsRebateTable));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryPriceHistory</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a query based on temp tables filled elsewhere.
    /// </summary>
    /// <param name="_mcrPriceHistoryTmp">
    ///     The MCRPriceHistory record.
    /// </param>
    /// <param name="_potential">
    ///     Indicates whether price history potential is considered.
    /// </param>
    /// <returns>
    ///     A <c>Query</c> containing the price history.
    /// </returns>
    /// <remarks>
    ///     See initList and initListPotential.
    /// </remarks>
    public final Query queryPriceHistory(
        MCRPriceHistory  _mcrPriceHistoryTmp,
        boolean         _potential)
    {
        Query                   query;
        QueryBuildDataSource    queryBuildDataSource;
        QueryBuildDataSource    queryBuildDataSourceInventDim;
        if (!_mcrPriceHistoryTmp.isTmp())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }
        if (_potential)
        {
            _mcrPriceHistoryTmp.setTmpData(mcrPriceHistoryPotential);
        }
        else
        {
            _mcrPriceHistoryTmp.setTmpData(mcrPriceHistory);
        }
        query = new Query();
        queryBuildDataSource = query.addDataSource(tableNum(MCRPriceHistory));

        queryBuildDataSource.addSortField(fieldNum(MCRPriceHistory, QuantityAmount), SortOrder::Ascending);
        queryBuildDataSource.addSortField(fieldNum(MCRPriceHistory, PriceHistoryUnitPrice), SortOrder::Descending);

        queryBuildDataSourceInventDim = queryBuildDataSource.addDataSource(tableNum(InventDim));
        queryBuildDataSourceInventDim.joinMode(JoinMode::InnerJoin);
        queryBuildDataSourceInventDim.relations(true);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryTAMVendRebateTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a vendor rebate table query that will be returned to the price history form.
    /// </summary>
    /// <param name="_tamVendRebateTableTmp">
    /// The vendor rebate table buffer that will hold the temporary rebate records.
    /// </param>
    /// <returns>
    /// The rebate table query that will be returned to the price history form.
    /// </returns>
    /// <remarks>
    /// This method also fills the passed in rebate table buffer with the temporary rebate records
    /// that will be used by the form to calculate the price discounts for the order line related to rebates.
    /// </remarks>
    public Query queryTAMVendRebateTable(TAMVendRebateTable _tamVendRebateTableTmp)
    {
        Query                   query;
        QueryBuildDataSource    queryBuildDataSource;

        if (!_tamVendRebateTableTmp.isTmp())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        mcrPriceHistoryLine.fillVendRebateTableTmp(_tamVendRebateTableTmp);

        query = new Query();
        queryBuildDataSource = query.addDataSource(tableNum(TAMVendRebateTable));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeDuplicatePotential</Name>
				<Source><![CDATA[
    private void removeDuplicatePotential()
    {
        MCRPriceHistory         mcrPriceHistoryPotentialTmpLocal;

        mcrPriceHistoryPotentialTmpLocal.setTmp();
        mcrPriceHistoryPotentialTmpLocal.setTmpData(mcrPriceHistoryPotential);

        delete_from mcrPriceHistoryPotential
            where mcrPriceHistoryPotential.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::LineDiscTo
               || mcrPriceHistoryPotential.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::MultiLineDiscTo
               || mcrPriceHistoryPotential.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::TradePriceTo
            exists join mcrPriceHistoryPotentialTmpLocal
            where mcrPriceHistoryPotentialTmpLocal.QuantityAmount                     == mcrPriceHistoryPotential.QuantityAmount
                    && mcrPriceHistoryPotentialTmpLocal.RecId                         != mcrPriceHistoryPotential.RecId
                    && (mcrPriceHistoryPotentialTmpLocal.PriceHistoryPotentialType    == MCRPriceHistoryPotentialType::LineDiscFrom
                        || mcrPriceHistoryPotentialTmpLocal.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::TradePriceFrom
                        || mcrPriceHistoryPotentialTmpLocal.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::MultiLineDiscFrom);

        delete_from mcrPriceHistoryPotential
            where mcrPriceHistoryPotential.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::LineDiscFrom
               || mcrPriceHistoryPotential.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::MultiLineDiscFrom
               || mcrPriceHistoryPotential.PriceHistoryPotentialType == MCRPriceHistoryPotentialType::TradePriceFrom
            exists join mcrPriceHistoryPotentialTmpLocal
            where mcrPriceHistoryPotentialTmpLocal.QuantityAmount                 == mcrPriceHistoryPotential.QuantityAmount
                    && mcrPriceHistoryPotentialTmpLocal.RecId                     != mcrPriceHistoryPotential.RecId
                    && mcrPriceHistoryPotentialTmpLocal.PriceHistoryPotentialType == mcrPriceHistoryPotential.PriceHistoryPotentialType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDiscAmountExtendedAmount</Name>
				<Source><![CDATA[
    public void setDiscAmountExtendedAmount(AmountCur _discAmountExtendedAmount)
    {
        discAmountExtendedAmount = _discAmountExtendedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDiscAmountExtendedUnitPrice</Name>
				<Source><![CDATA[
    public void setDiscAmountExtendedUnitPrice(PriceCur _discAmountExtendedUnitPrice)
    {
        discAmountExtendedUnitPrice = _discAmountExtendedUnitPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDiscPctExtendedAmount</Name>
				<Source><![CDATA[
    public void setDiscPctExtendedAmount(AmountCur _discPctExtendedAmount)
    {
        discPctExtendedAmount = _discPctExtendedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPreciseDiscPctExtendedAmount</Name>
				<Source><![CDATA[
    public void setPreciseDiscPctExtendedAmount(AmountCur _preciseDiscPctExtendedAmount)
    {
        preciseDiscPctExtendedAmount = _preciseDiscPctExtendedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDiscPctExtendedUnitPrice</Name>
				<Source><![CDATA[
    public void setDiscPctExtendedUnitPrice(PriceCur _discPctExtendedUnitPrice)
    {
        discPctExtendedUnitPrice = _discPctExtendedUnitPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPreciseDiscPctExtendedUnitPrice</Name>
				<Source><![CDATA[
    public void setPreciseDiscPctExtendedUnitPrice(PriceCur _perciseDiscPctExtendedUnitPrice)
    {
        perciseDiscPctExtendedUnitPrice = _perciseDiscPctExtendedUnitPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setItemPrice</Name>
				<Source><![CDATA[
    private void setItemPrice(PriceCur _itemPrice)
    {
        itemPrice = _itemPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLineDiscAmount</Name>
				<Source><![CDATA[
    private void setLineDiscAmount(DiscAmount _lineDiscAmount)
    {
        lineDiscAmount = _lineDiscAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLineDiscPct</Name>
				<Source><![CDATA[
    private void setLineDiscPct(DiscPct _lineDiscPct)
    {
        lineDiscPct = _lineDiscPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMarkup</Name>
				<Source><![CDATA[
    public void setMarkup(PriceMarkup _priceMarkup)
    {
        priceMarkup = _priceMarkup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMarkupExtendedAmount</Name>
				<Source><![CDATA[
    public void setMarkupExtendedAmount(AmountCur _markupExtendedAmount)
    {
        markupExtendedAmount = _markupExtendedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMarkupExtendedUnitPrice</Name>
				<Source><![CDATA[
    public void setMarkupExtendedUnitPrice(PriceCur _markupExtendedUnitPrice)
    {
        markupExtendedUnitPrice = _markupExtendedUnitPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMultilineDiscAmount</Name>
				<Source><![CDATA[
    private void setMultilineDiscAmount(DiscAmount _multilineDiscAmount)
    {
        multilineDiscAmount = _multilineDiscAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMultilineDiscPct</Name>
				<Source><![CDATA[
    private void setMultilineDiscPct(DiscPct _multilineDiscPct)
    {
        multilineDiscPct = _multilineDiscPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPriceUnit</Name>
				<Source><![CDATA[
    public void setPriceUnit(PriceUnit _priceUnit)
    {
        priceUnit = _priceUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQty</Name>
				<Source><![CDATA[
    protected void setQty(Qty _qty)
    {
        qty = _qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUnitId</Name>
				<Source><![CDATA[
    private void setUnitId(UnitOfMeasureSymbol _unitId)
    {
        unitId = _unitId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUnitPrice</Name>
				<Source><![CDATA[
    public void setUnitPrice(PriceCur _unitPrice)
    {
        unitPrice = _unitPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUnitPriceExtendedAmount</Name>
				<Source><![CDATA[
    public void setUnitPriceExtendedAmount(PriceCur _unitPriceExtendedAmount)
    {
        unitPriceExtendedAmount = _unitPriceExtendedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUnitPriceExtendedUnitPrice</Name>
				<Source><![CDATA[
    public void setUnitPriceExtendedUnitPrice(AmountCur _unitPriceExtendedUnitPrice)
    {
        unitPriceExtendedUnitPrice = _unitPriceExtendedUnitPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showAgreementRelated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>boolean</c> value indicating if the price history line shows values
    /// related to agreements.
    /// </summary>
    /// <returns>
    /// True if agreement related information shoud be be shown on price history form; otherwise, false.
    /// </returns>
    public boolean showAgreementRelated()
    {
        return mcrPriceHistoryLine.parmShowAgreementRelated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>showCustRebates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>boolean</c> value indicating if the price history line shows values
    /// related to customer rebates.
    /// </summary>
    /// <returns>
    /// True if customer rebates should be be shown; otherwise, false.
    /// </returns>
    public boolean showCustRebates()
    {
        return mcrPriceHistoryLine.parmShowCustRebates();
    }

]]></Source>
			</Method>
			<Method>
				<Name>showMarginBrokerAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>boolean</c> value indicating if the price history line shows values
    /// related to margin calculation and broker.
    /// </summary>
    /// <returns>
    /// True if broker amount for margin calculation should be be shown; otherwise, false.
    /// </returns>
    public boolean showMarginBrokerAmount()
    {
        return mcrPriceHistoryLine.parmShowMarginBrokerAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>showMarginEstimatedSalesPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>boolean</c> value indicating if the price history line shows values
    /// related to margin calculation and sales price.
    /// </summary>
    /// <returns>
    /// True if estimated sales price for margin calculation should be be shown; otherwise, false.
    /// </returns>
    public boolean showMarginEstimatedSalesPrice()
    {
        return mcrPriceHistoryLine.parmShowMarginEstimatedSalesPrice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>showMarginRelated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>boolean</c> value indicating if the price history line shows values
    /// related to margins.
    /// </summary>
    /// <returns>
    /// True if margin should be be shown on price history form; otherwise, false.
    /// </returns>
    public boolean showMarginRelated()
    {
        return mcrPriceHistoryLine.parmShowMarginRelated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>showMarginRoyaltyAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>boolean</c> value indicating if the price history line shows values
    /// related to margin calculation and royalties.
    /// </summary>
    /// <returns>
    /// True if royalty amount for margin calculation should be be shown; otherwise, false.
    /// </returns>
    public boolean showMarginRoyaltyAmount()
    {
        return mcrPriceHistoryLine.parmShowMarginRoyaltyAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>showMCRPriceHistoryTab</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns whether the price history tab should be shown or not on the price history form.
    /// </summary>
    /// <returns>
    /// True if the price history tab should be shown; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The tab is hidden when retail pricing is used.
    /// </remarks>
    public boolean showMCRPriceHistoryTab()
    {
        boolean showMCRPriceHistoryTab = true;

        if (mcrPriceHistoryLine.usesRetailPricing())
        {
            showMCRPriceHistoryTab = false;
        }
        return showMCRPriceHistoryTab;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showPotentialPriceTab</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns whether the potential price tab should be shown or not on the price history form.
    /// </summary>
    /// <returns>
    /// True if the potential price tab should be shown; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The tab is hidden when retail pricing is used.
    /// </remarks>
    public boolean showPotentialPriceTab()
    {
        boolean showPotentialPriceTab = true;

        if (mcrPriceHistoryLine.usesRetailPricing())
        {
            showPotentialPriceTab = false;
        }
        return showPotentialPriceTab;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showRoyaltyTab</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets a <c>boolean</c> value indicating if the sales price history line shows the royalty tab.
    /// </summary>
    /// <returns>
    ///     True if royalty tab shoud be be shown on price history form; otherwise, false.
    /// </returns>
    public boolean showRoyaltyTab()
    {
        return mcrPriceHistoryLine.parmShowRoyaltyTab();
    }

]]></Source>
			</Method>
			<Method>
				<Name>showVendRebates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>boolean</c> value indicating if the price history line shows values
    /// related to margin calculation and vendor rebates.
    /// </summary>
    /// <returns>
    /// True if vendor rebate amount should be be shown; otherwise, false.
    /// </returns>
    public boolean showVendRebates()
    {
        return mcrPriceHistoryLine.parmShowVendRebates();
    }

]]></Source>
			</Method>
			<Method>
				<Name>storeAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Stores the price per unit and extended amount in maps.
    /// </summary>
    /// <param name="_mcrPriceHistoryRecId">
    ///     The <c>RecId</c> of the price history record.
    /// </param>
    /// <param name="_extendedAmount">
    ///     The extended amount to store in the map.
    /// </param>
    /// <param name="_potential">
    ///     Indicates whether to store potential history and amount.
    /// </param>
    private void storeAmounts(
        RecId       _mcrPriceHistoryRecId,
        AmountCur   _extendedAmount,
        boolean     _potential)
    {
        if (_potential)
        {
            mapPotentialToExtendedAmount.insert(_mcrPriceHistoryRecId, _extendedAmount);
        }
        else
        {
            mapHistoryToExtendedAmount.insert(_mcrPriceHistoryRecId, _extendedAmount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>storePotentialDiscounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Stores the price per unit and extended amounts in maps.
    /// </summary>
    /// <param name="_mcrPriceHistoryRecId">
    ///     The <c>RecId</c> of the price history record.
    /// </param>
    /// <param name="_discAmount">
    ///     The discount amount to store in the map.
    /// </param>
    /// <param name="_discPct">
    ///     The discount percentage to store in the map.
    /// </param>
    final protected void storePotentialDiscounts(RecId       _mcrPriceHistoryRecId,
                                         DiscAmount  _discAmount,
                                         DiscPct     _discPct)
    {
        mapHistoryToActualDisc.insert(_mcrPriceHistoryRecId, _discAmount);
        mapHistoryToActualDiscPercent.insert(_mcrPriceHistoryRecId, _discPct);
    }

]]></Source>
			</Method>
			<Method>
				<Name>storePromotionInfo</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Stores miscellaneous promotion information in maps.
    /// </summary>
    /// <param name="_merchandisingEventID">
    ///     The <c>TAMMerchandisingEventId</c> to use to inert into the <c>TAMMerchandisingEvent</c> table.
    /// </param>
    private void storePromotionInfo(MCRMerchandisingEventID _merchandisingEventID)
    {
        TAMMerchandisingEvent    tamMerchandisingEvent;
        TAMTradePromotion         tamTradePromotion;

        // Store promotion Id and merchandising event description
        select PromotionID, Description, PromotionCust from tamMerchandisingEvent
            where tamMerchandisingEvent.MerchandisingEventID == _merchandisingEventID;
        mapMerchIdToPromotionId.insert(_merchandisingEventID,
                                        tamMerchandisingEvent.PromotionID);
        mapMerchIdToMerchDescription.insert(_merchandisingEventID,
                                             tamMerchandisingEvent.Description);

        // Store promotion description
        select PromotionDescription from tamTradePromotion
            where tamTradePromotion.CustAccount == tamMerchandisingEvent.PromotionCust
               && tamTradePromotion.PromotionID == tamMerchandisingEvent.PromotionID;
        mapMerchIdToPromotionDescription.insert(_merchandisingEventID,
                                                 tamTradePromotion.PromotionDescription);
    }

]]></Source>
			</Method>
			<Method>
				<Name>precisePrice2Amount</Name>
				<Source><![CDATA[
    private static AmountCur precisePrice2Amount(PriceCur         _price,
                                                 PriceUnit        _priceUnit,
                                                 DiscAmount       _discAmount,
                                                 Qty              _qtyNow,
                                                 Qty              _qty,
                                                 MarkupAmount     _markup,
                                                 DiscPct          _discPercent,
                                                 CurrencyCode     _currencyCode,
                                                 Amount           _amount,
                                                 boolean          _forceAmountCalculation = false)
    {
        Amount returnAmount;
        #ISOCountryRegionCodes

        if (!_price && !_discAmount && !_discPercent && !_markup && !_forceAmountCalculation)
        {
            if (_qtyNow == _qty)
            {
                return _amount;
            }
            else
            {
                _price = PriceDisc::amount2Price(_amount,
                                                 _discPercent,
                                                 _markup,
                                                 _qty,
                                                 _discAmount,
                                                 _priceUnit,
                                                 _currencyCode,
                                                 _price);
            }
        }

        if (_price  || _discAmount || _discPercent || _markup || _forceAmountCalculation)
        {
            if (!_priceUnit)
            {
                _priceUnit = 1;
            }
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]) &&
                SalesParameters::find().LineDiscCalculation_PL == PlLineDiscCalcType::PcsPrice &&
                (_discAmount || _markup || _discPercent))
            {
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferencePL00009, funcName());
                returnAmount = (_qtyNow / _priceUnit) * (_price - _discAmount + _markup) * (100 - _discPercent) / 100;
            }
            else
            {
                returnAmount = (_qtyNow * ((_price - _discAmount) / _priceUnit) + (_qtyNow >= 0 ? _markup : -_markup) ) * (100 - _discPercent) / 100;
            }

        }
        else
        {
            returnAmount = _amount;
        }

        return returnAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new object of type <c>MCRPriceHistoryForm</c>
    /// </summary>
    /// <param name="_common">
    /// Record used to initialize the new object.
    /// </param>
    /// <returns>
    /// A <c>MCRPriceHistoryForm</c> object.
    /// </returns>
    public static MCRPriceHistoryForm construct(Common _common)
    {
        MCRPriceHistoryForm mcrPriceHistoryForm;

        mcrPriceHistoryForm = new MCRPriceHistoryForm(_common);
        return mcrPriceHistoryForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    final internal MCRPriceInstrumentationLogger instrumentationLogger()
    {
        if (!instrumentationLogger)
        {
            instrumentationLogger = MCRPriceInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
        }

        return instrumentationLogger;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>