<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BOMMapInterface</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///     Base class providing an interface to common functionality applicable for tables mapped to the <c>BOMMap</c> table map.
/// </summary>
/// <remarks>
///     Intended usage of this hierarchy is to allow for extensions of <c>BOMMap</c> table map.
/// </remarks>
public abstract class BOMMapInterface
{
    protected BOMMap bomMap;
    
    private BOMVersion bomVersion;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new ()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialize</Name>
				<Source><![CDATA[
    private void initialize(BOMMap _bomMap)
    {
        bomMap = _bomMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInstance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>BOMMapInterface</c> object based on the provided <c>BOMMap</c> record.
    /// </summary>
    /// <param name = "_bomMap">
    /// A <c>BOMMap</c> record to create a <c>BOMMapInterface</c> object for.
    /// </param>
    /// <returns>
    /// The instance of <c>BOMMapInterface</c>.
    /// </returns>
    [Hookable(false)]
    public static BOMMapInterface createInstance(BOMMap _bomMap)
    {
        BOMMapInterfaceFactoryAttribute attribute = new BOMMapInterfaceFactoryAttribute(tableId2Name(_bomMap.TableId));

        BOMMapInterface instance = SysExtensionAppClassFactory::getClassFromSysAttribute(classStr(BOMMapInterface), attribute) as BOMMapInterface;
        
        // possibly an ISV table mapping => instantiate a default object
        if (!instance)
        {
            instance = new BOMMapDefaultImplementation();
        }

        instance.initialize(_bomMap);

        return instance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBOMMap</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMMap parmBOMMap()
    {
        return bomMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBOMId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMId parmBOMId()
    {
        return bomMap.BOMId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBOMQty</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMQty parmBOMQty()
    {
        return bomMap.BOMQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBOMConsump</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMConsumpType parmBOMConsump()
    {
        return bomMap.BOMConsump;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBOMType</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMType parmBOMType()
    {
        return bomMap.BOMType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final ItemIdInventoried parmItemId()
    {
        return bomMap.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final InventDimId parmInventDimId()
    {
        return bomMap.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHeight</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMMeasureHeight parmHeight()
    {
        return bomMap.Height;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWidth</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMMeasureWidth parmWidth()
    {
        return bomMap.Width;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDepth</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMMeasureDepth parmDepth()
    {
        return bomMap.Depth;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDensity</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMMeasureDensity parmDensity()
    {
        return bomMap.Density;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmConstant</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMMeasureConstant parmConstant()
    {
        return bomMap.Constant;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCalculation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMCalcBOMLine parmCalculation()
    {
        return bomMap.Calculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCWQuantity</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final PdsCWInventQty parmCWQuantity()
    {
        return bomMap.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEndSchedConsumption</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMEndSchedConsump parmEndSchedConsumption()
    {
        return bomMap.EndSchedConsump;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemBOMId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final ItemBOMId parmItemBOMId()
    {
        return bomMap.ItemBOMId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemRouteId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final ItemRouteId parmItemRouteId()
    {
        return bomMap.ItemRouteId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUnitId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final UnitOfMeasureSymbol parmUnitId()
    {
        return bomMap.UnitId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBOMQtySerie</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMQtySerie parmBOMQtySerie()
    {
        return bomMap.BOMQtySerie;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFormula</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMFormula parmFormula()
    {
        return bomMap.Formula;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineNum</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final LineNum parmLineNum()
    {
        return bomMap.LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOprNum</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final OprNum parmOprNum()
    {
        return bomMap.OprNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPdsIngredientType</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final PDSIngredientType parmPdsIngredientType()
    {
        return bomMap.PDSIngredientType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPDSBaseValue</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final PDSBaseValue parmPDSBaseValue()
    {
        return bomMap.PDSBaseValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPDSCompensationPrincipleId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final PDSCompensationPrincipleEnum parmPDSCompensationPrincipleId()
    {
        return bomMap.PDSCompensationPrincipleId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPDSInheritCoProductBatchAttribute</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final PDSInheritBatchAttrib parmPDSInheritCoProductBatchAttribute()
    {
        return bomMap.PDSInheritCoProductBatchAttrib;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPDSInheritCoProductShelfLife</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final PDSInheritShelfLife parmPDSInheritCoProductShelfLife()
    {
        return bomMap.PDSInheritCoProductShelfLife;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPDSInheritEndItemBatchAttribute</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final PDSInheritBatchAttrib parmPDSInheritEndItemBatchAttribute()
    {
        return bomMap.PDSInheritEndItemBatchAttrib;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPDSInheritEndItemShelfLife</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final PDSInheritShelfLife parmPDSInheritEndItemShelfLife()
    {
        return bomMap.PDSInheritEndItemShelfLife;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPmfFormulaPct</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final PmfFormulaPct parmPmfFormulaPct()
    {
        return bomMap.PmfFormulaPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPmfPctEnable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final NoYesId parmPmfPctEnable()
    {
        return bomMap.PmfPctEnable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPmfQtyWithoutYield</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMQty parmPmfQtyWithoutYield()
    {
        return bomMap.PmfQtyWithoutYield;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPmfScalable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final NoYesId parmPmfScalable()
    {
        return bomMap.PmfScalable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPosition</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final Position parmPosition()
    {
        return bomMap.Position;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProdFlushingPrinciple</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final ProdFlushingPrincipBOM parmProdFlushingPrinciple()
    {
        return bomMap.ProdFlushingPrincip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRoundUp</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMRoundUp parmRoundUp()
    {
        return bomMap.RoundUp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRoundUpQty</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMRoundUpQty parmRoundUpQty()
    {
        return bomMap.RoundUpQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmScrapVariable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final ScrapVar parmScrapVariable()
    {
        return bomMap.ScrapVar;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmScrapConstant</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final ScrapConst parmScrapConstant()
    {
        return bomMap.ScrapConst;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVendorId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final VendAccount parmVendorId()
    {
        return bomMap.VendId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWrkCtrConsumption</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final WrkCtrConsumption parmWrkCtrConsumption()
    {
        return bomMap.WrkCtrConsumption;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMaterialOverpickPercentage</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final WHSMaterialOverpickPercentage parmMaterialOverpickPercentage()
    {
        return bomMap.MaterialOverpickPercentage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bomQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes BOM consumption quantity based on a produced quantity
    /// </summary>
    /// <param name = "_seriesSize">
    /// The produced quantity 
    /// </param>
    /// <returns>
    /// The BOM consumption quantity
    /// </returns>
    [Hookable(false)]
    public final BOMQty bomQty(Qty _seriesSize = 1)
    {
        // Sign is multiplied later
        Qty  seriesSize = abs(_seriesSize);

        if (seriesSize && seriesSize != 1)
        {
            // Calculate using seriesize to avoid rounding later on
            return bomMap.bomQtySerie
                ? (seriesSize * bomMap.bomQty) / bomMap.bomQtySerie
                : seriesSize * bomMap.bomQty;
        }
        else
        {
            return (bomMap.bomQtySerie
                ? bomMap.bomQty / bomMap.bomQtySerie
                : bomMap.bomQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bomQtyFormula</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMQty bomQtyFormula(Qty _seriesSize, ItemId _parentItemId)
    {
        if (bomMap.Formula == BOMFormula::Formula0)
        {
            return this.bomQty(_seriesSize);
        }
        else
        {
            BOMCalcData bomCalcData = BOMCalcData::newInventTable(_seriesSize,
                                                      InventTable::find(_parentItemId));

            return BOMCalcConsumption::construct(bomMap.Formula, bomCalcData).bomQty(bomMap);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcVendId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final VendAccount calcVendId(RouteOprMap routeOpr)
    {
        VendAccount     vendId;
        
        if (routeOpr.RecId)
        {
            vendId = routeOpr.RouteOprMap::wrkCtrVendId();
        }

        if (! vendId)
        {
            vendId = bomMap.VendId;
        }

        if (! vendId)
        {
            InventTable inventTable = bomMap.inventTable();
            vendId      = inventTable.primaryVendorId(bomMap.InventDimId);
        }

        return vendId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromBOMMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the current record by copying all fields from another record.
    /// </summary>
    /// <param name="_bomMap">
    ///    A record that is related to the map of <c>BOMMap</c> type.
    /// </param>
    /// <remarks>
    ///    Both records relate to the map of <c>BOMMap</c> type.The <c>inventDimId</c> value will be copied as
    ///    well.
    /// </remarks>
    [Hookable(false)]
    public final void initFromBOMMap(BOMMap _bomMap)
    {
        bomMap.data(_bomMap);

        // inventDimId must be set by one of the dedicated methods if such exist in order to set financial dimensions.
        if (tableHasInstanceMethod(new DictTable(bomMap.TableId),tableMethodStr(ProdBOM,setInventDimId)))
        {
            bomMap.InventDimId = '';
            bomMap.setInventDimId(_bomMap.InventDimId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePhantomBOMMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the BOMMap fields from phantom BOM.
    /// </summary>
    /// <param name = "_phantomBOM"> Phantom BOM record </param>
    /// <param name = "_phantomUnitFactor"> The unit conversion factor to use </param>
    /// <param name = "_prodTable"> The production/batch order record </param>
    [Hookable(false)]
    internal void initializePhantomBOMMap(BOMMap      _phantomBOM,
                                          Factor      _phantomUnitFactor,
                                          ProdTable   _prodTable)
    {
        if (BOM::isPmfFormula(_phantomBOM.BOMId))
        {
            Qty searchQty   = _phantomBOM.BOMMap::searchQty(_prodTable.ItemId,_prodTable.QtySched);

            bomVersion = BOMVersion::selectBomVersionWithPriority(_phantomBOM.ItemId,
                                                                  _prodTable.BOMDate,
                                                                  searchQty,
                                                                  InventDim::find(_phantomBOM.InventDimId),
                                                                  true,
                                                                  true,
                                                                  true,
                                                                  false,
                                                                  true);
        }

        this.initFromPhantom(_phantomBOM, _phantomUnitFactor, _prodTable.ItemId, _prodTable.QtySched);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPhantom</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>BOMMapInterface</c> fields from phantom BOM.
    /// </summary>
    /// <param name = "_phantomBOM">The phantom BOM to initialize the instance from.</param>
    /// <param name = "_phantomUnitFactor">The phantom unit factor.</param>
    /// <param name = "_phantomParentItemId">The phantom parent item number.</param>
    /// <param name = "_serieSize">The series size quantity.</param>
    public void initFromPhantom(
        BOMMap      _phantomBOM,
        Factor      _phantomUnitFactor,
        ItemId      _phantomParentItemId,
        Qty         _serieSize)
    {
        if (#PmfEnabled)
        {
            bomMap.PmfScalable = false;
            bomMap.PmfPctEnable = false;
        }

        if (bomMap.Formula != BOMFormula::Formula0 && _phantomBOM.Formula != BOMFormula::Formula0)
            throw error("@SYS3567");

        if (bomMap.bomConsump == BOMConsumpType::Constant)
        {
            if (bomMap.Formula == BOMFormula::Formula0)
            {
                bomMap.bomQty     = bomMap.bomQty * _phantomUnitFactor;
            }
            else
            {
                bomMap.Constant   = (bomMap.Constant ? bomMap.Constant : 1) * _phantomUnitFactor;
            }
        }
        else
        {
            bomMap.ScrapConst = (_phantomBOM.ScrapConst * this.bomQty() * (bomMap.ScrapVar + 100) / 100 * _phantomUnitFactor + bomMap.ScrapConst);

            if (_phantomBOM.Formula == BOMFormula::Formula0 && bomMap.Formula != BOMFormula::Formula0)
            {
                bomMap.bomQty         = this.bomQtyFormula(1, _phantomBOM.ItemId);
                bomMap.bomQtySerie    = this.getPerSeriesForPhantomBOMLevel(_phantomBOM);
                bomMap.Formula        = this.getFormulaForPhantomBOMLevel(_phantomBOM);                
            }            

            if (bomMap.Formula == BOMFormula::Formula0)
            {
                BOMCalcConsumption bomCalcConsumption;
                Qty consumptionBOM;

                if (BOM::isPmfFormula(_phantomBOM.BOMId) && bomVersion)
                {
                    bomCalcConsumption = BOMCalcConsumption::construct(_phantomBOM.Formula,
                                                                       BOMCalcData::newInventTable(_serieSize,InventTable::find(_phantomParentItemId)),
                                                                       bomVersion.PmfYieldPct, 
                                                                       BOM::isPmfFormula(_phantomBOM.BOMId));
                    consumptionBOM = bomCalcConsumption.calcConsumption(_phantomBOM, 1, NoYes::Yes, NoYes::No, NoYes::No); // exclude scrap when computing BOM qty per unit => include when estimating consumption
                }
                else
                {
                    bomCalcConsumption = BOMCalcConsumption::construct(_phantomBOM.Formula, BOMCalcData::newInventTable(_serieSize,InventTable::find(_phantomParentItemId)));
                    consumptionBOM = decRound(bomCalcConsumption.bomQty(_phantomBOM),
                                              UnitOfMeasure::unitOfMeasureDecimalPrecision(
                                              UnitOfMeasure::unitOfMeasureIdBySymbol(_phantomBOM.UnitId)));
                }

                this.calcStandardFormulaBOMQty(_phantomBOM, _phantomUnitFactor, consumptionBOM, _serieSize);
            }
            else
            {
                InventTable inventTablePhantom = InventTable::find(_phantomBOM.ItemId);

                bomMap.Height     = bomMap.Height   * (inventTablePhantom.Height    ? inventTablePhantom.Height     : 1);
                bomMap.Width      = bomMap.Width    * (inventTablePhantom.Width     ? inventTablePhantom.Width      : 1);
                bomMap.Depth      = bomMap.Depth    * (inventTablePhantom.Depth     ? inventTablePhantom.Depth      : 1);
                bomMap.Density    = bomMap.Density  * (inventTablePhantom.Density   ? inventTablePhantom.Density    : 1);
                bomMap.Constant   = _phantomBOM.bomQty() * (bomMap.Constant ? bomMap.Constant : 1) * _phantomUnitFactor;

                if (bomMap.RoundUp == BOMRoundUp::Qty)
                {
                    bomMap.RoundUpQty = bomMap.RoundUpQty * _phantomBOM.bomQty();
                }
            }

            bomMap.ScrapVar   = ((100 + _phantomBOM.ScrapVar) * (100 + bomMap.ScrapVar) / 100 - 100);

            if (this.shouldUpdateBOMConsumptionToConstant(_phantomBOM))
            {
                bomMap.bomConsump = BOMConsumpType::Constant;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateBOMConsumptionToConstant</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the <c>bomMap</c> bom consumption should be updated to constant.
    /// </summary>
    /// <param name = "_phantomBOM">The phantom BOM used in the initialization of this class instance.</param>
    /// <returns>true if the bom consumption should be updated to constant; otherwise, false.</returns>
    protected boolean shouldUpdateBOMConsumptionToConstant(BOMMap _phantomBOM)
    {
        return _phantomBOM.bomConsump == BOMConsumpType::Constant 
            && bomMap.bomConsump == BOMConsumpType::Variable
            && !BOMCalcConsumpVariableFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcStandardFormulaBOMQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// An extension point to calculate material's bom quantity with standard formula requirement from phantom bill of material level.
    /// </summary> 
    /// <param name="_phantomBOM">
    ///  A phantom bill of material record.
    /// </param>
    /// <param name="_phantomUnitFactor">
    ///  A phantom bill of material unit conversion factor.
    /// </param>
    /// <param name="_consumptionBOM">
    ///  A material's bom consumption quantity.
    /// </param>
    /// <param name="_serieSize">
    ///  A production series size quantity.
    /// </param>
    public void calcStandardFormulaBOMQty(BOMMap _phantomBOM,
                                          Factor _phantomUnitFactor,
                                          Qty    _consumptionBOM,
                                          Qty    _serieSize)
    {
        boolean divideSerieSize = !(_phantomBOM.BOMConsump == BOMConsumpType::Constant)
                                 || BOMCalcConsumpVariableFlight::instance().isEnabled();

        bomMap.bomQty = _consumptionBOM / (_serieSize && divideSerieSize ? _serieSize : 1) * bomMap.bomQty * _phantomUnitFactor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFormulaForPhantomBOMLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// An extension point to get a formula for material with non-standard formula requirement from phantom bill of material level
    /// </summary>
    /// <param name="_phantomBOM">
    ///  A phantom bill of material record
    /// </param>
    /// <returns>
    /// BOM formula
    /// </returns>
    [Replaceable(true)]
    protected BOMFormula getFormulaForPhantomBOMLevel(BOMMap _phantomBOM)
    {
        return BOMFormula::Formula0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPerSeriesForPhantomBOMLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// An extension point to get per series for a material with non-standard formula requirement from phantom bill of material level
    /// </summary>
    /// <param name="_phantomBOM">
    ///  A phantom bill of material record
    /// </param>
    /// <returns>
    /// Per series quantity
    /// </returns>
    [Replaceable(true)]
    protected BOMQtySerie getPerSeriesForPhantomBOMLevel(BOMMap _phantomBOM)
    {
        return 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimFinal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the final inventory dimensions for a bills of materials line.
    /// </summary>
    /// <param name="_parentItemId">
    /// A string that holds the itemID for the parent item.
    /// </param>
    /// <param name="_parentInventDim">
    /// A record of type InventDim that holds the inventory dimensions related to the parent item.
    /// </param>
    /// <param name="_routeId">
    /// A string that holds the routeID related to the parent item.
    /// </param>
    /// <param name="_inventTable">
    /// An <c>InventTable</c> record containing the item data for the BOM item.
    /// </param>
    /// <param name="_oprNum">
    /// An integer value that holds the operation number.
    /// </param>
    /// <param name="_wrkCtrConsumption">
    /// A Boolean value that holds the resource consumption flag.
    /// </param>
    /// <returns>
    /// A record of type inventDim that holds the inventory dimensions the current bills of materials line must have.
    /// </returns>
    /// <remarks>
    /// A bill of materials line can be defined without all inventory dimensions specified.
    /// The missing inventory dimensions can first be determined when:
    /// <list type="bullet">
    /// <item><description>The parent item is specified.</description></item>
    /// <item><description>The inventory dimensions for the parent item is fully specified.</description></item>
    /// <item><description>The routeID that should be used to make the parent item can be found.</description></item>
    /// <item><description>The operation number is known</description></item>
    /// <item><description>The resource consumption setting is known</description></item>
    /// </list>
    /// </remarks>
    [Hookable(false)]
    public final InventDim inventDimFinal(
        ItemId            _parentItemId,
        InventDim         _parentInventDim,
        RouteId           _routeId,
        InventTable       _inventTable       = InventTable::find(bomMap.ItemId),
        OprNum            _oprNum            = bomMap.OprNum,
        WrkCtrConsumption _wrkCtrConsumption = bomMap.WrkCtrConsumption)

    {
        InventLocationIdInput inputInventLocationId;

        InventDim inventDim = InventDim::find(bomMap.InventDimId).data();
        InventDim inventDimCriteria;

        inputInventLocationId = this.routeInputInventLocationId(_parentItemId,
                                                                _routeId,
                                                                _parentInventDim.ConfigId,
                                                                _parentInventDim.InventSiteId,
                                                                _oprNum,
                                                                _wrkCtrConsumption,
                                                                dateNull());

        if (inputInventLocationId)
        {
            inventDim.InventLocationId = inputInventLocationId;
        }

        if (   _parentInventDim.InventSiteId
            && inventDim.InventSiteId != _parentInventDim.InventSiteId)
        {
            inventDim.InventSiteId = _parentInventDim.InventSiteId;
        }

        inventDimCriteria.InventSiteId = inventDim.InventSiteId;
        inventDimCriteria.copyProductDimensions(inventDim, bomMap.ItemId);
        inventDimCriteria = InventDim::findOrCreate(inventDimCriteria);

        // <GEERU>
        if (EcoResDimensionGroupSetup::isInventoryDimensionActiveForItem(bomMap.ItemId, fieldNum(InventDim, InventProfileId_RU)) &&
            !inventDim.InventProfileId_RU)
        {
            inventDim.InventProfileId_RU = BOMParameters::find().InventProfileId_RU;
        }
        // </GEERU>

        // checks and/or sets the warehouse
        inventDim.InventLocationId  = _inventTable.inventLocationId(inventDim.InventLocationId,
                                                                    inventDimCriteria.InventDimId,
                                                                    inventDimCriteria.InventSiteId);
        if (inventDim.InventLocationId && !inventDim.InventSiteId)
        {
            // In case the default record has both default site and warehouse defined
            // we need to update the site as well
            inventDim.InventSiteId = InventLocation::find(inventDim.InventLocationId).InventSiteId;
        }

        // Default the InventStatus dimension
        if (!inventDim.InventStatusId
            && EcoResDimensionGroupSetup::isInventDimActiveWithCoveragePlanForItem(bomMap.ItemId, fieldNum(InventDim, InventStatusId))
        )
        {
            inventDim.InventStatusId = WHSInvent::getDefaultStatusByParameters(bomMap.ItemId, inventDim, false, '', ModuleInventCustVend::Invent);
        }

        inventDim = InventDim::findOrCreate(inventDim);
        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemBOMId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMId itemBOMId(TransDate       _searchDate,
                                 FromQty         _searchQty,
                                 InventDim       _inventDimBOMFinal)
    {
        if (bomMap.ItemBOMId)
        {
            return bomMap.ItemBOMId;
        }

        return InventTable::find(bomMap.ItemId).bomId(_searchDate, _searchQty, _inventDimBOMFinal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>phantomUnitFactor</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final Factor phantomUnitFactor(Qty               _serieSize,
                                          InventTableModule _inventTableModuleInvent = InventTableModule::find(bomMap.ItemId,ModuleInventPurchSales::Invent))
    {
        if (bomMap.UnitId == _inventTableModuleInvent.UnitId)
        {
            return 1;
        }
        else
        {
            Qty consumptionBOM = decround(BOMCalcConsumption::construct(bomMap.Formula, BOMCalcData::newInventTable(_serieSize,InventTable::find(bomMap.ItemId))).bomQty(bomMap),
                                          UnitOfMeasure::unitOfMeasureDecimalPrecision(UnitOfMeasure::unitOfMeasureIdBySymbol(bomMap.UnitId)));

            if (!consumptionBOM)
            {
                return 1;
            }
            else
            {
                Qty consumptionInvent = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(bomMap.ItemId,
                                                                                                              bomMap.InventDimId,
                                                                                                              consumptionBOM,
                                                                                                              bomMap.UnitId,
                                                                                                              _inventTableModuleInvent.UnitId,
                                                                                                              NoYes::Yes);

                return consumptionInvent/consumptionBOM;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfBOMTable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final BOMTable pmfBOMTable(boolean _forUpdate = true)
    {
        return BOMTable::find(bomMap.bomId,_forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>routeInputInventLocationId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the input warehouse for the current BOM line in the context of using a specific route, configuration and site.
    /// </summary>
    /// <param name="_parentItemId">
    ///    The parent item ID to use to determine the input warehouse for the BOM line.
    /// </param>
    /// <param name="_routeId">
    ///    The route ID to use when determining the input warehouse.
    /// </param>
    /// <param name="_configId">
    ///    The configuration ID to use to determine the input warehouse.
    /// </param>
    /// <param name="_siteId">
    ///    The site ID to use to determine the input warehouse.
    /// </param>
    /// <param name="_oprNum">
    ///    The operation number to use to determine the input warehouse.
    /// </param>
    /// <param name="_wrkCtrConsumption">
    ///    The resource consumption setting to use to determine the input warehouse.
    /// </param>
    /// <param name="_date">
    ///    The date to use to determine the input warehouse.
    /// </param>
    /// <returns>
    ///    The input location ID.
    /// </returns>
    [Hookable(false)]
    public final InventLocationIdInput routeInputInventLocationId(
        ItemId                      _parentItemId,
        RouteId                     _routeId,
        EcoResItemConfigurationName _configId,
        InventSiteId                _siteId,
        OprNum                      _oprNum            = bomMap.OprNum,
        WrkCtrConsumption           _wrkCtrConsumption = bomMap.WrkCtrConsumption,
        TransDate                   _date              = dateNull())
    {
        RouteOpr                    routeOpr;
        InventLocationIdInput       inventLocationIdInput;

        routeOpr = this.getRouteOpr(_parentItemId, _routeId, _configId, _siteId, _oprNum, _wrkCtrConsumption);

        if (routeOpr)
        {
            inventLocationIdInput = routeOpr.inputWarehouse(_date, _siteId);
        }

        return inventLocationIdInput;
    }

]]></Source>
			</Method>
			<Method>
				<Name>routeInputWMSLocationId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the input WMSLocation for the current BOM line in the context of using a specific route, configuration and site.
    /// </summary>
    /// <param name="_parentItemId">
    ///    The parent item ID to use to determine the input location for the BOM line.
    /// </param>
    /// <param name="_routeId">
    ///    The route ID to use when determining the input location.
    /// </param>
    /// <param name="_configId">
    ///    The configuration ID to use to determine the input location.
    /// </param>
    /// <param name="_siteId">
    ///    The site ID to use to determine the input location.
    /// </param>
    /// <param name="_oprNum">
    ///    The operation number to use to determine the input location.
    /// </param>
    /// <param name="_wrkCtrConsumption">
    ///    The resource consumption setting to use to determine the input location.
    /// </param>
    /// <param name="_date">
    ///    The date to use to determine the input location.
    /// </param>
    /// <returns>
    ///    The input location ID if either the BOM item or warehouse are not enabled for advanced warehouse processes; otherwise empty string.
    /// </returns>
    [Hookable(false)]
    public final WMSLocationIdInput routeInputWMSLocationId(
        ItemId                      _parentItemId,
        RouteId                     _routeId,
        EcoResItemConfigurationName _configId,
        InventSiteId                _siteId,
        OprNum                      _oprNum            = bomMap.OprNum,
        WrkCtrConsumption           _wrkCtrConsumption = bomMap.WrkCtrConsumption,
        TransDate                   _date              = dateNull())
    {
        RouteOpr                    routeOpr;
        WMSLocationIdInput          inputWMSLocationId;

        if (this.whsEnabled())
        {
            return '';
        }

        routeOpr = this.getRouteOpr(_parentItemId, _routeId, _configId, _siteId, _oprNum, _wrkCtrConsumption);

        if (routeOpr)
        {
            inputWMSLocationId = routeOpr.inputWMSLocationId(_date, _siteId);
        }

        return inputWMSLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>scrapConstant</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final ScrapConst scrapConstant()
    {
        return bomMap.ScrapConst;
    }

]]></Source>
			</Method>
			<Method>
				<Name>scrapVariable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final ScrapVar scrapVariable()
    {
        return bomMap.ScrapVar;
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchQty</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public final Qty searchQty(ItemId              _parentItemId,
                               Qty                 _serieSize,
                               UnitOfMeasureSymbol _toUnitId = InventTable::find(bomMap.ItemId).inventTableModuleInvent().UnitId)
    {
        Qty  consumptionBOM     = decround(BOMCalcConsumption::construct(bomMap.Formula, BOMCalcData::newInventTable(_serieSize,InventTable::find(_parentItemId))).bomQty(bomMap),
                                           UnitOfMeasure::unitOfMeasureDecimalPrecision(UnitOfMeasure::unitOfMeasureIdBySymbol(bomMap.UnitId)));
        Qty  consumptionInvent  = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(bomMap.ItemId,
                                                                                                        bomMap.InventDimId,
                                                                                                        consumptionBOM,
                                                                                                        bomMap.UnitId,
                                                                                                        _toUnitId,
                                                                                                        NoYes::Yes);

        return consumptionInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRouteOpr</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the route operation for the current BOM line in the context of using a specific route, configuration and site.
    /// </summary>
    /// <param name="_parentItemId">
    ///    The parent item ID to use to determine the route operation for the BOM line.
    /// </param>
    /// <param name="_routeId">
    ///    The route ID to use when determining the route operation.
    /// </param>
    /// <param name="_configId">
    ///    The configuration ID to use to determine the route operation.
    /// </param>
    /// <param name="_siteId">
    ///    The site ID to use to determine the route operation.
    /// </param>
    /// <param name="_oprNum">
    ///    The operation number to use to determine the route operation.
    /// </param>
    /// <param name="_wrkCtrConsumption">
    ///    The resource consumption setting to use to determine the route operation.
    /// </param>
    /// <returns>
    ///    The route operation.
    /// </returns>
    private RouteOpr getRouteOpr(
        ItemId                      _parentItemId,
        RouteId                     _routeId,
        EcoResItemConfigurationName _configId,
        InventSiteId                _siteId,
        OprNum                      _oprNum,
        WrkCtrConsumption           _wrkCtrConsumption)
    {
        Route                       route;
        RouteOpr                    routeOpr;

        if (!_wrkCtrConsumption || !_routeId)
        {
            return routeOpr; // return empty
        }

        // If there is a operation defined on the BOM line then try to find it
        if (_oprNum)
        {
            route = Route::findFirstOpr(_routeId, _oprNum);
        }

        // If not defined or not found, use first operation
        if (!route)
        {
            route = Route::findFirst(_routeId);
        }

        if (route)
        {
            routeOpr = route.routeOpr(_parentItemId, _configId, _siteId, routeOpr);
        }

        return routeOpr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the current BOM line is eligible to advanced warehousing processes.
    /// </summary>
    /// <returns>
    /// true if both the item and the warehouse in the BOM line are enabled for advanced warehousing processes;
    /// otherwise, false.
    /// </returns>
    private boolean whsEnabled()
    {
        return InventDim::find(bomMap.InventDimId).inventLocation().WHSEnabled &&
               InventTable::find(bomMap.ItemId).whsItemIsWHSControlled();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>