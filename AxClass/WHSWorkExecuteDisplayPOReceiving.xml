<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWorkExecuteDisplayPOReceiving</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Handles the logic behind the RF flow used to manage received inbound order items.
/// </summary>
public abstract class WHSWorkExecuteDisplayPOReceiving extends WHSWorkExecuteDisplay
{
    private boolean trackingDimCaptureInProgressForGeneratedLP;
    private SysInstrumentationActivityContext activityContextDisplayFormRecursion;
    private int displayFormRecursionDepth;
    private boolean receivingWorkWasDeferred;
    internal static str ReceiptLoadIdDisplayField = 'ReceiptLoadIdDisplayField';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>buildGetPOLineLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for scanning LP of a received inbound order line.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_extratext">
    /// Label text.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    public container buildGetPOLineLP(container _con, str _extratext = '')
    {
        container       ret         = _con;
        int             numLP       = pass.lookup(#NumLP);
        int             currentLP   = pass.lookup(#CurrentLP);

        WHSInventTable whsInventTable = WHSInventTable::find(pass.lookup(#ItemId));

        ret += [this.buildControl(#RFLabel, #LPLoop, strFmt("@WAX1246", currentLP, numLP), 1, '', #WHSRFUndefinedDataType, '', 0)];

        var orderProvider = this.receivingOrderProvider();

        ret += [this.buildControl(#RFText, orderProvider.orderKey(), orderProvider.orderFieldLabel(), 1, orderProvider.orderNum(pass), orderProvider.orderTypeId(), '', 0, false)];
        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, pass.lookup(#ItemId), extendedTypeNum(InventInventItemSearchItem), '', 0, false)];

        if (whsInventTable.rfDescription1)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", whsInventTable.rfDescription1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
        }
        else
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", InventTable::find(whsInventTable.ItemId).productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
        }

        if (whsInventTable.rfDescription2)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", whsInventTable.rfDescription2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
        }

        ret += [this.buildControl(#RFText, #CurrentQty, "@SYS105177", 1, pass.lookup(#CurrentQty), extendedTypeNum(Qty), '', 0, false)];
        ret += [this.buildControl(#RFText, #CurrentUOM, "@WAX721", 1, pass.lookup(#CurrentUOM), extendedTypeNum(UnitOfMeasureSymbol), '', 0, false)];
        ret += [this.buildControl(#RFText, #RecvLocationId, "@WAX1196", 1, this.receivingLocationId(), extendedTypeNum(WMSLocationId), '', 0, false)];

        WHSRFMenuItemTable menuItemTable = WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem));

        if (this.canPromptForAutoGenerateLPWeight() && this.isReceivingLocationLPControlled())
        {
            ret += [this.buildControl(#RFText,
                                    #LicensePlateId,
            "@WAX1198",
                                    1,
                                    WHSLicensePlate::generateLicensePlateId(pass.lookup(#ItemId), pass.lookup(#CurrentUOM)),
                                    extendedTypeNum(WHSLicensePlateId),
                                    '',
                                    0,
                                    false)];
        }
        else
        {
            WHSLicensePlateId licensePlateId = pass.hasValue(#LicensePlateId) ? pass.lookupStr(#LicensePlateId) : '';
            boolean enableLicensePlateIdControl = !(menuItemTable.GenerateLP && licensePlateId);

            ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0, enableLicensePlateIdControl)];
        }

        if (PdsGlobal::pdsIsCWItem(pass.lookup(#ItemId))
        &&  !WHSInventTable::shouldCaptureAggregateWeight(pass.lookup(#ItemId))
        &&  !WHSInventTable::isCatchWeightTagTracked(pass.lookup(#ItemId))
        &&  !this.captureTrackingDimensions(pass.lookup(#ItemId)))
        {
            ret += [this.buildControl(#RFText, WHSWorkExecuteDisplayCatchWeightControls::CatchWeight, "@WAX:Weight", 1, pass.lookupStr(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight), extendedTypeNum(Weight), '', 0)];
        }

        if (menuItemTable.DisplayContainerTypeCode == NoYes::Yes)
        {
            if (pass.hasValue(#LicensePlateId))
            {
                ret = this.buildContainerType(ret, pass.lookupStr(#ContainerType));

                if (!pass.exists(#Initiation))
                {
                    pass.insert(#Initiation, 1);
                }
            }
            else if (!pass.exists(#Initiation) && pass.hasValue(#ContainerType))
            {
                pass.remove(#ContainerType);
            }
        }

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayDispositionCodeControl</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal protected boolean displayDispositionCodeControl()
    {
        if (pass.lookupNum(#Qty) == 0)
        {
            return false;
        }
        
        return WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).ShowDisposition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPOReceiving</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for PO Receiving screen.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_extratext">
    /// Label text.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    protected abstract container buildPOReceiving(container _con, str _extratext = '')
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchLine</Name>
				<Source><![CDATA[
    [SysObsolete('Logic has been moved to WHSWorkExecuteDisplay.receivingOrderLine', false, 13\02\2023)]
    protected abstract PurchLine getPurchLine(WHSRFPassthrough _pass)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderLine</Name>
				<Source><![CDATA[
    private WHSReceiptOrderLine getOrderLine(WHSRFPassthrough _pass)
    {
        // If receiving a purchLine, call the obsolete version of the method to ensure extenders still have their logic run.
        if (this.receivingOrderProvider().inventTransType() == InventTransType::Purch)
        {
            return this.getPurchLine(_pass);
        }

        return this.receivingOrderLine(_pass);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPOReceivingAndPutawayExecuteMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the receiving and putaway execute mode enum value of the current process.
    /// </summary>
    /// <returns>
    /// The receiving and putaway execute mdoe enum value.
    /// </returns>
    protected abstract WHSWorkExecuteMode getPOReceivingAndPutawayExecuteMode()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>workProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the work process enum value of the current process.
    /// </summary>
    /// <returns>
    /// The work process enum value.
    /// </returns>
    [Hookable(false)]
    protected WhsWorkProcess workProcess()
    {
        return WhsWorkProcess::All;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultReceivingQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the default receiving quantity.
    /// </summary>
    /// <returns>The default receiving quantity.</returns>
    protected WHSProdQty defaultReceivingQuantity()
    {
        if (pass.parmItemId())
        {
            WHSInventTable whsInventTable = WHSInventTable::find(pass.parmItemId());
            return whsInventTable.ProdQty;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates work based on the given <c>PurchLine</c>.
    /// </summary>
    /// <param name = "_purchLine">
    /// The purchase line to create work from
    /// </param>
    /// <returns>
    /// Work build id of the created work.
    /// </returns>
    [SysObsolete('Logic has been moved to createWorkForOrderLine', false, 15\02\2023)]
    protected WHSWorkBuildId createWork(PurchLine _purchLine)
    {
        return this.createWorkInternal(_purchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkForOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates work based on the given <c>WHSReceiptOrderLine</c>.
    /// </summary>
    /// <param name = "_orderLine">
    /// The inbound order line to create work from.
    /// </param>
    /// <returns>
    /// Work build id of the created work.
    /// </returns>
    protected WHSWorkBuildId createWorkForOrderLine(WHSReceiptOrderLine _orderLine)
    {
        // If the passed buffer is a purchLine, call the obsolete version of the method to ensure extenders still have their logic run.
        if (_orderLine is PurchLine)
        {
            return this.createWork(_orderLine as PurchLine);
        }

        return this.createWorkInternal(_orderLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkInternal</Name>
				<Source><![CDATA[
    private WHSWorkBuildId createWorkInternal(WHSReceiptOrderLine _orderLine)
    {
        WHSLicensePlate licensePlate = WHSLicensePlate::createLicensePlate(pass.lookup(#LicensePlateId), true, this.getDefaultContainerTypeCode());
       
        WHSWorkCreatePurchLine workCreatePurchLine = new WHSWorkCreatePurchLine(_orderLine);
        workCreatePurchLine.parmLoadId(pass.lookupStr(#LoadId));
        workCreatePurchLine.parmInventLocationId(pass.lookup(#InventLocationId));
        workCreatePurchLine.parmInventQty(WHSCatchWeightHelper::convertInventQuantity(_orderLine.ItemId,
                                                                                 pass.lookup(#CurrentUOM),
                                                                                 pass.lookupNum(#CurrentQty),
                                                                                 _orderLine.InventDimId));
        
        Qty calcCatchWeight;
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_orderLine.ItemId);
        InventHandlingQty totalReceiptQty = WHSCatchWeightHelper::convertInventQuantity(pass.lookup(#ItemId), pass.lookup(#UOM), pass.lookupNum(#Qty), _orderLine.InventDimId);

        if (isCWItem)
        {
            if (WHSDeferredPOReceivingHandleCatchWeightFlight::instance().isEnabled())
            {
                calcCatchWeight = WHSCatchWeightHelper::calculateCatchWeightAndUpdatePass(_orderLine.ItemId, workCreatePurchLine.parmInventQty(), totalReceiptQty, pass);
                workCreatePurchLine.parmCatchWeight(calcCatchWeight);
            }
            else
            {
                if (WHSInventTable::shouldCaptureAggregateWeight(_orderLine.ItemId))
                {
                    calcCatchWeight = WHSCatchWeightHelper::calculateAverageWeight(workCreatePurchLine.parmInventQty(),
                                                                        totalReceiptQty - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtySum),
                                                                        pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight) - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightWeightSum),
                                                                        InventTable::inventDecimals(_orderLine.ItemId));
                }
                else
                {
                    // If not capturing aggregate weight use work creation handling quantity rounded to correct decimal precision.
                    calcCatchWeight = WHSCatchWeightHelper::calculateAverageWeight(workCreatePurchLine.parmInventQty(),
                                                                        workCreatePurchLine.parmInventQty(),
                                                                        pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight),
                                                                        InventTable::inventDecimals(_orderLine.ItemId));

                    pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight);
                }

                workCreatePurchLine.parmCatchWeight(calcCatchWeight);

                if (workCreatePurchLine.parmInventQty() != (totalReceiptQty - pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtySum)))
                {
                    pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtySum, pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightQtySum) + workCreatePurchLine.parmInventQty());
                    pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightWeightSum, pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightWeightSum) + calcCatchWeight);
                }
            }
        }

        // Auto Generate catch weight tag records based on configs
        if (isCWItem
            && WHSInventTable::isCatchWeightTagTracked(_orderLine.ItemId)
            && WHSInventTable::shouldCaptureAggregateWeight(_orderLine.ItemId)
            && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateCatchWeightTag
            && !WHSReceiptDetails::existByReceiptIdLicensePlate(pass.lookup(#ReceiptId), pass.lookup(#LicensePlateId)))
        {
            WHSCatchWeightTagCreationSource tagSource = WHSCatchWeightTagCreationSource::instantiateFromSource(_orderLine, pass);
            WHSCatchWeightTagCreationMethod tagMethod = WHSCatchWeightTagCreationMethod::newAutoTagCreation(workCreatePurchLine.parmInventQty(), calcCatchWeight);
            WHSCatchWeightTagCreator tagCreator = WHSCatchWeightTagCreator::construct();
            this.trackAutoGeneratedCatchWeightTags(tagCreator.createCatchWeightTags(tagSource, tagMethod));
        }
        
        workCreatePurchLine.parmCreatedBy(userId);
        workCreatePurchLine.parmUnitizeQty(totalReceiptQty);
        workCreatePurchLine.parmLicensePlateGroupingPolicy(pass.lookup(#Unitization));
        workCreatePurchLine.parmTargetLicensePlateId(licensePlate.LicensePlateId);
        workCreatePurchLine.parmWorkTemplateCode(WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).WorkTemplateCode);
        workCreatePurchLine.parmDispositionCode(pass.lookupStr(#Disposition));
        workCreatePurchLine.parmReceiptId(pass.lookup(#ReceiptId));
        workCreatePurchLine.parmWorkProcess(this.workProcess());
        workCreatePurchLine.parmStartLocationId(this.receivingLocationId());

        WHSWorkBuildId workBuildId = workCreatePurchLine.createWork();

        if (isCWItem && pass.exists(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList))
        {
            WHSCatchWeightTagLastRegistration::updateCatchWeightTagRegistrationWorkLine(str2con(pass.lookupStr(WHSWorkExecuteDisplayCatchWeightControls::ScannedCatchWeightTagList)),
                WHSWorkTable::findSingleInboundWorkByWorkBuildId(workBuildId).WorkId);
        }

        return workBuildId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPOReceivingInfiniteLoopLog</Name>
				<Source><![CDATA[
    private void createPOReceivingInfiniteLoopLog(WHSRFPassthrough _fieldValues)
    {
        UserConnection conn = new UserConnection();

        try
        {
            conn.ttsbegin();

            WHSOperationInternalErrorLog errorLog;

            errorLog.setConnection(conn);
            errorLog.ErrorType   = WHSOperationInternalErrorType::InfiniteLoop;
            errorLog.ClassName   = classStr(WHSWorkExecuteDisplayPOReceiving);
            errorLog.LogMsg      = strFmt('{ "mode": "%1", "fieldValues": %2, "pass": %3}', enum2Symbol(enumNum(WHSWorkExecuteMode), enum2int(mode)), _fieldValues.toString(), pass.toString());

            errorLog.insert();

            conn.ttscommit();

            WHSWarehouseMobileDeviceTelemetryEventLogger::logMobileDeviceRequestInternalError(WHSOperationInternalErrorType::InfiniteLoop, errorLog.RecId);
        }
        finally
        {
            conn.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLicensePlateLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build labels for license plate.
    /// </summary>
    /// <param name = "_workBuildId">The work build id of the created work.</param>
    protected void buildLicensePlateLabels(WHSWorkBuildId _workBuildId)
    {
        var builder = WHSWorkExecuteDisplayLicensePlateLabelBuilder::newFromPass(pass);
        builder.parmWorkBuildId(_workBuildId);
        builder.buildLicensePlateLabels();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLicensePlateLabelsWithoutWork</Name>
				<Source><![CDATA[
    [SysObsolete('Logic has been moved to buildLicensePlateLabelsWithoutWorkForOrderLine', false, 13\02\2023)]
    protected void buildLicensePlateLabelsWithoutWork(PurchLine _purchLine)
    {
        this.buildLicensePlateLabelsWithoutWorkInternal(_purchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLicensePlateLabelsWithoutWorkForOrderLine</Name>
				<Source><![CDATA[
    protected void buildLicensePlateLabelsWithoutWorkForOrderLine(WHSReceiptOrderLine _orderLine)
    {
        // If the passed buffer is a purchLine, call the obsolete version of the method to ensure extenders still have their logic run.
        if (_orderLine is PurchLine)
        {
            this.buildLicensePlateLabelsWithoutWork(_orderLine as PurchLine);
            return;
        }

        this.buildLicensePlateLabelsWithoutWorkInternal(_orderLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLicensePlateLabelsWithoutWorkInternal</Name>
				<Source><![CDATA[
    private void buildLicensePlateLabelsWithoutWorkInternal(WHSReceiptOrderLine _orderLine)
    {
        WHSRFMenuItemTable rfMenuItem = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));

        if (receivingWorkWasDeferred)
        {
            WHSDeferredReceivingPolicy deferredReceivingPolicy = WHSDeferredReceivingPolicy::find(rfMenuItem.DeferredReceivingPolicyId);

            if (deferredReceivingPolicy.LabelPrintingOnConfirmingReceiving != WHSDeferredReceivingPrintLabelProcessEnum::DoNotGenerateLabels)
            {
                WHSLicensePlateLabelBuildWithoutWorkParameters parameters = new WHSLicensePlateLabelBuildWithoutWorkParameters(_orderLine,
                                                                                                                        _orderLine.workTransType(),
                                                                                                                        pass.lookup(#CurrentUOM),
                                                                                                                        pass.lookupReal(#CurrentQty),
                                                                                                                        pass.lookupStr(#ShipmentId),
                                                                                                                        pass.lookupStr(#LoadId),
                                                                                                                        pass.lookup(#LicensePlateId),
                                                                                                                        pass.lookup(#UserId));


                WHSLicensePlateLabelBuildWithoutWork labelBuild = WHSLicensePlateLabelBuildWithoutWork::newFromWorkTransTypeAndParameters(_orderLine.workTransType(), parameters);

                boolean skipPrint = deferredReceivingPolicy.LabelPrintingOnConfirmingReceiving == WHSDeferredReceivingPrintLabelProcessEnum::OnlyGenerateLabels;

                using (var noPrintContext = skipPrint ? WHSDeferredReceivingSkipPrintContext::construct() : null)
                {
                    labelBuild.buildLicensePlateLabels();
                }
            }
        }
        else if (rfMenuItem.PrintLabel)
        {   
            WHSLicensePlateLabelBuildWithoutWorkParameters parameters = new WHSLicensePlateLabelBuildWithoutWorkParameters(_orderLine,
                                                                                                                           _orderLine.workTransType(),
                                                                                                                           pass.lookup(#CurrentUOM),
                                                                                                                           pass.lookupReal(#CurrentQty),
                                                                                                                           pass.lookupStr(#ShipmentId),
                                                                                                                           pass.lookupStr(#LoadId),
                                                                                                                           pass.lookup(#LicensePlateId),
                                                                                                                           pass.lookup(#UserId));
                                                                                                                            
                                                                                                                                                
            WHSLicensePlateLabelBuildWithoutWork labelBuild = WHSLicensePlateLabelBuildWithoutWork::newFromWorkTransTypeAndParameters(_orderLine.workTransType(), parameters);

            labelBuild.buildLicensePlateLabels();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInventoryDimensionsControlsFromInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds RF text controls for inventory dimensions based on the specified <c>InventDim</c> record.
    /// </summary>
    /// <param name="_con">
    /// The current RF container we are adding text controls to.
    /// </param>
    /// <param name="_itemId">
    /// The item whose inventory dimensions we are adding controls for.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimension record we are basing inventory dimension controls on.
    /// </param>
    /// <param name="_enableControls">
    /// Boolean to determine whether added text controls should be editable.
    /// </param>
    /// <returns>
    /// An updated RF container which includes text controls for the item's product dimensions.
    /// </returns>
    protected container buildInventoryDimensionsControlsFromInventDim(
        container   _con,
        ItemId      _itemId,
        InventDim   _inventDim,
        boolean     _enableControls = true)
    {
        return this.buildProductDimensionsFromInventDim(_con, _itemId, _inventDim, _enableControls);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePassAndDisplayToExecutePutawayWork</Name>
				<Source><![CDATA[
    private container updatePassAndDisplayToExecutePutawayWork(
                                            WHSWorkBuildId          _workBuildId,
                                            WhsWorkExecuteDisplay   _workExecuteDisplay,
                                            container               _con,
                                            WMSLocationId           _newLocationId,
                                            str                     _buttonClicked)
    {
        container con = _con;
        container ret;

        this.removeTrackingDimensionsFromPass(pass.lookup(#ItemId));
        pass.remove(#DimQty);
        pass.insert(#DimUOM, WHSCatchWeightHelper::inventHandlingUnitId(pass.lookup(#ItemId)));

        workLine = WHSWorkTable::getFirstWorkLineByWorkBuildId(_workBuildId, userId);
        if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
        {
            throw error("@WAX1459");
        }
        workTable = workLine.whsWorkTable();

        if (workLine)
        {
            pass.insert(#DetermineStep, 1);
            Qty tmpQty = pass.lookupNum(#RunningQty);
            WHSMenuItemName menuItem = pass.lookup(#MenuItem);
            con = this.updateModeStepPass(con, mode, step, pass);

            boolean recall;
            container tmpPass;
            [ret, step , recall, tmpPass] = this.processWorkLine(workLine, con, mode, step, userId, _newLocationId, _buttonClicked, false);
            pass = new WHSRFPassthrough(Types::String, Types::String);
            pass = WHSRFPassthrough::create(tmpPass);

            pass.insert(#RunningQty, tmpQty);
            pass.insert(#MenuItem, menuItem);

            if (step == #Restart)
            {
                step = 0;
            }
            else if (step == #StepOne)
            {
                step = 1;
                pass.insert(#DetermineStep, 1);
            }

            con = this.updateModeStepPass(ret, mode, step, pass);
            con = conPoke(con, 1, [mode, step]);
            _workExecuteDisplay.setGlobals(mode, step, userId, pass, null);
            ret = _workExecuteDisplay.displayForm(con, _buttonClicked);
            pass = new WHSRFPassthrough(Types::String, Types::String);
            pass = WHSRFPassthrough::create(conPeek(ret, 2));
            pass.insert(#DoingWork, 1);
            if (pass.exists(#WorkId) && pass.exists(#LineNum))
            {
                workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                {
                    throw error("@WAX1459");
                }
                workTable = workLine.whsWorkTable();
            }
        }

        return [con, ret];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQtyAndUOMPassValuesForReceivingTheNextLP</Name>
				<Source><![CDATA[
    private void updateQtyAndUOMPassValuesForReceivingTheNextLP(WHSReceiptOrderLine _orderLine)
    {
        Qty                 finalQty;
        UnitOfMeasureSymbol finalUnitId;

        [finalQty, finalUnitId] = this.unitizeQtyForNextLicensePlate(
                                            pass,
                                            _orderLine.ItemId,
                                            _orderLine.InventDimId);

        pass.insert(#CurrentQty, finalQty);
        pass.insert(#CurrentUOM, finalUnitId);
        pass.insert(#CurrentLP, str2int(pass.lookup(#CurrentLP)) + 1);

        //Since we will not display the tracking dim screen and will be returning back to the previous one
        //we need to clear values that are not related to the current tracking dim screen.
        pass.remove(#SerialId);
        pass.remove(#LicensePlateId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayForm</Name>
				<Source><![CDATA[
    public container displayForm(container _con, str _buttonClicked = '')
    {
        using(var activeContextRecursion = this.displayFormRecursionActivityContext())
        {
            displayFormRecursionDepth++;
            this.instrumentationLogger().executePOReceiving().displayFormRecursionDepth(activeContextRecursion, displayFormRecursionDepth);

            container con = _con;
            WHSRFPassthrough globalPass = pass;
            pass = WHSRFPassthrough::create(conPeek(_con, 2));

            if (globalPass.exists(#CurrentUOM)                              &&
                pass.exists(#CurrentUOM)                                    &&
                globalPass.lookup(#CurrentUOM)  != ''                       &&
                pass.lookup(#CurrentUOM)        != ''                       &&
                globalPass.lookup(#CurrentUOM)  != pass.lookup(#CurrentUOM) &&
                step == 2)
            {
                pass.insert(#CurrentUOM, globalPass.lookup(#CurrentUOM));
            }

            pass = this.combineMaps(globalPass, pass);

            int hasError = this.hasError(_con);

            WMSLocationId   newLocationId;
            WhsWorkExecute  workExecute = WhsWorkExecute::construct();

            if (_buttonClicked == #RFException)
            {
                // Exception
                step = #ReceivingExceptionStep1;
            }
            else if (_buttonClicked == #RFOverride)
            {
                // Exception
                step = #OverrideStep1;
            }
            else if (_buttonClicked == #RFFull && step != 0)
            {
                step = #SplitWork;
            }
            else if (_buttonClicked == #RFNoLocation)
            {
                Set excludeLocationId = new Set(Types::String);

                workLine = WHSWorkLine::find(pass.lookupStr(#WorkId), pass.parmLineNum());
                if (pass.exists(#ExcludedLocations))
                {
                    excludeLocationId = this.buildLocationListFromStr(pass.lookup(#ExcludedLocations));
                }
                else
                {
                    excludeLocationId = this.buildLocationListFromStr(workLine.wmsLocationId);
                }
                container tmpCon;
                [newLocationId, tmpCon] = workExecute.findNewLocation(workLine, excludeLocationId);
                excludeLocationId = Set::create(tmpCon);
                pass.insert(#SuggestLocation, 1);
                pass.insert(#ExcludedLocations, this.buildLocationListFromSet(excludeLocationId));
                if (pass.exists(#PrevStep))
                {
                    step = pass.lookup(#PrevStep);
                }
                else
                {
                    pass.insert(#NoValidation, '1');
                }
            }
            else if (_buttonClicked == #RFSplitPut)
            {
                this.validateSplitPutAllowed();
                step = #SplitPutWork;
            }

            int startInfologLine = infologLine() + 1;

            container                   ret = conNull();
            boolean                     addCancel = true;
            WHSRFPassthrough            fieldValues = new WHSRFPassthrough(Types::String, Types::String);
            container                   tmpFieldValues;
            boolean                     complete;
            int                         numLP;
            Qty                         finalQty;
            UnitOfMeasureSymbol         finalUnitId;
            boolean                     addExceptionButton;
            WHSWorkExecuteDisplay       workExecuteDisplay = WHSWorkExecuteDisplay::construct(mode);
            WHSReceiptOrderLine         orderLine;
            boolean                     displayTrackingForm = false;
            WHSWorkBuildId              workBuildId;

            switch (step)
            {
                case 0,1:
                    if (pass.exists(#WorkComplete))
                    {
                        ret = this.addErrorLabel(ret, "@WAX866", WHSRFColorText::Success);
                        pass.remove(#WorkComplete);
                        addCancel = false;

                        ret = this.addClusterMessages(ret);
                    }

                    if (step)
                    {
                        if (hasError)
                        {
                            con = this.removeErrorMessages(con);
                        }

                        [con, tmpFieldValues] = WHSRFControlData::processDataWithCallback(this, con, pass);
                        fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                        pass = this.combineMaps(pass, fieldValues);
                        hasError = this.hasError(con);

                        if (hasError)
                        {
                            ret = con;
                            ret = this.rebuildUOM(ret, false, #UOM);
                            addCancel = false;
                            break;
                        }
                    }
                    else
                    {
                        step = 1;
                        pass.insert(#Initiation, '1');
                        pass.insert(#NoOverrideButton, 1);
                    }

                    boolean displayContainerType = WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem)).DisplayContainerTypeCode;

                    con = this.buildPOReceiving(ret);

                    if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).Unitization == WHSLicensePlateGroupingPolicy::UserDefined
                        && numOfDec(pass.lookupNum(#Qty)))
                    {
                        throw error("@WAX:ReceivingQuantityCannotBeDecimalWithUserDefinedLPGroupingError");
                    }

                    if (pass.exists(#Qty) && fieldValues.exists(#Qty) && pass.lookupNum(#Qty) != fieldValues.lookupNum(#Qty))
                    {
                        fieldValues.insert(#Qty, pass.lookup(#Qty));
                    }

                    this.updateInventoryDimensionFieldValues(fieldValues);

                    if (!fieldValues.empty())
                    {
                        [ret, complete] = this.processFieldValues(con, fieldValues);

                        if (complete)
                        {
                            if (!pass.exists(#Initiation) && !pass.exists(#CurrentUOM))
                            {
                                orderLine = this.getOrderLine(pass);

                                if (!orderLine)
                                {
                                    throw error(this.getErrorMessageForNotFoundProductDimensionsOnPurchOrder(this.receivingOrderProvider().orderNum(pass)));
                                }

                                this.checkReceiptAtWarehouseAllowed(orderLine, pass.lookup(#InventLocationId));

                                if (!this.checkWarehouseAllowsRFReceipt(pass.lookup(#InventLocationId)))
                                {
                                    throw error("@WAX4806");
                                }
                                                        
                                pass.parmUnitization(WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).Unitization);

                                this.validateOverdeliveryForOrderLine(pass, orderLine);

                                Qty qtyReceived = WHSCatchWeightHelper::convertInventQuantity(pass.lookup(#ItemId), pass.lookup(#UOM), pass.lookupNum(#Qty), orderLine.InventDimId);

                                [numLP, finalQty, finalUnitId] = this.unitizeQuantityForOrderLine(orderLine, qtyReceived);

                                if (numLP > 1 && mode == this.getPOReceivingAndPutawayExecuteMode())
                                {
                                    throw error("@WAX1615");
                                }

                                pass.insert(#CurrentQty, finalQty);
                                pass.insert(#CurrentUOM, finalUnitId);
                                pass.insert(#NumLP, numLP);
                                pass.insert(#CurrentLP, 1);

                                Qty runningQty = this.retrieveCurrentRunningQuantityForOrderReceiving(orderLine, numLP, qtyReceived);

                                pass.insert(#RunningQty, runningQty);

                                this.storeSerialToReceive(orderLine);

                                if ((WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem)).GenerateLP || !this.isReceivingLocationLPControlled())
                                    && !this.canPromptForAutoGenerateLPWeight())
                                {
                                    pass.insert(#RunningQty, pass.lookupStr(#QtyReceived, '0'));
                                    step = 2;
                                    ret = this.displayForm(_con);
                                    addCancel = false;
                                    break;
                                }

                                // Number of license plate prompt during inbound order receiving for user defined grouping policy should be equal to the quantity when the license plates are generated manually.
                                if (pass.parmUnitization() == WHSLicensePlateGroupingPolicy::UserDefined)
                                {
                                    pass.insert(#RunningQty, runningQty - 1);
                                }

                                pass.remove(#Initiation);
                                pass.remove(#NoOverrideButton);
                                ret = conNull();
                                ret = this.buildGetPOLineLP(ret);
                                ret = this.addCancelButton(ret, 1, true);
                                step = 2;
                            }
                            else
                            {
                                addExceptionButton = true;
                                pass.insert(#HideExceptionButton, '1');
                                pass.remove(#Initiation);
                                pass.remove(#NoOverrideButton);
                            }
                        }
                    }
                    else
                    {
                        ret = con;
                    }
                    break;
                case 2:
                    if (hasError)
                    {
                        con = this.removeErrorMessages(con);
                    }
                    if (pass.exists(#WorkId) && pass.exists(#LineNum))
                    {
                        pass.remove(#WorkId);
                        pass.remove(#LineNum);
                    }

                    if (!pass.exists(#ReceiptId))
                    {
                        pass.insert(#ReceiptId, NumberSeq::newGetNum(WHSParameters::numRefWHSReceiptId()).num());
                    }

                    pass.remove(#UpdatedBatchId);

                    [con, tmpFieldValues] = WHSRFControlData::processDataWithCallback(this, con, pass);
                    fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                    pass = this.combineMaps(pass, fieldValues);
                    hasError = this.hasError(con);

                    if (hasError)
                    {
                        ret = conNull();
                        ret = this.addErrorLabel(ret, conPeek(conPeek(con, #IndexOfErrorControlInContainer), #IndexOfErrorControlInContainer));
                        ret = this.buildGetPOLineLP(ret);
                        addCancel = false;
                        break;
                    }

                    WHSRFMenuItemTable menuItemTable = WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem));
                    boolean continueToNextStep;
                    boolean wasWorkCreated = false;

                    if ((menuItemTable.GenerateLP || !this.isReceivingLocationLPControlled())
                        && !this.canPromptForAutoGenerateLPWeight())
                    {
                        using (var deferredReceivingBatchTaskBundleCreationContext = WHSDeferredReceivingBatchTaskBundleCreationFlight::instance().isEnabled() ? WHSDeferredReceivingBatchTaskBundleCreationContext::construct() : null)
                        {
                            while (pass.lookupNum(#RunningQty) > 0)
                            {
                                if (!fieldValues.empty())
                                {
                                    if (!pass.exists(#LicensePlateId))
                                    {
                                        pass.insert(#LicensePlateId, WHSLicensePlate::generateLicensePlateId(pass.lookup(#ItemId), pass.lookup(#CurrentUOM)));                                  
                                    }

                                    if (menuItemTable.DisplayContainerTypeCode && !pass.exists(#ContainerType))
                                    {
                                        ret = this.buildGetPOLineLP(conNull());
                                        displayContainerType = true;
                                        break;
                                    }

                                    [ret, complete] = this.processFieldValues(con, fieldValues);

                                    if (complete)
                                    {
                                        orderLine = this.getOrderLine(pass);

                                        this.checkReceiptAtWarehouseAllowed(orderLine, pass.lookup(#InventLocationId));

                                        //For each license plate we will get all the tracking dimensions
                                        if (this.captureTrackingDimensions(pass.lookupStr(#ItemId))
                                        && !WHSReceiptDetails::existByReceiptIdLicensePlate(pass.lookup(#ReceiptId), pass.lookup(#LicensePlateId)))
                                        {
                                            trackingDimCaptureInProgressForGeneratedLP = true;

                                            if (this.mustCaptureSerialOnReceipt(pass.lookupStr(#ItemId)))
                                            {
                                                pass.insert(#CaptureSerial, true);
                                            }
                                            else if(InventTable::find(pass.lookupStr(#ItemId)).isItemGTDNumberActivated())
                                            {
                                                pass.insert(#CaptureGTDId, true);
                                            }

                                            int currentStep = step;

                                            ret = this.displayTrackingDimForm(ret, _buttonClicked, orderLine.InventDimId);
                                        
                                            if (pass.exists(#CaptureSerial))
                                            {
                                                pass.remove(#CaptureSerial);
                                                ret = this.updateModeStepPass(ret, mode, step, pass);
                                                this.resetDisplayFormRecursionDepth();
                                                return ret;
                                            }
                                            else if(pass.exists(#CaptureGTDId))
                                            {
                                                pass.remove(#CaptureGTDId);
                                                ret = this.updateModeStepPass(ret, mode, step, pass);
                                                this.resetDisplayFormRecursionDepth();
                                                return ret;
                                            }

                                            if (this.needsTrackingDisplayForm())
                                            {
                                                displayTrackingForm = true;
                                                break;
                                            }

                                            if (!displayTrackingForm)
                                            {
                                                step = currentStep;
                                            }
                                        }

                                        // In case of tracking dimensions are not enabled OR enabled but with auto generation during inventory or physical update - then start capturing the tags here.
                                        if ((!this.captureTrackingDimensions(pass.lookup(#ItemId))
                                                || this.continueTrackingDimCaptureForSameLine())
                                            && WHSInventTable::mustCaptureCatchWeightTagsPerCatchWeightUnit(pass.lookup(#ItemId), pass.lookup(#MenuItem))
                                            && !pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
                                        {
                                            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, 1);
                                            pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty, WHSCatchWeightHelper::convertInventQuantity(orderLine.ItemId,
                                                                                                                    pass.lookup(#CurrentUOM),
                                                                                                                    pass.lookupNum(#CurrentQty),
                                                                                                                    orderLine.InventDimId));

                                            ret = this.buildCWTagCapture(conNull());
                    
                                            step = #CatchWeightTagCapture;
                                            displayTrackingForm = true;
                                            break;
                                        }

                                        if (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
                                        {
                                            pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty);
                                        }
                                    
                                        if (this.validateCreateReceivingWorkForOrderLine(orderLine))
                                        {
                                            receivingWorkWasDeferred = false;

                                            if (menuItemTable.DeferredReceivingPolicyId != "")
                                            {
                                                receivingWorkWasDeferred = this.tryToDeferWork(orderLine, menuItemTable);
                                            }
                                        
                                            if (receivingWorkWasDeferred)
                                            {
                                                pass.parmReceiptId(NumberSeq::newGetNum(WHSParameters::numRefWHSReceiptId()).num());
                                            }
                                            else
                                            {
                                                workBuildId = this.createWorkForOrderLine(orderLine);
                                                wasWorkCreated =  WHSWorkTable::existsForWorkBuildId(workBuildId);
                                            }
                                        }
                                        else
                                        {
                                            ret = this.addErrorLabelFromInfolog(conNull(), startInfologLine, WHSRFColorText::Error);
                                            ret = this.buildPOReceiving(ret);
                                            // Return to step 1 as inbound order line could not be validated. Let user confirm again before moving to step 2 and processing as normal.
                                            step = 1;
                                            break;
                                        }

                                        if (orderLine.inventTable().ItemType != ItemType::Service)
                                        {
                                            if (wasWorkCreated)
                                            {
                                                this.buildLicensePlateLabels(workBuildId);
                                            }
                                            else
                                            {
                                                this.buildLicensePlateLabelsWithoutWorkForOrderLine(orderLine);
                                            }
                                        }

                                        this.removeTrackingDimensionsFromPass(pass.lookupStr(#ItemId));
                                        Qty runningQty = this.getRunningQuantityForOrderReceiving(orderLine);
                                        pass.insert(#RunningQty, runningQty);
                                        this.updateQtyAndUOMPassValuesForReceivingTheNextLP(orderLine);

                                        if (runningQty > 0)
                                        {
                                            fieldValues.insert(#CurrentUOM, pass.lookup(#CurrentUOM));
                                        }
                                        if (wasWorkCreated)
                                        {
                                            [continueToNextStep, ret] = this.assigningPutawayCluster(ret, workBuildId, step, menuItemTable);
                                        }

                                        if (continueToNextStep)
                                        {
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        // this shouldn't be reached. Infinite loop reached.
                                        this.createPOReceivingInfiniteLoopLog(fieldValues);

                                        throw error("@WAX:WarehouseMobileDevicePOReceivingRequestInfiniteLoop");
                                    }
                                }
                            }
                        }

                        trackingDimCaptureInProgressForGeneratedLP = false;
                        if (displayTrackingForm
                            || (!workBuildId && pass.lookupNum(#RunningQty))
                            || displayContainerType
                            || step == #SortReceive)
                        {
                            break;
                        }

                        if (mode == this.getPOReceivingAndPutawayExecuteMode() 
                            && !this.isNonSalesItemReqPOProjectPurchLine(orderLine)
                            && wasWorkCreated
                            && (orderLine.inventTable().ItemType != ItemType::Service))
                        {
                            [con, ret] = this.updatePassAndDisplayToExecutePutawayWork(workBuildId,
                                                                                workExecuteDisplay,
                                                                                con,
                                                                                newLocationId,
                                                                                _buttonClicked);
                        }
                        else
                        {
                            WHSLoadId tmpLoadId = pass.lookupStr(#LoadId);
                            PurchId   savedPurchId;

                            if (this.shouldRetainPurchaseOrderNumberForPutawayCluster()
                                && menuItemTable.AssignPutawayCluster)
                            {
                                savedPurchId = pass.lookupStr(#PONum);
                            }

                            pass = this.resetPassWithClusterMessages(pass, con, false);
                            pass.insert(#WorkComplete, 1);
                        
                            this.insertToWHSRFPassthrough(orderLine, tmpLoadId);

                            if (tmpLoadId)
                            {
                                pass.insert(#LoadId, tmpLoadId);
                            }

                            if (!pass.hasValue(#PONum) && savedPurchId)
                            {
                                pass.insert(#PONum, savedPurchId);
                            }

                            con = conPoke(con, 2, pass.pack());
                            step = 0;
                            workExecuteDisplay.setGlobals(mode, step, userId, pass, null);
                            ret = workExecuteDisplay.displayForm(con, _buttonClicked);
                            pass = new WHSRFPassthrough(Types::String, Types::String);
                            pass = WHSRFPassthrough::create(conPeek(ret, 2));
                            break;
                        }
                    }
                    else
                    {
                        if (!fieldValues.empty())
                        {
                            // Display screen extra time to allow for entering the container type.
                            if (pass.hasValue(#LicensePlateId)
                            &&  menuItemTable.DisplayContainerTypeCode
                            && !pass.exists(#ContainerType))
                            {
                                ret = this.buildGetPOLineLP(conNull());
                                break;
                            }

                            [ret, complete] = this.processFieldValues(con, fieldValues);

                            if (complete)
                            {
                                orderLine = this.getOrderLine(pass);

                                // If this screen is loaded again after the warning or an error, #CurrentUOM will be removed from the pass (WhsWorkExecuteDisplayLoadItemReceivinclassg).
                                // It is readded here again before creating the work.
                                if (!pass.exists(#CurrentUOM))
                                {
                                    Qty qtyReceived = WHSCatchWeightHelper::convertInventQuantity(pass.lookup(#ItemId), pass.lookup(#UOM), pass.lookupNum(#Qty), orderLine.InventDimId);
                                    [numLP, finalQty, finalUnitId] = this.unitizeQuantityForOrderLine(orderLine, qtyReceived);
                                    pass.insert(#CurrentUOM, finalUnitId);
                                }

                                this.checkReceiptAtWarehouseAllowed(orderLine, pass.lookup(#InventLocationId));

                                //For each license plate we will get all the tracking dimensions
                                if (this.captureTrackingDimensions(pass.lookupStr(#ItemId))
                                && !WHSReceiptDetails::existByReceiptIdLicensePlate(pass.lookup(#ReceiptId), pass.lookup(#LicensePlateId)))
                                {
                                    ret = this.displayTrackingDimForm(_con, _buttonClicked, orderLine.InventDimId);
                                    break;
                                }

                                if (!this.captureTrackingDimensions(pass.lookup(#ItemId))
                                && WHSInventTable::mustCaptureCatchWeightTagsPerCatchWeightUnit(pass.lookup(#ItemId), pass.lookup(#MenuItem))
                                && !pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
                                {
                                    pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagCounter, 1);
                                    pass.insert(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty, WHSCatchWeightHelper::convertInventQuantity(orderLine.ItemId,
                                                                                                            pass.lookup(#CurrentUOM),
                                                                                                            pass.lookupNum(#CurrentQty),
                                                                                                            orderLine.InventDimId));

                                    ret = conNull();
                                    ret = this.buildCWTagCapture(ret);
                   
                                    step = #CatchWeightTagCapture;
                                    break;
                                }

                                if (pass.exists(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty))
                                {
                                    pass.remove(WHSWorkExecuteDisplayCatchWeightControls::CatchWeightTagQty);
                                }

                                if (this.validateCreateReceivingWorkForOrderLine(orderLine))
                                {
                                    using (WHSVerifySingleLPLoadReceivingContext context = WHSVerifySingleLPLoadReceivingContext::construct())
                                    {
                                        boolean isAllowedLPGrouping = menuItemTable.Unitization == WHSLicensePlateGroupingPolicy::LicensePlateGrouping && pass.hasValue(#LicensePlateId);
                                        context.parmIsSingleLP(isAllowedLPGrouping);

                                        receivingWorkWasDeferred = false;

                                        if (menuItemTable.DeferredReceivingPolicyId != "")
                                        {
                                            using (var deferredReceivingBatchTaskBundleCreationContext = WHSDeferredReceivingBatchTaskBundleCreationFlight::instance().isEnabled() ? WHSDeferredReceivingBatchTaskBundleCreationContext::construct() : null)
                                            {
                                                receivingWorkWasDeferred = this.tryToDeferWork(orderLine, menuItemTable);
                                            }
                                        }
                                        
                                        if (receivingWorkWasDeferred)
                                        {
                                            pass.parmReceiptId(NumberSeq::newGetNum(WHSParameters::numRefWHSReceiptId()).num());
                                        }
                                        else
                                        {
                                            workBuildId = this.createWorkForOrderLine(orderLine);
                                            wasWorkCreated = WHSWorkTable::existsForWorkBuildId(workBuildId);
                                        }
                                    }
                                   
                                }
                                else
                                {
                                    ret = this.addErrorLabelFromInfolog(conNull(), startInfologLine, WHSRFColorText::Error);
                                    ret = this.buildPOReceiving(ret);
                                    break;
                                }

                                if (orderLine.inventTable().ItemType != ItemType::Service)
                                {
                                    if (wasWorkCreated)
                                    {
                                        this.buildLicensePlateLabels(workBuildId);
                                    }
                                    else
                                    {
                                        this.buildLicensePlateLabelsWithoutWorkForOrderLine(orderLine);
                                    }
                                }

                                if (mode == this.getPOReceivingAndPutawayExecuteMode() 
                                    && !this.isNonSalesItemReqPOProjectPurchLine(orderLine)
                                    && (wasWorkCreated)
                                    && (orderLine.inventTable().ItemType != ItemType::Service))
                                {
                                    [con, ret] = this.updatePassAndDisplayToExecutePutawayWork(workBuildId,
                                                                                workExecuteDisplay,
                                                                                con,
                                                                                newLocationId,
                                                                                _buttonClicked);
                                }

                                if ((!wasWorkCreated
                                        && this.canCompleteReceiveWithoutWork())
                                    || (pass.exists(#RunningQty)
                                        && pass.lookupNum(#RunningQty) == 0
                                        && (mode != this.getPOReceivingAndPutawayExecuteMode() 
                                            || this.isNonSalesItemReqPOProjectPurchLine(orderLine))))
                                {
                                    WHSLoadId tmpLoadId = pass.lookupStr(#LoadId);
                                    pass = this.resetPassthrough(con, false);
                                    pass.insert(#WorkComplete, 1);

                                    this.insertToWHSRFPassthrough(orderLine, tmpLoadId);

                                    if (tmpLoadId)
                                    {
                                        pass.insert(#LoadId, tmpLoadId);
                                    }

                                    if (wasWorkCreated)
                                    {
                                        [continueToNextStep, ret] = this.assigningPutawayCluster(ret, workBuildId, 0, menuItemTable);
                                    }

                                    if (continueToNextStep)
                                    {
                                        break;
                                    }
                                    
                                    con = conPoke(con, 2, pass.pack());
                                    step = 0;
                                    workExecuteDisplay.setGlobals(mode, step, userId, pass, null);
                                    ret = workExecuteDisplay.displayForm(con, _buttonClicked);
                                    pass = new WHSRFPassthrough(Types::String, Types::String);
                                    pass = WHSRFPassthrough::create(conPeek(ret, 2));
                                    break;
                                }

                                if (!this.isNonSalesItemReqPOProjectPurchLine(orderLine))
                                {
                                    //we are complete since all values are filled so
                                    if (!pass.exists(#DoingWork))
                                    {
                                        this.updateQtyAndUOMPassValuesForReceivingTheNextLP(orderLine);
                                        Qty runningQty = this.getRunningQuantityForOrderReceiving(orderLine);
                                        pass.insert(#RunningQty, runningQty);

                                        if (wasWorkCreated)
                                        {
                                            [continueToNextStep, ret] = this.assigningPutawayCluster(ret, workBuildId, step, menuItemTable);
                                        }

                                        if (continueToNextStep)
                                        {
                                            break;
                                        }                                        

                                        ret = conNull();
                                        ret = this.buildGetPOLineLP(ret);
                                    }
                                    pass.remove(#DoingWork);
                                }
                            }
                        }
                        break;
                    }
                    break;

                case #TrackingDimDetailsStep:
                    [hasError, ret, addCancel] = this.processTrackingDimDetails(2, hasError, con, fieldValues, startInfologLine, addCancel);
                    break;

                case #VendBatchDetailsStep:
                    [hasError, ret] = this.processVendorBatchDetails(hasError, con, fieldValues);
                    break;

                case #CatchWeightTagCapture:
                    ret = this.processCWTagCapture(hasError, con);
                    break;

                case #SortReceive:
                    ret = this.stepSortReceive(con, _buttonClicked);
                    break;
                    
                default:
                if (pass.exists(#WorkId))
                    {
                        if (pass.exists(#LineNum))
                        {
                            workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                        }
                        else
                        {
                            workLine = workExecute.getFirstOpenLine(pass.lookup(#WorkId), userId);
                        }

                        if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                        {
                            throw error("@WAX1459");
                        }

                        workTable = workLine.whsWorkTable();
                    }

                    Qty tmpQty = pass.lookupNum(#RunningQty);
                    WHSMenuItemName menuItem = pass.lookup(#MenuItem);
                    con = conPoke(con, 2, pass.pack());
                    WHSRFPassthrough tmpMap = pass;
                    int tmpStep = step;
                    workBuildId = workTable.WorkBuildId;

                    boolean recall;
                    container tmpPass;
                    [ret, step , recall, tmpPass] = this.processWorkLine(workLine, con, mode, step, userId, newLocationId, _buttonClicked, false);
                    pass = WHSRFPassthrough::create(tmpPass);

                    this.deleteNotCrossFormsFields(tmpMap);

                    pass = this.combineMaps(tmpMap, pass);

                    if (tmpStep != #ReceivingExceptionStep1 && tmpStep != #ReceivingExceptionStep2)
                    {
                        pass.insert(#RunningQty, tmpQty);
                    }

                    pass.insert(#MenuItem, menuItem);

                    if (step == #Restart)
                    {
                        if (pass.lookupNum(#RunningQty) == 0)
                        {
                            // Check for additional work to execute in case of cross docking
                            workLine = WHSWorkTable::findOpenCrossDockWorkByWorkBuildId(workBuildId, userId);

                            if (workLine.RecId != 0)
                            {
                                if (pass.exists(#WorkComplete))
                                {
                                    pass.remove(#WorkComplete);
                                }

                                this.restartForCrossDockInbound();
                                tmpQty = pass.parmRunningQty();
                                menuItem = pass.lookup(#MenuItem);
                                con = this.updateModeStepPass(con, mode, step, pass);
                                [ret, step , recall, tmpPass] = this.processWorkLine(workLine, con, mode, step, userId, newLocationId, _buttonClicked, false);
                                pass = WHSRFPassthrough::newReset(pass);
                                pass = WHSRFPassthrough::create(tmpPass);
                                pass.insert(#RunningQty, tmpQty);
                            }
                            else
                            {
                                orderLine = this.getOrderLine(pass);
                                WHSLoadId tmpLoadId = pass.lookupStr(#LoadId);
                                pass = WHSRFPassthrough::newReset(pass);
                                pass.insert(#WorkComplete, 1);

                                this.insertToWHSRFPassthrough(orderLine, tmpLoadId);

                                if (tmpLoadId)
                                {
                                    pass.insert(#LoadId, tmpLoadId);
                                }

                                con = conNull();
                                con = this.buildPOReceiving(con);
                                step = 0;
                            }
                        }
                        else
                        {
                            orderLine = this.getOrderLine(pass);
                            this.updateQtyAndUOMPassValuesForReceivingTheNextLP(orderLine);
                            step = 2;
                            con = conNull();
                            con = this.buildGetPOLineLP(con);
                        }
                    }
                    else if (step == #StepOne)
                    {
                        if (!pass.exists(#RebuildForm))
                        {
                            step = #StepMax;
                            pass.insert(#DetermineStep, 1);
                        }
                        else
                        {
                            ret = conNull();
                            ret = this.buildPOReceiving(ret);
                            pass.remove(#RebuildForm);
                            step = 1;
                        }
                    }

                    if (recall)
                    {
                        con = this.updateModeStepPass(con, mode, step, pass);
                        con = conPoke(con, 1, [mode, step]);
                        workExecuteDisplay.setGlobals(mode, step, userId, pass, null);
                        ret = workExecuteDisplay.displayForm(con, _buttonClicked);
                        pass = new WHSRFPassthrough(Types::String, Types::String);
                        pass = WHSRFPassthrough::create(conPeek(ret, 2));
                        if (pass.exists(#WorkId) && pass.exists(#LineNum))
                        {
                            workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                            workTable = workLine.whsWorkTable();
                        }
                    }
                    break;
            }

            if (step > 1)
            {
                ret = this.addButtons(ret);
            }
            else if (addCancel && !pass.exists(#NoCancelButton))
            {
                ret = this.addCancelButton(ret, 1, true);
            }
            else
            {
                pass.remove(#NoCancelButton);
            }
            if (addExceptionButton)
            {
                ret = this.addExceptionButton(ret);
            }

            pass.remove(#HideExceptionButton);

            ret = this.updateModeStepPass(ret, mode, step, pass);

            this.resetDisplayFormRecursionDepth();

            return ret;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryToDeferWork</Name>
				<Source><![CDATA[
    private boolean tryToDeferWork(WHSReceiptOrderLine _orderLine, WHSRFMenuItemTable _menuItemTable)
    {
        WHSDefaultContainerTypeCode defaultContainerCode = this.getDefaultContainerTypeCode();
        WHSLicensePlateId licensePlateId = pass.lookup(#LicensePlateId);
        WHSLicensePlate targetLicensePlate = WHSLicensePlate::createLicensePlate(licensePlateId, true, defaultContainerCode);

        WHSDeferredPOReceiving deferredReceiving;
        if (WHSDeferredReceivingISOFlight::instance().isEnabled())
        {
            deferredReceiving = this.createDeferredReceiving(pass, _orderLine,
                _menuItemTable, defaultContainerCode, WHSWorkTransType::Purch);
        }
        else
        {
            deferredReceiving = WHSDeferredPOReceiving::newFromParameters(
                pass, _orderLine, _menuItemTable, this.getDefaultContainerTypeCode(), WHSWorkTransType::Purch);
        }

        if (!deferredReceiving)
        {
            return false;
        }

        return deferredReceiving.tryToDeferPurchaseOrderReceiving();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDeferredReceiving</Name>
				<Source><![CDATA[
    [Wrappable(true), Replaceable(true)]
    internal WHSDeferredPOReceiving createDeferredReceiving(
        WHSRFPassthrough _pass,
        WHSReceiptOrderLine _orderLine,
        WHSRFMenuItemTable _menuItemTable,
        WHSDefaultContainerTypeCode _defaultContainerCode,
        WHSWorkTransType _workTransType)
    {
        return WHSDeferredPOReceiving::newFromParameters(_pass, _orderLine, _menuItemTable,
           _defaultContainerCode, _workTransType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNonSalesItemReqPOProjectPurchLine</Name>
				<Source><![CDATA[
    private boolean isNonSalesItemReqPOProjectPurchLine(WHSReceiptOrderLine _orderLine)
    {
        var purchLine = _orderLine as PurchLine;
        return purchLine && purchLine.isProjectPurchase() && !purchLine.purchTable().isProjectSalesItemReqPO();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteNotCrossFormsFields</Name>
				<Source><![CDATA[
    private void deleteNotCrossFormsFields(WhsrfPassthrough _tmpMap)
    {
        
        if (_tmpMap.exists(#SerialId))
        {
            _tmpMap.remove(#SerialId);
        }
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryDimensionFieldValues</Name>
				<Source><![CDATA[
    private void updateInventoryDimensionFieldValues(WHSRFPassthrough _fieldvalues)
    {
        ListEnumerator le = InventDimGroupSetup::newItemIdNoStorageDimensions(pass.lookupStr(#ItemId)).activeFields().getEnumerator();

        while (le.moveNext())
        {
            FieldName fieldName = fieldId2name(tableNum(InventDim), le.current());

            if (pass.exists(fieldName) && _fieldvalues.exists(fieldName) && !_fieldvalues.lookupStr(fieldName))
            {
                _fieldvalues.insert(fieldName, pass.lookupStr(fieldName));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getErrorMessageForNotFoundProductDimensionsOnPurchOrder</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal str getErrorMessageForNotFoundProductDimensionsOnPurchOrder(PurchId _purchId)
    {
        return "@SYP4861068";
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertToWHSRFPassthrough</Name>
				<Source><![CDATA[
    protected void insertToWHSRFPassthrough(WHSReceiptOrderLine _orderLine, WHSLoadId _tmpLoadId)
    {
        if (_orderLine
            && (!_tmpLoadId
                || WHSLoadTable::find(_tmpLoadId).OrderNum == _orderLine.OrderNumber))
        {
            this.receivingOrderProvider().setOrderNum(pass, _orderLine.OrderNumber);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRunningQuantityForPurchaseOrderReceiving</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the running quantity for the purchase order receiving based on the various license plate grouping.
    /// </summary>
    /// <param name="_purchLine">
    /// The purchase order line  record  for which running quantity is being calculated.
    /// </param>
    /// <returns>
    /// returns the running quantity for the purchase order receiving.
    /// </returns>
    [SysObsolete('Logic has been moved to getRunningQuantityForOrderReceiving', false, 13\02\2023)]
    protected Qty getRunningQuantityForPurchaseOrderReceiving(PurchLine _purchLine)
    {
        Qty runningQty = pass.lookupNum(#RunningQty);
        return this.retrieveCurrentRunningQuantityInternal(_purchLine, runningQty - 1, runningQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRunningQuantityForOrderReceiving</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the running quantity for the inbound order receiving based on the various license plate grouping.
    /// </summary>
    /// <param name="_orderLine">
    /// The inbound order line record for which running quantity is being calculated.
    /// </param>
    /// <returns>
    /// Returns the running quantity for the inbound order receiving.
    /// </returns>
    protected Qty getRunningQuantityForOrderReceiving(WHSReceiptOrderLine _orderLine)
    {
        // If the passed buffer is a purchLine, call the obsolete version of the method to ensure extenders still have their logic run.
        if (_orderLine is PurchLine)
        {
            return this.getRunningQuantityForPurchaseOrderReceiving(_orderLine as PurchLine);
        }

        Qty runningQty = pass.lookupNum(#RunningQty);
        return this.retrieveCurrentRunningQuantityInternal(_orderLine, runningQty - 1, runningQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unitizeQuanitityForPurchaseOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unitizes quantity of a purchase order line for the license plate grouping policy and insert QtyReceived into the map that stores the current data.
    /// </summary>
    /// <param name="_purchLine">
    /// The purchase order line record.
    /// </param>
    /// <param name="_quantiyReceived">
    /// Total amount of the quantity received during purchase order receiving.
    /// </param>
    /// <returns>
    /// Container containing the number of license plates, final quantity and unit of measure.
    /// </returns>
    [SysObsolete('Logic has been moved to unitizeQuantityForOrderLine', false, 13\02\2023)]
    protected container unitizeQuanitityForPurchaseOrderLine(
        PurchLine   _purchLine,
        Qty         _quantiyReceived)
    {
        return this.unitizeQuantityInternal(_purchLine, _quantiyReceived);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unitizeQuantityForOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unitizes quantity of a inbound order line for the license plate grouping policy and insert QtyReceived into the map that stores the current data.
    /// </summary>
    /// <param name="_orderLine">
    /// The inbound order line record.
    /// </param>
    /// <param name="_quantityReceived">
    /// Total amount of the quantity received during inbound order receiving.
    /// </param>
    /// <returns>
    /// Container containing the number of license plates, final quantity and unit of measure.
    /// </returns>
    protected container unitizeQuantityForOrderLine(WHSReceiptOrderLine _orderLine, Qty _quantityReceived)
    {
        // If the passed buffer is a purchLine, call the obsolete version of the method to ensure extenders still have their logic run.
        if (_orderLine is PurchLine)
        {
            return this.unitizeQuanitityForPurchaseOrderLine(_orderLine as PurchLine, _quantityReceived);
        }

        return this.unitizeQuantityInternal(_orderLine, _quantityReceived);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unitizeQuantityInternal</Name>
				<Source><![CDATA[
    private container unitizeQuantityInternal(WHSReceiptOrderLine _orderLine, Qty _quantityReceived)
    {
        int                         numberOfLicensePlates;
        Qty                         finalQuantity;
        UnitOfMeasureSymbol         finalUnitId;
        
        if (pass.parmUnitization() == WHSLicensePlateGroupingPolicy::UserDefined)
        {
            [numberOfLicensePlates, finalQuantity, finalUnitId] = WHSWorkCreateReceiving::unitizeQtyUserDefined(pass.lookupNum(#Qty), pass.lookup(#UOM));

            pass.insert(#QtyReceived, numberOfLicensePlates);
        }
        else if ((pass.parmUnitization() == WHSLicensePlateGroupingPolicy::None)
              || (pass.parmUnitization() == WHSLicensePlateGroupingPolicy::LicensePlateGrouping))
        {
            [numberOfLicensePlates, finalQuantity, finalUnitId] = WHSWorkCreateReceiving::unitizeQuantity(
                _orderLine.ItemId,
                _quantityReceived,
                pass.lookup(#Unitization),
                _orderLine.InventDimId);

            pass.insert(#QtyReceived, _quantityReceived);
        }
        return [numberOfLicensePlates, finalQuantity, finalUnitId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveCurrentRunningQuantityForPurchaseOrderReceiving</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the current running quantity for the purchase order receiving based on the various license plate grouping.
    /// </summary>
    /// <param name="_purchLine">
    /// The purchase order line  record  for which running quantity is being calculated.
    /// </param>
    /// <param name="_numberOfLicensePlates">
    /// The number of license plates generated during purchase order receiving.
    /// </param>
    /// <param name="_quantityReceived">
    /// Total amount of the quantity received during purchase order receiving.
    /// </param>
    /// <returns>
    /// returns the current running quantity for the purchase order receiving.
    /// </returns>
    [SysObsolete('Logic has been moved to retrieveCurrentRunningQuantityForOrderReceiving', false, 13\02\2023)]
    protected Qty retrieveCurrentRunningQuantityForPurchaseOrderReceiving(
        PurchLine   _purchLine,
        int         _numberOfLicensePlates,
        Qty         _quantityReceived)
    {
        return this.retrieveCurrentRunningQuantityInternal(_purchLine, _numberOfLicensePlates, _quantityReceived);
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveCurrentRunningQuantityForOrderReceiving</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the current running quantity for the inbound order receiving based on the various license plate grouping.
    /// </summary>
    /// <param name="_orderLine">
    /// The inbound order line record for which running quantity is being calculated.
    /// </param>
    /// <param name="_numberOfLicensePlates">
    /// The number of license plates generated during inbound order receiving.
    /// </param>
    /// <param name="_quantityReceived">
    /// Total amount of the quantity received during inbound order receiving.
    /// </param>
    /// <returns>
    /// returns the current running quantity for the inbound order receiving.
    /// </returns>
    protected Qty retrieveCurrentRunningQuantityForOrderReceiving(
        WHSReceiptOrderLine _orderLine,
        int                 _numberOfLicensePlates,
        Qty                 _quantityReceived)
    {
        // If the passed buffer is a purchLine, call the obsolete version of the method to ensure extenders still have their logic run.
        if (_orderLine is PurchLine)
        {
            return this.retrieveCurrentRunningQuantityForPurchaseOrderReceiving(_orderLine as PurchLine, _numberOfLicensePlates, _quantityReceived);
        }

        return this.retrieveCurrentRunningQuantityInternal(_orderLine, _numberOfLicensePlates, _quantityReceived);
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveCurrentRunningQuantityInternal</Name>
				<Source><![CDATA[
    private Qty retrieveCurrentRunningQuantityInternal(
        WHSReceiptOrderLine _orderLine,
        int                 _numberOfLicensePlates,
        Qty                 _quantityReceived)
    {
        Qty runningQty;

        if (pass.parmUnitization() == WHSLicensePlateGroupingPolicy::UserDefined)
        {
            runningQty = _numberOfLicensePlates;
        }
        else if ((pass.parmUnitization() == WHSLicensePlateGroupingPolicy::None)
              || (pass.parmUnitization() == WHSLicensePlateGroupingPolicy::LicensePlateGrouping))
        {
            runningQty = _quantityReceived - WHSCatchWeightHelper::convertInventQuantity(
                                                            _orderLine.ItemId,
                                                            pass.lookup(#CurrentUOM),
                                                            pass.lookupNum(#CurrentQty),
                                                            _orderLine.InventDimId);
        }

        return runningQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>storeSerialToReceive</Name>
				<Source><![CDATA[
    private void storeSerialToReceive(WHSReceiptOrderLine _orderLine)
    {
        if (EcoResTrackingDimensionGroup::find(InventTable::find(_orderLine.ItemId).trackingDimensionGroup()).IsSerialNumberControlEnabled)
        {
            InventDim           inventDim;
            InventTrans         inventTrans;
            InventTransOrigin   inventTransOrigin;
            int                 inventSerialCounter = 1;

            while select InventSerialId from inventDim
                where inventDim.inventSerialId != ''
                exists join inventTrans
                    where inventTrans.ItemId == _orderLine.ItemId
                        && inventTrans.StatusReceipt == StatusReceipt::Ordered
                        && inventTrans.StatusIssue == StatusIssue::None
                        && inventTrans.InventDimId == inventDim.InventDimId
                exists join inventTransOrigin
                    where inventTransOrigin.RecId == inventTrans.InventTransOrigin
                        && inventTransOrigin.InventTransId == _orderLine.InventTransId
            {
                pass.insert(strFmt(ListOfSerialNumbersForReceiving, inventSerialCounter), inventDim.InventSerialId);
                inventSerialCounter ++;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>continueTrackingDimCaptureForSameLine</Name>
				<Source><![CDATA[
    protected boolean continueTrackingDimCaptureForSameLine()
    {
        return trackingDimCaptureInProgressForGeneratedLP
            && (!this.itemRequiresManualDimTracking(InventTable::find(pass.lookup(#ItemId)))
                ||  this.batchDetailsOnPOLine())
            && !this.mustCaptureSerialOnReceipt(pass.lookupStr(#ItemId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>needsTrackingDisplayForm</Name>
				<Source><![CDATA[
    protected boolean needsTrackingDisplayForm()
    {
        return (!this.batchDetailsAlreadySet()
            &&  !this.batchDetailsOnPOLine())
            || (step == #VendBatchDetailsStep
            ||  pass.lookupStr(#CurrentQty) != pass.lookupStr(#DimQty)
            ||  this.needsPotency())
            || this.shouldCaptureWeightDuringDimRegistration(pass.lookup(#ItemId))
            || this.showTrackingDisplayForBatchDisposition(pass.lookup(#ItemId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchDetailsOnPOLine</Name>
				<Source><![CDATA[
    private boolean batchDetailsOnPOLine()
    {
        WHSReceiptOrderLine orderLine = this.getOrderLine(pass);
        InventDim orderLineInventDim = orderLine.inventDim();
        
        boolean ret = orderLineInventDim.inventBatchId || orderLineInventDim.inventSerialId;
        
        if (!ret)
        {
            ret = this.batchDetailsOnInboundOrderLineInventTrans(orderLine);

            if (ret)
            {
                this.instrumentationLogger().executePOReceiving().returnValueChanged();
            }
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTrackingDisplayForBatchDisposition</Name>
				<Source><![CDATA[
    private boolean showTrackingDisplayForBatchDisposition(ItemId _itemId)
    {
        return WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).ShowBatchDisposition
            && InventTable::find(_itemId).whsBatchActive();     
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchDetailsOnInboundOrderLineInventTrans</Name>
				<Source><![CDATA[
    private boolean batchDetailsOnInboundOrderLineInventTrans(WHSReceiptOrderLine _orderLine)
    {
        boolean ret = false;

        InventDim inventDim;
        InventTrans inventTrans;
        InventTransOrigin inventTransOrigin;
        InventMovement movement;

        if (WHSWorkExecuteDisplayReceivingRefactoringFlight::instance().isEnabled())
        {
            movement = InventMovement::construct(WhsWorkCreateReceiving::inventMovementArgumentFromOrderLine(_orderLine));

            select firstonly RecId from inventTrans
                join RecId from inventTransOrigin
                    where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                        && inventTransOrigin.InventTransId == _orderLine.InventTransId
                join inventDim
                    where inventDim.InventDimId == inventTrans.InventDimId;
        }
        else
        {
            PurchParmLine purchParmLine;
            purchParmLine.initFromPurchLine(_orderLine as PurchLine);

            movement = InventMovement::construct(purchParmLine);

            select firstonly RecId from inventTrans
                join RecId from inventTransOrigin
                    where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                        && inventTransOrigin.InventTransId == purchParmLine.InventTransId
                join inventDim
                    where inventDim.InventDimId == inventTrans.InventDimId;
        }

        InventDim inventDimInbound = _orderLine.inventDim();
        inventDim.InventSiteId = inventDimInbound.InventSiteId;
        inventDim.InventLocationId = inventDimInbound.InventLocationId;
        inventDim.setInventoryOwnerItemId(movement.itemId());
        inventDim.wmsLocationId = this.receivingLocationId();
        inventDim.LicensePlateId = pass.lookupStr(#LicensePlateId);
        inventDim = InventDim::findOrCreate(inventDim);

        InventDimParm inventDimParm;
        inventDimParm.initFromInventDim(inventDim);
        
        // InventUpd_Registered uses InventUpdate.initInventTransToReceiveList() to find inventory transactions to receive.
        // We need to use similar logic to get the first inventory transaction to receive.
        InventTransReceiveListParameters parameters = InventTransReceiveListParameters::construct();
        parameters.fromStatus = StatusReceipt::Arrived;
        parameters.toStatus = StatusReceipt::Ordered;
        parameters.maxQty = pass.exists(#CurrentQty) ? pass.lookupNum(#CurrentQty) : 1;
        parameters.addRecordsNotMatchingCriteria = true;
        parameters.inventDimId = inventDim.inventDimId;
        parameters.inventDimCriteria = inventDim;
        parameters.inventDimParm = inventDimParm;
        parameters.movement = movement;

        InventTransReceiveList inventTransReceiveList = InventTransReceiveList::newFromParameters(parameters);
        List receiptTransList = inventTransReceiveList.convertMapToList();
        ListEnumerator receiptTransListEnumerator = receiptTransList.getEnumerator();

        if (receiptTransListEnumerator.moveNext())
        {
            inventTrans = receiptTransListEnumerator.current() as InventTrans;
            InventDim inventTransInventDim = inventTrans.inventDim();
            ret = inventTransInventDim.inventBatchId || inventTransInventDim.inventSerialId;
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPromptForAutoGenerateLPWeight</Name>
				<Source><![CDATA[
    private boolean canPromptForAutoGenerateLPWeight()
    {
        boolean ret;

        if (PdsGlobal::pdsIsCWItem(pass.lookup(#ItemId))
            && !WHSInventTable::shouldCaptureAggregateWeight(pass.lookup(#ItemId))
            && !WHSInventTable::isCatchWeightTagTracked(pass.lookup(#ItemId))
            && !this.captureTrackingDimensions(pass.lookup(#ItemId))
            && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateLP)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayFormRecursionActivityContext</Name>
				<Source><![CDATA[
    private SysInstrumentationActivityContext displayFormRecursionActivityContext()
    {
        if (!activityContextDisplayFormRecursion)
        {
            activityContextDisplayFormRecursion = this.instrumentationLogger().executePOReceiving().batchDetailsOnPOLine();
        }

        return activityContextDisplayFormRecursion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetDisplayFormRecursionDepth</Name>
				<Source><![CDATA[
    private void resetDisplayFormRecursionDepth()
    {
        if (displayFormRecursionDepth)
        {
            displayFormRecursionDepth = 0;
            if (activityContextDisplayFormRecursion)
            {
                this.instrumentationLogger().executePOReceiving().displayFormRecursionDepth(this.displayFormRecursionActivityContext(), displayFormRecursionDepth);
                activityContextDisplayFormRecursion.dispose();
                activityContextDisplayFormRecursion = null;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateOverdelivery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether overdelivery constraints are met and if not, throws appropriate exceptions.
    /// </summary>
    /// <param name = "_pass">The current pass</param>
    /// <param name = "_purchLine">Purchase order line identified for receiving</param>
    [SysObsolete('Logic has been moved to validateOverdeliveryForOrderLine', false, 13\02\2023)]
    protected void validateOverdelivery(WhsrfPassthrough _pass, PurchLine _purchLine)
    {
        var workExecute = WhsWorkExecute::construct();

        if (!workExecute.checkOverDeliveryForOrderLine(_purchLine, _pass.lookupNum(#Qty), _pass.lookup(#UOM)))
        {
            throw error("@WAX2142");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateOverdeliveryForOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether overdelivery constraints are met and if not, throws appropriate exceptions.
    /// </summary>
    /// <param name = "_pass">The current pass</param>
    /// <param name = "_orderLine">Inbound order line identified for receiving</param>
    protected void validateOverdeliveryForOrderLine(WhsrfPassthrough _pass, WHSReceiptOrderLine _orderLine)
    {
        boolean useDeferredReceivingContext = false;

        WHSDeferredReceivingPolicyId deferredReceivingPolicyId = WHSRFMenuItemTable::find(_pass.lookupStr(#MenuItem)).DeferredReceivingPolicyId;
        useDeferredReceivingContext = deferredReceivingPolicyId
            && (WHSDeferredReceivingPolicy::find(deferredReceivingPolicyId).DeferredReceivingPolicySelection != WHSDeferredReceivingPolicySelectionEnum::Never);

        using (var context = useDeferredReceivingContext ? WHSDeferredReceivingContext::construct() : null)
        {
            // If the passed buffer is a purchLine, call the obsolete version of the method to ensure extenders still have their logic run.
            if (_orderLine is PurchLine)
            {
                this.validateOverdelivery(_pass, _orderLine as PurchLine);
                return;
            }

            var workExecute = WhsWorkExecute::construct();

            if (!workExecute.checkOverDeliveryForOrderLine(_orderLine, _pass.lookupNum(#Qty), _pass.lookup(#UOM)))
            {
                throw error("@WAX2142");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLocationControl</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal container buildLocationControl()
    {
        return [this.buildControl(#RFText, #WMSLocationId, "@SYS80395", 1, this.receivingLocationId(), extendedTypeNum(WMSLocationId), '', 0, false)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWarehouseAllowsRFReceipt</Name>
				<Source><![CDATA[
    protected boolean checkWarehouseAllowsRFReceipt(InventLocationId _inventLocationId)
    {
        WMSLocationid locationId = this.receivingLocationId();
        
        if (!locationId)
        {
            return false;
        }

        if (!WMSLocation::find(locationId, _inventLocationId).whsLocationIsLPControlled())
        {
            // if the location is not lp controlled, but there exists a work policy, we can receive at the location.
            return WHSWorkPolicy::findWorkPolicyForCreationMethodAndWorkProcess(WHSWorkCreationMethod::Never, 
                                                                                this.receivingOrderProvider().workTransType(),
                                                                                this.workProcess(),
                                                                                _inventLocationId, 
                                                                                locationId, 
                                                                                pass.lookup(#itemId)).RecId != 0;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReceivingLocationLPControlled</Name>
				<Source><![CDATA[
    private boolean isReceivingLocationLPControlled()
    {
        return WMSLocation::find(this.receivingLocationId(), pass.lookup(#InventLocationId)).whsLocationIsLPControlled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCompleteReceiveWithoutWork</Name>
				<Source><![CDATA[
    private boolean canCompleteReceiveWithoutWork()
    {
        return pass.lookup(#NumLP) == pass.lookup(#CurrentLP);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldRetainPurchaseOrderNumberForPutawayCluster</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decides whether Purchase order Id should be saved in pass when using cluster putaway.
    /// </summary>
    /// <returns>true</returns>
    public boolean shouldRetainPurchaseOrderNumberForPutawayCluster()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLoadIdForOrder</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal container buildLoadIdForOrder()
    {
        WHSLoadTable loadTable;
        WHSLoadLine  loadLine;
        WHSLoadId    loadId;
        boolean      multiple = false;

        var orderProvider = this.receivingOrderProvider();

        while select firstonly10 LoadId from loadLine
            group by loadLine.LoadId
            where loadLine.OrderNum          == orderProvider.orderNum(pass)
               && loadLine.InventTransType   == orderProvider.inventTransType()
               && loadLine.TransportRequest  == NoYes::No
            exists join loadTable
                where loadTable.LoadId       == loadLine.LoadId
                   && loadTable.LoadStatus   != WHSLoadStatus::Received
                   && !loadTable.LoadReceivingCompletedUTCDateTime
        {
            if (!loadId)
            {
                loadId = loadLine.LoadId;
            }
            else
            {
                multiple = true;
                break;
            }
        }

        // Change the data type when there are multiple/no loads on the order to avoid passing an invalid load ID filter to detours
        return [this.buildControl(#RFText, WHSWorkExecuteDisplayPOReceiving::ReceiptLoadIdDisplayField, "@WAX403", 1,
            multiple ? "@WAX402" : loadId,
            multiple || !loadId ? extendedTypeNum(WHSRFUndefinedDataType) : extendedTypeNum(WHSLoadId),
            '', 0, false)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCaptureSerialOnReceipt</Name>
				<Source><![CDATA[
    protected boolean mustCaptureSerialOnReceipt(ItemId _itemId)
    {
        boolean ret = super(_itemId);

        if (ret && WHSPOReceivingMobileAppNotPromptSerialWhenSerialAutogenerateV2Flight::instance().isEnabled())
        {
            InventTable inventTable = InventTable::find(_itemId);
            InventNumGroup inventNumGroup = InventNumGroup::find(inventTable.SerialNumGroupId);

            ret = inventTable.itemRequiresManualDimTracking(InventTrackingDimType::Serial)
                || !inventNumGroup.PhysicalUpdate || !inventNumGroup.PurchActivation;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showLoadIdForOrder</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean showLoadIdForOrder()
    {
        return WHSParameters::find().LoadReceivingCompletedPolicyForPurchaseOrders != WHSLoadReceivingCompletedPolicyForPurchaseOrders::Disabled && WHSShowLoadIdForPOReceivingFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>