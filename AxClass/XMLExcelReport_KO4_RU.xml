<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>XmlExcelReport_KO4_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Class prints unified form KO-4 to excel.
/// </summary>
public class XmlExcelReport_KO4_RU extends XMLExcelReport_RU implements BatchRetryable, ERIReportPostProcessingSupported
{
    protected const str Prolog = 'PROLOG';
    protected const str Epilog = 'EPILOG';
    protected const str ExchRate = 'EXCHRATE';
    protected const str PageHeader = 'PAGEHEADER';
    protected const str Top = 'TOP';
    protected const str Header = 'HEADER';
    protected const str RestInCash = 'RESTINCASH';
    protected const str Body = 'Body';
    protected const str CashDayTotal = 'CASHDAYTOTAL';
    protected const str RestInCashEnd = 'RESTINCASHEND';
    protected const str Footer = 'FOOTER';
    protected const str RestInCashEndCur = 'RESTINCASHENDCUR';
    protected const str RestInCashCur = 'RESTINCASHCUR';
    protected const str CashDayTotalCur = 'CASHDAYTOTALCUR';

    protected const int CharacterNum12 = 12;
    protected const int Num2StrParam2 = 2;

    protected const int DecimalNum = 4;
    protected const int DecimalSeparator = 2;
    protected const int ThousandSeparator = 1;

    protected const str WhiteSpace = ' ';

    QueryRun queryRun;
    RCashTrans rCashTrans;

    MSOfficeBookMark_RU currentSection;
    RCashReport_CashBook cashBookReport;

    CurrencyCode currencyCode;
    CurrencyCode standardCurrency;

    ArrayExtend_RU currencyAfter;
    ArrayExtend_RU currencyTotal;

    TransDate lastCashDate;
    TransDate curCashDate;
    TransDate balanceDate;
    TransDate pageDate;

    RCashAccount cashAccount;
    TempStr cashAccountName;

    int numInOrder;
    int numOutOrder;
    int numCurOrder;
    int footerSectionHeight;
    int restInCashHeight;
    int totalInCashHeight;
    int totalFooterHeight;
    int pageNum;
    int initPageNum;

    date startDate;
    date endDate;

    boolean printProlog;
    boolean printEpilog;
    boolean printCorr;
    boolean printCashierNow;
    boolean printRCashName;

    LanguageId languageId;
    RNumDateInWordConverter converter;

    Map recIdMap;

    int currencyTotalIdx;
    int currencyAfterIdx;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountantName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets current company's accountant name.
    /// </summary>
    /// <returns>
    /// Current company's accountant name.
    /// </returns>
    protected Name accountantName()
    {
        return OfficialsTable_RU::nameAccountant();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcRangeHeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates height of resizeable sections.
    /// </summary>
    /// <param name="_bookmark">
    /// Name of section.
    /// </param>
    /// <returns>
    /// Height of resizeable section.
    /// </returns>
    protected real calcRangeHeight(Bookmark _bookmark)
    {
        real ret;

        switch (_bookmark)
        {
            case RestInCash:
                ret = document.getNamedRangeHeightWrapped('BodyCashAmountDebet', this.cashAmountDebet());
                break;
            case RestInCashCur:
                ret = document.getNamedRangeHeightWrapped('BodyCashAmountDebet', this.cashAmountDebet());
                break;
            case Body:
                ret = max(document.getNamedRangeHeightWrapped('BodyCashNotes', this.cashNotes()),
                    document.getNamedRangeHeightWrapped('BodyCashAmountDebet', this.cashAmountDebet()),
                    document.getNamedRangeHeightWrapped('BodyCashAmountCredit', this.cashAmountCredit()));
                break;
            case CashDayTotal:
                ret = max(document.getNamedRangeHeightWrapped('BodyCashAmountDebet', this.cashAmountDebet()),
                    document.getNamedRangeHeightWrapped('BodyCashAmountCredit', this.cashAmountCredit()));
                break;
            case CashDayTotalCur:
                ret = max(document.getNamedRangeHeightWrapped('BodyCashAmountDebet', this.cashAmountDebet()),
                    document.getNamedRangeHeightWrapped('BodyCashAmountCredit', this.cashAmountCredit()));
                break;
            case RestInCashEnd:
                ret = document.getNamedRangeHeightWrapped('BodyCashAmountDebet', this.cashAmountDebet());
                break;
            case RestInCashEndCur:
                ret = document.getNamedRangeHeightWrapped('BodyCashAmountDebet', this.cashAmountDebet());
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashAccountNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns ledger account specified in current rcash transaction.
    /// </summary>
    /// <returns>
    /// Ledger account specified in current rcash transaction.
    /// </returns>
    protected RCashAccount cashAccountNum()
    {
        RCashAccount accountNum;

        if (!printCorr && rCashTrans.RefRecId == rCashTrans.RecId && recIdMap.exists(rCashTrans.RecId))
        {
            accountNum = recIdMap.lookup(rCashTrans.RecId);
        }
        else
        {
            accountNum = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(rCashTrans.OffsetLedgerDimension);
        }

        return accountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashAmountCredit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets credit amount for section being printed.
    /// </summary>
    /// <returns>
    /// Debet amount for section being printed.
    /// </returns>
    protected TempStr cashAmountCredit()
    {
        CurrencyCode curCurrency;
        TransDate currencyDate;
        AmountMST amount;
        AmountMST mstAmount;

        switch (currentSection)
        {
            case Body:
                RCashTrans rCashTransLocal;

                if (rCashTrans.RefRecId && rCashTrans.RefRecId != rCashTrans.RecId)
                {
                    rCashTransLocal = RCashTrans::findRecId(rCashTrans.RefRecId);
                }

                if (rCashTrans.DocType == RCashDocType::DisbursementSlip ||
                    (rCashTrans.DocType == RCashDocType::ExchRateDifference && rCashTrans.AmountMST < 0) ||
                    (printCorr == NoYes::Yes && rCashTrans.DocType == RCashDocType::Correction &&
                    ((!rCashTransLocal && rCashTrans.AmountCur > 0) ||
                    (rCashTransLocal && rCashTransLocal.DocType == RCashDocType::DisbursementSlip))))
                {
                    curCurrency = rCashTrans.CurrencyCode;
                    currencyDate = rCashTrans.TransDate;
                    amount = - rCashTrans.AmountCur;
                    mstAmount = - rCashTrans.AmountMST;
                }
                break;

            case CashDayTotal:
            case CashDayTotalCur:
                currencyDate = curCashDate;
                if (currencyCode)
                {
                    curCurrency = currencyCode;
                    amount = RCashBalanceTrans::amountDisbCur(cashAccount, curCashDate, curCashDate, currencyCode, printCorr);
                    mstAmount = RCashBalanceTrans::amountDisbMst(cashAccount, curCashDate, curCashDate, printCorr, currencyCode);
                }
                else
                {
                    curCurrency = standardCurrency;
                    amount = RCashBalanceTrans::amountDisbMst(cashAccount, curCashDate, curCashDate, printCorr);
                }
                break;
        }

        str amountStr;

        if (amount || (!amount && mstAmount && currentSection == Body))
        {
            if (curCurrency == standardCurrency)
            {
                amountStr = num2str(amount, CharacterNum12, Num2StrParam2, Num2StrParam2, 0);
            }
            else
            {
                amountStr = num2str(mstAmount, CharacterNum12, Num2StrParam2, Num2StrParam2, 0) + ' (' + num2str(amount, 1, Num2StrParam2, Num2StrParam2, 0) + ')';
            }
        }

        return amountStr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashAmountDebet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets debet amount for section being printed.
    /// </summary>
    /// <returns>
    /// Debet amount for section being printed.
    /// </returns>
    protected TempStr cashAmountDebet()
    {
        CurrencyCode curCurrency;
        TransDate currencyDate;
        AmountMST amount;
        AmountMST mstAmount;

        switch (currentSection)
        {
            case Body:
                RCashTrans rCashTransLocal;

                if (rCashTrans.RefRecId && rCashTrans.RefRecId != rCashTrans.RecId)
                {
                    rCashTransLocal = RCashTrans::findRecId(rCashTrans.RefRecId);
                }

                if (rCashTrans.DocType == RCashDocType::ReimbursementSlip ||
                    (rCashTrans.DocType == RCashDocType::ExchRateDifference && rCashTrans.AmountMST >= 0) ||
                    (printCorr == NoYes::Yes && rCashTrans.DocType == RCashDocType::Correction &&
                    ((!rCashTransLocal && rCashTrans.AmountCur <= 0) ||
                    (rCashTransLocal && rCashTransLocal.DocType == RCashDocType::ReimbursementSlip))))
                {
                    curCurrency = rCashTrans.CurrencyCode;
                    currencyDate = rCashTrans.TransDate;
                    amount = rCashTrans.AmountCur;
                    mstAmount = rCashTrans.AmountMST;
                }
                break;

            case RestInCash:
            case RestInCashCur:
                currencyDate = lastCashDate;
                if (currencyCode)
                {
                    curCurrency = currencyCode;
                    amount = RCashBalanceTrans::amountRestCur(cashAccount, balanceDate, rCashTrans.TransDate - 1, currencyCode, printCorr);
                    mstAmount = RCashBalanceTrans::amountRestMst(cashAccount, balanceDate, rCashTrans.TransDate - 1, printCorr, currencyCode);
                }
                else
                {
                    curCurrency = standardCurrency;
                    amount = RCashBalanceTrans::amountRestMst(cashAccount, balanceDate, rCashTrans.TransDate - 1, printCorr);
                }
                break;

            case RestInCashEnd:
            case RestInCashEndCur:
                currencyDate = curCashDate;
                if (currencyCode)
                {
                    curCurrency = currencyCode;
                    amount = RCashBalanceTrans::amountRestCur(cashAccount, balanceDate, curCashDate, currencyCode, printCorr);
                    mstAmount = RCashBalanceTrans::amountRestMst(cashAccount, balanceDate, curCashDate, printCorr, currencyCode);
                }
                else
                {
                    curCurrency = standardCurrency;
                    amount = RCashBalanceTrans::amountRestMst(cashAccount, balanceDate, curCashDate, printCorr);
                }
                break;

            case CashDayTotal:
            case CashDayTotalCur:
                currencyDate = curCashDate;
                if (currencyCode)
                {
                    curCurrency = currencyCode;
                    amount = RCashBalanceTrans::amountReimbCur(cashAccount, curCashDate, curCashDate, currencyCode, printCorr);
                    mstAmount = RCashBalanceTrans::amountReimbMst(cashAccount, curCashDate, curCashDate, printCorr, currencyCode);
                }
                else
                {
                    curCurrency = standardCurrency;
                    amount = RCashBalanceTrans::amountReimbMst(cashAccount, curCashDate, curCashDate, printCorr);
                }
                break;
        }

        str amountStr;

        if (amount || (!amount && mstAmount && currentSection == Body))
        {
            if (curCurrency == standardCurrency)
            {
                amountStr = num2str(amount, CharacterNum12, Num2StrParam2, Num2StrParam2, 0);
            }
            else
            {
                amountStr = num2str(mstAmount, CharacterNum12, Num2StrParam2, Num2StrParam2, 0) + ' (' + num2str(amount, 1, Num2StrParam2, Num2StrParam2, 0) + ')';
            }
        }
        else
        {
            if (currentSection == RestInCashEnd || currentSection == RestInCash)
            {
                amountStr = num2str(amount, CharacterNum12, Num2StrParam2, Num2StrParam2, 0);
            }
        }
        return amountStr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashBookPage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates label which contains page of cash book being printed.
    /// </summary>
    /// <returns>
    /// String which contains page of cash book being printed.
    /// </returns>
    protected Num cashBookPage()
    {
        return strFmt(SysLabel::labelId2String(literalStr("@GLS100755"), languageId),  int2str(initPageNum + pageNum));
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a description for current page of report.
    /// </summary>
    /// <returns>
    /// String with description of current page of report.
    /// </returns>
    protected TempStr cashDate()
    {
        return (pageDate ? (printCashierNow ? SysLabel::labelId2String(literalStr("@GLS102780"), languageId):
            SysLabel::labelId2String(literalStr("@GLS102778"), languageId)) + WhiteSpace + converter.date2str(pageDate): '') +
            (cashAccountName ? cashAccountName + "@SYS35672": '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDayTotalCurDescription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates description for amount in cash day total in currency section.
    /// </summary>
    /// <returns>
    /// Name of standard currency plus in brackets name of transaction currency.
    /// </returns>
    protected FreeText cashDayTotalCurDescription()
    {
        FreeText freeText;

        if (currencyCode == CompanyInfoHelper::standardCurrency())
        {
            freeText = currencyCode + "@SYS35675";
        }
        else
        {
            freeText = CompanyInfoHelper::standardCurrency() + "@SYS34952" + currencyCode + "@SYS34953"+"@SYS35675";
        }

        return freeText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashierName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets name of employee specified as cashier for this report.
    /// </summary>
    /// <returns>
    /// Name of employee specified as cashier for this report.
    /// </returns>
    protected Name cashierName()
    {
        return OfficialsTable_RU::find(OffReportType_RU::CashBookPage, OffPosition_RU::Cashier).Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashNotes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates notes for current transaction.
    /// </summary>
    /// <returns>
    /// Notes for current transaction.
    /// </returns>
    protected FreeText cashNotes()
    {
        FreeText freeText = this.nameOffAccount(rCashTrans.OffsetAccountType, rCashTrans.OffsetLedgerDimensionNum);

        if (rCashTrans.CurrencyCode != CompanyInfoHelper::standardCurrency())
        {
            freeText = freeText + WhiteSpace + CompanyInfoHelper::standardCurrency() + "@SYS34952" + rCashTrans.CurrencyCode + "@SYS34953" + "@SYS35675";
        }

        freeText += WhiteSpace + rCashTrans.Txt;

        return freeText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns RCashDocId from current transaction.
    /// </summary>
    /// <returns>
    /// RCashDocId from current transaction.
    /// </returns>
    protected Voucher cashVoucher()
    {
        Voucher voucher;

        if (rCashTrans.RefRecId && rCashTrans.RefRecId != rCashTrans.RecId)
        {
            RCashTrans rCashTransLocal;

            select firstonly DocId from rCashTransLocal
                where rCashTransLocal.RecId == rCashTrans.RefRecId;

            voucher = rCashTransLocal.DocId;
        }
        else
        {
            voucher = rCashTrans.DocId;
        }

        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkHeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether new page should be created.
    /// </summary>
    /// <returns>
    /// True if new page should be created.
    /// </returns>
    protected boolean checkHeight()
    {
        boolean ret;

        real rowHeight = this.getRangeHeight(Body);

        //if current order is last on page
        if (numCurOrder == numInOrder + numOutOrder)
        {
            //then Footer must fit
            if (pageHeight - currentHeight - rowHeight > totalFooterHeight)
            {
                ret = true;
            }
        }
        else
        {
            if (pageHeight - currentHeight - rowHeight > 0)
            {
                ret = true;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chiefName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets name of director specified in officials trans for this company.
    /// </summary>
    /// <returns>
    /// Name of director specified in officials trans for this company.
    /// </returns>
    protected RCashEmplName chiefName()
    {
        return OfficialsTable_RU::nameDirector();
    }

]]></Source>
			</Method>
			<Method>
				<Name>chiefTitle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets title of director specified in officials trans for this company.
    /// </summary>
    /// <returns>
    /// Title of director specified in officials trans for this company.
    /// </returns>
    protected EmployeeTitle_RU chiefTitle()
    {
        return OfficialsTable_RU::findDirector().Title;
    }

]]></Source>
			</Method>
			<Method>
				<Name>codeOkpo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Display method to get OKPO code.
    /// </summary>
    /// <returns>
    /// Current company's OKPO Code.
    /// </returns>
    protected Name codeOkpo()
    {
        return CompanyInfoHelper::partyOKPOasOfDate_RU(CompanyInfo::find(), endDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>companyName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns company name for current company.
    /// </summary>
    /// <returns>
    /// Company name for current company.
    /// </returns>
    protected Name companyName()
    {
        return CompanyInfo::find().name();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes report.
    /// </summary>
    protected void createReport()
    {
        curWorkSheetNum = 1;
        this.printRCashBook();
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates description for currency code which contains it's name and rate.
    /// </summary>
    /// <returns>
    /// Description for currency code which contains it's name and rate.
    /// </returns>
    protected TempStr currencyCode()
    {
        return SysLabel::labelId2String(literalStr("@GLS102763")) + #space + currencyCode + "@GLS102908"+"@SYS77038" +
            num2str(ExchangeRateHelper::ExchRate(currencyCode, rCashTrans.TransDate) / 100, 1, DecimalNum, DecimalSeparator, ThousandSeparator) +
            CompanyInfoHelper::standardCurrency() + "@SYS35672";
    }

]]></Source>
			</Method>
			<Method>
				<Name>departmentName</Name>
				<Source><![CDATA[
    /// <summary>
    /// If department name should be filled with RCashAccount data, returns rCashAccount's name, otherwise blank.
    /// </summary>
    /// <returns>
    /// If department name should be filled with RCashAccount data, returns rCashAccount's name, otherwise blank.
    /// </returns>
    protected Description departmentName()
    {
        return printRCashName ? RCashTable::find(cashAccount).Name: #blank;
    }

]]></Source>
			</Method>
			<Method>
				<Name>execute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes section of report. Some sections executed only if amount greater than 0.
    /// </summary>
    /// <param name="_bookmark">
    /// Name of bookmark.
    /// </param>
    protected void execute(MSOfficeBookMark_RU _bookmark)
    {
        EndDate toDate = curCashDate;

        currentSection = _bookmark;

        switch (_bookmark)
        {
            case RestInCashCur:
                toDate = rCashTrans.TransDate - 1;
            case RestInCashEndCur:
                if (RCashBalanceTrans::amountRestCur(cashAccount, balanceDate, toDate, currencyCode, printCorr))
                {
                    super(_bookmark);
                }
                break;
            default:
                super(_bookmark);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeBody</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes Body page, if nesessary, executes page Header.
    /// </summary>
    protected void executeBody()
    {
        if (!printCorr &&
            rCashTrans.RefRecId &&
            rCashTrans.RefRecId != rCashTrans.RecId &&
            recIdMap.exists(rCashTrans.RefRecId))
        {
            return;
        }

        if (rCashTrans.DocType == RCashDocType::DisbursementSlip ||
            rCashTrans.DocType == RCashDocType::ReimbursementSlip ||
            (rCashTrans.DocType == RCashDocType::Correction && printCorr == NoYes::Yes))
        {
            numCurOrder++;
        }

        currentSection = Body;

        if (!this.checkHeight())
        {
            this.newPageByHeight();
        }

        this.execute(Body);
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeFooter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes Footer of page, which consists of several sections.
    /// </summary>
    protected void executeFooter()
    {
        currencyCode = '';

        this.execute(CashDayTotal);

        for (currencyAfterIdx = 1; currencyAfterIdx <= (currencyAfter ? currencyAfter.lastIndex(): 0); currencyAfterIdx++)
        {
            currencyCode = currencyAfter.value(currencyAfterIdx);
            this.execute(CashDayTotalCur);
        }

        currencyCode = '';

        this.execute(RestInCashEnd);

        for ( currencyTotalIdx = 1; currencyTotalIdx <= (currencyTotal ? currencyTotal.lastIndex(): 0); currencyTotalIdx++)
        {
            currencyCode = currencyTotal.value(currencyTotalIdx);
            this.execute(RestInCashEndCur);
        }

        this.execute(Footer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>incrementOrderCounters</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Update <c>CashTrans</c> counters based on <c>RCashDocType</c>
    /// </summary>
    /// <param name = "_docType">
    ///    <c>RCashDocType</c> based on which counter to update is selected.
    /// </param>
    protected void incrementOrderCounters(RCashDocType _docType)
    {
        switch (_docType)
        {
            case RCashDocType::ReimbursementSlip:
                numInOrder++;
                break;
            case RCashDocType::DisbursementSlip :
                numOutOrder++;
                break;
            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes Header of page, which consists of several sections.
    /// </summary>
    protected void executeHeader()
    {
        RCashTrans cashTrans;

        currencyAfter = new ArrayExtend_RU(Types::String);
        pageDate = rCashTrans.TransDate;

        this.execute(Top);

        numInOrder = 0;
        numOutOrder = 0;
        numCurOrder = 0;

        while select TransDate, CurrencyCode, DocType from cashTrans
            order by TransDate, CurrencyCode
                where (!cashAccount || (cashAccount && cashTrans.AccountNum == cashAccount)) &&
                    (cashTrans.TransDate >= startDate ||
                    (startDate ? false: true)) &&
                    (cashTrans.TransDate <= endDate ||
                    (endDate ? false: true)) &&
                    cashTrans.TransDate <= pageDate &&
                    cashTrans.TransDate > lastCashDate &&
                    cashTrans.TransStatus == RCashTransStatus::Approved &&
                    cashTrans.DocType != RCashDocType::Correction &&
                    cashTrans.DocType != RCashDocType::ReportingExchRateDifference
        {
            if (cashTrans.TransDate == rCashTrans.TransDate)
            {
                if (!currencyAfter.arrayScan(cashTrans.CurrencyCode))
                {
                    currencyAfter.addElement(cashTrans.CurrencyCode);
                }

                this.incrementOrderCounters(cashTrans.DocType);
            }

            if (!currencyTotal.arrayScan(cashTrans.CurrencyCode))
            {
                currencyTotal.addElement(cashTrans.CurrencyCode);
            }
        }

        curCashDate = rCashTrans.TransDate;
        lastCashDate = (select reverse firstonly rCashTrans
            order by TransDate
                where (!cashAccount || (cashAccount && rCashTrans.AccountNum == cashAccount)) &&
                    rCashTrans.TransDate < pageDate &&
                    (cashTrans.TransDate >= startDate ||
                    (startDate ? false: true)) &&
                    (cashTrans.TransDate <= endDate ||
                    (endDate ? false: true)) &&
                    ((printCorr == NoYes::No && cashTrans.DocType != RCashDocType::Correction) ||
                    printCorr == NoYes::Yes) &&
                    cashTrans.DocType != RCashDocType::ReportingExchRateDifference &&
                    cashTrans.TransStatus != RCashTransStatus::Canceled
                    ).TransDate;

        if (!lastCashDate)
        {
            lastCashDate = curCashDate;
        }

        for (int i = 1; i <= currencyTotal.lastIndex(); i++)
        {
            if (currencyTotal.value(i) != CompanyInfoHelper::standardCurrency())
            {
                currencyCode = currencyTotal.value(i);
                this.execute(ExchRate);
            }
        }

        this.execute(Header);

        currencyCode = '';

        this.execute(RestInCash);

        for (currencyTotalIdx = 1; currencyTotalIdx <= currencyTotal.lastIndex(); currencyTotalIdx += 1)
        {
            currencyCode = currencyTotal.value(currencyTotalIdx);
            this.execute(RestInCashCur);
        }

        totalFooterHeight = footerSectionHeight + (currencyTotal.lastIndex() + 1) * restInCashHeight +
            (currencyAfter.lastIndex() + 1) * totalInCashHeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fileName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Name of the new file.
    /// </summary>
    /// <returns>
    /// Name of the new file.
    /// </returns>
    protected Filename fileName()
    {
        return strFmt('KO4_%1_', (printCashierNow ? "@GLS101336": "@GLS101075"));
    }

]]></Source>
			</Method>
			<Method>
				<Name>fileNamePostfix</Name>
				<Source><![CDATA[
    /// <summary>
    /// Postfix for a new file.
    /// </summary>
    /// <returns>
    /// Postfix for a new file.
    /// </returns>
    protected Filename fileNamePostfix()
    {
        return strFmt("%1_%2",
            date2str(startDate, 123, 2, 0, 2, 0, 2, DateFlags::None),
            date2str(endDate, 123, 2, 0, 2, 0, 2, DateFlags::None));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportFileName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the name of the report file.
    /// </summary>
    /// <returns>
    /// The name of the report file.
    /// </returns>
    public str getReportFileName()
    {
        return this.excelFileName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the name of the report.
    /// </summary>
    /// <returns>
    /// Name of the report.
    /// </returns>
    public str getReportName()
    {
        return 'KO4';
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillBody</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills Body section with data.
    /// </summary>
    protected void fillBody()
    {
        this.insertValueToSection('BodyCashVoucher', this.cashVoucher());
        this.insertValueToSection('BodyCashNotes', this.cashNotes());
        this.insertValueToSection('BodyCashAccountNum', this.cashAccountNum());
        this.insertValueToSection('BodyCashAmountDebet', this.cashAmountDebet());
        this.insertValueToSection('BodyCashAmountCredit', this.cashAmountCredit());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillCashDayTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills cash day total section with data.
    /// </summary>
    protected void fillCashDayTotal()
    {
        this.insertValueToSection('CashDayTotalCashAmountDebet', this.cashAmountDebet());
        this.insertValueToSection('CashDayTotalCashAmountCredit', this.cashAmountCredit());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillCashDayTotalCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills cash day total in currency section with data.
    /// </summary>
    protected void fillCashDayTotalCur()
    {
        this.insertValueToSection('CAshDayTotalCurDescr', this.cashDayTotalCurDescription());
        this.insertValueToSection('CashDayTotalCurDebet', this.cashAmountDebet());
        this.insertValueToSection('CashDayTotalCurCredit', this.cashAmountCredit());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills specified section with data.
    /// </summary>
    /// <param name="_bookmark">
    /// Name of section.
    /// </param>
    protected void fillData(MSOfficeBookMark_RU _bookmark)
    {
        switch (_bookmark)
        {
            case Prolog:
                this.fillProlog();
                break;
            case Epilog:
                this.fillEpilog();
                break;
            case ExchRate:
                this.fillExchRate();
                break;
            case PageHeader:
                this.fillPageHeader();
                break;
            case Header:
                this.fillHeader();
                break;
            case RestInCash:
                this.fillRestInCash();
                break;
            case Body:
                this.fillBody();
                break;
            case CashDayTotal:
                this.fillCashDayTotal();
                break;
            case RestInCashEnd:
                this.fillRestInCashEnd();
                break;
            case Footer:
                this.fillFooter();
                break;
            case Top:
                this.fillTop();
                break;
            case RestInCashEndCur:
                this.fillRestInCashEndCur();
                break;
            case RestInCashCur:
                this.fillRestInCashCur();
                break;
            case CashDayTotalCur:
                this.fillCashDayTotalCur();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillEpilog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills Epilog section with data.
    /// </summary>
    protected void fillEpilog()
    {
        this.insertValueToSection('NumberOfList', this.numberOfList());
        this.insertValueToSection('ChiefTitle', this.chiefTitle());
        this.insertValueToSection('ChiefName', this.chiefName());
        this.insertValueToSection('AccountantName', this.accountantName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills exch rate section with data.
    /// </summary>
    protected void fillExchRate()
    {
        this.insertValueToSection('CurrencyCode', this.currencyCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillFooter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills Footer section with data.
    /// </summary>
    protected void fillFooter()
    {
        this.insertValueToSection('CashierName', this.cashierName());
        this.insertValueToSection('IncomeOrder', this.inComeOrder());
        this.insertValueToSection('OutgoingOrder', this.outgoingOrder());
        this.insertValueToSection('AccountantNameFooter', this.accountantName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills Header section with data.
    /// </summary>
    protected void fillHeader()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillPageHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills page Header section with data.
    /// </summary>
    protected void fillPageHeader()
    {
        this.insertValueToSection('CompanyNamePageHeader', this.companyName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillProlog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills Prolog section with data.
    /// </summary>
    protected void fillProlog()
    {
        this.insertValueToSection('CompanyName', this.companyName());
        this.insertValueToSection('CodeOKPO', this.codeOkpo());
        this.insertValueToSection('CashAccountName', cashAccountName);
        this.insertValueToSection('Year', this.yearOfBook());
        this.insertValueToSection('Department', this.departmentName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillRestInCash</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills rest in cash section with data.
    /// </summary>
    protected void fillRestInCash()
    {
        this.insertValueToSection('RestInCashCashAmountDebet', this.cashAmountDebet());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillRestInCashCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills rest in cash in currency section with data.
    /// </summary>
    protected void fillRestInCashCur()
    {
        this.insertValueToSection('RestInCashCurDescr', this.restInCashCurDescription());
        this.insertValueToSection('RestInCashCurAmount', this.cashAmountDebet());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillRestInCashEnd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills rest in cash end section with data.
    /// </summary>
    protected void fillRestInCashEnd()
    {
        this.insertValueToSection('RestInCashEndBodyCashAmountDebet', this.cashAmountDebet());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillRestInCashEndCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills rest in cash end in currency section with data.
    /// </summary>
    protected void fillRestInCashEndCur()
    {
        this.insertValueToSection('RestInCashEndCurDescr', this.restInCashEndCurDescription());
        this.insertValueToSection('RestInCashEndCurAmount', this.cashAmountDebet());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillTop</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills Top section with data.
    /// </summary>
    protected void fillTop()
    {
        this.insertValueToSection('CashDate', this.cashDate());
        this.insertValueToSection('CashBookPage', this.cashBookPage());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRecIdMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates map which holds data about Main Accounts in transactions which reference another transactions.
    /// </summary>
    /// <returns>
    /// Map which holds data about Main Accounts in transactions which reference another transactions.
    /// </returns>
    protected Map getRecIdMap()
    {
        RCashTrans rCashTransLocalMain;
        RCashTrans rCashTransLocal;
        Map resultMap;

        resultMap = new Map(typeName2Type(extendedTypeStr(recId)), Types::String);

        while select RecId from rCashTransLocalMain
            where (rCashTransLocalMain.TransDate >= startDate ||
                (startDate ? false: true)) &&
                (rCashTransLocalMain.TransDate <= endDate ||
                (endDate ? false: true)) &&
                rCashTransLocalMain.DocType != RCashDocType::ReportingExchRateDifference &&
                rCashTransLocalMain.RefRecId == rCashTransLocalMain.RecId
        join OffsetLedgerDimension from rCashTransLocal
            where rCashTransLocal.RefRecId == rCashTransLocalMain.RecId &&
                rCashTransLocal.RefRecId != rCashTransLocal.RecId &&
                rCashTransLocal.AmountCur == rCashTransLocalMain.AmountCur &&
                rCashTransLocal.TransDate == rCashTransLocalMain.TransDate
        {
            resultMap.insert(rCashTransLocalMain.RecId, LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(rCashTransLocal.OffsetLedgerDimension));
        }

        return resultMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inComeOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns number of incoming orders converted to string.
    /// </summary>
    /// <returns>
    /// Number of incoming orders converted to string.
    /// </returns>
    protected TempStr inComeOrder()
    {
        return converter.numeralsToTxt(numInOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes report with parameters specified at caller.
    /// </summary>
    /// <returns>
    /// True, if successful.
    /// </returns>
    public boolean init()
    {
        const str spaceQuote = " '";
        const str quoteSpace = "' ";

        Query query = new Query();

        cashBookReport = args.caller();

        languageId = CompanyInfo::languageId();

        converter = RNumDateInWordConverter::construct(languageId);

        currencyTotal = new ArrayExtend_RU(Types::String);

        startDate = cashBookReport.parmFromDate();
        endDate = cashBookReport.parmToDate();
        printProlog = cashBookReport.parmPrintProlog();
        printEpilog = cashBookReport.parmPrintEpilog();
        balanceDate = dateNull(); // temp value
        initPageNum = cashBookReport.parmPageNum() - 1;
        printCorr = cashBookReport.parmPrintCorrections();
        printCashierNow = cashBookReport.parmPrintCashierNow();
        cashAccount = cashBookReport.parmCashAccount();
        cashAccountName = RCashTable::find(cashAccount).Name;
        printRCashName = cashBookReport.parmPrintRCashName();

        cashAccountName = cashAccountName ? SysLabel::labelId2String(literalStr("@GLS100666"), languageId) + spaceQuote
            + cashAccountName + quoteSpace : "";

        query.addDataSource(tableNum(RCashTrans)).clearRanges();

        query.dataSourceTable(tableNum(RCashTrans)).sortClear();
        query.dataSourceTable(tableNum(RCashTrans)).addSortField(fieldNum(RCashTrans, AccountNum));
        query.dataSourceTable(tableNum(RCashTrans)).addSortField(fieldNum(RCashTrans, TransDate));
        query.dataSourceTable(tableNum(RCashTrans)).addSortField(fieldNum(RCashTrans, DocId));
        query.dataSourceTable(tableNum(RCashTrans)).addSortField(fieldNum(RCashTrans, DocType));

        if (startDate || endDate)
        {
            query.dataSourceTable(tableNum(RCashTrans)).
                addRange(fieldNum(RCashTrans, TransDate)).
                value(queryRange(startDate, endDate));
        }

        query.dataSourceTable(tableNum(RCashTrans)).
            addRange(fieldNum(RCashTrans, TransStatus)).value(queryValue(RCashTransStatus::Approved));

        if (!printCorr)
        {

            str condition = this.getQueryConditionForRCashTrans();
            query.dataSourceTable(tableNum(RCashTrans)).
                addRange(fieldNum(RCashTrans, DocType)).value(condition);

            recIdMap = this.getRecIdMap();
        }
        else
        {
            query.dataSourceTable(tableNum(RCashTrans)).
                addRange(fieldNum(RCashTrans, DocType)).value(SysQuery::valueNot(RCashDocType::ReportingExchRateDifference));
        }

        if (cashAccount)
        {
            query.dataSourceTable(tableNum(RCashTrans)).
                addRange(fieldNum(RCashTrans, AccountNum)).value(queryValue(cashAccount));
        }

        if (printCashierNow)
        {
            printProlog = false;
            printEpilog = false;
        }

        standardCurrency = CompanyInfoHelper::standardCurrency();

        queryRun = new QueryRun(query);

        const int width = 86;

        widthCols = width;

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryConditionForRCashTrans</Name>
				<Source><![CDATA[
    public str getQueryConditionForRCashTrans()
    {
        str condition = strFmt('(((%1 != %2) && (%1 != %5)) || ((%1 == %2) && (%3 != %4)))',
                fieldStr(RCashTrans, DocType),
                any2int(RCashDocType::Correction),
                fieldStr(RCashTrans, RefRecId),
                0,
                any2int(RCashDocType::ReportingExchRateDifference)
                );

        return condition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initHeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes heighs of sections in reoort to variables.
    /// </summary>
    protected void initHeight()
    {
        footerSectionHeight = conPeek(mapSections.lookup(Footer), #posSectionHeight);
        restInCashHeight = conPeek(mapSections.lookup(RestInCash), #posSectionHeight);
        totalInCashHeight = conPeek(mapSections.lookup(CashDayTotal), #posSectionHeight);

        pageHeight = document.getPageHeight(curWorkSheetNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSectionMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method initializes map which holds section data.
    /// </summary>
    protected void initSectionMap()
    {
        this.addSection(Prolog);
        this.addSection(Epilog);
        this.addSection(ExchRate);
        this.addSection(PageHeader);
        this.addSection(Top);
        this.addSection(Header);
        this.addSection(RestInCash);
        this.addSection(Body, true);
        this.addSection(CashDayTotal, true);
        this.addSection(RestInCashEnd, true);
        this.addSection(RestInCashEndCur, true);
        this.addSection(RestInCashCur, true);
        this.addSection(CashDayTotalCur, true);
        this.addSection(Footer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>nameOffAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns name of account.
    /// </summary>
    /// <param name="_type">
    /// Type of account.
    /// </param>
    /// <param name="_account">
    /// Account number.
    /// </param>
    /// <returns>
    /// Name of account.
    /// </returns>
    protected FreeText nameOffAccount(LedgerJournalACType _type, DimensionDynamicAccount _account)
    {
        LedgerJournalTrans journalTrans;

        return journalTrans.accountNameFind(_type, _account, curext());
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new page for report when date changes.
    /// </summary>
    protected void newPage()
    {
        pageNum++;
        currentHeight = 0;

        if (printProlog || pageNum != 1)
        {
            document.insertPageBreak(currentRow, curWorkSheetNum);
        }

        this.execute(PageHeader); //Company Name

        this.executeHeader();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPageByHeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new page when data doesn't not fit on page.
    /// </summary>
    protected void newPageByHeight()
    {
        document.insertPageBreak(currentRow, curWorkSheetNum);

        pageNum++;
        currentHeight = 0;

        this.execute(PageHeader);

        this.execute(Top);
        this.execute(Header);
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts current page num to string.
    /// </summary>
    /// <returns>
    /// Current page num converted to string.
    /// </returns>
    protected PageNum_RU numberOfList()
    {
        return converter.numeralsToTxt(pageNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>outgoingOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns number of outgoing orders converted to string.
    /// </summary>
    /// <returns>
    /// Number of outgoing orders converted to string.
    /// </returns>
    protected TempStr outgoingOrder()
    {
        return converter.numeralsToTxt(numOutOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printRCashBook</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains main logic of report.
    /// </summary>
    protected void printRCashBook()
    {
        TransDate prevTransDate;

        this.initSectionMap();

        this.initHeight();

        if (printProlog)
        {
            this.execute(Prolog);
        }

        while (queryRun.next())
        {
            rCashTrans = queryRun.get(tableNum(RCashTrans));

            if (prevTransDate != rCashTrans.TransDate)
            {
                if (prevTransDate)
                {
                    this.executeFooter();
                }

                this.newPage();

                prevTransDate = rCashTrans.TransDate;
            }

            this.executeBody();
        }

        if (prevTransDate)
        {
            this.executeFooter();
        }
        else
        {
            throw error("@GLS101555");
        }

        if (printEpilog)
        {
            document.insertPageBreak(currentRow, curWorksheetNum);
            this.execute(Epilog);
        }

        this.setPrintArea();

        cashBookReport.parmRepPageNum(initPageNum + pageNum + 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>restInCashCurDescription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates description for amount in rest in cash in currency section.
    /// </summary>
    /// <returns>
    /// String which includes currency name and exchange rate for date being printed.
    /// </returns>
    protected FreeText restInCashCurDescription()
    {
        FreeText freeText;

        if (currencyCode == CompanyInfoHelper::standardCurrency())
        {
            freeText = currencyCode + "@SYS35675";
        }
        else
        {
            const int dateParam = 2;
            const int dateFormat = 123;

            freeText = strFmt(SysLabel::labelId2String(literalStr("@GLS104796"), languageId),
                date2str(lastCashDate, dateFormat, dateParam, dateParam, dateParam, dateParam, dateParam),
                SysLabel::labelId2String(literalStr("@GLS102763"), languageId), currencyCode,
                num2str(ExchangeRateHelper::ExchRate(currencyCode, lastCashDate) / 100, 1, DecimalNum, DecimalSeparator, ThousandSeparator), CompanyInfoHelper::standardCurrency())
                + CompanyInfoHelper::standardCurrency() + "@SYS34952" + currencyCode + "@SYS34953"+"@SYS35675";
        }

        return freeText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>restInCashEndCurDescription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates description for amount in rest in cash end in currency section.
    /// </summary>
    /// <returns>
    /// Name of standard currency plus in brackets name of transaction currency.
    /// </returns>
    protected FreeText restInCashEndCurDescription()
    {
        FreeText freeText;

        if (currencyCode == CompanyInfoHelper::standardCurrency())
        {
            freeText = currencyCode + "@SYS35675";
        }
        else
        {
            freeText = CompanyInfoHelper::standardCurrency() + "@SYS34952" + currencyCode + "@SYS34953"+"@SYS35675";
        }

        return freeText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns name of template for report.
    /// </summary>
    /// <returns>
    /// name of template for report.
    /// </returns>
    protected Filename templateName()
    {
        return resourceStr(RCashKO_4);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalCells</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates number of cells to be filled with data.
    /// </summary>
    /// <returns>
    /// Number of cells to be filled with data.
    /// </returns>
    protected Counter totalCells()
    {
        const int cellsBody = 5;
        const int cellsProlog = 4;
        const int cellsEpilog = 4;
        const int cellsOther = 22;
        return cellsBody * SysQuery::countTotal(queryRun) + cellsProlog * printProlog + cellsEpilog * printEpilog + cellsOther;
    }

]]></Source>
			</Method>
			<Method>
				<Name>yearOfBook</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns year of cash book.
    /// </summary>
    /// <returns>
    /// Year of cash book.
    /// </returns>
    protected int yearOfBook()
    {
        return year(startDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static XMLExcelReport_KO4_RU construct()
    {
        return new XMLExcelReport_KO4_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>