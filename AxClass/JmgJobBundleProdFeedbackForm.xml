<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>JmgJobBundleProdFeedbackForm</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>JmgJobBundleProdFeedbackForm</c> class supports the <c>JmgJobBundleProdFeedback</c> form.
/// </summary>
/// <remarks>
/// The form prompts the user to input feedback quantities when they make stop registrations on
/// production jobs. Based on an instance of the <c>JmgJobBundle</c> class, the
/// <c>JmgJobBundleProdFeedbackForm</c> class initializes two temporary tables,
/// <c>JmgTmpJobBundleProdFeedback</c> and <c>JmgTmpBOMConsump</c> , that contain feedback data and
/// consumption data respectively, which is presented to the user. When the
/// <c>JmgJobBundleProdFeedback</c> form closes, the data entered in the
/// <c>JmgTmpJobBundleProdFeedback</c> table is saved back into the <c>JmgJobBundle</c> object .Data in
/// the <c>JmgTmpBOMConsump</c> table is used to create and post a picking list journal with the
/// entered values. Use the <c>JmgJobBundleProdFeedbackForm</c> class only from the
/// <c>JmgJobBundleProdFeedback</c> form.
/// </remarks>
class JmgJobBundleProdFeedbackForm
{
    JmgJobBundle                            jobBundle;
    boolean                                 requireReportAsFinish;

    FormDataSource                          datasourceConsump;
    int                                     noOfJobsToReport;

    // Production postings:
    List                                    statusQtyProdJournalCheckPost;
    ProdJournalCheckPostBOM                 statusQtyProdJournalCheckPostBOM;
    JmgProdMultiReportFinished              jmgProdMultiReportFinished;
    Map                                     lastOperationCache;
    private JmgTmpSerialNumberSpecification serialNumberSpecification;
    private JmgTmpJobBundleProdFeedback     coByProductFeedback;

    [SysObsolete('Multi-line report as finish journal is taken care of by ProdMultiLineReportAsFinishSerialNumFeature', false, 03\07\2022)]
    private List                            reportFinishedMultiLineJournalCheckPostList;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>cancel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels production postings on the job bundle.
    /// </summary>
    void cancel()
    {
        jobBundle.reset();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFeedbackQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the provided feedback quantities information in the <c>JmgTmpJobBundleProdFeedback</c> table buffer is valid.
    /// </summary>
    /// <param name="_jobBundleProdFeedback">
    /// A temporary table instance of the <c>JmgTmpJobBundleProdFeedback</c> table that contains the values
    /// entered by the user.
    /// </param>
    /// <returns>true if it is valid; otherwise, false.</returns>
    protected boolean validateFeedbackQuantities(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        Map                         unpostedOperQtyMap = new Map(Types::Container, Types::Container);
        JmgTmpJobBundleProdFeedback jobBundleProdFeedback;
        JmgTmpJobBundleProdFeedback jobBundleProdFeedbackCheck;
        InventQty                   oprFeedbackGoodQty;
        InventQty                   oprFeedbackErrorQty;
        ProdRouteJob                prodRouteJob;

        void saveOprFeedbackValue(container key, JmgTmpJobBundleProdFeedback feedBackValue)
        {
            if (unpostedOperQtyMap.exists(key))
            {
                [oprFeedbackGoodQty, oprFeedbackErrorQty] = unpostedOperQtyMap.lookup(key);
                unpostedOperQtyMap.insert(key, [oprFeedbackGoodQty + feedBackValue.GoodNow, oprFeedbackErrorQty + feedBackValue.errorNow()]);
            }
            else
            {
                unpostedOperQtyMap.insert(key, [feedBackValue.GoodNow, feedBackValue.errorNow()]);
            }
        }
    
        boolean ret = true;
        jobBundleProdFeedback.setTmpData(_jobBundleProdFeedback);
        jobBundleProdFeedbackCheck.setTmpData(_jobBundleProdFeedback);
    
        if(JmgProdParameters::find().StampLevel == JmgStampLevel::Job)
        {
            while select jobBundleProdFeedback
                join OprNum from prodRouteJob
                    order by OprNum asc
                    where jobBundleProdFeedback.RouteOprPriority == RouteOprPriority::Primary
                       && prodRouteJob.JobId                     == jobBundleProdFeedback.JobId
                       && prodRouteJob.JobType                   == RouteJobType::Process
            {
                saveOprFeedbackValue([jobBundleProdFeedback.JobRef, prodRouteJob.OprNum], jobBundleProdFeedback);
            }
        }
        else
        {
            ProdRoute prodRoute;

            while select jobBundleProdFeedback
                join OprNum from prodRoute
                    order by OprNum asc
                    where jobBundleProdFeedback.RouteOprPriority == RouteOprPriority::Primary
                       && prodRoute.JobIdProcess                == jobBundleProdFeedback.JobId
            {
                saveOprFeedbackValue([jobBundleProdFeedback.JobRef, prodRoute.OprNum], jobBundleProdFeedback);
            }
        }

        // Validate quantity:
        while select jobBundleProdFeedback
            where jobBundleProdFeedback.RouteOprPriority == RouteOprPriority::Primary
        {
            JmgTermJob_Prod prodJob = JmgTermJob::construct(jobBundleProdFeedback.JobId);
    
            // As JmgJobBundleProdFeedbackForm::validateFeedbackQuantity(), only validate process.
            if (prodJob.module() != JmgModuleEnum::PROD || prodJob.jourRegType() != JmgJourRegTypeEnum::MrpProcess)
            {
                continue;
            }
    
            // Do not validate quantity for the last planning operation since there is no reported quantity.
            // Skip validation for co/by products as they do not exist in jmgJobTable
            if (jobBundleProdFeedback.ProductType == PmfProductType::Co_Product || jobBundleProdFeedback.ProductType == PmfProductType::By_Product ||
                (jobBundleProdFeedback.ProductType == PmfProductType::MainItem && jobBundleProdFeedback.isForLastOperation()))
            {
                continue;
            }

            oprFeedbackGoodQty  = 0;
            oprFeedbackErrorQty = 0;
    
            OprNum oprNum = prodJob.prodRoute().OprNum;
            boolean oprFinish = jobBundleProdFeedback.ReportAsFinished == JmgFeedbackStatus::Completed; 
            if (oprFinish)
            {
                JmgJobTable jmgJobTable;

                while select JobId from jmgJobTable
                    where jmgJobTable.JobId         != jobBundleProdFeedback.JobId
                       && jmgJobTable.OprNum        == oprNum
                       && jmgJobTable.Priority      == RouteOprPriority::Primary
                       && jmgJobTable.ModuleRefId   == jobBundleProdFeedback.JobRef
                    exists join prodRouteJob
                        where prodRouteJob.JobId     == jmgJobTable.JobId
                           && prodRouteJob.ProdId    == jobBundleProdFeedback.JobRef
                           && prodRouteJob.JobStatus != ProdJobStatus::Completed
                {
                    select firstonly RecId from jobBundleProdFeedbackCheck
                        where jobBundleProdFeedbackCheck.JobId              == jmgJobTable.JobId
                           && jobBundleProdFeedbackCheck.ReportAsFinished   == JmgFeedbackStatus::Completed;
    
                    if (!jobBundleProdFeedbackCheck.RecId)
                    {
                        oprFinish = false;
                        break;
                    }
                }
            }
    
            if (unpostedOperQtyMap.exists([jobBundleProdFeedback.JobRef, oprNum]))
            {
                [oprFeedbackGoodQty, oprFeedbackErrorQty] = unpostedOperQtyMap.lookup([jobBundleProdFeedback.JobRef, oprNum]);
            }
    
            if (!JmgJobBundleProdFeedbackForm::validateFeedbackQuantity(
                        oprFeedbackGoodQty + oprFeedbackErrorQty,
                        jobBundleProdFeedback.JobId,
                        oprFinish,
                        false,
                        unpostedOperQtyMap))
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateReportAsFinish</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates none of the records in the provided <c>JmgTmpJobBundleProdFeedback</c> table buffer
    /// have the <c>JmgFeedbackStatus::InProgress</c> status.
    /// </summary>
    /// <param name="_jobBundleProdFeedback">
    /// A temporary table instance of the <c>JmgTmpJobBundleProdFeedback</c> table that contains the values
    /// entered by the user.
    /// </param>
    /// <returns>true if it is valid; otherwise, false.</returns>
    protected boolean validateReportAsFinish(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        boolean ret = true;

        if (requireReportAsFinish)
        {
            JmgTmpJobBundleProdFeedback jobBundleProdFeedback;
            jobBundleProdFeedback.setTmpData(_jobBundleProdFeedback);

            select firstonly jobBundleProdFeedback
                where jobBundleProdFeedback.ReportAsFinished == JmgFeedbackStatus::InProgress;

            if (jobBundleProdFeedback)
            {
                ret = checkFailed("@SYS38464");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateReportedJobStatus</Name>
				<Source><![CDATA[
    private boolean validateReportedJobStatus(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJobCompletedInCurrentBundle</Name>
				<Source><![CDATA[
    private boolean checkJobCompletedInCurrentBundle(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback, 
        ProdId _prodId,
        JmgJobId _jobId, 
        OprNum _oprNum, 
        RouteOprPriority _oprPriority,
        RouteJobType _jobType)
    {
        boolean ret = true;
        JmgTmpJobBundleProdFeedback jobBundleProdFeedbackOneProd;
        jobBundleProdFeedbackOneProd.setTmpData(_jobBundleProdFeedback);

        select firstonly RecId from jobBundleProdFeedbackOneProd
               where jobBundleProdFeedbackOneProd.JobId            == _jobId &&
                     jobBundleProdFeedbackOneProd.ReportAsFinished == JmgFeedbackStatus::Completed;

        if (!jobBundleProdFeedbackOneProd.RecId)
        {
            ret = checkFailed(strFmt("@SCM:JmgJobHasNotBeenCompleted", _prodId, _jobId, _oprNum, _oprPriority, _jobType));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCanClose</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the provided information is valid for the form to be closed.
    /// </summary>
    /// <param name="_jobBundleProdFeedback">
    /// A temporary table instance of the <c>JmgTmpJobBundleProdFeedback</c> table that contains the values
    /// entered by the user.
    /// </param>
    /// <returns>true if it is valid; otherwise, false.</returns>
    protected boolean validateCanClose(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        return this.validateFeedbackQuantities(_jobBundleProdFeedback)
            && this.validateReportAsFinish(_jobBundleProdFeedback)
            && this.validateReportedJobStatus(_jobBundleProdFeedback);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canClose</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the form can close by validating the inputs and creating journals.
    /// </summary>
    /// <param name="_jobBundleProdFeedback">
    /// A temporary table instance of the <c>JmgTmpJobBundleProdFeedback</c> table that contains the values
    /// entered by the user.
    /// </param>
    /// <returns>
    /// true if the user can close the form; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The user can close the form if the entered feedback quantities are valid, according to the Shop
    /// Floor Control parameters.
    /// </remarks>
    public boolean canClose(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        boolean ret = this.validateCanClose(_jobBundleProdFeedback);
    
        // Prompt for journals:
        if (ret)
        {
            this.saveQuantities(_jobBundleProdFeedback);

            if (this.canCreateJournals(_jobBundleProdFeedback.JobId))
            {
                JmgPostStandardSystem jmgPostStandardSystem = JmgPostStandardSystem::constructJobBundle(jobBundle, false);
    
                // Status/quantity.
                statusQtyProdJournalCheckPost = jmgPostStandardSystem.createProdStatusQty();
    
                // Report as finished
                jmgProdMultiReportFinished = jmgPostStandardSystem.createReportFinishedJournal();

                // Multi-line Report as finished journals
                if (!FeatureStateProvider::isFeatureEnabled(ProdMultiLineReportAsFinishSerialNumFeature::instance()))
                {
                    reportFinishedMultiLineJournalCheckPostList = jmgPostStandardSystem.createMultiLineReportAsFinished();
                }

                if (jmgProdMultiReportFinished)
                {
                    ret = !jmgProdMultiReportFinished.parmUserCanceled();
                }
            }
        }
    
        if (!ret)
        {    
            if (!requireReportAsFinish)
            {
                this.cancel();
            }
            
            if (!requireReportAsFinish)
            {
                jobBundle.cancelProductionPostings();
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateJournals</Name>
				<Source><![CDATA[
    private boolean canCreateJournals(JmgJobId _jobId)
    {
        return !JmgManufacturingExecutionWorkloadConfigurationProvider::isJobDeployedOnSpoke(JmgJobTable::find(_jobId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductionParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the production parameters for the specific job.
    /// </summary>
    /// <param name="_jobId">
    /// A job ID.
    /// </param>
    /// <returns>
    /// Production parameters.
    /// </returns>
    public JmgProdParametersDim getProductionParameters(JmgJobId _jobId)
    {
        JmgTermJob_Prod prodJob = JmgTermJob::construct(_jobId);

        return JmgProdParametersDim::find(prodJob.siteInventDimId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReportQuantityNeeded</Name>
				<Source><![CDATA[
    internal boolean isReportQuantityNeeded(JmgJobId _jobId)
    {
        JmgProdParametersDim jmgProdParametersDim = this.getProductionParameters(_jobId);
        return jmgProdParametersDim.ReportFinishStatus == JmgProdStatusUpdateReportFinished::Qty ||
            jmgProdParametersDim.ReportFinishStatus == JmgProdStatusUpdateReportFinished::QtyOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTmpJobBundleProdFeedbackFromProductionJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the production job feedback from the production jobs.
    /// </summary>
    /// <param name = "_jmgTmpJobBundleProdFeedback">A production job feedback record.</param>
    /// <param name = "_prodJob">A production job object to initialize from.</param>
    protected void initializeTmpJobBundleProdFeedbackFromProductionJob(JmgTmpJobBundleProdFeedback _jmgTmpJobBundleProdFeedback, JmgTermJob_Prod _prodJob)
    {
        ProdTable prodTable = _prodJob.prodRoute().prodTable();

        _jmgTmpJobBundleProdFeedback.ProductType      = prodTable.inventTable().PmfProductType;
        _jmgTmpJobBundleProdFeedback.InventTransId    = prodTable.InventTransId;
        _jmgTmpJobBundleProdFeedback.ItemId           = _prodJob.itemId();
        _jmgTmpJobBundleProdFeedback.JobRef           = _prodJob.jobRef();
        _jmgTmpJobBundleProdFeedback.JobId            = _prodJob.jobId();
        _jmgTmpJobBundleProdFeedback.JobType          = _prodJob.prodJobType();
        _jmgTmpJobBundleProdFeedback.JobDescription   = _prodJob.jobDescription();
        _jmgTmpJobBundleProdFeedback.QtyGood          = _prodJob.qtyGood();
        _jmgTmpJobBundleProdFeedback.QtyError         = _prodJob.qtyError();
        _jmgTmpJobBundleProdFeedback.RouteOprPriority = _prodJob.oprPriority();
        _jmgTmpJobBundleProdFeedback.CalcQty          = _prodJob.calcQty();
        _jmgTmpJobBundleProdFeedback.WHSLicensePlate  = _jmgTmpJobBundleProdFeedback.checkWhsLicensePlateEnabledForJob() ? _prodJob.getWhsLicensePlateId() : null;

        if (JmgRegistrationTouchReportProgressBatchSerialNumberEnableFeature::isEnabled())
        {
            _jmgTmpJobBundleProdFeedback.InventBatch  = this.inventBatchRequired(_jmgTmpJobBundleProdFeedback)
                                            ? _prodJob.getInventBatchId() : null;

            _jmgTmpJobBundleProdFeedback.InventSerial = this.inventSerialRequired(_jmgTmpJobBundleProdFeedback) 
                                            ? _prodJob.getInventSerialId() : null;
        }
     
        if (#PdsCatchWeightEnabled)
        {
            _jmgTmpJobBundleProdFeedback.PdsCWQtyGood            = _prodJob.pdsCWQtyGood();
            _jmgTmpJobBundleProdFeedback.PdsCWQtyError           = _prodJob.pdsCWQtyError();
            _jmgTmpJobBundleProdFeedback.PdsCWCalcQty            = _prodJob.pdsCWCalcQty();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTmpJobBundleProdFeedbackFromCoByProduct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the production job feedback from the co/by product.
    /// </summary>
    /// <param name = "_jmgTmpJobBundleProdFeedback">A production job feedback record.</param>
    /// <param name = "_job">A production job object for a main item/formula to initialize from.</param>
    /// <param name = "_prodCoBy">A <c>PmfProdCoBy</c> object to initialize from.</param>
    protected void initializeTmpJobBundleProdFeedbackFromCoByProduct(JmgTmpJobBundleProdFeedback _jmgTmpJobBundleProdFeedback, JmgTermJob_Prod _job, PmfProdCoBy _prodCoBy)
    {
        _jmgTmpJobBundleProdFeedback.ItemId           = _prodCoBy.ItemId;
        _jmgTmpJobBundleProdFeedback.InventTransId    = _prodCoBy.InventTransId;
        _jmgTmpJobBundleProdFeedback.ProductType      = _prodCoBy.ProductType;
        _jmgTmpJobBundleProdFeedback.JobRef           = _prodCoBy.ProdId;
        _jmgTmpJobBundleProdFeedback.JobId            = _job.jobId();
        _jmgTmpJobBundleProdFeedback.JobType          = _job.prodJobType();
        _jmgTmpJobBundleProdFeedback.JobDescription   = _prodCoBy.itemName();
        _jmgTmpJobBundleProdFeedback.RouteOprPriority = RouteOprPriority::Primary;
        _jmgTmpJobBundleProdFeedback.CalcQty          = _prodCoBy.QtyCoByCalc;
        _jmgTmpJobBundleProdFeedback.QtyGood          = _prodCoBy.reportedFinishedGood();
        _jmgTmpJobBundleProdFeedback.QtyError         = _prodCoBy.reportedFinishedError();
        
        _jmgTmpJobBundleProdFeedback.WHSLicensePlate  = _jmgTmpJobBundleProdFeedback.checkWhsLicensePlateEnabledForJob() ? InventDim::find(_prodCoBy.InventDimId).LicensePlateId : null;

        if (JmgRegistrationTouchReportProgressBatchSerialNumberEnableFeature::isEnabled())
        {
            _jmgTmpJobBundleProdFeedback.InventBatch  = this.inventBatchRequired(_jmgTmpJobBundleProdFeedback)
                                            ? InventDim::find(_prodCoBy.InventDimId).inventBatchId : null;

            _jmgTmpJobBundleProdFeedback.InventSerial = this.inventSerialRequired(_jmgTmpJobBundleProdFeedback)
                                            ? InventDim::find(_prodCoBy.InventDimId).inventSerialId : null;
        }

        if (#PdsCatchWeightEnabled && PdsGlobal::pdsIsCWItem(_prodCoBy.ItemId))
        {
            _jmgTmpJobBundleProdFeedback.PdsCWCalcQty   = _prodCoBy.PdsCWInventCalc;
            _jmgTmpJobBundleProdFeedback.PdsCWQtyGood   = _prodCoBy.pdsCWReportedFinishedGood();
            _jmgTmpJobBundleProdFeedback.PdsCWQtyError  = _prodCoBy.pdsCWReportedFinishedError();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectJobsAndRelatedCoByProducts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the production job feedback list with related co/by products.
    /// </summary>
    /// <param name = "_prodJob">A production job object for a main item/formula to initialize from.</param>
    /// <returns>
    /// The production job feedback list with related co/by products.
    /// </returns>
    [Hookable(false)]
    internal jmgTmpJobBundleProdFeedback selectJobsAndRelatedCoByProducts(JmgTermJob_Prod _prodJob)
    {
        JmgTmpJobBundleProdFeedback jmgTmpJobBundleProdFeedback;

        using (var serialBatchControlContext = new JmgReportProgressSerialBatchNumberControlContext())
        {
            if (_prodJob)
            {
                this.initializeTmpJobBundleProdFeedbackFromProductionJob(jmgTmpJobBundleProdFeedback, _prodJob);
                jmgTmpJobBundleProdFeedback.insert();

                if (_prodJob.pmfCanHaveCoProducts() && _prodJob.jmgJobTable().isPrimaryOperation() && _prodJob.prodRoute().isLastOpr()
                  && (jmgTmpJobBundleProdFeedback.ProductType == PmfProductType::Formula || jmgTmpJobBundleProdFeedback.ProductType == PmfProductType::MainItem))
                {
                    PmfProdCoBy prodCoBy;

                    while select prodCoBy
                        where prodCoBy.ProdId == _prodJob.jobRef()
                    {
                        this.initializeTmpJobBundleProdFeedbackFromCoByProduct(jmgTmpJobBundleProdFeedback, _prodJob, prodCoBy);
                        jmgTmpJobBundleProdFeedback.insert();
                    }
                }

                if (this.mustRemoveAllPlanningItemsFromReportedList())
                {
                    while select jmgTmpJobBundleProdFeedback
                    {
                        // Remove all Planning items from the reported list
                        if (JmgTmpJobBundleProdFeedback.ProductType == PmfProductType::MainItem)
                        {
                            jmgTmpJobBundleProdFeedback.delete();
                        }
                    }
                }
            }
        }

        return jmgTmpJobBundleProdFeedback;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustRemoveAllPlanningItemsFromReportedList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the planning items must be removed from the reported list or not.
    /// </summary>
    /// <returns>True if the planning items must be removed from the reported list, otherwise false.</returns>
    protected boolean mustRemoveAllPlanningItemsFromReportedList()
    {
        return JmgJobBundleProdFeedbackReportPlanningItemFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTmpJobBundleProdFeedbackFromJmgRegistrationParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the production job feedback from the registration parameters.
    /// </summary>
    /// <param name = "_jmgTmpJobBundleProdFeedback">A production job feedback record.</param>
    /// <param name = "_params">The registration parameters to initialize from.</param>
    protected void initializeTmpJobBundleProdFeedbackFromJmgRegistrationParameters(JmgTmpJobBundleProdFeedback _jmgTmpJobBundleProdFeedback, JmgRegistrationParameters _params)
    {
        _jmgTmpJobBundleProdFeedback.GoodNow                 = _params.goodQuantity();
        _jmgTmpJobBundleProdFeedback.ErrorSpecification      = _params.errorSpecification();
        if (requireReportAsFinish)
        {
            _jmgTmpJobBundleProdFeedback.ReportAsFinished    = JmgParameters::find().DefaultReportAsFinish;
        }
        else
        {
            _jmgTmpJobBundleProdFeedback.ReportAsFinished    = _params.reportAsFinished();
        }
        _jmgTmpJobBundleProdFeedback.ProdJournalIdBOM        = _params.prodJournalIdBOM();

        if (#PdsCatchWeightEnabled)
        {
            _jmgTmpJobBundleProdFeedback.PdsCWGoodNow        = _params.pdsCWGoodQuantity();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTmpJobBundleProdFeedback</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a <c>JmgTmpJobBundleProdFeedback</c> record.
    /// </summary>
    /// <returns>
    /// A <c>JmgTmpJobBundleProdFeedback</c> record that contains the data that is displayed in the
    /// <c>JmgJobBundleProdFeedback</c> form.
    /// </returns>
    /// <remarks>
    /// The return value contains a record for every job that is found in the <c>JmgJobBundle</c> object
    /// that is specified in the <see cref="M:JmgJobBundleProdFeedbackForm.new" /> method.
    /// </remarks>
    public JmgTmpJobBundleProdFeedback getTmpJobBundleProdFeedback()
    {
        JmgTmpJobBundleProdFeedback ret;
        MapIterator activeJobsIterator      = jobBundle.getActiveJobsIterator();
        noOfJobsToReport = 0;
        while (activeJobsIterator.more())
        {
            JmgTermJob job = activeJobsIterator.value();
            if (job.module() == JmgModuleEnum::PROD)
            {
                this.insertProductionJobFeedback(ret, job);
            }
            activeJobsIterator.next();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTmpJobBundleProdFeedbackSelectedJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the initialized <c>JmgTmpJobBundleProdFeedback</c> for the selected job ids.
    /// </summary>
    /// <param name = "_selectedJobIds">Jobs ids for the selected jobs.</param>
    /// <returns>Feedback for the selected job ids.</returns>
    [Hookable(false)]
    internal JmgTmpJobBundleProdFeedback getTmpJobBundleProdFeedbackSelectedJobs(container _selectedJobIds)
    {
        JmgTmpJobBundleProdFeedback ret;
        for (int i = 1; i <= conLen(_selectedJobIds); i++)
        {
            JmgTermJob_Prod job = JmgTermJob::construct(queryValue(conPeek(_selectedJobIds, i)));
            this.insertProductionJobFeedback(ret, job);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTmpJobBundleProdFeedbackFromList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the data from the <c>JmgTmpJobBundleProdFeedback</c> for reporting progress.
    /// </summary>
    /// <param name = "_jobBundleProdFeedback">
    /// The <c>JmgTmpJobBundleProdFeedback</c> object which needs to be used for initialization.
    /// </param>
    /// <returns>
    /// The return value contains a record for every job that is found in the <c>JmgTmpJobBundleProdFeedback</c>
    /// that is passed as a parameter.
    /// </returns>
    [Hookable(false)]
    internal JmgTmpJobBundleProdFeedback getTmpJobBundleProdFeedbackFromList(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        noOfJobsToReport = 0;
        while select _jobBundleProdFeedback
        {
           // Initialize JobBundleProdFeedback only for main items
          if (!_jobBundleProdFeedback.isCoByProduct())
            {
                JmgRegistrationParameters params  = jobBundle.getFeedbackParameters(_jobBundleProdFeedback.JobId);
                this.initializeTmpJobBundleProdFeedbackFromJmgRegistrationParameters(_jobBundleProdFeedback, params);
            }

            noOfJobsToReport++;
            lastOperationCache.insert(_jobBundleProdFeedback.JobId, _jobBundleProdFeedback.isForLastOperation());
        }

        return _jobBundleProdFeedback;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProductionJobFeedback</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts production job feedback.
    /// </summary>
    /// <param name = "_jobBundleProdFeedback">Feedback on production job.</param>
    /// <param name = "_job">Job in Shop Floor Control.</param>
    protected void insertProductionJobFeedback(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback, JmgTermJob _job)
    {
        if (this.canInsertProductionJobFeedback(_job))
        {
            JmgTermJob_Prod prodJob = _job;
            this.initializeTmpJobBundleProdFeedbackFromProductionJob(_jobBundleProdFeedback, prodJob);
            JmgRegistrationParameters params  = jobBundle.getFeedbackParameters(_job.jobId());
            this.initializeTmpJobBundleProdFeedbackFromJmgRegistrationParameters(_jobBundleProdFeedback, params);
            _jobBundleProdFeedback.insert();
            noOfJobsToReport++;
            lastOperationCache.insert(prodJob.jobId(), prodJob.prodRoute().isLastOpr());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInsertProductionJobFeedback</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validation method for CoC whether insertion of production job feedback should happen or not.
    /// </summary>
    /// <param name = "_job"> Job in Shop Floor Control.</param>
    ///  <returns>
    ///    true if insertion of production job feedback should happen; otherwise, false.
    /// </returns>
    protected boolean canInsertProductionJobFeedback(JmgTermJob _job)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>JmgJobBundleProdFeedbackForm</c> class.
    /// </summary>
    /// <param name="_jobBundle">
    ///    A reference to the <c>JmgJobBundle</c> object, which is requesting feedback.
    /// </param>
    /// <param name="_requireReportAsFinish">
    ///    true if the user must set the status to either stopped or completed; otherwise, false.
    /// </param>
    /// <remarks>
    ///    The <c>JmgJobBundleProdFeedback</c> class should be instantiated only from the
    ///    <c>JmgJobBundleProdFeedback</c> form.
    /// </remarks>
    public void new(JmgJobBundle _jobBundle, boolean _requireReportAsFinish)
    {
        jobBundle               = _jobBundle;
        requireReportAsFinish   = _requireReportAsFinish;
        lastOperationCache      = new Map(Types::String, Types::Integer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>noOfFoundRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the number of jobs to provide feedback on.
    /// </summary>
    /// <returns>
    /// the number of jobs to provide feedback on.
    /// </returns>
    int noOfFoundRecords()
    {
        return noOfJobsToReport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onClose</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Hooks into the <c>close</c> method of the <c>JmgJobBundleProdFeedback</c> form.
    /// </summary>
    /// <param name="_jobBundleProdFeedback">
    ///    An instance of the <c>JmgTmpJobBundleProdFeedback</c> table that contains the information, which
    ///    should be saved in the <c>JmgJobBundle</c> object.
    /// </param>
    /// <remarks>
    ///    This method saves the entered values back into the <c>JmgJobBundle</c> object, and then posts a
    ///    picking list journal. It is created based on values entered in the
    ///    <c>JmgTmpJobBundleProdFeedback</c> buffer.Each record in the <c>JmgTmpJobBundleProdFeedback</c>
    ///    table contains the registration parameters for a job. These are saved back into the
    ///    <c>JmgJobBundle</c> object. Posting the picking list journal is handled by the
    ///    <c>JmgJobBundleProdFeedbackForm.postConsump</c> method.
    /// </remarks>
    public void onClose(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        jobBundle.setStatusQtyJournalPosting(statusQtyProdJournalCheckPost);

        this.saveQuantities(_jobBundleProdFeedback);

        jobBundle.setReportFinishedJournalPosting(jmgProdMultiReportFinished);
        if (!FeatureStateProvider::isFeatureEnabled(ProdMultiLineReportAsFinishSerialNumFeature::instance()))
        {
            jobBundle.setReportFinishedMultiLineJournalPosting(reportFinishedMultiLineJournalCheckPostList);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>quantityChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the reported quantity is valid and recalculates BOM consumption.
    /// </summary>
    /// <param name="_jobBundleProdFeedback">
    /// The job for which consumption should be recalculated.
    /// </param>
    /// <param name="_alwaysModifyPickList"> 
    /// true if the pick list should be updated silently, false if user should be prompted before updating the pick list
    /// </param>
    public void quantityChanged(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback, boolean _alwaysModifyPickList = false)
    {
        this.validateMaxReportQuantity(_jobBundleProdFeedback);

        this.recalculatePickingList(_jobBundleProdFeedback, _alwaysModifyPickList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalculatePickingList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculates the BOM consumption for a record in the <c>JmgTmpJobBundleProdFeedback</c> table.
    /// </summary>
    /// <param name="_jobBundleProdFeedback">
    /// The job for which consumption should be recalculated.
    /// </param>
    /// <param name="_alwaysModifyPickList"> 
    /// true if the pick list should be updated silently, false if user should be prompted before updating the pick list
    /// </param>
    [Hookable(false)]
    internal void recalculatePickingList(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback, boolean _alwaysModifyPickList = false)
    {
        // Prompt user if picking list should be recalculated.
        if (_jobBundleProdFeedback.ProdJournalIdBOM)
        {
            boolean modifyPickingList = _alwaysModifyPickList ? true: Box::yesNo("@SYS106206", DialogButton::Yes, "@SYS106207", "@SYS106208") == DialogButton::Yes;

            if (modifyPickingList)
            {
                JmgRegistrationParameters feedbackParams = new JmgRegistrationParameters();
                feedbackParams.goodQuantity(_jobBundleProdFeedback.GoodNow);
                feedbackParams.pdsCWGoodQuantity(_jobBundleProdFeedback.PdsCWGoodNow);
                feedbackParams.errorSpecification(_jobBundleProdFeedback.ErrorSpecification);
                feedbackParams.reportAsFinished(_jobBundleProdFeedback.ReportAsFinished);
                feedbackParams.prodJournalIdBOM(_jobBundleProdFeedback.ProdJournalIdBOM);

                JmgPostStandardSystem jmgPostStandardSystem = JmgPostStandardSystem::construct();
                jmgPostStandardSystem.addJob(JmgTermJob::construct(_jobBundleProdFeedback.JobId), feedbackParams);

                jmgPostStandardSystem.createUpdateBOMJournal();

                // Write the new BOM journal id back to temp table
                _jobBundleProdFeedback.ProdJournalIdBOM = feedbackParams.prodJournalIdBOM();
                _jobBundleProdFeedback.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the quantities that are provided by the user in the <c>JmgJobBundle</c> object.
    /// </summary>
    /// <param name="_jobBundleProdFeedback">
    /// A temporary buffer that contains the feedback provided by the user.
    /// </param>
    protected void saveQuantities(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        JmgTmpJobBundleProdFeedback jobBundleProdFeedback;
        JmgRegistrationParameters   feedbackParams;
        jobBundleProdFeedback.setTmpData(_jobBundleProdFeedback);

        while select jobBundleProdFeedback
        {
            feedbackParams = jobBundle.getFeedbackParameters(jobBundleProdFeedback.JobId);
            this.saveQuantity(feedbackParams, jobBundleProdFeedback, _jobBundleProdFeedback);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the quantity for the corresponding <c>JmgJobBundle</c> record.
    /// </summary>
    /// <param name = "_feedbackParams"> Feedback parameters for a specific job. </param>
    /// <param name = "_jobBundleProdFeedback"> The feedback provided by the user on the specific job. </param>
    /// <param name = "_tmpJobBundleProdFeedback"> A temporary buffer that contains the feedback provided by the user. </param>
    protected void saveQuantity(JmgRegistrationParameters _feedbackParams, JmgTmpJobBundleProdFeedback _jobBundleProdFeedback, JmgTmpJobBundleProdFeedback _tmpJobBundleProdFeedback)
    {
        _feedbackParams.goodQuantity(_jobBundleProdFeedback.GoodNow);
        _feedbackParams.pdsCWGoodQuantity(_jobBundleProdFeedback.PdsCWGoodNow);
        _feedbackParams.errorSpecification(_jobBundleProdFeedback.ErrorSpecification);
        _feedbackParams.reportAsFinished(_jobBundleProdFeedback.ReportAsFinished);
        if (_jobBundleProdFeedback.ProdJournalIdBOM)
        {
            _feedbackParams.prodJournalIdBOM(_jobBundleProdFeedback.ProdJournalIdBOM);
        }

        _feedbackParams.parmWHSLicensePlateId(this.whsLicensePlateEnabled(_jobBundleProdFeedback) ? _jobBundleProdFeedback.WHSLicensePlate : "");
        _feedbackParams.parmInventBatchId((_jobBundleProdFeedback.GoodNow > 0 && this.inventBatchRequired(_jobBundleProdFeedback)) ? _jobBundleProdFeedback.InventBatch : "");

        boolean serialNumberRequired = this.inventSerialRequired(_jobBundleProdFeedback);
        this.throwErrorIfSerialNumberReportingIsNotSupportedFromScaleUnits(serialNumberRequired);
        
        _feedbackParams.parmSerialNumberSpecification(this.parmSerialNumberSpecification());
        _feedbackParams.parmSerialNumberRequired(serialNumberRequired);

        _feedbackParams.parmCoByProductFeedback(this.parmCoByProductFeedback());
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwErrorIfSerialNumberReportingIsNotSupportedFromScaleUnits</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Throw error if serial number reporting is not supported from scale units.
    /// </summary>
    /// <param name = "_isSerialNumberRequired"> Is serial number registration required.</param>
    private void throwErrorIfSerialNumberReportingIsNotSupportedFromScaleUnits(boolean _isSerialNumberRequired)
    {
        if (_isSerialNumberRequired && JmgManufacturingExecutionWorkloadConfigurationProvider::isRunningOnSpoke())
        {
            throw Error ("@SCM:SerialNumberReportingIsNotSupportedWhenYouUseScaleUnits");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPickingListJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the Picking list journal for the registrations in the specified temporary buffer.
    /// </summary>
    /// <param name="_jobBundleProdFeedback">
    /// The temporary buffer that contains the registrations for which to display the BOM.
    /// </param>
    /// <param name="_createEmptyLines">
    /// true if the picking list journal must include lines with empty quantities (in case of registering the overconsumption); otherwise, false.
    /// </param>
    public JmgPostStandardSystem createPickingListJournal(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback, boolean _createEmptyLines = false)
    {
        JmgRegistrationParameters feedbackParams = new JmgRegistrationParameters();
        feedbackParams.goodQuantity(_jobBundleProdFeedback.GoodNow);
        feedbackParams.pdsCWGoodQuantity(_jobBundleProdFeedback.PdsCWGoodNow);
        feedbackParams.errorSpecification(_jobBundleProdFeedback.ErrorSpecification);
        feedbackParams.reportAsFinished(_jobBundleProdFeedback.ReportAsFinished);
        feedbackParams.prodJournalIdBOM(_jobBundleProdFeedback.ProdJournalIdBOM);

        JmgPostStandardSystem jmgPostStandardSystem = JmgPostStandardSystem::construct();
        jmgPostStandardSystem.addJob(JmgTermJob::construct(_jobBundleProdFeedback.JobId), feedbackParams);
        jmgPostStandardSystem.parmCreateEmptyQtyBomJournalLine(_createEmptyLines);

        if (!_jobBundleProdFeedback.ProdJournalIdBOM)
        {
            jmgPostStandardSystem.createUpdateBOMJournal(true, true);

            _jobBundleProdFeedback.ProdJournalIdBOM = feedbackParams.prodJournalIdBOM();
            _jobBundleProdFeedback.update();
        }

        return jmgPostStandardSystem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the BOM for the registrations in the specified temporary buffer.
    /// </summary>
    /// <param name="_jobBundleProdFeedback">
    /// The temporary buffer that contains the registrations for which to display the BOM.
    /// </param>
    public void showBOM(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        JmgPostStandardSystem jmgPostStandardSystem = this.createPickingListJournal(_jobBundleProdFeedback);
        jmgPostStandardSystem.showBOMJournals();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildBatchNumberLookupQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds a lookup query for the <c>inventBatchId</c> field.
    /// </summary>
    /// <param name = "_prodId">The <c>ProdId</c> of the reported production order.</param>
    /// <param name = "_itemId">The <c>ItemId</c> of the reported product.</param>
    /// <param name = "_inventTransId">The <c>InventTransId</c> of the reported product. It is null for reporting co-product variation. </param>
    /// <param name = "_inventBatchValue">The <c>inventBatchId</c> value if the batch number checking in the lookup list needed. Optional.
    /// </param>
    /// <returns>
    ///     A query for selecting all non-empty batch numbers for this production order 
    ///     or a query for checking the batch number in the batch number lookup list.
    /// </returns>
    [Hookable(false)]
    internal static Query buildBatchNumberLookupQuery(ProdId _prodId, ItemId _itemId, InventTransId _inventTransId = null, str _inventBatchValue = SysQuery::valueNotEmptyString())
    {
        Query                   query = new Query();
        QueryBuildDataSource    queryBuildInventDimDataSource;
                
        queryBuildInventDimDataSource = query.addDataSource(tableNum(InventDim));
        queryBuildInventDimDataSource.addRange(fieldNum(InventDim, inventBatchId)).value(_inventBatchValue);

        JmgJobBundleProdFeedbackForm::buildBatchNumberLookupQueryFromInventDim(queryBuildInventDimDataSource, _prodId, _itemId, _inventTransId);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildBatchNumberLookupQueryFromInventDim</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static void buildBatchNumberLookupQueryFromInventDim(QueryBuildDataSource _queryBuildInventDimDataSource, ProdId _prodId, ItemId _itemId, InventTransId _inventTransId = null)
    {
        QueryBuildDataSource queryBuildInventTransDataSource, queryBuildInventTransOrigDataSource;

        queryBuildInventTransDataSource = _queryBuildInventDimDataSource.addDataSource(tableNum(InventTrans));
        queryBuildInventTransDataSource.relations(true);
        queryBuildInventTransDataSource.fetchMode(QueryFetchMode::One2One);
        queryBuildInventTransDataSource.addRange(fieldNum(InventTrans, ItemId)).value(_itemId);

        queryBuildInventTransOrigDataSource = queryBuildInventTransDataSource.addDataSource(tableNum(InventTransOrigin));
        queryBuildInventTransOrigDataSource.relations(true);

        if (_inventTransId)
        {
            queryBuildInventTransOrigDataSource.addRange(fieldNum(InventTransOrigin, InventTransId)).value(_inventTransId);
        }

        queryBuildInventTransOrigDataSource.addRange(fieldNum(InventTransOrigin, ReferenceId)).value(_prodId);
        queryBuildInventTransOrigDataSource.addRange(fieldNum(InventTransOrigin, ItemId)).value(_itemId);

        _queryBuildInventDimDataSource.addSortField(fieldNum(InventDim, inventBatchId));
        _queryBuildInventDimDataSource.addGroupByField(fieldNum(InventDim, inventBatchId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSerialNumberLookupQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds a lookup query for the <c>inventSerialId</c> field.
    /// </summary>
    /// <param name = "_prodId">The <c>ProdId</c> of the reported production order.</param>
    /// <param name = "_itemId">The <c>ItemId</c> of the reported product.</param>
    /// <param name = "_inventTransId">The <c>InventTransId</c> of the reported product. It is null for reporting co-product variation. </param>
    /// <param name = "_inventSerialValue">The <c>inventBatchId</c> value if the serial number checking in the lookup list needed. Optional.
    /// </param>
    /// <returns>
    ///     A query for selecting all non-empty serial numbers for this production order
    ///     or a query for checking the serial number in the serial number lookup list.
    /// </returns>
    [Hookable(false)]
    internal static Query buildSerialNumberLookupQuery(ProdId _prodId, ItemId _itemId, InventTransId _inventTransId = null, str _inventSerialValue = SysQuery::valueNotEmptyString())
    {
        Query                   query = new Query();
        QueryBuildDataSource    queryBuildInventDimDataSource;
                
        queryBuildInventDimDataSource = query.addDataSource(tableNum(InventDim));
        queryBuildInventDimDataSource.addRange(fieldNum(InventDim, inventSerialId)).value(_inventSerialValue);

        JmgJobBundleProdFeedbackForm::buildSerialNumberLookupQueryFromInventDim(queryBuildInventDimDataSource, _prodId, _itemId, _inventTransId);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSerialNumberLookupQueryFromInventDim</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static void buildSerialNumberLookupQueryFromInventDim(QueryBuildDataSource _queryBuildInventDimDataSource, ProdId _prodId, ItemId _itemId, InventTransId _inventTransId = null)
    {
        QueryBuildDataSource    queryBuildInventTransDataSource, queryBuildInventTransOrigDataSource;

        queryBuildInventTransDataSource = _queryBuildInventDimDataSource.addDataSource(tableNum(InventTrans));
        queryBuildInventTransDataSource.relations(true);
        queryBuildInventTransDataSource.joinMode(JoinMode::ExistsJoin);
        queryBuildInventTransDataSource.fetchMode(QueryFetchMode::One2One);
        queryBuildInventTransDataSource.addRange(fieldNum(InventTrans, ItemId)).value(_itemId);
        queryBuildInventTransDataSource.addRange(fieldNum(InventTrans, StatusReceipt)).value(SysQuery::value(StatusReceipt::Ordered));

        queryBuildInventTransOrigDataSource = queryBuildInventTransDataSource.addDataSource(tableNum(InventTransOrigin));
        queryBuildInventTransOrigDataSource.relations(true);
        queryBuildInventTransDataSource.joinMode(JoinMode::ExistsJoin);

        if (_inventTransId)
        {
            queryBuildInventTransOrigDataSource.addRange(fieldNum(InventTransOrigin, InventTransId)).value(_inventTransId);
        }

        queryBuildInventTransOrigDataSource.addRange(fieldNum(InventTransOrigin, ReferenceId)).value(_prodId);
        queryBuildInventTransOrigDataSource.addRange(fieldNum(InventTransOrigin, ItemId)).value(_itemId);

        _queryBuildInventDimDataSource.addSortField(fieldNum(InventDim, inventSerialId));
        _queryBuildInventDimDataSource.addGroupByField(fieldNum(InventDim, inventSerialId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMaxReportQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the maximum allowed quantity for feedback reporting has not been exceeded.
    /// </summary>
    /// <param name="_jobBundleProdFeedback">
    /// A <c>JmgTmpJobBundleProdFeedback</c> record.
    /// </param>
    public void validateMaxReportQuantity(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        JmgProdParametersDim jmgProdParametersDim = this.getProductionParameters(_jobBundleProdFeedback.JobId);

        if (_jobBundleProdFeedback.GoodNow > jmgProdParametersDim.MaxQty)
        {
            warning(strFmt("@SYS4000717", _jobBundleProdFeedback.GoodNow, jmgProdParametersDim.MaxQty));
        }
        else if (_jobBundleProdFeedback.errorNow() > jmgProdParametersDim.MaxQty)
        {
            warning(strFmt("@SYS4000718", _jobBundleProdFeedback.errorNow(), jmgProdParametersDim.MaxQty));
        }
        else if (_jobBundleProdFeedback.PdsCWGoodNow > jmgProdParametersDim.MaxQty)
        {
            warning(strFmt("@SYS4000719", _jobBundleProdFeedback.PdsCWGoodNow, jmgProdParametersDim.MaxQty));
        }
        else if (_jobBundleProdFeedback.pdsCWErrorNow() > jmgProdParametersDim.MaxQty)
        {
            warning(strFmt("@SYS4000720", _jobBundleProdFeedback.pdsCWErrorNow(), jmgProdParametersDim.MaxQty));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMaxReportQuantityPrompt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prompts a dialog form of whether the worker wants to accept reporting a quantity that is over the maximum allowed quantity as per the 'Production order defaults' setup.
    /// </summary>
    /// <param name = "_jobBundleProdFeedback"> The <c>JmgTmpJobBundleProdFeedback</c> record. </param>
    /// <returns> true if user accepts report quantity; otherwise, false. </returns>
    [Hookable(false)]
    internal boolean validateMaxReportQuantityPrompt(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        JmgProdParametersDim jmgProdParametersDim = this.getProductionParameters(_jobBundleProdFeedback.JobId);

        if (!_jobBundleProdFeedback.isCWItem())
        {
            if (_jobBundleProdFeedback.GoodNow > jmgProdParametersDim.MaxQty)
            {
                return Box::yesNo(strFmt("@SCM:JmgMaxGoodQtyPrompt", _jobBundleProdFeedback.GoodNow, jmgProdParametersDim.MaxQty), DialogButton::No) == DialogButton::Yes;
            }

            if (_jobBundleProdFeedback.errorNow() > jmgProdParametersDim.MaxQty)
            {
                return Box::yesNo(strFmt("@SCM:JmgMaxErrorQtyPrompt", _jobBundleProdFeedback.errorNow(), jmgProdParametersDim.MaxQty), DialogButton::No) == DialogButton::Yes;
            }
        }
        else
        {
            if (_jobBundleProdFeedback.PdsCWGoodNow > jmgProdParametersDim.MaxQty)
            {
                return Box::yesNo(strFmt("@SCM:JmgMaxCWGoodQtyPrompt", _jobBundleProdFeedback.PdsCWGoodNow, jmgProdParametersDim.MaxQty), DialogButton::No) == DialogButton::Yes;
            }

            if (_jobBundleProdFeedback.pdsCWErrorNow() > jmgProdParametersDim.MaxQty)
            {
                return Box::yesNo(strFmt("@SCM:JmgMaxCWErrorQtyPrompt", _jobBundleProdFeedback.pdsCWErrorNow(), jmgProdParametersDim.MaxQty), DialogButton::No) == DialogButton::Yes;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFeedbackQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates a quantity that is entered by the user.
    /// </summary>
    /// <param name="_quantityDelta">
    ///    The quantity delta to validate.
    /// </param>
    /// <param name="_jobId">
    ///    The job ID that the quantity is entered for.
    /// </param>
    /// <param name="_finished">
    ///    Indicates whether the user has reported the job as finished.
    /// </param>
    /// <param name="_throwError">
    ///    Indicates whether to throw an error if the entered quantity is invalid; optional.
    /// </param>
    /// <param name ="_unpostedOperQtyMap">
    ///    Unposted quantity map; optional.
    /// </param>
    /// <returns>
    ///    true if the entered quantity was valid; otherwise, false.
    /// </returns>
    public static boolean validateFeedbackQuantity(real _quantityDelta, JmgJobId _jobId, boolean _finished, boolean _throwError = false, Map _unpostedOperQtyMap = null)
    {
        boolean                   retVal;
        JmgProdQuantityValidation qtyValidation;

        qtyValidation = JmgProdQuantityValidation::constructFromJobId(_jobId);
        retVal = qtyValidation.validateFeedbackQuantity(_quantityDelta, _throwError, _finished, _unpostedOperQtyMap);

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFeedbackForLastOperation</Name>
				<Source><![CDATA[
    private boolean isFeedbackForLastOperation(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        if (!lastOperationCache.exists(_jobBundleProdFeedback.JobId))
        {
            lastOperationCache.insert(_jobBundleProdFeedback.JobId, _jobBundleProdFeedback.isForLastOperation());
        }

        return lastOperationCache.lookup(_jobBundleProdFeedback.JobId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsLicensePlateEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the warehouse license plate id information is editable.
    /// </summary>
    /// <param name="_jobBundleProdFeedback">
    /// The <c>JmgTmpJobBundleProdFeedback</c> to make this check for.
    /// </param>
    /// <returns>
    /// true if the check passes; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The check passes when item and the warehouse are both WMS enabled,
    /// the worker is reporting some good quantity, the operation is the last one,
    /// and the production order is not a batch order.
    /// </remarks>
    public boolean whsLicensePlateEnabled(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        return _jobBundleProdFeedback.whsLicensePlateEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWHSWorkTableWithSameLicensePlate</Name>
				<Source><![CDATA[
    internal boolean checkWHSWorkTableWithSameLicensePlate(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        WHSWorkTable whsWorkTable = WHSWorkTable::findWHSWorkTableWithSameLicensePlate(_jobBundleProdFeedback.JobRef, _jobBundleProdFeedback.WHSLicensePlate);
        
        if (whsWorkTable)
        {
            return checkFailed(strFmt("@WAX:Error_RepeatedTargetLicensePlateNotAllowedForWHSWorkTable", _jobBundleProdFeedback.WHSLicensePlate));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventBatchRequired</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the batch number is enabled for <c>JmgTmpJobBundleProdFeedback</c>.
    /// </summary>
    /// <param name = "_jobBundleProdFeedback">
    ///     The <c>JmgTmpJobBundleProdFeedback</c> to make this check for.
    /// </param>
    /// <returns>
    ///     true if batch is enabled for job; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The check passes when item is batch number enabled,
    /// batch number group is not set for an item or 
    /// physical update is set to No for the batch number group.
    /// </remarks>
    [Hookable(false)]
    internal boolean inventBatchRequired(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        if (!this.doSerialBatchNumberControlCheck())
        {
            return false;
        }

        if (!_jobBundleProdFeedback.isForLastOperation())
        {
            return false;
        }

        if (!_jobBundleProdFeedback.ItemId)
        {
            throw Error(strFmt("@SYS50104", "@ENG185"));
        }
        
        if (!InventTable::isBatchReceiptRequired(_jobBundleProdFeedback.ItemId))
        {
            return false;
        }

        InventTable inventTable = InventTable::find(_jobBundleProdFeedback.ItemId);
        if (!inventTable.BatchNumGroupId)
        {
            return true;
        }

        InventNumGroup inventBatchNumGroup = InventNumGroup::find(inventTable.BatchNumGroupId);
        return !inventBatchNumGroup.PhysicalUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventSerialRequired</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the serial number is enabled for <c>JmgTmpJobBundleProdFeedback</c>.
    /// </summary>
    /// <param name = "_jobBundleProdFeedback">
    ///     The <c>JmgTmpJobBundleProdFeedback</c> to make this check for.
    /// </param>
    /// <returns>
    ///     true if serial is enabled for job; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The check passes when item is serial number enabled,
    /// serial number group is not set for an item or
    /// physical update is set to No for the batch number group.
    /// </remarks>
    [Hookable(false)]
    internal boolean inventSerialRequired(JmgTmpJobBundleProdFeedback _jobBundleProdFeedback)
    {
        if (!this.doSerialBatchNumberControlCheck())
        {
            return false;
        }

        if (!_jobBundleProdFeedback.isForLastOperation())
        {
            return false;
        }

        if (!_jobBundleProdFeedback.ItemId)
        {
            throw Error(strFmt("@SYS50104", "@ENG185"));
        }
        
        if (!InventTable::isSerialReceiptRequired(_jobBundleProdFeedback.ItemId))
        {
            return false;
        }

        InventTable inventTable = InventTable::find(_jobBundleProdFeedback.ItemId);
        if (!inventTable.SerialNumGroupId)
        {
            return true;
        }

        InventNumGroup inventSerialNumGroup = InventNumGroup::find(inventTable.SerialNumGroupId);
        return !inventSerialNumGroup.PhysicalUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doSerialBatchNumberControlCheck</Name>
				<Source><![CDATA[
    private boolean doSerialBatchNumberControlCheck()
    {
        return (JmgRegistrationTouchReportProgressBatchSerialNumberEnableFeature::isEnabled() &&
                JmgReportProgressSerialBatchNumberControlContext::shouldSerialBatchNumberControlBeApplied() &&
                JmgReportProgressSerialBatchNumberControlFlight::instance().isEnabled());
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSerialNumberSpecification</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets or retrieves the <paramref name="_serialNumberSpecification" /> parameter.
    /// </summary>
    /// <param name = "_serialNumberSpecification"> 
    ///     List of <c>JmgTmpSerialNumberSpecification</c>; optional.
    /// </param>
    /// <returns>
    ///     The list of the <paramref name="_serialNumberSpecification" /> parameter.
    /// </returns>
    [Hookable(false)]
    internal JmgTmpSerialNumberSpecification parmSerialNumberSpecification(JmgTmpSerialNumberSpecification _serialNumberSpecification = serialNumberSpecification)
    {
        serialNumberSpecification = _serialNumberSpecification;
        return serialNumberSpecification;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCoByProductFeedback</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal JmgTmpJobBundleProdFeedback parmCoByProductFeedback(JmgTmpJobBundleProdFeedback _coByProductFeedback = coByProductFeedback)
    {
        coByProductFeedback = _coByProductFeedback;
        return coByProductFeedback;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>