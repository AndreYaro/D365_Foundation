<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWorkCreateReplenishment</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WhsWorkCreateReplenishment</c> class creates warehouse work for replenishment.
/// </summary>
public class WhsWorkCreateReplenishment extends WHSWorkCreate implements System.IDisposable 
{
    WHSWorkCreateId          	workCreateId;
    ItemId                   	itemId;
    InventQty                	replenQty;
    InventDim                	replenInventDim;
    WHSTmpWorkLine           	demandTmpWorkLine;
    private WHSDemandWaveId     demandWaveId;
    WHSTmpWorkLine           	immedDemandTmpWorkLine;
    WHSTmpLoadDemand         	tmpLoadDemand;
    WHSWaveLockManager       	whsWaveLockManager;
    UnitOfMeasureSymbol      	immedReplenUnit;
    WMSLocationId            	immedReplenPutLocation;
    InventLocationId         	immedReplenPutWarehosue;
    Qty                      	immedReplenQty;
    boolean                  	mustDisposeWhsLockManager = false;
    Qty                      	immedReplenUsedExistingReplen;
    boolean                  	onlyExistingImmedReplenUsed;
    private Map              	itemDimWorkCreatedQtyMap;
    private Map                 itemDimExistingReplenWorkLinkDemandQtyMap;
    private Map              	refRecReplenishmentTempLineMap;
    private Map              	itemDimReplenTempLineExtraQtyMap;
    private Map              	itemDimPutLocationPickedQtyMap;
    private Map                 itemDimReplenWorkMap;
    private boolean          	shouldIgnoreLocDirFailWork;
    private boolean          	isReplenishmentLocationDirectiveFailureInitialized;
    private WHSLocDirFailWork	replenishmentLocationDirectiveFailure;
    private boolean             immedReplenAllowAllUnits;
    private TmpUnitOfMeasureFilter immedReplenAllowedUnits;
    private Set                 immedReplenAllowedUnitSet;
    private UnitOfMeasureSymbol immedReplenAllowedUnit;
    private boolean             useImmedReplenAllowedUnit;

    public static const str     StepCheckExistingReplenWork      = "@WAX:WHSReplenishmentStepCheckExistingReplenWork";
    public static const str     StepFindReplenishmentPutLocation = "@WAX:WHSReplenishmentStepFindReplenishmentPutLocation";
    public static const str     StepCreateReplenishmentPickLines = "@WAX:WHSReplenishmentStepCreateReplenishmentPickLines";
    public static const str     StepCreateReplenishmentWorks     = "@WAX:WHSReplenishmentStepCreateReplenishmentWorks";
    // For demand replenishment, there are 4 sub method steps:
    // check existing open replenishment, find replenishment put location, find replenishment pick location, create replenishment.
    private static const int    TotalSubMethodSteps                       = 4; 

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>Dispose</Name>
				<Source><![CDATA[
    /// <summary>
    /// Disposes the object and releases all currently held locks.
    /// </summary>
    public void Dispose()
    {
        this.disposeWhsWaveLockManager();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ignoreLocationDirectiveFailureForWork</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected boolean ignoreLocationDirectiveFailureForWork()
    {
        return shouldIgnoreLocDirFailWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setIgnoreLocDirFailWork</Name>
				<Source><![CDATA[
    private void setIgnoreLocDirFailWork(WHSWorkCreateReplenishment _workCreate, RefTableId _refTableId)
    {
        if (_refTableId == tableNum(WHSReplenishmentTemplateLine))
        {
            WHSReplenishmentTemplateLine locReplenishmentTempLine = _workCreate.parmReplenishmentTemplateLine();

            if (locReplenishmentTempLine.ReplenishmentStrategy == WHSReplenishmentStrategy::WaveDemandMaximumLocationCapacity)
            {
                _workCreate.shouldIgnoreLocDirFailWork = true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReplenishmentPutLine</Name>
				<Source><![CDATA[
    private boolean isReplenishmentPutLine(WHSTmpWorkLine _workLine)
    {
        return  _workLine.WorkTransType    == WHSWorkTransType::Replenishment
            &&  _workLine.WorkType         == WHSWorkType::Put
            &&  _workLine.OriginType       == WHSOriginType::Wave;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldApplyReplenishmentStrategyMaximumLocationCapacity</Name>
				<Source><![CDATA[
    private boolean shouldApplyReplenishmentStrategyMaximumLocationCapacity(WHSWorkCreateAdjustQuantitiesForLocationParameters _parameters)
    {
        WHSInventQty    locInventQty    = _parameters.parmInventQty();
        WHSInventQty    maxPutInventQty = _parameters.parmLocationDirective().parmAvailQty();

        return this.isReplenishmentPutLine(_parameters.parmTmpWorkLine())
            && _parameters.parmWmsLocationId() != ''
            && _parameters.parmRunningQty() <= locInventQty + _parameters.parmLocationDirective().parmReplenAvailQty()
            && replenishmentTemplateLine.ReplenishmentStrategy == WHSReplenishmentStrategy::WaveDemandMaximumLocationCapacity
            && maxPutInventQty > locInventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logExtraQuantityForItemReplenTempLine</Name>
				<Source><![CDATA[
    private void logExtraQuantityForItemReplenTempLine(WHSWorkCreateAdjustQuantitiesForLocationParameters _parameters, Qty _extraQty)
    {
        ItemId      locItemId        = _parameters.parmTmpWorkLine().ItemId;
        InventDimId inventDimId      = _parameters.parmInventDim().inventDimId;
        RefRecId    replenTempLineId = _parameters.parmTmpWorkLine().RefRecId;

        container key   = [locItemId, inventDimId, replenTempLineId];

        if (_parameters.parmTmpWorkLine().WorkType == WHSWorkType::Put)
        {
            // we can overwrite the old value, as we only increase the quantity
            // for the last location needed.
            if (itemDimReplenTempLineExtraQtyMap)
            {
                itemDimReplenTempLineExtraQtyMap.insert(key, [_parameters.parmWmsLocationId(), _extraQty]);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRemainingExtraQtyForItemReplenTempLine</Name>
				<Source><![CDATA[
    private void updateRemainingExtraQtyForItemReplenTempLine(WHSTmpWorkLine _tmpWorkLine, InventDimId _inventDimId, Qty _extraQty)
    {
        ItemId   locItemId        = _tmpWorkLine.ItemId;
        RefRecId replenTempLineId = _tmpWorkLine.RefRecId;

        container key   = [locItemId, _inventDimId, replenTempLineId];
        
        if (itemDimReplenTempLineExtraQtyMap && itemDimReplenTempLineExtraQtyMap.exists(key))
        {
            WMSLocationId maximizedLocation;
            Qty           oldExtraQty;

            [maximizedLocation, oldExtraQty] = itemDimReplenTempLineExtraQtyMap.lookup(key);
            itemDimReplenTempLineExtraQtyMap.insert(key, [maximizedLocation, _extraQty]);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExtraQtyForItemReplenTempLine</Name>
				<Source><![CDATA[
    private Qty getExtraQtyForItemReplenTempLine(ItemId _itemId, InventDimId _inventDimId, RefRecId _replenTempLineId)
    {
        container key   = [_itemId, _inventDimId, _replenTempLineId];

        if (itemDimReplenTempLineExtraQtyMap && itemDimReplenTempLineExtraQtyMap.exists(key))
        {
            return conPeek(itemDimReplenTempLineExtraQtyMap.lookup(key), 2);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLocationIdWithExtraQtyForItemReplenTempLine</Name>
				<Source><![CDATA[
    private WMSLocationId getLocationIdWithExtraQtyForItemReplenTempLine(ItemId _itemId, InventDimId _inventDimId, RefRecId _replenTempLineId)
    {
        container key   = [_itemId, _inventDimId, _replenTempLineId];

        if (itemDimReplenTempLineExtraQtyMap && itemDimReplenTempLineExtraQtyMap.exists(key))
        {
            return conPeek(itemDimReplenTempLineExtraQtyMap.lookup(key), 1);
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>logPickQtyForPutLocation</Name>
				<Source><![CDATA[
    private void logPickQtyForPutLocation(WHSTmpWorkLine _tmpWorkLine, InventDimId _inventDimId, WMSLocationId _pickLocationId, WHSInventQty _inventQty)
    {
        ItemId                  locItemId           = _tmpWorkLine.ItemId;
        InventDimId             locInventDimId      = _inventDimId;
        WMSLocationId           locWmsLocationId    = _tmpWorkLine.ReplenLocationId;
        WMSLocationId           locPickLocationId   = _pickLocationId;
        RefRecId                locReplenTempLineId = _tmpWorkLine.RefRecId;
        WHSInventQty            locInventQty        = _inventQty;

        boolean hasPickLocation = (locPickLocationId != '');

        container key   = [locItemId, locInventDimId, locWmsLocationId, locReplenTempLineId, hasPickLocation];

        if (_tmpWorkLine.WorkType == WHSWorkType::Pick && itemDimPutLocationPickedQtyMap)
        {
            if (itemDimPutLocationPickedQtyMap.exists(key))
            {
                InventQty locPickQty = itemDimPutLocationPickedQtyMap.lookup(key) + locInventQty;
                itemDimPutLocationPickedQtyMap.insert(key, locPickQty);
            }
            else
            {
                itemDimPutLocationPickedQtyMap.insert(key, locInventQty);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPickQtyForPutLocationWithPickLocation</Name>
				<Source><![CDATA[
    private Qty getPickQtyForPutLocationWithPickLocation(ItemId _itemId, InventDimId _inventDimId, WMSLocationId _putLocationId, RefRecId _replenTempLineId)
    {
        container key   = [_itemId, _inventDimId, _putLocationId, _replenTempLineId, true];

        if (itemDimPutLocationPickedQtyMap && itemDimPutLocationPickedQtyMap.exists(key))
        {
            return itemDimPutLocationPickedQtyMap.lookup(key);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPickQtyForPutLocationWithoutPickLocation</Name>
				<Source><![CDATA[
    private Qty getPickQtyForPutLocationWithoutPickLocation(ItemId _itemId, InventDimId _inventDimId, WMSLocationId _putLocationId, RefRecId _replenTempLineId)
    {
        container key   = [_itemId, _inventDimId, _putLocationId, _replenTempLineId, false];

        if (itemDimPutLocationPickedQtyMap && itemDimPutLocationPickedQtyMap.exists(key))
        {
            return itemDimPutLocationPickedQtyMap.lookup(key);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPickQtyForPutLocationWithPickLocation</Name>
				<Source><![CDATA[
    private void clearPickQtyForPutLocationWithPickLocation(ItemId _itemId, InventDimId _inventDimId, WMSLocationId _putLocationId, RefRecId _replenTempLineId)
    {
        container key   = [_itemId, _inventDimId, _putLocationId, _replenTempLineId, true];
        
        if (itemDimPutLocationPickedQtyMap)
        {
            itemDimPutLocationPickedQtyMap.remove(key);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPickQtyForPutLocationWithoutPickLocation</Name>
				<Source><![CDATA[
    private void clearPickQtyForPutLocationWithoutPickLocation(ItemId _itemId, InventDimId _inventDimId, WMSLocationId _putLocationId, RefRecId _replenTempLineId)
    {
        container key   = [_itemId, _inventDimId, _putLocationId, _replenTempLineId, false];
        
        if (itemDimPutLocationPickedQtyMap)
        {
            itemDimPutLocationPickedQtyMap.remove(key);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExtraQtyFromParameters</Name>
				<Source><![CDATA[
    private Qty getExtraQtyFromParameters(WHSWorkCreateAdjustQuantitiesForLocationParameters _originalParameters, WHSWorkCreateAdjustQuantitiesForLocationParameters _reternParameters)
    {
        return _reternParameters.parmInventQty() - _originalParameters.parmInventQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPickQtyForLocation</Name>
				<Source><![CDATA[
    private Qty getPickQtyForLocation(WHSWorkCreateAdjustQuantitiesForLocationParameters _parameters)
    {
        if (_parameters.parmTmpWorkLine().WorkType == WHSWorkType::Pick 
            && !_parameters.parmWmsLocationId() 
            && (!this.isReplenishmentLocationDirectiveFailureEnabled() || shouldIgnoreLocDirFailWork))
        {
            return _parameters.parmRunningQty();
        }

        return _parameters.parmInventQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustPickPutQuantitiesForLocation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WHSWorkCreateAdjustQuantitiesForLocationParameters adjustPickPutQuantitiesForLocation(WHSWorkCreateAdjustQuantitiesForLocationParameters _parameters)
    {
        WHSWorkCreateAdjustQuantitiesForLocationParameters ret  = WHSWorkCreateAdjustQuantitiesForLocationParameters::newFromInstance(_parameters);

        Qty                     locQty;
        UnitOfMeasureSymbol     locUnitId;
        WHSInventQty            locInventQty;

        this.logPickQtyForPutLocation(_parameters.parmTmpWorkLine(),
                                    _parameters.parmInventDim().inventDimId,
                                    _parameters.parmWmsLocationId(),
                                    this.getPickQtyForLocation(_parameters));

        [locQty, locUnitId, locInventQty] = this.applyReplenishmentStrategy(_parameters);

        ret.parmQty(locQty);
        ret.parmUnitId(locUnitId);
        ret.parmInventQty(locInventQty);

        this.logExtraQuantityForItemReplenTempLine(_parameters, this.getExtraQtyFromParameters(_parameters, ret));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReplenishmentStrategyQuantityAdjustedLog</Name>
				<Source><![CDATA[
    private void createReplenishmentStrategyQuantityAdjustedLog(WHSWorkCreateAdjustQuantitiesForLocationParameters _parameters, Qty _qty)
    {
        if (_qty != _parameters.parmQty())
        {
            WHSMessage message = strFmt("@WAX:WorkCreationHistoryLogMessage_adjustingQuantityToMaxOfLocation",
                                                        _parameters.parmWmsLocationId(),
                                                        _parameters.parmTmpWorkLine().ItemId,
                                                        _parameters.parmInventDim().inventDimId,
                                                        _parameters.parmQty(),
                                                        _qty,
                                                        _parameters.parmUnitId());
                                
            WHSWorkCreateHistory::createWorkHistoryLine(_parameters.parmTmpWorkLine().WorkCreateId, message, false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyReplenishmentStrategy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Based on the replenishment strategy re-evaluates the quantity to replenish.
    /// </summary>
    /// <param name="_parameters">
    ///  An object with all the necessary parameters to calculate the adjusted quantities.
    ///  For more details on the different parameters, look at the WHSWorkCreateAdjustQuantitiesForLocationParameters.
    /// </param>
    /// <returns>
    /// A container with the updated replenishment quantities.
    /// </returns>
    private container applyReplenishmentStrategy(WHSWorkCreateAdjustQuantitiesForLocationParameters _parameters)
    {
        Qty                     locQty          = _parameters.parmQty();
        UnitOfMeasureSymbol     locUnitId       = _parameters.parmUnitId();
        WHSInventQty            locInventQty    = _parameters.parmInventQty();
        
        if (this.shouldApplyReplenishmentStrategyMaximumLocationCapacity(_parameters))
        {
            [locQty, locUnitId, locInventQty] = this.applyMaximumQuantityReplenishmentStrategy(_parameters);
        
            this.createReplenishmentStrategyQuantityAdjustedLog(_parameters, locQty);
        }

        return [locQty, locUnitId, locInventQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyMaximumQuantityReplenishmentStrategy</Name>
				<Source><![CDATA[
    private container applyMaximumQuantityReplenishmentStrategy(WHSWorkCreateAdjustQuantitiesForLocationParameters _parameters)
    {
        UnitOfMeasureSymbol     locUnitId       = _parameters.parmUnitId();
        WHSInventQty            maxPutInventQty = _parameters.parmLocationDirective().parmAvailQty();
        InventDimId             inventDimId     = _parameters.parmInventDim().inventDimId;

        UnitOfMeasureSymbol inventHandlingUnitId = WHSCatchWeightHelper::inventHandlingUnitId(tmpWorkLine.ItemId);

        Qty roundingQty = unitConverter.convertGivenUnitSymbols(maxPutInventQty,
                                                            inventHandlingUnitId,
                                                            replenUOM,
                                                            NoYes::No,
                                                            tmpWorkLine.ItemId,
                                                            inventDimId,
                                                            NoYes::No);

        WHSInventQty locInventQty;

        if (roundingQty < 1)
        {
            locInventQty = maxPutInventQty;
        }
        else
        {
            roundingQty = Global::roundDown(roundingQty, 1);

            locInventQty = unitConverter.convertGivenUnitSymbols(roundingQty,
                                               replenUOM,
                                               inventHandlingUnitId,
                                               NoYes::No,
                                               tmpWorkLine.ItemId,
                                               inventDimId,
                                               NoYes::No);
        }

        Qty locQty = unitConverter.convertGivenUnitSymbols(locInventQty,
                                                    inventHandlingUnitId,
                                                    locUnitId,
                                                    NoYes::No,
                                                    tmpWorkLine.ItemId,
                                                    inventDimId,
                                                    NoYes::No);

        // When using restrict by UOM we must keep values as whole numbers; otherwise round value based on locatedUOM decimal precision
        if (_parameters.parmLocationDirective().parmMatchingDirective().restrictByUOM)
        {
            locQty = trunc(locQty);
        }
        else
        {
            locQty = roundDownDec(locQty, UnitOfMeasure::findBySymbol(locUnitId).DecimalPrecision);
        }

        locInventQty = unitConverter.convertGivenUnitSymbols(locQty,
                                                        locUnitId,
                                                        inventHandlingUnitId,
                                                        NoYes::No,
                                                        tmpWorkLine.ItemId,
                                                        inventDimId,
                                                        NoYes::No);

        return [locQty, locUnitId, locInventQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPickedQuantities</Name>
				<Source><![CDATA[
    private container findPickedQuantities(WHSTmpWorkLine _replenPutTmpWorkLine)
    {
        boolean existsPickLineWithNoLocation;
        
        ItemId              locItemId           = _replenPutTmpWorkLine.ItemId;
        InventDimId         inventDimId         = _replenPutTmpWorkLine.InventDimId;
        WMSLocationId       replenLocationId    = _replenPutTmpWorkLine.wmsLocationId;
        RefRecId            locReplenTempLineId = _replenPutTmpWorkLine.RefRecId;

        Qty replenishedQtyInLocation = this.getPickQtyForPutLocationWithPickLocation(locItemId, inventDimId, replenLocationId, locReplenTempLineId);

        existsPickLineWithNoLocation = (replenishedQtyInLocation != _replenPutTmpWorkLine.InventQty);

        return [existsPickLineWithNoLocation, replenishedQtyInLocation];
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFailedReplenishmentPickTmpWorkLinesForPutLocation</Name>
				<Source><![CDATA[
    private void deleteFailedReplenishmentPickTmpWorkLinesForPutLocation(
        WHSWorkCreateId     _workCreateId,
        ItemId              _itemId,
        InventDimId         _inventDimId,
        WMSLocationId       _replenLocationId,
        RefTableId          _refTableId,
        RefRecId            _refRecId,
        RecId               _workHistoryLineRecIdWithTelemetryInformation)
    {
        WHSTmpWorkLine pickLine;

        using (var processWorkHeaderPerf = WHSInstrumentationReplenishmentStrategyPerformanceTask::newWaveDemandReplenishmentStrategyFailedPickLinesCleanup(_workHistoryLineRecIdWithTelemetryInformation))
        {
            this.clearPickQtyForPutLocationWithoutPickLocation(_itemId, _inventDimId, _replenLocationId, _refRecId);

            delete_from pickLine
                where pickLine.WorkCreateId     == _workCreateId
                &&   pickLine.WorkType          == WHSWorkType::Pick
                &&   pickLine.ItemId            == _itemId
                &&   pickLine.InventDimId       == _inventDimId
                &&   pickLine.ReplenLocationId  == _replenLocationId
                &&   pickLine.RefTableId        == _refTableId
                &&   pickLine.RefRecId          == _refRecId
                &&   pickLine.WMSLocationId     == '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAllReplenishmentPickTmpWorkLinesForPutLocation</Name>
				<Source><![CDATA[
    private void deleteAllReplenishmentPickTmpWorkLinesForPutLocation(
        WHSWorkCreateId     _workCreateId,
        ItemId              _itemId,
        InventDimId         _inventDimId,
        WMSLocationId       _replenLocationId,
        RefTableId          _refTableId,
        RefRecId            _refRecId,
        RecId               _workHistoryLineRecIdWithTelemetryInformation)
    {
        WHSTmpWorkLine pickLine;

        using (var processWorkHeaderPerf = WHSInstrumentationReplenishmentStrategyPerformanceTask::newWaveDemandReplenishmentStrategyAllPickLinesCleanup(_workHistoryLineRecIdWithTelemetryInformation))
        {
            this.clearPickQtyForPutLocationWithPickLocation(_itemId, _inventDimId, _replenLocationId, _refRecId);
            this.clearPickQtyForPutLocationWithoutPickLocation(_itemId, _inventDimId, _replenLocationId, _refRecId);

            delete_from pickLine
                where pickLine.WorkCreateId     == _workCreateId
                &&   pickLine.WorkType          == WHSWorkType::Pick
                &&   pickLine.ItemId            == _itemId
                &&   pickLine.InventDimId       == _inventDimId
                &&   pickLine.ReplenLocationId  == _replenLocationId
                &&   pickLine.RefTableId        == _refTableId
                &&   pickLine.RefRecId          == _refRecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkCreationHistoryLineForReplenishmentStrategyRecoveryAttempt</Name>
				<Source><![CDATA[
    private void createWorkCreationHistoryLineForReplenishmentStrategyRecoveryAttempt(
        WHSWorkCreateId     _workCreateId,
        WMSLocationId       _wmsLocationId,
        ItemId              _itemId,
        InventDimId         _inventDimId,
        InventQty           _newInventQty)
    {
        UnitOfMeasureSymbol inventHandlingUnitId = WHSCatchWeightHelper::inventHandlingUnitId(_itemId);

        WHSMessage message = strFmt("@WAX:WorkCreationHistoryLogMessage_replenishmentStrategyFailedForLocation",
                                                        _wmsLocationId,
                                                        _itemId,
                                                        _inventDimId,
                                                        _newInventQty,
                                                        inventHandlingUnitId);
                                
        WHSWorkCreateHistory::createWorkHistoryLine(_workCreateId, message, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkCreationHistoryLineForReplenishmentStrategyPickLineVerificationLog</Name>
				<Source><![CDATA[
    private RecId createWorkCreationHistoryLineForReplenishmentStrategyPickLineVerificationLog(
       WHSWorkId       _replenWorkId,
       WMSLocationId   _replenPutLocationId,
       ItemId          _itemId,
       InventDimId     _inventDimId,
       RecId           _replenishmentTemplateRecId)
    {
        WHSMessage message = strFmt("@WAX:WorkCreationHistoryLogMessage_replenishmentStrategyReplenishmentPickLineValidation",
                                                        _replenWorkId,
                                                        _replenPutLocationId,
                                                        _itemId,
                                                        _inventDimId,
                                                        _replenishmentTemplateRecId);
                                
        WHSWorkCreateHistory workCreateHistory = WHSWorkCreateHistory::createAndGetWorkHistoryLine(_replenWorkId, message, true);

        return workCreateHistory.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeFailedReplenishmentTmpPickLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the failed replenishment pick tmpWorkLines. It is used
    /// when we have used all the extra quantity already, so we can't
    /// retry, and the location directive failures is enabled for replenishment.
    /// It is also used when we can use the extra requested quantity, to not
    /// replenish the current location.
    /// </summary>
    /// <param name = "_workCreate">And instance of the <c>WHSWorkCreateReplenishment</c> class.</param>
    /// <param name = "_replenPutTmpWorkLine">The tmp replenishment put work line record.</param>
    /// <param name = "_workHistoryLineRecIdWithTelemetryInformation">The record Id of the work history line.</param>
    /// <param name = "_replenishedQtyInLocation">The quantity of the replenishment in location.</param>
    private void removeFailedReplenishmentTmpPickLines(
        WHSWorkCreateReplenishment  _workCreate,
        WHSTmpWorkLine              _replenPutTmpWorkLine,
        RecId                       _workHistoryLineRecIdWithTelemetryInformation,
        Qty                         _replenishedQtyInLocation)
    {
        ItemId              locItemId       = _replenPutTmpWorkLine.ItemId;
        InventDimId         inventDimId     = _replenPutTmpWorkLine.InventDimId;
        WMSLocationId       wmsLocationId   = _replenPutTmpWorkLine.wmsLocationId;
        RefTableId          refTableId      = _replenPutTmpWorkLine.RefTableId;
        RefRecId            refRecId        = _replenPutTmpWorkLine.RefRecId;

        this.deleteFailedReplenishmentPickTmpWorkLinesForPutLocation(_workCreate.parmWorkCreateId(),
                                                                locItemId, inventDimId,
                                                                wmsLocationId, refTableId,
                                                                refRecId, _workHistoryLineRecIdWithTelemetryInformation);

        _workCreate.parmWorkCreatedQty(_replenishedQtyInLocation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTmpWorkLineQty</Name>
				<Source><![CDATA[
    private void updateTmpWorkLineQty(WHSTmpWorkLine _tmpWorkLine, Qty _newQty)
    {
        _tmpWorkLine.InventQty    = _newQty;
        _tmpWorkLine.DirectiveQty = _newQty;

        [_tmpWorkLine.HighestQty, _tmpWorkLine.HighestUnitId] = WHSInventTable::getHighestUnitQtyByUOMSeqGroup(_tmpWorkLine.ItemId,
                                                                                    _tmpWorkLine.DirectiveQty,
                                                                                    _tmpWorkLine.DirectiveUOM,
                                                                                    _tmpWorkLine.InventDimId);
        _tmpWorkLine.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReplenishmentLocationDirectiveFailureEnabled</Name>
				<Source><![CDATA[
    private WHSLocDirFailWork isReplenishmentLocationDirectiveFailureEnabled()
    {
        if (!isReplenishmentLocationDirectiveFailureInitialized)
        {
            replenishmentLocationDirectiveFailure = WHSLocDirFailure::find(WHSWorkTransType::Replenishment).LocDirFailWork;
            isReplenishmentLocationDirectiveFailureInitialized = true;
        }
        
        return replenishmentLocationDirectiveFailure;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDemandLineForLocationBasedOnOtherDemandLine</Name>
				<Source><![CDATA[
    private WHSTmpWorkLine getDemandLineForLocationBasedOnOtherDemandLine(WHSTmpWorkLine _tmpWorkLine, WMSLocationId _locationToIncrease)
    {
        WHSTmpWorkLine demandLine;

        // Loop over demand lines for the decrease location.
        select forupdate demandLine
            where demandLine.ItemId          == _tmpWorkLine.ItemId
            &&    demandLine.InventDimId     == _tmpWorkLine.InventDimId
            &&    demandLine.WorkType        == WHSWorkType::Pick  
            &&    demandLine.WorkCreateId    == workCreateId
            &&    demandLine.wmsLocationId   == _locationToIncrease
            &&    demandLine.InventTransId   == _tmpWorkLine.InventTransId
            &&    demandLine.ReplenDemand    == NoYes::Yes;

        return demandLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustSalesTmpWorkLines</Name>
				<Source><![CDATA[
    private void adjustSalesTmpWorkLines(WHSTmpWorkLine _tmpWorkLine, WMSLocationId _locationToIncrease, Qty _deltaQty, RecId _workHistoryLineRecIdWithTelemetryInformation)
    {
        WHSTmpWorkLine demandLineToDecrease, demandLineToIncrease;
        
        ItemId         locItemId           = _tmpWorkLine.ItemId;
        InventDimId    inventDimId         = _tmpWorkLine.InventDimId;
        WMSLocationId  locationToDecrease  = _tmpWorkLine.WMSLocationId;

        Qty runningQty = _deltaQty;

        if (_locationToIncrease != locationToDecrease)
        {
            using (var processWorkHeaderPerf = WHSInstrumentationReplenishmentStrategyPerformanceTask::newWaveDemandReplenishmentStrategyAdjustSalesLines(_workHistoryLineRecIdWithTelemetryInformation))
            {
                // Loop over demand lines for the decrease location.
                while select forupdate demandLineToDecrease
                    where demandLineToDecrease.ItemId          == locItemId            &&
                          demandLineToDecrease.InventDimId     == inventDimId          &&
                          demandLineToDecrease.WorkType        == WHSWorkType::Pick    &&
                          demandLineToDecrease.WorkCreateId    == workCreateId         &&
                          demandLineToDecrease.wmsLocationId   == locationToDecrease   &&
                          demandLineToDecrease.ReplenDemand    == NoYes::Yes
                {
                    if (runningQty <= 0)
                    {
                        break;
                    }

                    // if a demandLine with wmsLocation = _locationToIncrease exits, then use the existing line
                    // to avoid multiple worklines for the same location.
                    demandLineToIncrease = this.getDemandLineForLocationBasedOnOtherDemandLine(demandLineToDecrease, _locationToIncrease);

                    if (demandLineToDecrease.InventQty <= runningQty)
                    {
                        runningQty   -= demandLineToDecrease.InventQty;

                        if (demandLineToIncrease.RecId)
                        {
                            this.updateTmpWorkLineQty(demandLineToIncrease, demandLineToIncrease.InventQty + demandLineToDecrease.InventQty);
                            demandLineToDecrease.delete();
                        }
                        else
                        {
                            demandLineToDecrease.WMSLocationId = _locationToIncrease;
                            this.updateTmpWorkLineQty(demandLineToDecrease, demandLineToDecrease.InventQty);
                        }
                    }
                    else
                    {
                        if (demandLineToIncrease.RecId)
                        {
                            this.updateTmpWorkLineQty(demandLineToIncrease, demandLineToIncrease.InventQty + runningQty);
                            this.updateTmpWorkLineQty(demandLineToDecrease, demandLineToDecrease.InventQty - runningQty);
                        }
                        else
                        {
                            InventDim       inventDim = InventDim::find(inventDimId);
                            WMSLocation     wmsLocation = WMSLocation::find(_locationToIncrease, inventDim.InventLocationId);

                            LineNum lineNum = demandLineToDecrease.LineNum + 0.00001;
                            this.splitDemandTmpWorkLine(demandLineToDecrease, runningQty, demandLineToDecrease.InventQty - runningQty, lineNum);
                        
                            // we can use now demandLineToDecrease for the new location
                            demandLineToDecrease.WMSLocationId = _locationToIncrease;
                            demandLineToDecrease.ZoneId        = wmsLocation.ZoneId;
                            demandLineToDecrease.sortCode      = wmsLocation.sortCode;
                            demandLineToDecrease.AvailPhysical = 0; // all the available physical quantity has already been consumed.
                            demandLineToDecrease.update();
                        }

                        runningQty = 0;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useExtraQtyToRecoverMaximumLocationCapacityReplenishmentStrategy</Name>
				<Source><![CDATA[
    private void useExtraQtyToRecoverMaximumLocationCapacityReplenishmentStrategy(
        WHSWorkCreateReplenishment      _workCreate,
        WHSTmpWorkLine                  _replenPutTmpWorkLine,
        Qty                             _replenishedQtyInLocation,
        RecId                           _workHistoryLineRecIdWithTelemetryInformation,
        Qty                             _extraQty)
    {
        ItemId          locItemId       = _replenPutTmpWorkLine.ItemId;
        InventDimId     inventDimId     = _replenPutTmpWorkLine.InventDimId;
        WMSLocationId   wmsLocationId   = _replenPutTmpWorkLine.wmsLocationId;
        RefTableId      refTableId      = _replenPutTmpWorkLine.RefTableId;
        RefRecId        refRecId        = _replenPutTmpWorkLine.RefRecId;
        Qty             extraQty        = _extraQty;

        Qty           failedPickedQty      = this.getPickQtyForPutLocationWithoutPickLocation(locItemId, inventDimId, wmsLocationId, refRecId);
        wmsLocationId locationWithExtraQty = this.getLocationIdWithExtraQtyForItemReplenTempLine(locItemId, inventDimId, refRecId);

        if (extraQty >= failedPickedQty)
        {
            WHSInstrumentationReplenishmentStrategyPerformanceTask::logReplenishmentStrategyPickLineFailureWithoutRetry(_workHistoryLineRecIdWithTelemetryInformation);

            this.updateRemainingExtraQtyForItemReplenTempLine(_replenPutTmpWorkLine, inventDimId, extraQty - failedPickedQty);

            this.adjustSalesTmpWorkLines(_replenPutTmpWorkLine, locationWithExtraQty, failedPickedQty, _workHistoryLineRecIdWithTelemetryInformation);

            this.createWorkCreationHistoryLineForReplenishmentStrategyRecoveryAttempt(_workCreate.parmWorkCreateId(),
                                                                        wmsLocationId,
                                                                        locItemId,
                                                                        inventDimId,
                                                                        _replenPutTmpWorkLine.InventQty - failedPickedQty);

            this.removeFailedReplenishmentTmpPickLines(_workCreate,
                                        _replenPutTmpWorkLine,
                                        _workHistoryLineRecIdWithTelemetryInformation,
                                        _replenishedQtyInLocation);
        }
        else
        {
            WHSInstrumentationReplenishmentStrategyPerformanceTask::logReplenishmentStrategyPickLineFailureWithRetry(_workHistoryLineRecIdWithTelemetryInformation);

            this.updateRemainingExtraQtyForItemReplenTempLine(_replenPutTmpWorkLine, inventDimId, 0);
                
            this.adjustSalesTmpWorkLines(_replenPutTmpWorkLine, locationWithExtraQty, extraQty, _workHistoryLineRecIdWithTelemetryInformation);

            // since we failed to replenish to the maximum capacity, we should update the requested demand in the put line.
            // if we don't update this quantity we might find out that the replenished quantity is less than the requested
            // quantity. Above we didn't update it because we want to remove any replenishment links for this put location.
            _replenPutTmpWorkLine.InventQty = _replenPutTmpWorkLine.InventQty - extraQty;
        
                
            this.createWorkCreationHistoryLineForReplenishmentStrategyRecoveryAttempt(_workCreate.parmWorkCreateId(),
                                                                        wmsLocationId,
                                                                        locItemId,
                                                                        inventDimId,
                                                                        _replenPutTmpWorkLine.InventQty);

            this.deleteAllReplenishmentPickTmpWorkLinesForPutLocation(_workCreate.parmWorkCreateId(),
                                                                locItemId, inventDimId,
                                                                wmsLocationId, refTableId,
                                                                refRecId, _workHistoryLineRecIdWithTelemetryInformation);

            // since we are going to reuse _workCreate we need to clear the fullyAllocatedLocationsMap.
            _workCreate.fullyAllocatedLocationsMap = new Map(Types::String, Types::Class);

            _workCreate.parmWorkCreatedQty(0);
            
            _workCreate.parmReplenQty(_replenPutTmpWorkLine.InventQty);
            _workCreate.createTempTable();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleMaximumLocationCapacityFailedPickTmpWorkLines</Name>
				<Source><![CDATA[
    private void handleMaximumLocationCapacityFailedPickTmpWorkLines(
        WHSWorkCreateReplenishment      _workCreate,
        WHSTmpWorkLine                  _replenPutTmpWorkLine,
        Qty                             _replenishedQtyInLocation,
        RecId                           _workHistoryLineRecIdWithTelemetryInformation)
    {
        // if there is extra quantity for this item, replenTempLine, then we might have failed because of it.
        // We have to retry to pick less quantity. If we remove the extra quantity we might be able to cover the demand
        // if there is no extra quantity we won't be able to recover
        Qty extraQty = this.getExtraQtyForItemReplenTempLine(_replenPutTmpWorkLine.ItemId,
                                                        _replenPutTmpWorkLine.InventDimId,
                                                        _replenPutTmpWorkLine.RefRecId);

        if (extraQty)
        {
            this.useExtraQtyToRecoverMaximumLocationCapacityReplenishmentStrategy(_workCreate, 
                                                                            _replenPutTmpWorkLine,
                                                                            _replenishedQtyInLocation,
                                                                            _workHistoryLineRecIdWithTelemetryInformation,
                                                                            extraQty);
        }
        else
        {
            WHSInstrumentationReplenishmentStrategyPerformanceTask::logReplenishmentStrategyPickLineFailureWithoutRetry(_workHistoryLineRecIdWithTelemetryInformation);

            if (this.isReplenishmentLocationDirectiveFailureEnabled())
            {
                this.removeFailedReplenishmentTmpPickLines(_workCreate,
                                                    _replenPutTmpWorkLine,
                                                    _workHistoryLineRecIdWithTelemetryInformation,
                                                    _replenishedQtyInLocation);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>rollbackReplenishmentStrategyMaximumLocationCapacityIfFailedPickLines</Name>
				<Source><![CDATA[
    private void rollbackReplenishmentStrategyMaximumLocationCapacityIfFailedPickLines(
        WHSWorkCreateReplenishment      _workCreate,
        WHSTmpWorkLine                  _replenPutTmpWorkLine)
    {
        boolean existsPickLineWithNoLocation;
        Qty     replenishedQtyInLocation;

        // Now that we have tried once to create the temp pick work lines,
        // we need to stop ignoring location directive failures. If we find
        // that we need to retry creating the temp pick work lines, after
        // adjusting the requested quantities, and still fail to do that,
        // we need to allow for failure if the location directive failures
        // have been setup. Regardless of whether creating the temp work lines
        // succedded or not, we have to set this to false since the replenishment
        // strategy for the next temp put work line might be different.
        _workCreate.shouldIgnoreLocDirFailWork = false;

        RecId workHistoryLineRecIdWithTelemetryInformation = this.createWorkCreationHistoryLineForReplenishmentStrategyPickLineVerificationLog(_workCreate.parmWorkCreateId(),
                                                                                                                                        _replenPutTmpWorkLine.WMSLocationId,
                                                                                                                                        _replenPutTmpWorkLine.ItemId,
                                                                                                                                        _replenPutTmpWorkLine.InventDimId,
                                                                                                                                        _replenPutTmpWorkLine.RefRecId);
        
        WHSInstrumentationReplenishmentStrategyPerformanceTask::logWaveDemandReplenishmentStrategyPickLinesValidation(workHistoryLineRecIdWithTelemetryInformation);
        
        [existsPickLineWithNoLocation, replenishedQtyInLocation] = this.findPickedQuantities(_replenPutTmpWorkLine);
        
        if (existsPickLineWithNoLocation)
        {
            this.handleMaximumLocationCapacityFailedPickTmpWorkLines(
                                                    _workCreate,
                                                    _replenPutTmpWorkLine,
                                                    replenishedQtyInLocation,
                                                    workHistoryLineRecIdWithTelemetryInformation);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>rollbackReplenishmentStrategyIfFailedPickLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Because of the replenishment strategies, it could be the case that some replenishment
    /// pick lines have failed. We need to detect that and try to recover. For example when
    /// the replenishment strategy is the maximum location capacity, we might not have enough inventory
    /// to replenish to the maximum capacity a specific location, but we might have enough 
    /// inventory to cover demand. This method will detect failed replenishment pick lines,
    /// and if necessary will retry to create them.
    /// </summary>
    /// <param name = "_workCreate">
    /// The work that created the pick lines.
    /// </param>
    /// <param name = "_replenPutTmpWorkLine">
    /// Contains the aggregate information about the put work in a particular location.
    /// </param>
    private void rollbackReplenishmentStrategyIfFailedPickLines(
        WHSWorkCreateReplenishment _workCreate,
        WHSTmpWorkLine             _replenPutTmpWorkLine)
    {
        if (_replenPutTmpWorkLine.RefTableId == tableNum(WHSReplenishmentTemplateLine))
        {
            WHSReplenishmentTemplateLine locReplenishmentTempLine = _workCreate.parmReplenishmentTemplateLine();

            if (locReplenishmentTempLine.ReplenishmentStrategy == WHSReplenishmentStrategy::WaveDemandMaximumLocationCapacity)
            {
                this.rollbackReplenishmentStrategyMaximumLocationCapacityIfFailedPickLines(_workCreate, _replenPutTmpWorkLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignLocToDemandLines</Name>
				<Source><![CDATA[
    public void assignLocToDemandLines(WMSLocationId _wmsLocationId, InventQty _replenQty, InventQty _availQty, ItemId _itemId, InventDimId _inventDimId, WHSWorkBuildId _workBuildid)
    {
        #WHSLineNumSplit

        WHSTmpWorkLine  demandLine;
        InventQty       runningQty;
        InventQty       runningAvailQty;
        LineNum         lineNum;
        InventDim       inventDim = InventDim::find(_inventDimId);
        WMSLocation     wmsLocation = WMSLocation::find(_wmsLocationId, inventDim.InventLocationId);

        runningQty = _replenQty + _availQty;
        runningAvailQty = _availQty;
        ttsbegin;

        while select forupdate demandLine
            where demandLine.ItemId      == _itemId              &&
              demandLine.InventDimId     == _inventDimId         &&
              demandLine.WorkType        == WHSWorkType::Pick    &&
              demandLine.WorkCreateId    == _workBuildid         &&
              demandLine.wmsLocationId   == ''                   &&
              demandLine.ReplenDemand    == NoYes::Yes
        {
            if (!runningQty)
            {
                break;
            }

            // Qty being replenished will satisfy the full demand of current tmpWorkLine.
            if (runningQty >= demandLine.InventQty)
            {
                demandLine.wmsLocationId    = _wmsLocationId;
                demandLine.ZoneId           = wmsLocation.ZoneId;
                demandLine.sortCode         = wmsLocation.sortCode;
                demandLine.AvailPhysical    = demandLine.InventQty > runningAvailQty ? runningAvailQty : demandLine.InventQty;
                runningAvailQty             -= demandLine.AvailPhysical;
                runningQty                  -= demandLine.InventQty;
                demandLine.update();
            }
            else
            {
                // Call into splitTmpWorkLine using runningQty as max and (tmpWorkLine.InventQty - runningQty) as remaining
                // to split the demand line. Use macro to get new line number.
                lineNum = demandLine.LineNum + #splitTmpWorkLine;
                using (var context = WHSWorkCreateReplenishmentSplitTmpWorkLineWorkBreakContext::newFromParameters(this.shouldWorkBreakBeSetForSplitDemandTmpWorkLine()))
                {
                    this.splitDemandTmpWorkLine(demandLine, runningQty, demandLine.InventQty - runningQty, lineNum);
                }
                demandLine.wmsLocationId = _wmsLocationId;
                demandLine.ZoneId        = wmsLocation.ZoneId;
                demandLine.sortCode      = wmsLocation.sortCode;
                demandLine.AvailPhysical = runningAvailQty;
                runningAvailQty          = 0;
                runningQty               = 0;
                demandLine.update();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldWorkBreakBeSetForSplitDemandTmpWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if the work break should be set on the temporary work line when splitting the demand temporary work line during replenishment work creation.
    /// </summary>
    /// <returns>
    /// true if the work break field should be set; otherwise, false.
    /// </returns>
    protected boolean shouldWorkBreakBeSetForSplitDemandTmpWorkLine()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpDemandTmpWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up any demand TempWorkLines that were not successfully replenished.
    /// </summary>
    private void cleanUpDemandTmpWorkLine()
    {
        WHSLoadLine     demandLoadLine;

        Map replenishmentInventQtyToConsumeMap = new Map(Types::Container, Types::Real);

        while select forupdate demandTmpWorkLine
            order by ItemId, InventDimId
            where demandTmpWorkLine.WorkCreateId    == workCreateId
            &&    demandTmpWorkLine.WorkType        == WHSWorkType::Pick
            &&    demandTmpWorkLine.WorkTransType   != WHSWorkTransType::Replenishment
            &&    demandTmpWorkLine.wmsLocationId   == ''
        {
            container mapKey = [demandTmpWorkLine.ItemId, demandTmpWorkLine.InventDimId, demandTmpWorkLine.WMSLocationId];

            if (this.mustStopWorkOnLocationDirectiveFailure(demandTmpWorkLine))
            {
                if (demandTmpWorkLine.ShipmentId)
                {
                    WHSWaveFailedShipment::findOrCreate(demandTmpWorkLine.WaveId, demandTmpWorkLine.ShipmentId);
                }

                demandTmpWorkLine.deleteDemandWorkLine();
            }
            // If there was work created quantity for the matching item/dimension and no location directive failures, 
            // then the full quantity should at least have been created with no location.
            else if (!itemDimWorkCreatedQtyMap.exists(mapKey)
                    || itemDimWorkCreatedQtyMap.lookup(mapKey) == 0)
            {
                // Extra guard: this condition should not be needed - do not see any scenario which needs it.
                if (!WHSReplenWorkLink::demandLineHasReplenishmentLink(demandTmpWorkLine.WorkId, demandTmpWorkLine.LineNum))
                {
                    demandTmpWorkLine.ReplenDemand = NoYes::No;
                    demandTmpWorkLine.update();
                }
            }
            else
            {
                // Contains quantity for which we have replenishment not yet used by some other demand.
                InventQty replenishmentInventQtyToConsume;

                if (replenishmentInventQtyToConsumeMap.exists(mapKey))
                {
                    replenishmentInventQtyToConsume = replenishmentInventQtyToConsumeMap.lookup(mapKey);
                }
                else
                {
                    InventQty totalDemandQtyPendingReplenishmentWithLoc = this.getTotalDemandQtyPendingReplenishmentForItemAndDim(demandTmpWorkLine.ItemId, demandTmpWorkLine.InventDimId);
                    InventQty totalReplenishmentQty = itemDimWorkCreatedQtyMap.lookup(mapKey); // we know that this key exists in a map by now.

                    replenishmentInventQtyToConsume = totalReplenishmentQty - totalDemandQtyPendingReplenishmentWithLoc;
                }

                // If there is absolutely no qty we can "consume" for current demand (to cover even partially)
                // mark demand as not pending replenishment.
                if (replenishmentInventQtyToConsume <= 0)
                {
                    // Extra guard: this condition should not be needed - do not see any scenario which needs it.
                    if (!WHSReplenWorkLink::demandLineHasReplenishmentLink(demandTmpWorkLine.WorkId, demandTmpWorkLine.LineNum))
                    {
                        demandTmpWorkLine.ReplenDemand = NoYes::No;
                        demandTmpWorkLine.update();
                    }
                }

                replenishmentInventQtyToConsume -= demandTmpWorkLine.InventQty;

                replenishmentInventQtyToConsumeMap.insert(mapKey, replenishmentInventQtyToConsume);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalDemandQtyPendingReplenishmentForItemAndDim</Name>
				<Source><![CDATA[
    private InventQty getTotalDemandQtyPendingReplenishmentForItemAndDim(ItemId _itemId, InventDimId _inventDimId)
    {
        WHSTmpWorkLine demandTmpWorkLineLocal;

        select firstonly sum(InventQty) from demandTmpWorkLineLocal
            where  demandTmpWorkLineLocal.WorkCreateId    == workCreateId
                && demandTmpWorkLineLocal.WorkType        == WHSWorkType::Pick
                && demandTmpWorkLineLocal.WorkTransType   != WHSWorkTransType::Replenishment
                && demandTmpWorkLineLocal.ReplenDemand    == NoYes::Yes
                && demandTmpWorkLineLocal.wmsLocationId   != ''
                && demandTmpWorkLineLocal.ItemId          == _itemId
                && demandTmpWorkLineLocal.InventDimId     == _inventDimId;

        return demandTmpWorkLineLocal.InventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpFailedReplen</Name>
				<Source><![CDATA[
    /// <summary>
    /// If replenishment didn't allocated and failed to create work then we need to go back and update the demandLines so they don't point to locations not being replenished.
    /// </summary>
    /// <param name="_wmsLocationId">
    /// The warehouse location ID.
    /// </param>
    /// <param name="_workCreatedQty">
    /// The work created quantity.
    /// </param>
    /// <param name="_itemId">
    /// The Item ID.
    /// </param>
    /// <param name="_inventDimId">
    /// The inventory dimension ID.
    /// </param>
    /// <param name="_workBuildid">
    /// The work build ID.
    /// </param>
    void cleanUpFailedReplen(
        WMSLocationId   _wmsLocationId,
        InventQty       _workCreatedQty,
        ItemId          _itemId,
        InventDimId     _inventDimId,
        WHSWorkBuildId  _workBuildid)
    {
        #WHSLineNumSplit

        WHSTmpWorkLine  demandLine;
        InventQty       runningQty = _workCreatedQty;

        ttsbegin;       

        // Loop over demand lines order, order by the avail amount so we reduce splitting.
        while select forupdate demandLine
            order by demandLine.AvailPhysical desc
            where demandLine.ItemId          == _itemId              &&
                  demandLine.InventDimId     == _inventDimId         &&
                  demandLine.WorkType        == WHSWorkType::Pick    &&
                  demandLine.WorkCreateId    == _workBuildid         &&
                  demandLine.wmsLocationId   == _wmsLocationId       &&
                  demandLine.ReplenDemand    == NoYes::Yes
        {
            InventQty demandLineAvailPhysical = demandLine.AvailPhysical;
            if (demandLineAvailPhysical < 0)
            {
                WHSPostEngine::createWaveExecutionHistoryLine(parmWaveId, waveExecutionId, 
                        strFmt("@WAX:NegativeDemandLineAvailPhysicalDetected", parmWaveId, _itemId, _inventDimId, _wmsLocationId, demandLineAvailPhysical),
                        true, null, workCreateId);            
                demandLineAvailPhysical = 0;
            }            

            InventQty unReservedQty = demandLine.InventQty - demandLineAvailPhysical;
            if (unReservedQty < 0)
            {
                WHSPostEngine::createWaveExecutionHistoryLine(parmWaveId, waveExecutionId,
                        strFmt("@WAX:NegativeUnreservedQuantityDetected", parmWaveId, _itemId, _inventDimId, _wmsLocationId, unReservedQty),
                        true, null, workCreateId);
                unReservedQty = 0;
            }

            // If the runningQty is greater than the unreserved qty then we don't need to split the work line.
            if (runningQty >= unReservedQty)
            {
                runningQty -= unReservedQty;
            }
            else // If replenishment partially allocated a demand amount then we need to split the demand line again so that some can be replenished.
            {
                // If there is no running Qty left then we blank out the location on the demand line.
                if (runningQty <= 0)
                {
                    demandLine.wmsLocationId = '';
                    demandLine.ReplenDemand = NoYes::No;
                    demandLine.update();
                }
                else
                {
                    // Call into splitTmpWorkLine using (runningQty + the avail qty on the demand line) as max and (unreservedQty - the runningQty) as remaining
                    // to split the demand line. Use macro to get new line number.
                    LineNum lineNum = demandLine.LineNum + #splitTmpWorkLine;
                    
                    const boolean ShouldWorkBreakBeSet = false;

                    using (var context = WHSWorkCreateReplenishmentSplitTmpWorkLineWorkBreakContext::newFromParameters(ShouldWorkBreakBeSet))
                    {
                        this.splitTmpWorkLineHandlingQty(demandLine, runningQty + demandLineAvailPhysical, unReservedQty - runningQty, lineNum);
                    }                 
                    
                    WHSTmpWorkLine newDemandLine = WHSTmpWorkLine::find(demandLine.WorkCreateId, lineNum, true);
                    newDemandLine.wmsLocationId = '';
                    newDemandLine.ReplenDemand = NoYes::No;
                    newDemandLine.update();
                    runningQty = 0;
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTheReplenishmentWorkCreationLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns  replenishment work creation label.
    /// </summary>
    /// <returns>The replenishment work creation label.</returns>
    private LabelId getTheReplenishmentWorkCreationLabel()
    {
        return immedDemandTmpWorkLine.ItemId ? "@WAX:WorkCreatedForImmediateReplenishment" : "@WAX4068";
    }

]]></Source>
			</Method>
			<Method>
				<Name>numReplenPutTmpWorkLineToFindPickLocations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns count of replenishment temporary put work lines which need find pick location.
    /// </summary>
    /// <returns>The count of replenishment temporary put work lines.</returns>
    private int numReplenPutTmpWorkLineToFindPickLocations()
    {
        WHSTmpWorkLine replenPutTmpWorkLine;
        int rows;

        while select replenPutTmpWorkLine
            group by ItemId, wmsLocationId, InventDimId, RefTableId, RefRecId
            where replenPutTmpWorkLine.WorkCreateId  == workCreateId 
               && replenPutTmpWorkLine.WorkType      == WHSWorkType::Put
               && replenPutTmpWorkLine.WorkTransType == WHSWorkTransType::Replenishment
        {
            rows ++;
        }

        return rows;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSubWaveMethodStatusHandler</Name>
				<Source><![CDATA[
    private WHSWaveMethodStatusHandler createSubWaveMethodStatusHandler(str _step, WHSWorkCreateReplenishment _workCreate = null)
    {
        WHSWaveMethodStatusHandler subWaveMethodStatusHandler;

        if (waveMethodStatusHandler && WHSParameters::find().WaveProgressLog)
        {
            int totalSteps;
            if (_step == StepCheckExistingReplenWork || _step == StepFindReplenishmentPutLocation)
            {
                totalSteps = this.numDemandTmpWorkLineToFindPutLocation();
            }
            else if (_step == StepCreateReplenishmentPickLines)
            {
                totalSteps = this.numReplenPutTmpWorkLineToFindPickLocations();
            }
            else if (_step == StepCreateReplenishmentWorks && _workCreate)
            {
                totalSteps = _workCreate.numTmpWorkLineToCreateWork();
            }

            if (totalSteps > 0)
            {
                subWaveMethodStatusHandler = WHSWaveMethodStatusHandler::newWaveMethodStatusHandler(parmWaveId,
                                                                                               _step,
                                                                                               totalSteps,
                                                                                               waveMethodStatusHandler.waveMethodStatusRecId());
                subWaveMethodStatusHandler.updateWaveStepProgressToStarted();
            }
            else if (_step != StepCheckExistingReplenWork)
            {
                waveMethodStatusHandler.addTotalSteps(-1);
            }
        }

        return subWaveMethodStatusHandler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWaveStepProgressToCompleted</Name>
				<Source><![CDATA[
    private void updateWaveStepProgressToCompleted(WHSWaveMethodStatusHandler _waveMethodStatusHandler)
    {
        if (_waveMethodStatusHandler)
        {
            _waveMethodStatusHandler.updateWaveStepProgressToCompleted();
            WHSWaveMethodStatusHandler::makeOneStepForward(waveMethodStatusHandler, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDemandReplenishmentPickLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the replenishment tmpWorkLines for picks.
    /// </summary>
    /// <param name="_workCreate">
    /// A <c>WHSWorkCreateReplenishment</c> class instance.
    /// </param>
    /// <param name="_waveTable">
    /// The wave table for the replenishment wave.
    /// </param>
    /// <returns>
    /// True if work is being created; otherwise, false.
    /// </returns>
    private boolean createDemandReplenishmentPickLines(
        WHSWorkCreateReplenishment _workCreate,
        WHSWaveTable               _waveTable)
    {
        boolean createWork;
        List    replenPutTmpWorkLinesList = new List(Types::Record);

        refRecReplenishmentTempLineMap = new Map(Types::Int64, Types::Record);
        itemDimPutLocationPickedQtyMap = new Map(Types::Container, Types::Real);

        _workCreate.parmItemDimPutLocationPickedQtyMap(itemDimPutLocationPickedQtyMap);
        
        using (var activityContext = this.instrumentationLogger().replenishmentActivities().createDemandReplenishmentPickLines())
        {
            int replenPutTmpWorkLineEvaluated;

            WHSWaveMethodStatusHandler subWaveMethodStatusHandler = this.createSubWaveMethodStatusHandler(StepCreateReplenishmentPickLines);

            using (var waveLockManager = whsWaveLockManager::newStandard())
            {
                // Combine replenishment Put TmpWorkLines that are for the same location and inventDimId.
                // Now we know item, demand Qty, and put location: Create replenishment pick work lines (createTempTable).

                boolean shouldValidateReplenItemId = _workCreate.immedDemandTmpWorkLine.ItemId != '';

                InventQty totalReqReplenishment;
                Qty       pickWorkCreatedQty;

                boolean shouldValidateReplenInventDimId = _workCreate.immedDemandTmpWorkLine.InventDimId != '';

                WHSTmpWorkLine replenPutTmpWorkLine;
                SysDaQueryObject query = this.buildQueryGetGroupedGeneratedReplenishmentPutLines(replenPutTmpWorkLine,
                                                                                            workCreateId, 
                                                                                            _workCreate.immedDemandTmpWorkLine.ItemId,
                                                                                            _workCreate.immedDemandTmpWorkLine.InventDimId,
                                                                                            shouldValidateReplenItemId,
                                                                                            shouldValidateReplenInventDimId);
                SysDaSearchObject searchObject = new SysDaSearchObject(query);
                SysDaSearchStatement searchStatement = new SysDaSearchStatement();

                while(searchStatement.findNext(searchObject))
                {
                    replenPutTmpWorkLinesList.addEnd(replenPutTmpWorkLine);
                }

                WHSTmpWorkLine replenPutTmpWorkLineNoGrouping;

                SysDaQueryObject queryNoGrouping = this.buildQueryGetExceedCapacityEnabledReplenPutLines(replenPutTmpWorkLineNoGrouping,
                                                                                                    _workCreate.immedDemandTmpWorkLine.ItemId,
                                                                                                    _workCreate.immedDemandTmpWorkLine.InventDimId,
                                                                                                    shouldValidateReplenItemId,
                                                                                                    shouldValidateReplenInventDimId);
                SysDaSearchObject searchObjectNoGrouping = new SysDaSearchObject(queryNoGrouping);
                SysDaSearchStatement searchStatementNoGrouping = new SysDaSearchStatement();

                while(searchStatementNoGrouping.findNext(searchObjectNoGrouping))
                {
                    replenPutTmpWorkLinesList.addEnd(replenPutTmpWorkLineNoGrouping);
                }             

                ListEnumerator enumerator = replenPutTmpWorkLinesList.getEnumerator();
               
                while(enumerator.moveNext())
                {
                    ++replenPutTmpWorkLineEvaluated;

                    replenPutTmpWorkLine = enumerator.current();

                    InventDim replenDim = InventDim::find(replenPutTmpWorkLine.InventDimId);
                    replenDim.wmsLocationId = replenPutTmpWorkLine.wmsLocationId;
                    replenDim = InventDim::findOrCreate(replenDim);

                    _workCreate.parmReplenQty(replenPutTmpWorkLine.InventQty);
                    _workCreate.parmReplenItemId(replenPutTmpWorkLine.ItemId);
                    _workCreate.parmReplenInventDim(InventDim::find(replenDim.InventDimId));
                    _workCreate.parmDemandWaveId(_waveTable.DemandWaveId);
                
                    if (replenPutTmpWorkLine.RefTableId == tableNum(WHSReplenishmentTemplateLine))
                    {
                        if (refRecReplenishmentTempLineMap.exists(replenPutTmpWorkLine.RefRecId))
                        {
                            _workCreate.parmReplenishmentTemplateLine(refRecReplenishmentTempLineMap.lookup(replenPutTmpWorkLine.RefRecId));
                        }
                        else
                        {
                            _workCreate.parmReplenishmentTemplateLine(WHSReplenishmentTemplateLine::findByRecId(replenPutTmpWorkLine.RefRecId));
                            refRecReplenishmentTempLineMap.insert(replenPutTmpWorkLine.RefRecId, _workCreate.parmReplenishmentTemplateLine());
                        }
                    }

                    boolean isLockRequired = !immedDemandTmpWorkLine.ItemId;

                    if (isLockRequired)
                    {
                        boolean lockSuccess = waveLockManager.tryLockForItemDemandWaveAllocation(replenPutTmpWorkLine.ItemId,
                                                                                             replenPutTmpWorkLine.InventDimId,
                                                                                             _waveTable.WaveId,
                                                                                             whsParameters.WaveLockWait);
                        if (!lockSuccess)
                        {
                            this.instrumentationLogger().replenishmentActivities().logEvaluatedReplenPutTmpWorkLines(replenPutTmpWorkLineEvaluated);
                            throw error(strFmt("@WAX:WaveAllocationLockFailureError", replenPutTmpWorkLine.ItemId, replenPutTmpWorkLine.InventDimId, InventDim::find(replenPutTmpWorkLine.InventDimId).preFix(), whsParameters.WaveLockWait));
                        }
                    }
                
                    this.setIgnoreLocDirFailWork(_workCreate, replenPutTmpWorkLine.RefTableId);

                    // Create tmp table (pick replenishment lines).
                    _workCreate.createTempTable();

                    // because of the replenishment strategy, some of the location directives could have failed,
                    // in which case we have to rollback.
                    this.rollbackReplenishmentStrategyIfFailedPickLines(_workCreate, replenPutTmpWorkLine);

                    pickWorkCreatedQty = _workCreate.parmWorkCreatedQty();

                    totalReqReplenishment += replenPutTmpWorkLine.InventQty;

                    if (pickWorkCreatedQty > 0)
                    {
                        createWork = true;
                        str creationLabel = this.getTheReplenishmentWorkCreationLabel();
                        WHSWorkCreateHistory::createWorkHistoryLineFromTmpWorkLine(workCreateId,
                                                strFmt(creationLabel, replenPutTmpWorkLine.ItemId),
                                                false,
                                                replenPutTmpWorkLine);
                    }
                    else
                    {
                        WHSWorkCreateHistory::createWorkHistoryLineFromTmpWorkLine(workCreateId,
                                                strFmt("@WAX4090", replenPutTmpWorkLine.ItemId),
                                                true,
                                                replenPutTmpWorkLine);
                    }

                    if (pickWorkCreatedQty < replenPutTmpWorkLine.InventQty)
                    {
                        if (!immedDemandTmpWorkLine.ItemId)
                        {
                            this.cleanUpFailedReplen(replenDim.wmsLocationId,
                                                pickWorkCreatedQty,
                                                replenPutTmpWorkLine.ItemId,
                                                replenPutTmpWorkLine.InventDimId,
                                                workCreateId);
                        }
                        
                        this.parmImmediateReplenAvailQty(this.parmImmediateReplenAvailQty() - replenPutTmpWorkLine.InventQty + pickWorkCreatedQty);
                    }

                    if (isLockRequired)
                    {
                        waveLockManager.releaseForItemDemandWaveAllocation(replenPutTmpWorkLine.ItemId, replenPutTmpWorkLine.InventDimId);
                    }

                    WHSWaveMethodStatusHandler::makeOneStepForward(subWaveMethodStatusHandler);
                }

                if (pickWorkCreatedQty < totalReqReplenishment
                    && immedDemandTmpWorkLine.InventQty > pickWorkCreatedQty
                    && immedDemandTmpWorkLine.ItemId)
                {
                    this.assignImmedDemandLineQty(pickWorkCreatedQty);
                }

                this.instrumentationLogger().replenishmentActivities().logEvaluatedReplenPutTmpWorkLines(replenPutTmpWorkLineEvaluated);
            }

            this.updateWaveStepProgressToCompleted(subWaveMethodStatusHandler);
        }

        return createWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryGetGroupedGeneratedReplenishmentPutLines</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildQueryGetGroupedGeneratedReplenishmentPutLines(
        WHSTmpWorkLine _replenishmentPutTmpWorkLine,
        WHSWorkCreateId _workCreateId,
        ItemId _workCreateItemId,
        InventDimId _workCreateInventDimId,
        boolean _shouldValidateReplenItemId,
        boolean _shouldValidateReplenItemInventDimId)
    {
        SysDaQueryObject queryObj = new SysDaQueryObject(_replenishmentPutTmpWorkLine);
        queryObj.projection().addSum(fieldStr(WHSTmpWorkLine, InventQty));
        queryObj.projection().add(fieldStr(WHSTmpWorkLine, ItemId));
        queryObj.projection().add(fieldStr(WHSTmpWorkLine, WMSLocationId));
        queryObj.projection().add(fieldStr(WHSTmpWorkLine, InventDimId));
        queryObj.projection().add(fieldStr(WHSTmpWorkLine, RefTableId));
        queryObj.projection().add(fieldStr(WHSTmpWorkLine, RefRecId));
        queryObj.groupByClause()
                .add(fieldStr(WHSTmpWorkLine, ItemId))
                .add(fieldStr(WHSTmpWorkLine, WMSLocationId))
                .add(fieldStr(WHSTmpWorkLine, InventDimId))
                .add(fieldStr(WHSTmpWorkLine, RefTableId))
                .add(fieldStr(WHSTmpWorkLine, RefRecId));

       
        SysDaQueryExpression replenPutTmpWorkLineClause = 
            new SysDaEqualsExpression(
                new SysDaFieldExpression(_replenishmentPutTmpWorkLine, fieldStr(WHSTmpWorkLine, workCreateId)),
                new SysDaValueExpression(workCreateId)
            )
            .and(
                new SysDaEqualsExpression(
                    new SysDaFieldExpression(_replenishmentPutTmpWorkLine, fieldStr(WHSTmpWorkLine, WorkType)),
                    new SysDaValueExpression(WHSWorkType::Put))
            )
            .and(
                new SysDaEqualsExpression(
                    new SysDaFieldExpression(_replenishmentPutTmpWorkLine, fieldStr(WHSTmpWorkLine, workTransType)),
                    new SysDaValueExpression(WHSWorkTransType::Replenishment))
            )
            .and(
                new SysDaEqualsExpression(
                    new SysDaValueExpression(_shouldValidateReplenItemId),
                    new SysDaValueExpression(false))
                .or(
                new SysDaEqualsExpression(
                        new SysDaFieldExpression(_replenishmentPutTmpWorkLine, fieldStr(WHSTmpWorkLine, ItemId)),
                        new SysDaValueExpression(_workCreateItemId))
                )
            )
            .and(
                new SysDaEqualsExpression(
                    new SysDaValueExpression(_shouldValidateReplenItemInventDimId),
                    new SysDaValueExpression(false))
                .or(
                new SysDaEqualsExpression(
                        new SysDaFieldExpression(_replenishmentPutTmpWorkLine, fieldStr(WHSTmpWorkLine, InventDimId)),
                        new SysDaValueExpression(_workCreateInventDimId))
                )
            );
        
        WMSLocation         location;
        WHSLocationProfile  locationProfile;
            
        SysDaQueryObject locationQueryObj = new SysDaQueryObject(location);
        SysDaQueryObject locationProfileQueryObj = new SysDaQueryObject(locationProfile);

        SysDaQueryExpression locationClause = new SysDaEqualsExpression(
            new SysDaFieldExpression(location, fieldStr(WMSLocation, WMSLocationId)),
            new SysDaFieldExpression(_replenishmentPutTmpWorkLine, fieldStr(WHSTmpWorkLine, WMSLocationId))
        )
        .and(
            new SysDaEqualsExpression(
                new SysDaFieldExpression(location, fieldStr(WMSLocation, InventLocationId)),
                new SysDaFieldExpression(_replenishmentPutTmpWorkLine, fieldStr(WHSTmpWorkLine, InventLocationId))
        ));

        SysDaQueryExpression locationProfileClause = new SysDaEqualsExpression(
            new SysDaFieldExpression(locationProfile, fieldStr(WHSLocationProfile, LocProfileId)),
            new SysDaFieldExpression(location, fieldStr(WMSLocation, LocProfileId))
        )
        .and(
            new SysDaEqualsExpression(
                new SysDaFieldExpression(locationProfile, fieldStr(WHSLocationProfile, ReplenishmentExceedLocationCapacity)),
                new SysDaValueExpression(true))
        );
            
        locationQueryObj.whereClause(locationClause);
        locationProfileQueryObj.whereClause(locationProfileClause);
            
        locationQueryObj.joinClause(SysDaJoinKind::ExistsJoin, locationProfileQueryObj);
        queryObj.joinClause(SysDaJoinKind::NotExistsJoin, locationQueryObj);        

        queryObj.whereClause(replenPutTmpWorkLineClause);

        return queryObj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryGetExceedCapacityEnabledReplenPutLines</Name>
				<Source><![CDATA[
    private SysDaQueryObject buildQueryGetExceedCapacityEnabledReplenPutLines(
        WHSTmpWorkLine _replenishmentPutTmpWorkLine,
        ItemId _workCreateItemId,
        InventDimId _workCreateInventDimId,
        boolean _shouldValidateReplenItemId,
        boolean _shouldValidateReplenItemInventDimId)
    {
        SysDaQueryObject queryObj = new SysDaQueryObject(_replenishmentPutTmpWorkLine);
        queryObj.projection().add(fieldStr(WHSTmpWorkLine, InventQty));
        queryObj.projection().add(fieldStr(WHSTmpWorkLine, ItemId));
        queryObj.projection().add(fieldStr(WHSTmpWorkLine, WMSLocationId));
        queryObj.projection().add(fieldStr(WHSTmpWorkLine, InventDimId));
        queryObj.projection().add(fieldStr(WHSTmpWorkLine, RefTableId));
        queryObj.projection().add(fieldStr(WHSTmpWorkLine, RefRecId));

       
        SysDaQueryExpression replenPutTmpWorkLineClause =
            new SysDaEqualsExpression(
                new SysDaFieldExpression(_replenishmentPutTmpWorkLine, fieldStr(WHSTmpWorkLine, workCreateId)),
                new SysDaValueExpression(workCreateId)
            )
            .and(
                new SysDaEqualsExpression(
                    new SysDaFieldExpression(_replenishmentPutTmpWorkLine, fieldStr(WHSTmpWorkLine, WorkType)),
                    new SysDaValueExpression(WHSWorkType::Put))
            )
            .and(
                new SysDaEqualsExpression(
                    new SysDaFieldExpression(_replenishmentPutTmpWorkLine, fieldStr(WHSTmpWorkLine, workTransType)),
                    new SysDaValueExpression(WHSWorkTransType::Replenishment))
            )
            .and(
                new SysDaEqualsExpression(
                    new SysDaValueExpression(_shouldValidateReplenItemId),
                    new SysDaValueExpression(false))
                .or(
                new SysDaEqualsExpression(
                        new SysDaFieldExpression(_replenishmentPutTmpWorkLine, fieldStr(WHSTmpWorkLine, ItemId)),
                        new SysDaValueExpression(_workCreateItemId))
                )
            )
            .and(
                new SysDaEqualsExpression(
                    new SysDaValueExpression(_shouldValidateReplenItemInventDimId),
                    new SysDaValueExpression(false))
                .or(
                new SysDaEqualsExpression(
                        new SysDaFieldExpression(_replenishmentPutTmpWorkLine, fieldStr(WHSTmpWorkLine, InventDimId)),
                        new SysDaValueExpression(_workCreateInventDimId))
                )
            );

        queryObj.whereClause(replenPutTmpWorkLineClause);

        WMSLocation         location;
        WHSLocationProfile  locationProfile;
            
        SysDaQueryObject locationQueryObj = new SysDaQueryObject(location);
        SysDaQueryObject locationProfileQueryObj = new SysDaQueryObject(locationProfile);

        SysDaQueryExpression locationClause = new SysDaEqualsExpression(
                new SysDaFieldExpression(location, fieldStr(WMSLocation, WMSLocationId)),
                new SysDaFieldExpression(_replenishmentPutTmpWorkLine, fieldStr(WHSTmpWorkLine, WMSLocationId))
            )
            .and(
                new SysDaEqualsExpression(
                    new SysDaFieldExpression(location, fieldStr(WMSLocation, InventLocationId)),
                    new SysDaFieldExpression(_replenishmentPutTmpWorkLine, fieldStr(WHSTmpWorkLine, InventLocationId))
            ));

        SysDaQueryExpression locationProfileClause = new SysDaEqualsExpression(
                new SysDaFieldExpression(locationProfile, fieldStr(WHSLocationProfile, LocProfileId)),
                new SysDaFieldExpression(location, fieldStr(WMSLocation, LocProfileId))
            )
            .and(
                new SysDaEqualsExpression(
                    new SysDaFieldExpression(locationProfile, fieldStr(WHSLocationProfile, ReplenishmentExceedLocationCapacity)),
                    new SysDaValueExpression(true))
            );
            
        locationQueryObj.whereClause(locationClause);
        locationProfileQueryObj.whereClause(locationProfileClause);
            
        locationQueryObj.joinClause(SysDaJoinKind::ExistsJoin, locationProfileQueryObj);
        queryObj.joinClause(SysDaJoinKind::ExistsJoin, locationQueryObj);

        return queryObj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignImmedDemandLineQty</Name>
				<Source><![CDATA[
    private void assignImmedDemandLineQty(InventQty _workCreatedQty)
    {
        immedDemandTmpWorkLine.InventQty    = _workCreatedQty;
        immedDemandTmpWorkLine.DirectiveQty = EcoResReleasedProductUnitConverter::construct().convertGivenUnitSymbols(_workCreatedQty,
                                                            WHSCatchWeightHelper::inventHandlingUnitId(immedDemandTmpWorkLine.ItemId),
                                                            immedDemandTmpWorkLine.DirectiveUOM,
                                                            NoYes::No,
                                                            immedDemandTmpWorkLine.ItemId, 
                                                            immedDemandTmpWorkLine.InventDimId,
                                                            NoYes::Yes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReplenishmentWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a wave table record for the replenishment wave.
    /// </summary>
    /// <returns>
    /// A <c>WHSWaveTable</c> record.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected WHSWaveTable createReplenishmentWave()
    {
        WHSWaveTable demandWaveTable = WHSWaveTable::find(parmWaveId);

        WHSWaveTable waveTable;
        this.initReplenishmentWave(waveTable, demandWaveTable);
        waveTable.insert();

        // Log: Replenishment Wave Created
        WHSPostEngine::createWaveExecutionHistoryLine(parmWaveId,
                                                        waveExecutionId,
                                                        strFmt("@WAX4031", waveTable.WaveId),
                                                        true,
                                                        null,
                                                        workCreateId);
        info(strFmt("@WAX4031", waveTable.WaveId));

        return waveTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initReplenishmentWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes new replenishment wave.
    /// </summary>
    /// <param name = "_waveTable">Instance of <c>WHSWaveTable</c> to initialize.</param>
    /// <param name = "_demandWaveTable">Instance of <c>WHSWaveTable</c> to initialize from.</param>
    protected void initReplenishmentWave(WHSWaveTable _waveTable, WHSWaveTable _demandWaveTable)
    {
        _waveTable.WaveId = NumberSeq::newGetNum(WHSParameters::numRefWHSWaveId()).num();
        _waveTable.WaveTemplateName = _demandWaveTable.WaveTemplateName;
        _waveTable.DemandWaveId = parmWaveId;
        _waveTable.Description = strFmt("@WAX:ReplenishmentWaveDescription", _demandWaveTable.Description);
        _waveTable.WaveStatus = WHSWaveStatus::Executing;
        _waveTable.ExecutingUTCDateTime = DateTimeUtil::utcNow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReplenishmentWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finalizes the creation of replenishment work.
    /// </summary>
    /// <param name="_workCreate">
    /// An instance of the <c>WHSWorkCreateReplenishment</c> class to be used.
    /// </param>
    /// <param name="_waveTable">
    /// The replenishment wave.
    /// </param>
    /// <param name="_createWork">
    /// A Boolean value that determines if we must crate work or not.
    /// </param>
    private void createReplenishmentWork(
        WHSWorkCreateReplenishment  _workCreate,
        WHSWaveTable                _waveTable,
        boolean                     _createWork)
    {
        WHSWaveTable    replenWaveTable = _waveTable;

        // Process tmpTable for replenishment.
        if (_workCreate != null)
        {
            WHSWaveMethodStatusHandler subWaveMethodStatusHandler = this.createSubWaveMethodStatusHandler(StepCreateReplenishmentWorks, _workCreate);
            _workCreate.parmWaveMethodStatusHandler(subWaveMethodStatusHandler);

            _workCreate.processTempTable();
            _workCreate.cleanupTempTable();

            _workCreate.blockReplenishmentOverflowWorkExceedingCapacity();

            if (_createWork)
            {
                boolean autoRelease = WHSWaveTemplateTable::find(replenWaveTable.WaveTemplateName).AutoReleaseReplenWork;

                WhsPostEngine::setWaveStatusAfterProcessing(replenWaveTable, replenWaveTable.numWorkCreated(), autoRelease);
                replenWaveTable.update();

                if (!autoRelease
                ||  immedDemandTmpWorkLine.ItemId)
                {
                    WHSWorkTable::setFrozenForBlockingReasonTypeByWorkBuildId(replenWaveTable.WorkBuildId, WHSWorkBlockingReasonType::HeldWave);
                }
            }
            else
            {
                replenWaveTable.delete();
            }

            this.updateWaveStepProgressToCompleted(subWaveMethodStatusHandler);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTempTable</Name>
				<Source><![CDATA[
    void createTempTable()
    {
        InventDim   inventDim;

        inventDim = InventDim::find(replenInventDim.InventDimId);
        inventDim.wmsLocationId = '';
        inventDim = InventDim::findOrCreate(inventDim);

        tmpWorkLine.WorkType                     = WHSWorkType::Pick;
        tmpWorkLine.OriginType                   = parmWaveId ? WHSOriginType::Wave : WHSOriginType::Replenishment;
        tmpWorkLine.OriginRefId                  = parmWaveId ? parmWaveId : replenishmentTemplateLine.ReplenishTemplateId;
        tmpWorkLine.WorkCreateId                 = workCreateId;
        tmpWorkLine.WorkTransType                = WHSWorkTransType::Replenishment;
        tmpWorkLine.RefTableId                   = tableNum(WHSReplenishmentTemplateLine);
        tmpWorkLine.RefRecId                     = replenishmentTemplateLine.RecId;
        tmpWorkLine.RequestedTypeId              = replenishmentTemplateLine.ReplenishTemplateId;
        tmpWorkLine.StartLocationId              = startLocationId;
        tmpWorkLine.ItemId                       = itemId;
        tmpWorkLine.InventDimId                  = inventDim.InventDimId;
        tmpWorkLine.ReplenLocationId             = replenInventDim.wmsLocationId;
        tmpWorkLine.InventTransId                = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num();
        tmpWorkLine.WaveId                       = parmWaveId;
        tmpWorkLine.DemandWaveId                 = demandWaveId;
        tmpWorkLine.ImmediateReplenishmentUnitId = immedReplenUnit;
        this.initFromReplenishmentTemplate();

        this.setGlobals();

        this.addWorkTemplateCodeToSet(replenishmentTemplateLine.WorkTemplateCode);
        
        this.createTempLine(tmpWorkLine, replenQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTempTablePut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates temporary work line for put work.
    /// </summary>
    public void createTempTablePut()
    {
        tmpWorkLine.WorkType            = WHSWorkType::Put;
        if (parmWaveId)
        {
            tmpWorkLine.OriginType      = WHSOriginType::Wave;
            tmpWorkLine.OriginRefId     = parmWaveId;
        }
        else
        {
            tmpWorkLine.OriginType      = WHSOriginType::Replenishment;
            tmpWorkLine.OriginRefId     = replenishmentTemplateLine.ReplenishTemplateId;
        }
        // For Replenishment Put lines, parmWaveId is the demand wave, as replenishment wave has not been created yet, so both are set to the same value
        tmpWorkLine.WaveId              = parmWaveId;
        tmpWorkLine.DemandWaveId        = parmWaveId;
        tmpWorkLine.WorkCreateId        = workCreateId;
        tmpWorkLine.WorkTransType       = WHSWorkTransType::Replenishment;
        tmpWorkLine.RefTableId          = tableNum(WHSReplenishmentTemplateLine);
        tmpWorkLine.RefRecId            = replenishmentTemplateLine.RecId;
        tmpWorkLine.RequestedTypeId     = replenishmentTemplateLine.ReplenishTemplateId;

        this.initTempTablePut();

        this.setGlobals();

        // Create Put TmpWorkLine
        this.createTempLine(tmpWorkLine, replenQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteReplenPutTmpWorkLine</Name>
				<Source><![CDATA[
    private void deleteReplenPutTmpWorkLine(WHSWorkCreateReplenishment _workCreate)
    {
        WHSTmpWorkLine  replenPutTmpWorkLine;
        boolean shouldValidateReplenItemId = _workCreate.immedDemandTmpWorkLine.ItemId != '';
        boolean shouldValidateReplenInventDimId = _workCreate.immedDemandTmpWorkLine.InventDimId != '';

        delete_from replenPutTmpWorkLine
            where replenPutTmpWorkLine.WorkCreateId  == workCreateId
            &&    replenPutTmpWorkLine.WorkType      == WHSWorkType::Put
            &&    replenPutTmpWorkLine.WorkTransType == WHSWorkTransType::Replenishment
            &&    (!shouldValidateReplenItemId || replenPutTmpWorkLine.ItemId == _workCreate.immedDemandTmpWorkLine.ItemId)
            &&    (!shouldValidateReplenInventDimId || replenPutTmpWorkLine.InventDimId == _workCreate.immedDemandTmpWorkLine.InventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExistingReplenWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Iterate through temporary work lines to see if any lines that need replenishment can use existing replenishment work.
    /// </summary>
    /// <remarks>
    /// This method assumes that a single temporary put work line has been created for each item/location/inventory dimension
    /// combination.
    /// </remarks>
    private void checkExistingReplenWork()
    {
        using (var activityContext = this.instrumentationLogger().replenishmentActivities().checkExistingReplenishmentWork())
        {
            if (!this.mustCheckForExistingReplenishmentWork())
            {
                if (waveMethodStatusHandler && WHSParameters::find().WaveProgressLog)
                {
                    waveMethodStatusHandler.addTotalSteps(-1);
                }

                return;
            }

            WHSWorkId       replenWorkId;
            boolean         newSplitTmpLineExists;
            Qty             origDemandLineQty;
            int             demandTmpWorkLinesEvaluated;

            WHSWaveMethodStatusHandler subWaveMethodStatusHandler = this.createSubWaveMethodStatusHandler(StepCheckExistingReplenWork);

            do
            {
                newSplitTmpLineExists = false;

                ttsBegin;

                using (var waveLockManager = WhsWaveLockManager::newStandard())
                {
                    WHSTmpWorkLine	demandLine;
                    
                    // Iterate through each item/dimension combination that may have replenishment work available.
                    SysDaQueryObject query = this.buildQueryWithCombinationsOfAvailableReplenishmentWork(demandLine);
                    SysDaSearchObject searchObject = new SysDaSearchObject(query);
                    SysDaSearchStatement searchStatement = new SysDaSearchStatement();
                    while(searchStatement.findNext(searchObject))
                    {
                        ++demandTmpWorkLinesEvaluated;

                        // Lock is required in the scenario that another demand wave is running replenishment at the same time
                        // need to avoid both demands using the same quantity from existing replenishment.
                        boolean lockSuccess = waveLockManager.tryLockForItemDemandWaveAllocation(
                                                            demandLine.ItemId,
                                                            demandLine.InventDimId,
                                                            demandLine.WaveId,
                                                            whsParameters.WaveLockWait);

                        if (lockSuccess)
                        {
                            origDemandLineQty = demandLine.InventQty;
                
                            // Allocate replenishment work that is already used (but has unallocated qty) to the demand line if possible.
                            replenWorkId = this.allocateOpenReplenWork(demandLine, replenWorkId);
                            demandLine.reread();

                            // If no location was set based on already used replenishment work, try unused replenishment work.
                            if (demandLine.WMSLocationId == '')
                            {
                                this.allocateOpenReplenWork(demandLine);
                                demandLine.reread();
                            }

                            // If demand line quantity has changed then the line was split.
                            if (demandLine.InventQty != origDemandLineQty)
                            {
                                newSplitTmpLineExists = true;
                            }

                            waveLockManager.releaseforItemDemandWaveAllocation(demandLine.ItemId, demandLine.InventDimId);

                            WHSWaveMethodStatusHandler::makeOneStepForward(subWaveMethodStatusHandler);
                        }
                        else
                        {
                            this.instrumentationLogger().replenishmentActivities().logEvaluatedDemandTmpWorkLines(demandTmpWorkLinesEvaluated);
                            throw error(strFmt("@WAX:DemandReplenishmentLockFailure", demandLine.ItemId, demandLine.InventDimId, InventDim::find(demandLine.InventDimId).preFix(), whsParameters.WaveLockWait));
                        }
                    }
                }
                ttsCommit;
            }
            while (newSplitTmpLineExists);

            this.instrumentationLogger().replenishmentActivities().logEvaluatedDemandTmpWorkLines(demandTmpWorkLinesEvaluated);
            
            this.updateWaveStepProgressToCompleted(subWaveMethodStatusHandler);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryWithCombinationsOfAvailableReplenishmentWork</Name>
				<Source><![CDATA[
    private SysDaQueryObject buildQueryWithCombinationsOfAvailableReplenishmentWork(WHSTmpWorkLine _demandLine)
    {   
        WHSWorkLine     replenWorkLine;
        WHSWorkLine     replenWorkLinePick;

        SysDaQueryObject queryObj = new SysDaQueryObject(_demandLine);
        queryObj.orderByClause()
                .add(fieldStr(WHSTmpWorkLine, ItemId))
                .add(fieldStr(WHSTmpWorkLine, InventDimId));
        queryObj.forUpdateHint = true;
        queryObj = this.getDemandLineClause(queryObj, _demandLine);

        SysDaQueryObject replenWorkLineClause = WhsWorkCreateReplenishment::getReplenishmentWorkLineClause(replenWorkLine);
        SysDaQueryObject replenWorkLinePickClause = WhsWorkCreateReplenishment::getReplenishmentWorkLinePickClause(_demandLine, replenWorkLine, replenWorkLinePick);
        SysDaQueryObject replenWorkTableClause = WhsWorkCreateReplenishment::getReplenishmentWorkTableClause(replenWorkLine);

        replenWorkLinePickClause.joinClause(SysDaJoinKind::ExistsJoin, replenWorkTableClause);
        replenWorkLineClause.joinClause(SysDaJoinKind::ExistsJoin, replenWorkLinePickClause);       
        queryObj.joinClause(SysDaJoinKind::ExistsJoin, replenWorkLineClause);
        return queryObj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDemandLineClause</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a query with <c>WHSTmpWorkLine</c> buffer selection for possible available replenishment work.
    /// </summary>
    /// <param name = "_queryObj">Instance of <c>SysDaQueryObject</c>.</param>
    /// <param name = "_demandLine">A <c>WHSTmpWorkLine</c> record buffer.</param>
    /// <returns>An instance of <c>SysDaQueryObject</c>.</returns>
    protected SysDaQueryObject getDemandLineClause(SysDaQueryObject _queryObj, WHSTmpWorkLine _demandLine)
    {
        SysDaQueryExpression demandLineClause = new SysDaEqualsExpression(
                new SysDaFieldExpression(_demandLine, fieldStr(WHSTmpWorkLine, workCreateId)),
                new SysDaValueExpression(workCreateId)
            )
            .and(
                new SysDaEqualsExpression(
                    new SysDaFieldExpression(_demandLine, fieldStr(WHSTmpWorkLine, WorkType)),
                    new SysDaValueExpression(WHSWorkType::Pick)
                )
            )
            .and(
                new SysDaEqualsExpression(
                    new SysDaFieldExpression(_demandLine, fieldStr(WHSTmpWorkLine, WMSLocationId)),
                    new SysDaValueExpression('')
                )
            );
                
        _queryObj.whereClause(demandLineClause);
        return _queryObj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReplenishmentWorkTableClause</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a query object for the join of <c>WHSWorkTable</c> and <c>WHSWorkLine</c> record buffers.
    /// </summary>
    /// <param name = "_replenWorkLine">A <c>WHSWorkLine</c> record buffer.</param>
    /// <returns>An instance of <c>SysDaQueryObject</c>.</returns>
    protected static SysDaQueryObject getReplenishmentWorkTableClause(WHSWorkLine _replenWorkLine)
    {
        WHSWorkTable replenWorkTable;

        SysDaQueryObject replenWorkLineTableQueryObject = new SysDaQueryObject(replenWorkTable);
        replenWorkLineTableQueryObject.whereClause(
                new SysDaEqualsExpression(
                        new SysDaFieldExpression(replenWorkTable, fieldStr(WHSWorkTable, WorkId)),
                        new SysDaFieldExpression(_replenWorkLine, fieldStr(WHSWorkLine, WorkId))
                    )
                .and(
                    new SysDaEqualsExpression(
                        new SysDaFieldExpression(replenWorkTable, fieldStr(WHSWorkTable, WorkTransType)),
                        new SysDaValueExpression(WHSWorkTransType::Replenishment))
                    )
                .and(
                    new SysDaLessThanOrEqualsExpression(
                        new SysDaFieldExpression(replenWorkTable, fieldStr(WHSWorkTable, WorkStatus)),
                        new SysDaValueExpression(WHSWorkStatus::InProcess))
                    )
            );
        return replenWorkLineTableQueryObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReplenishmentWorkLinePickClause</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a query object for the join of <c>WHSTmpWorkLine</c> and <c>WHSWorkLine</c> record buffers.
    /// </summary>
    /// <param name = "_demandLine">A <c>WHSTmpWorkLine</c> record buffer.</param>
    /// <param name = "_replenWorkLine">A <c>WHSWorkLine</c> record buffer.</param>
    /// <param name = "_replenWorkLinePick">A <c>WHSWorkLine</c> record buffer.</param>
    /// <returns>An instance of <c>SysDaQueryObject</c> for the find statement.</returns>
    protected static SysDaQueryObject getReplenishmentWorkLinePickClause(
        WHSTmpWorkLine _demandLine, 
        WHSWorkLine _replenWorkLine, 
        WHSWorkLine _replenWorkLinePick)
    {
        SysDaQueryObject replenWorkLinePickQueryObject = new SysDaQueryObject(_replenWorkLinePick);
        replenWorkLinePickQueryObject.whereClause(
                new SysDaEqualsExpression(
                        new SysDaFieldExpression(_replenWorkLinePick, fieldStr(WHSWorkLine, WorkId)),
                        new SysDaFieldExpression(_replenWorkLine, fieldStr(WHSWorkLine, WorkId))
                    )
                .and(
                    new SysDaEqualsExpression(
                        new SysDaFieldExpression(_replenWorkLinePick, fieldStr(WHSWorkLine, WorkType)),
                        new SysDaValueExpression(WHSWorkType::Pick))
                    )
                .and(
                    new SysDaEqualsExpression(
                        new SysDaFieldExpression(_replenWorkLinePick, fieldStr(WHSWorkLine, InventDimId)),
                        new SysDaFieldExpression(_demandLine, fieldStr(WHSTmpWorkLine, InventDimId)))
                    )
                .and(
                    new SysDaEqualsExpression(
                        new SysDaFieldExpression(_replenWorkLinePick, fieldStr(WHSWorkLine, ItemId)),
                        new SysDaFieldExpression(_demandLine, fieldStr(WHSTmpWorkLine, ItemId)))
                    )
                );
        return replenWorkLinePickQueryObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReplenishmentWorkLineClause</Name>
				<Source><![CDATA[
    private static SysDaQueryObject getReplenishmentWorkLineClause(WHSWorkLine _replenWorkLine)
    {
        SysDaQueryObject replenWorkLineQueryObject = new SysDaQueryObject(_replenWorkLine);
        replenWorkLineQueryObject.whereClause(
                new SysDaEqualsExpression(
                    new SysDaFieldExpression(_replenWorkLine, fieldStr(WHSWorkLine, WorkType)),
                    new SysDaValueExpression(WHSWorkType::Put)
                )
                .and(
                    new SysDaLessThanOrEqualsExpression(
                        new SysDaFieldExpression(_replenWorkLine, fieldStr(WHSWorkTable, WorkStatus)),
                        new SysDaValueExpression(WHSWorkStatus::InProcess)
                    )
                )
            );

        return replenWorkLineQueryObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExistingReplenWorkForImmediateReplen</Name>
				<Source><![CDATA[
    private void checkExistingReplenWorkForImmediateReplen()
    {

        using (var activityContext = this.instrumentationLogger().replenishmentActivities().checkExistingReplenWorkForImmediateReplen())
        {
            if (!this.mustCheckForExistingImmediateReplenishmentWork())
            {
                return;
            }

            WHSWorkLine     replenWorkLine;
            WHSWorkLine     replenWorkLinePick;
            WHSWorkTable	replenWorkTable;
            WHSWorkId       replenWorkId;
            int             replenWorkLineEvaluated;
            boolean         mustRestrictByReplenishmentUnit = immedReplenAllowedUnitSet && immedReplenAllowedUnitSet.elements();

            ttsbegin;

            // Iterate through each item/dimension combination that may have replenishment work available.
            while select replenWorkLine
                where replenWorkLine.WorkType   == WHSWorkType::Put
                &&    replenWorkLine.WorkStatus	<= WHSWorkStatus::InProcess
                join ImmediateReplenishmentUnitId from replenWorkTable
                    where replenWorkTable.WorkId		                == replenWorkLine.WorkId
                    &&    replenWorkTable.UseWorkForWaveReplen          == NoYes::Yes
                    &&    replenWorkTable.WorkTransType	                == WHSWorkTransType::Replenishment
                    &&    replenWorkTable.WorkStatus	                <= WHSWorkStatus::InProcess
                    &&    (!mustRestrictByReplenishmentUnit || replenWorkTable.ImmediateReplenishmentUnitId != '')
                    &&    (!useImmedReplenAllowedUnit || replenWorkTable.ImmediateReplenishmentUnitId == immedReplenAllowedUnit)
                exists join replenWorkLinePick
                    where replenWorkLinePick.WorkId			== replenWorkLine.WorkId
                    &&    replenWorkLinePick.WorkType		== WHSWorkType::Pick
                    &&    replenWorkLinePick.InventDimId	== immedDemandTmpWorkLine.InventDimId
                    &&    replenWorkLinePick.ItemId		    == immedDemandTmpWorkLine.ItemId
            {
                if (mustRestrictByReplenishmentUnit &&
                    !immedReplenAllowedUnitSet.in(replenWorkTable.ImmediateReplenishmentUnitId))
                {
                    continue;
                }

                ++replenWorkLineEvaluated;

                Qty origDemandLineQty = immedDemandTmpWorkLine.InventQty;

                // Allocate replenishment work that is already used (but has unallocated qty) to the demand line if possible.
                replenWorkId = this.allocateOpenReplenWork(immedDemandTmpWorkLine, replenWorkId, true);

                // If no location was set based on already used replenishment work, try unused replenishment work.
                if (immedDemandTmpWorkLine.WMSLocationId == '')
                {
                    this.allocateOpenReplenWork(immedDemandTmpWorkLine, '', true);
                }

                // If the quantity hasn't changed the whole line is accounted for, or there is no available open replenishment work.
                if (immedDemandTmpWorkLine.InventQty == origDemandLineQty)
                {
                    break;
                }
            }

            ttscommit;

            this.instrumentationLogger().replenishmentActivities().logEvaluatedReplenWorkLines(replenWorkLineEvaluated);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExistingReplenWorkForImmediateReplenLegacy</Name>
				<Source><![CDATA[
    private void checkExistingReplenWorkForImmediateReplenLegacy()
    {
        using (var activityContext = this.instrumentationLogger().replenishmentActivities().checkExistingReplenWorkForImmediateReplen())
        {
            if (!this.mustCheckForExistingImmediateReplenishmentWork())
            {
                return;
            }

            WHSWorkLine     replenWorkLine;
            WHSWorkLine     replenWorkLinePick;
            WHSWorkTable	replenWorkTable;
            WHSWorkId       replenWorkId;
            int             replenWorkLineEvaluated;

            ttsbegin;

            // Iterate through each item/dimension combination that may have replenishment work available.
            while select replenWorkLine
                where replenWorkLine.WorkType   == WHSWorkType::Put
                &&    replenWorkLine.WorkStatus	<= WHSWorkStatus::InProcess
                exists join replenWorkLinePick
                    where replenWorkLinePick.WorkId			== replenWorkLine.WorkId
                    &&    replenWorkLinePick.WorkType		== WHSWorkType::Pick
                    &&    replenWorkLinePick.InventDimId	== immedDemandTmpWorkLine.InventDimId
                    &&    replenWorkLinePick.ItemId		    == immedDemandTmpWorkLine.ItemId
                exists join replenWorkTable
                    where replenWorkTable.WorkId		                == replenWorkLine.WorkId
                    &&    replenWorkTable.UseWorkForWaveReplen          == NoYes::Yes
                    &&    replenWorkTable.WorkTransType	                == WHSWorkTransType::Replenishment
                    &&    replenWorkTable.WorkStatus	                <= WHSWorkStatus::InProcess
                exists join immedReplenAllowedUnits
                    where immedReplenAllowAllUnits
                    ||    replenWorkTable.ImmediateReplenishmentUnitId  == immedReplenAllowedUnits.UnitId
            {
                ++replenWorkLineEvaluated;

                Qty origDemandLineQty = immedDemandTmpWorkLine.InventQty;

                // Allocate replenishment work that is already used (but has unallocated qty) to the demand line if possible.
                replenWorkId = this.allocateOpenReplenWork(immedDemandTmpWorkLine, replenWorkId, true);

                // If no location was set based on already used replenishment work, try unused replenishment work.
                if (immedDemandTmpWorkLine.WMSLocationId == '')
                {
                    this.allocateOpenReplenWork(immedDemandTmpWorkLine, '', true);
                }

                // If the quantity hasn't changed the whole line is accounted for, or there is no available open replenishment work.
                if (immedDemandTmpWorkLine.InventQty == origDemandLineQty)
                {
                    break;
                }
            }

            ttscommit;

            this.instrumentationLogger().replenishmentActivities().logEvaluatedReplenWorkLines(replenWorkLineEvaluated);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLastNonClosedPutWorkLine</Name>
				<Source><![CDATA[
    private WHSWorkLine findLastNonClosedPutWorkLine(WHSWorkId _workId)
    {
        WHSWorkLine lastPutWorkLine;
        select firstonly WMSLocationId from lastPutWorkLine
                order by LineNum desc
                where lastPutWorkLine.WorkId == _workId
                    && lastPutWorkLine.WorkType == WHSWorkType::Put
                    && lastPutWorkLine.WorkStatus <= WHSWorkStatus::InProcess;

        // Returning the entire record on purpose, so we can later check whether or not we found anything.
        // Relying on WMSLocationId is not good enough, as it can be blank.
        return lastPutWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unallocatedReplenQuantity</Name>
				<Source><![CDATA[
    private InventQty unallocatedReplenQuantity(WHSWorkLine _initialPickWorkLine)
    {
        WHSReplenWorkLink replenWorkLink;
        select sum(InventQty) from replenWorkLink
            where replenWorkLink.ReplenWorkId == _initialPickWorkLine.WorkId
                && replenWorkLink.ReplenLineNum == _initialPickWorkLine.LineNum;
        
        return _initialPickWorkLine.InventQtyWork - replenWorkLink.InventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findUnallocatedReplenQuantity</Name>
				<Source><![CDATA[
    private container findUnallocatedReplenQuantity(WHSTmpWorkLine _demandLine, WHSWorkId _replenWorkIdUsed)
    {
        int workHeadersEvaluated;
        int workLinesEvaluated;

        using (var activityContext = this.instrumentationLogger().replenishmentActivities().findUnallocatedReplenQuantity())
        {
            WHSWorkTable openReplenWorkTable = this.findWorkIdFromOpenReplenishmentWorkTable(_demandLine, _replenWorkIdUsed);

            
            var workEnumerator = WhsWorkOpenReplenishmentWorkEnumerator::newFromWorkTableSelect(openReplenWorkTable);
            if (immedReplenAllowedUnitSet && immedReplenAllowedUnitSet.elements())
            {
                workEnumerator.parmAllowedUnits(immedReplenAllowedUnitSet);
            }

            while (workEnumerator.moveNext())
            {
                WHSWorkId workId = workEnumerator.current();
                ++workHeadersEvaluated;

                WHSWorkLine lastPutWorkLine = this.findLastNonClosedPutWorkLine(workId);
                if (lastPutWorkLine)
                {
                    WHSWorkLine firstPutWorkLine = WHSWorkTable::getFirstPutWorkLine(workId);

                    WHSWorkLine initialPickWorkLine;
                    while select WorkId, LineNum, InventQtyWork from initialPickWorkLine
                    where initialPickWorkLine.WorkId == workId
                        && initialPickWorkLine.LineNum < firstPutWorkLine.LineNum
                        && initialPickWorkLine.WorkType == WHSWorkType::Pick
                        && initialPickWorkLine.WorkStatus != WHSWorkStatus::Cancelled
                        && initialPickWorkLine.ItemId == _demandLine.ItemId
                        && (this.skipCheckInitialPickWorkLineAndDemandLineInventDim() ||
                            initialPickWorkLine.InventDimId == _demandLine.InventDimId )
                    {
                        ++workLinesEvaluated;

                        InventQty unallocatedQty = this.unallocatedReplenQuantity(initialPickWorkLine);

                        if (unallocatedQty > 0)
                        {
                            this.instrumentationLogger().replenishmentActivities().logEvaluatedWorkHeadersAndWorkLines(activityContext, workHeadersEvaluated, workLinesEvaluated);
                            return [lastPutWorkLine.WMSLocationId, unallocatedQty, initialPickWorkLine.WorkId, initialPickWorkLine.LineNum];
                        }
                    }
                }
            }

            this.instrumentationLogger().replenishmentActivities().logEvaluatedWorkHeadersAndWorkLines(activityContext, workHeadersEvaluated, workLinesEvaluated);
            return ['', 0, '', ''];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipCheckInitialPickWorkLineAndDemandLineInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the check of inventory dimentions of the initial pick work line with inventory dimentions of the demand work line should be skipped.
    /// </summary>
    /// <returns>true, if the check should be skipped; otherwise, false.</returns>
    [Replaceable]
    protected boolean skipCheckInitialPickWorkLineAndDemandLineInventDim()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findWorkIdFromOpenReplenishmentWorkTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds <c>WHSWorkId</c> for open replenishment work table by the replenishment demand line and previously used <c>WHSWorkId</c>.
    /// </summary>
    /// <param name = "_demandLine">The temporary work line to find <c>WHSWorkId</c> for.</param>
    /// <param name = "_replenishmentWorkIdUsed">Replenishment <c>WHSWorkId</c> that was used during previous run.</param>
    /// <returns>Instance of <c>WHSWorkTable</c> that can be used to retrieve <c>WHSWorkId</c>.</returns>
    protected WHSWorkTable findWorkIdFromOpenReplenishmentWorkTable(WHSTmpWorkLine _demandLine, WHSWorkId _replenishmentWorkIdUsed)
    {
        WHSWorkTable openReplenWorkTable;
        WHSWorkLine replenWorkLine;

        
        boolean mustRestrictByReplenishmentUnit = immedReplenAllowedUnitSet && immedReplenAllowedUnitSet.elements();

        select WorkId, ImmediateReplenishmentUnitId from openReplenWorkTable
            order by WorkId asc
            where openReplenWorkTable.WorkStatus <= WHSWorkStatus::InProcess
                && openReplenWorkTable.WorkTransType == WHSWorkTransType::Replenishment
                && openReplenWorkTable.UseWorkForWaveReplen == NoYes::Yes
                && (!_demandLine.InventLocationId || openReplenWorkTable.InventLocationId == _demandLine.InventLocationId)
                && (!_replenishmentWorkIdUsed || openReplenWorkTable.WorkId == _replenishmentWorkIdUsed)
                //   && (!mustRestrictByReplenishmentUnit || openReplenWorkTable.ImmediateReplenishmentUnitId != '')
                && (!useImmedReplenAllowedUnit || openReplenWorkTable.ImmediateReplenishmentUnitId == immedReplenAllowedUnit)
            exists join replenWorkLine
                    where replenWorkLine.WorkId == openReplenWorkTable.WorkId
                        && replenWorkLine.ItemId == _demandLine.ItemId
                        && replenWorkLine.InventDimId == _demandLine.InventDimId
                        && replenWorkLine.WorkType == WHSWorkType::Pick
                        && replenWorkLine.WorkStatus != WHSWorkStatus::Cancelled;
      
        return openReplenWorkTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateOpenReplenWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove temporary put replenishment work lines for which existing replenishment work can be used.
    /// </summary>
    /// <param name="_demandLine">
    /// The temporary work line to find replenishment work for.
    /// </param>
    /// <param name="_replenWorkIdUsed">
    /// The replenishment work Id that was used in a previous run and had unallocated quantity remaining.
    /// Optional; only taken into consideration if <c>_runForUsed</c> is true.
    /// </param>
    /// <param name="_forImmediateReplen">
    /// true if being used for immediate replenishment; otherwise, false
    /// </param>
    /// <returns>
    /// The replenishment work Id if there was still quantity available on it; otherwise, an empty string.
    /// </returns>
    /// <remarks>
    /// This method assumes that a single temporary put work line has been created for each item/location/inventory dimension
    /// combination.
    /// </remarks>
    private WHSWorkId allocateOpenReplenWork(
        WHSTmpWorkLine _demandLine,
        WHSWorkId      _replenWorkIdUsed = '',
        boolean        _forImmediateReplen = false)
    {
        WMSLocationId   replenLocationId;
        Qty             replenUnallocatedQty;
        WHSWorkId       replenWorkId;
        LineNum         replenLineNum;

        using (var activityContext = this.instrumentationLogger().replenishmentActivities().allocateOpenReplenishmentWork())
        {
            [replenLocationId, replenUnallocatedQty, replenWorkId, replenLineNum] = this.findUnallocatedReplenQuantity(_demandLine, _replenWorkIdUsed);

            if (_forImmediateReplen)
            {
                return this.allocateOpenImmedReplenWork(replenLocationId, replenWorkId, replenUnallocatedQty, replenLineNum);
            }

            // Update demand location and create temporary demand and replenishment links.
            if (replenUnallocatedQty >= _demandLine.InventQty)
            {
                this.updateDemandLine(_demandLine, replenLocationId);
                this.createOrUpdateTempReplenWorkLinks(_demandLine.InventQty, replenWorkId, replenLineNum);
                this.increaseExistingReplenWorkLinkDemandQtyMap(itemDimExistingReplenWorkLinkDemandQtyMap, _demandLine.ItemId, _demandLine.InventDimId, _demandLine.WMSLocationId, _demandLine.InventQty);
                this.increaseItemDimMap(itemDimWorkCreatedQtyMap, _demandLine.ItemId, _demandLine.InventDimId, _demandLine.WMSLocationId, _demandLine.InventQty);
            }
            else if (replenUnallocatedQty > 0)
            {
                // Split the demand tmp work line to use up the unallocated inventory on the current work header.
                var lineNum =  this.getNextTmpWorkLineNum(workCreateId, _demandLine.LineNum);

                // The WorkBreak field should not be set on the temporary demand lines at this point in time
                // as it can lead to unwanted work header breaks when using containerization for example.
                // The work header breaks due to the setup on the work templates are happening after replenishment and containerization are done.
                const boolean ShouldWorkBreakBeSet = false;

                using (var context = WHSWorkCreateReplenishmentSplitTmpWorkLineWorkBreakContext::newFromParameters(ShouldWorkBreakBeSet))
                {
                    this.splitDemandTmpWorkLine(_demandLine, replenUnallocatedQty, (_demandLine.InventQty - replenUnallocatedQty), lineNum);
                }

                this.updateDemandLine(_demandLine, replenLocationId);
                this.createOrUpdateTempReplenWorkLinks(replenUnallocatedQty, replenWorkId, replenLineNum);
                this.increaseExistingReplenWorkLinkDemandQtyMap(itemDimExistingReplenWorkLinkDemandQtyMap, _demandLine.ItemId, _demandLine.InventDimId, _demandLine.WMSLocationId, _demandLine.InventQty);
                this.increaseItemDimMap(itemDimWorkCreatedQtyMap, _demandLine.ItemId, _demandLine.InventDimId, _demandLine.WMSLocationId, replenUnallocatedQty);
            }

            // Ensure same replenishment work header is used unless all quantity is allocated.
            replenWorkId = replenUnallocatedQty <= _demandLine.InventQty ? '' : replenWorkId;
        }

        return replenWorkId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDemandLine</Name>
				<Source><![CDATA[
    private void updateDemandLine(WHSTmpWorkLine _demandLine, WMSLocationId _replenLocationId)
    {
        this.initializeDemandLineWithLocation(_demandLine, _replenLocationId);
        _demandLine.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeDemandLineWithLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes demand line with replenishment location information.
    /// </summary>
    /// <param name = "_demandLine">The replenishment demand line record to be initialized.</param>
    /// <param name = "_replenishmentLocationId">The replenishment location Id.</param>
    protected void initializeDemandLineWithLocation(WHSTmpWorkLine _demandLine, WMSLocationId _replenishmentLocationId)
    {
        WMSLocation wmsLocation = WMSLocation::find(_replenishmentLocationId, _demandLine.InventLocationId);

        _demandLine.WMSLocationId    = _replenishmentLocationId;
        _demandLine.ZoneId           = wmsLocation.ZoneId;
        _demandLine.sortCode         = wmsLocation.sortCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitDemandTmpWorkLine</Name>
				<Source><![CDATA[
    private void splitDemandTmpWorkLine(        
        WHSTmpWorkLine      _tmpWorkLine,
        InventHandlingQty   _maxInventQty,
        InventHandlingQty   _remInventQty,
        LineNum             _lineNum)
    {
        this.splitTmpWorkLineHandlingQty(_tmpWorkLine, _maxInventQty, _remInventQty, _lineNum, false, false);
        // We need to set WorkBreak to No explicitly, because work break is Yes here, the work line will be added to new work header in the process of work creation.
        // Instead, system should use work template group/break to decide if the work line should be added to new work header.
        _tmpWorkLine.WorkBreak    = NoYes::No;
        _tmpWorkLine.ReplenDemand = NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>increaseExistingReplenWorkLinkDemandQtyMap</Name>
				<Source><![CDATA[
    private void increaseExistingReplenWorkLinkDemandQtyMap(
        Map             _existingReplenWorkLinkDemandQtyMap,
        ItemId          _itemId,
        InventDimId     _inventDimId,
        WMSLocationId   _replenPutLocationId,
        InventQty       _inventQty)
    {
        str mapKey = _itemId + _inventDimId + _replenPutLocationId;

        if (_existingReplenWorkLinkDemandQtyMap.exists(mapKey))
        {
            _existingReplenWorkLinkDemandQtyMap.insert(mapKey, _existingReplenWorkLinkDemandQtyMap.lookup(mapKey) + _inventQty);
        }
        else
        {
            _existingReplenWorkLinkDemandQtyMap.insert(mapKey, _inventQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>decreaseExistingReplenWorkLinkDemandQtyMap</Name>
				<Source><![CDATA[
    private void decreaseExistingReplenWorkLinkDemandQtyMap(
        Map             _existingReplenWorkLinkDemandQtyMap,
        ItemId          _itemId,
        InventDimId     _inventDimId,
        WMSLocationId   _replenPutLocationId,
        InventQty       _inventQty)
    {
        str mapKey = _itemId + _inventDimId + _replenPutLocationId;
                
        if (_existingReplenWorkLinkDemandQtyMap.exists(mapKey))
        {
            _existingReplenWorkLinkDemandQtyMap.insert(mapKey, _existingReplenWorkLinkDemandQtyMap.lookup(mapKey) - _inventQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>increaseItemDimMap</Name>
				<Source><![CDATA[
    private void increaseItemDimMap(
        Map             _itemDimMap,
        ItemId          _itemId,
        InventDimId     _inventDimId,
        WMSLocationId   _replenPutLocationId,
        InventQty       _inventQty)
    {
        container mapKey = [_itemId, _inventDimId, _replenPutLocationId];
                
        if (_itemDimMap.exists(mapKey))
        {
            _itemDimMap.insert(mapKey, _itemDimMap.lookup(mapKey) + _inventQty);
        }
        else
        {
            _itemDimMap.insert(mapKey, _inventQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>increaseReplenWorkMap</Name>
				<Source><![CDATA[
    private void increaseReplenWorkMap(
        Map             _replenWorkMap,
        WHSWorkLine     _replenWorkLine,
        WMSLocationId   _replenPutLocationId)
    {
        str mapKey = _replenWorkLine.ItemId + _replenWorkLine.InventDimId + _replenPutLocationId;
                
        if (_replenWorkMap.exists(mapKey))
        {
            List replenWorkLineRecIds = _replenWorkMap.lookup(mapKey);
            replenWorkLineRecIds.addEnd(int642str(_replenWorkLine.RecId));
            _replenWorkMap.insert(mapKey,  replenWorkLineRecIds);
        }
        else
        {
            List recIds = new List(Types::String);
            recIds.addStart(int642str(_replenWorkLine.RecId));

            _replenWorkMap.insert(mapKey, recIds);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateOpenImmedReplenWork</Name>
				<Source><![CDATA[
    private WHSWorkId allocateOpenImmedReplenWork(
        WMSLocationId   _replenLocationId,
        WHSWorkId       _replenWorkId,
        Qty             _replenUnallocatedQty,
        LineNum         _replenLineNum)
    {
        if (_replenUnallocatedQty > 0 && immedReplenQty > 0)
        {
            Qty minQty = min(_replenUnallocatedQty, immedReplenQty);

            if (immedReplenQty == minQty)
            {
                // Only use existing immediate replenishment(s).
                // Update demand location.
                immedDemandTmpWorkLine.InventLocationId = WHSWorkTable::find(_replenWorkId).InventLocationId;
                immedDemandTmpWorkLine.setWMSLocation(_replenLocationId, immedDemandTmpWorkLine.InventLocationId);
                onlyExistingImmedReplenUsed  = true;
                immedReplenPutLocation       = _replenLocationId;
            }

            // Immediate demand tmp work line is split (insert tmp work line into whstmpworkline table and temporary replenishment work link without demand work id).
            // Demand tmp work lines created when create or use replenishment work. Work create for the demand work only calculate how many work qty created.  
            this.splitImmediateDemandTmpWorkLine(_replenLocationId, _replenWorkId, minQty, _replenLineNum);
        }

        return _replenUnallocatedQty <= immedReplenQty ? '' : _replenWorkId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitImmediateDemandTmpWorkLine</Name>
				<Source><![CDATA[
    private void splitImmediateDemandTmpWorkLine(
        WMSLocationId   _replenLocationId,
        WHSWorkId       _replenWorkId,
        Qty             _replenUnallocatedQty,
        LineNum         _replenLineNum)
    {
        WHSTmpWorkLine newTmpWorkLine;

        buf2Buf(immedDemandTmpWorkLine, newTmpWorkLine);

        EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

        const boolean applyRounding = false;
        Qty convertedQty = releasedProductUnitConverter.convertGivenUnitSymbols(_replenUnallocatedQty,
                                                                                WHSCatchWeightHelper::inventHandlingUnitId(newTmpWorkLine.ItemId),
                                                                                newTmpWorkLine.DirectiveUOM,
                                                                                NoYes::No,
                                                                                newTmpWorkLine.ItemId,
                                                                                newTmpWorkLine.InventDimId,
                                                                                applyRounding);

        newTmpWorkLine.DirectiveQty         = convertedQty;
        newTmpWorkLine.InventQty            = _replenUnallocatedQty;
        newTmpWorkLine.InventLocationId     =  WHSWorkTable::find(_replenWorkId).InventLocationId;
        newTmpWorkLine.ReleaseToWarehouseId = releaseToWarehouseId;

        newTmpWorkLine.initFromInventDim(WHSWorkLine::find(_replenWorkId, _replenLineNum).inventDim());
        newTmpWorkLine.setWMSLocation(_replenLocationId, newTmpWorkLine.InventLocationId);
        newTmpWorkLine.setPackQtyCompare();

        [newTmpWorkLine.HighestQty,
         newTmpWorkLine.HighestUnitId] = WHSInventTable::getHighestUnitQtyByUOMSeqGroup(newTmpWorkLine.ItemId, newTmpWorkLine.DirectiveQty, newTmpWorkLine.DirectiveUOM, newTmpWorkLine.InventDimId);

        newTmpWorkLine.setLineNum();

        UserConnection  conn = new UserConnection();

        try
        {
            newTmpWorkLine.setConnection(conn);
            conn.ttsbegin();
            newTmpWorkLine.insert();
            conn.ttscommit();
        }
        finally
        {
            conn.finalize();
        }

        immedDemandTmpWorkLine.DirectiveQty -= convertedQty;
        immedDemandTmpWorkLine.InventQty    -= _replenUnallocatedQty;

        this.createOrUpdateTempReplenWorkLinks(_replenUnallocatedQty, _replenWorkId, _replenLineNum);
        immedReplenQty                -= _replenUnallocatedQty;
        immedReplenUsedExistingReplen += _replenUnallocatedQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateTempReplenWorkLinks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create or update a temporary replenishment/demand work link record.
    /// </summary>
    /// <param name="_qty">
    /// The quantity being allocated to the replenishment work.
    /// </param>
    /// <param name="_workId">
    /// The replenishment work header.
    /// </param>
    /// <param name="_lineNum">
    /// The replenishment work line number.
    /// </param>
    private void createOrUpdateTempReplenWorkLinks(
        InventQty	_qty,
        WHSWorkId	_workId,
        LineNum		_lineNum = 1)
    {
        #OCCRetryCount
        Connection connection;

        try
        {
            
            if (this.mustCreateOrUpdateTempReplenWorkLinksInUserConnection())
            {
                connection = new UserConnection();
            }
            else 
            {
                connection = new Connection();
            }

            connection.ttsbegin();

            this.createOrUpdateTempReplenWorkLinksInConnection(_workId, _lineNum, _qty, connection);
                        
            connection.ttscommit();
        }
        catch (Exception::DuplicateKeyException)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::DuplicateKeyExceptionNotRecovered;
            }

            retry;
        }
        finally
        {
            if (connection)
            {
                connection.finalize();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateTempReplenWorkLinksInConnection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates temporary replenishment work links using specified connection.
    /// </summary>
    /// <param name = "_replenWorkId">Replenishment work id.</param>
    /// <param name = "_replenWorkLineNum">Replenishment work line number.</param>
    /// <param name = "_demandQty">Demand quantity to create the replenishment work link for.</param>
    /// <param name = "_connection">Connection to be used during the create or update. Must use a user connection so if other demand work is looking for existing replenishment for the same item we avoid using the same quantity twice.</param>
    private void createOrUpdateTempReplenWorkLinksInConnection(        
        WHSWorkId	    _replenWorkId,
        LineNum		    _replenWorkLineNum,
        InventQty	    _demandQty,
        Connection      _connection)
    {  
        WHSReplenWorkLink replenWorkLink;
        replenWorkLink.setConnection(_connection);        
        replenWorkLink.skipDataMethods(true); // update() is overwritten, but the check inside is not relevant, and we want to avoid other dependencies (CRUD for other tables - that will not be in this connection)
        update_recordSet replenWorkLink
                setting InventQty = (replenWorkLink.InventQty + _demandQty)
                where replenWorkLink.ReplenWorkId	 == _replenWorkId
                    && replenWorkLink.ReplenLineNum  == _replenWorkLineNum
                    && replenWorkLink.DemandWorkId	 == ''
                    && replenWorkLink.DemandLineNum  == 0
                    && replenWorkLink.WorkBuildId	 == workCreateId;

        if (replenWorkLink.rowCount() == 0)
        {
            this.createTempReplenWorkLinksInConnection(_replenWorkId, _replenWorkLineNum, _demandQty, _connection);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTempReplenWorkLinksInConnection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates temporary replenishment work links using specified connection. 
    /// </summary>
    /// <param name = "_replenWorkId">Replenishment work id.</param>
    /// <param name = "_replenWorkLineNum">Replenishment work line number.</param>
    /// <param name = "_demandQty">Demand quantity to create the replenishment work link for.</param>
    /// <param name = "_connection">User connection to be used during the insert.</param>
    private void createTempReplenWorkLinksInConnection(
        WHSWorkId	    _replenWorkId,
        LineNum		    _replenWorkLineNum,
        InventQty	    _demandQty,
        Connection      _connection)
    {
        WHSReplenWorkLink replenWorkLink;       
        replenWorkLink.setConnection(_connection);
        
        replenWorkLink.ReplenLineNum	= _replenWorkLineNum;
        replenWorkLink.ReplenWorkId     = _replenWorkId;
        replenWorkLink.InventQty		= _demandQty;
        replenWorkLink.WorkBuildId		= workCreateId;
        replenWorkLink.doInsert(); // to avoid dependencies if insert() is overwritten and does CRUD for other tables - that will not be in this connection
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateOrUpdateTempReplenWorkLinksInUserConnection</Name>
				<Source><![CDATA[
    protected boolean mustCreateOrUpdateTempReplenWorkLinksInUserConnection()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numDemandTmpWorkLineToFindPutLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the count of demand temporary work lines which need find put location.
    /// </summary>
    /// <returns>The count of demand temporary work lines in put location.</returns>
    private int numDemandTmpWorkLineToFindPutLocation()
    {
        WHSTmpWorkLine localDemandTmpWorkLine;

        select count(RecId) from localDemandTmpWorkLine
            where localDemandTmpWorkLine.WorkCreateId    == workCreateId
               && localDemandTmpWorkLine.WorkType        == WHSWorkType::Pick
               && localDemandTmpWorkLine.wmsLocationId   == '';

        return localDemandTmpWorkLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>beforeFindReplenishmentPutLocation</Name>
				<Source><![CDATA[
    protected void beforeFindReplenishmentPutLocation(WHSReplenishTemplateId _replenishTemplateId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findReplenishmentPutLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the put location for replenishment work.
    /// </summary>
    /// <param name="_replenishTemplateId">
    /// The replenishment template Id being used.
    /// </param>
    private void findReplenishmentPutLocation(WHSReplenishTemplateId _replenishTemplateId)
    {
        this.beforeFindReplenishmentPutLocation(_replenishTemplateId);
        
        using (var activityContext = this.instrumentationLogger().replenishmentActivities().findReplenishmentPutLocation())
        {
            if (immedDemandTmpWorkLine.ItemId)
            {
                if (immedDemandTmpWorkLine.WMSLocationId == ''
                &&  immedReplenQty > 0)
                {
                    immedDemandTmpWorkLine = this.createReplenTempTablePut(immedReplenQty, immedDemandTmpWorkLine, _replenishTemplateId, true);
                    immedDemandTmpWorkLine.WMSLocationId    = immedReplenPutLocation;
                    immedDemandTmpWorkLine.InventLocationId = immedReplenPutWarehosue;
                }
            }
            else
            {
                ItemId      prevItemId;
                InventDimId prevInventDimId;
                int         demandTmpWorkLineEvaluated;
                int         demandTmpWorkLineGroupByItemAndInventDimEvaluated;
                InventQty   demandQty;

                WHSWaveMethodStatusHandler subWaveMethodStatusHandler = this.createSubWaveMethodStatusHandler(StepFindReplenishmentPutLocation);

                while select demandTmpWorkLine
                    order by ItemId, InventDimId
                    where demandTmpWorkLine.WorkCreateId    == workCreateId         &&
                          demandTmpWorkLine.WorkType        == WHSWorkType::Pick    &&
                          demandTmpWorkLine.wmsLocationId   == ''
                {
                    demandTmpWorkLineEvaluated++;

                    if (demandTmpWorkLine.ItemId != prevItemId || demandTmpWorkLine.InventDimId != prevInventDimId)
                    {
                        demandTmpWorkLineGroupByItemAndInventDimEvaluated++;

                        prevInventDimId = demandTmpWorkLine.InventDimId;
                        prevItemId = demandTmpWorkLine.ItemId;

                        WHSTmpWorkLine sumDemandTmpWorkLine;

                        select sum(InventQty) from sumDemandTmpWorkLine
                            where sumDemandTmpWorkLine.ItemId           == demandTmpWorkLine.ItemId
                                && sumDemandTmpWorkLine.InventDimId     == demandTmpWorkLine.InventDimId
                                && sumDemandTmpWorkLine.WorkCreateId    == workCreateId
                                && sumDemandTmpWorkLine.WorkType        == WHSWorkType::Pick
                                && sumDemandTmpWorkLine.wmsLocationId   == '';

                        demandQty = sumDemandTmpWorkLine.InventQty;
                
                        if (demandQty > 0)
                        {
                            demandTmpWorkLine = this.createReplenTempTablePut(demandQty, demandTmpWorkLine, _replenishTemplateId, false);
                        }
                    }

                    WHSWaveMethodStatusHandler::makeOneStepForward(subWaveMethodStatusHandler);
                }
            
                this.updateWaveStepProgressToCompleted(subWaveMethodStatusHandler);

                this.instrumentationLogger().replenishmentActivities().logEvaluatedDemandTmpWorkLines(demandTmpWorkLineEvaluated);
                this.instrumentationLogger().replenishmentActivities().logEvaluatedDemandTmpWorkLinesGroupByItemAndInventDim(demandTmpWorkLineGroupByItemAndInventDimEvaluated);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReplenTempTablePut</Name>
				<Source><![CDATA[
    private WHSTmpWorkLine createReplenTempTablePut(
        InventQty               _demandQty,
        WHSTmpWorkLine          _currentTmpWorkLine,
        WHSReplenishTemplateId  _replenishTemplateId,
        boolean                 _isImmedReplen)
    {
        WHSReplenishmentTemplateLine    replenTempLine;
        WHSTmpWorkLine                  localTmpWorkLine = _currentTmpWorkLine;
        InventQty                       demandQty = _demandQty;

        boolean whsWorkCreateReplenishmentUseLastImmediateReplenPutLocationFlight = WHSWorkCreateReplenishmentUseLastImmediateReplenPutLocationFlight::instance().isEnabled();

        while select replenTempLine
            order by replenTempLine.SeqNum
            where replenTempLine.ReplenishTemplateId == _replenishTemplateId
        {
            if (demandQty <= 0)
            {
                break;
            }

            // Check if item or item variant queries pass.
            if (!WHSReplenishmentTemplateLine::isProductSelectionFound(replenTempLine.RecId, localTmpWorkLine.ItemId, localTmpWorkLine.InventDimId))
            {
                continue;
            }

            UnitOfMeasureSymbol inventUnitId = WHSCatchWeightHelper::inventHandlingUnitId(localTmpWorkLine.ItemId);

            // Check replenishment template line unit of measure with workline unit of measure.
            if (!this.validateTemplateLineUOMConversion(replenTempLine, localTmpWorkLine, inventUnitId))
            {
                WHSWorkCreateHistory::createWorkHistoryLineFromTmpWorkLine(workCreateId,
                                                                           strFmt("@WAX:Error_ReplenishworkCannotBeCreatedBecauseNoUOM",
                                                                                  replenTempLine.ReplenishTemplateId,
                                                                                  replenTempLine.SeqNum,
                                                                                  localTmpWorkLine.ItemId,
                                                                                  inventUnitId,
                                                                                  replenTempLine.ReplenishmentUOM),
                                                                           true,
                                                                           localTmpWorkLine);
                continue;
            }

            // Log: Replenishment template line succeeded
            WHSPostEngine::createWaveExecutionHistoryLine(parmWaveId,
                                                          waveExecutionId,
                                                          strFmt("@WAX4063", replenTempLine.ReplenishTemplateId, replenTempLine.SeqNum, localTmpWorkLine.ItemId),
                                                          true,
                                                          null,
                                                          workCreateId);

            WHSWorkCreateHistory::createWorkHistoryLineFromTmpWorkLine(workCreateId,
                                                                       strFmt("@WAX4063",
                                                                              replenTempLine.ReplenishTemplateId,
                                                                              replenTempLine.SeqNum,
                                                                              localTmpWorkLine.ItemId),
                                                                       false,
                                                                       localTmpWorkLine);

            // Use location directives to find the Location(s) to replenishment.
            WhsWorkCreateReplenishment workcreate = new WHSWorkCreateReplenishment(replenTempLine, workCreateId);

            workcreate.parmParmWaveId(parmWaveId);
            workcreate.parmReplenishmentTemplateLine(replenTempLine);
            workcreate.parmReplenQty(demandQty);
            workcreate.parmReplenDemandTmpWorkLine(localTmpWorkLine);
            workcreate.parmLocDirHintCode(replenTempLine.LocDirHintCode);
            workcreate.parmReleaseToWarehouseId(releaseToWarehouseId);
            workcreate.parmReplenUOM(replenTempLine.ReplenishmentUOM);
            workcreate.parmImmedReplenUnit(immedReplenUnit);
            workcreate.parmIsImmedReplen(_isImmedReplen);
            workcreate.parmItemDimReplenTempLineExtraQtyMap(itemDimReplenTempLineExtraQtyMap);
            
            workcreate.createTempTablePut();
            demandQty -= workcreate.parmWorkCreatedQty();

            if (_isImmedReplen && whsWorkCreateReplenishmentUseLastImmediateReplenPutLocationFlight)
            {
                WMSLocationId localImmedReplenPutLocation = workcreate.parmLastImmediateReplenLocationId();

                if (localImmedReplenPutLocation)
                {
                    immedReplenPutLocation = localImmedReplenPutLocation;
                }
            }
            else
            {
                immedReplenPutLocation  = workcreate.parmLastImmediateReplenLocationId();
            }

            this.parmImmediateReplenAvailQty(workcreate.parmWorkCreatedQty() + this.parmImmediateReplenAvailQty());

            immedReplenPutWarehosue = workcreate.parmTmpWorkLine().InventLocationId;
        }

        if (demandQty > 0)
        {
            // replenishment work was not created for all of demand?
            WHSPostEngine::createWaveExecutionHistoryLine(parmWaveId, waveExecutionId,
                strFmt("@WAX:ReplenTemplateLineDidNotFullfilDemandQty", _replenishTemplateId, _demandQty - demandQty, _demandQty, localTmpWorkLine.ItemId),
                true, null, workCreateId);
        }

        return localTmpWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTemplateLineUOMConversion</Name>
				<Source><![CDATA[
    private boolean validateTemplateLineUOMConversion(
        WHSReplenishmentTemplateLine    _replenishmentTemplateLine,
        WHSTmpWorkLine                  _localTmpWorkLine,
        UnitOfMeasureSymbol             _inventUnitId)
    {
        return unitConverter.canBeConvertedGivenUnitSymbols(_replenishmentTemplateLine.ReplenishmentUOM,
                                            _inventUnitId,
                                            _localTmpWorkLine.ItemId,
                                            _localTmpWorkLine.InventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findReplenishmentTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find a Wave Demand replenishment template with the specified wave step code.
    /// </summary>
    /// <param name="_code">
    /// The Wave step code that must be on the replenishment template selected.
    /// </param>
    /// <returns>
    /// A <c>WHSReplenishmentTemplate</c> record.
    /// </returns>
    private WHSReplenishmentTemplate findReplenishmentTemplate(WHSWaveStepCode _code)
    {
        WHSReplenishmentTemplate    replenishmentTemplate;

        select firstonly replenishmentTemplate
            where replenishmentTemplate.WaveStepCode         == _code
            &&    replenishmentTemplate.ReplenishmentType    == WHSReplenishmentType::WaveDemand;

        return replenishmentTemplate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markDemandLineForReplen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks demands lines that need to be replenished.
    /// </summary>
    private void markDemandLineForReplen()
    {
        // Mark all demand records in the tmpTable
        // This statement is written as a while-select and not an update_recordset to avoid situations
        // where SQL escalates directly to a table lock since this will block later inserts in user connections.
        // Such situations can occur when a large number (+4000) of TmpWorkLines are updated in one statement.
        while select forupdate demandTmpWorkLine
            where demandTmpWorkLine.WorkCreateId    == workCreateId
               && demandTmpWorkLine.WorkType        == WHSWorkType::Pick
               && demandTmpWorkLine.wmsLocationId   == ''
        {
            demandTmpWorkLine.ReplenDemand = NoYes::Yes;
            demandTmpWorkLine.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(Common _common, WHSWorkCreateId _workCreateId = '')
    {
        replenishmentTemplateLine = _common;

        workCreateId = _workCreateId ? _workCreateId : NumberSeq::newGetNum(WHSParameters::numRefWHSWorkCreateId()).num();

        super(replenishmentTemplateLine, workCreateId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReplenDemandTmpWorkLine</Name>
				<Source><![CDATA[
    public WHSTmpWorkLine parmReplenDemandTmpWorkLine(WHSTmpWorkLine _demandTmpWorkLine = demandTmpWorkLine)
    {
        demandTmpWorkLine = _demandTmpWorkLine;

        return demandTmpWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmImmedDemandTmpWorkLine</Name>
				<Source><![CDATA[
    public WHSTmpWorkLine parmImmedDemandTmpWorkLine(WHSTmpWorkLine _immedDemandTmpWorkLine = immedDemandTmpWorkLine)
    {
        immedDemandTmpWorkLine = _immedDemandTmpWorkLine;

        return immedDemandTmpWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmImmedReplenPutLocation</Name>
				<Source><![CDATA[
    public WMSLocationId parmImmedReplenPutLocation(WMSLocationId _immedReplenPutLocation = immedReplenPutLocation)
    {
        immedReplenPutLocation = _immedReplenPutLocation;

        return immedReplenPutLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmImmedReplenQty</Name>
				<Source><![CDATA[
    public Qty parmImmedReplenQty(Qty _immedReplenQty = immedReplenQty)
    {
        immedReplenQty = _immedReplenQty;

        return immedReplenQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmImmedReplenUnit</Name>
				<Source><![CDATA[
    public UnitOfMeasureSymbol parmImmedReplenUnit(UnitOfMeasureSymbol _immedReplenUnit)
    {
        immedReplenUnit = _immedReplenUnit;

        return immedReplenUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReplenInventDim</Name>
				<Source><![CDATA[
    public InventDim parmReplenInventDim(InventDim _inventDim = replenInventDim)
    {
        replenInventDim = _inventDim;

        return replenInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReplenItemId</Name>
				<Source><![CDATA[
    public ItemId parmReplenItemId(ItemId _itemId = itemId)
    {
        itemId = _itemId;

        return itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReplenQty</Name>
				<Source><![CDATA[
    public InventQty parmReplenQty(InventQty _qty = replenQty)
    {
        replenQty = _qty;

        return replenQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDemandWaveId</Name>
				<Source><![CDATA[
    public WHSDemandWaveId parmDemandWaveId(WHSDemandWaveId _demandWaveId = demandWaveId)
    {
        demandWaveId = _demandWaveId;

        return demandWaveId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmImmedReplenUsedExistingReplen</Name>
				<Source><![CDATA[
    public Qty parmImmedReplenUsedExistingReplen(Qty _immedReplenUsedExistingReplen = immedReplenUsedExistingReplen)
    {
        immedReplenUsedExistingReplen = _immedReplenUsedExistingReplen;

        return immedReplenUsedExistingReplen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOnlyExistingImmedReplenUsed</Name>
				<Source><![CDATA[
    public boolean parmOnlyExistingImmedReplenUsed(boolean _onlyExistingImmedReplenUsed = onlyExistingImmedReplenUsed)
    {
        onlyExistingImmedReplenUsed = _onlyExistingImmedReplenUsed;
        
        return onlyExistingImmedReplenUsed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpLoadDemand</Name>
				<Source><![CDATA[
    public WHSTmpLoadDemand parmTmpLoadDemand(WHSTmpLoadDemand _tmpLoadDemand = tmpLoadDemand)
    {
        tmpLoadDemand = _tmpLoadDemand;

        return tmpLoadDemand;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWhsWaveLockManager</Name>
				<Source><![CDATA[
    public WHSWaveLockManager parmWhsWaveLockManager(WHSWaveLockManager _whsWaveLockManager = whsWaveLockManager)
    {
        if (!prmIsDefault(_whsWaveLockManager))
        {
            this.disposeWhsWaveLockManager();

            whsWaveLockManager = _whsWaveLockManager;
            mustDisposeWhsLockManager = false;
        }

        return whsWaveLockManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWorkCreateId</Name>
				<Source><![CDATA[
    public WHSWorkCreateId parmWorkCreateId(WHSWorkCreateId _workCreateId = workCreateId)
    {
        workCreateId = _workCreateId;

        return workCreateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemDimReplenTempLineExtraQtyMap</Name>
				<Source><![CDATA[
    public Map parmItemDimReplenTempLineExtraQtyMap(Map _itemDimReplenTempLineExtraQtyMap = itemDimReplenTempLineExtraQtyMap)
    {
        itemDimReplenTempLineExtraQtyMap = _itemDimReplenTempLineExtraQtyMap;

        return itemDimReplenTempLineExtraQtyMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemDimPutLocationPickedQtyMap</Name>
				<Source><![CDATA[
    public Map parmItemDimPutLocationPickedQtyMap(Map _itemDimPutLocationPickedQtyMap = itemDimPutLocationPickedQtyMap)
    {
        itemDimPutLocationPickedQtyMap = _itemDimPutLocationPickedQtyMap;

        return itemDimPutLocationPickedQtyMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findReplenishmentTemplateFromImmediateCode</Name>
				<Source><![CDATA[
    private WHSReplenishmentTemplate findReplenishmentTemplateFromImmediateCode(WHSImmediateReplenishTemplateId _immedReplenishTemplateId)
    {
        WHSReplenishmentTemplate replenishmentTemplate = WHSReplenishmentTemplate::find(_immedReplenishTemplateId);

        if (!replenishmentTemplate.RecId)
        {
            // Log: No replenishment template was found for immediate replenishment template.
            WHSPostEngine::createWaveExecutionHistoryLine(parmWaveId,
                                                          waveExecutionId,
                                                          strFmt("@WAX:MissingImmediateReplenTemplate", _immedReplenishTemplateId),
                                                          true,
                                                          null,
                                                          workCreateId);
        }

        return replenishmentTemplate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findReplenishmentTemplateFromWaveStepCode</Name>
				<Source><![CDATA[
    private WHSReplenishmentTemplate findReplenishmentTemplateFromWaveStepCode(WHSWaveStepCode _code)
    {
        WHSReplenishmentTemplate replenishmentTemplate;

        if (_code)
        {
            replenishmentTemplate = this.findReplenishmentTemplate(_code);

            if (!replenishmentTemplate)
            {
                WHSPostEngine::createWaveExecutionHistoryLine(parmWaveId,
                                                          waveExecutionId,
                                                          strFmt("@WAX:NoReplenishmentTemplateFoundForStepCode", _code),
                                                          true,
                                                          null,
                                                          workCreateId);
            }
        }
        else
        {
            WHSPostEngine::createWaveExecutionHistoryLine(parmWaveId,
                                                              waveExecutionId,
                                                              "@WAX:ReplenishmentTemplateNotFoundDueToEmptyWaveStepCode_ErrorMessage",
                                                              true,
                                                              null,
                                                              workCreateId);
        }

        return replenishmentTemplate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runDemandReplen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates demand replenishment work from a replenishment template.
    /// </summary>
    /// <param name="_code">
    /// Wave step code of the template.
    /// </param>
    /// <param name="_immediateReplenTemplateId">
    /// Immediate replenish template ID from the location directive line.
    /// </param>
    public void runDemandReplen(
        WHSWaveStepCode                  _code,
        WHSImmediateReplenishTemplateId  _immediateReplenTemplateId = '')
    {
        ttsbegin;
        
        // Setting globals.
        originRefId = parmWaveId;
        originType  = WHSOriginType::Wave;

        itemDimWorkCreatedQtyMap                    = new Map(Types::Container, Types::Real);
        itemDimExistingReplenWorkLinkDemandQtyMap   = new Map(Types::String, Types::Real);
        itemDimReplenTempLineExtraQtyMap            = new Map(Types::Container, Types::Container);
        itemDimReplenWorkMap                        = new Map(Types::String, Types::Class);
        immedReplenAllowedUnitSet                   = new Set(Types::String);
        useImmedReplenAllowedUnit                   = false;
        immedReplenAllowedUnit                      = '';

        WHSReplenishmentTemplate replenishmentTemplate;

        if (_immediateReplenTemplateId)
        {
            replenishmentTemplate = this.findReplenishmentTemplateFromImmediateCode(_immediateReplenTemplateId);
        }        
        else 
        {
            replenishmentTemplate = this.findReplenishmentTemplateFromWaveStepCode(_code);
        }

        using (var appInsightsActivity = WHSRunDemandReplenishmentApplicationInsightsActivity::newFromParameters(replenishmentTemplate.ReplenishTemplateId, _code))
        {
            if (replenishmentTemplate.RecId)
            {
                this.initImmedReplenAllowedUnits(replenishmentTemplate.UseExistingImmediateReplenishmentWorkCrossUnit, replenishmentTemplate.RecId);

                if (waveMethodStatusHandler != null)
                {
                    waveMethodStatusHandler.setTotalSteps(TotalSubMethodSteps);
                }

                if (_code)
                {
                    // Mark all demand records in the tmpTable.
                    this.markDemandLineForReplen();

                    // Use any existing replenishment work before creating new work.
                    this.checkExistingReplenWork();
                }
                else if (_immediateReplenTemplateId)
                {
                    immedDemandTmpWorkLine.ReplenDemand                 = NoYes::Yes;
                    immedDemandTmpWorkLine.ImmediateReplenishmentUnitId = immedReplenUnit;

                    this.checkExistingReplenWorkForImmediateReplen();
                }

                using (var context = new WHSRunImmediateReplenishmentContext())
                {
                    if (_immediateReplenTemplateId)
                    {
                        context.runImmediateReplenishment = true;
                    }

                    this.findReplenishmentPutLocation(replenishmentTemplate.ReplenishTemplateId);
                }

                // If we have any put replenishment lines then create a wave and work create class so we can create replenishment work.
                if (this.successfulReplenPutCreated())
                {
                    WHSWaveTable waveTable = this.createReplenishmentWave();

                    // Create a lock for the replenishment wave.
                    if (!whsWaveLockManager)
                    {
                        this.instantiateWHSWaveLockManager();
                    }

                    try
                    {
                        this.createDemandReplenishmentWork(waveTable, _immediateReplenTemplateId);
                    }
                    catch
                    {
                        // This is a noop catch block, should never be entered, as the call should be within a transaction.
                        // This ensures exception handling is consistent regardless of type of exception thrown (kernel or application).
                        throw error(Error::wrongUseOfFunction(funcName()));
                    }
                    finally
                    {
                        // Release the lock on the replenishment wave.
                        whsWaveLockManager.releaseForWaveId(waveTable.WaveId);
                    }
                }
                else
                {
                    if (waveMethodStatusHandler)
                    {
                        waveMethodStatusHandler.addTotalSteps(-2);
                    }

                    if (_immediateReplenTemplateId
                 &&  immedDemandTmpWorkLine.WMSLocationId != '')
                    {
                        workCreatedQty          = immedReplenQty;
                        immedReplenPutLocation  = immedDemandTmpWorkLine.WMSLocationId;
                    }
                }

                // Should not clean up temp work lines during immediate replenishment as wave demand could still run later.
                if (!immedDemandTmpWorkLine.ItemId)
                {
                    this.cleanUpDemandTmpWorkLine();
                }
            }

            // Set global waveID value so that it can be used in killFailedShipments method.
            waveId = parmWaveId;

            if (!immedDemandTmpWorkLine.ItemId)
            {
                this.killFailedShipments();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDemandReplenishmentWork</Name>
				<Source><![CDATA[
    private void createDemandReplenishmentWork(WHSWaveTable _replenWaveTable, WHSImmediateReplenishTemplateId  _immediateReplenTemplateId)
    {
        whsWaveLockManager.tryLockForWaveId(_replenWaveTable.WaveId, WHSParameters::find().WaveLockWait, true);

        // Create instance of work create class.
        var workCreate = new WHSWorkCreateReplenishment(null, '');
        workCreate.parmReleaseToWarehouseId(releaseToWarehouseId);
        workCreate.parmParmWaveId(_replenWaveTable.WaveId);
        workCreate.parmImmedDemandTmpWorkLine(immedDemandTmpWorkLine);
        workCreate.parmImmedReplenUnit(immedReplenUnit);

        _replenWaveTable.WorkBuildId = workCreate.parmWorkCreateId();
        _replenWaveTable.update();

        boolean createWork = this.createDemandReplenishmentPickLines(workCreate, _replenWaveTable);

        // Delete unneeded replenishment tmpWorkLines that are puts.
        this.deleteReplenPutTmpWorkLine(workCreate);

        this.createReplenishmentWork(workCreate, _replenWaveTable, createWork);

        workCreatedQty = workCreate.parmWorkCreatedQty();
        workCreate.populateReplenWorkQtyPerItemDimension(itemDimWorkCreatedQtyMap, itemDimReplenWorkMap);
                    
        if (createWork)
        {
            this.insertWaveDemandReplenWork(workCreate.parmWorkCreateId());
            if (!_immediateReplenTemplateId)
            {
                this.createWaveDemandTmpReplenWorkLinks(workCreateId);
            }
        }

        if (_immediateReplenTemplateId)
        {
            this.createImmediateDemandTmpWorkLinesAndImmedReplenWorkLinks(workCreate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckForExistingReplenishmentWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to check for existing replenishment work.
    /// </summary>
    /// <returns>true if existing replenishment work must be checked for; otherwise, false.</returns>
    protected boolean mustCheckForExistingReplenishmentWork()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckForExistingImmediateReplenishmentWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to check for existing immediate replenishment work.
    /// </summary>
    /// <returns>true if existing immediate replenishment work must be checked for; otherwise, false.</returns>
    protected boolean mustCheckForExistingImmediateReplenishmentWork()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateReplenWorkQtyPerItemDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates a map with the replenishment work created quantity per item and dimension set.
    /// Populates a map with the replenishment work ids per item and dimension set.
    /// </summary>
    /// <param name = "_itemDimWorkCreatedQtyMap">
    /// The current map, could have values from using existing replenishment.
    /// </param>
    /// <param name = "_itemDimReplenWorkMap">
    /// The map used for keeping values of newly created replenishment work ids.
    /// </param>
    private void populateReplenWorkQtyPerItemDimension(Map _itemDimWorkCreatedQtyMap, Map _itemDimReplenWorkMap)
    {
        WHSWorkTable replenWorkTable;
        
        while select WorkId from replenWorkTable
            where replenWorkTable.WorkBuildId   == this.workCreateId
            &&    replenWorkTable.WorkTransType == WHSWorkTransType::Replenishment
        {
            this.updateReplenWorkQtyPerItemDimensionMap(_itemDimWorkCreatedQtyMap, replenWorkTable.WorkId);
            this.updateReplenWorkIdsPerItemDimensionMap(_itemDimReplenWorkMap, replenWorkTable.WorkId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReplenWorkIdsPerItemDimensionMap</Name>
				<Source><![CDATA[
    private void updateReplenWorkIdsPerItemDimensionMap(Map _itemDimReplenWorkMap,  WHSWorkId _workId)
    {
        WHSWorkLine replenPutWorkLine = WHSWorkTable::getFirstPutWorkLine(_workId);
        WHSWorkLine replenPickWorkLine;
        
        while select ItemId, InventDimId, RecId from replenPickWorkLine
            where replenPickWorkLine.WorkId      == _workId
            &&    replenPickWorkLine.WorkType    == WHSWorkType::Pick
            &&    replenPickWorkLine.LineNum      < replenPutWorkLine.LineNum
        {
            this.increaseReplenWorkMap(_itemDimReplenWorkMap, replenPickWorkLine, replenPutWorkLine.WMSLocationId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReplenWorkQtyPerItemDimensionMap</Name>
				<Source><![CDATA[
    private void updateReplenWorkQtyPerItemDimensionMap(Map _itemDimWorkCreatedQtyMap, WHSWorkId _workId)
    {
        WHSWorkLine replenPutWorkLine = WHSWorkTable::getFirstPutWorkLine(_workId);
        WHSWorkLine replenSumWorkLine;
        
        while select sum(InventQtyWork) from replenSumWorkLine
            group by ItemId, InventDimId
            where replenSumWorkLine.WorkId      == _workId
            &&    replenSumWorkLine.WorkType    == WHSWorkType::Pick
            &&    replenSumWorkLine.LineNum      < replenPutWorkLine.LineNum
        {
            this.increaseItemDimMap(
                _itemDimWorkCreatedQtyMap,
                replenSumWorkLine.ItemId,
                replenSumWorkLine.InventDimId,
                replenPutWorkLine.WMSLocationId,
                replenSumWorkLine.InventQtyWork);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertWaveDemandReplenWork</Name>
				<Source><![CDATA[
    private void insertWaveDemandReplenWork(WHSWorkCreateId _demandReplenWorkCreateId)
    {
        WHSWaveDemandReplenishmentWork waveDemandReplenWork;

        waveDemandReplenWork.WaveId = parmWaveId;
        waveDemandReplenWork.WaveExecutionId = waveExecutionId;
        waveDemandReplenWork.DemandWorkCreateId = workCreateId;
        waveDemandReplenWork.ReplenWorkCreateId = _demandReplenWorkCreateId;

        if (!waveDemandReplenWork.validateWrite())
        {
            throw error(strFmt("@WAX:Error_MandatoryFieldsMissingOnTable", tablePName(WHSWaveDemandReplenishmentWork), waveDemandReplenWork.prefix()));
        }

        waveDemandReplenWork.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelUnnecessaryReplenWorkForWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancel demand replenishment work that was created, if there are no replenishment links remaining for it.
    /// Only cancel work if the corresponding flag is set on the replenishment template (Cancel replenishment if demand has been canceled).
    /// </summary>
    /// <param name="_waveId">Id of the wave being processed.</param>
    /// <param name="_waveExecutionId">Wave execution Id.</param>
    /// <param name="_demandWorkCreateId">Work creation Id for the demand work.</param>
    public static void cancelUnnecessaryReplenWorkForWave(WHSWaveId _waveId, WHSWaveExecutionID _waveExecutionId, WHSWorkCreateId _demandWorkCreateId)
    {
        WHSWaveDemandReplenishmentWork  waveDemandReplenWork;
        WHSReplenWorkLink               replenWorkLink;
        WHSWorkTable                    workTable;

        while select TableId from waveDemandReplenWork
            where waveDemandReplenWork.WaveId == _waveId
                && waveDemandReplenWork.WaveExecutionId == _waveExecutionId
                && waveDemandReplenWork.DemandWorkCreateId == _demandWorkCreateId
            join WorkId from workTable
                where workTable.WorkBuildId == waveDemandReplenWork.ReplenWorkCreateId
                    && workTable.CancelReplenWhenDemandCanceled == NoYes::Yes
                    && workTable.WorkTransType == WHSWorkTransType::Replenishment
                    && workTable.WorkStatus != WHSWorkStatus::Cancelled
                notexists join replenWorkLink
                    where replenWorkLink.ReplenWorkId == workTable.WorkId
                        && replenWorkLink.InventQty > 0
        {
            WHSWorkTable::cancelWork(workTable.WorkId, true, false, UnknownNoYes::Yes);
            WHSPostEngine::createWaveExecutionHistoryLine(_waveId, _waveExecutionId, strFmt("@WAX:ReplenWorkCancelledForFailedShipments", workTable.WorkId), false, null, _demandWorkCreateId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetReplenDemandValueIfNoReplenishmentIsNeeded</Name>
				<Source><![CDATA[
    private static void resetReplenDemandValueIfNoReplenishmentIsNeeded(WHSWorkLine _workLine)
    {        
        if (_workLine.ReplenDemand == NoYes::Yes)
        {
            ttsbegin;

            _workLine.selectForUpdate(true);

            _workLine.ReplenDemand = NoYes::No;
            _workLine.update();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateInventQtyMissingReplenLinkAndUpdateMap</Name>
				<Source><![CDATA[
    private InventQty calculateInventQtyMissingReplenLinkAndUpdateMap(WHSTmpWorkLine _tmpWorkLineForReplenWorkLink)
    {
        InventQty   initialDemandQty    = _tmpWorkLineForReplenWorkLink.InventQty - _tmpWorkLineForReplenWorkLink.AvailPhysical;
        str         mapKey = _tmpWorkLineForReplenWorkLink.ItemId + _tmpWorkLineForReplenWorkLink.InventDimId + _tmpWorkLineForReplenWorkLink.WMSLocationId;
        InventQty   existingReplenWorkLinkDemandQty;

        if (!itemDimReplenWorkMap.exists(mapKey))
        {
            return 0;
        }

        if (itemDimExistingReplenWorkLinkDemandQtyMap.exists(mapKey))
        {
            existingReplenWorkLinkDemandQty = itemDimExistingReplenWorkLinkDemandQtyMap.lookup(mapKey);
            if (existingReplenWorkLinkDemandQty < 0)
            {
                // should never happen, but added as a safeguard.
                existingReplenWorkLinkDemandQty = 0;
            }
        }

        InventQty qtyToDecrease = existingReplenWorkLinkDemandQty < initialDemandQty? existingReplenWorkLinkDemandQty : initialDemandQty;
        InventQty inventQtyMissingReplenLinkOrig = max(0, initialDemandQty - existingReplenWorkLinkDemandQty);

        this.decreaseExistingReplenWorkLinkDemandQtyMap(itemDimExistingReplenWorkLinkDemandQtyMap, _tmpWorkLineForReplenWorkLink.ItemId, _tmpWorkLineForReplenWorkLink.InventDimId, _tmpWorkLineForReplenWorkLink.WMSLocationId, qtyToDecrease);

        WHSInstrumentationWaveReplenishmentPerformanceTask::logInventQtyMissingReplenLink(_tmpWorkLineForReplenWorkLink, inventQtyMissingReplenLinkOrig);

        return inventQtyMissingReplenLinkOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWaveDemandTmpReplenWorkLinks</Name>
				<Source><![CDATA[
    private void createWaveDemandTmpReplenWorkLinks(WHSWorkBuildId _workBuildId)
    {
        WHSTmpWorkLine tmpWorkLineForReplenWorkLink;

        // Loop over pick lines that have replenishment demand
        while select tmpWorkLineForReplenWorkLink
            order by tmpWorkLineForReplenWorkLink.WorkId asc, tmpWorkLineForReplenWorkLink.LineNum asc  // forces an order in which lines were created to increase a chance of full qty match with replenishment (these columns are part of clustered index so it is the most likely order anyway).
            where tmpWorkLineForReplenWorkLink.WorkCreateId                        == _workBuildId
                  && tmpWorkLineForReplenWorkLink.WorkType                         == WHSWorkType::Pick
                  && tmpWorkLineForReplenWorkLink.ReplenDemand                     == NoYes::Yes
                  && tmpWorkLineForReplenWorkLink.ImmediateReplenishmentUnitId == '' // Currently processing wave demand, immediate replenishment lines should be skipped.
        {
            if (this.skipTmpDemandLineWithEmptyLocationId(tmpWorkLineForReplenWorkLink))
            {
                continue;
            }

            InventQty inventQtyMissingReplenLinkOrig = this.calculateInventQtyMissingReplenLinkAndUpdateMap(tmpWorkLineForReplenWorkLink);
            if (inventQtyMissingReplenLinkOrig <= 0)
            {
                continue;
            }

            InventQty inventQtyMissingReplenLinkRunningTotal = this.createTmpReplenLinksToNewReplenishments(tmpWorkLineForReplenWorkLink, inventQtyMissingReplenLinkOrig);

            if (inventQtyMissingReplenLinkRunningTotal > 0)
            {
                // disabled by default toggle, as this is to be able to investigate issues with replenishment.
                // the toggle and WHSTmpReplenishmentWorkLine should be removed once they are resolved. Label is also too technical to have widely shown.
                if (WHSInstrumentationReplenishmentWorkLinkToggle::instance().isEnabled())
                {
                    WhsWorkCreateReplenishment::logWaveReplenishmentWorkRecords(_workBuildId, tmpWorkLineForReplenWorkLink.WorkId, itemDimReplenWorkMap);
                    throw error(strFmt("@WAX:DemandQtyInsufficientReplenLinkQtyErrorFull", tmpWorkLineForReplenWorkLink.ItemId, tmpWorkLineForReplenWorkLink.InventDimId, _workBuildId, tmpWorkLineForReplenWorkLink.WorkId, inventQtyMissingReplenLinkOrig, inventQtyMissingReplenLinkOrig - inventQtyMissingReplenLinkRunningTotal));
                }
                else 
                {
                    throw error(strFmt("@WAX:DemandQtyInsufficientReplenLinkQtyError", tmpWorkLineForReplenWorkLink.ItemId, tmpWorkLineForReplenWorkLink.InventDimId, inventQtyMissingReplenLinkOrig, inventQtyMissingReplenLinkOrig - inventQtyMissingReplenLinkRunningTotal));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipTmpDemandLineWithEmptyLocationId</Name>
				<Source><![CDATA[
    private boolean skipTmpDemandLineWithEmptyLocationId(WHSTmpWorkLine _demandLine)
    {
        return _demandLine.WMSLocationId == ''
            && (this.isReplenishmentLocationDirectiveFailureEnabled()
            || WHSLocDirFailure::find(_demandLine.WorkTransType).LocDirFailWork);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createImmediateDemandTmpWorkLinesAndImmedReplenWorkLinks</Name>
				<Source><![CDATA[
    private void createImmediateDemandTmpWorkLinesAndImmedReplenWorkLinks(WhsWorkCreate _workCreate)
    {
        using (var activityContext = this.instrumentationLogger().replenishmentActivities().findReplenishmentPutLocation())
        {
            WHSWorkTable        replenWorkTable;
            WHSWorkLine         replenWorkLine;
            WHSReplenWorkLink   replenWorkLink;
            WHSWorkId           prevWorkId;
            WMSLocationId       replenLocationId;
            LineNum             firstPutLineNum;
            Qty                 demandQtyToReplenish = immedReplenQty;
            Map                 tmpDemandWorkLineMap = new Map(Types::String, Types::Record);
            Map                 replenInventQtyMap = new Map(Types::String, Types::Real);
            int                 replenWorkLineEvaluated;

            // Going through the initial pick lines of the created replenishment work, to build up temporary demand work lines and replenishment work links
            // for the quantity that was needed for the demand.
            while select WorkType, WorkId, LineNum, InventQtyWork, WMSLocationId from replenWorkLine
                order by WorkId asc, WorkType desc, LineNum asc
                where (replenWorkLine.WorkType == WHSWorkType::Pick
                ||     replenWorkLine.WorkType == WHSWorkType::Put)
                exists join replenWorkTable
                    where replenWorkTable.WorkBuildId   == _workCreate.parmWorkCreateId()
                    &&    replenWorkTable.WorkTransType == WHSWorkTransType::Replenishment
                    &&    replenWorkTable.WorkId        == replenWorkLine.WorkId
                notexists join replenWorkLink
                    where replenWorkLink.ReplenLineNum  == replenWorkLine.LineNum
                    &&    replenWorkLink.ReplenWorkId   == replenWorkLine.WorkId
                    &&    replenWorkLink.InventQty      != 0
            {
                ++replenWorkLineEvaluated;

                if (demandQtyToReplenish == 0)
                {
                    break;
                }

                // Get replenishment work final put location and first put line number.
                if (replenWorkLine.WorkType == WHSWorkType::Put) 
                {        
                    replenLocationId = replenWorkLine.WMSLocationId;

                    if (replenWorkLine.WorkId != prevWorkId)
                    {
                        firstPutLineNum = replenWorkLine.LineNum;
                        prevWorkId = replenWorkLine.WorkId;
                    }
                }
                else if (replenWorkLine.LineNum < firstPutLineNum)
                {
                    // Only need to look at initial picks.
                    Qty minQty = min(demandQtyToReplenish, replenWorkLine.InventQtyWork);

                    this.createOrUpdateTempReplenWorkLinks(minQty, replenWorkLine.WorkId, replenWorkLine.LineNum);

                    WHSTmpWorkLine tmpDemandWorkLine = this.createImmediateDemandTmpWorkLineFromReplenWorkLine(replenLocationId, replenWorkLine.WorkId, minQty);

                    if (tmpDemandWorkLineMap.exists(tmpDemandWorkLine.WMSLocationId))
                    {
                        WHSTmpWorkLine existingTmpDemandWorkLine = tmpDemandWorkLineMap.lookup(tmpDemandWorkLine.WMSLocationId);
                        existingTmpDemandWorkLine.DirectiveQty += tmpDemandWorkLine.DirectiveQty;
                        existingTmpDemandWorkLine.InventQty += tmpDemandWorkLine.InventQty;
                        tmpDemandWorkLineMap.insert(tmpDemandWorkLine.WMSLocationId, existingTmpDemandWorkLine);

                        InventQty replenInventQty = replenInventQtyMap.lookup(tmpDemandWorkLine.WMSLocationId);
                        replenInventQty += replenWorkLine.InventQtyWork;
                        replenInventQtyMap.insert(tmpDemandWorkLine.WMSLocationId, replenInventQty);
                    }
                    else
                    {
                        tmpDemandWorkLine.initFromInventDim(WHSWorkLine::find(replenWorkLine.WorkId, replenWorkLine.LineNum).inventDim());
                        tmpDemandWorkLine.setLineNum();
                        tmpDemandWorkLineMap.insert(tmpDemandWorkLine.WMSLocationId, tmpDemandWorkLine);

                        replenInventQtyMap.insert(tmpDemandWorkLine.WMSLocationId, replenWorkLine.InventQtyWork);
                    }

                    demandQtyToReplenish -= minQty;
                }
            }
            
            this.instrumentationLogger().replenishmentActivities().logEvaluatedReplenWorkLines(replenWorkLineEvaluated);

            this.insertDemandTmpWorkLines(tmpDemandWorkLineMap, replenInventQtyMap);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDemandTmpWorkLines</Name>
				<Source><![CDATA[
    private void insertDemandTmpWorkLines(Map _demandTmpWorkLines, Map _replenInventQtyMap)
    {
        MapEnumerator   demandTmpWorkLinesMapEnumerator = _demandTmpWorkLines.getEnumerator();
        UserConnection  conn = new UserConnection();

        try
        {
            while (demandTmpWorkLinesMapEnumerator.moveNext())
            {
                WHSTmpWorkLine newTmpWorkLine  = demandTmpWorkLinesMapEnumerator.currentValue();

                if (newTmpWorkLine.InventQty == _replenInventQtyMap.lookup(demandTmpWorkLinesMapEnumerator.currentKey())
                    && newTmpWorkLine.InventQty < immedReplenQty)
                {
                    InventQty originInventQty = newTmpWorkLine.InventQty;
                    WMSLocation location = WMSLocation::find(newTmpWorkLine.WMSLocationId, newTmpWorkLine.InventLocationId);
                    newTmpWorkLine.InventQty = WHSReplenQtyCalculator::calculateAvailableInventQty(newTmpWorkLine.WorkCreateId, newTmpWorkLine.InventDimId, location, newTmpWorkLine.ItemId);

                    newTmpWorkLine.InventQty = min(immedReplenQty, newTmpWorkLine.InventQty);
                    
                    newTmpWorkLine.AvailPhysical = newTmpWorkLine.InventQty - originInventQty;

                    const boolean applyRounding = false;
                    EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();
                    Qty convertedQty = releasedProductUnitConverter.convertGivenUnitSymbols(newTmpWorkLine.InventQty,
                                                                                WHSCatchWeightHelper::inventHandlingUnitId(newTmpWorkLine.ItemId),
                                                                                newTmpWorkLine.DirectiveUOM,
                                                                                NoYes::No,
                                                                                newTmpWorkLine.ItemId,
                                                                                newTmpWorkLine.InventDimId,
                                                                                applyRounding);
                    newTmpWorkLine.DirectiveQty = convertedQty;
                }

                [newTmpWorkLine.HighestQty,
                 newTmpWorkLine.HighestUnitId] = WHSInventTable::getHighestUnitQtyByUOMSeqGroup(newTmpWorkLine.ItemId, newTmpWorkLine.DirectiveQty, newTmpWorkLine.DirectiveUOM, newTmpWorkLine.InventDimId);

                this.insertTmpWorkLine(newTmpWorkLine, conn);
            }
        }
        finally
        {
            conn.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createImmediateDemandTmpWorkLineFromReplenWorkLine</Name>
				<Source><![CDATA[
    private WHSTmpWorkLine createImmediateDemandTmpWorkLineFromReplenWorkLine(
        WMSLocationId   _replenLocationId,
        WHSWorkId       _replenWorkId,
        Qty             _replenQty)
    {
        WHSTmpWorkLine newTmpWorkLine;

        buf2Buf(immedDemandTmpWorkLine, newTmpWorkLine);

        const boolean applyRounding = false;
        
        EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();
        Qty convertedQty = releasedProductUnitConverter.convertGivenUnitSymbols(_replenQty,
                                                                                WHSCatchWeightHelper::inventHandlingUnitId(newTmpWorkLine.ItemId),
                                                                                newTmpWorkLine.DirectiveUOM,
                                                                                NoYes::No,
                                                                                newTmpWorkLine.ItemId,
                                                                                newTmpWorkLine.InventDimId,
                                                                                applyRounding);

        newTmpWorkLine.DirectiveQty         = convertedQty;
        newTmpWorkLine.InventQty            = _replenQty;
        newTmpWorkLine.InventLocationId     =  WHSWorkTable::find(_replenWorkId).InventLocationId;
        newTmpWorkLine.ReleaseToWarehouseId = releaseToWarehouseId;

        newTmpWorkLine.setWMSLocation(_replenLocationId, newTmpWorkLine.InventLocationId);
        newTmpWorkLine.setPackQtyCompare();

        return newTmpWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateWHSWaveLockManager</Name>
				<Source><![CDATA[
    private void instantiateWHSWaveLockManager()
    {
        this.disposeWhsWaveLockManager();
        whsWaveLockManager = WHSWaveLockManager::newStandard();
        mustDisposeWhsLockManager = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>disposeWhsWaveLockManager</Name>
				<Source><![CDATA[
    private void disposeWhsWaveLockManager()
    {
        if (mustDisposeWhsLockManager && whsWaveLockManager)
        {
            whsWaveLockManager.dispose();
            mustDisposeWhsLockManager = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>successfulReplenPutCreated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if replenishment successfully created put TmpWorkLines.
    /// </summary>
    /// <returns>
    /// true if the a replenishment put TmpWorkLine is found; otherwise, false.
    /// </returns>
    protected boolean successfulReplenPutCreated()
    {
        WHSTmpWorkLine                  replenPutTmpWorkLine;

        select firstonly RecId from replenPutTmpWorkLine
            where replenPutTmpWorkLine.WorkCreateId  == workCreateId
            &&    replenPutTmpWorkLine.WorkType      == WHSWorkType::Put
            &&    replenPutTmpWorkLine.WorkTransType == WHSWorkTransType::Replenishment;

        return replenPutTmpWorkLine.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructor method for the class instances.
    /// </summary>
    /// <param name="_common">
    /// Common record to be used to construct instance.
    /// </param>
    /// <param name="_workCreateId">
    /// Work creation id to be used to construct instance.
    /// </param>
    /// <returns>
    /// The <c>WHSWorkCreateReplenishment</c> instance.
    /// </returns>
    static WHSWorkCreateReplenishment construct(Common _common, WHSWorkCreateId _workCreateId = '')
    {
        WHSWorkCreateReplenishment   workCreateWave;

        workCreateWave = new WHSWorkCreateReplenishment(_common, _workCreateId);

        return workCreateWave;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReplenLinkRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates replenishment work link records.
    /// </summary>
    /// <param name="_workBuildId">
    /// Work build id of the demand replenishment lines.
    /// </param>
    public static void createReplenLinkRecords(WHSWorkBuildId _workBuildId)
    {
        WHSWorkTable   workTable;
        WHSWorkLine    workLine;

        container workStatusesForReplenishment = WhsWorkCreateReplenishment::workStatusesForReplenishment();

        // Loop over pick lines that have replenishment demand.
        while select TableId from workTable
            join workLine
            order by workLine.WorkId asc, workLine.LineNum asc  // forces an order in which lines were created to increase a chance of full qty match with replenishment (these columns are part of clustered index so it is the most likely order anyway).
            where workTable.WorkId           == workLine.WorkId                  &&
                  workTable.WorkTransType    != WHSWorkTransType::Replenishment  &&
                  workTable.WorkBuildId      == _workBuildId                     &&
                  workTable.WorkStatus       in workStatusesForReplenishment     &&
                  workLine.WorkType          == WHSWorkType::Pick                &&
                  workLine.ReplenDemand      == NoYes::Yes
        {
            InventQty inventQtyMissingReplenLinkOrig = WhsWorkCreateReplenishment::getWorkLineQtyPendingReplenishment(workLine);
            if (inventQtyMissingReplenLinkOrig <= 0)
            {
                WhsWorkCreateReplenishment::resetReplenDemandValueIfNoReplenishmentIsNeeded(workLine);

                continue;
            }

              InventQty inventQtyMissingReplenLinkRunningTotal = inventQtyMissingReplenLinkOrig;

            if (!WhsWorkCreateReplenishment::createReplenLinkToSingleExistingReplenishmentCoveringFullQty(_workBuildId, workLine, inventQtyMissingReplenLinkRunningTotal))
            {
                inventQtyMissingReplenLinkRunningTotal = WhsWorkCreateReplenishment::createReplenLinksForPartialQtyToExistingReplenishments(_workBuildId, workLine, inventQtyMissingReplenLinkRunningTotal);

                if (inventQtyMissingReplenLinkRunningTotal)
                {
                    inventQtyMissingReplenLinkRunningTotal = WhsWorkCreateReplenishment::createReplenLinksToNewReplenishments(_workBuildId, workLine, inventQtyMissingReplenLinkRunningTotal);

                    if (inventQtyMissingReplenLinkRunningTotal > 0)
                    {
                        // disabled by default toggle, as this is to be able to investigate issues with replenishment.
                        // the toggle and WHSTmpReplenishmentWorkLink should be removed once they are resolved. Label is also too technical to have widely shown.
                        if (WHSInstrumentationReplenishmentWorkLinkToggle::instance().isEnabled())
                        {
                            WhsWorkCreateReplenishment::logWaveReplenishmentWorkRecords(_workBuildId, workLine.WorkId);
                            throw error(strFmt("@WAX:DemandQtyInsufficientReplenLinkQtyErrorFull", workLine.ItemId, workLine.InventDimId, _workBuildId, workLine.WorkId, inventQtyMissingReplenLinkOrig, inventQtyMissingReplenLinkOrig - inventQtyMissingReplenLinkRunningTotal));
                        }
                        else
                        {
                            throw error(strFmt("@WAX:DemandQtyInsufficientReplenLinkQtyError", workLine.ItemId, workLine.InventDimId, inventQtyMissingReplenLinkOrig, inventQtyMissingReplenLinkOrig - inventQtyMissingReplenLinkRunningTotal));
                        }
                    }
                }
            }
        }
        
        // Since permanent replenishment/demand links have been created delete the temporary links.
        WhsWorkCreateReplenishment::cleanupTempReplenWorkLinks(_workBuildId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>workStatusesForReplenishment</Name>
				<Source><![CDATA[
    public static container workStatusesForReplenishment()
    {
        return [WHSWorkStatus::Open];
    }

]]></Source>
			</Method>
			<Method>
				<Name>logWaveReplenishmentWorkRecords</Name>
				<Source><![CDATA[
    private static void logWaveReplenishmentWorkRecords(WHSWorkBuildId _workBuildId, WHSWorkId _workId, Map _itemDimReplenWorkMap = null)
    {
        UserConnection conn = new UserConnection();
        try
        {
            conn.ttsbegin();

            WHSTmpReplenishmentWorkLink::insertFromReplenWorkLink(_workBuildId, _workId, conn);

            WHSWaveReplenWorkLineLog::insertFromWorkLines(_workBuildId, _workId, conn);

            WHSWaveReplenTmpWorkLineLog::insertFromTmpWorkLines(_workBuildId, _workId, conn);

            if (_itemDimReplenWorkMap)
            {
                WHSItemDimReplenWorkMapLog::insertFromMap(_itemDimReplenWorkMap, conn);
            }

            conn.ttscommit();
        }
        finally 
        {
            conn.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupTempReplenWorkLinks</Name>
				<Source><![CDATA[
    protected final static void cleanupTempReplenWorkLinks(WHSWorkBuildId _workBuildId)
    {
        if (_workBuildId)
        {
            WHSReplenWorkLink replenWorkLinkDel;
            delete_from replenWorkLinkDel
                where replenWorkLinkDel.WorkBuildId == _workBuildId;
        }
        else
        {
            throw error("@WAX:CriticalError_WorkBuildIdBlank_cleanupTmpReplenWorkLinks");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkLineQtyPendingReplenishment</Name>
				<Source><![CDATA[
    protected final static InventQty getWorkLineQtyPendingReplenishment(WHSWorkLine _workLine)
    {
        WHSWorkInventTrans workInventTrans;

        // Need to account for WHS inventory transactions for at least 2 reasons:
        // 1) if we have the same work line for both - available on-hand and waiting replenishment quantities - we will have some WIT corresponding to on-hand immediately.
        // 2) if we complete replenishment work covering part of the quantity before we create a demand work line.
        select sum(Qty) from workInventTrans
            where workInventTrans.WorkId    == _workLine.WorkId   &&
                  workInventTrans.LineNum   == _workLine.LineNum;

        return _workLine.InventQtyWork - workInventTrans.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReplenLinkToSingleExistingReplenishmentCoveringFullQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Tries to create a permanent replenishment link to the existing replenishment (i.e. replenishment not created
    /// as part of this wave processing specifically for our demand) which covers demand quantity completely.
    /// </summary>
    /// <param name = "_workBuildId">Work build id of the current wave process.</param>
    /// <param name = "_demandPickWorkLine">A demand work pick line.</param>
    /// <param name = "_inventQtyMissingReplenLink">A quantity we try to consume from replenishment.</param>
    /// <returns>true if we successfully found a replenishment which covers full required quantity and created a link to it; otherwise, false.</returns>
    /// <remarks>
    /// We sort by WorkId and LineNum to get replenishment lines in the order of their creation
    /// because with higher chance they will correspond to demand lines we are looping over and
    /// we also want to consume from earlier replenishment (with higher chance).
    /// </remarks>
    protected final static boolean createReplenLinkToSingleExistingReplenishmentCoveringFullQty(
        WHSWorkBuildId  _workBuildId,
        WHSWorkLine     _demandPickWorkLine,
        InventQty       _inventQtyMissingReplenLink)
    {
        WHSWorkLine             replenPutLine;
        WHSWorkLine             replenPickLine;
        WHSReplenWorkLink       replenWorkLinkTemp;

        while select LineNum, WorkId, InventQtyWork from replenPickLine
            order by replenPickLine.WorkId asc, replenPickLine.LineNum asc // forces an order in which lines were created to increase a chance of full qty match with replenishment (these columns are part of clustered index so it is the most likely order anyway).
            where replenPickLine.ItemId           == _demandPickWorkLine.ItemId         &&
                    replenPickLine.InventDimId    == _demandPickWorkLine.InventDimId    &&
                    replenPickLine.WorkType       == WHSWorkType::Pick
            exists join InventQty from replenWorkLinkTemp
                where replenWorkLinkTemp.ReplenWorkId == replenPickLine.WorkId          &&
                    replenWorkLinkTemp.ReplenLineNum  == replenPickLine.LineNum         &&
                    replenWorkLinkTemp.InventQty      >= _inventQtyMissingReplenLink    &&
                    replenWorkLinkTemp.DemandWorkId   == ''                             &&
                    replenWorkLinkTemp.DemandLineNum  == 0                              &&
                    replenWorkLinkTemp.WorkBuildId    == _workBuildId
            exists join replenPutLine
                where replenPutLine.WorkId        == replenPickLine.WorkId              &&
                    replenPutLine.wmsLocationId   == _demandPickWorkLine.wmsLocationId  &&
                    replenPutLine.WorkType        == WHSWorkType::Put
        {
            if (replenPickLine.getInventQtyAvailableForReplenishment() >= _inventQtyMissingReplenLink)
            {
                WhsWorkCreateReplenishment::createPermanentReplenLinkFromTempLink(_workBuildId, _demandPickWorkLine, replenPickLine, _inventQtyMissingReplenLink);
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReplenLinksForPartialQtyToExistingReplenishments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Tries to create permanent replenishment links to potentially many existing replenishments (i.e. replenishments not created
    /// as part of this wave processing specifically for our demand) each covering demand quantity partially.
    /// </summary>
    /// <param name = "_workBuildId">Work build id of the current wave process.</param>
    /// <param name = "_demandPickWorkLine">A demand work pick line.</param>
    /// <param name = "_inventQtyMissingReplenLink">A quantity we try to consume from replenishment.</param>
    /// <returns>Remaining not covered demand quantity for which we still need to create permanent replenishment links.</returns>
    protected final static InventQty createReplenLinksForPartialQtyToExistingReplenishments(
        WHSWorkBuildId  _workBuildId,
        WHSWorkLine     _demandPickWorkLine,
        InventQty       _inventQtyMissingReplenLink)
    {
        InventQty runningInventQtyMissingReplenLink = _inventQtyMissingReplenLink;

        WHSWorkLine             replenPutLine;
        WHSWorkLine             replenPickLine;
        WHSReplenWorkLink       replenWorkLinkTemp;

        // Here we still try to consume existing replenishment, but this time, since we did not find an existing replenishment which covers demand completely,
        // we try to see if several replenishments would cover our demand in parts.
        while select LineNum, WorkId, InventQtyWork from replenPickLine
            order by replenPickLine.WorkId asc, replenPickLine.LineNum asc // sort in this way to ensure we consume first from potentially earlier replenishment.
            where replenPickLine.ItemId           == _demandPickWorkLine.ItemId          &&
                    replenPickLine.InventDimId    == _demandPickWorkLine.InventDimId     &&
                    replenPickLine.WorkType       == WHSWorkType::Pick
            join InventQty from replenWorkLinkTemp
                where replenWorkLinkTemp.ReplenWorkId == replenPickLine.WorkId    &&
                    replenWorkLinkTemp.ReplenLineNum  == replenPickLine.LineNum   &&
                    replenWorkLinkTemp.DemandWorkId   == ''                       &&
                    replenWorkLinkTemp.DemandLineNum  == 0                        &&
                    replenWorkLinkTemp.InventQty      >= 0                        &&
                    replenWorkLinkTemp.WorkBuildId    == _workBuildId   // extra guard - join conditions above constitute a clustered index key already.
            exists join replenPutLine
                where replenPutLine.WorkId        == replenPickLine.WorkId              &&
                    replenPutLine.wmsLocationId   == _demandPickWorkLine.wmsLocationId  &&
                    replenPutLine.WorkType        == WHSWorkType::Put
        {
            InventQty replenLinkQty = min(
                runningInventQtyMissingReplenLink,
                replenWorkLinkTemp.InventQty,
                replenPickLine.getInventQtyAvailableForReplenishment());  // extra guard - normally replenishment pick qty is never less than what we expect to consume from that replenishment.

            WhsWorkCreateReplenishment::createPermanentReplenLinkFromTempLink(_workBuildId, _demandPickWorkLine, replenPickLine, replenLinkQty);

            runningInventQtyMissingReplenLink -= replenLinkQty;

            if (!runningInventQtyMissingReplenLink)
            {
                break;
            }
        }

        return runningInventQtyMissingReplenLink;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPermanentReplenLinkFromTempLink</Name>
				<Source><![CDATA[
    private static void createPermanentReplenLinkFromTempLink(
        WHSWorkBuildId  _workBuildId,
        WHSWorkLine     _demandPickWorkLine,
        WHSWorkLine     _replenPickLine,
        InventQty       _replenLinkQty)
    {
        if (_replenLinkQty)
        {
            // extra guard - normally fields below those should not be empty.
            if (   !_demandPickWorkLine.WorkId
                || !_demandPickWorkLine.LineNum
                || !_replenPickLine.WorkId
                || !_replenPickLine.LineNum)
            {
                throw error(Error::wrongUseOfFunction(funcName()));
            }

            WHSReplenWorkLink replenWorkLink;

            select firstOnly forUpdate replenWorkLink
                where replenWorkLink.ReplenWorkId   == _replenPickLine.WorkId
                    && replenWorkLink.ReplenLineNum == _replenPickLine.LineNum
                    && replenWorkLink.DemandWorkId  == ''
                    && replenWorkLink.DemandLineNum == 0
                    && replenWorkLink.WorkBuildId   == _workBuildId; // extra guard - this is not necessary since the above conditions constitute a full clustered index of the table.

            replenWorkLink.InventQty -= _replenLinkQty;
            replenWorkLink.update();

            WHSReplenWorkLink::insertReplenWorkLink(_replenLinkQty,
                                                    _replenPickLine.WorkId,
                                                    _replenPickLine.LineNum,
                                                    _demandPickWorkLine.WorkId,
                                                    _demandPickWorkLine.LineNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReplenLinksToNewReplenishments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Tries to create permanent replenishment links to potentially many new replenishments (created as part of current wave 
    /// processing specifically for our demand) each covering demand quantity partially (or a single new replenishment
    /// covering demand quantity completely).
    /// </summary>
    /// <param name = "_workBuildId">Work build id of the current wave process.</param>
    /// <param name = "_demandPickWorkLine">A demand work pick line.</param>
    /// <param name = "_inventQtyMissingReplenLink">A quantity we try to consume from replenishment.</param>
    /// <returns>Remaining not covered demand quantity for which we still need to create permanent replenishment links.</returns>
    protected final static InventQty createReplenLinksToNewReplenishments(
        WHSWorkBuildId  _workBuildId,
        WHSWorkLine     _demandPickWorkLine,
        InventQty       _inventQtyMissingReplenLink)
    {
        InventQty runningInventQtyMissingReplenLink = _inventQtyMissingReplenLink;

        WHSWorkId       prevWorkId;
        WHSWorkLine     replenPickLine;
       
        SysDaQueryObject query = WhsWorkCreateReplenishment::createReplenLinkPickLineQuery(replenPickLine, _workBuildId, _demandPickWorkLine);
        SysDaSearchObject searchObject = new SysDaSearchObject(query);
        SysDaSearchStatement searchStatement = new SysDaSearchStatement();
        while (searchStatement.findNext(searchObject))
        {
            // there can be more than 1 replenishment pick line. By below check we try to avoid staging replenishment pick lines to avoid double count.
            if (replenPickLine.WorkType == WHSWorkType::Put || replenPickLine.WorkId == prevWorkId)
            {
                prevWorkId = replenPickLine.WorkId;
                continue;
            }

            InventQty availReplenQty = replenPickLine.getInventQtyAvailableForReplenishment();

            if (availReplenQty)
            {
                InventQty replenLinkQty = min(runningInventQtyMissingReplenLink, availReplenQty);

                WHSReplenWorkLink::insertReplenWorkLink(replenLinkQty,
                                                        replenPickLine.WorkId,
                                                        replenPickLine.LineNum,
                                                        _demandPickWorkLine.WorkId,
                                                        _demandPickWorkLine.LineNum);

                runningInventQtyMissingReplenLink -= replenLinkQty;

                if (!runningInventQtyMissingReplenLink)
                {
                    break;
                }
            }
        }

        return runningInventQtyMissingReplenLink;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReplenLinkPickLineQuery</Name>
				<Source><![CDATA[
    private static SysDaQueryObject createReplenLinkPickLineQuery(WHSWorkLine _replenPickLine, WHSWorkBuildId  _workBuildId, WHSWorkLine _demandPickWorkLine)
    {
        SysDaQueryObject queryObj = new SysDaQueryObject(_replenPickLine);
        queryObj.projection()
                .add(fieldStr(WHSWorkLine, WorkId))
                .add(fieldStr(WHSWorkLine, LineNum))
                .add(fieldStr(WHSWorkLine, InventQtyWork))
                .add(fieldStr(WHSWorkLine, WorkType));
        queryObj.orderByClause()
                .add(fieldStr(WHSWorkLine, WorkId))
                .add(fieldStr(WHSWorkLine, LineNum));
        
            
        SysDaQueryExpression replenPickLineClause = new SysDaEqualsExpression(
                new SysDaFieldExpression(_replenPickLine, fieldStr(WHSWorkLine, ItemId)),
                new SysDaValueExpression(_demandPickWorkLine.ItemId)
            )
            .and(
                new SysDaEqualsExpression(
                    new SysDaFieldExpression(_replenPickLine, fieldStr(WHSWorkLine, InventDimId)),
                    new SysDaValueExpression(_demandPickWorkLine.InventDimId)
                )
            )
            .and(
                new SysDaEqualsExpression(
                    new SysDaFieldExpression(_replenPickLine, fieldStr(WHSWorkLine, WorkType)),
                    new SysDaValueExpression(WHSWorkType::Pick)
                )
                .or(
                    new SysDaEqualsExpression(
                        new SysDaFieldExpression(_replenPickLine, fieldStr(WHSWorkLine, WorkType)),
                        new SysDaValueExpression(WHSWorkType::Put)
                    )
                )
            );

        queryObj.whereClause(replenPickLineClause);

        WHSWorkTable    replenWork;
        WHSWorkLine     replenPutLine;
        WHSWaveTable waveTable;
      
        SysDaQueryObject filteredQueryObj = WhsWorkCreateReplenishment::addReplenWorkQueryClause(queryObj, _replenPickLine, replenWork);
        filteredQueryObj = WhsWorkCreateReplenishment::addReplenPutLineClause(filteredQueryObj, replenWork, replenPutLine, _demandPickWorkLine.WMSLocationId);
        filteredQueryObj = WhsWorkCreateReplenishment::addWaveTableClause(filteredQueryObj, waveTable, replenWork);
        WhsWorkCreateReplenishment::addDemandWaveClause(filteredQueryObj, waveTable, _workBuildId);

        return queryObj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDemandWaveClause</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute, Wrappable(true), Replaceable(true)]
    protected static SysDaQueryObject addDemandWaveClause(SysDaQueryObject mainQueryObj, WHSWaveTable _waveTable, WHSWorkBuildId _workBuildId)
    {
        WHSWaveTable demandWaveTable;

        SysDaQueryObject demandWaveQueryObject = new SysDaQueryObject(demandWaveTable);
        demandWaveQueryObject.whereClause(
                new SysDaEqualsExpression(
                        new SysDaFieldExpression(_waveTable, fieldStr(WHSWaveTable, DemandWaveId)),
                        new SysDaFieldExpression(demandWaveTable, fieldStr(WHSWaveTable, WaveId))
                )
                .and(
                    new SysDaEqualsExpression(
                            new SysDaValueExpression(_workBuildId),
                            new SysDaFieldExpression(demandWaveTable, fieldStr(WHSWaveTable, WorkBuildId))
                    )
                )
            );

        return mainQueryObj.joinClause(SysDaJoinKind::ExistsJoin, demandWaveQueryObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addWaveTableClause</Name>
				<Source><![CDATA[
    private static SysDaQueryObject addWaveTableClause(SysDaQueryObject mainQueryObj, WHSWaveTable _waveTable, WHSWorkTable _replenWork)
    {
        SysDaQueryObject waveQueryObject = new SysDaQueryObject(_waveTable);
        waveQueryObject.whereClause(
                new SysDaEqualsExpression(
                    new SysDaFieldExpression(_waveTable, fieldStr(WHSWaveTable, WaveId)),
                    new SysDaFieldExpression(_replenWork, fieldStr(WHSWorkTable, WaveId))
                )
            );

        return mainQueryObj.joinClause(SysDaJoinKind::ExistsJoin, waveQueryObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addReplenPutLineClause</Name>
				<Source><![CDATA[
    private static SysDaQueryObject addReplenPutLineClause(
        SysDaQueryObject mainQueryObj, 
        WHSWorkTable _replenWork, 
        WHSWorkLine _replenPutLine,
        WMSLocationId _wmsLocationId)
    {
        SysDaQueryObject replenPutLineQueryObject = new SysDaQueryObject(_replenPutLine);

        replenPutLineQueryObject.whereClause(
                new SysDaEqualsExpression(
                    new SysDaFieldExpression(_replenPutLine, fieldStr(WHSWorkLine, WorkId)),
                    new SysDaFieldExpression(_replenWork, fieldStr(WHSWorkTable, WorkId))
                )
                .and(
                    new SysDaEqualsExpression(
                        new SysDaFieldExpression(_replenPutLine, fieldStr(WHSWorkLine, WMSLocationId)),
                        new SysDaValueExpression(_wmsLocationId)
                    )
                ).
                and(
                     new SysDaEqualsExpression(
                        new SysDaFieldExpression(_replenPutLine, fieldStr(WHSWorkLine, WorkType)),
                        new SysDaValueExpression(WHSWorkType::Put)
                    )
                )
            );

        return mainQueryObj.joinClause(SysDaJoinKind::ExistsJoin, replenPutLineQueryObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addReplenWorkQueryClause</Name>
				<Source><![CDATA[
    private static SysDaQueryObject addReplenWorkQueryClause(SysDaQueryObject mainQueryObj, WHSWorkLine _replenPickLine, WHSWorkTable _replenWork)
    {
        SysDaQueryObject replenWorkQueryObject = new SysDaQueryObject(_replenWork);
        replenWorkQueryObject.whereClause(
                new SysDaEqualsExpression(
                    new SysDaFieldExpression(_replenWork, fieldStr(WHSWorkTable, WorkId)),
                    new SysDaFieldExpression(_replenPickLine, fieldStr(WHSWorkLine, WorkId))
                )
                .and(
                    new SysDaEqualsExpression(
                        new SysDaFieldExpression(_replenWork, fieldStr(WHSWorkTable, WorkStatus)),
                        new SysDaValueExpression(WHSWorkStatus::Open)
                    )
                )
                .and(
                    new SysDaEqualsExpression(
                        new SysDaFieldExpression(_replenWork, fieldStr(WHSWorkTable, WorkTransType)),
                        new SysDaValueExpression(WHSWorkTransType::Replenishment)
                    )
                )
            );

        return mainQueryObj.joinClause(SysDaJoinKind::ExistsJoin, replenWorkQueryObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTmpReplenLinksToNewReplenishments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Tries to create temporary replenishment links to potentially many new replenishments (created as part of current wave
    /// processing specifically for our demand) each covering demand quantity partially (or a single new replenishment
    /// covering demand quantity completely).
    /// </summary>
    /// <param name = "_tmpDemandPickWorkLine">A temporary demand work pick line.</param>
    /// <param name = "_inventQtyMissingReplenLink">A quantity we try to consume from replenishment.</param>
    /// <returns>Remaining not covered demand quantity for which we still need to create permanent replenishment links.</returns>
    private InventQty createTmpReplenLinksToNewReplenishments(
        WHSTmpWorkLine  _tmpDemandPickWorkLine,
        InventQty       _inventQtyMissingReplenLink)
    {
        InventQty   runningInventQtyMissingReplenLink = _inventQtyMissingReplenLink;
        str   mapKey = _tmpDemandPickWorkLine.ItemId + _tmpDemandPickWorkLine.InventDimId + _tmpDemandPickWorkLine.WMSLocationId;

        if (!itemDimReplenWorkMap.exists(mapKey))
        {
            throw error("@WAX:WorkCreateReplenishmentNonExistentReplenWorkMapKey");
        }
        
        List replenWorkIds = itemDimReplenWorkMap.lookup(mapKey);
        ListEnumerator enumerator = replenWorkIds.getEnumerator();

        while (enumerator.moveNext())
        {
            var replenLineRecId = enumerator.current();

            WHSWorkLine replenWorkLine  = WHSWorkLine::findByRecId(replenLineRecId);
            InventQty availReplenQty    = replenWorkLine.calculateInventQtyAvailableForReplenishment();

            if (availReplenQty)
            {
                InventQty replenLinkQty = min(runningInventQtyMissingReplenLink, availReplenQty);

                this.createOrUpdateTempReplenWorkLinks(replenLinkQty, replenWorkLine.WorkId, replenWorkLine.LineNum);

                runningInventQtyMissingReplenLink -= replenLinkQty;

                if (!runningInventQtyMissingReplenLink)
                {
                    break;
                }
            }
        }

        return runningInventQtyMissingReplenLink;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromWaveReplenishmentProcessor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the parameters of the class based on the parameters sent in.
    /// </summary>
    /// <param name = "_waveId">The wave id.</param>
    /// <param name = "_releaseToWarehouseId">The release to warehouse id.</param>
    /// <param name = "_waveExecutionId">The wave execution id.</param>
    /// <param name = "_whsWaveLockManager">The wave lock manager.</param>
    /// <param name = "_waveMethodStatusHandler">The wave method status handler.</param>
    [Hookable(false)]
    internal void initFromWaveReplenishmentProcessor(
        WHSWaveId               _waveId,
        WHSReleaseToWarehouseId _releaseToWarehouseId,
        WHSWaveExecutionID      _waveExecutionId,
        WHSWaveLockManager      _whsWaveLockManager,
        WHSWaveMethodStatusHandler _waveMethodStatusHandler)
    {
        this.parmParmWaveId(_waveId);
        this.parmReleaseToWarehouseId(_releaseToWarehouseId);
        this.parmWaveExecutionId(_waveExecutionId);
        this.parmWhsWaveLockManager(_whsWaveLockManager);
        this.parmWaveMethodStatusHandler(_waveMethodStatusHandler);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromReplenishmentTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set temporary work line fields that are based on replenishment template configurations.
    /// </summary>
    private void initFromReplenishmentTemplate()
    {
        WHSReplenishmentTemplate replenishmentTemplate;

        select firstOnly UseWorkForWaveReplen, CancelReplenWhenDemandCanceled from replenishmentTemplate
            where replenishmentTemplate.ReplenishTemplateId == replenishmentTemplateLine.ReplenishTemplateId;

        tmpWorkLine.UseWorkForWaveReplen = replenishmentTemplate.UseWorkForWaveReplen;
        tmpWorkLine.CancelReplenWhenDemandCanceled = replenishmentTemplate.CancelReplenWhenDemandCanceled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReplenishmentAllowedForWorkTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if creating a replenishment link is allowed for the specified <c>WorkTransType</c>.
    /// </summary>
    /// <param name = "_workTransType">Work order type.</param>
    /// <returns>true if a replenishment order can be created; otherwise, false.</returns>
    public static boolean isReplenishmentAllowedForWorkTransType(WHSWorkTransType _workTransType)
    {
        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromType(_workTransType);

        if (workTransactionType)
        {
            return workTransactionType.isReplenishmentAllowed();
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initImmedReplenAllowedUnits</Name>
				<Source><![CDATA[
    private void initImmedReplenAllowedUnits(boolean _useExistingCrossUnit, RefRecId _replenishmentTemplateRecId)
    {
        
        if (_useExistingCrossUnit)
        {
            WHSReplenishmentTemplateUOM replenishmentUnits;

            while select RestrictionUnitId from replenishmentUnits
                where replenishmentUnits.ReplenishmentTemplateRecId == _replenishmentTemplateRecId
            {
                immedReplenAllowedUnitSet.add(replenishmentUnits.RestrictionUnitId);
                immedReplenAllowedUnit = replenishmentUnits.RestrictionUnitId;
            }
            if (immedReplenAllowedUnitSet.elements() == 1)
            {
                useImmedReplenAllowedUnit = true;
            }
            else
            {
                immedReplenAllowedUnit = '';
            }

        }
        else
        {
            immedReplenAllowedUnitSet.add(immedReplenUnit);
            immedReplenAllowedUnit = immedReplenUnit;
            useImmedReplenAllowedUnit = true;
        }
 
    }

]]></Source>
			</Method>
			<Method>
				<Name>runImmediateDemandReplen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes immediate replenishment.
    /// </summary>
    /// <param name = "_tmpWorkLine">The current temporary demand work line being processed.</param>
    /// <param name = "_matchingDirective">The matching directive that holds the current information of the directive being used.</param>
    /// <param name = "_inventDimId">Current dimension.</param>
    /// <param name = "_releaseToWarehouseId">The current <c>WHSReleaseToWarehouseId</c> being used.</param>
    /// <param name = "_waveExecutionId">The current <c>WHSWaveExecutionId</c> being used.</param>
    /// <returns>Container with the updated temporary demand work line and replenishment information.</returns>
    public static container runImmediateDemandReplen(
        WHSTmpWorkLine            _tmpWorkLine,
        WhsLocationDirectiveMatch _matchingDirective,
        InventDimId               _inventDimId,
        WHSReleaseToWarehouseId   _releaseToWarehouseId,
        WHSWaveExecutionId        _waveExecutionId)
    {
        WHSReplenishmentTemplateLine templateLine;
        WHSTmpWorkLine               localTmpWorkLine;
        container                    ret;
        const WHSWaveStepCode        BlankWaveStepCode = '';

        // Don't want to auto accept any changes to temp work line.
        buf2Buf(_tmpWorkLine, localTmpWorkLine);

        using (var workCreate = new WhsWorkCreateReplenishment(templateLine, localTmpWorkLine.WorkCreateId))
        using (var appInsightsActivity = WHSImmediateReplenishmentApplicationInsightsActivity::newFromParameters(_matchingDirective.immediateReplenishmentTemplateId))
        {
            workCreate.parmParmWaveId(localTmpWorkLine.WaveId);
            workCreate.parmReleaseToWarehouseId(_releaseToWarehouseId);
            workCreate.parmWaveExecutionId(_waveExecutionId);
            
            Qty                 replenQty = conPeek(conPeek(_matchingDirective.buildQty, 1), #BuildQtyQty);
            UnitOfMeasureSymbol replenUOM = conPeek(conPeek(_matchingDirective.buildQty, 1), #BuildQtyUOM);

            EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();
            InventQty inventImmedReplenQty = releasedProductUnitConverter.convertGivenUnitSymbols(replenQty,
                                                                                                  replenUOM,
                                                                                                  WHSCatchWeightHelper::inventHandlingUnitId(localTmpWorkLine.ItemId),
                                                                                                  NoYes::No,
                                                                                                  localTmpWorkLine.ItemId,
                                                                                                  _inventDimId,
                                                                                                  NoYes::Yes);
            
            workCreate.parmImmedReplenQty(inventImmedReplenQty);
            workCreate.parmImmedReplenUnit(replenUOM);
            WHSImmediateReplenishmentApplicationInsightsActivity::addReplenishmentQuantityAsSharedProperty(inventImmedReplenQty);
            WHSImmediateReplenishmentApplicationInsightsActivity::addReplenishmentUnitOfMeasureAsSharedProperty(replenUOM);

            localTmpWorkLine.DirectiveQty = replenQty;
            localTmpWorkLine.DirectiveUOM = replenUOM;
            localTmpWorkLine.InventQty    = inventImmedReplenQty;

            workCreate.parmImmedDemandTmpWorkLine(localTmpWorkLine);
            
            workCreate.runDemandReplen(BlankWaveStepCode, _matchingDirective.immediateReplenishmentTemplateId);

            Qty replenAvailQty = workCreate.parmImmediateReplenAvailQty();

            if (inventImmedReplenQty > replenAvailQty
                && workCreate.parmImmedDemandTmpWorkLine().InventQty > replenAvailQty)
            {
                //Quantities should be adjusted in case put replenishment lines do not fulfil the demand when summed with already available on location.
                workCreate.parmImmedDemandTmpWorkLine().InventQty    = replenAvailQty;
                workCreate.parmImmedDemandTmpWorkLine().DirectiveQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(localTmpWorkLine.ItemId,
                                                                                                    localTmpWorkLine.InventDimId,
                                                                                                    replenAvailQty,
                                                                                                    WHSCatchWeightHelper::inventHandlingUnitId(localTmpWorkLine.ItemId),
                                                                                                    localTmpWorkLine.DirectiveUOM);
            }

            if (workCreate.parmWorkCreatedQty() > 0
            ||  workCreate.parmImmedReplenUsedExistingReplen())
            {
                ret = [workCreate.parmImmedDemandTmpWorkLine(),
                       workCreate.parmImmedReplenPutLocation(),
                       false,
                       workCreate.parmWorkCreatedQty(),
                       true,
                       workCreate.parmImmedReplenUsedExistingReplen(),
                       workCreate.parmOnlyExistingImmedReplenUsed()];
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>demandWorkLocationDirectiveFailureDoesNotAllowCreatingTmpWorkLine</Name>
				<Source><![CDATA[
    private boolean demandWorkLocationDirectiveFailureDoesNotAllowCreatingTmpWorkLine(WHSTmpWorkLine _tmpWorkLine)
    {
        return _tmpWorkLine.WorkType == WHSWorkType::Put
            && WHSLocDirFailure::find(demandTmpWorkLine.WorkTransType).LocDirFailWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>locationDirectiveFailuresAllowCreatingTmpWorkLine</Name>
				<Source><![CDATA[
    internal protected WHSLocationDirectiveFailuresAllowCreatingWorkResult locationDirectiveFailuresAllowCreatingTmpWorkLine(WHSTmpWorkLine _tmpWorkLine)
    {
        if (this.demandWorkLocationDirectiveFailureDoesNotAllowCreatingTmpWorkLine(_tmpWorkLine))
        {
            return WHSLocationDirectiveFailuresAllowCreatingWorkResult::newFailureWithMessage(strFmt("@WAX:WHSLocationDirectiveFailureOfDemandWork", _tmpWorkLine.WorkType));
        }

        return super(_tmpWorkLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTempTablePut</Name>
				<Source><![CDATA[
	[Hookable(false)]
    protected void initTempTablePut()
    {
        // With immediate replenishment the demand tmpWorkLine will not be inserted yet.
        if (demandTmpWorkLine.RecId
        ||  isImmedReplen)
        {
            tmpWorkLine.ItemId                       = demandTmpWorkLine.ItemId;
            tmpWorkLine.InventBatchId                = demandTmpWorkLine.InventBatchId;
            tmpWorkLine.InventDimId                  = demandTmpWorkLine.InventDimId;
            tmpWorkLine.ImmediateReplenishmentUnitId = immedReplenUnit;
        }
        else
        {
            InventDim demandDim = InventDim::find(tmpLoadDemand.InventDimId);
            tmpWorkLine.ItemId          = tmpLoadDemand.ItemId;
            tmpWorkLine.InventBatchId   = demandDim.InventBatchId;
            tmpWorkLine.InventDimId     = demandDim.InventDimId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>blockReplenishmentOverflowWorkExceedingCapacity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Blocks replenishment work with a final put location that is replenishment overflow enabled and exceeds the overflow capacity.
    /// </summary>
    [Hookable(false)]
    public void blockReplenishmentOverflowWorkExceedingCapacity()
    {
        WHSWorkTable workTable;

        while select workTable
            where workTable.workTransType == WHSWorkTransType::Replenishment
                && workTable.WorkBuildId == workCreateId
        {
            if (WMSLocation::find(workTable.getFinalPutLocation(), workTable.InventLocationId).isReplenishmentOverflowEnabled()
                && !workTable.isFinalPutQtyWithinReplenishmentOverflowCapacity())
            {
                WHSWorkBlocking::newFromWorkId(workTable.WorkId)
                                .tryBlockWorkWithReasonType(WHSWorkBlockingReasonType::ExceedsReplenishmentOverflowCapacity);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustStopWorkOnLocationDirectiveFailure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the work should be stopped on location directive failure.
    /// </summary>
    /// <param name = "_demandTmpWorkLine">The temporary demand work line.</param>
    /// <returns>true if the work should be stopped on location directive failure; otherwise, false.</returns>
    protected boolean mustStopWorkOnLocationDirectiveFailure(WHSTmpWorkLine _demandTmpWorkLine)
    { 
        return WHSLocDirFailure::find(_demandTmpWorkLine.WorkTransType).LocDirFailWork;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>