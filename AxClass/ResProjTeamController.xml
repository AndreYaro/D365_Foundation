<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ResProjTeamController</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ResProjTeamController implements ResIProjTeamController
{
    #TimeConstants

    ProjId  projId;
    ResourceCategoryRecId resourceCategory;
    QuotationId quotationId;
    PSARSEntityType entityType;
    ResGenericResourceNameGenerator nameGenerator;
    ActivityRecId rootActivity;
   
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>add</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add a planned or staffed resource to a project or quotation.
    /// </summary>
    /// <param name = "_resourceCategory">
    /// Resource Category.
    /// </param>
    /// <param name = "_startDate">
    /// From date.
    /// </param>
    /// <param name = "_endDate">
    /// To Date.
    /// </param>
    /// <param name = "_resource">
    /// Resource.
    /// </param>
    /// <param name = "_updateRollUp">
    /// Whether <c>ResRollUp</c> table records will be updated.
    /// </param>
    /// <returns>
    /// Id of the added ActivityResource.
    /// </returns>
    /// <remarks>
    /// In this version, planned resource reservation on quotation is not supported.
    /// </remarks>
    public ActivityResourceRecId add(ResourceCategoryRecId _resourceCategory, TransDate _startDate, TransDate _endDate, ResourceRecId _resource = 0, boolean _updateRollUp = true)
    {
        PSAProjSchedRole psaProjSchedRole;

        ttsbegin;
        if (projId && _resource)
        {
            psaProjSchedRole = PSAProjSchedRole::findByResource(projId, _resource);
        }

        if (psaProjSchedRole.RecId == 0)
        {
            psaProjSchedRole.ResourceCategory = _resourceCategory;
            psaProjSchedRole.Resource = _resource;
            psaProjSchedRole.PSARoleStartDate = _startDate;
            psaProjSchedRole.PSARoleEndDate = _endDate;

            switch (entityType)
            {
                case PSARSEntityType::Project:
                    psaProjSchedRole.ProjId = projId;
                    break;

                case PSARSEntityType::Quotation:
                    psaProjSchedRole.QuotationId = quotationId;
                    break;

                default:
                    break;
            }

            if (psaProjSchedRole.Resource != 0)
            {
                psaProjSchedRole.Name = ResourceFacade::getName(psaProjSchedRole.Resource);
            }
            else
            {
                if (entityType == PSARSEntityType::Project)
                {
                    nameGenerator.resourceCategory(_resourceCategory);
                    psaProjSchedRole.Name = nameGenerator.getNextName();
                }
            }

            if (ResUtil::isPerformanceEnhancementFeatureEnabled(true))
            {
                if (projId)
                {
                    psaProjSchedRole.RootActivity = ActivityFacade::findActivityByProjectId(projId);
                }
                if (quotationId)
                {
                    psaProjSchedRole.RootActivity = ActivityFacade::findActivityByQuotationId(quotationId);
                }
            }

            psaProjSchedRole.insert();
        }

        if (entityType == PSARSEntityType::Project)
        {
            // update scheduling status
            ResUtil::addToProjectResourceValidation(_resource, projId);
            ProjActivityCapacity::updateScheduleStatusByProject(projId);
        }
        ttscommit;

        if (_updateRollUp && !ResUtil::isPerformanceEnhancementFeatureEnabled(ResEnableByDefaultPerfEnhancementFeatureFlight::instance().isEnabled()))
        {
            // update assignment and availability roll-ups for the activity resource
            ResActivityResourceDetailView activityResource;
            select firstOnly ActivityResourceId from activityResource
                where activityResource.ActivityResource == psaProjSchedRole.RecId;

            utcdatetime start = AVTimeframe::getTimeframe(
                DateTimeUtil::newDateTime(this.getRollUpStartDate(psaProjSchedRole.PSARoleStartDate), 0), AVTimeframeType::Month).start();
            utcdatetime end = AVTimeframe::getTimeframe(
                DateTimeUtil::newDateTime(this.getRollUpEndDate(psaProjSchedRole.PSARoleEndDate), #LastSecondOfTheDay), AVTimeframeType::Month).end();

            container arguments = [activityResource.ActivityResourceId, start, end];

            if (psaProjSchedRole.Resource == 0)
            {
                Global::runAsync(classNum(ResRollUpWriter),
                    staticMethodStr(ResRollUpWriter, setupRollUpForNewPlannedResourceAsync), arguments);
            }
            else
            {
                Global::runAsync(classNum(ResRollUpWriter),
                    staticMethodStr(ResRollUpWriter, updateRollUpForSpecificActivityResourceIdAsync), arguments);
            }
        }

        return psaProjSchedRole.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>release</Name>
				<Source><![CDATA[
    /// <summary>
    /// Release reserved hour from activity resource.
    /// </summary>
    /// <param name = "_activityResource">
    /// Activity Resource.
    /// </param>
    public void release(ActivityResourceRecId _activityResource)
    {
        if (PSAProjSchedRole::findByRecId(_activityResource))
        {
            ResIResourceManager     resourceManager = ResResourceManager::construct();
            ResICancelProcessor     cancelProcessor = ResCancelProcessor::getProcessor(ResCancelationType::EntireDay);
            List                    schedulesList = new List(Types::Class);

            ResReservationSchedule resSchedule = ResReservationSchedule::construct();

            resSchedule.activityResource(_activityResource);
            resSchedule.reservationType(ResReservationType::Both);
            resSchedule.commitment(ResCommitType::AnyType);

            schedulesList.addEnd(resSchedule);

            // cancel reservation according to the scheduling list
            resourceManager.CancelProcessor(cancelProcessor);
            resourceManager.Schedules(schedulesList);
            resourceManager.Cancel(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>remove</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove role/resource from project team.
    /// </summary>
    /// <param name = "_activityResource">
    /// Activity resource.
    /// </param>
    [SysObsoleteAttribute('Please use removeV2() method as replacement.', false, 02\01\2019)]
    public void remove(ActivityResourceRecId _activityResource)
    {
        this.removeV2(_activityResource, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove role/resource from project team.
    /// </summary>
    /// <param name = "_activityResource">
    /// Activity resource.
    /// </param>
    /// <param name = "_updateRollUpAsync">
    /// Whether to update <c>ResRollUp</c> table in async.
    /// </param>
    public void removeV2(ActivityResourceRecId _activityResource, boolean _updateRollUpAsync = false)
    {
        // Fetch the psaProjSchedRole record to be deleted.
        PSAProjSchedRole teamMember = PSAProjSchedRole::findByRecId(_activityResource);
        if (teamMember && teamMember.validateDelete())
        {
            ResourceRecId resource = teamMember.Resource;
            ProjId projectId = teamMember.ProjId;
            boolean isPlannedResource = resource ? false : true;

            // Get start and end rollup dates from the specify resource hours table.
            utcdateTime rollupStart =  AVTimeframe::getTimeframe(DateTimeUtil::newDateTime(teamMember.PSARoleStartDate, 0), AVTimeframeType::Month).start();
            utcdateTime rollupEnd =  AVTimeframe::getTimeframe(DateTimeUtil::newDateTime(teamMember.PSARoleEndDate, 0), AVTimeframeType::Month).end();

            List schedulesList = new List(Types::Class);

            ResReservationSchedule resSchedule = ResReservationSchedule::construct();

            resSchedule.activityResource(_activityResource);
            resSchedule.reservationType(ResReservationType::Both);
            resSchedule.commitment(ResCommitType::AnyType);

            schedulesList.addEnd(resSchedule);

            ResIResourceManager resourceManager = ResResourceManager::construct();

            resourceManager.CancelProcessor(ResCancelProcessor::getProcessor(ResCancelationType::EntireDay));
            resourceManager.Schedules(schedulesList);
            resourceManager.ExecuteRollUp(false);
            resourceManager.Cancel();

            ActivityResourceId activityResourceId;
            boolean perfFeatureEnabled = ResUtil::isPerformanceEnhancementFeatureEnabled(ResEnableByDefaultPerfEnhancementFeatureFlight::instance().isEnabled());
            if (!perfFeatureEnabled)
            {
                // Capture the ActivityResourceId before it gets deleted from PSAProjSchedRole
                ResActivityResourceDetailView projectResource;
                select firstOnly ActivityResourceId from projectResource
                    where projectResource.ActivityResource == _activityResource;
                activityResourceId = projectResource.ActivityResourceId;
            }

            // Remove the activity resource record.
            PSAProjSchedRole psaProjSchedRole;
            delete_from psaProjSchedRole
                where psaProjSchedRole.RecId == _activityResource;
                    
            if (entityType == PSARSEntityType::Project)
            {
                // delete the psaProjSchedRole record from the project resource validation group.
                ResUtil::deleteFromProjectResourceValidation(resource, projectId);
            }

            if (!perfFeatureEnabled)
            {
                // Update roll-ups for the activity resource.
                if (isPlannedResource)
                {
                    // Remove roll-ups if this is a planned resource.
                    if (_updateRollUpAsync)
                    {
                        container removeRollUpArguments = [activityResourceId];
                        Global::runAsync(classNum(ResRollUpWriter),
                            staticMethodStr(ResRollUpWriter, removeRollUpForSpecificActivityResourceIdAsync), removeRollUpArguments);
                    }
                    else
                    {
                        ResRollUpWriter::removeRollUpForSpecificActivityResourceId(activityResourceId);
                    }
                }
                else
                {
                    // Remove and update roll-ups for staffed activity resource.
                    if (_updateRollUpAsync)
                    {
                        container updateRollUpArguments = [activityResourceId, rollupStart, rollupEnd];
                        Global::runAsync(classNum(ResRollUpWriter),
                            staticMethodStr(ResRollUpWriter, removeAndUpdateRollUpForSpecificActivityResourceIdAsync), updateRollUpArguments);
                    }
                    else
                    {
                        ResRollUpWriter::removeRollUpForSpecificActivityResourceId(activityResourceId);
                        ResRollUpWriter::updateRollUpForSpecificActivityResourceId(activityResourceId, rollupStart, rollupEnd);
                    }
                }
            }
            
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>confirm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts soft booking and assignment to hard booking and assignment.
    /// </summary>
    /// <param name = "_activityResource">
    /// The activity resource for which to convert the soft reservation.
    /// </param>
    public void confirm(ActivityResourceRecId _activityResource)
    {
        if (PSAProjSchedRole::findByRecId(_activityResource))
        {
            ResIResourceManager     resourceManager = ResResourceManager::construct();
            ResIConfirmProcessor    confirmProcessor = ResConfirmProcessor::construct();
            List                    schedulesList = new List(Types::Class);

            ResReservationSchedule resSchedule = ResReservationSchedule::construct();

            resSchedule.ReservationType(ResReservationType::Both);
            resSchedule.activityResource(_activityResource);
            schedulesList.addEnd(resSchedule);

            // confirm the soft reservation according to the scheduling list
            resourceManager.ConfirmProcessor(confirmProcessor);
            resourceManager.Schedules(schedulesList);
            resourceManager.Confirm(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInstanceFromProjId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instance of the <c>ResProjTeamController</c> object from a project ID.
    /// </summary>
    /// <param name = "_selectedProjId">
    /// The project ID from which to get an instance.
    /// </param>
    /// <returns>
    /// The instanc of <c>ResIProjTeamController</c> object.
    /// </returns>
    public static ResIProjTeamController getInstanceFromProjId(ProjId _selectedProjId)
    {
        return new ResProjTeamController(_selectedProjId, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInstanceFromActivityRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instance of the <c>ResProjTeamController</c> object from an activity.
    /// </summary>
    /// <param name = "_activity">
    /// The <c>ActivityRecId</c> from which to get an instance.
    /// </param>
    /// <returns>
    /// An instance of <c>ResIProjTeamController</c> object.
    /// </returns>
    public static ResIProjTeamController getInstanceFromActivityRecId(ActivityRecId _activity)
    {
        return new ResProjTeamController('', _activity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(ProjId _selectedProjId, ActivityRecId _activity)
    {
        rootActivity = ProjWBS::getRootActivityRecId(_selectedProjId);
        nameGenerator = ResGenericResourceNameGenerator::construct(rootActivity);

        if (_selectedProjId != '')
        {
            projId = _selectedProjId;
            entityType = PSARSEntityType::Project;
        }
        else if (_activity != 0)
        {
            rootActivity = ActivityFacade::getRootActivity(_activity);
            PSARSEntityType activityType = ActivityFacade::getActivityType(rootActivity);
            entityType = activityType;
            switch (activityType)
            {
                case PSARSEntityType::Project:
                    projId = ActivityFacade::getProjId(rootActivity);
                    break;

                case PSARSEntityType::Quotation:
                    quotationId = ActivityFacade::getQuotationId(rootActivity);
                    break;

                default:
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ProjId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return project id.
    /// </summary>
    /// <returns>
    /// Project id.
    /// </returns>
    public ProjId ProjId()
    {
        return projId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ProjName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return project name.
    /// </summary>
    /// <returns>
    /// Project name.
    /// </returns>
    public ProjName ProjName()
    {
        return ProjTable::name(projId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ResourceCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return resource category record identifier.
    /// </summary>
    /// <param name = "_resourceCategory">Resource category record identifier.</param>
    /// <returns>
    /// Resource category record identifier.
    /// </returns>
    public ResourceCategoryRecId ResourceCategory(ResourceCategoryRecId _resourceCategory = resourceCategory)
    {
        resourceCategory = _resourceCategory;
        return resourceCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>merge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Merge reservation from activity resource to activity resource and remove from activity resource.
    /// </summary>
    /// <param name = "_mergeFrom">
    /// Activity resource from.
    /// </param>
    /// <param name = "_mergeTo">
    /// Activity resource to.
    /// </param>
    public void merge(ActivityResourceRecId _mergeFrom,  ActivityResourceRecId _mergeTo)
    {
        ResBooking          bookingFrom;
        ResAssignment       assignmentFrom;
        PSAProjSchedRole    PSAProjSchedRole;

        while select bookingFrom
            where bookingFrom.ActivityResource == _mergeFrom
        {
            bookingFrom.ActivityResource = _mergeTo;
        }

        while select assignmentFrom
            where assignmentFrom.ActivityResource == _mergeFrom
        {
            assignmentFrom.ActivityResource = _mergeTo;
        }

        this.updateScheduleDate(_mergeTo);
        delete_from PSAProjSchedRole
            where PSAProjSchedRole.RecId == _mergeFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateScheduleDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update schedule start/end date of activity resource and project.
    /// </summary>
    /// <param name = "_activityResource">Activity resource rec Id.</param>
    void updateScheduleDate(ActivityResourceRecId _activityResource)
    {
        TransDate           earliestDate, latestDate;
        PSAProjSchedRole    psaProjSchedRole;

        ttsbegin;

        earliestDate = ActivityResourceFacade::getEarliestReservationDate(_activityResource);
        latestDate = ActivityResourceFacade::getLatestReservationDate(_activityResource);

        select forupdate firstonly psaProjSchedRole
            where psaProjSchedRole.RecId == _activityResource;

        psaProjSchedRole.PSARoleStartDate = earliestDate;
        psaProjSchedRole.PSARoleEndDate = latestDate;
        psaProjSchedRole.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjScheduleDate</Name>
				<Source><![CDATA[
    private void updateProjScheduleDate(TransDate _startDate, TransDate _endDate)
    {
        ProjTable projTable = ProjTable::find(projId, true);
        if (projTable.PSASchedStartDate > _startDate)
        {
            projTable.PSASchedStartDate = _startDate;
        }

        if (projTable.PSASchedEndDate > _endDate)
        {
            projTable.PSASchedEndDate = _endDate;
        }

        projTable.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>assign</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns the specified resource to the planned resource.
    /// </summary>
    /// <param name = "_activityResource">Planned resource to be fulfilled.</param>
    /// <param name = "_resource">Resource record identifier.</param>
    /// <returns>true when the planned resource assignment operation succeeds; otherwise, false.</returns>
    public boolean assign(ActivityResourceRecId _activityResource, ResourceRecId _resource)
    {
        return this.assignV2(_activityResource, _resource);
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fulfill the specified resource to the planned resource
    /// </summary>
    /// <param name = "_activityResource">Planned resource to be fulfilled</param>
    /// <param name = "_resource">Resource record identifier</param>
    /// <param name = "_syncSpecificTimeScale">true to update a specific time scale in synchronous and the rest to run asynchronous; otherwise all time scale will run synchronously.</param>
    /// <param name = "_syncTimeScaleType">The specific time scale which will be run synchronously and the rest will be run in asynchronous.</param>
    /// <returns>true when the planned resource assignment operation succeeds; otherwise, false.</returns>
    boolean assignV2(ActivityResourceRecId _activityResource, ResourceRecId _resource, boolean _syncSpecificTimeScale = false, AVTimeframeType _syncTimeScaleType = AVTimeframeType::Day)
    {
        PSAProjSchedRole resourceTeam = PSAProjSchedRole::findByRecId(_activityResource, true);

        if (resourceTeam)
        {
            // Get start and end rollup dates.
            utcdateTime rollupStart =  AVTimeframe::getTimeframe(DateTimeUtil::newDateTime(
            this.getRollUpStartDate(resourceTeam.PSARoleStartDate), 0), AVTimeframeType::Month).start();
            utcdateTime rollupEnd =  AVTimeframe::getTimeframe(DateTimeUtil::newDateTime(
            this.getRollUpEndDate(resourceTeam.PSARoleEndDate), #LastSecondOfTheDay), AVTimeframeType::Month).end();

            ttsbegin;
            ActivityResourceRecId staffedActivityResource = ActivityResourceFacade::findByActivityAndResource(rootActivity, _resource);
            if (staffedActivityResource)
            {
                //If the staffed resource is a project team member of this project, update reservation tables.
                ResBooking resbooking;
                ResUtil::skipDatabaseLogAndEvent(resbooking);
                update_recordset resbooking
                setting ActivityResource = staffedActivityResource
                where resbooking.ActivityResource == _activityResource;

                ResAssignment resAssignment;
                ResUtil::skipDatabaseLogAndEvent(resAssignment);
                update_recordset resAssignment
                setting ActivityResource = staffedActivityResource
                where resAssignment.ActivityResource == _activityResource;

                // Remove the existing planned resource.
                resourceTeam.delete();
            }
            else
            {
                //Else update the existing resource team table record with this resource properties.
                resourceTeam.Resource = _resource;
                resourceTeam.Name = ResourceFacade::getName(_resource);
                resourceTeam.update();
            }
            ttscommit;

            // Add resource to validation group.
            if (entityType == PSARSEntityType::Project)
            {
                ResUtil::addToProjectResourceValidation(_resource, this.ProjId());
            }

            // Update activity scheduling status.
            ProjActivityCapacity::updateScheduleStatusByActivity(rootActivity);

            if (!ResUtil::isPerformanceEnhancementFeatureEnabled(ResEnableByDefaultPerfEnhancementFeatureFlight::instance().isEnabled()))
            {
                // remove assignment and availability roll-ups for the previous planned resource
                ActivityResourceId plannedActivityResourceCollectionKeyId = strFmt(ResUtil::activityResourceIdStrFormat,
                    int642Str(rootActivity), '0', int642Str(_activityResource));
                container removeRollUpArguments = [plannedActivityResourceCollectionKeyId];
                Global::runAsync(classNum(ResRollUpWriter),
                    staticMethodStr(ResRollUpWriter, removeRollUpForSpecificActivityResourceIdAsync), removeRollUpArguments);
            
                ActivityResourceId staffedResourceCollectionKeyId = strFmt(ResUtil::activityResourceIdStrFormat,
                    int642Str(rootActivity), int642Str(_resource), int642Str(_activityResource));

                // Update assignment and availability roll-ups for the staffed resource
                ResRollUpWriter::updateRollUpForSpecificActivityResourceId(staffedResourceCollectionKeyId,
                    rollupStart, rollupEnd, _syncSpecificTimeScale, _syncTimeScaleType);
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>customAssign</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fulfill the specified resource to the planned resource with activity and fulfill hours modification which specified in <c>ResTmpSpecifyResourceHours</c> table.
    /// </summary>
    /// <param name = "_plannedActivityResource">Planned activity resource record ID.</param>
    /// <param name = "_staffedResource">Staffed resource record ID.</param>
    /// <param name = "_specifyResourceHoursTable"><c>ResTmpSpecifyResourceHours</c> table buffer which contains the modification of fulfill activity and hours.</param>
    /// <param name = "_notification">Resource manager notification to project manager regarding to this extended fulfillment.</param>
    /// <param name = "_sendEmail">true to send email; otherwise, false.</param>
    /// <param name = "_projectManagerEmailAddress">Project manager email address.</param>
    /// <param name = "_syncSpecificTimeScale">true to update a specific time scale in synchronous and the rest to run asynchronous; otherwise all time scale will run synchronously.</param>
    /// <param name = "_syncTimeScaleType">The specific time scale which will be run synchronously and the rest will be run in asynchronous.</param>
    public void customAssign(ActivityResourceRecId _plannedActivityResource, ResourceRecId _staffedResource,
        ResTmpSpecifyResourceHours _specifyResourceHoursTable, ResExtendFulfillmentNotification _notification = '',
        boolean _sendEmail = false, LogisticsElectronicAddressLocator _projectManagerEmailAddress = '',
        boolean _syncSpecificTimeScale = false, AVTimeframeType _syncTimeScaleType = AVTimeframeType::Day)
    {
        boolean hasFulfillment = this.hasFulfillment(_specifyResourceHoursTable);

        // Verify if there is any record being fulfill
        if (hasFulfillment)
        {
            PSAProjSchedRole resourceTeam = PSAProjSchedRole::findByRecId(_plannedActivityResource);

            if (resourceTeam)
            {
                boolean extendFulfillment = this.hasExtendFulfillment(_specifyResourceHoursTable);
                ResourceCategoryRecId plannedResourceCategory = resourceTeam.ResourceCategory;

                select minof(ActualStartDateTime), maxof(ActualEndDateTime) from _specifyResourceHoursTable
                    where _specifyResourceHoursTable.ReservedHours != 0;

                utcdatetime reservationStartDateTime = _specifyResourceHoursTable.ActualStartDateTime;
                utcdatetime reservationEndDateTime = _specifyResourceHoursTable.ActualEndDateTime;

                //Only add the staffed resource to the project team if it is not a team member in this root activity.
                ResAddedToTeamByFulfillment addToTeamByFulfillment = ResAddedToTeamByFulfillment::No;
                ActivityResourceRecId staffedActivityResource = ActivityResourceFacade::findByActivityAndResource(rootActivity, _staffedResource);
                if (!staffedActivityResource)
                {
                    // Add the staffed resource to become an activity resource of this root activity
                    date staffedActivityResourceStart = DateTimeUtil::date(reservationStartDateTime);
                    date staffedActivityResourceEnd = DateTimeUtil::date(reservationEndDateTime);
                    staffedActivityResource = this.add(plannedResourceCategory,
                        staffedActivityResourceStart, staffedActivityResourceEnd, _staffedResource, false);
                    addToTeamByFulfillment = ResAddedToTeamByFulfillment::Yes;
                }

                // Update reseravtion table records to update activity resource from planned activity resource to staffed activity resource
                // for those records which user didn't make reservation hours and requested dates changes from request.
                // Aslo delete reservation records which assoicated with the planned activity resource which user has made changes to the
                // fulfillment hours or fulfillment date changes.
                this.updateReservationTablesForCustomAssign(_specifyResourceHoursTable, _plannedActivityResource, staffedActivityResource);

                if (extendFulfillment)
                {
                    // Remove all planned resource reservation which associates to extend fulfillment activity.
                    this.removePlannedResourceReservationForExtendFulfillment(_specifyResourceHoursTable, _plannedActivityResource);

                    // Reserve the staffed resource with user defined hours by reservation engine as manual booking type for extend fulfillment activity.
                    utcdatetime bookingRecordCreationStartDateTime = DateTimeUtil::getSystemDateTime();
                    this.reserveStaffedActivityResourceCustomFulfillmentHours(_specifyResourceHoursTable,
                        ResReservationType::Booking, _staffedResource, staffedActivityResource, plannedResourceCategory, ResExtendFulfillment::Yes);
                    this.reserveStaffedActivityResourceCustomFulfillmentHours(_specifyResourceHoursTable,
                        ResReservationType::Assignment, _staffedResource, staffedActivityResource, plannedResourceCategory, ResExtendFulfillment::Yes);
                    utcdatetime bookingRecordCreationEndDateTime = DateTimeUtil::getSystemDateTime();

                    // Insert extend fulfillment records to fulfillment records tables.
                    ResExtendFulfillmentManager::insertExtendFulfillment(_specifyResourceHoursTable, staffedActivityResource, _staffedResource, plannedResourceCategory,
                        _notification, addToTeamByFulfillment, bookingRecordCreationStartDateTime, bookingRecordCreationEndDateTime, rootActivity, _sendEmail, _projectManagerEmailAddress);
                }
                
                // Get the sum of reserved hours and requested hours for this planned activity resource which do not have extend fulfillment set to true.
                select sum(ReservedHours), sum(RequestedHours) from _specifyResourceHoursTable
                    where _specifyResourceHoursTable.ExtendFulfillment == ResExtendFulfillment::No
                    && _specifyResourceHoursTable.ActivityResource == _plannedActivityResource;

                if (_specifyResourceHoursTable.ReservedHours >= _specifyResourceHoursTable.RequestedHours)
                {
                    // Remove this planned resource reservation records if fulfill hours is equal or more than requested hours.
                    this.removePlannedResourceReservationForNonExtendFulfillment(_specifyResourceHoursTable, _plannedActivityResource);
                }
                else
                {
                    // Reserve this planned resource hours if the fulfill hours is less than request hours for non-extend fulfillment scenario.
                    this.reservePlannedActivityResourceCustomFulfillmentHours(_specifyResourceHoursTable, ResReservationType::Booking, _plannedActivityResource, plannedresourceCategory);
                    this.reservePlannedActivityResourceCustomFulfillmentHours(_specifyResourceHoursTable, ResReservationType::Assignment, _plannedActivityResource, plannedresourceCategory);
                }

                // Reserve the staffed resource with user defined hours by reservation engine as manual booking type for non-extend fulfillment activity.
                this.reserveStaffedActivityResourceCustomFulfillmentHours(_specifyResourceHoursTable,
                    ResReservationType::Booking, _staffedResource, staffedActivityResource, plannedResourceCategory, ResExtendFulfillment::No);
                this.reserveStaffedActivityResourceCustomFulfillmentHours(_specifyResourceHoursTable,
                    ResReservationType::Assignment, _staffedResource, staffedActivityResource, plannedResourceCategory, ResExtendFulfillment::No);

                
                // In case the total of assignment hours is more than the task hours, the hours is needed to be redistributed.
                // If there are multiple planned resources assigned to this task, it will remove the other planned resources since
                // there is no way to figure out how user will want to distribute the assigned hours among multiple planned resoruces.
                boolean hasReservePlannedActivityResourceByDeltaHours = this.reservePlannedActivityResourceByDeltaHours(_specifyResourceHoursTable, ResReservationType::Assignment,
                    _plannedActivityResource, plannedresourceCategory, rootActivity);

                boolean plannedResourcehasReservation = ActivityResourceFacade::hasReservation(_plannedActivityResource);
                
                if (!ResUtil::isPerformanceEnhancementFeatureEnabled(ResEnableByDefaultPerfEnhancementFeatureFlight::instance().isEnabled()))
                {
                    if (hasReservePlannedActivityResourceByDeltaHours)
                    {
                        select minof(RequestStartDateTime), maxof(RequestEndDateTime) from _specifyResourceHoursTable;
                        reservationStartDateTime = min(reservationStartDateTime, _specifyResourceHoursTable.RequestStartDateTime);
                        reservationEndDateTime = max(reservationEndDateTime, _specifyResourceHoursTable.RequestEndDateTime);
                    }

                    // Update roll-ups for the staffed resource
                    ActivityResourceId staffedActivityResourceId = strFmt(ResUtil::activityResourceIdStrFormat,
                        int642Str(rootActivity), int642Str(_staffedResource), int642Str(staffedActivityResource));
                
                    // Get start and end rollup dates from the specify resource hours table.
                    utcdateTime rollupStart =  AVTimeframe::getTimeframe(DateTimeUtil::newDateTime(this.getRollUpStartDate(
                        DateTimeUtil::date(reservationStartDateTime)), 0), AVTimeframeType::Month).start();
                    utcdateTime rollupEnd =  AVTimeframe::getTimeframe(DateTimeUtil::newDateTime(this.getRollUpEndDate(
                        DateTimeUtil::date(reservationEndDateTime)), #LastSecondOfTheDay), AVTimeframeType::Month).end();

                    // Update assignment and availability roll-ups for the staffed resource
                    ResRollUpWriter::updateRollUpForSpecificActivityResourceId(staffedActivityResourceId,
                        rollupStart, rollupEnd, _syncSpecificTimeScale, _syncTimeScaleType);
                
                    ActivityResourceId plannedActivityResourceId = strFmt(ResUtil::activityResourceIdStrFormat,
                        int642Str(rootActivity), '0', int642Str(_plannedActivityResource));
                    if (plannedResourcehasReservation)
                    {
                        // Update roll-ups for the planned resource
                        container plannedActivityResourceRollUpArguments = [plannedActivityResourceId, rollupStart, rollupEnd];
                        Global::runAsync(classNum(ResRollUpWriter),
                            staticMethodStr(ResRollUpWriter, updateRollUpForSpecificActivityResourceIdAsync), plannedActivityResourceRollUpArguments);
                    }
                    else
                    {
                        // Remove the planned resource and roll-ups.
                        this.removeResource(_plannedActivityResource);
                        
                        container removeRollUpArguments = [plannedActivityResourceId];
                        Global::runAsync(classNum(ResRollUpWriter),
                            staticMethodStr(ResRollUpWriter, removeRollUpForSpecificActivityResourceIdAsync), removeRollUpArguments);
                    }
                }
                else if (!plannedResourcehasReservation)
                {
                    // Remove the planned resource.
                    this.removeResource(_plannedActivityResource);
                }

                // Update activity scheduling status.
                ResActivityResourceReservationUnionView reservationView;
                while select Activity from reservationView
                    order by Activity
                    where reservationView.ActivityResource == staffedActivityResource
                {
                    ProjActivityCapacity::updateScheduleStatusByActivity(reservationView.Activity);
                }

                // update validation group and project status
                ResUtil::updateTeamInfo(rootActivity);
                
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeResource</Name>
				<Source><![CDATA[
    private void removeResource(ActivityResourceRecId _activityResource)
    {
        PSAProjSchedRole teamTable;
        delete_from teamTable
            where teamTable.RecId == _activityResource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReservationTablesForCustomAssign</Name>
				<Source><![CDATA[
    private void updateReservationTablesForCustomAssign(ResTmpSpecifyResourceHours _specifyResourceHoursTable,
        ActivityResourceRecId _plannedActivityResource, ActivityResourceRecId _staffedActivityResource)
    {
        // Update reservation records to become the fulfilled staffed activity resource only if the requested hours matched the reserved hours
        // which happens in the same date.
        ResBooking resbooking;
        ResUtil::skipDatabaseLogAndEvent(resbooking);

        update_recordset resBooking
            setting ActivityResource = _staffedActivityResource
            where resBooking.Activity == rootActivity
                && resBooking.ActivityResource == _plannedActivityResource
            join _specifyResourceHoursTable
                where _specifyResourceHoursTable.ExtendFulfillment == ResExtendFulfillment::No
                    && _specifyResourceHoursTable.ReservedHours != 0
                    && _specifyResourceHoursTable.ReservedHours == _specifyResourceHoursTable.RequestedHours
                    && _specifyResourceHoursTable.RequestStartDateTime == _specifyResourceHoursTable.ActualStartDateTime
                    && _specifyResourceHoursTable.RequestEndDateTime == _specifyResourceHoursTable.ActualEndDateTime
                    && _specifyResourceHoursTable.ActivityResource == resBooking.ActivityResource
                    && _specifyResourceHoursTable.ActualStartDateTime <= resBooking.Hour
                    && _specifyResourceHoursTable.ActualEndDateTime >= resBooking.Hour
                    && _specifyResourceHoursTable.CommitType == resBooking.CommitType;
                        
        ResAssignment resAssignment;
        ResUtil::skipDatabaseLogAndEvent(resAssignment);

        update_recordset resAssignment
            setting ActivityResource = _staffedActivityResource
            where resAssignment.ActivityResource == _plannedActivityResource
            join _specifyResourceHoursTable
                where _specifyResourceHoursTable.ExtendFulfillment == ResExtendFulfillment::No
                    && _specifyResourceHoursTable.ReservedHours != 0
                    && _specifyResourceHoursTable.ReservedHours == _specifyResourceHoursTable.RequestedHours
                    && _specifyResourceHoursTable.RequestStartDateTime == _specifyResourceHoursTable.ActualStartDateTime
                    && _specifyResourceHoursTable.RequestEndDateTime == _specifyResourceHoursTable.ActualEndDateTime
                    && _specifyResourceHoursTable.Activity == resAssignment.Activity
                    && _specifyResourceHoursTable.ActivityResource == resAssignment.ActivityResource
                    && _specifyResourceHoursTable.ActualStartDateTime <= resAssignment.Hour
                    && _specifyResourceHoursTable.ActualEndDateTime >= resAssignment.Hour
                    && _specifyResourceHoursTable.CommitType == resAssignment.CommitType;

        // Delete reservation records which the specifyResourceHoursTable has specified fulfilled hours
        delete_from resBooking
            where resBooking.Activity == rootActivity
                && resBooking.ActivityResource == _plannedActivityResource
            exists join _specifyResourceHoursTable
                where _specifyResourceHoursTable.ExtendFulfillment == ResExtendFulfillment::No
                    && _specifyResourceHoursTable.ReservedHours != 0
                    && _specifyResourceHoursTable.ActivityResource == resBooking.ActivityResource
                    && _specifyResourceHoursTable.RequestStartDateTime <= resBooking.Hour
                    && _specifyResourceHoursTable.RequestEndDateTime >= resBooking.Hour
                    && _specifyResourceHoursTable.CommitType == resBooking.CommitType;

        delete_from resAssignment
            where resAssignment.ActivityResource == _plannedActivityResource
            exists join _specifyResourceHoursTable
                where _specifyResourceHoursTable.ExtendFulfillment == ResExtendFulfillment::No
                    && _specifyResourceHoursTable.ReservedHours != 0
                    && _specifyResourceHoursTable.ActivityResource == resAssignment.ActivityResource
                    && _specifyResourceHoursTable.Activity == resAssignment.Activity
                    && _specifyResourceHoursTable.RequestStartDateTime <= resAssignment.Hour
                    && _specifyResourceHoursTable.RequestEndDateTime >= resAssignment.Hour
                    && _specifyResourceHoursTable.CommitType == resAssignment.CommitType;
                    
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveStaffedActivityResourceCustomFulfillmentHours</Name>
				<Source><![CDATA[
    private void reserveStaffedActivityResourceCustomFulfillmentHours(ResTmpSpecifyResourceHours _specifyResourceHoursTable, ResReservationType _reservationType,
        ResourceRecId _staffedResource, ActivityResourceRecId _staffedActivityResource, ResourceCategoryRecId _resourceCategory, ResExtendFulfillment _extendFulfillment)
    {
        List schedules = new List(Types::Class);
        while select _specifyResourceHoursTable
            where _specifyResourceHoursTable.ExtendFulfillment == _extendFulfillment
                && _specifyResourceHoursTable.ReservedHours != 0
                && _specifyResourceHoursTable.ReservationType == _reservationType
                && (_specifyResourceHoursTable.ExtendFulfillment == ResExtendFulfillment::Yes
                    || _specifyResourceHoursTable.ReservedHours != _specifyResourceHoursTable.RequestedHours
                    || _specifyResourceHoursTable.ActualStartDateTime != _specifyResourceHoursTable.RequestStartDateTime
                    || _specifyResourceHoursTable.ActualEndDateTime != _specifyResourceHoursTable.RequestEndDateTime)
        {
            ResIReservationSchedule schedule = ResReservationSchedule::construct();
            schedule.resource(_staffedResource);
            schedule.start(_specifyResourceHoursTable.ActualStartDateTime);
            schedule.end(_specifyResourceHoursTable.ActualEndDateTime);
            schedule.capacity(_specifyResourceHoursTable.ReservedHours * #SecondsPerHour);
            schedule.commitment(_specifyResourceHoursTable.CommitType);
            if (_extendFulfillment == ResExtendFulfillment::Yes)
            {
                // For extend fulfillment activity, it will only book the resource to the root activity.
                schedule.ReservationType(ResReservationType::Booking);
                schedule.Activity(rootActivity);
            }
            else
            {
                schedule.ReservationType(_specifyResourceHoursTable.ReservationType);
                schedule.Activity(_specifyResourceHoursTable.Activity);
            }
            schedule.ResourceCategory(_resourceCategory);
            schedule.parmIsExistingTeamMember(true);
            schedule.ActivityResource(_staffedActivityResource);
            schedules.addEnd(schedule);
        }

        if (!schedules.empty())
        {
            ResIResourceManager resourceManager = ResResourceManager::construct();
            resourceManager.ReserveProcessor(ResReserveProcessor::getProcessor(ResBookingType::Manual));
            resourceManager.Schedules(schedules);
            resourceManager.ExecuteRollUp(false);
            resourceManager.ReservationType(_reservationType);
            resourceManager.Reserve();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeReservation</Name>
				<Source><![CDATA[
    private void removeReservation(ActivityResourceRecId _activityResource, ActivityRecId _taskActivity, ResCommitType _commitType)
    {
        // Remove the existing planned resource booking hours from this activity
        ResBooking resBooking;
        ResAssignment resAssignment;
        ResUtil::skipDatabaseLogAndEvent(resBooking);

        delete_from resBooking
            where resBooking.ActivityResource == _activityResource
                && resBooking.CommitType == _commitType
        exists join resAssignment
            where resAssignment.ActivityResource == _activityResource
                && resAssignment.Activity == _taskActivity
                && resAssignment.CommitType == _commitType
                && resAssignment.Hour == resBooking.Hour;

        // Remove the existing planned resource hours from this activity
        ResUtil::skipDatabaseLogAndEvent(ResAssignment);

        delete_from resAssignment
            where resAssignment.Activity == _taskActivity
                && resAssignment.ActivityResource == _activityResource
                && resAssignment.CommitType == _commitType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reservePlannedActivityResourceByDeltaHours</Name>
				<Source><![CDATA[
    private boolean reservePlannedActivityResourceByDeltaHours(ResTmpSpecifyResourceHours _specifyResourceHoursTable, ResReservationType _reservationType,
        ActivityResourceRecId _plannedActivityResource, ResourceCategoryRecId _resourceCategory, ActivityRecId _rootActivity)
    {
        boolean reserveDeltaHours = false;
        List schedules = new List(Types::Class);

        while select minof(RequestStartDateTime), maxof(RequestEndDateTime), Activity, CommitType, ReservationType  from _specifyResourceHoursTable
            group by Activity, CommitType, ReservationType
            where _specifyResourceHoursTable.ReservedHours == 0 && _specifyResourceHoursTable.RequestedHours != 0
                && _specifyResourceHoursTable.ReservationType == ResReservationType::Assignment
        {
            Hours assignedActivityCapacity = ActivityFacade::getAssignedCapacityInHours(
                _specifyResourceHoursTable.Activity, _specifyResourceHoursTable.CommitType, true);
            Hours taskEffort = ProjPlanVersion::findByActivityRecId(_specifyResourceHoursTable.Activity).TaskEffort;
            if (assignedActivityCapacity > taskEffort
                && decRound(assignedActivityCapacity, 1) != decRound(taskEffort, 1))
            {
                reserveDeltaHours = true;
                
                // Remove this resource reservation.
                this.removeReservation(_plannedActivityResource, _specifyResourceHoursTable.Activity, _specifyResourceHoursTable.CommitType);
                
                // Task effort minus assigned capacity in hours excluding planned resource assigned hours
                Hours remainingEffortHours = taskEffort - ActivityFacade::getAssignedCapacityInHours(
                    _specifyResourceHoursTable.Activity, _specifyResourceHoursTable.CommitType, false);

                if (remainingEffortHours)
                {
                    ResIReservationSchedule schedule = ResReservationSchedule::construct();
                    schedule.start(_specifyResourceHoursTable.RequestStartDateTime);
                    schedule.end(_specifyResourceHoursTable.RequestEndDateTime);
                    schedule.capacity(remainingEffortHours * #SecondsPerHour);
                    schedule.commitment(_specifyResourceHoursTable.CommitType);
                    schedule.ReservationType(_specifyResourceHoursTable.ReservationType);
                    schedule.Activity(_specifyResourceHoursTable.Activity);
                    schedule.ResourceCategory(_resourceCategory);
                    schedule.parmIsExistingTeamMember(true);
                    schedule.ActivityResource(_plannedActivityResource);
                    schedules.addEnd(schedule);
                }
                
                // Remove reservation for the rest of the planned resources
                ResAssignment resAssignment;
                PSAProjSchedRole teamMember;

                select count(RecId) from resAssignment
                    group by ActivityResource
                    where resAssignment.ActivityResource != _plannedActivityResource
                        && resAssignment.Activity == _specifyResourceHoursTable.Activity
                        && resAssignment.CommitType == _specifyResourceHoursTable.CommitType
                exists join teamMember
                    where teamMember.RecId == resAssignment.ActivityResource
                        && teamMember.Resource == 0;

                int numberOfPlannedReosurces = int642int(resAssignment.RecId);
                boolean updateRollUpAsync = numberOfPlannedReosurces <= ResUtil::numberOfAsyncProcessAllow;

                while select resAssignment
                    group by ActivityResource
                    where resAssignment.ActivityResource != _plannedActivityResource
                        && resAssignment.Activity == _specifyResourceHoursTable.Activity
                        && resAssignment.CommitType == _specifyResourceHoursTable.CommitType
                exists join teamMember
                    where teamMember.RecId == resAssignment.ActivityResource
                        && teamMember.Resource == 0
                {
                    utcdatetime rollupStart = ActivityResourceFacade::getEarliestAssignmentDateTime(resAssignment.ActivityResource);
                    utcdatetime rollupEnd = ActivityResourceFacade::getLatestAssignmentDateTime(resAssignment.ActivityResource);

                    // Remove this resource reservation.
                    this.removeReservation(resAssignment.ActivityResource, _specifyResourceHoursTable.Activity, _specifyResourceHoursTable.CommitType);

                    boolean plannedActivityResourceHasReservation = ActivityResourceFacade::hasReservation(_plannedActivityResource);
                    if (!plannedActivityResourceHasReservation)
                    {
                        // Remove the planned resource
                        PSAProjSchedRole removeTeamMember;
                        delete_from removeTeamMember
                            where removeTeamMember.RecId == resAssignment.ActivityResource;
                    }

                    if (!ResUtil::isPerformanceEnhancementFeatureEnabled(ResEnableByDefaultPerfEnhancementFeatureFlight::instance().isEnabled()))
                    {
                        ActivityResourceId plannedActivityResourceId = strFmt(ResUtil::activityResourceIdStrFormat,
                        int642Str(_rootActivity), '0', int642Str(resAssignment.ActivityResource));

                        if (plannedActivityResourceHasReservation)
                        {
                            if (updateRollUpAsync)
                            {
                                // Update roll-ups for the planned resource
                                container plannedActivityResourceRollUpArguments = [plannedActivityResourceId, rollupStart, rollupEnd];
                                Global::runAsync(classNum(ResRollUpWriter),
                                    staticMethodStr(ResRollUpWriter, updateRollUpForSpecificActivityResourceIdAsync), plannedActivityResourceRollUpArguments);
                            }
                            else
                            {
                                ResRollUpWriter::updateRollUpForSpecificActivityResourceId(plannedActivityResourceId, rollupStart, rollupEnd);
                            }
                        }
                        else
                        {
                            // remove the planned activity resource roll-ups
                            if (updateRollUpAsync)
                            {
                                container removeRollUpArguments = [plannedActivityResourceId];
                                Global::runAsync(classNum(ResRollUpWriter),
                                    staticMethodStr(ResRollUpWriter, removeRollUpForSpecificActivityResourceIdAsync), removeRollUpArguments);
                            }
                            else
                            {
                                ResRollUpWriter::removeRollUpForSpecificActivityResourceId(plannedActivityResourceId);
                            }
                        }
                    }
                }
            }
        }

        if (!schedules.empty())
        {
            ResIResourceManager resourceManager = ResResourceManager::construct();
            resourceManager.ReserveProcessor(ResReserveProcessor::getProcessor(ResBookingType::Manual));
            resourceManager.Schedules(schedules);
            resourceManager.ExecuteRollUp(false);
            resourceManager.ReservationType(_reservationType);
            resourceManager.Reserve();
        }

        return reserveDeltaHours;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reservePlannedActivityResourceCustomFulfillmentHours</Name>
				<Source><![CDATA[
    private void reservePlannedActivityResourceCustomFulfillmentHours(ResTmpSpecifyResourceHours _specifyResourceHoursTable, ResReservationType _reservationType,
        ActivityResourceRecId _plannedActivityResource, ResourceCategoryRecId _resourceCategory)
    {
        // This method will only operate for non-extend fulfillment activity. For extend fulfillment activity, the planned resource should not be reserved.
        List schedules = new List(Types::Class);
        while select _specifyResourceHoursTable
            where _specifyResourceHoursTable.ExtendFulfillment == ResExtendFulfillment::No
                && _specifyResourceHoursTable.ReservedHours != 0
                && _specifyResourceHoursTable.RequestedHours > _specifyResourceHoursTable.ReservedHours
                && _specifyResourceHoursTable.ReservationType == _reservationType
        {
            ResIReservationSchedule schedule = ResReservationSchedule::construct();
            schedule.start(_specifyResourceHoursTable.RequestStartDateTime);
            schedule.end(_specifyResourceHoursTable.RequestEndDateTime);
            schedule.capacity((_specifyResourceHoursTable.RequestedHours - _specifyResourceHoursTable.ReservedHours) * #SecondsPerHour);
            schedule.commitment(_specifyResourceHoursTable.CommitType);
            schedule.ReservationType(_specifyResourceHoursTable.ReservationType);
            schedule.Activity(_specifyResourceHoursTable.Activity);
            schedule.ResourceCategory(_resourceCategory);
            schedule.parmIsExistingTeamMember(true);
            schedule.ActivityResource(_plannedActivityResource);
            schedules.addEnd(schedule);
        }

        if (!schedules.empty())
        {
            ResIResourceManager resourceManager = ResResourceManager::construct();
            resourceManager.ReserveProcessor(ResReserveProcessor::getProcessor(ResBookingType::Manual));
            resourceManager.Schedules(schedules);
            resourceManager.ExecuteRollUp(false);
            resourceManager.ReservationType(_reservationType);
            resourceManager.Reserve();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removePlannedResourceReservationForNonExtendFulfillment</Name>
				<Source><![CDATA[
    private void removePlannedResourceReservationForNonExtendFulfillment(ResTmpSpecifyResourceHours _specifyResourceHoursTable,
        ActivityResourceRecId _plannedActivityResource)
    {
        // Delete reservation records for the specify planned resource
        ResBooking resbooking;
        ResUtil::skipDatabaseLogAndEvent(resbooking);

        delete_from resBooking
            where resBooking.Activity == rootActivity
                && resBooking.ActivityResource == _plannedActivityResource
            exists join _specifyResourceHoursTable
                where _specifyResourceHoursTable.ActivityResource == resBooking.ActivityResource
                    && _specifyResourceHoursTable.CommitType == resBooking.CommitType;

        ResAssignment resAssignment;
        ResUtil::skipDatabaseLogAndEvent(resAssignment);

        delete_from resAssignment
            where resAssignment.ActivityResource == _plannedActivityResource
            exists join _specifyResourceHoursTable
                where _specifyResourceHoursTable.ActivityResource == resAssignment.ActivityResource
                    && _specifyResourceHoursTable.Activity == resAssignment.Activity
                    && _specifyResourceHoursTable.CommitType == resAssignment.CommitType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removePlannedResourceReservationForExtendFulfillment</Name>
				<Source><![CDATA[
    private void removePlannedResourceReservationForExtendFulfillment(ResTmpSpecifyResourceHours _specifyResourceHoursTable,
        ActivityResourceRecId _plannedActivityResource)
    {
        // Delete reservation records for the specify planned resource per the specified activity
        ResBooking resbooking;
        ResUtil::skipDatabaseLogAndEvent(resbooking);

        ResAssignment resAssignment;
        ResUtil::skipDatabaseLogAndEvent(resAssignment);

        // Remove planned resource booking records which does not overlap with assignment record
        delete_from resBooking
            where resBooking.Activity == rootActivity
                && resBooking.ActivityResource == _plannedActivityResource
            exists join _specifyResourceHoursTable
            where _specifyResourceHoursTable.ExtendFulfillment == ResExtendFulfillment::Yes
                && _specifyResourceHoursTable.Activity == rootActivity
                && _specifyResourceHoursTable.ActivityResource == resBooking.ActivityResource
                && _specifyResourceHoursTable.CommitType == resBooking.CommitType
            notexists join resAssignment
            where resAssignment.ActivityResource == resBooking.ActivityResource
                && resAssignment.CommitType == resBooking.CommitType
                && resAssignment.Hour == resBooking.Hour;

        //Remove booking records which back up the assignment records
        delete_from resBooking
                where resBooking.Activity == rootActivity
                    && resBooking.ActivityResource == _plannedActivityResource
                exists join _specifyResourceHoursTable
                    where _specifyResourceHoursTable.ExtendFulfillment == ResExtendFulfillment::Yes
                        && _specifyResourceHoursTable.ActivityResource == resBooking.ActivityResource
                        && _specifyResourceHoursTable.CommitType == resBooking.CommitType
                exists join resAssignment
                    where resAssignment.Activity == _specifyResourceHoursTable.Activity
                        && resAssignment.ActivityResource == resBooking.ActivityResource
                        && resAssignment.CommitType == resBooking.CommitType
                        && resAssignment.Hour == resBooking.Hour;

        //Remove assignment records
        delete_from resAssignment
                where resAssignment.ActivityResource == _plannedActivityResource
                exists join _specifyResourceHoursTable
                    where _specifyResourceHoursTable.ExtendFulfillment == ResExtendFulfillment::Yes
                        && _specifyResourceHoursTable.ActivityResource == resAssignment.ActivityResource
                        && _specifyResourceHoursTable.Activity == resAssignment.Activity
                        && _specifyResourceHoursTable.CommitType == resAssignment.CommitType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasFulfillment</Name>
				<Source><![CDATA[
    private boolean hasFulfillment(ResTmpSpecifyResourceHours _specifyResourceHoursTable)
    {
        select firstonly RecId from _specifyResourceHoursTable
            where _specifyResourceHoursTable.ReservedHours != 0;

        return (_specifyResourceHoursTable.RecId) ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStaffedActivityResource</Name>
				<Source><![CDATA[
    private ActivityResourceRecId getStaffedActivityResource(ResourceRecId _staffedResource, PSAProjSchedRole _resourceTeam, date _teamMemberStartDate, date _teamMemberEndDate)
    {
        ActivityResourceRecId staffedActivityResource = ActivityResourceFacade::findByActivityAndResource(rootActivity, _staffedResource);
        if (!staffedActivityResource)
        {
            // Add the staffed resource to become an activity resource of this root activity
            staffedActivityResource = this.add(_resourceTeam.ResourceCategory, _teamMemberStartDate, _teamMemberEndDate, _staffedResource, false);
        }
        return staffedActivityResource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasExtendFulfillment</Name>
				<Source><![CDATA[
    private boolean hasExtendFulfillment(ResTmpSpecifyResourceHours _specifyResourceHoursTable)
    {
        select firstonly RecId from _specifyResourceHoursTable
            where _specifyResourceHoursTable.ExtendFulfillment == ResExtendFulfillment::Yes;

        return (_specifyResourceHoursTable.RecId) ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAllPlannedResourceRollup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update all plannned resource roll up records for this engagement.
    /// </summary>
    /// <param name = "_asyncUpdate">Whether update will be done in async.</param>
    public void updateAllPlannedResourceRollup(boolean _asyncUpdate = true)
    {
        if (!ResUtil::isPerformanceEnhancementFeatureEnabled(ResEnableByDefaultPerfEnhancementFeatureFlight::instance().isEnabled()))
        {

            PSAProjSchedRole engagementTeamTable;

            switch (entityType)
            {
                case PSARSEntityType::Project:

                    // Update every planned resource in this project.
                    while select ProjId, PSARoleStartDate, PSARoleEndDate, RecId from engagementTeamTable
                    where engagementTeamTable.ProjId == projId
                        && engagementTeamTable.Resource == 0
                    {
                        this.updatePlannedResourceRollup(engagementTeamTable, _asyncUpdate);
                    }
                    break;

                case PSARSEntityType::Quotation:

                    // Update if each planned resource in this quotation.
                    while select QuotationId, PSARoleStartDate, PSARoleEndDate, RecId from engagementTeamTable
                    where engagementTeamTable.QuotationId == quotationId
                        && engagementTeamTable.Resource == 0
                    {
                        this.updatePlannedResourceRollup(engagementTeamTable, _asyncUpdate);
                    }
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePlannedResourceRollup</Name>
				<Source><![CDATA[
    private void updatePlannedResourceRollup(PSAProjSchedRole _engagementTeamTable, boolean _asyncUpdate)
    {
        // update assignment and availability roll-ups for the activity resource
        ResActivityResourceDetailView activityResource;
        select firstOnly ActivityResourceId from activityResource
            where activityResource.ActivityResource == _engagementTeamTable.RecId;

        utcdatetime start = AVTimeframe::getTimeframe(
            DateTimeUtil::newDateTime(
                this.getRollUpStartDate(_engagementTeamTable.PSARoleStartDate), 0),
                AVTimeframeType::Month).start();
        utcdatetime end = AVTimeframe::getTimeframe(
            DateTimeUtil::newDateTime(
                this.getRollUpEndDate(_engagementTeamTable.PSARoleEndDate), #LastSecondOfTheDay),
                    AVTimeframeType::Month).end();

        container arguments = [activityResource.ActivityResourceId, start, end];

        if (_asyncUpdate)
        {
            Global::runAsync(classNum(ResRollUpWriter),
                staticMethodStr(ResRollUpWriter, removeAndUpdateRollUpForSpecificActivityResourceIdAsync), arguments);
        }
        else
        {
            ResRollUpWriter::removeAndUpdateRollUpForSpecificActivityResourceIdAsync(arguments, System.Threading.CancellationToken::None);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRollUpStartDate</Name>
				<Source><![CDATA[
    private date getRollUpStartDate(date _startDate)
    {
        // get rollup table cache start date by getting the smaller date
        date cacheStartDate = _startDate;
        if (entityType == PSARSEntityType::Project)
        {
            ProjTable project;
            select firstonly PSASchedEndDate from project
                where project.ProjId == projId;
            cacheStartDate = _startDate < project.PSASchedStartDate ? _startDate : project.PSASchedStartDate;
        }
        else
        {
            SalesQuotationTable quotation;
            select firstonly PSAESTProjEndDate from quotation
                where quotation.QuotationId == quotationId;
            cacheStartDate = _startDate < quotation.PSAESTProjStartDate ? _startDate : quotation.PSAESTProjStartDate;
        }
        return cacheStartDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRollUpEndDate</Name>
				<Source><![CDATA[
    private date getRollUpEndDate(date _endDate)
    {
        // get rollup table cache end date by getting the higher date
        date cacheEndDate = _endDate;
        if (entityType == PSARSEntityType::Project)
        {
            ProjTable project;
            select firstonly PSASchedEndDate from project
                where project.ProjId == projId;
            cacheEndDate = _endDate > project.PSASchedEndDate ? _endDate : project.PSASchedEndDate;
        }
        else
        {
            SalesQuotationTable quotation;
            select firstonly PSAESTProjEndDate from quotation
                where quotation.QuotationId == quotationId;
            cacheEndDate = _endDate > quotation.PSAESTProjEndDate ? _endDate : quotation.PSAESTProjEndDate;
        }
        return cacheEndDate;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>