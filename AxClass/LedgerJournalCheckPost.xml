<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalCheckPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.GeneralLedger.Instrumentation;

/// <summary>
/// The <c>LedgerJournalCheckPost</c> class validates and posts ledger journals.
/// </summary>
class LedgerJournalCheckPost extends RunBaseBatch implements BatchRetryable
{
    public LedgerJournalCheckPostResults postingResults;
    public LedgerJournalTable  ledgerJournalTable;
    public LedgerJournalName   ledgerJournalName;
    public LedgerVoucher       ledgerVoucher;
    public Voucher             voucherNum;
    public NoYes               post;
    public NoYes               transferErrors;
    public Integer             transLogPoint;
    public Counter             numOfVouchersBooked;
    public Voucher             firstErrorVoucher;
    public Voucher             currentInterCompanyVoucher;

    boolean             showErrorOk;

    // <GCN>
    boolean             postProforma;
    Map                 mapJournalEntry;
    Map                 interCompanyVouchers_CN;
    // </GCN>

    boolean             inTransfer;
    boolean             errorJournalDeleted;
    boolean             checkNoSettlement;
    boolean             checkPaymStatus;

    Set                 voucherErrorList;
    LedgerJournalId     errorLedgerJournalId;

    Set                 interCompanyCompanies;
    Map                 interCompanyJournalIds;
    Map                 interCompanyVouchers;
    Map                 parentVoucherLinkMap;

    Map                 bankAccountBalances;

    Counter             progressCounter;
    Log                 tableErrorLog;
    DetailSummary       detailSummaryPosting;

    LedgerJournalId     ledgerJournalId;

    TaxVoucherService   taxVoucherService;

    container           accountBalances;

    Counter             starttime;

    RecordSortedList    bankFeeList;
    Counter             bankFeeCount;

    Map                 tmpVoucherMap;
    Map                 errorTmpVoucherMap;

    LedgerPostingMessageLog             ledgerPostingMessageCollection;

    container           newJournalNumCon;
    container           newCompanyCon;
    container           newVendIdCon;
    container           intercompanyRecIds;

    InterCompanyTradingValueMap         fromInterCompanyTradingValueMap;
    InterCompanyTradingValueMap         toInterCompanyTradingValueMap;
    InterCompanyEndpointActionPolicy    toInterCompanyEndpointActionPolicy;

    TradeInterCompanyConv            convAccount;

    RecordSortedList    taxWorkRegulationList;
    // <GIN>
    boolean             inclTax;
    boolean             retainOldInterCompany;
    container           checkSTForInterCompany;
    AmountCur           interCmpWithholdingTaxAmount;
    LedgerJournalTrans  ledgerJournalTransFBT;
    container           ledgerJournalRecId;
    boolean             tdsWarningMsg;
    // </GIN>

    // <GJP>
    boolean             isIntercompanyMapNeeded;
    boolean             isPaymentRequestEnable;
    Map                 ledgerJournalTransIntercompanyMap;
    // </GJP>
    #ISOCountryRegionCodes

    // <GEERU>
    LedgerBondClient_RU ledgerBondClient;
    boolean             parmPreview;
    boolean             rCashRejectedLineExists;
    // </GEERU>

    boolean isBudgetControlSourceIntegrationSupported;

    // Key: journal line Voucher Number (Str)
    // Value: Set of LedgerVoucherObject  (Set)
    Map                 budgetCheckVouchers;

    // Key: InterCompanyId + InterCompanyJournalId + InterCompanyVoucher (Str)
    // Value: journal line Voucher Number (Str)
    Map                 budgetCheckInterCompanyVouchers;

    // Key: journal line Voucher Number
    // Value: BudgetControlGeneralJournalEntry class instance (Class)
    Map                 budgetControlGeneralJournalEntries;

    // Feature checker for Letter of Credit
    boolean             isLetterOfCreditEnabled;

    // To "turn off" infologs announcing a successful post.
    boolean             bquiet;
    boolean             progressBarHide;

    container                   rboParameters;

    JournalizingDefinitionManagerBank   payrollDisbursementjournalizingDefinitionManagerBank;
    boolean                             canAddPayrollDisbursementEntries;

    RetailTransactionId    retailTransactionId;
    RetailTerminalId       retailTerminalId;
    RetailStoreId          retailStoreId;
    RetailCustTrans        retailCustTrans;

    // <GTE>
    Map taxDocumentMapForPosting;
    boolean isGTEEnabled = TaxSolutionScopeIntegrationUtil::isCompanyEnabled();
    // </GTE>

    int64 durationCheckJournal;
    int64 durationPostJournal;

    boolean simulatePosting = false;

    boolean journalIsBlocked;
    boolean isLedgerVoucherPosted;

    private const int CurrentVersion = 4;

    private Set ledgerJournalTransWithTaxUncommitedSet_BR;

    private LedgerJournalPostPerformanceMonitor perfMonitor;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>logJournalPostingProcessException</Name>
				<Source><![CDATA[
    /// <summary>
    /// A delegate that is called to log the exception in journal posting process.
    /// </summary>
    /// <param name = "_exception">
    /// The exception being caught
    /// </param>
    /// <param name = "_exceptionPlace">
    /// The place where the exception exists
    /// </param>
    delegate void logJournalPostingProcessException(System.Exception _exception, str _exceptionPlace)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>runInternalPrePostJournalDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// A delegate that is called immediately before the journal is posted in the runInternal method.
    /// </summary>
    /// <param name = "_ledgerJournalCheckPost">
    /// The instance of the <c>LedgerJournalCheckPost</c> class.
    /// </param>
    delegate void runInternalPrePostJournalDelegate(LedgerJournalCheckPost _ledgerJournalCheckPost)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>runInternalPostPostJournalDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// A delegate that is called immediately after the journal is posted in the runInternal method.
    /// </summary>
    /// <param name = "_ledgerJournalCheckPost">
    /// The instance of the <c>LedgerJournalCheckPost</c> class.
    /// </param>
    /// <param name = "_postingSuccess">
    /// A boolean value indicating if the journal was posted successfully.
    /// </param>
    /// <param name = "_intercompanyPostingSuccess">
    /// A boolean value indicating if the intercompany part of the journal was posted successfully.
    /// </param>
    delegate void runInternalPostPostJournalDelegate(LedgerJournalCheckPost _ledgerJournalCheckPost, boolean _postingSuccess, boolean _intercompanyPostingSuccess)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>runInternalPostValidateJournalDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// A delegate that is called immediately after the journal is validated.
    /// </summary>
    /// <param name = "_ledgerJournalCheckPost">
    /// The instance of the <c>LedgerJournalCheckPost</c> class.
    /// </param>
    /// <param name = "_validateSuccess">
    /// A boolean value indicating if the journal was validated successfully.
    /// </param>
    delegate void runInternalPostValidateJournalDelegate(LedgerJournalCheckPost _ledgerJournalCheckPost, boolean _validateSuccess)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>runInternalPostJournalTransactionEnded</Name>
				<Source><![CDATA[
    /// <summary>
    /// A delegate that is called immediately after the end of the transaction that contains the posting of the journal
    /// in the runInternal method.
    /// </summary>
    /// <param name = "_ledgerJournalCheckPost">
    /// The instance of the <c>LedgerJournalCheckPost</c> class.
    /// </param>
    delegate void runInternalPostJournalTransactionEnded(LedgerJournalCheckPost _ledgerJournalCheckPost)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournalIterateJournalLinesEnded</Name>
				<Source><![CDATA[
    /// <summary>
    /// A delegate that is called in the postJournal method at the end of the while loop on journal lines.
    /// </summary>
    /// <param name = "_ledgerJournalCheckPost">
    /// The instance of the <c>LedgerJournalCheckPost</c> class.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The current <c>LedgerJournalTrans</c> record in the loop.
    /// </param>
    /// <param name = "_ok">
    /// A boolean indicating the current value of the ok variable.
    /// </param>
    /// <param name = "_allOK">
    /// A boolean indicating the current value of the allOK variable.
    /// </param>
    delegate void postJournalIterateJournalLinesEnded(LedgerJournalCheckPost _ledgerJournalCheckPost, LedgerJournalTrans _ledgerJournalTrans, boolean _ok, boolean _allOK)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournalPostTransStarting</Name>
				<Source><![CDATA[
    /// <summary>
    /// A delegate that is called in the postJournal method before the postTrans method calls are made for the journal line.
    /// </summary>
    /// <param name = "_ledgerJournalCheckPost">
    /// The instance of the <c>LedgerJournalCheckPost</c> class.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The current <c>LedgerJournalTrans</c> record in the loop.
    /// </param>
    /// <param name = "_ok">
    /// A boolean indicating the current value of the ok variable.
    /// </param>
    /// <param name = "_allOK">
    /// A boolean indicating the current value of the allOK variable.
    /// </param>
    delegate void postJournalPostTransStarting(LedgerJournalCheckPost _ledgerJournalCheckPost, LedgerJournalTrans _ledgerJournalTrans, boolean _ok, boolean _allOK)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournalPostTransEnded</Name>
				<Source><![CDATA[
    /// <summary>
    /// A delegate that is called in the postJournal method after the postTrans method calls are made for the journal line.
    /// </summary>
    /// <param name = "_ledgerJournalCheckPost">
    /// The instance of the <c>LedgerJournalCheckPost</c> class.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The current <c>LedgerJournalTrans</c> record in the loop.
    /// </param>
    /// <param name = "_ok">
    /// A boolean indicating the current value of the ok variable.
    /// </param>
    /// <param name = "_allOK">
    /// A boolean indicating the current value of the allOK variable.
    /// </param>
    delegate void postJournalPostTransEnded(LedgerJournalCheckPost _ledgerJournalCheckPost, LedgerJournalTrans _ledgerJournalTrans, boolean _ok, boolean _allOK)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournalIterateJournalLinesEndedWithEventHandlerResultDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// A delegate that is called in the postJournal method at the end of the while loop on journal lines.
    /// </summary>
    /// <param name = "_ledgerJournalCheckPost">The instance of the <c>LedgerJournalCheckPost</c> class.</param>
    /// <param name = "_ledgerJournalTrans">The current <c>LedgerJournalTrans</c> record in the loop.</param>
    /// <param name = "_ok">A boolean indicating the current value of the ok variable.</param>
    /// <param name = "_allOK">A boolean indicating the current value of the allOK variable.</param>
    /// <param name = "_eventHandlerResult">The <c>EventHandlerResult</c> object.</param>
    delegate void postJournalIterateJournalLinesEndedWithEventHandlerResultDelegate(LedgerJournalCheckPost _ledgerJournalCheckPost, LedgerJournalTrans _ledgerJournalTrans, boolean _ok, boolean _allOK, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVoucherSeriesCodeInLedgerVoucherForAccrualsDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// A delegate that is called in the postJournal method to update voucher series for accruals.
    /// </summary>
    /// <param name = "_ledgerJournalCheckPost">The instance of the <c>LedgerJournalCheckPost</c> class.</param>
    /// <param name = "_ledgerJournalTrans">The current <c>LedgerJournalTrans</c> record.</param>
    delegate void updateVoucherSeriesCodeInLedgerVoucherForAccrualsDelegate(LedgerJournalCheckPost _ledgerJournalCheckPost, LedgerJournalTrans _ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isRetryable()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowSaveLast</Name>
				<Source><![CDATA[
    public boolean allowSaveLast()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEndBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the journal's ending balance equals the beginning balance plus the journal amount.
    /// </summary>
    /// <returns>
    /// true if the journal's ending balance equals the beginning balance plus the journal amount; otherwise, false.
    /// </returns>
    protected boolean checkEndBalance()
    {
        if (ledgerJournalTable.FixedOffsetAccount           &&
            ledgerJournalTable.OffsetLedgerDimension        &&
            ledgerJournalName.EndBalanceControl)
        {
            if (ledgerJournalTable.EndBalance != ledgerJournalTable.JournalBalance)
            {
                return checkFailed(strFmt("@SYS75197",
                                          ledgerJournalTable.JournalBalance,
                                          ledgerJournalTable.EndBalance));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPrepaymentAutoFacture_RU</Name>
				<Source><![CDATA[
    protected boolean checkPrepaymentAutoFacture_RU(LedgerJournalTrans _ledgerJournalTrans,
                                                boolean            _post     = false)
    {
        boolean         ret = true;

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust &&
            _ledgerJournalTrans.Prepayment &&
            _ledgerJournalTrans.CustFactureAutoCreate_RU &&
            _ledgerJournalTrans.UseOriginalDocumentAsFacture_RU &&
            ! _ledgerJournalTrans.DocumentNum)
        {
            ret = checkFailed(strFmt("@SalesPurchBook:AutoFactureCreateDocMustBeFilled", _ledgerJournalTrans.Voucher));

            if (_post)
            {
                this.insertInVoucherErrorList(_ledgerJournalTrans.Voucher);
            }
            else
            {
                this.updateTransInfoLog(_ledgerJournalTrans);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the current instance of a journal.
    /// </summary>
    /// <returns>
    ///    true if the journal is valid; otherwise, false.
    /// </returns>
    protected boolean checkJournal()
    {
        boolean journalStatus = this.checkJournalStatus();

        if (this.keepJournalValidationLog())
        {
            if (!journalStatus)
            {
                this.updateTransInfoLog();
            }

            this.updateTableInfoLog(ledgerJournalTable);
        }

        if (journalStatus && !bquiet)
        {
            this.showJournalPassedValidationMessage();
        }

        return journalStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showJournalPassedValidationMessage</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows messaging indicating that the journal passed validation.
    /// </summary>
    protected void showJournalPassedValidationMessage()
    {
        if (voucherNum)
        {
            if (showErrorOk)
            {
                info(strFmt("@SYS26544", voucherNum));
            }
        }
        else
        {
            info("@SYS17146");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the status of current instance of a journal.
    /// </summary>
    /// <returns>
    ///    true if the journal is in a valid state; otherwise, false.
    /// </returns>
    protected boolean checkJournalStatus()
    {
        boolean                     ok      = true;
        boolean                     allOk   = true;
        Voucher                     oldVoucher;
        utcdatetime                 oldReleaseDate;
        Voucher                     failedVoucher;
        
        TransDate                   checkTransDate;
        NoYes                       vatBookEnable_IT;
        boolean                     isOffset;

        boolean                     anyReversalsExistForJournal;
        boolean                     voucherContainsCurrentCompany;

        // <GEERU>
        TransDate                   oldTransDate;
        boolean                     transDateFailed;
        boolean                     countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        // <GJP>
        boolean                     isPositiveDRCROnlyEnabled;
        // </GJP>
        // <GIN>
        AssetTransTypeJournal       assetTransType;
        LedgerJournalTrans_Asset    ledgerJournalTransAsset;
        boolean                     isDepIncomeTaxActEnabled = AssetParameters::isDepreciationIncomeTaxActEnable_IN();
        AssetBook                   assetBookLocal;
        // </GIN>
        LedgerPostingController     ledgerPostingController;
        LedgerJournalTrans          ledgerJournalTrans;

        #ISOCountryRegionCodes

        allOk = this.checkEndBalance();
        SysModule sysModule = ledgerJournalTable.ledgerJournalName().getSysModuleForJournal();
        ledgerPostingMessageCollection = LedgerPostingMessageLog::construct();

        ledgerVoucher = LedgerVoucher::newLedgerCheck(ledgerJournalTable.DetailSummaryPosting,
                                                      sysModule,
                                                      NumberSequenceTable::find(ledgerJournalTable.NumberSequenceTable).NumberSequence,
                                                      this.isApprovalJournal());

        ledgerVoucher.parmCheckTransOnInsert(true);
        ledgerVoucher.parmLedgerPostingMessageLog(ledgerPostingMessageCollection);

        if (ledgerJournalTable)
        {
            transLogPoint = infologLine();
            setPrefix(strFmt("@SYS4004020", ledgerJournalTable.JournalNum));

            // Validating bank account corresponding to OffsetAccount and BankAccountId of LedgerJournalTable on Validate button.
            allOk = this.validateLedgerJournalTableBankAccount(ledgerJournalTable) && allOk;

            // Determine if any reversals exist for the journal to avoid lookups
            // for reversals on each line individually. Since most journals don't
            // contain reversals, check that here to avoid checking on each journal
            // line later on.
            LedgerJournalTrans ledgerJournalTransWork;
            select firstonly RecId from ledgerJournalTransWork
                where
                    ledgerJournalTransWork.RevRecId != 0
                exists join ledgerJournalTrans where
                    ledgerJournalTrans.RecId == ledgerJournalTransWork.RevRecId &&
                    ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum;

            anyReversalsExistForJournal = (ledgerJournalTransWork.RecId != 0);

            // If journal type is asset buget, don't need to check for blocked dimensions
            if (ledgerJournalTable.JournalType == LedgerJournalType::AssetBudgets)
            {
                ledgerVoucher.parmCheckBlockedDimensions(false);
            }

            // <GJP>
            isPositiveDRCROnlyEnabled = ledgerJournalTable.isPositiveDRCROnlyEnabled_JP();
            // </GJP>
            // <GIN>
            if (isDepIncomeTaxActEnabled)
            {
                select firstonly AssetGroup_IN, BookId, RefRecId from ledgerJournalTransAsset
                    join RecId, JournalNum from ledgerJournalTrans
                    where ledgerJournalTrans.JournalNum     == ledgerJournalTable.JournalNum    &&
                        ledgerJournalTransAsset.RefRecId  == ledgerJournalTrans.RecId;

                select firstonly AssetGroup, BookId from assetBookLocal
                    where assetBookLocal.AssetGroup         == ledgerJournalTransAsset.AssetGroup_IN
                    && assetBookLocal.BookId             == ledgerJournalTransAsset.BookId;
            }
            //
            // </GIN>

            // if fixed asset journal do the check for net book value
            if (ledgerJournalTable.JournalType == LedgerJournalType::Assets)
            {
                // <GIN>
                if (isDepIncomeTaxActEnabled                                                    &&
                    assetBookLocal.AssetGroupDepreciation_IN                                    &&
                    (ledgerJournalTransAsset.TransType == AssetTransTypeJournal::Depreciation   ||
                    ledgerJournalTransAsset.TransType  == AssetTransTypeJournal::DepreciationAdj))
                {
                    //
                    allOk = LedgerJournalCheckPostAssets::assetValidateNetBookValues_IN(this, ledgerJournalTable.JournalNum) && allOk;
                }
                //
                else
                {
                    //
                    // </GIN>
                    if (ledgerJournalTable.AssetTransferType_LT == LtAssetTransferType::TransferJour)
                    {
                        allOk = this.assetCheckReverseJournal_LT(ledgerJournalTable.RecId) && allOk;
                    }
                    else
                    {
                        allOk = LedgerJournalCheckPostAssets::assetValidateNetBookValues(this, ledgerJournalTable.JournalNum) && allOk;
                    }

                    // <GCN>
                    if (allOk && AssetParameters::isDepreciationMethodsEnabled())
                    {
                        allOk = allOk && LedgerJournalCheckPost_CN::validateAdjustmentForSYDM(ledgerJournalId);
                    }
                    // </GCN>
                    // <GIN>
                }
                // </GIN>
            }
            // check net book value of fixed asset transaction on other that fixed asset journal
            else
            {
                // <GIN>
                if (isDepIncomeTaxActEnabled)
                {
                    //
                    if (ledgerJournalTransAsset)
                    {
                        //
                        assetTransType = ledgerJournalTransAsset.TransType;
                    }
                }
                // </GIN>
                allOk = LedgerJournalCheckPostAssets::assetValidateNetBookValuesNonFA(this, ledgerJournalTable.JournalNum) && allOk;
            }

            allOk = LedgerJournalCheckPostProj::validateProjTrans(ledgerJournalTable) && allOk;

            // By default payroll disbursements for bank transaction type posting definitions are not required for a Payroll journal.
            canAddPayrollDisbursementEntries = false;

            // Determine if payroll disbursements for bank transaction type posting definitions are required for a Payroll journal.
            payrollDisbursementjournalizingDefinitionManagerBank =  LedgerJournalCheckPostJournalizing::initPayrollDisbursementEntries(ledgerJournalTable.JournalType);
            if (payrollDisbursementjournalizingDefinitionManagerBank)
            {
                canAddPayrollDisbursementEntries = payrollDisbursementjournalizingDefinitionManagerBank.parmJournalizingDefinition();
            }
        }

        //--> Italy:  Check transDate
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            vatBookEnable_IT = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]);
        }
        else
        {
            vatBookEnable_IT = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]) && ledgerJournalName.taxBookSectionId();
        }

        if (!vatBookEnable_IT && MultipleTaxIdReportingHelper::existsAddressInCountryRegion([#isoIT], MultipleTaxIdScope::VATDeclaration))
        {
            vatBookEnable_IT = ledgerJournalName.taxBookSectionId() ? NoYes::Yes : NoYes::No;
        }

        if (vatBookEnable_IT)
        {
            NumberSequenceTable numberSequenceTable = NumberSequenceTable::find(ledgerJournalName.NumberSequenceTable);
            Num num = NumberSeq::numInsertFormat((numberSequenceTable.NextRec - 1),numberSequenceTable.Format);

            GeneralJournalEntry generalJournalEntry;
            SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

            select maxof(AccountingDate) from subledgerVoucherGeneralJournalEntry
                                where subledgerVoucherGeneralJournalEntry.Voucher like num &&
                                      subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == curext()
                                join RecId from generalJournalEntry
                                where generalJournalEntry.Ledger == Ledger::current() &&
                                     generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry;
            checkTransDate = subledgerVoucherGeneralJournalEntry.AccountingDate;
        }

        Set voucherMap = new Set(Types::String);

        while select ledgerJournalTrans
            index NumVoucherIdx
            order by JournalNum, Voucher, AccountType
            where ledgerJournalTrans.JournalNum   == ledgerJournalTable.JournalNum
               && (voucherNum == '' || ledgerJournalTrans.Voucher == voucherNum)
        {
            if (oldVoucher && oldVoucher != ledgerJournalTrans.Voucher)
            {
                if (!voucherContainsCurrentCompany)
                {
                    allOK = this.logCompanyNotInVoucherError(oldVoucher, ledgerPostingMessageCollection);
                }
            }

            setPrefix(strFmt("@SYS25866", ledgerJournalTrans.Voucher));

            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
                ledgerJournalTable.JournalType == LedgerJournalType::RCash
                && LedgerJournalTrans_RCash::find(ledgerJournalTrans.RecId).TransStatus == RCashTransStatus::Canceled)
            {
                //
                continue;
            }
            //
            // </GEERU>
            ok = true;

            ledgerPostingMessageCollection.setTableIdRecId(
                tableNum(LedgerJournalTrans),
                ledgerJournalTrans.RecId);

            // Catera -> Handling Posting profile.
            if (LedgerJournalName::isNegotiableInstrumentJournal(ledgerJournalTable.JournalType))
            {
                if (ledgerJournalTrans.TransactionType == LedgerTransType::Fee)
                {
                    ledgerJournalTrans.PostingProfile =CustParameters::find().PostingProfile;
                }
            }

            if (BrazilParameters::isEnabled())
            {
                if (!ledgerJournalTransWithTaxUncommitedSet_BR)
                {
                    ledgerJournalTransWithTaxUncommitedSet_BR = LedgerJournalCheckPost_BR::initLedgerJournalTransWithTaxUncommitedSet(voucherNum, ledgerJournalTable.JournalNum);
                }

                if (ledgerJournalTransWithTaxUncommitedSet_BR && ledgerJournalTransWithTaxUncommitedSet_BR.in(ledgerJournalTrans.RecId))
                {
                    allOk = LedgerJournalCheckPost_BR::checkFiscalEstablishment(ledgerJournalTrans)
                        && LedgerJournalCheckPost_BR::checkTaxationCodeFiscalValue(ledgerJournalTrans)
                        && allOk;
                }

                allOk = LedgerJournalCheckPost_BR::checkTransactionTxt(ledgerJournalTrans, ledgerPostingMessageCollection)
                        &&  LedgerJournalCheckPost_BR::checkSalesTaxForProject(ledgerJournalTable, ledgerJournalTrans)
                        &&  allOk;
            }

            // Validating bank account corresponding to OffsetAccount, AccountNum and BankAccountId of LedgerJournalTrans on Validata button.
            ok = this.validateLedgerJournalTransBankAccount(ledgerJournalTrans);

            // <GEEHU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU]) && ledgerJournalTrans.isCashTransaction_RU())
            {
                ok = LedgerJournalCheckPost_RU::validateCashReportPeriod(ledgerJournalTrans, ledgerPostingMessageCollection);
            }
            // </GEEHU>

            //--> Italy:  Check transDate
            if (this.checkTransDateAndVatBookEnable_IT(ledgerJournalTrans, vatBookEnable_IT, checkTransDate))
            {
                ok = ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS75074", date2StrUsr(ledgerJournalTrans.TransDate, DateFlags::FormatAll), date2StrUsr(checkTransDate, DateFlags::FormatAll), ledgerJournalTrans.JournalNum));
            }

            //--> Italy: Asset leasing journal mandatory sales tax group and item sales tax group check for vendor invoice journal line with account type as vendor.
            ok = this.validateTaxGroupsForAssetLeaseInvoiceJournal(ledgerJournalTrans, ledgerPostingMessageCollection) && ok;

            if (!this.checkAccountNumber(ledgerJournalTrans))
            {
                ok = ledgerPostingMessageCollection.logCheckFailed("@SYS25989");
            }

            ok = this.validateTransForFixedAssets(ledgerJournalTrans, ledgerPostingMessageCollection) && ok;

            // <GJP>
            if (isPositiveDRCROnlyEnabled)
            {
                ok = LedgerJournalCheckPost_JP::checkPositiveDRCR(ledgerJournalTrans, ledgerPostingMessageCollection) && ok;
            }
            // </GJP>

            // <GIN>
            if (isDepIncomeTaxActEnabled)
            {
                if (assetBookLocal.AssetGroupDepreciation_IN &&
                    (ledgerJournalTransAsset.TransType       != AssetTransTypeJournal::Depreciation  &&
                    ledgerJournalTransAsset.TransType       != AssetTransTypeJournal::DepreciationAdj))
                {
                    if (!this.checkVoucher(ledgerJournalTrans))
                    {
                        ok = ledgerPostingMessageCollection.logCheckFailed(strFmt('%1 %2 %3', "@SYS24569", "@SYS4163", date2StrUsr(ledgerJournalTrans.TransDate, DateFlags::FormatAll)));
                    }
                }
            }
            else
            {
                // </GIN>
                if (!this.checkVoucher(ledgerJournalTrans))
                {
                    ok = ledgerPostingMessageCollection.logCheckFailed(strFmt('%1 %2 %3', "@SYS24569", "@SYS4163", date2StrUsr(ledgerJournalTrans.TransDate, DateFlags::FormatAll)));
                }
                // <GIN>
            }
            //

            if (ok
                && TaxWithholdParameters_IN::checkTaxParameters()
                && TaxWithholdParameters_IN::findByCompany(curext()).CrossCompanyPayment)
            {
                ok = LedgerJournalCheckPost_IN::checkPaymentForCP(ledgerJournalTrans, ledgerPostingMessageCollection);

                if (ok)
                {
                    ok = LedgerJournalCheckPost_IN::checkOverpaymentForCP(ledgerJournalTrans, ledgerPostingMessageCollection);
                }
            }
            // </GIN>
            // <GEERU>
            if (countryRegion_RU)
            {
                ok = LedgerJournalCheckPost_RU::checkSalesBookTax(this,
                                           ledgerJournalTrans,
                                           false,
                                           ledgerJournalTrans.isCompanyIntercompany() ? ledgerJournalTrans.Company : curext()) && ok;
                ok = LedgerJournalCheckPost_RU::checkPrepaymentAutoFacture_RU(this, ledgerJournalTrans, false) && ok;
            }
            //
            // </GEERU>

            if (LedgerParameters::find().AcknowledgementDate_IT)
            {
                if (ledgerJournalName.JournalType == LedgerJournalType::Daily ||
                    ledgerJournalName.JournalType == LedgerJournalType::Assets)
                {
                    GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIT00010, funcName());
                    if (ledgerJournalTrans.AcknowledgementDate < ledgerJournalTrans.TransDate)
                    {
                        // Posting date may not exceed competence date.
                        ok = ledgerPostingMessageCollection.logCheckFailed("@SYS99223");
                    }
                }
            }

            if (!this.checkReversingDate(ledgerJournalTrans))
            {
                ok = ledgerPostingMessageCollection.logCheckFailed("@SYS116157");
            }

            // For cheque and deposit slip reversals, it is an error if the transaction date
            // on the voucher is before the original transaction date (stored in DocumentDate).
            ok = this.validateTransDateForReversal(ledgerJournalTrans, ledgerJournalTable.JournalType, ledgerPostingMessageCollection) && ok;
            
            //Check that ReleaseDate is the same on all lines with the same voucher#
            if (oldVoucher != ledgerJournalTrans.Voucher)
            {
                oldReleaseDate = ledgerJournalTrans.ReleaseDate;
            }
            else
            {
                if (oldReleaseDate != ledgerJournalTrans.ReleaseDate)
                {
                    if (oldVoucher != failedVoucher)
                    {
                        //add message only once per voucher
                        ok = ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS115796", oldVoucher));
                        failedVoucher = oldVoucher;
                    }
                    ok = false;
                }
                //if
            }
            // else

            // <GEERU>
            if (oldTransDate                        &&
                ledgerJournalName.MandatoryDate_RU  &&
                oldTransDate != ledgerJournalTrans.TransDate)
            {
                ok = ledgerPostingMessageCollection.logCheckFailed("@GLS113711");
                transDateFailed = true;
            }
            //
            // </GEERU>
            ok = this.checkLedgerJournalTrans(ledgerJournalTrans, ok);

            // <GEEU>
            // This validation only issues warnings
            ledgerJournalTrans.checkPrepaymentTaxGroups();
            // </GEEU>

            if (oldVoucher != ledgerJournalTrans.Voucher)
            {
                ledgerJournalTrans.validateW9Received(true);

                voucherContainsCurrentCompany = ledgerJournalTrans.containsCurrentCompany();
            }
            else
            {
                voucherContainsCurrentCompany = voucherContainsCurrentCompany || ledgerJournalTrans.containsCurrentCompany();
            }

            if (ok)
            {
                ok = LedgerJournalCheckPostBank::validateBankLC(isLetterOfCreditEnabled, ledgerJournalTrans);
            }

            this.displayProgress(ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate);

            // <GEEU>
            ok = ledgerJournalTrans.checkVatRegData_W(tmpVoucherMap) && ok;
            // </GEEU>

            isOffset = false;

            if (!ledgerJournalTrans.LedgerDimension && ledgerJournalTrans.OffsetLedgerDimension)
            {
                ledgerJournalTrans = this.ledgerJournalTransOffset(ledgerJournalTrans);
                isOffset = true;
            }

            taxVoucherService = TaxVoucherService::construct(ledgerJournalTable);

            while (ledgerJournalTrans.LedgerDimension)
            {
                // For French Derogatory Tax Depreciation voucher, do not verify the account information
                // as this journal is not posted to GL.
                if (LedgerJournalCheckPost_FR::isDerogatoryTaxJournal(ledgerJournalTrans))
                {
                    break;
                }

                LedgerJournalTransUpdate ledgerJournalTransUpdate = LedgerJournalTransUpdate::construct(ledgerJournalTrans, isOffset);

                ledgerJournalTransUpdate.setTaxVoucherService(taxVoucherService);
                // <GJP>
                LedgerJournalCheckPost_JP::setLedgerJournalTransUpdIntercompanyMap(isIntercompanyMapNeeded,
                    ledgerJournalTransIntercompanyMap,
                    ledgerJournalTransUpdate);
                // </GJP>
                ledgerJournalTransUpdate.parmTmpVoucherMap(tmpVoucherMap);

                LedgerJournalCheckPostJournalizing::addWriteOffJournalizingEntries(ledgerVoucher, ledgerJournalTrans);

                ok = ledgerJournalTransUpdate.ledgerVoucherCheck(ledgerJournalTrans, ledgerVoucher, checkNoSettlement
                    , anyReversalsExistForJournal
                    ) && ok;

                // Checking the PaymStatus is not needed prior to generating a payment
                if (checkPaymStatus == true)
                {
                    ok = ledgerJournalTransUpdate.checkPaymStatus(ledgerJournalTable.JournalType,ledgerJournalTrans) && ok;
                }

                ledgerJournalTrans = this.ledgerJournalTransOffset(ledgerJournalTrans);

                isOffset = !isOffset;
            }

            if (oldVoucher != ledgerJournalTrans.Voucher)
            {
                oldVoucher = ledgerJournalTrans.Voucher;
                voucherMap.add(oldVoucher);
            }

            // <GEERU>
            if (countryRegion_RU
                && ! transDateFailed)
            {
                oldTransDate = ledgerJournalTrans.TransDate;
            }
            //
            // </GEERU>

            allOk = LedgerJournalCheckPost_WE::checkPaymStatus_NO(ledgerJournalTrans, ledgerPostingMessageCollection) && allOk;

            // <GEEPL>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]) &&
                ledgerJournalTable.JournalType == LedgerJournalType::CustPayment)
            {
                allOk = LedgerJournalCheckPost_PL::checkMarkedInvoice(ledgerJournalTrans, ledgerPostingMessageCollection) && allOk;
            }
            // </GEEPL>

            // <GJP>
            boolean isAssetDocumentEnabled = AssetDocumentUtility_JP::isAssetDocumentEnabled();

            if (isAssetDocumentEnabled)
            {
                LedgerJournalTrans_Asset ledgerJournalTrans_Asset = LedgerJournalTrans_Asset::find(ledgerJournalTrans.RecId);
                if (ledgerJournalTrans_Asset
                    && (ledgerJournalTrans_Asset.DocumentType_JP == AssetDocumentType_JP::AssetReductionEntry_DirectOff
                    || ledgerJournalTrans_Asset.DocumentType_JP == AssetDocumentType_JP::AssetReductionEntry_Reserve))
                {
                    AssetDocumentReductionEntryTable_JP assetDocumentReductionEntry = AssetDocumentReductionEntryTable_JP::findByDocumentEntry(ledgerJournalTrans_Asset.AssetDocumentEntry_JP);
                    if (assetDocumentReductionEntry.DocumentDate > ledgerJournalTrans.TransDate)
                    {
                        ok = ledgerPostingMessageCollection.logCheckFailed("@SYS4006136");
                    }

                    AssetReductionEntryProfile_JP assetReductionEntryProfile = AssetReductionEntryProfile_JP::findByReductionEntryTableRecId(assetDocumentReductionEntry.RecId);
                    if (assetReductionEntryProfile
                        && !assetReductionEntryProfile.validateTransDate(ledgerJournalTrans.TransDate))
                    {
                        allOk = ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS4006135",
                            ledgerJournalTrans.TransDate,
                            assetReductionEntryProfile.getValidFrom(),
                            assetReductionEntryProfile.getValidTo()));
                    }
                }
            }
            // </GJP>

            if (!ok)
            {
                this.updateTransInfoLog(ledgerJournalTrans);
                allOk = ok && allOk;
            }
        }

        if (oldVoucher && !voucherContainsCurrentCompany)
        {
            allOK = this.logCompanyNotInVoucherError(oldVoucher, ledgerPostingMessageCollection);
        }

        // Check for voucher for "One voucher" requirements if parameter is enabled (API provides check)
        SetEnumerator voucherEnumerator = voucherMap.getEnumerator();

        while (voucherEnumerator.moveNext())
        {
            Voucher currentVoucher = voucherEnumerator.current();
            ok = ok && this.checkMultipleTransactionsWithinOneVoucher(LedgerJournalTable.JournalNum, currentVoucher, ledgerPostingMessageCollection);
        }

        if (canAddPayrollDisbursementEntries)
        {
            // Payroll disbursements for bank transaction type posting definitions are required for a Payroll journal.
            LedgerJournalCheckPostJournalizing::addPayrollDisbursementEntries(payrollDisbursementjournalizingDefinitionManagerBank, ledgerVoucher);
        }

        // check for approval journal
        if (ledgerJournalTable)
        {
            if (ledgerJournalTable.JournalType == LedgerJournalType::Approval)
            {
                // if validating one voucher
                if (this.parmVoucher())
                {
                    // find the ledger trans for the voucher
                    ledgerJournalTrans = LedgerJournalTrans::find(ledgerJournalTable.JournalNum, this.parmVoucher(), false);
                    if (ledgerJournalTrans)
                    {
                        if (ledgerJournalTrans.AccountType == LedgerJournalACType::Project && ledgerJournalTable.LedgerJournalInclTax == NoYes::No)
                        {
                            ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher);
                            if (taxVoucherService)
                            {
                                taxVoucherService.post(ledgerPostingController);
                            }
                        }
                        // calculate the tax amount, but don't post tax - this code will
                        // create ledger trans to reverse the tax
                        this.movePostedTaxes(ledgerJournalTrans, false);

                        if (ledgerJournalTrans.Cancel)
                        {
                            //Verify that the approval journal voucher has no pending invoice in workflow
                            if (ledgerJournalTrans.hasPendingInvoiceInWorkflow())
                            {
                                allOk = checkFailed(strFmt("@AccountsPayable:PendingInvoiceInWorkflowError", ledgerJournalTrans.Voucher));
                                this.updateTransInfoLog(ledgerJournalTrans);
                            }
                        }
                        else
                        {
                            // Verify that the approval journal voucher has no pending invoices
                            if (ledgerJournalTrans.hasPendingInvoice())
                            {
                                allOk = checkFailed(strFmt("@SYS110664", ledgerJournalTrans.Voucher));
                                this.updateTransInfoLog(ledgerJournalTrans);
                            }
                        }
                    }
                }

                // validating all lines on journal
                else
                {
                    LedgerJournalTrans ledgerJournalTransWork;
                    while select ledgerJournalTransWork
                        group by Voucher
                        where ledgerJournalTransWork.JournalNum   == ledgerJournalTable.JournalNum
                    {
                        ledgerJournalTrans = LedgerJournalTrans::find(ledgerJournalTable.JournalNum, ledgerJournalTransWork.Voucher, false);
                        if (ledgerJournalTrans)
                        {
                            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Project && ledgerJournalTable.LedgerJournalInclTax == NoYes::No)
                            {
                                ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher);
                                if (taxVoucherService)
                                {
                                    taxVoucherService.post(ledgerPostingController);
                                }
                            }
                            // calculate the tax amount, but don't post tax - this code will
                            // create ledger trans to reverse the tax
                            this.movePostedTaxes(ledgerJournalTrans, false);

                            if (ledgerJournalTrans.Cancel)
                            {
                                //Verify that the approval journal voucher has no pending invoice in workflow
                                if (ledgerJournalTrans.hasPendingInvoiceInWorkflow())
                                {
                                    allOk = checkFailed(strFmt("@AccountsPayable:PendingInvoiceInWorkflowError", ledgerJournalTrans.Voucher));
                                    this.updateTransInfoLog(ledgerJournalTrans);
                                }
                            }
                            else
                            {
                                // Verify that the approval journal voucher has no pending invoices
                                if (ledgerJournalTrans.hasPendingInvoice())
                                {
                                    allOk = checkFailed(strFmt("@SYS110664", ledgerJournalTrans.Voucher));
                                    this.updateTransInfoLog(ledgerJournalTrans);
                                }
                            }
                        }
                    }
                }
            }
            else if (ledgerJournalTable.JournalType == LedgerJournalType::Payment)
            {
                // check the pre-defined Over Draft limits for BankAccounts tied to the LedgerJournal
                allOk = LedgerJournalCheckPostBank::checkOverDraftLimit(bankAccountBalances) && allOk;
            }
        }

        allOk = ledgerVoucher.end() && allOk;

        if (this.keepJournalValidationLog())
        {
            if (ledgerJournalTable)
            {
                isBudgetControlSourceIntegrationSupported =
                    isBudgetControlSourceIntegrationSupported ||
                    BudgetSourceLedgerJournalTrans::isBudgetControlSourceIntegrator(ledgerJournalTable.JournalType);

                if (isBudgetControlSourceIntegrationSupported)
                {
                    allOk = LedgerJournalCheckPostBudget::submitBudgetForCheckJournal(ledgerJournalTable, voucherNum) && allOk;
                }
            }
        }

        return allOk;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransDateAndVatBookEnable_IT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the latest date of the subledger voucher entries is greater than transaction date
    /// and sales tax book section is enabled for Italy.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> buffer.
    /// </param>
    /// <param name = "_vatBookEnable_IT">
    /// Determines if sales tax book section is enabled for Italy.
    /// </param>
    /// <param name = "_checkTransDate">
    /// The latest date of the subledger voucher entries.
    /// </param>
    /// <returns>
    /// true if sales tax book section is enabled for Italy
    /// and latest date of the subledger voucher entries is greater than transaction date; otherwise, false.
    /// </returns>
    protected boolean checkTransDateAndVatBookEnable_IT(LedgerJournalTrans _ledgerJournalTrans, NoYes _vatBookEnable_IT, TransDate _checkTransDate)
    {
        return (_vatBookEnable_IT && _checkTransDate > _ledgerJournalTrans.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ok">
    /// Boolean value of journal validation state.
    /// </param>
    /// <returns>
    /// Returns true if the journal is in valid state; otherwise, false.
    /// </returns>
    protected boolean checkLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans, boolean _ok)
    {
        _ok = _ledgerJournalTrans.checkCreditRemainAmountCur(ledgerPostingMessageCollection)  && _ok;
        _ok = _ledgerJournalTrans.checkInterCompany(ledgerPostingMessageCollection)           && _ok;
        _ok = _ledgerJournalTrans.checkNegInstPosting(ledgerPostingMessageCollection)         && _ok;
        _ok = _ledgerJournalTrans.validateInvoice(ledgerPostingMessageCollection)             && _ok;
        _ok = _ledgerJournalTrans.validateBankAccount()                                       && _ok;
        _ok = _ledgerJournalTrans.checkReleaseDate(ledgerPostingMessageCollection)            && _ok;
        _ok = _ledgerJournalTrans.checkJournalAccountControl()                                && _ok;
        _ok = _ledgerJournalTrans.checkReasonRefRecID(ledgerPostingMessageCollection)         && _ok;

        // <GEEU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]))
        {
            _ok = _ledgerJournalTrans.checkVendPrepayment_CZ(ledgerPostingMessageCollection)  && _ok;
        }
        
        // </GEEU>
        return _ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAccountNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the account number is specified.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true if the account number is specified; otherwise, false.
    /// </returns>
    protected boolean checkAccountNumber(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean returnValue = true;

        if (!_ledgerJournalTrans.LedgerDimension && _ledgerJournalTrans.RecId)
        {
            returnValue = false;
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the voucher is specified.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true if the voucher is specified; otherwise, false.
    /// </returns>
    protected boolean checkVoucher(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean returnValue = true;

        if (!_ledgerJournalTrans.Voucher && _ledgerJournalTrans.RecId)
        {
            returnValue = false;
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReversingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the reversing date is valid.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true if the reversing date is valid; otherwise, false.
    /// </returns>
    protected boolean checkReversingDate(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean returnValue = true;

        if (_ledgerJournalTrans.ReverseEntry && (_ledgerJournalTrans.ReverseDate <= _ledgerJournalTrans.TransDate))
        {
            returnValue = false;
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBudgetCheckForPostJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the budget-related class variables.
    /// </summary>
    protected void initBudgetCheckForPostJournal()
    {
        // Determine whether budget control supports the journal type.
        // When posting journal again due to transfer errors option or retry posting,
        // whether budget control supports the journal type should have been determined.
        isBudgetControlSourceIntegrationSupported =
            isBudgetControlSourceIntegrationSupported ||
            BudgetSourceLedgerJournalTrans::isBudgetControlSourceIntegrator(ledgerJournalTable.JournalType);

        // Initialize to perform budget funds available check for the posting journal.
        if (isBudgetControlSourceIntegrationSupported)
        {
            budgetCheckVouchers = new Map(Types::String, Types::Class);
            budgetCheckInterCompanyVouchers = new Map(Types::String, Types::String);
            budgetControlGeneralJournalEntries = new Map(Types::String, Types::Class);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReversingEntry</Name>
				<Source><![CDATA[
    private LedgerJournalTrans checkReversingEntry()
    {
        LedgerJournalTrans ledgerJournalTrans;
 
        select firstonly ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                && ledgerJournalTrans.ReverseEntry
                && ledgerJournalTrans.ReverseDate <= ledgerJournalTrans.TransDate;
 
        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRevEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a reversing entry record in the <c>LedgerJournalTrans</c> table for the current journal
    /// number that is being posted.
    /// </summary>
    /// <param name="_numberSequenceTableRecId">
    /// The number sequence ID to use when you are retrieving voucher numbers for the reversing entries.
    /// </param>
    /// <remarks>
    /// For the current record being posted, each <c>LedgerJournalTrans</c> record that has a
    /// <c>ReverseEntry</c> field value of true and has a <c>ReverseDate</c> field value that is not empty
    /// will have a reversing entry created for it in the <c>LedgerJournalTrans</c> table. New vouchers
    /// will be created to hold the reversing entries. Each unique originating voucher will have a new
    /// reversing voucher created for it. If the journal is set up to use one voucher number only or Manual
    /// voucher numbers, the Voucher on each reversing line will be taken from its originating line. Each
    /// originating voucher line will be updated with a link to its corresponding new reversing line.
    /// </remarks>
    protected void createRevEntries(RefRecId _numberSequenceTableRecId)
    {
        LedgerJournalTrans  updLedgerJournalTrans;
        NumberSeq           numberSeq;
        Voucher             newVoucher,
                            prevVoucher;
        TransactionTxt      transactionTxt;

        // get the text defined for ledger reversing entries
        transactionTxt = TransactionTxt::construct(LedgerTransTxt::LedgerReversingEntry);

        if (this.checkReversingEntry())
        {
            throw error("@SYS116157");
        }

        while select forupdate updLedgerJournalTrans order by Voucher where
                updLedgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum &&
                updLedgerJournalTrans.ReverseEntry
        {
            if (!prevVoucher || prevVoucher != updLedgerJournalTrans.Voucher)
            {
                if (ledgerJournalName.NewVoucher == NewVoucher::OneVoucher ||
                    ledgerJournalName.NewVoucher == NewVoucher::Manually)
                {
                    newVoucher = updLedgerJournalTrans.Voucher;
                }
                else
                {
                    numberSeq   = NumberSeq::newGetVoucherFromId(_numberSequenceTableRecId, false, false);
                    newVoucher = numberSeq.voucher();
                    numberSeq.used();
                }

                prevVoucher = updLedgerJournalTrans.Voucher;

                // set the originating voucher into the transaction text defined for ledger reversing entries
                transactionTxt.setVoucher(updLedgerJournalTrans.Voucher);
                transactionTxt.setDate(updLedgerJournalTrans.ReverseDate);
                transactionTxt.setFormLetter(LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(updLedgerJournalTrans.LedgerDimension));
                transactionTxt.setLanguage(currentUserLanguage());

                if (TransactionTextContext::isTypeSupported(LedgerTransTxt::LedgerReversingEntry))
                {
                    TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(LedgerTransTxt::LedgerReversingEntry);
                    transactionTextContext.setTableBuffer(updLedgerJournalTrans);
                    transactionTxt.setTransactionTextContext(transactionTextContext);
                }
            }

            this.createReverseEntryJournalLine(updLedgerJournalTrans, newVoucher, transactionTxt.txt());

            // Use doUpdate() instead of update() since the only value being
            // changed is the link to the reversing entry. Since that does not
            // impact taxes or the other validation done in the update() method,
            // that code can all be skipped to save processing time.
            updLedgerJournalTrans.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReverseEntryJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a reversing entry <c>LedgerJournalTrans</c> record that uses the specified voucher and
    ///    transaction text that offsets the <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record for which to create the reversing entry
    ///    <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher to use when you are creating the reversing <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_transactionTxt">
    ///    The transaction text to use when you are creating the reversing <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <remarks>
    ///    This method also creates reversing child records in the <c>LedgerJournalTrans_Asset</c> table and
    ///    the <c>LedgerJournalTrans_Project</c> tables, if the <c>LedgerJournalTrans</c> record being
    ///    reversed had child records in those tables.
    /// </remarks>
    protected void createReverseEntryJournalLine(
        LedgerJournalTrans      _ledgerJournalTrans,
        Voucher                 _voucher,
        LedgerJournalTransTxt   _transactionTxt)
    {
        LedgerJournalTrans_Asset    ledgerJournalTrans_Asset,
                                    ledgerJournalTransRE_Asset;
        LedgerJournalTrans_Project  ledgerJournalTrans_Project,
                                    ledgerJournalTransRE_Project;
        LedgerJournalTrans_RAsset   ledgerJournalTrans_RAsset,
                                    ledgerJournalTransRE_RAsset;

        // <GIN>
        LedgerJournalTransTaxExtensionIN    ledgerJournalTransTaxExtensionIN;
        // </GIN>

        LedgerJournalTrans ledgerJournalTransRE = this.populateReverseEntryJournalLine(_ledgerJournalTrans, _voucher, _transactionTxt);

        boolean isTaxIntegrationEnabled = TaxIntegrationUtils::isTaxIntegrationEnabledForJournalType(ledgerJournalTable.JournalType);
        if (isTaxIntegrationEnabled)
        {
            // Do not calculate tax. The reverse tax will be inserted.
            LedgerJournalTransRE.DelayTaxCalculation = NoYes::Yes;
        }

        ledgerJournalTransRE.insert();

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]) &&
            !ledgerJournalTransRE.ledgerJournalTransTaxExtensionIN())
        {
            ledgerJournalTransTaxExtensionIN = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN().data();
            ledgerJournalTransTaxExtensionIN.LedgerJournalTrans = ledgerJournalTransRE.RecId;
            ledgerJournalTransTaxExtensionIN.insert();
        }
        // </GIN>

        if (isTaxIntegrationEnabled)
        {
            ledgerJournalTransRE.VATNumJournal = _ledgerJournalTrans.VATNumJournal;
            LedgerJournalTransTaxExtension::copyLedgerJournalTransTaxExtension(_ledgerJournalTrans, ledgerJournalTransRE, true);
        }

        this.populateReverseEntryJournalLineForUpdate(_ledgerJournalTrans, ledgerJournalTransRE);
        
        ledgerJournalTransRE.doUpdate();

        // generate the taxes for the reversal based on the taxes of the original line to insure modified amounts are reversed.
        TaxReverse::reverseTaxUncommitted(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId, ledgerJournalTransRE.TableId, ledgerJournalTransRE.RecId, _voucher, _ledgerJournalTrans.ReverseDate);

        if (_ledgerJournalTrans.isFixedAssetsTransaction())
        {
            // create new child asset line from existing
            ledgerJournalTrans_Asset = LedgerJournalTrans_Asset::find(_ledgerJournalTrans.RecId);
            if (ledgerJournalTrans_Asset)
            {
                ledgerJournalTransRE_Asset.data(ledgerJournalTrans_Asset.data());
                ledgerJournalTransRE_Asset.RecId = 0;
                ledgerJournalTransRE_Asset.RefRecId = ledgerJournalTransRE.RecId;
                ledgerJournalTransRE_Asset.insert();
            }
        }

        if (_ledgerJournalTrans.isProjectTransaction())
        {
            // create new child project line from existing
            ledgerJournalTrans_Project = LedgerJournalTrans_Project::find(_ledgerJournalTrans.RecId);
            if (ledgerJournalTrans_Project)
            {
                ledgerJournalTransRE_Project.data(ledgerJournalTrans_Project.data());
                ledgerJournalTransRE_Project.RecId = 0;
                ledgerJournalTransRE_Project.RefRecId = ledgerJournalTransRE.RecId;
                ledgerJournalTransRE_Project.TransId = ProjCostTrans::newTransId();
                ledgerJournalTransRE_Project.Qty = -ledgerJournalTrans_Project.Qty;
                ledgerJournalTransRE_Project.ProjTransDate = ledgerJournalTransRE.TransDate;
                ledgerJournalTransRE_Project.insert();
            }
        }

        if (_ledgerJournalTrans.isFixedAssetsTransaction_RU())
        {
            ledgerJournalTrans_RAsset = LedgerJournalTrans_RAsset::find(_ledgerJournalTrans.RecId);
            if (ledgerJournalTrans_RAsset)
            {
                ledgerJournalTransRE_RAsset.data(ledgerJournalTrans_RAsset.data());
                ledgerJournalTransRE_RAsset.RecId = 0;
                ledgerJournalTransRE_RAsset.RefRecId = ledgerJournalTransRE.RecId;
                ledgerJournalTransRE_RAsset.insert();
            }
        }

        _ledgerJournalTrans.RevRecId = ledgerJournalTransRE.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateReverseEntryJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Populates the reversing entry <c>LedgerJournalTrans</c> record that uses the specified voucher and
    ///    transaction text that offsets the <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record for which to base field values on the reversing entry
    ///    <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher to use when you are creating the reversing <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_transactionTxt">
    ///    The transaction text to use when you are creating the reversing <c>LedgerJournalTrans</c> record.
    /// </param>
    protected LedgerJournalTrans populateReverseEntryJournalLine(
        LedgerJournalTrans      _ledgerJournalTrans,
        Voucher                 _voucher,
        LedgerJournalTransTxt   _transactionTxt)
    {
        LedgerJournalTrans ledgerJournalTransRE;

        // <GEERU>
        #isoCountryRegionCodes
        boolean                     countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        
        ledgerJournalTransRE.JournalNum         = ledgerJournalTable.JournalNum;
        ledgerJournalTransRE.Voucher            = _voucher;
        ledgerJournalTransRE.TransDate          = _ledgerJournalTrans.ReverseDate;
        ledgerJournalTransRE.AccountType        = _ledgerJournalTrans.AccountType;
        ledgerJournalTransRE.LedgerDimension    = _ledgerJournalTrans.LedgerDimension;
        ledgerJournalTransRE.OffsetAccountType  = _ledgerJournalTrans.OffsetAccountType;
        ledgerJournalTransRE.OffsetLedgerDimension = _ledgerJournalTrans.OffsetLedgerDimension;
        ledgerJournalTransRE.SettleVoucher      = _ledgerJournalTrans.SettleVoucher ;
        ledgerJournalTransRE.CurrencyCode       = _ledgerJournalTrans.CurrencyCode;
        ledgerJournalTransRE.PaymReference      = _ledgerJournalTrans.PaymReference;
        ledgerJournalTransRE.Txt                = _transactionTxt ? _transactionTxt : _ledgerJournalTrans.Txt;
        ledgerJournalTransRE.OffsetTxt          = _transactionTxt ? _transactionTxt : _ledgerJournalTrans.OffsetTxt;
        ledgerJournalTransRE.ExchRate           = _ledgerJournalTrans.ExchRate;
        ledgerJournalTransRE.ReportingCurrencyExchRate = _ledgerJournalTrans.ReportingCurrencyExchRate;
        ledgerJournalTransRE.ReasonRefRecID = _ledgerJournalTrans.ReasonRefRecID;
        ledgerJournalTransRE.Approved = _ledgerJournalTrans.Approved;
        ledgerJournalTransRE.ExchRateSecond = _ledgerJournalTrans.ExchRateSecond;
        ledgerJournalTransRE.FinTag = _ledgerJournalTrans.FinTag;
        ledgerJournalTransRE.OffsetFinTag = _ledgerJournalTrans.OffsetFinTag;

        if (_ledgerJournalTrans.AmountCurCredit)
        {
            ledgerJournalTransRE.AmountCurDebit = _ledgerJournalTrans.AmountCurCredit;
        }
        else
        {
            ledgerJournalTransRE.AmountCurCredit = _ledgerJournalTrans.AmountCurDebit;
        }

        ledgerJournalTransRE.Qty                = -_ledgerJournalTrans.Qty;

        ledgerJournalTransRE.PostingProfile     = _ledgerJournalTrans.PostingProfile;
        ledgerJournalTransRE.PaymMode           = _ledgerJournalTrans.PaymMode;
        ledgerJournalTransRE.Payment            = _ledgerJournalTrans.Payment;
        if (InvoiceJournalPaymentScheduleFeature::isEnabled()
            && ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister)
        {
            ledgerJournalTransRE.PaymSched      = _ledgerJournalTrans.PaymSched;
        }
        ledgerJournalTransRE.Company            = _ledgerJournalTrans.Company;
        ledgerJournalTransRE.OffsetCompany      = _ledgerJournalTrans.OffsetCompany;
        ledgerJournalTransRE.DefaultDimension   = _ledgerJournalTrans.DefaultDimension;
        ledgerJournalTransRE.OffsetDefaultDimension = _ledgerJournalTrans.OffsetDefaultDimension;
        ledgerJournalTransRE.TransactionType    = _ledgerJournalTrans.TransactionType;
        ledgerJournalTransRE.DocumentDate       = _ledgerJournalTrans.DocumentDate;
        ledgerJournalTransRE.DocumentNum        = _ledgerJournalTrans.DocumentNum;
        ledgerJournalTransRE.Invoice            = _ledgerJournalTrans.Invoice;

        // <GEERU>
        if (countryRegion_RU)
        {
            ledgerJournalTransRE.AccountAgreementId_RU       = _ledgerJournalTrans.AccountAgreementId_RU;
            ledgerJournalTransRE.OffsetAccountAgreementId_RU = _ledgerJournalTrans.OffsetAccountAgreementId_RU;
        }
        // </GEERU>

        // <GCN>
        if (LedgerParameters::isChineseVoucher_CN())
        {
            ledgerJournalTransRE.Voucher_CN             = NumberSeq_Voucher_CN::newGetVoucherFromCode(
                LedgerVoucherType_CN::find(_ledgerJournalTrans.LedgerVoucherType_CN).NumberSequenceTable,
                _ledgerJournalTrans.ReverseDate).voucher();
            ledgerJournalTransRE.LedgerVoucherType_CN   = _ledgerJournalTrans.LedgerVoucherType_CN;
        }
        // </GCN>

        // <GEERU><GEEU>
        if (RCashParameters::isCashModuleEnabled())
        {
            ledgerJournalTransRE.OffsetPostingProfile_RU     = _ledgerJournalTrans.OffsetPostingProfile_RU;
        }
        // </GEERU></GEEU>

        return ledgerJournalTransRE;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateReverseEntryJournalLineForUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates fields on the reversing entry <c>LedgerJournalTrans</c> record that need to be updated after the initial insert of the record.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record for which to base field values on the updated version of the reversing entry
    ///    <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTransRE">
    ///     The <c>LedgerJournalTrans</c> record for the reversing entry.
    /// </param>
    protected void populateReverseEntryJournalLineForUpdate(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTrans _ledgerJournalTransRE)
    {
        boolean countryRegion_PL = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]);

        // need to set the tax codes after the insert because the taxes are calculated during the insert if the tax codes are set.
        _ledgerJournalTransRE.TaxCode            = _ledgerJournalTrans.TaxCode;
        _ledgerJournalTransRE.TaxGroup           = _ledgerJournalTrans.TaxGroup;
        _ledgerJournalTransRE.TaxItemGroup       = _ledgerJournalTrans.TaxItemGroup;

        if (countryRegion_PL && LedgerJournalPopulateReverseEntryFlight_PL::instance().isEnabled())
        {
            _ledgerJournalTransRE.VatDueDate_W = _ledgerJournalTrans.VatDueDate_W;
            _ledgerJournalTransRE.Addressing_PL = _ledgerJournalTrans.Addressing_PL;
            _ledgerJournalTransRE.CustVendName_PL = _ledgerJournalTrans.CustVendName_PL;
            _ledgerJournalTransRE.CustVendAccount_PL = _ledgerJournalTrans.CustVendAccount_PL;
            _ledgerJournalTransRE.TaxPeriodPaymentCode_PL = _ledgerJournalTrans.TaxPeriodPaymentCode_PL;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFromPool</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes records from the ledger transaction pool for the specified voucher and invoice.
    /// </summary>
    /// <param name="_voucher">
    ///    The voucher to delete.
    /// </param>
    /// <param name="_invoice">
    ///    The invoice to delete; optional.
    /// </param>
    protected void deleteFromPool(
        Voucher     _voucher,
        InvoiceId   _invoice = '')
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayProgress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the posting progress text.
    /// </summary>
    /// <param name = "_voucher">
    /// The voucher of the transaction being posted.
    /// </param>
    /// <param name = "_transDate">
    /// The date of the transaction being posted.
    /// </param>
    void displayProgress(
        Voucher     _voucher,
        TransDate   _transDate)
    {
        if (!progressBarHide)
        {
            this.progressUpdate(strFmt("@SYS26801", _voucher, date2StrUsr(_transDate, DateFlags::FormatAll)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertInVoucherErrorList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts an vouchers error into the error list.
    /// </summary>
    /// <param name = "_voucher">The voucher.</param>
    public void insertInVoucherErrorList(Voucher _voucher)
    {
        Voucher voucher;

        if (tmpVoucherMap)
        {
            voucher = tmpVoucherMap.lookup(_voucher);
            errorTmpVoucherMap.insert(_voucher, voucher);
        }
        else
        {
            voucher = _voucher;
        }

        if (transferErrors)
        {
            if (!voucherErrorList.in(voucher))
            {
                voucherErrorList.add(voucher);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isApprovalJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns if the journal being posted is an Approval journal.
    /// </summary>
    /// <returns>
    /// false.
    /// </returns>
    protected boolean isApprovalJournal()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>keepJournalValidationLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the journal validation log will be kept.
    /// </summary>
    /// <returns>
    /// true if the journal validation log will be kept; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method returns true by default. Override this method to return false if the journal validation
    /// log should not be kept.
    /// </remarks>
    protected boolean keepJournalValidationLog()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldRecalculateExchRateForOffsetAccount</Name>
				<Source><![CDATA[
    private boolean shouldRecalculateExchRateForOffsetAccount(ExchRate _exchRate)
    {
        return !LedgerInterCompanyExchRateForOffsetAccountFlight::instance().isEnabled() || _exchRate == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalTransOffset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets up the journal line based on the offset values on the line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_swappedAcToPostTaxedFirst">
    /// Set to true when the transaction has the customer or vendor and primary account and ledger as the offset account.
    /// In this case, the ledger (offset) account is posted first (which already is done).
    /// </param>
    /// <returns>
    /// The <c>LedgerJournalTrans</c> record.
    /// </returns>
    protected LedgerJournalTrans ledgerJournalTransOffset(
        LedgerJournalTrans  _ledgerJournalTrans,
        boolean             _swappedAcToPostTaxedFirst = false)
    {
        LedgerRecId ledgerRecIdLocal;
        // <GEERU>
        #ISOCountryRegionCodes
        boolean        allowPrepaymentVAT;
        PostingProfile offsetPostingProfile_RU;
        boolean        countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        // <GIN>
        boolean checkTaxParameters = TaxParameters::checkTaxParameters_IN();
        // </GIN>

        if (_ledgerJournalTrans.OffsetLedgerDimension)
        {
            // <GIN>
            if (checkTaxParameters)
            {
                if ((_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger       ||
                     _ledgerJournalTrans.AccountType == LedgerJournalACType::Project)     &&
                        (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger ||
                            _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets ||
                            _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project))
                {
                    _ledgerJournalTrans.TaxGroup    = '';
                    _ledgerJournalTrans.TaxItemGroup= '';

                    if (!TaxVoucherService::ledgerAccountIsVATAccount(_ledgerJournalTrans.OffsetAccountType, _ledgerJournalTrans.OffsetLedgerDimension))
                    {
                        _ledgerJournalTrans.TaxCode     = '';
                    }
                }
                else
                {
                    if (FormulaDesigner_IN::isPriceInclTaxLine(_ledgerJournalTrans.TaxItemGroup))
                    {
                        inclTax = true;

                        if (!TaxVoucherService::ledgerAccountIsVATAccount(_ledgerJournalTrans.OffsetAccountType, _ledgerJournalTrans.OffsetLedgerDimension))
                        {
                            _ledgerJournalTrans.TaxCode     = '';
                        }
                    }
                }
            }
            else
            {
                // </GIN>
                if (_ledgerJournalTrans.ledgerJournalTable().LedgerJournalInclTax)
                {
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        allowPrepaymentVAT = (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust
                                                || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
                                                && _ledgerJournalTrans.Prepayment
                                                && countryRegion_RU;
                        if (!(_ledgerJournalTrans.AccountType != LedgerJournalACType::Ledger &&
                                _ledgerJournalTrans.AccountType != LedgerJournalACType::Project &&
                                (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger ||
                                _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets ||
                                _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project))   &&
                                ! allowPrepaymentVAT)
                        {
                            _ledgerJournalTrans.TaxGroup    = '';
                            _ledgerJournalTrans.TaxItemGroup= '';

                            if (!TaxVoucherService::ledgerAccountIsVATAccount(_ledgerJournalTrans.OffsetAccountType, _ledgerJournalTrans.OffsetLedgerDimension))
                            {
                                _ledgerJournalTrans.TaxCode     = '';
                            }
                        }
                    }
                    else
                    {
                        // </GEERU>

                        if (!(_ledgerJournalTrans.AccountType != LedgerJournalACType::Ledger &&
                                  _ledgerJournalTrans.AccountType != LedgerJournalACType::Project &&
                                 (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger ||
                                  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets ||
                                  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)))
                        {
                            _ledgerJournalTrans.TaxGroup    = '';
                            _ledgerJournalTrans.TaxItemGroup= '';

                            if (!TaxVoucherService::ledgerAccountIsVATAccount(_ledgerJournalTrans.OffsetAccountType, _ledgerJournalTrans.OffsetLedgerDimension))
                            {
                                _ledgerJournalTrans.TaxCode     = '';
                            }
                        }
                        // <GEERU>
                    }
                    // </GEERU>
                }
                else
                {
                    if ((_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger       ||
                             _ledgerJournalTrans.AccountType == LedgerJournalACType::Project)     &&
                            (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger ||
                             _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets ||
                             _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project))
                    {
                        _ledgerJournalTrans.TaxGroup    = '';
                        _ledgerJournalTrans.TaxItemGroup= '';

                        if (!TaxVoucherService::ledgerAccountIsVATAccount(_ledgerJournalTrans.OffsetAccountType, _ledgerJournalTrans.OffsetLedgerDimension))
                        {
                            _ledgerJournalTrans.TaxCode     = '';
                        }
                    }
                }

                // <GIN>
            }
            if (checkTaxParameters  &&
                FormulaDesigner_IN::isPriceInclTaxLine(_ledgerJournalTrans.TaxItemGroup))
            {
                if (_ledgerJournalTrans.AccountType       == LedgerJournalACType::FixedAssets &&
                    _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
                {
                    inclTax = true;

                    if (!TaxVoucherService::ledgerAccountIsVATAccount(_ledgerJournalTrans.OffsetAccountType, _ledgerJournalTrans.OffsetLedgerDimension))
                    {
                        _ledgerJournalTrans.TaxCode     = '';
                    }
                }
            }
            else
            {
                if (checkTaxParameters)
                {
                    if (_ledgerJournalTrans.AccountType       == LedgerJournalACType::FixedAssets &&
                        _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
                    {
                        _ledgerJournalTrans.TaxGroup    = '';
                        _ledgerJournalTrans.TaxItemGroup= '';

                        if (!TaxVoucherService::ledgerAccountIsVATAccount(_ledgerJournalTrans.OffsetAccountType, _ledgerJournalTrans.OffsetLedgerDimension))
                        {
                            _ledgerJournalTrans.TaxCode     = '';
                        }
                    }

                    if (_ledgerJournalTrans.AccountType       == LedgerJournalACType::Ledger &&
                        _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets &&
                        _ledgerJournalTrans.AmountCurCredit)
                    {
                        _ledgerJournalTrans.TaxGroup    = '';
                        _ledgerJournalTrans.TaxItemGroup= '';

                        if (!TaxVoucherService::ledgerAccountIsVATAccount(_ledgerJournalTrans.OffsetAccountType, _ledgerJournalTrans.OffsetLedgerDimension))
                        {
                            _ledgerJournalTrans.TaxCode     = '';
                        }
                    }
                }
                else
                {
                    // </GIN>
                    if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets
                        && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
                    {
                        _ledgerJournalTrans.TaxGroup    = '';
                        _ledgerJournalTrans.TaxItemGroup= '';

                        if (!TaxVoucherService::ledgerAccountIsVATAccount(_ledgerJournalTrans.OffsetAccountType, _ledgerJournalTrans.OffsetLedgerDimension))
                        {
                            _ledgerJournalTrans.TaxCode     = '';
                        }
                    }

                    // <GIN>
                }
            }
            // </GIN>

            switch (_ledgerJournalTrans.AccountType)
            {
                case LedgerJournalACType::Vend:
                    _ledgerJournalTrans.PoolRecId       = 0;
                    _ledgerJournalTrans.SettleVoucher   = SettlementType::None;
                    break;

                case LedgerJournalACType::Cust:
                    _ledgerJournalTrans.SettleVoucher   = SettlementType::None;
                    if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
                    {
                        _ledgerJournalTrans.Invoice = '';
                    }
                    break;
            }

            if (_ledgerJournalTrans.Company != curext() &&
               !this.parmPost())
            {
                ledgerRecIdLocal = Ledger::primaryLedger(CompanyInfo::findDataArea(_ledgerJournalTrans.company()).RecId);

                if (_ledgerJournalTrans.CurrencyCode != Ledger::accountingCurrency(CompanyInfo::current()))
                {
                    if (this.shouldRecalculateExchRateForOffsetAccount(_ledgerJournalTrans.ExchRate))
                    {
                        _ledgerJournalTrans.ExchRate       = ExchangeRateHelper::getExchangeRate1_Static(ledgerRecIdLocal,
                                                                                                     _ledgerJournalTrans.CurrencyCode,
                                                                                                     _ledgerJournalTrans.TransDate);
                        _ledgerJournalTrans.ExchRateSecond = ExchangeRateHelper::getExchangeRate2_Static(ledgerRecIdLocal,
                                                                                                     _ledgerJournalTrans.CurrencyCode,
                                                                                                     _ledgerJournalTrans.TransDate);
                    }
                }

                if (_ledgerJournalTrans.CurrencyCode != Ledger::reportingCurrency())
                {
                    if (this.shouldRecalculateExchRateForOffsetAccount(_ledgerJournalTrans.ReportingCurrencyExchRate))
                    {
                        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newExchangeDate(ledgerRecIdLocal, _ledgerJournalTrans.CurrencyCode, _ledgerJournalTrans.TransDate);
                        exchangeRateHelper.parmToCurrency(Ledger::reportingCurrency());
                        exchangeRateHelper.parmExchangeRateTypeRecId(Ledger::reportingCurrencyExchangeRateType());
                        _ledgerJournalTrans.ReportingCurrencyExchRate = exchangeRateHelper.getExchangeRate1();
                        _ledgerJournalTrans.ReportingCurrencyExchRateSecondary = exchangeRateHelper.getExchangeRate2();
                    }
                }
            }

            // <GEERU>
            offsetPostingProfile_RU = _ledgerJournalTrans.OffsetPostingProfile_RU;
            // </GEERU>

            _ledgerJournalTrans.swapAccountOffsetAccount();
            _ledgerJournalTrans.OffsetLedgerDimension = 0;
            _ledgerJournalTrans.OffsetAccountType = _ledgerJournalTrans.AccountType;
            _ledgerJournalTrans.FurtherPostingType = false;

            // Third party bank account fields need to be cleared, when accounts are swapped for posting.
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::vend
                && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::vend)
            {
                _ledgerJournalTrans.VendBankAccount = 0;
                _ledgerJournalTrans.CustVendBankAccountId = "";
            }

            // <GEERU>
            if (!_swappedAcToPostTaxedFirst && ! offsetPostingProfile_RU)
            // </GEERU>
            {
                if (LedgerJournalName::isNegotiableInstrumentJournal(ledgerJournalTable.JournalType))
                {
                    _ledgerJournalTrans.PostingProfile = CustVendNegInstPost::getPostingProfile(LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalType,
                                                                                                _ledgerJournalTrans.BankRemittanceType);
                }
                else
                {
                    _ledgerJournalTrans.PostingProfile = '';
                }
            }

            // The _swappedAcToPostTaxedFirst is set to true when the transaction has the
            // customer or vendor and primary account and ledger as the offset account.
            // In this case, the ledger (offset) account is posted first (which already is done).
            // The ledgerJournalTransOffset() is now swapping the account to get ready to post
            // the customer or vendor.  So when _swappedAcToPostTaxedFirst is true and the
            // account is customer or vendor don't change the value of checkNoSettlement
            // but in all other cases it should be set to false.
            if (!(_swappedAcToPostTaxedFirst == true &&
                (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
                 _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)))
            {
                checkNoSettlement = false;
            }
        }
        else
        {
            // <GIN>
            if (checkTaxParameters)
            {
                inclTax = false;
            }
            // </GIN>
            _ledgerJournalTrans.LedgerDimension = 0;
            _ledgerJournalTrans.AmountCurDebit  = 0;
            _ledgerJournalTrans.AmountCurCredit = 0;
        }

        return _ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerTransferToJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfers a journal.
    /// </summary>
    /// <param name = "_ledgerJournalId">
    /// The ID of the journal to transfer.
    /// </param>
    public void ledgerTransferToJournal(LedgerJournalId _ledgerJournalId)
    {
        // Please note that this is only apply to posting "vendor invoice register" journals
    }

]]></Source>
			</Method>
			<Method>
				<Name>movePostedTaxes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows subclasses to create a new set of tax transactions.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// Boolean value indicating if the journal is being posted or not.
    /// <param name = "_posting"></param>
    protected void movePostedTaxes(
        LedgerJournalTrans _ledgerJournalTrans,
        boolean            _posting = true)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveTransferredBack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves transferred journal lines back to the journal.
    /// </summary>
    protected void moveTransferredBack()
    {
        LedgerJournalTrans  ledgerJournalTrans;
        LedgerJournalTable  ledgerJournalTableLocal;

        if (errorLedgerJournalId)
        {
            ttsbegin;

            ledgerJournalTrans.skipDataMethods(true);
            update_recordset ledgerJournalTrans
                setting JournalNum = ledgerJournalTable.JournalNum
                where ledgerJournalTrans.JournalNum == errorLedgerJournalId;

            delete_from ledgerJournalTableLocal
                where ledgerJournalTableLocal.JournalNum == errorLedgerJournalId;

            [ledgerJournalTable.JournalTotalDebit,
             ledgerJournalTable.JournalTotalCredit,
             ledgerJournalTable.JournalTotalOffsetBalance,
             ledgerJournalTable.JournalTotalDebitReportingCurrency,
             ledgerJournalTable.JournalTotalCreditReportingCurrency] = LedgerJournalTable::journalBalanceMST(ledgerJournalId);

            ttscommit;

            errorJournalDeleted = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        this.resetInternals();
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetInternals</Name>
				<Source><![CDATA[
    private void resetInternals()
    {
        interCompanyCompanies   = new Set(Types::String);
        interCompanyJournalIds  = new Map(Types::String, Types::String);
        interCompanyVouchers    = new Map(Types::String, Types::String);
        interCompanyVouchers_CN = new Map(Types::String, Types::String);
        bankAccountBalances     = new Map(Types::Int64, Types::Container);
        mapJournalEntry         = new Map(Types::Class, Types::Class);
        voucherErrorList        = new Set(Types::String);
        showErrorOk             = true;
        checkPaymStatus         = true;

        taxWorkRegulationList   = new RecordSortedList(tableNum (TaxWorkRegulation));
        taxWorkRegulationList.sortOrder(fieldNum(TaxWorkRegulation, RecId));

        isLetterOfCreditEnabled = BankLCImportFeatureChecker::checkBankLCImportEnabled() || BankLCExportFeatureChecker::checkBankLCExportEnabled();

        postingResults = LedgerJournalCheckPostResults::construct();

        perfMonitor = LedgerJournalPostPerformanceMonitor::newMonitor();
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfErrorsInList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Number of errors in the error list.
    /// </summary>
    /// <returns>The number of errors</returns>
    public Counter numOfErrorsInList()
    {
        return voucherErrorList.elements();
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfVouchersBooked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Number of vouchers booked.
    /// </summary>
    /// <returns>The number of vouchers booked.</returns>
    public Counter numOfVouchersBooked()
    {
        return numOfVouchersBooked - voucherErrorList.elements();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDurationCheckJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// The check jounal duration in millseconds.
    /// </summary>
    /// <returns>
    /// Duration in milliseconds.
    /// </returns>
    public int64 parmDurationCheckJournal()
    {
        return durationCheckJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDurationPostJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// The post journal in milliseconds.
    /// </summary>
    /// <returns>
    /// Duration in milliseconds.
    /// </returns>
    public int64 parmDurationPostJournal()
    {
        return durationPostJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankFeeCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the count of bank fees.
    /// </summary>
    /// <param name = "_bankFeeCount">The bank fee count.</param>
    /// <returns>The current count of bank fees.</returns>
    public int parmBankFeeCount(int _bankFeeCount = bankFeeCount)
    {
        bankFeeCount = _bankFeeCount;

        return bankFeeCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankFeeList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the list of bank fees.
    /// </summary>
    /// <param name = "_bankFeeList">The bank fee list.</param>
    /// <returns>The current list of bank fees.</returns>
    public RecordSortedList parmBankFeeList(RecordSortedList _bankFeeList = bankFeeList)
    {
        bankFeeList = _bankFeeList;

        return bankFeeList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBeQuiet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or set the be quiet setting.
    /// </summary>
    /// <param name = "_beQuiet">The be quiet setting.</param>
    /// <returns>The current value of the be quiet setting.</returns>
    public boolean parmBeQuiet(boolean _beQuiet = bquiet)
    {
        bquiet = _beQuiet;

        return bquiet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNewCompanyCon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the new company container.
    /// </summary>
    /// <param name = "_newCompanyCon">The new company container.</param>
    /// <returns>The current value of the new company container.</returns>
    public container parmNewCompanyCon(container _newCompanyCon = newCompanyCon)
    {
        newCompanyCon = _newCompanyCon;

        return newCompanyCon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNewVendIdCon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the new vendor Id container.
    /// </summary>
    /// <param name = "_newVendIdCon">The new vendor Id container. </param>
    /// <returns>The current value of the new vendor Ids.</returns>
    public container parmNewVendIdCon(container _newVendIdCon = newVendIdCon)
    {
        newVendIdCon = _newVendIdCon;

        return newVendIdCon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNewJournalNumCon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the new journal number container.
    /// </summary>
    /// <param name = "_newJournalNumCon">The new journal number container.</param>
    /// <returns>The current value of the new journal number container.</returns>
    public container parmNewJournalNumCon(container _newJournalNumCon = newJournalNumCon)
    {
        newJournalNumCon = _newJournalNumCon;

        return newJournalNumCon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFromInterCompanyTradingValueMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the from intercompany trading value map.
    /// </summary>
    /// <param name = "_fromInterCompanyTradingValueMap">The from intercompany trading value map.</param>
    /// <returns>The from intercompany trading value map.</returns>
    public InterCompanyTradingValueMap parmFromInterCompanyTradingValueMap(InterCompanyTradingValueMap _fromInterCompanyTradingValueMap = fromInterCompanyTradingValueMap)
    {
        fromInterCompanyTradingValueMap = _fromInterCompanyTradingValueMap;

        return fromInterCompanyTradingValueMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmToInterCompanyTradingValueMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the to intercompany trading value map.
    /// </summary>
    /// <param name = "_toInterCompanyTradingValueMap">The to intercompany trading value map.</param>
    /// <returns>The current value of the to intercompany trading value map.</returns>
    public InterCompanyTradingValueMap parmToInterCompanyTradingValueMap(InterCompanyTradingValueMap _toInterCompanyTradingValueMap = fromInterCompanyTradingValueMap)
    {
        toInterCompanyTradingValueMap = _toInterCompanyTradingValueMap;

        return toInterCompanyTradingValueMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmToInterCompanyEndpointActionPolicy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the intercompany endpoint action policy.
    /// </summary>
    /// <param name = "_toInterCompanyEndpointActionPolicy">The intercompany endpoint action policy.</param>
    /// <returns>The current value of the intercompany endpoint action policy.</returns>
    public InterCompanyEndpointActionPolicy parmToInterCompanyEndpointActionPolicy(InterCompanyEndpointActionPolicy _toInterCompanyEndpointActionPolicy = toInterCompanyEndpointActionPolicy)
    {
        toInterCompanyEndpointActionPolicy = _toInterCompanyEndpointActionPolicy;

        return toInterCompanyEndpointActionPolicy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmErrorLedgerJournalId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the error journal number.
    /// </summary>
    /// <param name = "_errorLedgerJournalId">The error journal number.</param>
    /// <returns>The current value of the error journal number.</returns>
    public ledgerJournalId parmErrorLedgerJournalId(ledgerJournalId _errorLedgerJournalId = errorLedgerJournalId)
    {
        errorLedgerJournalId = _errorLedgerJournalId;

        return errorLedgerJournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmErrorTmpVoucherMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the Error temporary voucher map.
    /// </summary>
    /// <param name = "_errorTmpVoucherMap">The Error temporary voucher map.</param>
    /// <returns>The current value of the Error temporary voucher map.</returns>
    public Map parmErrorTmpVoucherMap(Map _errorTmpVoucherMap = errorTmpVoucherMap)
    {
        errorTmpVoucherMap = _errorTmpVoucherMap;

        return errorTmpVoucherMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmErrorJournalDeleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the deleted journal.
    /// </summary>
    /// <param name = "_errorJournalDeleted">The deleted journal.</param>
    /// <returns>The current deleted journal.</returns>
    public boolean parmErrorJournalDeleted(boolean _errorJournalDeleted = errorJournalDeleted)
    {
        errorJournalDeleted = _errorJournalDeleted;

        return errorJournalDeleted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetCheckInterCompanyVouchers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the map of budget check inter company vouchers.
    /// </summary>
    /// <param name = "_budgetCheckInterCompanyVouchers">The map of budget check inter company vouchers.</param>
    /// <returns>The current map of budget check inter company vouchers.</returns>
    public Map parmBudgetCheckInterCompanyVouchers(Map _budgetCheckInterCompanyVouchers = budgetCheckInterCompanyVouchers)
    {
        budgetCheckInterCompanyVouchers = _budgetCheckInterCompanyVouchers;

        return budgetCheckInterCompanyVouchers;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetControlGeneralJournalEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the control general journal enteries.
    /// </summary>
    /// <param name = "_budgetControlGeneralJournalEntries">The control general journal enteries.</param>
    /// <returns>The current control general journal enteries.</returns>
    public Map parmBudgetControlGeneralJournalEntries(Map _budgetControlGeneralJournalEntries = budgetControlGeneralJournalEntries)
    {
        budgetControlGeneralJournalEntries = _budgetControlGeneralJournalEntries;

        return budgetControlGeneralJournalEntries;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetCheckVouchers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the map of budget check vouchers.
    /// </summary>
    /// <param name = "_budgetCheckVouchers">The map of budget check vouchers.</param>
    /// <returns>The current map of budget check vouchers.</returns>
    public Map parmBudgetCheckVouchers(Map _budgetCheckVouchers = budgetCheckVouchers)
    {
        budgetCheckVouchers = _budgetCheckVouchers;

        return budgetCheckVouchers;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckPaymStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the check payment status.
    /// </summary>
    /// <param name = "_checkPaymStatus">The check payment status.</param>
    /// <returns>The current check payment status.</returns>
    public boolean parmCheckPaymStatus(boolean _checkPaymStatus = checkPaymStatus)
    {
        checkPaymStatus = _checkPaymStatus;

        return checkPaymStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDetailSummaryPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the detail summary posting.
    /// </summary>
    /// <param name = "_detailSummaryPosting">The detail summary posting.</param>
    /// <returns>The current detail summary posting.</returns>
    public DetailSummary parmDetailSummaryPosting(DetailSummary _detailSummaryPosting = detailSummaryPosting)
    {
        detailSummaryPosting = _detailSummaryPosting;
        return detailSummaryPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsBudgetControlSourceIntegrationSupported</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets if budget control source integration is supported.
    /// </summary>
    /// <param name = "_isBudgetControlSourceIntegrationSupported">The budget control source integration is supported.</param>
    /// <returns>The current value if budget control source integration is supported.</returns>
    public boolean parmIsBudgetControlSourceIntegrationSupported(boolean _isBudgetControlSourceIntegrationSupported = isBudgetControlSourceIntegrationSupported)
    {
        isBudgetControlSourceIntegrationSupported = _isBudgetControlSourceIntegrationSupported;
        return isBudgetControlSourceIntegrationSupported;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the in transfer parameter.
    /// </summary>
    /// <param name = "_inTransfer">The in transfer parameter.</param>
    /// <returns>The current in transfer parameter.</returns>
    public boolean parmInTransfer(boolean _inTransfer = inTransfer)
    {
        inTransfer = _inTransfer;
        return inTransfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalEntryMap_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value of the map which includes the post proforma data.
    /// </summary>
    /// <param name="_mapJournalEntry">
    /// The new value of the map which includes the post proforma data.
    /// </param>
    /// <returns>
    /// The current value of map which includes the post proforma data.
    /// </returns>
    public Map parmJournalEntryMap_CN(Map _mapJournalEntry = mapJournalEntry)
    {
        mapJournalEntry = _mapJournalEntry;
        return mapJournalEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value of the journal number.
    /// </summary>
    /// <param name = "_ledgerJournalId">The journal number.</param>
    /// <returns>The current value of the journal number.</returns>
    public LedgerJournalId parmJournalNum(LedgerJournalId _ledgerJournalId = ledgerJournalId)
    {
        ledgerJournalId = _ledgerJournalId;
        return ledgerJournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the ledger journal name.
    /// </summary>
    /// <param name = "_ledgerJournalName">The ledger journal name.</param>
    /// <returns>The current ledger journal name.</returns>
    public LedgerJournalName parmLedgerJournalName(LedgerJournalName _ledgerJournalName = ledgerJournalName)
    {
        ledgerJournalName = _ledgerJournalName;
        return ledgerJournalName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the ledger journal table.
    /// </summary>
    /// <param name = "_ledgerJournalTable">The ledger journal table.</param>
    /// <returns>The current ledger journal table.</returns>
    public LedgerJournalTable parmLedgerJournalTable(LedgerJournalTable _ledgerJournalTable = ledgerJournalTable)
    {
        ledgerJournalTable = _ledgerJournalTable;
        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the ledger voucher.
    /// </summary>
    /// <param name = "_ledgerVoucher">The ledger voucher.</param>
    /// <returns>The current ledger voucher.</returns>
    public LedgerVoucher parmLedgerVoucher(LedgerVoucher _ledgerVoucher = ledgerVoucher)
    {
        ledgerVoucher = _ledgerVoucher;
        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRProgressBarHide</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the progress bar hide parameter.
    /// </summary>
    /// <param name = "_progressBarHide">Hide the progress bar.</param>
    /// <returns>The current progress bar hide setting.</returns>
    public boolean parmMCRProgressBarHide(boolean _progressBarHide = progressBarHide)
    {
        progressBarHide = _progressBarHide;
        return progressBarHide;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the post parameter.
    /// </summary>
    /// <param name = "_post">The post parameter.</param>
    /// <returns>The current value of the post parameter.</returns>
    public NoYes parmPost(NoYes _post = post)
    {
        post = _post;

        return post;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingResults</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>LedgerJournalCheckPostResults</c> instance.
    /// </summary>
    /// <param name = "_value">The <c>LedgerJournalCheckPostResults</c> instance.</param>
    /// <returns>The <c>LedgerJournalCheckPostResults</c> instance.</returns>
    public LedgerJournalCheckPostResults parmPostingResults(LedgerJournalCheckPostResults _value = postingResults)
    {
        postingResults = _value;

        return postingResults;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostProforma_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value of the post proforma.
    /// </summary>
    /// <param name="_postProforma">
    /// The new value of the post proforma.
    /// </param>
    /// <returns>
    /// The current value of post proforma.
    /// </returns>
    public boolean parmPostProforma_CN(boolean _postProforma = postProforma)
    {
        postProforma = _postProforma;

        return postProforma;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreview_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the preview setting.
    /// </summary>
    /// <param name = "_parmPreview">The preview setting.</param>
    /// <returns>The current value of the preview setting.</returns>
    public boolean parmPreview_RU(boolean _parmPreview = parmPreview)
    {
        parmPreview = _parmPreview;
        return parmPreview;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rboParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the RBO parameters.
    /// </summary>
    /// <param name = "_rboCustTrans">RBO customer transactions.</param>
    /// <param name = "_rboTransactionId">RBO Transaction id.</param>
    /// <param name = "_rboStoreId">The RBO store id.</param>
    /// <param name = "_rboTerminalId">The RBO terminal id.</param>
    public void rboParameters(RetailCustTrans _rboCustTrans, RetailTransactionId _rboTransactionId, RetailStoreId _rboStoreId, RetailTerminalId _rboTerminalId)
    {
        rboParameters = [_rboCustTrans,_rboTransactionId,_rboStoreId,_rboTerminalId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRetailParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the retail parameters.
    /// </summary>
    public void initRetailParameters()
    {
        [retailCustTrans,retailTransactionId,retailStoreId,retailTerminalId] = rboParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRboParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the RBO parameters.
    /// </summary>
    public container getRboParameters()
    {
        return rboParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProgress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the runbase progress.
    /// </summary>
    /// <param name = "_progress">The runbase progress.</param>
    /// <returns>The current value of the runbase progress.</returns>
    public RunbaseProgress parmProgress(RunbaseProgress _progress = progress)
    {
        progress = _progress;

        return progress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowErrorOk</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or set the show error ok parameter.
    /// </summary>
    /// <param name = "_showErrorOk">The show error ok parameter.</param>
    /// <returns>The current show error ok parameter.</returns>
    public boolean parmShowErrorOk(boolean _showErrorOk = showErrorOk)
    {
        showErrorOk = _showErrorOk;

        return showErrorOk;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSimulatePosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets or sets a value indicating if posting should be simulated.
    /// </summary>
    /// <param name = "_simulatePosting">true if posting should be simulated; otherwise, false.</param>
    /// <returns>The current value of the simulated posting setting.</returns>
    /// <remarks>Posting is simulated to provide better validation.</remarks>
    public boolean parmSimulatePosting(boolean _simulatePosting = simulatePosting)
    {
        simulatePosting = _simulatePosting;

        return simulatePosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxVoucherService</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the tax voucher service.
    /// </summary>
    /// <param name = "_taxVoucherService">The tax voucher service.</param>
    /// <returns>The current tax voucher service.</returns>
    public TaxVoucherService parmTaxVoucherService(TaxVoucherService _taxVoucherService = taxVoucherService)
    {
        taxVoucherService = _taxVoucherService;

        return taxVoucherService;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTdsWarningMsg</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the TDS warning message parameter.
    /// </summary>
    /// <param name = "_tdsWarningMsg">The TDS warning message parameter.</param>
    /// <returns>The current TDS warning message parameter.</returns>
    public boolean parmTdsWarningMsg(boolean _tdsWarningMsg = tdsWarningMsg)
    {
        tdsWarningMsg = _tdsWarningMsg;

        return tdsWarningMsg;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpVoucherMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the temporary voucher map.
    /// </summary>
    /// <param name = "_tmpVoucherMap">The temporary voucher map.</param>
    /// <returns>The current temporary voucher map.</returns>
    public Map parmTmpVoucherMap(Map _tmpVoucherMap = tmpVoucherMap)
    {
        tmpVoucherMap = _tmpVoucherMap;

        return tmpVoucherMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransferErrors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the transfer errors parameter.
    /// </summary>
    /// <param name = "_transferErrors">The transfer errors parameter.</param>
    /// <returns>The current transfer errors parameter.</returns>
    public NoYes parmTransferErrors(NoYes _transferErrors = transferErrors)
    {
        transferErrors = _transferErrors;

        return transferErrors;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the voucher.
    /// </summary>
    /// <param name = "_voucher">The voucher.</param>
    /// <returns>The current voucher.</returns>
    public Voucher parmVoucher(Voucher _voucher = voucherNum)
    {
        voucherNum = _voucher;

        return voucherNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>LedgerVoucher</c> class instance.
    /// </summary>
    /// <param name = "_sysModule">
    /// A <c>SysModule</c> enumeration value.
    /// </param>
    /// <param name = "_numberSequenceId">
    /// A number sequence id.
    /// </param>
    /// <returns>
    /// A <c>LedgerVoucher</c> class instance.
    /// </returns>
    protected LedgerVoucher createLedgerVoucher(SysModule _sysModule, RefRecId _numberSequenceId)
    {
        // <GCN>
        if (postProforma)
        {
            ledgerVoucher = LedgerVoucher::newLedgerPostProforma_CN(detailSummaryPosting,
                                                                    _sysModule,
                                                                    FinNumberSequenceExtension::getNumberSequence(_numberSequenceId),
                                                                    TransactionLogType::LedgerJournal,
                                                                    ledgerJournalTable.JournalNum + ' ' + ledgerJournalTable.Name);
        }
        else
        {
            // </GCN>
            ledgerVoucher = LedgerVoucher::newLedgerPost(detailSummaryPosting,
                                                         _sysModule,
                                                         FinNumberSequenceExtension::getNumberSequence(_numberSequenceId),
                                                         TransactionLogType::LedgerJournal,
                                                         ledgerJournalTable.JournalNum + ' ' + ledgerJournalTable.Name,
                                                         this.isApprovalJournal());
            // <GCN>
        }
        // </GCN>

        ledgerVoucher.parmLedgerJournalId(ledgerJournalTable.JournalNum);
        ledgerVoucher.parmTmpVoucherMap(tmpVoucherMap);
        ledgerVoucher.parmLedgerPostingMessageLog(ledgerPostingMessageCollection);

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts the current instance of a journal.
    /// </summary>
    /// <returns>
    ///    true if the journal was posted; otherwise, false.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The journal is not approved or balanced.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    The account or amount is not set.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    The voucher number is not set for the ledger journal line.
    /// </exception>
    protected container postJournal()
    {
        // <GEERU>
        #isoCountryRegionCodes
        // </GEERU>

        parentVoucherLinkMap = new Map(Types::Container, Types::Int64);
        ledgerPostingMessageCollection = LedgerPostingMessageLog::construct();

        System.Diagnostics.Stopwatch journalPreprocessingStopWatch = perfMonitor.startNewStopwatch();

        transLogPoint = infologLine();
        setPrefix(strFmt("@SYS4004020", ledgerJournalTable.JournalNum));

        // send in true for the fifth parameter to validate even if all the dimensions are empty
        if (!ledgerJournalTable.checkJournalMayBeBooked() || !this.checkEndBalance())
        {
            throw error("@SYS21533");
        }

        this.initBudgetCheckForPostJournal();

        RefRecId numberSequenceId = this.replaceTmpVoucher();  // tempVoucher replaced with real voucher

        SysModule sysModule = ledgerJournalTable.ledgerJournalName().getSysModuleForJournal();

        ledgerVoucher = this.createLedgerVoucher(sysModule, numberSequenceId);

        LedgerJournalCheckPostBank::bankFeeJournal2List(this);

        taxVoucherService = TaxVoucherService::construct(ledgerJournalTable);

        boolean allOK = true;

        if (ledgerJournalTable)
        {
            // Validating bank account corresponding to OffsetAccount and BankAccountId of LedgerJournalTrans on Validate button.
            allOK = this.validateLedgerJournalTableBankAccount(ledgerJournalTable);

            allOK = allOK && ledgerJournalTable.defaultAndValidateReportingExchangeRates(ledgerPostingMessageCollection);

            boolean isProjTrans = LedgerJournalCheckPostProj::validateProjTrans(ledgerJournalTable);
            // Validate budget for the project if budget checking is enabled
            if (!isProjTrans)
            {
                throw Exception::Error;
            }

            // <GIN>
            if (TaxParameters::isServiceTaxEnable_IN())
            {
                allOK = isProjTrans && allOK;
            }
            // </GIN>

            // check for fixed asset journal and check for net book value
            if (ledgerJournalTable.JournalType == LedgerJournalType::Assets)
            {
                // <GEELT>
                if (ledgerJournalTable.AssetTransferType_LT == LtAssetTransferType::TransferJour)
                {
                    allOk = this.assetCheckReverseJournal_LT(ledgerJournalTable.RecId) && allOk;
                    this.updateAssetTransfer_LT();
                }
                else
                {
                    // </GEELT>
                    allOk = LedgerJournalCheckPostAssets::assetValidateNetBookValues(this, ledgerJournalTable.JournalNum) && allOk;

                    // <GCN>
                    if (allOK && AssetParameters::isDepreciationMethodsEnabled())
                    {
                        allOK = allOK && LedgerJournalCheckPost_CN::validateAdjustmentForSYDM(ledgerJournalId);
                    }
                    // </GCN>
                    // <GEELT>
                }
                // </GEELT>
            }
            // check net book value of fixed asset transaction on other that fixed asset journal
            else
            {
                allOK = LedgerJournalCheckPostAssets::assetValidateNetBookValuesNonFA(this, ledgerJournalTable.JournalNum) && allOK;
            }

            // By default payroll disbursements for bank transaction type posting definitions are not required for a Payroll journal.
            canAddPayrollDisbursementEntries = false;

            if (isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration))
                    && ledgerJournalTable.JournalType == LedgerJournalType::PayrollDisbursement)
            {
                // Determine if payroll disbursements for bank transaction type posting definitions are required for a Payroll journal.
                LedgerJournalCheckPostJournalizing::initPayrollDisbursementEntries(ledgerJournalTable.JournalType);
            }

            // Check Posting Restrictions to see if the user has access to post the journal.
            if (LedgerJournalPostControl::postControlEnabledForJournalType(ledgerJournalTable.JournalType) &&
                (ledgerJournalTable.CreatedBy != '')                                                       &&
                (ledgerJournalTable.CreatedBy != curUserId()))
            {
                boolean postingRestricted = LedgerJournalPostControl::userHasPostControl(ledgerJournalTable.JournalName, ledgerJournalTable.JournalType, curUserId());

                if (postingRestricted == true)
                {
                    allOK = checkFailed(strFmt("@SYS116357", ledgerJournalTable.JournalName));
                }
            }
        }

        // Stores transactions that the deductions' parents settled against
        // [RecId, <List of RecId>]
        Map ledgerJournalTransRecIdsByDeduction;
        // Only need to store if journal contains deductions
        if (ledgerJournalTable.mcrHasDeduction())
        {
            ledgerJournalTransRecIdsByDeduction = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Class);
            LedgerJournalCheckPostSales::tamStoreDeductionParentSettlement(ledgerJournalId, ledgerJournalTransRecIdsByDeduction);
        }

        if (FeatureStateProvider::isFeatureEnabled(VendInvoicePostingDateAutoAdjustmentFeature::instance()))
        {
            LedgerJournalCheckPostVendTrans::updateVendTransDate(ledgerJournalTable);
        }

        // calculate taxes
        if (
            // <GTE>
            !isGTEEnabled
            // </GTE>
            && !ledgerJournalTable.isTaxCalculatedForAllJournalTrans())
        {
            TaxVoucherService::calculateTaxForJournal(ledgerJournalTable.JournalNum);
        }

        boolean isLedgerJournalTableCreatedFromTaxJournal = TaxEngineTaxJournalUtil::isLedgerJournalTableCreatedFromTaxJournal(ledgerJournalTable.RecId);
        // <GTE>
        if (isGTEEnabled && !isLedgerJournalTableCreatedFromTaxJournal)
        {
            LedgerJournalTrans ledgerJournalTransLoc;

            while select Voucher, JournalNum from ledgerJournalTransLoc
                group by Voucher, JournalNum
                    where ledgerJournalTransLoc.JournalNum == ledgerJournalTable.JournalNum
            {
                ITaxableDocument taxableDocument = TaxableDocumentObject::construct(
                        TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(ledgerJournalTransLoc));

                TaxBusinessService::calculateTax(taxableDocument);
            }
        }
        // </GTE>

        // <GIN>
        // calculate withhold taxes
        boolean taxWithholdParameterMarked = TaxWithholdParameters_IN::checkTaxParameters();
        if (taxWithholdParameterMarked)
        {
            TaxVoucherService::calculateWithholdTaxForJournal_IN(ledgerJournalTable.JournalNum);
        }
        // </GIN>

        // create reversing entry journal lines so they will be posted with the existing journal lines
        if (this.shouldCreateReversingEntry())
        {
            this.createRevEntries(numberSequenceId);
        }

        LedgerJournalTrans      ledgerJournalTrans;

        // perf: Emit telemetry warnings for large journals
        LedgerJournalCheckPostInstrumentation::logTelemetryForLargeNumberOfJournalLines(ledgerJournalTable.JournalNum);

        // post taxes
        LedgerPostingController ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher);
        
        // <GTE>
        if (!isGTEEnabled)
        {
            // </GTE>
            taxVoucherService.post(ledgerPostingController);
            // <GTE>
        }
        // </GTE>
        // <GTE>
        if (isGTEEnabled && !isLedgerJournalTableCreatedFromTaxJournal)
        {
            Voucher             lastVoucher = ledgerVoucher.lastVoucher();
            TransDate           lastTransDate = ledgerVoucher.lastTransDate();

            LedgerJournalTrans ledgerJournalTransLoc;

            while select Voucher, JournalNum, TransDate from ledgerJournalTransLoc
                group by  Voucher, JournalNum, TransDate
                    where ledgerJournalTransLoc.JournalNum == ledgerJournalTable.JournalNum
            {
                ITaxableDocument taxableDocument = TaxableDocumentObject::construct(
                        TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(ledgerJournalTransLoc));

                ledgerVoucher.lastVoucher(ledgerJournalTransLoc.Voucher);
                ledgerVoucher.lastTransDate(ledgerJournalTransLoc.TransDate);
                TaxBusinessService::postTax(ledgerVoucher, taxableDocument);
                
                if (taxDocumentMapForPosting)
                {
                    taxDocumentMapForPosting.insert([taxableDocument.getTransactionTableId(), taxableDocument.getTransactionRecordId()], ledgerVoucher);
                }
            }

            ledgerVoucher.lastVoucher(lastVoucher);
            ledgerVoucher.lastTransDate(lastTransDate);
        }
        // </GTE>

        // <GIN>
        //post Withhold taxes
        if (taxWithholdParameterMarked)
        {
            taxVoucherService.postWithholdTax_IN(ledgerPostingController);
        }
        // </GIN>

        perfMonitor.trackPreprocessingTime(journalPreprocessingStopWatch.ElapsedMilliseconds);

        // perf: Determine whether the entire journal has any post dated checks before posting
        // to avoid doing a while select for each LedgerJournalTrans to not find anything.
        // This is worse because a while select can't be cached.
        // perf: When the config key for custVendPDCRegister is disabled
        // reading from it creates tables in TempDB. It causes a performance degradation
        // when posting a large number of small journals within a single transaction scope.
        boolean journalHasPDC = CustVendPDCRegister::existsForJournalNum(ledgerJournalTable.JournalNum);

        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        LedgerJournalCheckPost_PostLinesRequest postLinesRequest = new LedgerJournalCheckPost_PostLinesRequest();
        postLinesRequest.allOK = allOK;
        postLinesRequest.journalHasPDC = journalHasPDC;
        postLinesRequest.taxWithholdParameterMarked = taxWithholdParameterMarked;
        postLinesRequest.countryRegion_RU = countryRegion_RU;
        postLinesRequest.sysModule = sysModule;
        postLinesRequest.ledgerJournalTransRecIdsByDeduction = ledgerJournalTransRecIdsByDeduction;

        LedgerJournalCheckPost_PostLinesResult postResult = this.postJournalLines(postLinesRequest);

        allOK = postResult.allOK;
        Map voucherMap = postResult.voucherMap;

        System.Diagnostics.Stopwatch postProcessingStopwatch = perfMonitor.startNewStopwatch();

        if ((ledgerJournalTable) && (ledgerJournalTable.JournalType == LedgerJournalType::Payment))
        {
            // check the pre-defined Over Draft limits for BankAccounts tied to the LedgerJournal
            allOK = allOK && LedgerJournalCheckPostBank::checkOverDraftLimit(bankAccountBalances);
        }

        // <RUP>
        if (countryRegion_RU && isConfigurationkeyEnabled(configurationKeyNum(RPayroll)))
        {
            LedgerjournalCheckPost_RU::createRPayDeferrals(this);
        }
        // </RUP>

        if (journalHasPDC)
        {
            CustVendPDCManager::postDatedCheckPost(ledgerJournalTable.JournalNum);
        }

        // <GIN>
        if (taxWithholdParameterMarked)
        {
            TaxWithholdUncommitted_IN::deleteForDocumentHeader(ledgerJournalTable.TableId, ledgerJournalTable.RecId, false);
        }
        // </GIN>

        boolean allOKIntercompany = true;
        boolean ok;

        if (interCompanyCompanies.elements() > 0)
        {
            // Create a map of the source company voucher's group id's to be consumed in the
            // intercompany posting process which creates the intercompany voucher relations
            MapEnumerator voucherMapEnumerator = voucherMap.getEnumerator();

            while (voucherMapEnumerator.moveNext())
            {
                LedgerJournalTransFieldCache ledgerJournalTransFieldCache = voucherMapEnumerator.currentValue();

                container voucherLinkKey = [ledgerJournalTransFieldCache.parmVoucher(), ledgerJournalTransFieldCache.parmTransDate(), curExt()];

                LedgerTransVoucherLink parentVoucherLink = LedgerTransVoucherLink::findOrCreateParentVoucherLink(
                    ledgerJournalTransFieldCache.parmVoucher(),
                    ledgerJournalTransFieldCache.parmTransDate(),
                    curExt());

                parentVoucherLinkMap.insert(voucherLinkKey, parentVoucherLink.RecId);
            }

            SetEnumerator interCompanyCompaniesEnumerator = interCompanyCompanies.getEnumerator();
            while (interCompanyCompaniesEnumerator.moveNext())
            {
                if (interCompanyJournalIds.exists(interCompanyCompaniesEnumerator.current()))
                {
                    ok = this.postJournalInterCompany(interCompanyCompaniesEnumerator.current(),
                                                      interCompanyJournalIds.lookup(interCompanyCompaniesEnumerator.current()), false);
                    if (!ok)
                    {
                        allOKIntercompany = false;
                    }
                }
                else
                {
                    throw error("@SYS26812");
                }
            }
        }

        taxVoucherService.moveTaxForeignKeyToTaxTrans();

        // after posting, TaxUncommitted records get removed.
        TaxUncommitted::deleteForDocumentHeader(ledgerJournalTable.TableId, ledgerJournalTable.RecId, false);

        // <GEEPL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            ExportSalesInvoiceDomesticTaxVoucher::deleteUnpostedDomesticSalesTaxVoucher(ledgerJournalTable.JournalNum);
        }
        // </GEEPL>

        if (countryRegion_RU)
        {
            LedgerJournalCheckPost_RU::createTransLink(this);

            if (ledgerJournalTable.JournalType == LedgerJournalType::RCash)
            {
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00037, funcName());
            }
        }

        if (allOK && allOKIntercompany && LedgerJournalTable && !this.parmSimulatePosting())
        {
            if (ledgerJournalTable.JournalType == LedgerJournalType::CustPayment
                    && RetailMCRChannelTable::mcrEnableOrderCompletionFindByUser()
                    && !LedgerJournalCheckPostCash::mcrValidatePayments(ledgerJournalTable))
            {
                throw error(strFmt("@MCR22377", ledgerJournalTable.JournalNum));
            }
        }

        this.sendBusinessEvents();

        perfMonitor.trackPostprocessingTime(postProcessingStopwatch.ElapsedMilliseconds);

        return [allOK, allOKIntercompany];
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowCreateOrUpdatePostingReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the voucher or transaction date have changed and if the journal line is a first record to create or update posting reference.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_previousVoucher">
    /// The previous voucher.
    /// </param>
    /// <param name = "_previousTransDate">
    /// The previous transaction date.
    /// </param>
    /// <param name = "_first">
    /// A boolean value indicating this is the first line of the journal.
    /// </param>
    /// <returns>
    /// true if the voucher or transaction date have changed or the journal line is the first line; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean allowCreateOrUpdatePostingReference(LedgerJournalTrans _ledgerJournalTrans, Voucher _previousVoucher, TransDate _previousTransDate, boolean _first)
    {
        return (_ledgerJournalTrans.Voucher != _previousVoucher || _ledgerJournalTrans.TransDate != _previousTransDate || _first);
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleConditionalTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Settles conditional tax.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The record of <c>LedgerJournalTrans</c>.</param>
    /// <param name = "_ledgerJournalTable">The record od <c>LedgerJournalTable</c></param>
    private void settleConditionalTax(LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTable _ledgerJournalTable)
    {
        BankParameters bankParameters = BankParameters::find();
        if (bankParameters.EnablePDC && bankParameters.TaxEnablePDCConditionalTax && _ledgerJournalTrans.FurtherPostingRecId)
        {
            LedgerEntry ledgerEntry;
            GeneralJournalAccountEntry generalJournalAccountEntry;
            SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
            GeneralJournalEntry generalJournalEntry;
            LedgerEntryJournal ledgerEntryJournal;
            select firstonly Voucher, AccountingDate, VoucherDataAreaId from subledgerVoucherGeneralJournalEntry
                join generalJournalAccountEntry
                    where generalJournalAccountEntry.GeneralJournalEntry == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                join RecId from generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                        && generalJournalEntry.Ledger == Ledger::current()
                join JournalNumber from ledgerEntryJournal
                    where ledgerEntryJournal.RecId == generalJournalEntry.LedgerEntryJournal
                join * from ledgerEntry
                    where ledgerEntry.RecId == _ledgerJournalTrans.FurtherPostingRecId
                        && generalJournalAccountEntry.RecId == ledgerEntry.GeneralJournalAccountEntry;
 
            LedgerJournalTrans ledgerJournalTransPayment;
            select firstonly ledgerJournalTransPayment
                where ledgerJournalTransPayment.Voucher == subledgerVoucherGeneralJournalEntry.Voucher
                    && ledgerJournalTransPayment.TransDate == subledgerVoucherGeneralJournalEntry.AccountingDate
                    && ledgerJournalTransPayment.JournalNum == LedgerEntryJournal.JournalNumber
                    && ledgerJournalTransPayment.DataAreaId == subledgerVoucherGeneralJournalEntry.VoucherDataAreaId;

            CustVendACType custVendACType;
            if (ledgerJournalTransPayment.AccountType == LedgerJournalACType::Vend)
            {
                custVendACType = CustVendACType::Vend;
            }
            else if (ledgerJournalTransPayment.AccountType == LedgerJournalACType::Cust)
            {
                CustVendACType = CustVendACType::Cust;
            }
            
            if (ledgerJournalTransPayment)
            {
                CustVendPDCManager::settleConditionalTax(custVendACType, _ledgerJournalTable, ledgerJournalTransPayment, _ledgerJournalTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateReversingEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies whether the reversal entries should be created for the journal.
    /// </summary>
    /// <returns>
    /// Returns true if the journal should include reversal entries; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean shouldCreateReversingEntry()
    {
        return (isConfigurationkeyEnabled(configurationKeyNum(LedgerBasicReversingEntries))
            && ledgerJournalTable.JournalType == LedgerJournalType::Daily);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucherFromLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the last known Voucher and transaction date from <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The <c>LedgerVoucher</c> class object.
    /// </returns>
    protected LedgerVoucher initLedgerVoucherFromLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        ledgerVoucher.lastVoucher(_ledgerJournalTrans.Voucher);
        ledgerVoucher.lastTransDate(_ledgerJournalTrans.TransDate);
  
        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPostingReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create <c>LedgerVoucherObject</c> reference.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_sysModule">
    /// A <c>SysModule</c> enumeration value.
    /// </param>
    /// <returns>
    /// The created <c>LedgerVoucherObject</c> reference.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerVoucherObject createPostingReference(
        LedgerJournalTrans _ledgerJournalTrans,
        SysModule _sysModule)
    {
        return LedgerVoucherObject::newVoucher(
            _ledgerJournalTrans.Voucher,
            _ledgerJournalTrans.TransDate,
            _sysModule,
            _ledgerJournalTrans.TransactionType,
            _ledgerJournalTrans.correct(),
            ledgerJournalTable.CurrentOperationsTax,
            _ledgerJournalTrans.DocumentNum,
            _ledgerJournalTrans.DocumentDate,
            _ledgerJournalTrans.AcknowledgementDate);

    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostingReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>LedgerVoucherObject</c> with information from the specified journal line.
    /// </summary>
    /// <param name = "_postingReference">
    /// The <c>LedgerVoucherObject</c> instance.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_sysModule">
    /// A <c>SysModule</c> enumeration value.
    /// </param>
    /// <returns>
    /// The updated <c>LedgerVoucherObject</c> reference.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerVoucherObject updatePostingReference(
        LedgerVoucherObject _postingReference,
        LedgerJournalTrans _ledgerJournalTrans,
        SysModule _sysModule)
    {
        _postingReference.parmTransactionTypeDefault(_ledgerJournalTrans.TransactionType);
        _postingReference.parmCorrection(_ledgerJournalTrans.correct());
        _postingReference.parmPostingLayer(ledgerJournalTable.CurrentOperationsTax);
        _postingReference.parmDocumentNumber(_ledgerJournalTrans.DocumentNum);
        _postingReference.parmDocumentDate(_ledgerJournalTrans.DocumentDate);
        _postingReference.parmAcknowledgementDate(_ledgerJournalTrans.AcknowledgementDate);
        _postingReference.parmSysModule(_sysModule);

        return _postingReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransactionBeforePosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that a ledger journal line can be posted.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// A ledger journal line to be validated.
    /// </param>
    /// <returns>
    /// true if the line is valid; otherwise, false.
    /// </returns>
    protected boolean validateTransactionBeforePosting(LedgerJournalTrans _ledgerJournalTrans)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSetInterCompanyWitholdingTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether to set inter company witholding tax amount.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    ///     The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_taxWithholdParameterMarked">
    ///     A boolean value.
    /// </param>
    /// <returns>
    ///     true if the inter company witholding tax amount need to set; otherwise, false.
    /// </returns>
    protected boolean shouldSetInterCompanyWitholdingTax_IN(LedgerJournalTrans _ledgerJournalTrans, boolean _taxWithholdParameterMarked)
    {
        return (_taxWithholdParameterMarked && _ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact
                     && _ledgerJournalTrans.Company != _ledgerJournalTrans.OffsetCompany);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Transaction date of <c>LedgerJournalTrans</c> record to next available date.
    /// </summary>
    /// <param name = "_isAccountingDateUpdateAllowed">
    /// The Boolean value that indicates if the accounting date should be updated.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The updated <c>LedgerJournalTrans</c> record.
    /// </returns>
    protected LedgerJournalTrans updateTransDate(boolean _isAccountingDateUpdateAllowed, LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_isAccountingDateUpdateAllowed && _ledgerJournalTrans.isProjectTransaction())
        {
            // updating the TransDate per Voucher record as there will be distinct vouchers for each LedgerJournalTrans in a project journal.
            _ledgerJournalTrans.selectForUpdate(true);
            _ledgerJournalTrans.TransDate = LedgerFiscalCalendarPeriod::findNextAvailableDate(_ledgerJournalTrans.TransDate);
            _ledgerJournalTrans.doUpdate();
        }

        return _ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNegotiableInstrumentPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the negotiable instrument journal is valid for posting.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_journalHasNegotiableInstrument">
    /// Determines if this is a negotiable instrument journal.
    /// </param>
    /// <returns>
    /// true if the negotiable instrument journal is valid for posting; otherwise, false.
    /// </returns>
    protected boolean checkNegotiableInstrumentPosting(LedgerJournalTrans _ledgerJournalTrans, boolean _journalHasNegotiableInstrument)
    {
        boolean returnValue = true;

        if (_journalHasNegotiableInstrument && !_ledgerJournalTrans.checkNegInstPosting(ledgerPostingMessageCollection))
        {
            returnValue = false;
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInterCompanyPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the journal is valid for intercompany posting.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_isCompanyIntercompany">
    /// Identifies whether a company account is intercompany.
    /// </param>
    /// <param name = "_isOffsetCompanyIntercompany">
    /// Identifies whether an offset company account is intercompany.
    /// </param>
    /// <returns>
    /// true if the journal is valid for intercompany posting; otherwise, false.
    /// </returns>
    protected boolean checkInterCompanyPosting(LedgerJournalTrans _ledgerJournalTrans, boolean _isCompanyIntercompany, boolean _isOffsetCompanyIntercompany)
    {
        boolean returnValue = true;

        if ((_isOffsetCompanyIntercompany || _isCompanyIntercompany) && !_ledgerJournalTrans.checkInterCompany(ledgerPostingMessageCollection))
        {
            returnValue = false;
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReleaseDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the release date against the current date.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true if the release date is satisfied (in the past) and the transaction can be posted; otherwise, false.
    /// </returns>
    protected boolean checkReleaseDate(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean returnValue = true;

        if (!_ledgerJournalTrans.checkReleaseDate(ledgerPostingMessageCollection))
        {
            returnValue = false;
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAcknowledgementDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the acknowledgement date against the date on the journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true if the acknowledgement date is on or after the date on the journal line; otherwise, false.
    /// </returns>
    protected boolean checkAcknowledgementDate(LedgerJournalTrans _ledgerJournalTrans, boolean _useAcknowlegementDate)
    {
        boolean returnValue = true;

        if (_useAcknowlegementDate)
        {
            if (ledgerJournalName.JournalType == LedgerJournalType::Daily ||
                ledgerJournalName.JournalType == LedgerJournalType::Assets)
            {
                if (_ledgerJournalTrans.AcknowledgementDate < _ledgerJournalTrans.TransDate)
                {
                    returnValue = false;
                }
            }
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalLineHasRequiredInformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the specified journal line has the information required for posting.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true if the specified journal line has the information required for posting; otherwise, false.
    /// </returns>
    protected boolean journalLineHasRequiredInformation(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean returnValue = true;

        if (!_ledgerJournalTrans.LedgerDimension &&
            !_ledgerJournalTrans.AmountCurCredit &&
            !_ledgerJournalTrans.AmountCurDebit)
        {
            returnValue = false;
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValidUser</Name>
				<Source><![CDATA[
    private boolean checkValidUser(LedgerJournalTrans _ledgerJournalTrans, LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;
                    
        MainAccount mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(_ledgerJournalTrans.LedgerDimension);
                
        MainAccount offsetMainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(_ledgerJournalTrans.OffsetLedgerDimension);
                
        if ((mainAccount.ValidateUser == FieldControl::FillIn ||
            offsetMainAccount.ValidateUser == FieldControl::FillIn)
            && ledgerJournalTable.InUseBy == '')
        {
            if (_ledgerPostingMessageCollection)
            {
                ok = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@GeneralLedger:CheckValidUser", mainAccount.MainAccountId, offsetMainAccount.MainAccountId));
            }
            else
            {
                ok = checkFailed(strFmt("@GeneralLedger:CheckValidUser", mainAccount.MainAccountId, offsetMainAccount.MainAccountId));
            }
        }
 
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelApprovalJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels an approval journal.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true if there are no issues cancelling the approval journal; otherwise, false.
    /// </returns>
    protected boolean cancelApprovalJournal(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean returnValue = true;

        // Cancelling the voucher - Delete the pending invoices only if they aren't being processed in workflow
        if (_ledgerJournalTrans.hasPendingInvoiceInWorkflow())
        {
            returnValue = ledgerPostingMessageCollection.logCheckFailed(strFmt("@AccountsPayable:PendingInvoiceInWorkflowError", _ledgerJournalTrans.Voucher));
            this.insertInVoucherErrorList(_ledgerJournalTrans.Voucher);
        }
        else
        {
            LedgerJournalTrans ledgerJournalTransPool = LedgerJournalTrans::ledgerJournalTransPool(_ledgerJournalTrans);

            if (ledgerJournalTransPool.RecId != 0)
            {
                VendInvoiceInfoTable localVendInvoiceInfoTable;
                delete_from localVendInvoiceInfoTable where localVendInvoiceInfoTable.PoolRecId == ledgerJournalTransPool.RecId;
            }
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournalInterCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts an intercompany journal.
    /// </summary>
    /// <param name = "_companyId">
    /// The ID of company that will have an intercompany journal posted.
    /// </param>
    /// <param name = "_ledgerJournalId">
    /// The journal batch number of the intercompany journal.
    /// </param>
    /// <param name = "_isOffset">
    /// A boolean value that indicates if the intercompany journal is an offset.
    /// </param>
    /// <returns>
    /// true if the intercompany journal was posted successfully; otherwise, false.
    /// </returns>
    protected boolean postJournalInterCompany(
        CompanyId       _companyId,
        LedgerJournalId _ledgerJournalId,
        boolean         _isOffset)
    {
        boolean             ok = true;
        LedgerJournalTrans  ledgerJournalTrans, originalLedgerJournalTrans;
        LedgerJournalTable  ledgerJournalTableInterCompany;
        Voucher             oldVoucher          = '';
        CurrencyCode        oldCurrencyCode     = '';
        LedgerVoucher       ledgerVoucherOrig;
        LedgerJournalACType mainAccountTypeForCurrentVoucher;
        LedgerPostingController ledgerPostingController;
        LedgerVoucherObject ledgerVoucherObject;
        Voucher             budgetCheckVoucher;
        // <GCN>
        LedgerVoucherObject      ledgerVoucherObject_CN;
        boolean                  chineseVoucher;
        // </GCN>
        //<GIN>
        TaxItemGroupHeading      taxItemGroupHeadingServTax;
        //</GIN>
        // <GIN>
        CompanyId                currentCompanyId = curext();
        TaxAmountCur             taxWithholdAmountCur;
        LedgerJournalTransTaxExtensionIN ledgerJournalTranTaxExt;
        // </GIN>

        Map foreignVoucherMap = new Map(Types::String, Types::String);

        #define.IsIntercompanyVoucher(true)
        #define.JournalDoesNotHaveAccruals(false)

        if (! xDataArea::exist(_companyId))
        {
            throw error(strFmt("@SYS10666",_companyId));
        }

        changecompany(_companyId)
        {
            // <GCN>
            chineseVoucher = LedgerParameters::isChineseVoucher_CN();
            // </GCN>

            ledgerJournalTableInterCompany = LedgerJournalTable::find(_ledgerJournalId, true);
            ledgerVoucherOrig = ledgerVoucher;
            ledgerVoucher = LedgerVoucher::newLedgerPost(ledgerJournalTableInterCompany.DetailSummaryPosting,
                                                         SysModule::Ledger,
                                                         NumberSequenceTable::find(ledgerJournalTableInterCompany.NumberSequenceTable).NumberSequence,
                                                         TransactionLogType::LedgerJournal,
                                                         ledgerJournalTableInterCompany.JournalNum + ' ' + ledgerJournalTableInterCompany.Name);

            ledgerVoucher.parmLedgerJournalId(_ledgerJournalId);
            //<GIN>
            if (TaxParameters::isServiceTaxEnable_IN())
            {
                ledgerVoucher.parmInterCompanyTransForST_IN(checkSTForInterCompany);
            }
            //</GIN>

            // post taxes
            ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher);
            // <GIN>
            if (TaxParameters::isServiceTaxEnable_IN())
            {
                // Even if item sales tax group contains other tax codes including standard, only service tax codes
                // will posted, because payment side tax will be calculated for service tax only.
                while select Company from ledgerJournalTrans
                    group by Company
                    where ledgerJournalTrans.JournalNum == _ledgerJournalId
                    exists join taxItemGroupHeadingServTax
                        where taxItemGroupHeadingServTax.TaxItemGroup == ledgerJournalTrans.TaxItemGroup
                           && taxItemGroupHeadingServTax.ServiceTaxBasis_IN == ServiceTaxBasis_IN::CashBasis
                {
                    taxVoucherService.parmLoggedInCompany_IN(ledgerJournalTrans.Company);
                    taxVoucherService.postIntercompany(ledgerPostingController, _ledgerJournalId, '');
                }
            }
            else
            {
                // </GIN>
                taxVoucherService.postIntercompany(ledgerPostingController, _ledgerJournalId, '');
                // <GIN>
            }
            // </GIN>
            while select forupdate ledgerJournalTrans
                order by Voucher, AccountType desc
                where ledgerJournalTrans.JournalNum == _ledgerJournalId
            {
                // Taxes is dependent upon the order in which the LedgerJournalTrans records
                // get processed.  Any changes to the order by will require changes to
                // TaxVoucherService.

                // The ledger journal trans record will get messed with during this operation,
                // but the original values are necessary to properly calculate taxes. So, the
                // original values are copied to a temporary buffer here to avoid needing to
                // do an additional select during tax calculation.
                originalLedgerJournalTrans.data(ledgerJournalTrans);
                // <GTH>
                originalLedgerJournalTrans.SysExtensionSerializerMap::copyExtensionTableData(ledgerJournalTrans);
                // </GTH>

                // <GIN>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                {
                    ledgerJournalTranTaxExt = ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
                }

                if (TaxParameters::isServiceTaxEnable_IN())
                {
                    taxVoucherService.parmIsInterCompanyTrans_IN(retainOldInterCompany);
                    if (this.shouldFillServiceTaxForInterCompany_IN(ledgerJournalTrans)
                        && ledgerJournalTrans.isServiceApplicable_IN())
                    {
                        checkSTForInterCompany = conNull();
                        checkSTForInterCompany += ledgerJournalTrans.JournalNum;
                        checkSTForInterCompany += ledgerJournalTrans.Company;
                        checkSTForInterCompany += 1;

                        taxVoucherService.parmInterCompanyTaxBase_IN(SpecTransManager::getTotalSettleAmountForSpecReference(ledgerJournalTrans.Company,
                                                                     ledgerJournalTrans.TableId,
                                                                     ledgerJournalTrans.RecId,
                                                                     ledgerJournalTrans.CurrencyCode,
                                                                     ledgerJournalTrans.Company,
                                                                     ledgerJournalTrans.TransDate,
                                                                     ledgerJournalTrans.crossrate()));
                        checkSTForInterCompany += taxVoucherService.parmInterCompanyTaxBase_IN();
                        ledgerVoucher.parmInterCompanyTransForST_IN(checkSTForInterCompany);
                    }
                }

                if (TaxWithholdParameters_IN::checkTaxParameters()
                    && (ledgerJournalTranTaxExt.tdsGroup
                        || ledgerJournalTranTaxExt.tcsGroup))
                {
                    ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher);

                    taxVoucherService.parmLoggedInCompany_IN(ledgerJournalTrans.Company);
                    taxWithholdAmountCur = taxVoucherService.postWithholdIntercompany_IN(
                        ledgerPostingController,
                        _ledgerJournalId,
                        ledgerJournalTrans.Voucher,
                        currentCompanyId);
                    ledgerVoucher.parmAdvancePaymentWHT_IN(taxWithholdAmountCur);

                    if (this.shouldSetBackwardAmountForPostJournalInterCompany(ledgerJournalTrans, ledgerJournalTranTaxExt))
                    {
                        ledgerVoucher.parmBackWardAmountWHT_IN(-taxWithholdAmountCur);
                    }
                }
                // </GIN>

                if (ledgerJournalTrans.CashDiscCode || ledgerJournalTrans.CashDiscAmount)
                {
                    LedgerJournalEngine ledgerJournalEngine = LedgerJournalEngine::construct(ledgerJournalTableInterCompany.JournalType);
                    ledgerJournalEngine.newJournalActive(ledgerJournalTableInterCompany);
                    ledgerJournalEngine.cashDiscCodeModified(ledgerJournalTrans, null, true);
                }

                if (ledgerJournalTrans.Voucher != oldVoucher)
                {
                    // <GCN>
                    if (chineseVoucher)
                    {
                        ledgerVoucherObject_CN = LedgerVoucherObject::newVoucher(
                            ledgerJournalTrans.Voucher,
                            ledgerJournalTrans.TransDate,
                            SysModule::Ledger);
                        ledgerVoucherObject_CN.parmDocumentNumber(ledgerJournalTrans.DocumentNum);
                        ledgerVoucherObject_CN.parmDocumentDate(ledgerJournalTrans.DocumentDate);

                        if (ledgerVoucherObject_CN)
                        {
                            ledgerVoucherObject_CN.parmVoucher_CN(ledgerJournalTrans.Voucher_CN);
                            ledgerVoucherObject_CN.parmLedgerVoucherType_CN(ledgerJournalTrans.LedgerVoucherType_CN);
                        }
                    }
                    else
                    {
                        // </GCN>
                        // <GEERU>
                        if (oldVoucher
                            && ledgerVoucher
                            && ledgerBondClient)
                        {
                            LedgerJournalCheckPost_RU::bondJournalVoucher(ledgerBondClient, ledgerVoucher);
                        }
                        // </GEERU>
                        // Tax may have already created the LedgerVoucherObject.
                        ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject(ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate);
                        if (!ledgerVoucherObject)
                        {
                            ledgerVoucherObject = LedgerVoucherObject::newVoucher(ledgerJournalTrans.Voucher,
                                                                                ledgerJournalTrans.TransDate,
                                                                                SysModule::Ledger,
                                                                                LedgerTransType::None,
                                                                                NoYes::No,
                                                                                ledgerJournalTableInterCompany.CurrentOperationsTax,
                                                                                ledgerJournalTrans.DocumentNum,
                                                                                ledgerJournalTrans.DocumentDate);
                        }
                        // <GEERU>
                        ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
                        // </GEERU>
                        // <GCN>
                    }
                    // </GCN>
                    if (isBudgetControlSourceIntegrationSupported)
                    {
                        budgetCheckVoucher = LedgerJournalCheckPostBudget::getBudgetCheckVoucherForInterCompany(
                            budgetCheckInterCompanyVouchers,
                            ledgerJournalTable.JournalType,
                            _companyId,
                            _ledgerJournalId,
                            ledgerJournalTrans.Voucher);
                    }
                    // <GCN>
                    if (chineseVoucher)
                    {
                        // Add intercompany chinese voucher to the journal line's budget check ledgerVoucherObject list.
                        LedgerJournalCheckPostBudget::addBudgetCheckVoucher(
                            this,
                            budgetCheckVoucher,
                            ledgerVoucherObject_CN,
                            #IsIntercompanyVoucher);
                        ledgerVoucher.addVoucher(ledgerVoucherObject_CN);
                    }
                    else
                    {
                        // </GCN>
                        // Add intercompany voucher to the journal line's budget check ledgerVoucherObject list.
                        LedgerJournalCheckPostBudget::addBudgetCheckVoucher(
                            this,
                            budgetCheckVoucher,
                            ledgerVoucherObject,
                            #IsIntercompanyVoucher);
                        // <GIN>
                        if ((!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
                            || (TaxWithholdParameters_IN::checkTaxParameters())
                                && !ledgerVoucher.findLedgerVoucherObject(ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate)))
                        {
                            // </GIN>
                            ledgerVoucher.addVoucher(ledgerVoucherObject);
                            // <GIN>
                        }
                        // </GIN>
                        // <GCN>
                    }
                    // </GCN>

                    mainAccountTypeForCurrentVoucher = ledgerJournalTrans.displayMainAccountType();

                    // Create the intercompany related voucher links
                    container parentVoucherLinkKey = [ledgerJournalTrans.ForeignVoucher, ledgerJournalTrans.TransDate, ledgerJournalTrans.ForeignCompany];

                    // Track the relationship between the originating (foreign) voucher, the intercompany voucher
                    foreignVoucherMap.insert(ledgerJournalTrans.Voucher, ledgerJournalTrans.ForeignVoucher);

                    if (parentVoucherLinkMap.exists(parentVoucherLinkKey))
                    {
                        RecId parentVoucherLink = parentVoucherLinkMap.lookup(parentVoucherLinkKey);
                        this.createIntercompanyVoucherLink(parentVoucherLink, ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate);
                    }

                    oldVoucher = ledgerJournalTrans.Voucher;

                    numOfVouchersBooked++;
                }

                // Initialize the cache for the main account type.
                ledgerJournalTrans.MainAccountType = [mainAccountTypeForCurrentVoucher];

                if (ok)
                {
                    // We only need to set the bank cheque table values for vendor and customer accounts
                    if ((ledgerJournalTrans.AccountType == LedgerJournalACType::Vend) ||
                        (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust))
                    {
                        LedgerJournalCheckPostBank::updateInterCompanyBankCheque(ledgerJournalTrans);
                    }

                    // <GIN>
                    if (TaxWithholdParameters_IN::checkTaxParameters())
                    {
                        ledgerVoucher.parmCurrentCompany_IN(currentCompanyId);
                    }
                    // </GIN>

                    // The exchange rates on the ledgerJournalTrans here are the exchange rates
                    // for the intercompany journal vouchers already.  They were set by the previous
                    // updateInterCompanyJournal call.  Therefore, there is no need to calculate
                    // the exchange rates again.
                    ok = this.postTransV2(ledgerVoucher,
                                        originalLedgerJournalTrans,
                                        ledgerJournalTrans,
                                        ledgerJournalTrans.ExchRate,
                                        ledgerJournalTrans.ExchRateSecond,
                                        ledgerJournalTrans.Triangulation,
                                        ledgerJournalTrans.ReportingCurrencyExchRate,
                                        ledgerJournalTrans.ReportingCurrencyExchRateSecondary,
                                        ledgerJournalTrans.ExchRate,
                                        ledgerJournalTrans.ExchRateSecond,
                                        ledgerJournalTrans.Triangulation,
                                        ledgerJournalTrans.ReportingCurrencyExchRate,
                                        ledgerJournalTrans.ReportingCurrencyExchRateSecondary,
                                        false,
                                        true,
                                        _isOffset,
                                        #JournalDoesNotHaveAccruals);

                    if (ok && ledgerJournalTrans.PoolRecId && ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                    {
                        changecompany(ledgerJournalTrans.OffsetCompany)
                        {
                            LedgerJournalTrans::findRecId(ledgerJournalTrans.PoolRecId, true).delete();
                            ledgerJournalTrans.PoolRecId = 0;
                        }
                    }
                }

                oldCurrencyCode = ledgerJournalTrans.CurrencyCode;
            }
            
            if (oldVoucher && ledgerVoucher)
            {
                if (taxVoucherService)
                {
                    // post sales tax in case of no offset account
                    taxVoucherService.postTaxOnErrorAccount(ledgerVoucher, oldVoucher, oldCurrencyCode);
                }
            }

            // <GEERU>
            if (ledgerBondClient)
            {
                LedgerJournalCheckPost_RU::bondJournalVoucher(ledgerBondClient, ledgerVoucher);
            }

            // </GEERU>

            LedgerVoucherList voucherList = ledgerVoucher.getInternalCollection();
            boolean voucherCheck = true;
            boolean moreVouchers = voucherList.first();

            while (moreVouchers)
            {
                LedgerVoucherObject voucherObject = voucherList.item();

                if (!voucherObject.check(ledgerVoucher))
                {
                    // Insert the originating voucher in the voucherErrorList map for error transfer to pick it up
                    // if the process is post and transfer
                    this.insertInVoucherErrorList(foreignVoucherMap.lookup(voucherObject.parmVoucher()));
                    voucherCheck = false;
                }

                moreVouchers = voucherList.next();
            }

            ok = ok && voucherCheck;

            // Perf: if voucher check failed, do not call end which will perform the
            // voucher check again
            if (voucherCheck)
            {
                isLedgerVoucherPosted = ledgerVoucher.end() && isLedgerVoucherPosted;
            }

            if (ok)
            {
                [ledgerJournalTableInterCompany.JournalTotalDebit,
                    ledgerJournalTableInterCompany.JournalTotalCredit,
                    ledgerJournalTableInterCompany.JournalTotalOffsetBalance,
                    ledgerJournalTableInterCompany.JournalTotalDebitReportingCurrency,
                    ledgerJournalTableInterCompany.JournalTotalCreditReportingCurrency] = LedgerJournalTable::journalBalanceMST(_ledgerJournalId);

                ledgerJournalTableInterCompany.Posted           = NoYes::Yes;
                ledgerJournalTableInterCompany.PostedDateTime   = DateTimeUtil::getSystemDateTime();
                ledgerJournalTableInterCompany.WorkflowApprovalStatus = LedgerJournalWFApprovalStatus::Approved;
                ledgerJournalTableInterCompany.update();
            }
            ledgerVoucher = ledgerVoucherOrig;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldFillServiceTaxForInterCompany_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether to set inter company parameter.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    ///     A <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <returns>
    ///     true if the inter company parameter need to set; otherwise, false.
    /// </returns>
    protected boolean shouldFillServiceTaxForInterCompany_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        return (_ledgerJournalTrans.Company != _ledgerJournalTrans.OffsetCompany && _ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSetBackwardAmountForPostJournalInterCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether to set backward amount.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    ///     A <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <param name = "_ledgerJournalTranTaxExt">
    ///     A <c>LedgerJournalTransTaxExtensionIN</c> table buffer.
    /// </param>
    /// <returns>
    ///     true if the backward amount need to set; otherwise, false.
    /// </returns>
    protected boolean shouldSetBackwardAmountForPostJournalInterCompany(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTransTaxExtensionIN _ledgerJournalTranTaxExt)
    {
        return _ledgerJournalTrans.SettleVoucher != SettlementType::SelectedTransact
            && (_ledgerJournalTranTaxExt.TCSGroup
                || (_ledgerJournalTranTaxExt.TDSGroup
                    && _ledgerJournalTrans.AmountCurCredit
                    && _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                    && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createIntercompanyVoucherLink</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates links in the LedgerTransVoucherLink table between the supplied
    /// parent voucher link and the intercompany vouchers created.
    /// </summary>
    /// <param name="_parentVoucherLink">
    /// The record id of the parent voucher link.
    /// </param>
    /// <param name="_relatedVoucher">
    /// The related voucher.
    /// </param>
    /// <param name="_relatedVoucherTransDate">
    /// The related voucher transaction date.
    /// </param>
    protected void createIntercompanyVoucherLink(
        RecId _parentVoucherLink,
        Voucher _relatedVoucher,
        TransDate _relatedVoucherTransDate)
    {
        // must be within an existing database transaction
        Debug::assert(appl.ttsLevel() > 0);
        Debug::assert(_parentVoucherLink != 0);

        RecId previousVoucherGroupId = LedgerTransVoucherLink::getCurrentVoucherGroupId(_parentVoucherLink, _relatedVoucher, _relatedVoucherTransDate);

        LedgerTransVoucherLink::updateVoucherLinkParentGroup(previousVoucherGroupId, _parentVoucherLink);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxedFirst</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the account will be swapped.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> buffer.</param>
    /// <returns>The boolean value.</returns>
    protected boolean postTaxedFirst(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean accountsSwapped = false;
        boolean hasOffsetPostingProfile_RU = _ledgerJournalTrans.OffsetPostingProfile_RU ? true : false;

        if (!_ledgerJournalTrans.Cancel &&
                !_ledgerJournalTrans.Prepayment &&
                !_ledgerJournalTrans.FurtherPostingType &&
            ((_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger ||
                _ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets) &&
                _ledgerJournalTrans.LedgerDimension) &&
            ((_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust ||
                _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend ||
                _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank) &&
                _ledgerJournalTrans.OffsetLedgerDimension) ||
            (_ledgerJournalTrans.AccountType == LedgerJournalACType::Employee_RU &&
                _ledgerJournalTrans.LedgerDimension &&
                _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::RCash &&
                _ledgerJournalTrans.OffsetLedgerDimension))
        {
            _ledgerJournalTrans.swapAccountOffsetAccount();

            if (! hasOffsetPostingProfile_RU)
            {
                _ledgerJournalTrans.PostingProfile = '';
            }

            accountsSwapped = true;
        }

        return accountsSwapped;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts a journal line.
    /// </summary>
    /// <param name = "_ledgerVoucher">
    /// The voucher number.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_originalLedgerJournalTrans">
    /// The original <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_exchRateForAccountCompany">
    /// The exchange rate for the account company.
    /// </param>
    /// <param name = "_exchRateSecondaryForAccountCompany">
    /// The secondary exchange rate for the account company.
    /// </param>
    /// <param name = "_euroTriangulationForAccountCompany">
    /// A <c>NoYes</c> value indicating triangulation for the account company.
    /// </param>
    /// <param name = "_exchRateForCurrentCompany">
    /// The exhange rate for the current company.
    /// </param>
    /// <param name = "_exchRateSecondaryForCurrentCompany">
    /// The secondary exchange rate for the current company.
    /// </param>
    /// <param name = "_euroTriangulationForCurrentCompany">
    /// A <c>NoYes</c> value indicating triangulation for the current company.
    /// </param>
    /// <param name = "_ledgerJournalTransHasOffsetAccount">
    /// A boolean value indicating that the journal has offset accounts.
    /// </param>
    /// <param name = "_interCompany">
    /// A boolean value indicating that the posting process is updating transactions in a different
    /// company than the original logged in company.
    /// </param>
    /// <param name = "_isOffset">
    /// A boolean value indicating that the journal is an offset.
    /// </param>
    /// <param name = "_journalHasAccruals">
    /// A boolean value indicating that the journal has accruals.
    /// </param>
    /// <param name = "_oldCurrencyCode">
    /// The original currency code.
    /// </param>
    /// <param name = "_reversalsMayExist">
    /// A boolean value indicating that reverals may exist.
    /// </param>
    /// <param name = "_ledgerPostingMessageCollection">
    /// An instance of the <c>LedgerPostingMessageLog</c> class.
    /// </param>
    /// <returns>
    /// true if the journal was posted successfully; otherwise, false.
    /// </returns>
    [SysObsolete('Method postTrans has been deprecated. Please use postTransV2 method instead.', false, 30\06\2018)]
    protected boolean postTrans(
        LedgerVoucher               _ledgerVoucher,
        LedgerJournalTrans          _ledgerJournalTrans,
        LedgerJournalTrans          _originalLedgerJournalTrans,
        ExchRate                    _exchRateForAccountCompany,
        ExchrateSecondary           _exchRateSecondaryForAccountCompany,
        EUROTriangulation           _euroTriangulationForAccountCompany,
        ExchRate                    _exchRateForCurrentCompany,
        ExchrateSecondary           _exchRateSecondaryForCurrentCompany,
        EUROTriangulation           _euroTriangulationForCurrentCompany,
        boolean                     _ledgerJournalTransHasOffsetAccount,
        boolean                     _interCompany,
        boolean                     _isOffset,
        boolean                     _journalHasAccruals,
        CurrencyCode                _oldCurrencyCode = '',
        boolean                     _reversalsMayExist = true,
        LedgerPostingMessageLog     _ledgerPostingMessageCollection = null)
    {
        LedgerJournalTransUpdate    ledgerJournalTransUpdate;
        VendTrans                   vendTrans;
        boolean                     ok                  = true;
        boolean                     hasAccrual;
        boolean                     needToRetrieveExchangeRate;
        CompanyId                   currentCompany      = curext();
        LedgerJournalTrans          ledgerJournalTransLocal;
        VendTransOpen               vendTransOpen;
        VendTransCashDisc           vendTransCashDisc;
        CurrencyCode                internalCurrencyCode;
        LedgerJournalTrans_Asset    ledgerJournalTransAsset;
        boolean                     updateLedgerJournalTrans;
        boolean                     isAcquistionForPO;
        boolean                     isStockedItem;
        LedgerDimensionAccount      purchaseLineDimension;
        AssetPostPurchaseLineInfo   assetPostPurchaseLineInfo;

        // <GIN>
        CustVendPaymJournalFee      custVendPaymJournalFeeLoc;
        CustInvoiceJour             custInvoiceJourloc;
        CustTrans                   custTransloc;
        boolean                     taxWithholdParameterMarked = TaxWithholdParameters_IN::checkTaxParameters();
        // </GIN>

        // <GBR>
        if (BrazilParameters::isEnabled()
             && _ledgerJournalTrans.getPaymentExtension_BR().TaxWithholdEditStatus_BR == LedgerTransTaxWithholdEditStatus_BR::Opened)
        {
            LedgerJournalCheckPost_BR::updateTaxWithholdLineStatus(_ledgerJournalTrans);
        }
        // </GBR>

        // When intercompany transactions are involved, the original exchange rates stored on the LedgerJournalTrans
        // are used as the fixed rates for the intercompany (could be the primary account or the offset account, or
        // both depending on which account is not the current company).  The exchange rates for the original logged
        // in company from which the posting process is launched are NOT stored on the LedgerJournalTrans record.
        // Need to update them so that the exchange rates for the current company will be used for voucher creations
        // for current company.
        CurrencyCode originalCompanyAccountingCurrency = Ledger::accountingCurrency(CompanyInfo::findDataArea(_originalLedgerJournalTrans.Company).RecId);
        CurrencyCode originalOffsetCompanyAccountingCurrency = Ledger::accountingCurrency(CompanyInfo::findDataArea(_originalLedgerJournalTrans.OffsetCompany).RecId);
        if (originalCompanyAccountingCurrency != originalOffsetCompanyAccountingCurrency)
        {
            _ledgerJournalTrans.ExchRate = _exchRateForCurrentCompany;
            _ledgerJournalTrans.ExchRateSecond = _exchRateSecondaryForCurrentCompany;
            _ledgerJournalTrans.Triangulation = _euroTriangulationForCurrentCompany;
        }

        // Note: _interCompany is only true when the posting process is updating transactions in a different
        // company than the original logged in company from which the posting process is launched.
        if (!_interCompany && _ledgerJournalTrans.Company && (_ledgerJournalTrans.Company != currentCompany))
        {
            _ledgerJournalTrans.NoEdit = true;
            hasAccrual = false;

            if (!xDataArea::exist(_ledgerJournalTrans.Company))
            {
                throw error(strFmt("@SYS10666",_ledgerJournalTrans.Company));
            }

            changecompany(_ledgerJournalTrans.Company)
            {
                internalCurrencyCode     = CompanyInfoHelper::standardCurrency();
                ledgerJournalTransUpdate = LedgerJournalTransUpdate::construct(_ledgerJournalTrans, _isOffset);
                ok = ledgerJournalTransUpdate.checkWhenPost(_ledgerJournalTrans, _originalLedgerJournalTrans, true, _ledgerPostingMessageCollection);
            }

            if (ok)
            {
                ledgerJournalTransUpdate.setTaxVoucherService(taxVoucherService);

                // <GIN>
                if (TaxParameters::checkTaxParameters_IN())
                {
                    taxVoucherService.parmIsInterCompanyTrans_IN(LedgerJournalCheckPost_IN::isInterCompanyTransaction(_ledgerJournalTrans));
                    retainOldInterCompany = taxVoucherService.parmIsInterCompanyTrans_IN();
                }

                // </GIN>

                ledgerJournalTransUpdate.updateInterCompany(ledgerVoucher,
                                                            LedgerPostingType::InterCompany,
                                                            _ledgerJournalTrans,
                                                            _originalLedgerJournalTrans,
                                                            ledgerJournalTransUpdate,
                                                            _ledgerJournalTrans.Company,
                                                            _ledgerJournalTransHasOffsetAccount,
                                                            ledgerJournalTable.JournalType == LedgerJournalType::Allocation);

                // for allocation journals all posting are considered offsets so the exchange rates will be retrieved
                changecompany(_ledgerJournalTrans.Company)
                {
                    needToRetrieveExchangeRate = (_isOffset) ||
                                                (_oldCurrencyCode != internalCurrencyCode && ledgerJournalTable.JournalType == LedgerJournalType::Approval) ||
                                                ledgerJournalTable.JournalType == LedgerJournalType::Allocation;

                    LedgerInterCompany ledgerInterCompany =
                        LedgerInterCompany::findCompanyPair(currentCompany, _ledgerJournalTrans.Company);

                    this.updateInterCompanyJournal(_ledgerJournalTrans,
                                                   _exchRateForAccountCompany,
                                                   _exchRateSecondaryForAccountCompany,
                                                   _euroTriangulationForAccountCompany,
                                                   ledgerInterCompany,
                                                   currentCompany,
                                                   needToRetrieveExchangeRate);
                }
            }
        }
        else
        {
            updateLedgerJournalTrans = true;
            // If an acquisition transaction originated from an PO, but
            // the PO did not create an acquisition due to FA parameter disallow it,
            // additional steps need to be taken.
            if (_originalLedgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets
                && _ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger
                && _isOffset
                && !AssetParameters::find().AssetAllowAcqPostingPO)
            {
                ledgerJournalTransAsset = LedgerJournalTrans_Asset::find(_ledgerJournalTrans.RecId);

                if (ledgerJournalTransAsset
                    && (ledgerJournalTransAsset.TransType == AssetTransTypeJournal::Acquisition
                    || ledgerJournalTransAsset.TransType == AssetTransTypeJournal::AcquisitionAdj))
                {
                    assetPostPurchaseLineInfo = AssetPost::getPurchaseTransactionAcquisitionInfo(
                            ledgerJournalTransAsset.AssetId,
                            ledgerJournalTransAsset.BookId,
                            _ledgerJournalTrans.AmountCurCredit? _ledgerJournalTrans.AmountCurCredit : _ledgerJournalTrans.AmountCurDebit,
                            _ledgerJournalTrans.Voucher,
                            true);

                    if (assetPostPurchaseLineInfo)
                    {
                        isStockedItem = assetPostPurchaseLineInfo.parmIsStockedItem();
                        isAcquistionForPO = assetPostPurchaseLineInfo.parmIsAcquisitionAmountForPO();
                        purchaseLineDimension = assetPostPurchaseLineInfo.parmPurchaseLineDimension();
                    }

                    // For stocked item vouchers are not posted as they are already posted with the inventory
                    // vouchers for the inventory issue vouchers.
                    // For non-stock items, dimension from the original PO needs to be used for the vouchers.
                    if (isAcquistionForPO)
                    {
                        if (isStockedItem)
                        {
                            if (assetPostPurchaseLineInfo.parmIsPostFinancialInventory())
                            {
                                updateLedgerJournalTrans = false;
                            }
                        }
                        else
                        {
                            if (purchaseLineDimension)
                            {
                                _ledgerJournalTrans.LedgerDimension = purchaseLineDimension;
                            }
                        }
                    }
                }
            }

            if (updateLedgerJournalTrans)
            {
                if (!_interCompany)
                {
                    ledgerJournalTransUpdate = LedgerJournalTransUpdate::construct(_ledgerJournalTrans, _isOffset);
                }
                else
                {
                    ledgerJournalTransUpdate = LedgerJournalTransUpdate::construct(_ledgerJournalTrans);
                }

                ok = ledgerJournalTransUpdate.checkWhenPost(_ledgerJournalTrans, _originalLedgerJournalTrans, checkNoSettlement, _ledgerPostingMessageCollection) &&
                     _ledgerJournalTrans.checkPaymentFilledOk(ledgerJournalTable) &&
                     _ledgerJournalTrans.validateBankAccount();

                ledgerJournalTransUpdate.setTaxVoucherService(taxVoucherService);
                // <GJP>
                LedgerJournalCheckPost_JP::setLedgerJournalTransUpdIntercompanyMap(isIntercompanyMapNeeded, ledgerJournalTransIntercompanyMap, ledgerJournalTransUpdate);
                // </GJP>

                // <GIN>
                if (TaxParameters::checkTaxParameters_IN())
                {
                    if (ledgerJournalTable.JournalType == LedgerJournalType::Approval)
                    {
                        ledgerJournalTransUpdate.parmApproval_IN(true);
                    }
                    ledgerJournalTransUpdate.parmInclTax_IN(inclTax);
                }

                if (taxWithholdParameterMarked)
                {
                    select firstonly FeeId from custVendPaymJournalFeeLoc
                        where custVendPaymJournalFeeLoc.FeeTransRecId == _ledgerJournalTrans.RecId;
                    if (custVendPaymJournalFeeLoc)
                    {
                        _ledgerJournalTrans.BankChequeNum = LedgerJournalCheckPost_IN::taxWithholdGetCheckNum(custVendPaymJournalFeeLoc.FeeId,
                                                                                        _ledgerJournalTrans.Voucher,
                                                                                        _ledgerJournalTrans.TransDate);
                    }
                }

                if (taxWithholdParameterMarked && interCmpWithholdingTaxAmount
                    && TaxWithholdParameters_IN::findByCompany(_ledgerJournalTrans.ForeignCompany).CrossCompanyPayment)
                {
                    _ledgerVoucher.parmAdvancePaymentWHT_IN(interCmpWithholdingTaxAmount);
                }
                // </GIN>

                hasAccrual = _journalHasAccruals && LedgerJournalTransAccrual::findAccountOffsetaccount(
                    _ledgerJournalTrans.TableId,
                    _ledgerJournalTrans.RecId,
                    _isOffset ? AccountOffsetaccount::OffsetAccount : AccountOffsetaccount::Account);

                ledgerJournalTransUpdate.parmAccrual(hasAccrual);
                ledgerJournalTransUpdate.parmIntercompanyRecIds(intercompanyRecIds);
                if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
                {
                    ledgerJournalTransUpdate.rboParameters(rboParameters);
                }

                ledgerJournalTransUpdate.parmIsVoucherValid(true);

                System.Diagnostics.Stopwatch stopWatchUpdateNow = perfMonitor.startNewStopwatch();

                ledgerJournalTransUpdate.updateNow(
                    _ledgerVoucher,
                    LedgerPostingType::LedgerJournal,
                    _ledgerJournalTrans,
                    _originalLedgerJournalTrans,
                    _interCompany,
                    _reversalsMayExist);

                perfMonitor.trackProcessingTimePerSubledger(classId2Name(classIdGet(ledgerJournalTransUpdate)), stopWatchUpdateNow.ElapsedMilliseconds);

                ok = ok && ledgerJournalTransUpdate.parmIsVoucherValid();
            }
        }

        // <GTE>
        // Merge tax document from custVendSettle with tax document for ledgerJournalTrans
        if (ledgerJournalTransUpdate && isGTEEnabled)
        {
            Map taxDocumentMapForSettlement = ledgerJournalTransUpdate.getTaxDocumentLedgerVoucherMap();
            if (taxDocumentMapForPosting)
            {
                if (taxDocumentMapForSettlement)
                {
                    MapEnumerator mapEnumerator = taxDocumentMapForSettlement.getEnumerator();
                    while(mapEnumerator.moveNext())
                    {
                        taxDocumentMapForPosting.insert(mapEnumerator.currentKey(), mapEnumerator.currentValue());
                    }
                }
            }
            else
            {
                taxDocumentMapForPosting = taxDocumentMapForSettlement;
            }
        }
        // </GTE>

        ledgerJournalTransUpdate = null;

        if (!_interCompany)
        {
            if (ledgerJournalTable.JournalType == LedgerJournalType::Approval)
            {
                if (_ledgerJournalTrans.VendTransId)
                {
                    select firstonly forupdate vendTrans
                        index hint recid
                        where vendTrans.RecId == _ledgerJournalTrans.VendTransId;

                    if (vendTrans)
                    {
                        VendInvoiceJour vendInvoiceJour = VendInvoiceJour::findFromVendTrans(vendTrans.Invoice, vendTrans.TransDate, vendTrans.AccountNum, true);

                        if (vendInvoiceJour)
                        {
                            vendInvoiceJour.LedgerVoucher = _ledgerJournalTrans.Voucher;
                            vendInvoiceJour.InvoiceDate = _ledgerJournalTrans.TransDate;
                            vendInvoiceJour.doUpdate();
                        }

                        vendTrans.initFromLedgerJournalTransApproval(_ledgerJournalTrans);
                        vendTrans.update();

                        if (TaxIntegrationTaxJurisdictionParameters::shouldCashDiscDeductedBeforeTaxCalc(_ledgerJournalTrans))
                        {
                            select sum(CashDiscAmount)
                                from ledgerJournalTransLocal
                                where (ledgerJournalTransLocal.JournalNum         == _ledgerJournalTrans.JournalNum &&
                                       ledgerJournalTransLocal.Voucher            == _ledgerJournalTrans.Voucher &&
                                       ledgerJournalTransLocal.TransDate          == _ledgerJournalTrans.TransDate &&
                                       ledgerJournalTransLocal.PurchLedgerPosting == ArrivalPostingType::None);

                            while select forupdate vendTransOpen
                                where vendTransOpen.RefRecId == vendTrans.RecId
                            {
                                vendTransOpen.PossibleCashDisc = - ledgerJournalTransLocal.CashDiscAmount * vendTransOpen.AmountCur / vendTrans.AmountCur;
                                vendTransOpen.update();

                                select firstonly forupdate * from vendTransCashDisc
                                    order by CashDiscdate
                                    where vendTransCashDisc.RefRecId == vendTransOpen.RecId;
                                if (vendTransCashDisc)
                                {
                                    vendTransCashDisc.CashDiscAmount = vendTransOpen.PossibleCashDisc;
                                    vendTransCashDisc.update();
                                }
                            }
                        }
                    }
                }
            }
        }

        if (hasAccrual)
        {
            // some of the callers may change the default voucher
            _ledgerVoucher.lastVoucher(_ledgerJournalTrans.Voucher);
            _ledgerVoucher.lastTransDate(_ledgerJournalTrans.TransDate);
            _ledgerVoucher.lastPostingLayer(_ledgerJournalTrans.ledgerJournalTable().CurrentOperationsTax);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTransV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts a journal line.
    /// </summary>
    /// <param name = "_ledgerVoucher">
    /// The voucher number.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_originalLedgerJournalTrans">
    /// The original <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_exchRateForAccountCompany">
    /// The exchange rate for the account company.
    /// </param>
    /// <param name = "_exchRateSecondaryForAccountCompany">
    /// The secondary exchange rate for the account company.
    /// </param>
    /// <param name = "_euroTriangulationForAccountCompany">
    /// A <c>NoYes</c> value indicating triangulation for the account company.
    /// </param>
    /// <param name = "_reportingCurrencyExchRateForAccountCompany">
    /// The reporting currency exchange rate for the account company.
    /// </param>
    /// <param name = "_reportingCurrencyExchRateSecondaryForAccountCompany">
    /// The reporting currency secondary exchange rate for the account company.
    /// </param>
    /// <param name = "_exchRateForCurrentCompany">
    /// The exhange rate for the current company.
    /// </param>
    /// <param name = "_exchRateSecondaryForCurrentCompany">
    /// The secondary exchange rate for the current company.
    /// </param>
    /// <param name = "_euroTriangulationForCurrentCompany">
    /// A <c>NoYes</c> value indicating triangulation for the current company.
    /// </param>
    /// <param name = "_reportingCurrencyExchRateForCurrentCompany">
    /// The reporting currency exchange rate for the current company.
    /// </param>
    /// <param name = "_reportingCurrencyExchRateSecondaryForCurrentCompany">
    /// The reporting currency secondary exchange rate for the current company.
    /// </param>
    /// <param name = "_ledgerJournalTransHasOffsetAccount">
    /// A boolean value indicating that the journal has offset accounts.
    /// </param>
    /// <param name = "_interCompany">
    /// A boolean value indicating that the posting process is updating transactions in a different
    /// company than the original logged in company.
    /// </param>
    /// <param name = "_isOffset">
    /// A boolean value indicating that the journal is an offset.
    /// </param>
    /// <param name = "_journalHasAccruals">
    /// A boolean value indicating that the journal has accruals.
    /// </param>
    /// <param name = "_oldCurrencyCode">
    /// The original currency code.
    /// </param>
    /// <param name = "_reversalsMayExist">
    /// A boolean value indicating that reverals may exist.
    /// </param>
    /// <param name = "_ledgerPostingMessageCollection">
    /// An instance of the <c>LedgerPostingMessageLog</c> class.
    /// </param>
    /// <returns>
    /// true if the journal was posted successfully; otherwise, false.
    /// </returns>
    protected boolean postTransV2(
        LedgerVoucher               _ledgerVoucher,
        LedgerJournalTrans          _ledgerJournalTrans,
        LedgerJournalTrans          _originalLedgerJournalTrans,
        ExchRate                    _exchRateForAccountCompany,
        ExchrateSecondary           _exchRateSecondaryForAccountCompany,
        EUROTriangulation           _euroTriangulationForAccountCompany,
        ReportingCurrencyExchRate           _reportingCurrencyExchRateForAccountCompany,
        ReportingCurrencyExchRateSecondary  _reportingCurrencyExchRateSecondaryForAccountCompany,
        ExchRate                    _exchRateForCurrentCompany,
        ExchrateSecondary           _exchRateSecondaryForCurrentCompany,
        EUROTriangulation           _euroTriangulationForCurrentCompany,
        ReportingCurrencyExchRate           _reportingCurrencyExchRateForCurrentCompany,
        ReportingCurrencyExchRateSecondary  _reportingCurrencyExchRateSecondaryForCurrentCompany,
        boolean                     _ledgerJournalTransHasOffsetAccount,
        boolean                     _interCompany,
        boolean                     _isOffset,
        boolean                     _journalHasAccruals,
        CurrencyCode                _oldCurrencyCode = '',
        boolean                     _reversalsMayExist = true,
        LedgerPostingMessageLog     _ledgerPostingMessageCollection = null)
    {
        LedgerJournalTransUpdate    ledgerJournalTransUpdate;
        VendTrans                   vendTrans;
        boolean                     ok                  = true;
        boolean                     hasAccrual;
        boolean                     needToRetrieveExchangeRate;
        CompanyId                   currentCompany      = curext();
        LedgerJournalTrans          ledgerJournalTransLocal;
        VendTransOpen               vendTransOpen;
        VendTransCashDisc           vendTransCashDisc;
        CurrencyCode                internalCurrencyCode;
        LedgerJournalTrans_Asset    ledgerJournalTransAsset;
        boolean                     isAcquistionForPO;
        boolean                     isStockedItem;
        LedgerDimensionAccount      purchaseLineDimension;
        AssetPostPurchaseLineInfo   assetPostPurchaseLineInfo;
        DataAreaId                  taxGroupCompany;

        // <GIN>
        CustVendPaymJournalFee      custVendPaymJournalFeeLoc;
        CustInvoiceJour             custInvoiceJourloc;
        CustTrans                   custTransloc;
        boolean                     taxWithholdParameterMarked = TaxWithholdParameters_IN::checkTaxParameters();
        // </GIN>

        // <GBR>
        if (BrazilParameters::isEnabled()
             && _ledgerJournalTrans.getPaymentExtension_BR().TaxWithholdEditStatus_BR == LedgerTransTaxWithholdEditStatus_BR::Opened)
        {
            LedgerJournalCheckPost_BR::updateTaxWithholdLineStatus(_ledgerJournalTrans);
        }
        // </GBR>

        // When intercompany transactions are involved, the original exchange rates stored on the LedgerJournalTrans
        // are used as the fixed rates for the intercompany (could be the primary account or the offset account, or
        // both depending on which account is not the current company).  The exchange rates for the original logged
        // in company from which the posting process is launched are NOT stored on the LedgerJournalTrans record.
        // Need to update them so that the exchange rates for the current company will be used for voucher creations
        // for current company.

        CompanyInfo originatingCompany = CompanyInfo::findDataArea(_originalLedgerJournalTrans.Company);
        CompanyInfo originatingOffsetCompany = CompanyInfo::findDataArea(_originalLedgerJournalTrans.OffsetCompany);

        CurrencyCode originalCompanyAccountingCurrency = Ledger::accountingCurrency(originatingCompany.RecId);
        CurrencyCode originalOffsetCompanyAccountingCurrency = Ledger::accountingCurrency(originatingOffsetCompany.RecId);

        if (originalCompanyAccountingCurrency != originalOffsetCompanyAccountingCurrency)
        {
            _ledgerJournalTrans.ExchRate = _exchRateForCurrentCompany;
            _ledgerJournalTrans.ExchRateSecond = _exchRateSecondaryForCurrentCompany;
            _ledgerJournalTrans.Triangulation = _euroTriangulationForCurrentCompany;
        }

        CurrencyCode originalCompanyReportingCurrency = Ledger::reportingCurrency(originatingCompany.RecId);
        CurrencyCode originalOffsetCompanyReportingCurrency = Ledger::reportingCurrency(originatingOffsetCompany.RecId);

        if (originalCompanyReportingCurrency != originalOffsetCompanyReportingCurrency)
        {
            _ledgerJournalTrans.ReportingCurrencyExchRate = _reportingCurrencyExchRateForCurrentCompany;
            _ledgerJournalTrans.ReportingCurrencyExchRateSecondary = _reportingCurrencyExchRateSecondaryForCurrentCompany;
        }

        // Note: _interCompany is only true when the posting process is updating transactions in a different
        // company than the original logged in company from which the posting process is launched.
        if (!_interCompany && _ledgerJournalTrans.Company && (_ledgerJournalTrans.Company != currentCompany))
        {
            _ledgerJournalTrans.NoEdit = true;
            hasAccrual = false;

            if (!xDataArea::exist(_ledgerJournalTrans.Company))
            {
                throw error(strFmt("@SYS10666",_ledgerJournalTrans.Company));
            }

            _ledgerJournalTrans.ExchRate = _exchRateForCurrentCompany;
            _ledgerJournalTrans.ReportingCurrencyExchRate = _reportingCurrencyExchRateForCurrentCompany;

            taxGroupCompany = LedgerJournalTrans::getSalesTaxGroupCompanyForIntercompany(_ledgerJournalTrans);
            if (!taxGroupCompany)
            {
                taxGroupCompany = _ledgerJournalTrans.Company;
            }

            changecompany(_ledgerJournalTrans.Company)
            {
                internalCurrencyCode = CompanyInfoHelper::standardCurrency();
                ledgerJournalTransUpdate = LedgerJournalTransUpdate::construct(_ledgerJournalTrans, _isOffset);

                ledgerJournalTransUpdate.parmTaxGroupCompany(taxGroupCompany);
                ok = ledgerJournalTransUpdate.checkWhenPost(_ledgerJournalTrans, _originalLedgerJournalTrans, true, _ledgerPostingMessageCollection);
            }

            if (ok)
            {
                ledgerJournalTransUpdate.setTaxVoucherService(taxVoucherService);

                // <GIN>
                if (TaxParameters::checkTaxParameters_IN())
                {
                    taxVoucherService.parmIsInterCompanyTrans_IN(LedgerJournalCheckPost_IN::isInterCompanyTransaction(_ledgerJournalTrans));
                    retainOldInterCompany = taxVoucherService.parmIsInterCompanyTrans_IN();
                }

                // </GIN>

                ledgerJournalTransUpdate.updateInterCompany(ledgerVoucher,
                                                            LedgerPostingType::InterCompany,
                                                            _ledgerJournalTrans,
                                                            _originalLedgerJournalTrans,
                                                            ledgerJournalTransUpdate,
                                                            _ledgerJournalTrans.Company,
                                                            _ledgerJournalTransHasOffsetAccount,
                                                            ledgerJournalTable.JournalType == LedgerJournalType::Allocation);

                // for allocation journals all posting are considered offsets so the exchange rates will be retrieved
                changecompany(_ledgerJournalTrans.Company)
                {
                    needToRetrieveExchangeRate = (_isOffset) ||
                                                (_oldCurrencyCode != internalCurrencyCode && ledgerJournalTable.JournalType == LedgerJournalType::Approval) ||
                                                ledgerJournalTable.JournalType == LedgerJournalType::Allocation;

                    LedgerInterCompany ledgerInterCompany =
                        LedgerInterCompany::findCompanyPair(currentCompany, _ledgerJournalTrans.Company);

                    this.updateInterCompanyJournalV2(_ledgerJournalTrans,
                                                   _exchRateForAccountCompany,
                                                   _exchRateSecondaryForAccountCompany,
                                                   _euroTriangulationForAccountCompany,
                                                   _reportingCurrencyExchRateForAccountCompany,
                                                   _reportingCurrencyExchRateSecondaryForAccountCompany,
                                                   ledgerInterCompany,
                                                   currentCompany,
                                                   needToRetrieveExchangeRate);
                }
            }
        }
        else
        {
            boolean updateLedgerJournalTrans = this.shouldUpdateLedgerJournalTrans(_ledgerJournalTrans, _originalLedgerJournalTrans);

            // If an acquisition transaction originated from an PO, but
            // the PO did not create an acquisition due to FA parameter disallow it,
            // additional steps need to be taken.
            if (_originalLedgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets
                && _ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger
                && _isOffset
                && !AssetParameters::find().AssetAllowAcqPostingPO)
            {
                ledgerJournalTransAsset = LedgerJournalTrans_Asset::find(_ledgerJournalTrans.RecId);

                if (ledgerJournalTransAsset
                    && (ledgerJournalTransAsset.TransType == AssetTransTypeJournal::Acquisition
                    || ledgerJournalTransAsset.TransType == AssetTransTypeJournal::AcquisitionAdj))
                {
                    assetPostPurchaseLineInfo = AssetPost::getPurchaseTransactionAcquisitionInfo(
                            ledgerJournalTransAsset.AssetId,
                            ledgerJournalTransAsset.BookId,
                            _ledgerJournalTrans.AmountCurCredit? _ledgerJournalTrans.AmountCurCredit : _ledgerJournalTrans.AmountCurDebit,
                            _ledgerJournalTrans.Voucher,
                            true);

                    if (assetPostPurchaseLineInfo)
                    {
                        isStockedItem = assetPostPurchaseLineInfo.parmIsStockedItem();
                        isAcquistionForPO = assetPostPurchaseLineInfo.parmIsAcquisitionAmountForPO();
                        purchaseLineDimension = assetPostPurchaseLineInfo.parmPurchaseLineDimension();
                    }

                    // For stocked item vouchers are not posted as they are already posted with the inventory
                    // vouchers for the inventory issue vouchers.
                    // For non-stock items, dimension from the original PO needs to be used for the vouchers.
                    if (isAcquistionForPO)
                    {
                        if (isStockedItem)
                        {
                            if (assetPostPurchaseLineInfo.parmIsPostFinancialInventory())
                            {
                                updateLedgerJournalTrans = false;
                            }
                        }
                        else
                        {
                            if (purchaseLineDimension)
                            {
                                _ledgerJournalTrans.LedgerDimension = purchaseLineDimension;
                            }
                        }
                    }
                }
            }

            if (updateLedgerJournalTrans)
            {
                if (!_interCompany)
                {
                    ledgerJournalTransUpdate = LedgerJournalTransUpdate::construct(_ledgerJournalTrans, _isOffset);
                }
                else
                {
                    ledgerJournalTransUpdate = LedgerJournalTransUpdate::construct(_ledgerJournalTrans);
                }

                taxGroupCompany = LedgerJournalTrans::getSalesTaxGroupCompanyForIntercompany(_ledgerJournalTrans);
                if (!taxGroupCompany)
                {
                    if (_ledgerJournalTrans.ForeignVoucher != '')
                    {
                        TaxUncommitted taxUncommitted;
                        LedgerJournalTrans ledgerJournalTransWithSalesTaxGroup;
                        LedgerJournalTable tmpLedgerJournalTable;

                        select firstonly OriginalJournalNum from tmpLedgerJournalTable
                            where tmpLedgerJournalTable.JournalNum == _ledgerJournalTrans.JournalNum;

                        select firstonly crosscompany Company from taxUncommitted
                            where taxUncommitted.SourceTableId == tableNum(LedgerJournalTrans)
                            join RecId from ledgerJournalTransWithSalesTaxGroup
                                where ledgerJournalTransWithSalesTaxGroup.RecId == taxUncommitted.SourceRecId
                                    && ledgerJournalTransWithSalesTaxGroup.Voucher == _ledgerJournalTrans.ForeignVoucher
                                    && ledgerJournalTransWithSalesTaxGroup.Invoice == _ledgerJournalTrans.Invoice
                                    && ledgerJournalTransWithSalesTaxGroup.JournalNum == tmpLedgerJournalTable.OriginalJournalNum
                                    && ledgerJournalTransWithSalesTaxGroup.DataAreaId == _ledgerJournalTrans.ForeignCompany;

                        taxGroupCompany = taxUncommitted.Company;
                    }
                }

                ledgerJournalTransUpdate.parmTaxGroupCompany(taxGroupCompany);

                ok = ledgerJournalTransUpdate.checkWhenPost(_ledgerJournalTrans, _originalLedgerJournalTrans, checkNoSettlement, _ledgerPostingMessageCollection) &&
                    _ledgerJournalTrans.checkPaymentFilledOk(ledgerJournalTable) &&
                    _ledgerJournalTrans.validateBankAccount();

                ledgerJournalTransUpdate.setTaxVoucherService(taxVoucherService);
                // <GJP>
                LedgerJournalCheckPost_JP::setLedgerJournalTransUpdIntercompanyMap(isIntercompanyMapNeeded, ledgerJournalTransIntercompanyMap, ledgerJournalTransUpdate);
                // </GJP>

                // <GIN>
                if (TaxParameters::checkTaxParameters_IN())
                {
                    if (ledgerJournalTable.JournalType == LedgerJournalType::Approval)
                    {
                        ledgerJournalTransUpdate.parmApproval_IN(true);
                    }
                    ledgerJournalTransUpdate.parmInclTax_IN(inclTax);
                }

                if (taxWithholdParameterMarked)
                {
                    select firstonly FeeId from custVendPaymJournalFeeLoc
                        where custVendPaymJournalFeeLoc.FeeTransRecId == _ledgerJournalTrans.RecId;
                    if (custVendPaymJournalFeeLoc)
                    {
                        _ledgerJournalTrans.BankChequeNum = LedgerJournalCheckPost_IN::taxWithholdGetCheckNum(custVendPaymJournalFeeLoc.FeeId,
                                                                                        _ledgerJournalTrans.Voucher,
                                                                                        _ledgerJournalTrans.TransDate);
                    }
                }

                if (taxWithholdParameterMarked && interCmpWithholdingTaxAmount
                    && TaxWithholdParameters_IN::findByCompany(_ledgerJournalTrans.ForeignCompany).CrossCompanyPayment)
                {
                    _ledgerVoucher.parmAdvancePaymentWHT_IN(interCmpWithholdingTaxAmount);
                }
                // </GIN>

                hasAccrual = _journalHasAccruals && LedgerJournalTransAccrual::findAccountOffsetaccount(
                    _ledgerJournalTrans.TableId,
                    _ledgerJournalTrans.RecId,
                    _isOffset ? AccountOffsetaccount::OffsetAccount : AccountOffsetaccount::Account);

                ledgerJournalTransUpdate.parmAccrual(hasAccrual);
                ledgerJournalTransUpdate.parmIntercompanyRecIds(intercompanyRecIds);
                if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
                {
                    ledgerJournalTransUpdate.rboParameters(rboParameters);
                }

                ledgerJournalTransUpdate.parmIsVoucherValid(true);

                System.Diagnostics.Stopwatch stopWatchUpdateNow = perfMonitor.startNewStopwatch();

                ledgerJournalTransUpdate.updateNow(
                    _ledgerVoucher,
                    LedgerPostingType::LedgerJournal,
                    _ledgerJournalTrans,
                    _originalLedgerJournalTrans,
                    _interCompany,
                    _reversalsMayExist);

                perfMonitor.trackProcessingTimePerSubledger(classId2Name(classIdGet(ledgerJournalTransUpdate)), stopWatchUpdateNow.ElapsedMilliseconds);

                ok = ok && ledgerJournalTransUpdate.parmIsVoucherValid();
            }
        }

        // <GTE>
        // Merge tax document from custVendSettle with tax document for ledgerJournalTrans
        if (ledgerJournalTransUpdate && isGTEEnabled)
        {
            Map taxDocumentMapForSettlement = ledgerJournalTransUpdate.getTaxDocumentLedgerVoucherMap();
            if (taxDocumentMapForPosting)
            {
                if (taxDocumentMapForSettlement)
                {
                    MapEnumerator mapEnumerator = taxDocumentMapForSettlement.getEnumerator();
                    while(mapEnumerator.moveNext())
                    {
                        taxDocumentMapForPosting.insert(mapEnumerator.currentKey(), mapEnumerator.currentValue());
                    }
                }
            }
            else
            {
                taxDocumentMapForPosting = taxDocumentMapForSettlement;
            }
        }
        // </GTE>

        ledgerJournalTransUpdate = null;

        if (!_interCompany)
        {
            if (ledgerJournalTable.JournalType == LedgerJournalType::Approval)
            {
                if (_ledgerJournalTrans.VendTransId)
                {
                    select firstonly forupdate vendTrans
                        index hint recid
                        where vendTrans.RecId == _ledgerJournalTrans.VendTransId;

                    if (vendTrans)
                    {
                        VendInvoiceJour vendInvoiceJour = VendInvoiceJour::findFromVendTrans(
                            vendTrans.Invoice, 
                            vendTrans.TransDate, 
                            vendTrans.AccountNum, 
                            true, 
                            vendTrans.Voucher);

                        if (vendInvoiceJour)
                        {
                            vendInvoiceJour.initFromLedgerJournalTransApproval(_ledgerJournalTrans);

                            if (!vendInvoiceJour.SumTax && vendTrans.displayTaxAmountReverse())
                            {
                                vendInvoiceJour.SumTax = vendTrans.displayTaxAmountReverse();
                            }

                            vendInvoiceJour.doUpdate();
                        }

                        vendTrans.initFromLedgerJournalTransApproval(_ledgerJournalTrans);
                        vendTrans.update();

                        if (TaxIntegrationTaxJurisdictionParameters::shouldCashDiscDeductedBeforeTaxCalc(_ledgerJournalTrans))
                        {
                            select sum(CashDiscAmount)
                                from ledgerJournalTransLocal
                                where (ledgerJournalTransLocal.JournalNum         == _ledgerJournalTrans.JournalNum &&
                                       ledgerJournalTransLocal.Voucher            == _ledgerJournalTrans.Voucher &&
                                       ledgerJournalTransLocal.TransDate          == _ledgerJournalTrans.TransDate &&
                                       ledgerJournalTransLocal.PurchLedgerPosting == ArrivalPostingType::None);

                            while select forupdate vendTransOpen
                                where vendTransOpen.RefRecId == vendTrans.RecId
                            {
                                vendTransOpen.PossibleCashDisc = - ledgerJournalTransLocal.CashDiscAmount * vendTransOpen.AmountCur / vendTrans.AmountCur;
                                vendTransOpen.update();

                                select firstonly forupdate * from vendTransCashDisc
                                    order by CashDiscdate
                                    where vendTransCashDisc.RefRecId == vendTransOpen.RecId;
                                if (vendTransCashDisc)
                                {
                                    vendTransCashDisc.CashDiscAmount = vendTransOpen.PossibleCashDisc;
                                    vendTransCashDisc.update();
                                }
                            }
                        }
                    }
                }
            }
        }

        if (hasAccrual)
        {
            // some of the callers may change the default voucher
            _ledgerVoucher.lastVoucher(_ledgerJournalTrans.Voucher);
            _ledgerVoucher.lastTransDate(_ledgerJournalTrans.TransDate);
            _ledgerVoucher.lastPostingLayer(_ledgerJournalTrans.ledgerJournalTable().CurrentOperationsTax);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the <c>LedgerJournalTrans</c> should be updated.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_originalLedgerJournalTrans">
    /// The original <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// True to update <c>LedgerJournalTrans</c> record;
    /// </returns>
    [Wrappable(true)]
    protected final boolean shouldUpdateLedgerJournalTrans(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTrans _originalLedgerJournalTrans)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>progress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the operations's progress instance.
    /// </summary>
    /// <param name = "_progress">
    /// The <c>RunbaseProgress</c> instance.
    /// </param>
    public void progress(RunbaseProgress _progress)
    {
        progress = _progress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the progress for this operation.
    /// </summary>
    /// <param name = "_text">The progress text.</param>
    public void progressUpdate(str _text)
    {
        progressCounter++;
        progress.setCount(progressCounter);
        progress.setText(_text);
    }

]]></Source>
			</Method>
			<Method>
				<Name>replaceTmpVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Replaces temporary voucher numbers in the journal with real voucher numbers.
    /// </summary>
    /// <returns>
    /// A number sequence id.
    /// </returns>
    protected RefRecId replaceTmpVoucher()
    {
        NumberSequenceTable                 numberSequenceTable;
        Num                                 num;
        GeneralJournalEntry                 generalJournalEntry;
        LedgerJournalTrans                  ledgerJournalTrans;
        RefRecId                            numberSequenceId;
        Voucher                             oldVoucher          = '';
        Voucher                             voucherToPost;

        // <GCN>
        Voucher_CN              voucher_CN;
        
        // </GCN>
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        VendInvoiceIntrastat                vendInvoiceIntrastat;
        TaxUncommitted                      taxUncommitted;

        // <GIN>
        TaxWithholdUncommitted_IN           taxWithholdUncommitted;
        // </GIN>

        #ISOCountryRegionCodes

        if (ledgerJournalTable.VoucherAllocatedAtPosting)
        {
            LedgerChineseVoucherEnabled_CN chineseVoucher_CN = LedgerParameters::isChineseVoucher_CN();
            boolean taxWithhold_IN = TaxWithholdParameters_IN::checkTaxParameters();

            numberSequenceId       = ledgerJournalName.NumberSequenceTable;
            tmpVoucherMap       = new Map(Types::String, Types::String);
            errorTmpVoucherMap  = new Map(Types::String, Types::String);
            Map tmpVoucher_CNMap = new Map(Types::String, Types::String);

            LedgerJournalCheckPostInstrumentation::logTmpVoucherWithContinuousNumberSequence(numberSequenceId);

            if (MultipleTaxIdReportingHelper::isLegalEntityOrAddressInCountryRegion([#isoIT], MultipleTaxIdScope::VATDeclaration)
                && ledgerJournalName.taxBookSectionId()
                && !FeatureStateProvider::isFeatureEnabled(UnifiedPostingDateControlFeature_IT::instance()))//--> Italy:  Check transDate
            {
                numberSequenceTable = NumberSequenceTable::find(numberSequenceId);
                num = NumberSeq::numInsertFormat((numberSequenceTable.NextRec - 1),numberSequenceTable.Format);

                select maxof(AccountingDate) from subledgerVoucherGeneralJournalEntry
                    where subledgerVoucherGeneralJournalEntry.Voucher like num &&
                        subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == curext()
                    join RecId from generalJournalEntry
                    where generalJournalEntry.Ledger == Ledger::current() &&
                        generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry;

                select firstonly ledgerJournalTrans
                    where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum &&
                        ledgerJournalTrans.TransDate  < subledgerVoucherGeneralJournalEntry.AccountingDate;

                if (ledgerJournalTrans.RecId && subledgerVoucherGeneralJournalEntry.AccountingDate > ledgerJournalTrans.TransDate)
                {
                    throw error(strFmt("@SYS75074", date2StrUsr(ledgerJournalTrans.TransDate, DateFlags::FormatAll), date2StrUsr(subledgerVoucherGeneralJournalEntry.AccountingDate, DateFlags::FormatAll), ledgerJournalTrans.JournalNum));
                }
            }

            while select ledgerJournalTrans
                order by Voucher, AccountType
                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
            {
                if (ledgerJournalTrans.Voucher != oldVoucher)
                {
                    NumberSeq numSeqForNewVoucher = this.getNumberSeq(numberSequenceId);

                    voucherToPost = numSeqForNewVoucher.voucher();
                    oldVoucher = ledgerJournalTrans.Voucher;

                    tmpVoucherMap.insert(voucherToPost, oldVoucher);

                    // Set buffer value with new voucher for APIs that require the LedgerJournalTrans buffer
                    ledgerJournalTrans.Voucher = voucherToPost;

                    // update Voucher Template record only on first line of each voucher
                    if (ledgerJournalTable.JournalType == LedgerJournalType::Daily ||
                        ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister)
                    {
                        LedgerJournalTransVoucherTemplate::updateVoucherTemplate(
                            ledgerJournalTrans,
                            ledgerJournalTrans.JournalNum,
                            oldVoucher);
                    }

                    // update Vend Invoice Intrastat record with correct voucher number
                    vendInvoiceIntrastat = VendInvoiceIntrastat::findByVoucherTransDate(oldVoucher, ledgerJournalTrans.TransDate, true);
                    if (vendInvoiceIntrastat)
                    {
                        vendInvoiceIntrastat.Voucher = voucherToPost;
                        vendInvoiceIntrastat.update();
                    }

                    // <GCN>
                    if (chineseVoucher_CN)
                    {
                        if (ledgerJournalTrans.LedgerVoucherType_CN
                            && ledgerJournalTrans.Voucher_CN
                            && LedgerJournalTrans_CN_Extension::checkVoucherNotUsed_CN(ledgerJournalTrans))
                        {
                            voucher_CN = ledgerJournalTrans.Voucher_CN;
                        }
                        else
                        {
                            voucher_CN = NumberSeq_Voucher_CN::newGetVoucherFromCode(
                                LedgerVoucherType_CN::find(ledgerJournalTrans.LedgerVoucherType_CN).NumberSequenceTable,
                                ledgerJournalTrans.TransDate).voucher();
                        }

                        tmpVoucher_CNMap.insert(voucherToPost, voucher_CN);
                    }
                    // </GCN>

                    if (this.isApprovalJournal())
                    {
                        // Replace the temporary voucher with the posted approval voucher to maintain the link to the invoice register.
                        LedgerJournalVoucherChanged::modifyChangedVoucherDate(
                            ledgerJournalTable.JournalNum,
                            oldVoucher,
                            ledgerJournalTrans.TransDate,
                            voucherToPost,
                            ledgerJournalTrans.TransDate);
                    }
                }

                LedgerJournalCheckPostBank::updateBankCheque(ledgerJournalTrans, oldVoucher);
            }

            MapEnumerator voucherEnumerator = tmpVoucherMap.getEnumerator();

            while (voucherEnumerator.moveNext())
            {
                voucherToPost = voucherEnumerator.currentKey();
                oldVoucher = voucherEnumerator.currentValue();

                if (isGTEEnabled)
                {
                    TaxEngineLedgerJournalTransHeader::updateVoucherByJourNumVoucher(ledgerJournalTable.JournalNum, oldVoucher, voucherToPost);
                }

                // update TaxUncommited records
                update_recordset taxUncommitted
                    setting Voucher = voucherToPost
                    where taxUncommitted.HeadingTableId == tableNum(LedgerJournalTable) &&
                        taxUncommitted.HeadingRecId == ledgerJournalTable.RecId &&
                        taxUncommitted.Voucher == oldVoucher;

                // update TaxWithholdUncommitted_IN and TaxWithholdSettleTrans_IN records
                if (taxWithhold_IN)
                {
                    update_recordset taxWithholdUncommitted
                        setting Voucher = voucherToPost
                            where taxWithholdUncommitted.HeadingTableId == ledgerJournalTable.TableId
                                && taxWithholdUncommitted.HeadingRecId == ledgerJournalTable.RecId
                                && taxWithholdUncommitted.Voucher == oldVoucher;

                    TaxWithholdSettleTrans_IN taxWithholdSettleTrans_IN;

                    taxWithholdSettleTrans_IN.skipDataMethods(true);
                    taxWithholdSettleTrans_IN.skipEvents(true);

                    update_recordset taxWithholdSettleTrans_IN
                        setting LedgerVoucher = voucherToPost
                            where taxWithholdSettleTrans_IN.Mark == true
                                && taxWithholdSettleTrans_IN.Closed == false
                                exists join RecId from ledgerJournalTrans
                                    where ledgerJournalTrans.Voucher == taxWithholdSettleTrans_IN.LedgerVoucher
                                        && ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                                        && ledgerJournalTrans.Voucher == oldVoucher;
                }

                Voucher voucherCN;

                if (chineseVoucher_CN)
                {
                    voucherCN = tmpVoucher_CNMap.lookup(voucherToPost);
                }

                ledgerJournalTrans.skipDataMethods(true);
                ledgerJournalTrans.skipEvents(true);

                update_recordset ledgerJournalTrans
                    setting Voucher = voucherToPost,
                        Voucher_CN = voucherCN
                        where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum &&
                            ledgerJournalTrans.Voucher == oldVoucher;

                // Update budget source with new voucher number.
                if (BudgetControlCheckRequest::isControlConfigured() && isBudgetControlSourceIntegrationSupported)
                {
                    LedgerJournalCheckPostBudget::updatedVoucherForBudgetSource(ledgerJournalTable, ledgerJournalTable.JournalNum, oldVoucher, voucherToPost);
                }

                LedgerJournalCheckPost_PL::updateVoucherForExportSalesVAT(ledgerJournalTable.JournalNum, oldVoucher, voucherToPost);
            }
        }
        else
        {
            numberSequenceId = ledgerJournalTable.NumberSequenceTable;
        }

        return numberSequenceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberSeq</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>NumberSeq</c> object.
    /// </summary>
    /// <param name = "_numberSequenceId">
    /// A number sequence id.
    /// </param>
    /// <returns>
    /// A <c>NumberSeq</c> object.
    /// </returns>
    [Wrappable(true)]
    protected final NumberSeq getNumberSeq(RefRecId _numberSequenceId)
    {
        return NumberSeq::newGetVoucherFromId(_numberSequenceId, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reuseTmpVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Restore the vouchers of the unposted lines due to errors.
    /// </summary>
    protected void reuseTmpVoucher()
    {
        MapIterator         mapIterator;
        LedgerJournalTrans  ledgerJournalTransLocal;

        if (errorTmpVoucherMap)   // restore the voucher of the unposted ledgerJournalTrans
        {
            mapIterator = new MapIterator(errorTmpVoucherMap);
            while (mapIterator.more())
            {
                while select forupdate ledgerJournalTransLocal
                 where ledgerJournalTransLocal.JournalNum == ledgerJournalTable.JournalNum
                    && ledgerJournalTransLocal.Voucher    == mapIterator.key()
                {
                    // <GCN>
                    if (LedgerParameters::isChineseVoucher_CN()
                        && ledgerJournalTable.VoucherAllocatedAtPosting)
                    {
                        NumberSeq_Voucher_CN::release(
                            LedgerVoucherType_CN::find(ledgerJournalTransLocal.LedgerVoucherType_CN).NumberSequenceTable,
                            ledgerJournalTransLocal.Voucher_CN,
                            ledgerJournalTransLocal.TransDate);
                        ledgerJournalTransLocal.Voucher_CN = '';
                    }
                    // </GCN>
                    ledgerJournalTransLocal.Voucher = mapIterator.value();
                    ledgerJournalTransLocal.doUpdate();
                }
                mapIterator.next();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the posting operation and post operation processing.
    /// </summary>
    /// <param name = "_ledgerJournalCheckPost">The <c>LedgerJournalCheckPost</c> instance.</param>
    /// <param name = "_ledgerJournalEngine">The <c>LedgerJournalEngine</c>instance; optional.</param>
    public static void processOperation(
        LedgerJournalCheckPost _ledgerJournalCheckPost,
        LedgerJournalEngine _ledgerJournalEngine = null)
    {
        if (_ledgerJournalCheckPost == null)
        {
            throw error (error::wrongUseOfFunction(funcName()));
        }

        try
        {
            if (_ledgerJournalCheckPost.canGoBatch() && !_ledgerJournalCheckPost.prompt())
            {
                return;
            }

            _ledgerJournalCheckPost.runOperation();
        }
        catch (Exception::Break)
        {
            _ledgerJournalCheckPost.processCancel();

            throw Exception::Break;
        }
        finally
        {
            if (_ledgerJournalEngine)
            {
                _ledgerJournalEngine.parmPostingResults_Server(_ledgerJournalCheckPost.parmPostingResults());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        try
        {
            this.runInternal();

            this.publishPostedJournalEvent();
        }
        catch
        {
            if (transferErrors)
            {
                // Transfer errors if necessary.
                this.transferJournalErrors();
            }

            // If an unhandled exception occurs, perform cleanup activities such as removing the system lock
            this.finalizeOnError();

            // Chain the exception forward so that processes like batch recognize the
            // error and therefore correctly update their success status.
            throw Exception::Error;
        }
        // This call covers the scenario that a voucher did not post yet an error wasn't thrown.
        if (transferErrors)
        {
            // Transfer errors if necessary.
            this.transferJournalErrors();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>publishPostedJournalEvent</Name>
				<Source><![CDATA[
    private void publishPostedJournalEvent()
    {
        try
        {
            // Publish parent journal once all the split journals are posted.
            if (!ledgerJournalTable.hasUnpostedSiblings())
            {
                LedgerPostedJournalTable postedParentJournal;

                select firstonly RecId from postedParentJournal
                    where postedParentJournal.PostedJournalNum == ledgerJournalTable.ParentJournalNum;

                if (!postedParentJournal.RecId) // This check makes sure that ParentJournal posting event is published only once
                {
                    postedParentJournal.PostedJournalNum = ledgerJournalTable.ParentJournalNum;

                    ttsbegin;

                    postedParentJournal.insert();                    

                    LedgerJournalCheckPost::publishPostedParentJournal(ledgerJournalTable.getParentJournalNumber());

                    ttscommit;
                }
            }
            
        }
        catch(Exception::DuplicateKeyException)
        {
            // do nothing
        }
        catch
        {
            throw;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferJournalErrors</Name>
				<Source><![CDATA[
    private void transferJournalErrors()
    {
        if (this.numOfErrorsInList() && this.numOfVouchersBooked() > 0)
        {
            this.transferToNewLedgerTable();

            // Reset internal variables/maps before invoking posting again with the error vouchers transferred to another journal
            this.resetInternals();

            this.runInternal();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runInternal</Name>
				<Source><![CDATA[
    protected void runInternal()
    {
        #OCCRetryCount

        boolean postingSuccess;
        boolean intercompanyPostingSuccess;
        Counter progressTotal;

        // <GCN>
        boolean     countryRegion_CN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCN]);
        // </GCN>

        Microsoft.Dynamics.Ax.Xpp.InfoException infoEx;
        Microsoft.Dynamics.Ax.Xpp.ErrorException errorEx;
        Microsoft.Dynamics.Ax.Xpp.DeadlockException deadLockEx;
        Microsoft.Dynamics.Ax.Xpp.UpdateConflictException updateConflictEx;

        // <GTE>
        if (isGTEEnabled)
        {
            taxDocumentMapForPosting = new Map(Types::AnyType, Types::AnyType);
        }
        // </GTE>

        using (SysInstrumentationActivityContext activityContext =
            LedgerJournalCheckPostInstrumentation::createLogger().activityContext(LedgerJournalInstrumentationConstants::ActivityNamePostJournal, LedgerJournalInstrumentationConstants::InstrumentationNamespace))
        {
            real startWatchTimeCompleteJournalProcessing = activityContext.getElapsedMilliseconds();
            real startWatchTimeJournalPostingValidationStep = activityContext.getElapsedMilliseconds();
            real startWatchTimeJournalPostingStep;
            real startWatchTimeJournalPostProcessingStep;
            real stopWatchTimeCompleteJournalProcessing;
            real stopWatchTimeJournalPostingValidationStep;
            real stopWatchTimeJournalPostingStep;
            real stopWatchTimeJournalPostProcessingStep;

            try
            {
                // Attempt to block the journal. Retry until it doesn't fail or the
                // maximum retry count is reached. Do nothing on failures since the
                // block failed and the result is that nothing is blocked.

                ttsbegin;

                // <GCN>
                if (LedgerParameters::isChineseVoucher_CN())
                {
                    if (!LedgerJournalCheckPost_CN::checkRestriction(ledgerJournalId))
                    {
                        // At least one voucher doesn't meet voucher type rules.
                        throw error("@GLS60255");
                    }
                }
                // </GCN>

                ledgerJournalTable = LedgerJournalTable::find(ledgerJournalId, true);
                ledgerJournalName   = ledgerJournalTable.ledgerJournalName();

                activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::CustomPropertyJournalRecId, int642Str(ledgerJournalTable.RecId));

                if (inTransfer)
                {
                    inTransfer = false;
                }
                else
                {
                    if (!this.validate())
                    {
                        throw error(strFmt("@GeneralLedger:GeneralJournalPostPreValidateFail", ledgerJournalId));
                    }

                    if (ledgerJournalTable.checkIsBlockedOrInUse())
                    {
                        throw error(strFmt("@GeneralLedger:GeneralJournalPostPreValidateFail", ledgerJournalId));
                    }

                    // <GCN>
                    if (!postProforma || !countryRegion_CN)
                    {
                        // </GCN>
                        this.updateSystemBlock(ledgerJournalTable, true);
                        // <GCN>
                    }
                    // </GCN>
                }

                ttscommit;

                stopWatchTimeJournalPostingValidationStep = activityContext.getElapsedMilliseconds();

                activityContext.addCustomProperty(
                    LedgerJournalInstrumentationConstants::TimeforJournalPostingValidationStep,
                        any2Str((stopWatchTimeJournalPostingValidationStep - startWatchTimeJournalPostingValidationStep) / 1000));
            }
            catch (deadLockEx)
            {
                this.logJournalPostingProcessException(deadLockEx, methodStr(LedgerJournalCheckPost, runInternal));

                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::Error, deadLockEx.Message);
                    throw Exception::Deadlock;
                }
                else
                {
                    activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::RetryCount, any2Str(xSession::currentRetryCount()));
                    LedgerJournalCheckPostInstrumentation::logRetryDeadlock();

                    retry;
                }
            }
            catch (updateConflictEx)
            {
                this.logJournalPostingProcessException(updateConflictEx, methodStr(LedgerJournalCheckPost, runInternal));

                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::Error, updateConflictEx.Message);
                        throw Exception::UpdateConflictNotRecovered;
                    }
                    else
                    {
                        activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::RetryCount, any2Str(xSession::currentRetryCount()));
                        LedgerJournalCheckPostInstrumentation::logRetryUpdateConflict();

                        retry;
                    }
                }
                else
                {
                    activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::Error, updateConflictEx.Message);
                    throw Exception::UpdateConflict;
                }
            }

            try
            {
                // Reset timer to calculate journal posting time
                startWatchTimeJournalPostingStep = activityContext.getElapsedMilliseconds();

                // Attempt to process the journal. Retry until it doesn't fail or the
                // maximum retry count is reached. Make sure it is unblocked by all
                // paths when it succeeds or the maximum retry count is reached.

                //
                // Updates to the LedgerJournalTable during the previous validation process
                // require a re-set of these values.
                //
                ledgerJournalTable  = LedgerJournalTable::find(ledgerJournalId);
                ledgerJournalName   = ledgerJournalTable.ledgerJournalName();

                numOfVouchersBooked = 0;
                progressTotal       = voucherNum ? 1 : ledgerJournalTable.numOfVouchers();

                perfMonitor.trackJournal(ledgerJournalTable);

                if (progressTotal)
                {
                    // Posted journals should not be checked or posted
                    if (ledgerJournalTable.Posted == NoYes::No)
                    {
                        if (postingResults != null)
                        {
                            ledgerPostingMessageCollection = LedgerPostingMessageLog::construct();
                            postingResults.parmLedgerPostingMessageLog(ledgerPostingMessageCollection);
                            postingResults.clearErrorLog();
                        }

                        if (!post)
                        {
                            if (!progress)
                            {
                                this.progressInit("@SYS13894", progressTotal, #AviFindFile);
                                progress.setText("@SYS26577");
                            }

                            System.Diagnostics.Stopwatch stopWatchCheckJournal = perfMonitor.startNewStopwatch();

                            boolean validateSuccess = this.checkJournal();

                            durationCheckJournal = stopWatchCheckJournal.ElapsedMilliseconds;

                            perfMonitor.finalizeForValidation(validateSuccess, durationCheckJournal);

                            this.runInternalPostValidateJournalDelegate(this, validateSuccess);

                            //  The journal was successfully checked; release the system block.
                            this.updateSystemBlockCheckedPostedJournal();
                        }
                        else
                        {
                            this.progressInit("@SYS25781", progressTotal, #AviFormLetter);
                            progress.setText("@SYS26577");

                            boolean skipCommit = false;
                            boolean skipFinalLogic = false;
                            boolean skipPostProcessing = false;

                            ttsbegin;
                            this.initializePostingTransactionScopeHandlers();
                            int postingTtsLevel = appl.ttsLevel();

                            //<GIN>
                            tdsWarningMsg = false;
                            //</GIN>

                            this.runInternalPrePostJournalDelegate(this);

                            System.Diagnostics.Stopwatch stopWatchPostJournal = perfMonitor.startNewStopwatch();

                            boolean isContextRequired =  this.parmSimulatePosting() && ProjCustPaymentJournalSimulatePostingFlight::instance().isEnabled();
        
                            using (ProjLedgerJournalPostContext context = isContextRequired ? ProjLedgerJournalPostContext::construct() : null)
                            {
                                if (context)
                                {
                                    context.parmSimulatePosting(this.parmSimulatePosting());
                                }

                                [postingSuccess, intercompanyPostingSuccess] = this.postJournal();
                            }

                            durationPostJournal = stopWatchPostJournal.ElapsedMilliseconds;
                            perfMonitor.finalizeForPosting(activityContext, postingSuccess, durationPostJournal, BatchHeader::isExecutingInBatch());

                            stopWatchTimeJournalPostingStep = activityContext.getElapsedMilliseconds();

                            activityContext.addCustomProperty(
                                LedgerJournalInstrumentationConstants::TimeforJournalPostingStep,
                                any2Str((stopWatchTimeJournalPostingStep - startWatchTimeJournalPostingStep) / 1000));

                            // Reset timer to calculate Post processing time
                            startWatchTimeJournalPostProcessingStep = activityContext.getElapsedMilliseconds();

                            this.runInternalPostPostJournalDelegate(this, postingSuccess, intercompanyPostingSuccess);

                            // <GCN>
                            if ((postProforma && countryRegion_CN)
                            // </GCN>
                            || (this.parmSimulatePosting()))
                            {
                                skipCommit = true;
                                skipFinalLogic = true;
                                skipPostProcessing = true;
                            }

                            if (!skipFinalLogic)
                            {
                                if (!postingSuccess || !intercompanyPostingSuccess)
                                {
                                    if (transferErrors)
                                    {
                                        inTransfer = true;

                                        skipCommit = true;
                                        skipFinalLogic = true;
                                        skipPostProcessing = true;

                                        //  Release the system block.
                                        this.updateSystemBlockCheckedPostedJournal();
                                    }
                                    // <GIN>
                                    // If the posting unsuccess is caused by India TDS warning message
                                    else if (tdsWarningMsg)
                                    {
                                        skipCommit = true;
                                        skipFinalLogic = true;
                                        skipPostProcessing = true;

                                        this.updateSystemBlockCheckedPostedJournal();
                                    }
                                    // </GIN>
                                    else if (this.abortOnPostingFailure())
                                    {
                                        skipCommit = true;
                                        skipFinalLogic = true;
                                        skipPostProcessing = true;

                                        this.updateSystemBlockCheckedPostedJournal();
                                    }
                                    else
                                    {
                                        throw error("@SYS21628");
                                    }
                                }
                                else if (numOfVouchersBooked)
                                {
                                    this.updateJournalForPosted();

                                    TransactionLog::create(TransactionLogType::LedgerJournal, ledgerJournalTable.JournalNum + ' ' + ledgerJournalTable.Name);
                                }
                                // <GEERU>
                                else if (rCashRejectedLineExists)
                                {
                                    ledgerJournalTable = LedgerJournalTable::find(ledgerJournalId, true);

                                    [ledgerJournalTable.JournalTotalDebit,
                                     ledgerJournalTable.JournalTotalCredit,
                                     ledgerJournalTable.JournalTotalOffsetBalance,
                                     ledgerJournalTable.JournalTotalDebitReportingCurrency,
                                     ledgerJournalTable.JournalTotalCreditReportingCurrency] = LedgerJournalTable::journalBalanceMST(ledgerJournalId);

                                    ledgerJournalTable.Posted           = NoYes::Yes;
                                    ledgerJournalTable.PostedDateTime   = DateTimeUtil::getSystemDateTime();
                                    ledgerJournalTable.update();
                                }
                                // </GEERU>

                                // there is a double check of skipFinalLogic because it can be set inside the first check
                                if (!skipFinalLogic)
                                {
                                    // Submit the budget funds available check for the posted journal.
                                    LedgerJournalCheckPostBudget::submitBudgetForPostJournal(this);
                                }
                            }

                            if (skipCommit)
                            {
                                ttsabort;
                            }
                            else
                            {
                                // <GEERU>
                                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                                {
                                    LedgerJournalCheckPost_RU::postCorrection(ledgerJournalTable);
                                }
                                // </GEERU>

                                LedgerJournalCheckPostInstrumentation::logTtsLevelMismatch(appl.ttsLevel(), postingTtsLevel);

                                ttscommit;
                            }

                            this.runInternalPostJournalTransactionEnded(this);

                            if (this.parmSimulatePosting())
                            {
                                info("@SYS9265");

                                //  Release the system block.
                                this.updateSystemBlockCheckedPostedJournal();
                            }
                            else if (this.parmTransferErrors())
                            {
                                //  Release the system block.
                                this.removeSystemBlock();
                            }
                            else
                            {
                                this.postTaxDocument();
                            }

                            if (!skipPostProcessing)
                            {
                                //  The journal was successfully posted; release the system block.
                                this.updateSystemBlockCheckedPostedJournal();

                                LedgerJournalCheckPostCash::interCompanyTransferToCustPayment(this);

                                CashRegisterProcessingBase::sendFromLedgerJournal(ledgerJournalTable);

                                if (postingSuccess && ledgerJournalTable && (ledgerJournalTable.JournalType == LedgerJournalType::PayrollDisbursement))
                                {
                                    VendTrans vendTrans;

                                    select firstonly * from vendTrans
                                        where vendTrans.Invoice == ledgerJournalTable.DocumentNum;

                                    if (vendTrans != null)
                                    {
                                        LedgerJournalCheckPostCash::settlePayrollDisbursementJournal(ledgerJournalTable, vendTrans, bquiet);
                                    }
                                    else
                                    {
                                        if (!bquiet)
                                        {
                                            warning(strFmt("@SYS4090093", ledgerJournalTable.DocumentNum));
                                        }
                                    }
                                }

                                if (postingSuccess
                                    && ledgerJournalTable
                                    && LedgerJournalTable::canJournalTypeHaveSettlements(ledgerJournalTable.JournalType)
                                    && LedgerJournalTable::hasAnySpecTrans(ledgerJournalTable.JournalNum))
                                {
                                    LedgerJournalTable::deleteMarkedTransactionsForJournal(ledgerJournalTable.JournalNum);
                                }

                                if (postingSuccess && intercompanyPostingSuccess)
                                {
                                    // <GEERU>
                                    if (! this.parmPreview_RU())
                                    {
                                        // </GEERU>
                                        if (!bquiet)
                                        {
                                            if (voucherNum)
                                            {
                                                info(strFmt("@SYS9799", LedgerJournalTrans::findTmpVoucher(voucherNum, tmpVoucherMap)));
                                            }
                                            else
                                            {
                                                info(strFmt("@SYS25783", numOfVouchersBooked));
                                            }
                                        }
                                        // <GEERU>
                                    }
                                    // </GEERU>
                                }
                                else
                                {
                                    if (!intercompanyPostingSuccess || !transferErrors)
                                    {
                                        if (voucherNum)
                                        {
                                            if (!bquiet)
                                            {
                                                info(strFmt("@SYS19281", LedgerJournalTrans::findTmpVoucher(voucherNum, tmpVoucherMap)));
                                            }
                                        }
                                        else
                                        {
                                            checkFailed("@SYS23002");
                                        }

                                        this.reuseTmpVoucher();   // restore the voucher of the unposted ledgerJournalTrans
                                    }

                                    this.reuseTmpVoucher();   // restore the voucher of the unposted ledgerJournalTrans
                                }

                                stopWatchTimeJournalPostProcessingStep = activityContext.getElapsedMilliseconds();

                                activityContext.addCustomProperty(
                                    LedgerJournalInstrumentationConstants::TimeforJournalPostProcessingStep,
                                    any2Str((stopWatchTimeJournalPostProcessingStep - startWatchTimeJournalPostProcessingStep) / 1000));

                                stopWatchTimeCompleteJournalProcessing = activityContext.getElapsedMilliseconds();

                                activityContext.addCustomProperty(
                                    LedgerJournalInstrumentationConstants::TimeforCompleteJournalProcessing,
                                    any2Str((stopWatchTimeCompleteJournalProcessing - startWatchTimeCompleteJournalProcessing) / 1000));
                            }
                        }
                    }
                }
                else
                {
                    throw info("@SYS27671");
                }
            }
            catch (deadLockEx)
            {
                activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::Error, deadLockEx.Message);

                this.logJournalPostingProcessException(deadLockEx, methodStr(LedgerJournalCheckPost, runInternal));

                LedgerJournalCheckPostInstrumentation::logRetryDeadlock();

                retry;
            }
            catch (updateConflictEx)
            {
                this.logJournalPostingProcessException(updateConflictEx, methodStr(LedgerJournalCheckPost, runInternal));

                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        this.removeSystemBlock();
                        activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::Error, updateConflictEx.Message);
                        throw Exception::UpdateConflictNotRecovered;
                    }
                    else
                    {
                        LedgerJournalCheckPostInstrumentation::logRetryUpdateConflict();

                        retry;
                    }
                }
                else
                {
                    this.removeSystemBlock();
                    activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::Error, updateConflictEx.Message);
                    throw Exception::UpdateConflict;
                }
            }
            catch (errorEx)
            {
                this.logJournalPostingProcessException(errorEx, methodStr(LedgerJournalCheckPost, runInternal));

                this.finalizeOnError();

                activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::Error, errorEx.Message);

                // Chain the exception forward so that processes like batch recognize the
                // error and therefore correctly update their success status.
                throw Exception::Error;
            }
            catch (infoEx)
            {
                activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::Error, infoEx.Message);

                this.logJournalPostingProcessException(infoEx, methodStr(LedgerJournalCheckPost, runInternal));

                ttsbegin;

                // Restores temp voucher numbers on budget sources.
                LedgerJournalCheckPostBudget::restoreTmpVoucherForBudget(this);

                // Buffer values may have changed this requires a new "find with lock" for updating the "System blocked" information.
                ledgerJournalTable = LedgerJournalTable::find(ledgerJournalId, true);

                // Un-block the journal and display the info block
                this.updateSystemBlock(ledgerJournalTable, false);

                ttscommit;

                // Chain the exception forward so that processes like batch recognize the
                // error and therefore correctly update their success status.
                throw Exception::Error;
            }
            catch (Exception::CLRError)
            {
                System.Exception ex = ClrInterop::getLastException();

                if (ex != null)
                {
                    activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::Error, ex.Message);
                }

                this.finalizeOnError();

                this.logCLRException();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logCLRException</Name>
				<Source><![CDATA[
    private void logCLRException()
    {
        System.Exception ex = ClrInterop::getLastException();

        if (ex != null)
        {
            ApplicationUnhandledExceptionLogger::logCLRException(ex);

            str errorMessage = ex.Message;

            // If an inner exception exists, display this error message as it is the original exception message
            // which is more useful
            if (ex.InnerException != null)
            {
                this.logJournalPostingProcessException(ex.InnerException, methodStr(LedgerJournalCheckPost, runInternal));
                errorMessage = ex.InnerException.Message;
            }
            else
            {
                this.logJournalPostingProcessException(ex, methodStr(LedgerJournalCheckPost, runInternal));
            }

            throw error(errorMessage);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeOnError</Name>
				<Source><![CDATA[
    private void finalizeOnError()
    {
        ttsbegin;

        // capture any errors thrown during posting because only errors that
        // return false during validation have been captured so far
        this.updateTransInfoLog();

        this.finalizeOnErrorPre();

        // Restores temp voucher numbers on budget sources.
        if (BudgetControlCheckRequest::isControlConfigured() && isBudgetControlSourceIntegrationSupported)
        {
            LedgerJournalCheckPostBudget::restoreTmpVoucherForBudget(this);
        }

        // <GEEPL>
        // Restores temp voucher numbers on export sales VAT.
        LedgerJournalCheckPost_PL::restoreTmpVoucherForExportSalesVAT(this);
        // </GEEPL>

        // Buffer values may have changed this requires a new "find with lock" for updating the "System blocked" information.
        ledgerJournalTable = LedgerJournalTable::find(ledgerJournalId, true);

        this.updateSystemBlock(ledgerJournalTable, false);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeOnErrorPre</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method could be used for adding exensibility to finalizeOnError via CoC.
    /// </summary>
    protected void finalizeOnErrorPre()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>abortOnPostingFailure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the abort has to be performed without throwing an error.
    /// </summary>
    /// <returns>
    /// Returns true if abort has to be performed; otherwise, false.
    /// </returns>
    protected boolean abortOnPostingFailure()
    {
        //This is for extensibility purpose.
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalForPosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the journal details after posting.
    /// </summary>
    protected void updateJournalForPosted()
    {
        //
        // Updates to the LedgerJournalTable during the previous posting process
        // require a re-set of this value.
        //
        ledgerJournalTable = LedgerJournalTable::find(ledgerJournalId, true);

        // Defensive check to ensure the journal is not double posted if the journal system lock
        // does not prevent a parallel posting of the journal.
        if (ledgerJournalTable.Posted)
        {
            LedgerJournalCheckPostInstrumentation::logJournalAlreadyPosted();

            throw error(strfmt("@SYS18421", ledgerJournalTable.JournalNum));
        }

        [ledgerJournalTable.JournalTotalDebit,
                                    ledgerJournalTable.JournalTotalCredit,
                                    ledgerJournalTable.JournalTotalOffsetBalance,
                                    ledgerJournalTable.JournalTotalDebitReportingCurrency,
                                    ledgerJournalTable.JournalTotalCreditReportingCurrency] = LedgerJournalTable::journalBalanceMST(ledgerJournalId);

        this.ledgerTransferToJournal(ledgerJournalId);

        LedgerJournalCheckPostCash::updateMarkedInvoiceRecIdLines(ledgerJournalTable);

        if (!errorJournalDeleted)
        {
            ledgerJournalTable.Posted           = NoYes::Yes;
            ledgerJournalTable.PostedDateTime   = DateTimeUtil::getSystemDateTime();

            if (this.transferErrors())
            {
                //
                // The journal balances must be recalculated to account for
                // transfered error transactions.
                //
                [ledgerJournalTable.JournalTotalDebit,
                                         ledgerJournalTable.JournalTotalCredit,
                                         ledgerJournalTable.JournalTotalOffsetBalance,
                                         ledgerJournalTable.JournalTotalDebitReportingCurrency,
                                         ledgerJournalTable.JournalTotalCreditReportingCurrency] = LedgerJournalTable::journalBalanceMST(ledgerJournalId);

                ledgerJournalTable.Log = strFmt("@SYS53324", this.numOfErrorsInList(), errorLedgerJournalId);
            }

            LedgerJournalCheckPostPurch::purchLineSubmitToWorkflow(ledgerJournalTable);
        }

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            if (ledgerJournalTable.Posted)
            {
                TaxWithholdSettleTrans_IN taxWithholdSettleTrans;
                LedgerJournalTrans ledgerJournalTrans;

                update_recordset taxWithholdSettleTrans
                    setting Closed = true
                    where taxWithholdSettleTrans.Mark == true
                        && taxWithholdSettleTrans.Closed == false
                    join RecId, Voucher from ledgerJournalTrans
                        where ledgerJournalTrans.Voucher == taxWithholdSettleTrans.LedgerVoucher
                            && ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum;
            }
        }
        // </GIN>

        ledgerJournalTable.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>tableErrorLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the error log.
    /// </summary>
    /// <returns>
    /// The error log string.
    /// </returns>
    public Log tableErrorLog()
    {
        return tableErrorLog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferErrors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if there are journal lines to transfer for errors.
    /// </summary>
    /// <returns>
    /// true if there are errors and errors should be transferred; otherwise, false.
    /// </returns>
    protected boolean transferErrors()
    {
        return (transferErrors && voucherErrorList.elements() > 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferToNewLedgerTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfers journal lines due to error.
    /// </summary>
    /// <returns>
    /// The journal batch number of error journal.
    /// </returns>
    public LedgerJournalId transferToNewLedgerTable()
    {
        #OCCRetryCount
        LedgerJournalTable      errorLedgerJournalTable;
        LedgerJournalTable_W    errorLedgerJournalTableW;
        LedgerJournalTableData  journalTableData = JournalTableData::newTable(ledgerJournalTable);
        Voucher                 voucher;
        SetEnumerator           voucherErrorListEnumerator;
        SysInfoAction_Formrun   sysInfoAction_Formrun;

        try
        {
            if (this.transferErrors())
            {
                ttsbegin;

                errorLedgerJournalId = journalTableData.nextJournalId();

                errorLedgerJournalTable.JournalNum = errorLedgerJournalId;
                errorLedgerJournalTable.DefaultDimension = ledgerJournalTable.DefaultDimension;
                errorLedgerJournalTable.initFromLedgerJournalTable(ledgerJournalTable);
                errorLedgerJournalTable.GroupBlockId = ledgerJournalTable.GroupBlockId;
                errorLedgerJournalTable.FixedOffsetAccount = ledgerJournalTable.FixedOffsetAccount;

                if (SysExtensionSerializerExtensionMap::isExtensionEnabled(tableNum(LedgerJournalTable_W)))
                {
                    buf2Buf(ledgerJournalTable.ledgerJournalTable_W(), errorLedgerJournalTableW);
                    errorLedgerJournalTableW.LedgerJournalTable = errorLedgerJournalTable.RecId;
                    errorLedgerJournalTable.packLedgerJournalTable_W(errorLedgerJournalTableW);
                }

                errorLedgerJournalTable.insert();

                voucherErrorListEnumerator = voucherErrorList.getEnumerator();

                while (voucherErrorListEnumerator.moveNext())
                {
                    voucher = voucherErrorListEnumerator.current();

                    journalTableData.moveVoucherToJournal(errorLedgerJournalTable.JournalNum, voucher);

                    // Update budget source with new journal number.
                    if (isBudgetControlSourceIntegrationSupported)
                    {
                        LedgerJournalCheckPostBudget::transferBudgetSourceToNewJournalTable(
                            ledgerJournalTable,
                            errorLedgerJournalTable.JournalNum,
                            voucher);
                    }
                }

                sysInfoAction_Formrun = SysInfoAction_Formrun::newFormname(formStr(LedgerJournalTable));
                sysInfoAction_Formrun.parmCallerBuffer(LedgerJournalTable::find(errorLedgerJournalId));

                if (!bquiet)
                {
                    info(strFmt("@SYS53324", this.numOfErrorsInList(), errorLedgerJournalId), '', sysInfoAction_Formrun);
                }

                ttscommit;

                // The tax voucher service is no longer valid since vouchers have been moved,
                // clear out the tax voucher service and rebuild without using retained cache
                taxVoucherService = null;
            }

            return errorLedgerJournalId;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the class.
    /// </summary>
    /// <returns>The packed container. </returns>
    public container pack()
    {
        return [CurrentVersion,       ledgerJournalId,       voucherNum,          post,               transferErrors,
                detailSummaryPosting, showErrorOk,           numOfVouchersBooked, ledgerJournalTable, voucherErrorList.pack(),
                tableErrorLog,        postingResults.pack(), bquiet,              progressBarHide,    checkPaymStatus,
                inTransfer,           parmPreview,           postProforma,        tdsWarningMsg,      retailCustTrans,
                retailTransactionId,  retailStoreId,         retailTerminalId,    simulatePosting,    mapJournalEntry.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Version version = RunBase::getVersion(packedClass);
        container voucherErrorListContainer;
        container postingResultsContainer;
        container mapJournalEntryContainer;

        #LOCALMACRO.CurrentList_V1
            ledgerJournalId,
            voucherNum,
            post
        #ENDMACRO

        switch (version)
        {
            case CurrentVersion:
                [version,                 ledgerJournalId,         voucherNum,          post,               transferErrors,
                    detailSummaryPosting, showErrorOk,             numOfVouchersBooked, ledgerJournalTable, voucherErrorListContainer,
                    tableErrorLog,        postingResultsContainer, bquiet,              progressBarHide,    checkPaymStatus,
                    inTransfer,           parmPreview,             postProforma,        tdsWarningMsg,      retailCustTrans,
                    retailTransactionId,  retailStoreId,           retailTerminalId,    simulatePosting,    mapJournalEntryContainer] = packedClass;

                voucherErrorList = Set::create(voucherErrorListContainer);
                postingResults = LedgerJournalCheckPostResults::createClient(postingResultsContainer);
                mapJournalEntry = Map::create(mapJournalEntryContainer);
                if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
                {
                    this.rboParameters(retailCustTrans, retailTransactionId, retailStoreId, retailTerminalId);
                }

                break;

            case 4:
                [version,                 ledgerJournalId,         voucherNum,          post,               transferErrors,
                    detailSummaryPosting, showErrorOk,             numOfVouchersBooked, ledgerJournalTable, voucherErrorListContainer,
                    tableErrorLog,        postingResultsContainer, bquiet,              progressBarHide,    checkPaymStatus,
                    inTransfer,           parmPreview,             postProforma,        tdsWarningMsg,       retailCustTrans,
                    retailTransactionId,  retailStoreId,         retailTerminalId] = packedClass;

                voucherErrorList = Set::create(voucherErrorListContainer);
                postingResults = LedgerJournalCheckPostResults::createClient(postingResultsContainer);
                if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
                {
                    this.rboParameters(retailCustTrans, retailTransactionId, retailStoreId, retailTerminalId);
                }

                break;

            case 3:
                [version,                 ledgerJournalId,         voucherNum,          post,               transferErrors,
                    detailSummaryPosting, showErrorOk,             numOfVouchersBooked, ledgerJournalTable, voucherErrorListContainer,
                    tableErrorLog,        postingResultsContainer, bquiet,              progressBarHide,    checkPaymStatus,
                    inTransfer,           parmPreview,             postProforma,        tdsWarningMsg] = packedClass;

                voucherErrorList = Set::create(voucherErrorListContainer);
                postingResults = LedgerJournalCheckPostResults::createClient(postingResultsContainer);

            case 2 :
                [version, ledgerJournalId, voucherNum, post, transferErrors, detailSummaryPosting, showErrorOk] = packedClass;

                break;

            case 1 :
                [version, #CurrentList_V1] = packedClass;
                break;

            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInterCompanyJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates or updates intercompany journals, vouchers, and transactions for the given intercompany
    ///    ledger journal transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The ledger journal transaction for which to create or update intercompany journals, vouchers, and
    ///    transactions.
    /// </param>
    /// <param name="_exchRateForInterCompany">
    ///    The exchange rate that will be used to create intercompany transactions.
    /// </param>
    /// <param name="_exchRateSecondaryForInterCompany">
    ///    The secondary exchange rate that will be used to create intercompany transactions.
    /// </param>
    /// <param name="_euroTriangulationForInterCompany">
    ///    The euro triangulation value that will be used to create intercompany transactions.
    /// </param>
    /// <param name="_ledgerInterCompany">
    ///    The intercompany posting setup record for the given ledger journal transaction.
    /// </param>
    /// <param name="_currentCompany">
    ///    The company from which posting was initiated.
    /// </param>
    /// <param name="_retrieveExchangeRates">
    ///    true when exchange rates must be retrieved; otherwise, false.
    /// </param>
    /// <remarks>
    ///    This method assumes that the intercompany part of the ledger journal transaction is the primary
    ///    account.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    The intercompany posting setup is missing.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    The intercompany posting journal name is missing.
    /// </exception>
    [SysObsolete('Method updateInterCompanyJournal has been deprecated. Please use updateInterCompanyJournalV2 method instead.', false, 30\06\2018)]
    protected void updateInterCompanyJournal(
        LedgerJournalTrans _ledgerJournalTrans,
        ExchRate           _exchRateForInterCompany,
        ExchrateSecondary  _exchRateSecondaryForInterCompany,
        EUROTriangulation  _euroTriangulationForInterCompany,
        LedgerInterCompany _ledgerInterCompany,
        CompanyId          _currentCompany,
        boolean            _retrieveExchangeRates)
    {
        LedgerJournalTable                  newLedgerJournalTable;
        LedgerJournalTrans                  newLedgerJournalTrans;
        LedgerJournalTrans                  ledgerJournalTransOrig;
        // <GEERU>
        LedgerJournalTrans                  ledgerJournalTrans;
        // </GEERU>
        LedgerJournalTrans_Asset            newLedgerJournalTrans_Asset;
        LedgerJournalName                   newLedgerJournalName = LedgerJournalName::find(_ledgerInterCompany.JournalName);
        UnknownNoYes                        triangulation;
        RecId                               newRecId;
        Voucher                             newVoucher;
        ReasonRefRecID                      reasonRecId;
        RefRecId                            numberSequenceId;
        LedgerDimensionDefaultAccount       defaultAccount;
        List                                dimensionSources;
        TransDate                           exchangeRateDate;
        // <GCN>
        LedgerVoucherType_CN                ledgerVoucherType;
        Voucher_CN                          newVoucher_CN;
        boolean                             chineseVoucher = LedgerParameters::isChineseVoucher_CN();
        // </GCN>

        // <GEERU>
        #isoCountryRegionCodes

        boolean                             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        // <GEEU>
        CzCustAdvanceInvoiceLink            custAdvanceInvoiceLink;
        CzVendAdvanceInvoiceLink            vendAdvanceInvoiceLink;

        #EECountryRegionCodes
        // </GEEU>
        // <GIN>
        LedgerJournalTrans                  newLedgerJournalTransForWHT;
        LedgerJournalTransTaxExtensionIN    ledgerJournalTransExtension;
        LedgerJournalTransTaxExtensionIN    newLedgerJournalTransExtension;
        // </GIN>

        // <GJP>
        isIntercompanyMapNeeded = PaymFeeBankRuleUtil_JP::isIntercompanyMapEnabled();
        // </GJP>

        dimensionSources = new List(Types::Class);

        // <GCN>
        // Get a default voucher type for the intercompany transaction
        if (chineseVoucher)
        {
            ledgerVoucherType = LedgerVoucherType_CN::findDefault();
            if (!ledgerVoucherType)
            {
                // Intercompany posting with voucher type missing.
                throw error("@SYS4000071");
            }
        }
        // </GCN>

        if (! interCompanyCompanies.in(_ledgerJournalTrans.Company))
        {
            if (! newLedgerJournalName)
            {
                throw error(strFmt("@SYS25355", _ledgerInterCompany.JournalName, curext()));
            }
            newLedgerJournalTable.JournalName           = _ledgerInterCompany.JournalName;
            newLedgerJournalTable.Name                  = "@SYS3805";
            newLedgerJournalTable.initFromLedgerJournalName();
            newLedgerJournalTable.JournalNum            = JournalTableData::newTable(newLedgerJournalTable).nextJournalId();
            newLedgerJournalTable.OriginalCompany       = _currentCompany;
            newLedgerJournalTable.OriginalJournalNum    = _ledgerJournalTrans.JournalNum;
            newLedgerJournalTable.TaxObligationCompany  = ledgerJournalTable.TaxObligationCompany;
            newLedgerJournalTable.LedgerJournalInclTax  = ledgerJournalTable.LedgerJournalInclTax;
            newLedgerJournalTable.insert();

            interCompanyCompanies.add(_ledgerJournalTrans.Company);
            interCompanyJournalIds.insert(_ledgerJournalTrans.Company, newLedgerJournalTable.JournalNum);

            newLedgerJournalTable.FixedExchRate         = ledgerJournalTable.FixedExchRate;

            // If fixed exchange rate use the exchange rate and secondard exchange rate.
            if (newLedgerJournalTable.FixedExchRate)
            {
                newLedgerJournalTable.ExchRate          =  ledgerJournalTable.ExchRate;
                newLedgerJournalTable.ExchrateSecondary =  ledgerJournalTable.ExchrateSecondary;
            }
            //<GIN>
            //To post serice tax entries in to related voucher in case of intercompany transaction or CP Transactions....
            if (TaxParameters::isServiceTaxEnable_IN())
            {
                checkSTForInterCompany += newLedgerJournalTable.JournalNum;
                checkSTForInterCompany += _ledgerJournalTrans.Company;
                checkSTForInterCompany += LedgerJournalCheckPost_IN::isInterCompanyTransactionForST(_ledgerJournalTrans);
            }
            //</GIN>
        }
        else
        {
            newLedgerJournalTable = LedgerJournalTable::find(interCompanyJournalIds.lookup(_ledgerJournalTrans.Company));
        }

        if (!interCompanyVouchers.exists(_ledgerJournalTrans.Company))
        {
            numberSequenceId = newLedgerJournalName.NumberSequenceTable;
            newVoucher = NumberSeq::newGetVoucherFromId(numberSequenceId, false).voucher();

            // Add a new entry to the map for the indicated company ID and the new instance of JournalVoucherNum.
            interCompanyVouchers.insert(_ledgerJournalTrans.Company, newVoucher);

            // <GCN>
            if (chineseVoucher)
            {
                newVoucher_CN = NumberSeq_Voucher_CN::newGetVoucherFromCode(ledgerVoucherType.NumberSequenceTable, _ledgerJournalTrans.TransDate).voucher();
                interCompanyVouchers_CN.insert(_ledgerJournalTrans.Company, newVoucher_CN);
            }
            // </GCN>
        }
        else
        {
            if (newLedgerJournalTable.ledgerJournalName().NewVoucher == NewVoucher::OneVoucher)
            {
                newVoucher = interCompanyVouchers.lookup(_ledgerJournalTrans.Company);

                // <GCN>
                if (chineseVoucher)
                {
                    newVoucher_CN = interCompanyVouchers_CN.lookup(_ledgerJournalTrans.Company);
                }
                // </GCN>
            }
            else
            {
                numberSequenceId = newLedgerJournalName.NumberSequenceTable;
                newVoucher = NumberSeq::newGetVoucherFromId(numberSequenceId, false).voucher();
                // <GCN>
                if (chineseVoucher)
                {
                    newVoucher_CN = NumberSeq_Voucher_CN::newGetVoucherFromCode(ledgerVoucherType.NumberSequenceTable, _ledgerJournalTrans.TransDate).voucher();
                }
                // </GCN>
            }
        }

        Debug::assert(newVoucher != '');

        Debug::assert(newLedgerJournalTrans.DataAreaId == curext());
        newLedgerJournalTrans = _ledgerJournalTrans.data();
        // <GTH>
        newLedgerJournalTrans.SysExtensionSerializerMap::copyExtensionTableData(_ledgerJournalTrans);
        // </GTH>

        // Set the DataAreaId to be in the correct company.
        newLedgerJournalTrans.company(curext());

        newLedgerJournalTrans.OffsetLedgerDimension = 0;
        newLedgerJournalTrans.OffsetAccountType = _ledgerJournalTrans.OffsetAccountType ? _ledgerJournalTrans.OffsetAccountType : LedgerJournalACType::Ledger;
        newLedgerJournalTrans.OffsetDefaultDimension = 0;

        newLedgerJournalTrans.ForeignVoucher    = _ledgerJournalTrans.Voucher;
        newLedgerJournalTrans.ForeignCompany    = _currentCompany;
        newLedgerJournalTrans.JournalNum        = interCompanyJournalIds.lookup(_ledgerJournalTrans.Company);
        newLedgerJournalTrans.Voucher           = newVoucher;
        // <GCN>
        if (chineseVoucher)
        {
            newLedgerJournalTrans.LedgerVoucherType_CN  = ledgerVoucherType.RecId;
            newLedgerJournalTrans.Voucher_CN            = newVoucher_CN;
        }
        else
        {
            // reset to default value.
            newLedgerJournalTrans.LedgerVoucherType_CN  = 0;
            newLedgerJournalTrans.Voucher_CN            = '';
        }
        // </GCN>

        ledgerJournalTransOrig = LedgerJournalTrans::findByReverse(_ledgerJournalTrans.RecId);

        if (ledgerJournalTransOrig)
        {
            // There is an original ledger journal trans for the current ledger journal trans - set the exchange rate date to the original
            // <GEEU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll))
            {
                exchangeRateDate = ledgerJournalTransOrig.exchRateDate_W();
            }
            else
            {
                // </GEEU>
                exchangeRateDate = ledgerJournalTransOrig.TransDate;
                // <GEEU>
            }
            // </GEEU>
        }
        else
        {
            // There is not an original ledger journal trans - set the exchange rate date to the current ledger journal trans date
            // <GEEU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll))
            {
                exchangeRateDate = newLedgerJournalTrans.exchRateDate_W();
            }
            else
            {
                // </GEEU>
                exchangeRateDate = newLedgerJournalTrans.TransDate;
                // <GEEU>
            }
            // </GEEU>
        }

        if (_retrieveExchangeRates == true)
        {
            // If fixed exchange rate use the original triangulation value; otherwise get the triangulation value for the currency and date
            newLedgerJournalTrans.Triangulation = newLedgerJournalTable.FixedExchRate ? _euroTriangulationForInterCompany :
                Currency::triangulation(newLedgerJournalTrans.CurrencyCode, exchangeRateDate);

            triangulation = Currency::noYes2UnknownNoYes(newLedgerJournalTrans.Triangulation);

            Ledger sourceLedger = Ledger::findByLegalEntity(CompanyInfo::findDataArea(_currentCompany).RecId);

            // If fixed exchange rate, or the source and destination companies share the same accounting currency,
            // use the original exchange rate value; otherwise, get the exchange rate value for the currency and date
            if (newLedgerJournalTable.FixedExchRate || sourceLedger.AccountingCurrency == Ledger::accountingCurrency())
            {
                newLedgerJournalTrans.ExchRate = _exchRateForInterCompany;
                newLedgerJournalTrans.ExchRateSecond  = _exchRateSecondaryForInterCompany;
            }
            else
            {
                newLedgerJournalTrans.ExchRate = ExchangeRateHelper::exchRate(newLedgerJournalTrans.CurrencyCode, exchangeRateDate, triangulation);
                newLedgerJournalTrans.ExchRateSecond = ExchangeRateHelper::exchRateSecond(newLedgerJournalTrans.CurrencyCode, exchangeRateDate, triangulation);
            }
        }
        else
        {
            // This is the company account so used passed in exchange rate and triangulation
            newLedgerJournalTrans.Triangulation = _euroTriangulationForInterCompany;
            newLedgerJournalTrans.ExchRate = _exchRateForInterCompany;
            newLedgerJournalTrans.ExchRateSecond = _exchRateSecondaryForInterCompany;
        }

        newLedgerJournalTrans.Company           = curext();
        newLedgerJournalTrans.OffsetCompany     = _currentCompany;

        //create a copy of reason record in another company; remember it in local variable, to use it in another record we insert later
        reasonRecId = ReasonTableRef::checkCreateInCompany(_ledgerJournalTrans.ReasonRefRecID, newLedgerJournalTrans.DataAreaId);
        newLedgerJournalTrans.ReasonRefRecID = reasonRecId;

        // Update the settleVoucher field based on the auto settlement parameter, else transaction are already marked (SettlementType::SelectedTransact)
        this.populateSettleVoucher(newLedgerJournalTrans);

        newLedgerJournalTrans.LineNum = LedgerJournalTrans::lastLineNum(newLedgerJournalTrans.JournalNum) + 1;

        newLedgerJournalTrans.LedgerDimensionName = LedgerJournalTransLedgerDimensionNameHelper::findName(
            newLedgerJournalTrans.Company,
            newLedgerJournalTrans.AccountType,
            newLedgerJournalTrans.LedgerDimension);

        newLedgerJournalTrans.doInsert();
        taxVoucherService.updateLedgerJournalTransIntercompanyMap(_ledgerJournalTrans.RecId, newLedgerJournalTrans.RecId);
        // <GJP>
        LedgerJournalCheckPost_JP::updateLedgerJournalTransIntercompanyMap(isIntercompanyMapNeeded, ledgerJournalTransIntercompanyMap, _ledgerJournalTrans.RecId, newLedgerJournalTrans.RecId);
        // </GJP>

        if (ledgerJournalTransOrig)
        {
            LedgerJournalCheckPost::updateReversedRecord(_ledgerJournalTrans.RecId, newLedgerJournalTrans.RecId);
        }

        // If the AccountType == Cust/Vend and SettleVoucher == SelectedTransact, there are settlements set up for the transaction.
        // Update the SpecTrans records' SpecCompany, SpecRecId for the new customer/vendor journal transaction.
        if (this.shouldUpdateSpecTrans(newLedgerJournalTrans))
        {
            SpecTrans updateSpecTrans;
            // SpecTrans records exist and point to the _ledgerJournalTrans passed in. Update SpecTrans records to reference
            // the newLedgerJournalTrans for the Spec reference so they will be settled when this new journal is posted.
            update_recordset updateSpecTrans
                setting SpecCompany = newLedgerJournalTrans.DataAreaId,
                    SpecRecId = newLedgerJournalTrans.RecId
                where updateSpecTrans.SpecCompany == _ledgerJournalTrans.DataAreaId &&
                    updateSpecTrans.SpecTableId == tableNum(LedgerJournalTrans) &&
                    updateSpecTrans.SpecRecId == _ledgerJournalTrans.RecId;
        }

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            ledgerJournalTransExtension = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
            TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(newLedgerJournalTrans);
            newLedgerJournalTransForWHT = newLedgerJournalTrans.data();
            newLedgerJournalTransExtension.clear();
            newLedgerJournalTransExtension.LedgerJournalTrans  = newLedgerJournalTrans.RecId;
            newLedgerJournalTransExtension.TDSGroup = ledgerJournalTransExtension.TDSGroup;
            newLedgerJournalTransExtension.TCSGroup = ledgerJournalTransExtension.TCSGroup;
            newLedgerJournalTransExtension.insert(false, false);
        }
        // </GIN>

        // <GEEU>
        if (isConfigurationkeyEnabled(configurationKeyNum(CzCustVendAdvanceInvoices)))
        {
            if (newLedgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                update_recordset custAdvanceInvoiceLink
                    setting PaymentCompany = newLedgerJournalTrans.Company,
                            Voucher        = newLedgerJournalTrans.Voucher,
                            TransDate      = newLedgerJournalTrans.TransDate
                    where custAdvanceInvoiceLink.PaymentCompany == _ledgerJournalTrans.DataAreaId &&
                          custAdvanceInvoiceLink.Voucher        == _ledgerJournalTrans.Voucher &&
                          custAdvanceInvoiceLink.TransDate      == _ledgerJournalTrans.TransDate;
            }
            else if (newLedgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                update_recordset vendAdvanceInvoiceLink
                    setting PaymentCompany = newLedgerJournalTrans.Company,
                            Voucher        = newLedgerJournalTrans.Voucher,
                            TransDate      = newLedgerJournalTrans.TransDate
                    where vendAdvanceInvoiceLink.PaymentCompany == _ledgerJournalTrans.DataAreaId &&
                          vendAdvanceInvoiceLink.Voucher        == _ledgerJournalTrans.Voucher &&
                          vendAdvanceInvoiceLink.TransDate      == _ledgerJournalTrans.TransDate;
            }
        }
        // </GEEU>

        if (newLedgerJournalTrans.isFixedAssetsTransaction())
        {
            // This is a fixed assets transaction, so we need to perform a find on the original
            // LedgerJournalTrans record to initialize the LedgerJournalTrans_Asset buffer.
            newLedgerJournalTrans_Asset = _ledgerJournalTrans.findLedgerJournalTransAssetSibling().data();

            // Set the DataAreaId to be in the correct company as the original LedgerJournalTrans_Asset selected above existed in
            // the non-intercompany company.
            newLedgerJournalTrans_Asset.company(newLedgerJournalTrans.DataAreaId);

            // Link the new LedgerJournalTrans and LedgerJournalTrans_Asset records
            // and insert the record.
            newLedgerJournalTrans_Asset.RefRecId = newLedgerJournalTrans.RecId;

            newLedgerJournalTrans_Asset.doInsert();
        }

        // save the recId for the new ledger that the taxes will be calculated for
        newRecId = newLedgerJournalTrans.RecId;

        //Original amount Debit => this amount Credit
        newLedgerJournalTrans.AmountCurDebit    = _ledgerJournalTrans.AmountCurCredit;
        newLedgerJournalTrans.AmountCurCredit   = _ledgerJournalTrans.AmountCurDebit;
        newLedgerJournalTrans.AccountType       = LedgerJournalACType::Ledger;

        // Merge the default ledger dimension and default dimension value to create a ledger dimension
        defaultAccount = _ledgerJournalTrans.AmountCurDebit ? _ledgerInterCompany.DestinationCreditLedgerDimension : _ledgerInterCompany.DestinationDebitLedgerDimension;

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
        {
            dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getLedgerDimensionSpecifiers(_ledgerJournalTrans.LedgerDimension));
        }
        else
        {
            dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(_ledgerJournalTrans.DefaultDimension));
        }

        newLedgerJournalTrans.LedgerDimension = LedgerDimensionDefaultingEngine::createLedgerDimension(defaultAccount, dimensionSources);

        newLedgerJournalTrans.TaxGroup          = '';
        newLedgerJournalTrans.TaxItemGroup      = '';
        // <GIN>
        // Check For Inter Company Trans When Service Tax is Marked .........
        if (TaxParameters::isServiceTaxEnable_IN()
            && _ledgerJournalTrans.isServiceTax_IN()
            && _ledgerJournalTrans.OffsetCompany)
        {
            newLedgerJournalTrans.TaxGroup      = _ledgerJournalTrans.TaxGroup;
            newLedgerJournalTrans.TaxItemGroup  = _ledgerJournalTrans.TaxItemGroup;
        }
        // </GIN>
        newLedgerJournalTrans.TaxCode           = '';
        newLedgerJournalTrans.ReasonRefRecID    = reasonRecId;
        newLedgerJournalTrans.DefaultDimension  = 0;
        newLedgerJournalTrans.Company           = curext();
        newLedgerJournalTrans.OffsetCompany     = _currentCompany;

        newLedgerJournalTrans.LineNum = LedgerJournalTrans::lastLineNum(newLedgerJournalTrans.JournalNum) + 1;
        newLedgerJournalTrans.doInsert();
        taxVoucherService.updateLedgerJournalTransIntercompanyMap(_ledgerJournalTrans.RecId, newLedgerJournalTrans.RecId);
        // <GJP>
        LedgerJournalCheckPost_JP::updateLedgerJournalTransIntercompanyMap(isIntercompanyMapNeeded, ledgerJournalTransIntercompanyMap, _ledgerJournalTrans.RecId, newLedgerJournalTrans.RecId);
        // </GJP>
        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(newLedgerJournalTrans);
            newLedgerJournalTransExtension = newLedgerJournalTrans.ledgerJournalTransTaxExtensionIN();
            newLedgerJournalTransExtension.clear();
            newLedgerJournalTransExtension.LedgerJournalTrans  = newLedgerJournalTrans.RecId;
            newLedgerJournalTransExtension.insert(false);
            if (newLedgerJournalTransForWHT)
            {
                TaxWithholdUncommitted_IN::updateAdjustmentForCP(_ledgerJournalTrans, newLedgerJournalTransForWHT);
            }
        }
        // </GIN>

        if (ledgerJournalTransOrig)
        {
            LedgerJournalCheckPost::updateReversedRecord(_ledgerJournalTrans.RecId, newLedgerJournalTrans.RecId);
        }

        intercompanyRecIds += newLedgerJournalTrans.RecId;

        if (newLedgerJournalTrans.isFixedAssetsTransaction())
        {
            // Link the new LedgerJournalTrans and LedgerJournalTrans_Asset records
            // and insert the record.
            newLedgerJournalTrans_Asset.RefRecId = newLedgerJournalTrans.RecId;

            newLedgerJournalTrans_Asset.doInsert();
        }

        _ledgerJournalTrans.ForeignVoucher      = newVoucher;
        _ledgerJournalTrans.ForeignCompany      = _ledgerJournalTrans.Company;

        // <GEERU>
        if (countryRegion_RU)
        {
            changecompany(_ledgerJournalTrans.company())
            {
                ledgerJournalTrans = LedgerJournalTrans::findRecId(_ledgerJournalTrans.RecId, true);
                ledgerJournalTrans.ForeignVoucher = newVoucher;
                ledgerJournalTrans.ForeignCompany = _ledgerJournalTrans.Company;
                ledgerJournalTrans.doUpdate();
            }
        }
        // </GEERU>
        //Need tax work record for the new journal if one existed for the initial journal
        TaxWorkRegulation::saveTaxWorkRegulationList(taxWorkRegulationList, newLedgerJournalTrans.TableId, newRecId);

        // <GIN>
        //Need Update work record for the new journal if one existed for the initial journal
        if (TaxWithholdParameters_IN::checkTaxParameters()
            && TaxWithholdParameters_IN::findByCompany(_ledgerJournalTrans.OffsetCompany).CrossCompanyPayment)
        {
            TaxWithholdWorkRegulation_IN::updateSourceRecId(_ledgerJournalTrans.RecId, newRecId, _ledgerJournalTrans.OffsetCompany);
        }
        // </GIN>

        // reset the list so a second posting can't inadvertantly access the previous adjustments by mistake
        taxWorkRegulationList = new RecordSortedList(tableNum (TaxWorkRegulation));
        taxWorkRegulationList.sortOrder(fieldNum(TaxWorkRegulation, RecId));

        // Add the mapping for journal line company's voucher and its related intercompany voucher
        LedgerJournalCheckPostBudget::addBudgetCheckVoucherForInterCompany(this, curext(), newLedgerJournalTable.JournalNum, newVoucher, _ledgerJournalTrans.Voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateSettleVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Populates settle voucher field of <c>LedgerJournalTrans</c> table.
    /// </summary>
    /// <param name = "_newLedgerJournalTrans">
    ///     A <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    protected void populateSettleVoucher(LedgerJournalTrans _newLedgerJournalTrans)
    {
        if (_newLedgerJournalTrans.SettleVoucher == SettlementType::None || _newLedgerJournalTrans.SettleVoucher == SettlementType::OpenTransact)
        {
            if (_newLedgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                _newLedgerJournalTrans.SettleVoucher = CustParameters::find().AutoSettle ? SettlementType::OpenTransact : SettlementType::None;
            }
            if (_newLedgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                _newLedgerJournalTrans.SettleVoucher = VendParameters::find().AutoSettle ? SettlementType::OpenTransact : SettlementType::None;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateSpecTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether to update spec trans records for the new customer/vendor journal transaction.
    /// </summary>
    /// <param name = "_newLedgerJournalTrans">
    ///     The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    ///     true if spec trans records need to be updated for the new customer/vendor journal transaction; otherwise, false.
    /// </returns>
    protected boolean shouldUpdateSpecTrans(LedgerJournalTrans _newLedgerJournalTrans)
    {
        return ((_newLedgerJournalTrans.AccountType == LedgerJournalACType::Cust || _newLedgerJournalTrans.AccountType == LedgerJournalACType::Vend) &&
            (_newLedgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact));
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUseProvidedExchangeRates</Name>
				<Source><![CDATA[
    private boolean shouldUseProvidedExchangeRates(LedgerJournalTrans _ledgerJournalTrans, CompanyId _currentCompany)
    {
        // The allocation journal contains only one side journal entries
        // (i.e. there is no offset account specified), it is assumed that the exchange rates specified
        // on the journal line is used for current company MST and the account company MST.
        // An approval journal must use the same exchange rates that were used on the invoice register
        // If the account company and the originating company are the same, use the exchange rate provided on the journal line
        // as there is no additional currency translation needed

        return (ledgerJournalTable.JournalType == LedgerJournalType::Allocation ||
            ledgerJournalTable.JournalType == LedgerJournalType::Approval ||
            _ledgerJournalTrans.Company == _currentCompany);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInterCompanyJournalV2</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates or updates intercompany journals, vouchers, and transactions for the given intercompany
    ///    ledger journal transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The ledger journal transaction for which to create or update intercompany journals, vouchers, and
    ///    transactions.
    /// </param>
    /// <param name="_exchRateForInterCompany">
    ///    The exchange rate that will be used to create intercompany transactions.
    /// </param>
    /// <param name="_exchRateSecondaryForInterCompany">
    ///    The secondary exchange rate that will be used to create intercompany transactions.
    /// </param>
    /// <param name="_euroTriangulationForInterCompany">
    ///    The euro triangulation value that will be used to create intercompany transactions.
    /// </param>
    /// <param name="_reportingCurrencyExchRateForInterCompany">
    ///    The reporting currency exchange rate that will be used to create intercompany transactions.
    /// </param>
    /// <param name="_reportingCurrencyExchRateSecondaryForInterCompany">
    ///    The reporting currency secondary exchange rate that will be used to create intercompany transactions.
    /// </param>
    /// <param name="_ledgerInterCompany">
    ///    The intercompany posting setup record for the given ledger journal transaction.
    /// </param>
    /// <param name="_currentCompany">
    ///    The company from which posting was initiated.
    /// </param>
    /// <param name="_retrieveExchangeRates">
    ///    true when exchange rates must be retrieved; otherwise, false.
    /// </param>
    /// <remarks>
    ///    This method assumes that the intercompany part of the ledger journal transaction is the primary
    ///    account.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    The intercompany posting setup is missing.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    The intercompany posting journal name is missing.
    /// </exception>
    protected void updateInterCompanyJournalV2(
        LedgerJournalTrans _ledgerJournalTrans,
        ExchRate           _exchRateForInterCompany,
        ExchrateSecondary  _exchRateSecondaryForInterCompany,
        EUROTriangulation  _euroTriangulationForInterCompany,
        ReportingCurrencyExchRate _reportingCurrencyExchRateForInterCompany,
        ReportingCurrencyExchRateSecondary _reportingCurrencyExchRateSecondaryForInterCompany,
        LedgerInterCompany _ledgerInterCompany,
        CompanyId          _currentCompany,
        boolean            _retrieveExchangeRates)
    {
        LedgerJournalTable                  newLedgerJournalTable;
        LedgerJournalTrans                  newLedgerJournalTrans;
        LedgerJournalTrans                  ledgerJournalTransOrig;
        // <GEERU>
        LedgerJournalTrans                  ledgerJournalTrans;
        // </GEERU>
        LedgerJournalTrans_Asset            newLedgerJournalTrans_Asset;
        LedgerJournalName                   newLedgerJournalName = LedgerJournalName::find(_ledgerInterCompany.JournalName);
        UnknownNoYes                        triangulation;
        RecId                               newRecId;
        Voucher                             newVoucher;
        ReasonRefRecID                      reasonRecId;
        RefRecId                            numberSequenceId;
        TransDate                           exchangeRateDate;
        // <GCN>
        LedgerVoucherType_CN                ledgerVoucherType;
        Voucher_CN                          newVoucher_CN;
        boolean                             chineseVoucher = LedgerParameters::isChineseVoucher_CN();
        // </GCN>

        // <GEERU>
        #isoCountryRegionCodes

        boolean                             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        // <GEEU>
        CzCustAdvanceInvoiceLink            custAdvanceInvoiceLink;
        CzVendAdvanceInvoiceLink            vendAdvanceInvoiceLink;

        #EECountryRegionCodes
        // </GEEU>
        // <GIN>
        LedgerJournalTrans                  newLedgerJournalTransForWHT;
        LedgerJournalTransTaxExtensionIN    ledgerJournalTransExtension;
        LedgerJournalTransTaxExtensionIN    newLedgerJournalTransExtension;
        // </GIN>

        // <GJP>
        isIntercompanyMapNeeded = PaymFeeBankRuleUtil_JP::isIntercompanyMapEnabled();
        // </GJP>
        isPaymentRequestEnable = CFMParameters::isPaymentRequestsEnabled();
        // <GCN>
        // Get a default voucher type for the intercompany transaction
        if (chineseVoucher)
        {
            ledgerVoucherType = LedgerVoucherType_CN::findDefault();
            if (!ledgerVoucherType)
            {
                // Intercompany posting with voucher type missing.
                throw error("@SYS4000071");
            }
        }
        // </GCN>

        if (! interCompanyCompanies.in(_ledgerJournalTrans.Company))
        {
            if (! newLedgerJournalName)
            {
                throw error(strFmt("@SYS25355", _ledgerInterCompany.JournalName, curext()));
            }

            newLedgerJournalTable = this.insertLedgerJournalTable(_ledgerJournalTrans, newLedgerJournalTable, ledgerJournalTable, _ledgerInterCompany, _currentCompany);

            if (!newLedgerJournalTable.RecId)
            {
                throw Error("@GeneralLedger:InterCompanyJournalheaderDoesNotExist");
            }

            interCompanyCompanies.add(_ledgerJournalTrans.Company);
            interCompanyJournalIds.insert(_ledgerJournalTrans.Company, newLedgerJournalTable.JournalNum);

            newLedgerJournalTable.FixedExchRate         = ledgerJournalTable.FixedExchRate;

            // If fixed exchange rate use the exchange rate and secondard exchange rate.
            if (newLedgerJournalTable.FixedExchRate)
            {
                newLedgerJournalTable.ExchRate          =  ledgerJournalTable.ExchRate;
                newLedgerJournalTable.ExchrateSecondary =  ledgerJournalTable.ExchrateSecondary;
                newLedgerJournalTable.ReportingCurrencyExchRate = ledgerJournalTable.ReportingCurrencyExchRate;
                newLedgerJournalTable.ReportingCurrencyExchRateSecondary = ledgerJournalTable.ReportingCurrencyExchRateSecondary;
            }
            //<GIN>
            //To post serice tax entries in to related voucher in case of intercompany transaction or CP Transactions....
            if (TaxParameters::isServiceTaxEnable_IN())
            {
                checkSTForInterCompany += newLedgerJournalTable.JournalNum;
                checkSTForInterCompany += _ledgerJournalTrans.Company;
                checkSTForInterCompany += LedgerJournalCheckPost_IN::isInterCompanyTransactionForST(_ledgerJournalTrans);
            }
            //</GIN>
        }
        else
        {
            newLedgerJournalTable = LedgerJournalTable::find(interCompanyJournalIds.lookup(_ledgerJournalTrans.Company));
        }

        if (!interCompanyVouchers.exists(_ledgerJournalTrans.Company))
        {
            numberSequenceId = newLedgerJournalName.NumberSequenceTable;
            newVoucher = NumberSeq::newGetVoucherFromId(numberSequenceId, false).voucher();

            // Add a new entry to the map for the indicated company ID and the new instance of JournalVoucherNum.
            interCompanyVouchers.insert(_ledgerJournalTrans.Company, newVoucher);

            // <GCN>
            if (chineseVoucher)
            {
                newVoucher_CN = NumberSeq_Voucher_CN::newGetVoucherFromCode(ledgerVoucherType.NumberSequenceTable, _ledgerJournalTrans.TransDate).voucher();
                interCompanyVouchers_CN.insert(_ledgerJournalTrans.Company, newVoucher_CN);
            }
            // </GCN>
        }
        else
        {
            if (newLedgerJournalTable.ledgerJournalName().NewVoucher == NewVoucher::OneVoucher)
            {
                newVoucher = interCompanyVouchers.lookup(_ledgerJournalTrans.Company);

                // <GCN>
                if (chineseVoucher)
                {
                    newVoucher_CN = interCompanyVouchers_CN.lookup(_ledgerJournalTrans.Company);
                }
                // </GCN>
            }
            else
            {
                numberSequenceId = newLedgerJournalName.NumberSequenceTable;
                newVoucher = NumberSeq::newGetVoucherFromId(numberSequenceId, false).voucher();
                // <GCN>
                if (chineseVoucher)
                {
                    newVoucher_CN = NumberSeq_Voucher_CN::newGetVoucherFromCode(ledgerVoucherType.NumberSequenceTable, _ledgerJournalTrans.TransDate).voucher();
                }
                // </GCN>
            }
        }

        Debug::assert(newVoucher != '');

        Debug::assert(newLedgerJournalTrans.DataAreaId == curext());
        newLedgerJournalTrans = _ledgerJournalTrans.data();
        // <GTH>
        newLedgerJournalTrans.SysExtensionSerializerMap::copyExtensionTableData(_ledgerJournalTrans);
        // </GTH>

        // Set the DataAreaId to be in the correct company.
        newLedgerJournalTrans.company(curext());

        newLedgerJournalTrans.OffsetLedgerDimension = 0;
        newLedgerJournalTrans.OffsetAccountType = _ledgerJournalTrans.OffsetAccountType ? _ledgerJournalTrans.OffsetAccountType : LedgerJournalACType::Ledger;
        newLedgerJournalTrans.OffsetDefaultDimension = 0;

        newLedgerJournalTrans.ForeignVoucher    = _ledgerJournalTrans.Voucher;
        newLedgerJournalTrans.ForeignCompany    = _currentCompany;
        newLedgerJournalTrans.JournalNum        = interCompanyJournalIds.lookup(_ledgerJournalTrans.Company);
        newLedgerJournalTrans.Voucher           = newVoucher;
        // <GCN>
        if (chineseVoucher)
        {
            newLedgerJournalTrans.LedgerVoucherType_CN  = ledgerVoucherType.RecId;
            newLedgerJournalTrans.Voucher_CN            = newVoucher_CN;
        }
        else
        {
            // reset to default value.
            newLedgerJournalTrans.LedgerVoucherType_CN  = 0;
            newLedgerJournalTrans.Voucher_CN            = '';
        }
        // </GCN>

        ledgerJournalTransOrig = LedgerJournalTrans::findByReverse(_ledgerJournalTrans.RecId);

        if (ledgerJournalTransOrig)
        {
            // There is an original ledger journal trans for the current ledger journal trans - set the exchange rate date to the original
            // <GEEU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll))
            {
                exchangeRateDate = ledgerJournalTransOrig.exchRateDate_W();
            }
            else
            {
                // </GEEU>
                exchangeRateDate = ledgerJournalTransOrig.TransDate;
                // <GEEU>
            }
            // </GEEU>
        }
        else
        {
            // There is not an original ledger journal trans - set the exchange rate date to the current ledger journal trans date
            // <GEEU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll))
            {
                exchangeRateDate = newLedgerJournalTrans.exchRateDate_W();
            }
            else
            {
                // </GEEU>
                exchangeRateDate = newLedgerJournalTrans.TransDate;
                // <GEEU>
            }
            // </GEEU>
        }

        if (_retrieveExchangeRates)
        {
            // If fixed exchange rate use the original triangulation value; otherwise get the triangulation value for the currency and date
            newLedgerJournalTrans.Triangulation = newLedgerJournalTable.FixedExchRate ? _euroTriangulationForInterCompany :
                Currency::triangulation(newLedgerJournalTrans.CurrencyCode, exchangeRateDate);

            triangulation = Currency::noYes2UnknownNoYes(newLedgerJournalTrans.Triangulation);

            Ledger sourceLedger = Ledger::findByLegalEntity(CompanyInfo::findDataArea(_currentCompany).RecId);
            CurrencyCode currentAccountingCurrency = Ledger::accountingCurrency();

            // If fixed exchange rate, or spot rate is defined on journal and the matching currency pair is found
            // use the spot rate value; otherwise, get the exchange rate value for the currency and date
            // Example of "currency pair" and "how to compare":
            // For source company, say Transaction currency is AUD, Accounting currency is EUR, and Reporting currency is USD
            // Exchange rates are defined on the journal for both Accounting and Reporting currencies
            // Then we have following spot rates for currency pairs: spot rate for "AUD-EUR" & spot rate for "AUD-USD"
            // For destination company, both Accounting and Reporting currencies are USD
            // Since we have spot rate for "AUD-USD", on destination company journal, AUD-USD spot rate will be used for both Accounting and Reporting currencies
            if (newLedgerJournalTable.FixedExchRate || sourceLedger.AccountingCurrency == currentAccountingCurrency)
            {
                newLedgerJournalTrans.ExchRate = _exchRateForInterCompany;
                newLedgerJournalTrans.ExchRateSecond  = _exchRateSecondaryForInterCompany;
            }
            else if (sourceLedger.ReportingCurrency == currentAccountingCurrency)
            {
                newLedgerJournalTrans.ExchRate = _reportingCurrencyExchRateForInterCompany;
                newLedgerJournalTrans.ExchRateSecond  = _reportingCurrencyExchRateSecondaryForInterCompany;
            }
            else
            {
                newLedgerJournalTrans.ExchRate = ExchangeRateHelper::exchRate(newLedgerJournalTrans.CurrencyCode, exchangeRateDate, triangulation);
                newLedgerJournalTrans.ExchRateSecond = ExchangeRateHelper::exchRateSecond(newLedgerJournalTrans.CurrencyCode, exchangeRateDate, triangulation);
            }

            CurrencyCode currentReportingCurrency = Ledger::reportingCurrency();

            if (currentReportingCurrency)
            {
                // If fixed reporting exchange rate, or spot rate is defined and the matching currency pair is found
                // use the spot rate value; otherwise, get the reporting exchange rate value for the currency and date
                // Please see example of "how to compare" above for Accounting currency
                if (newLedgerJournalTable.ReportingCurrencyFixedExchRate || sourceLedger.ReportingCurrency == currentReportingCurrency)
                {
                    newLedgerJournalTrans.ReportingCurrencyExchRate = _reportingCurrencyExchRateForInterCompany;
                    newLedgerJournalTrans.ReportingCurrencyExchRateSecondary = _reportingCurrencyExchRateSecondaryForInterCompany;
                }
                else if (sourceLedger.AccountingCurrency == currentReportingCurrency)
                {
                    newLedgerJournalTrans.ReportingCurrencyExchRate = _exchRateForInterCompany;
                    newLedgerJournalTrans.ReportingCurrencyExchRateSecondary = _exchRateSecondaryForInterCompany;
                }
                else
                {
                    ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newExchangeDate(Ledger::current(), newLedgerJournalTrans.CurrencyCode, exchangeRateDate);
                    exchangeRateHelper.parmToCurrency(currentReportingCurrency);
                    exchangeRateHelper.parmExchangeRateTypeRecId(Ledger::reportingCurrencyExchangeRateType());
                    newLedgerJournalTrans.ReportingCurrencyExchRate = exchangeRateHelper.getExchangeRate1();
                    newLedgerJournalTrans.ReportingCurrencyExchRateSecondary = exchangeRateHelper.getExchangeRate2();
                }
            }
        }
        else
        {
            // This is the company account so used passed in exchange rate and triangulation
            newLedgerJournalTrans.Triangulation = _euroTriangulationForInterCompany;
            newLedgerJournalTrans.ExchRate = _exchRateForInterCompany;
            newLedgerJournalTrans.ExchRateSecond = _exchRateSecondaryForInterCompany;
            newLedgerJournalTrans.ReportingCurrencyExchRate = _reportingCurrencyExchRateForInterCompany;
            newLedgerJournalTrans.ReportingCurrencyExchRateSecondary = _reportingCurrencyExchRateSecondaryForInterCompany;
        }

        newLedgerJournalTrans.Company           = curext();
        newLedgerJournalTrans.OffsetCompany     = _currentCompany;

        //create a copy of reason record in another company; remember it in local variable, to use it in another record we insert later
        reasonRecId = ReasonTableRef::checkCreateInCompany(_ledgerJournalTrans.ReasonRefRecID, newLedgerJournalTrans.DataAreaId);
        newLedgerJournalTrans.ReasonRefRecID = reasonRecId;

        // Update the settleVoucher field based on the auto settlement parameter, else transaction are already marked (SettlementType::SelectedTransact)
        this.populateSettleVoucher(newLedgerJournalTrans);

        newLedgerJournalTrans.LineNum = LedgerJournalTrans::lastLineNum(newLedgerJournalTrans.JournalNum) + 1;

        newLedgerJournalTrans.LedgerDimensionName = LedgerJournalTransLedgerDimensionNameHelper::findName(
            newLedgerJournalTrans.Company,
            newLedgerJournalTrans.AccountType,
            newLedgerJournalTrans.LedgerDimension);

        newLedgerJournalTrans.doInsert();
        taxVoucherService.updateLedgerJournalTransIntercompanyMap(_ledgerJournalTrans.RecId, newLedgerJournalTrans.RecId);
        // <GJP>
        LedgerJournalCheckPost_JP::updateLedgerJournalTransIntercompanyMap(isIntercompanyMapNeeded, ledgerJournalTransIntercompanyMap, _ledgerJournalTrans.RecId, newLedgerJournalTrans.RecId);
        // </GJP>
        if (CFMParameters::isPaymentRequestsEnabled())
        {
            isIntercompanyMapNeeded = isPaymentRequestEnable && (ledgerJournalTable.JournalType == LedgerJournalType::CustPayment || ledgerJournalTable.JournalType == LedgerJournalType::Payment);
        }

        if (ledgerJournalTransOrig)
        {
            LedgerJournalCheckPost::updateReversedRecord(_ledgerJournalTrans.RecId, newLedgerJournalTrans.RecId);
        }

        // If the AccountType == Cust/Vend and SettleVoucher == SelectedTransact, there are settlements set up for the transaction.
        // Update the SpecTrans records' SpecCompany, SpecRecId for the new customer/vendor journal transaction.
        if (this.shouldUpdateSpecTrans(newLedgerJournalTrans))
        {
            SpecTrans updateSpecTrans;
            // SpecTrans records exist and point to the _ledgerJournalTrans passed in. Update SpecTrans records to reference
            // the newLedgerJournalTrans for the Spec reference so they will be settled when this new journal is posted.
            update_recordset updateSpecTrans
                setting SpecCompany = newLedgerJournalTrans.DataAreaId,
                    SpecRecId = newLedgerJournalTrans.RecId
                where updateSpecTrans.SpecCompany == _ledgerJournalTrans.DataAreaId &&
                    updateSpecTrans.SpecTableId == tableNum(LedgerJournalTrans) &&
                    updateSpecTrans.SpecRecId == _ledgerJournalTrans.RecId;
        }

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            ledgerJournalTransExtension = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
            TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(newLedgerJournalTrans);
            newLedgerJournalTransForWHT = newLedgerJournalTrans.data();
            newLedgerJournalTransExtension.clear();
            newLedgerJournalTransExtension.LedgerJournalTrans  = newLedgerJournalTrans.RecId;
            newLedgerJournalTransExtension.TDSGroup = ledgerJournalTransExtension.TDSGroup;
            newLedgerJournalTransExtension.TCSGroup = ledgerJournalTransExtension.TCSGroup;
            newLedgerJournalTransExtension.insert(false, false);
        }
        // </GIN>

        if (TaxIntegrationUtils::isTaxIntegrationEnabledForJournalType(ledgerJournalTable.JournalType))
        {
            LedgerJournalTransTaxExtension::copyLedgerJournalTransTaxExtension(_ledgerJournalTrans, newLedgerJournalTrans, false);
        }

        // <GEEU>
        if (isConfigurationkeyEnabled(configurationKeyNum(CzCustVendAdvanceInvoices)))
        {
            if (newLedgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                update_recordset custAdvanceInvoiceLink
                    setting PaymentCompany = newLedgerJournalTrans.Company,
                            Voucher        = newLedgerJournalTrans.Voucher,
                            TransDate      = newLedgerJournalTrans.TransDate
                    where custAdvanceInvoiceLink.PaymentCompany == _ledgerJournalTrans.DataAreaId &&
                          custAdvanceInvoiceLink.Voucher        == _ledgerJournalTrans.Voucher &&
                          custAdvanceInvoiceLink.TransDate      == _ledgerJournalTrans.TransDate;
            }
            else if (newLedgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                update_recordset vendAdvanceInvoiceLink
                    setting PaymentCompany = newLedgerJournalTrans.Company,
                            Voucher        = newLedgerJournalTrans.Voucher,
                            TransDate      = newLedgerJournalTrans.TransDate
                    where vendAdvanceInvoiceLink.PaymentCompany == _ledgerJournalTrans.DataAreaId &&
                          vendAdvanceInvoiceLink.Voucher        == _ledgerJournalTrans.Voucher &&
                          vendAdvanceInvoiceLink.TransDate      == _ledgerJournalTrans.TransDate;
            }
        }
        // </GEEU>

        if (newLedgerJournalTrans.isFixedAssetsTransaction())
        {
            // This is a fixed assets transaction, so we need to perform a find on the original
            // LedgerJournalTrans record to initialize the LedgerJournalTrans_Asset buffer.
            newLedgerJournalTrans_Asset = _ledgerJournalTrans.findLedgerJournalTransAssetSibling().data();

            // Set the DataAreaId to be in the correct company as the original LedgerJournalTrans_Asset selected above existed in
            // the non-intercompany company.
            newLedgerJournalTrans_Asset.company(newLedgerJournalTrans.DataAreaId);

            // Link the new LedgerJournalTrans and LedgerJournalTrans_Asset records
            // and insert the record.
            newLedgerJournalTrans_Asset.RefRecId = newLedgerJournalTrans.RecId;

            newLedgerJournalTrans_Asset.doInsert();
        }

        // save the recId for the new ledger that the taxes will be calculated for
        newRecId = newLedgerJournalTrans.RecId;

        newLedgerJournalTrans = this.populateInterCompanyOffsetJournalLine(
            _ledgerJournalTrans,
            newLedgerJournalTrans,
            _ledgerInterCompany,
            _currentCompany,
            reasonRecId);

        newLedgerJournalTrans.doInsert();
        taxVoucherService.updateLedgerJournalTransIntercompanyMap(_ledgerJournalTrans.RecId, newLedgerJournalTrans.RecId);
        // <GJP>
        LedgerJournalCheckPost_JP::updateLedgerJournalTransIntercompanyMap(isIntercompanyMapNeeded, ledgerJournalTransIntercompanyMap, _ledgerJournalTrans.RecId, newLedgerJournalTrans.RecId);
        // </GJP>
        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(newLedgerJournalTrans);
            newLedgerJournalTransExtension = newLedgerJournalTrans.ledgerJournalTransTaxExtensionIN();
            newLedgerJournalTransExtension.clear();
            newLedgerJournalTransExtension.LedgerJournalTrans  = newLedgerJournalTrans.RecId;
            newLedgerJournalTransExtension.insert(false);
            if (newLedgerJournalTransForWHT)
            {
                TaxWithholdUncommitted_IN::updateAdjustmentForCP(_ledgerJournalTrans, newLedgerJournalTransForWHT);
            }
        }
        // </GIN>

        if (TaxIntegrationUtils::isTaxIntegrationEnabledForJournalType(ledgerJournalTable.JournalType))
        {
            LedgerJournalTransTaxExtension::copyLedgerJournalTransTaxExtension(_ledgerJournalTrans, newLedgerJournalTrans, false);
        }

        if (ledgerJournalTransOrig)
        {
            LedgerJournalCheckPost::updateReversedRecord(_ledgerJournalTrans.RecId, newLedgerJournalTrans.RecId);
        }

        intercompanyRecIds += newLedgerJournalTrans.RecId;

        if (newLedgerJournalTrans.isFixedAssetsTransaction())
        {
            // Link the new LedgerJournalTrans and LedgerJournalTrans_Asset records
            // and insert the record.
            newLedgerJournalTrans_Asset.RefRecId = newLedgerJournalTrans.RecId;

            newLedgerJournalTrans_Asset.doInsert();
        }

        _ledgerJournalTrans.ForeignVoucher      = newVoucher;
        _ledgerJournalTrans.ForeignCompany      = _ledgerJournalTrans.Company;

        // <GEERU>
        if (countryRegion_RU)
        {
            changecompany(_ledgerJournalTrans.company())
            {
                ledgerJournalTrans = LedgerJournalTrans::findRecId(_ledgerJournalTrans.RecId, true);
                ledgerJournalTrans.ForeignVoucher = newVoucher;
                ledgerJournalTrans.ForeignCompany = _ledgerJournalTrans.Company;
                ledgerJournalTrans.doUpdate();
            }
        }
        // </GEERU>
        //Need tax work record for the new journal if one existed for the initial journal
        TaxWorkRegulation::saveTaxWorkRegulationList(taxWorkRegulationList, newLedgerJournalTrans.TableId, newRecId);

        // <GIN>
        //Need Update work record for the new journal if one existed for the initial journal
        if (TaxWithholdParameters_IN::checkTaxParameters()
            && TaxWithholdParameters_IN::findByCompany(_ledgerJournalTrans.OffsetCompany).CrossCompanyPayment)
        {
            TaxWithholdWorkRegulation_IN::updateSourceRecId(_ledgerJournalTrans.RecId, newRecId, _ledgerJournalTrans.OffsetCompany);
        }
        // </GIN>

        // reset the list so a second posting can't inadvertantly access the previous adjustments by mistake
        taxWorkRegulationList = new RecordSortedList(tableNum (TaxWorkRegulation));
        taxWorkRegulationList.sortOrder(fieldNum(TaxWorkRegulation, RecId));

        // Add the mapping for journal line company's voucher and its related intercompany voucher
        LedgerJournalCheckPostBudget::addBudgetCheckVoucherForInterCompany(this, curext(), newLedgerJournalTable.JournalNum, newVoucher, _ledgerJournalTrans.Voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLedgerJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Insert the intercompany journal header.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> record.</param>
    /// <param name = "_newLedgerJournalTable">The <c>LedgerJournalTable</c> record.</param>
    /// <param name = "_ledgerJournalTable">The <c>LedgerJournalTable</c> record.</param>
    /// <param name = "_ledgerInterCompany">
    ///   The intercompany posting setup record for the given ledger journal transaction.
    /// </param>
    /// <param name = "_currentCompany">
    ///   The company from which posting was initiated.
    /// </param>
    /// <returns>The instance <c>LedgerJournalTable</c> record.</returns>
    [Replaceable]
    protected ledgerJournalTable insertLedgerJournalTable(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTable _newLedgerJournalTable,
        LedgerJournalTable _ledgerJournalTable,
        LedgerInterCompany _ledgerInterCompany,
        CompanyId _currentCompany)
    {
        _newLedgerJournalTable.JournalName           = _ledgerInterCompany.JournalName;
        _newLedgerJournalTable.Name                  = "@SYS3805";
        _newLedgerJournalTable.initFromLedgerJournalName();
        _newLedgerJournalTable.JournalNum            = JournalTableData::newTable(_newLedgerJournalTable).nextJournalId();
        _newLedgerJournalTable.OriginalCompany       = _currentCompany;
        _newLedgerJournalTable.OriginalJournalNum    = _ledgerJournalTrans.JournalNum;
        _newLedgerJournalTable.TaxObligationCompany  = _ledgerJournalTable.TaxObligationCompany;
        _newLedgerJournalTable.LedgerJournalInclTax  = _ledgerJournalTable.LedgerJournalInclTax;
        _newLedgerJournalTable.insert();

        return _newLedgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateInterCompanyOffsetJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>LedgerJournalTrans</c> buffer based on given intercompany transaction.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The ledger journal transaction for which to create or update intercompany journals and transactions.
    /// </param>
    /// <param name = "_newLedgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> buffer.
    /// </param>
    /// <param name = "_ledgerInterCompany">
    /// The intercompany posting setup record for the given ledger journal transaction.
    /// </param>
    /// <param name = "_currentCompany">
    /// The company from which posting was initiated.
    /// </param>
    /// <param name = "_reasonRecId">
    /// The record ID of the <c>ReasonTableRef</c> buffer.
    /// </param>
    /// <returns>
    /// The initialized <c>LedgerJournalTrans</c> buffer.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerJournalTrans populateInterCompanyOffsetJournalLine(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTrans _newLedgerJournalTrans,
        LedgerInterCompany _ledgerInterCompany,
        CompanyID _currentCompany,
        ReasonRefRecID _reasonRecId)
    {
        List dimensionSources = new List(Types::Class);

        //Original amount Debit => this amount Credit
        _newLedgerJournalTrans.AmountCurDebit = _ledgerJournalTrans.AmountCurCredit;
        _newLedgerJournalTrans.AmountCurCredit = _ledgerJournalTrans.AmountCurDebit;
        _newLedgerJournalTrans.AccountType = LedgerJournalACType::Ledger;

        // Merge the default ledger dimension and default dimension value to create a ledger dimension
        LedgerDimensionDefaultAccount defaultAccount = _ledgerJournalTrans.AmountCurDebit ? _ledgerInterCompany.DestinationCreditLedgerDimension : _ledgerInterCompany.DestinationDebitLedgerDimension;

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
        {
            dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getLedgerDimensionSpecifiers(_ledgerJournalTrans.LedgerDimension));

            DimensionDefault journalHeaderDefaultDimensions = LedgerJournalName::find(_ledgerInterCompany.JournalName).DefaultDimension;

            if (journalHeaderDefaultDimensions)
            {
                dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(journalHeaderDefaultDimensions));
            }
        }
        else
        {
            dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(_ledgerJournalTrans.DefaultDimension));
        }

        _newLedgerJournalTrans.LedgerDimension = LedgerDimensionDefaultingEngine::createLedgerDimension(defaultAccount, dimensionSources);

        _newLedgerJournalTrans.TaxGroup = '';
        _newLedgerJournalTrans.TaxItemGroup = '';

        // <GIN>
        // Check For Inter Company Trans When Service Tax is Marked .........
        if (TaxParameters::isServiceTaxEnable_IN()
            && _ledgerJournalTrans.isServiceTax_IN()
            && _ledgerJournalTrans.OffsetCompany)
        {
            _newLedgerJournalTrans.TaxGroup = _ledgerJournalTrans.TaxGroup;
            _newLedgerJournalTrans.TaxItemGroup = _ledgerJournalTrans.TaxItemGroup;
        }
        // </GIN>

        _newLedgerJournalTrans.TaxCode = '';
        _newLedgerJournalTrans.ReasonRefRecID = _reasonRecId;
        _newLedgerJournalTrans.DefaultDimension = 0;
        _newLedgerJournalTrans.Company = curext();
        _newLedgerJournalTrans.OffsetCompany = _currentCompany;

        _newLedgerJournalTrans.LineNum = LedgerJournalTrans::lastLineNum(_newLedgerJournalTrans.JournalNum) + 1;

        return _newLedgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSystemBlock</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a journal to indicate if it should be blocked or not.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    /// <param name = "set">
    /// A boolean indicating if the journal should be blocked; optional.
    /// </param>
    public void updateSystemBlock(LedgerJournalTable _ledgerJournalTable, boolean set = true)
    {
        if (set)
        {
            _ledgerJournalTable.SystemBlocked = NoYes::Yes;
        }
        else
        {
            this.updateTableInfoLog(_ledgerJournalTable);

            _ledgerJournalTable.SystemBlocked = NoYes::No;
        }

        _ledgerJournalTable.update();

        journalIsBlocked = _ledgerJournalTable.SystemBlocked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSystemBlockCheckedPostedJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Releases the system block on a successfully checked or posted journal.
    /// </summary>
    /// <remarks>
    ///    This update requires its own try-catch block in order to isolate any retries.
    /// </remarks>
    /// <exception cref="M:Exception::Deadlock">
    ///    An unrecoverable deadlock has occurred.
    /// </exception>
    /// <exception cref="M:Exception::UpdateConflict">
    ///    An update conflict has occurred.
    /// </exception>
    /// <exception cref="M:Exception::UpdateConflictNotRecovered">
    ///    An unrecoverable update conflict has occurred.
    /// </exception>
    protected void updateSystemBlockCheckedPostedJournal()
    {
        #OCCRetryCount

        try
        {
            // Reset the progress indicator.
            progress = null;

            if (!inTransfer || (this.numOfVouchersBooked()) <= 0)
            {
                this.removeSystemBlock();
            }
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeSystemBlock</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove the system block status.
    /// </summary>
    public void removeSystemBlock()
    {
        ttsbegin;

        // Buffer values may have changed this requires a new "find with lock" for updating the "System blocked" information.
        ledgerJournalTable = LedgerJournalTable::find(ledgerJournalId, true);

        // Un-block the journal.
        this.updateSystemBlock(ledgerJournalTable, false);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCancel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs cleanup if the processing is cancelled by the user.
    /// </summary>
    public void processCancel()
    {
        this.removeSystemBlock();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTableInfoLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the log on a journal.
    /// </summary>
    /// <param name = "_journalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    protected void updateTableInfoLog(LedgerJournalTable _journalTable)
    {
        LedgerJournalTable ledgerJournalTableLocal;

        ttsbegin;

        if (errorLedgerJournalId)
        {
            ledgerJournalTableLocal = LedgerJournalTable::find(errorLedgerJournalId, true);

            ledgerJournalTableLocal.Log = tableErrorLog;

            if (tableErrorLog == '')
            {
                _journalTable.Log = '';
            }

            ledgerJournalTableLocal.doUpdate();
        }
        else
        {
            // do not read the passed in record again because an update conflict will result
            // instead, update the buffer and rely on the caller to save it
            _journalTable.Log = tableErrorLog;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransInfoLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the infolog for the given transaction.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The transaction.</param>
    public void updateTransInfoLog(LedgerJournalTrans _ledgerJournalTrans = null)
    {
        #Define.UserTab('\t')

        Log             logTxt;
        Integer         x = transLogPoint;
        Integer         y = infolog.num(0);
        str             currentLine;
        Voucher         voucher;
        // <GEERU>
        Log             tableLogTxt;
        boolean         countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        if (postingResults)
        {
            postingResults.parmLedgerPostingMessageLog(ledgerPostingMessageCollection);
        }

        while (x < y)
        {
            x++;

            currentLine = strRem(infolog.text(x), #UserTab);

            // <GEERU>
            if (countryRegion_RU)
            {
                logTxt      =  currentLine + '\r\n';
                tableLogTxt += logTxt;
            }
            else
            {
                // </GEERU>
                logTxt += currentLine + '\r\n';
                // <GEERU>
            }
            // </GEERU>

            if (logTxt && postingResults != null)
            {
                if (_ledgerJournalTrans.Voucher == '')
                {
                    voucher = LedgerJournalCheckPostResults::getVoucherFromLogText(currentLine);
                    if (voucher == '')
                    {
                        // continue because calling the LedgerJournalCheckPostResults.updateErrorLog
                        // method with a blank voucher has terrible performance and will not change the results
                        continue;
                    }
                }
                else
                {
                    voucher = _ledgerJournalTrans.Voucher;
                }

                postingResults.updateErrorLog(voucher, logTxt);
            }
        }

        // <GEERU>
        if (countryRegion_RU)
        {
            logTxt = tableLogTxt;
        }
        // </GEERU>

        if (logTxt)
        {
            tableErrorLog += logTxt;
        }

        transLogPoint = y;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates a journal for posting.
    /// </summary>
    /// <param name="_calledFrom">
    /// Identifies the object from which this method is called. Default value is null.
    /// </param>
    /// <returns>
    /// true if the journal is valid for posting; otherwise, false.
    /// </returns>
    public boolean validate(Object _calledFrom = null)
    {
        boolean isValid = true;

        if (! ledgerJournalTable.JournalNum)
        {
            isValid = checkFailed(strFmt("@SYS21496", ledgerJournalTable.JournalNum));
        }

        isValid = isValid && JournalTableData::newTable(ledgerJournalTable).checkOpen();

        if (!this.parmSimulatePosting())
        {
            if (post == NoYes::Yes && ledgerJournalTable.isInWFApprovalProcess() && !ledgerJournalTable.isWFApprovalApproved())
            {
                // The journal is in workflow approvals and not approved so it can't be posted.
                isValid = isValid && checkFailed(strFmt("@SYS110592", ledgerJournalTable.JournalNum));
            }

            if (post == NoYes::Yes && !ledgerJournalTable.approved())
            {
                // The journal hasn't been approved.
                isValid = isValid && checkFailed(strFmt("@SYS22057", ledgerJournalTable.JournalNum));
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the validation company.
    /// </summary>
    /// <param name = "_currentCompanyId">The current company.</param>
    /// <returns>The validation company.</returns>
    public SelectableDataArea validateCompany(SelectableDataArea _currentCompanyId)
    {
        if (_currentCompanyId == '')
        {
            return curext();
        }
        else
        {
            return _currentCompanyId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerJournalTableBankAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates bank accounts that correspond to the <c>OffsetAccount</c> and <c>BankAccountId</c> fields
    ///    of the <c>LedgerJournalTable</c> table.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    ///    The <c>LedgerJournalTable</c> table.
    /// </param>
    /// <returns>
    ///    false if the <c>BankAccountHoldStatus</c> status against that bank account contains the
    ///    <c>InactiveForAllTransactions</c> enumeration value; otherwise, true.
    /// </returns>
    protected boolean validateLedgerJournalTableBankAccount(LedgerJournalTable  _ledgerJournalTable)
    {
        boolean isActive = true;

        if (_ledgerJournalTable.OffsetAccountType == LedgerJournalACType::Bank)
        {
            if (_ledgerJournalTable.OffsetLedgerDimension)
            {
                isActive = BankAccountTable::findByLedgerDimension(_ledgerJournalTable.parmOffsetLedgerDimension()).checkIsActiveForAllTransactions();
            }
        }

        if (_ledgerJournalTable.BankAccountId)
        {
            isActive = BankAccountTable::find(_ledgerJournalTable.BankAccountId).checkIsActiveForAllTransactions();
        }

        return isActive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransForFixedAssets</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate the journal line for Fixed assets.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerPostingMessageCollection">
    /// A <c>LedgerPostingMessageLog</c> instance; optional.
    /// </param>
    /// <returns>
    /// true.
    /// </returns>
    public boolean validateTransForFixedAssets(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTaxGroupsForAssetLeaseInvoiceJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate tax groups for asset leasing vendor invoice journal
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerPostingMessageCollection">
    /// A <c>LedgerPostingMessageLog</c> instance.
    /// </param>
    /// <returns>
    /// True if validation of tax groups is successful; otherwise, false.
    /// </returns>
    protected boolean validateTaxGroupsForAssetLeaseInvoiceJournal(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerPostingMessageLog _ledgerPostingMessageCollection)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProjTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate the journal for Project.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    /// <returns>
    /// true.
    /// </returns>
    protected boolean validateProjTrans(LedgerJournalTable  _ledgerJournalTable)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerJournalTransBankAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates bank accounts that correspond to the <c>OffsetAccount</c>, <c>AccountNum</c> and
    ///    <c>BankAccountId</c> fields of the <c>LedgerJournalTrans</c> table.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table.
    /// </param>
    /// <returns>
    ///    false if the <c>BankAccountHoldStatus</c> status against that bank account has the
    ///    <c>InactiveForAllTransactions</c> enumeration value; otherwise, true.
    /// </returns>
    protected boolean validateLedgerJournalTransBankAccount(LedgerJournalTrans  _ledgerJournalTrans)
    {
        boolean isActive = true;
        BankAccountTable bankAccount;

        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank)
        {
            if (_ledgerJournalTrans.OffsetLedgerDimension)
            {
                changecompany(_ledgerJournalTrans.getOffsetCompany())
                {
                    bankAccount = BankAccountTable::findByLedgerDimension(_ledgerJournalTrans.OffsetLedgerDimension);

                    isActive = bankAccount.checkIsActiveForAllTransactions();

                    // Only calculate balances for transactions with the potential to overdraft.
                    if (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Payment)
                    {
                        LedgerJournalCheckPostBank::calculateOffsetBalances(bankAccount, _ledgerJournalTrans, bankAccountBalances);
                    }
                }
            }
        }

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank)
        {
            if (_ledgerJournalTrans.LedgerDimension)
            {
                changecompany(_ledgerJournalTrans.Company)
                {
                    isActive = BankAccountTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension).checkIsActiveForAllTransactions();
                }
            }
        }

        // The Bank Account Id only executes in the context of the current company, no need to verify the cross-company scenarios.
        if (_ledgerJournalTrans.BankAccountId)
        {
            isActive = BankAccountTable::find(_ledgerJournalTrans.BankAccountId).checkIsActiveForAllTransactions();
        }

        return isActive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransDateForReversal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the transaction date on the journal line is not before the document date.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The journal line to validate.
    /// </param>
    /// <param name="_ledgerJournalType">
    ///    The type of journal being posted.
    /// </param>
    /// <param name="_ledgerPostingMessageCollection">
    ///    The posting messages collection; optional.
    /// </param>
    /// <returns>
    ///    true if the transaction date is later than or equal to the document date; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    For check and deposit slip reversals, an error is thrown if the transaction date on the journal
    ///    line is before the original transaction date.
    /// </remarks>
    protected boolean validateTransDateForReversal(
        LedgerJournalTrans  _ledgerJournalTrans,
        LedgerJournalType   _ledgerJournalType,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;

        if (_ledgerJournalTrans.TransDate < _ledgerJournalTrans.DocumentDate)
        {
            if (_ledgerJournalType == LedgerJournalType::BankChequeReversal)
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok =  _ledgerPostingMessageCollection.logCheckFailed("@SYS91442");
                }
                else
                {
                    ok =  checkFailed("@SYS91442");
                }
            }
            else if (_ledgerJournalType == LedgerJournalType::BankDepositPaymCancel)
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok =  _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS91506", date2StrUsr(_ledgerJournalTrans.TransDate, DateFlags::FormatAll), date2StrUsr(_ledgerJournalTrans.DocumentDate, DateFlags::FormatAll)));
                }
                else
                {
                    ok =  checkFailed(strFmt("@SYS91506", date2StrUsr(_ledgerJournalTrans.TransDate, DateFlags::FormatAll), date2StrUsr(_ledgerJournalTrans.DocumentDate, DateFlags::FormatAll)));
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMultipleTransactionsWithinOneVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the journal contains "One voucher" transactions.  There is a parameter
    /// that determines if these transactions are permitted.
    /// </summary>
    /// <param name="_journalBatchNumber">
    /// The journal batch number.
    /// </param>
    /// <param name="_voucher">
    /// The journal voucher number.
    /// </param>
    /// <param name="_ledgerPostingMessageCollection">
    /// The posting messages collection.
    /// </param>
    /// <returns>
    /// true when either "One voucher" transactions are permitted or none exist for the
    /// specified journal voucher; otherwise false.
    /// </returns>
    /// <remarks>
    /// The exclusion of the "Fee" type transaction allows for an LedgerTransType::Fee
    /// transaction to be posted inside the same voucher grouping.
    /// </remarks>
    protected boolean checkMultipleTransactionsWithinOneVoucher(
        LedgerJournalId _journalBatchNumber,
        Voucher _voucher,
        LedgerPostingMessageLog _ledgerPostingMessageCollection)
    {
        boolean ok = true;

        if (LedgerParameters::find().AllowMultipleTransactionsWithinOneVoucher == NoYes::No)
        {
            int numCustVend, numBank, numFixedAssets, numProject;
            int numRCash;
            LedgerJournalTrans ledgerJournalTrans;

            while select count(RecId) from ledgerJournalTrans
                group by ledgerJournalTrans.AccountType
                where ledgerJournalTrans.Voucher == _voucher &&
                    ledgerJournalTrans.JournalNum == _journalBatchNumber &&
                    ledgerJournalTrans.TransactionType != LedgerTransType::Fee &&
                    (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend ||
                        ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
                        ledgerJournalTrans.AccountType == LedgerJournalACType::Bank ||
                        ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets ||
                        ledgerJournalTrans.AccountType == LedgerJournalACType::Project ||
                        ledgerJournalTrans.AccountType == LedgerJournalACType::RCash)
            {
                if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend || ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
                {
                    numCustVend += int642int(ledgerJournalTrans.RecId);
                }
                else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Bank)
                {
                    numBank = int642int(ledgerJournalTrans.RecId);
                }
                else if (ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
                {
                    numFixedAssets = int642int(ledgerJournalTrans.RecId);
                }
                else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Project)
                {
                    numProject = int642int(ledgerJournalTrans.RecId);
                }
                else if (ledgerJournalTrans.AccountType == LedgerJournalACType::RCash)
                {
                    numRCash = int642int(ledgerJournalTrans.RecId);
                }
            }

            while select count(RecId) from ledgerJournalTrans
                    group by ledgerJournalTrans.OffsetAccountType
                    where ledgerJournalTrans.Voucher == _voucher &&
                        ledgerJournalTrans.JournalNum == _journalBatchNumber &&
                        ledgerJournalTrans.OffsetLedgerDimension != 0 &&
                        ledgerJournalTrans.TransactionType != LedgerTransType::Fee &&
                        (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend ||
                            ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust ||
                            ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank ||
                            ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets ||
                            ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project ||
                            ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::RCash)
            {
                if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend || ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
                {
                    numCustVend += int642int(ledgerJournalTrans.RecId);
                }
                else if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank)
                {
                    numBank += int642int(ledgerJournalTrans.RecId);
                }
                else if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets)
                {
                    numFixedAssets += int642int(ledgerJournalTrans.RecId);
                }
                else if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
                {
                    numProject += int642int(ledgerJournalTrans.RecId);
                }
                else if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::RCash)
                {
                    numRCash += int642int(ledgerJournalTrans.RecId);
                }
            }

            if (numCustVend > 1)
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok = _ledgerPostingMessageCollection.logCheckFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedCustVend");
                }
                else
                {
                    ok = checkFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedCustVend");
                }
            }

            if (numBank > 1)
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok = _ledgerPostingMessageCollection.logCheckFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedBank");
                }
                else
                {
                    ok = checkFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedBank");
                }
            }

            if (numFixedAssets > 1)
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok = _ledgerPostingMessageCollection.logCheckFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedFixedAssets");
                }
                else
                {
                    ok = checkFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedFixedAssets");
                }
            }

            if (numProject > 1)
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok = _ledgerPostingMessageCollection.logCheckFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedProject");
                }
                else
                {
                    ok = checkFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedProject");
                }
            }

            if (numRCash > 1)
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok = _ledgerPostingMessageCollection.logCheckFailed("@CashManagement_Localization:MultipleTransactionsWithinOneVoucherNotAllowedPettyCash");
                }
                else
                {
                    ok = checkFailed("@CashManagement_Localization:MultipleTransactionsWithinOneVoucherNotAllowedPettyCash");
                }
            }
            
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logCompanyNotInVoucherError</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Logs a message under the correct prefix for when a voucher doesn't contain the current company.
    /// </summary>
    /// <param name = "_oldVoucher">Voucher that doesn't contain an entry for the current company.</param>
    /// <param name = "_ledgerPostingMessageCollection">The posting messages collection; optional.</param>
    /// <returns>False</returns>
    private boolean logCompanyNotInVoucherError(Voucher _oldVoucher, LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok;

        setPrefix(strFmt("@SYS25866", _oldVoucher));
        
        if (_ledgerPostingMessageCollection)
        {
            ok = _ledgerPostingMessageCollection.logCheckFailed("@GeneralLedger:UnableToPostVoucherNoCurrentCompany");
        }
        else
        {
            ok = checkFailed("@GeneralLedger:UnableToPostVoucherNoCurrentCompany");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new <c>LedgerJournalCheckPost</c> object.
    /// </summary>
    /// <param = "_ledgerJournalType">The journal type.</param>
    /// <param = "_approval">Whether the value is an approval.</param>
    /// <returns>A new instance of the <c>LedgerJournalCheckPost</c> object.</returns>
    public static LedgerJournalCheckPost construct(
        LedgerJournalType _ledgerJournalType,
        NoYes             _approval = NoYes::No)
    {
        LedgerJournalCheckPost  ledgerJournalCheckPost;

        if (_approval == NoYes::Yes)
        {
            ledgerJournalCheckPost = new LedgerJournalCheckPostApproval();
        }
        else
        {
            switch (_ledgerJournalType)
            {
                case LedgerJournalType::Approval :
                    ledgerJournalCheckPost = new LedgerJournalCheckPostApproval();
                    break;
                case LedgerJournalType::PurchaseLedger :
                    ledgerJournalCheckPost = new LedgerJournalCheckPostInvoiceRegister();
                    break;
                case LedgerJournalType::CustPayment :
                    ledgerJournalCheckPost = LedgerJournalCheckPostCustomerPayment::construct();
                    break;
                case LedgerJournalType::Payment :
                    ledgerJournalCheckPost = LedgerJournalCheckPostVendorPayment::construct();
                    break;
                default :
                    ledgerJournalCheckPost = new LedgerJournalCheckPost();
            }
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
        {
            ledgerJournalCheckPost.rboParameters(NoYes::No, "", "", "");
            ledgerJournalCheckPost.initRetailParameters();
        }

        return ledgerJournalCheckPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>caption</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the caption for the operation.
    /// </summary>
    /// <returns>
    ///    The caption for the operation.
    /// </returns>
    public ClassDescription caption()
    {
        if (this.parmSimulatePosting())
        {
            return "@GeneralLedger:LedgerJournalValidateDescription";
        }
        else
        {
            if (post)
            {
                return "@GeneralLedger:LedgerJournalPostDescription";
            }
            else
            {
                return "@GeneralLedger:LedgerJournalValidateDescription";
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS25808";
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerJournalTable</Name>
				<Source><![CDATA[
    public static LedgerJournalCheckPost newLedgerJournalTable(
        LedgerJournalTable  _ledgerJournalTable,
        NoYes               _post,
        NoYes               _transferErrors = NoYes::No)
    {
        LedgerJournalCheckPost  ledgerJournalCheckPost;

        ledgerJournalCheckPost = LedgerJournalCheckPost::construct(_ledgerJournalTable.JournalType);

        ledgerJournalCheckPost.parmJournalNum(_ledgerJournalTable.JournalNum);
        ledgerJournalCheckPost.parmPost(_post);
        ledgerJournalCheckPost.parmTransferErrors(_transferErrors);
        ledgerJournalCheckPost.parmDetailSummaryPosting(_ledgerJournalTable.DetailSummaryPosting);
        ledgerJournalCheckPost.parmLedgerJournalTable(_ledgerJournalTable);

        return ledgerJournalCheckPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerJournalTrans</Name>
				<Source><![CDATA[
    public static LedgerJournalCheckPost newLedgerJournalTrans(
        LedgerJournalTrans   _ledgerJournalTrans,
        LedgerJournalVoucher _journalVoucher,
        NoYes                _post,
        NoYes                _transferErrors = NoYes::No,
        NoYes                _approval       = NoYes::No)
    {
        LedgerJournalCheckPost  ledgerJournalCheckPost;

        LedgerJournalTable ledgerJournalTable = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum);
        ledgerJournalCheckPost = LedgerJournalCheckPost::construct(ledgerJournalTable.JournalType, _approval);

        ledgerJournalCheckPost.parmJournalNum(_ledgerJournalTrans.JournalNum);

        if (_journalVoucher == LedgerJournalVoucher::Voucher)
        {
            ledgerJournalCheckPost.parmVoucher(_ledgerJournalTrans.Voucher);
        }

        ledgerJournalCheckPost.parmPost(_post);
        ledgerJournalCheckPost.parmTransferErrors(_transferErrors);
        ledgerJournalCheckPost.parmDetailSummaryPosting(_ledgerJournalTrans.ledgerJournalTable().DetailSummaryPosting);

        ledgerJournalCheckPost.parmLedgerJournalTable(ledgerJournalTable);

        return ledgerJournalCheckPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReversedRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>RevRecId</c> field of the specified reverse <c>LedgerJournalTrans</c> record reference.
    /// </summary>
    /// <param name="_reverseRecId">
    ///    The reverse record ID reference of the <c>LedgerJournalTrans</c> record to update.
    /// </param>
    /// <param name="_newReversalRecId">
    ///    The new reversal record ID reference.
    /// </param>
    private static void updateReversedRecord(RecId _reverseRecId, RecId _newReversalRecId)
    {
        LedgerJournalTrans ledgerJournalTransToUpdate;

        ledgerJournalTransToUpdate = LedgerJournalTrans::findByReverse(_reverseRecId, true);

        if (ledgerJournalTransToUpdate)
        {
            // Update the reversal reference of the ledger journal trans
            ledgerJournalTransToUpdate.RevRecId = _newReversalRecId;
            ledgerJournalTransToUpdate.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// true if the class is designed for executing the operation in a new session; otherwise, false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in batch.
    /// </summary>
    /// <returns>
    /// true if the class is designed for execution in batch; otherwise, false.
    ///</returns>
    public boolean canGoBatch()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetTransfer_LT</Name>
				<Source><![CDATA[
    private void updateAssetTransfer_LT()
    {
        AssetTable assetTable;
        AssetBook assetBook;
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTrans_Asset ledgerJournalTrans_Asset;

        ttsbegin;
        select firstonly forupdate assetTable
        join ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
        join ledgerJournalTrans_Asset
            where ledgerJournalTrans_Asset.RefRecId == ledgerJournalTrans.RecId
                && ledgerJournalTrans_Asset.AssetId == assetTable.AssetId
                && ledgerJournalTrans_Asset.AssetGroup_LT != assetTable.AssetGroup;

        assetTable.AssetGroup = ledgerJournalTrans_Asset.AssetGroup_LT;
        assetTable.update();

        update_recordset assetBook
            setting AssetGroup = assetTable.AssetGroup
                where assetBook.AssetId == assetTable.AssetId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetCheckReverseJournal_LT</Name>
				<Source><![CDATA[
    private boolean assetCheckReverseJournal_LT(LedgerJournalRecId _journalRecId)
    {
        boolean retOK = true;

        LedgerJournalTable reverseJournalTable = LedgerJournalTable::findByRecId(LedgerJournalTable_W::findByLedgerJournalTable(_journalRecId).ReverseJournalTable_LT);
        if (!reverseJournalTable.Posted)
        {
            retOK = ledgerPostingMessageCollection.logCheckFailedTableIdRecId(ledgerJournalTable.TableId, ledgerJournalTable.RecId, strfmt("@FixedAssets:FA_MessageError_JournalHasNotYetBeenPosted", reverseJournalTable.JournalNum));
        }

        return retOK;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseAndPostUnrealizedGainLoss</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method reverses any previous unrealized exchange gain/loss for the current transaction
    /// and posts unrealized gain/loss for current transaction date.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> to which the exchange rate gain/loss needs to be posted.
    /// </param>
    protected void reverseAndPostUnrealizedGainLoss(LedgerJournalTrans _ledgerJournalTrans, LedgerVoucher _ledgerVoucher)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostTaxDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if can post tax document.
    /// </summary>
    /// <returns>true if can post tax document.</returns>
    protected boolean canPostTaxDocument()
    {
        boolean canPostTaxDocument;
        canPostTaxDocument = isGTEEnabled
            && !TaxEngineTaxJournalUtil::isLedgerJournalTableCreatedFromTaxJournal(ledgerJournalTable.RecId)
            && ledgerVoucher
            && (isLedgerVoucherPosted || ledgerVoucher.check());
        return canPostTaxDocument;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxDocument</Name>
				<Source><![CDATA[
    private void postTaxDocument()
    {
        if (this.canPostTaxDocument())
        {
            Debug::assert(taxDocumentMapForPosting!= null);

            if (!taxDocumentMapForPosting.empty())
            {
                TableId transactionTableId;
                RecId transactionRecId;
                MapEnumerator enumerator = taxDocumentMapForPosting.getEnumerator();
                while(enumerator.moveNext())
                {
                    [transactionTableId, transactionRecId] = enumerator.currentKey();
                    ledgerVoucher ledgerVoucherLoc = enumerator.currentValue();
                    TaxEngineLedgerJournalTransHeader TaxEngineLedgerJournalTransHeader;
                    select firstonly TaxEngineLedgerJournalTransHeader
                        where TaxEngineLedgerJournalTransHeader.TableId == transactionTableId
                            && TaxEngineLedgerJournalTransHeader.RecId == transactionRecId;

                    if (TaxEngineLedgerJournalTransHeader.RecId)
                    {
                        LedgerJournalTrans ledgerJournalTransLoc;
                        select firstonly Voucher, TransDate from ledgerJournalTransLoc
                            where ledgerJournalTransLoc.Voucher == TaxEngineLedgerJournalTransHeader.Voucher
                                && ledgerJournalTransLoc.JournalNum == TaxEngineLedgerJournalTransHeader.JournalNum;
                        if (ledgerJournalTransLoc.RecId)
                        {
                            ledgerVoucherLoc.lastVoucher(ledgerJournalTransLoc.Voucher);
                            ledgerVoucherLoc.lastTransDate(ledgerJournalTransLoc.TransDate);
                        }
                    }

                    DictTable dictTable = new DictTable(transactionTableId);
                    Common common = dictTable.makeRecord();
                    select firstonly common
                        where common.RecId == transactionRecId;
                    if (common.RecId)
                    {
                        TaxBusinessService::postTaxDocument(
                            TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(common)),
                                ledgerVoucherLoc);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendBusinessEvents</Name>
				<Source><![CDATA[
    protected void sendBusinessEvents()
    {
        // to avoid a breaking change a subtype for a collections write-off
        // could not be used (because of no specific JournalType), therefore,
        // business event logic for the associated event is done here
        if (ledgerJournalTable.JournalName == CustParameters::find().CollectionsWriteOffLedgerJournalName)
        {
            if (BusinessEventsConfigurationReader::isBusinessEventEnabled(classStr(CustWriteOffPostedBusinessEvent)))
            {
                LedgerJournalTrans ledgerJournalTrans;

                while select ledgerJournalTrans
                    where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum &&
                        ledgerJournalTrans.AccountType == LedgerJournalACType::Cust
                {
                    CustWriteOffPostedBusinessEvent::newFromLedgerJournalTrans(ledgerJournalTrans).send();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>publishPostedParentJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///   This API publishes the Parent journal number when all the split journals have been posted.
    ///
    ///   When a journal is created, it may or may not get split into 2 or more journals during the posting if the LineLimitBeforeDistribution is set up at the original journal level.
    ///   We have ParentJournalNum column in LedgerJournalTable which ties all of these split journal together.
    /// </summary>
    /// <param name="_postedParentJournalNum">
    ///    posted parent journal.
    /// </param>
    public static void publishPostedParentJournal(LedgerJournalId _postedParentJournalNum)
    {

    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePostingTransactionScopeHandlers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds transaction scope handlers to validate Journal Posted flag from current session when the top level transaction is committed.
    /// </summary>
    private void initializePostingTransactionScopeHandlers()
    {
        str transactionScopeCacheKey = funcname();
        str className = classStr(LedgerJournalCheckPost);

        if (appl.ttsLevel() > 0)
        {
            SysTransactionScope transactionScope = appl.transactionScope();
            SysGlobalCache transactionCache = transactionScope.parmTransactionScopeCache();

            if(!transactionCache.isSet(className, transactionScopeCacheKey))
            {
                transactionCache.set(className, transactionScopeCacheKey, true);
                transactionScope.ttsCommitting += eventhandler(this.validateJournalForPosted);
            }
        }
        else
        {
            // TTS level should always be greater than zero
            throw error(Error::wrongUseOfFunction(funcname()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateJournalForPosted</Name>
				<Source><![CDATA[
    private void validateJournalForPosted()
    {
        if (this.ledgerJournalId && ledgerVoucher != null)
        {
            LedgerJournalCheckPostInstrumentation::logCompletedJournalHeaderNotSetToPosted(this.ledgerJournalId, ledgerVoucher.numOfVouchers());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasRevRecReversals</Name>
				<Source><![CDATA[
    private static boolean hasRevRecReversals(LedgerJournalId _journalNum)
    {
        LedgerJournalTrans ledgerJournalTransRevRec;
        LedgerJournalTrans ledgerJournalTransBase;

        select firstonly RecId from ledgerJournalTransRevRec
            where ledgerJournalTransRevRec.RevRecId != 0
        exists join ledgerJournalTransBase
            where ledgerJournalTransBase.RecId == ledgerJournalTransRevRec.RevRecId
                && ledgerJournalTransBase.JournalNum == _journalNum;

        return ledgerJournalTransRevRec.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournalLines</Name>
				<Source><![CDATA[
    private LedgerJournalCheckPost_PostLinesResult postJournalLines(LedgerJournalCheckPost_PostLinesRequest _request)
    {
        boolean ok = true;
        boolean first = true;
        Voucher oldVoucher = '';
        TransDate oldTransDate;
        InvoiceId oldinvoice;
        utcdatetime oldReleaseDate;
        CurrencyCode oldCurrencyCode;
        ReportingCurrencyExchRate reportingCurrencyExchRateForAccountCompany;
        boolean voucherContainsCurrentCompany;
        boolean allOK = _request.allOK;
        CompanyId currentCompany = curext();
        Map voucherMap = new Map(Types::String, Types::Class);
        
        LedgerVoucherObject postingReference;

        boolean isAccountingDateUpdateAllowed = ProjParameters::find().IsAccountingDateUpdateAllowed;

        boolean useAcknowlegementDate = LedgerParameters::find().AcknowledgementDate_IT;

        // <GJP>
        boolean isAssetDocumentEnabled = AssetDocumentUtility_JP::isAssetDocumentEnabled();
        // </GJP>

        // perf: Determine whether the entire journal has any bank fees before posting
        // to avoid doing a while select for each LedgerJournalTrans to not find anything.
        // This is worse because a while select can't be cached.
        boolean journalHasBankFees = CustVendPaymJournalFee::existRefRecId(ledgerJournalTable.RecId);

        // perf: Determine whether the entire journal has any accruals before posting
        // to avoid doing two queries for each LedgerJournalTrans to not find anything
        LedgerJournalTrans ledgerJournalTrans = LedgerJournalTransAccrual::getFirstAccrualLineForLedgerJournal(ledgerJournalTable.JournalNum);
        boolean journalHasAccruals = (ledgerJournalTrans != null);

        if (journalHasAccruals && FeatureStateProvider::isFeatureEnabled(LedgerVoucherUpdateVoucherSeriesForAccrualsFlight::instance()))
        {
            this.updateVoucherSeriesCodeInLedgerVoucherForAccrualsDelegate(this, ledgerJournalTrans);
        }

        // perf: Determine if any reversals exist for the journal to avoid lookups
        // for reversals on each line individually. Since most journals don't
        // contain reversals, check that here to avoid checking on each journal
        // line later on.
        boolean anyReversalsExistForJournal = LedgerJournalCheckPost::hasRevRecReversals(ledgerJournalTable.JournalNum);

        // perf: Determine whether or not any journal control exists
        boolean journalHasJournalControl = LedgerJournalTable::hasJournalControl(ledgerJournalTable.JournalName);

        // perf: Determine if this is a negotiable instrument journal
        boolean journalHasNegotiableInstrument = LedgerJournalName::isNegotiableInstrumentJournal(ledgerJournalTable.JournalType);

        // perf: Determine if any disputes exist for the journal.
        boolean journalHasCustDispute = CustDisputeHistoryAutomation::doesDisputeExistForJournal(ledgerJournalTable.JournalNum);

        while select ledgerJournalTrans
            order by Voucher, TransDate, AccountType desc, RecId
            where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
        {
            ledgerJournalTrans = this.updateTransDate(isAccountingDateUpdateAllowed, ledgerJournalTrans);

            if ((oldVoucher && oldVoucher != ledgerJournalTrans.Voucher) && (!voucherContainsCurrentCompany))
            {
                allOK = this.logCompanyNotInVoucherError(oldVoucher, ledgerPostingMessageCollection);
            }

            if (!anyReversalsExistForJournal)
            {
                allOK = allOK && ledgerJournalTrans.defaultAndValidateReportingExchangeRates(ledgerPostingMessageCollection);
            }

            allOK = allOK && this.checkValidUser(ledgerJournalTrans, ledgerPostingMessageCollection);

            setPrefix(strFmt("@SYS25866", ledgerJournalTrans.Voucher));

            if (postingReference)
            {
                postingReference.parmSourceRecIdDefault(ledgerJournalTrans.RecId);
                postingReference.parmSourceTableIdDefault(tableNum(LedgerJournalTrans));
            }

            ledgerPostingMessageCollection.setTableIdRecId(
                tableNum(LedgerJournalTrans),
                ledgerJournalTrans.RecId);

            if (ledgerJournalTrans.isProjectTransaction())
            {
                LedgerJournalTrans_Project ledgerJournalTrans_Project = LedgerJournalTrans_Project::find(ledgerJournalTrans.RecId);
                if (ledgerJournalTrans_Project)
                {
                    ProjOpsFinancialsLogger logger = ProjOpsFinancialsLogger::createLogger(classStr(LedgerJournalCheckPost));
                
                    logger.logInformation(strFmt(ProjOpsFinancialsInstrumentationActivites::JournalPostingLogMessageFmt,
                        ledgerJournalTable.JournalName, ledgerJournalTrans.JournalNum, ledgerJournalTrans.LineNum,
                        ledgerJournalTrans_Project.ProjId, ledgerJournalTrans_Project.TransId, ledgerJournalTrans.Voucher));
                }
            }

            // <GIN>
            // Validates TAN number is filled in.
            if (_request.taxWithholdParameterMarked)
            {
                changecompany(ledgerJournalTrans.DataAreaId)
                {
                    TransTaxInformationHelper			helper;
                    TransTaxInformation                 transTaxInformation;
                    LedgerJournalTransTaxExtensionIN    ledgerJournalTransTaxExt = ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

                    helper = TransTaxInformationHelper::newHelper();

                    transTaxInformation = helper.getTransTaxInformation(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId);

                    if (transTaxInformation && !transTaxInformation.TaxWithholdTAN
                        && (ledgerJournalTransTaxExt.tdsGroup || ledgerJournalTransTaxExt.tcsGroup))
                    {
                        ledgerPostingMessageCollection.logAndThrowError(strFmt("@SYS26332", "@GLS5353"));
                    }
                }
            }
            // </GIN>

            // <GEERU><GEEU>
            if (ledgerJournalTable.JournalType == LedgerJournalType::RCash
               && RCashParameters::isCashModuleEnabled()
               && LedgerJournalTrans_RCash::find(ledgerJournalTrans.RecId).TransStatus == RCashTransStatus::Canceled)
            {
                rCashRejectedLineExists = true;
                continue;
            }

            // </GEEU></GEERU>

            // Taxes is dependent upon the order in which the LedgerJournalTrans records
            // get processed.  Any changes to the order by will require changes to
            // TaxVoucherService.

            // The ledger journal trans record will get messed with during this operation,
            // but the original values are necessary to properly calculate taxes. So, the
            // original values are copied to a temporary buffer here to avoid needing to
            // do an additional select during tax calculation.
            LedgerJournalTrans originalLedgerJournalTrans;
            originalLedgerJournalTrans.data(ledgerJournalTrans);
            // <GTH>
            originalLedgerJournalTrans.SysExtensionSerializerMap::copyExtensionTableData(ledgerJournalTrans);
            // </GTH>

            // Cache if the journal has offset account and the original LedgerJournalTrans exchange rates
            // before the posting process starts to swap account and offset account.
            ExchRate exchRateForAccountCompany = ledgerJournalTrans.ExchRate;
            ExchrateSecondary exchRateSecondaryForAccountCompany = ledgerJournalTrans.ExchRateSecond;
            EUROTriangulation euroTriangulationForAccountCompany = ledgerJournalTrans.Triangulation;
            ExchrateSecondary exchRateSecondaryForCurrentCompany;
            EUROTriangulation euroTriangulationForCurrentCompany;
            ReportingCurrencyExchRate reportingCurrencyExchRateForCurrentCompany;
            ExchRate exchRateForCurrentCompany;
            ReportingCurrencyExchRateSecondary reportingCurrencyExchRateSecondaryForCurrentCompany;
           
            reportingCurrencyExchRateForAccountCompany = ledgerJournalTrans.ReportingCurrencyExchRate;
            ReportingCurrencyExchRateSecondary reportingCurrencyExchRateSecondaryForAccountCompany = ledgerJournalTrans.ReportingCurrencyExchRateSecondary;
            boolean hasOffsetAccount = (ledgerJournalTrans.OffsetLedgerDimension != 0);

            CurrencyCode transactionReportingCurrencyCode;
            CurrencyCode currentCompanyReportingCurrencyCurrencyCode;
            CurrencyCode curCompanyCurrencyCode;
            CurrencyCode transAccountingCurrencyCode;

            TransDate oldTransDate_RU;

            if (ledgerJournalTrans.Company == currentCompany)
            {
                curCompanyCurrencyCode = '';
                transAccountingCurrencyCode = '';
                transactionReportingCurrencyCode = '';
                currentCompanyReportingCurrencyCurrencyCode = '';
            }
            else
            {
                curCompanyCurrencyCode = Ledger::accountingCurrency();
                currentCompanyReportingCurrencyCurrencyCode = Ledger::reportingCurrency();

                changecompany(ledgerJournalTrans.Company)
                {
                    transAccountingCurrencyCode = Ledger::accountingCurrency();
                    transactionReportingCurrencyCode = Ledger::reportingCurrency();
                }
            }

            LedgerJournalTrans ledgerJournalTransOrig;

            if (this.shouldUseProvidedExchangeRates(ledgerJournalTrans, currentCompany))
            {
                exchRateForCurrentCompany = ledgerJournalTrans.ExchRate;
                exchRateSecondaryForCurrentCompany = ledgerJournalTrans.ExchRateSecond;
                euroTriangulationForCurrentCompany = ledgerJournalTrans.Triangulation;
                reportingCurrencyExchRateForCurrentCompany = ledgerJournalTrans.ReportingCurrencyExchRate;
                reportingCurrencyExchRateSecondaryForCurrentCompany = ledgerJournalTrans.ReportingCurrencyExchRateSecondary;
            }
            else if ((curCompanyCurrencyCode == transAccountingCurrencyCode || currentCompanyReportingCurrencyCurrencyCode == transactionReportingCurrencyCode)
                && (ledgerJournalTable.JournalType == LedgerJournalType::Daily
                    || ledgerJournalTable.JournalType == LedgerJournalType::PurchaseLedger
                    || ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister
                    || ledgerJournalTable.JournalType == LedgerJournalType::Payment
                    || ledgerJournalTable.JournalType == LedgerJournalType::CustPayment))
            {
                Ledger currentLedger = Ledger::find(Ledger::current());

                ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newExchangeDate(currentLedger.RecId, ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate);

                if (!ledgerJournalTrans.ReverseEntry)
                {
                    ledgerJournalTransOrig = LedgerJournalTrans::findByReverse(ledgerJournalTrans.RecId);
                }

                // For intercompany posting, if both companies have the same accounting currency,
                // then the overridden rate on the journal should be used.
                if (curCompanyCurrencyCode == transAccountingCurrencyCode)
                {
                    exchRateForCurrentCompany = ledgerJournalTrans.ExchRate;
                    exchRateSecondaryForCurrentCompany = ledgerJournalTrans.ExchRateSecond;
                    euroTriangulationForCurrentCompany = ledgerJournalTrans.Triangulation;
                }
                else if (curCompanyCurrencyCode == transactionReportingCurrencyCode)
                {
                    exchRateForCurrentCompany = ledgerJournalTrans.ReportingCurrencyExchRate;
                    exchRateSecondaryForCurrentCompany = ledgerJournalTrans.ReportingCurrencyExchRateSecondary;
                    euroTriangulationForCurrentCompany = ledgerJournalTrans.Triangulation;
                }
                else
                {
                    if (ledgerJournalTransOrig.RecId != 0 && ledgerJournalTransOrig.ReverseEntry)
                    {
                        // For reversal ledgerjournalTrans entries get the original ledgerJournalTrans record to calculate exchange rates.
                        exchangeRateHelper.parmExchangeDate(ledgerJournalTransOrig.TransDate);
                        exchRateForCurrentCompany = exchangeRateHelper.getExchangeRate1();
                        exchRateSecondaryForCurrentCompany = exchangeRateHelper.getExchangeRate2();
                    }
                    else
                    {
                        exchRateForCurrentCompany = exchangeRateHelper.getExchangeRate1();
                        exchRateSecondaryForCurrentCompany = exchangeRateHelper.getExchangeRate2();
                    }
                }

                // For intercompany posting, if both companies have the same reporting currency,
                // then the overridden rate on the journal should be used.
                if (currentCompanyReportingCurrencyCurrencyCode == transactionReportingCurrencyCode)
                {
                    reportingCurrencyExchRateForCurrentCompany = ledgerJournalTrans.ReportingCurrencyExchRate;
                    reportingCurrencyExchRateSecondaryForCurrentCompany = ledgerJournalTrans.ReportingCurrencyExchRateSecondary;
                }
                else
                {
                    if (currentLedger.ReportingCurrency)
                    {
                        if (ledgerJournalTransOrig.RecId != 0 && ledgerJournalTransOrig.ReverseEntry)
                        {
                            // For reversal ledgerjournalTrans entries get the original ledgerJournalTrans record to calculate exchange rates.
                            exchangeRateHelper.parmToCurrency(currentLedger.ReportingCurrency);
                            exchangeRateHelper.parmExchangeRateTypeRecId(currentLedger.ReportingCurrencyExchangeRateType);
                            exchangeRateHelper.parmExchangeDate(ledgerJournalTransOrig.TransDate);
                            reportingCurrencyExchRateForCurrentCompany = exchangeRateHelper.getExchangeRate1();
                            reportingCurrencyExchRateSecondaryForCurrentCompany = exchangeRateHelper.getExchangeRate2();
                        }
                        else
                        {
                            exchangeRateHelper.parmToCurrency(currentLedger.ReportingCurrency);
                            exchangeRateHelper.parmExchangeRateTypeRecId(currentLedger.ReportingCurrencyExchangeRateType);
                            reportingCurrencyExchRateForCurrentCompany = exchangeRateHelper.getExchangeRate1();
                            reportingCurrencyExchRateSecondaryForCurrentCompany = exchangeRateHelper.getExchangeRate2();
                        }
                    }
                }
            }
            else
            {
                if (!ledgerJournalTrans.ReverseEntry)
                {
                    ledgerJournalTransOrig = LedgerJournalTrans::findByReverse(ledgerJournalTrans.RecId);
                }

                if (ledgerJournalTransOrig != null && ledgerJournalTransOrig.ReverseEntry)
                {
                    // For reversal ledgerjournalTrans entries get the original ledgerJournalTrans record
                    // to calculate exchange rates.
                    exchRateForCurrentCompany = ExchangeRateHelper::exchRate(ledgerJournalTrans.CurrencyCode, ledgerJournalTransOrig.TransDate);
                    exchRateSecondaryForCurrentCompany = ExchangeRateHelper::exchRateSecond(ledgerJournalTrans.CurrencyCode, ledgerJournalTransOrig.TransDate);
                    euroTriangulationForCurrentCompany = Currency::triangulation(ledgerJournalTrans.CurrencyCode, ledgerJournalTransOrig.TransDate);

                    Ledger ledger = Ledger::find(Ledger::current());
                    if (ledger.ReportingCurrency)
                    {
                        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newExchangeDate(ledger.RecId, ledgerJournalTrans.CurrencyCode, ledgerJournalTransOrig.TransDate);
                        exchangeRateHelper.parmToCurrency(ledger.ReportingCurrency);
                        exchangeRateHelper.parmExchangeRateTypeRecId(ledger.ReportingCurrencyExchangeRateType);
                        reportingCurrencyExchRateForCurrentCompany = exchangeRateHelper.getExchangeRate1();
                        reportingCurrencyExchRateSecondaryForCurrentCompany = exchangeRateHelper.getExchangeRate2();
                    }
                }
                else
                {
                    exchRateForCurrentCompany = ExchangeRateHelper::exchRate(ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate);
                    exchRateSecondaryForCurrentCompany = ExchangeRateHelper::exchRateSecond(ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate);
                    euroTriangulationForCurrentCompany = Currency::triangulation(ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate);
                    
                    Ledger ledger = Ledger::find(Ledger::current());
                    if (ledger.ReportingCurrency)
                    {
                        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newExchangeDate(ledger.RecId, ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate);
                        exchangeRateHelper.parmToCurrency(ledger.ReportingCurrency);
                        exchangeRateHelper.parmExchangeRateTypeRecId(ledger.ReportingCurrencyExchangeRateType);
                        reportingCurrencyExchRateForCurrentCompany = exchangeRateHelper.getExchangeRate1();
                        reportingCurrencyExchRateSecondaryForCurrentCompany = exchangeRateHelper.getExchangeRate2();
                    }
                }
            }

            boolean isCompanyIntercompany = ledgerJournalTrans.isCompanyIntercompany();
            boolean isOffsetCompanyIntercompany = ledgerJournalTrans.isOffsetCompanyIntercompany();

            checkNoSettlement = true;
            allOK = LedgerJournalCheckPost_WE::checkPaymStatus_NO(ledgerJournalTrans, ledgerPostingMessageCollection) && allOK;

            // <GIN>
            if (allOK
                && _request.taxWithholdParameterMarked
                && TaxWithholdParameters_IN::findByCompany(curext()).CrossCompanyPayment
                && ledgerJournalTable.JournalType != LedgerJournalType::BankChequeReversal
                && ledgerJournalTable.JournalType != LedgerJournalType::BankDepositPaymCancel)
            {
                allOK = LedgerJournalCheckPost_IN::checkPaymentForCP(ledgerJournalTrans, ledgerPostingMessageCollection);

                if (allOK)
                {
                    allOK = LedgerJournalCheckPost_IN::checkOverpaymentForCP(ledgerJournalTrans, ledgerPostingMessageCollection);
                }
            }
            // </GIN>

            // <GBR>
            #ISOCountryRegionCodes
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR]))
            {
                if (!ledgerJournalTransWithTaxUncommitedSet_BR)
                {
                    ledgerJournalTransWithTaxUncommitedSet_BR = LedgerJournalCheckPost_BR::initLedgerJournalTransWithTaxUncommitedSet(voucherNum, ledgerJournalTable.JournalNum);
                }
                    
                if (ledgerJournalTransWithTaxUncommitedSet_BR && ledgerJournalTransWithTaxUncommitedSet_BR.in(ledgerJournalTrans.RecId))
                {
                    allOK = LedgerJournalCheckPost_BR::checkFiscalEstablishment(ledgerJournalTrans) && allOK;
                }

                allOK =     LedgerJournalCheckPost_BR::checkTransactionTxt(ledgerJournalTrans, ledgerPostingMessageCollection)
                        &&  LedgerJournalCheckPost_BR::checkSalesTaxForProject(ledgerJournalTable, ledgerJournalTrans)
                        &&  allOK;
            }
            // </GBR>

            if (journalHasJournalControl)
            {
                allOK = ledgerJournalTrans.checkJournalAccountControl() && allOK;
            }

            // <GEEU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]))
            {
                allOK = ledgerJournalTrans.checkVendPrepayment_CZ(ledgerPostingMessageCollection) && allOK;
            }

            // This validation only issues warnings
            ledgerJournalTrans.checkPrepaymentTaxGroups();

            //--> Italy: Asset leasing journal mandatory sales tax group and item sales tax group check for vendor invoice journal line with account type as vendor.
            allOK = this.validateTaxGroupsForAssetLeaseInvoiceJournal(ledgerJournalTrans, ledgerPostingMessageCollection) && allOK;

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]) &&
                ledgerJournalTable.JournalType == LedgerJournalType::CustPayment)
            {
                allOK = LedgerJournalCheckPost_PL::checkMarkedInvoice(ledgerJournalTrans, ledgerPostingMessageCollection) && allOK;
            }
            // </GEEU>

            // Validating bank account corresponding to OffsetAccount, AccountNum and BankAccountId of LedgerJournalTrans on Post button.
            allOK = this.validateLedgerJournalTransBankAccount(ledgerJournalTrans) && allOK;

            // Catera -> Handling Posting profile.
            if (journalHasNegotiableInstrument && ledgerJournalTrans.TransactionType == LedgerTransType::Fee)
            {
                ledgerJournalTrans.PostingProfile =CustParameters::find().PostingProfile;
            }

            if (!this.journalLineHasRequiredInformation(ledgerJournalTrans))
            {
                allOK = ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS60118", LedgerJournalTrans::findTmpVoucher(ledgerJournalTrans.Voucher, tmpVoucherMap)));
                this.insertInVoucherErrorList(ledgerJournalTrans.Voucher);
            }

            // <GEERU>
            if (_request.countryRegion_RU)
            {
                allOK = allOK && LedgerJournalCheckPost_RU::checkSalesBookTax(this,
                                                  ledgerJournalTrans,
                                                  true,
                                                  ledgerJournalTrans.isCompanyIntercompany() ? ledgerJournalTrans.Company : curext());

                allOK = allOK && LedgerJournalCheckPost_RU::checkPrepaymentAutoFacture_RU(this, ledgerJournalTransFBT, true);
                allOK = allOK && LedgerJournalCheckPost_RU::checkRestoredVAT(this, ledgerJournalTrans, true);

                if (allOK && ledgerJournalTrans.Invoice)
                {
                    RestoredVATLogTable_RU::setRecalcAll(ledgerJournalTrans.TransDate);
                }
            }
            // </GEERU>

            // <GEEU>
            if (!ledgerJournalTrans.checkVatRegData_W(tmpVoucherMap))
            {
                allOK = false;
                this.insertInVoucherErrorList(ledgerJournalTrans.Voucher);
                this.updateTransInfoLog(ledgerJournalTrans);
            }
            // </GEEU>

            // <GJP>
            if (ledgerJournalTable.isPositiveDRCROnlyEnabled_JP()
                && !LedgerJournalCheckPost_JP::checkPositiveDRCR(ledgerJournalTrans, ledgerPostingMessageCollection))
            {
                allOK = false;
                this.insertInVoucherErrorList(ledgerJournalTrans.Voucher);
            }

            if (isAssetDocumentEnabled)
            {
                LedgerJournalTrans_Asset ledgerJournalTrans_Asset = LedgerJournalTrans_Asset::find(ledgerJournalTrans.RecId);
                if (ledgerJournalTrans_Asset
                    && (ledgerJournalTrans_Asset.DocumentType_JP == AssetDocumentType_JP::AssetReductionEntry_DirectOff
                    || ledgerJournalTrans_Asset.DocumentType_JP == AssetDocumentType_JP::AssetReductionEntry_Reserve))
                {
                    AssetDocumentReductionEntryTable_JP assetDocumentReductionEntry = AssetDocumentReductionEntryTable_JP::findByDocumentEntry(ledgerJournalTrans_Asset.AssetDocumentEntry_JP);
                    if (assetDocumentReductionEntry.DocumentDate > ledgerJournalTrans.TransDate)
                    {
                        allOK = ledgerPostingMessageCollection.logCheckFailed("@SYS4006136");
                    }

                    AssetReductionEntryProfile_JP assetReductionEntryProfile = AssetReductionEntryProfile_JP::findByReductionEntryTableRecId(assetDocumentReductionEntry.RecId);
                    if (assetReductionEntryProfile
                        && !assetReductionEntryProfile.validateTransDate(ledgerJournalTrans.TransDate))
                    {
                        allOK = ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS4006135",
                            ledgerJournalTrans.TransDate,
                            assetReductionEntryProfile.getValidFrom(),
                            assetReductionEntryProfile.getValidTo()));
                    }
                }
            }
            // </GJP>

            ok = ok && this.validateTransForFixedAssets(ledgerJournalTrans, ledgerPostingMessageCollection);

            // <GEEPL>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
            {
                if (TaxGroupHeading::find(ledgerJournalTrans.TaxGroup).IsMandatoryServiceTariff_PL &&
                    !TaxServiceTariff::findByParent(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId))
                {
                    allOK = ledgerPostingMessageCollection.logCheckFailed(strFmt("@GLS115885", ledgerJournalTrans.JournalNum, ledgerJournalTrans.Voucher));
                    this.insertInVoucherErrorList(ledgerJournalTrans.Voucher);
                }
            }
            // </GEEPL>

            this.displayProgress(ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate);

            if (!ledgerJournalTrans.Voucher)
            {
                ledgerPostingMessageCollection.logAndThrowError(strFmt('%1 %2 %3', "@SYS24569", "@SYS4163", date2StrUsr(ledgerJournalTrans.TransDate, DateFlags::FormatAll)));
            }

            if (!this.checkNegotiableInstrumentPosting(ledgerJournalTrans, journalHasNegotiableInstrument))
            {
                allOK = false;
                this.insertInVoucherErrorList(ledgerJournalTrans.Voucher);
            }

            if (!this.checkInterCompanyPosting(ledgerJournalTrans, isCompanyIntercompany, isOffsetCompanyIntercompany))
            {
                allOK = false;
                this.insertInVoucherErrorList(ledgerJournalTrans.Voucher);
            }

            if (!this.checkReleaseDate(ledgerJournalTrans))
            {
                allOK = false;
                this.insertInVoucherErrorList(ledgerJournalTrans.Voucher);
            }

            if (!this.checkAcknowledgementDate(ledgerJournalTrans, useAcknowlegementDate))
            {
                // Posting date may not exceed competence date.
                allOK = ledgerPostingMessageCollection.logCheckFailed("@SYS99223");
                this.insertInVoucherErrorList(ledgerJournalTrans.Voucher);
            }

            // For cheque and deposit slip reversals, it is an error if the transaction date
            // on the voucher is before the original transaction date (stored in DocumentDate).
            allOK = allOK && this.validateTransDateForReversal(ledgerJournalTrans, ledgerJournalTable.JournalType, ledgerPostingMessageCollection);

            if (allOK)
            {
                allOK = ledgerJournalTrans.checkReasonRefRecID(ledgerPostingMessageCollection);
            }

            if (oldVoucher != ledgerJournalTrans.Voucher)
            {
                ledgerJournalTrans.validateW9Received(true);

                voucherContainsCurrentCompany = ledgerJournalTrans.containsCurrentCompany();
            }
            else
            {
                voucherContainsCurrentCompany = voucherContainsCurrentCompany || ledgerJournalTrans.containsCurrentCompany();
            }

            if (allOK)
            {
                allOK = LedgerJournalCheckPostBank::validateBankLC(isLetterOfCreditEnabled, ledgerJournalTrans);
                if (allOK && _request.journalHasPDC)
                {
                    allOK = LedgerJournalCheckPostCash::validatePDC(ledgerJournalTrans, ledgerPostingMessageCollection);

                    if (!allOK)
                    {
                        this.insertInVoucherErrorList(ledgerJournalTrans.Voucher);
                    }
                }
            }

            //Check that ReleaseDate is the same on all lines with the same voucher#
            if (oldVoucher != ledgerJournalTrans.Voucher)
            {
                oldReleaseDate = ledgerJournalTrans.ReleaseDate;
            }
            else
            {
                if (oldReleaseDate != ledgerJournalTrans.ReleaseDate)
                {
                    allOK = ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS115796", oldVoucher));
                    this.insertInVoucherErrorList(ledgerJournalTrans.Voucher);
                }
                //if
            }
            // else

            // <GEERU>
            boolean transDateFailed;

            if (oldTransDate_RU
                && ledgerJournalName.MandatoryDate_RU
                && oldTransDate_RU != ledgerJournalTrans.TransDate)
            {
                allOK = ledgerPostingMessageCollection.logCheckFailed("@GLS113711");
                this.insertInVoucherErrorList(ledgerJournalTrans.Voucher);
                transDateFailed = true;
            }
            // </GEERU>

            LedgerJournalACType mainAccountTypeForCurrentVoucher;

            if (this.allowCreateOrUpdatePostingReference(ledgerJournalTrans, oldVoucher, oldTransDate, first))
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    LedgerJournalTransFieldCache ledgerJournalTransFieldCache = new LedgerJournalTransFieldCache();
                    ledgerJournalTransFieldCache.parmCurrencyCode(oldCurrencyCode);
                    ledgerJournalTransFieldCache.parmInvoice(oldinvoice);
                    ledgerJournalTransFieldCache.parmTransDate(oldTransDate);
                    ledgerJournalTransFieldCache.parmVoucher(oldVoucher);

                    // <GEERU>
                    if (ledgerBondClient)
                    {
                        LedgerJournalCheckPost_RU::bondJournalVoucher(ledgerBondClient, ledgerVoucher);
                    }
                    // </GEERU>
                    voucherMap.insert(oldVoucher, ledgerJournalTransFieldCache);
                }

                oldVoucher = ledgerJournalTrans.Voucher;
                oldTransDate = ledgerJournalTrans.TransDate;
                oldinvoice = ledgerJournalTrans.Invoice;
                oldCurrencyCode = ledgerJournalTrans.CurrencyCode;

                postingReference = ledgerVoucher.findLedgerVoucherObject(ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate);
                if (!postingReference)
                {
                    postingReference = this.createPostingReference(ledgerJournalTrans, _request.sysModule);
                    
                    // Adds the voucher and requests to save the budget source for checking budget funds availability later.
                    LedgerJournalCheckPostBudget::addBudgetCheckVoucher(
                        this,
                        ledgerJournalTrans.Voucher,
                        postingReference,
                        false);
                    numOfVouchersBooked++;

                    ledgerVoucher.addVoucher(postingReference);
                }
                else
                {
                    // The LedgerVoucherObject was created by Tax. Tax doesn't have some of this information for the proper defaults
                    // so we need to update the defaults.
                    postingReference = this.updatePostingReference(postingReference, ledgerJournalTrans, _request.sysModule);

                    // Adds the voucher and requests to save the budget source for checking budget funds availability later.
                    LedgerJournalCheckPostBudget::addBudgetCheckVoucher(
                        this,
                        ledgerJournalTrans.Voucher,
                        postingReference,
                        false);

                    numOfVouchersBooked++;
                }

                // <GCN>
                if (LedgerParameters::isChineseVoucher_CN()
                    && postingReference)
                {
                    postingReference.parmVoucher_CN(ledgerJournalTrans.Voucher_CN);
                    postingReference.parmLedgerVoucherType_CN(ledgerJournalTrans.LedgerVoucherType_CN);
                }
                // </GCN>

                this.movePostedTaxes(ledgerJournalTrans);

                // Verify that an approval journal voucher has no pending invoices
                if (ledgerJournalTable.JournalType == LedgerJournalType::Approval)
                {
                    if (ledgerJournalTrans.Cancel)
                    {
                        allOK = allOK && this.cancelApprovalJournal(ledgerJournalTrans);
                    }
                    else if (ledgerJournalTrans.hasPendingInvoice())
                    {
                        // Prevent the voucher from posting
                        allOK = ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS110664", ledgerJournalTrans.Voucher));
                        this.insertInVoucherErrorList(ledgerJournalTrans.Voucher);
                    }
                }
                
                // <GEERU>
                ledgerBondClient = postingReference.ledgerBondClient_RU();
                // </GEERU>
                mainAccountTypeForCurrentVoucher = ledgerJournalTrans.displayMainAccountType();
            }
            else
            {
                // Update the correction property of the Voucher for the new ledgerJournalTrans.
                postingReference.parmCorrection(ledgerJournalTrans.correct());
                ok = true;
            }

            postingReference.parmSourceTableIdDefault(tableNum(LedgerJournalTrans));
            postingReference.parmSourceRecIdDefault(ledgerJournalTrans.RecId);

            // <GEERU>
            if (_request.countryRegion_RU && !transDateFailed)
            {
                oldTransDate_RU = ledgerJournalTrans.TransDate;
            }
            // </GEERU>

            // Initialize the cache for the main account type.
            ledgerJournalTrans.MainAccountType = [mainAccountTypeForCurrentVoucher];

            // save any taxworkregulation records for use by the offsetting intercompany record
            if (isOffsetCompanyIntercompany || isCompanyIntercompany)
            {
                taxWorkRegulationList = TaxWorkRegulation::loadTaxWorkRegulationList(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId);
            }
            ledgerVoucher = this.initLedgerVoucherFromLedgerJournalTrans(ledgerJournalTrans);
            boolean swappedAcToPostTaxedFirst = this.postTaxedFirst(ledgerJournalTrans);   //Solves error request: FR-791-871-SLX4

            // <GEERU>
            if (_request.countryRegion_RU)
            {
                postingReference.parmPostingLayer(ledgerJournalTrans.operationTax_RU());
            }
            // </GEERU>

            // start with account, it will be switched to offset account at the end of the loop or the loop will end
            // if the accounts were swapped above then the office account will be posted first.
            boolean isOffset = swappedAcToPostTaxedFirst;

            allOK = allOK && this.validateTransactionBeforePosting(ledgerJournalTrans);

            this.postJournalPostTransStarting(this, ledgerJournalTrans, ok, allOK);

            System.Diagnostics.Stopwatch postJournalLineStopWatch = perfMonitor.startNewStopwatch();

            boolean isCollectionStatusUpdatedForJournal;

            while (ledgerJournalTrans.LedgerDimension || ledgerJournalTrans.AmountCurDebit || ledgerJournalTrans.AmountCurCredit)
            {
                if (ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister
                    && ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Ledger
                    && PaymTerm::isCashAccount(ledgerJournalTrans.Payment))
                {
                    ledgerVoucher.findReference(ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate, ledgerVoucher.lastPostingLayer());
                }

                if (!this.postTransV2(
                                    ledgerVoucher,
                                    ledgerJournalTrans,
                                    originalLedgerJournalTrans,
                                    exchRateForAccountCompany,
                                    exchRateSecondaryForAccountCompany,
                                    euroTriangulationForAccountCompany,
                                    reportingCurrencyExchRateForAccountCompany,
                                    reportingCurrencyExchRateSecondaryForAccountCompany,
                                    exchRateForCurrentCompany,
                                    exchRateSecondaryForCurrentCompany,
                                    euroTriangulationForCurrentCompany,
                                    reportingCurrencyExchRateForCurrentCompany,
                                    reportingCurrencyExchRateSecondaryForCurrentCompany,
                                    hasOffsetAccount,
                                    false,
                                    isOffset,
                                    journalHasAccruals,
                                    oldCurrencyCode,
                                    anyReversalsExistForJournal,
                                    ledgerPostingMessageCollection))
                {
                    ok = false;
                    allOK = false;
                    this.insertInVoucherErrorList(ledgerJournalTrans.Voucher);
                    this.updateTransInfoLog(ledgerJournalTrans);
                }
                else
                {
                    if (ledgerJournalTrans.PoolRecId &&
                        ledgerJournalTrans.AccountType == LedgerJournalACType::Vend &&
                        ledgerJournalTrans.Company == currentCompany)
                    {
                        LedgerJournalTrans::findRecId(ledgerJournalTrans.PoolRecId, true).delete();
                        ledgerJournalTrans.PoolRecId = 0;
                    }
                }

                // <GEERU>
                if (ok
                    && ledgerBondClient
                    && ledgerJournalTrans.orig().parmOffsetAccount()
                    && ! ledgerJournalTrans.parmOffsetAccount())
                {
                    LedgerJournalCheckPost_RU::bondJournalVoucher(ledgerBondClient, ledgerVoucher);
                }

                // </GEERU>
                // <GIN>
                if (this.shouldSetInterCompanyWitholdingTax_IN(ledgerJournalTrans, _request.taxWithholdParameterMarked) && TaxWithholdParameters_IN::findByCompany(curext()).CrossCompanyPayment)
                {
                    interCmpWithholdingTaxAmount = ledgerVoucher.parmAdvancePaymentWHT_IN();
                }
                // </GIN>

                // If this is a French derogatory tax value model we don't post the GL transactions.
                if (LedgerJournalCheckPost_FR::isDerogatoryTaxJournal(ledgerJournalTrans))
                {
                    break;
                }

                if (TaxParameters::canApplyCashDiscOnInvoice_ES() &&
                    ledgerJournalTrans.CashDiscAmount != 0 &&
                    (ledgerJournalTable.JournalType == LedgerJournalType::Daily ||
                    ledgerJournalTable.JournalType  == LedgerJournalType::VendInvoiceRegister))
                {
                    LedgerJournalCheckPostCash::cashDiscAddTrans_ES(ledgerVoucher, ledgerJournalTrans, ledgerPostingMessageCollection);
                }

                ledgerJournalTrans = this.ledgerJournalTransOffset(ledgerJournalTrans, swappedAcToPostTaxedFirst);

                isOffset = !isOffset;
            }

            this.postJournalPostTransEnded(this, ledgerJournalTrans, ok, allOK);

            perfMonitor.trackJournalLine(ledgerJournalTrans, postJournalLineStopWatch.ElapsedMilliseconds);

            if (ok && journalHasBankFees)
            {
                LedgerJournalCheckPostBank::bankFeeListWrite(this, ledgerJournalTrans.RecId);
            }

            if (ok)
            {
                LedgerJournalCheckPostBank::updateBankLC(isLetterOfCreditEnabled, ledgerJournalTrans);
            }

            if (ok && journalHasCustDispute && !isCollectionStatusUpdatedForJournal)
            {
                if (CustDisputeUpdateCollectionStatusPerLedgerJournalTransFlight::instance().isEnabled())
                {
                    if (ledgerJournalTrans.TransactionType == LedgerTransType::Payment)
                    {
                        CustDisputeHistoryAutomationPayment::updateCollectionsStatusForPaymentJournalLine(ledgerJournalTrans);
                    }
                }
                else
                {
                    //isCollectionStatusUpdatedForJournal variable is not required as it is declared within loop and is set for each iteration 
                    CustDisputeHistoryAutomationPayment::updateCollectionsStatusForPaymentJournal(ledgerJournalTrans.JournalNum);
                    isCollectionStatusUpdatedForJournal = true;
                }
    
            }

            EventHandlerResult eventHandlerResult = new EventHandlerResult();
            this.postJournalIterateJournalLinesEndedWithEventHandlerResultDelegate(
                this,
                ledgerJournalTrans,
                ok,
                allOK,
                eventHandlerResult);

            if (eventHandlerResult.hasResult())
            {
                allOK = eventHandlerResult.result() && allOK;
            }

            this.postJournalIterateJournalLinesEnded(this, ledgerJournalTrans, ok, allOK);
            this.settleConditionalTax(ledgerJournalTrans, ledgerJournalTable);
        }

        if (oldVoucher && !voucherContainsCurrentCompany)
        {
            allOK = this.logCompanyNotInVoucherError(oldVoucher, ledgerPostingMessageCollection);
        }

        if (!first)
        {
            if (allOK)
            {
                allOK = LedgerJournalCheckPostBank::bankFeeListTransfer(this);
            }

            if (canAddPayrollDisbursementEntries)
            {
                // Payroll disbursements for bank transaction type posting definitions are required for a Payroll journal.
                LedgerJournalCheckPostJournalizing::addPayrollDisbursementEntries(payrollDisbursementjournalizingDefinitionManagerBank, ledgerVoucher);
            }

            if (allOK &&  _request.ledgerJournalTransRecIdsByDeduction != null)
            {
                LedgerJournalCheckPostSales::tamUpdateDeductionsAfterPost(ledgerJournalId, _request.ledgerJournalTransRecIdsByDeduction);
            }

            LedgerJournalTransFieldCache ledgerJournalTransFieldCache = new LedgerJournalTransFieldCache();
            ledgerJournalTransFieldCache.parmCurrencyCode(oldCurrencyCode);
            ledgerJournalTransFieldCache.parmInvoice(oldinvoice);
            ledgerJournalTransFieldCache.parmTransDate(oldTransDate);
            ledgerJournalTransFieldCache.parmVoucher(oldVoucher);

            voucherMap.insert(oldVoucher, ledgerJournalTransFieldCache);

            MapEnumerator voucherMapEnumerator = voucherMap.getEnumerator();
            while (voucherMapEnumerator.moveNext())
            {
                ledgerJournalTransFieldCache = voucherMapEnumerator.currentValue();

                setPrefix(strFmt("@SYS25866", ledgerJournalTransFieldCache.parmVoucher()));

                if (allOK)
                {
                    // Check for voucher for "One voucher" requirements if parameter is enabled (API provides check)
                    allOK = this.checkMultipleTransactionsWithinOneVoucher(ledgerJournalTable.JournalNum, ledgerJournalTransFieldCache.parmVoucher(), ledgerPostingMessageCollection);
                }

                this.deleteFromPool(ledgerJournalTransFieldCache.parmVoucher(), ledgerJournalTransFieldCache.parmInvoice());
                if (taxVoucherService)
                {
                    // post sales tax in case of no offset account
                    taxVoucherService.postTaxOnErrorAccount(ledgerVoucher, ledgerJournalTransFieldCache.parmVoucher(), ledgerJournalTransFieldCache.parmCurrencyCode(),ledgerJournalTransFieldCache.parmTransDate());
                }

                // <GEERU>
                if (ledgerBondClient)
                {
                    LedgerJournalCheckPost_RU::bondJournalVoucher(ledgerBondClient, ledgerVoucher);
                }
                // </GEERU>

                if (!ledgerVoucher.checkVoucher(ledgerJournalTransFieldCache.parmVoucher(), ledgerJournalTransFieldCache.parmTransDate(), ledgerJournalTable.CurrentOperationsTax))
                {
                    allOK = false;
                    this.insertInVoucherErrorList(ledgerJournalTransFieldCache.parmVoucher());
                }
            }

            isLedgerVoucherPosted = ledgerVoucher.end();

            // <GCN>
            if (postProforma && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCN]))
            {
                LedgerVoucherPostProforma_CN ledgerVoucherPostProforma = ledgerVoucher as LedgerVoucherPostProforma_CN;
                mapJournalEntry = ledgerVoucherPostProforma.parmJournalEntryMap();
            }
            // </GCN>
        }

        LedgerJournalCheckPost_PostLinesResult postResult = new LedgerJournalCheckPost_PostLinesResult();
        postResult.allOK = allOK;
        postResult.voucherMap = voucherMap;
        return postResult;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>