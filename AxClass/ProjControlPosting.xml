<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjControlPosting</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class ProjControlPosting extends RunBaseBatch
{
    #OCCRetryCount

    ProjId                  projId;
    ProjControlId           controlId;
    ProjPeriodFrom          periodFrom;
    ProjPeriodTo            periodTo;
    ProjControlVersion      projControlVersion;

    boolean                 showQueryValues;
    boolean isContractLineUsed;

    [FormObservable]
    ProjPeriodId            periodId;
    NoYes                   outputInfolog;
    ProjControlTypeOutput   outputResult;

    TransDate               transDate;
    DialogField             fieldTransDate;

    QueryRun                queryRun;

    Counter                 i;
    boolean                 periodic;
    ProjGroup               projGroup;
    AcknowledgementDate     acknowledgementDate;

    NoYes                   postWarnings;
    ProjBeginningBalance    beginningBalance;

    ProjParameters          projParameters;

    str                     selectedRecIds;
    ProjRevenueProfile projRevProfile;

    [SysObsolete("This variable is obsolete. Use projContractCurrencyForRevRecParmEnabled instead.", false, 10\6\2024)]
    boolean contractCurrencyRevRecCalculationFeature = ProjContractCurrencyForRevRecCalculationFeature::isEnabled();

    private boolean isMultipleContractLineFeatureEnabled = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();
    boolean contractLineBasedRevRecFeature = ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled();
    private boolean projContractCurrencyForRevRecParmEnabled = ProjParameters::find().EnableContractCurrencyForRevRec;
    private boolean defaultDimensionRuleFeature = ProjFeatureStateHelper::isProjDefaultDimensionRuleFeatureEnabled();
    private ProjRevRecInstrumentationLogger logger;
    private RecId projWIPTableRecId;
    private const str LoggerRetryExceptionMsg = '%1 retries exceeded max limit for %2 method. ProjWIPTable: %3';
    private NoYes usePriorPeriodEndDate;
    
    #define.CurrentVersion(13)
    #define.Version12(12)

    #localmacro.CurrentListV12
        projId,
        controlId,
        periodFrom,
        projControlversion,
        periodic,
        transDate,
        periodId,
        outputInfolog,
        outputResult,
        periodTo,
        showQueryValues,
        acknowledgementDate,
        beginningBalance,
        selectedRecIds
    #endmacro

    #localmacro.CurrentList
        #CurrentListV12,
        usePriorPeriodEndDate
    #endmacro
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkCreateRevenueTrans</Name>
				<Source><![CDATA[
    public boolean checkCreateRevenueTrans()
    {
        if (this.getCompletePrinciple() == ProjCompletePrincip::CompletedContract)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostOnAccCompletePrincip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements checking of complete principle for <c>ProjControlPosting::checkPostOnAcc</c>.
    /// </summary>
    /// <param name="_completePrincip">Value of complete principle.</param>
    /// <returns>true if the check succeeds; otherwise, false</returns>
    [Replaceable]
    protected boolean checkPostOnAccCompletePrincip(ProjCompletePrincip _completePrincip)
    {
        return _completePrincip == ProjCompletePrincip::CompletedPercentage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostOnAcc</Name>
				<Source><![CDATA[
    public boolean checkPostOnAcc()
    {
        if (this.getInvoicePosting()  == ProjLedgerStatusOnAcc::BalanceSheet)
        {
            return false;
        }

        if (this.getInvoicePosting()  == ProjLedgerStatusOnAcc::Operations &&
            this.getMatchingPrinciple() == ProjMatchingPrincip::SalesValue   &&
            this.checkPostOnAccCompletePrincip(this.getCompletePrinciple()))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostRevenueReverse</Name>
				<Source><![CDATA[
    public boolean checkPostRevenueReverse()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createControlTransProcessByMatchingPrincipExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements <c>createControlTrans::Process</c> for extended <c>ProjMatchingPrincip</c> values.
    /// </summary>
    /// <param name = "_matchingPrincip">Extended value of matching principle.</param>
    /// <param name = "_funcName">Name of the calling function (used to error handling).</param>
    /// <param name = "_projControlPeriod"><c>ProjControlPeriod</c> value.</param>
    /// <param name = "_projTrans"><c>ProjTrans</c> object being processed.</param>
    /// <returns>A container consisting of [<c>ProjWIPAmount</c> (wipAccruedTurnover), <c>ProjWIPAmount</c> (wipAccruedTurnoverProd), <c>ProjWIPAmount</c> (wipAccruedTurnoverProfit)]</returns>
    [Replaceable]
    protected container createControlTransProcessByMatchingPrincipExt(
        ProjMatchingPrincip _matchingPrincip,
        str _funcName,
        ProjControlPeriodTable _projControlPeriod,
        ProjTrans _projTrans)
    {
        throw error(strFmt("@SYS22828",funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createControlTransProcessFeeByMatchingPrincipExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements <c>createControlTrans::ProcessFee</c> for extended <c>ProjMatchingPrincip</c> values.
    /// </summary>
    /// <param name = "_matchingPrincip">Extended value of matching principle.</param>
    /// <param name = "_wipAccruedTurnover"><c>AccuredTurnover</c> amount.</param>
    /// <param name = "_wipAccruedTurnoverProd"><c>AccruedTurnoverProd</c> amount.</param>
    /// <param name = "_wipAccruedTurnoverProfit"><c>AccruedTurnoverProfit</c> amount.</param>
    [Replaceable]
    protected void createControlTransProcessFeeByMatchingPrincipExt(
        ProjMatchingPrincip _matchingPrincip,
        ProjWIPAmount _wipAccruedTurnover,
        ProjWIPAmount _wipAccruedTurnoverProd,
        ProjWIPAmount _wipAccruedTurnoverProfit)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createControlTrans</Name>
				<Source><![CDATA[
    protected void createControlTrans(ProjControlPeriodTable _projControlPeriod)
    {
        ProjWIPAmount totalWIPAccruedTurnover = 0;
        ProjWIPAmount totalWIPAccruedTurnoverProd = _projControlPeriod.WIPAccruedTurnoverProd;
        ProjWIPAmount totalWIPAccruedTurnoverProfit = _projControlPeriod.WIPAccruedTurnoverProfit;
        ProjTable projTableLoc;

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            PSAContractLineItems contractLine;
            ProjRevRecContractLine projRevRecContractLine;
            PSAContractLineItemsSetup contractLineAssoc;
           
            projTableLoc = ProjTable::find(ProjWIPTable::getProjIdForRevenuePosting(_projControlPeriod.ProjId));
        }
        else
        {
            projTableLoc = ProjTable::find(_projControlPeriod.ProjId);
        }
        
        // Convert amounts to accounting currency if enable project contract currency for estimate calculation feature is enabled and
        // if project is fixed price project
        // or enable multiple contract lines for a project feature is enabled and project contract billing method is fixed price.
        
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            if (projContractCurrencyForRevRecParmEnabled)
            {
                // Calculate total accounting currency amount for posting estimate.
                ProjOnAccTrans projOnAccTrans;
                ProjOnAccTransSale projOnAccTransSale;
                ProjRevRecContractLine projRevRecContractLine;
                while select projOnAccTrans
                    join projOnAccTransSale
                        where projOnAccTransSale.TransId == projOnAccTrans.TransId
                        && projOnAccTransSale.TransStatus != ProjTransStatus::Adjusted
                    exists join projRevRecContractLine
                        where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId
                            && projRevRecContractLine.ContractLineNum == projOnAccTrans.PSAContractLineNum
                {
                    ProjInvoiceOnAcc projInvoiceOnAcc;
                    ProjInvoiceOnAccDetail projInvoiceOnAccDetail;
                    select sum(AmountMST) from projInvoiceOnAccDetail
                    where projInvoiceOnAccDetail.SaleRefRecId == projOnAccTransSale.RecId
                        && projInvoiceOnAccDetail.wipPeriod == this.parmPeriodTo()
                    exists join projInvoiceOnAcc
                        where projInvoiceOnAcc.RecId == projInvoiceOnAccDetail.InvoiceRefRecId;
                    if (projInvoiceOnAccDetail.AmountMST)
                    {
                        totalWIPAccruedTurnover += projInvoiceOnAccDetail.AmountMST;
                    }
                    else
                    {
                        ProjTrans projTrans = ProjTrans::newProjOnAccTransSale(projOnAccTrans, projOnAccTransSale);

                        totalWIPAccruedTurnover += projTrans.transTurnoverMST();
                    }
                }
            
                CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_projControlPeriod.company()).RecId), _projControlPeriod.PeriodTo);
                CurrencyCode currencyCode = ProjInvoiceTable::find(PSAContractLineItems::find(projRevRecContractLine.ContractLineNum).ProjInvoiceProjId).CurrencyId;
                if (totalWIPAccruedTurnoverProd)
                {
                    totalWIPAccruedTurnoverProd = currencyExchangeHelper.calculateTransactionToAccounting(currencyCode, totalWIPAccruedTurnoverProd, true);
                }

                if (totalWIPAccruedTurnoverProfit)
                {
                    totalWIPAccruedTurnoverProfit = currencyExchangeHelper.calculateTransactionToAccounting(currencyCode, totalWIPAccruedTurnoverProfit, true);
                }
            }
            else
            {
                totalWIPAccruedTurnover = _projControlPeriod.wipAccruedTurnover;
            }
        }
        else if (projContractCurrencyForRevRecParmEnabled
            && (projTableLoc.Type == ProjType::FixedPrice
            || (isMultipleContractLineFeatureEnabled
            && ProjMultipleContractLinesForProjectFeatureHelper::existContractLineForBillingMethod(projTableLoc.ProjId, projTableLoc.ProjInvoiceProjId, ProjContractBillingMethod::FixedPrice))))
        {
            // Calculate total accounting currency amount for posting estimate.
            ProjTable projTable;
            ProjOnAccTrans projOnAccTrans;
            ProjOnAccTransSale projOnAccTransSale;
            while select projOnAccTrans
                    join projOnAccTransSale
                        where projOnAccTransSale.TransId == projOnAccTrans.TransId
                        && projOnAccTransSale.TransStatus != ProjTransStatus::Adjusted
                    exists join projTable
                        where projTable.ProjId == projOnAccTrans.ProjID
                            && projTable.WIPProject == _projControlPeriod.ProjId
            {
                ProjInvoiceOnAcc projInvoiceOnAcc;
                ProjInvoiceOnAccDetail projInvoiceOnAccDetail;
                select sum(AmountMST) from projInvoiceOnAccDetail
                    where projInvoiceOnAccDetail.SaleRefRecId == projOnAccTransSale.RecId
                        && projInvoiceOnAccDetail.wipPeriod == this.parmPeriodTo()
                    exists join projInvoiceOnAcc
                        where projInvoiceOnAcc.RecId == projInvoiceOnAccDetail.InvoiceRefRecId;
                if (projInvoiceOnAccDetail.AmountMST)
                {
                    totalWIPAccruedTurnover += projInvoiceOnAccDetail.AmountMST;
                }
                else
                {
                    ProjTrans projTrans = ProjTrans::newProjOnAccTransSale(projOnAccTrans, projOnAccTransSale);

                    totalWIPAccruedTurnover += projTrans.transTurnoverMST();
                }
            }
            
            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_projControlPeriod.company()).RecId), _projControlPeriod.PeriodTo);

            if (totalWIPAccruedTurnoverProd)
            {
                totalWIPAccruedTurnoverProd = currencyExchangeHelper.calculateTransactionToAccounting(projTableLoc.contractCurrCode(), totalWIPAccruedTurnoverProd, true);
            }

            if (totalWIPAccruedTurnoverProfit)
            {
                totalWIPAccruedTurnoverProfit = currencyExchangeHelper.calculateTransactionToAccounting(projTableLoc.contractCurrCode(), totalWIPAccruedTurnoverProfit, true);
            }
        }
        else
        {
            totalWIPAccruedTurnover = _projControlPeriod.wipAccruedTurnover;
        }

        void process(ProjTrans _projTrans)
        {
            ProjWIPAmount           wipAccruedTurnover;
            ProjWIPAmount           wipAccruedTurnoverProd;
            ProjWIPAmount           wipAccruedTurnoverProfit;

            switch (this.getMatchingPrinciple())
            {
                case ProjMatchingPrincip::SalesValue:
                    wipAccruedTurnover = this.processSalesValue(_projControlPeriod, _projTrans);
                    break;

                case ProjMatchingPrincip::ProductionProfit:
                    [wipAccruedTurnoverProd,  wipAccruedTurnoverProfit] = this.processProductionProfit(_projControlPeriod, _projTrans);
                    break;

                default:
                    [wipAccruedTurnover, wipAccruedTurnoverProd, wipAccruedTurnoverProfit] = this.createControlTransProcessByMatchingPrincipExt(
                        this.getMatchingPrinciple(),
                        funcName(),
                        _projControlPeriod,
                        _projTrans);
            }

            if (wipAccruedTurnover)
            {
                totalWIPAccruedTurnover -= wipAccruedTurnover;

                this.insertControlTrans(
                    _projControlPeriod,
                    ProjWIPType::AccruedTurnover,
                    wipAccruedTurnover,
                    _projTrans.transId(),
                    this.transType(_projTrans),
                    _projTrans.recId());
            }

            if (wipAccruedTurnoverProd)
            {
                totalWIPAccruedTurnoverProd -= wipAccruedTurnoverProd;

                this.insertControlTrans(
                    _projControlPeriod,
                    ProjWIPType::AccruedTurnoverProd,
                    wipAccruedTurnoverProd,
                    _projTrans.transId(),
                    this.transType(_projTrans),
                    _projTrans.recId());
            }

            if (wipAccruedTurnoverProfit)
            {
                totalWIPAccruedTurnoverProfit -= wipAccruedTurnoverProfit;

                this.insertControlTrans(
                    _projControlPeriod,
                    ProjWIPType::AccruedTurnoverProfit,
                    wipAccruedTurnoverProfit,
                    _projTrans.transId(),
                    this.transType(_projTrans),
                    _projTrans.recId());
            }
        }

        void processHour()
        {
            ProjEmplTrans           projEmplTrans;
            ProjEmplTransCost       projEmplTransCost;
            ProjTrans               projTrans;
            ProjTable               projTable;
            PSAIndirectComponentTrans   psaIndirectComponentTrans;
            ProjRevRecContractLine projRevRecContractLine;

            if(isContractLineUsed && contractLineBasedRevRecFeature)
            {
                while select forupdate projEmplTrans
                join forupdate projEmplTransCost
                    where projEmplTransCost.TransId == projEmplTrans.TransId &&
                        projEmplTransCost.TransStatus == ProjTransStatus::Estimated &&
                        projEmplTransCost.wipPeriod <= _projControlPeriod.PeriodTo
               exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId
                && projRevRecContractLine.ContractLineNum == projEmplTrans.PSAContractLineNum
                {
                    while select psaIndirectComponentTrans
                    where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                        psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                        psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                    {
                        projTrans = ProjTrans::newProjEmplTransIndirectCost(projEmplTrans, projEmplTransCost, psaIndirectComponentTrans);
                        process(projTrans);
                    }

                    projTrans = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
                    process(projTrans);
                }
            }
            else
            {
                while select forupdate projEmplTrans
                join projTable
                    where projEmplTrans.ProjId == projTable.ProjId &&
                    projTable.WIPProject == _projControlPeriod.ProjId
            join forupdate projEmplTransCost
                where projEmplTransCost.TransId == projEmplTrans.TransId &&
                    projEmplTransCost.TransStatus == ProjTransStatus::Estimated &&
                    projEmplTransCost.wipPeriod <= _projControlPeriod.PeriodTo
                {
                    while select psaIndirectComponentTrans
                    where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                        psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                        psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                    {
                        projTrans = ProjTrans::newProjEmplTransIndirectCost(projEmplTrans, projEmplTransCost, psaIndirectComponentTrans);
                        process(projTrans);
                    }

                    projTrans = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
                    process(projTrans);
                }
            }
        }

        void processExpense()
        {
            ProjCostTrans           projCostTrans;
            ProjCostTransCost       projCostTransCost;
            ProjTrans               projTrans;
            ProjTable               projTable;
            ProjRevRecContractLine projRevRecContractLine;

            if(isContractLineUsed && contractLineBasedRevRecFeature)
            {
                while select forupdate projCostTrans
                      join forupdate projCostTransCost
                        where projCostTransCost.TransId == projCostTrans.TransId &&
                              projCostTransCost.TransStatus == ProjTransStatus::Estimated &&
                              projCostTransCost.wipPeriod <= _projControlPeriod.PeriodTo
                    exists join projRevRecContractLine
                    where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId
                    && projRevRecContractLine.ContractLineNum == projCostTrans.PSAContractLineNum
                {
                    projTrans = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
                    process(projTrans);
                }
            }
            else
            {
                while select forupdate projCostTrans
                join projTable
                    where projCostTrans.ProjId == projTable.ProjId &&
                          projTable.WIPProject == _projControlPeriod.ProjId
                      join forupdate projCostTransCost
                        where projCostTransCost.TransId == projCostTrans.TransId &&
                              projCostTransCost.TransStatus == ProjTransStatus::Estimated &&
                              projCostTransCost.wipPeriod <= _projControlPeriod.PeriodTo
                {
                    projTrans = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
                    process(projTrans);
                }
            }
        }

        void processItem()
        {
            ProjItemTrans           projItemTrans;
            ProjItemTransCost       projItemTransCost;
            ProjTrans               projTrans;
            ProjTable               projTable;
            ProjRevRecContractLine projRevRecContractLine;

            if(isContractLineUsed && contractLineBasedRevRecFeature)
            {
                while select forupdate projItemTrans
                      join forupdate projItemTransCost
                        where projItemTransCost.InventTransId == projItemTrans.InventTransId &&
                              projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId &&
                              projItemTransCost.TransStatus == ProjTransStatus::Estimated &&
                              projItemTransCost.wipPeriod <= _projControlPeriod.PeriodTo
                    exists join projRevRecContractLine
                    where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId
                    && projRevRecContractLine.ContractLineNum == projItemTrans.PSAContractLineNum
                {
                    projTrans = ProjTrans::newProjItemTransCost(projItemTransCost);
                    process(projTrans);
                }
            }
            else
            {

                while select forupdate projItemTrans
                 join projTable
                    where projItemTrans.ProjId == projTable.ProjId &&
                          projTable.WIPProject == _projControlPeriod.ProjId
                      join forupdate projItemTransCost
                        where projItemTransCost.InventTransId == projItemTrans.InventTransId &&
                              projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId &&
                              projItemTransCost.TransStatus == ProjTransStatus::Estimated &&
                              projItemTransCost.wipPeriod <= _projControlPeriod.PeriodTo
                {
                    projTrans = ProjTrans::newProjItemTransCost(projItemTransCost);
                    process(projTrans);
                }
            }
        }

        void processFee(ProjWIPAmount _wipAccruedTurnover, ProjWIPAmount _wipAccruedTurnoverProd, ProjWIPAmount _wipAccruedTurnoverProfit)
        {
            switch (this.getMatchingPrinciple())
            {
                case  ProjMatchingPrincip::SalesValue:
                    if (_wipAccruedTurnover)
                    {
                        this.insertControlTrans(_projControlPeriod,ProjWIPType::AccruedTurnover,_wipAccruedTurnover);
                    }
                    break;

                case  ProjMatchingPrincip::ProductionProfit:
                    if (_wipAccruedTurnoverProd)
                    {
                        this.insertControlTrans(_projControlPeriod,ProjWIPType::AccruedTurnoverProd,_wipAccruedTurnoverProd);
                    }
                    if (_wipAccruedTurnoverProfit)
                    {
                        this.insertControlTrans(_projControlPeriod,ProjWIPType::AccruedTurnoverProfit,_wipAccruedTurnoverProfit);
                    }
                    break;

                default:
                    this.createControlTransProcessFeeByMatchingPrincipExt(this.getMatchingPrinciple(), _wipAccruedTurnover, _wipAccruedTurnoverProd, _wipAccruedTurnoverProfit);
            }
        }

        if (this.getSalesPriceMatchingPrinciple() == ProjSalesPriceMatchingPrincip::None)
        {
            ProjWIPAmount wipAccruedTurnover;
            ProjWIPAmount wipAccruedTurnoverProd = _projControlPeriod.WIPAccruedTurnoverProd;
            ProjWIPAmount wipAccruedTurnoverProfit = _projControlPeriod.WIPAccruedTurnoverProfit;

            
            // Convert amounts to accounting currency if enable project contract currency for estimate calculation feature is enabled and
            // if project is fixed price project
            // or enable multiple contract lines for a project feature is enabled and project contract billing method is fixed price.
            if (projContractCurrencyForRevRecParmEnabled
                && ((isContractLineUsed && contractLineBasedRevRecFeature) || projTableLoc.Type == ProjType::FixedPrice
                || (isMultipleContractLineFeatureEnabled
                && ProjMultipleContractLinesForProjectFeatureHelper::existContractLineForBillingMethod(projTableLoc.ProjId, projTableLoc.ProjInvoiceProjId, ProjContractBillingMethod::FixedPrice))))
            {
                CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                            Ledger::primaryLedger(CompanyInfo::findDataArea(_projControlPeriod.company()).RecId),
                            _projControlPeriod.PeriodTo);
               
                wipAccruedTurnover = currencyExchangeHelper.calculateTransactionToAccounting(projTableLoc.contractCurrCode(), _projControlPeriod.wipAccruedTurnover, true);
                
                if (wipAccruedTurnoverProd)
                {
                    wipAccruedTurnoverProd = currencyExchangeHelper.calculateTransactionToAccounting(projTableLoc.contractCurrCode(), wipAccruedTurnoverProd, true);
                }
                
                if (wipAccruedTurnoverProfit)
                {
                    wipAccruedTurnoverProfit = currencyExchangeHelper.calculateTransactionToAccounting(projTableLoc.contractCurrCode(), wipAccruedTurnoverProfit, true);
                }
            }
            else
            {
                wipAccruedTurnover = _projControlPeriod.WIPAccruedTurnover;
            }

            processFee(wipAccruedTurnover, wipAccruedTurnoverProd, wipAccruedTurnoverProfit);
        }
        else
        {
            processHour();
            processExpense();
            processItem();
            processFee(totalWIPAccruedTurnover, totalWIPAccruedTurnoverProd, totalWIPAccruedTurnoverProfit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCostTransInvestment</Name>
				<Source><![CDATA[
    public void createCostTransInvestment(
        ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher           _ledgerVoucher,
        NoYes                   _nonEstimatedPosting = NoYes::No,
        AmountCur               _nonEstimatedPostingAmount = 0.0)
    {
        LedgerJournalTrans          ledgerJournalTrans;
        LedgerJournalTrans_Project  ledgerJournalTrans_Project;
        ProjTable                   projTable   = ProjTable::find(_projControlPeriod.ProjIdNew);
        AmountCur                   amountToPost;

        if (_nonEstimatedPosting == NoYes::No)
        {
            amountToPost =  this.investmentEliminationAmount(_projControlPeriod);
        }
        else
        {
            amountToPost = _nonEstimatedPostingAmount;
        }

        // Set the base journal fields.
        ledgerJournalTrans.clear();
        ledgerJournalTrans.parmAccount(_projControlPeriod.ProjIdNew, LedgerJournalACType::Project);
        ledgerJournalTrans.TransDate                = _ledgerVoucher.lastTransDate();
        ledgerJournalTrans.Txt                      = _projControlPeriod.ProjId;
        ledgerJournalTrans.DefaultDimension         = projTable.DefaultDimension;
        ledgerJournalTrans.CurrencyCode             = Ledger::accountingCurrency(CompanyInfo::current());
        ledgerJournalTrans.insert();

        // Set the project specific journal fields.
        ledgerJournalTrans_Project.clear();
        ledgerJournalTrans_Project.RefRecId       = ledgerJournalTrans.RecId;
        ledgerJournalTrans_Project.ProjId         = ledgerJournalTrans.parmAccount();
        ledgerJournalTrans_Project.CategoryId     = _projControlPeriod.CategoryNew;
        ledgerJournalTrans_Project.ActivityNumber = _projControlPeriod.ActivityNew;
        ledgerJournalTrans_Project.LinePropertyId = _projControlPeriod.LinePropertyIdNew;
        ledgerJournalTrans_Project.SalesCurrencyId = ProjInvoiceTable::find(projTable.ProjInvoiceProjId).CurrencyId;
        ledgerJournalTrans_Project.ProjTransDate  = ledgerJournalTrans.TransDate;

        if (_projControlPeriod.QtyCostNew)
        {
            ledgerJournalTrans_Project.Qty = _projControlPeriod.QtyCostNew;
        }
        else
        {
            ledgerJournalTrans_Project.Qty = 1;
        }

        if (!ledgerJournalTrans_Project.SalesCurrencyId)
        {
            if (projTable.CustAccount)
            {
                ledgerJournalTrans_Project.SalesCurrencyId = CustTable::find(projTable.CustAccount).Currency;
            }
            else
            {
                ledgerJournalTrans_Project.SalesCurrencyId = CompanyInfoHelper::standardCurrency();
            }
        }

        boolean projRevRecEliminateToProjFlightEnabled = ProjRevRecEliminateToProjFlight::instance().isEnabled();
        CostPrice calculatedCostPrice = amountToPost / ledgerJournalTrans_Project.Qty;
        
        ledgerJournalTrans_Project.CostPrice  = projRevRecEliminateToProjFlightEnabled?
                                                    calculatedCostPrice: CurrencyExchangeHelper::price(calculatedCostPrice);

        ProjPriceParameters priceParams = ProjCostSalesPrice::constructPriceParametersForFindCostSalesPrice(
            ledgerJournalTrans_Project.ProjId,
            0,
            ledgerJournalTrans_Project.CategoryId,
            ledgerJournalTrans_Project.CostPrice,
            ledgerJournalTrans.CurrencyCode,
            ledgerJournalTrans_Project.SalesCurrencyId,
            ledgerJournalTrans.TransDate);
        [LedgerJournalTrans_Project.SalesPrice] = ProjCostSalesPrice::findCostSalesPriceByPriceParameters(priceParams);

        ledgerJournalTrans_Project.TaxGroupSales     = ProjParameters::taxGroupInvoice(ledgerJournalTrans_Project.ProjId);
        ledgerJournalTrans_Project.TaxItemGroupSales = ProjCategory::find(ledgerJournalTrans_Project.CategoryId).TaxItemGroupId;

        ledgerJournalTrans_Project.insert();

        this.postEstimateInvestment(ledgerJournalTrans,_ledgerVoucher);

        // We do not need to call delete on the project table as there is a cascading delete
        // setup on the LedgerJournalTrans.
        ledgerJournalTrans.delete(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doAction</Name>
				<Source><![CDATA[
    public boolean doAction(ProjControlPeriodTable _projControlPeriodTable)
    {
        return (select firstonly projWIPTable
                    where   projWIPTable.ProjId         == _projControlPeriodTable.ProjId
                    &&      projWIPTable.wipEliminated  == NoYes::No).RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareLedgerVoucherTransObjectForLedgerPosting</Name>
				<Source><![CDATA[
    internal LedgerVoucherTransObject prepareLedgerVoucherTransObjectForLedgerPosting(
        ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher           _ledgerVoucher,
        CurrencyExchangeHelper  _exchangeRateHelper,
        AmountCur               _amountToPost)
    {
        // need to merge the default account with the default dimensions
        LedgerDimensionAccount mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_projControlPeriod.LedgerDimension, _projControlPeriod.projTable().DefaultDimension);
        //  ledgerTrans
        CurrencyCode accountingCurrency = Ledger::accountingCurrency(CompanyInfo::current());
        AmountCur roundedAmount = CurrencyExchange::round(_amountToPost, accountingCurrency);

        LedgerVoucherTransObject  ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                             _ledgerVoucher.findLedgerVoucherObject(),
                             LedgerPostingType::ProjCost,
                             mergedLedgerDimension,
                             accountingCurrency,
                             roundedAmount,
                             _exchangeRateHelper);
        ledgerVoucherTransObject.parmSourceTableId(_projControlPeriod.TableId);
        ledgerVoucherTransObject.parmSourceRecId(_projControlPeriod.RecId);
        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>eliminateInvestment</Name>
				<Source><![CDATA[
    public void eliminateInvestment(
        ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher           _ledgerVoucher,
        NoYes                   _nonEstimatedPosting = NoYes::No,
        AmountCur               _nonEstimatedPostingAmount = 0.0)
    {
        AmountCur   amountToPost;
        ProjTable   projTable;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        AssetPost assetPost;
        CurrencyExchangeHelper exchangeRateHelper;

        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
                    Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                    _ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());
        exchangeRateHelper.parmExchangeRate1(0);
        exchangeRateHelper.parmExchangeRate2(0);

        if (_nonEstimatedPosting == NoYes::No)
        {
            amountToPost =  this.investmentEliminationAmount(_projControlPeriod);
        }
        else
        {
            amountToPost = _nonEstimatedPostingAmount;
        }

        switch (_projControlPeriod.EstimateOutput)
        {
            //      post to a ledgerAccount
            case ProjEstimateOutput::Ledger:
                
                ledgerVoucherTransObject = this.prepareLedgerVoucherTransObjectForLedgerPosting(_projControlPeriod, _ledgerVoucher, exchangeRateHelper, amountToPost);
                _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                break;

            //      create a new asset
            case ProjEstimateOutput::Asset:
                assetPost = AssetPost::newProjEstimate(_ledgerVoucher, _projControlPeriod, amountToPost);
                if (this.isReversal() || assetPost.check())
                {
                    assetpost.post(true);

                    projTable = ProjTable::find(_projControlPeriod.ProjId, true);
                    if (projTable)
                    {
                        projTable.AssetId = _projControlPeriod.AssetIdNew;
                        projTable.update();
                    }
                }
                else
                {
                    throw error("@SYS21628");
                }
                break;
            //      create a cost transaction
            case ProjEstimateOutput::Project:
                this.createCostTransInvestment(_projControlPeriod,_ledgerVoucher, _nonEstimatedPosting, _nonEstimatedPostingAmount);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>elimination</Name>
				<Source><![CDATA[
    public boolean elimination()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        boolean ret;

        ret = super();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryValues</Name>
				<Source><![CDATA[
    public container getQueryValues()
    {
        QueryRun                tmpQueryRun;
        Query                   tmpQuery;
        QueryBuildDataSource    tmpQueryBuildDataSource;
        QueryBuildRange         tmpQueryBuildRange;
        QueryBuildRange         tmpQueryBuildRangeProjPeriodId;
        ProjId                  projIdRangeValue            = '';
        ProjPeriodId            projPeriodIdRangeValue      = '';

        if (this.queryRun())
        {
            tmpQueryRun = this.queryRun();

            if (tmpQueryRun)
            {
                tmpQuery = this.queryRun().query();

                if (tmpQuery.dataSourceTable(tableNum(ProjWIPTable)))
                {
                    tmpQueryBuildDataSource = tmpQuery.dataSourceTable(tableNum(ProjWIPTable));

                    if (tmpQueryBuildDataSource.findRange(fieldNum(ProjWIPTable,ProjId)))
                    {
                        tmpQueryBuildRange = tmpQueryBuildDataSource.findRange(fieldNum(ProjWIPTable,ProjId));
                        projIdRangeValue = tmpQueryBuildRange.value();
                    }

                    if (tmpQueryBuildDataSource.findRange(fieldNum(ProjWIPTable,PeriodId)))
                    {
                        tmpQueryBuildRangeProjPeriodId = tmpQueryBuildDataSource.findRange(fieldNum(ProjWIPTable,PeriodId));
                        projPeriodIdRangeValue = tmpQueryBuildRangeProjPeriodId.value();
                    }
                }
            }
        }

        return [projIdRangeValue,projPeriodIdRangeValue];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the internal variables.
    /// </summary>
    /// <remarks>
    /// This method is called when no <c>SysLastValue</c> record can be found when calling the
    /// <c>SysLastValue.GetLast</c> method. Remember to call the <c>super</c> method.
    /// </remarks>
    public void initParmDefault()
    {
        this.initQuery();

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQuery</Name>
				<Source><![CDATA[
    public void initQuery()
    {
        QueryBuildDataSource    dataSourceProjWIPTable;
        QueryBuildDataSource    dataSourceProjTable;
        QueryBuildDataSource    dataSourceProjControlPeriodTable;
        QueryBuildRange         rangeControlId;
        Query                   query = new Query();

        dataSourceProjWIPTable  = query.addDataSource(tableNum(ProjWIPTable));
        dataSourceProjWIPTable.addRange(fieldNum(ProjWIPTable,ProjId));
        rangeControlId          = dataSourceProjWIPTable.addRange(fieldNum(ProjWIPTable,ControlId));
        rangeControlId.status(RangeStatus::Hidden);

        if(!isContractLineUsed || !contractLineBasedRevRecFeature)
        {
            dataSourceProjTable     = dataSourceProjWIPTable.addDataSource(tableNum(ProjTable));
            dataSourceProjTable.fields().clearFieldList();
            dataSourceProjTable.addSelectionField(fieldNum(ProjTable, ProjId));
            dataSourceProjTable.addSelectionField(fieldNum(ProjTable, WIPProject));
            dataSourceProjTable.joinMode(JoinMode::InnerJoin);
            dataSourceProjTable.relations(true);
            dataSourceProjTable.fetchMode(QueryFetchMode::One2One);
        }

        dataSourceProjControlPeriodTable = dataSourceProjWIPTable.addDataSource(tableNum(ProjControlPeriodTable));
        dataSourceProjControlPeriodTable.relations(true);
        dataSourceProjControlPeriodTable.fetchMode(QueryFetchMode::One2One);

        queryRun = new SysQueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjControlPeriodTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a project control period transaction record in the <c>ProjControlPeriodTrans</c> table.
    /// </summary>
    /// <param name="_projControlPeriod">
    ///    A <c>ProjControlPeriodTable</c> table buffer that contains the project control period.
    /// </param>
    /// <param name="_wipType">
    ///    The work-in-progress type.
    /// </param>
    /// <param name="_wipAmount">
    ///    The work-in-progress amount.
    /// </param>
    /// <param name="_transId">
    ///    The project transaction ID, optional.
    /// </param>
    /// <param name="_transType">
    ///    The project transaction type, optional.
    /// </param>
    /// <param name="_costRefRecId">
    ///    The cost reference ID, optional.
    /// </param>
    /// <returns>
    ///    A <c>ProjControlPeriodTrans</c> table buffer.
    /// </returns>
    protected ProjControlPeriodTrans initializeProjControlPeriodTrans(ProjControlPeriodTable _projControlPeriod,
                                      ProjWIPType                   _wipType,
                                      ProjWIPAmount                 _wipAmount,
                                      ProjTransIdBase               _transId = '',
                                      ProjTransType                 _transType = ProjTransType::None,
                                      RefRecId                      _costRefRecId = 0)
    {
        ProjControlPeriodTrans projControlPeriodTrans;
        projControlPeriodTrans.ProjId       = _projControlPeriod.ProjId;
        projControlPeriodTrans.ControlId    = _projControlPeriod.ControlId;
        projControlPeriodTrans.PeriodFrom   = _projControlPeriod.PeriodFrom;
        projControlPeriodTrans.Version      = _projControlPeriod.Version;

        projControlPeriodTrans.Amount       = CurrencyExchangeHelper::amount(_wipAmount, Ledger::accountingCurrency(CompanyInfo::findDataArea(curext()).RecId));
        projControlPeriodTrans.wipType      = _wipType;

        projControlPeriodTrans.TransType    = _transType;
        projControlPeriodTrans.CostRefRecId = _costRefRecId;

        if (_transId)
        {
            projControlPeriodTrans.TransId  = _transId;
        }
        
        return projControlPeriodTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertControlTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts project control period transaction into the <c>ProjControlPeriodTrans</c> table.
    /// </summary>
    /// <param name="_projControlPeriod">
    ///    A <c>ProjControlPeriodTable</c> table buffer that contains the project control period.
    /// </param>
    /// <param name="_wipType">
    ///    The work-in-progress type.
    /// </param>
    /// <param name="_wipAmount">
    ///    The work-in-progress amount.
    /// </param>
    /// <param name="_transId">
    ///    The project transaction ID, optional.
    /// </param>
    /// <param name="_transType">
    ///    The project transaction type, optional.
    /// </param>
    /// <param name="_costRefRecId">
    ///    The cost reference ID, optional.
    /// </param>
    protected void insertControlTrans(ProjControlPeriodTable        _projControlPeriod,
                                      ProjWIPType                   _wipType,
                                      ProjWIPAmount                 _wipAmount,
                                      ProjTransIdBase               _transId = '',
                                      ProjTransType                 _transType = ProjTransType::None,
                                      RefRecId                      _costRefRecId = 0)
    {
        ProjControlPeriodTrans projControlPeriodTrans = this.initializeProjControlPeriodTrans(_projControlPeriod, _wipType, _wipAmount, _transId, _transType, _costRefRecId);
        if (ProjPostEstimateTelemetryFlight::instance().isEnabled())
        {
            using (var activityContext = logger.revRecActivity().postEstimateContext())
            {
                logger.logInformation(strFmt("ProjId: %1, DataAreaId: %2, RecId: %3, TransId: %4, Call stack: %5", projControlPeriodTrans.ProjId, projControlPeriodTrans.DataAreaId, projControlPeriodTrans.RecId, projControlPeriodTrans.TransId, ProjOpsInstrumentationLogger::getCallStack(xSession::xppCallStack())));
            }
        }
        ttsbegin;
        projControlPeriodTrans.insert();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRevenue</Name>
				<Source><![CDATA[
    public void insertRevenue(
        ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher           _ledgerVoucher)
    {
        ProjControlPeriodTrans      projControlPeriodTrans;
        ProjPost                    projPost;

        while select projControlPeriodTrans
            where projControlPeriodTrans.ProjId     == _projControlPeriod.ProjId     &&
                  projControlPeriodTrans.ControlId  == _projControlPeriod.ControlId  &&
                  projControlPeriodTrans.PeriodFrom == _projControlPeriod.PeriodFrom &&
                  projControlPeriodTrans.Version    == _projControlPeriod.Version    &&
                  projControlPeriodTrans.wipType    != ProjWIPType::Cost
        {
            projPost = ProjPost::newEnterRevenueEstimate(projControlPeriodTrans,
                                              null,
                                              _ledgerVoucher,
                                              this.isReversal(),
                                              this.elimination());

            if (this.parmBeginningBalance() && !this.elimination())
            {
                projPost.parmPostToGeneralLedger(false);
            }
            projPost.postTrans();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>investmentEliminationAmount</Name>
				<Source><![CDATA[
    public AmountMST investmentEliminationAmount(ProjControlPeriodTable  _projControlPeriod)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDesignName</Name>
				<Source><![CDATA[
    public IdentifierName lastValueDesignName()
    {
        return queryValue(periodic);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerStatusCostTo</Name>
				<Source><![CDATA[
    protected ProjLedgerStatus ledgerStatusCostTo(ProjTrans _projTrans)
    {
        ProjLedgerStatus    ret;
        ProjTable           projTable;
        ProjWIPTable        wipProject;

        ret = ProjLedgerStatus::Operations;

        if (_projTrans.transType() == ProjTransType::Cost &&
            _projTrans.ledgerStatusCost() == ProjLedgerStatus::None)
        {
            ret = _projTrans.ledgerStatusCost();
        }
        else if (_projTrans.ledgerStatusCost() ==  ProjLedgerStatus::Never) // Handle Never Ledger (Hour or Item)
        {
            ret = ProjLedgerStatus::Never;
        }
        else
        {
            
            // Can't use getCompletePrinciple() method here because this code is refetching the ProjGroup instead of using projGroup class variable.
            if(isContractLineUsed && contractLineBasedRevRecFeature)
            {
                wipProject = ProjWIPTable::find(ProjRevRecContractLine::findByContractLineNum(_projTrans.psaContractLineNum()).RevenueRecognitionId);
                if (ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject).CompletePrinciple == ProjCompletePrincip::CompletedContract)
                {
                    if (_projTrans.canBeCapitalize())
                    {
                        ret = ProjLedgerStatus::BalanceSheet;
                    }
                }

            }
            else if (isMultipleContractLineFeatureEnabled)
            {
                projTable = projTable::find(_projTrans.projId());
                if (ProjRevRecHelper::getRevProfile(projTable, ProjContractBillingMethod::FixedPrice).CompletePrinciple == ProjCompletePrincip::CompletedContract)
                {
                    if (_projTrans.canBeCapitalize())
                    {
                        ret = ProjLedgerStatus::BalanceSheet;
                    }
                }
            }
            else
            {
                projTable = projTable::find(_projTrans.projId());
                if ((projTable.Type == ProjType::Investment)
                ||(ProjGroup::find(projTable.ProjGroupId).CompletePrincip == ProjCompletePrincip::CompletedContract))
                {
                    if (_projTrans.canBeCapitalize())
                    {
                        ret = ProjLedgerStatus::BalanceSheet;
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion,#CurrentList,queryRun.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAcknowledgementDate</Name>
				<Source><![CDATA[
    public AcknowledgementDate parmAcknowledgementDate(AcknowledgementDate _acknowledgementDate = acknowledgementDate)
    {
        acknowledgementDate = _acknowledgementDate;

        return acknowledgementDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjRevenueProfile</Name>
				<Source><![CDATA[
    public ProjRevenueProfile parmProjRevenueProfile(ProjRevenueProfile _projRevProfile)
    {
        projRevProfile = _projRevProfile;

        return projRevProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBeginningBalance</Name>
				<Source><![CDATA[
    public NoYes parmBeginningBalance(NoYes _beginningBalance = beginningBalance)
    {
        beginningBalance = _beginningBalance;

        return beginningBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPeriodFrom</Name>
				<Source><![CDATA[
    public ProjPeriodFrom parmPeriodFrom(ProjPeriodFrom _periodFrom = periodFrom)
    {
        periodFrom  = _periodFrom;

        return periodFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPeriodic</Name>
				<Source><![CDATA[
    public boolean parmPeriodic(boolean _periodic = periodic)
    {
        periodic    = _periodic;

        return periodic;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPeriodTo</Name>
				<Source><![CDATA[
    public ProjPeriodTo parmPeriodTo(ProjPeriodTo _periodTo = periodTo)
    {
        periodTo  = _periodTo;

        return periodTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsContractLineUsed</Name>
				<Source><![CDATA[
    public boolean parmIsContractLineUsed(boolean _isContractLineUsed = isContractLineUsed)
    {
        isContractLineUsed  = _isContractLineUsed;

        return isContractLineUsed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUsePriorPeriodEndDate</Name>
				<Source><![CDATA[
    public NoYes parmUsePriorPeriodEndDate(NoYes _usePriorPeriodEndDate = usePriorPeriodEndDate)
    {
        usePriorPeriodEndDate = _usePriorPeriodEndDate;

        if (usePriorPeriodEndDate)
        {
            ProjPeriodLine projPeriodLine = ProjPeriodLine::findPrevFromDate(this.periodId, DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()));

            if (ProjPeriodLine::exist(projPeriodLine.PeriodId, projPeriodLine.PeriodFrom))
            {
                this.parmPeriodFrom(projPeriodLine.PeriodFrom);
                this.parmPeriodTo(projPeriodLine.PeriodTo);
                this.parmTransDate(projPeriodLine.PeriodTo);
            }
        }

        return usePriorPeriodEndDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostWarnings</Name>
				<Source><![CDATA[
    public NoYes parmPostWarnings(NoYes _postWarnings = postWarnings)
    {
        postWarnings = _postWarnings;

        return postWarnings;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjControlId</Name>
				<Source><![CDATA[
    public ProjControlId parmProjControlId(ProjControlId _controlId = controlId)
    {
        controlId  = _controlId;

        return controlId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjControlTypeOutput</Name>
				<Source><![CDATA[
    public ProjControlTypeOutput parmProjControlTypeOutput(ProjControlTypeOutput _outputResult = outputResult)
    {
        outputResult = _outputResult;

        return outputResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjId</Name>
				<Source><![CDATA[
    public ProjId parmProjId(ProjId _parmProjId = projId)
    {
        projId = _parmProjId;

        return projId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjPeriodId</Name>
				<Source><![CDATA[
    public ProjPeriodId parmProjPeriodId(ProjPeriodId _projPeriodId = periodId)
    {
        periodId    = _projPeriodId;

        return periodId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowInfoLog</Name>
				<Source><![CDATA[
    public NoYes parmShowInfoLog(NoYes _outputInfolog = outputInfolog)
    {
        outputInfolog = _outputInfolog;

        return outputInfolog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowQueryValues</Name>
				<Source><![CDATA[
    public boolean parmShowQueryValues(boolean _showQueryValues = showQueryValues)
    {
        showQueryValues = _showQueryValues;

        return showQueryValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransDate</Name>
				<Source><![CDATA[
    public TransDate parmTransDate(TransDate _transDate = transDate)
    {
        transDate = _transDate;

        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVersion</Name>
				<Source><![CDATA[
    public ProjControlVersion parmVersion(ProjControlVersion _version = projControlVersion)
    {
        projControlVersion = _version;

        return projControlVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAccruedCost</Name>
				<Source><![CDATA[
    public void postAccruedCost(
        Common              _buffer,
        Common              _bufferCost,
        LedgerVoucher       _ledgerVoucher
        )
    {
        ProjPost    projPost;

        projPost = ProjPost::newCreateCostEstimate(_buffer,_bufferCost,_ledgerVoucher,this.isReversal(),this.elimination());
        projPost.postTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEstimateInvestment</Name>
				<Source><![CDATA[
    public void postEstimateInvestment(
        Common              _buffer,
        LedgerVoucher       _ledgerVoucher
        )
    {
        ProjPost    projPost;

        projPost = ProjPost::newCreateCostEstimateInvestment(_buffer,_ledgerVoucher,this.isReversal(),this.elimination());
        if (this.parmBeginningBalance() && !this.elimination())
        {
            projPost.parmPostToGeneralLedger(false);
        }
        projPost.postTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processProductionProfit</Name>
				<Source><![CDATA[
    private container processProductionProfit(
        ProjControlPeriodTable  _projControlPeriod,
        ProjTrans               _projTrans
    )
    {
        ProjWIPAmount                   wipAccruedTurnoverProd;
        ProjWIPAmount                   wipAccruedTurnoverProfit;
        ProjWIPAmount                   prevWIPAccruedTurnoverProd;
        ProjWIPAmount                   prevWIPAccruedTurnoverProfit;
        ProjControlPeriodTable          locProjControlPeriodTable;
        ProjControlPeriodTrans          projControlPeriodTrans;
        ProjControlPeriodTableColumn    projControlPeriodTableColumn;

        projControlPeriodTableColumn = ProjControlPeriodTableColumn::find(_projControlPeriod.ProjId, _projControlPeriod.ControlId, _projControlPeriod.PeriodFrom, _projControlPeriod.Version, ProjEstimateColumn::Total);

        switch (this.getSalesPriceMatchingPrinciple())
        {
            case ProjSalesPriceMatchingPrincip::ValueAddedMarkupPercent:
            case ProjSalesPriceMatchingPrincip::ValueAddedHourRate:

                switch (this.getCompletePrinciple())
                {
                    case ProjCompletePrincip::CompletedPercentage:
                        if (!this.elimination())
                        {
                            select sum(Amount) from projControlPeriodTrans
                                where projControlPeriodTrans.TransType == this.transType(_projTrans) &&
                                    projControlPeriodTrans.CostRefRecId == _projTrans.recId() &&
                                    projControlPeriodTrans.wipType == ProjWIPType::AccruedTurnoverProd &&
                                    projControlPeriodTrans.PeriodFrom < _projControlPeriod.PeriodFrom
                                exists join locProjControlPeriodTable
                                where locProjControlPeriodTable.ProjId == projControlPeriodTrans.ProjId &&
                                      locProjControlPeriodTable.ControlId == projControlPeriodTrans.ControlId &&
                                      locProjControlPeriodTable.PeriodFrom == projControlPeriodTrans.PeriodFrom &&
                                      locProjControlPeriodTable.Version == projControlPeriodTrans.Version &&
                                      locProjControlPeriodTable.PeriodStatus == ProjControlPeriodStatus::Posted;

                            prevWIPAccruedTurnoverProd = projControlPeriodTrans.Amount;

                            select sum(Amount) from projControlPeriodTrans
                                where projControlPeriodTrans.TransType == this.transType(_projTrans) &&
                                    projControlPeriodTrans.CostRefRecId == _projTrans.recId() &&
                                    projControlPeriodTrans.wipType == ProjWIPType::AccruedTurnoverProfit &&
                                    projControlPeriodTrans.PeriodFrom < _projControlPeriod.PeriodFrom
                                exists join locProjControlPeriodTable
                                where locProjControlPeriodTable.ProjId == projControlPeriodTrans.ProjId &&
                                      locProjControlPeriodTable.ControlId == projControlPeriodTrans.ControlId &&
                                      locProjControlPeriodTable.PeriodFrom == projControlPeriodTrans.PeriodFrom &&
                                      locProjControlPeriodTable.Version == projControlPeriodTrans.Version &&
                                      locProjControlPeriodTable.PeriodStatus == ProjControlPeriodStatus::Posted;

                            prevWIPAccruedTurnoverProfit = projControlPeriodTrans.Amount;
                        }
                        break;
                    case ProjCompletePrincip::CompletedContract:
                        if (this.elimination())
                        {
                            prevWIPAccruedTurnoverProd = 0;
                            prevWIPAccruedTurnoverProfit = 0;
                        }
                        break;
                    default:
                        throw error(strFmt("@SYS22828",funcName()));
                }

                wipAccruedTurnoverProd = this.transCostMST(_projTrans) - prevWIPAccruedTurnoverProd;

                if (this.transType(_projTrans) == ProjTransType::Hour)
                {
                    if (this.getSalesPriceMatchingPrinciple() == ProjSalesPriceMatchingPrincip::ValueAddedMarkupPercent)
                    {
                        if (projControlPeriodTableColumn.plCostHour)
                        {
                            wipAccruedTurnoverProfit = CurrencyExchangeHelper::amount(this.transCostMST(_projTrans) * (projControlPeriodTableColumn.plTotalGrossMargin + projControlPeriodTableColumn.plCostHour) / projControlPeriodTableColumn.plCostHour - this.transCostMST(_projTrans) - prevWIPAccruedTurnoverProfit);
                        }
                    }
                    else if (this.getSalesPriceMatchingPrinciple() == ProjSalesPriceMatchingPrincip::ValueAddedHourRate)
                    {
                        if (projControlPeriodTableColumn.GeneralHoursQty)
                        {
                            wipAccruedTurnoverProfit = CurrencyExchangeHelper::amount(_projTrans.qty() * (projControlPeriodTableColumn.plTotalGrossMargin + projControlPeriodTableColumn.plCostHour) / projControlPeriodTableColumn.GeneralHoursQty - this.transCostMST(_projTrans) - prevWIPAccruedTurnoverProfit);
                        }
                    }
                }
                break;

            default:
                throw error(strFmt("@SYS22828",funcName()));
        }

        return [wipAccruedTurnoverProd, wipAccruedTurnoverProfit];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSalesValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the work-in-progress amount to be accrued.
    /// </summary>
    /// <param name="_projControlPeriod">
    ///    A <c>_projControlPeriod</c> table buffer that contains the project control period.
    /// </param>
    /// <param name="_projTrans">
    ///    A <c>ProjTrans</c> class that contains the project transaction.
    /// </param>
    /// <returns>
    ///    The work-in-progress amount to be accrued.
    /// </returns>
    protected ProjWIPAmount processSalesValue(
        ProjControlPeriodTable  _projControlPeriod,
        ProjTrans               _projTrans
    )
    {
        ProjWIPAmount               wipAccruedTurnover;
        AmountMST                   contractAmount;
        AmountMST                   costAmount;
        ProjWIPAmount               prevWipAmount;
        ProjControlPeriodTable      locProjControlPeriodTable;
        ProjControlPeriodTrans      projControlPeriodTrans;
        ProjControlPeriodCostGroup  projControlPeriodCostGroup;
        
        switch (this.getSalesPriceMatchingPrinciple())
        {
            case ProjSalesPriceMatchingPrincip::MarkupPercentTotal:
                switch (this.getCompletePrinciple())
                {
                    case ProjCompletePrincip::CompletedPercentage:
                        if (!this.elimination())
                        {
                            contractAmount = _projControlPeriod.totalContract();
                            costAmount = _projControlPeriod.totalCost();

                            select sum(Amount) from projControlPeriodTrans
                                where projControlPeriodTrans.TransType == this.transType(_projTrans) &&
                                    projControlPeriodTrans.CostRefRecId == _projTrans.recId() &&
                                    projControlPeriodTrans.wipType == ProjWIPType::AccruedTurnover &&
                                    projControlPeriodTrans.PeriodFrom < _projControlPeriod.PeriodFrom
                                exists join locProjControlPeriodTable
                                where locProjControlPeriodTable.ProjId == projControlPeriodTrans.ProjId &&
                                      locProjControlPeriodTable.ControlId == projControlPeriodTrans.ControlId &&
                                      locProjControlPeriodTable.PeriodFrom == projControlPeriodTrans.PeriodFrom &&
                                      locProjControlPeriodTable.Version == projControlPeriodTrans.Version &&
                                      locProjControlPeriodTable.PeriodStatus == ProjControlPeriodStatus::Posted;

                            prevWipAmount = projControlPeriodTrans.Amount;
                        }
                        break;
                    case ProjCompletePrincip::CompletedContract:
                        if (this.elimination())
                        {
                            contractAmount = _projControlPeriod.ActualContract;
                            costAmount = _projControlPeriod.ActualCostAmount;
                            prevWipAmount = 0;
                        }
                        break;
                    default:
                        throw error(strFmt("@SYS22828",funcName()));
                }
                break;

            case ProjSalesPriceMatchingPrincip::MarkupPercentEstimateLine:
                projControlPeriodCostGroup = ProjControlPeriodCostGroup::find(
                    _projControlPeriod.ProjId,
                    _projControlPeriod.ControlId,
                    _projControlPeriod.PeriodFrom,
                    _projControlPeriod.Version,
                    ProjControlCategory::findCategoryGroup(_projControlPeriod.ControlId, _projTrans.categoryId()));

                if (projControlPeriodCostGroup)
                {
                    switch (this.getCompletePrinciple())
                    {
                        case ProjCompletePrincip::CompletedPercentage:
                            if (!this.elimination())
                            {
                                contractAmount = projControlPeriodCostGroup.Contract;
                                costAmount = projControlPeriodCostGroup.totalCostAmount();

                                select sum(Amount) from projControlPeriodTrans
                                    where projControlPeriodTrans.TransType == this.transType(_projTrans) &&
                                        projControlPeriodTrans.CostRefRecId == _projTrans.recId() &&
                                        projControlPeriodTrans.wipType == ProjWIPType::AccruedTurnover &&
                                    projControlPeriodTrans.PeriodFrom < _projControlPeriod.PeriodFrom
                                exists join locProjControlPeriodTable
                                where locProjControlPeriodTable.ProjId == projControlPeriodTrans.ProjId &&
                                      locProjControlPeriodTable.ControlId == projControlPeriodTrans.ControlId &&
                                      locProjControlPeriodTable.PeriodFrom == projControlPeriodTrans.PeriodFrom &&
                                      locProjControlPeriodTable.Version == projControlPeriodTrans.Version &&
                                      locProjControlPeriodTable.PeriodStatus == ProjControlPeriodStatus::Posted;

                                prevWipAmount = projControlPeriodTrans.Amount;
                            }
                            break;
                        case ProjCompletePrincip::CompletedContract:
                            if (this.elimination())
                            {
                                contractAmount = projControlPeriodCostGroup.Contract;
                                costAmount = projControlPeriodCostGroup.ActuelCostAmount;
                                prevWipAmount = 0;
                            }
                            break;
                        default:
                            throw error(strFmt("@SYS22828",funcName()));
                    }
                }
                break;

            default:
                throw error(strFmt("@SYS22828",funcName()));
        }
        
        if (costAmount)
        {
            if (RevRecCompletionPercentageWithMarkUpPerTotalFlight::instance().isEnabled()
                    && this.getSalesPriceMatchingPrinciple() == ProjSalesPriceMatchingPrincip::MarkupPercentTotal)
            {
                wipAccruedTurnover = this.calculateSalesValue(_projTrans, _projControlPeriod, contractAmount, costAmount, prevWipAmount);
            }
            else
            {
                wipAccruedTurnover = CurrencyExchangeHelper::amount(this.transCostMST(_projTrans) * contractAmount / costAmount - prevWipAmount);
            }
        }

        return wipAccruedTurnover;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSalesValue</Name>
				<Source><![CDATA[
    private ProjWIPAmount calculateSalesValue(ProjTrans _projTrans, ProjControlPeriodTable  _projControlPeriod, 
        AmountMST contractAmount, AmountMST costAmount, ProjWIPAmount prevWipAmount)
    {
        ProjWIPAmount wipAccruedTurnover;
        switch (this.getCompletePrinciple())
        {
            case ProjCompletePrincip::CompletedPercentage:
                wipAccruedTurnover = CurrencyExchangeHelper::amount(this.transCostMST(_projTrans) * _projControlPeriod.WIPAccruedTurnover / costAmount - prevWipAmount);
                break;
            case ProjCompletePrincip::CompletedContract:
                wipAccruedTurnover = CurrencyExchangeHelper::amount(this.transCostMST(_projTrans) * contractAmount / costAmount - prevWipAmount);
                break;
            default:
                wipAccruedTurnover = CurrencyExchangeHelper::amount(this.transCostMST(_projTrans) * contractAmount / costAmount - prevWipAmount);
                break;
        }
        return wipAccruedTurnover; 
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressTransText</Name>
				<Source><![CDATA[
    public str progressTransText(ProjId                _projId,
                          ProjPeriodFrom        _projPeriodFrom,
                          ProjControlVersion    _version)
    {
        return strFmt("@SYS55664",_projId,_projPeriodFrom,_version);
    }

]]></Source>
			</Method>
			<Method>
				<Name>projControlPeriodStatusNew</Name>
				<Source><![CDATA[
    protected ProjControlPeriodStatus projControlPeriodStatusNew()
    {
        return ProjControlPeriodStatus::Created;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projParameters</Name>
				<Source><![CDATA[
    public ProjParameters projParameters()
    {
        if (!projParameters)
        {
            projParameters = ProjParameters::find();
        }

        return projParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryNext</Name>
				<Source><![CDATA[
    protected void queryNext(
        LedgerVoucher _ledgerVoucher)
    {
        ProjWIPTable projWIPTable;
        ProjControlPeriodTable projControlPeriod;

        if (queryRun.changed(tableNum(ProjWIPTable)))
        {
            projWIPTable = queryRun.get(tableNum(ProjWIPTable));
            projWIPTableRecId = projWIPTable.RecId;

            if ((isMultipleContractLineFeatureEnabled  || (isContractLineUsed && contractLineBasedRevRecFeature))
                && !projWIPTable.ProjRevenueProfileId)
            {
                warning(strFmt("@Proj:FPRevRecProjectRevProfileAssociationFailure", projWIPTable.ProjId));
                return;
            }

            if (this.isReversal() && !this.elimination())
            {
                select firstonly projControlPeriod
                    where projControlPeriod.ProjId == projWIPTable.ProjId &&
                          projControlPeriod.ControlId == projWIPTable.ControlId &&
                          projControlPeriod.PeriodFrom == this.parmPeriodFrom() &&
                          projControlPeriod.PeriodStatus == ProjControlPeriodStatus::Posted &&
                          projControlPeriod.Version	<= this.parmVersion() &&
                          projControlPeriod.BeginningBalance == this.parmBeginningBalance();
            }
            else
            {
                projControlPeriod = ProjControlPeriodTable::find(projWIPTable.ProjId, projWIPTable.ControlId, this.parmPeriodFrom());   
            }

            using (var activityContext = logger.revRecActivity().postEstimateContext())
            {
                activityContext.addCustomProperty(ProjRevRecInstrumentationActivities::PostingType, this.isReversal() ? ProjRevRecInstrumentationActivities::PostingType_Reverse : ProjRevRecInstrumentationActivities::PostingType_Post);
                logger.logInformation(strFmt("Estimate ProjectId: %1", this.projId));
                this.postEstimate(projControlPeriod, _ledgerVoucher);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    /// The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    /// This method is used if a query prompt is the dialog, and if a select menu item is added to a
    /// dialog. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it
    /// in the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverse</Name>
				<Source><![CDATA[
    [SysObsolete("This method is obsolete. Use IsReveral() method instead.", false, 9\7\2020)]
    public boolean reverse()
    {
        return this.isReversal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReversal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the posting is a reversal posting.
    /// </summary>
    /// <returns>true if the posting is reversal; otherwise, false.</returns>
    protected boolean isReversal()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        logger = ProjRevRecInstrumentationLogger::createLogger(classStr(ProjControlPosting));

        if (! this.validate())
        {
            throw error("@SYS21628");
        }

        List listRecIds = strSplit(this.parmSelectedRecIds(), ",");
        
        if (listRecIds.elements() == 0)
        {
            return;
        }

        if (this.parmPeriodic())
        {
            this.setQueryValues();
        }

        QueryBuildDataSource projControlPeriodTable_ds = this.queryRun().query().dataSourceTable(tableNum(ProjControlPeriodTable));

        // Added range to filter posted/eliminated transactions while posting reverse estimate, elimination and reverse elimination in order to generate correct number sequence for period posting vouchers.
        if ((this.isReversal() || this.elimination()) && projControlPeriodTable_ds)
        {
            QueryBuildRange rangePeriodStatus = projControlPeriodTable_ds.findRange(fieldNum(ProjControlPeriodTable, PeriodStatus));
            QueryBuildRange rangePeriodFrom = projControlPeriodTable_ds.findRange(fieldNum(ProjControlPeriodTable, PeriodFrom));
            QueryBuildRange rangePeriodTo = projControlPeriodTable_ds.findRange(fieldNum(ProjControlPeriodTable, PeriodTo));
            if (!rangePeriodStatus)
            {
                rangePeriodStatus = projControlPeriodTable_ds.addRange(fieldNum(ProjControlPeriodTable, PeriodStatus));
            }
            if (!rangePeriodFrom)
            {
                rangePeriodFrom = projControlPeriodTable_ds.addRange(fieldNum(ProjControlPeriodTable, PeriodFrom));
            }
            if (!rangePeriodTo)
            {
                rangePeriodTo = projControlPeriodTable_ds.addRange(fieldNum(ProjControlPeriodTable, PeriodTo));
            }

            if (this.isReversal() && this.elimination())
            {
                rangePeriodStatus.value(queryValue(ProjControlPeriodStatus::Eliminate));
            }
            else
            {
                rangePeriodStatus.value(queryValue(ProjControlPeriodStatus::Posted));
            }

            rangePeriodFrom.value(queryValue(this.PeriodFrom));
            rangePeriodTo.value(queryValue(this.PeriodTo));
        }

        TransactionTxt transTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);

        DetailSummary detailSummary = ProjParameters::find().LineTotalEstimate == ProjLineTotal::Line ? DetailSummary::Detail : DetailSummary::Summary ;

        try
        {
            this.runEnhancedCommitmentScope(listRecIds, projControlPeriodTable_ds, transTxt, detailSummary);
        }

        catch (Exception::Error)
        {
            throw error("@SYS21628");
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjControlPeriodRange</Name>
				<Source><![CDATA[
    private void updateProjControlPeriodRange(QueryBuildDataSource _projControlPeriodTable_ds, str _selectedRecId)
    {
        if (_selectedRecId)
        {
            _projControlPeriodTable_ds.clearRange(fieldNum(ProjControlPeriodTable, RecId));
            _projControlPeriodTable_ds.addRange(fieldNum(ProjControlPeriodTable, RecId)).value(_selectedRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingExecution</Name>
				<Source><![CDATA[
    private void postingExecution(NumberSeq _numberSeq, Voucher _voucher, TransactionTxt _transTxt, DetailSummary _detailSummary)
    {
        _transTxt.setDate(this.parmTransDate());
        _transTxt.setVoucher(_voucher);

        LedgerVoucher ledgerVoucher = LedgerVoucher::newLedgerPost(_detailSummary,
            SysModule::Project, _numberSeq.parmVoucherSequenceCode(),
            this.transactionLogType(), this.transactionLogTxt());

        LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(_voucher,
            this.parmTransDate(), SysModule::Project, LedgerTransType::Project);
        ledgerVoucherObject.parmAcknowledgementDate(this.parmAcknowledgementDate());
        ledgerVoucherObject.lastTransTxt(_transTxt.txt());
        ledgerVoucher.addVoucher(ledgerVoucherObject);

        // <GEERU>
        LedgerBondClient_RU ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
        if (ledgerBondClient)
        {
            ledgerBondClient.addNewLogObject();
        }

        // </GEERU>

        const int NumOfBars = 1;
        this.progressInit(strFmt("@SYS50725", this.parmPeriodFrom()), NumOfBars, #AviUpdate);

        this.queryNext(ledgerVoucher);

        // <GEERU>
        if (ledgerBondClient)
        {
            if (ledgerBondClient.currentLogLength() >= 2)
            {
                ledgerBondClient.bondLastVRef2CurrentLog();
            }
            ledgerBondClient.removeCurrentLogObject();
        }
        // </GEERU>

        ledgerVoucher.end();
    }

]]></Source>
			</Method>
			<Method>
				<Name>runEnhancedCommitmentScope</Name>
				<Source><![CDATA[
    private void runEnhancedCommitmentScope(List _listRecIds, QueryBuildDataSource _projControlPeriodTable_ds,
        TransactionTxt _transTxt, DetailSummary _detailSummary)
    {
        ListEnumerator listEnum = _listRecIds.getEnumerator();
        NumberSequenceReference estimateNumSeq = ProjParameters::numRefProjPeriodVoucher();
        int numOfEstimateProject;

        using (var activityContext = logger.revRecActivity().postEstimateLoopContext())
        {
            NumberSeq numberSeq = NumberSeq::newGetVoucher(estimateNumSeq);

            while (listEnum.moveNext())
            {
                this.updateProjControlPeriodRange(_projControlPeriodTable_ds, listEnum.current());

                while (this.queryRun().next())
                {
                    numOfEstimateProject++;

                    try
                    {
                        ttsbegin;
                        Voucher voucher = numberSeq.voucher();
                        this.postingExecution(numberSeq, voucher, _transTxt, _detailSummary);
                        ttscommit;
                    }
                    catch (Exception::Deadlock)
                    {
                        if (xSession::currentRetryCount() >= #RetryNum)
                        {
                            logger.logError(strFmt(LoggerRetryExceptionMsg, 'Deadlock',
                            'ProjControlPosting.runEnhancedCommitmentScope()', projWIPTableRecId));
                            throw Exception::Deadlock;
                        }
                        else
                        {
                            sleep(ProjConstants::DeadLockRetryInterval * xSession::currentRetryCount());
                            retry;
                        }
                    }
                    catch (Exception::UpdateConflict)
                    {
                        if (appl.ttsLevel() == 0)
                        {
                            if (xSession::currentRetryCount() >= #RetryNum)
                            {
                                logger.logError(strFmt(LoggerRetryExceptionMsg, 'UpdateConflict',
                                'ProjControlPosting.runEnhancedCommitmentScope()', projWIPTableRecId));
                                throw Exception::UpdateConflictNotRecovered;
                            }
                            else
                            {
                                retry;
                            }
                        }
                        else
                        {
                            throw Exception::UpdateConflict;
                        }
                    }
                    catch (Exception::TransientSqlConnectionError)
                    {
                        if (ProjTransientSQLConnectionRetryProvider::retryTransientSqlConnectionError())
                        {
                            retry;
                        }
                        else
                        {
                            logger.logError(strFmt(LoggerRetryExceptionMsg, 'TransientSqlConnectionError',
                            'ProjControlPosting.runEnhancedCommitmentScope()', projWIPTableRecId));
                            throw Exception::TransientSqlConnectionError;
                        }
                    }
                }

                this.queryRun().reset();
            }

            this.logExecutionTelemetry(activityContext, true, numOfEstimateProject);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logExecutionTelemetry</Name>
				<Source><![CDATA[
    private void logExecutionTelemetry(SysInstrumentationActivityContext _activityContext, 
        boolean _commitScopeFlightEnable, int _numOfEstimateProject)
    {
        _activityContext.addCustomProperty(ProjRevRecInstrumentationActivities::NumOfEstimateProject, 
            int2Str(_numOfEstimateProject));
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the batch task is run on the server or on a client.
    /// </summary>
    /// <returns>
    /// true if the task is run on the server; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Your classes that extend the <c>RunBaseBatch</c> class must override the <c>runsImpersonated</c>
    /// method and return false, if you want those tasks to run on a client.
    /// </remarks>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProgress</Name>
				<Source><![CDATA[
    public void setProgress(ProjControlPeriodTable  _projControlPeriod)
    {
        i++;
        progress.setCount(i);
        progress.setText(this.progressTransText(_projControlPeriod.ProjId,
                                                _projControlPeriod.PeriodFrom,
                                                _projControlPeriod.Version));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQueryValues</Name>
				<Source><![CDATA[
    public void setQueryValues()
    {
        Query                   query;
        QueryBuildDataSource    dataSourceProjWIPTable;
        QueryBuildRange         rangeProjId;
        QueryBuildRange         rangeControlId;

        if (queryRun == null)
        {
            this.initQuery();
        }

        query   = queryRun.query();

        dataSourceProjWIPTable = query.dataSourceTable(tableNum(ProjWIPTable));

        rangeProjId     = dataSourceProjWIPTable.findRange(fieldNum(ProjWIPTable,ProjId));
        rangeControlId  = dataSourceProjWIPTable.findRange(fieldNum(ProjWIPTable,ControlId));

        if (! rangeProjId)
        {
            rangeProjId     = dataSourceProjWIPTable.addRange(fieldNum(ProjWIPTable,ProjId));
        }

        if (! rangeControlId)
        {
            rangeControlId  = dataSourceProjWIPTable.addRange(fieldNum(ProjWIPTable,ControlId));
        }

        if (this.parmProjId())
        {
            rangeProjId.value(this.parmProjId());
        }

        if (this.parmProjControlId())
        {
            rangeControlId.value(this.parmProjControlId());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to add a select button to the dialog.
    /// </summary>
    /// <returns>
    /// True if a select button is to be added to the dialog; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    /// return a valid <c>queryRun</c> .If you change the return value to false the button will no longer
    /// be added.
    /// </remarks>
    public boolean showQueryValues()
    {
        return showQueryValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogTxt</Name>
				<Source><![CDATA[
    protected TransTxt  transactionLogTxt()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogType</Name>
				<Source><![CDATA[
    protected TransactionLogType  transactionLogType()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>transCostMST</Name>
				<Source><![CDATA[
    private AmountMST transCostMST(ProjTrans _projTrans)
    {
        return (this.transType(_projTrans) == ProjTransType::Cost ? _projTrans.ledgerCostAmountMST() : _projTrans.transCostMST());
    }

]]></Source>
			</Method>
			<Method>
				<Name>transType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns transaction type for the <c>ProjTrans</c> object
    /// </summary>
    /// <param name="_projTrans">
    /// The <c>ProjTrans</c> object
    /// </param>
    /// <returns>
    /// Transaction type for the <c>ProjTrans</c> object
    /// </returns>
    private ProjTransType transType(ProjTrans _projTrans)
    {
        return (_projTrans.tableId() == tableNum(PSAIndirectComponentTrans) ? ProjTransType::IndirectComponent : _projTrans.transType());
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        int         version = conPeek(_packedClass,1);
        container   packedQuery;

        #LOCALMACRO.List9
            projId,
            controlId,
            periodFrom,
            projControlversion,
            periodic,
            transDate,
            periodId,
            outputInfolog,
            outputResult,
            periodTo,
            showQueryValues,
            usePriorPeriodEndDate
        #ENDMACRO

        switch (version)
        {
            case #CurrentVersion:
                [version,#CurrentList,packedQuery] = _packedClass;
                if (SysQuery::isPackedOk(packedQuery))
                {
                    queryRun = new QueryRun(packedQuery);
                }
                else
                {
                    this.initQuery();
                    this.setQueryValues();
                }

                break;

            case 9:
                [version, #List9, packedQuery] = _packedClass;
                if (SysQuery::isPackedOk(packedQuery))
                {
                    queryRun = new QueryRun(packedQuery);
                }
                else
                {
                    this.initQuery();
                }
                break;

            case #Version12:
                [version,#CurrentListV12, packedQuery] = _packedClass;
                if (SysQuery::isPackedOk(packedQuery))
                {
                    queryRun = new QueryRun(packedQuery);
                }
                else
                {
                    this.initQuery();
                    this.setQueryValues();
                }

                break;

            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAccruedCost</Name>
				<Source><![CDATA[
    public void updateAccruedCost(
        ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher           _ledgerVoucher)
    {
        LedgerJournalTrans              ledgerJournalTrans;
        LedgerJournalTrans_Project      ledgerJournalTrans_Project;

        ProjControlPeriodTableColumn    projControlPeriodTableColumnEstimate    =
                                        ProjControlPeriodTableColumn::find(_projControlPeriod.ProjId,
                                                                           _projControlPeriod.ControlId,
                                                                           _projControlPeriod.PeriodFrom,
                                                                           _projControlPeriod.Version,
                                                                           ProjEstimateColumn::Estimate);

        if (projControlPeriodTableColumnEstimate.plCostAccCost)
        {
            ledgerJournalTrans.clear();
            ledgerJournalTrans.Txt                      = strFmt("@SYS53184", _projControlPeriod.PeriodFrom,_projControlPeriod.PeriodTo);
            ledgerJournalTrans.CurrencyCode             = Ledger::accountingCurrency(CompanyInfo::current());

            if (isContractLineUsed && contractLineBasedRevRecFeature)
            {
                ledgerJournalTrans.DefaultDimension = ProjTable::find(ProjWIPTable::getProjIdForRevenuePosting(_projControlPeriod.ProjId)).DefaultDimension;
            }
            else
            {
                ledgerJournalTrans.DefaultDimension = ProjTable::find(_projControlPeriod.ProjId).DefaultDimension;
            }

            ledgerJournalTrans.parmAccount(_projControlPeriod.ProjId, LedgerJournalACType::Project);
            ledgerJournalTrans.TransDate                = this.parmTransDate();
            ledgerJournalTrans.insert();

            ledgerJournalTrans_Project.clear();
            ledgerJournalTrans_Project.RefRecId     = ledgerJournalTrans.RecId;
            ledgerJournalTrans_Project.ProjId       = ledgerJournalTrans.parmAccount();
            ledgerJournalTrans_Project.CategoryId   = ProjRevRecHelper::getAccruedCostCategoryId(_projControlPeriod);
            ledgerJournalTrans_Project.CostPrice    = projControlPeriodTableColumnEstimate.plCostAccCost;
            ledgerJournalTrans_Project.Qty          = 1;
            ledgerJournalTrans_Project.ProjTransDate = this.parmTransDate();
            ledgerJournalTrans_Project.insert();

            this.postAccruedCost(ledgerJournalTrans,null,_ledgerVoucher);

            // We do not need to call delete on the project table as there is a cascading delete
            // setup on the LedgerJournalTrans.
            ledgerJournalTrans.delete(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAccruedOnAcc</Name>
				<Source><![CDATA[
    public void updateAccruedOnAcc(
        ProjId        _projId,
        LedgerVoucher _ledgerVoucher)
    {
        ProjOnAccTrans          projOnAccTrans;
        ProjInvoiceOnAcc        projInvoiceOnAcc;
        ProjInvoiceOnAccDetail  projInvoiceOnAccDetail;
        ProjTable               projTable;
        ProjPost                projPost;
        ProjRevRecContractLine projRevRecContractLine;

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            
            while select RecId from projRevRecContractLine
            where projRevRecContractLine.RevenueRecognitionId == _projId
            join RecId from projOnAccTrans
            where projOnAccTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
                join projInvoiceOnAcc
                    where projInvoiceOnAcc.TransId == projOnAccTrans.TransId
                        join projInvoiceOnAccDetail
                            where projInvoiceOnAccDetail.InvoiceRefRecId == projInvoiceOnAcc.RecId &&
                                projInvoiceOnAccDetail.wipPeriod == this.parmPeriodTo()
            {
                projInvoiceOnAcc.selectForUpdate(true);
                projInvoiceOnAccDetail.selectForUpdate(true);
                projPost = ProjPost::newEnterOnAccEstimate(projInvoiceOnAcc,projInvoiceOnAccDetail,_ledgerVoucher,this.parmPeriodTo(),this.checkPostOnAcc(),this.isReversal(),false);
                if (this.parmBeginningBalance() && !this.elimination())
                {
                    projPost.parmPostToGeneralLedger(false);
                }
                projPost.postTrans();

                projInvoiceOnAcc.selectForUpdate(true);
                projInvoiceOnAccDetail.selectForUpdate(true);
                projPost = ProjPost::newEnterOnAccEstimateInvoice(projInvoiceOnAcc,projInvoiceOnAccDetail,this.parmPeriodTo());
                if (this.parmBeginningBalance() && !this.elimination())
                {
                    projPost.parmPostToGeneralLedger(false);
                }
                projPost.postTrans();
            }
        }
        else
        {

        while select RecId from projTable
            where projTable.wipProject == _projId
            join RecId from projOnAccTrans
            where projOnAccTrans.ProjID == projTable.ProjId
                join projInvoiceOnAcc
                    where projInvoiceOnAcc.TransId == projOnAccTrans.TransId
                        join projInvoiceOnAccDetail
                            where projInvoiceOnAccDetail.InvoiceRefRecId == projInvoiceOnAcc.RecId &&
                                projInvoiceOnAccDetail.wipPeriod == this.parmPeriodTo()
        {
            projInvoiceOnAcc.selectForUpdate(true);
            projInvoiceOnAccDetail.selectForUpdate(true);
            projPost = ProjPost::newEnterOnAccEstimate(projInvoiceOnAcc,projInvoiceOnAccDetail,_ledgerVoucher,this.parmPeriodTo(),this.checkPostOnAcc(),this.isReversal(),false);
            if (this.parmBeginningBalance() && !this.elimination())
            {
                projPost.parmPostToGeneralLedger(false);
            }
            projPost.postTrans();

            projInvoiceOnAcc.selectForUpdate(true);
            projInvoiceOnAccDetail.selectForUpdate(true);
            projPost = ProjPost::newEnterOnAccEstimateInvoice(projInvoiceOnAcc,projInvoiceOnAccDetail,this.parmPeriodTo());
            if (this.parmBeginningBalance() && !this.elimination())
            {
                projPost.parmPostToGeneralLedger(false);
            }
            projPost.postTrans();
        }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjControlPeriodTableFields</Name>
				<Source><![CDATA[
    protected void setProjControlPeriodTableFields(ProjControlPeriodTable _projControlPeriodTable, LedgerVoucher _ledgerVoucher)
    {
        _projControlPeriodTable.PeriodStatus = this.projControlPeriodStatusNew();
        _projControlPeriodTable.VoucherPosted = _ledgerVoucher.lastVoucher();
        _projControlPeriodTable.VoucherDatePosted = _ledgerVoucher.lastTransDate();
        if (this.elimination() && this.isReversal())
        {
            _projControlPeriodTable.Elimination = NoYes::No;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePeriod</Name>
				<Source><![CDATA[
    protected void updatePeriod(LedgerVoucher _ledgerVoucher)
    {
        ProjControlPeriodTable  projControlPeriodTable  = ProjControlPeriodTable::findUsingBegBal(this.parmProjId(), controlId,
            periodFrom, this.parmBeginningBalance(), projControlVersion, true);

        if (projControlPeriodTable.RecId)
        {
            this.setProjControlPeriodTableFields(projControlPeriodTable, _ledgerVoucher);
            projControlPeriodTable.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjTable</Name>
				<Source><![CDATA[
    protected void updateProjTable()
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjTrans</Name>
				<Source><![CDATA[
    protected void updateProjTrans()
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRevenue</Name>
				<Source><![CDATA[
    public void updateRevenue(
        ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher           _ledgerVoucher)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRevenueForEstimateCategoryOnly</Name>
				<Source><![CDATA[
    public void updateRevenueForEstimateCategoryOnly(ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher _ledgerVoucher)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePeriod</Name>
				<Source><![CDATA[
    public boolean validatePeriod(ProjControlPeriodTable  _projControlPeriodTable)
    {
        boolean                         ret = true;
        ProjControlPeriodTableColumn    projControlPeriodTableColumnEstimate;

        if (_projControlPeriodTable.projTable().Type == ProjType::Investment)
        {
            switch (_projControlPeriodTable.EstimateOutput)
            {
                case ProjEstimateOutput::Ledger:
                    if (! _projControlPeriodTable.LedgerDimension)
                    {
                        ret = checkFailed("@Proj:Proj_Ledger_Elimination");
                    }
                    break;

                case ProjEstimateOutput::Asset:
                    if (! _projControlPeriodTable.AssetIdNew)
                    {
                        ret = checkFailed("@Proj:Proj_Asset_Elimination");
                    }
                    break;

                case ProjEstimateOutput::Project:
                    if (! _projControlPeriodTable.LinePropertyIdNew)
                    {
                        ret = checkFailed("@Proj:Proj_LineProperty_Elimination");
                    }
                    if (! _projControlPeriodTable.ProjIdNew)
                    {
                        ret = checkFailed("@Proj:Proj_Project_Elimination");
                    }
                    if (! _projControlPeriodTable.CategoryNew)
                    {
                        ret = checkFailed("@Proj:Proj_Category_Elimination");
                    }
                    if (!_projControlPeriodTable.checkActivity())
                    {
                        ret = false;
                    }
                    if (!_projControlPeriodTable.checkReqActivity())
                    {
                        ret = checkFailed("@Proj:Proj_Activity_Elimination");
                    }
                    if (! _projControlPeriodTable.QtyCostNew)
                    {
                        ret = checkFailed("@Proj:Proj_Quantity_Elimination");
                    }
                    break;
            }
        }
        else
        {
            projControlPeriodTableColumnEstimate    = ProjControlPeriodTableColumn::find(_projControlPeriodTable.ProjId,
                                                                                         _projControlPeriodTable.ControlId,
                                                                                         _projControlPeriodTable.PeriodFrom,
                                                                                         _projControlPeriodTable.Version,
                                                                                         ProjEstimateColumn::Estimate);

            if (projControlPeriodTableColumnEstimate.plCostAccCost)
            {
                if (!ProjRevRecHelper::getAccruedCostCategoryId(_projControlPeriodTable))
                {
                    ret = checkFailed("@SYS89910");
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePosting</Name>
				<Source><![CDATA[
    protected boolean validatePosting(ProjControlPeriodTable _projControlPeriodTable)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipPost</Name>
				<Source><![CDATA[
    protected void wipPost(
        ProjControlPeriodTable _projControlPeriod,
        LedgerVoucher         _ledgerVoucher)
    {
        ProjTable               projTable;
        ProjRevRecContractLine projRevRecContractLine;

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select  projRevRecContractLine
            where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId
            {
                PSAContractLineItems contractLine = PSAContractLineItems::find(projRevRecContractLine.ContractLineNum);
                if (contractLine.IncludeHourTrans && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice)
                {
                    this.wipPostEmpl(_projControlPeriod, _ledgerVoucher, projTable.ProjId);
                }

                if (contractLine.IncludeExpenseTrans && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice)
                {
                    this.wipPostCost(_projControlPeriod, _ledgerVoucher, projTable.ProjId);
                }
                if (contractLine.IncludeItemTrans && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice)
                {
                    this.wipPostItem(_projControlPeriod, _ledgerVoucher, projTable.ProjId);
                }
            }
        }
        else
        {
        while select ProjId, ProjInvoiceProjId from projTable
            where projTable.wipProject == _projControlPeriod.ProjId
        {
            boolean multipleContractLinesFeatureEnabled = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();
            if (!multipleContractLinesFeatureEnabled ||
                ProjMultipleContractLinesForProjectFeatureHelper::isTransTypeIncludedByBillingMethod(projTable.ProjId, projTable.ProjInvoiceProjId, ProjTransType::Hour, ProjContractBillingMethod::FixedPrice))
            {
                this.wipPostEmpl(_projControlPeriod, _ledgerVoucher, projTable.ProjId);
            }

            if (!multipleContractLinesFeatureEnabled ||
                ProjMultipleContractLinesForProjectFeatureHelper::isTransTypeIncludedByBillingMethod(projTable.ProjId, projTable.ProjInvoiceProjId, ProjTransType::Cost, ProjContractBillingMethod::FixedPrice))
            {
                this.wipPostCost(_projControlPeriod, _ledgerVoucher, projTable.ProjId);
            }
            if (!multipleContractLinesFeatureEnabled ||
                ProjMultipleContractLinesForProjectFeatureHelper::isTransTypeIncludedByBillingMethod(projTable.ProjId, projTable.ProjInvoiceProjId, ProjTransType::Item, ProjContractBillingMethod::FixedPrice))
            {
                this.wipPostItem(_projControlPeriod, _ledgerVoucher, projTable.ProjId);
            }
        }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipPostCost</Name>
				<Source><![CDATA[
    protected void wipPostCost(
        ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher           _ledgerVoucher,
        ProjId                  _projId
        )
    {
        ProjCostTrans           projCostTrans;
        ProjCostTransCost       projCostTransCost;
        ProjTrans               projTrans;
        ProjLedgerStatus        projLedgerStatusTo;
        ProjPost                projPost;
        ProjWIPTable            projWIPTable;
        ProjControlCategory     projControlCategory;
        ProjTable projTable;
        ProjRevRecContractLine projRevRecContractLine;
        boolean useBegBal = this.parmBeginningBalance() == NoYes::Yes;

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select projRevRecContractLine
            where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId
        join forupdate projCostTrans
            where projCostTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
                && projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
                && ((useBegBal && projCostTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                    || (!useBegBal && projCostTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                    join forupdate projCostTransCost
                    where projCostTransCost.TransId == projCostTrans.TransId &&
                            projCostTransCost.TransStatus == ProjTransStatus::Estimated &&
                            projCostTransCost.wipPeriod <= _projControlPeriod.PeriodTo
                    exists join projWIPTable
                        where projWIPTable.ProjId == _projControlPeriod.ProjId
                    exists join projControlCategory
                        where projControlCategory.ControlId == projWIPTable.ControlId
                            && projControlCategory.CategoryId == projCostTrans.CategoryId
            {
                projTrans   = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
                projLedgerStatusTo =  this.ledgerStatusCostTo(projTrans);
                if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
                {
                    projPost = ProjPost::newEnterCost_TrxDetail(projCostTrans, projCostTransCost, _ledgerVoucher, projLedgerStatusTo, ProjOrigin::PostEstimate);
                    projPost.postTrans();
                    this.insertControlTrans(_projControlPeriod,ProjWIPType::Cost,projTrans.transCostMST(),projCostTrans.TransId);
                }
            }
        }
        else
        {
        while select forupdate projCostTrans
            where projCostTrans.ProjId == _projId
                && projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
                && ((useBegBal && projCostTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                    || (!useBegBal && projCostTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                    join forupdate projCostTransCost
                    where projCostTransCost.TransId == projCostTrans.TransId &&
                            projCostTransCost.TransStatus == ProjTransStatus::Estimated &&
                            projCostTransCost.wipPeriod <= _projControlPeriod.PeriodTo
                    exists join projTable
                        where projTable.ProjId == projCostTrans.ProjId
                    exists join projWIPTable
                        where projWIPTable.ProjId == projTable.WIPProject
                    exists join projControlCategory
                        where projControlCategory.ControlId == projWIPTable.ControlId
                            && projControlCategory.CategoryId == projCostTrans.CategoryId
        {
            projTrans   = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
            projLedgerStatusTo =  this.ledgerStatusCostTo(projTrans);
            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                projPost = ProjPost::newEnterCost_TrxDetail(projCostTrans, projCostTransCost, _ledgerVoucher, projLedgerStatusTo, ProjOrigin::PostEstimate);
                projPost.postTrans();
                this.insertControlTrans(_projControlPeriod,ProjWIPType::Cost,projTrans.transCostMST(),projCostTrans.TransId);
            }
        }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipPostEmpl</Name>
				<Source><![CDATA[
    protected void wipPostEmpl(
        ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher           _ledgerVoucher,
        ProjId                  _projId
        )
    {
        ProjEmplTrans           projEmplTrans;
        ProjEmplTransCost       projEmplTransCost;
        ProjTrans               projTrans;
        ProjLedgerStatus        projLedgerStatusTo;
        ProjPost                projPost;
        PSAIndirectComponentTrans   psaIndirectComponentTrans;
        ProjTrans               projTransEmplTransIndirectCost;
        ProjWIPTable            projWIPTable;
        ProjControlCategory     projControlCategory;
        ProjTable projTable;
        ProjRevRecContractLine projRevRecContractLine;
        boolean useBegBal = this.parmBeginningBalance() == NoYes::Yes;

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select forupdate projRevRecContractLine
            where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId
            join forupdate projEmplTrans
            where projEmplTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
                    join forupdate projEmplTransCost
                    where projEmplTransCost.TransId == projEmplTrans.TransId &&
                            projEmplTransCost.TransStatus == ProjTransStatus::Estimated &&
                            projEmplTransCost.wipPeriod <= _projControlPeriod.PeriodTo &&
                            ((useBegBal && projEmplTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                              || (!useBegBal && projEmplTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                    exists join projWIPTable
                        where projWIPTable.ProjId == _projControlPeriod.ProjId
                    exists join projControlCategory
                        where projControlCategory.ControlId == projWIPTable.ControlId
                            && projControlCategory.CategoryId == projEmplTrans.CategoryId
            {
                projTrans   = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
                projLedgerStatusTo =  this.ledgerStatusCostTo(projTrans);
                if (projTrans.ledgerStatusCost() != ProjLedgerStatus::Never)
                {
                    if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
                    {
                        while select psaIndirectComponentTrans
                        where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                            psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                            psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                        {
                            projTransEmplTransIndirectCost = ProjTrans::newProjEmplTransIndirectCost(projEmplTrans, projEmplTransCost, psaIndirectComponentTrans);
                            projPost = ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::PostEstimate, false, false, psaIndirectComponentTrans);
                            projPost.postTrans();
                            this.insertControlTrans(_projControlPeriod,ProjWIPType::Cost,projTransEmplTransIndirectCost.transCostMST(),projEmplTrans.TransId);
                        }
                        projPost = ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::PostEstimate);
                        projPost.postTrans();
                        this.insertControlTrans(_projControlPeriod,ProjWIPType::Cost,projTrans.transCostMST(),projEmplTrans.TransId);
                    }
                }
            }
        }
        else
        {

        while select forupdate projEmplTrans
            where projEmplTrans.ProjId == _projId
                    join forupdate projEmplTransCost
                    where projEmplTransCost.TransId == projEmplTrans.TransId &&
                            projEmplTransCost.TransStatus == ProjTransStatus::Estimated &&
                            projEmplTransCost.wipPeriod <= _projControlPeriod.PeriodTo &&
                            ((useBegBal && projEmplTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                              || (!useBegBal && projEmplTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                    exists join projTable
                        where projTable.ProjId == projEmplTrans.ProjId
                    exists join projWIPTable
                        where projWIPTable.ProjId == projTable.WIPProject
                    exists join projControlCategory
                        where projControlCategory.ControlId == projWIPTable.ControlId
                            && projControlCategory.CategoryId == projEmplTrans.CategoryId
        {
            projTrans   = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
            projLedgerStatusTo =  this.ledgerStatusCostTo(projTrans);
            if (projTrans.ledgerStatusCost() != ProjLedgerStatus::Never)
            {
                if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
                {
                    while select psaIndirectComponentTrans
                        where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                            psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                            psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                    {
                        projTransEmplTransIndirectCost = ProjTrans::newProjEmplTransIndirectCost(projEmplTrans, projEmplTransCost, psaIndirectComponentTrans);
                        projPost = ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::PostEstimate, false, false, psaIndirectComponentTrans);
                        projPost.postTrans();
                        this.insertControlTrans(_projControlPeriod,ProjWIPType::Cost,projTransEmplTransIndirectCost.transCostMST(),projEmplTrans.TransId);
                    }
                    projPost = ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::PostEstimate);
                    projPost.postTrans();
                    this.insertControlTrans(_projControlPeriod,ProjWIPType::Cost,projTrans.transCostMST(),projEmplTrans.TransId);
                }
            }
        }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipPostItem</Name>
				<Source><![CDATA[
    protected void wipPostItem(
        ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher           _ledgerVoucher,
        ProjId                  _projId
        )
    {
        ProjItemTrans           projItemTrans;
        ProjItemTransCost       projItemTransCost;
        ProjTrans               projTrans;
        ProjLedgerStatus        projLedgerStatusTo;
        ProjPost                projPost;
        ProjWIPTable            projWIPTable;
        ProjControlCategory     projControlCategory;
        ProjTable projTable;
        ProjRevRecContractLine projRevRecContractLine;
        boolean useBegBal = this.parmBeginningBalance() == NoYes::Yes;

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select projRevRecContractLine
            where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId
        join forupdate projItemTrans
            where projItemTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
            join forupdate projItemTransCost
                where projItemTransCost.InventTransId == projItemTrans.InventTransId &&
                    projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId &&
                    projItemTransCost.TransStatus == ProjTransStatus::Estimated &&
                    projItemTransCost.wipPeriod <= _projControlPeriod.PeriodTo &&
                    ((useBegBal && projItemTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                              || (!useBegBal && projItemTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                exists join projWIPTable
                    where projWIPTable.ProjId == _projControlPeriod.ProjId
                exists join projControlCategory
                    where projControlCategory.ControlId == projWIPTable.ControlId
                        && projControlCategory.CategoryId == projItemTrans.CategoryId
            {
                projTrans   = ProjTrans::newProjItemTransCost(projItemTransCost);
                projLedgerStatusTo =  this.ledgerStatusCostTo(projTrans);
                if (projTrans.ledgerStatusCost() != ProjLedgerStatus::Never)
                {
                    if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
                    {
                        projPost = ProjPost::newEnterCost_TrxDetail(projItemTrans, projItemTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::PostEstimate);
                        projPost.postTrans();
                        this.insertControlTrans(_projControlPeriod,ProjWIPType::Cost,projTrans.transCostMST(),ProjItemTrans::findInvent(projItemTransCost.InventTransId,projItemTransCost.ProjAdjustRefId).ProjTransId);
                    }
                }
            }
        }
        else
        {
        while select forupdate projItemTrans
            where projItemTrans.ProjId == _projId
            join forupdate projItemTransCost
                where projItemTransCost.InventTransId == projItemTrans.InventTransId &&
                    projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId &&
                    projItemTransCost.TransStatus == ProjTransStatus::Estimated &&
                    projItemTransCost.wipPeriod <= _projControlPeriod.PeriodTo &&
                    ((useBegBal && projItemTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                              || (!useBegBal && projItemTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                exists join projTable
                    where projTable.ProjId == projItemTrans.ProjId
                exists join projWIPTable
                    where projWIPTable.ProjId == projTable.WIPProject
                exists join projControlCategory
                    where projControlCategory.ControlId == projWIPTable.ControlId
                        && projControlCategory.CategoryId == projItemTrans.CategoryId
        {
            projTrans   = ProjTrans::newProjItemTransCost(projItemTransCost);
            projLedgerStatusTo =  this.ledgerStatusCostTo(projTrans);
            if (projTrans.ledgerStatusCost() != ProjLedgerStatus::Never)
            {
                if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
                {
                    projPost = ProjPost::newEnterCost_TrxDetail(projItemTrans, projItemTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::PostEstimate);
                    projPost.postTrans();
                    this.insertControlTrans(_projControlPeriod,ProjWIPType::Cost,projTrans.transCostMST(),ProjItemTrans::findInvent(projItemTransCost.InventTransId,projItemTransCost.ProjAdjustRefId).ProjTransId);
                }
            }
        }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static ProjControlPosting construct(Args _args)
    {
        ProjControlPeriodTable  projControlPeriodTable;
        ProjControlPeriodStatus projControlPeriodStatus;
        ProjControlPosting      projControlPosting;

        projControlPeriodStatus      = _args.parmEnum();

        if (_args.dataset() == tableNum(ProjControlPeriodTable))
        {
            projControlPeriodTable   = _args.record();
        }

        if (projControlPeriodTable.Elimination)
        {
            projControlPosting = new ProjControlPostingEliminate();
        }
        else
        {
            switch (projControlPeriodStatus)
            {
                case ProjControlPeriodStatus::Posted:
                    projControlPosting = new ProjControlPostingPosted();
                    break;

                case ProjControlPeriodStatus::Reversal:
                    projControlPosting = new ProjControlPostingReverse();
                    break;

                default:
                    throw error(strFmt("@SYS22828","@SYS56216"));
            }
        }

        return projControlPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    protected static ClassDescription description()
    {
        return "@SYS55483";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        ProjControlPeriodTable  projControlPeriodTable;
        ProjControlPosting      projControlPosting;
        ProjControlType         projControlType;
        QueryBuildDataSource    projControlPeriodTable_ds;
        QueryBuildDataSource    projWIPTable_Ds;
        container               estimateRecIdRange;

        MenuFunction            menuItemRun;
        Args                    parmArgs;

        if (!args)
        {
            throw error("@SYS25407");
        }

        if ( args.parmEnumType()  && args.parmEnumType() == enumNum(ProjControlType) )
        {
            projControlType = args.parmEnum();
        }

        if (projControlType == projControlType::PeriodicPost && args.multiSelectionContext() && args.multiSelectionContext().getFirst())
        {
            projControlPeriodTable = args.multiSelectionContext().getFirst() ? args.multiSelectionContext().getFirst() : args.record();
            projControlPosting = ProjControlPosting::new_ControlPosting(projControlType, projControlPeriodTable);
            projControlPosting.parmVersion(0);

            while (projControlPeriodTable)
            {
                estimateRecIdRange += projControlPeriodTable.RecId;
                projControlPeriodTable = args.multiSelectionContext().getNext();
            }

            projWIPTable_Ds = projControlPosting.queryRun().query().dataSourceTable(tableNum(ProjWIPTable));
            projControlPeriodTable_ds = projControlPosting.queryRun().query().dataSourceTable(tableNum(ProjControlPeriodTable));
            projWIPTable_Ds.clearRange(fieldNum(ProjWIPTable, projId));
            projWIPTable_Ds.clearRange(fieldNum(ProjWIPTable, controlId));
            projControlPosting.parmSelectedRecIds(con2Str(estimateRecIdRange, ','));

            // this is to persist the selected RecIds
            projControlPosting.saveLast();
        }
        else
        {
            if (args.record() && args.record().TableId == tableNum(ProjControlPeriodTable))
            {
                projControlPeriodTable   = args.record();
            }
            projControlPosting = ProjControlPosting::new_ControlPosting(projControlType, projControlPeriodTable);
        }

        if (projControlPosting.prompt())
        {
            projControlPosting.runOperation();

            if (projControlPosting.parmProjControlTypeOutput() != ProjControlTypeOutput::NothingToPrint)
            {
                menuItemRun = new MenuFunction(menuitemOutputStr(projEstimateList),MenuItemType::Output);
                parmArgs    = new Args();

                args.parmObject(projControlPosting);
                menuItemRun.run(parmArgs);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new_ControlPosting</Name>
				<Source><![CDATA[
    public static ProjControlPosting new_ControlPosting(
        ProjControlType         _projControlType,
        ProjControlPeriodTable  _projControlPeriod
    )
    {
        ProjControlPosting     projControlPosting;

        if (_projControlPeriod.Elimination)
        {
            projControlPosting = new ProjControlPostingEliminate();
        }
        else
        {
            switch (_projControlType)
            {
                case ProjControlType::Post:
                    projControlPosting  = new ProjControlPostingPosted();
                    break;

                case ProjControlType::Reversal:
                    projControlPosting  = new ProjControlPostingReverse();
                    break;

                case ProjControlType::Eliminate:
                    projControlPosting  = new ProjControlPostingEliminate();
                    break;

                case ProjControlType::PeriodicPost:
                    projControlPosting  = new ProjControlPostingPosted();
                    break;

                case ProjControlType::EliminateReverse:
                    projControlPosting  = new ProjControlPostingEliminateRev();
                    break;
            }
        }

        if (_projControlPeriod)
        {
            projControlPosting.parmPeriodic(false);
            projControlPosting.parmProjId(_projControlPeriod.ProjId);
            projControlPosting.parmProjControlId(_projControlPeriod.ControlId);
            projControlPosting.parmPeriodFrom(_projControlPeriod.PeriodFrom);
            projControlPosting.parmVersion(_projControlPeriod.Version);
            projControlPosting.parmTransDate(_projControlPeriod.PeriodTo);
            projControlPosting.parmAcknowledgementDate(_projControlPeriod.PeriodTo);
            projControlPosting.parmPeriodTo(_projControlPeriod.PeriodTo);
            projControlPosting.parmProjPeriodId(_projControlPeriod.PeriodId);
            projControlPosting.parmBeginningBalance(_projControlPeriod.BeginningBalance);
            projControlPosting.parmIsContractLineUsed(ProjWIPTable::find(_projControlPeriod.ProjId).IsContractLineUsed);
        }
        else
        {
            projControlPosting.parmPeriodic(true);
            projControlPosting.parmProjId('');
            projControlPosting.parmProjControlId('');
            projControlPosting.parmPeriodFrom(dateNull());
            projControlPosting.parmVersion(0);
            projControlPosting.parmTransDate(dateNull());
        }

        projControlPosting.parmSelectedRecIds('');
        projControlPosting.parmShowQueryValues(projControlPosting.parmPeriodic());
        projControlPosting.setQueryValues();

        projControlPosting.saveLast();

        return projControlPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipCreateControlTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the creation of the project control transactions must be skipped.
    /// </summary>
    /// <param name = "_projControlPeriod">
    /// A <c>ProjControlPeriodTable</c> record.
    /// </param>
    /// <returns>
    /// true if the creation of the project control transactions must be skipped; otherwise, false.
    /// </returns>
    protected boolean skipCreateControlTrans(ProjControlPeriodTable _projControlPeriod)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEstimate</Name>
				<Source><![CDATA[
    protected void postEstimate(ProjControlPeriodTable    projControlPeriod, LedgerVoucher    _ledgerVoucher)
    {
        if (!this.validatePosting(projControlPeriod))
        {
            throw error("@SYS21628");
        }

        if (projControlPeriod)
        {
            if (this.validatePeriod(projControlPeriod))
            {
                ProjTable projTableLoc = ProjTable::find(projControlPeriod.ProjId);
                if(isContractLineUsed && contractLineBasedRevRecFeature)
                {
                    projRevProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(ProjWIPTable::find(projControlPeriod.ProjId));
                }
                else if (isMultipleContractLineFeatureEnabled)
                {
                    projRevProfile = ProjRevRecHelper::getRevProfile(projTableLoc, ProjContractBillingMethod::FixedPrice);
                }
                else
                {
                    projGroup = ProjGroup::find(projTableLoc.ProjGroupId);
                }
                this.parmProjId(projControlPeriod.ProjId);
                controlId = projControlPeriod.ControlId;
                periodFrom = projControlPeriod.PeriodFrom;
                projControlVersion = projControlPeriod.Version;
                beginningBalance = projControlPeriod.BeginningBalance;

                if (this.doAction(projControlPeriod))
                {
                    this.setProgress(projControlPeriod);

                    if (!this.skipCreateControlTrans(projControlPeriod))
                    {
                        this.createControlTrans(projControlPeriod);
                    }

                    if (this.checkCreateRevenueTrans())
                    {
                        this.insertRevenue(projControlPeriod, _ledgerVoucher);
                    }

                    if (this.checkPostRevenueReverse())
                    {
                        this.updateRevenue(projControlPeriod, _ledgerVoucher);
                    }

                    else if(isContractLineUsed && contractLineBasedRevRecFeature) 
                    {
                        if(ProjRevRecHelper::getCompletePrincipleContractLine(ProjWIPTable::find(this.parmProjId())) != ProjCompletePrincip::CompletedContract)
                        {
                            this.updateRevenueForEstimateCategoryOnly(projControlPeriod, _ledgerVoucher);
                        }
                        
                    }
                    else if (ProjRevRecHelper::getCompletePrincipleForProjTable(ProjTable::find(this.parmProjId())) != ProjCompletePrincip::CompletedContract)
                    {
                        //This method will get called if 'Fee' is set to no on contract line and ProjCompletePrinciple is not CompletedContract
                        this.updateRevenueForEstimateCategoryOnly(projControlPeriod, _ledgerVoucher);
                    }

                    this.updateAccruedOnAcc(projControlPeriod.ProjId,_ledgerVoucher);

                    this.estimateWIPpost(projControlPeriod, _ledgerVoucher);

                    this.updateAccruedCost(projControlPeriod, _ledgerVoucher);

                    if (!isMultipleContractLineFeatureEnabled && projGroup.ProjType  == ProjType::Investment && this.elimination())
                    {
                        this.eliminateInvestment(projControlPeriod, _ledgerVoucher);
                    }

                    this.updatePeriod(_ledgerVoucher);
                    this.updateProjTable();
                    this.updateProjTrans();

                    if (this.parmShowInfoLog())
                    {
                        info(strFmt("@SYS55664",projControlPeriod.ProjId,projControlPeriod.PeriodTo,projControlPeriod.Version));
                    }
                }
            }
            else
            {
                throw error("@SYS21628");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipEstimateWIPPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the creation of WIP related project control transactions must be skipped.
    /// </summary>
    /// <param name = "_projControlPeriod">
    /// A <c>ProjControlPeriodTable</c> record.
    /// </param>
    /// <returns>
    /// true if the creation of WIP related project control transactions must be skipped; otherwise, false.
    /// </returns>
    protected boolean skipEstimateWIPPost(ProjControlPeriodTable _projControlPeriod)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimateWIPpost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates and executes WIP related project control transaction posting.
    /// </summary>
    /// <param name = "_projControlPeriod">
    /// A <c>ProjControlPeriodTable</c> record.
    /// </param>
    /// <param name = "_ledgerVoucher">
    /// An instance of the <c>LedgerVoucher</c> object which will be used in the project transaction posting.
    /// </param>
    protected void estimateWIPpost(ProjControlPeriodTable _projControlPeriod, LedgerVoucher _ledgerVoucher)
    {
        if (!this.skipEstimateWIPPost(_projControlPeriod))
        {
            this.wipPost(_projControlPeriod, _ledgerVoucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSelectedRecIds</Name>
				<Source><![CDATA[
    public str parmSelectedRecIds(str _recIds = selectedRecIds)
    {
        selectedRecIds = _recIds;

        return selectedRecIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompletePrinciple</Name>
				<Source><![CDATA[
    private ProjCompletePrincip getCompletePrinciple()
    {
        return (isMultipleContractLineFeatureEnabled  || (isContractLineUsed && contractLineBasedRevRecFeature)) ? projRevProfile.CompletePrinciple : projGroup.CompletePrincip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMatchingPrinciple</Name>
				<Source><![CDATA[
    private ProjMatchingPrincip getMatchingPrinciple()
    {
        return (isMultipleContractLineFeatureEnabled || (isContractLineUsed && contractLineBasedRevRecFeature)) ? projRevProfile.MatchingPrinciple : projGroup.MatchingPrincip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesPriceMatchingPrinciple</Name>
				<Source><![CDATA[
    protected internal ProjSalesPriceMatchingPrincip getSalesPriceMatchingPrinciple()
    {
        return (isMultipleContractLineFeatureEnabled || (isContractLineUsed && contractLineBasedRevRecFeature)) ? projRevProfile.SalesPriceMatchingPrinciple : projGroup.SalesPriceMatchingPrincip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoicePosting</Name>
				<Source><![CDATA[
    private ProjLedgerStatusOnAcc getInvoicePosting()
    {
        return (isMultipleContractLineFeatureEnabled || (isContractLineUsed && contractLineBasedRevRecFeature)) ? projRevProfile.OnAccLedgerStatus : projGroup.InvoicePosting;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>