<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustPaymReconcilImport_EP_Return_BR</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class CustPaymReconcilImport_EP_Return_BR extends CustPaymReconciliationImport implements BatchRetryable
{
    #EP_Return_BR
    dataAreaId                 companyName;
    CustVendAC                 accountNum;
    date                       dueDate;
    InvoiceId                  custinvoiceId;
    TransDate                  transDate;
    CustCashDiscAmount         custCashDiscAmount;
    FinInterestAmount_BR       finInterestAmount_BR;
    AmountCurDebCred           amountCurDebCred;
    RealBase                   feevalue;
    EP_FileReturnSequencialNum retFileSequenceNum;
    EPBankInvoiceId_BR         bankInvoiceId;
    boolean                    retFilesequenceCheck;
    container                  datasizeBatchHeader[];
    FineAmount_BR              fineAmount_BR;
    EPCompanyDocument_BR       companyDocument;
    container                  specRecID;
    boolean                    readFileHeader;
    EPLayoutReturnOccCode_BR   layoutReturnOccCode;
    boolean                    isFileRead;
    boolean                    check;
    protected LedgerJournalTransPayment_BR ledgerJournalTransPaymentTmp;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>clearLocalData</Name>
				<Source><![CDATA[
    public void clearLocalData()
    {
        companyName          = '';
        accountNum           = '';
        custinvoiceId        = '';
        custCashDiscAmount   = 0 ;
        finInterestAmount_BR = 0 ;
        amountCurDebCred     = 0 ;
        feevalue             = 0 ;
        bankInvoiceId        = "";
        transDate            = dateNull();
        paymStatusCur        = CustVendPaymStatus::None;
        companyDocument      = '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>companyuse</Name>
				<Source><![CDATA[
    public void companyuse(str _companyUse)
    {
        if (_companyUse)
        {
            companyName = this.getFieldData_BR(substr(_companyUse, 1, 3));
            accountNum  = this.getFieldData_BR(substr(_companyUse, 4, 10));
            dueDate     = str2date(this.getFieldData_BR(substr(_companyUse, 16, 25)), 123);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFineInterestAmt</Name>
				<Source><![CDATA[
    public void getFineInterestAmt(InterestAmountCur _fineAndInterestAmts, EPCompanyDocument_BR _companyDocument)
    {
        LedgerJournalTransPayment_BR ledgerJournalTransPayment_BR;

        select FineAmountCur_BR from ledgerJournalTransPayment_BR
            where ledgerJournalTransPayment_BR.EPCompanyDocument_BR == _companyDocument;

        if (_fineAndInterestAmts)
        {
            if (ledgerJournalTransPayment_BR.FineAmountCur_BR <= _fineAndInterestAmts)
            {
                fineAmount_BR        = ledgerJournalTransPayment_BR.FineAmountCur_BR;
                finInterestAmount_BR = _fineAndInterestAmts - fineAmount_BR;
            }
            else
            {
                fineAmount_BR = _fineAndInterestAmts;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interfaceName</Name>
				<Source><![CDATA[
    public ClassName interfaceName()
    {
        return "@GLS423";
    }

]]></Source>
			</Method>
			<Method>
				<Name>openFile</Name>
				<Source><![CDATA[
    boolean openFile()
    {
        boolean ret = false;
        int     fieldcountloc;

        this.clearContainerData_BR();

        for (fieldcountloc = 1; fieldcountloc < this.parmFieldCount(); fieldcountloc += 1)
        {
            if (fieldDimensions[fieldcountloc]  )
                if (conpeek(fieldDimensions[fieldcountloc], 1) == #Command      &&
                    conpeek(fieldDimensions[fieldcountloc], 2) == #RegisterType &&
                    conpeek(fieldDimensions[fieldcountloc], 5 ) != "" )
            {
                if (this.parmlayoutType() == ConfLayoutTypesChoice_BR::FixedLength)
                        datasize[1] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 8),
                                       conpeek(fieldDimensions[fieldcountloc], 5),
                                       conpeek(fieldDimensions[fieldcountloc], 4)];
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
                        datasize[1] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 5),
                                       conpeek(fieldDimensions[fieldcountloc], 4)];
            }

            if ( conpeek(fieldDimensions[fieldcountloc], 1) == tablestr(ledgerJournalTransPayment_BR)
                    && conpeek(fieldDimensions[fieldcountloc], 2) == fieldstr(ledgerJournalTransPayment_BR, EPCompanyDocument_BR))
            {
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::FixedLength)
                        datasize[2] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 8),
                                       conpeek(fieldDimensions[fieldcountloc], 5) ];
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
                        datasize[2] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 5)];
            }

            if (conpeek(fieldDimensions[fieldcountloc], 1) == tablestr(CustTrans)
                    && conpeek(fieldDimensions[fieldcountloc], 2) == fieldstr(CustTrans, Invoice))
            {
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::FixedLength)
                        datasize[3] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 8),
                                       conpeek(fieldDimensions[fieldcountloc], 5) ];
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
                        datasize[3] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 5)];
            }

            if ((conpeek(fieldDimensions[fieldcountloc], 1) == tablestr(CustTransOpen)
                    && conpeek(fieldDimensions[fieldcountloc], 2) == fieldstr(CustTransOpen, TransDate))
                    || (conpeek(fieldDimensions[fieldcountloc], 1) == tablestr(LedgerJournalTrans)
                    && conpeek(fieldDimensions[fieldcountloc], 2) == fieldstr(LedgerJournalTrans, TransDate)))
            {
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::FixedLength)
                        datasize[4] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 8),
                                       conpeek(fieldDimensions[fieldcountloc], 5),
                                       conpeek(fieldDimensions[fieldcountloc], 6)];
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
                        datasize[4] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 5),
                                       conpeek(fieldDimensions[fieldcountloc], 6)];
            }

            if (conpeek(fieldDimensions[fieldcountloc], 1) == tablestr(CustTransCashDisc)
                && conpeek(fieldDimensions[fieldcountloc], 2) == fieldstr(CustTransCashDisc, CashDiscAmount))
            {
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::FixedLength)
                        datasize[5] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 8),
                                       conpeek(fieldDimensions[fieldcountloc], 5),
                                       conpeek(fieldDimensions[fieldcountloc], 6)];
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
                        datasize[5] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 5),
                                       conpeek(fieldDimensions[fieldcountloc], 6)];
            }

            if (conpeek(fieldDimensions[fieldcountloc], 1) == tablestr(ledgerJournalTransPayment_BR)
                    && conpeek(fieldDimensions[fieldcountloc], 2) == fieldstr(ledgerJournalTransPayment_BR, FinInterestAmountCur_BR))
            {
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::FixedLength)
                        datasize[6] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 8),
                                       conpeek(fieldDimensions[fieldcountloc], 5),
                                       conpeek(fieldDimensions[fieldcountloc], 6)];
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
                        datasize[6] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 5),
                                       conpeek(fieldDimensions[fieldcountloc], 6)];
            }

            if ((conpeek(fieldDimensions[fieldcountloc], 1) == tablestr(CustTransOpen)
                        && conpeek(fieldDimensions[fieldcountloc], 2) == fieldstr(CustTransOpen, AmountCur))
                        || (conpeek(fieldDimensions[fieldcountloc], 1) == tablestr(LedgerJournalTrans)
                        && conpeek(fieldDimensions[fieldcountloc], 2) == fieldstr(LedgerJournalTrans, AmountCurCredit)))
            
            {
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::FixedLength)
                        datasize[7] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 8),
                                       conpeek(fieldDimensions[fieldcountloc], 5),
                                       conpeek(fieldDimensions[fieldcountloc], 6)];
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
                        datasize[7] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 5),
                                       conpeek(fieldDimensions[fieldcountloc], 6)];
            }
            if (conpeek(fieldDimensions[fieldcountloc], 1) == tablestr(CustVendPaymJournalFee)
                    && conpeek(fieldDimensions[fieldcountloc], 2) == fieldstr(CustVendPaymJournalFee, FeeValue))
            {
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::FixedLength)
                        datasize[8] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 8),
                                       conpeek(fieldDimensions[fieldcountloc], 5),
                                       conpeek(fieldDimensions[fieldcountloc], 6)];
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
                        datasize[8] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 5),
                                       conpeek(fieldDimensions[fieldcountloc], 6)];
            }
            if (conpeek(fieldDimensions[fieldcountloc], 1) == tablestr(EPRetOccCodes_BR)
                    && conpeek(fieldDimensions[fieldcountloc], 2) == fieldstr(EPRetOccCodes_BR, LayoutRetOccCode))
            {
                if ( datasize[9] == connull())
                {
                    if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::FixedLength)
                            datasize[9] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                           conpeek(fieldDimensions[fieldcountloc], 8),
                                           conpeek(fieldDimensions[fieldcountloc], 5) ];
                    if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
                            datasize[9] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                           conpeek(fieldDimensions[fieldcountloc], 5)];
                }
            }

            if (conpeek(fieldDimensions[fieldcountloc], 1) == tablestr(CustTransEPRemit_BR)
                    && conpeek(fieldDimensions[fieldcountloc], 2) == fieldstr(CustTransEPRemit_BR, BankInvoiceId))
            {
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::FixedLength)
                        datasize[10] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 8),
                                       conpeek(fieldDimensions[fieldcountloc], 5) ];
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
                        datasize[10] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 5)];
            }
            if (conpeek(fieldDimensions[fieldcountloc], 1) == tablestr(EP_FileSequenceNum_BR)
                    && conpeek(fieldDimensions[fieldcountloc], 2) == fieldstr(EP_FileSequenceNum_BR, FileReturnSequenceNumber)
                    && conpeek(fieldDimensions[fieldcountloc], 4) == ConfLayoutLineType_BR::Header)
            {
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::FixedLength)
                        datasize[11] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 8),
                                       conpeek(fieldDimensions[fieldcountloc], 5) ];
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
                        datasize[11] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 5)];
            }

            if (conpeek(fieldDimensions[fieldcountloc], 1) == tablestr(ledgerJournalTransPayment_BR)
                    && conpeek(fieldDimensions[fieldcountloc], 2) == fieldstr(ledgerJournalTransPayment_BR, FineAmountCur_BR))
            {
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::FixedLength)
                        datasize[12] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 8),
                                       conpeek(fieldDimensions[fieldcountloc], 5),
                                       conpeek(fieldDimensions[fieldcountloc], 6)];
                if ( this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
                        datasize[12] = [conpeek(fieldDimensions[fieldcountloc], 7),
                                       conpeek(fieldDimensions[fieldcountloc], 5),
                                       conpeek(fieldDimensions[fieldcountloc], 6)];
            }
        }
        if (this.parmlayoutType() == ConfLayoutTypesChoice_BR::FixedLength)
        {
            file = this.convertFileStreamToStreamIO();
        }

        if (this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
        {
            file = this.convertFileStreamToStreamIO(StreamType::CommaIo);
        }

        if (file)
        {
            if (file.status())
            {
                throw error("@SYS52680");
            }
            file.inFieldDelimiter('\r\n');
            file.inRecordDelimiter('\r\n');
            if (this.parmlayoutType() == ConfLayoutTypesChoice_BR::Delimited)
            file.inFieldDelimiter(delimiterChars);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the payment status on the record in the <c>SpecTrans</c> table.
    /// </summary>
    /// <param name="_journalNum">
    /// JournalNum of the transaction.
    /// </param>
    /// <returns>
    /// true if the payment status changed; otherwise, false.
    /// </returns>
    public boolean paymentStatus(LedgerJournalId _journalNum)
    {
        return this.paymentStatusV2(_journalNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymentStatusV2</Name>
				<Source><![CDATA[
    private boolean paymentStatusV2(LedgerJournalId _journalNum)
    {
        LedgerJournalTrans ledgerJournalTransLoc;
        SpecTrans          specTransLoc;
        boolean            ret = false;
        TransDate          transDateLoc;

        while select TransDate from ledgerJournalTransLoc
            where ledgerJournalTransLoc.JournalNum == _journalNum
            join PaymentStatus from specTransLoc
                where specTransLoc.SpecRecId == ledgerJournalTransLoc.RecId
                    && specTransLoc.SpecTableId == ledgerJournalTransLoc.TableId
                    && specTransLoc.SpecCompany == ledgerJournalTransLoc.DataAreaId
                    && (specTransLoc.PaymentStatus == CustVendPaymStatus::Recieved
                        || specTransLoc.PaymentStatus == CustVendPaymStatus::Sent
                        || specTransLoc.PaymentStatus == CustVendPaymStatus::None
                        || specTransLoc.PaymentStatus == CustVendPaymStatus::Confirmed)
        {
            switch (specTransLoc.PaymentStatus)
            {
                case CustVendPaymStatus::Recieved:
                case CustVendPaymStatus::Sent:
                case CustVendPaymStatus::None:
                    ret = true;
                    break;
                    
                case CustVendPaymStatus::Confirmed:
                    if (!transDateLoc)
                    {
                        transDateLoc = ledgerJournalTransLoc.TransDate;
                    }

                    if (transDateLoc != ledgerJournalTransLoc.TransDate)
                    {
                        ret = true;
                    }
                    break;

                default:
                    break;
            }

            if (ret)
            {
                break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRecord</Name>
				<Source><![CDATA[
    public void processRecord(container _record)
    {
        str fileLine;
        str regtypeloc;

        fineAmount_BR = 0.00;
        switch (this.parmlayoutType())

        {
            case ConfLayoutTypesChoice_BR::FixedLength:

                if (conpeek(_record, 1))
                {
                    fileLine = conpeek(_record, 1);
                }
                if (datasize[1])
                {
                    regtypeloc = this.getFieldData_BR(substr(fileLine, conpeek(datasize[1], 1), conpeek(datasize[1], 2)));
                }

                if ( regtypeloc == this.getFieldData_BR(conpeek(datasize[1], 3)))
                {
                    if (datasize[11] == connull())
                    {
                        retFileSequenceNum = '0'; // Uninformed and not obligatory since it's not in the layout
                    }
                    else if (this.getFieldData_BR(substr(fileLine, conpeek(datasize[11], 1), conpeek(datasize[11], 2)))
                            && conpeek(datasize[1],4) == ConfLayoutLineType_BR::Header)
                    {
                        if (EP_FileSequenceNum_BR::insertRetSeq(this.getFieldData_BR(substr(fileLine, conpeek(datasize[11], 1), conpeek(datasize[11], 2))), layoutGroupID) == true)
                        {
                            retFileSequenceNum = this.getFieldData_BR(substr(fileLine, conpeek(datasize[11], 1), conpeek(datasize[11], 2)));
                            isFileRead = true;
                        }
                        else
                        {
                            isFileImportedAlready = true;
                            isFileRead = false;
                        }
                    }

                    if (substr(fileLine, conpeek(datasize[2], 1), conpeek(datasize[2], 2)))
                    {
                        companyDocument = this.getFieldData_BR(substr(fileLine, conpeek(datasize[2], 1),conpeek(datasize[2], 2)));
                    }

                    if (substr(fileLine, conpeek(datasize[3], 1), conpeek(datasize[3], 2)))
                    {
                        custinvoiceId = this.getFieldData_BR(substr(fileLine, conpeek(datasize[3], 1), conpeek(datasize[3], 2)));
                    }

                    if (substr(fileLine, conpeek(datasize[4], 1), conpeek(datasize[4], 2)))
                    {
                        str fieldDate = this.getFieldData_BR(substr(fileLine, conpeek(datasize[4], 1), conpeek(datasize[4], 2)));

                        if (fieldDate)
                        {
                            transDate = this.parseDate(fieldDate, conpeek(datasize[4], 4));
                        }

                        if (!transDate)
                        {
                            transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                        }
                    }

                    if (substr(fileLine, conpeek(datasize[5], 1), conpeek(datasize[5], 2)))
                    {
                        custCashDiscAmount = this.processReturnAmount_BR(_record, 5, ConfLayoutTypesChoice_BR::FixedLength);
                    }

                    if (substr(fileLine, conpeek(datasize[6], 1), conpeek(datasize[6], 2)))
                    {
                        finInterestAmount_BR = this.processReturnAmount_BR(_record, 6, ConfLayoutTypesChoice_BR::FixedLength);
                    }

                    if (substr(fileLine, conpeek(datasize[7],1),conpeek(datasize[7],2)))
                    {
                        amountCurDebCred = this.processReturnAmount_BR( _record, 7, ConfLayoutTypesChoice_BR::FixedLength);
                    }

                    if (substr(fileLine, conpeek(datasize[8], 1), conpeek(datasize[8], 2)))
                    {
                        feevalue = this.processReturnAmount_BR( _record, 8, ConfLayoutTypesChoice_BR::FixedLength);
                    }

                    if (substr(fileLine, conpeek(datasize[9], 1), conpeek(datasize[9], 2)))
                    {
                        layoutReturnOccCode = this.getFieldData_BR(substr(fileLine, conpeek(datasize[9], 1),conpeek(datasize[9], 2)));
                        this.parmPaymentStatus(layoutGroupID, layoutReturnOccCode);
                    }

                    if (substr(fileLine, conpeek(datasize[10], 1),conpeek(datasize[10], 2)))
                    {
                        bankInvoiceId = this.getFieldData_BR(substr(fileLine, conpeek(datasize[10], 1),conpeek(datasize[10], 2)));
                    }

                    if (substr(fileLine, conpeek(datasize[12], 1),conpeek(datasize[12], 2)))
                    {
                        fineAmount_BR = this.processReturnAmount_BR( _record, 12, ConfLayoutTypesChoice_BR::FixedLength);
                    }
                }
                break;

            case ConfLayoutTypesChoice_BR::Delimited:
                if (datasize[1])
                {
                    regtypeloc =this.getFieldData_BR(conpeek(_record, conpeek(datasize[1], 1)));
                }

                if ( regtypeloc == this.getFieldData_BR(conpeek(datasize[1], 2)))
                {
                    if (conpeek(_record, conpeek(datasize[11], 1))
                        && conpeek(datasize[1], 3) == ConfLayoutLineType_BR::Header)
                    {
                        if ( EP_FileSequenceNum_BR::insertRetSeq(this.getFieldData_BR(conpeek(_record, conpeek(datasize[11], 1))), layoutGroupID) == true)
                        {
                            retFileSequenceNum = this.getFieldData_BR(conpeek(_record, conpeek(datasize[11], 1)));
                            isFileRead = true;
                        }
                        else
                        {
                            isFileImportedAlready = true;
                            isFileRead = false;
                        }
                    }

                    if (conpeek(_record, conpeek(datasize[2], 1)))
                    {
                        companyDocument = this.getFieldData_BR(conpeek(_record, conpeek(datasize[2], 1)));
                    }

                    if (conpeek(_record, conpeek(datasize[3], 1)))
                    {
                        custinvoiceId = this.getFieldData_BR(conpeek(_record, conpeek(datasize[3], 1)));
                    }

                    if (conpeek(_record,conpeek(datasize[4],1)))
                    {
                        transDate = this.parseDate(conpeek(_record,conpeek(datasize[4],1)), conpeek(datasize[4],4));
                        if (!transDate)
                        {
                            transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                        }
                    }

                    if (conpeek(_record, conpeek(datasize[5], 1)))
                    {
                        custCashDiscAmount = this.processReturnAmount_BR(_record, 5, ConfLayoutTypesChoice_BR::Delimited);
                    }

                    if (conpeek(_record, conpeek(datasize[6], 1)))
                    {
                        finInterestAmount_BR = this.processReturnAmount_BR(_record, 6, ConfLayoutTypesChoice_BR::Delimited);
                    }

                    if (conpeek(_record, conpeek(datasize[7], 1)))
                    {
                        amountCurDebCred = this.processReturnAmount_BR(_record, 7, ConfLayoutTypesChoice_BR::Delimited);
                    }

                    if (conpeek(_record, conpeek(datasize[8], 1)))
                    {
                        feevalue = this.processReturnAmount_BR(_record, 8, ConfLayoutTypesChoice_BR::Delimited);
                    }

                    if (conpeek(_record, conpeek(datasize[9], 1)))
                    {
                        layoutReturnOccCode = this.getFieldData_BR(conpeek(_record, conpeek(datasize[9], 1)));
                        this.parmPaymentStatus(layoutGroupID, layoutReturnOccCode);
                    }
                    if (conpeek(_record, conpeek(datasize[10], 1)))
                    {
                        bankInvoiceId = this.getFieldData_BR(conpeek(_record, conpeek(datasize[10], 1)));
                    }

                    if (substr(fileLine, conpeek(datasize[12], 1), conpeek(datasize[12], 2)))
                    {
                        fineAmount_BR = this.processReturnAmount_BR(_record, 12, ConfLayoutTypesChoice_BR::Delimited);
                    }
                }
                break;
        }

        if ( paymStatusCur && companyDocument && retFileSequenceNum)
        {
            if (!transDate)
            {
                transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
            }

            this.setStatusOnInvoice(custinvoiceId,
                                    paymStatusCur,
                                    '',
                                    companyDocument,
                                    transDate,
                                    abs(custCashDiscAmount),
                                    amountCurDebCred,
                                    finInterestAmount_BR,
                                    fineAmount_BR,
                                    feevalue,
                                    bankInvoiceId);

            this.clearLocalData();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRecordComplex_BR</Name>
				<Source><![CDATA[
    public void processRecordComplex_BR()
    {
        EPReturnFileReader_BR returnFileReader = new EPReturnFileReader_BR();
        returnFileReader.setFile(file);

        ConfImportEPComplex_BR confImportEPComplex = ConfImportEPComplex_BR::constructCustPaymForLayout(layoutGroupID);
        confImportEPComplex.setPaymMode(paymMode);
        confImportEPComplex.setFile(returnFileReader);
        confImportEPComplex.doImport();

        ListEnumerator le = confImportEPComplex.getListOfProcessedDocuments().getEnumerator();
        ledgerJournalTransPaymentTmp.setTempDB();

        while (le.MoveNext())
        {
            EPReturnValues_BR epReturnValues = confImportEPComplex.getValuesForProcessedDocument(le.current());

            if (!epReturnValues.parmPaymentDate())
            {
                epReturnValues.parmPaymentDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
            }

            layoutReturnOccCode = epReturnValues.parmReturnOccuranceCode();

            if (!epReturnValues.parmCompanyDocument())
            {
                info(strFmt("@GLS223814", tableId2pname(tableNum(LedgerJournalTrans))));

                continue;
            }

            this.setStatusOnInvoice(
                '',
                epReturnValues.parmStatus(),
                '',
                epReturnValues.parmCompanyDocument(),
                epReturnValues.parmPaymentDate(),
                abs(epReturnValues.parmDiscountAmount()),
                epReturnValues.parmPaymentAmount(),
                epReturnValues.parmInterestAmount(),
                epReturnValues.parmFineAmount(),
                epReturnValues.parmFeeValue(),
                epReturnValues.parmBankInvoiceId());
        }

        isFileRead = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        #OCCRetryCount
        if (! this.validate())
        {
            throw error("");
        }

        try
        {
            ttsbegin;
            this.getLayoutGroupID_BR(paymMode,sysModule);

            if (layoutGroupID
                && isFileRead)
            {
                this.updatePayments();
            }
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setStatusOnInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the customer payment data on the invoice.
    /// </summary>
    /// <param name="_invoice">
    ///     The invoice number.
    /// </param>
    /// <param name="_status">
    ///     Status the invoice should be updated to. Represented by the base enum <c>CustVendPaymStatus</c>.
    /// </param>
    /// <param name="_errorCodePayment">
    ///     Error code reveived with the return message.
    /// </param>
    /// <param name="_companyDocument">
    ///     The number of the document on the company.
    /// </param>
    /// <param name="_debitDate">
    ///     The date when the debit was performed.
    /// </param>
    /// <param name="_discAmount">
    ///     The amount of discount applied to the payment.
    /// </param>
    /// <param name="_paymentAmount">
    ///     The amount paid.
    /// </param>
    /// <param name="_intAmount">
    ///     The interest amount applied to the payment.
    /// </param>
    /// <param name="_fineAmount">
    ///     The fine amount applied to the payment.
    /// </param>
    /// <param name="_paymentFee">
    ///     The fee amount applied to the payment.
    /// </param>
    /// <param name="_bankInvoiceId">
    ///     The number used for identification of invoice by the bank.
    /// </param>
    public void setStatusOnInvoice(
        InvoiceId _invoice,
        CustVendPaymStatus _status,
        ErrorCodePayment _errorCodePayment = '',
        EPCompanyDocument_BR _companyDocument='',
        date _debitDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        DiscAmount _discAmount = 0.00,
        AmountCurDebit _paymentAmount = 0.00,
        FinInterestAmount_BR _intAmount = 0.00,
        FineAmount_BR _fineAmount = 0.00,
        PaymFeeValue _paymentFee = 0.00,
        EPBankInvoiceId_BR _bankInvoiceId ='')
    {
        SpecTrans                       specTrans;
        LedgerJournalTrans              ledgerJournalTransLoc;
        LedgerJournalTransPayment_BR    ledgerJournalTransPaymentLoc;

        ttsbegin;

        specTrans = this.updateLedgerJournalTransPaymentStatus(_status, _companyDocument, _errorCodePayment);

        if (specTrans.RecId)
        {
            if (_status == CustVendPaymStatus::Confirmed)
            {
                this.updateCustConfirmStatusDetails(_debitDate, _discAmount, _intAmount, _fineAmount, _paymentAmount, _paymentFee, _bankInvoiceId, specTrans.RecId);
            }

            this.updateCustReturnOccuranceDetails_BRV2(_debitDate, _bankInvoiceId, specTrans);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustConfirmStatusDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the payment details, if the payment status is confirm.
    /// </summary>
    /// <param name="_debitDate">
    /// TransDate of the transaction.
    /// </param>
    /// <param name="_discAmount">
    /// DiscountAmount of the transaction.
    /// </param>
    /// <param name="_finInterestAmount">
    /// InterestAmount of the transaction.
    /// </param>
    /// <param name="_fineAmount">
    /// FineAmount of the transaction.
    /// </param>
    /// <param name="_paymentAmount">
    /// PaymentAmount of the transaction.
    /// </param>
    /// <param name="_paymentFee">
    /// PaymentFee of the transaction.
    /// </param>
    /// <param name="_bankInvoiceId">
    /// BankInvoiceId of the transaction.
    /// </param>
    /// <param name="_specTransRecId">
    /// RecId of <c>SpecTrans</c> table for the transaction.
    /// </param>
    /// <remarks>
    /// Updates payment details.
    /// </remarks>
    public void updateCustConfirmStatusDetails(date                 _debitDate,
                                        DiscAmount           _discAmount,
                                        FinInterestAmount_BR _finInterestAmount,
                                        FineAmount_BR        _fineAmount,
                                        AmountCurDebit       _paymentAmount,
                                        PaymFeeValue         _paymentFee,
                                        EPBankInvoiceId_BR   _bankInvoiceId,
                                        RecId                _specTransRecId)
    {
        if (_specTransRecId)
        {
            this.updateCustPaymentDetails(
                    _paymentAmount,
                    _fineAmount,
                    _finInterestAmount,
                    _discAmount,
                    _paymentFee,
                    _debitDate,
                    _specTransRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustDebitDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the payment trans date, if the payment status is confirm.
    /// </summary>
    /// <param name="_debitDate">
    /// TransDate of the transaction.
    /// </param>
    /// <param name="_specTransRecId">
    /// RecId of <c>SpecTrans</c> table for the transaction.
    /// </param>
    public void updateCustDebitDate(
        date    _debitDate,
        Recid   _specTransRecId)
    {
        LedgerJournalTrans ledgerJournalTransLoc;
        SpecTrans          specTransLoc;

        ttsbegin;
        select forupdate specTransLoc
            where specTransLoc.RecId == _specTransRecId
                join forupdate  ledgerJournalTransLoc
                    where ledgerJournalTransLoc.RecId == specTransLoc.SpecRecId;
        if (ledgerJournalTransLoc)
        {
            ledgerJournalTransLoc.TransDate = _debitDate;
            ledgerJournalTransLoc.update();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the discount amount of the transaction, if the payment status is confirm.
    /// </summary>
    /// <param name="_discAmount">
    /// DiscountAmount of the transaction.
    /// </param>
    /// <param name="_debitDate">
    /// TransDate of the transaction.
    /// </param>
    /// <param name="_specTransRecId">
    /// RecId of <c>SpecTrans</c> table for the transaction.
    /// </param>
    public void updateCustDiscAmount(DiscAmount _discAmount,
                              date       _debitDate,
                              RecId      _specTransRecId)
    {
        CustTransOpen     custTransOpenLoc;
        SpecTrans         specTransLoc;
        CustTransCashDisc custTransCashDiscLoc;

        if (confind(specRecid, _specTransRecId) == 0)
        {
            ttsbegin;

            select forupdate specTransLoc where specTransLoc.RecId == _specTransRecId;

            if (specTransLoc.RefCompany)
            {
                changecompany(specTransLoc.RefCompany)
                {
                    delete_from custTransCashDiscLoc
                        where custTransCashDiscLoc.RefRecId == specTransLoc.RefRecId;

                    custTransCashDiscLoc.CashDiscdate   = _debitDate;
                    custTransCashDiscLoc.CashDiscAmount = _discAmount;
                    custTransCashDiscLoc.RefRecId       = specTransLoc.RefRecId;
                    custTransCashDiscLoc.RefTableId     = tablename2id(tablestr(CustTransOpen));
                    custTransCashDiscLoc.CashDiscDue    = CashDiscDue::CashDisc;
                    custTransCashDiscLoc.Manual         = NoYes::No;
                    custTransCashDiscLoc.insert();

                    select forupdate custTransOpenLoc where custTransOpenLoc.RecId == specTransLoc.RefRecId;
                    custTransOpenLoc.PossibleCashDisc   = _discAmount;
                    custTransOpenLoc.update();
                }
            }

            specTransLoc.Balance01 = custTransOpenLoc.AmountCur + custTransOpenLoc.InterestAmount_BR + custTransOpenLoc.FineAmount_BR -_discAmount;
            specTransLoc.CashDiscToTake = _discAmount;
            specTransLoc.update();
            ttscommit;
            specRecid += _specTransRecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustPaymentDetails</Name>
				<Source><![CDATA[
    private void updateCustPaymentDetails(
        AmountCurCredit _paymentAmount,
        FineAmount_BR _fineAmount,
        FinInterestAmount_BR _intAmount,
        DiscAmount _discAmount,
        PaymFeeValue _paymentFee,
        date _debitDate,
        RecId _specTransRecId)
    {
        LedgerJournalTrans ledgerJournalTransLoc;
        SpecTrans specTransLoc;
        CustTransOpen custTransOpenLoc;
        LedgerJournalTransPayment_BR ledgerJournalTransPayment_BRloc;
        CustTransCashDisc custTransCashDiscLoc;
        CustVendPaymJournalFee custVendPaymJournalFeeLoc;

        boolean specRecIdNotExists = confind(specRecid, _specTransRecId) == 0;

        ttsbegin;

        select firstonly forupdate specTransLoc
            where specTransLoc.RecId == _specTransRecId
                && specTransLoc.SpecTableId == tableNum(LedgerJournalTrans)
            join forupdate ledgerJournalTransLoc
                where ledgerJournalTransLoc.RecId == specTransLoc.SpecRecId
                    outer join forUpdate ledgerJournalTransPayment_BRloc
                        where ledgerJournalTransPayment_BRloc.RefRecId == ledgerJournalTransLoc.RecId
                    outer join forupdate custTransOpenLoc
                        where custTransOpenLoc.RecId == specTransLoc.RefRecId
                    outer join forupdate custVendPaymJournalFeeLoc
                        where custVendPaymJournalFeeLoc.RefRecId == ledgerJournalTransLoc.RecId;

        if (ledgerJournalTransLoc)
        {
            if (_paymentAmount)
            {
                ledgerJournalTransLoc.AmountCurDebit = 0;
                ledgerJournalTransLoc.AmountCurCredit = abs(_paymentAmount);
            }

            if (_debitDate)
            {
                ledgerJournalTransLoc.TransDate = _debitDate;
            }

            ledgerJournalTransLoc.update();
        }

        if (ledgerJournalTransPayment_BRloc)
        {
            ledgerJournalTransPayment_BRloc.FineAmountCur_BR = _fineAmount;
            ledgerJournalTransPayment_BRloc.FinInterestAmountCur_BR = _intAmount;
            ledgerJournalTransPayment_BRloc.update();
        }

        if (specTransLoc.RefCompany)
        {
            changecompany(specTransLoc.RefCompany)
            {
                if (custTransOpenLoc)
                {
                    if (ledgerJournalTransPayment_BRloc)
                    {
                        custTransOpenLoc.FineAmount_BR = _fineAmount;
                        custTransOpenLoc.FineAmountPaymCur_BR = _fineAmount;
                        custTransOpenLoc.InterestAmount_BR = _intAmount;
                        custTransOpenLoc.InterestAmountPaymCur_BR = _intAmount;
                    }

                    if (specRecIdNotExists)
                    {
                        custTransOpenLoc.PossibleCashDisc = _discAmount;
                    }

                    custTransOpenLoc.update();
                }

                if (specRecIdNotExists)
                {
                    delete_from custTransCashDiscLoc
                        where custTransCashDiscLoc.RefRecId == specTransLoc.RefRecId;

                    custTransCashDiscLoc.CashDiscdate   = _debitDate;
                    custTransCashDiscLoc.CashDiscAmount = _discAmount;
                    custTransCashDiscLoc.RefRecId       = specTransLoc.RefRecId;
                    custTransCashDiscLoc.RefTableId     = tablename2id(tablestr(CustTransOpen));
                    custTransCashDiscLoc.CashDiscDue    = CashDiscDue::CashDisc;
                    custTransCashDiscLoc.Manual         = NoYes::No;
                    custTransCashDiscLoc.insert();
                }

                if (custVendPaymJournalFeeLoc)
                {
                    if (custVendPaymJournalFeeLoc.FeeId)
                    {
                        if (_paymentFee != 0)
                        {
                            custVendPaymJournalFeeLoc.FeeValue = _paymentFee;
                            custVendPaymJournalFeeLoc.update();
                        }
                        else
                        {
                            custVendPaymJournalFeeLoc.delete();
                        }
                    }
                }
                else
                {
                    if (_paymentFee != 0)
                    {
                        custVendPaymJournalFeeLoc.RefRecId            = ledgerJournalTransLoc.RecId;
                        custVendPaymJournalFeeLoc.FeeValue            = _paymentFee;
                        custVendPaymJournalFeeLoc.FeeCurrency         = ledgerJournalTransLoc.CurrencyCode;
                        custVendPaymJournalFeeLoc.Module              = ModuleCustVend::Cust;
                        custVendPaymJournalFeeLoc.LedgerJournalACType = LedgerJournalACType::Ledger;
                        custVendPaymJournalFeeLoc.insert();
                    }
                }
            }
        }

        if (specRecIdNotExists)
        {
            specTransLoc.Balance01 = custTransOpenLoc.AmountCur + _fineAmount + _intAmount -_discAmount;
            specTransLoc.CashDiscToTake = _discAmount;
            specTransLoc.update();

            specRecid += _specTransRecId;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustPaymentAmountDebitDate</Name>
				<Source><![CDATA[
    private void updateCustPaymentAmountDebitDate(
        date _debitDate,
        AmountCurCredit _paymentAmount,
        RecId _specTransRecId)
    {
        LedgerJournalTrans ledgerJournalTransLoc;
        SpecTrans          specTransLoc;

        ttsbegin;

        select RecId from specTransLoc
            where specTransLoc.RecId == _specTransRecId
               && specTransLoc.SpecTableId == ledgerJournalTransLoc.TableId
            join forupdate ledgerJournalTransLoc
                where specTransLoc.SpecRecId == ledgerJournalTransLoc.RecId;

        if (ledgerJournalTransLoc)
        {
            if (_paymentAmount)
            {
                ledgerJournalTransLoc.AmountCurDebit = 0;
                ledgerJournalTransLoc.AmountCurCredit = abs(_paymentAmount);
            }

            if (_debitDate)
            {
                ledgerJournalTransLoc.TransDate = _debitDate;
            }

            ledgerJournalTransLoc.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustFineAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the fine amount of the transaction, if the payment status is confirm.
    /// </summary>
    /// <param name="_fineAmount">
    /// FineAmount of the transaction.
    /// </param>
    /// <param name="_specTransRecId">
    /// RecId of <c>SpecTrans</c> table for the transaction.
    /// </param>
    public void updateCustFineAmount(
        FineAmount_BR   _fineAmount,
        RecId           _specTransRecId)
    {
        LedgerJournalTrans           ledgerJournalTransLoc;
        SpecTrans                    specTransLoc;
        CustTransOpen                custTransOpenLoc;
        LedgerJournalTransPayment_BR ledgerJournalTransPayment_BRloc;

        ttsbegin;
        select RefCompany, RefTableId, RefRecId from specTransLoc
            where specTransLoc.RecId == _specTransRecId
            join forupdate  ledgerJournalTransLoc
                where ledgerJournalTransLoc.RecId == specTransLoc.SpecRecId
                && ledgerJournalTransLoc.TableId == specTransLoc.SpecTableId
                && ledgerJournalTransLoc.DataAreaId == specTransLoc.SpecCompany
                    join forUpdate ledgerJournalTransPayment_BRloc
                        where ledgerJournalTransPayment_BRloc.RefRecId == ledgerJournalTransLoc.RecId;

        if (ledgerJournalTransPayment_BRloc)
        {
            ledgerJournalTransPayment_BRloc.FineAmountCur_BR = _fineAmount;
            ledgerJournalTransPayment_BRloc.update();
        }

        if (specTransLoc.RefCompany)
        {
            changecompany(specTransLoc.RefCompany)
            {
                select forupdate custTransOpenLoc
                    where custTransOpenLoc.RecId == specTransLoc.RefRecId
                    && custTransOpenLoc.TableId == specTransLoc.RefTableId
                    && custTransOpenLoc.DataAreaId == specTransLoc.RefCompany;

                if (custTransOpenLoc)
                {
                    custTransOpenLoc.FineAmount_BR        = _fineAmount;
                    custTransOpenLoc.FineAmountPaymCur_BR = _fineAmount;
                    custTransOpenLoc.update();
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustInterestAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the interest amount of the transaction, if the payment status is confirm.
    /// </summary>
    /// <param name="_intAmount">
    /// InterestAmount of the transaction.
    /// </param>
    /// <param name="_specTransRecId">
    /// RecId of <c>SpecTrans</c> table for the transaction.
    /// </param>
    public void updateCustInterestAmount(
        FinInterestAmount_BR    _intAmount,
        RecId                   _specTransRecId)
    {
        LedgerJournalTrans           ledgerJournalTransLoc;
        SpecTrans                    specTransLoc;
        CustTransOpen                custTransOpenLoc;
        LedgerJournalTransPayment_BR ledgerJournalTransPayment_BRloc;

        ttsbegin;
        select RefCompany, RefTableId, RefRecId from specTransLoc
            where specTransLoc.RecId == _specTransRecId
            join RecId from ledgerJournalTransLoc
                where ledgerJournalTransLoc.RecId == specTransLoc.SpecRecId
                && ledgerJournalTransLoc.TableId == specTransLoc.SpecTableId
                && ledgerJournalTransLoc.DataAreaId == specTransLoc.SpecCompany
                    join forUpdate ledgerJournalTransPayment_BRloc
                        where ledgerJournalTransPayment_BRloc.RefRecId == ledgerJournalTransLoc.RecId;

        if (ledgerJournalTransPayment_BRloc)
        {
            ledgerJournalTransPayment_BRloc.FinInterestAmountCur_BR = _intAmount;
            ledgerJournalTransPayment_BRloc.update();
        }

        if (specTransLoc.RefCompany)
        {
            changecompany(specTransLoc.RefCompany)
            {
                select forupdate custTransOpenLoc
                    where custTransOpenLoc.RecId == specTransLoc.RefRecId
                        && custTransOpenLoc.TableId == specTransLoc.RefTableId
                        && custTransOpenLoc.DataAreaId == specTransLoc.RefCompany;

                if (custTransOpenLoc)
                {
                    custTransOpenLoc.InterestAmount_BR        = _intAmount;
                    custTransOpenLoc.InterestAmountPaymCur_BR = _intAmount;
                    custTransOpenLoc.update();
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustPaymentAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the payment amount of the transaction, if the payment status is confirm.
    /// </summary>
    /// <param name="_paymentAmount">
    /// PaymentAmount of the transaction.
    /// </param>
    /// <param name="_specTransRecId">
    /// RecId of <c>SpecTrans</c> table for the transaction.
    /// </param>
    /// <param name="_finInterestAmount">
    /// FineandInterestAmount of the transaction.
    /// </param>
    /// <param name="_fineAmount">
    /// FineAmount of the transaction.
    /// </param>
    public void updateCustPaymentAmount(
        AmountCurCredit      _paymentAmount,
        RecId                _specTransRecId,
        FinInterestAmount_BR _finInterestAmount = 0.00,
        FineAmount_BR        _fineAmount = 0)
    {
        LedgerJournalTrans ledgerJournalTransLoc;
        SpecTrans          specTransLoc;

        ttsbegin;

        select forupdate ledgerJournalTransLoc
            exists join specTransLoc
            where specTransLoc.RecId                == _specTransRecId
               && ledgerJournalTransLoc.RecId       == specTransLoc.SpecRecId
               && ledgerJournalTransLoc.TableId     == specTransLoc.SpecTableId
               && ledgerJournalTransLoc.dataAreaId  == specTransLoc.SpecCompany;

        if (ledgerJournalTransLoc)
        {
            ledgerJournalTransLoc.AmountCurDebit = 0;
            ledgerJournalTransLoc.AmountCurCredit = abs(_paymentAmount);
            ledgerJournalTransLoc.update();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustPaymentFee</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the fee amount of the transaction, if the payment status is confirm.
    /// </summary>
    /// <param name="_paymentFee">
    /// FeeAmount of the transaction.
    /// </param>
    /// <param name="_specTransRecId">
    /// RecId of <c>SpecTrans</c> table for the transaction.
    /// </param>
    public void updateCustPaymentFee(
        PaymFeeValue    _paymentFee,
        RecId           _specTransRecId)
    {
        LedgerJournalTrans     ledgerJournalTransLoc;
        CustVendPaymJournalFee custVendPaymJournalFeeLoc;
        SpecTrans              specTransLoc;

        ttsbegin;
        select RefCompany, RefTableId, RefRecId from specTransLoc
            where specTransLoc.RecId == _specTransRecId
            join  ledgerJournalTransLoc
                where ledgerJournalTransLoc.RecId == specTransLoc.SpecRecId;

        if (ledgerJournalTransLoc)
        {
            changecompany(specTransLoc.RefCompany)
            {
                select forupdate custVendPaymJournalFeeLoc where custVendPaymJournalFeeLoc.RefRecId == ledgerJournalTransLoc.RecId;

                if (custVendPaymJournalFeeLoc)
                {
                    if (custVendPaymJournalFeeLoc.FeeId)
                    {
                        if (_paymentFee != 0)
                        {
                            custVendPaymJournalFeeLoc.FeeValue = _paymentFee;
                            custVendPaymJournalFeeLoc.update();
                        }
                        else
                        {
                            custVendPaymJournalFeeLoc.delete();
                        }
                    }
                }
                else
                {
                    if (_paymentFee != 0)
                    {
                        custVendPaymJournalFeeLoc.RefRecId            = ledgerJournalTransLoc.RecId;
                        custVendPaymJournalFeeLoc.FeeValue            = _paymentFee;
                        custVendPaymJournalFeeLoc.FeeCurrency         = ledgerJournalTransLoc.CurrencyCode;
                        custVendPaymJournalFeeLoc.Module              = ModuleCustVend::Cust;
                        custVendPaymJournalFeeLoc.LedgerJournalACType = LedgerJournalACType::Ledger;
                        custVendPaymJournalFeeLoc.insert();
                    }
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustReturnOccuranceDetails_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the interest amount of the transaction.
    /// </summary>
    /// <param name="_debitDate">
    /// TransDate of the transaction.
    /// </param>
    /// <param name="_bankInvoiceId">
    /// BankInvoiceId of the transaction.
    /// </param>
    /// <param name="_specTransRecId">
    /// RecId of <c>SpecTrans</c> table for the transaction.
    /// </param>
    public void updateCustReturnOccuranceDetails_BR(
        date _debitDate,
        EPBankInvoiceId_BR _bankInvoiceId,
        RecId _specTransRecId)
    {
        SpecTrans specTransLoc;

        select firstonly RefCompany, RefRecId from specTransLoc
            where specTransLoc.RecId == _specTransRecId;

        this.updateCustReturnOccuranceDetails_BRV2(
            _debitDate,
            _bankInvoiceId,
            specTransLoc);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustReturnOccuranceDetails_BRV2</Name>
				<Source><![CDATA[
    private void updateCustReturnOccuranceDetails_BRV2(
        date _debitDate,
        EPBankInvoiceId_BR _bankInvoiceId,
        SpecTrans _specTrans)
    {
        EPRetOccCode_BR epRetOccCode_BR;
        epRetOccCode_BR = str2enum(epRetOccCode_BR, this.parmReturnOccCode_BR(layoutGroupID, layoutReturnOccCode));

        if (_specTrans.RefCompany)
        {
            changecompany(_specTrans.RefCompany)
            {
                CustTransEPRemit_BR custTransEPRemit_BR;

                select forupdate custTransEPRemit_BR
                    where custTransEPRemit_BR.CustTransOpenRefRecId == _specTrans.RefRecId;

                if (custTransEPRemit_BR)
                {
                    custTransEPRemit_BR.RetOccCode = epRetOccCode_BR;
                    custTransEPRemit_BR.RetDate       = _debitDate;
                    custTransEPRemit_BR.BankInvoiceId = _bankInvoiceId;
                    custTransEPRemit_BR.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerJournalTransPaymentStatus</Name>
				<Source><![CDATA[
    private SpecTrans updateLedgerJournalTransPaymentStatus(
        CustVendPaymStatus _status,
        EPCompanyDocument_BR _companyDocument,
        ErrorCodePayment _errorCodePayment)
    {
        SpecTrans specTrans;
        LedgerJournalTrans ledgerJournalTransLoc;
        LedgerJournalTransPayment_BR ledgerJournalTransPaymentLoc;
        DimensionAttributeValueCombination dimAttrValueComboLoc;
        #ISOCountryRegionCodes

        ttsbegin;

        select firstonly RecId, LedgerDimension, Voucher, JournalNum from ledgerJournalTransLoc
            where ledgerJournalTransLoc.PaymentStatus != CustVendPaymStatus::None
            join forupdate specTrans
                where specTrans.SpecRecId == ledgerJournalTransLoc.RecId
                    && specTrans.SpecTableId == ledgerJournalTransLoc.TableId
                    && specTrans.SpecCompany == ledgerJournalTransLoc.DataAreaId
            join DisplayValue from dimAttrValueComboLoc
                where dimAttrValueComboLoc.RecId == ledgerJournalTransLoc.LedgerDimension
            exists join ledgerJournalTransPaymentLoc
                where ledgerJournalTransPaymentLoc.RefRecId == ledgerJournalTransLoc.RecId
                    && ledgerJournalTransPaymentLoc.EPCompanyDocument_BR == _companyDocument;

        if (specTrans)
        {
            specTrans.PaymentStatus = _status;
            specTrans.ErrorCodePayment = _errorCodePayment;
            specTrans.update();
        }

        if (ledgerJournalTransLoc)
        {
            LedgerJournalTable ledgerJournalTable;
            LedgerJournalTrans ledgerJournalTrans;
            DimensionAttributeValueCombination dimAttrValueCombo;
            boolean recordsUpdated;

            while select forupdate ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == ledgerJournalTransLoc.JournalNum
                    && ledgerJournalTrans.Voucher == ledgerJournalTransLoc.Voucher
                exists join ledgerJournalTable
                    where ledgerJournalTable.JournalType == LedgerJournalType::CustPayment
                        && ledgerJournalTable.JournalNum == ledgerJournalTrans.JournalNum
                exists join dimAttrValueCombo
                    where dimAttrValueCombo.RecId == ledgerJournalTrans.LedgerDimension
                        && dimAttrValueCombo.DisplayValue == dimAttrValueComboLoc.DisplayValue
            {
                if (!LedgerJournalTransPayment_BR::find(ledgerJournalTrans.RecId))
                {
                    ledgerJournalTransPaymentTmp.clear();
                    ledgerJournalTransPaymentTmp.RefRecId = ledgerJournalTrans.RecId;
                    ledgerJournalTransPaymentTmp.doInsert();
                }

                ledgerJournalTrans.PaymentStatus = _status;
                ledgerJournalTrans.update();

                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]))
                {
                    this.updateInvoicesFromPayment(ledgerJournalTrans);
                }

                if (!recordsUpdated)
                {
                    recordsUpdated = true;
                }
            }

            if (!recordsUpdated)
            {
                info(strfmt("@SYS67948", ledgerJournalTransLoc.JournalNum, ledgerJournalTransLoc.Voucher, dimAttrValueComboLoc.DisplayValue));
            }
        }
        else
        {
            info(strFmt("@GLS223815", _companyDocument));
        }

        ttscommit;

        return specTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the payment details of the transaction.
    /// </summary>
    public void updatePayments()
    {
        LedgerJournalTable ledgerJournalTable;
        LedgerJournalTable localNewLedgerJournalTable;
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTrans ledgerJournalTransRejected;
        SpecTrans specTrans;
        AmountCur amountConfirmed;
        AmountCur amountRejected;
        AmountCur amountRecieved;
        CurrencyCode currencyCode;
        date dateloc;
        LedgerJournalId errorLedgerJournalId;
        LedgerJournalId journalnumLoc;
        LedgerJournalTrans ledgerJournalTransLoc;
        CustVendPaymJournalFee custVendPaymJournalFeeLoc;
        CustTransEPRemit_BR custTransEPRemitLoc;
        SpecTrans outerSpecTrans;

        void updatePayment()
        {
            if (journalnumLoc != ledgerJournalTable.JournalNum)
            {
                errorLedgerJournalId = '';
                journalnumLoc = ledgerJournalTable.JournalNum;
            }
            else
            {
                dateLoc = (select firstonly TransDate from ledgerJournalTrans
                            where ledgerJournalTrans.JournalNum == errorLedgerJournalId).TransDate;
                if (dateLoc == ledgerJournalTrans.TransDate)
                {
                    journalnumLoc = ledgerJournalTable.JournalNum;
                }
                else
                {
                    errorLedgerJournalId = '';
                }
            }

            amountConfirmed = 0;
            ledgerJournalTransRejected = null;
            amountRejected  = 0;
            amountRecieved  = 0;

            while select forupdate crosscompany specTrans
                where specTrans.SpecTableId == ledgerJournalTrans.TableId &&
                      specTrans.SpecRecId   == ledgerJournalTrans.RecId &&
                      specTrans.SpecCompany == ledgerJournalTrans.company()
            {
                switch (specTrans.PaymentStatus)
                {
                    case CustVendPaymStatus::Confirmed :
                        ledgerJournalTrans.PaymentStatus = CustVendPaymStatus::Confirmed;
                        currencyCode = this.fetchTransCurrencyCode(specTrans.RefTableId, specTrans.RefRecId, specTrans.RefCompany);
                        if (currencyCode != ledgerJournalTrans.CurrencyCode)
                            amountConfirmed += CurrencyExchangeHelper::curAmount2CurAmount(specTrans.Balance01, currencyCode, ledgerJournalTransRejected.CurrencyCode, ledgerJournalTransRejected.TransDate, true);
                        else
                            amountConfirmed += specTrans.Balance01;
                        break;

                    case CustVendPaymStatus::Recieved :
                        ledgerJournalTrans.PaymentStatus = CustVendPaymStatus::Recieved;
                        currencyCode = this.fetchTransCurrencyCode(specTrans.RefTableId,specTrans.RefRecId, specTrans.RefCompany);
                        if (currencyCode != ledgerJournalTrans.CurrencyCode)
                            amountRecieved += CurrencyExchangeHelper::curAmount2CurAmount(specTrans.Balance01, currencyCode, ledgerJournalTransRejected.CurrencyCode, ledgerJournalTransRejected.TransDate, true);
                        else
                            amountRecieved += specTrans.Balance01;
                        break;
                    case CustVendPaymStatus::Rejected :
                        if (!ledgerJournalTransRejected.RecId)
                        {
                            ledgerJournalTransRejected.data(ledgerJournalTrans);
                            ledgerJournalTransRejected.PaymentStatus = CustVendPaymStatus::Rejected;
                            ledgerJournalTransRejected.AmountCurCredit = 0;
                            ledgerJournalTransRejected.AmountCurDebit = 0;
                            ledgerJournalTransRejected.LineNum		  = LedgerJournalTrans::lastLineNum(ledgerJournalTrans.JournalNum) + 1;
                            ledgerJournalTransRejected.insert();
                        }
                        specTrans.SpecRecId = ledgerJournalTransRejected.RecId;
                        changecompany(specTrans.company())
                        {
                            specTrans.update();
                        }

                        currencyCode = this.fetchTransCurrencyCode(specTrans.RefTableId,specTrans.RefRecId, specTrans.RefCompany);
                        if (currencyCode != ledgerJournalTrans.CurrencyCode)
                            amountRejected += CurrencyExchangeHelper::curAmount2CurAmount(specTrans.Balance01, currencyCode, ledgerJournalTransRejected.CurrencyCode, ledgerJournalTransRejected.TransDate, true);
                        else
                            amountRejected += specTrans.Balance01;
                        break;

                    default :
                        break;
                }
            }

            if (amountConfirmed)
            {
                if ((ledgerJournalTrans.PaymMode == paymMode) && layoutGroupID)
                {
                    if (this.paymentStatus(ledgerJournalTable.JournalNum) == true)
                    {
                        if (!LedgerJournalTable::find(errorLedgerJournalId).JournalNum)
                        {
                            errorLedgerJournalId = JournalTableData::newTable(localNewLedgerJournalTable).nextJournalId();
                            localNewLedgerJournalTable.JournalName           = ledgerJournalTable.JournalName;
                            localNewLedgerJournalTable.JournalNum            = errorLedgerJournalId;
                            localNewLedgerJournalTable.Name                  = ledgerJournalTable.Name;
                            localNewLedgerJournalTable.OriginalJournalNum    = ledgerJournalTable.JournalNum;
                            localNewLedgerJournalTable.JournalType           = ledgerJournalTable.JournalType;
                            localNewLedgerJournalTable.parmOffsetLedgerDimension(ledgerJournalTable.parmOffsetLedgerDimension());
                            localNewLedgerJournalTable.OffsetAccountType     = ledgerJournalTable.OffsetAccountType;
                            localNewLedgerJournalTable.NumberSequenceTable   = ledgerJournalTable.NumberSequenceTable;
                            localNewLedgerJournalTable.LedgerJournalInclTax  = ledgerJournalTable.LedgerJournalInclTax;
                            localNewLedgerJournalTable.insert();
                            ledgerJournalTrans.JournalNum = errorLedgerJournalId;
                            ledgerJournalTrans.doUpdate();

                            select custVendPaymJournalFeeLoc
                                where custVendPaymJournalFeeLoc.RefRecId == ledgerJournalTrans.RecId;

                            if (custVendPaymJournalFeeLoc)
                            {
                                ledgerJournalTransLoc            = LedgerJournalTrans::findRecId(custVendPaymJournalFeeLoc.FeeTransRecId,true);
                                ledgerJournalTransLoc.JournalNum = errorLedgerJournalId;
                                ledgerJournalTransLoc.Voucher    = ledgerJournalTrans.Voucher;
                                ledgerJournalTransLoc.doUpdate();
                            }
                        }
                        else
                        {
                            ledgerJournalTrans.JournalNum = errorLedgerJournalId;
                            ledgerJournalTrans.doUpdate();
                        }
                    }
                }
            }

            if (amountRejected)
            {
                if ((ledgerJournalTrans.PaymentStatus != CustVendPaymStatus::None))
                {
                    ledgerJournalTrans.PaymentStatus    = CustVendPaymStatus::Rejected;
                    ledgerJournalTrans.AmountCurCredit  = ledgerJournalTransRejected.AmountCurCredit;
                    ledgerJournalTrans.AmountCurDebit   = ledgerJournalTransRejected.AmountCurDebit;
                    ledgerJournalTrans.update();

                    while select forupdate crosscompany specTrans
                        where specTrans.SpecRecId   == ledgerJournalTransRejected.RecId &&
                        specTrans.SpecTableId   == ledgerJournalTransRejected.TableId &&
                        specTrans.SpecCompany   == ledgerJournalTransRejected.company()
                    {
                        specTrans.SpecRecId = ledgerJournalTrans.RecId;
                        changecompany(specTrans.company())
                        {
                            specTrans.update();
                        }
                    }

                    ledgerJournalTransRejected.delete();
                }
            }
        }

        errorLedgerJournalId = '';

        ttsbegin;

        ledgerJournalTransRejected.selectForUpdate(true);
        specTrans.selectForUpdate(true);

        while select forupdate ledgerJournalTable
            where ledgerJournalTable.JournalType == this.journalType()
                  && ledgerJournalTable.Posted == NoYes::No
            join forupdate ledgerJournalTrans order by JournalNum, PaymentStatus, TransDate
                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                    && ledgerJournalTrans.PaymMode == paymMode
                    && (ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::Sent
                        || ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::Recieved
                        || ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::Confirmed
                        || ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::Rejected)
                exists join ledgerJournalTransPaymentTmp
                    where ledgerJournalTransPaymentTmp.RefRecId == ledgerJournalTrans.RecId
                exists join custTransEPRemitLoc
                    where custTransEPRemitLoc.JournalNum == ledgerJournalTrans.JournalNum
                exists join outerSpecTrans
                    where outerSpecTrans.RefRecId == custTransEPRemitLoc.CustTransOpenRefRecId
        {
            updatePayment();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return new CustPaymReconcilImport_EP_Return_BR().interfaceName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>