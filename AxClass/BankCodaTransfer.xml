<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BankCodaTransfer</Name>
	<SourceCode>
		<Declaration><![CDATA[
class BankCodaTransfer extends RunBase
{
    BankCodaAccountStatement    bankCodaAccountStatement;
    BankCodaTransferErrorCause  errorCause;
    LedgerJournalTable          ledgerJournalTable;
    LedgerJournalEngine         ledgerJournalEngine;
    LedgerJournalId             ledgerJournalId;
    boolean                     postDeviation;
    Amount                      amountDeviation;
    int                         recCount;
    Percent                     codaDeviation;
    BankCodaParameters          bankCodaParameters;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>amountToSettle</Name>
				<Source><![CDATA[
    protected void amountToSettle(Amount _invoiceAmount, Amount  _paidAmount)
    {
        Amount  amountPlus, amountMin;

        //check amount on disccount

        amountPlus = _invoiceAmount + ((_invoiceAmount/100)*codaDeviation);
        amountMin  = _invoiceAmount - ((_invoiceAmount/100)*codaDeviation);

        if ((_paidAmount != _invoiceAmount) && (_paidAmount <= amountPlus && _paidAmount >= amountMin))
        {
            amountDeviation = abs(_paidAmount) - abs(_invoiceAmount);
            postDeviation   = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bridgingPosting</Name>
				<Source><![CDATA[
    protected LedgerDimensionAccount bridgingPosting(BankCodaInvoiceId _codaInvoiceId)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        LedgerTransFurtherPosting ledgerTransFurtherPosting;
        VendTrans vendTrans;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        select firstonly GeneralJournalEntry, LedgerDimension, RecId from generalJournalAccountEntry
            join Invoice, LastSettleVoucher, LastSettleDate from vendTrans
            join RecId from generalJournalEntry
            join Voucher,AccountingDate from subledgerVoucherGeneralJournalEntry
            join RefRecId from ledgerTransFurtherPosting
                where vendTrans.Invoice == _codaInvoiceId
                && subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && subledgerVoucherGeneralJournalEntry.Voucher == vendTrans.LastSettleVoucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == vendTrans.LastSettleDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == vendTrans.DataAreaId
                && generalJournalEntry.Ledger == Ledger::current()
                && generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && ledgerTransFurtherPosting.RefRecId == generalJournalAccountEntry.RecId;

        return generalJournalAccountEntry.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bridgingPostingRecID</Name>
				<Source><![CDATA[
    protected recId bridgingPostingRecID(BankCodaAccountStatementLines     _bankCodaAccountStatementLines)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        LedgerTransFurtherPosting ledgerTransFurtherPosting;
        VendTrans vendTrans;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        select firstonly RefRecId from ledgerTransFurtherPosting
            join GeneralJournalEntry, LedgerDimension, RecId from generalJournalAccountEntry
            join Invoice, LastSettleVoucher, LastSettleDate from vendTrans
            join RecId from generalJournalEntry
            join Voucher,AccountingDate from subledgerVoucherGeneralJournalEntry
                where vendTrans.Invoice == _bankCodaAccountStatementLines.InvoiceId
                && subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && subledgerVoucherGeneralJournalEntry.Voucher == vendTrans.LastSettleVoucher
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == vendTrans.DataAreaId
                && subledgerVoucherGeneralJournalEntry.AccountingDate == vendTrans.LastSettleDate
                && generalJournalEntry.Ledger == Ledger::current()
                && generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && ledgerTransFurtherPosting.RefRecId == generalJournalAccountEntry.RecId;

        return ledgerTransFurtherPosting.RefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCashDiscountLine</Name>
				<Source><![CDATA[
    protected boolean createCashDiscountLine(
        TransDate       _transDate,
        CurrencyCode    _currencyCode,
        PaymId          _paymId,
        Amount          _invoice,
        Amount          _paid,
        CustVendAC      _accountNum,
        ModuleCustVend  _moduleCustVend,
        CashDiscCode    _cashDiscCode,
        Amount          _discount
        )
    {
        LedgerJournalTrans      ledgerJournalTrans;
        boolean                 ret = true;
        LedgerDimensionDefaultAccount defaultAccount;

        ledgerJournalTrans = this.createLedgerJournalTrans(_currencyCode);

        ledgerJournalTrans.TransDate       = _transDate;
        ledgerJournalTrans.AccountType     = LedgerJournalACType::Ledger;

        if (_moduleCustVend == ModuleCustVend::Cust)
        {
            defaultAccount = CashDisc::paidLedgerDimension(_cashDiscCode);
            ledgerJournalTrans.AmountCurCredit     = abs(_discount);
        }
        else
        {
            defaultAccount = CashDisc::receivedLedgerDimension(_cashDiscCode);
            ledgerJournalTrans.AmountCurDebit = abs(_discount);
        }
        ledgerJournalTrans.parmLedgerDimension(ledgerJournalTrans.getLedgerDimensionForLedgerType(defaultAccount, ledgerJournalTrans.Company));

        ledgerJournalTrans.PaymId       = _paymId;
        ledgerJournalTrans.PaymentNotes = _accountNum+'\n'
                                          +"@SYS12128"+':'+_paymId+'\n'
                                          +"@SYS9458"+':'+num2str(abs(_invoice),10,2,2,1)+'\n'
                                          +"@SYS59532"+':'+num2str(abs(_paid),10,2,2,1)+'\n'
                                          +"@SYS4376"+':'+num2str(_discount,10,2,2,1);

        ledgerJournalTrans = this.insertLedgerJournalTrans(ledgerJournalTrans);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDiscountBePosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether discount has to be posted or not.
    /// </summary>
    /// <param name="_moduleCustVend">
    /// Variable specifying the module type.
    /// </param>
    /// <param name="_custVendTrans">
    /// The transaction for which to calculate the cash discount grace date.
    /// </param>
    /// <param name="_transDate">
    /// TransDate of the <c>BankAccountStatementLine</c> record.
    /// </param>
    /// <returns>
    /// True, if the transdate of the <c>BankAccountStatementLine</c> record
    /// is before the CashDiscount Grace Date.Otherwise,false.
    /// </returns>
    private boolean canDiscountBePosted(ModuleCustVend _moduleCustVend, CustvendTrans _custVendTrans, TransDate _transDate)
    {
        DiscGraceDays discGraceDays;
        TransDate     graceDateForDiscount;

        if (_custVendTrans)
        {
            graceDateForDiscount = CashDisc::find(_custVendTrans.CashDiscCode).discDate(_custVendTrans.TransDate);

            discGraceDays = CustVendPaymModeTable::findModule(_moduleCustVend, _custVendTrans.PaymMode).DiscGraceDays;

            graceDateForDiscount = graceDateForDiscount + discGraceDays;

            if (_transDate <= graceDateForDiscount)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustVendLine</Name>
				<Source><![CDATA[
    //This method will transfer the bankaccountstatementline to the
    //LedgerJournalTrans table as it's a customer settlement. In case an invoice is linked, the specTrans lines will also be created.
    protected boolean createCustVendLine(
        BankCodaAccountStatementLines _bankCodaAccountStatementLines,
        ModuleCustVend                _moduleCustVend
        )
    {
        boolean                 ret = true;
        LedgerJournalTrans      ledgerJournalTrans;
        CustVendTrans           custVendTrans;
        CustVendTransOpen       custVendTransOpen;
        CustTrans               custTrans;
        CustTransOpen           custTransOpen;
        VendTrans               vendTrans;
        VendTransOpen           vendTransOpen;
        SpecTrans               specTrans;
        boolean                 postDiscount;
        CurrencyCode            currencyCode;
        boolean                 openTransAction;
        LedgerDimensionAccount  bridgingAccount;
        LedgerJournalACType     ledgerJournalACType;
        LedgerDimensionDefaultAccount defaultAccount;

        if (_bankCodaAccountStatementLines.LedgerDimension)
        {
            currencyCode = BankAccountTable::find(_bankCodaAccountStatementLines.AccountId).CurrencyCode;
            ledgerJournalTrans = this.createLedgerJournalTrans(currencyCode);

            ledgerJournalTrans.TransDate = bankCodaAccountStatement.AccountStatementDate;
            ledgerJournalTrans.Txt       = _bankCodaAccountStatementLines.Message;

            if (_moduleCustVend == ModuleCustVend::Cust)
            {
                custVendTrans = custTrans;

                ledgerJournalTrans.AccountType = str2enum(ledgerJournalACType, enum2str(_bankCodaAccountStatementLines.AccountType));
                if (ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
                {
                    defaultAccount = _bankCodaAccountStatementLines.LedgerDimension;
                    ledgerJournalTrans.parmLedgerDimension(ledgerJournalTrans.getLedgerDimensionForLedgerType(defaultAccount, ledgerJournalTrans.Company));
                }
                else
                {
                    ledgerJournalTrans.parmAccount(_bankCodaAccountStatementLines.parmAccount());
                }

                if (_bankCodaAccountStatementLines.AmountCur > 0)
                {
                    ledgerJournalTrans.AmountCurCredit = abs(_bankCodaAccountStatementLines.AmountCur);
                }
                else
                {
                    ledgerJournalTrans.AmountCurDebit  = abs(_bankCodaAccountStatementLines.AmountCur);
                }
            }
            else
            {
                custVendTrans   = vendTrans;
                openTransAction = this.openTransAction(_bankCodaAccountStatementLines.InvoiceId);

                if (conLen(str2con(_bankCodaAccountStatementLines.InvoiceId)) > 1 && !openTransAction)
                {
                    throw error("@CashManagement:VendorBankStatementLineCanBeMatchedToOneInvoice");
                }

                if (! openTransAction)
                {
                    bridgingAccount = this.bridgingPosting(_bankCodaAccountStatementLines.InvoiceId);
                }

                if (! openTransAction && bridgingAccount)
                {
                    ledgerJournalTrans.AccountType = LedgerJournalACType::Ledger;
                    ledgerJournalTrans.parmLedgerDimension(bridgingAccount);
                    ledgerJournalTrans.FurtherPostingType  = true;
                    ledgerJournalTrans.FurtherPostingRecId = this.bridgingPostingRecID(_bankCodaAccountStatementLines);
                }
                else
                {
                    ledgerJournalTrans.AccountType = str2enum(ledgerJournalACType, enum2str(_bankCodaAccountStatementLines.AccountType));

                    if (ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
                    {
                        if (openTransAction)
                        {
                            defaultAccount = _bankCodaAccountStatementLines.LedgerDimension;
                        }
                        else
                        {
                            defaultAccount = bankCodaParameters.LedgerDimension;
                        }

                        ledgerJournalTrans.parmLedgerDimension(ledgerJournalTrans.getLedgerDimensionForLedgerType(defaultAccount, ledgerJournalTrans.Company));
                    }
                    else
                    {
                        ledgerJournalTrans.parmAccount(_bankCodaAccountStatementLines.parmAccount());
                    }

                    if (openTransAction)
                    {
                        ledgerJournalTrans.SettleVoucher = SettlementType::SelectedTransact;
                    }
                }

                if (_bankCodaAccountStatementLines.AmountCur > 0)
                {
                    ledgerJournalTrans.AmountCurCredit = abs(_bankCodaAccountStatementLines.AmountCur);
                }
                else
                {
                    ledgerJournalTrans.AmountCurDebit  = abs(_bankCodaAccountStatementLines.AmountCur);
                }
            }

            if (_bankCodaAccountStatementLines.AmountCur > 0)
            {
                ledgerJournalTrans.AmountCurCredit = abs(_bankCodaAccountStatementLines.AmountCur);
            }
            else
            {
                ledgerJournalTrans.AmountCurDebit  = abs(_bankCodaAccountStatementLines.AmountCur);
            }

            ledgerJournalTrans.OffsetAccountType = LedgerJournalName::find(ledgerJournalTable.JournalName).OffsetAccountType;
            if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                defaultAccount = LedgerJournalName::find(ledgerJournalTable.JournalName).parmOffsetLedgerDimension();
                ledgerJournalTrans.parmOffsetLedgerDimension(ledgerJournalTrans.getOffsetLedgerDimensionForLedgerType(defaultAccount, ledgerJournalTrans.getOffsetCompany()));
            }
            else
            {
                ledgerJournalTrans.parmOffsetAccount(LedgerJournalName::find(ledgerJournalTable.JournalName).parmOffsetAccount());
            }

            ledgerJournalTrans = this.insertLedgerJournalTrans(ledgerJournalTrans);

            if (SpecTrans::getSpecTransCount(
                    _bankCodaAccountStatementLines.company(),
                    _bankCodaAccountStatementLines.TableId,
                    _bankCodaAccountStatementLines.RecId) > 1)
            {
                CustVendTrans custVendTransLoc = custVendTrans.data();

                custVendTransOpen = _moduleCustVend == ModuleCustVend::Cust
                    ? custTransOpen as CustVendTransOpen
                    : vendTransOpen as CustVendTransOpen;

                // It is not possible to use the update_recordset statement due to
                // the fact that it does not support crossCompany updates.
                while select forupdate crossCompany specTrans
                    where specTrans.SpecTableId == _bankCodaAccountStatementLines.TableId
                        && specTrans.SpecRecId == _bankCodaAccountStatementLines.RecId
                        && specTrans.SpecCompany == _bankCodaAccountStatementLines.company()
                    join RecId, RefRecId, AmountCur from custVendTransOpen
                        where custVendTransOpen.RecId == specTrans.RefRecId
                            && custVendTransOpen.TableId == specTrans.RefTableId
                            && custVendTransOpen.DataAreaId == specTrans.RefCompany
                    join RecId, CurrencyCode from custVendTransLoc
                        where custVendTransLoc.RecId == custVendTransOpen.RefRecId
                {
                    changecompany(specTrans.RefCompany)
                    {
                        specTrans.SpecTableId = tablenum(LedgerJournalTrans);
                        specTrans.SpecRecId = ledgerJournalTrans.RecId;
                        specTrans.Code = custVendTransLoc.CurrencyCode;
                        specTrans.Balance01 = custVendTransOpen.AmountCur;
                        specTrans.update();
                    }
                }

                ledgerJournalTrans.SettleVoucher = SettlementType::SelectedTransact;
            }
            else
            {
                select forupdate crossCompany specTrans
                    where  specTrans.SpecTableId == _bankCodaAccountStatementLines.TableId
                       &&  specTrans.SpecRecId   == _bankCodaAccountStatementLines.RecId
                       &&  specTrans.SpecCompany == _bankCodaAccountStatementLines.company();
                if (specTrans)
                {
                    if (_moduleCustVend == ModuleCustVend::Cust)
                    {
                        custVendTrans = specTrans.custTrans();
                    }
                    else
                    {
                        vendTrans     = specTrans.vendTrans();
                        custVendTrans = vendTrans;
                        ledgerJournalTrans.RemittanceAddress  = vendTrans.RemittanceAddress;
                        ledgerJournalTrans.RemittanceLocation = vendTrans.RemittanceLocation;
                    }

                    specTrans.SpecTableId = tablenum(LedgerJournalTrans);
                    specTrans.SpecRecId   = ledgerJournalTrans.RecId;
                    specTrans.Code        = custVendTrans.CurrencyCode;

                    if (_bankCodaAccountStatementLines.CashDiscLinked == NoYes::No)
                    {
                        this.amountToSettle(custVendTrans.AmountCur,_bankCodaAccountStatementLines.AmountCur);
                    }
                    else
                    {
                        postDiscount = this.canDiscountBePosted(_moduleCustVend, custVendTrans, _bankCodaAccountStatementLines.StatementDate);
                    }
                    if (postDeviation)
                    {
                        specTrans.Balance01 = custVendTrans.AmountCur;
                    }
                    else
                    {
                        specTrans.Balance01 = _bankCodaAccountStatementLines.AmountCur;
                    }
                    changecompany(specTrans.RefCompany)
                    {
                        specTrans.update();
                    }

                    ledgerJournalTrans.SettleVoucher       = SettlementType::SelectedTransact;
                    
                    if (specTrans.Balance01 > 0)
                    {
                        ledgerJournalTrans.AmountCurCredit = abs(specTrans.Balance01);
                    }
                    else
                    {
                        ledgerJournalTrans.AmountCurDebit  = abs(specTrans.Balance01);
                    }
                }
           }
           ledgerJournalTrans.PaymId = _bankCodaAccountStatementLines.InvoiceId;
           ledgerJournalTrans = this.insertLedgerJournalTrans(ledgerJournalTrans, false);

            if (postDeviation)
            {
                postDeviation = false;
                this.createDeviationLine(_bankCodaAccountStatementLines.DatePosted,
                    currencyCode,
                    ledgerJournalTrans.PaymId,
                    custVendTrans.AmountCur,
                    _bankCodaAccountStatementLines.AmountCur,
                    ledgerJournalTrans.parmAccount());
                amountDeviation = 0;
            }

            postDiscount = postDiscount & !BankCodaParameters::find().IgnoreCashDiscount;

            if (postDiscount)
            {
                postDiscount = false;
                this.createCashDiscountLine(_bankCodaAccountStatementLines.DatePosted,
                        currencyCode,
                        ledgerJournalTrans.PaymId,
                        custVendTrans.AmountCur,
                        _bankCodaAccountStatementLines.AmountCur,
                        ledgerJournalTrans.parmAccount(),
                        _moduleCustVend,
                        custVendTrans.CashDiscCode,
                        custVendTrans.possibleCashDisc(_bankCodaAccountStatementLines.TransDate));
            }
        }
        else
        {
            ret        = false;
            errorCause = BankCodaTransferErrorCause::NoAccount;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDeviationLine</Name>
				<Source><![CDATA[
    protected boolean createDeviationLine(
        TransDate       _transDate,
        CurrencyCode    _currencyCode,
        PaymId          _paymId,
        Amount          _invoice,
        Amount          _paid,
        CustVendAC      _accountNum
        )
    {
        LedgerJournalTrans  ledgerJournalTrans;
        boolean             ret                     = true;
        LedgerDimensionDefaultAccount defaultAccount;

        ledgerJournalTrans = this.createLedgerJournalTrans(_currencyCode);

        ledgerJournalTrans.TransDate     = _transDate;
        ledgerJournalTrans.AccountType   = LedgerJournalACType::Ledger;
        ledgerJournalTrans.PaymId        = _paymId;
        ledgerJournalTrans.PaymentNotes  = _accountNum+'\n'
                                           +"@SYS12128"+':'+_paymId+'\n'
                                           +"@SYS9458"+':'+num2str(abs(_invoice),10,2,2,1)+'\n'
                                           +"@SYS59532"+':'+num2str(abs(_paid),10,2,2,1);
        if (amountDeviation > 0)
        {
            defaultAccount = bankCodaParameters.ProfitLedgerDimension;
            ledgerJournalTrans.AmountCurCredit = abs(amountDeviation);
        }
        else
        {
            defaultAccount = bankCodaParameters.LossLedgerDimension;
            ledgerJournalTrans.AmountCurDebit  = abs(amountDeviation);
        }
        ledgerJournalTrans.parmLedgerDimension(ledgerJournalTrans.getLedgerDimensionForLedgerType(defaultAccount, ledgerJournalTrans.Company));

        ledgerJournalTrans.OffsetAccountType = LedgerJournalName::find(ledgerJournalTable.JournalName).OffsetAccountType;
        if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
        {
            defaultAccount = LedgerJournalName::find(ledgerJournalTable.JournalName).parmOffsetLedgerDimension();
            ledgerJournalTrans.parmOffsetLedgerDimension(ledgerJournalTrans.getOffsetLedgerDimensionForLedgerType(defaultAccount, ledgerJournalTrans.getOffsetCompany()));
        }
        else
        {
            ledgerJournalTrans.parmOffsetAccount(LedgerJournalName::find(ledgerJournalTable.JournalName).parmOffsetAccount());
        }

        ledgerJournalTrans = this.insertLedgerJournalTrans(ledgerJournalTrans);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerJournalTable</Name>
				<Source><![CDATA[
    //This method will create a new ledgerjournalTable
    //record of the type defined in codajournalname of the bankAccount
    protected boolean createLedgerJournalTable()
    {
        boolean          ret = true;

        ledgerJournalTable.JournalName = BankCodaAccountTable::findByAccountId(bankCodaAccountStatement.AccountId).CodaJournalName;

        if (! ledgerJournalTable.JournalName)
        {
            errorCause = BankCodaTransferErrorCause::NoCodaJournalName;
            ret = false;
        }
        else
        {
            ledgerJournalTable.initFromLedgerJournalName();
            ledgerJournalTable.insert();
        }

        ledgerJournalId = ledgerJournalTable.JournalNum;
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerJournalTrans</Name>
				<Source><![CDATA[
    //This method will initialize the new ledgerjournaltrans record
    //to be created and the ledgerjournalEngine
    protected LedgerJournalTrans createLedgerJournalTrans(CurrencyCode  _currencyCode)
    {
        NumberSeq           numberSeq;
        LedgerJournalName   journalName;
        LedgerJournalTrans  ledgerJournalTrans;

        ledgerJournalTrans.initValue();
        ledgerJournalTrans.JournalNum   = ledgerJournalId;
        ledgerJournalEngine.initValue(ledgerJournalTrans);
        ledgerJournalTrans.CurrencyCode = _currencyCode;

        if (!ledgerJournalTrans.Voucher && ledgerJournalEngine.takeNewVoucher())
        {
            select journalName
            where journalName.JournalName == ledgerJournalTable.JournalName;
            if (journalName)
            {
                switch (journalName.NewVoucher)
                {
                    case NewVoucher::OneVoucher:
                        numberSeq = NumberSeq::newReserveNumFromId(journalName.NumberSequenceTable);
                        ledgerJournalTrans.Voucher = numberSeq.num();
                        numberSeq.used();
                        break;
                    case NewVoucher::BalanceSheet:
                        numberSeq = NumberSeq::newReserveNumFromId(journalName.NumberSequenceTable);
                        ledgerJournalTrans.Voucher = numberSeq.num();
                        numberSeq.used();
                        break;
                    default: break;
                }
            }
        }
        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerLine</Name>
				<Source><![CDATA[
    //This method will transfer the bankaccountstatementline to the LedgerJournalTrans table.
    protected boolean createLedgerLine(BankCodaAccountStatementLines     _bankCodaAccountStatementLines)
    {
        boolean                 ret  = true;
        LedgerJournalTrans      ledgerJournalTrans;
        LedgerJournalACType     ledgerJournalACType;
        LedgerDimensionDefaultAccount defaultAccount;

        if (_bankCodaAccountStatementLines.LedgerDimension)
        {
            ledgerJournalTrans = this.createLedgerJournalTrans(BankAccountTable::find(_bankCodaAccountStatementLines.AccountId).CurrencyCode);

            ledgerJournalTrans.TransDate   = bankCodaAccountStatement.AccountStatementDate;

            ledgerJournalTrans.AccountType = str2enum(ledgerJournalACType, enum2str(_bankCodaAccountStatementLines.AccountType));
            Debug::assert(ledgerJournalTrans.AccountType == ledgerJournalACType);

            defaultAccount = _bankCodaAccountStatementLines.LedgerDimension;
            ledgerJournalTrans.parmLedgerDimension(ledgerJournalTrans.getLedgerDimensionForLedgerType(defaultAccount, ledgerJournalTrans.Company));

            ledgerJournalTrans.Txt         = _bankCodaAccountStatementLines.Message;

            if (_bankCodaAccountStatementLines.AmountCur > 0)
            {
                ledgerJournalTrans.AmountCurCredit = abs(_bankCodaAccountStatementLines.AmountCur);
            }
            else
            {
                ledgerJournalTrans.AmountCurDebit  = abs(_bankCodaAccountStatementLines.AmountCur);
            }
            ledgerJournalTrans.TaxGroup      = _bankCodaAccountStatementLines.TaxGroup;
            ledgerJournalTrans.TaxItemGroup  = _bankCodaAccountStatementLines.TaxItemGroup;

            if (ledgerJournalTrans.TaxGroup && ledgerJournalTrans.TaxItemGroup)
                ledgerJournalTrans.TaxDirectionControl = NoYes::Yes;

            ledgerJournalTrans.OffsetAccountType = LedgerJournalName::find(ledgerJournalTable.JournalName).OffsetAccountType;
            if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                defaultAccount = LedgerJournalName::find(ledgerJournalTable.JournalName).parmOffsetLedgerDimension();
                ledgerJournalTrans.parmOffsetLedgerDimension(ledgerJournalTrans.getOffsetLedgerDimensionForLedgerType(defaultAccount, ledgerJournalTrans.getOffsetCompany()));
            }
            else
            {
                ledgerJournalTrans.parmOffsetAccount(LedgerJournalName::find(ledgerJournalTable.JournalName).parmOffsetAccount());
            }

            ledgerJournalTrans = this.insertLedgerJournalTrans(ledgerJournalTrans);
        }
        else
        {
            ret = false;
            errorCause = BankCodaTransferErrorCause::NoAccount;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayProgress</Name>
				<Source><![CDATA[
    protected void displayProgress(
        Counter                     _line,
        BankCodaTransactionType     _transType
        )
    {
        this.progressUpdate(strfmt("@SYS79599",_line, enum2str(_transType)),_line);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getErrorString</Name>
				<Source><![CDATA[
    protected str getErrorString()
    {
        str     errorString;

        switch (errorCause)
        {
            case BankCodaTransferErrorCause::NoAccountType:
                errorString = "@SYS79600";
                break;

            case BankCodaTransferErrorCause::NoCodaJournalName:
                errorString = "@SYS79601";
                break;

            case BankCodaTransferErrorCause::NoAccount:
                errorString = "@SYS79566";
                break;

            default:
                errorString = this.extensionGetErrorString(errorCause);
        }

        return errorString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>extensionGetErrorString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the extension error string by CODA error cause.
    /// </summary>
    /// <param name = "_errorCause">
    /// CODA error cause.
    /// </param>
    /// <returns>
    /// Error string.
    /// </returns>
    [Replaceable(true)]
    protected str extensionGetErrorString(BankCodaTransferErrorCause _errorCause)
    {
        return "@SYS79602";
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasChildStatementLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     checks if there are any child statement lines.
    /// </summary>
    /// <param name="_bankCodaAccountStatementLines">
    ///     Line for which we have to find the child statement lines.
    /// </param>
    /// <returns>
    ///     True if Child statement lines are found, otherwise false.
    /// </returns>
    protected boolean hasChildStatementLines(BankCodaAccountStatementLines _bankCodaAccountStatementLines)
    {
        BankCodaAccountStatementLines bankCodaAccountStatementLines;

        return (select firstonly RecId
            from bankCodaAccountStatementLines
                where bankCodaAccountStatementLines.SequenceNumber == _bankCodaAccountStatementLines.SequenceNumber
                && bankCodaAccountStatementLines.RefRecId          == _bankCodaAccountStatementLines.RecId
                && bankCodaAccountStatementLines.TransactionType   == BankCodaTransactionType::Movement
                && bankCodaAccountStatementLines.DetailNumber      != '0000').RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initEngine</Name>
				<Source><![CDATA[
    //This method creates a new instance of the class ledgerjournalEngine
    //and inits the ledgerjournaltable of this class with the one created.
    protected void initEngine()
    {
        ledgerJournalEngine = new LedgerJournalEngine(null);
        ledgerJournalEngine.ledgerJournalTable(ledgerJournalTable);
        ledgerJournalEngine.newJournalActive(ledgerJournalTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLedgerJournalTrans</Name>
				<Source><![CDATA[
    //This method performs the same code as if the line is created by a
    //user on the form. A prewrite and write are executed on t ledgerjournalengine
    //and the ledgerjournaltrans record is inserted or updated
    protected LedgerJournalTrans insertLedgerJournalTrans(
        LedgerJournalTrans _ledgerJournalTrans,
        boolean            _insert = true
        )
    {
        ledgerJournalEngine.active(_ledgerJournalTrans);
        ledgerJournalEngine.currencyModified(_ledgerJournalTrans);
        ledgerJournalEngine.preWrite(_ledgerJournalTrans);
        ledgerJournalEngine.preWriteUpdateDefaultDimension(_ledgerJournalTrans, null);

        if (_insert)
        {
            _ledgerJournalTrans.insert();
        }
        else
        {
            _ledgerJournalTrans.update();
        }

        ledgerJournalEngine.write(_ledgerJournalTrans);

        return _ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfRecords</Name>
				<Source><![CDATA[
    protected int numberOfRecords()
    {
        BankCodaAccountStatementLines       bankAccountStatementLines;

        select count(RecId) from bankAccountStatementLines
               where  bankAccountStatementLines.AccountStatementNum == bankCodaAccountStatement.AccountStatementNum
                  &&  bankAccountStatementLines.StatementDate       == bankCodaAccountStatement.AccountStatementDate
                  &&  bankAccountStatementLines.TransactionType     == BankCodaTransactionType::Movement
                  &&  bankAccountStatementLines.Processed           == NoYes::No;

        return any2int(bankAccountStatementLines.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>openTransAction</Name>
				<Source><![CDATA[
    protected boolean openTransAction(BankCodaInvoiceId _codaInvoiceId)
    {
        VendTrans       vendTrans;
        VendTransOpen   vendTransOpen;
        boolean         openTransAction;
        container       invoiceID;
        int             i;
        InvoiceId       invId;

        invoiceID = str2con(_codaInvoiceId);

        for (i=1; i<=conLen(invoiceID); i++)
        {
            if (i == 1)
            {
                openTransAction = true;
            }

            invId = conPeek(invoiceID,i);

            if (invId)
            {
                select firstonly RecId from vendTransOpen
                    exists join vendTrans
                    where vendTransOpen.RefRecId == vendTrans.RecId
                        && vendTrans.Invoice == invId;
            }

            openTransAction = openTransAction && (vendTransOpen.RecId != 0);
        }

        return openTransAction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container ret;

        ret = super();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankAccountStatement</Name>
				<Source><![CDATA[
    public void parmBankAccountStatement(BankCodaAccountStatement   _bankAccountStatement)
    {
        bankCodaAccountStatement = _bankAccountStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressUpdate</Name>
				<Source><![CDATA[
    protected void progressUpdate(
        str         _text,
        Counter     _line
        )
    {
        progress.setCount(_line);
        progress.setText(_text);
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        BankCodaAccountStatementLines   bankAccountStatementLines;
        BankCodaAccountStatement    codaBankAccountStatement;
        LedgerJournalEngine_Server  ledgerJournalEngine_Server;
        boolean                     transferStatus;
        BankAccountTable            bankAccountTable;

        bankAccountTable = BankAccountTable::find(bankCodaAccountStatement.AccountId);

        if (bankAccountTable)
        {
            if (!bankAccountTable.checkIsActiveForAllTransactions())
            return;
        }

        this.progressInit(strfmt("@SYS79603", bankCodaAccountStatement.AccountStatementNum), this.numberOfRecords(), #AviFindFile);
        this.displayProgress(recCount, BankCodaTransactionType::None);

        transferStatus     = true;
        bankCodaParameters = BankCodaParameters::find();
        codaDeviation      = bankCodaParameters.CodaDeviation;

        ttsbegin;
        if (this.createLedgerJournalTable())
        {
            this.initEngine();

            while select forupdate bankAccountStatementLines
                order by SequenceNumber,DetailNumber
                where    bankAccountStatementLines.AccountStatementNum == bankCodaAccountStatement.AccountStatementNum &&
                         bankAccountStatementLines.StatementDate       == bankCodaAccountStatement.AccountStatementDate &&
                         bankAccountStatementLines.AccountId           == bankCodaAccountStatement.AccountId &&
                         bankAccountStatementLines.TransactionType     == BankCodaTransactionType::Movement            &&
                         bankAccountStatementLines.DetailNumber        == '0000'
            {
                recCount++;
                this.displayProgress(recCount, BankCodaTransactionType::Movement);

                if (bankAccountStatementLines.GlobalisationCode == GlobalisationCode::None)
                {
                    throw error("@SYS79626");
                }
				if (bankAccountStatementLines.GlobalisationCode == GlobalisationCode::Global
                    || (bankAccountStatementLines.GlobalisationCode == GlobalisationCode::Details
                        && !this.hasChildStatementLines(bankAccountStatementLines)
                        && bankCodaParameters.ProcessCodaDetail))
                {
                    transferStatus = this.transfer(bankAccountStatementLines);
                }
                else
                {
                    this.searchStatementLines(bankAccountStatementLines, true);
                }

                if (! transferStatus)
                {
                    break;
                }
            }

            // update LedgerJournalTable with balances
            ledgerJournalTable = LedgerJournalTable::find(ledgerJournalId, true);
            ledgerJournalEngine_Server = LedgerJournalEngine_Server::construct();

            [ledgerJournalTable.JournalTotalDebit,
             ledgerJournalTable.JournalTotalCredit,
             ledgerJournalTable.JournalTotalOffsetBalance] = ledgerJournalEngine_Server.initBalances(ledgerJournalTable.JournalNum, true);

            if (BankAccountTable::find(ledgerJournalTable.parmOffsetAccount()).BankMultiCurrency)
            {
                ledgerJournalTable.JournalBalance = ledgerJournalTable.JournalTotalOffsetBalance;
            }
            else
            {
                ledgerJournalTable.JournalBalance = CurrencyExchangeHelper::curAmount(ledgerJournalTable.JournalTotalOffsetBalance, BankAccountTable::find(LedgerJournalName::find(ledgerJournalTable.JournalName).parmOffsetAccount()).CurrencyCode);
            }
            ledgerJournalTable.update();
        }

        if (! transferStatus)
        {
            throw error(this.getErrorString());
        }

        select forupdate codaBankAccountStatement
            where codaBankAccountStatement.RecId == bankCodaAccountStatement.RecId;

        codaBankAccountStatement.DetailsTransferred = NoYes::Yes;
        codaBankAccountStatement.Processed          = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        codaBankAccountStatement.ReconcileDate      = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        codaBankAccountStatement.update();

        ttscommit;

        Info(strFmt("@ApplicationSuite_Localization:BankCodaTransferComplete", ledgerJournalTable.JournalNum));
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchStatementLines</Name>
				<Source><![CDATA[
    protected void searchStatementLines(
        BankCodaAccountStatementLines _bankCodaAccountStatementLines,
        boolean                       _details                          = true
        )
    {
        BankCodaAccountStatementLines bankAccountStatementLinesLocal;
        boolean                   transferStatus;

        while select forupdate bankAccountStatementLinesLocal
            order by SequenceNumber,DetailNumber
            where bankAccountStatementLinesLocal.SequenceNumber    == _bankCodaAccountStatementLines.SequenceNumber
               && bankAccountStatementLinesLocal.RefRecId          == _bankCodaAccountStatementLines.RecId
               && bankAccountStatementLinesLocal.TransactionType   == BankCodaTransactionType::Movement
               && bankAccountStatementLinesLocal.DetailNumber      != '0000'
        {
            recCount++;
            this.displayProgress(recCount,BankCodaTransactionType::Movement);

            if (bankAccountStatementLinesLocal.GlobalisationCode == GlobalisationCode::None)
            {
                throw error("@SYS79626");
            }

            if (_details && bankAccountStatementLinesLocal.GlobalisationCode == GlobalisationCode::Details)
            {
                if (this.hasChildStatementLines(bankAccountStatementLinesLocal))
                {
                    this.searchStatementLines(bankAccountStatementLinesLocal, false);
                }
                else
                {
                    transferStatus = this.transfer(bankAccountStatementLinesLocal);
                }
            }

            if (! _details || bankAccountStatementLinesLocal.GlobalisationCode == GlobalisationCode::Global)
            {
                transferStatus = this.transfer(bankAccountStatementLinesLocal);
            }

            if (! transferStatus)
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transfer</Name>
				<Source><![CDATA[
    //According to the accountype,
    //the adequate method is called to handle the bankaccountstatementline record
    protected boolean transfer(BankCodaAccountStatementLines     _bankCodaAccountStatementLines)
    {
        boolean  transferStatus;

        switch (_bankCodaAccountStatementLines.AccountType)
        {
            case BankCodaLedgerJournalACType::Cust:
                transferStatus = this.createCustVendLine(_bankCodaAccountStatementLines, ModuleCustVend::Cust);
                break;

            case BankCodaLedgerJournalACType::Vend:
                transferStatus = this.createCustVendLine(_bankCodaAccountStatementLines, ModuleCustVend::Vend);
                break;

            case BankCodaLedgerJournalACType::Ledger:
                transferStatus = this.createLedgerLine(_bankCodaAccountStatementLines);
                break;

            default :
                errorCause     = BankCodaTransferErrorCause::NoAccountType;
                transferStatus = false;
        }

        return transferStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        boolean ret;

        ret = super(packedClass);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static public BankCodaTransfer construct()
    {
        return new BankCodaTransfer();
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static public void main(Args _args)
    {
        BankCodaTransfer      codaTransfer = BankCodaTransfer::construct();

        if (_args.dataset() == tablenum(BankCodaAccountStatement))
        {
            codaTransfer.parmBankAccountStatement(_args.record());
        }
        else
        {
            if (_args.dataset() == tablenum(BankCodaAccountStatementLines))
            {
                codaTransfer.parmBankAccountStatement(BankCodaAccountStatement::findLines(_args.record()));
            }
            else
            {
                throw error("@SYS79604");
            }
        }
        codaTransfer.runOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>