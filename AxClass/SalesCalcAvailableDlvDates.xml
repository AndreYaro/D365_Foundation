<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesCalcAvailableDlvDates</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>SalesCalcAvailableDlvDates</c> class is the engine for the delivery date control.
/// </summary>
/// <remarks>
///  The class can be instantiated and used through the following static methods:
///  <list type="bullet">
///   <item>
///   <description><see cref="M:SalesCalcAvailableDlvDates::initDateFields" /></description>
///   </item>
///   <item>
///   <description><see cref="M:SalesCalcAvailableDlvDates::main" /></description>
///   </item>
///  </list>
/// </remarks>
abstract class SalesCalcAvailableDlvDates extends RunBase
{
    #define.notFoundLeadTime(-1)

    SalesDeliveryDateControlMap deliveryDateControlMap;
    int                         calcDays;

    InventLocationId            inventLocationIdSelected;
    DlvModeId                   dlvModeIdSelected;
    SalesShippingDateAvailable  shippingDateAvailableSelected;
    SalesReceiptDateAvailable   receiptDateAvailableSelected;

    PriceDisc_Price             priceDisc;

    TransDate                   shippingDateBestGuess;
    TransDate                   receiptDateBestGuess;

    TransDate                   effectiveOrderDate;

    TransDate                   masterDate;
    SalesDlvDateType            masterDateType;

    NoYesId                     returnConfirmedDates;

    SalesAvailableDlvDatesTmp   salesAvailableDlvDatesTmp;
    SalesAvailableDlvDatesTmp   salesAvailableDlvDatesTmpBestGuess;

    boolean                     showTransferToConfirmedButton;
    boolean                     showTransferToRequestedButton;
    boolean                     showDisableDlvDateControlButton;
    boolean                     showActualShipDates;
    boolean                     showConfirmation;

    SalesCreateReleaseOrderLog  errorText;
    Exception                   errorTextType;
    boolean                     disableDlvDateControl;

    CalendarId                  receiptCalendarId;
    LeadTime                    salesLeadTime;
    LeadTime                    salesLeadTimeBasedOnCalendarSetup;
    boolean                     salesLeadTimeFound;

    boolean                     cancelModifiedField;
    boolean                     acceptWarnings;
    boolean                     checkOnly;
    boolean                     enableShowDialog;
    boolean                     showDialog;
    boolean                     recalculateShippingDate;
    boolean                     forceCalcToUseMarking;
    int                         infologLineStart;
    FormTreeControl             errorTreeCtrl;
    SysInfolog                  tmpInfoTable;

    boolean                     includeTodayInAvailableDlvDates;

    InventSiteId                    inventSiteIdSelected;
    InventLocationId                inventLocationIdTransportShipping;
    SalesOrderEntryDeadlineUser     orderEntryDeadlineUser;
    SalesOrderEntryDeadlineSite     orderEntryDeadlineSite;
    InventOrderEntryDeadlineGroupId orderEntryDeadlineGroupId;

    TransDate                       shippingLocationDate;

    boolean                         isTempDeliveryDateControlType;
    SalesDeliveryDateControlType    salesDeliveryDateControlType;

    ReqSetupDim                     reqSetupDim;
    InventDimId                     inventDimId;
    boolean                         hasPromiseLeadTime;

    private SalesInstrumentationLogger instrumentationLogger;

    #DEFINE.CurrentVersion(5)
    #LOCALMACRO.CurrentList
        calcDays,
        dlvModeIdSelected,
        inventLocationIdSelected,
        inventSiteIdSelected,
        deliveryDateControlMap,
        showTransferToConfirmedButton,
        showTransferToRequestedButton,
        showDisableDlvDateControlButton,
        errorText,
        shippingDateAvailableSelected,
        receiptDateAvailableSelected,
        orderEntryDeadlineUser,
        orderEntryDeadlineSite,
        infologLineStart,
        effectiveOrderDate,
        inventLocationIdTransportShipping,
        salesLeadTime,
        salesLeadTimeFound,
        salesLeadTimeBasedOnCalendarSetup,
        returnConfirmedDates,
        orderEntryDeadlineGroupId,
        disableDlvDateControl,
        receiptCalendarId,
        includeTodayInAvailableDlvDates,
        masterDateType,
        masterDate,
        shippingDateBestGuess,
        receiptDateBestGuess,
        errorTextType,
        cancelModifiedField,
        acceptWarnings,
        checkOnly,
        enableShowDialog,
        showDialog,
        recalculateShippingDate,
        tmpInfoTable,
        shippingLocationDate,
        salesAvailableDlvDatesTmpBestGuess,
        isTempDeliveryDateControlType,
        salesDeliveryDateControlType,
        forceCalcToUseMarking,
        showActualShipDates,
        showConfirmation
    #ENDMACRO

    //List of parameters extracted from arguments for the transfer from main() to mainOnServer().
    //Do not include records in this list, as it will not work with respect to calls to .orig()
    #LOCALMACRO.CachedArgsList
        formName
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowEditDlvMode</Name>
				<Source><![CDATA[
    public boolean allowEditDlvMode()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditInventLocation</Name>
				<Source><![CDATA[
    public boolean allowEditInventLocation()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditInventSite</Name>
				<Source><![CDATA[
    public boolean allowEditInventSite()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAllUnitConversionInfoRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if more information is needed in order to do unit conversions.
    /// </summary>
    /// <returns>
    /// true if we have all information needed to perform unit conversions; otherwise, false
    /// </returns>
    /// <remarks>
    /// This is needed when using proudct variant level conversions.
    /// If we don't have enough information we delay the actions of this class until more information is required.
    /// </remarks>
    protected boolean validateAllUnitConversionInfoRequired()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustLeadTimeForWorkingDays</Name>
				<Source><![CDATA[
    protected LeadTime adjustLeadTimeForWorkingDays(LeadTime _originalLeadTime)
    {
        if (SalesParameters::find().CalendarDays == NoYes::No)
        {
            return _originalLeadTime;
        }

        WorkCalendarSched workCalendarSched = new WorkCalendarSched();

        TransDate effectiveDate = this.effectiveOrderDate();
        effectiveDate = workCalendarSched.schedDate(SchedDirection::Forward,
                                                    effectiveDate,
                                                    0,
                                                    true,
                                                    this.shippingCalendarId());

        SalesShippingDateAvailable availableShippingDate = workCalendarSched.schedDate(SchedDirection::Forward,
                                                                                        effectiveDate,
                                                                                        _originalLeadTime,
                                                                                        true,
                                                                                        this.shippingCalendarId());

        return availableShippingDate - this.effectiveOrderDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBackward</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the first available receipt date backward from <paramref name="_fromDate" />. Then, the ship date is calculated based on the first available receipt date.
    /// </summary>
    /// <param name="_fromDate">
    ///    The starting date for the calculation.
    /// </param>
    /// <param name="_workCalendarSched">
    ///    Class object for class <c>WorkCalendarSched</c>.
    /// </param>
    /// <param name="_shippingCalendarId">
    ///    Shipping calendar.
    /// </param>
    /// <param name="_transportCalendarId">
    ///    Transport calendar.
    /// </param>
    /// <param name="_transportDays">
    ///    Number of transport days.
    /// </param>
    /// <returns>
    ///    Container: Available ship date and available receipt date.
    /// </returns>
    protected container calcBackward(FromDate                    _fromDate,
                                     WorkCalendarSched           _workCalendarSched,
                                     CalendarId                  _shippingCalendarId,
                                     CustVendTransportCalendarId _transportCalendarId,
                                     CustVendTransportDays       _transportDays)
    {
        // Calculate first available receipt date backward from planed receipt date
        SalesReceiptDateAvailable availableReceiptDate = this.scheduleDateInReceiptCalendar(_workCalendarSched,
                                                                                              SchedDirection::Backward,
                                                                                      _fromDate,
                                                                                      0,
                                                                                              true);

        // Calculate closest shipping date
        SalesShippingDateAvailable availableShippingDate = this.scheduleDateInShippingAndTransportCalendar(_workCalendarSched,
                                                                                                           SchedDirection::Backward,
                                                                                        availableReceiptDate,
                                                                                        _transportDays,
                                                                                        true,
                                                                                        _transportCalendarId,
                                                                                        _shippingCalendarId,
                                                                                        SalesCheckForPickup::PrimaryCalendar);

        return [availableShippingDate,availableReceiptDate];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDatesFromUTCNow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Uses the current UTC date and time as a basis to compute the shipping and receipt dates.
    /// </summary>
    void calcDatesFromUTCNow()
    {
        this.parmShippingDate(this.effectiveOrderDate() + this.salesLeadTime());
        this.initMaster(this.masterDateType() == SalesDlvDateType::ConfirmedReceipt ? SalesDlvDateType::ConfirmedShipping : SalesDlvDateType::RequestedShipping);
        this.createPossibleShippingAndReceiptDates(true);
        this.setDates();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcEarliestShipReceiptDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the earliest shipping and receipt dates.
    /// </summary>
    /// <param name="_fromDate">
    /// A date value that holds a starting date.
    /// </param>
    /// <returns>
    /// A <c>container</c> that holds the earliest shipping date and the earliest receipt date.
    /// </returns>
    public container calcEarliestShipReceiptDates(TransDate     _fromDate = dateNull())
    {
        // need to reset a previous found lead time as this could be a default lead time (fallback).
        salesLeadTimeFound  = NoYes::No;

        // find earlist ship and receipt date starting from the effectiveOrderDate.
        masterDateType      = SalesDlvDateType::ConfirmedShipping;
        masterDate          = _fromDate ? max(_fromDate , this.effectiveOrderDate()) : this.effectiveOrderDate();

        this.parmShippingDateBestGuess(masterDate);
        this.parmReceiptDateBestGuess(masterDate);
        this.createPossibleShippingAndReceiptDates(true);

        return [salesAvailableDlvDatesTmpBestGuess.AvailableShippingDate,salesAvailableDlvDatesTmpBestGuess.AvailableReceiptDate];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcForward</Name>
				<Source><![CDATA[
    /// <summary>
    ///    First, calculates the first available ship date forward from the planned ship date <paramref name="_fromDate" /> (open for shipping and pickup). Then, calculates the first possible receipt date at
    ///    the customer (transport and receipt calendar does not have to be open at the same time). Finally, the ship date is moved closer to the calculated receipt date, if possible.
    /// </summary>
    /// <param name="_fromDate">
    ///    The starting date for the calculation.
    /// </param>
    /// <param name="_createOnlyOneRecord">
    ///    If this parameter is true, the lead time is considered and added to the planned ship date in the calculation.
    /// </param>
    /// <param name="_workCalendarSched">
    ///    The class object for class <c>WorkCalendarSched</c>.
    /// </param>
    /// <param name="_shippingCalendarId">
    ///    The shipping calendar.
    /// </param>
    /// <param name="_transportCalendarId">
    ///    The transport calendar.
    /// </param>
    /// <param name="_transportDays">
    ///    The number of transport days.
    /// </param>
    /// <param name="_salesLeadTimeCalc">
    ///    The number of lead time days.
    /// </param>
    /// <returns>
    ///    Available ship date and receipt date.
    /// </returns>
    protected container calcForward(FromDate                    _fromDate,
                                    boolean                     _createOnlyOneRecord,
                                    WorkCalendarSched           _workCalendarSched,
                                    CalendarId                  _shippingCalendarId,
                                    CustVendTransportCalendarId _transportCalendarId,
                                    CustVendTransportDays       _transportDays,
                                    LeadTime                    _salesLeadTimeCalc)
    {
        SalesReceiptDateAvailable   availableReceiptDate;

        // calculate first available shipping date forward from planed shipping date (open for shipping and pickup)
        SalesShippingDateAvailable availableShippingDate = this.scheduleDateInShippingAndTransportCalendar(_workCalendarSched,
                                                                                                           SchedDirection::Forward,
                                                                                        _fromDate,
                                                                                        _createOnlyOneRecord ? (this.parmAcceptWarnings() ? 0 : _salesLeadTimeCalc) : 0,
                                                                                        false,
                                                                                        _shippingCalendarId,
                                                                                        _transportCalendarId,
                                                                                        SalesCheckForPickup::SecondCalendar);

        if (availableShippingDate)
        {
            // calculate first posible receipt date at the customer (transport and receipt calendar doesn't have to be open at the same time))
            availableReceiptDate = this.scheduleDateInShippingAndTransportCalendar(_workCalendarSched,
                                                                                    SchedDirection::Forward,
                                                                availableShippingDate,
                                                                _transportDays,
                                                                true,
                                                                _transportCalendarId);

            if (availableReceiptDate)
            {
                // Calculate first open date at the customer
                availableReceiptDate = this.scheduleDateInReceiptCalendar(_workCalendarSched,
                                                                            SchedDirection::Forward,
                                                                    availableReceiptDate,
                                                                    0,
                                                                            true);

                if (availableReceiptDate)
                {
                    // Move shipping date closer to calculated receipt date
                    availableShippingDate = this.scheduleDateInShippingAndTransportCalendar(_workCalendarSched,
                                                                                            SchedDirection::Backward,
                                                                         availableReceiptDate,
                                                                         _transportDays,
                                                                         true,
                                                                         _transportCalendarId,
                                                                         _shippingCalendarId,
                                                                         SalesCheckForPickup::PrimaryCalendar);
                }
            }
        }

        if ( !salesAvailableDlvDatesTmp && (availableShippingDate == dateNull() || availableReceiptDate == dateNull()) )
        {
            throw error("@SYS89972");
        }

        return [availableShippingDate,availableReceiptDate];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcReceiptDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the receipt date based on the entered shipping date
    /// </summary>
    /// <param name="_pushShipDateCloser">
    ///    A Boolean value that indicates whether the method also attempts to push shipping date closer to the
    ///    newly calculated receipt date
    /// </param>
    void calcReceiptDate(boolean _pushShipDateCloser=true)
    {
        this.setOrderEntryDeadlines(this);
        this.createPossibleShippingAndReceiptDates(true);
        this.setDates();

        if (_pushShipDateCloser)
        {
            this.initMaster(this.masterDateType() == SalesDlvDateType::ConfirmedShipping ? SalesDlvDateType::ConfirmedReceipt : SalesDlvDateType::RequestedReceipt);
            this.createPossibleShippingAndReceiptDates(true);
            this.setDates();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkConfirmedDates</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to do delivery date control on the confirmed dates.
    /// </summary>
    /// <returns>
    ///    true if it should do the delivery date control on confirmed dates; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Should always returns false in sub-classes that are related to tables that do not contain confirmed
    ///    date fields. For example, the <c>TmpSalesTable</c> and <c>TmpSalesLine</c> tables.
    /// </remarks>
    protected boolean checkConfirmedDates()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReceiptDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if the entered receipt date is valid.
    /// </summary>
    /// <param name="_checkCalendar">
    ///    A Boolean value that specifies whether it also verifies if the receipt date is an open date in both
    ///    the customer and the transport calendars.
    /// </param>
    void checkReceiptDate(boolean _checkCalendar=false)
    {
        if (this.isReceiptDateInPast())
        {
            errorText = this.errorTextHandling(strFmt("@SYS88282",date2StrUsr(this.parmReceiptDate(), DateFlags::FormatAll)),Exception::Error);
        }
        else if (_checkCalendar)
        {
            this.checkReceiptDateInCalendar();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReceiptDateInCalendar</Name>
				<Source><![CDATA[
    /// <summary>
    ///  It verifies if the receipt date is an open date in both the customer's and the transport calendars.
    /// </summary>
    void checkReceiptDateInCalendar()
    {
        if (!this.isReceiptDateOpen())
        {
            // case: Closed date at customer site
            if (this.interCompanyOrder()
                &&  deliveryDateControlMap.SkipUpdate != InterCompanySkipUpdate::No)
            {
                errorText = this.errorTextHandling(strFmt("@SYS119894",date2StrUsr(this.parmReceiptDate(), DateFlags::FormatAll), curext()),
                                                   Exception::Warning);
                //showing dialog is prohibited for IC sales order, no matter what the value of the showDialog
                //parameter is
                this.parmEnableShowDialog(false);
            }
            else
            {
                errorText = this.errorTextHandling(strFmt("@SYS88283",date2StrUsr(this.parmReceiptDate(), DateFlags::FormatAll)),Exception::Error);
                this.parmEnableShowDialog(true);
            }
        }
        else if (!this.isReceiptDateOpenInTransportCalendar())
        {
            errorText = this.errorTextHandling(strFmt("@SYS89097",date2StrUsr(this.parmReceiptDate(), DateFlags::FormatAll)),Exception::Error);
            this.parmEnableShowDialog(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkShippingDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if the entered shipping date is valid
    /// </summary>
    /// <param name="_checkCalendar">
    ///    A Boolean value that specifies whether it also verifies if the shipping date is an open date in the
    ///    shipping calendar.
    /// </param>
    /// <param name="_modifiedField">
    ///    A Boolean value that specifies whether the method is called as a response to a modified field event.
    /// </param>
    void checkShippingDate(boolean _checkCalendar = false, boolean _modifiedField = true)
    {
        if (this.isShippingDateInPast())
        {
            this.setShippingDateBeforeTodayErrorText(_modifiedField);
        }
        else if (this.isShippingDateInLeadTime())
        {
            this.setShippingDateInLeadTimeErrorText(_modifiedField);
        }
        else if (_checkCalendar)
        {
            //check also in calendar
            this.checkShippingDateInCalendar();

            if (errorText)
            {
                this.parmEnableShowDialog(true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkShippingDateInCalendar</Name>
				<Source><![CDATA[
    /// <summary>
    ///    It verifies if the proposed shipping date is an open date in the shipping calendar.
    /// </summary>
    void checkShippingDateInCalendar()
    {
        if (!this.isShippingDateOpen())
        {
            // case: Shipping date closed in company/warehouse
            if (this.interCompanyOrder()
                &&  deliveryDateControlMap.SkipUpdate != InterCompanySkipUpdate::No)
            {
                errorText = this.errorTextHandling(strFmt("@SYS119895",date2StrUsr(this.parmShippingDate(), DateFlags::FormatAll),curext()),Exception::Warning);
                //no dialog in this case
                this.parmEnableShowDialog(false);
            }
            else
            {
                errorText = this.errorTextHandling(strFmt("@SYS88288",date2StrUsr(this.parmShippingDate(),DateFlags::FormatAll)),Exception::Error);
                this.parmEnableShowDialog(true);
            }
        }
        else if (!this.isPickupDate(this.parmShippingDate()) )
        {
            errorText = this.errorTextHandling(strFmt("@SYS88289", date2StrUsr(this.parmShippingDate(), DateFlags::FormatAll)),Exception::Error);
            this.parmEnableShowDialog(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPossibleShippingAndReceiptDates</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the possible shipping and receipt dates.
    /// </summary>
    /// <param name="_createOnlyOneRecord">
    ///    A Boolean value that specifies whether to create one or more records; optional. (More records are
    ///    needed when it will be presented in the available ship and receipt dates dialog box).
    /// </param>
    public void createPossibleShippingAndReceiptDates(boolean  _createOnlyOneRecord = false)
    {
        #define.loopBreak(1000)

        CalendarId                  shippingCalendarId  = this.shippingCalendarId();
        CustVendTransportCalendarId transportCalendarId = this.transportCalendarId();

        SalesShippingDateAvailable  availableShippingDate;
        SalesReceiptDateAvailable   availableReceiptDate;

        FromDate                    fromDate;
        SchedDirection              schedDirection;
        LeadTime                    salesLeadTimeCalc;

        Counter                     i;

        salesAvailableDlvDatesTmp = null;
        salesAvailableDlvDatesTmpBestGuess.clear();
        delete_from salesAvailableDlvDatesTmp;

        if (masterDateType == SalesDlvDateType::None)
            this.initMaster();

        [fromDate, calcDays, schedDirection, salesLeadTimeCalc] = this.calculateDateAndDays(_createOnlyOneRecord);

        calcDays = min(calcDays,#loopBreak);
        WorkCalendarSched workCalendarSched = new WorkCalendarSched();

        CustVendTransportDays transportDays = this.transportDays();

        for (i = 1; i <= calcDays ; i++)
        {
            switch (schedDirection)
            {
                case SchedDirection::Forward :
                    [availableShippingDate,availableReceiptDate] = this.calcForward(fromDate,
                                                                                    _createOnlyOneRecord,
                                                                                    workCalendarSched,
                                                                                    shippingCalendarId,
                                                                                    transportCalendarId,
                                                                                    transportDays,
                                                                                    salesLeadTimeCalc);
                    break;

                case SchedDirection::Backward :
                    [availableShippingDate,availableReceiptDate] = this.calcBackward(fromDate,
                                                                                     workCalendarSched,
                                                                                     shippingCalendarId,
                                                                                     transportCalendarId,
                                                                                     transportDays);
                    break;
            }

            fromDate = availableShippingDate + (schedDirection == SchedDirection::Backward ?  - 1 : 1);

            this.initSalesAvailableDlvDatesTmp(salesAvailableDlvDatesTmp,dlvModeIdSelected,inventLocationIdSelected,inventSiteIdSelected,availableShippingDate,availableReceiptDate);
            salesAvailableDlvDatesTmp.insert();

            this.setAvailableDlvDatesBestGuess(availableShippingDate,availableReceiptDate);

            if (!_createOnlyOneRecord &&
                 i==calcDays && ((this.parmReceiptDateBestGuess()  && this.parmReceiptDateBestGuess()  > availableReceiptDate) ||
                                (this.parmShippingDateBestGuess() && this.parmShippingDateBestGuess() > availableShippingDate)))
            {
                calcDays++;
            }

            if (calcDays > #loopBreak)
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDateAndDays</Name>
				<Source><![CDATA[
    protected container calculateDateAndDays(boolean _createOnlyOneRecord = false)
    {
        #define.minRecordsInDialog(30)

        FromDate                    fromDate;
        SchedDirection              schedDirection;
        LeadTime                    salesLeadTimeCalc;

        if (_createOnlyOneRecord)
        {
            switch (masterDateType)
            {
                case SalesDlvDateType::RequestedReceipt, SalesDlvDateType::ConfirmedReceipt :
                    schedDirection = SchedDirection::Backward;
                    break;

                case SalesDlvDateType::RequestedShipping, SalesDlvDateType::ConfirmedShipping :
                    schedDirection = SchedDirection::Forward;
                    break;
            }
            fromDate       = masterDate;
            calcDays       = 1;
            salesLeadTimeCalc  = this.salesLeadTime() - max((masterDate - this.effectiveOrderDate()),0);
            salesLeadTimeCalc  = max(salesLeadTimeCalc,0);
        }
        else
        {
            schedDirection = SchedDirection::Forward;
            if (this.parmIncludeTodayInAvailableDlvDates())
            {
                fromDate   = this.shippingLocationDate();
            }
            else
            {
                fromDate   = this.effectiveOrderDate();
            }
            calcDays       = max(calcDays,#minRecordsInDialog);
            calcDays       = max(calcDays,this.salesLeadTime()+1);
        }

        return [fromDate, calcDays, schedDirection, salesLeadTimeCalc];
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryDateControlActive</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the delivery date control is active or not.
    /// </summary>
    /// <returns>
    ///    true if the delivery date control is active; otherwise, false.
    /// </returns>
    protected boolean deliveryDateControlActive()
    {
        boolean ok = true;

        if (deliveryDateControlMap.DeliveryDateControlType == SalesDeliveryDateControlType::None)
            ok = false;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryDateControlMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>SalesDeliveryDateControlMap</c> map that applies for the calculation.
    /// </summary>
    /// <returns>
    /// A <c>SalesDeliveryDateControlMap</c> map that represents different types of records.
    /// </returns>
    public SalesDeliveryDateControlMap deliveryDateControlMap()
    {
        return deliveryDateControlMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    /// in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        Args        args = new Args();

        args.name(formStr(SalesAvailableDlvDates));
        args.caller(this);

        FormRun salesAvailableDlvDates = classfactory.formRunClass(args);
        salesAvailableDlvDates.init();

        return salesAvailableDlvDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doModifiedFieldCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the date delivery check should be performed when the date delivery fields are modified.
    /// </summary>
    /// <returns>
    /// true if the check should be performed; otherwise, false.
    /// </returns>
    protected boolean doModifiedFieldCheck()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doValidateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether changes have been made to fields that influence the delivery date control.
    /// </summary>
    /// <returns>
    /// true if changes have been made to fields that influence the delivery date control; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method returns true if changes have been made to these fields. The method is called from the
    /// <see cref="M:SalesCalcAvailableDlvDates.validateWritePrompt" /> to determine whether to perform the
    /// validation or delivery date control.
    /// </remarks>
    protected abstract boolean doValidateWrite()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>effectiveOrderDate</Name>
				<Source><![CDATA[
    public TransDate effectiveOrderDate()
    {
        if (!effectiveOrderDate)
        {
            effectiveOrderDate = InventOrderEntryDeadlineTable::effectiveOrderDate(inventSiteIdSelected,orderEntryDeadlineGroupId);
        }
        return effectiveOrderDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorTextHandling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements logic for adding error messages.
    /// </summary>
    /// <param name="_errorText">
    /// A string value that holds the error message.
    /// </param>
    /// <param name="_exception">
    /// An enumeration value of type <c>Exception</c> that holds the exception type.
    /// </param>
    /// <param name="_writeToInInfolog">
    /// A Boolean value that indicates whether the error message should be added to the <c>infolog</c>
    /// object.
    /// </param>
    /// <returns>
    /// A string value that holds all error messages.
    /// </returns>
    public SalesCreateReleaseOrderLog errorTextHandling(
        SalesCreateReleaseOrderLog _errorText,
        Exception                  _exception,
        boolean                    _writeToInInfolog = true)
    {
        SalesCreateReleaseOrderLog txt = this.parmErrorText();

        if (_exception > this.parmErrorTextType())
            this.parmErrorTextType(_exception);

        if (!infologLineStart)
        {
            infologLineStart = infologLine() + 1;
        }

        txt += this.parmErrorText() ? '\n\n' : '';
        txt += _errorText;

        if (_errorText && _writeToInInfolog && this.showErrorText())
        {
            this.errorTextInfolog(_errorText, _exception);
        }

        this.parmErrorText(txt);

        return txt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorTextInfolog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds an error message to the info log.
    /// </summary>
    /// <param name="_errorText">A string value that holds the error message.</param>
    /// <param name="_exception">An enumeration value of type <c>Exception</c> that holds the exception type.</param>
    protected void errorTextInfolog(
        SalesCreateReleaseOrderLog _errorText,
        Exception                  _exception)
    {
        switch (_exception)
        {
            case Exception::Info :
                info(_errorText);
                break;
            case Exception::Warning :
                warning(_errorText);
                break;
            case Exception::Error :
                error(_errorText);
                break;
            default :
                info(_errorText);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showErrorText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an error text should be shown.
    /// </summary>
    /// <returns>true if the error text should be shown; otherwise false.</returns>
    protected boolean showErrorText()
    {
        return this.parmShowDialog();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldId2DlvDateType</Name>
				<Source><![CDATA[
    abstract protected SalesDlvDateType fieldId2DlvDateType(FieldId _fieldId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the item ID for the record to calculate delivery date for.
    /// </summary>
    /// <returns>
    /// An ItemId.
    /// </returns>
    protected ItemId getItemId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMaster</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Instantiates which date and date type to use for delivery date calculation.
    /// </summary>
    /// <param name="_masterDateType">
    ///    The calling codes requested date type; optional.
    /// </param>
    /// <remarks>
    ///    The master date is the date that is used as starting point for the delivery date control
    ///    calculation. There are four types of master dates:
    ///    <list type="bullet">
    ///       <item>
    ///          <description>Confirmed receipt dates</description>
    ///       </item>
    ///       <item>
    ///          <description>Confirmed ship date</description>
    ///       </item>
    ///       <item>
    ///          <description>Requested receipt date</description>
    ///       </item>
    ///       <item>
    ///          <description>Confirmed receipt date</description>
    ///       </item>
    ///    </list>
    ///     The type can be determined either by the <paramref name="_masterDateType " />
    ///     parameter or by the content of the four date fields. If the type is being determined by the
    ///    content of the date field, the four date fields is prioritized in the order shown in the list
    ///    earlier in this section. This means that if all four date fields are entered, for example, the type
    ///    of the master date would be the confirmed receipt date, and then the confirmed receipt date will be
    ///    the starting point for the delivery date control calculation.If none of the date fields are
    ///    entered, the type would be the requested ship date and the master date would be set as equal to the
    ///    effective order date, plus the sales lead.
    /// </remarks>
    protected void initMaster(SalesDlvDateType _masterDateType = SalesDlvDateType::None)
    {
        switch (_masterDateType)
        {
            case SalesDlvDateType::RequestedReceipt :
                masterDateType = SalesDlvDateType::RequestedReceipt;
                masterDate     = deliveryDateControlMap.ReceiptDateRequested;
                break;

            case SalesDlvDateType::RequestedShipping :
                masterDateType = SalesDlvDateType::RequestedShipping;
                masterDate     = deliveryDateControlMap.ShippingDateRequested;
                break;

            case SalesDlvDateType::ConfirmedShipping :
                if (this.checkConfirmedDates())
                {
                    masterDateType = SalesDlvDateType::ConfirmedShipping;
                    masterDate     = deliveryDateControlMap.ShippingDateConfirmed;
                }
                break;

            case SalesDlvDateType::ConfirmedReceipt :
                if (this.checkConfirmedDates())
                {
                    masterDateType = SalesDlvDateType::ConfirmedReceipt;
                    masterDate     = deliveryDateControlMap.ReceiptDateConfirmed;
                }
                break;

            case SalesDlvDateType::None :

                if (this.parmRecalculateShippingDate())
                {
                    masterDateType = SalesDlvDateType::RequestedShipping;
                    masterDate     = this.effectiveOrderDate() + this.salesLeadTime();
                }
                else if (this.checkConfirmedDates() && deliveryDateControlMap.ReceiptDateConfirmed)
                {
                    masterDateType = SalesDlvDateType::ConfirmedReceipt;
                    masterDate     = deliveryDateControlMap.ReceiptDateConfirmed;
                }
                else if (this.checkConfirmedDates() && deliveryDateControlMap.ShippingDateConfirmed)
                {
                    masterDateType = SalesDlvDateType::ConfirmedShipping;
                    masterDate     = deliveryDateControlMap.ShippingDateConfirmed;
                }
                else if (deliveryDateControlMap.ReceiptDateRequested)
                {
                    masterDateType = SalesDlvDateType::RequestedReceipt;
                    masterDate     = deliveryDateControlMap.ReceiptDateRequested;
                }
                else if (deliveryDateControlMap.ShippingDateRequested)
                {
                    masterDateType = SalesDlvDateType::RequestedShipping;
                    masterDate     = deliveryDateControlMap.ShippingDateRequested;
                }
                else
                {
                    masterDateType = SalesDlvDateType::RequestedShipping;
                    masterDate     = this.effectiveOrderDate() + this.salesLeadTime();
                }
                break;

            default :
                break;
        }

        if (masterDateType == SalesDlvDateType::RequestedReceipt || masterDateType == SalesDlvDateType::ConfirmedReceipt)
            this.parmReceiptDateBestGuess(masterDate);
        else
            this.parmShippingDateBestGuess(masterDate);

        if (this.isMasterDateTypeConfirmed())
        {
            showTransferToRequestedButton = false;
            showTransferToConfirmedButton = true;
        }
        else
        {
            showTransferToRequestedButton = true;
            showTransferToConfirmedButton = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initReqSetupDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Create a <c>ReqSetupDim</c> for a given item with given inventory dimensions.
    /// </summary>
    /// <param name="_itemId">
    ///    The item for which issue margin will be found.
    /// </param>
    /// <param name="_inventDim">
    ///    The inventory dimensions that are used to find issue margin.
    /// </param>
    /// <param name="_deliverDateControlType">
    ///    The delivery date control type to find dates for.
    /// </param>
    protected void initReqSetupDim(ItemId _itemId, InventDim _inventDim, SalesDeliveryDateControlType _deliverDateControlType)
    {
        if (!reqSetupDim
            && (_deliverDateControlType == SalesDeliveryDateControlType::ATP
            || _deliverDateControlType == SalesDeliveryDateControlType::ATPPlusIssueMargin
            || MpsDeliveryDateControlTypeCTPHelper::isDeliveryDateControlTypeClassicCTP(_deliverDateControlType)))
        {
            reqSetupDim = ReqSetupDim::newInventTable(InventTable::find(_itemId),_inventDim.InventDimId,_inventDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSalesAvailableDlvDatesTmp</Name>
				<Source><![CDATA[
    protected void initSalesAvailableDlvDatesTmp(SalesAvailableDlvDatesTmp  _salesAvailableDlvDatesTmp,
                                                 DlvModeId                  _dlvModeIdSelected,
                                                 InventLocationId           _inventLocationIdSelected,
                                                 InventSiteId               _inventSiteIdSelected,
                                                 SalesShippingDateAvailable _availableShippingDate,
                                                 SalesReceiptDateAvailable  _availableReceiptDate)
    {
        _salesAvailableDlvDatesTmp.clear();
        _salesAvailableDlvDatesTmp.initValue();
        _salesAvailableDlvDatesTmp.DlvModeId             = _dlvModeIdSelected;
        _salesAvailableDlvDatesTmp.InventLocationId      = _inventLocationIdSelected;
        _salesAvailableDlvDatesTmp.InventSiteId          = _inventSiteIdSelected;
        _salesAvailableDlvDatesTmp.AvailableShippingDate = _availableShippingDate;
        _salesAvailableDlvDatesTmp.AvailableReceiptDate  = _availableReceiptDate;
        _salesAvailableDlvDatesTmp.InLeadtime            = (this.salesLeadTime() + this.effectiveOrderDate()) > _availableShippingDate ? 1 : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyDerivedOrder</Name>
				<Source><![CDATA[
    public boolean interCompanyDerivedOrder()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyDirectDeliveryOrig</Name>
				<Source><![CDATA[
    public boolean interCompanyDirectDeliveryOrig()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyOrder</Name>
				<Source><![CDATA[
    public boolean interCompanyOrder()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimIdUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Modifications are made to dimensions, such as warehouse on sales order lines where all the
    ///    dimension fields are positioned in the related table <see cref="T:InventDim" />.
    /// </summary>
    /// <param name="_inventDim">
    ///    The <see cref="T:InventDim" /> record that contain fields that have been modified.
    /// </param>
    /// <remarks>
    ///    The reason why people use this method is that the key <c>InventDimId</c> field on the parent table
    ///    that links to the <c>InventDim</c> record has not been updated at the time when the delivery date
    ///    control is occurring. Therefore, the method is used to get the new value of the dimension field
    ///    from the related <c>InventDim</c> table.
    /// </remarks>
    protected void inventDimIdUpdate(InventDim _inventDim)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMasterDateTypeConfirmed</Name>
				<Source><![CDATA[
    protected boolean isMasterDateTypeConfirmed()
    {
        return (masterDateType == SalesDlvDateType::ConfirmedReceipt || masterDateType == SalesDlvDateType::ConfirmedShipping);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPickupDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether <paramref name="_transDate" /> is a pickup date.
    /// </summary>
    /// <param name="_transDate">
    ///    Shipping date.
    /// </param>
    /// <returns>
    ///    Indicates if <paramref name="_transDate" /> is a pickup date.
    /// </returns>
    protected boolean isPickupDate(TransDate _transDate)
    {
        CustVendTransportCalendarSetup transportCalendarSetup = CustVendTransportCalendarSetup::find(this.parmDlvMode(),inventLocationIdTransportShipping);
        if (!transportCalendarSetup)
            transportCalendarSetup = CustVendTransportCalendarSetup::find(this.parmDlvMode(),'');

        if (!transportCalendarSetup)
            return true;

        if (!transportCalendarSetup.Calendar)
            return true;

        return WorkCalendarDate::isPickupDate(transportCalendarSetup.Calendar,_transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReceiptDateInPast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the receipt date is in the past
    /// </summary>
    /// <returns>
    ///    true if the receipt date is in the past; otherwise, false.
    /// </returns>
    boolean isReceiptDateInPast()
    {
        if (this.parmReceiptDate() < this.effectiveOrderDate() )
        {
            if (this.parmReceiptDate() < this.shippingLocationDate() || !this.parmIncludeTodayInAvailableDlvDates())
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReceiptDateOpen</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the receipt date is open in the customer's calendar.
    /// </summary>
    /// <returns>
    ///    true if receipt date is open; otherwise, false.
    /// </returns>
    public boolean isReceiptDateOpen()
    {
        return WorkCalendarDate::isDateOpen(this.receiptCalendarId(),this.parmReceiptDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReceiptDateOpenInTransportCalendar</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the receipt date is open in the transport's calendar.
    /// </summary>
    /// <returns>
    ///    true if receipt date is open; otherwise, false.
    /// </returns>
    protected boolean isReceiptDateOpenInTransportCalendar()
    {
        return WorkCalendarDate::isDateOpen(this.transportCalendarId(),this.parmReceiptDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isShippingDateOpen</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the shipping date is open in the shipping's calendar.
    /// </summary>
    /// <returns>
    ///    true if receipt date is open; otherwise, false.
    /// </returns>
    protected boolean isShippingDateOpen()
    {
        return WorkCalendarDate::isDateOpen(this.shippingCalendarId(),this.parmShippingDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isShippingDateInLeadTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the shipping date is in the order lead time.
    /// </summary>
    /// <returns>
    ///    true if the shipping date is in the order lead time; otherwise false.
    /// </returns>
    boolean isShippingDateInLeadTime()
    {
        TransDate localShippingDate = this.parmShippingDate();
        TransDate localEffectiveOrderDate = this.effectiveOrderDate();
        if (localShippingDate >= localEffectiveOrderDate &&
            localShippingDate < (localEffectiveOrderDate + this.salesLeadTime()))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isShippingDateInPast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the shipping date is in the past
    /// </summary>
    /// <returns>
    ///    true if the shipping date is in the past; otherwise, false.
    /// </returns>
    boolean isShippingDateInPast()
    {
        if (this.parmShippingDate() < this.effectiveOrderDate())
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastConfirmation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the last confirmation date and confirmation ID.
    /// </summary>
    /// <returns>
    /// A <c>container</c> that holds the latest confirmation date and the latest confirmation ID.
    /// </returns>
    public container lastConfirmation()
    {
        return [dateNull(),''];
    }

]]></Source>
			</Method>
			<Method>
				<Name>leadTimeFromCTP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the lead time based on a capable to promise calculation.
    /// </summary>
    /// <param name="_inventTransOriginId">
    /// An integer value that holds the inventory transaction originator <c>RecId</c> value.
    /// </param>
    /// <returns>
    /// An integer value that represents the lead time in days.
    /// </returns>
    protected Days leadTimeFromCTP(
        InventTransOriginId  _inventTransOriginId)
    {
        ReqTrans                    reqTrans;
        TransDate                   requestedOrDelayedShipDate;

        if (_inventTransOriginId)
        {
            RefRecId reqPlanVersionRefRecId = ReqPlanVersion::findActiveReqPlanIdDynamic().RecId;

            if (reqPlanVersionRefRecId)
            {
                select maxof(FuturesDate) from reqTrans
                    where reqTrans.PlanVersion       == reqPlanVersionRefRecId
                       && reqTrans.InventTransOrigin == _inventTransOriginId;

                requestedOrDelayedShipDate = reqTrans.FuturesDate;
            }
        }

        if (requestedOrDelayedShipDate)
        {
            return max(requestedOrDelayedShipDate - this.effectiveOrderDate(),0);
        }

        return #notFoundLeadTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>leadTimeFromMarking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the lead time based on marked transactions.
    /// </summary>
    /// <param name="_inventTransOriginId">
    /// An integer value that holds the inventory transaction originator <c>RecId</c> value.
    /// </param>
    /// <returns>
    /// An integer value that represents the lead time in days.
    /// </returns>
    protected Days leadTimeFromMarking(InventTransOriginId  _inventTransOriginId)
    {
        InventTrans     inventTransReceipt;
        InventTrans     inventTransIssue;

        select maxof(DateStatus) from inventTransReceipt
            where inventTransReceipt.MarkingRefInventTransOrigin == _inventTransOriginId
            exists join inventTransIssue
                where inventTransIssue.InventTransOrigin            == _inventTransOriginId
                &&    inventTransIssue.MarkingRefInventTransOrigin  == inventTransReceipt.InventTransOrigin;

        if (inventTransReceipt.DateStatus)
        {
            return max(inventTransReceipt.DateStatus - this.effectiveOrderDate(),0);
        }

        return #notFoundLeadTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>marginIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds issue margin for a given item with given inventory dimensions.
    /// </summary>
    /// <param name="_itemId">
    ///    The item for which issue margin will be found.
    /// </param>
    /// <param name="_inventDim">
    ///    The inventory dimensions that are used to find issue margin.
    /// </param>
    /// <returns>
    ///    Issue margin value.
    /// </returns>
    /// <remarks>
    ///    If coverage group is defined for the item, issue margin for this coverage group is returned.
    ///    Otherwise, issue margin for default coverage group in Master Planning parameters is returned.
    /// </remarks>
    public MarginIssue marginIssue(ItemId _itemId, InventDim _inventDim)
    {
        MarginIssue marginIssue;

        if (reqSetupDim)
        {
            marginIssue = reqSetupDim.marginIssue();
        }
        return marginIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>masterDateType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the type of the master date.
    /// </summary>
    /// <returns>
    ///    Returns the type of the master date.
    /// </returns>
    protected SalesDlvDateType masterDateType()
    {
        return masterDateType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Recalculates delivery dates when a field having impact on delivery dates is changed and enhanced
    ///    delivery date control is enabled.
    /// </summary>
    /// <param name="_record">
    ///    The record upon which delivery dates are recalculated.
    /// </param>
    /// <param name="_showDialog">
    ///    A Boolean value that specifies whether a dialog box should be displayed upon irresolvable conflicts.
    /// </param>
    /// <param name="_acceptWarnings">
    ///    A Boolean value that specifies whether warning messages are considered as acceptable.
    /// </param>
    /// <param name="_checkOnly">
    ///    A Boolean value that specifies whether delivery date control should only check the entered delivery
    ///    dates and not recalculate them with conflicts.
    /// </param>
    void modifiedField(Common _record, boolean _showDialog = true, boolean _acceptWarnings = false, boolean _checkOnly = false)
    {
        if (! this.doModifiedFieldCheck())
        {
            return;
        }

        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesCalcAvailableDlvDatesActivities().modifiedField())
        {
            this.preUpdateBuffer();

            this.parmShowDialog(_showDialog);
            this.parmAcceptWarnings(_acceptWarnings);
            this.parmCheckOnly(_checkOnly);

            this.parmIncludeTodayInAvailableDlvDates(true);
            this.parmShowDisableDlvDateControlButton(true);

            if (this.deliveryDateControlActive())
            {
                switch (this.masterDateType())
                {
                    case SalesDlvDateType::RequestedReceipt :
                    case SalesDlvDateType::ConfirmedReceipt :
                        if (this.parmReceiptDate())
                        {
                            using (var nestedActivityContext = this.instrumentationLogger().salesCalcAvailableDlvDatesActivities().modifiedFieldCheckReceiptDate())
                            {
                                this.checkReceiptDate(true);
                            }

                            if (!errorText)
                            {
                                //calculate shipping date
                                this.createPossibleShippingAndReceiptDates(true);
                                this.setDates();

                                using (var nestedActivityContext = this.instrumentationLogger().salesCalcAvailableDlvDatesActivities().modifiedFieldCheckShippingDate())
                                {
                                    //check calculated shipping date
                                    this.checkShippingDate();
                                }
                            }

                            if (errorText && this.parmShowDialog())
                            {
                                this.showAvailableDlvDatesDialog(errorText);
                            }
                        }
                        break;

                    case SalesDlvDateType::RequestedShipping :
                    case SalesDlvDateType::ConfirmedShipping :

                        if (this.parmShippingDate())
                        {
                            using (var nestedActivityContext = this.instrumentationLogger().salesCalcAvailableDlvDatesActivities().modifiedFieldCheckShippingDate())
                            {
                                //check shipping date also in calendar
                                this.checkShippingDate(true);
                            }

                            if (errorText && this.parmShowDialog())
                            {
                                this.showAvailableDlvDatesDialog(errorText);
                            }
                            else
                            {
                                if (!this.parmCheckOnly() && (!errorText ||
                                   (errorText && this.parmAcceptWarnings() && this.parmErrorTextType() <= Exception::Warning)))
                                {
                                    using (var nestedActivityContext = this.instrumentationLogger().salesCalcAvailableDlvDatesActivities().modifiedFieldCalcReceiptDate())
                                    {
                                        this.calcReceiptDate();
                                    }
                                }
                            }
                        }
                }

                activityContext
                    .addCustomProperty('HasErrorText', any2Str(errorText != ''))
                    .addCustomProperty('ShowDialog', any2Str(showDialog));
            }

            this.updateCaller(_record, this.parmDisableDeliveryDateControl());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedFieldBeforeInsert</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Recalculates delivery dates when a field having impact on delivery dates is changed on a record
    ///    that is not yet saved. It can also be applied on already saved records but it works in silent mode.
    ///    This means that it never displays error messages and never offers user to resolve conflicts
    ///    manually by using the dialog box, but recalculates delivery dates as from today for irresolvable
    ///    conflicts.
    /// </summary>
    /// <param name="_record">
    ///    The record upon which delivery dates are recalculated.
    /// </param>
    /// <param name="_acceptwarnings">
    ///    A Boolean value that specifies whether warnings are acceptable.
    /// </param>
    void modifiedFieldBeforeInsert(Common _record, boolean _acceptwarnings = false)
    {
        // Delay recalculations for scenarios where not all product dimensions are known and 
        // product variant level conversions are being used.
        if (!this.validateAllUnitConversionInfoRequired())
        {
            return;
        }

        this.parmAcceptWarnings(_acceptwarnings);
        //never show dialog
        this.parmShowDialog(false);

        if (this.deliveryDateControlActive())
        {
            switch (this.masterDateType())
            {
                case SalesDlvDateType::RequestedReceipt :
                case SalesDlvDateType::ConfirmedReceipt :

                    if (!this.isReceiptDateInPast())
                    {
                        if (!this.isReceiptDateOpen())
                        {
                            this.pushBackReceiptDateToFirstOpenDate();

                            if (this.isReceiptDateInPast())
                            {
                                this.calcDatesFromUTCNow();
                                this.updateCaller(_record,this.parmDisableDeliveryDateControl());
                                return;
                            }

                            //NOTE: no need to test again here for receipt date being open
                        }

                        //calculate shipping date
                        this.createPossibleShippingAndReceiptDates(true);
                        this.setDates();

                        if (this.isShippingDateInPast() || this.isShippingDateInLeadTime())
                        {
                            this.calcDatesFromUTCNow();
                        }
                    }
                    else
                    {
                        this.calcDatesFromUTCNow();
                    }
            }
        }

        this.updateCaller(_record, this.parmDisableDeliveryDateControl());
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container salesAvailableDlvDatesTmp_Container;

        while select salesAvailableDlvDatesTmp
        {
            salesAvailableDlvDatesTmp_Container += [[salesAvailableDlvDatesTmp.DlvModeId,
                                                    salesAvailableDlvDatesTmp.InventLocationId,
                                                    salesAvailableDlvDatesTmp.InventSiteId,
                                                    salesAvailableDlvDatesTmp.AvailableShippingDate,
                                                    salesAvailableDlvDatesTmp.AvailableReceiptDate]];
        }

        return [#CurrentVersion,#CurrentList,salesAvailableDlvDatesTmp_Container];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAcceptWarnings</Name>
				<Source><![CDATA[
    public boolean parmAcceptWarnings(boolean _acceptWarnings = acceptWarnings)
    {
        acceptWarnings = _acceptWarnings;
        return acceptWarnings;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCalcDays</Name>
				<Source><![CDATA[
    public int parmCalcDays(int _calcDays = calcDays)
    {
        calcDays = _calcDays;
        return calcDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCancelModifiedField</Name>
				<Source><![CDATA[
    boolean parmCancelModifiedField(boolean _cancelModifiedField = cancelModifiedField)
    {
        cancelModifiedField = _cancelModifiedField;
        return cancelModifiedField;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckOnly</Name>
				<Source><![CDATA[
    public boolean parmCheckOnly(boolean _checkOnly = checkOnly)
    {
        checkOnly = _checkOnly;
        return checkOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDeliveryDateControlType</Name>
				<Source><![CDATA[
    public SalesDeliveryDateControlType parmDeliveryDateControlType(SalesDeliveryDateControlType _deliveryDateControlType = isTempDeliveryDateControlType ? salesDeliveryDateControlType : deliveryDateControlMap.DeliveryDateControlType)
    {
        SalesDeliveryDateControlType    localDeliveryDateControlType;

        if (isTempDeliveryDateControlType)
        {
            if (_deliveryDateControlType != salesDeliveryDateControlType)
            {
                salesLeadTimeFound = false;
            }

            salesDeliveryDateControlType = _deliveryDateControlType;
            localDeliveryDateControlType = salesDeliveryDateControlType;
        }
        else
        {
            if (_deliveryDateControlType != deliveryDateControlMap.DeliveryDateControlType)
            {
                salesLeadTimeFound = false;
            }

            deliveryDateControlMap.DeliveryDateControlType = _deliveryDateControlType;
            localDeliveryDateControlType                   = deliveryDateControlMap.DeliveryDateControlType;
        }
        if (!prmisDefault(_deliveryDateControlType) && !reqSetupDim && this.getItemId())
        {
            this.initReqSetupDim(this.getItemId(), InventDim::find(this.parmInventDimId()), localDeliveryDateControlType);
        }

        return localDeliveryDateControlType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDisableDeliveryDateControl</Name>
				<Source><![CDATA[
    public boolean parmDisableDeliveryDateControl(boolean _disableDlvDateControl = disableDlvDateControl)
    {
        disableDlvDateControl = _disableDlvDateControl;
        return disableDlvDateControl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDlvMode</Name>
				<Source><![CDATA[
    protected DlvModeId parmDlvMode(DlvModeId _dlvMode = deliveryDateControlMap.DlvMode)
    {
        deliveryDateControlMap.DlvMode = _dlvMode;
        return deliveryDateControlMap.DlvMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDlvModeIdSelected</Name>
				<Source><![CDATA[
    public DlvModeId parmDlvModeIdSelected(DlvModeId _dlvModeId = dlvModeIdSelected)
    {
        dlvModeIdSelected = _dlvModeId;
        return dlvModeIdSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEnableShowDialog</Name>
				<Source><![CDATA[
    public boolean parmEnableShowDialog(boolean _enableShowDialog = enableShowDialog)
    {
        enableShowDialog = _enableShowDialog;
        return enableShowDialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmErrorText</Name>
				<Source><![CDATA[
    public SalesCreateReleaseOrderLog parmErrorText(SalesCreateReleaseOrderLog _errorText = errorText)
    {
        errorText = _errorText;
        return errorText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmErrorTextType</Name>
				<Source><![CDATA[
    public Exception parmErrorTextType(Exception _errorTextType = errorTextType)
    {
        errorTextType = _errorTextType;
        return errorTextType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmErrorTreeCtrl</Name>
				<Source><![CDATA[
    public FormTreeControl parmErrorTreeCtrl(FormTreeControl _errorTreeCtrl = errorTreeCtrl)
    {
        errorTreeCtrl = _errorTreeCtrl;
        return errorTreeCtrl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmForceCalcToUseMarking</Name>
				<Source><![CDATA[
    public boolean parmForceCalcToUseMarking(boolean _forceCalcToUseMarking = forceCalcToUseMarking)
    {
        forceCalcToUseMarking = _forceCalcToUseMarking;

        return forceCalcToUseMarking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeTodayInAvailableDlvDates</Name>
				<Source><![CDATA[
    public boolean parmIncludeTodayInAvailableDlvDates(boolean _includeTodayInAvailableDlvDates = includeTodayInAvailableDlvDates)
    {
        includeTodayInAvailableDlvDates = _includeTodayInAvailableDlvDates;

        return includeTodayInAvailableDlvDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInfologLineStart</Name>
				<Source><![CDATA[
    public int parmInfologLineStart(int _infologLineStart = infologLineStart)
    {
        infologLineStart = _infologLineStart;

        return infologLineStart;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimId</Name>
				<Source><![CDATA[
    public InventDimId parmInventDimId(InventDimId _inventDimId = inventDimId)
    {
        inventDimId = _inventDimId;
        return inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventLocationId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>InventLocationId</c> parameter.
    /// </summary>
    /// <param name="_inventLocationId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>InventLocationId</c> parameter.
    /// </returns>
    protected abstract InventLocationId parmInventLocationId(InventLocationId  _inventLocationId = '')
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventLocationIdSelected</Name>
				<Source><![CDATA[
    public InventLocationId parmInventLocationIdSelected(InventLocationId _inventLocationId = inventLocationIdSelected)
    {
        if (_inventLocationId != inventLocationIdSelected)
        {
            salesLeadTimeFound = false;

            InventDim inventDim = InventDim::find(this.parmInventDimId());
            inventDim.InventLocationId = _inventLocationId;
            this.parmInventDimId(inventDim::findOrCreate(inventDim).inventDimId);
        }

        inventLocationIdSelected = _inventLocationId;
        return inventLocationIdSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventLocationTransportShipping</Name>
				<Source><![CDATA[
    public InventLocationId parmInventLocationTransportShipping(InventLocationId _inventLocationId = inventLocationIdTransportShipping)
    {
        if (!_inventLocationId && inventSiteIdSelected)
        {
            inventLocationIdTransportShipping = InventFallbackWarehouse::find(inventSiteIdSelected).InventLocationId;
        }
        else
        {
            inventLocationIdTransportShipping = _inventLocationId;
        }
        return inventLocationIdTransportShipping;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventSiteId</Name>
				<Source><![CDATA[
    protected abstract InventSiteId parmInventSiteId(InventSiteId  _inventSiteId = '')
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventSiteIdSelected</Name>
				<Source><![CDATA[
    public InventSiteId parmInventSiteIdSelected(InventSiteId _inventSiteId = inventSiteIdSelected)
    {
        if (_inventSiteId != inventSiteIdSelected)
        {
            salesLeadTimeFound = false;

            InventDim inventDim = InventDim::find(this.parmInventDimId());
            inventDim.InventSiteId = _inventSiteId;
            this.parmInventDimId(inventDim::findOrCreate(inventDim).inventDimId);
        }

        inventSiteIdSelected = _inventSiteId;
        return inventSiteIdSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOrderEntryDeadlineGroupId</Name>
				<Source><![CDATA[
    public InventOrderEntryDeadlineGroupId parmOrderEntryDeadlineGroupId(InventOrderEntryDeadlineGroupId _orderEntryDeadlineGroupId = orderEntryDeadlineGroupId)
    {
        orderEntryDeadlineGroupId = _orderEntryDeadlineGroupId;

        return orderEntryDeadlineGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOrderEntryDeadlineSite</Name>
				<Source><![CDATA[
    public SalesOrderEntryDeadlineSite parmOrderEntryDeadlineSite(SalesOrderEntryDeadlineSite _orderEntryDeadlineSite = orderEntryDeadlineSite)
    {
        orderEntryDeadlineSite = _orderEntryDeadlineSite;

        return orderEntryDeadlineSite;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOrderEntryDeadlineUser</Name>
				<Source><![CDATA[
    public SalesOrderEntryDeadlineUser parmOrderEntryDeadlineUser(SalesOrderEntryDeadlineUser _orderEntryDeadlineUser = orderEntryDeadlineUser)
    {
        orderEntryDeadlineUser = _orderEntryDeadlineUser;

        return orderEntryDeadlineUser;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPriceDisc</Name>
				<Source><![CDATA[
    protected PriceDisc_Price parmPriceDisc(PriceDisc_Price _priceDisc = priceDisc)
    {
        priceDisc = _priceDisc;
        return priceDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRecalculateShippingDate</Name>
				<Source><![CDATA[
    public boolean parmRecalculateShippingDate(boolean _recalculateShippingDate = recalculateShippingDate)
    {
        recalculateShippingDate = _recalculateShippingDate;
        return recalculateShippingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReceiptDate</Name>
				<Source><![CDATA[
    protected TransDate parmReceiptDate(TransDate _transDate = dateNull())
    {
        if (prmisDefault(_transDate))
        {
            if (this.isMasterDateTypeConfirmed())
            {
                return deliveryDateControlMap.ReceiptDateConfirmed;
            }
            else
            {
                return deliveryDateControlMap.ReceiptDateRequested;
            }
        }
        else
        {
            if (this.isMasterDateTypeConfirmed())
            {
                deliveryDateControlMap.ReceiptDateConfirmed = _transDate;
                return deliveryDateControlMap.ReceiptDateConfirmed;
            }
            else
            {
                deliveryDateControlMap.ReceiptDateRequested = _transDate;
                return deliveryDateControlMap.ReceiptDateRequested;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReceiptDateAvailableSelected</Name>
				<Source><![CDATA[
    public SalesReceiptDateAvailable parmReceiptDateAvailableSelected(SalesReceiptDateAvailable _receiptDateAvailableSelected = receiptDateAvailableSelected)
    {
        receiptDateAvailableSelected = _receiptDateAvailableSelected;
        return receiptDateAvailableSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReceiptDateBestGuess</Name>
				<Source><![CDATA[
    public TransDate parmReceiptDateBestGuess(TransDate _receiptDateBestGuess = receiptDateBestGuess)
    {
        receiptDateBestGuess = _receiptDateBestGuess;
        return receiptDateBestGuess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReturnConfirmedDates</Name>
				<Source><![CDATA[
    public NoYesId parmReturnConfirmedDates(NoYesId _returnConfirmedDates = returnConfirmedDates)
    {
        returnConfirmedDates = _returnConfirmedDates;
        return returnConfirmedDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesAvailableDlvDatesTmp</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the <c>SalesAvailableDlvDatesTmp</c> parameter.
    /// </summary>
    /// <returns>
    ///    The value of the <c>SalesAvailableDlvDatesTmp</c> parameter.
    /// </returns>
    /// <remarks>
    ///    The TmpSalesAvailableDIvDates variable represents the results of the calculation finding several
    ///    available receipt and shipping dates.
    /// </remarks>
    public SalesAvailableDlvDatesTmp parmSalesAvailableDlvDatesTmp()
    {
        return salesAvailableDlvDatesTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesAvailableDlvDatesTmpBestGuess</Name>
				<Source><![CDATA[
    public SalesAvailableDlvDatesTmp parmSalesAvailableDlvDatesTmpBestGuess()
    {
        return salesAvailableDlvDatesTmpBestGuess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShippingDate</Name>
				<Source><![CDATA[
    protected TransDate parmShippingDate(TransDate _transDate = dateNull())
    {
        if (prmisDefault(_transDate))
        {
            if (this.isMasterDateTypeConfirmed())
                return deliveryDateControlMap.ShippingDateConfirmed;
            else
                return deliveryDateControlMap.ShippingDateRequested;
        }
        else
        {
            if (this.isMasterDateTypeConfirmed())
            {
                deliveryDateControlMap.ShippingDateConfirmed = _transDate;
                return deliveryDateControlMap.ShippingDateConfirmed;
            }
            else
            {
                deliveryDateControlMap.ShippingDateRequested = _transDate;
                return deliveryDateControlMap.ShippingDateRequested;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShippingDateAvailableSelected</Name>
				<Source><![CDATA[
    public SalesShippingDateAvailable parmShippingDateAvailableSelected(SalesShippingDateAvailable _shippingDateAvailableSelected = shippingDateAvailableSelected)
    {
        shippingDateAvailableSelected = _shippingDateAvailableSelected;
        return shippingDateAvailableSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShippingDateBestGuess</Name>
				<Source><![CDATA[
    public TransDate parmShippingDateBestGuess(TransDate _shippingDateBestGuess = shippingDateBestGuess)
    {
        shippingDateBestGuess = _shippingDateBestGuess;
        return shippingDateBestGuess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowActualShipDates</Name>
				<Source><![CDATA[
    public boolean parmShowActualShipDates(boolean _showActualShipDates = showActualShipDates)
    {
        showActualShipDates = _showActualShipDates;

        return showActualShipDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowConfirmation</Name>
				<Source><![CDATA[
    public boolean parmShowConfirmation(boolean _showConfirmation = showConfirmation)
    {
        showConfirmation = _showConfirmation;

        return showConfirmation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowDialog</Name>
				<Source><![CDATA[
    public boolean parmShowDialog(boolean _showDialog = showDialog)
    {
        showDialog = _showDialog;
        return showDialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowDisableDlvDateControlButton</Name>
				<Source><![CDATA[
    public boolean parmShowDisableDlvDateControlButton(boolean _showDisableDlvDateControlButton = showDisableDlvDateControlButton)
    {
        showDisableDlvDateControlButton = _showDisableDlvDateControlButton;
        return showDisableDlvDateControlButton;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowTransferToConfirmedButton</Name>
				<Source><![CDATA[
    public boolean parmShowTransferToConfirmedButton(boolean _showTransferToConfirmedButton = showTransferToConfirmedButton)
    {
        showTransferToConfirmedButton = _showTransferToConfirmedButton;
        return showTransferToConfirmedButton;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowTransferToRequestedButton</Name>
				<Source><![CDATA[
    public boolean parmShowTransferToRequestedButton(boolean _showTransferToRequestedButton = showTransferToRequestedButton)
    {
        showTransferToRequestedButton = _showTransferToRequestedButton;
        return showTransferToRequestedButton;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTempDeliveryDateControlType</Name>
				<Source><![CDATA[
    public boolean parmTempDeliveryDateControlType(boolean _isTempDeliveryDateControlType = isTempDeliveryDateControlType)
    {
        isTempDeliveryDateControlType =  _isTempDeliveryDateControlType;
        return  isTempDeliveryDateControlType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpInfoTable</Name>
				<Source><![CDATA[
    public SysInfolog parmTmpInfoTable(SysInfolog _tmpInfoTable = tmpInfoTable)
    {
        tmpInfoTable = _tmpInfoTable;
        return tmpInfoTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preUpdateBuffer</Name>
				<Source><![CDATA[
    protected void preUpdateBuffer()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>pushBackReceiptDateToFirstOpenDate</Name>
				<Source><![CDATA[
    void pushBackReceiptDateToFirstOpenDate()
    {
        WorkCalendarSched workCalendarSched = new WorkCalendarSched();

        this.parmReceiptDate(this.scheduleDateInReceiptCalendar(workCalendarSched,
                                                                SchedDirection::Backward,
                                                  this.parmReceiptDate(),   // PossibleShippingDate
                                                  0,                        // Transport days
                                                                true));                     // CalendarDays
    }

]]></Source>
			</Method>
			<Method>
				<Name>receiptCalendarId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the receipt calendar ID for the customer and returns it.
    /// </summary>
    /// <returns>
    ///    Returns the receipt calendar ID for the customer.
    /// </returns>
    protected abstract CalendarId receiptCalendarId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqSetupDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Get the value of the reqSetupDim variable
    /// </summary>
    /// <returns>
    ///    reqSetupDim variable
    /// </returns>
    public ReqSetupDim reqSetupDim()
    {
        return reqSetupDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesLeadTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the lead time based on item ID and inventory dimension for the sales quotation line.
    /// </summary>
    /// <param name="_basedOnCalendarSetup">
    /// NoYes::Yes if the lead time should consider working calendar setup; otherwise, NoYes::No.
    /// </param>
    /// <returns>
    /// The found lead time.
    /// </returns>
    public LeadTime salesLeadTime(CalendarDays _basedOnCalendarSetup = NoYes::Yes)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesCalcAvailableDlvDatesActivities().salesLeadTime())
        {
            if (!salesLeadTimeFound)
            {
                this.initializeSalesLeadTimeBasedOnDeliveryDateControlType();
            }

            return _basedOnCalendarSetup == NoYes::Yes? salesLeadTimeBasedOnCalendarSetup : salesLeadTime;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeSalesLeadTimeBasedOnDeliveryDateControlType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the sales lead time based on the delivery date control type.
    /// </summary>
    protected void initializeSalesLeadTimeBasedOnDeliveryDateControlType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAvailableDlvDatesBestGuess</Name>
				<Source><![CDATA[
    protected void setAvailableDlvDatesBestGuess(SalesShippingDateAvailable _availableShippingDate,
                                                 SalesReceiptDateAvailable  _availableReceiptDate)
    {
        if (!salesAvailableDlvDatesTmpBestGuess)
        {
            if ((this.parmReceiptDateBestGuess()  && this.parmReceiptDateBestGuess()  <= _availableReceiptDate) ||
                (this.parmShippingDateBestGuess() && this.parmShippingDateBestGuess() <= _availableShippingDate))
            {
                salesAvailableDlvDatesTmpBestGuess = salesAvailableDlvDatesTmp.data();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDates</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets, depending on the type of the master date, either the two confirmed dates or the two requested
    ///    dates.
    /// </summary>
    /// <remarks>
    ///    The per of dates will be set to either the first available per of dates based on the master date or
    ///    the selected per from the available ship and receipt dates dialog box. If there are no available
    ///    dates and no dates are selected, the per of dates will be set equal to greatest of the existing
    ///    date and the effective date plus sales lead time.
    /// </remarks>
    protected void setDates()
    {
        LeadTime    salesLeadTimeLocal;
        TransDate   effectiveOrderDateLocal;

        if (this.parmShippingDateAvailableSelected() || this.parmReceiptDateAvailableSelected())
        {
            if (this.parmReturnConfirmedDates())
            {
                if (this.shouldCancelConfirmedDatesSet())
                {
                    this.parmCancelModifiedField(true);
                }
                else 
                {
                    // Selected from dialog
                    deliveryDateControlMap.ShippingDateConfirmed = this.parmShippingDateAvailableSelected();
                    deliveryDateControlMap.ReceiptDateConfirmed  = this.parmReceiptDateAvailableSelected();
                }
            }
            else
            {
                // Selected from dialog
                deliveryDateControlMap.ShippingDateRequested = this.parmShippingDateAvailableSelected();
                deliveryDateControlMap.ReceiptDateRequested  = this.parmReceiptDateAvailableSelected();
            }
        }
        else if (this.isMasterDateTypeConfirmed())
        {
            if (salesAvailableDlvDatesTmp.AvailableShippingDate || salesAvailableDlvDatesTmp.AvailableReceiptDate)
            {
                // Best guess based on masterdate
                deliveryDateControlMap.ShippingDateConfirmed = salesAvailableDlvDatesTmp.AvailableShippingDate;
                deliveryDateControlMap.ReceiptDateConfirmed  = salesAvailableDlvDatesTmp.AvailableReceiptDate;
            }
            else
            {
                effectiveOrderDateLocal = this.effectiveOrderDate();
                salesLeadTimeLocal      = this.salesLeadTime();
                deliveryDateControlMap.ShippingDateConfirmed = max(deliveryDateControlMap.ShippingDateConfirmed,effectiveOrderDateLocal + salesLeadTimeLocal);
                deliveryDateControlMap.ReceiptDateConfirmed  = max(deliveryDateControlMap.ReceiptDateConfirmed, effectiveOrderDateLocal + salesLeadTimeLocal);
            }
        }
        else
        {
            if (salesAvailableDlvDatesTmp.AvailableShippingDate || salesAvailableDlvDatesTmp.AvailableReceiptDate)
            {
                // Best guess based on masterdate
                deliveryDateControlMap.ShippingDateRequested = salesAvailableDlvDatesTmp.AvailableShippingDate;
                deliveryDateControlMap.ReceiptDateRequested  = salesAvailableDlvDatesTmp.AvailableReceiptDate;
            }
            else
            {
                // Initiate dates if blank
                effectiveOrderDateLocal = this.effectiveOrderDate();
                salesLeadTimeLocal      = this.salesLeadTime();
                deliveryDateControlMap.ShippingDateRequested = max(deliveryDateControlMap.ShippingDateRequested,effectiveOrderDateLocal + salesLeadTimeLocal);
                deliveryDateControlMap.ReceiptDateRequested  = max(deliveryDateControlMap.ReceiptDateRequested, effectiveOrderDateLocal + salesLeadTimeLocal);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCancelConfirmedDatesSet</Name>
				<Source><![CDATA[
    protected internal boolean shouldCancelConfirmedDatesSet()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showSalesCalcAvailableDlvDatesPrompt</Name>
				<Source><![CDATA[
    internal protected boolean showSalesCalcAvailableDlvDatesPrompt()
    {
        return this.prompt();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldShowAvailableDlvDatesDialogPrompt</Name>
				<Source><![CDATA[
    internal protected boolean shouldShowAvailableDlvDatesDialogPrompt()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDeliveryDateControlTypeFullRunCTP</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected boolean isDeliveryDateControlTypeFullRunCTP()
    {
        return MpsFullRunCTPFeature::instance().isEnabled()
            && deliveryDateControlMap.DeliveryDateControlType == SalesDeliveryDateControlType::FullRunCTP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDeliveryDateControlTypeMpsOnlineCTP</Name>
				<Source><![CDATA[
    internal boolean isDeliveryDateControlTypeMpsOnlineCTP()
    {
        return MpsDeliveryDateControlTypeCTPHelper::isMpsOnlineCTPFeatureEnabledWithPlanningService()
            && deliveryDateControlMap.DeliveryDateControlType == SalesDeliveryDateControlType::CTP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDeliveryDateControlTypeMpsCTP</Name>
				<Source><![CDATA[
    internal boolean isDeliveryDateControlTypeMpsCTP()
    {
        return MpsDeliveryDateControlTypeCTPHelper::isDeliveryDateControlTypeMpsCTP(deliveryDateControlMap.DeliveryDateControlType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setOrderEntryDeadlines</Name>
				<Source><![CDATA[
    public void setOrderEntryDeadlines(SalesCalcAvailableDlvDates _salesCalcAvailableDlvDates)
    {
        SalesLatestOrderEntry   latestOrderEntryUser;
        date                    shippingdate = _salesCalcAvailableDlvDates.parmShippingDate();

        SalesLatestOrderEntry latestOrderEntry = InventOrderEntryDeadlineTable::orderEntryDeadline(_salesCalcAvailableDlvDates.parmInventSiteIdSelected(),
                                                                                                   _salesCalcAvailableDlvDates.parmOrderEntryDeadlineGroupId(),
                                                                                                   shippingDate);

        _salesCalcAvailableDlvDates.parmOrderEntryDeadlineSite(latestOrderEntry);

        utcdatetime utcTimeUser = DateTimeUtil::newDateTime(shippingDate,latestOrderEntry);
        int64 seconds = DateTimeUtil::getDifference(DateTimeUtil::newDateTime(shippingDate,latestOrderEntry, this.getShippingLocationTimeZone()),
                                                              DateTimeUtil::newDateTime(shippingDate,latestOrderEntry,DateTimeUtil::getUserPreferredTimeZone()));

        utcTimeUser           = DateTimeUtil::addSeconds(utcTimeUser,int642int(seconds));
        latestOrderEntryUser += DateTimeUtil::time(utcTimeUser);
        _salesCalcAvailableDlvDates.parmOrderEntryDeadlineUser(latestOrderEntryUser);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getShippingLocationTimeZone</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retreives shipping location time zone.
    /// </summary>
    public Timezone getShippingLocationTimeZone()
    {
        return InventSite::timeZoneSite(this.parmInventSiteIdSelected());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setShippingDateBeforeTodayErrorText</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the error text when a shipping date is in the past.
    /// </summary>
    /// <param name="_modifiedField">
    ///    A Boolean value that specifies whether the method is called as a response to a modified field event.
    /// </param>
    void setShippingDateBeforeTodayErrorText(boolean _modifiedField)
    {
        if (this.parmShippingDate() < this.shippingLocationDate())
        {
            if (_modifiedField)
            {
                if (this.masterDateType() == SalesDlvDateType::RequestedReceipt ||
                   this.masterDateType() ==  SalesDlvDateType::ConfirmedReceipt)
                {
                    errorText = this.errorTextHandling(strFmt("@SYS119896",date2StrUsr(this.parmReceiptDate(), DateFlags::FormatAll),
                                                       date2StrUsr(this.shippingLocationDate(),DateFlags::FormatAll)),Exception::Error,(this.parmShowDialog() || this.parmCheckOnly()));
                }
                else
                {
                    errorText = this.errorTextHandling(strFmt("@SYS111445",date2StrUsr(this.shippingLocationDate(),DateFlags::FormatAll)),Exception::Error);
                }
            }
            else
            {
                if (this.parmReceiptDate())
                {
                    errorText = this.errorTextHandling(strFmt("@SYS119899",date2StrUsr(this.parmShippingDate(),DateFlags::FormatAll),
                                                       date2StrUsr(this.shippingLocationDate(),DateFlags::FormatAll)),
                                                       Exception::Error);
                }
                else
                {
                    errorText = this.errorTextHandling(strFmt("@SYS111445",date2StrUsr(this.parmShippingDate(),DateFlags::FormatAll)),Exception::Error);
                }
            }
        }
        else
        {
            // case: Shipping date == today but before effective orderdate
            if (this.parmIncludeTodayInAvailableDlvDates())
            {
                if (_modifiedField)
                {
                    if (this.masterDateType() == SalesDlvDateType::RequestedReceipt ||
                        this.masterDateType() ==  SalesDlvDateType::ConfirmedReceipt)
                    {
                        errorText= this.errorTextHandling(strFmt("@SYS119912",date2StrUsr(this.parmReceiptDate(),DateFlags::FormatAll),
                                                          date2StrUsr(this.parmShippingDate(),DateFlags::FormatAll)),Exception::Warning,(this.parmShowDialog() || this.parmCheckOnly()));
                    }
                    else
                    {
                        errorText=  this.errorTextHandling(strFmt("@SYS119912",date2StrUsr(this.shippingLocationDate(), DateFlags::FormatAll),DateFlags::FormatAll),Exception::Warning);
                    }
                }
                else
                {
                    if (this.parmReceiptDate())
                    {
                        errorText=this.errorTextHandling(strFmt("@SYS111445",date2StrUsr(this.parmReceiptDate(),DateFlags::FormatAll),
                                                                              date2StrUsr(this.parmShippingDate(),DateFlags::FormatAll)),Exception::Warning);
                    }
                    else
                    {
                        errorText = this.errorTextHandling(strFmt("@SYS111445",date2StrUsr(this.parmReceiptDate(),DateFlags::FormatAll),
                                                                                date2StrUsr(this.parmShippingDate(),DateFlags::FormatAll)),Exception::Warning);
                    }
                }
            }
            else
            {
                if (_modifiedField)
                {
                    if (this.masterDateType() == SalesDlvDateType::RequestedReceipt ||
                       this.masterDateType() ==  SalesDlvDateType::ConfirmedReceipt)
                    {
                        errorText = this.errorTextHandling(strFmt("@SYS119912",date2StrUsr(this.parmReceiptDate(),DateFlags::FormatAll),
                                                          date2StrUsr(this.parmShippingDate(),DateFlags::FormatAll)),Exception::Error,(this.parmShowDialog() || this.parmCheckOnly()));
                    }
                    else
                    {
                        errorText = this.errorTextHandling(strFmt("@SYS119912",date2StrUsr(this.shippingLocationDate(),DateFlags::FormatAll)),Exception::Error);
                    }
                }
                else
                {
                    if (this.parmReceiptDate())
                    {
                        errorText = this.errorTextHandling(strFmt("@SYS111445",date2StrUsr(this.parmReceiptDate(),DateFlags::FormatAll),
                                                                               date2StrUsr(this.parmShippingDate(),DateFlags::FormatAll)),Exception::Error);
                    }
                    else
                    {
                        errorText= this.errorTextHandling(strFmt("@SYS111445",date2StrUsr(this.parmReceiptDate(),DateFlags::FormatAll),
                                                                             date2StrUsr(this.parmShippingDate(),DateFlags::FormatAll)),Exception::Error);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setShippingDateInLeadTimeErrorText</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the error text when a shipping date is in the order lead time.
    /// </summary>
    /// <param name="_modifiedField">
    ///    A Boolean value that specifies whether a method is called as a response to the modified field event.
    /// </param>
    void setShippingDateInLeadTimeErrorText(boolean _modifiedField)
    {
        if (this.deliveryDateControlMap().DeliveryDateControlType == SalesDeliveryDateControlType::ATP
            || this.deliveryDateControlMap().DeliveryDateControlType == SalesDeliveryDateControlType::ATPPlusIssueMargin)
        {
            errorText = this.errorTextHandling(strFmt("@SYS119201",date2StrUsr(this.parmShippingDate(),DateFlags::FormatAll)),Exception::Warning);
        }
        else
        {
            if (_modifiedField && (this.masterDateType() == SalesDlvDateType::RequestedReceipt ||
                                   this.masterDateType() ==  SalesDlvDateType::ConfirmedReceipt))
            {
                errorText = this.errorTextHandling(strFmt("@SYS88285",date2StrUsr(this.parmReceiptDate(),DateFlags::FormatAll)),
                                                   Exception::Warning, (this.parmShowDialog() || this.parmCheckOnly()));
            }
            else
            {
                errorText = this.errorTextHandling(strFmt("@SYS88287",date2StrUsr(this.parmShippingDate(),DateFlags::FormatAll)),Exception::Warning);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shippingCalendarId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the shipping calendar ID and returns it.
    /// </summary>
    /// <returns>
    ///    The shipping calendar ID.
    /// </returns>
    protected CalendarId shippingCalendarId()
    {
        SalesCalendarId shippingCalendarId;

        if (inventLocationIdTransportShipping)
            shippingCalendarId = InventLocation::find(inventLocationIdTransportShipping).ReqCalendarId;

        if (!shippingCalendarId)
            shippingCalendarId = CompanyInfo::find().ShippingCalendarId;

        return shippingCalendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shippingLocationDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and returns the shipping locations date.
    /// </summary>
    /// <returns>
    /// The shipping locations date.
    /// </returns>
    public TransDate shippingLocationDate()
    {
        if (!shippingLocationDate)
        {
            utcdatetime gmtTime = DateTimeUtil::utcNow();

            utcdatetime shippingLocationTime = DateTimeUtil::applyTimeZoneOffset(gmtTime,InventSite::timeZoneSite(this.parmInventSiteId()));

            shippingLocationDate = DateTimeUtil::date(shippingLocationTime);
        }
        return shippingLocationDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showAvailableDlvDatesDialog</Name>
				<Source><![CDATA[
    boolean showAvailableDlvDatesDialog(SalesCreateReleaseOrderLog  _errorText)
    {
        boolean ok;
        
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesCalcAvailableDlvDatesActivities().showAvailableDlvDatesDialog())
        {
            this.setOrderEntryDeadlines(this);
            this.createPossibleShippingAndReceiptDates();
            this.parmErrorText(_errorText);
            this.createPossibleShippingAndReceiptDates();
            xSysLastValue::saveLast(this);

            if (this.shouldShowAvailableDlvDatesDialogPrompt() && this.prompt())
            {
                if (this.parmDisableDeliveryDateControl())
                {
                    this.parmDeliveryDateControlType(SalesDeliveryDateControlType::None);
                }
                else
                {
                    this.parmDlvMode(this.parmDlvModeIdSelected());
                    this.parmInventLocationId(this.parmInventLocationIdSelected());
                    this.parmInventSiteId(this.parmInventSiteIdSelected());
                    this.setDates();
                }

                ok = true;
            }
            else
            {
                if (this.parmDisableDeliveryDateControl())
                {
                    this.parmDeliveryDateControlType(SalesDeliveryDateControlType::None);
                }
                else
                {
                    this.parmCancelModifiedField(true);
                }

                ok = false;
            }

            activityContext
                .addCustomProperty('ClickedOk', any2Str(ok));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleDateInReceiptCalendar</Name>
				<Source><![CDATA[
    protected SchedDate scheduleDateInReceiptCalendar(
        WorkCalendarSched   _workCalendarSched,
        SchedDirection      _schedDirection,
        SchedDate           _schedDateFrom,
        Days                _days,
        CalendarDays        _calendarDays)
    {
        return _workCalendarSched.schedDate(_schedDirection,
                                            _schedDateFrom,
                                            _days,
                                            _calendarDays,
                                            this.receiptCalendarId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleDateInShippingAndTransportCalendar</Name>
				<Source><![CDATA[
    protected SchedDate scheduleDateInShippingAndTransportCalendar(
        WorkCalendarSched   _workCalendarSched,
        SchedDirection      _schedDirection,
        SchedDate           _schedDateFrom,
        Days                _days,
        CalendarDays        _calendarDays,
        CalendarId          _shippingCalendarId,
        CalendarId          _transportCalendarId    = '',
        SalesCheckForPickup _checkForPickup         = SalesCheckForPickup::Never
        )
    {
        return _workCalendarSched.schedDate(_schedDirection,
                                            _schedDateFrom,
                                            _days,
                                            _calendarDays,
                                            _shippingCalendarId,
                                            _transportCalendarId,
                                            _checkForPickup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transportCalendarId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the transport calendar ID for a given mode of delivery and a possible warehouse.
    /// </summary>
    /// <returns>
    ///    The transport calendar ID.
    /// </returns>
    protected CalendarId transportCalendarId()
    {
        CustVendTransportCalendarId transportCalendarId;

        if (dlvModeIdSelected)
        {
            if (CustVendTransportCalendarSetup::exist(dlvModeIdSelected, inventLocationIdTransportShipping))
                transportCalendarId = CustVendTransportCalendarSetup::find(dlvModeIdSelected, inventLocationIdTransportShipping).Calendar;
            else if (CustVendTransportCalendarSetup::exist(dlvModeIdSelected, ''))
                transportCalendarId = CustVendTransportCalendarSetup::find(dlvModeIdSelected, '').Calendar;
        }
        return transportCalendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transportDays</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the number of days it takes an order to retrieve from the shipping point (warehouse) to the
    ///    receiving point (delivery address) for a given mode of delivery.
    /// </summary>
    /// <returns>
    ///    The number of days it takes an order to retrieve from the shipping point (warehouse) to the
    ///    receiving point (delivery address) for a given mode of delivery.
    /// </returns>
    public CustVendTransportDays transportDays()
    {
        LogisticsPostalAddress          logisticsPostalAddress;

        switch (deliveryDateControlMap.TableId)
        {
            case tableNum(SalesTable) :
            case tableNum(SalesLine) :
            case tableNum(SalesQuotationTable) :
            case tableNum(SalesQuotationLine) :
            case tableNum(SalesCreateReleaseOrderTableTmp) :
            case tableNum(SalesCreateReleaseOrderLineTmp) :
                if (deliveryDateControlMap.PostalAddress)
                {
                    select firstonly CountryRegionId, State, County, ZipCode from logisticsPostalAddress
                    where logisticsPostalAddress.RecId == deliveryDateControlMap.PostalAddress;
                }
                break;

            default:
                if (deliveryDateControlMap.Location)
                {
                    select firstonly CountryRegionId, State, County, ZipCode from logisticsPostalAddress
                    where logisticsPostalAddress.Location == deliveryDateControlMap.Location;
                }
        }

        CustVendTransportDays transportDays = CustVendTransportPointLine::defaultTransportDays(dlvModeIdSelected,
                                                                                               inventLocationIdTransportShipping,
                                                                                               logisticsPostalAddress.CountryRegionId,
                                                                                               logisticsPostalAddress.State,
                                                                                               logisticsPostalAddress.County,
                                                                                               logisticsPostalAddress.ZipCode);
        return transportDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Version     version = RunBase::getVersion(packedClass);
        container   salesAvailableDlvDatesTmp_Container;
        int         i;

        switch (version)
        {
            case #CurrentVersion:
                [version,#CurrentList,salesAvailableDlvDatesTmp_Container] = packedClass;

                salesAvailableDlvDatesTmp = null;
                salesAvailableDlvDatesTmpBestGuess.clear();
                delete_from salesAvailableDlvDatesTmp;
                for (i = 1; i <= conLen(salesAvailableDlvDatesTmp_Container); i++)
                {
                    container salesAvailableDlvDatesTmp_Record = conPeek(salesAvailableDlvDatesTmp_Container, i);
                    this.initSalesAvailableDlvDatesTmp(salesAvailableDlvDatesTmp
                                                        , conPeek(salesAvailableDlvDatesTmp_Record, 1)   // DlvNodeId
                                                        , conPeek(salesAvailableDlvDatesTmp_Record, 2)   // InventLocationId
                                                        , conPeek(salesAvailableDlvDatesTmp_Record, 3)   // InventSiteId
                                                        , conPeek(salesAvailableDlvDatesTmp_Record, 4)   // Available Shipping Date
                                                        , conPeek(salesAvailableDlvDatesTmp_Record, 5)); //Available Receipt date
                    salesAvailableDlvDatesTmp.insert();
                    this.setAvailableDlvDatesBestGuess(conPeek(salesAvailableDlvDatesTmp_Record, 4),conPeek(salesAvailableDlvDatesTmp_Record, 5));
                }

                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCaller</Name>
				<Source><![CDATA[
    protected void updateCaller(Common record, boolean _disableDlvDateControl = false)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalculateIfShippingDatesBeforeSalesLeadTimeDate</Name>
				<Source><![CDATA[
    private void recalculateIfShippingDatesBeforeSalesLeadTimeDate(TransDate _salesLeadTimeDate)
    {
        if (this.isMasterDateTypeConfirmed())
        {
            if (deliveryDateControlMap.ShippingDateConfirmed < _salesLeadTimeDate)
            {
                deliveryDateControlMap.ShippingDateConfirmed = _salesLeadTimeDate;
                this.initMaster(SalesDlvDateType::ConfirmedShipping);
                this.createPossibleShippingAndReceiptDates(true);
            }
        }
        else
        {
            if (deliveryDateControlMap.ShippingDateRequested < _salesLeadTimeDate)
            {
                deliveryDateControlMap.ShippingDateRequested = _salesLeadTimeDate;
                this.initMaster(SalesDlvDateType::RequestedShipping);
                this.createPossibleShippingAndReceiptDates(true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWritePrompt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies whether delivery dates are OK upon a record being inserted or updated.
    /// </summary>
    /// <param name="_record">
    ///    The record upon which delivery dates are checked.
    /// </param>
    /// <param name="_showDialog">
    ///    A Boolean value that specifies whether to show a dialog box to the user for irresolvable conflicts.
    /// </param>
    /// <param name="_forceValidate">
    ///    A Boolean value that indicates whether validation is enforced regardless of what has been changed
    ///    on the record being saved.
    /// </param>
    /// <param name="_showWarning">
    ///    A Boolean value that specifies whether warning messages are shown in the Infolog.
    /// </param>
    /// <param name="_recalculateShippingDate">
    ///    A Boolean value that specifies whether recalculation of the shipping date on a record is forced
    ///    regardless of circumstances.
    /// </param>
    /// <returns>
    ///    true if there are no conflicts with delivery dates and record can be saved; otherwise, false.
    /// </returns>
    boolean validateWritePrompt(Common _record,
                                 boolean _showDialog=true,
                                 boolean _forceValidate = false,
                                 boolean _showWarning = false,
                                 boolean _recalculateShippingDate = false)
    {
        boolean    ok = true;

        if (_recalculateShippingDate != this.parmRecalculateShippingDate() &&
            !prmisDefault(_recalculateShippingDate))
        {
            this.parmRecalculateShippingDate(_recalculateShippingDate);
            this.initMaster(SalesDlvDateType::None);
        }

        this.preUpdateBuffer();
        this.parmShowDialog(_showDialog);
        this.parmIncludeTodayInAvailableDlvDates(true);

        if (!this.deliveryDateControlActive())
        {
            return ok;
        }

        if (!_forceValidate && !this.doValidateWrite())
        {
            return ok;
        }

        if (this.parmReceiptDate())
        {
            //check also calendars
            this.checkReceiptDate(true);

            if (errorText)
            {
                //just inform
                if (!enableShowDialog)
                {
                    info(errorText);
                    return ok;
                }
            }
            else
            {
                //calculate shipping date
                this.createPossibleShippingAndReceiptDates(true);
                this.setDates();

                //note: the checkCalendar parameter is false,
                // as there's no need to recheck the calendars for shipping dates just calculated
                this.checkShippingDate(false, false);
            }
        }
        else if (this.parmShippingDate())
        {
            this.checkShippingDate(true, false);

            //NOTE: the method parameter is true, meaning it also pushes shipping date
            //closer to receipt date
            if (! errorText)
            {
                this.calcReceiptDate(true);
            }
        }

        if (errorText)
        {
            if (enableShowDialog)
            {
                if (_showDialog)
                {
                    ok = this.showAvailableDlvDatesDialog(errorText);
                }
                else
                {
                    if (_showWarning)
                    {
                        warning(errorText);
                    }

                    ok = false;
                }
            }
            else
            {
                if (_showWarning)
                {
                    if (this.parmErrorTextType() == Exception::Error)
                    {
                        error(errorText);
                        this.parmCancelModifiedField(true);
                        ok = false;
                    }
                    else
                    {
                        warning(errorText);
                        ok = true;
                    }
                }
            }
        }

        this.parmErrorText(errorText);

        this.updateCaller(_record, this.parmDisableDeliveryDateControl());

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDateFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initiates the <c>Requested ship date</c>, <c>Requested receipt date</c>, <c>Confirmed ship
    /// date</c>, and <c>Confirmed receipt date</c> fields
    /// </summary>
    /// <param name="_record">
    /// The record that contains the date fields to be initiated; optional.
    /// </param>
    /// <param name="_priceDisc">
    /// The instance of the price and discount class to use during the calculation.
    /// </param>
    /// <remarks>
    /// If one or both of the confirmed fields in the <paramref name="_record" /> parameter  are filled,
    /// these two confirmed fields will be initiated; otherwise, the two requested fields will be initiated.
    /// </remarks>
    public static void initDateFields(Common _record, PriceDisc_Price _priceDisc = null)
    {
        SalesCalcAvailableDlvDates salesCalcAvailableDlvDates = SalesCalcAvailableDlvDates::newCommonSalesDlvDateType(_record);

        using (var activityContext = salesCalcAvailableDlvDates.instrumentationLogger().salesCalcAvailableDlvDatesActivities().initDateFields())
        {
            salesCalcAvailableDlvDates.parmPriceDisc(_priceDisc);
            SalesCalcAvailableDlvDates::initDateFieldsForSalesCalc(_record, salesCalcAvailableDlvDates, false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDateFieldsForSalesCalc</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initiates the <c>Requested ship date</c>, <c>Requested receipt date</c>, <c>Confirmed ship date</c>, and <c>Confirmed receipt date</c> fields based on the specified calculation class instance.
    /// </summary>
    /// <param name="_record">
    ///     The record that contains the date fields to be initiated.
    /// </param>
    /// <param name="_salesCalcAvailableDlvDates">
    ///     The instance of the <c>SalesCalcAvailableDlvDates</c> class to use in calculations.
    /// </param>
    /// <param name="_considerBufferCommitedStatus">
    ///     A boolean value indicating whether to consider the commited status of the buffer upon the initialization of the dates.
    /// </param>
    public static void initDateFieldsForSalesCalc(Common _record, SalesCalcAvailableDlvDates _salesCalcAvailableDlvDates, boolean _considerBufferCommitedStatus)
    {
        TransDate                   salesLeadTimeDate;
        LeadTime                    salesLeadTime;

        if (!_salesCalcAvailableDlvDates)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        using (var activityContext = _salesCalcAvailableDlvDates.instrumentationLogger().salesCalcAvailableDlvDatesActivities().initDateFieldsForSalesCalc())
        {
            SalesDeliveryDateControlMap deliveryDateControlMap = _salesCalcAvailableDlvDates.deliveryDateControlMap();

            if (_salesCalcAvailableDlvDates.deliveryDateControlActive())
            {
                salesLeadTime              = _salesCalcAvailableDlvDates.salesLeadTime();
                salesLeadTimeDate          = _salesCalcAvailableDlvDates.effectiveOrderDate() + salesLeadTime;

                _salesCalcAvailableDlvDates.resetSalesDeliveryDateControlMapRequestedDate(_record, salesLeadTime, salesLeadTimeDate, deliveryDateControlMap);

                if (_salesCalcAvailableDlvDates.isMasterDateTypeConfirmed())
                {
                    deliveryDateControlMap.ShippingDateConfirmed = max(deliveryDateControlMap.ShippingDateConfirmed, salesLeadTimeDate);
                    deliveryDateControlMap.ReceiptDateConfirmed  = max(deliveryDateControlMap.ReceiptDateConfirmed,  salesLeadTimeDate);
                }
                else
                {
                    if (!_considerBufferCommitedStatus || _record.RecId)
                    {
                        deliveryDateControlMap.ShippingDateRequested = max(deliveryDateControlMap.ShippingDateRequested, salesLeadTimeDate);
                        deliveryDateControlMap.ReceiptDateRequested  = max(deliveryDateControlMap.ReceiptDateRequested,  salesLeadTimeDate);
                    }
                    else
                    {
                        deliveryDateControlMap.ShippingDateRequested = salesLeadTimeDate;
                        deliveryDateControlMap.ReceiptDateRequested  = salesLeadTimeDate;
                    }
                }
                _salesCalcAvailableDlvDates.initMaster();
                _salesCalcAvailableDlvDates.createPossibleShippingAndReceiptDates(true);
                _salesCalcAvailableDlvDates.setDates();

                _salesCalcAvailableDlvDates.recalculateIfShippingDatesBeforeSalesLeadTimeDate(salesLeadTimeDate);
            }
            else
            {
                if (_considerBufferCommitedStatus && !_record.RecId)
                {
                    salesLeadTime                                = _salesCalcAvailableDlvDates.salesLeadTime();
                    salesLeadTimeDate                            = _salesCalcAvailableDlvDates.effectiveOrderDate() + salesLeadTime;

                    deliveryDateControlMap.ShippingDateRequested = salesLeadTimeDate;
                    deliveryDateControlMap.ReceiptDateRequested  = salesLeadTimeDate;
                }
            }

            _salesCalcAvailableDlvDates.setDates();
            _salesCalcAvailableDlvDates.updateCaller(_record, _salesCalcAvailableDlvDates.parmDisableDeliveryDateControl());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetSalesDeliveryDateControlMapRequestedDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reset <c>SalesDeliveryDateControlMap</c> requested dates when the salesLeadTime is 0 for a common sales line, means there is enough on hand.
    /// </summary>
    /// <param name = "_record">The record that contains the date fields to be initiated.</param>
    /// <param name = "_salesLeadTime">The calculated sales lead time.</param>
    /// <param name = "_salesLeadTimeDate">The calculated effective order date.</param>
    /// <param name = "_deliveryDateControlMap">The instance of the <c>SalesDeliveryDateControlMap</c>.</param>
    protected void resetSalesDeliveryDateControlMapRequestedDate(
        Common                      _record,
        LeadTime                    _salesLeadTime,
        TransDate                   _salesLeadTimeDate,
        SalesDeliveryDateControlMap _deliveryDateControlMap
        )
    {
        if (_record.TableId == tableNum(SalesLine))
        {
            SalesLine salesLine = _record as SalesLine;
            if (salesLine.Reservation == ItemReservation::None
				    && salesLine.DeliveryDateControlType != SalesDeliveryDateControlType::None
				    && !salesLine.isDirectDelivery()
				    && !_salesLeadTime)
			{
                SalesTable salesTable = salesLine.salesTable();
                _deliveryDateControlMap.ShippingDateRequested = max(salesTable.ShippingDateRequested, _salesLeadTimeDate);
                _deliveryDateControlMap.ReceiptDateRequested  = max(salesTable.ReceiptDateRequested, _salesLeadTimeDate);
            }
        }        
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDateFieldsOrderEntryDeadline</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initiates the <c>Requested ship date</c>, <c>Requested receipt date</c>, <c>Confirmed ship date</c>, and <c>Confirmed receipt date</c> fields based on the specified calculation class instance.
    /// </summary>
    /// <param name="_record">
    ///     The record that contains the date fields to be initiated.
    /// </param>
    /// <param name="_priceDisc">
    ///     The instance of the price and discount class to use during the calculation; optional.
    /// </param>
    /// <param name="_inventDim">
    ///     The dimension record associated with the current record.
    /// </param>
    public static void initDateFieldsOrderEntryDeadline(Common _record, PriceDisc_Price _priceDisc = null, InventDim _inventDim = null)
    {
        SalesCalcAvailableDlvDates  salesCalcAvailableDlvDates = SalesCalcAvailableDlvDates::newCommonSalesDlvDateType(_record,0,_inventDim);

        salesCalcAvailableDlvDates.parmPriceDisc(_priceDisc);
        SalesCalcAvailableDlvDates::initDateFieldsForSalesCalc(_record, salesCalcAvailableDlvDates, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        FormDataSource                  common_ds;

        if (! _args)
        {
            throw error("@SYS25407");
        }

        Common record = _args.record();
        FormRun formRun = _args.caller();
        str formName = formRun.name();

        using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContext(_args))
        {
            container cachedArgs = [#CachedArgsList];
            boolean refreshCaller = SalesCalcAvailableDlvDates::mainOnServer(cachedArgs, record);

            if (refreshCaller)
            {
                if (record.TableId == tableNum(SalesLine))
                {
                    SalesLine salesLine = record as SalesLine;
                    if (salesLine)
                    {
                        common_ds = FormDataUtil::getFormDataSource(salesLine);
                    }

                    if (common_ds)
                    {
                        SalesLine salesLineActive = SalesLine::findRecId(salesLine.RecId);
                        if (!salesLine.isTmp())
                        {
                            common_ds.write();
                        }

                        common_ds.reread();
                        common_ds.refresh();
                    }
                }
                else if (record || record.TableId == tableNum(SalesTable) || record.TableId == tableNum(SalesQuotationTable))
                {
                    common_ds = FormDataUtil::getFormDataSource(record);
                    if (common_ds)
                    {
                        common_ds.refresh();
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeFromCaller</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>SalesCalcAvailableDlvDates</c> from the caller record and form.
    /// </summary>
    /// <param name = "_record">A line record.</param>
    /// <param name = "_formName">A form name.</param>
    protected void initializeFromCaller(Common _record, str _formName)
    {
        switch (_record.TableId)
        {
            case tableNum(SalesTable)    :
                if (_formName == formStr(SalesCreateOrder))
                {
                    this.parmShowTransferToConfirmedButton(false);
                    this.parmShowTransferToRequestedButton(true);
                }
                else
                {
                    SalesTable salesTable = _record as SalesTable;
                    this.parmShowTransferToRequestedButton(!(salesTable.InterCompanyOrigin == InterCompanyOrigin::Derived));
                }
                break;

            case tableNum(SalesLine)     :
                SalesLine salesLine = _record as SalesLine;
                this.parmShowTransferToRequestedButton(!(salesLine.InterCompanyOrigin == InterCompanyOrigin::Derived));
                break;

            case tableNum(SalesCreateReleaseOrderTableTmp) :
                this.parmShowTransferToConfirmedButton(false);
                this.parmShowTransferToRequestedButton(true);
                break;

            case tableNum(SalesCreateReleaseOrderLineTmp) :
                this.parmShowTransferToConfirmedButton(false);
                this.parmShowTransferToRequestedButton(true);
                break;

            case tableNum(SalesQuotationLine) :
                this.parmShowTransferToConfirmedButton(false);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mainOnServer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the delivery date on the server tier.
    /// </summary>
    /// <param name="_cachedArgs">
    /// The parameters from the <c>Args</c> class on the client tier.
    /// </param>
    /// <param name="_record">
    /// A record from the <c>Args</c> class on the client tier.
    /// </param>
    /// <returns>
    /// true if the calculation is executed; otherwise, false.
    /// </returns>
    protected static boolean mainOnServer(container _cachedArgs, Common _record)
    {
        str                             formName;
        SalesLine                       salesLine;
        SalesLine                       salesLineBuffer;
        SalesTable                      salesTable;
        boolean                         executed;
        boolean                         updateMultiLineDisc;
        boolean                         updateFinalDisc;

        [#CachedArgsList] = _cachedArgs;

        SalesCalcAvailableDlvDates salesCalcAvailableDlvDates = SalesCalcAvailableDlvDates::newCommonSalesDlvDateType(_record);
        salesCalcAvailableDlvDates.parmShowTransferToConfirmedButton(true);
        salesCalcAvailableDlvDates.parmShowTransferToRequestedButton(true);
        salesCalcAvailableDlvDates.parmIncludeTodayInAvailableDlvDates(true);
        SalesDeliveryDateControlMap deliveryDateControlMap = salesCalcAvailableDlvDates.deliveryDateControlMap();

        salesCalcAvailableDlvDates.initializeFromCaller(_record, formName);

        salesCalcAvailableDlvDates.setOrderEntryDeadlines(salesCalcAvailableDlvDates);
        salesCalcAvailableDlvDates.createPossibleShippingAndReceiptDates();
        xSysLastValue::saveLast(salesCalcAvailableDlvDates);
        
        if (salesCalcAvailableDlvDates.showSalesCalcAvailableDlvDatesPrompt())
        {
            salesCalcAvailableDlvDates.parmDlvMode(salesCalcAvailableDlvDates.parmDlvModeIdSelected());
            salesCalcAvailableDlvDates.parmInventLocationId(salesCalcAvailableDlvDates.parmInventLocationIdSelected());
            salesCalcAvailableDlvDates.parmInventSiteId(salesCalcAvailableDlvDates.parmInventSiteIdSelected());
            salesCalcAvailableDlvDates.setDates();
            salesCalcAvailableDlvDates.updateCaller(_record, salesCalcAvailableDlvDates.parmDisableDeliveryDateControl());
            executed = true;

            if (_record.TableId == tableNum(SalesLine))
            {
                salesLine = _record as SalesLine;

                if (!salesLine.isTmp())
                {
                    salesTable = salesLine.salesTable();
                    if (!salesTable.isInterCompanyPOInvoiceMatched())
                    {
                        updateMultiLineDisc = PriceDiscPolicyRule::createInstance(salesTable).launchPolicyDialogForSinglePolicyField(PriceDiscPolicyField::newPriceDiscResultsField(fieldNum(PriceDiscResultFields, MultiLineDiscCode)));
                        updateFinalDisc     = PriceDiscPolicyRule::createInstance(salesTable).launchPolicyDialogForSinglePolicyField(PriceDiscPolicyField::newPriceDiscResultsField(fieldNum(PriceDiscResultFields, DiscPercent)));
                        if (SalesParameters::find().PriceDateType == SalesPriceDateType::ShippingDateRequested)
                        {
                            PriceDiscPolicyRule::createInstance(salesLine).launchPolicyDialogForAllPolicyFields(false, false);
                        }
                    }
                }

                ttsbegin;

                if (salesLine.LineDeliveryType != LineDeliveryType::DeliveryLine
                    && (!salesLine.isInterCompanyOrder()
                    ||   salesLine.salesTable().interCompanyEndpointActionPolicy().PriceDiscountSearch))
                {
                    salesLine.setPriceDisc(salesLine.inventDim(), false);
                }
                if (salesLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries)
                {
                    InventMovement::bufferSetRemainQty(salesLine);
                }

                if (salesLine.isTmp())
                {
                    if (salesLine.RecId)
                    {
                        salesLine.doUpdate();
                    }
                    else
                    {
                        salesLine.doInsert();
                    }
                }
                else
                {
                    if (salesLine.RecId)
                    {
                        salesLine.update();
                    }
                    else
                    {
                        salesLine.insert();
                    }

                    if (updateMultiLineDisc)
                    {
                        salesTable.PriceDiscHeading::updateMultiLineDiscount(salesLineBuffer, true);
                    }

                    if (updateFinalDisc)
                    {
                        salesTable.selectForUpdate(true);
                        salesTable.PriceDiscHeading::updateFinalDiscount(salesLineBuffer, true);
                    }
                }
                ttscommit;
            }
        }
        return executed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedFieldOrderEntryDeadLine</Name>
				<Source><![CDATA[
    public static SalesCalcAvailableDlvDates modifiedFieldOrderEntryDeadLine(Common    _record,
                                                                                    FieldId   _fieldId,
                                                                                    InventDim _inventDim      = null)
    {
        SalesCalcAvailableDlvDates salesCalcAvailableDlvDates = SalesCalcAvailableDlvDates::newCommonSalesDlvDateType(_record,_fieldId,_inventDim);
        salesCalcAvailableDlvDates.preUpdateBuffer();
        salesCalcAvailableDlvDates.parmIncludeTodayInAvailableDlvDates(true);

        salesCalcAvailableDlvDates.setOrderEntryDeadlines(salesCalcAvailableDlvDates);
        salesCalcAvailableDlvDates.createPossibleShippingAndReceiptDates(true);
        salesCalcAvailableDlvDates.setDates();

        // case: Push shipping date closer to receipt date
        salesCalcAvailableDlvDates.initMaster(salesCalcAvailableDlvDates.masterDateType() == SalesDlvDateType::ConfirmedShipping ? SalesDlvDateType::ConfirmedReceipt : SalesDlvDateType::RequestedReceipt);
        salesCalcAvailableDlvDates.createPossibleShippingAndReceiptDates(true);
        salesCalcAvailableDlvDates.setDates();

        salesCalcAvailableDlvDates.updateCaller(_record, salesCalcAvailableDlvDates.parmDisableDeliveryDateControl());

        return salesCalcAvailableDlvDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCommonSalesDlvDateType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>SalesCalcAvailableDlvDates</c> class.
    /// </summary>
    /// <param name = "_common">The buffer containing the delivery date control field.</param>
    /// <param name = "_fieldId">The field ID of the delivery date control; optional.</param>
    /// <param name = "_inventDim">The invent dimensions used by the delivery date control; optional.</param>
    /// <returns>An instance of the <c>SalesCalcAvailableDlvDates</c> class.</returns>
    [Replaceable]
    public static SalesCalcAvailableDlvDates  newCommonSalesDlvDateType(Common           _common,
                                                                 FieldId          _fieldId   = 0,
                                                                 InventDim        _inventDim = null)
    {
        switch (_common.TableId)
        {
            case tableNum(SalesTable)                       :   return SalesCalcAvailableDlvDates_SalesTable::newSalesTable(_common,_fieldId);
            case tableNum(SalesLine)                        :   return SalesCalcAvailableDlvDates_SalesLine::newSalesLine(_common,_fieldId,_inventDim);
            case tableNum(SalesCreateReleaseOrderTableTmp)  :   return SalesCalcAvailableDlvDates_ReleaseTable::newSalesCreateReleaseOrderTableTmp(_common,_fieldId);
            case tableNum(SalesCreateReleaseOrderLineTmp)   :   return SalesCalcAvailableDlvDates_ReleaseLine::newSalesCreateReleaseOrderLineTmp(_common,_fieldId,_inventDim);
            case tableNum(InventTransferLine)               :   return SalesCalcAvailableDlvDates_TransferLine::newTransferLine(_common,_fieldId);
            case tableNum(InventTransferTable)              :   return SalesCalcAvailableDlvDates_TransferTable::newTransferTable(_common,_fieldId);
            case tableNum(SalesQuotationTable)              :   return SalesCalcAvailableDlvDates_QuoteTable::newSalesQuotationTable(_common,_fieldId);
            case tableNum(SalesQuotationLine)               :   return SalesCalcAvailableDlvDates_QuoteLine::newSalesQuotationLine(_common,_fieldId,_inventDim);

            default : throw error(strFmt("@SYS19306",funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCommonSalesDlvDateTypeByEntity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>SalesCalcAvailableDlvDates</c> class used for data entities.
    /// </summary>
    /// <param name = "_common">The buffer containing the delivery date control field.</param>
    /// <param name = "_fieldId">The field ID of the delivery date control; optional.</param>
    /// <param name = "_inventDim">The invent dimensions used by the delivery date control; optional.</param>
    /// <returns>An instance of the <c>SalesCalcAvailableDlvDates</c> class.</returns>
    [Replaceable]
    public static SalesCalcAvailableDlvDates newCommonSalesDlvDateTypeByEntity(
        Common           _common,
        FieldId          _fieldId   = 0,
        InventDim        _inventDim = null)
    {
        switch (_common.TableId)
        {
            case tableNum(SalesTable)                       :   return SalesCalcAvailableDlvDates_SalesTable::newSalesTable(_common,_fieldId);
            case tableNum(SalesLine)                        :   return SalesCalcAvailableDlvDates_SalesLine::newSalesLine(_common,_fieldId,_inventDim);
            case tableNum(SalesCreateReleaseOrderTableTmp)  :   return SalesCalcAvailableDlvDates_ReleaseTable::newSalesCreateReleaseOrderTableTmp(_common,_fieldId);
            case tableNum(SalesCreateReleaseOrderLineTmp)   :   return SalesCalcAvailableDlvDates_ReleaseLine::newSalesCreateReleaseOrderLineTmp(_common,_fieldId,_inventDim);
            case tableNum(InventTransferLine)               :   return SalesCalcAvailableDlvDates_TransferLineEntity::newTransferLine(_common,_fieldId);
            case tableNum(InventTransferTable)              :   return SalesCalcAvailableDlvDates_TransferTableEntity::newTransferTable(_common,_fieldId);
            case tableNum(SalesQuotationTable)              :   return SalesCalcAvailableDlvDates_QuoteTable::newSalesQuotationTable(_common,_fieldId);
            case tableNum(SalesQuotationLine)               :   return SalesCalcAvailableDlvDates_QuoteLine::newSalesQuotationLine(_common,_fieldId,_inventDim);

            default : throw error(strFmt("@SYS19306",funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies whether delivery dates are valid upon a record being inserted or updated.
    /// </summary>
    /// <param name="_common">
    /// The record upon which delivery dates are checked.
    /// </param>
    /// <returns>
    /// true if there are no conflicts with delivery dates and record can be saved; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method ensures the logic is executed on the server and will not show the validation dialog.
    /// </remarks>
    public static boolean validateWrite(Common _common)
    {
        SalesCalcAvailableDlvDates salesCalcAvailableDlvDates = SalesCalcAvailableDlvDates::newCommonSalesDlvDateType(_common);
        return salesCalcAvailableDlvDates.validateWritePrompt(_common,false,true,true, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWritePromptOnServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies whether delivery dates are OK upon a record being inserted or updated.
    /// </summary>
    /// <param name="_record">
    ///    The record upon which delivery dates are checked.
    /// </param>
    /// <param name="_showDialog">
    ///    A Boolean value that specifies whether to show a dialog box to the user for irresolvable conflicts.
    /// </param>
    /// <param name="_forceValidate">
    ///    A Boolean value that indicates whether validation is enforced regardless of what has been changed
    ///    on the record being saved.
    /// </param>
    /// <param name="_showWarning">
    ///    A Boolean value that specifies whether warning messages are shown in the Infolog.
    /// </param>
    /// <param name="_recalculateShippingDate">
    ///    A Boolean value that specifies whether recalculation of the shipping date on a record is forced
    ///    regardless of circumstances.
    /// </param>
    /// <returns>
    ///    true if there are no conflicts with delivery dates and record can be saved; otherwise, false.
    /// </returns>
    public static boolean validateWritePromptOnServer(Common   _record,
                                                             boolean  _showDialog = true,
                                                             boolean _forceValidate = false,
                                                             boolean _showWarning = false,
                                                             boolean _recalculateShippingDate = false)
    {
        return SalesCalcAvailableDlvDates::newCommonSalesDlvDateType(_record).validateWritePrompt(_record,
                                                                                                  _showDialog,
                                                                                                  _forceValidate,
                                                                                                  _showWarning,
                                                                                                  _recalculateShippingDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustDatesForCalendar</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the ship and receipt date based on the earliest possible ship date and the applicable calendars.
    /// </summary>
    /// <param name = "_earliestShipDate">The earliest date when there is enough inventory to ship.</param>
    /// <param name = "_transportDays">The transport time to the receipt location.</param>
    /// <returns>A container containing the actual ship and receipt dates.</returns>
    public container adjustDatesForCalendar(FromDate _earliestShipDate, CustVendTransportDays _transportDays)
    {
        WorkCalendarSched   sched = new WorkCalendarSched();

        return this.calcForward(_earliestShipDate,
            true,
            sched,
            this.shippingCalendarId(),
            this.transportCalendarId(),
            _transportDays,
            0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    final internal SalesInstrumentationLogger instrumentationLogger()
    {
        if (!instrumentationLogger)
        {
            instrumentationLogger = SalesInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
        }

        return instrumentationLogger;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>