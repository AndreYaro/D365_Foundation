<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>MCRPickingWorkBench</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>MCRPickingWorkBench</c> class is used with the <c>MCRPickingWorkbench</c> form and batch proccesses to pick orders.
/// </summary>
class McrPickingWorkBench
{
    MCRPickingWorkbenchSession mcrPickingWorkbenchSession;
    MCRTmpPickingWorkbenchTrans mcrTmpPickingWorkbenchTrans;

    str                         promptStr;
    boolean                     displayWarnings;
    boolean                     pickingListRegUsed;

    InventLocationId            prevWarehouse;
    CustDlvModeId               prevDlvMode;
    MCRShipAlone                prevShipAlone;
    OMOperatingUnitNumber       prevDimension;
    SalesId                     prevSalesId;
    Addressing                  prevDeliveryAddress;
    Name                        prevDeliveryName;

    NoYes                       splitByDlvMode;
    NoYes                       splitByShipAlone;
    int                         maxLinesPerPicklist;

    boolean                     whExistsWithSplitByDlvMode;
    boolean                     whExistsSplitByShipAlone;

    MCRPickingWave              currentPickingWaveID;
    MCRPickingWave              prevPickingWaveID;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>cleanupMCRPickingWorkbenchWaveSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes rows MCRPickingWorkbenchWaveSalesLine which belongs to a picking workbench wave in the specified set
    /// </summary>
    /// <param name="_waveSet">
    /// Set of picking workbench waves to be deleted
    /// </param>
    private void cleanupMCRPickingWorkbenchWaveSalesLine(Set _waveSet)
    {
        MCRPickingWorkbenchWaveSalesLine    mcrPickingWorkbenchWaveSalesLine;
        SetEnumerator                       waveSetEnumerator = _waveSet.getEnumerator();

        ttsBegin;
        while (waveSetEnumerator.moveNext())
        {
            delete_from mcrPickingWorkbenchWaveSalesLine where mcrPickingWorkbenchWaveSalesLine.PickingWorkbenchWaveId == waveSetEnumerator.current();
        }
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new picking wave record, and also sets the previous and current picking wave reference ID.
    /// </summary>
    protected void createNewWave()
    {
        MCRPickingWorkbenchWave mcrPickingWorkbenchWave;

        prevPickingWaveID = currentPickingWaveID;

        mcrPickingWorkbenchWave.clear();

        ttsbegin;
        mcrPickingWorkbenchWave.WaveReferenceId = NumberSeq::newGetNum(InventParameters::mcrNumRefPickingWorkbenchWaveId()).num();
        mcrPickingWorkbenchWave.SessionId       = mcrPickingWorkbenchSession.SessionId;
        mcrPickingWorkbenchWave.Warehouse       = mcrTmpPickingWorkbenchTrans.InventLocationId;

        // Format the split fields only if splitting by them.
        if (splitByShipAlone)
        {
            mcrPickingWorkbenchWave.mcrShipAlone = mcrTmpPickingWorkbenchTrans.mcrShipAlone;
        }
        if (splitByDlvMode)
        {
            mcrPickingWorkbenchWave.DlvMode = mcrTmpPickingWorkbenchTrans.DlvMode;
        }

        // Insert the pick group.
        if (mcrPickingWorkbenchWave.validateWrite())
        {
            mcrPickingWorkbenchWave.insert();
        }
        else
        {
            throw error("@SYS104318");
        }

        ttscommit;

        currentPickingWaveID = mcrPickingWorkbenchWave.WaveReferenceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPickList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts a pick list.
    /// </summary>
    /// <param name="_splitDeliveryPickingList">
    /// A flag indicating if the posting of the picking list should be split into multiple picking lists.
    /// </param>
    protected void createPickList(boolean _splitDeliveryPickingList)
    {
        try
        {
            if (_splitDeliveryPickingList)
            {
                MCRPickingWorkBench::createAndPostPickListSplit(prevSalesId,
                                                                currentPickingWaveID,
                                                                prevDlvMode,
                                                                prevDeliveryName,
                                                                prevDeliveryAddress,
                                                                pickingListRegUsed);
            }
            else
            {
                MCRPickingWorkBench::createAndPostPicklist(prevSalesId, currentPickingWaveID, pickingListRegUsed);
            }
        }
        catch
        {
            info(strFmt("@MCR11395", prevSalesId, currentPickingWaveID));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWaveFromWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new picking wave record, using a wave as a template.
    /// </summary>
    /// <param name="_mcrPickingWorkbenchWaveTemplate">
    /// The picking wave record used as a template to create a new picking wave.
    /// </param>
    /// <returns>
    /// The picking wave reference ID of the newly created picking wave.
    /// </returns>
    protected MCRPickingWave createWaveFromWave(MCRPickingWorkbenchWave _mcrPickingWorkbenchWaveTemplate)
    {
        MCRPickingWorkbenchWave     mcrPickingWorkbenchWave;

        mcrPickingWorkbenchWave.clear();

        ttsbegin;
        mcrPickingWorkbenchWave.WaveReferenceId = NumberSeq::newGetNum(InventParameters::mcrNumRefPickingWorkbenchWaveId()).num();
        mcrPickingWorkbenchWave.SessionId       = _mcrPickingWorkbenchWaveTemplate.SessionId;
        mcrPickingWorkbenchWave.Warehouse       = _mcrPickingWorkbenchWaveTemplate.Warehouse;
        mcrPickingWorkbenchWave.mcrShipAlone    = _mcrPickingWorkbenchWaveTemplate.mcrShipAlone;
        mcrPickingWorkbenchWave.DlvMode         = _mcrPickingWorkbenchWaveTemplate.DlvMode;
        mcrPickingWorkbenchWave.insert();
        ttscommit;

        return mcrPickingWorkbenchWave.WaveReferenceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generatePicklistFromTransition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks transition points to see if a picklist should be generated.
    /// </summary>
    /// <param name="_splitDeliveryPicklist">
    /// A flag indicating if the picking list should be split.
    /// </param>
    /// <param name="_linesInPicklist">
    /// The number of lines contained in the picking list.
    /// </param>
    /// <returns>
    /// true if a new picking list should be generated; otherwise, false.
    /// </returns>
    protected boolean generatePicklistFromTransition(boolean _splitDeliveryPicklist, int _linesInPicklist)
    {
        boolean generatePickList = false;

        if (prevSalesId != mcrTmpPickingWorkbenchTrans.SalesId)
        {
            generatePickList = true;
        }

        if (this.newPickWaveTransition())
        {
            generatePickList = true;
        }

        if (_splitDeliveryPicklist)
        {
            if ((prevDeliveryName       != mcrTmpPickingWorkbenchTrans.Name)
                || (prevDeliveryAddress != mcrTmpPickingWorkbenchTrans.Address)
                || (prevDlvMode         != mcrTmpPickingWorkbenchTrans.DlvMode))
            {
                generatePickList = true;
            }
        }

        // Max lines per a picklist, allows for splitting up large picking lists.
        if (maxLinesPerPicklist && (_linesInPicklist >= maxLinesPerPicklist))
        {
            generatePickList = true;
        }

        return generatePickList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateWaves</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates picking workbench batches based on the criteria selected for the picking session.
    /// </summary>
    void generateWaves()
    {
        #avifiles
        SysOperationProgress                progressBar = SysOperationProgress::newGeneral(#aviUpdate, "@MCR11394", 100); // Generating pick groups

        Query                               query;
        QueryBuildDataSource                qbdsMCRTmpPickingWorkbenchTrans;
        QueryRun                            queryRun;
        MCRPickingWorkbenchWaveSalesLine    mcrPickingWorkbenchWaveSalesLine;

        int                                 totalLines = 0;
        int                                 tmpTableLines;
        int                                 linesInPicklist = 0;
        boolean                             firstTime = true;
        boolean                             splitDeliveryPickingList  = SalesParameters::find().SplitDeliveryPickingList;

        MCRPickingWorkbenchSession          mcrPickingWorkbenchSession_Update;

        // Set of waves used during this picking workbench session
        Set                                 waveSet = new Set(typeOf(mcrPickingWorkbenchWaveSalesLine.PickingWorkbenchWaveId));

        if (!mcrPickingWorkbenchSession.CreatedFromBatch)
        {
            progressBar.setText("@MCR11388"); // Searching and reservation
            progressBar.update(true);
        }

        // Fill temp table based on sessions search criteria.
        if (mcrPickingWorkbenchSession.Prompt == MCRPickingPrompt::BySalesID)
        {
            mcrTmpPickingWorkbenchTrans.initFromSalesIdPrompt(mcrPickingWorkbenchSession.SessionId, promptStr, displayWarnings);
        }
        else if (mcrPickingWorkbenchSession.Prompt == MCRPickingPrompt::ByItem)
        {
            mcrTmpPickingWorkbenchTrans.initFromItemPrompt(mcrPickingWorkbenchSession.SessionId, promptStr, displayWarnings);
        }
        else if (mcrPickingWorkbenchSession.Prompt == MCRPickingPrompt::ByContinuity)
        {
            mcrTmpPickingWorkbenchTrans.initFromContinuityItemPrompt(mcrPickingWorkbenchSession.SessionId, promptStr, displayWarnings);
        }
        else
        {
            mcrTmpPickingWorkbenchTrans.initFromSessionCriteria(mcrPickingWorkbenchSession.SessionId, displayWarnings);
        }

        // Obtain count of temp table.
        select count(RecId) from mcrTmpPickingWorkbenchTrans;
        tmpTableLines = int642int(mcrTmpPickingWorkbenchTrans.RecId);

        this.setWarehouseSplitByExistsParams(mcrPickingWorkbenchSession.Warehouse);

        if (!mcrPickingWorkbenchSession.CreatedFromBatch)
        {
            progressBar.setText("@MCR34065"); // Processing lines and generating picklists
            progressBar.setCount(0);
            // Set progress bar to total lines in temp table.
            progressBar.setTotal(tmpTableLines, 1);
            progressBar.update(true);
        }

        // Sort temp tables based on splits.
        query = new Query();
        qbdsMCRTmpPickingWorkbenchTrans = query.addDataSource(tableNum(MCRTmpPickingWorkbenchTrans));
        qbdsMCRTmpPickingWorkbenchTrans.addSortField(fieldNum(MCRTmpPickingWorkbenchTrans, InventLocationId));
        if (whExistsWithSplitByDlvMode)
        {
            qbdsMCRTmpPickingWorkbenchTrans.addSortField(fieldNum(MCRTmpPickingWorkbenchTrans, DlvMode));
        }
        if (whExistsSplitByShipAlone)
        {
            qbdsMCRTmpPickingWorkbenchTrans.addSortField(fieldNum(MCRTmpPickingWorkbenchTrans, mcrShipAlone));
        }
        qbdsMCRTmpPickingWorkbenchTrans.addSortField(fieldNum(MCRTmpPickingWorkbenchTrans, SalesId));
        qbdsMCRTmpPickingWorkbenchTrans.addSortField(fieldNum(MCRTmpPickingWorkbenchTrans, Name));
        qbdsMCRTmpPickingWorkbenchTrans.addSortField(fieldNum(MCRTmpPickingWorkbenchTrans, Address));

        queryRun = new QueryRun(query);
        queryRun.setCursor(mcrTmpPickingWorkbenchTrans);

        // Loop through the query.
        while (queryRun.next())
        {
            queryRun.get(tableNum(MCRTmpPickingWorkbenchTrans));

            // Check if a pick list should be generated.
            if (!firstTime && this.generatePicklistFromTransition(splitDeliveryPickingList, linesInPicklist))
            {
                this.createPickList(splitDeliveryPickingList);
                prevPickingWaveID = currentPickingWaveID;
                linesInPicklist = 0;
            }

            // Check if a new pick wave is needed.
            if (firstTime || this.newPickWaveTransition())
            {
                firstTime = false;
                this.setSplitByParametersFromWarehouse();
                this.createNewWave();
            }

            waveSet.add(currentPickingWaveID);

            // Update previous variables used for checking transitions.
            prevSalesId         = mcrTmpPickingWorkbenchTrans.SalesId;
            prevWarehouse       = mcrTmpPickingWorkbenchTrans.InventLocationId;
            prevShipAlone       = mcrTmpPickingWorkbenchTrans.mcrShipAlone;
            prevDlvMode         = mcrTmpPickingWorkbenchTrans.DlvMode;
            prevDeliveryName    = mcrTmpPickingWorkbenchTrans.Name;
            prevDeliveryAddress = mcrTmpPickingWorkbenchTrans.Address;
            linesInPicklist++;

            // Set the picking wave ID on the sales order line.
            // The line may have been picked in another wave, but the picking has been cancelled. If this is the case then update the wave Id
            this.writeMCRPickingWorkbenchWaveSalesLine(mcrTmpPickingWorkbenchTrans.SalesLineRecId, currentPickingWaveID);

            totalLines++;

            if (!mcrPickingWorkbenchSession.CreatedFromBatch)
            {
                progressBar.setText(strFmt("@MCR34069", totalLines, tmpTableLines)); // Processing line %1 of %2.
                progressBar.incCount();
                progressBar.update(true);
            }
        }

        // Generate last picklist (only check if any sales order was picked up).
        if (prevSalesId && currentPickingWaveID)
        {
            this.createPickList(splitDeliveryPickingList);

            if (!mcrPickingWorkbenchSession.CreatedFromBatch)
            {
                progressBar.setText("@MCR34070"); // Sorting picking groups
                progressBar.update(true);
            }

            // Sort the waves.
            this.sortPickingWaves();
        }

        // Once the picking lists has been created, then the data in the MCRPickingWorkbenchWaveSalesLine is not used.
        // So for performance reason it is cleaned up for the waves generated in this picking workbench session
        this.cleanupMCRPickingWorkbenchWaveSalesLine(waveSet);

        if (!mcrPickingWorkbenchSession.CreatedFromBatch)
        {
            progressBar.setText("@SYS54623"); // Completed
            progressBar.update(true);
            progressBar.hide();
            progressBar.kill();
        }

        // Change status of session if sales orders processed.
        if (totalLines == 0)
        {
            // No matching orders found, keep status of session as open.
            info("@MCR11404");
        }
        else
        {
            ttsbegin;
            mcrPickingWorkbenchSession_Update = MCRPickingWorkbenchSession::find(mcrPickingWorkbenchSession.SessionId, true);
            mcrPickingWorkbenchSession_Update.SessionStatus = MCRPickingSessionStatus::Created;
            if (mcrPickingWorkbenchSession_Update.validateWrite())
            {
                mcrPickingWorkbenchSession_Update.update();
            }
            else
            {
                throw error("@SYS104318");
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defaults class variables to initial values.
    /// </summary>
    void new()
    {
        prevWarehouse           = '';
        prevDlvMode             = '';
        prevSalesId             = '';
        prevDeliveryAddress     = '';
        prevDeliveryName        = '';
        prevShipAlone           = NoYes::No;

        splitByDlvMode          = NoYes::No;
        splitByShipAlone        = NoYes::No;
        maxLinesPerPicklist     = 0;

        currentPickingWaveID    = '';
        prevPickingWaveID       = '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPickWaveTransition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for transition points to create a new pick wave.
    /// </summary>
    /// <returns>
    /// true if a new pick wave should be generated; otherwise, false.
    /// </returns>
    protected boolean newPickWaveTransition()
    {
        boolean ret = false;

        if (  prevWarehouse         != mcrTmpPickingWorkbenchTrans.InventLocationId
            || (prevShipAlone       != mcrTmpPickingWorkbenchTrans.mcrShipAlone     && splitByShipAlone)
            || (prevDlvMode         != mcrTmpPickingWorkbenchTrans.DlvMode          && splitByDlvMode))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSessionParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets session parameters.
    /// </summary>
    /// <param name="_mcrPickingWorkbenchSession">
    /// The <c>MCRPickingWorkbenchSession</c> record currently being processed.
    /// </param>
    /// <param name="_promptStr">
    /// The results of a prompt for when selectic specific sales order Ids or item Ids to pick.
    /// </param>
    /// <param name="_displayWarnings">
    /// When set, warnings will be displayed to the Infolog.
    /// </param>
    void setSessionParameters(MCRPickingWorkbenchSession _mcrPickingWorkbenchSession, str _promptStr, boolean _displayWarnings)
    {
        mcrPickingWorkbenchSession = _mcrPickingWorkbenchSession;
        promptStr = _promptStr;
        displayWarnings = _displayWarnings;

        if (SalesParameters::find().PickRouteStatusOnUpdate == WMSPickRouteStatusOnUpdate::activated)
        {
            pickingListRegUsed = true;
        }
        else
        {
            pickingListRegUsed = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSplitByParametersFromWarehouse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets split by parameters based on the warehouse info of the current line.
    /// </summary>
    protected void setSplitByParametersFromWarehouse()
    {
        MCRPickingWBWarehouseInfo mcrPickingWBWarehouseInfo;

        mcrPickingWBWarehouseInfo = MCRPickingWBWarehouseInfo::find(mcrTmpPickingWorkbenchTrans.InventLocationId);
        if (mcrPickingWBWarehouseInfo)
        {
            splitByDlvMode      = mcrPickingWBWarehouseInfo.SplitByDlvMode;
            splitByShipAlone    = mcrPickingWBWarehouseInfo.SplitByShipAlone;
            maxLinesPerPicklist = mcrPickingWBWarehouseInfo.MaxLinesPerPickList;
        }
        else
        {
            splitByDlvMode      = NoYes::No;
            splitByShipAlone    = NoYes::No;
            maxLinesPerPicklist = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWarehouseSplitByExistsParams</Name>
				<Source><![CDATA[
    private void setWarehouseSplitByExistsParams(InventLocationId _inventLocationId)
    {
        MCRPickingWBWarehouseInfo mcrPickingWBWarehouseInfo;

        whExistsWithSplitByDlvMode  = false;
        whExistsSplitByShipAlone    = false;

        if (_inventLocationId)
        {
            mcrPickingWBWarehouseInfo = MCRPickingWBWarehouseInfo::find(_inventLocationId);
            if (mcrPickingWBWarehouseInfo.SplitByDlvMode)
            {
                whExistsWithSplitByDlvMode = true;
            }
            if (mcrPickingWBWarehouseInfo.SplitByShipAlone)
            {
                whExistsSplitByShipAlone = true;
            }
        }
        else
        {
            select firstonly RecId from mcrPickingWBWarehouseInfo
                where mcrPickingWBWarehouseInfo.SplitByDlvMode == NoYes::Yes;
            if (mcrPickingWBWarehouseInfo)
            {
                whExistsWithSplitByDlvMode = true;
            }
            select firstonly RecId from mcrPickingWBWarehouseInfo
                where mcrPickingWBWarehouseInfo.SplitByShipAlone == NoYes::Yes;
            if (mcrPickingWBWarehouseInfo)
            {
                whExistsSplitByShipAlone = true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sortPickingWaves</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sorts and splits up picking waves.
    /// </summary>
    protected void sortPickingWaves()
    {
        MCRPickingWorkbenchWave    mcrPickingWorkbenchWave;
        MCRPickingWBWarehouseInfo   mcrPickingWBWarehouseInfo;
        WMSPickingRoute             wmsPickingRoute;
        MCRPickingWave              pickingWaveID;
        int                         maxPicklistsPerWave;
        int                         loopCounter = 0;
        int                         pickListsInWave;

        // Loop thru each wave attached to a session.
        while select mcrPickingWorkbenchWave where mcrPickingWorkbenchWave.SessionId == mcrPickingWorkbenchSession.SessionId
        {
            mcrPickingWBWarehouseInfo = MCRPickingWBWarehouseInfo::find(mcrPickingWorkbenchWave.Warehouse);
            maxPicklistsPerWave = mcrPickingWBWarehouseInfo.MaxOrdersPerWave; // Concept of max orders is now max lists

            if (maxPicklistsPerWave)
            {
                select count(RecId) from wmsPickingRoute where wmsPickingRoute.mcrPickingWaveRef == mcrPickingWorkbenchWave.WaveReferenceId;
                pickListsInWave = int642int(wmsPickingRoute.RecId);
                pickingWaveID = mcrPickingWorkbenchWave.WaveReferenceId;
                loopCounter = 0;

                if (pickListsInWave > maxPicklistsPerWave)
                {
                    ttsbegin;
                    while select forupdate wmsPickingRoute where wmsPickingRoute.mcrPickingWaveRef == mcrPickingWorkbenchWave.WaveReferenceId
                    {
                        loopCounter++;
                        if (loopCounter > maxPickListsPerWave)
                        {
                            // Create new pickwaveID from current and update wmsPickingRoute records.
                            pickingWaveID = this.createWaveFromWave(mcrPickingWorkbenchWave);
                            loopCounter = 1; // This will be 1st in the new wave.
                        }

                        if (wmsPickingRoute.mcrPickingWaveRef != pickingWaveID)
                        {
                            // Move pick list to the new group.
                            wmsPickingRoute.mcrPickingWaveRef = pickingWaveID;
                            wmsPickingRoute.doUpdate();
                        }
                    }
                    ttscommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeMCRPickingWorkbenchWaveSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Based on Sales line RecId a row is either inserted or updated in MCRPickingWorkbenchWaveSalesLine table
    /// </summary>
    /// <param name="_salesLineRecId">
    /// RecId of the Sales line
    /// </param>
    /// <param name="_pickingWaveID">
    /// Picking wave Id to inserted or updated
    /// </param>
    private void writeMCRPickingWorkbenchWaveSalesLine(RecId _salesLineRecId, MCRPickingWave _pickingWaveID)
    {
        MCRPickingWorkbenchWaveSalesLine    mcrPickingWorkbenchWaveSalesLine;

        // Set the picking wave ID on the sales order line.
        // The line may have been picked in another wave, but the picking has been cancelled. If this is the case then update the wave Id
        ttsbegin;
        select firstonly forupdate mcrPickingWorkbenchWaveSalesLine
            where mcrPickingWorkbenchWaveSalesLine.SalesLine == _salesLineRecId;
        if (mcrPickingWorkbenchWaveSalesLine)
        {
            mcrPickingWorkbenchWaveSalesLine.PickingWorkbenchWaveId = _pickingWaveID;
            mcrPickingWorkbenchWaveSalesLine.update();
        }
        else
        {
            mcrPickingWorkbenchWaveSalesLine.SalesLine = _salesLineRecId;
            mcrPickingWorkbenchWaveSalesLine.PickingWorkbenchWaveId = _pickingWaveID;
            mcrPickingWorkbenchWaveSalesLine.insert();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAndReserveLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks a line using the <c>inventTransId</c> to see if any inventory can be reserved,
    /// and if possible reserves availabile inventory for the line.
    /// </summary>
    /// <param name="_salesLine">
    /// The sales order line to reserve inventory on.
    /// </param>
    /// <param name="_inventTransId">
    /// Inventory transaction ID of sales order line.
    /// </param>
    /// <returns>
    /// true if the sales order line contains reserved inventory; otherwise, false.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// An info log is displayed for any lines that have failed reservation.
    /// </exception>
    public static boolean checkAndReserveLine(SalesLine _salesLine, InventTransId _inventTransId)
    {
        InventTrans                 inventTrans;
        InventTrans                 inventTransPartialReserved;
        InventTransOrigin           inventTransOrigin;
        InventUpd_Reservation       inventUpd_Reservation;
        InventMovement              movement;
        boolean                     canLinesBeProcessed;
        SalesTable                  salesTable;
        boolean                     reserveInventory;
        boolean                     retValue;

        salesTable = SalesTable::find(_salesLine.SalesId);

        if (salesTable
            && !MCRCustPaymTable::isFullyAuthed(salesTable.RecId,
                                                   salesTable.TableId))
        {
            if (!MCRCustPaymTable::processIfAuthStale(salesTable.RecId))
            {
                // If the reauth does not succeed then error.
                salesTable.reread();
                return checkFailed(strFmt("@MCR37103", salesTable.SalesId));
            }
        }

        if (!InventDistinctProductValidator::checkProductNotStopped(_salesLine.ItemId, _salesLine.type().inventItemOrderSetupType(), _salesLine.inventDim(), false))
        {
            return false;
        }

        canLinesBeProcessed = SalesFormletterParmDataPickingList::mcrCanPickingWorkbenchReserve(_salesLine, salesTable);

        if (!canLinesBeProcessed)
        {
            if (MCRPickingWorkBench::lineReservedIfAuthStale(salesTable))
            {
                reserveInventory = true;
            }
            else
            {
                reserveInventory = false;
            }
        }
        else
        {
            reserveInventory = true;
        }

        if (reserveInventory == true)
        {
            while select inventTrans
                where inventTrans.StatusIssue          == StatusIssue::OnOrder
                    && inventTrans.TransChildType      == InventTransChildType::None
                    && inventTrans.StatusReceipt       == StatusReceipt::None
                exists join inventTransOrigin
                where inventTransOrigin.InventTransId  == _inventTransId
                    && inventTransOrigin.RecId         == inventTrans.InventTransOrigin
            {
                // This reservation method picks max possible based on original inventDim configurations.
                movement = InventMovement::construct(inventTrans);
                inventUpd_Reservation = InventUpd_Reservation::newMovement(movement,
                                                                            inventTrans.Qty,
                                                                            true,
                                                                            false,
                                                                            false,
                                                                            inventTrans.PdsCWQty);
                inventUpd_Reservation.updateNow();
            }
        }

        // Get total reserved physical on the sales line.
        select sum(Qty) from inventTrans
            where inventTrans.StatusIssue == StatusIssue::ReservPhysical
                && inventTrans.StatusReceipt  == StatusReceipt::None
                && inventTrans.TransChildType == InventTransChildType::None
            exists join inventTransOrigin
            where inventTransOrigin.InventTransId == _inventTransId
                && inventTransOrigin.RecId == inventTrans.InventTransOrigin;
        if (inventTrans.Qty < 0)
        {
            // Check and display log message if full amount has not been reserved.
            select sum(Qty) from inventTransPartialReserved
                where inventTransPartialReserved.StatusIssue == StatusIssue::OnOrder
                    && inventTransPartialReserved.TransChildType == InventTransChildType::None
                exists join inventTransOrigin
                where inventTransOrigin.InventTransId == _inventTransId
                    && inventTransOrigin.RecId == inventTransPartialReserved.InventTransOrigin;
            if (inventTransPartialReserved.Qty < 0)
            {
                info(strFmt("@MCR4410343", abs(inventTransPartialReserved.Qty),
                                           _salesLine.ItemId,
                                           _salesLine.SalesId));
            }

            retValue = true;
        }
        else
        {
            retValue= false;
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the class <c>MCRPickingWorkbench</c>.
    /// </summary>
    /// <param name="_mcrPickingWorkbenchSession">
    /// The picking workbench session record.
    /// </param>
    /// <param name="_promptStr">
    /// A prompt string used when picking workbench requires prompts based on selection criteria.
    /// </param>
    /// <param name="_displayWarnings">
    /// A flag to indicate whether warnings should be displayed to the Infolog.
    /// </param>
    /// <returns>
    /// An instantiation of the <c>MCRPickingWorkbench</c> class.
    /// </returns>
    public static MCRPickingWorkBench construct(MCRPickingWorkbenchSession _mcrPickingWorkbenchSession, str _promptStr, boolean _displayWarnings)
    {
        MCRPickingWorkBench mcrPickingWorkBench;

        mcrPickingWorkBench = new MCRPickingWorkBench();
        mcrPickingWorkBench.setSessionParameters(_mcrPickingWorkbenchSession, _promptStr, _displayWarnings);

        return mcrPickingWorkBench;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndPostPicklist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and post the picking list.
    /// </summary>
    /// <param name="_salesId">
    /// The sales order ID of the picking list to be posted.
    /// </param>
    /// <param name="_mcrPickingWaveRef">
    /// The picking wave ID that is being picked.
    /// </param>
    /// <param name="_checkPickingListReg">
    /// A flag to indicate if the picking list should be checked for a registered status.
    /// </param>
    public static void createAndPostPicklist(SalesIdBase _salesId, MCRPickingWave _mcrPickingWaveRef, boolean _checkPickingListReg = false)
    {
        SalesFormLetter_PickingList         pickingListFormLetter;
        SalesTable                          salesTable;
        SalesLine                           salesLine;
        MCRPickingWorkbenchWaveSalesLine    mcrPickingWorkbenchWaveSalesLine;

        // Loop through salesLines that match the picking wave reference,
        // and update their delivernow fields based on warehouse.
        ttsbegin;

        while select forupdate salesLine
            where salesLine.SalesId == _salesId
            exists join mcrPickingWorkbenchWaveSalesLine
                where mcrPickingWorkbenchWaveSalesLine.SalesLine == salesLine.RecId
                    && mcrPickingWorkbenchWaveSalesLine.PickingWorkbenchWaveId == _mcrPickingWaveRef
        {
            // Check if the line is in a picking list registration status of activated, and if so skip line.
            if (_checkPickingListReg
                &&  MCRPickingWorkBench::isPickingListRegistrationActivated(salesLine.InventTransId, _mcrPickingWaveRef))
            {
                continue;
            }

            [salesLine.InventDeliverNow,
                salesLine.PdsCWInventDeliverNow] = MCRPickingWorkBench::pickWaveInventDeliverNowQty(salesLine,
                                                                                                    _mcrPickingWaveRef);

            salesLine.SalesDeliverNow = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(salesLine.ItemId,
                                                                                                              salesLine.InventDimId,
                                                                                                              salesLine.InventDeliverNow,
                                                                                                              salesLine.inventTable().inventUnitId(),
                                                                                                              salesLine.SalesUnit,
                                                                                                              NoYes::Yes);
            if (salesLine.validateWrite())
            {
                salesLine.update();
            }
            else
            {
                throw error("@SYS104318");
            }
        }

        salesTable = SalesTable::find(_salesId);

        pickingListFormLetter = SalesFormLetter::construct(DocumentStatus::PickingList);
        pickingListFormLetter.parmMCRPickWaveReference(_mcrPickingWaveRef);
        pickingListFormLetter.reArrangeNow(false);
        pickingListFormLetter.update(salesTable,
                                DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()),
                                SalesUpdate::DeliverNow,
                                AccountOrder::None,
                                NoYes::No,
                                NoYes::No);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndPostPickListSplit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts a picking list, split by any necessary transitions.
    /// </summary>
    /// <param name="_salesId">
    /// The sales order ID of the lines being posted.
    /// </param>
    /// <param name="_mcrPickingWaveRef">
    /// The picking wave reference ID belonging to the picking list being posted.
    /// </param>
    /// <param name="_dlvMode">
    /// The delivery mode ID of the lines being posted.
    /// </param>
    /// <param name="_name">
    /// The delivery name of the lines being posted.
    /// </param>
    /// <param name="_address">
    /// The delivery address of the lines being posted.
    /// </param>
    /// <param name="_checkPickingListReg">
    /// Flag to indicate if need to check picking list registration status.
    /// </param>
    /// <remarks>
    /// Posts a picking list by setting the <c>SalesDeliveryNow</c> and <c>InventDeliverNow</c> fields on the <c>Salesline</c> record.
    /// </remarks>
    public static void createAndPostPickListSplit(
        SalesIdBase     _salesId,
        MCRPickingWave  _mcrPickingWaveRef,
        CustDlvModeId   _dlvMode,
        Name            _name,
        Addressing      _address,
        boolean         _checkPickingListReg = false)
    {
        SalesFormLetter_PickingList pickingListFormLetter;
        SalesTable                          salesTable;
        SalesLine                           salesLine;
        LogisticsPostalAddress              logisticsPostalAddress;
        MCRPickingWorkbenchWaveSalesLine    mcrPickingWorkbenchWaveSalesLine;

        boolean isSkipCountryRegionAddressCompare = MCRPickingWorkBench::isSkipCountryRegionAddressCompare(_salesId);

        // Loop through saleslines that match the pickwaveref,
        // and update their delivernow fields based on warehouse.
        ttsbegin;

        while select forupdate salesLine
            where salesLine.SalesId        == _salesId
               && salesLine.DlvMode        == _dlvMode
               && salesLine.DeliveryName   == _name
            exists join logisticsPostalAddress
                where salesLine.DeliveryPostalAddress == logisticsPostalAddress.RecId
                    && (mcrPickingWorkBench::shouldCreateAndPostPickListSplitSkipConditionOnAddresses()
                        || logisticsPostalAddress.Address  == _address
                        || isSkipCountryRegionAddressCompare)
            exists join mcrPickingWorkbenchWaveSalesLine
                where mcrPickingWorkbenchWaveSalesLine.SalesLine == salesLine.RecId
                    && mcrPickingWorkbenchWaveSalesLine.PickingWorkbenchWaveId == _mcrPickingWaveRef
        {
            // Check if the line is in a picking list registration status of activated, and if so skip line.
            if (_checkPickingListReg
                &&  MCRPickingWorkBench::isPickingListRegistrationActivated(salesLine.InventTransId, _mcrPickingWaveRef))
            {
                continue;
            }

            [salesLine.InventDeliverNow,
                salesLine.PdsCWInventDeliverNow] = MCRPickingWorkBench::pickWaveInventDeliverNowQty(salesLine,
                                                                                                    _mcrPickingWaveRef);

            salesLine.SalesDeliverNow = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(salesLine.ItemId,
                                                                                                              salesLine.InventDimId,
                                                                                                              salesLine.InventDeliverNow,
                                                                                                              salesLine.inventTable().inventUnitId(),
                                                                                                              salesLine.SalesUnit,
                                                                                                              NoYes::Yes);

            if (salesLine.validateWrite())
            {
                salesLine.update();
            }
            else
            {
                throw error("@SYS104318");
            }
        }
        ttscommit;

        select firstonly salesTable where salesTable.SalesId == _salesId;

        pickingListFormLetter = SalesFormLetter::construct(DocumentStatus::PickingList);
        pickingListFormLetter.parmMCRPickWaveReference(_mcrPickingWaveRef);
        pickingListFormLetter.update(
            salesTable,
            DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()),
            SalesUpdate::DeliverNow,
            AccountOrder::None,
            NoYes::No,
            NoYes::No);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSkipCountryRegionAddressCompare</Name>
				<Source><![CDATA[
    private static boolean isSkipCountryRegionAddressCompare(SalesId _salesId)
    {
        boolean ret = false;

        if (MCRPickingWorkBenchAddressFmtCountryRegionExpandOnFlight::instance().isEnabled()
            && _salesId
            && SalesParameters::find().SplitDeliveryPickingList)
        {
            LogisticsPostalAddress logisticsPostalAddressFormat;
            logisticsPostalAddressFormat = SalesTable::find(_salesId).deliveryAddress();
            LogisticsAddressCountryRegion countryRegion = LogisticsAddressCountryRegion::find(logisticsPostalAddressFormat.CountryRegionId);

            LogisticsAddressFormatLines formatLines;
            select firstonly Expand from formatLines
                where formatLines.AddrFormat    == countryRegion.AddrFormat
                   && formatLines.Element       == LogisticsAddressElement::CountryRegion;

            if (formatLines.Expand)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPickingListRegistrationActivated</Name>
				<Source><![CDATA[
    private static boolean isPickingListRegistrationActivated(InventTransId _inventTransId, MCRPickingWave _mcrPickingWaveRef)
    {
        WMSOrderTrans   wmsOrderTrans;
        WMSPickingRoute wmsPickingRoute;
        boolean ret = false;

        select firstonly RecId from wmsOrderTrans
            where wmsOrderTrans.InventTransId == _inventTransId
                &&  wmsOrderTrans.ExpeditionStatus == WMSExpeditionStatus::Activated
            exists join PickingRouteID, mcrPickingWaveRef, RecId from wmsPickingRoute
                where wmsPickingRoute.PickingRouteID == wmsOrderTrans.RouteId
                    && wmsPickingRoute.mcrPickingWaveRef == _mcrPickingWaveRef;
        if (wmsOrderTrans)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineReservedIfAuthStale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks sales paramter flag to see if inventory should be reserved in cases
    /// of credit card stale authorization.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order record in which checking credit card authorization.
    /// </param>
    /// <returns>
    /// true if inventory should be reserved; otherwise, fales.
    /// </returns>
    public static boolean lineReservedIfAuthStale(SalesTable _salesTable)
    {
        MCROrderParameters mcrOrderParameters;
        boolean reserveInvent= false;
        boolean isAuthed;

        isAuthed = MCRCustPaymTable::isFullyAuthed(_salesTable.RecId, tableNum(SalesTable));

        if (isAuthed)
        {
            mcrOrderParameters = MCROrderParameters::find();
            if (mcrOrderParameters.mcrReserveInventAuthStale == NoYes::Yes)
            {
                reserveInvent = true;
            }
            else
            {
                reserveInvent = false;
            }
        }
        else
        {
            // If auth is not stale or if the payment is by any other
            // form of payment we still need to reserve inventory.
            reserveInvent = true;
        }
        return reserveInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxOrdersPerWaveForWarehouse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the maximum orders per picking wave for the specified warehouse.
    /// </summary>
    /// <param name="_warehouse">
    /// The inventory location ID.
    /// </param>
    /// <returns>
    /// The max orders per wave for a given warehouse.  If there is no maximum, than a value of '0' will be returned.
    /// </returns>
    public static int maxOrdersPerWaveForWarehouse(InventLocationId _warehouse)
    {
        MCRPickingWBWarehouseInfo mcrPickingWBWarehouseInfo;

        select firstonly MaxOrdersPerWave from mcrPickingWBWarehouseInfo
            where mcrPickingWBWarehouseInfo.Warehouse == _warehouse;

        return mcrPickingWBWarehouseInfo.MaxOrdersPerWave;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGenerateWavesLogic</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates and posts waves for a picking workbench session.
    /// </summary>
    /// <param name="_mcrPickingWorkbenchSession">
    /// The picking session being processed.
    /// </param>
    /// <param name="_promptStr">
    /// A prompt string used when picking workbench requires prompts based on selection criteria.
    /// </param>
    /// <param name="_displayWarnings">
    /// A flag that when set, will display warnings to the InfoLog.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Throws an error if the status of picking session is not open.
    /// </exception>
    public static void mcrGenerateWavesLogic(MCRPickingWorkbenchSession _mcrPickingWorkbenchSession, str _promptStr = "", boolean _displayWarnings = false)
    {
        MCRPickingWorkBench mcrPickingWorkBench;

        // Check status that waves have not already been generated or posted.
        if (_mcrPickingWorkbenchSession.SessionStatus != MCRPickingSessionStatus::Open)
        {
            throw error("@MCR11334");
        }

        mcrPickingWorkBench = MCRPickingWorkBench::construct(_mcrPickingWorkbenchSession, _promptStr, _displayWarnings);
        mcrPickingWorkBench.generateWaves();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickWaveInventDeliverNowQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the max inventory delivery now quantity of a sales order line based on the
    /// inventory transactions selected warehouse and the current picking wave's warehouse.
    /// </summary>
    /// <param name="_salesLine">
    /// The sales line record being processed.
    /// </param>
    /// <param name="_pickingWaveRef">
    /// The picking wave reference ID of the wave being picked.
    /// </param>
    /// <returns>
    /// A container consisting of the max inventory delivery now quantity and catch weight qty
    /// that can be picked for a sales line based on picking wave.
    /// </returns>
    public static container pickWaveInventDeliverNowQty(SalesLine _salesLine, MCRPickingWave _pickingWaveRef)
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;
        InventDim           inventDim;
        InventQty           qtyToPick;
        PdsCWInventQty      cwQtyToPick;
        InventLocationId    warehouseToPick;

        warehouseToPick = MCRPickingWorkbenchWave::find(_pickingWaveRef).Warehouse;

        select sum(Qty), sum(PdsCWQty) from  inventTrans
            where inventTrans.StatusIssue == StatusIssue::ReservPhysical
                    && inventTrans.StatusReceipt       == StatusReceipt::None
            exists join inventTransOrigin
                where inventTransOrigin.InventTransId  == _salesLine.InventTransId
                    && inventTransOrigin.RecId == inventTrans.InventTransOrigin
            exists join inventDim
                where inventDim.InventDimId == inventTrans.InventDimId
                    && inventDim.InventLocationId == warehouseToPick;

        qtyToPick   = abs(inventTrans.Qty);
        cwQtyToPick = abs(inventTrans.PdsCWQty);

        return [qtyToPick, cwQtyToPick];
    }

]]></Source>
			</Method>
			<Method>
				<Name>printPickLists</Name>
				<Source><![CDATA[
    private static void printPickLists(MCRPickingWorkbenchWave _pickWaveToPrint)
    {
        WMSPickingRoute         wmsPickingRoute;
        RecordSortedList        recordSortedList;
        MCRPickingWorkbenchWave mcrPickingWorkbenchWave;
        Args                    args = new Args();

        args.menuItemType(MenuItemType::Display);
        args.menuItemName(menuItemDisplayStr(mcrPickingWorkBench));
        while select wmsPickingRoute
            where   wmsPickingRoute.mcrPickingWaveRef == _pickWaveToPrint.WaveReferenceId
                &&  wmsPickingRoute.ExpeditionStatus  != WMSExpeditionStatus::Cancelled
        {
            recordSortedList = new RecordSortedList(tableNum(WMSPickingRoute));
            recordSortedList.ins(wmsPickingRoute);
            args.object(recordSortedList);
            WMSPickingList_OrderPick::main(args);
        }

         // Update status to created.
        if (_pickWaveToPrint.WaveStatus == MCRPickingWaveStatus::Created)
        {
            update_recordset mcrPickingWorkbenchWave
                setting WaveStatus = MCRPickingWaveStatus::Printed
                    where mcrPickingWorkbenchWave.WaveReferenceId == _pickWaveToPrint.WaveReferenceId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printPickWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints the picking wave header and picking lists assoicated with a picking workbench batch.
    /// </summary>
    /// <param name="_pickWaveToPrint">
    /// The picking wave to print.
    /// </param>
    /// <param name="_warnIfCompleted">
    /// A lag to indicate if the user should be warned when trying to print a completed picking wave.
    /// </param>
    public static void printPickWave(MCRPickingWorkbenchWave _pickWaveToPrint, boolean _warnIfCompleted = true)
    {
        Args                            argsHeader;
        DialogButton                    dialogButton;

        // If wave already completed, give warning and prompt for continuation.
        if (_warnIfCompleted && (_pickWaveToPrint.WaveStatus == MCRPickingWaveStatus::Completed))
        {
            dialogButton = Box::okCancel(strFmt("@MCR11412", _pickWaveToPrint.WaveReferenceId),
                                                            DialogButton::Ok, "@SYS866");
            if (dialogButton == DialogButton::Cancel)
            {
                return;
            }
        }

        // print the pick wave header
        argsHeader = new Args();
        argsHeader.menuItemType(MenuItemType::Display);
        argsHeader.menuItemName(menuItemDisplayStr(MCRPickingWorkbench));
        argsHeader.parm(_pickWaveToPrint.WaveReferenceId);

        argsHeader.name(classStr(MCRPickWaveHeaderController));
        MCRPickWaveHeaderController::main(argsHeader);

        // Print the picklists associated with a wave
        MCRPickingWorkBench::printPickLists(_pickWaveToPrint);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateAndPostPickListSplitSkipConditionOnAddresses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decides if pick list should be created and posted to split by skipping delivery address checking.
    /// </summary>
    /// <returns>
    /// true if checking delivery address should be skipped when splitting picking list; otherwise, false.
    /// </returns>
    protected static boolean shouldCreateAndPostPickListSplitSkipConditionOnAddresses()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSessionPrintStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of a picking workbench session based on waves that have been printed.
    /// </summary>
    /// <param name="_mcrPickingWorkbenchSession">
    /// The picking workbench session being processed.
    /// </param>
    /// <returns>
    /// true if the picking workbench session status changed; otherwise, false.
    /// </returns>
    public static boolean updateSessionPrintStatus(MCRPickingWorkbenchSession _mcrPickingWorkbenchSession)
    {
        boolean                     changeMade = false;
        boolean                     allWavesPrinted;
        MCRPickingWorkbenchWave    mcrPickingWorkbenchWave;
        MCRPickingWorkbenchSession mcrPickingWorkbenchSessionLocal;

        if ((_mcrPickingWorkbenchSession.SessionStatus == MCRPickingSessionStatus::Created)
            || (_mcrPickingWorkbenchSession.SessionStatus == MCRPickingSessionStatus::PartiallyPrinted))
        {
            changeMade = true;
            allWavesPrinted = true;
            select firstonly RecId from mcrPickingWorkbenchWave
                where mcrPickingWorkbenchWave.SessionId == _mcrPickingWorkbenchSession.SessionId
                    && mcrPickingWorkbenchWave.WaveStatus == MCRPickingWaveStatus::Created;
            if (mcrPickingWorkbenchWave)
            {
                allWavesPrinted = false;
            }

            ttsbegin;
            select forupdate mcrPickingWorkbenchSessionLocal
                where mcrPickingWorkbenchSessionLocal.SessionId == _mcrPickingWorkbenchSession.SessionId;

            if (allWavesPrinted)
            {
                mcrPickingWorkbenchSessionLocal.SessionStatus = MCRPickingSessionStatus::Printed;
            }
            else
            {
                mcrPickingWorkbenchSessionLocal.SessionStatus = MCRPickingSessionStatus::PartiallyPrinted;
            }

            mcrPickingWorkbenchSessionLocal.update();
            ttscommit;
        }
        return changeMade;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>