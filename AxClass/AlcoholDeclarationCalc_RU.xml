<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AlcoholDeclarationCalc_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>AlcoholDeclarationCalc_RU</c> class and its child classes perform calculation
///    of data which have to be printed or electronically sent in the alcohol declaration.
/// </summary>
abstract class AlcoholDeclarationCalc_RU extends RunBase
{
    private AlcoholDeclarationJournalTable_RU           journalTable;
    private AlcoholDeclarationJournalTrans_RU           journalTrans;
    protected AlcoholDeclarationJournalTransBranch_RU   journalTransBranch;
    protected FromDate                                  fromDate;
    protected ToDate                                    toDate;
    protected Branches_RU                               branch;
    protected KeySum                                    keySumReceiptIssue, keySumMovement;
    protected container                                   valueCon;
    protected CompanyInfo                               companyInfo;
    protected InventParameters                          inventParameters;
    protected UnitOfMeasureSymbol                       toUnitOfMeasureSymbol;

    protected AlcoholDeclarationPeriodNum_RU            currentPeriodNum;
    protected AlcoholDeclarationFiscalYear_RU           currentFiscalYear;

    protected boolean                                   calcReceipt, calcIssue, calcMovement;
    protected boolean                                   recalcReceiptIssue;

    protected Common                                    common;
    private Query                                       query;

    protected const int QuartersPerYear = 4;
    protected const int ReceiptIssueKeyLength = 11;
    protected const int ReceiptIssueValueLength = 1;
    protected const int MovementKeyLength = 4;
    protected const int MovementValueLength = 12;

    protected const int ManufacturerPurchQtyPos = 1;
    protected const int WholesalePurchQtyPos = 2;
    protected const int ImportPurchQtyPos = 3;
    protected const int PurchReturnQtyPos = 4;
    protected const int OtherRecieptQtyPos = 5;
    protected const int InternalTransferReceiptQtyPos = 6;

    protected const int WholesaleSalesQtyPos = 7;
    protected const int RetailSalesQtyPos = 8;
    protected const int ExportSalesQtyPos = 9;
    protected const int OtherIssueQtyPos = 10;
    protected const int SalesReturnQtyPos = 11;
    protected const int InternalTransferIssueQtyPos = 12;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>activityType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the activity type (wholesale or retail) of the current child of the <c>AlcoholDeclarationCalc_RU</c> class.
    /// </summary>
    /// <returns>
    ///    The activity type to which the current object relates.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden in the child classes.
    /// </remarks>
    protected AlcoholActivityType_RU activityType()
    {
        throw error(strFmt("@SYS18885", funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void calc()
    {
        try
        {
            ttsBegin;
            this.init();
            this.preCalc();
            this.process();
            ttsCommit;
        }
        catch(Exception::Deadlock)
        {
            retry;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code which checks if the class can run.
    /// </summary>
    /// <returns>
    ///    Always true.
    /// </returns>
    public boolean check()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createKeyMovement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates key for the <c>KeySum</c> object where the data are stored before saving to the tables. Relates to the movement calculation.
    /// </summary>
    /// <param name="_transDate">
    ///    The date to which the data should relate.
    /// </param>
    /// <param name="_inventTable">
    ///    The inventory table record which contains necessary data to construct the key.
    /// </param>
    /// <returns>
    ///    The container which is used as a key in the <c>KeySum</c> object.
    /// </returns>
    protected container createKeyMovement(TransDate     _transDate,
                                          InventTable   _inventTable)
    {
        return [_inventTable.AlcoholProductionTypeId_RU,
                _inventTable.AlcoholManufacturerId_RU,
                this.getPeriodNum(_transDate),
                year(_transDate)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createKeyReceiptIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>KeySum</c> object when calculating receips/issues.
    /// </summary>
    /// <param name="_alcoholDeclarationTransType">
    ///    The line type (receipt or issue).
    /// </param>
    /// <param name="_inventTable">
    ///    <c>InventTable</c> record which contains data necessary for the update.
    /// </param>
    /// <param name="_inventDim">
    ///    <c>InventDim</c> record which contains data necessary for the update.
    /// </param>
    /// <param name="_licenseSeriesNum">
    ///    Alcohol license series and num.
    /// </param>
    /// <param name="_custVendInvoiceJour">
    ///    <c>CustInvoiceJour</c> or <c>VendInvoiceJour</c> record.
    /// </param>
    /// <param name="_documentDate">
    ///    Date to which the data from the <c>InventTrans</c> should relate.
    /// </param>
    /// <param name="_inventTrans">
    ///    <c>InventTrans</c> record which contains data necessary for the update.
    /// </param>
    /// <param name="_inventTransOrigin">
    ///    <c>InventTransOrigin</c> record which contains data necessary for the update.
    /// </param>
    /// <param name="_isReturn">
    ///    Boolean parameter showing if a return sign should be set.
    /// </param>
    /// <returns>
    ///    The container which is used as a key in the <c>KeySum</c> object.
    /// </returns>
    protected container createKeyReceiptIssue(AlcoholDeclarationTransType_RU      _alcoholDeclarationTransType,
                                              InventTable                         _inventTable,
                                              InventDim                           _inventDim,
                                              AlcoholLicenseSeriesNum_RU          _licenseSeriesNum,
                                              CustVendInvoiceJour                 _custVendInvoiceJour,
                                              DocumentDate                        _documentDate,
                                              InventTrans                         _inventTrans,
                                              InventTransOrigin                   _inventTransOrigin,
                                              NoYes                               _isReturn)
    {
        if (! keySumReceiptIssue)
        {
            keySumReceiptIssue  = KeySum::construct(ReceiptIssueKeyLength, ReceiptIssueValueLength);
        }

        return [_alcoholDeclarationTransType,
                _inventTable.AlcoholProductionTypeId_RU,
                _inventTable.AlcoholManufacturerId_RU,
                _custVendInvoiceJour.InvoiceAccount,
                _inventTransOrigin.ReferenceCategory == InventTransType::Purch ? CustVend_RU::Vend : CustVend_RU::Cust,
                _licenseSeriesNum,
                _inventTrans.DateFinancial,
                _custVendInvoiceJour.InvoiceId,
                _inventDim.InventGtdId_RU,
                _isReturn,
                this.getPeriodNum(_documentDate),
                year(_documentDate)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>declarationType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the declaration type of the current child of the <c>AlcoholDeclarationCalc_RU</c> class.
    /// </summary>
    /// <returns>
    ///    The declaration type to which the current object corresponds.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden in the child classes.
    /// </remarks>
    protected AlcoholDeclarationType_RU declarationType()
    {
        throw error(strFmt("@SYS18885", funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRecords</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the previously created calculation results.
    /// </summary>
    /// <remarks>
    ///    Should be overridden in the child classes.
    /// </remarks>
    protected void deleteRecords()
    {
        throw error(strFmt("@SYS18885", funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRecordsMovement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the previously created movement results.
    /// </summary>
    /// <param name="_declarationType">
    ///    The alcohol declaration type for which the data should be deleted.
    /// </param>
    protected void deleteRecordsMovement(AlcoholDeclarationType_RU  _declarationType = this.declarationType())
    {
        AlcoholDeclarationTransMovement_RU      declarationTrans;
        AlcoholDeclarationJournalTable_RU       journalTableLocal;

        delete_from declarationTrans
            where declarationTrans.AlcoholDeclarationType == _declarationType
               && declarationTrans.BranchId               == journalTransBranch.BranchId
        exists join journalTableLocal
            where journalTableLocal.JournalId  == declarationTrans.JournalId
               && journalTableLocal.PeriodType == journalTable.PeriodType
               && journalTableLocal.PeriodNum  == journalTable.PeriodNum
               && journalTableLocal.FiscalYear == journalTable.FiscalYear;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRecordsReceiptIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the previously created receipt/issue results.
    /// </summary>
    /// <param name="_declarationTransType">
    ///    The lines type (receipt or issue) which has to be deleted from the <c>AlcoholDeclarationTrans_RU</c> table.
    /// </param>
    /// <param name="_declarationType">
    ///    The alcohol declaration type for which the data should be deleted.
    /// </param>
    protected void deleteRecordsReceiptIssue(AlcoholDeclarationTransType_RU _declarationTransType,
                                             AlcoholDeclarationType_RU      _declarationType = this.declarationType())
    {
        AlcoholDeclarationTrans_RU          declarationTrans;
        AlcoholDeclarationJournalTable_RU   journalTableLocal;

        delete_from declarationTrans
            where declarationTrans.AlcoholDeclarationType == _declarationType
               && declarationTrans.BranchId               == journalTransBranch.BranchId
               && declarationTrans.Type                   == _declarationTransType
        exists join journalTableLocal
            where journalTableLocal.JournalId  == declarationTrans.JournalId
               && journalTableLocal.PeriodType == journalTable.PeriodType
               && journalTableLocal.PeriodNum  == journalTable.PeriodNum
               && journalTableLocal.FiscalYear == journalTable.FiscalYear;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds <c>CustInvoiceTrans</c> or <c>VendInvoiceTrans</c> record by <c>InventTrans</c> record.
    /// </summary>
    /// <param name="_inventTrans">
    ///    <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventTransOrigin">
    ///    <c>InventTransOrigin</c> record.
    /// </param>
    /// <returns>
    ///    CustVendInvoiceTrans map initialized byt the found <c>CustInvoiceTrans</c> or <c>VendInvoiceTrans</c>.
    /// </returns>
    protected CustVendInvoiceTrans getCustVendInvoiceTrans(InventTrans          _inventTrans,
                                                           InventTransOrigin    _inventTransOrigin)
    {
        CustVendInvoiceTrans    custVendInvoiceTrans;
        VendInvoiceTrans        vendInvoiceTrans;
        CustInvoiceTrans        custInvoiceTrans;
        RefRecId                refRecId;

        switch (_inventTransOrigin.ReferenceCategory)
        {
            case InventTransType::Sales:
                custVendInvoiceTrans = custInvoiceTrans;
                break;

            case InventTransType::Purch:
                custVendInvoiceTrans = vendInvoiceTrans;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcname()));
        }

        select firstonly custVendInvoiceTrans
            where custVendInvoiceTrans.InventTransId == _inventTransOrigin.InventTransId
               && custVendInvoiceTrans.InvoiceDate   == _inventTrans.DateFinancial
               && custVendInvoiceTrans.InvoiceNum    == _inventTrans.InvoiceId;

        refRecId = custVendInvoiceTrans.CustVendInvoiceTrans::refAdjustedTrans_RU();

        if (refRecId && refRecId != custVendInvoiceTrans.RecId)
        {
            select firstonly custVendInvoiceTrans
                where custVendInvoiceTrans.RecId == refRecId;
        }

        return custVendInvoiceTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPeriodNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates a quarter number to which the date passed belongs.
    /// </summary>
    /// <param name="_transDate">
    ///    The date for the period number should be defined.
    /// </param>
    /// <returns>
    ///    Quarter number in the year.
    /// </returns>
    protected AlcoholDeclarationPeriodNum_RU getPeriodNum(TransDate  _transDate)
    {
        const int monthsPerQuarter = 3;
        AlcoholDeclarationPeriodNum_RU periodNum;

        periodNum = mthofyr(_transDate) div monthsPerQuarter;

        if (periodNum * monthsPerQuarter < mthofyr(_transDate))
        {
            periodNum++;
        }

        return periodNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPeriodStartQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the period start quantity of the item for the period being calculated.
    /// </summary>
    /// <param name="_declarationTrans">
    ///    <c>AlcoholDeclarationTransMovement_RU</c> record for which the period start quantity is being calculated.
    /// </param>
    /// <param name="_periodNum">
    ///    Number of period being calculated.
    /// </param>
    /// <param name="_fiscalYear">
    ///    Fiscal year to which the data being calculated relate.
    /// </param>
    /// <returns>
    ///    Quantity at the start of period.
    /// </returns>
    protected Amount getPeriodStartQty(AlcoholDeclarationTransMovement_RU   _declarationTrans,
                                       AlcoholDeclarationPeriodNum_RU       _periodNum,
                                       AlcoholDeclarationFiscalYear_RU      _fiscalYear)
    {
        AlcoholDeclarationJournalTable_RU           prevJournalTable, curJournalTable;
        AlcoholDeclarationJournalTransBranch_RU     prevJournalTransBranch;
        AlcoholDeclarationPeriodNum_RU              prevPeriodNum;
        AlcoholDeclarationFiscalYear_RU             prevFiscalYear;
        AlcoholDeclarationTransMovement_RU          declarationTrans;
        Amount                                      ret = 0;

        InventSumDateDim                            inventSumDateDim;
        InventDim                                   inventDimCriteria;
        InventDimParm                               inventDimParm;
        InventTable                                 inventTable;
        InventLocation                              inventLocation;
        TransDate                                   perDate;
        InventProfile_RU                            inventProfile;
        InventSum                                   inventSum;

        // In order to define period start quantity data of previous period should be analyzed

        prevPeriodNum   = _periodNum - 1;
        prevFiscalYear  = _fiscalYear;

        if (prevPeriodNum == 0)
        {
            prevPeriodNum  = QuartersPerYear;
            prevFiscalYear = prevFiscalYear - 1;
        }

        select firstonly RecId from prevJournalTransBranch
            order by CorrectionNum desc
            where prevJournalTransBranch.BranchId               == journalTransBranch.BranchId
               && prevJournalTransBranch.AlcoholDeclarationType == journalTransBranch.AlcoholDeclarationType
        join declarationTrans
            where declarationTrans.JournalId                == prevJournalTransBranch.JournalId
               && declarationTrans.AlcoholDeclarationType   == prevJournalTransBranch.AlcoholDeclarationType
               && declarationTrans.BranchId                 == prevJournalTransBranch.BranchId
               && declarationTrans.AlcoholProductionTypeId  == _declarationTrans.AlcoholProductionTypeId
               && declarationTrans.ManufacturerId           == _declarationTrans.ManufacturerId
        exists join prevJournalTable
            where prevJournalTable.JournalId            == prevJournalTransBranch.JournalId
               && prevJournalTable.CorrectedPeriodNum   == prevPeriodNum
               && prevJournalTable.CorrectedFiscalYear  == prevFiscalYear
               && prevJournalTable.PeriodType           == journalTable.PeriodType;

        if (declarationTrans)
        {
            ret = declarationTrans.PeriodEndQty;
        }
        else
        {
            select firstonly FromDate from prevJournalTable
                where prevJournalTable.PeriodNum   == _periodNum
                   && prevJournalTable.FiscalYear  == _fiscalYear;

            perDate = prevJournalTable.FromDate - 1;

            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                // calculate inventory remains
                while select InventLocationId from inventLocation
                    where inventLocation.VendAccount == branch.VendAccount
                {
                    while select InventProfileId from inventProfile
                        where inventProfile.AlcoholActivityType == this.activityType()
                    {
                        while select inventTable
                            where inventTable.AlcoholProductionTypeId_RU    == _declarationTrans.AlcoholProductionTypeId
                               && (   inventTable.AlcoholManufacturerId_RU  == _declarationTrans.ManufacturerId
                                   || ! _declarationTrans.ManufacturerId)
                            join InventDimId, #InventDimGroupAllFields from inventSum
                                where inventSum.ItemId              == inventTable.itemId
                                &&    inventSum.InventLocationId    == inventLocation.InventLocationId
                                &&    inventSum.InventProfileId_RU  == inventProfile.InventProfileId
                        {
                            inventDimCriteria.clear();
                            inventDimCriteria.initFromInventSum(inventSum);

                            inventDimParm.initFromInventDim(inventDimCriteria);
                            inventSumDateDim = InventSumDateDim::newParameters(perDate, inventTable.ItemId, inventDimCriteria, inventDimParm);
                            ret += this.calculateVolume(inventSumDateDim.postedQty(), inventTable, inventSum.InventDimId);
                        }
                    }
                }
            }
            else
            {
                // calculate inventory remains
                while select InventLocationId from inventLocation
                    where inventLocation.VendAccount == branch.VendAccount
                {
                    while select InventProfileId from inventProfile
                        where inventProfile.AlcoholActivityType == this.activityType()
                    {
                        while select inventTable
                            where inventTable.AlcoholProductionTypeId_RU    == _declarationTrans.AlcoholProductionTypeId
                               && (   inventTable.AlcoholManufacturerId_RU  == _declarationTrans.ManufacturerId
                                   || ! _declarationTrans.ManufacturerId)
                            join inventSum
                                where inventSum.ItemId == inventTable.itemId
                            join inventDimCriteria
                                where InventDimCriteria.inventDimId         == inventSum.InventDimId
                                &&    inventDimCriteria.InventLocationId    == inventLocation.InventLocationId
                                &&    inventDimCriteria.InventProfileId_RU  == inventProfile.InventProfileId
                        {
                            inventDimParm.initFromInventDim(inventDimCriteria);
                            inventSumDateDim = InventSumDateDim::newParameters(perDate, inventTable.ItemId, inventDimCriteria, inventDimParm);
                            ret += this.calculateVolume(inventSumDateDim.postedQty(), inventTable, inventSum.InventDimId);
                        }
                    }
                }
            }
        }

        // Now all the movement should be added except the movement in the line for which the start period quantity is being calculated

        select sum(TotalReceiptQty), sum(TotalIssueQty) from declarationTrans
            where declarationTrans.AlcoholDeclarationType   == journalTransBranch.AlcoholDeclarationType
               && declarationTrans.BranchId                 == journalTransBranch.BranchId
               && declarationTrans.AlcoholProductionTypeId  == _declarationTrans.AlcoholProductionTypeId
               && declarationTrans.ManufacturerId           == _declarationTrans.ManufacturerId
               && declarationTrans.RecId                    != _declarationTrans.RecId
        exists join curJournalTable
            where curJournalTable.JournalId == declarationTrans.JournalId
               && curJournalTable.CorrectedPeriodNum   == _periodNum
               && curJournalTable.CorrectedFiscalYear  == _fiscalYear;

        ret = ret + declarationTrans.TotalReceiptQty - declarationTrans.TotalIssueQty;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the <c>TransDate</c> to which the quantyty from the <c>InventTrans</c> record should relate.
    /// </summary>
    /// <param name="_inventTrans">
    ///    <c>InventTrans</c> record.
    /// </param>
    /// <param name="_custVendinvoiceJour">
    ///    <c>CustInvoiceJour</c> or <c>VendInvoiceJour</c> record.
    /// </param>
    /// <returns>
    ///    TransDate.
    /// </returns>
    protected TransDate getTransDate(InventTrans            _inventTrans,
                                     CustVendInvoiceJour    _custVendinvoiceJour)
    {
        TransDate       transDate;

        transDate = this.isDaily() ? _inventTrans.DateFinancial :
                                    (_custVendinvoiceJour.DocumentDate ? _custVendinvoiceJour.DocumentDate
                                                                       : _custVendinvoiceJour.InvoiceDate);

        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateVolume</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the volume in dal/liters based on the quantity in the inventory transaction.
    /// </summary>
    /// <param name="_qty">
    ///    Quantity from <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventTable">
    ///    <c>InventTable</c> record corresponding to the item in the <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventDimId">The dimension ID to use for conversion.</param>
    /// <returns>
    ///    Volume in dal/liters to be saved in the calculation results.
    /// </returns>
    protected Qty calculateVolume(
        InventQty   _qty,
        InventTable _inventTable,
        InventDimId _inventDimId)
    {
        Qty qty = _qty;
        
        if (inventParameters.AlcoholConsiderStrength_RU)
        {
            qty = qty * _inventTable.AlcoholStrength_RU / 100;
        }

        qty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_inventTable.ItemId,
                                                                                    _inventDimId,
                                                                                    qty,
                                                                                    _inventTable.inventUnitId(),
                                                                                    toUnitOfMeasureSymbol,
                                                                                    NoYes::Yes);

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVolumeIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the quantity in units in which the data should be stored in the Issue section.
    /// </summary>
    /// <param name="_inventTrans">
    ///    <c>InventTrans</c> record being analyzed.
    /// </param>
    /// <param name="_inventTable">
    ///    <c>InventTable</c> record corresponding to the item in the <c>InventTrans</c> record.
    /// </param>
    /// <returns>
    ///    The quantity in units in which the data should be stored in the Issue section.
    /// </returns>
    /// <remarks>
    ///    Units in which the data is calculated for Movement and Receipt/Issue sections can be different.
    ///    In such case this method is overridden.
    /// </remarks>

    protected Qty getVolumeIssue(InventTrans     _inventTrans,
                                 InventTable     _inventTable)
    {
        return this.calculateVolume(_inventTrans.Qty, _inventTable, '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVolumeReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the quantity in units in which the data should be stored in the Receipt section.
    /// </summary>
    /// <param name="_inventTrans">
    ///    <c>InventTrans</c> record being analyzed.
    /// </param>
    /// <param name="_inventTable">
    ///    <c>InventTable</c> record corresponding to the item in the <c>InventTrans</c> record.
    /// </param>
    /// <returns>
    ///    The quantity in units in which the data should be stored in the Receipt section.
    /// </returns>
    /// <remarks>
    ///    Units in which the data is calculated for Movement and Receipt/Issue sections can be different.
    ///    In such case this method is overridden.
    /// </remarks>

    protected Qty getVolumeReceipt(InventTrans     _inventTrans,
                                   InventTable     _inventTable)
    {
        return this.calculateVolume(_inventTrans.Qty, _inventTable, '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes variables which will be often used during calculation.
    /// </summary>
    /// <returns>
    ///    Always true.
    /// </returns>
    public boolean init()
    {
        journalTransBranch      = common;
        journalTrans            = journalTransBranch.journalTrans();
        journalTable            = journalTrans.journalTable();

        fromDate                = journalTable.FromDate;
        toDate                  = journalTable.ToDate;
        currentPeriodNum        = journalTable.PeriodNum;
        currentFiscalYear       = journalTable.FiscalYear;

        branch                  = Branches_RU::find(journalTransBranch.BranchId);
        companyInfo             = CompanyInfo::find();
        inventParameters        = InventParameters::find();
        toUnitOfMeasureSymbol   = inventParameters.AlcoholUnitId_RU;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initKeySum</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes <c>KeySum</c> objects: one or two, depending on the data which have to be calculated.
    /// </summary>
    private void initKeySum()
    {
        int i;

        if (calcMovement)
        {
            keySumMovement = KeySum::construct(MovementKeyLength, MovementValueLength);
            for (i = 1; i <= MovementValueLength; i++)
            {
                valueCon += 0;
            }
        }

        if (calcReceipt || calcIssue)
        {
            keySumReceiptIssue  = KeySum::construct(ReceiptIssueKeyLength, ReceiptIssueValueLength);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes <c>Query</c> object to use it for data fetching.
    /// </summary>
    protected void initQuery()
    {
        QueryBuildDataSource    qbdsInventTrans, qbdsInventProfile, qbdsProdType, qbdsBranch;

        query = AlcoholDeclarationCalc_RU::getDefaultQuery(calcMovement);

        findOrCreateRange_W(query.dataSourceTable(tableNum(InventTrans)), fieldNum(InventTrans, DateFinancial), queryRange(fromDate, toDate));
        findOrCreateRange_W(query.dataSourceTable(tableNum(InventProfile_RU)), fieldNum(InventProfile_RU, AlcoholActivityType), queryValue(this.activityType()));
        findOrCreateRange_W(query.dataSourceTable(tableNum(Branches_RU)), fieldNum(Branches_RU, branchId), queryValue(branch.BranchId));
        findOrCreateRange_W(query.dataSourceTable(tableNum(AlcoholProductionType_RU)), fieldNum(AlcoholProductionType_RU, IsBeer), queryValue(queryValue(this.isBeer())));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBeer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows if the current child of <c>AlcoholDeclarationCalc_RU</c> class should analyze production types which are "beer".
    /// </summary>
    /// <returns>
    ///    true if the current child of <c>AlcoholDeclarationCalc_RU</c> class should analyze production types which are "beer"; false otherwise.
    /// </returns>
    protected AlcoholIsBeer_RU isBeer()
    {

        return NoYesCombo::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDaily</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows if the current child of <c>AlcoholDeclarationCalc_RU</c> class relates to the daily journal.
    /// </summary>
    /// <returns>
    ///    False.
    /// </returns>
    protected boolean isDaily()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>AlcoholDeclarationCalc_RU</c> class.
    /// </summary>
    /// <param name="_common">
    ///    The record for which the calculation was called.
    /// </param>
    public void new(Common    _common)
    {
        super();
        common = _common;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a container that holds the macros for <c>CurrentVersion</c> and <c>CurrentList</c>, which is defined in the <c>ClassDeclaration</c> method.
    /// </summary>
    /// <returns>
    ///    A container that holds the macros for <c>CurrentVersion</c> and <c>CurrentList</c>.
    /// </returns>
    public container pack()
    {
        return connull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRecalcReceiptIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Passes the parameter showing if the recalculation of receipts and issues should be performed while recalculating movement in the 5th form of declaration.
    /// </summary>
    /// <param name="_recalcReceiptIssue">
    ///    Boolean parameter showing whether to recalculate receipts and issues.
    /// </param>
    /// <returns>
    ///    Boolean parameter showing whether to recalculate receipts and issues.
    /// </returns>
    public boolean parmRecalcReceiptIssue(boolean _recalcReceiptIssue = recalcReceiptIssue)
    {
        recalcReceiptIssue = _recalcReceiptIssue;
        return recalcReceiptIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preCalc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs some actions before calculation.
    /// </summary>
    protected void preCalc()
    {
        if (! this.check())
            throw error("@GLS104171");

        this.deleteRecords();
        this.updateStatus();
    }

]]></Source>
			</Method>
			<Method>
				<Name>process</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes the calculation. Calls methods for calculation and saving data.
    /// </summary>
    protected void process()
    {
        this.initKeySum();

        if (calcMovement || calcReceipt)
        {
            this.processReceipt();
        }

        if (calcMovement || calcIssue)
        {
            this.processIssue();
        }

        if (keySumMovement)
        {
            this.saveCalculatedDataMovement();
        }

        if (keySumReceiptIssue)
        {
            this.saveCalculatedDataReceiptIssue();
        }

        if (this.isDaily())
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00126, funcName());
        }
        else
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00055, funcName());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs issues calculation.
    /// </summary>
    protected void processIssue()
    {
        InventLocation              inventLocationIssue;
        InventTrans                 inventTransReceipt, inventTransIssue;
        InventTransOrigin           inventTransOrigin, transferInventTransOrigin;
        InventDim                   inventDimReceipt, inventDimIssue;
        InventTable                 inventTable;
        Branches_RU                 branchReceipt;
        VendInvoiceJour             vendInvoiceJour;
        VendInvoiceTrans            vendInvoiceTrans;
        CustInvoiceJour             custInvoiceJour;
        CustInvoiceTrans            custInvoiceTrans;
        CustInvoiceTrans_RU         custInvoiceTrans_RU;
        AlcoholProductionType_RU    alcoholProductionType;
        container                   key;
        InventProfile_RU            inventProfileIssue;
        TransDate                   transDate;
        Qty                         volume;

        while select InventLocationId from inventLocationIssue
            where inventLocationIssue.VendAccount == branch.VendAccount
        {
            while select inventTransIssue
                where inventTransIssue.StatusReceipt == StatusReceipt::None
                   && inventTransIssue.StatusIssue   == StatusIssue::Sold
                   && inventTransIssue.DateFinancial >= fromDate
                   && inventTransIssue.DateFinancial <= toDate
                   && inventTransIssue.Qty           < 0
            join inventTransOrigin
                where inventTransOrigin.RecId == inventTransIssue.InventTransOrigin
                   && (   inventTransOrigin.ReferenceCategory == InventTransType::Sales
                       || inventTransOrigin.ReferenceCategory == InventTransType::Purch
                       || (    calcMovement
                           && (   inventTransOrigin.ReferenceCategory == InventTransType::InventTransfer
                               || inventTransOrigin.ReferenceCategory == InventTransType::InventCounting
                               || inventTransOrigin.ReferenceCategory == InventTransType::InventLossProfit
                               || inventTransOrigin.ReferenceCategory == InventTransType::InventTransaction
                               || inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderShip
                               || inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderReceive)
                          )
                      )
            join RecId from inventDimIssue
                where inventDimIssue.inventDimId      == inventTransIssue.inventDimId
                   && inventDimIssue.InventLocationId == inventLocationIssue.InventLocationId
            join AlcoholActivityType from inventProfileIssue
                where inventProfileIssue.InventProfileId     == inventDimIssue.InventProfileId_RU
                   && inventProfileIssue.AlcoholActivityType == this.activityType()
            join inventTable
                where inventTable.ItemId == inventTransIssue.ItemId
                   && inventTable.AlcoholProductionTypeId_RU
            join RecId from alcoholProductionType
                where alcoholProductionType.TypeId == inventTable.AlcoholProductionTypeId_RU
                   && alcoholProductionType.IsBeer == this.isBeer()
            {
                switch (inventTransOrigin.ReferenceCategory)
                {
                    case InventTransType::Sales:

                        custInvoiceTrans    = this.getCustVendInvoiceTrans(inventTransIssue, inventTransOrigin);
                        custInvoiceTrans_RU = custInvoiceTrans.custInvoiceTrans_RU();
                        custInvoiceJour     = custInvoiceTrans.custInvoiceJour();
                        transDate           = this.getTransDate(inventTransIssue, custInvoiceJour);

                        if (transDate <= toDate)
                        {
                            volume  = this.calculateVolume(inventTransIssue.Qty, inventTable, inventTransIssue.inventDimId);

                            if (calcIssue)
                            {
                                key = this.createKeyReceiptIssue(AlcoholDeclarationTransType_RU::Issue,
                                                                 inventTable,
                                                                 inventDimIssue,
                                                                 custInvoiceTrans_RU.AlcoholLicenseSeriesNum_RU,
                                                                 custInvoiceJour,
                                                                 transDate,
                                                                 inventTransIssue,
                                                                 inventTransOrigin,
                                                                 NoYes::No);
                                this.updateKeySumReceiptIssue(key, volume);
                            }

                            if (calcMovement)
                            {
                                key = this.createKeyMovement(transDate, inventTable);

                                if (CustTable::find(custInvoiceJour.InvoiceAccount).ForeignResident_RU && ! this.isDaily())     // for the daily journal export shouldn't be filled
                                {
                                    this.updateKeySumMovement(key, volume, ExportSalesQtyPos);
                                }
                                else if (inventProfileIssue.AlcoholActivityType == AlcoholActivityType_RU::Retail)
                                {
                                    this.updateKeySumMovement(key, volume, RetailSalesQtyPos);
                                }
                                else
                                {
                                    this.updateKeySumMovement(key, volume, WholesaleSalesQtyPos);
                                }
                            }
                        }

                    break;

                    case InventTransType::Purch:

                        vendInvoiceTrans = this.getCustVendInvoiceTrans(inventTransIssue, inventTransOrigin);
                        vendInvoiceJour  = vendInvoiceTrans.vendInvoiceJour();
                        transDate        = this.getTransDate(inventTransIssue, vendInvoiceJour);

                        if (transDate <= toDate)
                        {
                            volume = this.calculateVolume(inventTransIssue.Qty, inventTable, inventTransIssue.inventDimId);

                            if (calcIssue)
                            {
                                key = this.createKeyReceiptIssue(AlcoholDeclarationTransType_RU::Issue,
                                                                 inventTable,
                                                                 inventDimIssue,
                                                                 vendInvoiceTrans.AlcoholLicenseSeriesNum_RU,
                                                                 vendInvoiceJour,
                                                                 transDate,
                                                                 inventTransIssue,
                                                                 inventTransOrigin,
                                                                 NoYes::Yes);
                                this.updateKeySumReceiptIssue(key, volume);
                            }

                            if (calcMovement)
                            {
                                this.updateKeySumMovement(this.createKeyMovement(transDate, inventTable), volume, SalesReturnQtyPos);
                            }
                        }

                    break;

                    case InventTransType::InventCounting:
                    case InventTransType::InventLossProfit:
                    case InventTransType::InventTransaction:
                        if (calcMovement)
                        {
                            this.updateKeySumMovement(this.createKeyMovement(inventTransIssue.DateFinancial, inventTable),
                                                      this.calculateVolume(inventTransIssue.Qty, inventTable, inventTransIssue.inventDimId),
                                                      OtherIssueQtyPos);
                        }
                    break;

                    case InventTransType::InventTransfer:
                    case InventTransType::TransferOrderShip:
                    case InventTransType::TransferOrderReceive:
                        if (calcMovement)
                        {
                            transferInventTransOrigin = inventTransIssue.transferInventTransOrigin();

                            select firstonly InventDimId from inventTransReceipt
                                where inventTransReceipt.InventTransOrigin == transferInventTransOrigin.RecId
                                   && inventTransReceipt.RecId             != inventTransIssue.RecId
                                   && inventTransReceipt.Qty               > 0
                            join inventDimReceipt
                                where inventDimReceipt.inventDimId == inventTransReceipt.inventDimId;

                            if (   inventDimReceipt
                                && inventProfileIssue.AlcoholActivityType != InventProfile_RU::find(inventDimReceipt.InventProfileId_RU).AlcoholActivityType)
                            {
                                this.updateKeySumMovement(this.createKeyMovement(inventTransIssue.DateFinancial, inventTable),
                                                          this.calculateVolume(inventTransIssue.Qty, inventTable, inventTransIssue.inventDimId),
                                                          OtherIssueQtyPos);
                            }
                            else
                            {
                                select firstonly BranchId from branchReceipt
                                    where branchReceipt.VendAccount == inventTransReceipt.inventDim().inventLocation().VendAccount;

                                if (branchReceipt.BranchId != branch.BranchId) // transfer between separate subdivisions (branches)
                                {
                                   this.updateKeySumMovement(this.createKeyMovement(inventTransIssue.DateFinancial, inventTable),
                                                             this.calculateVolume(inventTransIssue.Qty, inventTable, inventTransIssue.inventDimId),
                                                             InternalTransferIssueQtyPos);
                                }
                            }
                        }
                    break;

                    default:
                    break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs receipts calculation.
    /// </summary>
    protected void processReceipt()
    {
        InventLocation              inventLocationReceipt;
        InventTrans                 inventTransReceipt, inventTransIssue;
        InventTransOrigin           inventTransOrigin, transferInventTransOrigin;
        InventDim                   inventDimReceipt, inventDimIssue;
        InventTable                 inventTable;
        Branches_RU                 branchIssue;
        VendInvoiceJour             vendInvoiceJour;
        VendInvoiceTrans            vendInvoiceTrans;
        CustInvoiceJour             custInvoiceJour;
        CustInvoiceTrans            custInvoiceTrans;
        CustInvoiceTrans_RU         custInvoiceTrans_RU;
        AlcoholProductionType_RU    alcoholProductionType;
        container                   key;
        InventProfile_RU            inventProfileReceipt;
        TransDate                   transDate;
        VendTable                   vendTable;
        Qty                         volume;

        while select InventLocationId from inventLocationReceipt
            where inventLocationReceipt.VendAccount == branch.VendAccount
        {
            while select inventTransReceipt
                where inventTransReceipt.StatusReceipt == StatusReceipt::Purchased
                   && inventTransReceipt.StatusIssue   == StatusIssue::None
                   && inventTransReceipt.DateFinancial >= fromDate
                   && inventTransReceipt.DateFinancial <= toDate
                   && inventTransReceipt.Qty           > 0
            join inventTransOrigin
                where inventTransOrigin.RecId == inventTransReceipt.InventTransOrigin
                   && (   inventTransOrigin.ReferenceCategory == InventTransType::Sales
                       || inventTransOrigin.ReferenceCategory == InventTransType::Purch
                       || (    calcMovement
                           && (   inventTransOrigin.ReferenceCategory == InventTransType::InventTransfer
                               || inventTransOrigin.ReferenceCategory == InventTransType::InventCounting
                               || inventTransOrigin.ReferenceCategory == InventTransType::InventLossProfit
                               || inventTransOrigin.ReferenceCategory == InventTransType::InventTransaction
                               || inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderShip
                               || inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderReceive)
                          )
                      )
            join inventDimReceipt
                where inventDimReceipt.inventDimId      == inventTransReceipt.inventDimId
                   && inventDimReceipt.InventLocationId == inventLocationReceipt.InventLocationId
            join AlcoholActivityType from inventProfileReceipt
                where inventProfileReceipt.InventProfileId     == inventDimReceipt.InventProfileId_RU
                   && inventProfileReceipt.AlcoholActivityType == this.activityType()
            join inventTable
                where inventTable.ItemId == inventTransReceipt.ItemId
                   && inventTable.AlcoholProductionTypeId_RU
            join RecId from alcoholProductionType
                where alcoholProductionType.TypeId == inventTable.AlcoholProductionTypeId_RU
                   && alcoholProductionType.IsBeer == this.isBeer()
            {
                switch (inventTransOrigin.ReferenceCategory)
                {
                    case InventTransType::Purch:

                        vendInvoiceTrans = this.getCustVendInvoiceTrans(inventTransReceipt, inventTransOrigin);
                        vendInvoiceJour  = vendInvoiceTrans.vendInvoiceJour();
                        transDate        = this.getTransDate(inventTransReceipt, vendInvoiceJour);

                        if (transDate <= toDate)
                        {
                            volume = this.calculateVolume(inventTransReceipt.Qty, inventTable, inventTransReceipt.inventDimId);

                            if (calcReceipt)
                            {
                                key = this.createKeyReceiptIssue(AlcoholDeclarationTransType_RU::Receipt,
                                                                 inventTable,
                                                                 inventDimReceipt,
                                                                 vendInvoiceTrans.AlcoholLicenseSeriesNum_RU,
                                                                 vendInvoiceJour,
                                                                 transDate,
                                                                 inventTransReceipt,
                                                                 inventTransOrigin,
                                                                 NoYes::No);
                                this.updateKeySumReceiptIssue(key, volume);
                            }

                            if (calcMovement)
                            {
                                key         = this.createKeyMovement(transDate, inventTable);
                                vendTable   = VendTable::find(vendInvoiceJour.InvoiceAccount);

                                if (vendTable.ForeignResident_RU)
                                {
                                    this.updateKeySumMovement(key, volume, ImportPurchQtyPos);
                                }
                                else
                                {
                                    if (VendTable::find(inventTable.AlcoholManufacturerId_RU).AccountNum == vendTable.AccountNum)
                                    {
                                        this.updateKeySumMovement(key, volume, ManufacturerPurchQtyPos);
                                    }
                                    else
                                    {
                                        this.updateKeySumMovement(key, volume, WholesalePurchQtyPos);
                                    }
                                }
                            }
                        }

                    break;

                    case InventTransType::Sales:

                        custInvoiceTrans    = this.getCustVendInvoiceTrans(inventTransReceipt, inventTransOrigin);
                        custInvoiceTrans_RU = custInvoiceTrans.custInvoiceTrans_RU();
                        custInvoiceJour     = custInvoiceTrans.custInvoiceJour();
                        transDate           = this.getTransDate(inventTransReceipt, custInvoiceJour);

                        if (transDate <= toDate)
                        {
                            volume = this.calculateVolume(inventTransReceipt.Qty, inventTable, inventTransReceipt.inventDimId);

                            if (calcReceipt)
                            {
                                key = this.createKeyReceiptIssue(AlcoholDeclarationTransType_RU::Receipt,
                                                              inventTable,
                                                              inventDimReceipt,
                                                              custInvoiceTrans_RU.AlcoholLicenseSeriesNum_RU,
                                                              custInvoiceJour,
                                                              transDate,
                                                              inventTransReceipt,
                                                              inventTransOrigin,
                                                              NoYes::Yes);
                                this.updateKeySumReceiptIssue(key, volume);
                            }

                            if (calcMovement)
                            {
                                this.updateKeySumMovement(this.createKeyMovement(transDate, inventTable), volume, PurchReturnQtyPos);
                            }
                        }

                    break;

                    case InventTransType::InventCounting:
                    case InventTransType::InventLossProfit:
                    case InventTransType::InventTransaction:
                        if (calcMovement)
                        {
                            this.updateKeySumMovement(this.createKeyMovement(inventTransReceipt.DateFinancial, inventTable),
                                                      this.calculateVolume(inventTransReceipt.Qty, inventTable, inventTransReceipt.inventDimId),
                                                      OtherRecieptQtyPos);
                        }
                    break;

                    case InventTransType::InventTransfer:
                    case InventTransType::TransferOrderShip:
                    case InventTransType::TransferOrderReceive:
                        if (calcMovement)
                        {
                            transferInventTransOrigin = inventTransReceipt.transferInventTransOrigin();

                            select firstonly InventDimId from inventTransIssue
                                where inventTransIssue.InventTransOrigin == transferInventTransOrigin.RecId
                                   && inventTransIssue.Qty               < 0
                                   && inventTransIssue.RecId             != inventTransReceipt.RecId
                            join inventDimIssue
                                where inventDimIssue.InventDimId == inventTransIssue.InventDimId;

                            if (   inventDimIssue
                                && inventProfileReceipt.AlcoholActivityType != InventProfile_RU::find(inventDimIssue.InventProfileId_RU).AlcoholActivityType)
                            {
                                this.updateKeySumMovement(this.createKeyMovement(inventTransReceipt.DateFinancial, inventTable),
                                                          this.calculateVolume(inventTransReceipt.Qty, inventTable, inventTransReceipt.inventDimId),
                                                          OtherRecieptQtyPos);
                            }
                            else
                            {
                                select firstonly branchId from branchIssue
                                    where branchIssue.VendAccount == inventDimIssue.inventLocation().VendAccount;

                                if (branchIssue.BranchId != branch.BranchId) // transfer between separate subdivisions (branches)
                                {
                                    this.updateKeySumMovement(this.createKeyMovement(inventTransReceipt.DateFinancial, inventTable),
                                                              this.calculateVolume(inventTransReceipt.Qty, inventTable, inventTransReceipt.inventDimId),
                                                              InternalTransferReceiptQtyPos);
                                }
                            }
                        }
                    break;

                    default:
                    break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveCalculatedDataMovement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs saving movement data which are stored in the <c>KeySum</c> objects to the persistent tables.
    /// </summary>
    protected void saveCalculatedDataMovement()
    {
        AlcoholDeclarationTransMovement_RU      declarationTrans, declarationTransCorr;
        int                                     idx;
        container                               conKey, conData;
        AlcoholDeclarationPeriodNum_RU          correctedPeriodNum;
        AlcoholDeclarationFiscalYear_RU         correctedFiscalYear;
        AlcoholDeclarationJournalTransBranch_RU journalTransBranchCorr, journalTransBranchMov;
        Set                                     createdRecIdSet = new Set(Types::Container);
        Set                                     createdAuxRecIdSet = new Set(Types::Container);
        SetEnumerator                           se;
        container                               con;
        InventTable                             inventTable;
        AlcoholProductionType_RU                alcoholProductionType;
        InventSum                               inventSum;

        void incCorrPeriod()
        {
            correctedPeriodNum++;
            if (correctedPeriodNum > QuartersPerYear)
            {
                correctedPeriodNum = 1;
                correctedFiscalYear++;
            }
        }

        AlcoholDeclarationType_RU declarationType()
        {
            if (this.declarationType() == AlcoholDeclarationType_RU::Wholesale6 ||
                this.declarationType() == AlcoholDeclarationType_RU::Wholesale7)
            {
                return AlcoholDeclarationType_RU::Wholesale5;
            }
            else
                return this.declarationType();
        }

        // if the calculation is being performed from the 6th or 7th calculation class, it's necessarry to find the branch line, related to the 5th declaration -->
        journalTransBranchMov = AlcoholDeclarationJournalTransBranch_RU::find(journalTransBranch.JournalId,
                                                                              declarationType(),
                                                                              journalTransBranch.BranchId);

        if (!journalTransBranchMov)
            return;
        // if the calculation is being performed from the 6th or 7th calculation class, it's necessarry to find the branch line, related to the 5th declaration <--

        // create trans lines for ordinary and correction journals -->
        for (idx = 1; idx <= keySumMovement.numOfTrans(); idx++)
        {
            conKey  = keySumMovement.index2Key(idx);
            conData = keySumMovement.index2Data(idx);

            correctedPeriodNum  = conpeek(conKey, 3);
            correctedFiscalYear = conpeek(conKey, 4);

            declarationTrans.clear();
            declarationTrans.initValue();

            if (correctedPeriodNum != currentPeriodNum || correctedFiscalYear != currentFiscalYear)
            {
                journalTransBranchCorr = AlcoholDeclarationJournalTransBranch_RU::findOrCreateJournalTransBranchCorr(journalTransBranch.JournalId,
                                                                                                                     declarationType(),
                                                                                                                     journalTransBranch.BranchId,
                                                                                                                     correctedPeriodNum,
                                                                                                                     correctedFiscalYear);

                declarationTrans.initFromTransBranch(journalTransBranchCorr);
            }
            else
            {
                declarationTrans.initFromTransBranch(journalTransBranchMov);
            }

            declarationTrans.AlcoholProductionTypeId    = conpeek(conKey,1);
            declarationTrans.ManufacturerId             = conpeek(conKey,2);

            declarationTrans.PeriodStartQty             = 0;

            declarationTrans.ManufacturerPurchQty       = abs(conpeek(conData, ManufacturerPurchQtyPos));
            declarationTrans.WholesalePurchQty          = abs(conpeek(conData, WholesalePurchQtyPos));
            declarationTrans.ImportPurchQty             = abs(conpeek(conData, ImportPurchQtyPos));
            declarationTrans.PurchReturnQty             = abs(conpeek(conData, PurchReturnQtyPos));
            declarationTrans.OtherRecieptQty            = abs(conpeek(conData, OtherRecieptQtyPos));
            declarationTrans.InternalTransferReceiptQty = abs(conpeek(conData, InternalTransferReceiptQtyPos));

            declarationTrans.TotalPurchQty              =   declarationTrans.ManufacturerPurchQty
                                                          + declarationTrans.WholesalePurchQty
                                                          + declarationTrans.ImportPurchQty;

            declarationTrans.TotalReceiptQty            =   declarationTrans.TotalPurchQty
                                                          + declarationTrans.PurchReturnQty
                                                          + declarationTrans.OtherRecieptQty
                                                          + declarationTrans.InternalTransferReceiptQty;

            declarationTrans.WholesaleSalesQty          = abs(conpeek(conData, WholesaleSalesQtyPos));
            declarationTrans.RetailSalesQty             = abs(conpeek(conData, RetailSalesQtyPos));
            declarationTrans.ExportSalesQty             = abs(conpeek(conData, ExportSalesQtyPos));
            declarationTrans.OtherIssueQty              = abs(conpeek(conData, OtherIssueQtyPos));
            declarationTrans.SalesReturnQty             = abs(conpeek(conData, SalesReturnQtyPos));
            declarationTrans.InternalTransferIssueQty   = abs(conpeek(conData, InternalTransferIssueQtyPos));

            declarationTrans.TotalSalesQty              =   declarationTrans.WholesaleSalesQty
                                                          + declarationTrans.RetailSalesQty
                                                          + declarationTrans.ExportSalesQty;

            declarationTrans.TotalIssueQty              =   declarationTrans.TotalSalesQty
                                                          + declarationTrans.OtherIssueQty
                                                          + declarationTrans.SalesReturnQty
                                                          + declarationTrans.InternalTransferIssueQty;

            declarationTrans.PeriodEndQty               = 0;

            declarationTrans.insert();

            createdRecIdSet.add([correctedFiscalYear,
                                 correctedPeriodNum,
                                 declarationTrans.RecId]);  // adding year and period number in order to then sort them starting from the earliest
        }
        // create trans lines for ordinary and correction journals <--

        // running through the created lines -->
        se = createdRecIdSet.getEnumerator();
        while (se.moveNext())
        {
            con = se.current();
            correctedFiscalYear = conpeek(con,1);
            correctedPeriodNum  = conpeek(con,2);
            declarationTrans = AlcoholDeclarationTransMovement_RU::findRecId(conpeek(con, 3));

            // if the line to the correction journal was added, it's necessary to create lines with empty movement in the journals till the current period
            if (correctedPeriodNum != currentPeriodNum || correctedFiscalYear != currentFiscalYear)
            {
                incCorrPeriod();

                while (correctedPeriodNum != currentPeriodNum || correctedFiscalYear != currentFiscalYear)
                {
                    journalTransBranchCorr = AlcoholDeclarationJournalTransBranch_RU::findOrCreateJournalTransBranchCorr(journalTransBranch.JournalId,
                                                                                                                         declarationType(),
                                                                                                                         journalTransBranch.BranchId,
                                                                                                                         correctedPeriodNum,
                                                                                                                         correctedFiscalYear);

                    if (! AlcoholDeclarationTransMovement_RU::exist(journalTransBranchCorr.JournalId,
                                                                    journalTransBranchCorr.AlcoholDeclarationType,
                                                                    journalTransBranchCorr.BranchId,
                                                                    declarationTrans.AlcoholProductionTypeId,
                                                                    declarationTrans.ManufacturerId))
                    {
                        declarationTransCorr.clear();
                        declarationTransCorr.initValue();
                        declarationTransCorr.initFromTransBranch(journalTransBranchCorr);
                        declarationTransCorr.AlcoholProductionTypeId = declarationTrans.AlcoholProductionTypeId;
                        declarationTransCorr.ManufacturerId          = declarationTrans.ManufacturerId;
                        declarationTransCorr.insert();

                        createdAuxRecIdSet.add([correctedFiscalYear,
                                                correctedPeriodNum,
                                                declarationTransCorr.RecId]);
                    }

                    incCorrPeriod();
                }
            }
        }
        // running through the created lines <--

        createdRecIdSet = Set::union(createdRecIdSet, createdAuxRecIdSet);

        // updating period start and end quantities in the created records -->
        se = createdRecIdSet.getEnumerator();

        while (se.moveNext())
        {
            con = se.current();
            declarationTrans = AlcoholDeclarationTransMovement_RU::findRecId(conpeek(con, 3), true);
            declarationTrans.PeriodStartQty = this.getPeriodStartQty(declarationTrans,
                                                                     conpeek(con,2),
                                                                     conpeek(con,1));

            declarationTrans.PeriodEndQty = declarationTrans.PeriodStartQty + declarationTrans.TotalReceiptQty - declarationTrans.TotalIssueQty;

            declarationTrans.update();
        }
        // updating period start and end quantities in the created records <--

        // adding to the current journal lines, related to the production types, which don't have movement, but have remains (start or end) -->
        while select AlcoholProductionTypeId_RU, AlcoholManufacturerId_RU from inventTable
            group by AlcoholProductionTypeId_RU, AlcoholManufacturerId_RU
            where inventTable.AlcoholProductionTypeId_RU
               && inventTable.AlcoholManufacturerId_RU
        exists join alcoholProductionType
            where alcoholProductionType.TypeId == inventTable.AlcoholProductionTypeId_RU
               && alcoholProductionType.IsBeer == this.isBeer()
        exists join inventSum
            where inventSum.ItemId == inventTable.itemId
        {
            if (! AlcoholDeclarationTransMovement_RU::exist(journalTransBranchMov.JournalId,
                                                            journalTransBranchMov.AlcoholDeclarationType,
                                                            journalTransBranchMov.BranchId,
                                                            inventTable.AlcoholProductionTypeId_RU,
                                                            inventTable.AlcoholManufacturerId_RU))
            {
                declarationTrans.clear();
                declarationTrans.initValue();
                declarationTrans.initFromTransBranch(journalTransBranchMov);
                declarationTrans.AlcoholProductionTypeId = inventTable.AlcoholProductionTypeId_RU;
                declarationTrans.ManufacturerId          = inventTable.AlcoholManufacturerId_RU;

                declarationTrans.PeriodStartQty = this.getPeriodStartQty(declarationTrans,
                                                                         currentPeriodNum,
                                                                         currentFiscalYear);

                if (declarationTrans.PeriodStartQty)
                {
                    declarationTrans.PeriodEndQty = declarationTrans.PeriodStartQty;
                    declarationTrans.insert();
                }
            }
        }
        // adding to the current journal lines, related to the production types, which don't have movement, but have remains (start or end) <--
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveCalculatedDataReceiptIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs saving receipt/issue data which are stored in the <c>KeySum</c> objects to the persistent tables.
    /// </summary>
    protected void saveCalculatedDataReceiptIssue()
    {
        AlcoholDeclarationTrans_RU              declarationTrans;
        int                                     idx;
        container                               con;
        AlcoholDeclarationJournalTransBranch_RU journalTransBranchLocal;
        AlcoholDeclarationPeriodNum_RU          correctedPeriodNum;
        AlcoholDeclarationFiscalYear_RU         correctedFiscalYear;
        AlcoholDeclarationTransType_RU          declarationTransType;

        // in the case of saving data is running from the 6th or 7th declaration class,
        // it's necessary to correctly define the declaration type, to which the lines have to be bound -->
        AlcoholDeclarationType_RU declarationType()
        {
            if (this.declarationType() == AlcoholDeclarationType_RU::Wholesale5)
            {
                if (declarationTransType == AlcoholDeclarationTransType_RU::Receipt)
                    return AlcoholDeclarationType_RU::Wholesale7;
                else
                    return AlcoholDeclarationType_RU::Wholesale6;
            }
            else
                return this.declarationType();
        }
        // in the case of saving data is running from the 6th or 7th declaration class,
        // it's necessary to correctly define the declaration type, to which the lines have to be bound <--

        void createIfNotExist(AlcoholDeclarationType_RU  _alcoholDeclarationType)
        {
            journalTransBranchLocal = AlcoholDeclarationJournalTransBranch_RU::find(journalTransBranch.JournalId,
                                                                                    _alcoholDeclarationType,
                                                                                    journalTransBranch.BranchId,
                                                                                    true);

            if (journalTransBranchLocal)
            {
                if (journalTransBranchLocal.Status == AlcoholDeclarationStatus_RU::NotCalculated)
                {
                    journalTransBranchLocal.Status = AlcoholDeclarationStatus_RU::Calculated;
                    journalTransBranchLocal.update();
                }
            }
            else
            {
                journalTransBranchLocal.clear();
                journalTransBranchLocal.initValue();
                journalTransBranchLocal.initFromJournalTransBranch(journalTransBranch);
                journalTransBranchLocal.AlcoholDeclarationType  = _alcoholDeclarationType;
                journalTransBranchLocal.Status                  = AlcoholDeclarationStatus_RU::Calculated;
                journalTransBranchLocal.insert();
            }
        }

        for (idx = 1; idx <= keySumReceiptIssue.numOfTrans(); idx++)
        {
            con = keySumReceiptIssue.index2Key(idx);

            declarationTransType    = conpeek(con, 1);
            correctedPeriodNum      = conpeek(con, 11);
            correctedFiscalYear     = conpeek(con, 12);

            declarationTrans.clear();
            declarationTrans.initValue();

            if (correctedPeriodNum != currentPeriodNum || correctedFiscalYear != currentFiscalYear)
            {
                journalTransBranchLocal = AlcoholDeclarationJournalTransBranch_RU::findOrCreateJournalTransBranchCorr(journalTransBranch.JournalId,
                                                                                                                      declarationType(),
                                                                                                                      journalTransBranch.BranchId,
                                                                                                                      correctedPeriodNum,
                                                                                                                      correctedFiscalYear);
            }
            else
            {
                journalTransBranchLocal = AlcoholDeclarationJournalTransBranch_RU::find(journalTransBranch.JournalId,
                                                                                        declarationType(),
                                                                                        journalTransBranch.BranchId);

                if (journalTransBranchLocal)
                {
                    if (journalTransBranchLocal.Status != AlcoholDeclarationStatus_RU::Calculated)
                    {
                        journalTransBranchLocal         = AlcoholDeclarationJournalTransBranch_RU::findRecId(journalTransBranchLocal.RecId, true);
                        journalTransBranchLocal.Status  = AlcoholDeclarationStatus_RU::Calculated;
                        journalTransBranchLocal.update();
                    }
                }
                else
                {
                    journalTransBranchLocal.clear();
                    journalTransBranchLocal.initValue();
                    journalTransBranchLocal.JournalId               = journalTransBranch.JournalId;
                    journalTransBranchLocal.AlcoholDeclarationType  = declarationType();
                    journalTransBranchLocal.BranchId                = journalTransBranch.BranchId;
                    journalTransBranchLocal.Status                  = AlcoholDeclarationStatus_RU::Calculated;
                    journalTransBranchLocal.insert();
                }
            }

            declarationTrans.initFromTransBranch(journalTransBranchLocal);

            declarationTrans.Type                    = conpeek(con,1);
            declarationTrans.AlcoholProductionTypeId = conpeek(con,2);
            declarationTrans.ManufacturerId          = conpeek(con,3);
            declarationTrans.CustVendAC              = conpeek(con,4);
            declarationTrans.CustVend                = conpeek(con,5);
            declarationTrans.LicenseSeriesNum        = conpeek(con,6);
            declarationTrans.TransDate               = conpeek(con,7);
            declarationTrans.InvoiceId               = conpeek(con,8);
            declarationTrans.InventGTDId             = conpeek(con,9);
            declarationTrans.IsReturn                = conpeek(con,10);
            declarationTrans.Qty                     = abs(keySumReceiptIssue.index2Data(idx));
            declarationTrans.insert();
        }

        if (recalcReceiptIssue && this.declarationType() == AlcoholDeclarationType_RU::Wholesale5)
        {
            createIfNotExist(AlcoholDeclarationType_RU::Wholesale6);
            createIfNotExist(AlcoholDeclarationType_RU::Wholesale7);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Unpacks what the <c>pack</c> method has packed.
    /// </summary>
    /// <param name="packedClass">
    ///    The packed class in a container.
    /// </param>
    /// <returns>
    ///    true if the container has been unpacked successfully; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    When the <c>isSwappingPrompt</c> method returns a value of true, it may be necessary to unpack some prompt-related variables as well.
    /// </remarks>
    public boolean unpack(container packedClass)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateKeySumMovement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>KeySum</c> object when calculating movement.
    /// </summary>
    /// <param name="_key">
    ///    The key value to update the <c>KeySum</c> object.
    /// </param>
    /// <param name="_value">
    ///    The value to add to the <c>KeySum</c> object.
    /// </param>
    /// <param name="_pos">
    ///    Position in the value container of the <c>KeySum</c> object to be updated.
    /// </param>
    protected void updateKeySumMovement(container   _key,
                                        Amount      _value,
                                        int         _pos)
    {
        int i;

        if (! keySumMovement)
        {
            keySumMovement = KeySum::construct(MovementKeyLength, MovementValueLength);

            for (i = 1; i <= MovementValueLength; i++)
            {
                valueCon += 0;
            }
        }

        keySumMovement.updateNow(_key, conpoke(valueCon, _pos, _value));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateKeySumReceiptIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>KeySum</c> object when calculating receipt/issue.
    /// </summary>
    /// <param name="_key">
    ///    The key value to update the <c>KeySum</c> object.
    /// </param>
    /// <param name="_value">
    ///    The value to add to the <c>KeySum</c> object.
    /// </param>
    protected void updateKeySumReceiptIssue(container   _key,
                                            Qty         _value)
    {
        if (! keySumReceiptIssue)
        {
            keySumReceiptIssue  = KeySum::construct(ReceiptIssueKeyLength, ReceiptIssueValueLength);
        }

        keySumReceiptIssue.updateNow(_key, _value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the status of the journal.
    /// </summary>
    protected void updateStatus()
    {
        journalTransBranch.Status = AlcoholDeclarationStatus_RU::Calculated;
        journalTransBranch.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an appropriate object of <c>AlcoholDeclarationCalc_RU</c> hierarchy.
    /// </summary>
    /// <param name="_common">
    ///    The record which corresponds either to <c>AlcoholDeclarationJournalTransBranch_RU</c> or to <c>AlcoholDailyJournalTable_RU</c> table.
    /// </param>
    /// <returns>
    ///    The object of the appropriate <c>AlcoholDeclarationCalc_RU</c> child class.
    /// </returns>
    public static AlcoholDeclarationCalc_RU construct(Common  _common)
    {
        AlcoholDeclarationJournalTransBranch_RU     journalTransBranch;
        AlcoholDailyJournalTable_RU                 dailyJournalTable;
        AlcoholDeclarationType_RU                   alcoholDeclarationType;
        boolean                                     isDaily = false;

        switch (_common.TableId)
        {
            case tablenum(AlcoholDeclarationJournalTransBranch_RU) :
                 journalTransBranch     = _common;
                 alcoholDeclarationType = journalTransBranch.AlcoholDeclarationType;
                 break;

            case tablenum(AlcoholDailyJournalTable_RU) :
                 dailyJournalTable      = _common;
                 alcoholDeclarationType = dailyJournalTable.AlcoholDeclarationType;
                 isDaily = true;
                 break;

            default:
                throw error(Error::wrongUseOfFunction(funcname()));
        }

        switch (alcoholDeclarationType)
        {
            case AlcoholDeclarationType_RU::Wholesale5:
                return new AlcoholDeclarationCalc5_RU(_common);

            case AlcoholDeclarationType_RU::Wholesale6:
                return new AlcoholDeclarationCalc6_RU(_common);

            case AlcoholDeclarationType_RU::Wholesale7:
                return new AlcoholDeclarationCalc7_RU(_common);

            case AlcoholDeclarationType_RU::Retail11:
                if (isDaily)
                {
                    return new AlcoholDeclarationCalc11Daily_RU(_common);
                }
                else
                {
                    return new AlcoholDeclarationCalc11_RU(_common);
                }

            case AlcoholDeclarationType_RU::Retail12:
                if (isDaily)
                {
                    return new AlcoholDeclarationCalc12Daily_RU(_common);
                }
                else
                {
                    return new AlcoholDeclarationCalc12_RU(_common);
                }

            default :
                throw error(Error::wrongUseOfFunction(funcname()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultQuery</Name>
				<Source><![CDATA[
    public static Query getDefaultQuery(boolean _includeInventTransfer = false)
    {
        Query                   query;
        QueryBuildDataSource    qbdsInventTransOrigin, qbdsInventTrans, qbdsInventDim, qbdsInventProfile,
                            qbdsInventTable, qbdsProdType, qbdsInventLocation, qbdsBranch;
        container               con;

        query = new Query();
        qbdsInventTransOrigin = query.addDataSource(tableNum(InventTransOrigin));
        qbdsInventTransOrigin.addRange(fieldNum(InventTransOrigin, ReferenceCategory)).value(con2Str([InventTransType::Sales, InventTransType::Purch])); 

        if (_includeInventTransfer)
        {
            con = [InventTransType::InventTransfer,
               InventTransType::InventCounting,
               InventTransType::InventLossProfit,
               InventTransType::InventTransaction,
               InventTransType::TransferOrderShip,
               InventTransType::TransferOrderReceive];

            qbdsInventTransOrigin.addRange(fieldNum(InventTransOrigin, ReferenceCategory)).value(con2Str(con));
        }

        qbdsInventTrans = qbdsInventTransOrigin.addDataSource(tableNum(InventTrans));
        qbdsInventTrans.relations(true);
        qbdsInventTrans.fetchMode(QueryFetchMode::One2One);
        qbdsInventTrans.addSortField(fieldNum(InventTrans, DateFinancial), SortOrder::Ascending);
        qbdsInventTrans.addSortField(fieldNum(InventTrans, InvoiceId), SortOrder::Ascending);

        qbdsInventDim = qbdsInventTrans.addDataSource(tableNum(InventDim));
        qbdsInventDim.relations(true);
        qbdsInventDim.fetchMode(QueryFetchMode::One2One);

        qbdsInventProfile = qbdsInventDim.addDataSource(tableNum(InventProfile_RU));
        qbdsInventProfile.relations(true);
        qbdsInventProfile.fetchMode(QueryFetchMode::One2One);

        qbdsInventLocation = qbdsInventDim.addDataSource(tableNum(InventLocation));
        qbdsInventLocation.relations(true);
        qbdsInventLocation.fetchMode(QueryFetchMode::One2One);

        qbdsBranch = qbdsInventLocation.addDataSource(tableNum(Branches_RU));
        qbdsBranch.addLink(fieldNum(InventLocation, VendAccount), fieldNum(Branches_RU, VendAccount));
        qbdsBranch.fetchMode(QueryFetchMode::One2One);

        qbdsInventTable = qbdsInventTrans.addDataSource(tableNum(InventTable));
        qbdsInventTable.relations(true);
        qbdsInventTable.fetchMode(QueryFetchMode::One2One);
        qbdsInventTable.addRange(fieldNum(InventTable, AlcoholProductionTypeId_RU)).value(SysQuery::valueNotEmptyString());

        qbdsProdType = qbdsInventTable.addDataSource(tableNum(AlcoholProductionType_RU));
        qbdsProdType.relations(true);
        qbdsProdType.fetchMode(QueryFetchMode::One2One);

        return query;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>