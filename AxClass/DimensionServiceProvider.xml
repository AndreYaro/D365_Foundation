<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>DimensionServiceProvider</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>DimensionServiceProvider</c> class manages business logic for accounts and financial dimension customer services.
/// </summary>
// This is a framework class. Customizing this class may cause problems with future upgrades to the software.
class DimensionServiceProvider
{
    #DimensionServiceFaults
    #xsd
    #AifDimensionDataContainerTypes

    boolean validateAllDimensionsAreApplied;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>buildDimStorageForDimSetCombo</Name>
				<Source><![CDATA[
    private LedgerDimensionAccount buildDimStorageForDimSetCombo(DimensionSetCombinationContract _combination)
    {
        DimensionAttribute      dimensionAttribute;
        DimensionAttributeValue dimensionAttributeValue;
        DimensionStorage        dimensionStorage;
        DimensionStorageSegment segment;
        LedgerDimensionAccount  ledgerDimensionId;
        RecId                   hierarchyId;
        ListEnumerator          listEnumerator;
        str                     attributeName, attributeValue;
        int                     segmentIndex;

        dimensionStorage = DimensionStorage::construct(0, LedgerDimensionType::Account);

        // Add the account structure to the dimension storage instance.
        hierarchyId = DimensionHierarchy::findByTypeAndName(DimensionHierarchyType::Focus, _combination.parmDimensionSetName()).RecId;
        dimensionStorage.addHierarchy(hierarchyId);

        // Add the dimension segments to the dimension storage instance.
        listEnumerator = _combination.parmValues().getEnumerator();

        while (listEnumerator.moveNext())
        {
            attributeName = listEnumerator.current().parmName();
            dimensionAttribute = DimensionAttribute::findByName(attributeName);

            attributeValue = listEnumerator.current().parmValue();
            dimensionAttributeValue = DimensionAttributeValue::findByDimensionAttributeAndValue(dimensionAttribute, attributeValue, false, true);

            segmentIndex = DimensionHierarchyLevel::findByDimensionHierarchyAndDimAttribute(hierarchyId, dimensionAttribute.RecId).Level;

            if (segmentIndex)
            {
                segment = DimensionStorageSegment::constructFromValue(dimensionAttributeValue.CachedDisplayValue, dimensionAttributeValue);
                dimensionStorage.setSegmentForHierarchy(1, segmentIndex, segment);
            }
        }

        ledgerDimensionId = dimensionStorage.save();
        return ledgerDimensionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMainAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a main account record from the specified <c>MainAccountContract</c> object.
    /// </summary>
    /// <param name="_mainAccount">
    ///    The <c>MainAccountContract</c> object to create.
    /// </param>
    /// <returns>
    ///    true if the main account was successfully created; otherwise, false.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    An exception can be thrown for the following reasons: The main account contract is null.The
    ///    <c>MainAccountId</c> value is not specified.The account name is not specified.The
    ///    <c>LedgerChartOfAccounts</c> name value is specified but does not exist.The account already
    ///    exists.The specified opening account does not exist.
    /// </exception>
    public boolean createMainAccount(MainAccountContract _mainAccount)
    {
        MainAccount             mainAccount;
        DimensionAttributeValue dimAttrValue;
        RecId                   dimAttrId;
        LedgerChartOfAccounts   ledgerChartOfAccounts;
        boolean                 success = false;

        if (!_mainAccount)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        // Validate MainAccountContract
        if (!DimensionServiceProvider::validateMainAccount(_mainAccount))
        {
            throw AifFault::faultList("@SYS98197", #ValidationFailed);
        }

        ledgerChartOfAccounts = LedgerChartOfAccounts::findByName(_mainAccount.parmLedgerChartOfAccounts());

        mainAccount.MainAccountId = _mainAccount.parmMainAccountId();
        mainAccount.Name = _mainAccount.parmName();
        mainAccount.Type = _mainAccount.parmType();
        mainAccount.ReportingAccountType = _mainAccount.parmReportingAccountType();
        mainAccount.LedgerChartOfAccounts = ledgerChartOfAccounts.RecId;
        mainAccount.AccountCategoryRef = _mainAccount.parmAccountCategoryRef();
        mainAccount.DebitCreditProposal = _mainAccount.parmDebitCreditProposal();
        mainAccount.DebitCreditCheck = _mainAccount.parmDebitCreditCheck();
        mainAccount.DebitCreditBalanceDemand = _mainAccount.parmDebitCreditBalanceDemand();
        mainAccount.ExchangeAdjusted = _mainAccount.parmExchangeAdjusted();
        mainAccount.Closing = _mainAccount.parmClosing();
        mainAccount.MandatoryPaymentReference = _mainAccount.parmMandatoryPaymentReference();
        mainAccount.ConsolidationMainAccount = _mainAccount.parmConsolidationMainAccount();
        mainAccount.sruCode = _mainAccount.parmSRUCode();
        mainAccount.CurrencyCode = _mainAccount.parmCurrencyCode();
        mainAccount.ValidateCurrency = _mainAccount.parmValidateCurrency();
        mainAccount.UserInfoId = _mainAccount.parmUserInfoId();
        mainAccount.ValidateUser = _mainAccount.parmValidateUser();
        mainAccount.PostingType = _mainAccount.parmPostingType();
        mainAccount.ValidatePosting = _mainAccount.parmValidatePosting();

        if (_mainAccount.parmOffsetLedgerDimension()!= '')
        {
            // Get the Record ID for the OffsetLedgerDimension (which is a default account).
            LedgerDimensionDefaultAccountResolver ledgerDimensionDefaultAccountResolver = LedgerDimensionDefaultAccountResolver::newResolver(_mainAccount.parmOffsetLedgerDimension());
            mainAccount.OffsetLedgerDimension = ledgerDimensionDefaultAccountResolver.resolve();
        }

        if (_mainAccount.parmOpeningAccount() != '')
        {
            mainAccount.OpeningAccount = MainAccount::findByMainAccountId(_mainAccount.parmOpeningAccount(), false, ledgerChartOfAccounts.RecId).RecId;

            // OpeningAccount not found
            if (mainAccount.OpeningAccount == 0)
            {
                AifFault::checkFailedLogFault(strFmt("@SYS328201", _mainAccount.parmOpeningAccount(), ledgerChartOfAccounts.Name), #OpeningAccountDoesNotExist);
                throw AifFault::faultList("@SYS98197", #ValidationFailed);
            }
        }

        if (mainAccount.validateWrite())
        {
            mainAccount.insert();
            success = true;

            // If the DimensionAttributeValue fields are not the default value create DAV record and set fields
            if (_mainAccount.parmIsSuspended() ||
                _mainAccount.parmIsBlockedforManualEntry() ||
                _mainAccount.parmActiveFrom() ||
                _mainAccount.parmActiveTo())
            {
                dimAttrId = DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount);

                dimAttrValue = DimensionAttributeValue::findByDimensionAttributeAndEntityInst(dimAttrId, mainAccount.RecId, true, true);

                dimAttrValue.IsSuspended = _mainAccount.parmIsSuspended();
                dimAttrValue.IsBlockedForManualEntry = _mainAccount.parmIsBlockedforManualEntry();
                dimAttrValue.ActiveFrom = _mainAccount.parmActiveFrom();
                dimAttrValue.ActiveTo = _mainAccount.parmActiveTo();

                if (dimAttrValue.validateWrite())
                {
                    dimAttrValue.update();
                }
                else
                {
                    success = false;
                }
            }
        }
        else
        {
            success = false;
        }

        if (!success)
        {
            throw AifFault::faultList("@SYS98197", #ValidationFailed);
        }

        return success;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBalance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the balance for the specified dimension set.
    /// </summary>
    /// <param name="_dimensionSet">
    ///    The <c>DimensionSetContract</c> object for which to retrieve the balance.
    /// </param>
    /// <returns>
    ///    A <c>DimensionSetBalanceContract</c> object.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    An exception can be thrown for the following reasons: The dimension set contract is null.
    ///    Accounting date from is after accounting date to. The Ledger specified by ledger name does not
    ///    exist. The specified combination is not created correctly.
    /// </exception>
    public DimensionSetBalanceContract getBalance(DimensionSetContract _dimensionSet)
    {
        RecId                                   ledgerDimensionId;
        RecId                                   ledgerId;
        DimensionAttributeValueCombination      dimAttrValueCombo;
        LedgerBalanceDimAttrValueComboAmounts   ledgerBalance;
        DimensionSetBalanceContract             result = new DimensionSetBalanceContract();

        if (!_dimensionSet)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        // Validate DimensionSetContract
        DimensionServiceProvider::validateDimensionSet(_dimensionSet);

        // Setup LedgerBalanceDimAttrValueComboAmounts
        ledgerBalance = LedgerBalanceDimAttrValueComboAmounts::construct();
        ledgerBalance.parmAccountingDateRange(_dimensionSet.parmAccountingDateFrom(), _dimensionSet.parmAccountingDateTo());
        ledgerBalance.parmIncludeOpeningPeriod(_dimensionSet.parmIncludeOpeningFiscalPeriod());
        ledgerBalance.parmIncludeRegularPeriod(_dimensionSet.parmIncludeOperatingFiscalPeriod());
        ledgerBalance.parmPostingLayerList(_dimensionSet.parmPostingLayerList());

        // Only set IncludeClosingPeriodBySystem or IncludeClosingFiscalPeriod, not both.
        if (_dimensionSet.parmIsSystemGeneratedUltimo())
        {
            ledgerBalance.parmIncludeClosingPeriodBySystem(_dimensionSet.parmIsSystemGeneratedUltimo());
        }
        else
        {
            ledgerBalance.parmIncludeClosingPeriod(_dimensionSet.parmIncludeClosingFiscalPeriod());
        }

        // Setting Ledger parameter if specified
        ledgerId = DimensionServiceProvider::getLedgerId(_dimensionSet.parmLedgerName());
        ledgerBalance.parmLedgerRecId(ledgerId);

        // Setup DimensionStorage
        ledgerDimensionId = this.buildDimStorageForDimSetCombo(_dimensionSet.parmCombination());
        Debug::assert(ledgerDimensionId);

        dimAttrValueCombo = DimensionAttributeValueCombination::find(ledgerDimensionId);

        ledgerBalance.calculateBalance(dimAttrValueCombo);

        result.parmAccountingCurrencyAmount(ledgerBalance.getAccountingCurrencyBalance());
        result.parmReportingCurrencyAmount(ledgerBalance.getReportingCurrencyBalance());
        result.parmQuantity(ledgerBalance.getQuantityBalance());

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetAccountListValidationStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the validation status for the collection of budget account contracts.
    /// </summary>
    /// <param name="_budgetAccountListValidationContract">
    /// The collection for which to get the validation statuses.
    /// </param>
    /// <returns>
    /// A collection of dimension validation statuses.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws an error when the contract provided is null or when the incoming list is null.
    /// </exception>
    public DimensionValidationStatusListContract getBudgetAccountListValidationStatus(BudgetAccountListValidationContract _budgetAccountListValidationContract)
    {
        if (!_budgetAccountListValidationContract)
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        return DimensionCombinationServiceProvider::getCombinationListValidationStatus(_budgetAccountListValidationContract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetPlanAccountListValidationStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the validation status for the collection of budget planning contracts.
    /// </summary>
    /// <param name="_budgetPlanAccountListValidationContract">
    /// The collection for which to get the validation statuses.
    /// </param>
    /// <returns>
    /// A collection of dimension validation statuses.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws an error when the contract provided is null or when the incoming list is null.
    /// </exception>
    public DimensionValidationStatusListContract getBudgetPlanAccountListValidationStatus(BudgetPlanAccountListValidationContract _budgetPlanAccountListValidationContract)
    {
        if (!_budgetPlanAccountListValidationContract)
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        return DimensionCombinationServiceProvider::getCombinationListValidationStatus(_budgetPlanAccountListValidationContract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerAccountListValidationStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the validation status for the collection of ledger account contracts.
    /// </summary>
    /// <param name="_ledgerAccountListValidationContract">
    /// The collection for which to get the validation statuses.
    /// </param>
    /// <returns>
    /// A collection of dimension validation statuses.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws an error when the contract provided is null or when the incoming list is null.
    /// </exception>
    public DimensionValidationStatusListContract getLedgerAccountListValidationStatus(LedgerAccountListValidationContract _ledgerAccountListValidationContract)
    {
        if (!_ledgerAccountListValidationContract)
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        return DimensionCombinationServiceProvider::getCombinationListValidationStatus(_ledgerAccountListValidationContract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerChartOfAccounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the existing ledger chart of account records.
    /// </summary>
    /// <returns>
    ///    A list of the <c>LedgerChartOfAccountContract</c> objects.
    /// </returns>
    public List getLedgerChartOfAccounts()
    {
        List                            chartOfAccountsList;
        LedgerChartOfAccounts           ledgerChartOfAccounts;
        LedgerChartOfAccountContract    ledgerChartOfAccountContract;

        chartOfAccountsList = new List(Types::Class);

        while select Name, Description from ledgerChartOfAccounts
        {
            ledgerChartOfAccountContract = new LedgerChartOfAccountContract();
            ledgerChartOfAccountContract.parmName(ledgerChartOfAccounts.Name);
            ledgerChartOfAccountContract.parmDescription(ledgerChartOfAccounts.Description);
            chartOfAccountsList.addEnd(ledgerChartOfAccountContract);
        }

        return chartOfAccountsList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgers</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the existing ledger records.
    /// </summary>
    /// <returns>
    ///    A list of the <c>LedgerContract</c> objects.
    /// </returns>
    public List getLedgers()
    {
        List            ledgerList;
        Ledger          ledger;
        LedgerContract  ledgerContract;

        ledgerList = new List(Types::Class);

        while select Name, Description from ledger
        {
            ledgerContract = new LedgerContract();

            ledgerContract.parmName(ledger.Name);
            ledgerContract.parmDescription(ledger.Description);

            ledgerList.addEnd(ledgerContract);
        }

        return ledgerList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMainAccountsForLedgerChartOfAccount</Name>
				<Source><![CDATA[
    public List getMainAccountsForLedgerChartOfAccount(LedgerChartOfAccountContract _ledgerChartOfAccount)
    {
        List                            mainAccountsList;
        Name                            ledgerChartOfAccountName = _ledgerChartOfAccount.parmName();
        MainAccount                     mainAccount;
        LedgerChartOfAccounts           ledgerChartOfAccounts;
        DimensionAttributeValue         dimAttrValue;
        MainAccountContract             contract;

        if (!_ledgerChartOfAccount)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        // Validate LedgerChartOfAccountContract
        DimensionServiceProvider::validateLedgerChartOfAccount(_ledgerChartOfAccount);

        mainAccountsList = new List(Types::Class);

        while select mainAccount
            outer join IsSuspended, IsBlockedForManualEntry, ActiveFrom, ActiveTo from dimAttrValue
                where dimAttrValue.EntityInstance == mainAccount.RecId &&
                    dimAttrValue.DimensionAttribute == DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount)
            exists join ledgerChartOfAccounts
                where ledgerChartOfAccounts.RecId == mainAccount.LedgerChartOfAccounts &&
                    ledgerChartOfAccounts.Name == ledgerChartOfAccountName
        {
            contract = new MainAccountContract();
            contract.parmMainAccountId(mainAccount.MainAccountId);
            contract.parmName(mainAccount.Name);
            contract.parmLedgerChartOfAccounts(ledgerChartOfAccountName);
            contract.parmType(mainAccount.Type);
            contract.parmReportingAccountType(mainAccount.ReportingAccountType);
            contract.parmAccountCategoryRef(mainAccount.AccountCategoryRef);
            contract.parmDebitCreditProposal(mainAccount.DebitCreditProposal);
            contract.parmDebitCreditCheck(mainAccount.DebitCreditCheck);
            contract.parmDebitCreditBalanceDemand(mainAccount.DebitCreditBalanceDemand);
            contract.parmExchangeAdjusted(mainAccount.ExchangeAdjusted);
            contract.parmClosing(mainAccount.Closing);
            contract.parmMandatoryPaymentReference(mainAccount.MandatoryPaymentReference);
            contract.parmConsolidationMainAccount(mainAccount.ConsolidationMainAccount);
            contract.parmSRUCode(mainAccount.sruCode);
            contract.parmCurrencyCode(mainAccount.CurrencyCode);
            contract.parmValidateCurrency(mainAccount.ValidateCurrency);
            contract.parmUserInfoId(mainAccount.UserInfoId);
            contract.parmValidateUser(mainAccount.ValidateUser);
            contract.parmPostingType(mainAccount.PostingType);
            contract.parmValidatePosting(mainAccount.ValidatePosting);

            if (mainAccount.OffsetLedgerDimension)
            {
                contract.parmOffsetLedgerDimension(LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(mainAccount.OffsetLedgerDimension));
            }

            if (mainAccount.OpeningAccount)
            {
                contract.parmOpeningAccount(MainAccount::find(mainAccount.OpeningAccount).MainAccountId);
            }

            contract.parmIsSuspended(dimAttrValue.IsSuspended);
            contract.parmIsBlockedforManualEntry(MainAccount::isBlockedForManualEntryByDimensionAttributeValue(dimAttrValue.RecId, curExt()));
            contract.parmActiveFrom(dimAttrValue.ActiveFrom);
            contract.parmActiveTo(dimAttrValue.ActiveTo);

            mainAccountsList.addEnd(contract);
        }

        return mainAccountsList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmValidateAllDimensionsAreApplied</Name>
				<Source><![CDATA[
	public boolean parmValidateAllDimensionsAreApplied(boolean _validateAllDimensionsAreApplied = validateAllDimensionsAreApplied)
    {
        validateAllDimensionsAreApplied = _validateAllDimensionsAreApplied;
        return validateAllDimensionsAreApplied;
	}

]]></Source>
			</Method>
			<Method>
				<Name>getStatusForBudgetAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the <c>DimensionValidationStatusContract</c> object for the specified <c>BudgetAccountValidationContract</c> object.
    /// </summary>
    /// <param name="_budgetAccountValidationContract">
    ///    The <c>BudgetAccountValidationContract</c> object.
    /// </param>
    /// <returns>
    ///    An instance of the <c>DimensionValidationStatusContract</c> contract containing the validation status.
    /// </returns>
    public DimensionValidationStatusContract getStatusForBudgetAccount(
        BudgetAccountValidationContract _budgetAccountValidationContract)
    {
        if (!_budgetAccountValidationContract)
        {
            throw AifFault::fault("@SYS326400", #DimensionValidationContractIsNotInitialized);
        }

        if (!_budgetAccountValidationContract.parmBudgetAccountContract())
        {
            throw AifFault::fault("@SYS326401", #FinancialDimensionCombinationIsNotSpecified);
        }

        BudgetDimensionCombinationServiceProvider serviceProvider =
            BudgetDimensionCombinationServiceProvider::newForBudgetAccountContract(_budgetAccountValidationContract.parmBudgetAccountContract());

        serviceProvider.parmValidateAllDimensionsAreApplied(validateAllDimensionsAreApplied);

        return serviceProvider.getValidationStatus(_budgetAccountValidationContract.parmValidDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatusForBudgetPlanning</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the <c>DimensionValidationStatusContract</c> object for the specified <c>BudgetPlanningValidationContract</c> object.
    /// </summary>
    /// <param name="_budgetPlanningValidationContract">
    ///    The <c>BudgetPlanningValidationContract</c> object.
    /// </param>
    /// <returns>
    ///    An instance of the <c>DimensionValidationStatusContract</c> contract containing the validation status.
    /// </returns>
    public DimensionValidationStatusContract getStatusForBudgetPlanning(
        BudgetPlanningValidationContract _budgetPlanningValidationContract)
    {
        if (!_budgetPlanningValidationContract)
        {
            throw AifFault::fault("@SYS326400", #DimensionValidationContractIsNotInitialized);
        }

        if (!_budgetPlanningValidationContract.parmBudgetPlanningContract())
        {
            throw AifFault::fault("@SYS326401", #FinancialDimensionCombinationIsNotSpecified);
        }

        BudgetPlanningDimensionCombinationServiceProvider serviceProvider =
            BudgetPlanningDimensionCombinationServiceProvider::newForBudgetPlanningAccountContract(
                _budgetPlanningValidationContract.parmBudgetPlanningContract());

        serviceProvider.parmValidateAllDimensionsAreApplied(validateAllDimensionsAreApplied);

        return serviceProvider.getValidationStatus(_budgetPlanningValidationContract.parmValidDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatusForLedgerAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the <c>DimensionValidationStatusContract</c> object for the <c>LedgerAccountValidationContract</c> object.
    /// </summary>
    /// <param name="_ledgerAccountValidationContract">
    ///    The <c>LedgerAccountValidationContract</c> object.
    /// </param>
    /// <returns>
    ///    An instance of the <c>DimensionValidationStatusContract</c> contract containing the validation status.
    /// </returns>
    public DimensionValidationStatusContract getStatusForLedgerAccount(
        LedgerAccountValidationContract _ledgerAccountValidationContract)
    {
        if (!_ledgerAccountValidationContract)
        {
            throw AifFault::fault("@SYS326400", #DimensionValidationContractIsNotInitialized);
        }

        if (!_ledgerAccountValidationContract.parmLedgerAccount())
        {
            throw AifFault::fault("@SYS326401", #FinancialDimensionCombinationIsNotSpecified);
        }

        LedgerDimensionCombinationServiceProvider serviceProvider =
            LedgerDimensionCombinationServiceProvider::newForLedgerAccountContract(_ledgerAccountValidationContract.parmLedgerAccount());

        serviceProvider.parmValidateAllDimensionsAreApplied(validateAllDimensionsAreApplied);

        return serviceProvider.getValidationStatus(_ledgerAccountValidationContract.parmValidDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes an incoming contract of the <c>BudgetAccountValidationContract</c> class.
    /// </summary>
    /// <param name="_budgetAccountValidationContract">
    ///    The <c>BudgetAccountValidationContract</c> contract.
    /// </param>
    /// <returns>
    ///    true if the budget account is valid; otherwise, false.
    /// </returns>
    public boolean validateBudgetAccount(BudgetAccountValidationContract _budgetAccountValidationContract)
    {
        return this.getStatusForBudgetAccount(_budgetAccountValidationContract).isValid();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetPlanningAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes an incoming contract of the <c>BudgetPlanningValidationContract</c> class.
    /// </summary>
    /// <param name="_budgetPlanningValidationContract">
    /// The <c>BudgetPlanningValidationContract</c> contract.
    /// </param>
    /// <returns>
    /// True if the budget Planning is valid; otherwise, false.
    /// </returns>
    public boolean validateBudgetPlanningAccount(BudgetPlanningValidationContract _budgetPlanningValidationContract)
    {
        return this.getStatusForBudgetPlanning(_budgetPlanningValidationContract).isValid();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes an incoming contract of the <c>LedgerAccountValidationContract</c> class.
    /// </summary>
    /// <param name="_ledgerAccountValidationContract">
    ///    The <c>LedgerAccountValidationContract</c> contract.
    /// </param>
    /// <returns>
    ///    true if the ledger account is valid; otherwise, false.
    /// </returns>
    public boolean validateLedgerAccount(LedgerAccountValidationContract _ledgerAccountValidationContract)
    {
        return this.getStatusForLedgerAccount(_ledgerAccountValidationContract).isValid();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildDimensionStorageAttributesAndValues</Name>
				<Source><![CDATA[
    //This method needs to be static so it can be called from buildDimensionStorageForLedgerAccount which is public static.
    private static void buildDimensionStorageAttributesAndValues(List _values, Map _dimensionSpecifiers)
    {
        ListEnumerator              listEnumerator;
        Name                        dimName;
        DimensionAttribute          dimAttr;
        DimensionValue              dimValue;
        DimensionAttributeValue     dimAttrValue;

        listEnumerator = _values.getEnumerator();

        while (listEnumerator.moveNext())
        {
            dimName = listEnumerator.current().parmName();
            dimAttr = DimensionAttribute::findByName(dimName);

            dimValue = listEnumerator.current().parmValue();
            dimAttrValue = DimensionAttributeValue::findByDimensionAttributeAndValue(dimAttr, dimValue, false, true);

            // A dimension attribute value is required.
            Debug::assert(dimAttrValue.RecId);

            LedgerDimensionDefaultingEngine::insertDimensionSpecifer(
                _dimensionSpecifiers,
                dimAttr.RecId,
                dimAttrValue.CachedDisplayValue,
                dimAttrValue.RecId,
                dimAttrValue.HashKey,
                dimAttrValue.EntityInstance);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildDimensionStorageForLedgerAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a dimension storage object from a ledger account contract.
    /// </summary>
    /// <param name = "_ledgerAccount">
    /// The ledger account contract used to build the dimension storage object.
    /// </param>
    /// <param name = "_createForDefaultAccount">
    /// true if a default account should be built; otherwise, false; optional.
    /// </param>
    /// <returns>
    /// The <c>DimensionStorage</c> instance built for the ledger account.
    /// </returns>
    public static DimensionStorage buildDimensionStorageForLedgerAccount(
        LedgerAccountContract   _ledgerAccount,
        boolean                 _createForDefaultAccount = false)
    {
        Name                            accountName;
        Map                             dimensionSpecifiers;
        List                            dimensionSources;
        MainAccount                     mainAccount;
        LedgerDimensionDefaultingEngine dimDefaultingEngine;
        LedgerRecId                     ledgerRecId;

        if (!_ledgerAccount)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        accountName = _ledgerAccount.parmMainAccount();
        mainAccount = MainAccount::findByMainAccountId(accountName);
        ledgerRecId = Ledger::current();

        dimDefaultingEngine = LedgerDimensionDefaultingEngine::constructForMainAccountId(mainAccount.RecId, DimensionHierarchy::getAccountStructure(mainAccount.RecId, ledgerRecId));

        if (_createForDefaultAccount)
        {
            // Additional items are invalid if creating DimensionStorage for DefaultAccount
            if (_ledgerAccount.parmValues() && _ledgerAccount.parmValues().elements())
            {
                throw AifFault::fault("@SYS326452", #DimensionContainerNotValidForDefaultAccount);
            }
        }
        else
        {
            // Setting up dimensions for DimensionStorage
            dimensionSpecifiers = LedgerDimensionDefaultingEngine::createEmptyDimensionSpecifiers();

            DimensionServiceProvider::buildDimensionStorageAttributesAndValues(_ledgerAccount.parmValues(), dimensionSpecifiers);

            dimensionSources = new List(Types::Class);
            dimensionSources.addEnd(dimensionSpecifiers);

            dimDefaultingEngine.applyDimensionSources(dimensionSources);
        }

        return dimDefaultingEngine.getStorage();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildDimStorageForBudgetPlanAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds an instance of the <c>DimensionStorage</c> class for a budget plan account structure based on the passed in <c>BudgetPlanningContract</c>.
    /// </summary>
    /// <param name="_budgetPlanningContract">
    /// The <c>BudgetPlanningContract</c> class which is used to read and validate the account structure as well as build the proper <c>DimensionStorage</c> class.
    /// </param>
    /// <returns>
    /// An instance of the <c>DimensionStorage</c> class specific to budget planning.
    /// </returns>
    public static DimensionStorage buildDimStorageForBudgetPlanAccount(BudgetPlanningContract _budgetPlanningContract)
    {
        RecId                       hierarchyId;
        Map                         dimensionSpecifiers;
        List                        dimensionSources = new List(Types::Class);
        LedgerDimensionDefaultingEngine dimDefaultingEngine;

        // Read and validate the Account Structure.
        hierarchyId = DimensionHierarchy::findByTypeAndName(DimensionHierarchyType::AccountStructure, _budgetPlanningContract.parmAccountStructure()).RecId;

        dimensionSpecifiers = LedgerDimensionDefaultingEngine::createEmptyDimensionSpecifiers();
        DimensionServiceProvider::buildDimensionStorageAttributesAndValues(_budgetPlanningContract.parmValues(), dimensionSpecifiers);
        dimDefaultingEngine = LedgerDimensionDefaultingEngine::constructForAccountStructure(hierarchyId, dimensionSpecifiers, LedgerDimensionType::BudgetPlanning);

        dimensionSources.addEnd(dimensionSpecifiers);
        dimDefaultingEngine.applyDimensionSources(dimensionSources);

        return dimDefaultingEngine.getStorage(LedgerDimensionType::BudgetPlanning);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerId</Name>
				<Source><![CDATA[
    private static RecId getLedgerId(LedgerName _ledgerName)
    {
        Ledger  ledger;

        select firstonly RecId from ledger where ledger.Name == _ledgerName;

        return ledger.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDimensionSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the dimension set object.
    /// </summary>
    /// <param name="_dimensionSet">
    /// The <c>DimensionSetContract</c> object to validate.
    /// </param>
    /// <remarks>
    /// This method will throw an exception if the account structure is not specified or does not exist or
    /// the specified ledger does not exist. It will also throw an exception if the
    /// <c>accountingDateFrom</c> value is the after <c>accountingDateTo</c> value in the specified
    /// <c>DimensionSetContract</c> object.
    /// </remarks>
    public static void validateDimensionSet(DimensionSetContract _dimensionSet)
    {
        RecId               ledgerId;
        RecId               hierarchyId;
        str                 attributeName, attributeValue;
        DimensionAttribute  dimensionAttribute;
        ListEnumerator      listEnumerator;
        boolean             throwError = false;

        // Validate the Account Strucutre.
        if (!_dimensionSet.parmCombination().parmDimensionSetName())
        {
            AifFault::checkFailedLogFault(strFmt("@SYS342561", _dimensionSet.parmCombination().parmDimensionSetName()), #AccountStructureDoesNotExist);
            throwError = true;
        }
        else
        {
            hierarchyId = DimensionHierarchy::findByTypeAndName(DimensionHierarchyType::Focus, _dimensionSet.parmCombination().parmDimensionSetName()).RecId;

            if (hierarchyId == 0)
            {
                AifFault::checkFailedLogFault(strFmt("@SYS342561", _dimensionSet.parmCombination().parmDimensionSetName()), #AccountStructureDoesNotExist);
                throwError = true;
            }
        }

        // Validate the passed in DimensionAttributes and Values.
        listEnumerator = _dimensionSet.parmCombination().parmValues().getEnumerator();

        while (listEnumerator.moveNext())
        {
            attributeName = listEnumerator.current().parmName();
            dimensionAttribute = DimensionAttribute::findByName(attributeName);
            if (!dimensionAttribute)
            {
                AifFault::checkFailedLogFault(strFmt("@SYS342559", attributeName), #DimensionAttributeDoesNotExist);
                throwError = true;
            }

            // Verify that the DimensionAttribute is in the specified Dimension Set Hierarchy.
            if (!LedgerDimensionHierarchyHelper::getAttributeLevel(hierarchyId, dimensionAttribute.RecId))
            {
                AifFault::checkFailedLogFault(strFmt("@SYS343094", attributeName, _dimensionSet.parmCombination().parmDimensionSetName()), #DimensionAttributeValueDoesNotExist);
                throwError = true;
            }

            attributeValue = listEnumerator.current().parmValue();
            if (!DimensionAttributeValue::findByDimensionAttributeAndValueNoError(dimensionAttribute, attributeValue, false, true))
            {
                AifFault::checkFailedLogFault(strFmt("@SYS342560", attributeValue), #DimensionAttributeValueDoesNotExist);
                throwError = true;
            }
        }

        // Validate the date values.
        if (_dimensionSet.parmAccountingDateFrom() || _dimensionSet.parmAccountingDateTo())
        {
            if (_dimensionSet.parmAccountingDateFrom() > _dimensionSet.parmAccountingDateTo())
            {
                AifFault::checkFailedLogFault(strFmt("@SYS326019", _dimensionSet.parmAccountingDateFrom(), _dimensionSet.parmAccountingDateTo()), #FromDateAfterToDate);
                throwError = true;
            }
        }

        // Determine if the Ledger Name is empty.  If so, default it.
        if (!_dimensionSet.parmLedgerName())
        {
            _dimensionSet.parmLedgerName(Ledger::name());
        }

        // Validate the Ledger Name is a valid Ledger.
        ledgerId = DimensionServiceProvider::getLedgerId(_dimensionSet.parmLedgerName());
        if (ledgerId == 0)
        {
            AifFault::checkFailedLogFault(strFmt("@SYS326020", _dimensionSet.parmLedgerName()), #LedgerDoesNotExist);
            throwError = true;
        }

        if (throwError)
        {
            throw AifFault::faultList("@SYS98197", #ValidationFailed);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerChartOfAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the <c>LedgerChartOfAccount</c> contract.
    /// </summary>
    /// <param name="_ledgerChartOfAccount">
    ///    The <c>LedgerChartOfAccountContract</c> class to validate.
    /// </param>
    public static void validateLedgerChartOfAccount(LedgerChartOfAccountContract _ledgerChartOfAccount)
    {
        Name    name = _ledgerChartOfAccount.parmName();

        // Name must be populated
        if (name == '')
        {
            throw AifFault::fault("@SYS324034", #NameNotSpecified);
        }
        else if (!LedgerChartOfAccounts::exist(name))
        {
            throw AifFault::fault(strFmt(LedgerChartOfAccounts::txtNotExist(), name), #LedgerChartOfAccountsDoesNotExist);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMainAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the <c>MainAccount</c> record.
    /// </summary>
    /// <param name="_mainAccount">
    ///    The <c>MainAccountContract</c> to validate.
    /// </param>
    /// <returns>
    ///    true if the <c>MainAccountContract</c> is valid; otherwise, false.
    /// </returns>
    public static boolean validateMainAccount(MainAccountContract _mainAccount)
    {
        MainAccount                 mainAccount;
        LedgerChartOfAccounts       ledgerChartOfAccounts;
        MainAccountNum              mainAccountId = _mainAccount.parmMainAccountId();
        Name                        ledgerChartOfAccountsName = _mainAccount.parmLedgerChartOfAccounts();
        boolean                     ret = true;

        // MainAccountId, Name, LedgerChartOfAccounts must be set.
        if (mainAccountId == '')
        {
            ret = AifFault::checkFailedLogFault("@SYS324035", #MainAccountIdNotSpecified);
        }

        if (_mainAccount.parmName() == '')
        {
            ret = AifFault::checkFailedLogFault("@SYS324034", #NameNotSpecified);
        }

        // LedgerChartOfAccounts must be set and be valid
        if (ledgerChartOfAccountsName == '')
        {
            ret = AifFault::checkFailedLogFault("@SYS324036", #LedgerChartOfAccountsNotSpecified);
        }
        else if (!LedgerChartOfAccounts::exist(ledgerChartOfAccountsName))
        {
            ret = AifFault::checkFailedLogFault(strFmt(LedgerChartOfAccounts::txtNotExist(), ledgerChartOfAccountsName), #LedgerChartOfAccountsDoesNotExist);
        }

        // Verify that the MainAccount record does not exist.
        if (ret)
        {
            select firstonly RecId from mainAccount
                where mainAccount.MainAccountId == mainAccountId
                exists join ledgerChartOfAccounts
                    where ledgerChartOfAccounts.RecId == mainAccount.LedgerChartOfAccounts &&
                        ledgerChartOfAccounts.Name == ledgerChartOfAccountsName;

            if (mainAccount.RecId != 0)
            {
                ret = AifFault::checkFailedLogFault(strFmt("@SYS324037", mainAccountId, ledgerChartOfAccountsName), #MainAccountAlreadyExists);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>