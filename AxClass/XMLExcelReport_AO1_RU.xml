<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>XmlExcelReport_AO1_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Class prints unified form AO-1 to excel.
/// </summary>
public class XmlExcelReport_AO1_RU extends XMLExcelReport_RU implements BatchRetryable, ERIReportPostProcessingSupported
{
    private const str LocalizationFeatureReference = 'EEU-00025';

    EmplAdvTable_RU             headerTable;
    EmplAdvLine_RU              lineTable;
    EmplTrans_RU                emplTrans;

    int                         iOrderNum;
    int                         jResult;
    int                         pageCount;

    str                         docTxt;
    str                         docAmount;

    AccountNum                  creditAccountNum;
    AccountNum                  debitAccountNum;

    Amount                      creditAmount;
    Amount                      debitAmount;
    Amount                      balanceMst;
    Amount                      balanceExchAdjMst;
    Amount                      totalSpendAmount;
    Amount                      sumAmountMst;
    TempStr                     sumAmountCur;
    Amount                      sumAmountMstAppr;
    TempStr                     sumAmountCurAppr;
    Amount                      assertAmount;
    Num                         assertDocNum;
    TempStr                     assertDocDate;

    TempStr                     amountApprTotal;
    TempStr                     amountApprTotalInNum;
    TempStr                     amountApprTotalInWords;
    TempStr                     countReasonDoc;
    TempStr                     countReasonDocPrep;
    TempStr                     docDeclension;
    TempStr                     pageDeclension;
    TempStr                     amountInWordsHeader1;
    TempStr                     amountInWordsHeader2;

    CurrencyCode                linesCurrency;
    CurrencyCode                standardCurrency;
    EmplAdvanceId_RU            advanceId;

    boolean                     lines_printed;
    boolean                     overDraft;
    boolean                     checkParm;
    boolean                     overExec;
    boolean                     showName;
    container                   contain;

    KeySum                      keySumDoc;
    Map                         spendLines;
    EmplTransSource_RU          source;
    EmplReport_Advance_RU       advanceReport;
    EmplAdvanceReport_Settle_RU settleAdvance;

    TransDate                   docDate;
    TempStr                     docNum;
    TempStr                     docName;
    CurrencyCode                curCode;
    MainAccountNum              mainAcc;
    AmountMST                   amtMst, amtMstAppr;
    TempStr                     amountCur, amountCurAppr;
    boolean                     curDiff;

    RNumDateInWordConverter     converter;

    LanguageId                  languageId;
    ExchRate                    newExchRate;

    #define.one(1)
    #define.two(2)
    #define.three(3)
    #define.four(4)
    #define.five(5)
    #define.six(6)

    #define.ReportHeader('REPORTHEADER')
    #define.PrevAdvance('PREVADVANCE')
    #define.AdvanceGrid('ADVANCEGRID')
    #define.Summary('SUMMARY')
    #define.OverUnder('OVERUNDER')
    #define.Accountant('ACCOUNTANT')
    #define.Receipt('RECEIPT')
    #define.PageHeader('PAGEHEADER')
    #define.ExpenseGrid('EXPENSEGRID')
    #define.Footer('FOOTER')
    #define.width(55)
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>amountAdvTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates value of line amount and tax line amount with exchange rate adjustment
    /// </summary>
    /// <param name="_exchAdjAmount">
    /// Exchange rate adjustment
    /// </param>
    /// <returns>
    /// Container with tax amount and line amount exlude tax
    /// </returns>
    container amountAdvTax(AmountMST _exchAdjAmount)
    {
        TaxAmount   taxAmount;
        Amount      amountExclTax;
        Amount      amountMstExclTax;

        amountExclTax = Tax::baseAmountExclTax(lineTable.TaxGroup,
                                               lineTable.TaxItemGroup,
                                               lineTable.DocumentDate,
                                               CompanyInfoHelper::standardCurrency(),
                                               _exchAdjAmount,
                                               TaxModuleType::Purch);

        taxAmount = lineTable.TaxAmountMST - _exchAdjAmount + amountExclTax;

        amountMstExclTax = lineTable.AmountMst - _exchAdjAmount - taxAmount;

        return [taxAmount, amountMstExclTax];
    }

]]></Source>
			</Method>
			<Method>
				<Name>applExec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills grid which contains data about expenses from this report
    /// </summary>
    #define.Value8(8)
    #define.Value2(2)
    #define.Value16(16)
    #define.four(4)
    #define.accPosInKey(5)

    protected void applExec()
    {
        KeySum                           keySumLine  = KeySum::construct(#five, #four);
        TaxEmplAdvance_RU                taxSource;
        Amount                           lineAmountWithTaxIn,
                                         lineAmountWithTaxMstIn,
                                         amountMST,
                                         tempAmount,
                                         tempAmountAppr, tmpTaxAmount;
        int                              i, j, y;
        CurrencyCode                     curArray[];
        TmpTaxWorkTrans                  tmpTaxWorkTrans;
        RecId                            headingRecId, prevHeadingRecId = 0, prevSourceRecId  = 0, prevLineTableRecId;
        container                        key, prevKey;
        Set                              headingSourceSet = new Set(Types::Container);
        ExchRate                         exchRate;
        AmountMST                        exchAdjAmount;
        TaxAmount                        taxAmount;
        Amount                           amountMstExclTax;

        boolean                         isAccountDistributed = false;
        real                            enteredRate;
        real                            lineRate;

        AccDistLedgerDimAmount                  accDistLedgerDimAmount;
        AccDistLedgerDimAmountList              accDistLedgerDimAmountList;
        AccDistLedgerDimAmountListEnumerator    accDistLedgerDimAmountListEnumerator;
        AccountingDistribution                  accountingDistribution;

        void insertTaxes(EmplAdvLine_RU _lineTable, RecId _hedingRecId, RecId _sourceRecId)
        {
            container                        keyLocal, dataLocal;
            int                              indexLocal;
            ExchRate                         exchRateTax = _lineTable.AmountMst / _lineTable.AmountCur * 100;
            MainAccountNum                   lineTableAccountNumLocal;

            if (headingSourceSet.add([_hedingRecId, _sourceRecId]))
            {
                newExchRate     = 0;
                exchAdjAmount   = 0;

                if (settleAdvance.keyCount(#six))
                {
                    for (y = 1; y <= settleAdvance.keyCount(#six); y++)
                    {
                        if (_lineTable.RecId == conPeek(settleAdvance.keyIndex(#six, y), #three))
                        {
                            exchAdjAmount  -= conPeek(settleAdvance.keyData(#six, y), #one);
                            newExchRate     = conPeek(settleAdvance.keyData(#six, y), #five);
                        }
                    }
                }

                lineTableAccountNumLocal = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(_lineTable.LedgerDimension);

                while select sum(SourceTaxAmountCur), sum(SourceRegulateAmountCur) from tmpTaxWorkTrans
                    group by LedgerDimension, TaxInCostPrice
                    where tmpTaxWorkTrans.HeadingRecId == _hedingRecId &&
                          tmpTaxWorkTrans.SourceRecId  == _sourceRecId
                {
                    tmpTaxAmount = tmpTaxWorkTrans.SourceRegulateAmountCur ?
                                   tmpTaxWorkTrans.SourceRegulateAmountCur :
                                   tmpTaxWorkTrans.SourceTaxAmountCur;
                    keyLocal = [_lineTable.DocumentDate,
                                _lineTable.DocumentNum,
                                _lineTable.DocumentName,
                                _lineTable.CurrencyCode,
                                tmpTaxWorkTrans.TaxInCostPrice ? lineTableAccountNumLocal : LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(tmpTaxWorkTrans.LedgerDimension),
                                _lineTable.LineType];

                    if (! tmpTaxWorkTrans.TaxInCostPrice)
                    {
                        indexLocal = keySumLine.key2Index_W(keyLocal);
                        if (indexLocal)
                        {
                            dataLocal = keySumLine.index2Data(indexLocal);
                            keySumLine.indexDelete_W(indexLocal);
                            keySumLine.updateNow(keyLocal, dataLocal);
                        }
                    }

                    if (newExchRate)
                    {
                        [taxAmount, amountMstExclTax] = this.amountAdvTax(exchAdjAmount);

                        keySumLine.updateNow(keyLocal,
                                              [CurrencyExchangeHelper::amount(tmpTaxAmount * _lineTable.AmountCur / _lineTable.AmountCurApproved, _lineTable.CurrencyCode),  //Entered
                                              tmpTaxAmount,                                     //Approved
                                              taxAmount * _lineTable.AmountCur /
                                              _lineTable.AmountCurApproved,                     //Entered
                                              taxAmount]);                                      //Approved
                    }
                    else
                    {
                        keySumLine.updateNow(keyLocal,
                                              [CurrencyExchangeHelper::amount(tmpTaxAmount * _lineTable.AmountCur / _lineTable.AmountCurApproved, _lineTable.CurrencyCode),  //Entered
                                              tmpTaxAmount,                                     //Approved
                                              CurrencyExchangeHelper::amountCur2MST(tmpTaxAmount * _lineTable.AmountCur / _lineTable.AmountCurApproved, _lineTable.CurrencyCode, 0, _lineTable.DocumentDate),  //Entered
                                              CurrencyExchangeHelper::amountCur2MST(tmpTaxAmount, _lineTable.CurrencyCode, 0, _lineTable.DocumentDate)]); //Approved
                    }
                }
            }
        }

        taxSource       = TaxEmplAdvance_RU::calcAndFillWorkTrans(headerTable);
        tmpTaxWorkTrans.setTmpData(taxSource.tmpTaxWorkTrans());

        while select lineTable
            order by DocumentDate, DocumentNum, DocumentName, CurrencyCode
            where lineTable.AdvanceId   == advanceId
        {
            curCode     = "@GLS102907" + lineTable.CurrencyCode;
            exchRate    = lineTable.AmountMst / lineTable.AmountCurApproved * 100;

            key     = [lineTable.DocumentDate,
                       lineTable.DocumentNum,
                       lineTable.DocumentName,
                       lineTable.CurrencyCode,
                       "",
                       lineTable.LineType];

            headingRecId = lineTable.LineType == EmplAdvLineType_RU::None?
                           lineTable.RecId : headerTable.RecId;
            // taxes
            if (prevHeadingRecId                   &&
                (prevHeadingRecId != headingRecId  ||
                 prevSourceRecId  != lineTable.EmplTransRecId ||
                 prevKey          != key))
            {
                insertTaxes(EmplAdvLine_RU::findRecId(prevLineTableRecId), prevHeadingRecId, prevSourceRecId);
            }
            prevHeadingRecId   = lineTable.LineType == EmplAdvLineType_RU::None
                                 ?
                                 lineTable.RecId : headerTable.RecId;
            prevSourceRecId    = lineTable.EmplTransRecId;
            prevLineTableRecId = lineTable.RecId;
            prevKey            = key;

            newExchRate     = 0;
            exchAdjAmount   = 0;

            if (settleAdvance.keyCount(#six))
            {
                for (y = 1; y <= settleAdvance.keyCount(#six); y++)
                {
                    if (lineTable.RecId == conPeek(settleAdvance.keyIndex(#six, y), #three))
                    {
                        exchAdjAmount  -= conPeek(settleAdvance.keyData(#six, y), #one);
                        newExchRate     = conPeek(settleAdvance.keyData(#six, y), #five);
                    }
                }
            }

            enteredRate = lineTable.AmountCur / lineTable.AmountCurApproved;

            accDistLedgerDimAmountList = AccDistLedgerDimAmountList::construct();
            if (lineTable.SourceDocumentLine)
            {
                SourceDocumentLineProvider::getAccDistLedgerDimAmountList(lineTable.SourceDocumentLine, accDistLedgerDimAmountList, false);
            }
            else
            {
                accountingDistribution.LedgerDimension = lineTable.LedgerDimension;
                accountingDistribution.AllocationFactor = 1;
                accountingDistribution.TransactionCurrencyAmount    = lineTable.AmountCurExclTax;
                accDistLedgerDimAmountList.addEnd(AccDistLedgerDimAmount::construct(accountingDistribution));
            }
            accDistLedgerDimAmountListEnumerator = accDistLedgerDimAmountList.getEnumerator();
            while (accDistLedgerDimAmountListEnumerator.moveNext())
            {
                accDistLedgerDimAmount = accDistLedgerDimAmountListEnumerator.current();
                key = conPoke(key, #accPosInKey, LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(accDistLedgerDimAmount.parmLedgerDimension()));
                lineRate    = accDistLedgerDimAmount.parmTransactionCurrencyAmount() / lineTable.AmountCurExclTax;
                if (lineTable.TaxGroup && lineTable.TaxItemGroup)
                {
                    [taxAmount, amountMstExclTax] = this.amountAdvTax(exchAdjAmount);

                    // amounts without taxes
                    keySumLine.updateNow(key,
                                         [lineTable.AmountCurExclTax * enteredRate * lineRate,  //Entered
                                         lineTable.AmountCurExclTax * lineRate,   //Approved
                                         (newExchRate ? amountMstExclTax : lineTable.AmountMstExclTax) * enteredRate * lineRate,  //Entered
                                         (newExchRate ? amountMstExclTax : lineTable.AmountMstExclTax) * lineRate ]); //Approved
                }
                else
                {
                    lineAmountWithTaxIn    = lineTable.AmountCur * lineRate;
                    lineAmountWithTaxMstIn = CurrencyExchangeHelper::amountCur2MST(lineAmountWithTaxIn, accDistLedgerDimAmount.parmTransactionCurrency(), newExchRate ? newExchRate : exchRate, headerTable.TransDate);

                    amountMST = CurrencyExchangeHelper::amountCur2MST(accDistLedgerDimAmount.parmTransactionCurrencyAmount(), accDistLedgerDimAmount.parmTransactionCurrency(), newExchRate ? newExchRate : exchRate, headerTable.TransDate) +
                                CurrencyExchangeHelper::amountCur2MST(lineAmountWithTaxIn - accDistLedgerDimAmount.parmTransactionCurrencyAmount(), accDistLedgerDimAmount.parmTransactionCurrency(), 0, headerTable.TransDate);

                    keySumLine.updateNow(key,
                                            [ lineTable.AmountCur * lineRate, //Entered
                                            accDistLedgerDimAmount.parmTransactionCurrencyAmount(), //Approved
                                            amountMST, //Entered
                                            (newExchRate ? (lineTable.AmountCurApproved * newExchRate / 100) : lineTable.AmountMst) * lineRate]); //Approved
                }
            }
        }

        lineTable = EmplAdvLine_RU::findRecId(prevLineTableRecId);
        if (lineTable)
        {
            insertTaxes(lineTable,
                        lineTable.LineType == EmplAdvLineType_RU::None
                        ?
                        lineTable.RecId : headerTable.RecId,
                        lineTable.EmplTransRecId);
        }

        [docDate, docNum, docName, curCode, mainAcc] = [dateNull(), "", "", "", ""];

        for (i=1; i<=keySumLine.numOfTrans(); i++)
        {
            [lineAmountWithTaxIn, lineAmountWithTaxMstIn, amtMst, amtMstAppr] = keySumLine.index2Data(i);
            [docDate, docNum, docName, curCode, mainAcc]    = keySumLine.index2Key(i);

            if (! curDiff)
            {
                for (j=1; j<=(i-1); j++)
                {
                    if (curArray[j] != curCode)
                    {
                        if (curArray[j] != standardCurrency && curCode != standardCurrency)
                        {
                            curDiff = true;
                            break;
                        }
                    }
                }
            }

            sumAmountMst     += amtMst;
            sumAmountMstAppr += amtMstAppr;
            if (curCode != standardCurrency)
            {
                tempAmount       += lineAmountWithTaxIn;
                tempAmountAppr   += lineAmountWithTaxMstIn;
            }
            curArray[i]       = curCode;
            amountCur         = strLTrim(num2str(lineAmountWithTaxIn,#Value16,#Value2,1,1) + "@GLS102907" + curCode);
            amountCurAppr     = strLTrim(num2str(lineAmountWithTaxMstIn,#Value16,#Value2,1,1) + "@GLS102907" + curCode);

            this.execute(#ExpenseGrid);
        }

        sumAmountCur     = strLTrim(num2str(tempAmount,#Value16,#Value2,1,1)); // + " " + curCode);
        sumAmountCurAppr = strLTrim(num2str(tempAmountAppr,#Value16,#Value2,1,1)); // + " " + curCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcRangeHeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates resizeable section height
    /// </summary>
    /// <param name="_bookmark">
    /// Name of section
    /// </param>
    /// <returns>
    /// Height of section
    /// </returns>
    /// <remarks>
    /// Not used in this report
    /// </remarks>
    protected real calcRangeHeight(Bookmark _bookmark)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcSpentAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates spent amount for each advance report line
    /// </summary>
    /// <returns>
    /// Map which holds data about spent amounts
    /// </returns>
    #define.Value2(2)
    private Map calcSpentAmount()
    {
        TaxTrans                         taxTrans;
        Map                              lineSum = new Map(Types::Container,Types::Container);
        EmplTrans_RU                     emplTransLocal;
        boolean                          insertSpentAmount;
        Set                              emplTransSet = new Set(typeName2Type(extendedTypeStr(RecId)));
        MainAccountNum                   lineTableAccountNum,
                                         localEmplTransAccountNum;

        AmountMST                       exchAdjAmount;
        boolean                         inheritInvoicePosting;
        boolean                         notSettlement;
        int                             y;
        AmountMST                       creditAmountMST;
        TaxAmount                       taxAmount;
        Amount                          amountMstExclTax;
        AccountingDistribution          accountingDistribution;

        MainAccountNum                  addDebitAccNum, addCreditAccNum;
        Amount                          addDebitAmount, addCreditAmount;
        real                            lineRate;

        AccDistLedgerDimAmount                  accDistLedgerDimAmount;
        AccDistLedgerDimAmountList              accDistLedgerDimAmountList;
        AccDistLedgerDimAmountListEnumerator    accDistLedgerDimAmountListEnumerator;

        void addLine(container _key, container _value)
        {
            container value = [0,0];

            if (lineSum.exists(_key))
            {
                value = lineSum.lookup(_key);
            }
            value = [conPeek(value,1) + conPeek(_value,1), conPeek(value,#Value2) + conPeek(_value,#Value2)];
            lineSum.insert(_key,value);
        }
        totalSpendAmount = 0;

        settleAdvance = new EmplAdvanceReport_Settle_RU(advanceId, headerTable.TransDate, advanceReport.parmSettleTable(), advanceReport.parmExchAdjUnrealizedTrans());
        settleAdvance.run();

        //Spent sum to key -->
        while select lineTable
            where lineTable.AdvanceId   == advanceId
        {
            select firstonly LedgerDimension from emplTransLocal
                where emplTransLocal.RecId == lineTable.EmplTransRecId;

            exchAdjAmount           = 0;
            newExchRate             = 0;
            creditAmountMST         = 0;
            insertSpentAmount       = true;
            inheritInvoicePosting   = false;
            notSettlement           = false;

            if (settleAdvance.keyCount(#six))
            {
                for (y = 1; y <= settleAdvance.keyCount(#six); y++)
                {
                    if (lineTable.RecId == conPeek(settleAdvance.keyIndex(#six, y), #three))
                    {
                        exchAdjAmount          -= conPeek(settleAdvance.keyData(#six, y), #one);
                        inheritInvoicePosting   = conPeek(settleAdvance.keyData(#six, y), #three);
                        notSettlement           = conPeek(settleAdvance.keyData(#six, y), #four);
                        newExchRate             = conPeek(settleAdvance.keyData(#six, y), #five);
                    }
                }
            }

            if (newExchRate)
            {
                creditAmountMST = CurrencyExchangeHelper::amount(lineTable.AmountCurExclTax * newExchRate / 100);
            }

            lineTableAccountNum      = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(lineTable.LedgerDimension);
            localEmplTransAccountNum = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(emplTransLocal.LedgerDimension);

            if (lineTable.TaxAmount && emplTransSet.add(lineTable.EmplTransRecId))
            {
                while select TableId from emplTrans
                    where emplTrans.RecId == lineTable.EmplTransRecId
                join TaxAmount, SourceTaxAmountCur, TaxInCostPrice, TaxBaseAmount, RecId from taxTrans
                     where taxTrans.Voucher   == emplTrans.Voucher    &&
                           taxTrans.TransDate == emplTrans.TransDate
                {
                    if (newExchRate)
                    {
                        [taxAmount, amountMstExclTax] = this.amountAdvTax(exchAdjAmount);

                        creditAmountMST = taxAmount + amountMstExclTax;

                        addLine([localEmplTransAccountNum, taxTrans.TaxInCostPrice ? lineTableAccountNum : taxTrans.accountName()],
                                [taxAmount, insertSpentAmount ? creditAmountMST : 0]);
                    }
                    else
                    {
                        addLine([localEmplTransAccountNum, taxTrans.TaxInCostPrice ? lineTableAccountNum : taxTrans.accountName()],
                                [taxTrans.TaxAmount, insertSpentAmount ? lineTable.AmountMst : 0]);
                    }
                    insertSpentAmount = false;
                }
            }

            accDistLedgerDimAmountList = AccDistLedgerDimAmountList::construct();
            if (lineTable.SourceDocumentLine)
            {
                SourceDocumentLineProvider::getAccDistLedgerDimAmountList(lineTable.SourceDocumentLine, accDistLedgerDimAmountList, false);
            }
            else
            {
                accountingDistribution.LedgerDimension = lineTable.LedgerDimension;
                accountingDistribution.AllocationFactor = 1;
                accountingDistribution.TransactionCurrencyAmount    = lineTable.AmountCurExclTax;
                accDistLedgerDimAmountList.addEnd(AccDistLedgerDimAmount::construct(accountingDistribution));
            }

            accDistLedgerDimAmountListEnumerator    = accDistLedgerDimAmountList.getEnumerator();

            addDebitAccNum                          = localEmplTransAccountNum;
            while (accDistLedgerDimAmountListEnumerator.moveNext())
            {
                accDistLedgerDimAmount  = accDistLedgerDimAmountListEnumerator.current();
                addCreditAccNum         = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(accDistLedgerDimAmount.parmLedgerDimension());
                lineRate                = accDistLedgerDimAmount.parmTransactionCurrencyAmount() / lineTable.AmountCurExclTax;

                if (newExchRate)
                {
                    addDebitAmount  = (lineTable.AmountCurExclTax * newExchRate / 100) * lineRate;
                    addCreditAmount = insertSpentAmount ? (lineTable.AmountCurApproved * newExchRate / 100) * lineRate : 0;
                }
                else
                {
                    addDebitAmount  = lineTable.AmountMstExclTax * lineRate;
                    addCreditAmount = insertSpentAmount ? (lineTable.AmountMst * lineRate) : 0;
                }

                addLine([addDebitAccNum, addCreditAccNum], [addDebitAmount, addCreditAmount]);
            }
            totalSpendAmount += (! notSettlement && inheritInvoicePosting) ? lineTable.AmountMst :
                                creditAmountMST ? creditAmountMST : (lineTable.AmountMst - exchAdjAmount);
        }
        //<--

        return lineSum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes report
    /// </summary>
    protected void createReport()
    {
        curWorksheetNum = 1;
        widthCols       = #width;

        this.printAdvanceOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayAccountant</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns accountant name for this report
    /// </summary>
    /// <returns>
    /// Accountant name for this report
    /// </returns>
    #define.Value12(12)
    protected EmplName displayAccountant()
    {
        return conPeek(contain,#Value12);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayAccountantJ</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns name of accountand specified for this report
    /// </summary>
    /// <returns>
    /// Name of accountand specified for this report
    /// </returns>
    #define.Value13(13)
    protected EmplName displayAccountantJ()
    {
        return conPeek(contain,#Value13);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayAdvanceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns report's Advance ID
    /// </summary>
    /// <returns>
    /// Advance report ID
    /// </returns>
    protected EmplAdvanceId_RU displayAdvanceId()
    {
        return conPeek(contain,1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayAssertAmountCOP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns amount of cents for over or under expenditure
    /// </summary>
    /// <returns>
    /// Amount of cents for over or under expenditure
    /// </returns>
    protected AmountCur displayAssertAmountCOP()
    {
        return real2int(assertAmount * 100) mod 100 / 100;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayAssertAmountRUR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns amount of over or under expenditure without cents
    /// </summary>
    /// <returns>
    /// Amount of over or under expenditure without cents
    /// </returns>
    protected AmountCur displayAssertAmountRUR()
    {
        return real2int(assertAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns incoming balance for this advance holder
    /// </summary>
    /// <returns>
    /// Incoming balance for this advance holder
    /// </returns>
    protected AmountMST displayBalance()
    {
        return abs(balanceMst - balanceExchAdjMst);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayBalanceExchAdj</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns balance of exchange rate adjustment
    /// </summary>
    /// <returns>
    /// Balance of exchange rate adjustment
    /// </returns>
    protected AmountMST displayBalanceExchAdj()
    {
        return sign(balanceMst) * balanceExchAdjMst;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCashier</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns cashier name for this company
    /// </summary>
    /// <returns>
    /// Cashier name for this company
    /// </returns>
    #define.Value14(14)
    protected EmplName displayCashier()
    {
        return conPeek(contain,#Value14);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayChiefName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns director name for this company
    /// </summary>
    /// <returns>
    /// Director name for this company
    /// </returns>
    #define.Value10(10)
    protected Name displayChiefName()
    {
        return conPeek(contain,#Value10);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayChiefTitle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns director title for this company
    /// </summary>
    /// <returns>
    /// Director title for this company
    /// </returns>
    #define.Value11(11)
    protected EmployeeTitle_RU displayChiefTitle()
    {
        return conPeek(contain, #Value11);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCompanyName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns company name
    /// </summary>
    /// <returns>
    /// Company name
    /// </returns>
    #define.Value4(4)
    protected CompanyName displayCompanyName()
    {
        return conPeek(contain, #Value4);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayConfirmSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns confirmed(approved) amount in digits
    /// </summary>
    /// <returns>
    /// Confirmed(approved) amount in digits
    /// </returns>
    protected str displayConfirmSum()
    {
        return '(' + amountApprTotal + ')';
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns report date
    /// </summary>
    /// <returns>
    /// Advance report date
    /// </returns>
    #define.Value3(3)
    protected TempStr displayDate()
    {
        return conPeek(contain, #Value3);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayDateShort</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns advance report date converted to string in digits
    /// </summary>
    /// <returns>
    /// Advance report date converted to string in digits
    /// </returns>
    #define.posShortDate(2)
    protected str displayDateShort()
    {
        return conPeek(contain, #posShortDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayDepartment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns name of department advance holder belongs to
    /// </summary>
    /// <returns>
    /// Name of department advance holder belongs to
    /// </returns>
    #define.Value8(8)
    protected StructDepartment_RU displayDepartment()
    {
        return conPeek(contain,#Value8);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayEmplId</Name>
				<Source><![CDATA[
    /// <summary>
    /// returns employee Id this report belong to
    /// </summary>
    /// <returns>
    /// Employee Id this report belong to
    /// </returns>
    #define.Value5(5)
    protected str displayEmplId()
    {
        return conPeek(contain,#Value5);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayEmplName</Name>
				<Source><![CDATA[
    /// <summary>
    /// returns employee name this report belong to
    /// </summary>
    /// <returns>
    /// Employee name this report belong to
    /// </returns>
    #define.Value6(6)
    protected Name displayEmplName()
    {
        return conPeek(contain,#Value6);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayEmplPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// returns employee position this report belong to
    /// </summary>
    /// <returns>
    /// Employee position this report belong to
    /// </returns>
    #define.Value7(7)
    protected Position displayEmplPosition()
    {
        return conPeek(contain,#Value7);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayLinesCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns currency of report line converted to upper case
    /// </summary>
    /// <returns>
    /// Currency of report line converted to upper case
    /// </returns>
    protected CurrencyCode displayLinesCurrency()
    {
        return strUpr(linesCurrency);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayOKPO</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets company's OKPO code
    /// </summary>
    /// <returns>
    /// Company's OKPO code
    /// </returns>
    #define.AODatePosition(19)
    protected OKPO_RU displayOKPO()
    {
        return CompanyInfoHelper::partyOKPOasOfDate_RU(CompanyInfo::find(), conPeek(contain, #AODatePosition));
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTarget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns notes for this advance report
    /// </summary>
    /// <returns>
    /// Notes for this advance report
    /// </returns>
    #define.Value17(17)
    protected TempStr displayTarget()
    {
        return conPeek(contain,#Value17);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fileName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Name of the new file
    /// </summary>
    /// <returns>
    /// Name of the new file
    /// </returns>
    protected Filename fileName()
    {
        return 'AdvanceOrder';
    }

]]></Source>
			</Method>
			<Method>
				<Name>fileNamePostfix</Name>
				<Source><![CDATA[
    /// <summary>
    /// Postfix for a new file
    /// </summary>
    /// <returns>
    /// number of advance id
    /// </returns>
    protected Filename fileNamePostfix()
    {
        return advanceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportFileName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the name of the report file.
    /// </summary>
    /// <returns>
    /// The name of the report file.
    /// </returns>
    public str getReportFileName()
    {
        return this.excelFileName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the name of the report.
    /// </summary>
    /// <returns>
    /// Name of the report.
    /// </returns>
    public str getReportName()
    {
        return 'AO1';
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillAccountant</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills Accountant section with data
    /// </summary>
    protected void fillAccountant()
    {
        this.insertValueToSection('CashierName', this.displayCashier());
        this.insertValueToSection('CashierDate', this.displayDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillAdvanceGrid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills AdvanceGrid section with data
    /// </summary>
    protected void fillAdvanceGrid()
    {
        this.insertValueToSection('DocTxt'        , docTxt);
        this.insertValueToSection('DocAmount'     , docAmount);
        this.insertValueToSection('DebetAccount'  , debitAccountNum);

        if (debitAmount)
        {
            this.insertValueToSection('DebetAmount'   , debitAmount);
        }
        else
        {
            this.insertValueToSection('DebetAmount'   , "");
        }

        this.insertValueToSection('CreditAccount' , creditAccountNum);

        if (creditAmount)
        {
            this.insertValueToSection('CreditAmount'  , creditAmount);
        }
        else
        {
            this.insertValueToSection('CreditAmount'  , "");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills specified section with data
    /// </summary>
    /// <param name="_bookmark">
    /// Name of section
    /// </param>
    protected void fillData(MSOfficeBookMark_RU _bookmark)
    {
        switch (_bookmark)
        {
            case #ReportHeader:
                this.fillReportHeader();
                break;
            case #PrevAdvance:
                this.fillPrevAdvance();
                break;
            case #AdvanceGrid:
                this.fillAdvanceGrid();
                break;
            case #Summary:
                this.fillSummary();
                break;
            case #OverUnder:
                this.fillOverUnder();
                break;
            case #Accountant:
                this.fillAccountant();
                break;
            case #Receipt:
                this.fillReceipt();
                break;
            case #ExpenseGrid:
                this.fillExpenseGrid();
                break;
            case #Footer:
                this.fillFooter();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillExpenseGrid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills ExpenseGrid section with data
    /// </summary>
    protected void fillExpenseGrid()
    {
        this.insertValueToSection('LineNum', this.lineNum());
        this.insertValueToSection('DocDate', docDate);
        this.insertValueToSection('DocNum', docNum);
        this.insertValueToSection('DocName', docName);
        this.insertValueToSection('AmountMST', amtMst);
        this.insertValueToSection('AmountMSTApprove', amtMstAppr);
        this.insertValueToSection('LedAcc', mainAcc);

        if (curCode != standardCurrency)
        {
            this.insertValueToSection('AmountCur', strRTrim(amountCur));
            this.insertValueToSection('AmountCurApprove', strRTrim(amountCurAppr));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillFooter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills Footer section with data
    /// </summary>
    protected void fillFooter()
    {
        this.insertValueToSection('TotalAmountMST', sumAmountMst);
        this.insertValueToSection('TotalAmountMSTAppr', sumAmountMstAppr);

        if (curCode != standardCurrency)
        {
            this.insertValueToSection('TotalAmountCur', sumAmountCur);
            this.insertValueToSection('TotalAmountCurAppr', sumAmountCurAppr);
        }

        this.insertValueToSection('FooterEmplName', this.displayEmplName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillOverUnder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills OverUnder section with data
    /// </summary>
    protected void fillOverUnder()
    {
        if (assertAmount)
        {
            this.insertValueToSection('AmountRUR'     , this.displayAssertAmountRUR());
            this.insertValueToSection('AmountCOP'     , this.displayAssertAmountCOP());
            this.insertValueToSection('CashOrder'     , assertDocNum);
            this.insertValueToSection('CashOrderDate' , assertDocDate);
        }

        if (!showName)
        {
            this.insertValueToSection('RemainderPaid'     , #blank);
            this.insertValueToSection('ExpenditureGiven'  , #blank);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillPrevAdvance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills PrevAdvance section with data
    /// </summary>
    protected void fillPrevAdvance()
    {
        if (balanceMst < 0)
        {
            this.insertValueToSection('Overdraft', this.displayBalance());
        }
        if (balanceMst > 0)
        {
            this.insertValueToSection('Remainder', this.displayBalance());
        }

        this.insertValueToSection('ExchAdj', this.displayBalanceExchAdj());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills Receipt section with data
    /// </summary>
    protected void fillReceipt()
    {
        this.insertValueToSection('ReceiptEmplName'       , this.displayEmplName());
        this.insertValueToSection('ReceiptAdvNo'          , this.displayAdvanceId());
        this.insertValueToSection('ReceiptAdvDate'        , this.displayDate());
        this.insertValueToSection('ReceiptAmountTxt'      , amountApprTotalInWords);
        this.insertValueToSection('ReceiptDocCount'       , countReasonDoc);
        this.insertValueToSection('ReceiptDocCountPrep'   , countReasonDocPrep);
        this.insertValueToSection('ReceiptDocCountDecl'   , pageDeclension);
        this.insertValueToSection('ReceiptAccountant'     , this.displayAccountantJ());
        this.insertValueToSection('ReceiptDate'           , this.displayDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillReportHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills ReportHeader section with data
    /// </summary>
    protected void fillReportHeader()
    {
        this.insertValueToSection('CompanyName'           , this.displayCompanyName());
        this.insertValueToSection('AdvanceId'             , this.displayAdvanceId());
        this.insertValueToSection('Date'                  , this.displayDateShort());
        this.insertValueToSection('OKPO'                  , this.displayOKPO());
        this.insertValueToSection('AmountInWordsHeader1'  , amountInWordsHeader1);
        this.insertValueToSection('AmountInWordsHeader2'  , amountInWordsHeader2);
        this.insertValueToSection('ChiefTitle'            , this.displayChiefTitle());
        this.insertValueToSection('ChiefName'             , this.displayChiefName());
        this.insertValueToSection('EmplName'              , this.displayEmplName());
        this.insertValueToSection('EmplPosition'          , this.displayEmplPosition());
        this.insertValueToSection('Department'            , this.displayDepartment());
        this.insertValueToSection('EmplId'                , this.displayEmplId());
        this.insertValueToSection('Target'                , this.displayTarget());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSummary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills Summary section with data
    /// </summary>
    protected void fillSummary()
    {
        this.insertValueToSection('CountReasonDoc', countReasonDoc);
        this.insertValueToSection('DocDeclension', docDeclension);
        this.insertValueToSection('CountReasonDocPrep', countReasonDocPrep);
        this.insertValueToSection('PageDeclension', pageDeclension);

        this.insertValueToSection('AmountApprovedTotalInWords', amountApprTotalInWords);
        this.insertValueToSection('ConfirmSum', this.displayConfirmSum());

        this.insertValueToSection('ChiefAccountantName', this.displayAccountant());
        this.insertValueToSection('AccountantName', this.displayAccountantJ());
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes report data
    /// </summary>
    /// <returns>
    /// returns true if report initialized successfully, otherwise false
    /// </returns>
    #define.Value3(3)
    #define.Value2(2)
    #define.Value16(16)
    public boolean init()
    {
        CurrencyNameDeclension_RU   curDec;

        advanceReport = args.caller();
        languageId    = CompanyInfo::languageId();

        contain     = advanceReport.parmContain();
        advanceId   = conPeek(contain, 1);
        headerTable = advanceReport.parmHeaderTable();
        checkParm   = true;

        converter   = RNumDateInWordConverter::construct(languageId);

        if (! (contain && advanceId))
        {
            checkParm = checkFailed("@SYS32665");
        }

        spendLines          = this.calcSpentAmount();

        while select lineTable
            group by DocumentDate,
                     DocumentNum,
                     DocumentName
            where lineTable.AdvanceId == advanceId
        {
            pageCount++;
        }

        standardCurrency = CompanyInfoHelper::standardCurrency();

        if (totalSpendAmount == 0 || pageCount == 0)
        {
            checkParm = checkFailed("@GLS101896");
        }

        linesCurrency          = (select firstonly CurrencyCode from emplAdvLine_RU
                                    where emplAdvLine_RU.AdvanceId    == advanceId  &&
                                          emplAdvLine_RU.CurrencyCode != standardCurrency).CurrencyCode;

        GlobalizationInstrumentationHelper::featureRun(LocalizationFeatureReference, funcName());

        curDec = CurrencyNameDeclension_RU::find(linesCurrency, languageId);
        if ((curDec.ShortName && curDec.ShortNamePenny))
        {
            curDec = CurrencyNameDeclension_RU::find(standardCurrency, languageId);
        }
        if (curDec && ! (curDec.ShortName && curDec.ShortNamePenny) && standardCurrency)
        {
            warning(strFmt("@GLS104626", curDec.CurrencyCode));
        }

        this.pageNumDeclension();
        countReasonDoc         = converter.numeralsToTxt(pageCount);
        countReasonDocPrep     = converter.numeralsToTxt(pageCount, true, true);

        amountApprTotal        = CurrencyNameDeclension_RU::numeralsToCurrencyShort(totalSpendAmount, standardCurrency);
        amountApprTotalInNum   = num2str(totalSpendAmount, #Value16, #Value2, #Value2, #Value3);
        amountApprTotalInWords = converter.numeralsToCurrency(totalSpendAmount, standardCurrency);

        lines_printed          = false;

        return checkParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSectionMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method initializes map which holds section data
    /// </summary>
    protected void initSectionMap()
    {
        this.addSection(#ReportHeader);
        this.addSection(#PrevAdvance);
        this.addSection(#AdvanceGrid);
        this.addSection(#Summary);
        this.addSection(#OverUnder);
        this.addSection(#Accountant);
        this.addSection(#Receipt);
        this.addSection(#PageHeader);
        this.addSection(#ExpenseGrid);
        this.addSection(#Footer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSplitText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes texts which have to be splitted between several lines of report
    /// </summary>
    #define.AmountApprTotal(21)
    protected void initSplitText()
    {
        [amountInWordsHeader1, amountInWordsHeader2] = XMLExcelReport_RU::splitStrByLines(amountApprTotalInWords, [#AmountApprTotal]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and returns current line num
    /// </summary>
    /// <returns>
    /// Current line num
    /// </returns>
    protected int lineNum()
    {
        iOrderNum ++;
        return iOrderNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>overDocExec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Excecutes section of report which contains data about over or under expenditures
    /// </summary>
    #define.Value123(123)
    protected void overDocExec()
    {
        int         i;
        RCashDocId  docId;

        void clearAssert()
        {
            assertAmount  = 0;
            assertDocNum  = "";
            assertDocDate = "";
        }

        showName = true;
        clearAssert();
        if (settleAdvance.keyCount(#three))
        {
            overExec  = true;

            for (i=1; i<=settleAdvance.keyCount(#three); i++)
            {
                assertDocNum  = conPeek(settleAdvance.keyIndex(#three, i), #one);
                [assertAmount, assertDocDate]  = settleAdvance.keyData(#three, i);
                assertAmount = abs(assertAmount);
                docId = (select firstonly DocId from rCashTrans
                           where rCashTrans.Voucher    == assertDocNum &&
                                 rCashTrans.TransDate  == str2Date(assertDocDate,#Value123)).DocId;
                assertDocNum = docId ? docId : assertDocNum;
                this.execute(#OverUnder);
                showName  = false;
            }
        }
        else
        {
            this.execute(#OverUnder);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>overExec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills advancegrid with data
    /// </summary>
    #define.Value3(3)
    #define.Value2(2)
    #define.Value16(16)
    protected void overExec()
    {
        AmountMST           tmpAmount;
        int                 i;
        boolean             retplus, retminus;

        void execEmpty()
        {
            creditAmount      = 0;
            debitAmount       = creditAmount;
            creditAccountNum  = "";
            debitAccountNum   = "";

            this.execute(#AdvanceGrid);
        }

        tmpAmount  = balanceMst - totalSpendAmount;

        for (i=1; i<=settleAdvance.keyCount(#two); i++)
        {
           docTxt    = "";
           docAmount = "";

            if (conPeek(settleAdvance.keyData(#two, i), #one) < 0)
            {
                if (! retplus)
                {
                    docTxt            = SysLabel::labelId2String(literalStr("@GLS103658"), languageId);
                    docAmount         = tmpAmount >= 0 ? num2str(abs(tmpAmount), #Value16, #Value2, #Value2, #Value3) : "";
                    retplus           = true;
                }
                creditAmount      = abs( conPeek(settleAdvance.keyData(#two, i), #one));
                debitAmount       = creditAmount;
                creditAccountNum  = conPeek(settleAdvance.keyData(#two, i), #two);
                debitAccountNum   = conPeek(settleAdvance.keyIndex(#two, i), #one);

                this.execute(#AdvanceGrid);
            }
            else
            {
                if (! retminus)
                {
                    docTxt            = SysLabel::labelId2String(literalStr("@GLS103658"), languageId);
                    docAmount         = "";
                    execEmpty();
                    docTxt            = SysLabel::labelId2String(literalStr("@GLS101914"), languageId);
                    docAmount         = tmpAmount < 0 ? num2str(abs(tmpAmount), #Value16, #Value2, #Value2, #Value3) : "";
                    retminus          = true;
                }
                creditAmount      = settleAdvance.keyData(#two, i);
                debitAmount       = creditAmount;
                creditAccountNum  = conPeek(settleAdvance.keyIndex(#two, i), #one);
                debitAccountNum   = conPeek(settleAdvance.keyData(#two, i), #two);

                this.execute(#AdvanceGrid);
            }
        }

        if (! retplus && ! retminus)
        {
            docTxt            = SysLabel::labelId2String(literalStr("@GLS103658"), languageId);
            docAmount         = tmpAmount >= 0 ? num2str(abs(tmpAmount), #Value16, #Value2, #Value2, #Value3) : "";
            execEmpty();
        }
        if (! retminus)
        {
            docTxt            = SysLabel::labelId2String(literalStr("@GLS101914"), languageId);
            docAmount         = tmpAmount < 0 ? num2str(abs(tmpAmount), #Value16, #Value2, #Value2, #Value3) : "";
            execEmpty();
        }

        overDraft = retminus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pageNumDeclension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates description how many pages there are in report
    /// </summary>
    /// <remarks>
    /// Description how many pages there are in report
    /// </remarks>
    #define.Value100(100)
    #define.Value20(20)
    #define.Value4(4)
    #define.Value3(3)
    #define.Value2(2)
    #define.Value10(10)
    protected void pageNumDeclension()
    {
        void makeText(int        _digits,
                      container  _docEnd,
                      container  _pageEnd)
        {
            if (_digits >= #Value100)
            {
                _digits = _digits mod #Value100;
            }
            if (_digits >= #Value20)
            {
                _digits = _digits mod #Value10;
            }
            switch (_digits)
            {
                case 1:
                    docDeclension  = conPeek(_docEnd, 1);
                    pageDeclension = conPeek(_pageEnd, 1);
                    break;
                case #Value2,#Value3,#Value4:
                    docDeclension  = conPeek(_docEnd, #Value2);
                    pageDeclension = conPeek(_pageEnd, #Value2);
                    break;
                default:
                   docDeclension   = conPeek(_docEnd, #Value3);
                   pageDeclension  = conPeek(_pageEnd, #Value3);
                   break;
            }
        }

        makeText(pageCount,
                 [SysLabel::labelId2String(literalStr("@GLS104627"), languageId),
                  SysLabel::labelId2String(literalStr("@GLS102449"), languageId),
                  SysLabel::labelId2String(literalStr("@GLS101925"), languageId)],
                 [SysLabel::labelId2String(literalStr("@GLS104628"),languageId),
                  SysLabel::labelId2String(literalStr("@GLS100900"), languageId),
                  SysLabel::labelId2String(literalStr("@GLS100900"), languageId)]);

        docDeclension += "@GLS102907" + SysLabel::labelId2String(literalStr("@GLS111248"), languageId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printAdvanceOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains main logic of creation of report
    /// </summary>
    protected void printAdvanceOrder()
    {
        boolean pageBreakInserted;

        pageHeight = document.getPageHeight(curWorksheetNum);

        this.initSectionMap();
        this.initSplitText();

        document.setWorksheetSpans(#width, curWorksheetNum);

        this.execute(#ReportHeader);

        this.settleExec(); //Settlement and incoming balance

        this.spentExec();  //Spent sum

        this.overExec();   //Overhead (outgoing balance)

        this.execute(#Summary);
        this.overDocExec(); //Print overhead documents

        this.execute(#Accountant);

        if (currentHeight > pageHeight)
        {
            document.insertPageBreak(currentRow, curWorksheetNum);
            pageBreakInserted = true;
        }

        this.execute(#Receipt);

        if (!pageBreakInserted)
        {
            document.insertPageBreak(currentRow, curWorksheetNum);
        }

        this.execute(#PageHeader);

        this.applExec();   //Application

        this.execute(#Footer);

        this.setPrintArea();
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes report
    /// </summary>
    public void run()
    {
        if (this.init())
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleExec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills top grid of report, which shows data about previuos advances
    /// </summary>
    #define.Value3(3)
    #define.Value2(2)
    #define.Value16(16)
    protected void settleExec()
    {
        //Definition -->
        AmountMST                       tmpAmount;
        MainAccountNum                  keyAccount, keyOffsetAccount;
        CurrencyCode                    keyCurrency;
        Voucher                         keyVoucher;
        int                             i;

        #define.four(4)
        #define.five(5)
        #define.six(6)

        //Print exchange adjustments -->
        Amount exchAdjustments(int _key, boolean _print = true)
        {
            Voucher         tmpVoucher;
            MainAccountNum  tmpLedger;
            Amount          tmplTransAmount, tmpTransAmountTotal;
            int             y;
            boolean         correct;

            for (y = 1; y <= settleAdvance.keyCount(_key); y++)
            {
                if (_key == #six)
                {
                    if (conPeek(settleAdvance.keyData(_key, y), #three) == true)
                    {
                        continue;
                    }
                }

                [tmpVoucher, tmpLedger] = settleAdvance.keyIndex(_key, y);
                if (tmpVoucher == keyVoucher)
                {
                    tmplTransAmount     =  conPeek(settleAdvance.keyData(_key, y), #one);
                    correct             =  conPeek(settleAdvance.keyData(_key, y), #six);
                    tmpTransAmountTotal += tmplTransAmount;

                    if (_print)
                    {
                        docTxt            = '';
                        docAmount         = '';
                        creditAccountNum  = debitAccountNum;
                        debitAmount       = correct ? tmplTransAmount : abs(tmplTransAmount);
                        creditAmount      = debitAmount;

                        if  ((tmplTransAmount > 0) || correct)
                        {
                            debitAccountNum   = tmpLedger;
                            creditAccountNum  = conPeek(settleAdvance.keyData(_key, y), #two);
                        }
                        else
                        {
                            creditAccountNum  = tmpLedger;
                            debitAccountNum   = conPeek(settleAdvance.keyData(_key, y), #two);
                        }

                        this.execute(#AdvanceGrid);
                    }
                }
            }
            return tmpTransAmountTotal;
        }
        //<--

        //Print issued documents -->
        void mainAccounts(boolean _empty = false)
        {
            if (! _empty)
            {
                debitAmount  = conPeek(settleAdvance.keyData(#one, i), #one);

                if (debitAmount)
                {
                    debitAccountNum   = keyOffsetAccount;
                    creditAccountNum  = keyAccount;
                    creditAmount      = debitAmount;
                }
            }
            else
            {
                debitAmount       = 0;
                debitAccountNum   = "";
                creditAccountNum  = "";
                creditAmount      = debitAmount;
            }
        }
        //<--

        balanceMst        = settleAdvance.balanceMst();
        balanceExchAdjMst = settleAdvance.balanceExchAdjMst();

        this.execute(#PrevAdvance);

        if (! balanceExchAdjMst)
        {
            document.deleteRow(currentRow, curWorkSheetNum);
            currentRow--;
        }

        if (! settleAdvance.keyCount(#one))
        {
            docTxt     = strFmt(SysLabel::labelId2String(literalStr("@GLS103656"), languageId), #one);
            docAmount  = "";

            this.execute(#AdvanceGrid);

            docTxt     = strFmt(SysLabel::labelId2String(literalStr("@GLS103657"), languageId), #one, "");

            this.execute(#AdvanceGrid);
        }
        else
        {
            for (i = 1; i <= settleAdvance.keyCount(#one); i++)
            {
                docTxt            = "";
                docAmount         = "";
                creditAccountNum  = "";
                debitAccountNum   = "";
                debitAmount       = 0;
                creditAmount      = 0;

                [keyVoucher, keyAccount, keyCurrency] = settleAdvance.keyIndex(#one, i);
                docTxt           = strFmt(SysLabel::labelId2String(literalStr("@GLS103656"), languageId), i);
                docAmount        = num2str(conPeek(settleAdvance.keyData(#one, i), #one),#Value16,#Value2,#Value2,#Value3);
                keyOffsetAccount = conPeek(settleAdvance.keyData(#one, i), #three);
                mainAccounts();

                this.execute(#AdvanceGrid);

                if (keyCurrency != standardCurrency)
                {
                    docTxt     = strFmt(SysLabel::labelId2String(literalStr("@GLS103657"), languageId), i, keyCurrency);
                    docAmount  = num2str(conPeek(settleAdvance.keyData(#one, i), #two),#Value16,#Value2,#Value2,#Value3);
                    mainAccounts(true);

                    this.execute(#AdvanceGrid);
                }

                tmpAmount += conPeek(settleAdvance.keyData(#one, i), #one);
                tmpAmount -= exchAdjustments(#five);
                tmpAmount -= exchAdjustments(#four);
                exchAdjustments(#six);
            }
        }
        //Settlement <--

        // Total received
        docTxt            = SysLabel::labelId2String(literalStr("@GLS101920"), languageId);
        docAmount         = num2str(tmpAmount, #Value16, #Value2, #Value2, #Value3);
        debitAccountNum   = "";
        debitAmount       = 0;
        creditAccountNum  = "";
        creditAmount      = 0;

        this.execute(#AdvanceGrid);

        balanceMst       += tmpAmount;
        //<--
    }

]]></Source>
			</Method>
			<Method>
				<Name>spentExec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes logic of fulfilment of AdvanceGrid section, where previous advances displayed, with data
    /// </summary>
    #define.Value3(3)
    #define.Value2(2)
    protected void spentExec()
    {
        MainAccountNum  creditAccountPrev,debitAccountPrev;
        container       conKey, conData;
        MapEnumerator   mapEnumerator = spendLines.getEnumerator();
        Map             lineMap = new Map(Types::Container,Types::Container);

        while (mapEnumerator.moveNext())
        {
            conData = mapEnumerator.currentValue();
            if (creditAccountPrev != conPeek(mapEnumerator.currentKey(),1))
            {
                creditAccountPrev = conPeek(mapEnumerator.currentKey(),1);
                debitAccountPrev  = conPeek(mapEnumerator.currentKey(),#Value2);
                lineMap.insert([creditAccountPrev,debitAccountPrev,creditAccountPrev],conData);
            }
            else
            {
                lineMap.insert([creditAccountPrev,debitAccountPrev,creditAccountPrev],
                               [conPeek(lineMap.lookup([creditAccountPrev,debitAccountPrev,creditAccountPrev]),1),
                                conPeek(lineMap.lookup([creditAccountPrev,debitAccountPrev,creditAccountPrev]),#Value2) +
                                conPeek(conData,#Value2)]);
                conData = [conPeek(conData,1),0];
                lineMap.insert([creditAccountPrev,conPeek(mapEnumerator.currentKey(),#Value2),""],conData);
            }
        }
        mapEnumerator = lineMap.getEnumerator();
        docTxt        = SysLabel::labelId2String(literalStr("@GLS101921"), languageId);
        docAmount     = amountApprTotalInNum;
        while (mapEnumerator.moveNext())
        {
            conKey  = mapEnumerator.currentKey();
            conData = mapEnumerator.currentValue();
            creditAccountNum  = conPeek(conKey, #Value3);
            creditAmount      = conPeek(conData, #Value2);
            debitAccountNum   = conPeek(conKey, #Value2);
            debitAmount       = conPeek(conData, 1);

            this.execute(#AdvanceGrid);

            docTxt            = "";
            docAmount         = "";
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns name of template for report
    /// </summary>
    /// <returns>
    /// name of template for report
    /// </returns>
    protected Filename templateName()
    {
        return resourceStr(EmplAdvanceReport_RU);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalCells</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates number of cells to be filled with data
    /// </summary>
    /// <returns>
    /// Number of cells to be filled with data
    /// </returns>
    #define.cellsBody(9)
    #define.cellsOther(53)
    protected Counter totalCells()
    {
        select count(RecId) from lineTable
            where lineTable.AdvanceId == advanceId;

        return int642int(lineTable.RecId) * #cellsBody + #cellsOther;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static XMLExcelReport_AO1_RU construct()
    {
        return new XMLExcelReport_AO1_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>