<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailPricingDataManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Application.Instrumentation;
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;
using CrtPricingPropertyDefinition = Microsoft.Dynamics.Commerce.Runtime.DataModel.PricingPropertyDefinition;
using CrtPricingPropertyLevel = Microsoft.Dynamics.Commerce.Runtime.DataModel.PricingPropertyLevel;
using CrtPriceGroup = Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceGroup;
using CrtCommercePropertyValue = Microsoft.Dynamics.Commerce.Runtime.DataModel.CommercePropertyValue;
using CrtPriceContext = Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.PriceContext;
using CrtPricingPropertyValueContext = Microsoft.Dynamics.Commerce.Runtime.DataModel.PricingPropertyValueContext;
using CrtPricingApplicabilityRule = Microsoft.Dynamics.Commerce.Runtime.DataModel.PricingApplicabilityRule;
using CrtPeriodicDiscount = Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount;
using CrtPriceAdjustment = Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceAdjustment;

/// <summary>
/// The <c>RetailPricingDataManager</c> class implements the actual queries for <c>IPricingDataAccessor</c>.
/// These queries search for pricing rules and product details from the AX database. They are mostly executed in
/// the context of a particular retail channel in order to mimic the records it would find in its database.
/// </summary>
public class RetailPricingDataManager implements Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.IPricingDataAccessorV8
{
    protected const str RetailInstrumentationSegmentArea = 'PriceEngine';

    private const str RetailSalesAgreementPriceSupportFeatureName = "Dynamics.AX.Application.RetailSalesAgreementPriceSupportFeature";
    private const str RetailPricingPropertyFeatureName = "Dynamics.AX.Application.RetailPricingPropertyFeature";

    protected static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

    private static readonly str InventDimIdAllBlank = InventDim::inventDimIdBlank();

    protected Map isVariantMap = new Map(Types::String, Types::Enum);

    RecId mChannelRecId;
    RetailTransactionId mTransactionId;

    // Cache channel configuration, as it's in the implementation.
    Microsoft.Dynamics.Commerce.Runtime.DataModel.ChannelPriceConfiguration mPriceChannelConfiguration;

    RetailTempOrderData mTmpOrderData;
    RecordInsertList tmpOrderDataInsertList;

    RetailTempOrderItem mTmpOrderItem;

    boolean isPriceSimulatorPropertyBasedMode;

    /// <summary>
    /// Map storing whether a discount is applicable to current transaction.
    /// Key: [Price group RefRecId, OfferId].
    /// Value: 1 if discount is applicable, otherwise 0.
    /// </summary>
    Map isDiscountApplicableMap = new Map(Types::Container, Types::Integer);

    Set offerIdSet = new Set(Types::String);

    protected static ValidFromDate noDate = DateTimeUtil::date(DateTimeUtil::minValue());
    protected static ValidToDate neverDate = DateTimeUtil::date(DateTimeUtil::maxValue());

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(RecId _channelRecordId, RetailTransactionId _transactionId, RetailTempOrderItem _tempOrderItem = null, boolean _isTempOrderItemFilled = false)
    {
        mChannelRecId = _channelRecordId;
        mTransactionId = _transactionId;
        this.parmIsPriceSimulatorPropertyBasedMode(false);

        if (_isTempOrderItemFilled)
        {
            mTmpOrderItem = _tempOrderItem;
        }

        RetailChannelTable retailChannelTable = RetailChannelTable::findByRecId(mChannelRecId);
        RetailParameters   retailparams = RetailParameters::find();

        mPriceChannelConfiguration = new Microsoft.Dynamics.Commerce.Runtime.DataModel.ChannelPriceConfiguration();
        mPriceChannelConfiguration.Company = curext();
        mPriceChannelConfiguration.CompanyCurrency = CompanyInfoHelper::standardCurrency();
        mPriceChannelConfiguration.ChannelTimeZoneId = retailChannelTable.ChannelTimeZoneInfoId;
        // set discount algorithm mode and max step count
        mPriceChannelConfiguration.DiscountAlgorithmMode = enum2int(RetailDiscountAlgorithmMode::Marginal);
        mPriceChannelConfiguration.IsThresholdJoinExclusiveCompetitionAllowed = enum2int(retailparams.AllowThresholdJoinExclusiveCompetition);
        if(mPriceChannelConfiguration.IsThresholdJoinExclusiveCompetitionAllowed)
        {
            eventSource.EventWriteFeatureUsed(
                'IsThresholdJoinExclusiveCompetitionAllowed',
                classStr(RetailPricingDataManager),
                'new',
                '');
        }

        mPriceChannelConfiguration.MaxBestDealStepCount = retailparams.MaxBestDealStepCount;
        mPriceChannelConfiguration.HoldTogetherForDiscountRounding = retailparams.HoldTogetherForDiscountRounding;
        mPriceChannelConfiguration.ApplyDiscountsToPriceKeyedIn = retailparams.ApplyDiscountsToPriceKeyedIn;
        mPriceChannelConfiguration.ApplyDiscountsToPriceOverrides = retailparams.ApplyDiscountsToPriceOverrides;
        mPriceChannelConfiguration.IsOrganizationHierarchyEnabledOnSalesAgreement = retailparams.IsOrganizationHierarchyEnabledOnSalesAgreement;
        mPriceChannelConfiguration.ExtChannelType = Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.TypeHelperForAx::GetExtensibleRetailChannelTypeByValue(enum2int(retailChannelTable.ChannelType));
        mPriceChannelConfiguration.InventLocationId = retailChannelTable.inventLocation;

        int concurrencyControl = RetailConfigurationParameters::getDiscountConcurrencyControlModel();
        mPriceChannelConfiguration.DiscountConcurrencyControlModel = concurrencyControl;
        int compoundBehavior = RetailConfigurationParameters::getDiscountCompoundBehavior();
        RetailPricingEngineHelper::setIntPropertyIfExistsInClass(mPriceChannelConfiguration, RetailConfigurationParameters::getNameForDiscountCompoundBehavior(), compoundBehavior);

        RetailPricingEngineHelper::setIntPropertyIfExistsInClass(mPriceChannelConfiguration, 'ManuallyApplyDiscountsToReturnProduct',  RetailConfigurationParameters::getManuallyApplyDiscountsToReturnProduct());

        RetailPricingEngineHelper::setIntPropertyIfExistsInClass(mPriceChannelConfiguration, RetailConfigurationParameters::getNameForManualDiscountMode(), RetailConfigurationParameters::getManualDiscountMode());

        RetailPricingEngineHelper::setBooleanPropertyIfExistsInClass(mPriceChannelConfiguration, 'DistributeMixAndMatchLeastExpensive', RetailConfigurationParameters::getMixAndMatchLeastExpensiveDistribution());

        SalesParameters salesParam = SalesParameters::find();
        mPriceChannelConfiguration.LineDiscountCalculationType = salesParam.Disc;

        if (RetailPricingCalcBulkInsertTempTableFlight::instance().isEnabled())
        {
            tmpOrderDataInsertList = new RecordInsertList(
                tableNum(RetailTempOrderData),
                true, // skip insert
                true, // skip database log
                true, // skip events
                true, // skip aos validation
                true, // skip RLS validation
                mTmpOrderData); // buffer where records will be inserted
        }
        else
        {
            tmpOrderDataInsertList = new RecordInsertList(
                tableNum(RetailTempOrderData),
                false, // skip insert
                false, // skip database log
                false, // skip events
                false, // skip aos validation
                false, // skip RLS validation
                mTmpOrderData); // buffer where records will be inserted
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsPriceSimulatorPropertyBasedMode</Name>
				<Source><![CDATA[
    internal boolean parmIsPriceSimulatorPropertyBasedMode(boolean _isPriceSimulatorPropertyBasedMode)
    {
        isPriceSimulatorPropertyBasedMode = _isPriceSimulatorPropertyBasedMode;
        return isPriceSimulatorPropertyBasedMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetAffiliationPriceGroups</Name>
				<Source><![CDATA[
    public System.Object GetAffiliationPriceGroups(System.Object affiliationLoyaltyTiers)
    {
        PriceDiscGroup priceDiscGroup;
        RetailAffiliationPriceGroup affiliationPriceGroup;
        CLRObject crtPriceGroupList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceGroup());
        CLRObject crtAffiliationLoyaltyTierList = affiliationLoyaltyTiers;
        CLRObject clrEn = crtAffiliationLoyaltyTierList.GetEnumerator();
        while (clrEn.MoveNext())
        {
            Microsoft.Dynamics.Commerce.Runtime.DataModel.AffiliationLoyaltyTier crtAffiliationLoyaltyTier = clrEn.get_Current();
            while select RecId, GroupId, RetailPricingPriorityNumber from priceDiscGroup
            exists join affiliationPriceGroup
                where priceDiscGroup.RecId == affiliationPriceGroup.PriceDiscGroup
                    && affiliationPriceGroup.RetailAffiliation == crtAffiliationLoyaltyTier.AffiliationId
                    && affiliationPriceGroup.RetailLoyaltyTier == 0
            {
                crtPriceGroupList.Add(this.ConvertToPriceGroup(priceDiscGroup));
            }

            if (crtAffiliationLoyaltyTier.LoyaltyTierId != 0)
            {
                while select RecId, GroupId, RetailPricingPriorityNumber from priceDiscGroup
                exists join affiliationPriceGroup
                    where priceDiscGroup.RecId == affiliationPriceGroup.PriceDiscGroup
                        && affiliationPriceGroup.RetailLoyaltyTier == crtAffiliationLoyaltyTier.LoyaltyTierId
                {
                    crtPriceGroupList.Add(this.ConvertToPriceGroup(priceDiscGroup));
                }
            }
        }

        return crtPriceGroupList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetSalesAgreementsByRecordId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fetches the superset of sales agreement lines by sales agreement id which could apply to all of these items for the given date.
    /// </summary>
    /// <param name="_salesAgreementRecordId">The sales agreement record id.</param>
    /// <param name="_itemIds">The item Ids to fetch agreements for.</param>
    /// <param name="_minActiveDate">The channel earliest inclusive active date to search by. Must be less than or equal to maxActiveDate.</param>
    /// <param name="_maxActiveDate">The channel latest inclusive active date to search by. Must be greater than or equal to minActiveDate.</param>
    /// <param name="_currencyCode">Currency code to filter by.</param>
    /// <returns>Collection of sales agreement lines which may be applied to the given items.</returns>
    public System.Object GetSalesAgreementsByRecordId(
                System.Int64 _salesAgreementRecordId,
                System.Object _itemIds,
                System.DateTimeOffset _minActiveDate,
                System.DateTimeOffset _maxActiveDate,
                System.String _currencyCode)
    {
        AgreementLine salesAgreementLine;
        AgreementLineDefault agreementLineDefault;
        InventDim inventDim;

        SalesAgreementHeader salesAgreementHeader = SalesAgreementHeader::find(_salesAgreementRecordId);

        CLRObject crtAgreementLineList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesAgreementLine());

        ValidFromDate minFromDate = this.GetDateInChannelTimeZone(_minActiveDate);
        ValidToDate maxToDate = this.GetDateInChannelTimeZone(_maxActiveDate);

        boolean isValid = salesAgreementHeader.RecId
            && !salesAgreementHeader.IsDeleted
            && salesAgreementHeader.AgreementState == AgreementState::Effective
            && salesAgreementHeader.Currency == _currencyCode;

        if (isValid)
        {
            while select salesAgreementLine
                    where salesAgreementLine.Agreement == salesAgreementHeader.RecId
                        && salesAgreementLine.IsDeleted == NoYes::No
                        && (salesAgreementLine.AgreementLineType == CommitmentType::ProductQuantity || salesAgreementLine.AgreementLineType == CommitmentType::ProductVolume)
                        && salesAgreementLine.EffectiveDate <= minFromDate
                        && salesAgreementLine.ExpirationDate >= maxToDate
                        && salesAgreementLine.ProjectProjId == '' // Project is our of scope then take only empty ones.
                outer join agreementLineDefault
                    where salesAgreementLine.RecId == agreementLineDefault.AgreementLine
                join inventDim
                    where salesAgreementLine.InventDimId == inventDim.inventDimId
                join mTmpOrderItem
                    where salesAgreementLine.ItemId == mTmpOrderItem.itemId
            {
                crtAgreementLineList.Add(this.ConvertToSalesAgreementLine(salesAgreementHeader, salesAgreementLine, agreementLineDefault, inventDim));
            }
        }

        return crtAgreementLineList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetSalesAgreementsByCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fetches the superset of sales agreement lines by customer account which could apply to all of these items for the given date.
    /// </summary>
    /// <param name="_itemIds">The item Ids to fetch agreements for.</param>
    /// <param name="_customerAccount">Optional. Customer account number to search by.</param>
    /// <param name="_minActiveDate">The channel earliest inclusive active date to search by. Must be less than or equal to maxActiveDate.</param>
    /// <param name="_maxActiveDate">The channel latest inclusive active date to search by. Must be greater than or equal to minActiveDate.</param>
    /// <param name="_currencyCode">Currency code to filter by.</param>
    /// <param name="_searchOrganizationHierarchy">Whether to get sales agreement on organization(if defined) this person account belongs to.</param>
    /// <returns>Collection of sales agreements which may be applied to the given items.</returns>
    public System.Object GetSalesAgreementsByCustomer(
                System.Object _itemIds,
                System.String _customerAccount,
                System.DateTimeOffset _minActiveDate,
                System.DateTimeOffset _maxActiveDate,
                System.String _currencyCode,
                System.Boolean _searchOrganizationHierarchy)
    {
        AgreementLine salesAgreementLine;
        AgreementLineDefault agreementLineDefault;
        InventDim inventDim;
        SalesAgreementHeader salesAgreementHeader;

        CLRObject crtAgreementLineList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesAgreementLine());

        // Check customer account
        CustTable custTable = CustTable::find(_customerAccount);

        if (!custTable.RecId)
        {
            return crtAgreementLineList;
        }

        RetailTempName candidateCustomerAcct;

        if (_searchOrganizationHierarchy)
        {
            DirPartyTable dirPartyTable = DirPartyTable::findRec(custTable.Party);

            if (dirPartyTable.baseType() == DirPartyBaseType::Person)
            {
                // find organization this customer belongs to.
                CustHierarchy hierarchy;
                CustHierarchyNode node;
                CustTable orgCustTable;

                insert_recordset candidateCustomerAcct (Name)
                    select AccountNum from orgCustTable
                    exists join hierarchy
                        where orgCustTable.Party == hierarchy.OrganizationParty
                    exists join node
                        where node.CustHierarchyId == hierarchy.CustHierarchyId && node.Party == custTable.Party;
            }
        }

        if (candidateCustomerAcct.RowCount() <= 0)
        {
            candidateCustomerAcct.clear();
            candidateCustomerAcct.Name = _customerAccount;
            candidateCustomerAcct.insert();
        }

        // Get sales agreement line list.
        ValidFromDate minFromDate = this.GetDateInChannelTimeZone(_minActiveDate);
        ValidToDate maxToDate = this.GetDateInChannelTimeZone(_maxActiveDate);

        while select salesAgreementHeader
                where salesAgreementHeader.Currency == _currencyCode
                    && !salesAgreementHeader.IsDeleted
                    && salesAgreementHeader.AgreementState == AgreementState::Effective
            join candidateCustomerAcct
                where candidateCustomerAcct.Name == salesAgreementHeader.CustAccount
            join salesAgreementLine
                where salesAgreementLine.Agreement == salesAgreementHeader.RecId
                    && salesAgreementLine.IsDeleted == NoYes::No
                    && (salesAgreementLine.AgreementLineType == CommitmentType::ProductQuantity || salesAgreementLine.AgreementLineType == CommitmentType::ProductVolume)
                    && salesAgreementLine.EffectiveDate <= minFromDate
                    && salesAgreementLine.ExpirationDate >= maxToDate
                    && salesAgreementLine.ProjectProjId == '' // Project is our of scope then take only empty ones.
            outer join agreementLineDefault
                where salesAgreementLine.RecId == agreementLineDefault.AgreementLine
            join inventDim
                where salesAgreementLine.InventDimId == inventDim.inventDimId
            join mTmpOrderItem
                where salesAgreementLine.ItemId == mTmpOrderItem.itemId
        {
            crtAgreementLineList.Add(this.ConvertToSalesAgreementLine(salesAgreementHeader, salesAgreementLine, agreementLineDefault, inventDim));
        }

        return crtAgreementLineList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ReadPriceTradeAgreements</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns applicable trade agreements list as per the supplied parameters.
    /// </summary>
    /// <param name = "itemIds">Items id's for trade agreement search.</param>
    /// <param name = "priceGroups">Price groups for trade agreement search.</param>
    /// <param name = "customerAccount">Customer account number.</param>
    /// <param name = "minActiveDate">Minimum active date for trade agreement search.</param>
    /// <param name = "maxActiveDate">Maximum active date for trade agreement search.</param>
    /// <param name = "currencyCode">Currency code value for trade agreement search.</param>
    /// <param name = "settings">Query result settings value.</param>
    /// <returns>CLR object containing trade agreements.</returns>
    public System.Object ReadPriceTradeAgreements(
                System.Object itemIds,
                System.Object priceGroups,
                System.String customerAccount,
                System.DateTimeOffset minActiveDate,
                System.DateTimeOffset maxActiveDate,
                System.String currencyCode,
                Microsoft.Dynamics.Commerce.Runtime.DataModel.QueryResultSettings settings)
    {
        PriceDiscTable tradeAgreement;
        InventDim inventDim;
        RetailChannelTable retailChannelTable = RetailChannelTable::findByRecId(mChannelRecId);
        ValidFromDate minFromDate = this.GetDateInChannelTimeZone(minActiveDate);
        ValidToDate maxToDate = this.GetDateInChannelTimeZone(maxActiveDate);

        CLRObject clrPriceGroups = priceGroups;

        CLRObject tradeAgreementList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.TradeAgreement());

        SysDaSearchObject searchObject = RetailPricingDataManagerTradeAgreementsQuery::execute(
            currencyCode,
            minFromDate,
            maxToDate,
            tradeAgreement,
            inventDim,
            mTmpOrderItem,
            retailChannelTable);

        SysDaSearchStatement searchStatement = new SysDaSearchStatement();

        while (searchStatement.next(searchObject))
        {
            // skip if customer-specific to different customer
            if (tradeAgreement.AccountCode == PriceDiscPartyCodeType::Table
                && tradeAgreement.AccountRelation != customerAccount)
            {
                continue;
            }

            // skip if group-specific but not channel group or customer group
            if (tradeAgreement.AccountCode == PriceDiscPartyCodeType::GroupId
                && !clrPriceGroups.Contains(tradeAgreement.AccountRelation))
            {
                continue;
            }

            tradeAgreementList.Add(this.ConvertToTradeAgreement(tradeAgreement, inventDim));
        }

        return tradeAgreementList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetCustomerPriceGroup</Name>
				<Source><![CDATA[
    public Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceGroup GetCustomerPriceGroup(System.String customerPriceGroupId)
    {
        PriceDiscGroup priceDiscGroup = PriceDiscGroup::find(ModuleInventCustVend::Cust, PriceGroupType::PriceGroup, customerPriceGroupId);

        Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceGroup crtPriceGroup = null;
        if (priceDiscGroup)
        {
            crtPriceGroup = this.ConvertToPriceGroup(priceDiscGroup);
        }
        else
        {
            crtPriceGroup = new Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceGroup();
        }

        return crtPriceGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetCatalogPriceGroups</Name>
				<Source><![CDATA[
    public System.Object GetCatalogPriceGroups(System.Object catalogIds)
    {
        PriceDiscGroup priceDiscGroup;
        RetailCatalogPriceGroup catalogPriceGroup;

        RetailTmpRecId tmpCatalogIds = this.getRetailTmpRecId(catalogIds);

        CLRObject crtCatalogPriceGroupList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.CatalogPriceGroup());

        while select RecId, GroupId, RetailPricingPriorityNumber from priceDiscGroup
                join Catalog from catalogPriceGroup
                    where priceDiscGroup.RecId == catalogPriceGroup.PriceDiscGroup
                exists join tmpCatalogIds
                    where catalogPriceGroup.Catalog == tmpCatalogIds.ReferenceRecId
        {
            crtCatalogPriceGroupList.Add(this.ConvertToCatalogPriceGroup(priceDiscGroup, catalogPriceGroup));
        }

        return crtCatalogPriceGroupList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetChannelPriceConfiguration</Name>
				<Source><![CDATA[
    public Microsoft.Dynamics.Commerce.Runtime.DataModel.ChannelPriceConfiguration GetChannelPriceConfiguration()
    {
        return mPriceChannelConfiguration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetAllStores</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the stores information for store number, warehouse, site mapping lookup.
    /// </summary>
    /// <returns>Collection of OrgUnitLocation.</returns>
    public System.Object GetAllStores()
    {
        RetailStoreLocatorGroupMember storeLocatorGroupMember;
        InventLocation InventLocation;
        RetailStoreTable retailStoreTable;

        RetailChannelTable currentChannel = RetailChannelTable::findByRecId(mChannelRecId);

        CLRObject orgUnitLocationList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.OrgUnitLocation());

        while select InventLocationId, inventLocationDataAreaId, Store
            from storeLocatorGroupMember
                group by InventLocationId
                where storeLocatorGroupMember.InventLocationDataAreaId == currentChannel.inventLocationDataAreaId
            join InventSiteId, InventLocationId from inventLocation
                group by InventSiteId
                where storeLocatorGroupMember.InventLocationId == inventLocation.InventLocationId
                    && inventLocation.DataAreaId == currentChannel.inventLocationDataAreaId
            join StoreNumber, RecId from retailStoreTable
                group by StoreNumber
                where storeLocatorGroupMember.Store == retailStoreTable.RecId
                    && retailStoreTable.InventLocationDataAreaId == currentChannel.inventLocationDataAreaId
        {
            Microsoft.Dynamics.Commerce.Runtime.DataModel.OrgUnitLocation orgUnitLocation = new Microsoft.Dynamics.Commerce.Runtime.DataModel.OrgUnitLocation();

            orgUnitLocation.OrgUnitNumber = retailStoreTable.StoreNumber;
            orgUnitLocation.InventorySiteId = InventLocation.InventSiteId;
            orgUnitLocation.InventoryLocationId = storeLocatorGroupMember.InventLocationId;

            orgUnitLocationList.Add(orgUnitLocation);
        }

        return orgUnitLocationList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>IsFeatureEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get state of a feature.
    /// </summary>
    /// <param name = "_featureName">The feature name.</param>
    /// <returns>True if the feature is pricing engine supported and is enabled, otherwise false.</returns>
    public System.Boolean IsFeatureEnabled(System.String _featureName)
    {
        boolean isEnabled = false;

        switch (_featureName)
        {
            case RetailSalesAgreementPriceSupportFeatureName:
                isEnabled = FeatureStateProvider::isFeatureEnabled(RetailSalesAgreementPriceSupportFeature::instance());
                break;
            case RetailPricingPropertyFeatureName:
                isEnabled = FeatureStateProvider::isFeatureEnabled(RetailPricingPropertyFeature::instance())
                    || isPriceSimulatorPropertyBasedMode; // For price simulator, we allow users to calculate in property based mode without enabling the feature.
                break;
        }

        return isEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDiscountCodesByOfferIds</Name>
				<Source><![CDATA[
    public System.Object GetDiscountCodesByOfferIds(System.Object offerIds)
    {
        RetailDiscountCode retailDiscountCode;
        UserId userId = curUserId();
        CLRObject crtDiscountCodeList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.DiscountCode());

        while select RecId from mTmpOrderData
                where mTmpOrderData.dataType == RetailTmpOrderDataType::OfferId
            join retailDiscountCode
                group by retailDiscountCode.DiscountOfferId, retailDiscountCode.BarCode, retailDiscountCode.DiscountCode, retailDiscountCode.RecId
                where mTmpOrderData.dataValue == retailDiscountCode.DiscountOfferId
        {
            crtDiscountCodeList.Add(this.ConvertToDiscountCode(retailDiscountCode));
        }

        return crtDiscountCodeList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ReadDiscountTradeAgreements</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets discounts trade agreements.
    /// </summary>
    /// <param name = "itemIds">An object of item number.</param>
    /// <param name = "customerAccount">A customer account number.</param>
    /// <param name = "minActiveDate">A minimum active date to find out trade agreement for.</param>
    /// <param name = "maxActiveDate">A maximum active date to find out trade agreement for.</param>
    /// <param name = "currencyCode">A Currency code to find out trade agreement for.</param>
    /// <param name = "settings">The query result settings.</param>
    /// <returns>Trade agreement value.</returns>
    public System.Object ReadDiscountTradeAgreements(
                System.Object itemIds,
                System.String customerAccount,
                System.DateTimeOffset minActiveDate,
                System.DateTimeOffset maxActiveDate,
                System.String currencyCode,
                Microsoft.Dynamics.Commerce.Runtime.DataModel.QueryResultSettings settings)
    {
        CustTable custTable;
        InventTableModule inventTableModule;
        PriceDiscTable priceDisc;
        PriceDiscHeading priceDiscHeading;
        InventDim inventDim, inventDimAllBlank;

        // Bug 308922: Disc not calculated in the sales order for an item
        // line discount trade agreements search needs to respect the line disocunt group in sales order header.
        if (RetailPricingEngine::isMCROrder(mTransactionId))
        {
            priceDiscHeading = SalesTable::find(mTransactionId);
        }

        if (RetailPricingEngine::isMCRQuote(mTransactionId))
        {
            priceDiscHeading = SalesQuotationTable::find(mTransactionId);
        }

        custTable = CustTable::find(customerAccount);

        ValidFromDate minFromDate = this.GetDateInChannelTimeZone(minActiveDate);
        ValidToDate maxToDate = this.GetDateInChannelTimeZone(maxActiveDate);
        #localmacro.WhileSelectPriceDiscTable
            while select priceDisc
                    where (priceDisc.relation == PriceType::EndDiscSales
                            || priceDisc.relation == PriceType::LineDiscSales
                            || priceDisc.relation == PriceType::MultiLineDiscSales)
                        && priceDisc.Currency == currencyCode
                        && (priceDisc.FromDate <= minFromDate || priceDisc.FromDate <= noDate)
                        && (priceDisc.ToDate >= maxToDate || priceDisc.ToDate <= noDate)
                        && ((priceDisc.AccountCode == PriceDiscPartyCodeType::GroupId
                                && ((priceDisc.relation == PriceType::LineDiscSales && (priceDisc.AccountRelation == custTable.LineDisc || priceDisc.AccountRelation == priceDiscHeading.LineDisc))
                                    || (priceDisc.relation == PriceType::MultiLineDiscSales && (priceDisc.AccountRelation == custTable.MultiLineDisc || priceDisc.AccountRelation ==priceDiscHeading.MultiLineDisc))
                                    || (priceDisc.relation == PriceType::EndDiscSales && (priceDisc.AccountRelation == custTable.EndDisc || priceDisc.AccountRelation == priceDiscHeading.EndDisc))))
                            || (priceDisc.AccountCode == PriceDiscPartyCodeType::Table && priceDisc.AccountRelation == custTable.AccountNum)
                            || priceDisc.AccountCode == PriceDiscPartyCodeType::All)
            #endmacro

        CLRObject tradeAgreementList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.TradeAgreement());

        using(var t = RetailPricingInstrumentationSegment::construct(
            classStr(RetailPricingDataManager), 'ReadDiscountTradeAgreements.ItemCodeAll.InventDimAllBlank'))
        {
            #WhileSelectPriceDiscTable
                && priceDisc.ItemCode == PriceDiscProductCodeType::All
                && (priceDisc.InventDimId == '' || priceDisc.InventDimId == InventDimIdAllBlank)
            {
                tradeAgreementList.Add(this.ConvertToTradeAgreement(priceDisc, inventDimAllBlank));
            }
        }

        using(var t = RetailPricingInstrumentationSegment::construct(
            classStr(RetailPricingDataManager), 'ReadDiscountTradeAgreements.ItemCodeAll.InventDimNotBlank'))
        {
            #WhileSelectPriceDiscTable
                && priceDisc.ItemCode == PriceDiscProductCodeType::All
                && priceDisc.InventDimId != '' && priceDisc.InventDimId != InventDimIdAllBlank
            join inventDim
                where inventDim.inventDimId == priceDisc.InventDimId
            {
                tradeAgreementList.Add(this.ConvertToTradeAgreement(priceDisc, inventDim));
            }
        }

        using(var t = RetailPricingInstrumentationSegment::construct(
            classStr(RetailPricingDataManager), 'ReadDiscountTradeAgreements.ItemCodeTable.InventDimAllBlank'))
        {
            #WhileSelectPriceDiscTable
                && priceDisc.ItemCode == PriceDiscProductCodeType::Table
                && (priceDisc.InventDimId == '' || priceDisc.InventDimId == InventDimIdAllBlank)
            exists join mTmpOrderItem
                    where mTmpOrderItem.itemId == priceDisc.ItemRelation
            {
                tradeAgreementList.Add(this.ConvertToTradeAgreement(priceDisc, inventDimAllBlank));
            }
        }

        using(var t = RetailPricingInstrumentationSegment::construct(
            classStr(RetailPricingDataManager), 'ReadDiscountTradeAgreements.ItemCodeTable.InventDimNotBlank'))
        {
            #WhileSelectPriceDiscTable
                && priceDisc.ItemCode == PriceDiscProductCodeType::Table
                && priceDisc.InventDimId != '' && priceDisc.InventDimId != InventDimIdAllBlank
            join inventDim
                where inventDim.inventDimId == priceDisc.InventDimId
                exists join mTmpOrderItem
                        where mTmpOrderItem.itemId == priceDisc.ItemRelation
            {
                inventDim = InventDim::find(priceDisc.InventDimId);
                tradeAgreementList.Add(this.ConvertToTradeAgreement(priceDisc, inventDim));
            }
        }

        using(var t = RetailPricingInstrumentationSegment::construct(
            classStr(RetailPricingDataManager), 'ReadDiscountTradeAgreements.ItemCodeGroupForLineDisc.InventDimAllBlank'))
        {
            #WhileSelectPriceDiscTable
                && priceDisc.ItemCode == PriceDiscProductCodeType::GroupId
                && priceDisc.relation == PriceType::LineDiscSales
                && (priceDisc.InventDimId == '' || priceDisc.InventDimId == InventDimIdAllBlank)
            exists join inventTableModule
                where inventTableModule.LineDisc == priceDisc.ItemRelation
                    && inventTableModule.ModuleType == ModuleInventPurchSales::Sales
            exists join mTmpOrderItem
                where mTmpOrderItem.itemId == inventTableModule.ItemId
            {
                tradeAgreementList.Add(this.ConvertToTradeAgreement(priceDisc, inventDimAllBlank));
            }
        }

        using(var t = RetailPricingInstrumentationSegment::construct(
            classStr(RetailPricingDataManager), 'ReadDiscountTradeAgreements.ItemCodeGroupForLineDisc.InventDimNotBlank'))
        {
            #WhileSelectPriceDiscTable
                && priceDisc.ItemCode == PriceDiscProductCodeType::GroupId
                && priceDisc.relation == PriceType::LineDiscSales
                && priceDisc.InventDimId != '' && priceDisc.InventDimId != InventDimIdAllBlank
            join inventDim
                where inventDim.inventDimId == priceDisc.InventDimId
            exists join inventTableModule
                where inventTableModule.LineDisc == priceDisc.ItemRelation
                    && inventTableModule.ModuleType == ModuleInventPurchSales::Sales
            exists join mTmpOrderItem
                where mTmpOrderItem.itemId == inventTableModule.ItemId
            {
                tradeAgreementList.Add(this.ConvertToTradeAgreement(priceDisc, inventDim));
            }
        }

        using(var t = RetailPricingInstrumentationSegment::construct(
            classStr(RetailPricingDataManager), 'ReadDiscountTradeAgreements.ItemCodeGroupForMultiLineDisc.InventDimAllBlank'))
        {
            #WhileSelectPriceDiscTable
                && priceDisc.ItemCode == PriceDiscProductCodeType::GroupId
                && priceDisc.relation == PriceType::MultiLineDiscSales
                && (priceDisc.InventDimId == '' || priceDisc.InventDimId == InventDimIdAllBlank)
            exists join inventTableModule
                where inventTableModule.MultiLineDisc == priceDisc.ItemRelation
                    && inventTableModule.ModuleType == ModuleInventPurchSales::Sales
            exists join mTmpOrderItem
                where mTmpOrderItem.itemId == inventTableModule.ItemId
            {
                tradeAgreementList.Add(this.ConvertToTradeAgreement(priceDisc, inventDimAllBlank));
            }
        }

        using(var t = RetailPricingInstrumentationSegment::construct(
            classStr(RetailPricingDataManager), 'ReadDiscountTradeAgreements.ItemCodeGroupForMultiLineDisc.InventDimNotBlank'))
        {
            #WhileSelectPriceDiscTable
                && priceDisc.ItemCode == PriceDiscProductCodeType::GroupId
                && priceDisc.relation == PriceType::MultiLineDiscSales
                && priceDisc.InventDimId != '' && priceDisc.InventDimId != InventDimIdAllBlank
            join inventDim
                where inventDim.inventDimId == priceDisc.InventDimId
            exists join inventTableModule
                where inventTableModule.MultiLineDisc == priceDisc.ItemRelation
                    && inventTableModule.ModuleType == ModuleInventPurchSales::Sales
            exists join mTmpOrderItem
                where mTmpOrderItem.itemId == inventTableModule.ItemId
            {
                tradeAgreementList.Add(this.ConvertToTradeAgreement(priceDisc, inventDim));
            }
        }

        return tradeAgreementList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetItems</Name>
				<Source><![CDATA[
    public System.Object GetItems(System.Object itemIds)
    {
        UserId userId = curUserId();
        InventTable inventTable;
        EcoResProductTranslation productTranslation;
        InventTableModule inventTableModule;
        RetailInventTable retailInventTable;
        ItemId            prevItemId;

        CLRObject crtItemList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.Item());

        while select itemId from mTmpOrderItem
                order by itemId
                join RecId, ItemId, Product from inventTable
                    where inventTable.ItemId == mTmpOrderItem.ItemId
                join Price, PriceUnit, MarkupGroupId, Markup, PriceQty, AllocateMarkup, LineDisc, MultiLineDisc, EndDisc, TaxItemGroupId
                    from inventTableModule
                    where inventTableModule.ItemId == mTmpOrderItem.ItemId
            && inventTableModule.ModuleType == ModuleInventPurchSales::Sales
                join noDiscountAllowed, noManualDiscountAllowed, noPeriodicDiscountAllowed, noTenderDiscountsAllowed from retailInventTable
                    where retailInventTable.itemId == mTmpOrderItem.ItemId
        {
            // avoid add duplicate item to item list
            if (mTmpOrderItem.itemId != prevItemId)
            {
                crtItemList.Add(this.ConvertToItem(inventTable, inventTableModule, retailInventTable));
                prevItemId = mTmpOrderItem.itemId;
            }
        }

        return crtItemList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetMixAndMatchLineGroupsByOfferIds</Name>
				<Source><![CDATA[
    public System.Object GetMixAndMatchLineGroupsByOfferIds(System.Object offerIds)
    {
        RetailMixAndMatchLineGroups mixMatchLineGroup;
        RetailDiscountLineMixAndMatch discountLineMixAndMatch;

        UserId userId = curUserId();

        CLRObject crtLineGroupList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.MixAndMatchLineGroup());

        if (RetailPricingKillSwitch::filterMixAndMatchLineGroupsByDiscountLine())
        {
            while select dataValue from mTmpOrderData
                    where mTmpOrderData.dataType == RetailTmpOrderDataType::OfferId
            join mixMatchLineGroup
                group by mixMatchLineGroup.mixAndMatchId, mixMatchLineGroup.mixAndMatchLineGroup, mixMatchLineGroup.numberOfItemsNeeded, mixMatchLineGroup.RecId
                where mixMatchLineGroup.mixAndMatchId == mTmpOrderData.dataValue
            exists join discountLineMixAndMatch
                where discountLineMixAndMatch.OfferId == mTmpOrderData.dataValue
                   && discountLineMixAndMatch.lineGroup == mixMatchLineGroup.mixAndMatchLineGroup
            {
                crtLineGroupList.Add(this.ConvertToMixAndMatchLineGroup(mixMatchLineGroup));
            }
        }
        else
        {
            while select dataValue from mTmpOrderData
                where mTmpOrderData.dataType == RetailTmpOrderDataType::OfferId
            join mixMatchLineGroup
                group by mixMatchLineGroup.mixAndMatchId, mixMatchLineGroup.mixAndMatchLineGroup, mixMatchLineGroup.numberOfItemsNeeded, mixMatchLineGroup.RecId
                where mixMatchLineGroup.mixAndMatchId == mTmpOrderData.dataValue
            {
                crtLineGroupList.Add(this.ConvertToMixAndMatchLineGroup(mixMatchLineGroup));
            }
        }

        return crtLineGroupList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetMultipleBuyDiscountLinesByOfferIds</Name>
				<Source><![CDATA[
    public System.Object GetMultipleBuyDiscountLinesByOfferIds(System.Object offerIds)
    {
        RetailMultibuyDiscountLine multibuyDiscountLine;

        UserId userId = curUserId();

        CLRObject crtQuantityTierList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.QuantityDiscountLevel());

        while select dataValue from mTmpOrderData
                where mTmpOrderData.dataType == RetailTmpOrderDataType::OfferId
            join multibuyDiscountLine
                group by multibuyDiscountLine.multibuyId, multibuyDiscountLine.qtyLowest, multibuyDiscountLine.priceDiscPct, multibuyDiscountLine.RecId
                where multibuyDiscountLine.multibuyId == mTmpOrderData.dataValue
        {
            crtQuantityTierList.Add(this.ConvertToQuantityDiscountLevel(multibuyDiscountLine));
        }

        return crtQuantityTierList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ReadPriceAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets price adjustments.
    /// If this method is updated, please update RetailPricingDataManagerSimulator.ReadPriceAdjustments() as well.
    /// </summary>
    /// <param name = "items">An object of item number.</param>
    /// <param name = "priceGroups">An object of price group.</param>
    /// <param name = "minActiveDate">A minimum active date.</param>
    /// <param name = "maxActiveDate">A maximum active date.</param>
    /// <param name = "settings">The query result settings.</param>
    /// <returns>The adjusted price.</returns>
    public System.Object ReadPriceAdjustments(
            System.Object items,
            System.Object priceGroups,
            System.DateTimeOffset minActiveDate,
            System.DateTimeOffset maxActiveDate,
            Microsoft.Dynamics.Commerce.Runtime.DataModel.QueryResultSettings settings)
    {
        System.Diagnostics.Stopwatch instrumentationTimer = new System.Diagnostics.Stopwatch();
        int64    instrumentationProductsMetric = 0;   // Metric 1 - Discounts for products
        int64    instrumentationVariantsMetric = 0;   // Metric 2 - Discounts for variants
        int64    instrumentationProductCatMetric = 0; // Metric 4 - Discount for product categories
        int64    instrumentationVariantCatMetric = 0; // Metric 5 - Discount for variant categories

        ValidFromDate minFromDate = this.GetDateInChannelTimeZone(minActiveDate);
        ValidToDate maxToDate = this.GetDateInChannelTimeZone(maxActiveDate);
        UserId userId = curUserId();

        RetailPeriodicDiscount promo;
        RetailDiscountLineOffer promoLine;
        RetailDiscountPriceGroup promoPriceGroup;
        RetailGroupMemberLine retailGroupMemberLine;
        EcoResProductCategory productCategory;
        RetailSpecialCategoryMember variantCategory;
        RetailCategoryContainmentLookup categoryLookup;
        RetailGroupMemberLine groupMemberLineForCategoryVariant;
        UnitOfMeasure unitOfMeasure;

        // Lookup of promotion discount offer Ids to determine whether the offer Id has already been added to RetailTempOrderData.
        Set promoOfferIdSet = new Set(Types::String);

        Map validationPeriodLookup = new Map(Types::String, Types::AnyType);
        Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceAdjustment crtPriceAdjustment;

        instrumentationTimer.Start();

        // Get discount data table for MatchAllAssociatedPriceGroups set as yes and associated price groups.
        RetailTmpOfferIdWithPriceGroups offerIdWithPriceDiscGroupTmp = this.getOfferIdAndAssociatedPriceGroupList();

        // convert price group record ids into temp table for join
        TmpRecIdFilter priceDiscGroupTmp = this.getTmpPriceGroupTableFromGroupIds(priceGroups);

        #localmacro.WhileSelectPriceAdjustment
        while select promo
               where promo.PeriodicDiscountType == RetailDiscountOfferTypeBase::Promotion
                   && promo.Status == RetailDisabledEnabled::Enabled
                   && ((promo.ValidFrom <= minFromDate || promo.ValidFrom <= noDate)
                   && (promo.ValidTo >= maxToDate || promo.ValidTo <= noDate))
            join
                OfferId, discountMethod, offerPrice, discPct, discAmount, RetailGroupMemberLine, RecId
            from promoLine
                where promo.OfferId == promoLine.OfferId
            join RecId, Product, Variant, Category from retailGroupMemberLine
                where retailGroupMemberLine.RecId == promoLine.RetailGroupMemberLine
               // get lines matching the variant, product, or non-zero category
        #endmacro

        #localmacro.JoinUnitOfMeasureAndPriceGroup
            outer join Symbol from unitOfMeasure
                where unitOfMeasure.RecId == promoLine.UnitOfMeasure
            exists join promoPriceGroup
                where promoPriceGroup.OfferId == promo.OfferId
            exists join priceDiscGroupTmp
                where priceDiscGroupTmp.RefRecId == promoPriceGroup.PriceDiscGroup
        #endmacro

        #localmacro.SetValidationPeriod
            if (promo.ValidationPeriodId)
            {
                Microsoft.Dynamics.Commerce.Runtime.DataModel.ValidationPeriod crtValidationPeriod = null;
                if (validationPeriodLookup.exists(promo.ValidationPeriodId))
                {
                    crtValidationPeriod = validationPeriodLookup.lookup(promo.ValidationPeriodId);
                }
                else
                {
                    crtValidationPeriod = this.GetValidationPeriod(promo.ValidationPeriodId);
                    validationPeriodLookup.insert(promo.ValidationPeriodId, crtValidationPeriod);
                }

                crtPriceAdjustment.ValidationPeriod = crtValidationPeriod;
            }
        #endmacro

        delete_from mTmpOrderData;

        CLRObject adjustmentList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceAdjustment());

        // get lines matching the product
        if (RetailPricingCacheForDataManager::shouldQueryPriceAdjustmentsProduct())
        {
            #WhileSelectPriceAdjustment
            join mTmpOrderItem
                where retailGroupMemberLine.Variant == 0
                    && retailGroupMemberLine.Product != 0
                    && retailGroupMemberLine.Product == mTmpOrderItem.Product
                #JoinUnitOfMeasureAndPriceGroup
            {
                crtPriceAdjustment = this.ConvertToPriceAdjustmentV2(promo, promoLine, mTmpOrderItem.itemId, mTmpOrderItem.inventDimId, unitOfMeasure);

                // Check is discount applicable.
                if (this.isDiscountApplicable(promo.OfferId, promo.MatchAllAssociatedPriceGroups, priceDiscGroupTmp, offerIdWithPriceDiscGroupTmp))
                {
                    #SetValidationPeriod
                    adjustmentList.Add(crtPriceAdjustment);
                    this.addOfferIdToTmpOrderDataList(promo.OfferId, promoOfferIdSet);
                }

                instrumentationProductsMetric += 1;
            }
        }

        // get lines matching the variant
        if (RetailPricingCacheForDataManager::shouldQueryPriceAdjustmentsVariant())
        {
            #WhileSelectPriceAdjustment
            join mTmpOrderItem
                where retailGroupMemberLine.Variant != 0
                    && retailGroupMemberLine.Variant == mTmpOrderItem.Variant
                #JoinUnitOfMeasureAndPriceGroup
            {
                crtPriceAdjustment = this.ConvertToPriceAdjustmentV2(promo, promoLine, mTmpOrderItem.itemId, mTmpOrderItem.inventDimId, unitOfMeasure);

                // Check is discount applicable.
                if (this.isDiscountApplicable(promo.OfferId, promo.MatchAllAssociatedPriceGroups, priceDiscGroupTmp, offerIdWithPriceDiscGroupTmp))
                {
                    #SetValidationPeriod
                    adjustmentList.Add(crtPriceAdjustment);
                    this.addOfferIdToTmpOrderDataList(promo.OfferId, promoOfferIdSet);
                }

                instrumentationVariantsMetric += 1;
            }
        }

        // get lines matching the category, for product
        if (RetailPricingCacheForDataManager::shouldQueryPriceAdjustmentsCategory())
        {
            #WhileSelectPriceAdjustment
            && retailGroupMemberLine.Variant == 0
                && retailGroupMemberLine.Product == 0
                && retailGroupMemberLine.Category != 0
            join mTmpOrderItem
                where mTmpOrderItem.Product != 0
            join ContainedCategory from categoryLookup
                where retailGroupMemberLine.Category == categoryLookup.Category
            join Product from productCategory
                where categoryLookup.ContainedCategory == productCategory.Category
                    && productCategory.Product == mTmpOrderItem.Product
            #JoinUnitOfMeasureAndPriceGroup
            {
                crtPriceAdjustment = this.ConvertToPriceAdjustmentV2(promo, promoLine, mTmpOrderItem.itemId, mTmpOrderItem.inventDimId, unitOfMeasure);

                // Check is discount applicable.
                if (this.isDiscountApplicable(promo.OfferId, promo.MatchAllAssociatedPriceGroups, priceDiscGroupTmp, offerIdWithPriceDiscGroupTmp))
                {
                    #SetValidationPeriod
                    adjustmentList.Add(crtPriceAdjustment);
                    this.addOfferIdToTmpOrderDataList(promo.OfferId, promoOfferIdSet);
                    }

                instrumentationProductCatMetric += 1;
            }

            // get lines matching the category, for variant
            #WhileSelectPriceAdjustment
            && retailGroupMemberLine.Variant == 0
                    && retailGroupMemberLine.Product == 0
                    && retailGroupMemberLine.Category != 0
                join mTmpOrderItem
                    where mTmpOrderItem.Variant != 0
                join ContainedCategory from categoryLookup
                    where retailGroupMemberLine.Category == categoryLookup.Category
                join RetailGroupMember from variantCategory
                    where categoryLookup.ContainedCategory == variantCategory.Category
                join groupMemberLineForCategoryVariant
                    where groupMemberLineForCategoryVariant.RecId == variantCategory.RetailGroupMember
                        && groupMemberLineForCategoryVariant.Variant == mTmpOrderItem.Variant
                #JoinUnitOfMeasureAndPriceGroup
            {
                crtPriceAdjustment = this.ConvertToPriceAdjustmentV2(promo, promoLine, mTmpOrderItem.itemId, mTmpOrderItem.inventDimId, unitOfMeasure);

                // Check is discount applicable.
                if (this.isDiscountApplicable(promo.OfferId, promo.MatchAllAssociatedPriceGroups, priceDiscGroupTmp, offerIdWithPriceDiscGroupTmp))
                {
                    #SetValidationPeriod
                    adjustmentList.Add(crtPriceAdjustment);
                    this.addOfferIdToTmpOrderDataList(promo.OfferId, promoOfferIdSet);
                }

                instrumentationVariantCatMetric += 1;
            }
        }

        tmpOrderDataInsertList.insertDatabase();

        // Instrumentaion Reporting
        instrumentationTimer.Stop();
        eventSource.EventWritePricingDiscountsRead(
            funcName(),
            instrumentationTimer.get_ElapsedMilliseconds(),
            instrumentationProductsMetric,
            instrumentationVariantsMetric,
            0,
            instrumentationProductCatMetric,
            instrumentationVariantCatMetric);

        return adjustmentList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetChannelPriceGroups</Name>
				<Source><![CDATA[
    public System.Object GetChannelPriceGroups()
    {
        PriceDiscGroup priceDiscGroup;
        RetailChannelPriceGroup retailChannelPriceGroup;

        CLRObject crtPriceGroupList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceGroup());

        while select RecId, GroupId, RetailPricingPriorityNumber from priceDiscGroup
                exists join retailChannelPriceGroup
                where priceDiscGroup.RecId == retailChannelPriceGroup.PriceGroup
                   && retailChannelPriceGroup.RetailChannel == mChannelRecId
        {
            crtPriceGroupList.Add(this.ConvertToPriceGroup(priceDiscGroup));
        }

        this.addSalesPriceGroup(crtPriceGroupList);

        return crtPriceGroupList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSalesPriceGroup</Name>
				<Source><![CDATA[
    private void addSalesPriceGroup(CLRObject crtPriceGroupList)
    {
        PriceDiscHeading priceDiscHeading;
        PriceDiscGroup customerPriceGroup;

        // If this is a retail sales order
        if (RetailPricingEngine::isMCROrder(mTransactionId))
        {
            priceDiscHeading = SalesTable::find(mTransactionId);
        }

        // If this is a retail sales quotation
        if (RetailPricingEngine::isMCRQuote(mTransactionId))
        {
            priceDiscHeading = SalesQuotationTable::find(mTransactionId);
        }

        if (priceDiscHeading)
        {
            customerPriceGroup = PriceDiscGroup::find(ModuleInventCustVend::Cust, PriceGroupType::PriceGroup, priceDiscHeading.PriceGroup);
        }
        else
        {
            int64 mTransactionRecId;
            if (System.Int64::TryParse(mTransactionId, byref mTransactionRecId))
            {
                // If succeeded, check whether it's a price simulator transaction.
                RetailPricingSimulatorSalesTransaction psSalesTransaction = RetailPricingSimulatorSalesTransaction::findByRef(mTransactionRecId);

                if (psSalesTransaction.RecId)
                {
                    CustTable custTable = CustTable::find(psSalesTransaction.CustAccount, false);

                    if (custTable.PriceGroup)
                    {
                        customerPriceGroup = PriceDiscGroup::find(ModuleInventCustVend::Cust, PriceGroupType::PriceGroup, custTable.PriceGroup);
                    }
                }
            }
            else
            {
                eventSource.EventWriteGeneralExceptionOnMethodWithErrorMessage(funcName(), 'TransactionId provided cannot be converted into RecId.');
            }
        }

        if (customerPriceGroup.RecId)
        {
            crtPriceGroupList.Add(this.ConvertToPriceGroup(customerPriceGroup));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetPriceParameters</Name>
				<Source><![CDATA[
    public Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceParameters GetPriceParameters()
    {
        PriceParameters priceParameters = PriceParameters::find();

        Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceParameters crtPriceParameters = this.ConvertToPriceParameters(priceParameters);

        return crtPriceParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetRetailCategoryMembersForItems</Name>
				<Source><![CDATA[
    public System.Object GetRetailCategoryMembersForItems(System.Object productOrVariantIds)
    {
        RetailProductAndVariantCategory productCategory;
        RetailCategoryContainmentLookup categoryContainment;

        container allCategoryMembers;
        container oneCategoryMember;

        RetailTmpRecId tmpProductOrVariantIds = this.getRetailTmpRecId(productOrVariantIds);
        CLRObject crtCategoryMemberList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.RetailCategoryMember());

        while select Product from productCategory
                join Category from categoryContainment
                    where categoryContainment.ContainedCategory == productCategory.Category
                exists join tmpProductOrVariantIds
                    where tmpProductOrVariantIds.ReferenceRecId == productCategory.Product
        {
            crtCategoryMemberList.Add(this.ConvertToRetailCategoryMember(productCategory, categoryContainment));
        }

        return crtCategoryMemberList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetRetailDiscountPriceGroups</Name>
				<Source><![CDATA[
    public System.Object GetRetailDiscountPriceGroups(System.Object offerIds)
    {
        PriceDiscGroup priceDiscGroup;
        RetailDiscountPriceGroup discountPriceGroup;
        UserId userId = curUserId();

        CLRObject crtOfferIdList = offerIds;
        CLRObject clrEn = crtOfferIdList.GetEnumerator();
        var DiscountPriceGroupofferIdSet = new Set(Types::String);
        while (clrEn.MoveNext())
        {
            DiscountPriceGroupofferIdSet.add(clrEn.get_Current());
        }

        CLRObject crtPriceGroupList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.RetailDiscountPriceGroup());

        while select RecId from  mTmpOrderData
                where mTmpOrderData.dataType == RetailTmpOrderDataType::OfferId
            join discountPriceGroup
                where mTmpOrderData.dataValue == discountPriceGroup.OfferId
            join priceDiscGroup
                group by discountPriceGroup.OfferId, discountPriceGroup.PriceDiscGroup, priceDiscGroup.GroupId, priceDiscGroup.RecId, priceDiscGroup.RetailPricingPriorityNumber
                where priceDiscGroup.RecId == discountPriceGroup.PriceDiscGroup
        {
            if (DiscountPriceGroupofferIdSet.in(discountPriceGroup.OfferId))
            {
                crtPriceGroupList.Add(this.ConvertToRetailDiscountPriceGroup(priceDiscGroup, discountPriceGroup));
            }
        }

        return crtPriceGroupList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ReadRetailDiscounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets retail discounts.
    /// If this method is updated, please update RetailPricingDataManagerSimulator.ReadRetailDiscounts() as well.
    /// </summary>
    /// <param name = "items">An object of item number.</param>
    /// <param name = "priceGroups">An object of price group.</param>
    /// <param name = "minActiveDate">A minimum active date to read retail discount.</param>
    /// <param name = "maxActiveDate">A maximum active date to read retail discount.</param>
    /// <param name = "currencyCode">A currency code to read retail discount.</param>
    /// <param name = "settings">Settings.</param>
    /// <returns>Retail discounts.</returns>
    public System.Object ReadRetailDiscounts(
            System.Object items,
            System.Object priceGroups,
            System.DateTimeOffset minActiveDate,
            System.DateTimeOffset maxActiveDate,
            System.String currencyCode,
            Microsoft.Dynamics.Commerce.Runtime.DataModel.QueryResultSettings settings)
    {
        System.Diagnostics.Stopwatch instrumentationTimer = new System.Diagnostics.Stopwatch();
        int64    instrumentationProductsMetric = 0;   // Metric 1 - Discounts for products
        int64    instrumentationVariantsMetric = 0;   // Metric 2 - Discounts for variants
        int64    instrumentationProductDimMetric = 0; // Metric 3 - Discount for individual product dimentions
        int64    instrumentationProductCatMetric = 0; // Metric 4 - Discount for product categories
        int64    instrumentationVariantCatMetric = 0; // Metric 5 - Discount for variant categories

        ValidFromDate minFromDate =  this.GetDateInChannelTimeZone(minActiveDate);
        ValidFromDate maxToDate =  this.GetDateInChannelTimeZone(maxActiveDate);
        UserId userId = curUserId();

        RetailPeriodicDiscount periodicDiscount;
        RetailPeriodicDiscountLine periodicDiscountLine;

        RetailDiscountPriceGroup discountPriceGroup;
        RetailGroupMemberLine retailGroupMemberLine;
        EcoResProductCategory productCategory;
        RetailSpecialCategoryMember variantCategory;
        RetailCategoryContainmentLookup categoryLookup;
        RetailGroupMemberLine groupMemberLineForCategoryVariant;
        UnitOfMeasure unitOfMeasure;
        offerIdSet = new Set(Types::String);

        Map validationPeriodLookup = new Map(Types::String, Types::AnyType);
        Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount crtDiscount;

        int discountType;

        instrumentationTimer.Start();

        // Get discount data table for MatchAllAssociatedPriceGroups set as yes and associated price groups.
        RetailTmpOfferIdWithPriceGroups offerIdWithPriceDiscGroupTmp = this.getOfferIdAndAssociatedPriceGroupList();

        // convert price group record ids into temp table for join
        TmpRecIdFilter priceDiscGroupTmp = this.getTmpPriceGroupTableFromGroupIds(priceGroups);

        #localmacro.WhileSelectPeriodicDiscount
        while select periodicDiscount
            where periodicDiscount.PeriodicDiscountType != RetailDiscountOfferTypeBase::Promotion && periodicDiscount.PeriodicDiscountType != RetailDiscountOfferTypeBase::Shipping
                   && periodicDiscount.Status == RetailDisabledEnabled::Enabled
                   && ((periodicDiscount.ValidFrom <= minFromDate || periodicDiscount.ValidFrom <= noDate)
                   && (periodicDiscount.ValidTo >= maxToDate || periodicDiscount.ValidTo <= noDate))
            join periodicDiscountLine
                where periodicDiscount.OfferId == periodicDiscountLine.OfferId
            join RecId, Product, Variant, Category, InventDimId from retailGroupMemberLine
                where retailGroupMemberLine.RecId == periodicDiscountLine.RetailGroupMemberLine
        #endmacro

        #localmacro.JoinUnitOfMeasureAndPriceGroup
            outer join RecId, Symbol from unitOfMeasure
                where unitOfMeasure.RecId == periodicDiscountLine.UnitOfMeasure
            exists join discountPriceGroup
                where discountPriceGroup.OfferId == periodicDiscount.OfferId
            exists join RefRecId from priceDiscGroupTmp
                where priceDiscGroupTmp.RefRecId == discountPriceGroup.PriceDiscGroup
        #endmacro

        #localmacro.BuildPeriodicDiscountContainer
            crtDiscount = this.ConvertToCrtPeriodicDiscountV2(
                periodicDiscount,
                periodicDiscountLine,
                unitOfMeasure,
                discountType,
                mTmpOrderItem.itemId,
                mTmpOrderItem.inventDimId);

            discountList.Add(crtDiscount);
        #endmacro

        delete_from mTmpOrderData;

        CLRObject discountList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount());

        // get lines matching the product with no dimension
        if (RetailPricingCacheForDataManager::shouldQueryRetailDiscountsProductNoDim())
        {
            #WhileSelectPeriodicDiscount
            join mTmpOrderItem
                    where retailGroupMemberLine.Variant == 0
                            && (retailGroupMemberLine.InventDimId == '' || retailGroupMemberLine.InventDimId == InventDimIdAllBlank)
                            && retailGroupMemberLine.Product != 0
                            && retailGroupMemberLine.Product == mTmpOrderItem.Product
                #JoinUnitOfMeasureAndPriceGroup
            {
                // Check is discount applicable.
                if (this.isDiscountApplicable(periodicDiscount.OfferId, periodicDiscount.MatchAllAssociatedPriceGroups, priceDiscGroupTmp, offerIdWithPriceDiscGroupTmp))
                {
                    #BuildPeriodicDiscountContainer
                    crtDiscount.ValidationPeriod = this.setValidationPeriod(periodicDiscount.ValidationPeriodId, validationPeriodLookup);
                    this.addOfferIdToTmpOrderDataList(periodicDiscount.OfferId, offerIdSet);
                }

                instrumentationProductsMetric += 1;
            }
        }

        // get lines matching the variant
        if (RetailPricingCacheForDataManager::shouldQueryRetailDiscountsVariant())
        {
            #WhileSelectPeriodicDiscount
            join mTmpOrderItem
                    where retailGroupMemberLine.Variant != 0
                            && (retailGroupMemberLine.InventDimId == '' || retailGroupMemberLine.InventDimId == InventDimIdAllBlank)
                            && retailGroupMemberLine.Variant == mTmpOrderItem.Variant
                #JoinUnitOfMeasureAndPriceGroup
            {
                // Check is discount applicable.
                if (this.isDiscountApplicable(periodicDiscount.OfferId, periodicDiscount.MatchAllAssociatedPriceGroups, priceDiscGroupTmp, offerIdWithPriceDiscGroupTmp))
                {
                    #BuildPeriodicDiscountContainer
                    crtDiscount.ValidationPeriod = this.setValidationPeriod(periodicDiscount.ValidationPeriodId, validationPeriodLookup);
                    this.addOfferIdToTmpOrderDataList(periodicDiscount.OfferId, offerIdSet);
                }

                instrumentationVariantsMetric += 1;
            }
        }

        // get lines matching the dimension
        if (RetailPricingCacheForDataManager::shouldQueryRetailDiscountsProductWithDim())
        {
            #WhileSelectPeriodicDiscount
            join mTmpOrderItem
                    where retailGroupMemberLine.Variant == 0
                            && retailGroupMemberLine.Product != 0
                            && retailGroupMemberLine.Product == mTmpOrderItem.Product
                            && mTmpOrderItem.Variant != 0
                            && retailGroupMemberLine.InventDimId != ''
                            && retailGroupMemberLine.InventDimId != InventDimIdAllBlank
                #JoinUnitOfMeasureAndPriceGroup
            {
                if (this.isVariantMatch(mTmpOrderItem.Variant, retailGroupMemberLine.InventDimId))
                {
                    // Check is discount applicable.
                    if (this.isDiscountApplicable(periodicDiscount.OfferId, periodicDiscount.MatchAllAssociatedPriceGroups, priceDiscGroupTmp, offerIdWithPriceDiscGroupTmp))
                    {
                        #BuildPeriodicDiscountContainer
                        crtDiscount.ValidationPeriod = this.setValidationPeriod(periodicDiscount.ValidationPeriodId, validationPeriodLookup);
                        this.addOfferIdToTmpOrderDataList(periodicDiscount.OfferId, offerIdSet);
                    }

                    instrumentationProductDimMetric += 1;
                }
            }
        }

        // get lines matching non-zero category, for product
        if (RetailPricingCacheForDataManager::shouldQueryRetailDiscountsCategory())
        {
            #WhileSelectPeriodicDiscount
            && retailGroupMemberLine.Variant == 0
                    && (retailGroupMemberLine.InventDimId == '' || retailGroupMemberLine.InventDimId == InventDimIdAllBlank)
                    && retailGroupMemberLine.Product == 0
                    && retailGroupMemberLine.Category != 0
                    join mTmpOrderItem
                        where mTmpOrderItem.Product != 0
                    join ContainedCategory from categoryLookup
                        where retailGroupMemberLine.Category == categoryLookup.Category
                    join Product from productCategory
                        where categoryLookup.ContainedCategory == productCategory.Category
                        && productCategory.Product == mTmpOrderItem.Product
                #JoinUnitOfMeasureAndPriceGroup
            {
                // Check is discount applicable.
                if (this.isDiscountApplicable(periodicDiscount.OfferId, periodicDiscount.MatchAllAssociatedPriceGroups, priceDiscGroupTmp, offerIdWithPriceDiscGroupTmp))
                {
                    #BuildPeriodicDiscountContainer
                    crtDiscount.ValidationPeriod = this.setValidationPeriod(periodicDiscount.ValidationPeriodId, validationPeriodLookup);
                    this.addOfferIdToTmpOrderDataList(periodicDiscount.OfferId, offerIdSet);
                }

                instrumentationProductCatMetric += 1;
            }

            // get lines matching non-zero category, for variant
            #WhileSelectPeriodicDiscount
            && retailGroupMemberLine.Variant == 0
                    && (retailGroupMemberLine.InventDimId == '' || retailGroupMemberLine.InventDimId == InventDimIdAllBlank)
                    && retailGroupMemberLine.Product == 0
                    && retailGroupMemberLine.Category != 0
                join mTmpOrderItem
                    where mTmpOrderItem.Variant != 0
                join ContainedCategory from categoryLookup
                    where retailGroupMemberLine.Category == categoryLookup.Category
                join RetailGroupMember from variantCategory
                    where categoryLookup.ContainedCategory == variantCategory.Category
                join groupMemberLineForCategoryVariant
                    where groupMemberLineForCategoryVariant.RecId == variantCategory.RetailGroupMember
                        && groupMemberLineForCategoryVariant.Variant == mTmpOrderItem.Variant
                #JoinUnitOfMeasureAndPriceGroup
            {
                // Check is discount applicable.
                if (this.isDiscountApplicable(periodicDiscount.OfferId, periodicDiscount.MatchAllAssociatedPriceGroups, priceDiscGroupTmp, offerIdWithPriceDiscGroupTmp))
                {
                    #BuildPeriodicDiscountContainer
                    crtDiscount.ValidationPeriod = this.setValidationPeriod(periodicDiscount.ValidationPeriodId, validationPeriodLookup);
                    this.addOfferIdToTmpOrderDataList(periodicDiscount.OfferId, offerIdSet);
                }

                instrumentationVariantCatMetric += 1;
            }
        }

        tmpOrderDataInsertList.insertDatabase();

        // Instrumentaion Reporting
        instrumentationTimer.Stop();
        eventSource.EventWritePricingDiscountsRead(
            funcName(),
            instrumentationTimer.get_ElapsedMilliseconds(),
            instrumentationProductsMetric,
            instrumentationVariantsMetric,
            instrumentationProductDimMetric,
            instrumentationProductCatMetric,
            instrumentationVariantCatMetric);

        return discountList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDiscountApplicable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the discount should add in discount list.
    /// </summary>
    /// <param name = "_offerId">Discount.</param>
    /// <param name = "_matchAllAssociatedPriceGroups"> Contains status of discount's MatchAllAssociatedPriceGroups property.</param>
    /// <param name = "_priceGroups"> The <c>TmpRecIdFilter</c> table buffers contains transaction price groups.</param>
    /// <param name = "_offerIdWithPriceGroups">Discount data table for MatchAllAssociatedPriceGroups set as yes and associated price groups.</param>
    /// <returns>True if discount is associated with all price groups, otherwise false.</returns>
    public boolean isDiscountApplicable(RetailOfferIdEx3 _offerId, RetailMatchAllAssociatedPriceGroups _matchAllAssociatedPriceGroups, TmpRecIdFilter _priceGroups, RetailTmpOfferIdWithPriceGroups _offerIdWithPriceGroups)
    {
        boolean addDiscountInList = true;

        // Check if discount _matchAllAssociatedPriceGroups property is true, then discount's pricegroups should match with transaction's pricegroups.
        if (_matchAllAssociatedPriceGroups == NoYes::Yes)
        {
            // Generate key for Map isDiscountApplicableMap.
            Container mapKey = this.generateKeyForIsDiscountApplicableMap(_priceGroups, _offerId);

            if (isDiscountApplicableMap.exists(mapKey))
            {
                addDiscountInList = isDiscountApplicableMap.lookup(mapKey);
            }
            else
            {
                RetailTmpOfferIdWithPriceGroups retailTmpOfferIdWithPriceGroup;

                TmpRecIdFilter priceGroups;
                int offeridPriceGroupCount, transactionPriceGroupCount;

                priceGroups.linkPhysicalTableInstance(_priceGroups);
                retailTmpOfferIdWithPriceGroup.setTmpData(_offerIdWithPriceGroups);

                // Get the number of price groups that are associated with discount/offer.
                select count(RecId) from retailTmpOfferIdWithPriceGroup
                where retailTmpOfferIdWithPriceGroup.OfferId == _offerId;

                // Ignore the warning since RecId field stores the sum value.
                offeridPriceGroupCount = retailTmpOfferIdWithPriceGroup.RecId;

                // Get the number of transaction price groups that are associated with discount/offer.
                select count(RecId) from retailTmpOfferIdWithPriceGroup
                where retailTmpOfferIdWithPriceGroup.OfferId == _offerId
                exists join priceGroups
                    where priceGroups.RefRecId == retailTmpOfferIdWithPriceGroup.PriceGroupRecId;

                // Ignore the warning since RecId field stores the sum value.
                transactionPriceGroupCount = retailTmpOfferIdWithPriceGroup.RecId;

                // Check discount and transaction's PriceGroup matched.
                If (offeridPriceGroupCount != transactionPriceGroupCount)
                {
                    addDiscountInList = false;
                }

                isDiscountApplicableMap.insert(mapKey, addDiscountInList);
            }
        }

        return addDiscountInList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOfferIdAndAssociatedPriceGroupList</Name>
				<Source><![CDATA[
    // Get discount datatable for MatchAllAssociatedPriceGroups set as yes and associated price groups.
    public RetailTmpOfferIdWithPriceGroups getOfferIdAndAssociatedPriceGroupList()
    {
        RetailPeriodicDiscount periodicDiscount;
        RetailDiscountPriceGroup discountPriceGroup;

        RetailTmpOfferIdWithPriceGroups offerIdWithPriceDiscGroupTmp;
        RecordInsertList recordInsertList;
        if (RetailPricingCalcBulkInsertTempTableFlight::instance().isEnabled())
        {
            recordInsertList = new RecordInsertList(
                tableNum(RetailTmpOfferIdWithPriceGroups),
                true, // skip insert
                true, // skip database log
                true, // skip events
                true, // skip aos validation
                true, // skip RLS validation
                offerIdWithPriceDiscGroupTmp); // buffer where records will be inserted
        }
        else
        {
            recordInsertList = new RecordInsertList(
                tableNum(RetailTmpOfferIdWithPriceGroups),
                false, // skip insert
                false, // skip database log
                false, // skip events
                false, // skip aos validation
                false, // skip RLS validation
                offerIdWithPriceDiscGroupTmp); // buffer where records will be inserted
        }

        while select OfferId from periodicDiscount
            where periodicDiscount.MatchAllAssociatedPriceGroups == NoYes::Yes
            join discountPriceGroup
                where periodicDiscount.OfferId == discountPriceGroup.OfferId
        {
            // Convert offerId with price group record ids into temp table for join.
            offerIdWithPriceDiscGroupTmp.OfferId = periodicDiscount.OfferId;
            offerIdWithPriceDiscGroupTmp.PriceGroupRecId = discountPriceGroup.PriceDiscGroup;
            recordInsertList.add(offerIdWithPriceDiscGroupTmp);
        }

        recordInsertList.insertDatabase();

        return offerIdWithPriceDiscGroupTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetPricingPropertyDefinitions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get all pricing property definitions.
    /// </summary>
    /// <returns>An IEnumerable of Crt PricingPropertyDefinition entity.</returns>
    [Hookable(false), Wrappable(false)]
    public System.Object GetPricingPropertyDefinitions()
    {
        CLRObject definitionList = this.createCLRList(new CrtPricingPropertyDefinition());

        // Users change property definition very infrequently. Here is leveraging the table cache from AOS so we don't query database every time.
        // See the Cache Lookup on RetailPricingPropertyDefinition table.
        RetailPricingPropertyDefinition definition;
        while select definition where definition.Status == RetailPricingPropertyProcessStatus::Published
        {
            CrtPricingPropertyDefinition clrDefinition = new CrtPricingPropertyDefinition();
            clrDefinition.RecordId = definition.RecId;
            clrDefinition.PropertyLevelValue = enum2int(definition.PropertyLevel);
            clrDefinition.PropertyTypeValue = enum2int(definition.PropertyType);
            clrDefinition.PropertySourceValue = enum2int(definition.PropertySource);
            clrDefinition.PredefinedPropertyValue = enum2int(definition.PredefinedProperty);
            clrDefinition.AttributeRecordId = definition.EcoResAttributeRecId;
            definitionList.Add(clrDefinition);
        }
        return definitionList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetPricingPropertyValueHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// This returns a runtime-aware implementation of IPricingPropertyValueHandler.
    /// As some of the property providers need to access runtime, e.g. database.
    /// </summary>
    /// <returns>An instance of a IPricingPropertyValueHandler.</returns>
    [Hookable(false), Wrappable(false)]
    public Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.IPricingPropertyValueHandler GetPricingPropertyValueHandler()
    {
        return new RetailPricingPropertyValueHandler(this.mTmpOrderItem, this.mTransactionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetPriceGroupsByProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets all price groups by the runtime properties.
    /// </summary>
    /// <param name = "priceContext">The price context.</param>
    /// <returns>An IEnumrable of Crt PriceGroup entity.</returns>
    [Hookable(false), Wrappable(false)]
    public System.Object GetPriceGroupsByProperties(CrtPriceContext priceContext)
    {
        CLRObject priceGroupList = this.createCLRList(new CrtPriceGroup());
        CLRObject pricingProperties = priceContext.get_PropertyValueContext().get_PricingProperties();
        System.Collections.SortedList definitionList = new System.Collections.SortedList();
        System.Collections.IEnumerator enumerator = pricingProperties.GetEnumerator();
        while (enumerator.MoveNext())
        {
            CrtPricingPropertyDefinition definition = enumerator.get_Current();
            if (definition.get_PropertyLevel() == CrtPricingPropertyLevel::Header)
            {
                definitionList.Add(definition.get_RecordId(), definition);
            }
        }

        Query priceGroupQuery = new Query();
        QueryBuildDataSource qbds = priceGroupQuery.addDataSource(tableNum(PriceDiscGroup));
        qbds.addSelectionField(fieldNum(PriceDiscGroup, RecId));
        qbds.addSelectionField(fieldNum(PriceDiscGroup, GroupId));
        qbds.addSelectionField(fieldNum(PriceDiscGroup, RetailPricingPriorityNumber));
        qbds = qbds.addDataSource(tableNum(RetailPriceGroupApplicabilityRule));
        qbds.joinMode(JoinMode::ExistsJoin);
        qbds.relations(true);

        // We have up to 10 property settings globally.
        this.addRetailPriceGroupApplicabilityRuleRange(priceContext, definitionList, 0, qbds, fieldNum(RetailPriceGroupApplicabilityRule, PropValue0));
        this.addRetailPriceGroupApplicabilityRuleRange(priceContext, definitionList, 1, qbds, fieldNum(RetailPriceGroupApplicabilityRule, PropValue1));
        this.addRetailPriceGroupApplicabilityRuleRange(priceContext, definitionList, 2, qbds, fieldNum(RetailPriceGroupApplicabilityRule, PropValue2));
        this.addRetailPriceGroupApplicabilityRuleRange(priceContext, definitionList, 3, qbds, fieldNum(RetailPriceGroupApplicabilityRule, PropValue3));
        this.addRetailPriceGroupApplicabilityRuleRange(priceContext, definitionList, 4, qbds, fieldNum(RetailPriceGroupApplicabilityRule, PropValue4));
        this.addRetailPriceGroupApplicabilityRuleRange(priceContext, definitionList, 5, qbds, fieldNum(RetailPriceGroupApplicabilityRule, PropValue5));
        this.addRetailPriceGroupApplicabilityRuleRange(priceContext, definitionList, 6, qbds, fieldNum(RetailPriceGroupApplicabilityRule, PropValue6));
        this.addRetailPriceGroupApplicabilityRuleRange(priceContext, definitionList, 7, qbds, fieldNum(RetailPriceGroupApplicabilityRule, PropValue7));
        this.addRetailPriceGroupApplicabilityRuleRange(priceContext, definitionList, 8, qbds, fieldNum(RetailPriceGroupApplicabilityRule, PropValue8));
        this.addRetailPriceGroupApplicabilityRuleRange(priceContext, definitionList, 9, qbds, fieldNum(RetailPriceGroupApplicabilityRule, PropValue9));
        QueryRun queryRun = new QueryRun(priceGroupQuery);
        while (queryRun.next())
        {
            PriceDiscGroup priceDiscGroup = queryRun.getNo(1);
            
            CrtPriceGroup crtPriceGroup = new CrtPriceGroup();
            crtPriceGroup.PriceGroupId = priceDiscGroup.RecId;
            crtPriceGroup.GroupId = priceDiscGroup.GroupId;
            crtPriceGroup.PricingPriorityNumber = priceDiscGroup.RetailPricingPriorityNumber;
            priceGroupList.Add(crtPriceGroup);
        }
        return priceGroupList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRetailPriceGroupApplicabilityRuleRange</Name>
				<Source><![CDATA[
    private void addRetailPriceGroupApplicabilityRuleRange(CrtPriceContext priceContext, System.Collections.SortedList definitionList, int idx, QueryBuildDataSource qbds, FieldId fieldId)
    {
        if (definitionList.Count <= idx)
        {
            return ;
        }

        CrtPricingPropertyDefinition definition = definitionList.GetByIndex(idx);
        System.Collections.IEnumerator enumerator = priceContext.get_PropertyValueContext().GetHeaderValues(definition).GetEnumerator();
            
        while (enumerator.MoveNext())
        {
            CrtCommercePropertyValue propertyValue = enumerator.get_Current();
            str propValue = propertyValue.GetPropertyValue().ToString();
            qbds.addRange(fieldId).value(SysQuery::value(propValue));
        }
        qbds.addRange(fieldId).value(SysQuery::valueEmptyString());
    }

]]></Source>
			</Method>
			<Method>
				<Name>ReadDiscountsByProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets all applicable discounts by the runtime properties.
    /// </summary>
    /// <param name = "priceContext">The price context.</param>
    /// <returns>An IEnumrable of Crt PeriodicDiscount entity.</returns>
    [Hookable(false), Wrappable(false)]
    public System.Object ReadDiscountsByProperties(CrtPriceContext priceContext)
    {
        container discountOfferTypes = [
            RetailDiscountOfferTypeBase::Multibuy,
            RetailDiscountOfferTypeBase::MixAndMatch,
            RetailDiscountOfferTypeBase::DiscountOffer,
            RetailDiscountOfferTypeBase::Threshold,
            RetailDiscountOfferTypeBase::LeastExpensiveFavorRetailer,
            RetailDiscountOfferTypeBase::DiscountOfferLineQuantityLimit
        ];

        return this.readDiscountByPropertiesInternal(priceContext, discountOfferTypes).AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ReadPriceAdjustmentsByProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets all applicable price adjustments by the runtime properties.
    /// </summary>
    /// <param name = "priceContext">The price context.</param>
    /// <returns>An IEnumrable of Crt PriceAdjustment entity.</returns>
    [Hookable(false), Wrappable(false)]
    public System.Object ReadPriceAdjustmentsByProperties(CrtPriceContext priceContext)
    {
        container discountOfferTypes = [
            RetailDiscountOfferTypeBase::Promotion
        ];

        CLRObject discountList = this.readDiscountByPropertiesInternal(priceContext, discountOfferTypes);

        CLRObject priceAdjustmentList = this.createCLRList(new CrtPriceAdjustment());

        System.Collections.IEnumerator enumerator = discountList.GetEnumerator();
        while (enumerator.MoveNext())
        {
            CrtPeriodicDiscount discount = enumerator.get_Current();
            CrtPriceAdjustment priceAdjustment = CrtPriceAdjustment::FromPeriodicDiscount(discount);
            priceAdjustment.ValidationPeriod = discount.ValidationPeriod;
            priceAdjustmentList.Add(priceAdjustment);
        }

        return priceAdjustmentList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>readDiscountByPropertiesInternal</Name>
				<Source><![CDATA[
    protected CLRObject readDiscountByPropertiesInternal(CrtPriceContext priceContext, container discountOfferTypes)
    {
        CLRObject discountList = this.createCLRList(new CrtPeriodicDiscount());

        if (priceContext.get_PropertyBasedPriceGroups().Count == 0)
        {
            return discountList;
        }

        CrtPricingPropertyValueContext propertyValueContext = priceContext.get_PropertyValueContext();
        System.Collections.SortedList definitionList = new System.Collections.SortedList();
        System.Collections.IEnumerator enumerator = propertyValueContext.get_PricingProperties().GetEnumerator();
        while (enumerator.MoveNext())
        {
            CrtPricingPropertyDefinition definition = enumerator.get_Current();
            if (definition.get_PropertyLevel() == CrtPricingPropertyLevel::Line)
            {
                definitionList.Add(definition.get_RecordId(), definition);
            }
        }

        Set lineNumbers = new Set(Types::AnyType);
        enumerator = propertyValueContext.get_LinePropertyValues().get_Keys().GetEnumerator();
        while (enumerator.MoveNext())
        {
            CLRObject tuple = enumerator.get_Current();
            System.Decimal lineNumber = this.GetTupleValue(tuple, 'Item2');
            lineNumbers.add(lineNumber);
        }

        Map lineNumberPropertyHash = new Map(Types::AnyType, Types::AnyType);
        Map hashLineNumber = new Map(Types::AnyType, Types::AnyType);

        this.PopulateApplicabilityRules(lineNumberPropertyHash, hashLineNumber, lineNumbers, definitionList, propertyValueContext);

        Set couponOfferIds = this.getCouponCodeOfferIds();
        Map validationPeriodLookup = new Map(Types::String, Types::AnyType);

        date activeDate = this.GetDateInChannelTimeZone(priceContext.ActiveDate);

        this.ReadDiscountsFromDatabaseByProperties(hashLineNumber.keySet(), hashLineNumber, activeDate,
            priceContext.PropertyBasedPriceGroups, priceContext.CurrencyCode, couponOfferIds, discountList, validationPeriodLookup, discountOfferTypes);

        tmpOrderDataInsertList.insertDatabase();

        return discountList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>PopulateApplicabilityRules</Name>
				<Source><![CDATA[
    private void PopulateApplicabilityRules(
        Map lineNumberPropertyHash,
        Map hashLineNumber,
        Set lineNumbers,
        System.Collections.SortedList lineProperties,
        CrtPricingPropertyValueContext propertyValueContext)
    {
        SetEnumerator se = lineNumbers.getEnumerator();
        while (se.moveNext())
        {
            System.Decimal lineNumber = se.current();

            List propertyValueRules = new List(Types::AnyType);
            propertyValueRules.addEnd(new CrtPricingApplicabilityRule());  // Add the default empty rule.

            for (int idx = 0; idx < lineProperties.Count; idx++)
            {
                CrtPricingPropertyDefinition definition = lineProperties.GetByIndex(idx);

                CLRObject propertyValueSet = propertyValueContext.GetLineValues(definition, lineNumber);

                System.Collections.IEnumerator enumerator = propertyValueSet.GetEnumerator();
                List propertyValues = new List(Types::AnyType);
                while (enumerator.MoveNext())
                {
                    CrtCommercePropertyValue value = enumerator.Current;
                    System.String stringValue = value.GetPropertyValue().ToString();

                    if (!System.String::IsNullOrWhiteSpace(stringValue))
                    {
                        propertyValues.addEnd(stringValue);
                    }
                }

                List newPropertyValueRules = new List(Types::AnyType);
                ListEnumerator le = propertyValueRules.getEnumerator();
                while (le.moveNext())
                {
                    CrtPricingApplicabilityRule existingRule = le.current();

                    ListEnumerator leValue = propertyValues.getEnumerator();
                    while (leValue.moveNext())
                    {
                        System.String newValue = leValue.current();

                        CrtPricingApplicabilityRule newRule = existingRule.Clone();

                        newRule.set_Item(idx, newValue);

                        newPropertyValueRules.addEnd(newRule);
                    }
                }

                le = newPropertyValueRules.getEnumerator();
                while (le.moveNext())
                {
                    CrtPricingApplicabilityRule newRule = le.current();

                    propertyValueRules.addEnd(newRule);
                }
            }

            Set hashValues = new Set(Types::AnyType);
            ListEnumerator le = propertyValueRules.getEnumerator();
            while (le.moveNext())
            {
                CrtPricingApplicabilityRule rule = le.current();

                System.String hashKey = rule.get_HashKey();
                hashValues.add(hashKey);

                if (hashLineNumber.exists(hashKey))
                {
                    List lineNumberList = hashLineNumber.lookup(hashKey);
                    lineNumberList.addEnd(lineNumber);
                }
                else
                {
                    List lineNumberList = new List(Types::AnyType);
                    lineNumberList.addEnd(lineNumber);
                    hashLineNumber.insert(hashKey, lineNumberList);
                }
            }
            lineNumberPropertyHash.add(lineNumber, hashValues);
        }

        MapEnumerator me = lineNumberPropertyHash.getEnumerator();
        while (me.moveNext())
        {
            System.Decimal lineNumber = me.currentKey();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ReadDiscountsFromDatabaseByProperties</Name>
				<Source><![CDATA[
    private System.Object ReadDiscountsFromDatabaseByProperties(
        Set hashKeys,
        Map hashLineNumber,
        date activeDate,
        CLRObject crtPriceGroups,
        System.String _currencyCode,
        Set _couponOfferIds,
        CLRObject _discountList,
        Map _validationPeriodLookup,
        container discountOfferType)
    {
        TmpRecIdFilter priceDiscGroupTmp;
        RecordInsertList recordInsertList = new RecordInsertList(tableNum(TmpRecIdFilter), true, true, true, true, true, priceDiscGroupTmp);
        System.Collections.IEnumerator clrEn = crtPriceGroups.GetEnumerator();
        while (clrEn.MoveNext())
        {
            CrtPriceGroup crtPriceGroup = clrEn.get_Current();
            priceDiscGroupTmp.RefRecId = crtPriceGroup.get_PriceGroupId();
            recordInsertList.add(priceDiscGroupTmp);
        }
        recordInsertList.insertDatabase();

        RetailRetailApplicabiiltyRuleSHA3HashHexTmp hashTmp;
        recordInsertList = new RecordInsertList(tableNum(RetailRetailApplicabiiltyRuleSHA3HashHexTmp), true, true, true, true, true, hashTmp);

        SetEnumerator se = hashKeys.GetEnumerator();
        while (se.moveNext())
        {
            System.String hashKey = se.current();
            hashTmp.SHA3HashHex = hashKey;
            recordInsertList.add(hashTmp);
        }
        recordInsertList.insertDatabase();

        // Minimize the further effort for simulator cases to not copy the method.
        boolean includeDisabledDiscounts = false;
        if (this is RetailPricingDataManagerSimulator)
        {
            RetailPricingDataManagerSimulator simulator = this as RetailPricingDataManagerSimulator;
            includeDisabledDiscounts = simulator.includeDisabledDiscounts;
        }

        RetailDiscountPriceGroup discountPriceGroup;
        RetailPeriodicDiscount periodicDiscount;
        RetailPeriodicDiscountLine periodicDiscountLine;
        RetailDiscountApplicabilityRule retailDiscountApplicabilityRule;
        while select forceSelectOrder forceNestedLoop hashTmp
            join SHA3HashHex from retailDiscountApplicabilityRule
                where hashTmp.SHA3HashHex == retailDiscountApplicabilityRule.SHA3HashHex
            join periodicDiscountLine
                where periodicDiscountLine.RecId == retailDiscountApplicabilityRule.RetailPeriodicDiscountLine
            join periodicDiscount
                where periodicDiscount.PeriodicDiscountType in discountOfferType
                    && (periodicDiscount.ValidFrom <= activeDate || periodicDiscount.ValidFrom <= noDate)
                    && (periodicDiscount.ValidTo >= activeDate || periodicDiscount.ValidTo <= noDate)
                    && periodicDiscount.CurrencyCode == _currencyCode
                    && periodicDiscount.OfferId == periodicDiscountLine.OfferId
                    && (includeDisabledDiscounts || (periodicDiscount.Status == RetailDisabledEnabled::Enabled))
            exists join RecId from discountPriceGroup
                where discountPriceGroup.OfferId == periodicDiscount.OfferId
            exists join RefRecId from priceDiscGroupTmp
                where priceDiscGroupTmp.RefRecId == discountPriceGroup.PriceDiscGroup
        {
            if (this.validateCoupon(periodicDiscount, _couponOfferIds))
            {
                continue;
            }

            System.String hashHex = retailDiscountApplicabilityRule.SHA3HashHex;
            if (!hashLineNumber.exists(hashHex))
            {
                continue;
            }

            ListEnumerator le = hashLineNumber.lookup(hashHex).GetEnumerator();
            while (le.moveNext())
            {
                System.Decimal lineNumber = le.current();

                CrtPeriodicDiscount crtDiscount = this.ConvertToPropertyPeriodicDiscount(periodicDiscount, periodicDiscountLine, lineNumber);

                _discountList.Add(crtDiscount);

                crtDiscount.ValidationPeriod = this.setValidationPeriod(periodicDiscount.ValidationPeriodId, _validationPeriodLookup);
                this.addOfferIdToTmpOrderDataList(periodicDiscount.OfferId, offerIdSet);
            }
        }

        return _discountList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetTupleValue</Name>
				<Source><![CDATA[
    // X++ isn't able to handle generic correctly.
    // Will migrate below method to Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.TypeHelperForAx when Channel code change is ready.
    protected System.Object GetTupleValue(System.Object tuple, str name)
    {
        System.Type clrType = tuple.GetType();
        return clrType.GetField(name).GetValue(tuple);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCouponCodeOfferIds</Name>
				<Source><![CDATA[
    protected Set getCouponCodeOfferIds()
    {
        Set couponOfferIds = new Set(Types::String);

        if (RetailPricingEngine::isMCROrder(mTransactionId))
        {
            RetailCouponUsage retailCouponUsage;
            RetailCouponCodeTable retailCouponCodeTable;
            RetailCoupon retailCoupon;

            while select DiscountOfferId from retailCoupon
            join retailCouponCodeTable
                where retailCouponCodeTable.CouponNumber == retailCoupon.CouponNumber
                exists join retailCouponUsage
                    where retailCouponUsage.CouponCodeId == retailCouponCodeTable.CouponCodeId
                        && retailCouponUsage.SalesId == mTransactionId
            {
                couponOfferIds.add(retailCoupon.DiscountOfferId);
            }

            return couponOfferIds;
        }

        if (RetailPricingEngine::isPriceSimulatorTrans(mTransactionId))
        {
            RetailPricingSimulatorDiscountCode retailPricingSimulatorDiscountCode;
            RetailCouponCodeTable retailCouponCodeTable;
            RetailCoupon retailCoupon;

            int64 transactionId;
            // See RetailPricingSimulator. We currently int642Str in getTransactionIdString.
            if (!System.Int64::TryParse(mTransactionId, byref transactionId))
            {
                return couponOfferIds;
            }

            while select DiscountOfferId from retailCoupon
            join retailCouponCodeTable
                where retailCouponCodeTable.CouponNumber == retailCoupon.CouponNumber
                exists join retailPricingSimulatorDiscountCode
                    where retailPricingSimulatorDiscountCode.RetailDiscountCode == retailCouponCodeTable.RecId
                        && retailPricingSimulatorDiscountCode.RetailPricingSimulatorSalesTransaction == transactionId
            {
                couponOfferIds.add(retailCoupon.DiscountOfferId);
            }

            return couponOfferIds;
        }


        return couponOfferIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToPropertyPeriodicDiscount</Name>
				<Source><![CDATA[
    private Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount ConvertToPropertyPeriodicDiscount(
        RetailPeriodicDiscount periodicDiscount,
        RetailPeriodicDiscountLine periodicDiscountLine,
        System.Decimal linenumber)
    {
        RetailExtensibleEnumerationInitializer::setExtensibleEnumInitializer(funcName());

        Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount crtDiscount = this.constructCRTPeriodicDiscount();

        RetailDiscountOffer discountOffer;
        RetailDiscountMixAndMatch discountMixAndMatch;
        RetailDiscountMultibuy discountMultibuy;
        RetailDiscountThreshold discountThreshold;
        RetailDiscountLineOffer discountLineOffer;
        RetailDiscountLineMixAndMatch discountLineMixAndMatch;
        RetailDiscountLineThresholdApplying discountLineThresholdApplying;

        int discountType = 0;
        try
        {
            switch (periodicDiscount.PeriodicDiscountType)
            {
                case RetailDiscountOfferTypeBase::DiscountOffer:
                case RetailDiscountOfferTypeBase::DiscountOfferLineQuantityLimit:
                    discountOffer = periodicDiscount;
                    discountLineOffer = periodicDiscountLine;
                    break;
                case RetailDiscountOfferTypeBase::MixAndMatch:
                case RetailDiscountOfferTypeBase::LeastExpensiveFavorRetailer:
                    discountLineMixAndMatch = periodicDiscountLine;
                    discountMixAndMatch = periodicDiscount;
                    discountType = discountMixAndMatch.MixAndMatchDiscountType;
                    break;
                case RetailDiscountOfferTypeBase::Multibuy:
                    discountMultibuy = periodicDiscount;
                    discountType = discountMultibuy.MultibuyDiscountType;
                    break;
                case RetailDiscountOfferTypeBase::Threshold:
                    discountThreshold = periodicDiscount;
                    if(periodicDiscountLine.IsDiscountApplyingLine == NoYes::Yes)
                    {
                        discountLineThresholdApplying = periodicDiscountLine;

                        eventSource.EventWriteFeatureUsed(
                            'ThresholdDiscountWithGiftPurchaseFeature',
                            classStr(RetailPricingDataManager),
                            methodStr(RetailPricingDataManager, ConvertToCrtPeriodicDiscountV2),
                            '');
                    }
                    break;
                case RetailDiscountOfferTypeBase::Promotion:
                    discountLineOffer = periodicDiscountLine;
                    break;
                default:
                    break;
            }
        }
        catch (Exception::CLRError)
        {
            error(strFmt(
                "@RetailPricing:DiscountLineInvalidCast",
                periodicDiscountLine.LineNum,
                periodicDiscountLine.OfferId,
                periodicDiscount.PeriodicDiscountType));
            System.Exception ex = CLRInterop::getLastException().get_InnerException();
            throw ex;
        }

        crtDiscount.RecordId = periodicDiscountLine.RecId;
        crtDiscount.OfferId = periodicDiscount.OfferId;
        crtDiscount.ValidFromDate = this.ConvertDateToSystemDateTimeOffset(periodicDiscount.ValidFrom);
        crtDiscount.ValidToDate = this.ConvertDateToSystemDateTimeOffset(periodicDiscount.ValidTo);
        crtDiscount.ConcurrencyMode = enum2int(periodicDiscount.ConcurrencyMode);
        crtDiscount.PricingPriorityNumber = periodicDiscount.PricingPriorityNumber;
        crtDiscount.DateValidationType = periodicDiscount.DateValidationType;
        crtDiscount.ValidationPeriodId = periodicDiscount.ValidationPeriodId;
        crtDiscount.DiscountMethod = discountLineOffer.discountMethod;
        crtDiscount.OfferPrice = discountLineOffer.offerPrice;
        crtDiscount.DiscountPercent = discountLineOffer.discPct;
        crtDiscount.DiscountAmount = discountLineOffer.discAmount;
        crtDiscount.Name = periodicDiscount.Name;
        crtDiscount.ExtensiblePeriodicDiscountType = Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.TypeHelperForAx::GetExtensiblePeriodicDiscountOfferTypeByValue(enum2int(periodicDiscount.PeriodicDiscountType));
        crtDiscount.IsDiscountCodeRequired = periodicDiscount.IsDiscountCodeRequired;
        crtDiscount.DiscountType = discountType;
        crtDiscount.MixAndMatchDealPrice = discountMixAndMatch.DealPriceValue;
        crtDiscount.MixAndMatchDiscountPercent = periodicDiscount.DiscountPercentValue;
        crtDiscount.MixAndMatchDiscountAmount = discountMixAndMatch.DiscountAmountValue;
        crtDiscount.MixAndMatchNumberOfLeastExpensiveLines = discountMixAndMatch.NoOfLeastExpensiveLines;
        crtDiscount.MixAndMatchNumberOfTimeApplicable = discountMixAndMatch.numberOfTimesApplicable;
        crtDiscount.LeastExpensiveMode = enum2int(discountMixAndMatch.LeastExpensiveMode);
        crtDiscount.DiscountLineNumber = periodicDiscountLine.LineNum;
        crtDiscount.DiscountLinePercentOrValue = periodicDiscountLine.DiscountPercentOrValue;
        crtDiscount.MixAndMatchLineGroup = discountLineMixAndMatch.lineGroup;
        crtDiscount.MixAndMatchLineSpecificDiscountType = discountLineMixAndMatch.discountType;
        crtDiscount.MixAndMatchShouldCountNonDiscountItems = discountMixAndMatch.MixAndMatchCountNonDiscountItems;
        crtDiscount.MixAndMatchLineNumberOfItemsNeeded = discountLineMixAndMatch.numberOfItemsNeeded;
        crtDiscount.ShouldCountNonDiscountItems = discountThreshold.CountNonDiscountItems;
        crtDiscount.CurrencyCode = periodicDiscount.CurrencyCode;
        crtDiscount.MixAndMatchGeneratesBundleId = discountMixAndMatch.GeneratesBundleId;
        crtDiscount.OfferQuantityLimit = discountOffer.QuantityLimit;
        crtDiscount.LineType = enum2int(periodicDiscountLine.LineType);
        crtDiscount.SalesLineNumber = linenumber;

        crtDiscount.IsDiscountApplyingLine = discountLineThresholdApplying.IsDiscountApplyingLine;
        crtDiscount.ThresholdApplyingLineQuantityLimit = discountLineThresholdApplying.QuantityLimit;
        crtDiscount.ThresholdApplyingLineDiscountMethod = enum2int(discountLineThresholdApplying.ThresholdLineDiscountMethod);
        crtDiscount.ThresholdApplyingLineTierId = discountLineThresholdApplying.Tier;

        return crtDiscount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCoupon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Only add coupon discounts for further processing when:
    /// Manully apply coupon code to return transaction is false (so discount may apply even when no coupon code is given).
    /// and coupon code matches transaction coupons.
    /// Note: Do not check if there is line with negative quantity, since the line may well be the last line and not saved to DB yet.
    /// The recalculation is only triggered when certain fields are set (based on price discount policy), and no recaluclation is triggered upon saving thus discount will be incorrect for this last line.
    /// Same for below 3 methods.
    /// </summary>
    /// <param name = "_discount">The discount</param>
    /// <param name = "_couponOfferIds">Available coupon offer ids.</param>
    /// <returns>A boolean indicates if the coupon discount is applicable.</returns>
    protected boolean validateCoupon(RetailPeriodicDiscount _discount, Set _couponOfferIds)
    {
        return _discount.IsDiscountCodeRequired
            && !_couponOfferIds.in(_discount.OfferId)
            && RetailConfigurationParameters::getManuallyApplyDiscountsToReturnProduct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCrtPeriodicDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find applicable discount and discount line, construct <c>PeriodicDiscount</c> and add to list of discounts.
    /// </summary>
    /// <param name = "_periodicDiscount">Periodic discount.</param>
    /// <param name = "_itemId">Item Id which will be used to generate PeriodicDiscount.</param>
    /// <param name = "_inventDimId">InventDimId which will be used to generate <c>PeriodicDiscount</c>.</param>
    /// <param name = "_categoriesRecId">Collection of category RecIds to which line item belongs to (including current category and ancestor category). </param>
    /// <param name = "_discountList">Collection of <c>PeriodicDiscount</c> to which applicable <c>PeriodicDiscount</c> found will be added.</param>
    /// <param name = "_validationPeriodLookup">Validation period lookup.</param>
    [Hookable(false), Wrappable(false)]
    protected void buildCrtPeriodicDiscount(RetailPeriodicDiscount _periodicDiscount, str _itemId, str _inventDimId, container _categoriesRecId, CLRObject _discountList, Map _validationPeriodLookup)
    {
        using(var t = RetailInstrumentationSegment::construct(RetailInstrumentationSegmentArea, funcName()))
        {
            int discountType = 0;
            Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount crtDiscount;

            List categoryDiscounts = this.ReadRetailDiscountsForCategories(_periodicDiscount, _categoriesRecId);
            ListEnumerator enumerator = categoryDiscounts.getEnumerator();

            while (enumerator.moveNext())
            {
                RetailPeriodicDiscountCategoryCache discount = enumerator.current();

                if (discount.retailPeriodicDiscountLine)
                {
                    crtDiscount = this.ConvertToCrtPeriodicDiscountV2(_periodicDiscount,
                                discount.retailPeriodicDiscountLine,
                                discount.unitOfMeasure,
                                discountType,
                                _itemId,
                                _inventDimId);

                    _discountList.Add(crtDiscount);

                    crtDiscount.ValidationPeriod = this.setValidationPeriod(_periodicDiscount.ValidationPeriodId, _validationPeriodLookup);
                    this.addOfferIdToTmpOrderDataList(_periodicDiscount.OfferId, offerIdSet);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setValidationPeriod</Name>
				<Source><![CDATA[
    [Hookable(false), Wrappable(false)]
    protected Microsoft.Dynamics.Commerce.Runtime.DataModel.ValidationPeriod setValidationPeriod(RetailDiscountValidationPeriodId _validationPeriodId, Map _validationPeriodLookup)
    {
        if (_validationPeriodId)
        {
            Microsoft.Dynamics.Commerce.Runtime.DataModel.ValidationPeriod crtValidationPeriod = null;
            if (_validationPeriodLookup.exists(_validationPeriodId))
            {
                crtValidationPeriod = _validationPeriodLookup.lookup(_validationPeriodId);
            }
            else
            {
                crtValidationPeriod = this.GetValidationPeriod(_validationPeriodId);
                _validationPeriodLookup.insert(_validationPeriodId, crtValidationPeriod);
            }

            return crtValidationPeriod;
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addOfferIdToTmpOrderDataList</Name>
				<Source><![CDATA[
    [Hookable(false), Wrappable(false)]
    protected void addOfferIdToTmpOrderDataList(str _offerId, Set _offerIdLookup)
    {
        if (!_offerIdLookup.in(_offerId))
        {
            mTmpOrderData.clear();
            mTmpOrderData.dataType = RetailTmpOrderDataType::OfferId;
            mTmpOrderData.dataValue = _offerId;
            tmpOrderDataInsertList.add(mTmpOrderData);

            _offerIdLookup.add(_offerId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addOfferIdToTmpOrderDataListInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// It's a facade of addOfferIdToTmpOrderDataList, for testing purpose only.
    /// </summary>
    /// <param name = "_offerId">The offer id.</param>
    /// <param name = "_offerIdLookup">The offer id lookup.</param>
    internal void addOfferIdToTmpOrderDataListInternal(str _offerId, Set _offerIdLookup)
    {
        this.addOfferIdToTmpOrderDataList(_offerId, _offerIdLookup);
        tmpOrderDataInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ReadRetailDiscountsForCategories</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets collection of RetailPeriodicDiscountCategoryCache which contain all applicable discount lines in given discount for the collection of category RecIds.
    /// </summary>
    /// <param name = "_periodicDiscount">Discount.</param>
    /// <param name = "_categoriesRecId">Collection of category RecIds.</param>
    /// <returns>Collection of RetailPeriodicDiscountCategoryCache which contain all applicable discount lines in given discount for the collection of category RecIds.</returns>
    private List ReadRetailDiscountsForCategories(RetailPeriodicDiscount _periodicDiscount, container _categoriesRecId)
    {
        List categoryDiscounts = new List(Types::Class);

        for (int i = 1; i <= conLen(_categoriesRecId); i++)
        {
            using(var t = RetailInstrumentationSegment::construct(RetailInstrumentationSegmentArea, funcName()))
            {
                RecId categoryRecId = conpeek(_categoriesRecId, i);

                var categoryDiscount = RetailPricingCacheManager::readRetailDiscountForCategory(_periodicDiscount, categoryRecId);
                if (categoryDiscount)
                {
                    categoryDiscounts.addEnd(categoryDiscount);
                }
            }
        }

        return categoryDiscounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetThresholdTiersByOfferIds</Name>
				<Source><![CDATA[
    public System.Object GetThresholdTiersByOfferIds(System.Object offerIds)
    {
        RetailDiscountThresholdTiers retailThresholdTier;
        UserId userId = curUserId();

        CLRObject crtThresholdTierList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.ThresholdDiscountTier());

        while select dataValue from mTmpOrderData
                where mTmpOrderData.dataType == RetailTmpOrderDataType::OfferId
            join retailThresholdTier
                group by retailThresholdTier.OfferId, retailThresholdTier.AmountThreshold, retailThresholdTier.DiscountMethod, retailThresholdTier.DiscountValue, retailThresholdTier.RecId
                where retailThresholdTier.OfferId == mTmpOrderData.dataValue
        {
            crtThresholdTierList.Add(this.ConvertToThresholdDiscountTier(retailThresholdTier));
        }

        return crtThresholdTierList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetVariantDimensionsByInventDimensionIds</Name>
				<Source><![CDATA[
    public System.Object GetVariantDimensionsByInventDimensionIds(System.Object inventoryDimensionIds)
    {
        InventDim inventDim;

        PriceDiscTableItemAccountRelationTmp dimTmp = this.getTmpAccountRelations(inventoryDimensionIds);

        CLRObject crtDimensionList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.ProductVariant());

        while select RecId, inventDimId, inventColorId, inventSizeId, inventStyleId, inventVersionId, configId from inventDim
            join dimTmp where inventDim.inventDimId == dimTmp.AccountItemRelation
        {
            crtDimensionList.Add(this.ConvertInventDimToProductVariant(inventDim));
        }

        return crtDimensionList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetVariants</Name>
				<Source><![CDATA[
    public System.Object GetVariants(System.Object itemVariants)
    {
        InventDimCombination inventDimCombination;
        InventDim inventDim;
        UserId userId = curUserId();
        RetailVariantId  checkRetailVariantId;

        CLRObject crtProductVariantList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.ProductVariant());

        while select itemId, retailVariantId
                from mTmpOrderItem
                order by retailVariantId
                where mTmpOrderItem.retailVariantId
                join ItemId, InventDimId, RetailVariantId, DistinctProductVariant, RecId
                    from inventDimCombination
                    where mTmpOrderItem.ItemId == inventDimCombination.ItemId
                            && mTmpOrderItem.InventDimId == inventDimCombination.InventDimId
                join InventSizeId, InventColorId, InventStyleId, InventVersionId, configId, InventDimId
                    from inventDim
                    where inventDim.InventDimId == mTmpOrderItem.InventDimId
        {
            // avoid add duplicate variant to crtProductVariantList
            if (mTmpOrderItem.retailVariantId != checkRetailVariantId)
            {
                crtProductVariantList.Add(this.ConvertToProductVariant(inventDimCombination, inventDim));
                checkRetailVariantId = mTmpOrderItem.retailVariantId;
            }
        }

        return crtProductVariantList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetAllRetailDiscounts</Name>
				<Source><![CDATA[
    public System.Object GetAllRetailDiscounts()
    {
        throw error(Error::missingOverride(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCLRSetOfString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets CLR set of string.
    /// </summary>
    /// <returns>Empty CLR set of string.</returns>
    public System.Object getCLRSetOfString()
    {
        return Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.TypeHelperForAx::CreateSetOfString();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCLRSetOfLong</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets CLR set of long.
    /// </summary>
    /// <returns>Emtpy CLR set of long.</returns>
    public System.Object getCLRSetOfLong()
    {
        return Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.TypeHelperForAx::CreateSetOfLong();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCLRList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates CLR list of passed object.
    /// </summary>
    /// <param name = "baseObject">Base object in the list.</param>
    /// <returns>Empty CLR list.</returns>
    public System.Object createCLRList(System.Object baseObject)
    {
        System.Type baseType = baseObject.GetType();
        System.Object crtList = Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.TypeHelperForAx::CreateListOfType(baseType);

        return crtList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToPriceParameters</Name>
				<Source><![CDATA[
    private Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceParameters ConvertToPriceParameters(PriceParameters priceParameters)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceParameters crtPriceParameters = new Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceParameters();

        crtPriceParameters.RecordId = priceParameters.RecId;
        crtPriceParameters.ApplyPriceForCustomerAndItem = priceParameters.SalesPriceAccountItem;
        crtPriceParameters.ApplyPriceForCustomerGroupAndItem = priceParameters.SalesPriceGroupItem;
        crtPriceParameters.ApplyPriceForAllCustomersAndItem = priceParameters.SalesPriceAllItem;
        crtPriceParameters.ApplyLineDiscountForCustomerAndItem = priceParameters.SalesLineAccountItem;
        crtPriceParameters.ApplyLineDiscountForCustomerAndItemGroup = priceParameters.SalesLineAccountGroup;
        crtPriceParameters.ApplyLineDiscountForCustomerAndAllItems = priceParameters.SalesLineAccountAll;
        crtPriceParameters.ApplyLineDiscountForCustomerGroupAndItem = priceParameters.SalesLineGroupItem;
        crtPriceParameters.ApplyLineDiscountForCustomerGroupAndItemGroup = priceParameters.SalesLineGroupGroup;
        crtPriceParameters.ApplyLineDiscountForCustomerGroupAndAllItems = priceParameters.SalesLineGroupAll;
        crtPriceParameters.ApplyLineDiscountForAllCustomersAndItem = priceParameters.SalesLineAllItem;
        crtPriceParameters.ApplyLineDiscountForAllCustomersAndItemGroup = priceParameters.SalesLineAllGroup;
        crtPriceParameters.ApplyLineDiscountForAllCustomersAndAllItems = priceParameters.SalesLineAllAll;
        crtPriceParameters.ApplyMultilineDiscountForCustomerAndItemGroup = priceParameters.SalesMultiLnAccountGroup;
        crtPriceParameters.ApplyMultilineDiscountForCustomerAndAllItems = priceParameters.SalesMultiLnAccountAll;
        crtPriceParameters.ApplyMultilineDiscountForCustomerGroupAndItemGroup = priceParameters.SalesMultiLnGroupGroup;
        crtPriceParameters.ApplyMultilineDiscountForCustomerGroupAndAllItems = priceParameters.SalesMultiLnGroupAll;
        crtPriceParameters.ApplyMultilineDiscountForAllCustomersAndItemGroup = priceParameters.SalesMultiLnAllGroup;
        crtPriceParameters.ApplyMultilineDiscountForAllCustomersAndAllItems = priceParameters.SalesMultiLnAllAll;
        crtPriceParameters.ApplyTotalDiscountForCustomerAndAllItems = priceParameters.SalesEndAccountAll;
        crtPriceParameters.ApplyTotalDiscountForCustomerGroupAndAllItems = priceParameters.SalesEndGroupAll;
        crtPriceParameters.ApplyTotalDiscountForAllCustomersAndAllItems = priceParameters.SalesEndAllAll;

        return crtPriceParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToDiscountCode</Name>
				<Source><![CDATA[
    private Microsoft.Dynamics.Commerce.Runtime.DataModel.DiscountCode ConvertToDiscountCode(RetailDiscountCode retailDiscountCode)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.DiscountCode crtDiscountCode = new Microsoft.Dynamics.Commerce.Runtime.DataModel.DiscountCode();

        crtDiscountCode.Code = retailDiscountCode.DiscountCode;
        crtDiscountCode.Barcode = retailDiscountCode.BarCode;
        crtDiscountCode.RecordId = retailDiscountCode.RecId;
        crtDiscountCode.OfferId = retailDiscountCode.DiscountOfferId;

        return crtDiscountCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToItem</Name>
				<Source><![CDATA[
    private Microsoft.Dynamics.Commerce.Runtime.DataModel.Item ConvertToItem(
        InventTable inventTable,
        InventTableModule inventTableModule,
        RetailInventTable retailInventTable)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.Item crtItem = new Microsoft.Dynamics.Commerce.Runtime.DataModel.Item();
        crtItem.ItemId = inventTable.ItemId;
        crtItem.BasePrice = inventTableModule.Price;
        crtItem.Product = inventTable.Product;
        crtItem.ChargeGroup = inventTableModule.MarkupGroupId;
        crtItem.Markup = inventTableModule.Markup;
        crtItem.PriceQuantity = inventTableModule.priceQty;
        crtItem.AllocateMarkup = inventTableModule.AllocateMarkup;
        crtItem.LineDiscountGroupId = inventTableModule.LineDisc;
        crtItem.MultilineDiscountGroupId = inventTableModule.MultiLineDisc;
        crtItem.IsTotalDiscountAllowed = inventTableModule.EndDisc;
        crtItem.NoDiscountAllowed = retailInventTable.noDiscountAllowed;
        crtItem.NoManualDiscountAllowed = retailInventTable.noManualDiscountAllowed;
        crtItem.NoTenderDiscountAllowed = retailInventTable.noTenderDiscountsAllowed;
        crtItem.NoPeriodicDiscountAllowed = retailInventTable.noPeriodicDiscountAllowed;
        crtItem.ItemTaxGroupId = inventTableModule.TaxItemGroupId;
        crtItem.InventoryUnitOfMeasure = inventTableModule.UnitId;
        RetailPricingEngineHelper::setRealPropertyIfExistsInClass(crtItem, 'PriceUnit', inventTableModule.PriceUnit);

        return crtItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToTradeAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts <c>PriceDiscTable</c> record to CRT TradeAgreement
    /// </summary>
    /// <param name = "priceDisc">The <c>PriceDiscTable</c> record.</param>
    /// <param name = "inventDim">The <c>InventDim</c> record.</param>
    /// <returns>The CRT TradeAgreement object.</returns>
    [Hookable(true), Wrappable(true)]
    protected Microsoft.Dynamics.Commerce.Runtime.DataModel.TradeAgreement ConvertToTradeAgreement(PriceDiscTable priceDisc, InventDim inventDim)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.TradeAgreement crtTradeAgreement = new Microsoft.Dynamics.Commerce.Runtime.DataModel.TradeAgreement();

        crtTradeAgreement.RecordId = priceDisc.RecId;
        crtTradeAgreement.ItemCode = enum2int(priceDisc.ItemCode);
        crtTradeAgreement.AccountCode = enum2int(priceDisc.AccountCode);
        crtTradeAgreement.ItemRelation = priceDisc.ItemRelation;
        crtTradeAgreement.AccountRelation = priceDisc.AccountRelation;
        crtTradeAgreement.QuantityAmountFrom = priceDisc.QuantityAmountFrom;
        crtTradeAgreement.QuantityAmountTo = priceDisc.QuantityAmountTo;
        crtTradeAgreement.FromDate = this.ConvertDateToSystemDateTimeOffset(priceDisc.FromDate);
        crtTradeAgreement.ToDate = this.ConvertDateToSystemDateTimeOffset(priceDisc.ToDate);
        crtTradeAgreement.Amount = priceDisc.Amount;
        crtTradeAgreement.Currency = priceDisc.Currency;
        crtTradeAgreement.PercentOne = priceDisc.Percent1;
        crtTradeAgreement.PercentTwo = priceDisc.Percent2;
        crtTradeAgreement.ShouldSearchAgain = priceDisc.SearchAgain;
        crtTradeAgreement.PriceUnit = priceDisc.PriceUnit;
        crtTradeAgreement.Relation = enum2int(priceDisc.relation);
        crtTradeAgreement.UnitOfMeasureSymbol = priceDisc.UnitId;
        crtTradeAgreement.MarkupAmount = priceDisc.Markup;
        crtTradeAgreement.InventoryDimensionId = priceDisc.InventDimId;
        crtTradeAgreement.ConfigId = inventDim.configId;
        crtTradeAgreement.ColorId = inventDim.InventColorId;
        crtTradeAgreement.SizeId = inventDim.InventSizeId;
        crtTradeAgreement.StyleId = inventDim.InventStyleId;
        crtTradeAgreement.SiteId = inventDim.InventSiteId;
        crtTradeAgreement.WarehouseId = inventDim.InventLocationId;
        crtTradeAgreement.SerialNumber = inventDim.InventSerialId;

        return crtTradeAgreement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToPriceAdjustmentV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a RetailPeriodicDiscount record into Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceAdjustment type object.
    /// </summary>
    /// <param name = "discount">A record from RetailPeriodicDiscount table.</param>
    /// <param name = "discountLineOffer">A record from RetailDiscountLineOffer table.</param>
    /// <param name = "itemId">Item Id.</param>
    /// <param name = "inventDimId">Inventory dimension Id.</param>
    /// <param name = "unitOfMeasure">A record from UnitOfMeasure table.</param>
    /// <returns>Returns a Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceAdjustment type object.</returns>
    protected Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceAdjustment ConvertToPriceAdjustmentV2(
            RetailPeriodicDiscount discount,
            RetailDiscountLineOffer discountLineOffer,
            ItemId itemId,
            InventDimId inventDimId,
            UnitOfMeasure unitOfMeasure)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceAdjustment crtAdjustment = new Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceAdjustment();

        crtAdjustment.OfferId = discount.OfferId;
        crtAdjustment.ValidFromDate = this.ConvertDateToSystemDateTimeOffset(discount.ValidFrom);
        crtAdjustment.ValidToDate = this.ConvertDateToSystemDateTimeOffset(discount.ValidTo);
        crtAdjustment.ConcurrencyMode = enum2int(discount.ConcurrencyMode);
        crtAdjustment.PricingPriorityNumber = discount.PricingPriorityNumber;
        crtAdjustment.DateValidationType = discount.DateValidationType;
        crtAdjustment.ValidationPeriodId = discount.ValidationPeriodId;
        crtAdjustment.DiscountMethod = enum2int(discountLineOffer.discountMethod);
        crtAdjustment.OfferPrice = discountLineOffer.offerPrice;
        crtAdjustment.DiscountPercent = discountLineOffer.discPct;
        crtAdjustment.DiscountAmount = discountLineOffer.discAmount;
        crtAdjustment.RecordId = discountLineOffer.RecId;
        crtAdjustment.ItemId = itemId;
        crtAdjustment.InventoryDimensionId = inventDimId;
        crtAdjustment.UnitOfMeasure = unitOfMeasure.Symbol;
        crtAdjustment.CurrencyCode = discount.CurrencyCode;

        return crtAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToCrtPeriodicDiscountV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a PeriodicDiscount record into Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount object.
    /// </summary>
    /// <param name = "periodicDiscount">A record from RetailPeriodicDiscount table.</param>
    /// <param name = "periodicDiscountLine">A record from RetailPeriodicDiscountLine table.</param>
    /// <param name = "unitOfMeasure">A record from UnitOfMeasure table.</param>
    /// <param name = "discountType">Discount type of mix and match and mutibuy discounts.</param>
    /// <param name = "itemId">Item Id.</param>
    /// <param name = "inventDimId">Inventory dimension Id.</param>
    /// <returns>Returns Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount type object.</returns>
    [Hookable(true)]
    protected Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount ConvertToCrtPeriodicDiscountV2(
        RetailPeriodicDiscount periodicDiscount,
        RetailPeriodicDiscountLine periodicDiscountLine,
        UnitOfMeasure unitOfMeasure,
        int discountType,
        ItemId itemId,
        InventDimId inventDimId)
    {
        RetailExtensibleEnumerationInitializer::setExtensibleEnumInitializer(funcName());

        Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount crtDiscount = this.constructCRTPeriodicDiscount();

        RetailDiscountOffer discountOffer;
        RetailDiscountMixAndMatch discountMixAndMatch;
        RetailDiscountMultibuy discountMultibuy;
        RetailDiscountThreshold discountThreshold;
        RetailDiscountLineOffer discountLineOffer;
        RetailDiscountLineMixAndMatch discountLineMixAndMatch;
        RetailDiscountLineThresholdApplying discountLineThresholdApplying;

        try
        {
            switch (periodicDiscount.PeriodicDiscountType)
            {
                case RetailDiscountOfferTypeBase::DiscountOffer:
                case RetailDiscountOfferTypeBase::DiscountOfferLineQuantityLimit:
                    discountOffer = periodicDiscount;
                    discountLineOffer = periodicDiscountLine;
                    break;
                case RetailDiscountOfferTypeBase::MixAndMatch:
                case RetailDiscountOfferTypeBase::LeastExpensiveFavorRetailer:
                    discountLineMixAndMatch = periodicDiscountLine;
                    discountMixAndMatch = periodicDiscount;
                    discountType = discountMixAndMatch.MixAndMatchDiscountType;
                    break;
                case RetailDiscountOfferTypeBase::Multibuy:
                    discountMultibuy = periodicDiscount;
                    discountType = discountMultibuy.MultibuyDiscountType;
                    break;
                case RetailDiscountOfferTypeBase::Threshold:
                    discountThreshold = periodicDiscount;
                    if(periodicDiscountLine.IsDiscountApplyingLine == NoYes::Yes)
                    {
                        discountLineThresholdApplying = periodicDiscountLine;

                        eventSource.EventWriteFeatureUsed(
                            'ThresholdDiscountWithGiftPurchaseFeature',
                            classStr(RetailPricingDataManager),
                            methodStr(RetailPricingDataManager, ConvertToCrtPeriodicDiscountV2),
                            '');
                    }
                    break;
                default:
                    break;
            }
        }
        catch (Exception::CLRError)
        {
            error(strFmt(
                "@RetailPricing:DiscountLineInvalidCast",
                periodicDiscountLine.LineNum,
                periodicDiscountLine.OfferId,
                periodicDiscount.PeriodicDiscountType));
            System.Exception ex = CLRInterop::getLastException().get_InnerException();
            throw ex;
        }

        crtDiscount.RecordId = periodicDiscountLine.RecId;
        crtDiscount.OfferId = periodicDiscount.OfferId;
        crtDiscount.ValidFromDate = this.ConvertDateToSystemDateTimeOffset(periodicDiscount.ValidFrom);
        crtDiscount.ValidToDate = this.ConvertDateToSystemDateTimeOffset(periodicDiscount.ValidTo);
        crtDiscount.ConcurrencyMode = enum2int(periodicDiscount.ConcurrencyMode);
        crtDiscount.PricingPriorityNumber = periodicDiscount.PricingPriorityNumber;
        crtDiscount.DateValidationType = periodicDiscount.DateValidationType;
        crtDiscount.ValidationPeriodId = periodicDiscount.ValidationPeriodId;
        crtDiscount.DiscountMethod = discountLineOffer.discountMethod;
        crtDiscount.OfferPrice = discountLineOffer.offerPrice;
        crtDiscount.DiscountPercent = discountLineOffer.discPct;
        crtDiscount.DiscountAmount = discountLineOffer.discAmount;
        crtDiscount.Name = periodicDiscount.Name;
        crtDiscount.ExtensiblePeriodicDiscountType = Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.TypeHelperForAx::GetExtensiblePeriodicDiscountOfferTypeByValue(enum2int(periodicDiscount.PeriodicDiscountType));
        crtDiscount.IsDiscountCodeRequired = periodicDiscount.IsDiscountCodeRequired;
        crtDiscount.DiscountType = discountType;
        crtDiscount.MixAndMatchDealPrice = discountMixAndMatch.DealPriceValue;
        crtDiscount.MixAndMatchDiscountPercent = periodicDiscount.DiscountPercentValue;
        crtDiscount.MixAndMatchDiscountAmount = discountMixAndMatch.DiscountAmountValue;
        crtDiscount.MixAndMatchNumberOfLeastExpensiveLines = discountMixAndMatch.NoOfLeastExpensiveLines;
        crtDiscount.MixAndMatchNumberOfTimeApplicable = discountMixAndMatch.numberOfTimesApplicable;
        crtDiscount.LeastExpensiveMode = enum2int(discountMixAndMatch.LeastExpensiveMode);
        crtDiscount.DiscountLineNumber = periodicDiscountLine.LineNum;
        crtDiscount.DiscountLinePercentOrValue = periodicDiscountLine.DiscountPercentOrValue;
        crtDiscount.MixAndMatchLineGroup = discountLineMixAndMatch.lineGroup;
        crtDiscount.MixAndMatchLineSpecificDiscountType = discountLineMixAndMatch.discountType;
        crtDiscount.MixAndMatchShouldCountNonDiscountItems = discountMixAndMatch.MixAndMatchCountNonDiscountItems;
        crtDiscount.MixAndMatchLineNumberOfItemsNeeded = discountLineMixAndMatch.numberOfItemsNeeded;
        crtDiscount.UnitOfMeasureSymbol = unitOfMeasure.Symbol;
        crtDiscount.ShouldCountNonDiscountItems = discountThreshold.CountNonDiscountItems;
        crtDiscount.ItemId = itemId;
        crtDiscount.InventoryDimensionId = inventDimId;
        crtDiscount.CurrencyCode = periodicDiscount.CurrencyCode;
        crtDiscount.MixAndMatchGeneratesBundleId = discountMixAndMatch.GeneratesBundleId;
        crtDiscount.OfferQuantityLimit = discountOffer.QuantityLimit;
        crtDiscount.LineType = enum2int(periodicDiscountLine.LineType);

        crtDiscount.IsDiscountApplyingLine = discountLineThresholdApplying.IsDiscountApplyingLine;
        crtDiscount.ThresholdApplyingLineQuantityLimit = discountLineThresholdApplying.QuantityLimit;
        crtDiscount.ThresholdApplyingLineDiscountMethod = enum2int(discountLineThresholdApplying.ThresholdLineDiscountMethod);
        crtDiscount.ThresholdApplyingLineTierId = discountLineThresholdApplying.Tier;

        return crtDiscount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructCRTPeriodicDiscount</Name>
				<Source><![CDATA[
    protected Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount constructCRTPeriodicDiscount()
    {
        return new Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertInventDimToProductVariant</Name>
				<Source><![CDATA[
    private Microsoft.Dynamics.Commerce.Runtime.DataModel.ProductVariant ConvertInventDimToProductVariant(InventDim inventDim)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.ProductVariant crtProductVariant = new Microsoft.Dynamics.Commerce.Runtime.DataModel.ProductVariant();

        this.FillProductVariantFromInventDim(crtProductVariant, InventDim);

        return crtProductVariant;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToProductVariant</Name>
				<Source><![CDATA[
    private Microsoft.Dynamics.Commerce.Runtime.DataModel.ProductVariant ConvertToProductVariant(InventDimCombination inventDimCombo, InventDim inventDim)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.ProductVariant crtProductVariant = new Microsoft.Dynamics.Commerce.Runtime.DataModel.ProductVariant();

        this.FillProductVariantFromInventDim(crtProductVariant, InventDim);
        crtProductVariant.ItemId = inventDimCombo.ItemId;
        crtProductVariant.VariantId = inventDimCombo.RetailVariantId;
        crtProductVariant.DistinctProductVariantId = inventDimCombo.DistinctProductVariant;

        crtProductVariant.Size = crtProductVariant.SizeId;
        crtProductVariant.Color = crtProductVariant.ColorId;
        crtProductVariant.Style = crtProductVariant.StyleId;
        crtProductVariant.Configuration = crtProductVariant.ConfigId;

        return crtProductVariant;
    }

]]></Source>
			</Method>
			<Method>
				<Name>FillProductVariantFromInventDim</Name>
				<Source><![CDATA[
    private void FillProductVariantFromInventDim(Microsoft.Dynamics.Commerce.Runtime.DataModel.ProductVariant crtProductVariant, InventDim inventDim)
    {
        crtProductVariant.InventoryDimensionId = inventDim.InventDimId;
        crtProductVariant.ColorId = inventDim.InventColorId;
        crtProductVariant.SizeId = inventDim.InventSizeId;
        crtProductVariant.StyleId = inventDim.InventStyleId;
        crtProductVariant.ConfigId = inventDim.configId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToThresholdDiscountTier</Name>
				<Source><![CDATA[
    private Microsoft.Dynamics.Commerce.Runtime.DataModel.ThresholdDiscountTier ConvertToThresholdDiscountTier(RetailDiscountThresholdTiers retailThresholdTier)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.ThresholdDiscountTier crtThresholdTier = new Microsoft.Dynamics.Commerce.Runtime.DataModel.ThresholdDiscountTier();

        crtThresholdTier.OfferId = retailThresholdTier.OfferId;
        crtThresholdTier.AmountThreshold = retailThresholdTier.AmountThreshold;
        crtThresholdTier.DiscountMethod = enum2int(retailThresholdTier.DiscountMethod);
        crtThresholdTier.DiscountValue = retailThresholdTier.DiscountValue;
        crtThresholdTier.RecordId = retailThresholdTier.RecId;

        return crtThresholdTier;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToQuantityDiscountLevel</Name>
				<Source><![CDATA[
    private Microsoft.Dynamics.Commerce.Runtime.DataModel.QuantityDiscountLevel ConvertToQuantityDiscountLevel(RetailMultibuyDiscountLine multibuyTier)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.QuantityDiscountLevel crtQuantityTier = new Microsoft.Dynamics.Commerce.Runtime.DataModel.QuantityDiscountLevel();

        crtQuantityTier.RecordId = multibuyTier.RecId;
        crtQuantityTier.OfferId = multibuyTier.multibuyId;
        crtQuantityTier.DiscountPriceOrPercent = multibuyTier.PriceDiscPct;
        crtQuantityTier.MinimumQuantity = multibuyTier.QtyLowest;

        return crtQuantityTier;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToMixAndMatchLineGroup</Name>
				<Source><![CDATA[
    private Microsoft.Dynamics.Commerce.Runtime.DataModel.MixAndMatchLineGroup ConvertToMixAndMatchLineGroup(RetailMixAndMatchLineGroups mixMatchLineGroup)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.MixAndMatchLineGroup crtMixMatchLineGroup = new Microsoft.Dynamics.Commerce.Runtime.DataModel.MixAndMatchLineGroup();

        crtMixMatchLineGroup.RecordId = mixMatchLineGroup.RecId;
        crtMixMatchLineGroup.OfferId = mixMatchLineGroup.mixAndMatchId;
        crtMixMatchLineGroup.LineGroup = mixMatchLineGroup.mixAndMatchLineGroup;
        crtMixMatchLineGroup.NumberOfItemsNeeded = mixMatchLineGroup.numberOfItemsNeeded;

        return crtMixMatchLineGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToPriceGroup</Name>
				<Source><![CDATA[
    private Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceGroup ConvertToPriceGroup(PriceDiscGroup priceDiscGroup)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceGroup crtPriceGroup = new Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceGroup();
        this.FillPriceGroup(crtPriceGroup, priceDiscGroup);

        return crtPriceGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToCatalogPriceGroup</Name>
				<Source><![CDATA[
    private Microsoft.Dynamics.Commerce.Runtime.DataModel.CatalogPriceGroup ConvertToCatalogPriceGroup(PriceDiscGroup priceDiscGroup, RetailCatalogPriceGroup catalogPriceGroup)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.CatalogPriceGroup crtCatalogPriceGroup = new Microsoft.Dynamics.Commerce.Runtime.DataModel.CatalogPriceGroup();

        this.FillPriceGroup(crtCatalogPriceGroup, priceDiscGroup);
        crtCatalogPriceGroup.CatalogId = catalogPriceGroup.Catalog;

        return crtCatalogPriceGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToRetailDiscountPriceGroup</Name>
				<Source><![CDATA[
    private Microsoft.Dynamics.Commerce.Runtime.DataModel.RetailDiscountPriceGroup ConvertToRetailDiscountPriceGroup(PriceDiscGroup priceDiscGroup, RetailDiscountPriceGroup discountPriceGroup)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.RetailDiscountPriceGroup crtDiscountPriceGroup = new Microsoft.Dynamics.Commerce.Runtime.DataModel.RetailDiscountPriceGroup();

        this.FillPriceGroup(crtDiscountPriceGroup, priceDiscGroup);
        crtDiscountPriceGroup.OfferId = discountPriceGroup.OfferId;

        return crtDiscountPriceGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>FillPriceGroup</Name>
				<Source><![CDATA[
    private void FillPriceGroup(Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceGroup crtPriceGroup, PriceDiscGroup priceDiscGroup)
    {
        crtPriceGroup.RecordId = priceDiscGroup.RecId;
        crtPriceGroup.GroupId = priceDiscGroup.GroupId;
        crtPriceGroup.PriceGroupId = priceDiscGroup.RecId;
        crtPriceGroup.PricingPriorityNumber = priceDiscGroup.RetailPricingPriorityNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToRetailCategoryMember</Name>
				<Source><![CDATA[
    private Microsoft.Dynamics.Commerce.Runtime.DataModel.RetailCategoryMember ConvertToRetailCategoryMember(
        RetailProductAndVariantCategory productCategory,
        RetailCategoryContainmentLookup categoryContainment)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.RetailCategoryMember crtRetailCategoryMember = new Microsoft.Dynamics.Commerce.Runtime.DataModel.RetailCategoryMember();

        crtRetailCategoryMember.ProductOrVariantId = productCategory.Product;
        crtRetailCategoryMember.CategoryId = categoryContainment.Category;

        return crtRetailCategoryMember;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToSalesAgreementLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the retrieved sales agreement record to CRT SalesAgreementLine.
    /// </summary>
    /// <param name = "_agreementHeader">The sales agreement header.</param>
    /// <param name = "_agreementLine">The sales agreement line.</param>
    /// <param name = "_agreementLineDefault">The sales agreement line default settings.</param>
    /// <param name = "_inventDim">The invent dimension.</param>
    /// <returns>The CRT SalesAgreementLine object.</returns>
    private Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesAgreementLine ConvertToSalesAgreementLine(SalesAgreementHeader _agreementHeader, AgreementLine _agreementLine, AgreementLineDefault _agreementLineDefault, InventDim _inventDim)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesAgreementLine crtSalesAgreementLine = new Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesAgreementLine();

        // Base line.
        crtSalesAgreementLine.RecordId = _agreementLine.RecId;
        crtSalesAgreementLine.ItemId = _agreementLine.ItemId;
        crtSalesAgreementLine.LineType = enum2int(_agreementLine.AgreementLineType);
        crtSalesAgreementLine.EffectiveDate = this.ConvertDateToSystemDateTimeOffset(_agreementLine.EffectiveDate);
        crtSalesAgreementLine.ExpirationDate = this.ConvertDateToSystemDateTimeOffset(_agreementLine.ExpirationDate);
        crtSalesAgreementLine.IsMaxCommittedValueEnforced = _agreementLine.IsMaxEnforced;
        crtSalesAgreementLine.IsPriceAndDiscountFixed = _agreementLine.IsPriceInformationMandatory;
        crtSalesAgreementLine.LineDiscountPercent = _agreementLine.LineDiscountPercent;
        crtSalesAgreementLine.MaximumReleaseAmount = _agreementLine.AgreedReleaseLineMaxAmount;
        crtSalesAgreementLine.MinimumReleaseAmount = _agreementLine.AgreedReleaseLineMinAmount;

        // Special line type.
        if (_agreementLine.AgreementLineType == CommitmentType::ProductQuantity)
        {
            AgreementLineQuantityCommitment quantityLine = (_agreementLine as AgreementLineQuantityCommitment);
            crtSalesAgreementLine.CommittedQuantity = quantityLine.CommitedQuantity;
            crtSalesAgreementLine.LineDiscountAmount = quantityLine.LineDiscountAmount;
            crtSalesAgreementLine.PricePerUnit = quantityLine.PricePerUnit;
            crtSalesAgreementLine.PriceUnit = quantityLine.PriceUnit;
            crtSalesAgreementLine.UnitOfMeasure = quantityLine.ProductUnitOfMeasure;
        }
        else if (_agreementLine.AgreementLineType == CommitmentType::ProductVolume)
        {
            AgreementLineVolumeCommitment volumeLine = (_agreementLine as AgreementLineVolumeCommitment);
            crtSalesAgreementLine.CommittedAmount = volumeLine.CommitedAmount;
        }

        // Header level information.
        crtSalesAgreementLine.SalesAgreementRecordId = _agreementHeader.RecId;
        crtSalesAgreementLine.DocumentTitle = _agreementHeader.DocumentTitle;
        crtSalesAgreementLine.SalesAgreementId = _agreementHeader.SalesNumberSequence;
        crtSalesAgreementLine.CustomerAccount = _agreementHeader.CustAccount;

        // InventDim
        crtSalesAgreementLine.ColorId = _inventDim.InventColorId;
        crtSalesAgreementLine.SizeId = _inventDim.inventSizeId;
        crtSalesAgreementLine.StyleId = _inventDim.InventStyleId;
        crtSalesAgreementLine.ConfigurationId = _inventDim.configId;
        crtSalesAgreementLine.SiteId = _inventDim.InventSiteId;
        crtSalesAgreementLine.WarehouseId = _inventDim.InventLocationId;

        // Line default.
        crtSalesAgreementLine.DeliveryMode = _agreementLineDefault.SalesModeOfDelivery;

        // Get latest remaining quantity/amount.
        if (_agreementLine.IsMaxEnforced)
        {
            #AgreementsRemains

            container lineFulfillment = _agreementLine.calculateAgreementRemansOnServer();

            if (_agreementLine.AgreementLineType == CommitmentType::ProductQuantity)
            {
                AgreementLineQuantityCommitment agreementLineQuantity = _agreementLine;
                crtSalesAgreementLine.RemainingQuantity = conPeek(lineFulfillment, #RemainingIndex);
            }
            else
            {
                AgreementLineVolumeCommitment agreementLineVolume = _agreementLine;
                crtSalesAgreementLine.RemainingAmount = conPeek(lineFulfillment, #RemainingIndex);
            }

        }

        return crtSalesAgreementLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertDateToSystemDateTimeOffset</Name>
				<Source><![CDATA[
    protected System.DateTimeOffset ConvertDateToSystemDateTimeOffset(date localDate)
    {
        System.TimeZoneInfo timeZoneInfo;
        if (mPriceChannelConfiguration.ChannelTimeZoneId)
        {
            timeZoneInfo = System.TimeZoneInfo::FindSystemTimeZoneById(mPriceChannelConfiguration.ChannelTimeZoneId);
        }
        else
        {
            // Get the company timezone
            DataArea dataArea;
            select firstonly TimeZone from dataArea where dataArea.Id == curExt();
            timeZoneInfo = System.TimeZoneInfo::FindSystemTimeZoneById(DateTimeUtil::getTimeZoneId(dataArea.timeZone));
        }
        return new System.DateTimeOffset(year(localDate), mthofyr(localDate), dayofmth(localDate), 0, 0, 0, timeZoneInfo.BaseUtcOffset);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTmpAccountRelations</Name>
				<Source><![CDATA[
    private PriceDiscTableItemAccountRelationTmp getTmpAccountRelations(System.Object _list)
    {
        PriceDiscTableItemAccountRelationTmp tmpOfferIds;
        CLRObject crtList = _list;
        CLRObject clrEn = crtList.GetEnumerator();

        if (RetailPricingCalcBulkInsertTempTableFlight::instance().isEnabled())
        {
            RecordInsertList recordInsertList = new RecordInsertList(tableNum(PriceDiscTableItemAccountRelationTmp), true, true, true, true, true, tmpOfferIds);
            while (clrEn.MoveNext())
            {
                tmpOfferIds.clear();
                tmpOfferIds.AccountItemRelation = clrEn.get_Current();
                recordInsertList.add(tmpOfferIds);
            }
            recordInsertList.insertDatabase();
        }
        else
        {
            while (clrEn.MoveNext())
            {
                tmpOfferIds.AccountItemRelation = clrEn.get_Current();
                tmpOfferIds.doInsert();
            }
        }

        return tmpOfferIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailTmpRecId</Name>
				<Source><![CDATA[
    private RetailTmpRecId getRetailTmpRecId(System.Object recordIds)
    {
        RetailTmpRecId tmpRecIds;

        RefRecId recId;
        CLRObject crtList = recordIds;
        CLRObject clrEn = crtList.GetEnumerator();
        while (clrEn.MoveNext())
        {
            tmpRecIds.ReferenceRecId = clrEn.get_Current();
            tmpRecIds.doInsert();
        }

        return tmpRecIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTmpPriceGroupTableFromGroupIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts price groups object into TmpRecIdFilter table's records.
    /// </summary>
    /// <param name = "priceGroups">CLR price groups object.</param>
    /// <returns>Returns TmpRecIdFilter table's records.</returns>
    protected TmpRecIdFilter getTmpPriceGroupTableFromGroupIds(System.Object priceGroups)
    {
        TmpRecIdFilter priceDiscGroupTmp;

        using(var instrumentationSegment = RetailInstrumentationSegment::construct(RetailInstrumentationSegmentArea, funcName()))
        {
            RecordInsertList recordInsertList;
            if (RetailPricingCalcBulkInsertTempTableFlight::instance().isEnabled())
            {
                recordInsertList = new RecordInsertList(
                    tableNum(TmpRecIdFilter),
                    true, // skip insert
                    true, // skip database log
                    true, // skip events
                    true, // skip aos validation
                    true, // skip RLS validation
                    priceDiscGroupTmp); // buffer where records will be inserted
            }
            else
            {
                recordInsertList = new RecordInsertList(
                    tableNum(TmpRecIdFilter),
                    false, // skip insert
                    false, // skip database log
                    false, // skip events
                    false, // skip aos validation
                    false, // skip RLS validation
                    priceDiscGroupTmp); // buffer where records will be inserted
            }

            CLRObject crtList = priceGroups;
            CLRObject clrEn = crtList.GetEnumerator();
            while (clrEn.MoveNext())
            {
                PriceGroupId groupId = clrEn.get_Current();
                PriceDiscGroup priceDiscGroup = PriceDiscGroup::find(ModuleInventCustVend::Cust, PriceGroupType::PriceGroup, groupId);
                priceDiscGroupTmp.RefRecId = priceDiscGroup.RecId;
                recordInsertList.add(priceDiscGroupTmp);
            }

            int rowCount = recordInsertList.insertDatabase();

            instrumentationSegment.RowCount = rowCount;
        }

        return priceDiscGroupTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDateInChannelTimeZone</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts CLR datetime into channel's timezone datetime object.
    /// </summary>
    /// <param name = "dateTimeOffSet">CLR datetime object.</param>
    /// <returns>Datetime in channel's timezone.</returns>
    protected date GetDateInChannelTimeZone(System.DateTimeOffset dateTimeOffSet)
    {
        System.DateTimeOffset dateTimeOffSetInChannelTimeZone;
        System.DateTime dateTimeInChannelTimeZone;
        date ret;

        if (mPriceChannelConfiguration.ChannelTimeZoneId == '')
        {
            // No destination time zone info - use same
            dateTimeOffSetInChannelTimeZone = dateTimeOffSet;
        }
        else
        {
            // Adjust for time zone...
            dateTimeOffSetInChannelTimeZone = System.TimeZoneInfo::ConvertTimeBySystemTimeZoneId(dateTimeOffSet, mPriceChannelConfiguration.ChannelTimeZoneId);
        }

        dateTimeInChannelTimeZone = dateTimeOffSetInChannelTimeZone.get_DateTime();
        ret = DateTimeUtil::date(dateTimeInChannelTimeZone);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetValidationPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts RetailDiscountValidationPeriodId table's records into Microsoft.Dynamics.Commerce.Runtime.DataModel.ValidationPeriod object.
    /// </summary>
    /// <param name = "_periodId">A record from RetailDiscountValidationPeriodId table.</param>
    /// <returns>Returns Microsoft.Dynamics.Commerce.Runtime.DataModel.ValidationPeriod type object.</returns>
    protected Microsoft.Dynamics.Commerce.Runtime.DataModel.ValidationPeriod GetValidationPeriod(RetailDiscountValidationPeriodId _periodId)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.ValidationPeriod crtValidationPeriod = null;
        RetailDiscountValidationPeriod validationPeriod = RetailDiscountValidationPeriod::find(_periodId);
        if (validationPeriod)
        {
            crtValidationPeriod = new Microsoft.Dynamics.Commerce.Runtime.DataModel.ValidationPeriod();
            crtValidationPeriod.PeriodId = validationPeriod.periodId;

            crtValidationPeriod.ValidFrom = this.ConvertDateToSystemDateTimeOffset(validationPeriod.validFrom);
            crtValidationPeriod.ValidTo = this.ConvertDateToSystemDateTimeOffset(validationPeriod.validTo);

            crtValidationPeriod.StartingTime = validationPeriod.startingTime;
            crtValidationPeriod.EndingTime = validationPeriod.endingTime;
            crtValidationPeriod.IsTimeBounded = validationPeriod.timeWithinBounds;
            crtValidationPeriod.IsEndTimeAfterMidnight = validationPeriod.endingTimeAfterMidnight;

            crtValidationPeriod.MondayStartingTime = validationPeriod.mondayStartingTime;
            crtValidationPeriod.MondayEndingTime = validationPeriod.mondayEndingTime;
            crtValidationPeriod.IsMondayTimeBounded = validationPeriod.mondayTimeWithinBounds;
            crtValidationPeriod.IsMondayEndTimeAfterMidnight = validationPeriod.mondayEndingTimeAfterMidnight;

            crtValidationPeriod.TuesdayStartingTime = validationPeriod.thuesdayStartingTime;
            crtValidationPeriod.TuesdayEndingTime = validationPeriod.thuesdayEndingTime;
            crtValidationPeriod.IsTuesdayTimeBounded = validationPeriod.thuesdayTimeWithinBounds;
            crtValidationPeriod.IsTuesdayEndTimeAfterMidnight = validationPeriod.thuesdayEndingTimeAfterMidnight;

            crtValidationPeriod.WednesdayStartingTime = validationPeriod.wednesdayStartingTime;
            crtValidationPeriod.WednesdayEndingTime = validationPeriod.wednesdayEndingTime;
            crtValidationPeriod.IsWednesdayTimeBounded = validationPeriod.wednesdayTimeWithinBounds;
            crtValidationPeriod.IsWednesdayEndTimeAfterMidnight = validationPeriod.wednesdayEndingTimeAfterMidnight;

            crtValidationPeriod.ThursdayStartingTime = validationPeriod.thursdayStartingTime;
            crtValidationPeriod.ThursdayEndingTime = validationPeriod.thursdayEndingTime;
            crtValidationPeriod.IsThursdayTimeBounded = validationPeriod.thursdayTimeWithinBounds;
            crtValidationPeriod.IsThursdayEndTimeAfterMidnight = validationPeriod.thursdayEndingTimeAfterMidnight;

            crtValidationPeriod.FridayStartingTime = validationPeriod.fridayStartingTime;
            crtValidationPeriod.FridayEndingTime = validationPeriod.fridayEndingTime;
            crtValidationPeriod.IsFridayTimeBounded = validationPeriod.fridayTimeWithinBounds;
            crtValidationPeriod.IsFridayEndTimeAfterMidnight = validationPeriod.fridayEndingTimeAfterMidnight;

            crtValidationPeriod.SaturdayStartingTime = validationPeriod.saturdayStartingTime;
            crtValidationPeriod.SaturdayEndingTime = validationPeriod.saturdayEndingTime;
            crtValidationPeriod.IsSaturdayTimeBounded = validationPeriod.saturdayTimeWithinBounds;
            crtValidationPeriod.IsSaturdayEndTimeAfterMidnight = validationPeriod.saturdayEndingTimeAfterMidnight;

            crtValidationPeriod.SundayStartingTime = validationPeriod.sundayStartingTime;
            crtValidationPeriod.SundayEndingTime = validationPeriod.sundayEndingTime;
            crtValidationPeriod.IsSundayTimeBounded = validationPeriod.sundayTimeWithinBounds;
            crtValidationPeriod.IsSundayEndTimeAfterMidnight = validationPeriod.sundayEndingTimeAfterMidnight;
        }

        return crtValidationPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVariantMatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines weather the variant match the target inventDim or not.
    /// </summary>
    /// <param name = "variantId">product variant id.</param>
    /// <param name = "targetDimId">target inventDim id.</param>
    /// <returns>true if product variant matches target inventDim; otherwise, false.</returns>
    protected boolean isVariantMatch(RefRecId variantId, InventDimId targetDimId)
    {
        str variantIdDimMapKey = int642Str(variantId) + '-' + targetDimId;

        boolean result = true;

        if (isVariantMap.exists(variantIdDimMapKey))
        {
            result = isVariantMap.lookup(variantIdDimMapKey) == NoYes::Yes;
        }
        else
        {
            result = result && (variantId != 0) && (!System.String::IsNullOrWhiteSpace(targetDimId));

            if (result)
            {
                InventDim variant;
                InventDimCombination variantLink = InventDimCombination::findByDistinctProductVariant(variantId);
                if (variantLink)
                {
                    variant = InventDim::find(variantLink.InventDimId);
                }

                InventDim targetDim = InventDim::find(targetDimId);

                result = result
                    && variant
                    && targetDim
                    && ((System.String::IsNullOrWhiteSpace(targetDim.configId) || targetDim.configId == variant.configId)
                    && (System.String::IsNullOrWhiteSpace(targetDim.InventColorId) || targetDim.InventColorId == variant.InventColorId)
                    && (System.String::IsNullOrWhiteSpace(targetDim.InventSizeId) || targetDim.InventSizeId == variant.InventSizeId)
                    && (System.String::IsNullOrWhiteSpace(targetDim.InventStyleId) || targetDim.InventStyleId == variant.InventStyleId)
                    && (System.String::IsNullOrWhiteSpace(targetDim.InventVersionId) || targetDim.InventVersionId == variant.InventVersionId));

                isVariantMap.insert(variantIdDimMapKey, result ? NoYes::Yes : NoYes::No);
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ReadTenderDiscounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets tender discounts.
    /// </summary>
    /// <param name = "items">An object of item number.</param>
    /// <param name = "priceGroups">An object of price group.</param>
    /// <param name = "minActiveDate">A minimum active date to read tender discount.</param>
    /// <param name = "maxActiveDate">A maximum active date to read tender discount.</param>
    /// <param name = "settings">Settings.</param>
    /// <returns>Tender discounts.</returns>
    public System.Object ReadTenderDiscounts(
                System.Object items,
                System.Object priceGroups,
                System.DateTimeOffset minActiveDate,
                System.DateTimeOffset maxActiveDate,
                Microsoft.Dynamics.Commerce.Runtime.DataModel.QueryResultSettings settings)
    {
        ValidFromDate minFromDate =  this.GetDateInChannelTimeZone(minActiveDate);
        ValidFromDate maxToDate =  this.GetDateInChannelTimeZone(maxActiveDate);

        RetailTenderDiscount tenderDiscount;
        RetailTenderDiscountThresholdTiers tenderDiscountThreshold;
        RetailTenderTypeTable retailTenderTypeTable;
        RetailTenderDiscountPriceGroup tenderDiscountPriceGroup;

        Microsoft.Dynamics.Commerce.Runtime.DataModel.TenderDiscountRule crtDiscount;

        // convert price group record ids into temp table for join
        TmpRecIdFilter priceDiscGroupTmp = this.getTmpPriceGroupTableFromGroupIds(priceGroups);
        RetailChannelTable retailChannelTable;

        CLRObject discountList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.TenderDiscountRule());

        while select tenderDiscount
            where tenderDiscount.Status == RetailDisabledEnabled::Enabled
                   && ((tenderDiscount.ValidFrom <= minFromDate || tenderDiscount.ValidFrom <= noDate)
                   && (tenderDiscount.ValidTo >= maxToDate || tenderDiscount.ValidTo <= noDate))
            join tenderDiscountThreshold
                where tenderDiscount.OfferId == tenderDiscountThreshold.OfferId
            join retailTenderTypeTable
                where retailTenderTypeTable.RecId == tenderDiscount.RetailTenderType
            join tenderDiscountPriceGroup
                where tenderDiscountPriceGroup.RetailTenderDiscount == tenderDiscount.RecId
            join priceDiscGroupTmp
                where priceDiscGroupTmp.RefRecId == tenderDiscountPriceGroup.PriceDiscGroup
        {

            while select mTmpOrderItem
            {
                crtDiscount = this.ConvertToCrtTenderDiscount(
                    tenderDiscount,
                    tenderDiscountThreshold,
                    retailTenderTypeTable,
                    mTmpOrderItem);

                discountList.Add(crtDiscount);
            }
        }

        return discountList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetTaxExemptPercentage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the percent value of all exempt taxes.
    /// </summary>
    /// <param name="salesTaxGroupId">The sales tax group assigned to the taxable item.</param>
    /// <param name="itemTaxGroupId">The item tax group assigned to the taxable item.</param>
    /// <param name="taxBase">The tax base of the taxable item. This is used when a tax code has intervals configured for different price ranges.</param>
    /// <returns>The percent value of all exempt taxes.</returns>
    public System.Decimal GetTaxExemptPercentage(System.String salesTaxGroupId, System.String itemTaxGroupId, System.Decimal taxBase)
    {
        date currentDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

        List taxIntervals = RetailPricingCacheManager::getTaxIntervalsForTaxGroups(salesTaxGroupId, itemTaxGroupId);

        real taxExemptPercentage = 0;

        ListIterator iterator = new ListIterator(taxIntervals);

        // Iterate over tax intervals to sum all valid values.
        while (iterator.more())
        {
            RetailTaxIntervalCacheObject taxIntervalObject = iterator.value();

            if (taxIntervalObject.getTaxCode() == "")
            {
                break;
            }

            date taxFromDate = taxIntervalObject.getTaxFromDate();
            date taxToDate = taxIntervalObject.getTaxToDate();
            real taxLimitMin = taxIntervalObject.getTaxLimitMin();
            real taxLimitMax = taxIntervalObject.getTaxLimitMax();
            real taxValue = taxIntervalObject.getTaxValue();

            if ((!taxFromDate && !taxToDate) || (taxFromDate <= currentDate && currentDate <= taxToDate))
            {
                if ((!taxLimitMin && !taxLimitMax) || (!taxLimitMin && taxBase <= taxLimitMax) || (taxLimitMin < taxBase && taxBase <= taxLimitMax) || (taxLimitMin < taxBase && !taxLimitMax))
                {
                    taxExemptPercentage += taxValue;
                }
            }

            iterator.next();
        }

        return taxExemptPercentage / 100;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetConfigurationParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the configuration parameter.
    /// </summary>
    /// <returns>The configuration parameter.</returns>
    public System.Object GetConfigurationParameter()
    {
        CLRObject configurationParameterList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.RetailConfigurationParameter());
        this.addConfigurationParameter(configurationParameterList, retailConfigurationParameters::findByName(RetailConfigurationParameters::getNameForRetailRemoveSystemDiscountWhenManualDiscountIsBlocked()));
        this.addConfigurationParameter(configurationParameterList, retailConfigurationParameters::findByName(RetailConfigurationParameters::getNameForRetailGetOverlappingWithoutThresholdApplyingLines()));
        this.addConfigurationParameter(configurationParameterList, retailConfigurationParameters::findByName(RetailConfigurationParameters::getNameForEnableTradeAgreementLineUnitAndDefaultUnitConversion()));
        return configurationParameterList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addConfigurationParameter</Name>
				<Source><![CDATA[
    private void addConfigurationParameter(CLRObject _configurationParameterList, RetailConfigurationParameters _retailConfigurationParameters)
    {
        if (_retailConfigurationParameters.RecId)
        {
            Microsoft.Dynamics.Commerce.Runtime.DataModel.RetailConfigurationParameter configurationParameter = new Microsoft.Dynamics.Commerce.Runtime.DataModel.RetailConfigurationParameter();
            configurationParameter.RecordId = _retailConfigurationParameters.RecId;
            configurationParameter.Name = _retailConfigurationParameters.Name;
            configurationParameter.Value = _retailConfigurationParameters.Value;

            _configurationParameterList.Add(configurationParameter);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertToCrtTenderDiscount</Name>
				<Source><![CDATA[
    private Microsoft.Dynamics.Commerce.Runtime.DataModel.TenderDiscountRule ConvertToCrtTenderDiscount(
        RetailTenderDiscount tenderDiscount,
        RetailTenderDiscountThresholdTiers tenderDiscountThreshold,
        RetailTenderTypeTable retailTenderTypeTable,
        RetailTempOrderItem retailTempOrderItem)
    {
        RetailExtensibleEnumerationInitializer::setExtensibleEnumInitializer(funcName());

        Microsoft.Dynamics.Commerce.Runtime.DataModel.TenderDiscountRule crtDiscount = new Microsoft.Dynamics.Commerce.Runtime.DataModel.TenderDiscountRule();

        crtDiscount.OfferId = tenderDiscount.OfferId;
        crtDiscount.TenderTypeId = retailTenderTypeTable.tenderTypeId;
        crtDiscount.CardTypeId = tenderDiscount.CardTypeId;
        crtDiscount.AmountThreshold = tenderDiscountThreshold.AmountThreshold;
        crtDiscount.DiscountPercent = tenderDiscountThreshold.DiscountValue;
        crtDiscount.OfferName = tenderDiscount.Name;
        crtDiscount.ProductId = retailTempOrderItem.Product;

        return crtDiscount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateKeyForIsDiscountApplicableMap</Name>
				<Source><![CDATA[
    private container generateKeyForIsDiscountApplicableMap(TmpRecIdFilter _priceGroups, RetailOfferIdEx3 _offerId)
    {
        container mapKey;

        while select RefRecId from _priceGroups
            order by _priceGroups.RefRecId asc
        {
            mapKey += _priceGroups.RefRecId;
        }

        mapKey += _offerId;

        return mapKey;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>