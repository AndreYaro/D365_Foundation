<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendCalcSettledAmounts_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class CustVendCalcSettledAmounts_RU
{
    Map                         mapTransAmountsMST, mapTransAmountsCur, mapTransAmountsReporting;
    Map                         mapSettledAmountsMST, mapSettledAmountsCur, mapSettledAmountsReporting;
    Map                         mapLastSettledAmountsMST, mapLastSettledAmountsCur, mapLastSettledAmountsReporting;
    Map                         mapMapSettledAmountsMST, mapMapSettledAmountsCur, mapMapSettledAmountsReporting;
    Map                         mapUnroundSettledAmountsMST, mapUnroundSettledAmountsCur, mapUnroundSettledAmountsReporting;
    AmountMST                   transAmountMSTInclVAT, totalSettledAmountsMST;
    AmountCur                   transAmountCurInclVAT, totalSettledAmountsCur;
    AmountMSTSecondary          transAmountReportingInclVAT, totalSettledAmountsReporting;
    CurrencyCode                currencyCode;
    CurrencyCode                reportingCurrencyCode;
    CustVendTrans               mainTrans;
    QueryRun                    queryRun;
    ExchRate                    exchRate;
    ExchRate                    exchRateReporting;
    boolean                     throwOnError;
    QueryRun                    queryRunTransAmounts;
    boolean                     taxTransKeyExt;
    LedgerVoucherObject         ledgerVoucherObject;

    // ledger dimensions of tax transactions in ledgerVoucherObject
    TmpTaxTransLedgerDimension_RU tmpTaxLedgerDimensions;
    TmpTaxTransLedgerDimension_RU tmpTaxLedgerDimensionsOffset;

    Map                         sourceTransMap;
    Map                         settlementLinesMap;
    AmountCur                   totalSourceTransAmount;
    boolean                     useParentSourceDocumentLine;
    RecId                       parentSourceDocumentLine;

    #localMacro.TaxTransKey
        [taxtrans.TaxCode,
         LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(combination.RecId),
         useParentSourceDocumentLine ? int642str(parentSourceDocumentLine) : taxTrans.InventTransId,
         combination.RecId,
         offsetCombination.RecId,
         taxTrans.Source]
    #endmacro

    #localMacro.TaxTransKeyExt
        [taxTrans.TaxGroup,
         taxTrans.TaxItemGroup,
         taxtrans.TaxCode,
         LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(combination.RecId),
         useParentSourceDocumentLine ? int642str(parentSourceDocumentLine) : taxTrans.InventTransId,
         combination.RecId,
         offsetCombination.RecId,
         taxTrans.Source]
    #endmacro

    #define.TransNotLiable(taxTransKeyExt ? ['', '', '', 0, '', 0, 0, 0] : ['', 0, '', 0, 0, 0])

    #localMacro.SettledAmountsKey
         [_custVendSettlement.TransDate,
          _custVendSettlement.RecId,
          _custVendSettlement.TransRecId,
          _custVendSettlement.OffsetRecId,
          _custVendSettlement.ReversedRecId_RU,
          _custVendSettlement.ReverseTrans_ru,
          _custVendSettlement.ReverseDate_RU(),
          _custVendSettlement.TransCompany,
          _custVendSettlement.OffsetCompany]
    #endmacro

    #localMacro.TransAmountsKey
        (taxTransKeyExt ? #taxTransKeyExt : #TaxTransKey)
    #endMacro

    #localMacro.ReportingTaxTransKey
        [taxPostingLog.TaxCode,
         LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(taxPostingLog.LedgerDimension),
         '',
         taxPostingLog.LedgerDimension,
         taxPostingLog.OffsetLedgerDimension,
         TaxModuleType::Tax]
    #endmacro

    #localMacro.ReportingTaxTransKeyExt
        ['',
         '',
         taxPostingLog.TaxCode,
         LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(taxPostingLog.LedgerDimension),
         '',
         taxPostingLog.LedgerDimension,
         taxPostingLog.OffsetLedgerDimension,
         TaxModuleType::Tax]
    #endmacro

    #localMacro.ReportingTransAmountsKey
        (taxTransKeyExt ? #ReportingTaxTransKeyExt : #ReportingTaxTransKey)
    #endMacro
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addAmountsToMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds VAT related amounts to map.
    /// </summary>
    /// <param name="_map">
    /// The map to insert amounts into.
    /// </param>
    /// <param name="_key">
    /// Key value that idetifies specific recotd in the map.
    /// </param>
    /// <param name="_amountLiableToVAT">
    /// Amount liable to VAT.
    /// </param>
    /// <param name="_amountVAT">
    /// VAT amount.
    /// </param>
    /// <param name="_update">
    /// true if amounts need to be updated; false if amounts need to be inserted.
    /// </param>
    protected void addAmountsToMap(Map _map, anytype _key, TaxBase _amountLiableToVAT, TaxAmount _amountVAT, boolean _update = true)
    {
        BookStructSmallVATAmounts_RU amounts;

        if (!_map)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        amounts = _update && _map.exists(_key) ? BookStructSmallVATAmounts_RU::create(_map.lookup(_key)) : new BookStructSmallVATAmounts_RU();

        amounts.addAmounts(_amountLiableToVAT + _amountVAT, _amountLiableToVAT, _amountVAT);

        _map.insert(_key, amounts.pack());
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaxInCostPriceToMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the TaxInCostPrice amount to map.
    /// </summary>
    /// <param name = "_map">The map which is inserted the TaxInCostPrice amount.</param>
    /// <param name = "_key">Key value that idetifies specific recotd in the map.</param>
    /// <param name = "_taxInCostPrice">The TaxInCostPrice amount.</param>
    internal void addTaxInCostPriceToMap(Map _map, anytype _key, TaxAmount _taxInCostPrice)
    {
        BookStructSmallVATAmounts_RU amounts;

        if (!_map)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        amounts = _map.exists(_key) ? BookStructSmallVATAmounts_RU::create(_map.lookup(_key)) : new BookStructSmallVATAmounts_RU();

        amounts.addTaxInCostPrice(_taxInCostPrice);

        _map.insert(_key, amounts.pack());
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAdvAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes advance adjustment calculation
    /// </summary>
    /// <param name="_custVendSettlement">
    /// <c>CustVendSettlement</c> record
    /// </param>
    public void calcAdvAdjustments(CustVendSettlement  _custVendSettlement = CustVendTransStatic::newTrans(mainTrans).custVendSettlement())
    {
        TaxTrans                     taxTrans;
        TaxTable                     taxTable;
        BookStructSmallVATAmounts_RU transAmountsMST, transAmountsTotalMST;
        TaxCode                      taxCode;
        DimensionDefault             defaultDimension;
        AmountMST                    amountInclVAT, totalAmountInclVAT;
        AmountMST                    amountLiableToVAT, totalAmountLiableToVAT;
        AmountMST                    amountVAT, totalAmountVAT;
        container                    key;
        Map                          mapSettledAmounts;
        Map                          mapTaxDimAmounts;
        MapEnumerator                mapEnumerator;
        CustVendTransPostingLog_RU   postingLog;
        CustVendTrans                custVendTransAdvAdj       = mainTrans.data();
        CustVendSettlement           custVendSettlementReverse = _custVendSettlement.data();
        TaxTransLedgerDimensions_RU  taxTransLedgerDimensions;

        DimensionDefault getDefaultDimensionWORTax25(DimensionDefault _defaultDimension)
        {
            RefRecId                            rTax25dimAttrId = RTax25Parameters::find().DimensionAttribute;
            DimensionDefault                    res             = _defaultDimension;
            DimensionAttributeValueSetStorage   dimAttrValueSetStorage;

            if (rTax25dimAttrId)
            {
                dimAttrValueSetStorage = DimensionAttributeValueSetStorage::find(_defaultDimension);
                dimAttrValueSetStorage.removeDimensionAttribute(rTax25dimAttrId);
                res = dimAttrValueSetStorage.save();
            }

            return res;
        }

        AmountMST calcPartAdjustment(AmountMST _amount, AmountMST _totalAmount, AmountMST _amountAdj)
        {
            AmountMST ret;

            if (_totalAmount)
            {
                ret = CurrencyExchangeHelper::amount(-_amount / _totalAmount * _amountAdj);
            }

            return ret;
        }

        while select _custVendSettlement
            where _custVendSettlement.TransRecId        == mainTrans.RecId      &&
                  _custVendSettlement.AccountNum        == mainTrans.AccountNum &&
                  _custVendSettlement.SettleAmountCur   != 0
        {
            while select custVendTransAdvAdj
                where custVendTransAdvAdj.AccountNum  == mainTrans.AccountNum          &&
                      custVendTransAdvAdj.Invoice     == mainTrans.Invoice             &&
                      custVendTransAdvAdj.OffsetRecId == mainTrans.RecId               &&
                      custVendTransAdvAdj.TransDate   == _custVendSettlement.TransDate &&
                      custVendTransAdvAdj.TransType   == LedgerTransType::AdvanceAdjustment_RU
            exists join postingLog
                where postingLog.Voucher        == custVendTransAdvAdj.Voucher          &&
                      postingLog.TransDate      == _custVendSettlement.reverseDate_RU() &&
                    ((postingLog.TransRecId     == _custVendSettlement.TransRecId       &&
                      postingLog.OffSetRecId    == _custVendSettlement.OffsetRecId)     ||
                     (postingLog.TransRecId     == _custVendSettlement.OffsetRecId      &&
                      postingLog.OffSetRecId    == _custVendSettlement.TransRecId))     &&
                      postingLog.PostingLogType == CustVendTransPostingLogType_RU::AdvanceAdjustment
            {
                if (!mapMapSettledAmountsMST.exists(#SettledAmountsKey))
                    continue;

                mapSettledAmounts = mapMapSettledAmountsMST.lookup(#SettledAmountsKey);

                mapTaxDimAmounts = new Map(Types::Container, Types::Container);

                mapEnumerator = mapSettledAmounts.getEnumerator();
                while (mapEnumerator.moveNext())
                {
                    taxCode          = taxTransKeyExt ? conPeek(mapEnumerator.currentKey(), 3) : conPeek(mapEnumerator.currentKey(), 1);
                    defaultDimension = taxTransKeyExt ? conPeek(mapEnumerator.currentKey(), 4) : conPeek(mapEnumerator.currentKey(), 2);
                    defaultDimension = getDefaultDimensionWORTax25(defaultDimension);

                    key = [taxCode, defaultDimension];

                    transAmountsMST = mapTaxDimAmounts.exists(key)                                       ?
                                      BookStructSmallVATAmounts_RU::create(mapTaxDimAmounts.lookup(key)) :
                                      new BookStructSmallVATAmounts_RU();

                    transAmountsMST.addAmounts2(BookStructSmallVATAmounts_RU::create(mapEnumerator.currentValue()));
                    mapTaxDimAmounts.insert(key, transAmountsMST.pack());
                }

                while select sum(TaxBaseAmount),
                             sum(TaxAmount)
                    from taxTrans
                    group by TaxCode
                    where taxTrans.TransDate     == custVendTransAdvAdj.TransDate &&
                          taxTrans.Voucher       == custVendTransAdvAdj.Voucher   &&
                          taxTrans.SourceRecId   == custVendTransAdvAdj.RecId     &&
                          taxTrans.SourceTableId == custVendTransAdvAdj.TableId
                join taxTransLedgerDimensions group by LedgerDimension
                    where taxTransLedgerDimensions.TaxTrans == taxTrans.RecId
                join TaxType_W from taxTable
                    where taxTable.TaxCode == taxTrans.TaxCode &&
                          (taxTable.TaxType_W == TaxType_W::VAT        ||
                           taxTable.TaxType_W == TaxType_W::VATReduced ||
                           taxTable.TaxType_W == TaxType_W::VATZero)
                {
                    totalAmountInclVAT      = 0;
                    totalAmountLiableToVAT  = 0;
                    totalAmountVAT          = 0;
                    key                     = conNull();

                    mapEnumerator = mapSettledAmounts.getEnumerator();
                    while (mapEnumerator.moveNext())
                    {
                        taxCode          = taxTransKeyExt ? conPeek(mapEnumerator.currentKey(), 3) : conPeek(mapEnumerator.currentKey(), 1);
                        defaultDimension = taxTransKeyExt ? conPeek(mapEnumerator.currentKey(), 4) : conPeek(mapEnumerator.currentKey(), 2);
                        defaultDimension = getDefaultDimensionWORTax25(defaultDimension);

                        if (taxCode != taxTrans.TaxCode ||
                            !DimensionDefaultFacade::areEqual(
                                defaultDimension,
                                LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(taxTransLedgerDimensions.LedgerDimension)))
                        {
                            continue;
                        }

                        key = mapEnumerator.currentKey();

                        transAmountsTotalMST = mapTaxDimAmounts.exists([taxCode, defaultDimension])                                       ?
                                               BookStructSmallVATAmounts_RU::create(mapTaxDimAmounts.lookup([taxCode, defaultDimension])) :
                                               new BookStructSmallVATAmounts_RU();
                        transAmountsMST = BookStructSmallVATAmounts_RU::create(mapEnumerator.currentValue());

                        amountInclVAT       = calcPartAdjustment(transAmountsMST.amountInclVAT(),
                                                                 transAmountsTotalMST.amountInclVAT(),
                                                                 taxTrans.TaxBaseAmount + taxTrans.TaxAmount);

                        amountLiableToVAT   = calcPartAdjustment(transAmountsMST.amountLiableToVAT(),
                                                                 transAmountsTotalMST.amountLiableToVAT(),
                                                                 taxTrans.TaxBaseAmount);

                        amountVAT           = calcPartAdjustment(transAmountsMST.taxAmountVAT(),
                                                                 transAmountsTotalMST.taxAmountVAT(),
                                                                 taxTrans.TaxAmount);

                        totalAmountInclVAT      += amountInclVAT;
                        totalAmountLiableToVAT  += amountLiableToVAT;
                        totalAmountVAT          += amountVAT;

                        transAmountsMST.addAmounts(amountInclVAT, amountLiableToVAT, amountVAT);

                        mapSettledAmounts.insert(mapEnumerator.currentKey(), transAmountsMST.pack());
                    }

                    if (key != conNull())
                    {
                        transAmountsMST = BookStructSmallVATAmounts_RU::create(mapSettledAmounts.lookup(key));
                        transAmountsMST.addAmounts(- (taxTrans.TaxBaseAmount + taxTrans.TaxAmount) - totalAmountInclVAT,
                                                   -  taxTrans.TaxBaseAmount - totalAmountLiableToVAT,
                                                   -  taxTrans.TaxAmount - totalAmountVAT);

                        mapSettledAmounts.insert(key, transAmountsMST.pack());
                    }
                }

                mapMapSettledAmountsMST.insert(#SettledAmountsKey, mapSettledAmounts);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcNewSettlement</Name>
				<Source><![CDATA[
    public void calcNewSettlement(AmountMST _amountAccounting, AmountCur _amountTransaction, AmountMSTSecondary _amountReporting = 0)
    {
        this.calcVirtualSettlementAccounting(_amountAccounting, _amountTransaction);
        this.calcVirtualSettlementTransaction(_amountTransaction, _amountTransaction);
        this.calcVirtualSettlementReporting(_amountReporting, _amountTransaction);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcSettledAmounts</Name>
				<Source><![CDATA[
    public void calcSettledAmounts()
    {
        CustVendSettlement custVendSettlement;
        AmountMST          settledAmountAccounting;
        AmountCur          settledAmountTransaction;
        AmountMSTSecondary settledAmountReporting;

        while (queryRun.next())
        {
            custVendSettlement = queryRun.getNo(1);

            settledAmountAccounting     = custVendSettlement.SettleAmountMST - custVendSettlement.ExchAdjustment;
            settledAmountTransaction    = custVendSettlement.SettleAmountCur;

            if (reportingCurrencyCode)
            {
                settledAmountReporting = custVendSettlement.SettleAmountReporting - custVendSettlement.ExchAdjustmentReporting;
            }

            if ((mainTrans.Prepayment && !this.calcVATTransitSettlementPrepayment(custVendSettlement)) ||
               (!mainTrans.Prepayment && !this.calcVATTransitSettlement(custVendSettlement)))
            {
                this.calcVirtualSettlementAccounting(settledAmountAccounting, settledAmountTransaction, custVendSettlement);
                this.calcVirtualSettlementTransaction(settledAmountTransaction, settledAmountTransaction, custVendSettlement);
                this.calcVirtualSettlementReporting(settledAmountReporting, settledAmountTransaction, custVendSettlement);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTransAmounts</Name>
				<Source><![CDATA[
    protected void calcTransAmounts()
    {
        TaxTrans                    taxTrans;
        AmountMST                   totalAmountAccountingInclVAT;
        AmountCur                   totalAmountTransactionInclVAT;
        AmountMSTSecondary          totalAmountReportingInclVAT;
        TaxAmountCur                taxAmountTransaction, taxInCostPriceTransaction;
        boolean                     useInventTransId;
        MapEnumerator               me;
        Sign                        sign = mainTrans.Prepayment ? 1 : -1;
        Map                         settlementMap;
        AmountCur                   settlementLineAmount;
        container                   settlementCon;
        CustVendTransPostingLog_RU  taxPostingLog;
        TaxTable                    taxTable;

        DimensionAttributeValueCombination combination;
        DimensionAttributeValueCombination offsetCombination;
        List                        distributions;

        TaxTrans                                taxTransOrig;
        TaxTrans                                taxTransRemainder;
        Enumerator                              e;
        CustVendTransCorrespondentDistribution  distribution;
        int                                     i;
        boolean                                 isLast;

        void distributeAmount(FieldID _field, CurrencyCode _currencyCode='')
        {
            if (isLast)
            {
                taxTrans.(_field)  = taxTransRemainder.(_field);
            }
            else
            {
                taxTrans.(_field)  = CurrencyExchangeHelper::amount(taxTransOrig.(_field) * distribution.transactionAmount(), _currencyCode);
                taxTransRemainder.(_field) -= taxTrans.(_field);
            }
        }
        void groupTransMapValues(Map _map)
        {
            AmountCur origLineAmount, totalOrigLineAmount;
            AmountCur markedLineAmount, totalMarkedLineAmount;

            if (_map && _map.exists([taxTrans.SourceTableId, taxTrans.SourceRecId]))
            {
                if (_map.exists(#TransAmountsKey))
                {
                    [totalOrigLineAmount, totalMarkedLineAmount] = _map.lookup(#TransAmountsKey);
                }

                [origLineAmount, markedLineAmount] = _map.lookup([taxTrans.SourceTableId, taxTrans.SourceRecId]);

                _map.insert(#TransAmountsKey, [totalOrigLineAmount + origLineAmount, totalMarkedLineAmount + markedLineAmount]);
            }
        }

        void addDiffAmountsToMap(Amount _totalAmountInclVAT, Amount _transAmountInclVAT, Map _mapTransAmounts)
        {
            BookStructSmallVATAmounts_RU    transAmounts;
            boolean                         transNotLiableExists = mapTransAmountsCur.exists(#TransNotLiable);

            if (transNotLiableExists || _totalAmountInclVAT != _transAmountInclVAT)
            {
                transAmounts = new BookStructSmallVATAmounts_RU();
                transAmounts.addAmounts(_transAmountInclVAT - _totalAmountInclVAT, _transAmountInclVAT - _totalAmountInclVAT, 0);

                if (transNotLiableExists)
                {
                    _mapTransAmounts.insert(#TransNotLiable, transAmounts.pack());
                }
                else
                {
                    me = _mapTransAmounts.getEnumerator();
                    if (me.moveNext())
                    {
                        transAmounts.addAmounts2(BookStructSmallVATAmounts_RU::create(me.currentValue()));
                        _mapTransAmounts.insert(me.currentKey(), transAmounts.pack());
                    }
                }
            }
        }

        exchRate = mainTrans.AmountCur ? mainTrans.AmountMST / mainTrans.AmountCur : 1;

        if (reportingCurrencyCode)
        {
            exchRateReporting = mainTrans.AmountMST ? mainTrans.ReportingCurrencyAmount / mainTrans.AmountMST : 0;
        }

        transAmountMSTInclVAT       = mainTrans.AmountMST;
        transAmountCurInclVAT       = mainTrans.AmountCur;
        transAmountReportingInclVAT = mainTrans.ReportingCurrencyAmount;

        useInventTransId = SysQuery::findSortingNo_W(queryRunTransAmounts.query().dataSourceTable(tableNum(TaxTrans)), fieldNum(TaxTrans, InventTransId));

        if (mainTrans.Invoice && useInventTransId)
        {
            [totalAmountTransactionInclVAT, totalAmountAccountingInclVAT, totalAmountReportingInclVAT] = this.initMapTransAmounts();
        }

        if (reportingCurrencyCode                                       &&
            mainTrans.TransType == LedgerTransType::ExchAdjustment      ||
            mainTrans.TransType == LedgerTransType::AdvanceAdjustment_RU)
        {
            while select sum(AmountMSTSecond), sum(TaxBaseAmountReporting) from taxPostingLog
                group by TaxCode, LedgerDimension, OffsetLedgerDimension
                join TableId from taxTable
                where taxPostingLog.Voucher     == mainTrans.Voucher
                  &&  taxPostingLog.TransDate   == mainTrans.TransDate
                  &&  taxPostingLog.IsReportingCurrencyTax
                  &&  taxTable.TaxCode          == taxPostingLog.TaxCode
                  && (taxTable.TaxType_W        == TaxType_W::VAT
                  ||  taxTable.TaxType_W        == TaxType_W::VATReduced
                  ||  taxTable.TaxType_W        == TaxType_W::VATZero)
            {
                this.addAmountsToMap(mapTransAmountsMST, #ReportingTransAmountsKey, 0, 0);
                this.addAmountsToMap(mapTransAmountsCur, #ReportingTransAmountsKey, 0, 0);
                this.addAmountsToMap(
                    mapTransAmountsReporting,
                    #ReportingTransAmountsKey,
                sign * (taxPostingLog.TaxBaseAmountReporting),
                    sign *  taxPostingLog.AmountMSTSecond);

                totalAmountReportingInclVAT += sign * (taxPostingLog.TaxBaseAmountReporting + taxPostingLog.AmountMSTSecond);
            }
        }

        while (queryRunTransAmounts.next())
        {
            taxTrans            = queryRunTransAmounts.get(tableNum(TaxTrans));
            taxTransOrig        = taxTrans.data();
            taxTransRemainder   = taxTrans.data();
            if (useParentSourceDocumentLine)
            {
                Debug::assert(taxTrans.SourceDocumentLine);
                parentSourceDocumentLine = SourceDocumentLine::find(taxTrans.SourceDocumentLine).ParentSourceDocumentLine;
            }

            distributions = this.getDistributions(taxTransOrig);
            e = distributions.getEnumerator();
            i = 0;
            while (e.moveNext())
            {
                i++;
                distribution = e.current();
                combination = DimensionAttributeValueCombination::find(distribution.ledgerDimension());
                offsetCombination = DimensionAttributeValueCombination::find(distribution.offsetLedgerDimension());

                isLast = i == distributions.elements();

                distributeAmount(fieldNum(TaxTrans, TaxAmount));
                distributeAmount(fieldNum(TaxTrans, TaxBaseAmount));
                distributeAmount(fieldNum(TaxTrans, TaxAmountCur),              taxTrans.CurrencyCode);
                distributeAmount(fieldNum(TaxTrans, SourceTaxAmountCur),        taxTrans.CurrencyCode);
                distributeAmount(fieldNum(TaxTrans, SourceRegulateAmountCur),   taxTrans.CurrencyCode);
                distributeAmount(fieldNum(TaxTrans, SourceBaseAmountCur),   taxTrans.CurrencyCode);

                groupTransMapValues(sourceTransMap);
                if (settlementLinesMap)
                {
                    me = settlementLinesMap.getEnumerator();
                    while (me.moveNext())
                    {
                        [settlementLineAmount, settlementCon] = me.currentValue();
                        settlementMap = Map::create(settlementCon);
                        groupTransMapValues(settlementMap);
                        settlementLinesMap.insert(me.currentKey(), [settlementLineAmount, settlementMap.pack()]);
                    }
                }

                taxAmountTransaction = taxTrans.TaxAutogenerated ? taxTrans.SourceTaxAmountCur : taxTrans.SourceRegulateAmountCur;
                taxInCostPriceTransaction = taxTrans.TaxAutogenerated ? taxTrans.TaxInCostPrice : taxTrans.TaxInCostPriceRegulated;

                if (!sourceTransMap || sourceTransMap.exists([taxTrans.SourceTableId, taxTrans.SourceRecId]))
                {
                    this.addAmountsToMap(mapTransAmountsMST, #TransAmountsKey, sign * taxTrans.TaxBaseAmount,       sign * taxTrans.TaxAmount);
                    this.addTaxInCostPriceToMap(mapTransAmountsMST, #TransAmountsKey, sign * taxTrans.TaxInCostPriceMST);

                    this.addAmountsToMap(mapTransAmountsCur, #TransAmountsKey, sign * taxTrans.SourceBaseAmountCur, sign * taxAmountTransaction);
                    this.addTaxInCostPriceToMap(mapTransAmountsCur, #TransAmountsKey, sign * taxInCostPriceTransaction);

                    if (reportingCurrencyCode                                       &&
                        mainTrans.TransType != LedgerTransType::ExchAdjustment      &&
                        mainTrans.TransType != LedgerTransType::AdvanceAdjustment_RU)
                    {
                        this.addAmountsToMap(
                            mapTransAmountsReporting,
                            #TransAmountsKey,
                        CurrencyExchangeHelper::amount(sign * taxTrans.TaxBaseAmount * exchRateReporting, reportingCurrencyCode),
                            CurrencyExchangeHelper::amount(sign * taxTrans.TaxAmount * exchRateReporting, reportingCurrencyCode));

                        this.addTaxInCostPriceToMap(
                            mapTransAmountsReporting,
                            #TransAmountsKey,
                        CurrencyExchangeHelper::amount(sign * taxTrans.TaxInCostPriceMST * exchRateReporting, reportingCurrencyCode));

                        totalAmountReportingInclVAT +=
                                CurrencyExchangeHelper::amount(sign * (taxTrans.TaxBaseAmount + taxTrans.TaxAmount) * exchRateReporting, reportingCurrencyCode);
                    }
                    else
                    {
                        this.addAmountsToMap(mapTransAmountsReporting, #TransAmountsKey, 0, 0);
                    }
                }

                totalAmountAccountingInclVAT    += sign * (taxTrans.TaxBaseAmount + taxTrans.TaxAmount);
                totalAmountTransactionInclVAT   += sign * (taxTrans.SourceBaseAmountCur + taxAmountTransaction);
            }
        }

        if (totalAmountTransactionInclVAT != transAmountCurInclVAT)
        {
            this.addAmountsToMap(mapTransAmountsCur, #TransNotLiable, transAmountCurInclVAT - totalAmountTransactionInclVAT, 0, false);
        }

        addDiffAmountstoMap(totalAmountAccountingInclVAT, transAmountMSTInclVAT, mapTransAmountsMST);
        addDiffAmountstoMap(totalAmountReportingInclVAT, transAmountReportingInclVAT, mapTransAmountsReporting);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcVATTransitSettlement</Name>
				<Source><![CDATA[
    protected boolean calcVATTransitSettlement(CustVendSettlement _custVendSettlement)
    {
        TaxCode                 taxCode;
        DimensionDefault        defaultDimension;
        InventTransId           inventTransId;
        AmountMST               settledAmountAccounting;
        AmountCur               settledAmountTransaction;
        AmountMSTSecondary      settledAmountReporting;
        AmountMSTSecondary      taxBaseAmountReporting;
        int                     transAmountsCount;

        BookStructSmallVATAmounts_RU    settledAmountsAccounting;
        BookStructSmallVATAmounts_RU    settledAmountsTransaction;
        BookStructSmallVATAmounts_RU    settledAmountsReporting;

        CustVendTransPostingLog_RU      postingLog;
        RefTableId                      refTableId = _custVendSettlement.TableId == tableNum(CustSettlement) ? tableNum(CustTrans) : tableNum(VendTrans);

        MapEnumerator                   me = mapTransAmountsMST.getEnumerator();

        mapLastSettledAmountsMST        = new Map(Types::Container, Types::Container);
        mapLastSettledAmountsCur        = new Map(Types::Container, Types::Container);
        mapLastSettledAmountsReporting  = new Map(Types::Container, Types::Container);
        transAmountsCount               = mapTransAmountsMST.elements();

        while (me.moveNext())
        {
            [taxCode, defaultDimension, inventTransId] = me.currentKey();
            transAmountsCount--;

            while select AmountMST, AmountCur, TaxBaseAmountMST, TaxBaseAmountCur, LedgerDimension, AmountMSTSecond from postingLog
                where postingLog.TaxCode          == taxCode
                   && postingLog.InventTransId    == inventTransId
                   && postingLog.Voucher          == _custVendSettlement.TaxVoucher_RU
                   && postingLog.TransDate        == _custVendSettlement.reverseDate_RU()
                   && postingLog.Correct          == mainTrans.Correct
                   && ((postingLog.TransRecId     == _custVendSettlement.TransRecId    && postingLog.OffSetRecId   == _custVendSettlement.OffsetRecId
                   &&   postingLog.TransCompany   == _custVendSettlement.TransCompany  && postingLog.OffsetCompany == _custVendSettlement.OffsetCompany)
                   ||  (postingLog.TransRecId     == _custVendSettlement.OffsetRecId   && postingLog.OffSetRecId   == _custVendSettlement.TransRecId
                   &&   postingLog.TransCompany   == _custVendSettlement.OffsetCompany && postingLog.OffsetCompany == _custVendSettlement.TransCompany))
                   && postingLog.PostingLogType   == CustVendTransPostingLogType_RU::VATTransit
                   && postingLog.RefTableId       == refTableId
            {
                if (LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(postingLog.LedgerDimension) == defaultDimension)
                {
                    break;
                }
            }

            if (postingLog)
            {
                if (_custVendSettlement.ReverseTrans_RU)
                {
                    this.reverseAmounts(postingLog);
                }

                this.addAmountsToMap(mapLastSettledAmountsMST, me.currentKey(), -postingLog.TaxBaseAmountMST, -postingLog.AmountMST, false); // reverse sign
                this.addAmountsToMap(mapLastSettledAmountsCur, me.currentKey(), -postingLog.TaxBaseAmountCur, -postingLog.AmountCur, false); // reverse sign

                if (reportingCurrencyCode)
                {
                    if (transAmountsCount)
                    {
                        taxBaseAmountReporting = CurrencyExchangeHelper::amount(postingLog.TaxBaseAmountMST * exchRateReporting, reportingCurrencyCode);
                    }
                    else
                    {
                        taxBaseAmountReporting = _custVendSettlement.ExchAdjustmentReporting - _custVendSettlement.SettleAmountReporting + settledAmountReporting - postingLog.AmountMSTSecond;
                    }

                    this.addAmountsToMap(mapLastSettledAmountsReporting,
                        me.currentKey(),
                        -taxBaseAmountReporting,
                        -postingLog.AmountMSTSecond,
                        false);

                    settledAmountReporting  -= taxBaseAmountReporting + postingLog.AmountMSTSecond;
                }
                else
                {
                    this.addAmountsToMap(mapLastSettledAmountsReporting, me.currentKey(), 0, 0, false);
                }

                settledAmountAccounting     -= postingLog.TaxBaseAmountMST + postingLog.AmountMST;
                settledAmountTransaction    -= postingLog.TaxBaseAmountCur + postingLog.AmountCur;
            }
            else
            {
                return false;
            }
        }

        me = mapLastSettledAmountsMST.getEnumerator();
        while (me.moveNext())
        {
            settledAmountsAccounting = BookStructSmallVATAmounts_RU::create(me.currentValue());
            this.addAmountsToMap(mapSettledAmountsMST, me.currentKey(), settledAmountsAccounting.amountLiableToVAT(), settledAmountsAccounting.taxAmountVAT());

            settledAmountsTransaction = BookStructSmallVATAmounts_RU::create(mapLastSettledAmountsCur.lookup(me.currentKey()));
            this.addAmountsToMap(mapSettledAmountsCur, me.currentKey(), settledAmountsTransaction.amountLiableToVAT(), settledAmountsTransaction.taxAmountVAT());

            settledAmountsReporting = BookStructSmallVATAmounts_RU::create(mapLastSettledAmountsReporting.lookup(me.currentKey()));
            this.addAmountsToMap(mapSettledAmountsReporting, me.currentKey(), settledAmountsReporting.amountLiableToVAT(), settledAmountsReporting.taxAmountVAT());
        }

        mapMapSettledAmountsMST.insert(#SettledAmountsKey, mapLastSettledAmountsMST); // key sorted by transdate and recid
        mapMapSettledAmountsCur.insert(#SettledAmountsKey, mapLastSettledAmountsCur);
        mapMapSettledAmountsReporting.insert(#SettledAmountsKey, mapLastSettledAmountsReporting);

        totalSettledAmountsMST          += settledAmountAccounting;
        totalSettledAmountsCur          += settledAmountTransaction;
        totalSettledAmountsReporting    += settledAmountReporting;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcVATTransitSettlementPrepayment</Name>
				<Source><![CDATA[
    protected boolean calcVATTransitSettlementPrepayment(CustVendSettlement _custVendSettlement)
    {
        TaxCode                     taxCode;
        TaxGroup                    taxGroup;
        TaxItemGroup                taxItemGroup;
        DimensionDefault            defaultDimension;
        AmountMST                   settledAmountAccounting;
        AmountCur                   settledAmountTransaction;
        AmountMSTSecondary          settledAmountReporting;
        TaxTrans                    taxTrans;
        TaxTrans                    taxTransSumAmounts;
        Set                         sourceRecIdSet = new Set(typeName2Type(extendedTypeStr(RecId)));
        TaxTransLedgerDimensions_RU taxTransLedgerDimensions;
        int                         transAmountsCount;
        AmountMSTSecondary          amountInclVATReporting;
        AmountMSTSecondary          amountLiableToVATReporting;
        AmountMSTSecondary          taxAmountVATReporting;

        BookStructSmallVATAmounts_RU    settledAmountsAccounting;
        BookStructSmallVATAmounts_RU    settledAmountsTransaction;
        BookStructSmallVATAmounts_RU    settledAmountsReporting;

        CustVendTransPostingLog_RU      postingLog;
        RefTableId                      refTableId = _custVendSettlement.TableId == tableNum(CustSettlement) ? tableNum(CustTrans) : tableNum(VendTrans);

        MapEnumerator                   me;

        mapLastSettledAmountsMST        = new Map(Types::Container, Types::Container);
        mapLastSettledAmountsCur        = new Map(Types::Container, Types::Container);
        mapLastSettledAmountsReporting  = new Map(Types::Container, Types::Container);

        if (_custVendSettlement.ReverseTrans_RU)
        {
            select firstonly Voucher, TransDate, RecId from postingLog
                where postingLog.TransDate      == _custVendSettlement.reverseDate_RU()       &&
                      postingLog.Voucher        ==  _custVendSettlement.TaxVoucher_RU         &&
                      ((postingLog.AmountCur > 0 && _custVendSettlement.SettleAmountCur > 0)  ||
                      (postingLog.AmountCur < 0 && _custVendSettlement.SettleAmountCur < 0)) &&
                      ((postingLog.TransRecId   == _custVendSettlement.TransRecId    && postingLog.OffSetRecId   == _custVendSettlement.OffsetRecId &&
                        postingLog.TransCompany == _custVendSettlement.TransCompany  && postingLog.OffsetCompany == _custVendSettlement.OffsetCompany) ||
                      (postingLog.TransRecId    == _custVendSettlement.OffsetRecId   && postingLog.OffSetRecId   == _custVendSettlement.TransRecId &&
                       postingLog.TransCompany  == _custVendSettlement.OffsetCompany && postingLog.OffsetCompany == _custVendSettlement.TransCompany)) &&
                      postingLog.PostingLogType == CustVendTransPostingLogType_RU::PrepaymentStornoVAT &&
                      postingLog.RefTableId     == refTableId;
        }
        else
        {
            select firstonly Voucher, TransDate, RecId from postingLog
                where postingLog.TransDate      == _custVendSettlement.TransDate              &&
                      postingLog.Voucher        ==  _custVendSettlement.TaxVoucher_RU         &&
                      ((postingLog.AmountCur > 0 && _custVendSettlement.SettleAmountCur < 0)  ||
                      (postingLog.AmountCur < 0 && _custVendSettlement.SettleAmountCur > 0)) &&
                      ((postingLog.TransRecId   == _custVendSettlement.TransRecId    && postingLog.OffSetRecId   == _custVendSettlement.OffsetRecId &&
                        postingLog.TransCompany == _custVendSettlement.TransCompany  && postingLog.OffsetCompany == _custVendSettlement.OffsetCompany) ||
                      (postingLog.TransRecId    == _custVendSettlement.OffsetRecId   && postingLog.OffSetRecId   == _custVendSettlement.TransRecId &&
                       postingLog.TransCompany  == _custVendSettlement.OffsetCompany && postingLog.OffsetCompany == _custVendSettlement.TransCompany)) &&
                      postingLog.PostingLogType == CustVendTransPostingLogType_RU::PrepaymentStornoVAT &&
                      postingLog.RefTableId     == refTableId;
        }

        if (!postingLog)
        {
            return false;
        }

        transAmountsCount = mapTransAmountsMST.elements();
        me = mapTransAmountsMST.getEnumerator();
        while (me.moveNext())
        {
            transAmountsCount--;
            if (taxTransKeyExt)
            {
                [taxGroup, taxItemGroup, taxCode, defaultDimension] = me.currentKey();
            }
            else
            {
                [taxCode, defaultDimension] = me.currentKey();
            }

            taxTransSumAmounts.clear();

            while select sum(TaxBaseAmount), sum(TaxAmount), sum(SourceBaseAmountCur), sum(SourceTaxAmountCur), sum(SourceRegulateAmountCur) from taxTrans
                group by SourceRecId
                where taxTrans.Voucher         == postingLog.Voucher                &&
                        taxTrans.TransDate     == postingLog.TransDate              &&
                        taxTrans.TaxOrigin     == TaxOrigin::TaxReversed            &&
                        (taxTrans.TaxGroup     == taxGroup     || ! taxTransKeyExt) &&
                        (taxTrans.TaxItemGroup == taxItemGroup || ! taxTransKeyExt) &&
                        taxTrans.TaxCode       == taxCode
                join taxTransLedgerDimensions group by LedgerDimension
                    where taxTransLedgerDimensions.TaxTrans == taxTrans.RecId
            {
                if (LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(taxTransLedgerDimensions.LedgerDimension) == defaultDimension)
                {
                    taxTransSumAmounts.SourceRecId              =  taxTrans.SourceRecId;
                    taxTransSumAmounts.TaxBaseAmount            += taxTrans.TaxBaseAmount;
                    taxTransSumAmounts.TaxAmount                += taxTrans.TaxAmount;
                    taxTransSumAmounts.SourceBaseAmountCur      += taxTrans.SourceBaseAmountCur;
                    taxTransSumAmounts.SourceTaxAmountCur       += taxTrans.SourceTaxAmountCur;
                    taxTransSumAmounts.SourceRegulateAmountCur  += taxTrans.SourceRegulateAmountCur;
                }
            }

            settledAmountsAccounting = new BookStructSmallVATAmounts_RU();
            settledAmountsAccounting.addAmounts(
                -taxTransSumAmounts.TaxBaseAmount - taxTransSumAmounts.TaxAmount,
                -taxTransSumAmounts.TaxBaseAmount,
                -taxTransSumAmounts.TaxAmount); // reverse sign

            settledAmountsTransaction = new BookStructSmallVATAmounts_RU();
            settledAmountsTransaction.addAmounts(
                -taxTransSumAmounts.SourceBaseAmountCur - taxTransSumAmounts.SourceTaxAmountCur,
                -taxTransSumAmounts.SourceBaseAmountCur,
                -taxTransSumAmounts.SourceTaxAmountCur); // reverse sign

            settledAmountsReporting = new BookStructSmallVATAmounts_RU();
            if (reportingCurrencyCode)
            {
                CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                                            Ledger::current(),
                                            mainTrans.TransDate);
                amountInclVATReporting = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(
                                            mainTrans.CurrencyCode,
                                            settledAmountsTransaction.amountInclVAT());

                if (transAmountsCount)
                {
                    taxAmountVATReporting       = CurrencyExchangeHelper::amount(settledAmountsAccounting.taxAmountVAT() * exchRateReporting, reportingCurrencyCode);
                    amountLiableToVATReporting  = CurrencyExchangeHelper::amount(settledAmountsAccounting.amountLiableToVAT() * exchRateReporting, reportingCurrencyCode);
                }
                else
                {
                    taxAmountVATReporting       = _custVendSettlement.SettleAmountReporting - _custVendSettlement.ExchAdjustmentReporting - settledAmountReporting;
                    amountLiableToVATReporting  = amountInclVATReporting - taxAmountVATReporting;
                }

                settledAmountsReporting.addAmounts(amountInclVATReporting, amountLiableToVATReporting, taxAmountVATReporting);
            }

            if (_custVendSettlement.ReverseTrans_RU)
            {
                settledAmountsAccounting.reverseAmounts();
                settledAmountsTransaction.reverseAmounts();
                settledAmountsReporting.reverseAmounts();
            }

            mapLastSettledAmountsMST.insert(me.currentKey(), settledAmountsAccounting.pack());
            mapLastSettledAmountsCur.insert(me.currentKey(), settledAmountsTransaction.pack());
            mapLastSettledAmountsReporting.insert(me.currentKey(), settledAmountsReporting.pack());

            settledAmountAccounting     += settledAmountsAccounting.taxAmountVAT();
            settledAmountTransaction    += settledAmountsTransaction.taxAmountVAT();
            settledAmountReporting      += settledAmountsReporting.taxAmountVAT();

            if (!sourceRecIdSet.in(taxTransSumAmounts.SourceRecId))
            {
                settledAmountAccounting     += settledAmountsAccounting.amountLiableToVAT();
                settledAmountTransaction    += settledAmountsTransaction.amountLiableToVAT();
                settledAmountReporting      += settledAmountsReporting.amountLiableToVAT();
                sourceRecIdSet.add(taxTransSumAmounts.SourceRecId);
            }
        }

        me = mapLastSettledAmountsMST.getEnumerator();
        while (me.moveNext())
        {
            settledAmountsAccounting = BookStructSmallVATAmounts_RU::create(me.currentValue());
            this.addAmountsToMap(mapSettledAmountsMST, me.currentKey(), settledAmountsAccounting.amountLiableToVAT(), settledAmountsAccounting.taxAmountVAT());

            settledAmountsTransaction = BookStructSmallVATAmounts_RU::create(mapLastSettledAmountsCur.lookup(me.currentKey()));
            this.addAmountsToMap(mapSettledAmountsCur, me.currentKey(), settledAmountsTransaction.amountLiableToVAT(), settledAmountsTransaction.taxAmountVAT());

            settledAmountsReporting = BookStructSmallVATAmounts_RU::create(mapLastSettledAmountsReporting.lookup(me.currentKey()));
            this.addAmountsToMap(mapSettledAmountsReporting, me.currentKey(), settledAmountsReporting.amountLiableToVAT(), settledAmountsReporting.taxAmountVAT());
        }

        mapMapSettledAmountsMST.insert(#SettledAmountsKey, mapLastSettledAmountsMST); // key sorted by transdate and recid
        mapMapSettledAmountsCur.insert(#SettledAmountsKey, mapLastSettledAmountsCur);
        mapMapSettledAmountsReporting.insert(#SettledAmountsKey, mapLastSettledAmountsReporting);

        totalSettledAmountsMST          += settledAmountAccounting;
        totalSettledAmountsCur          += settledAmountTransaction;
        totalSettledAmountsReporting    += settledAmountReporting;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcVirtualSettlement</Name>
				<Source><![CDATA[
    private Amount calcVirtualSettlement(
        Amount              _amount,
        Amount              _amountCur,
        CurrencyCode        _currencyCode,
        Amount              _totalTransAmount,
        Amount              _totalSettledAmount,
        Map                 _mapTransAmounts,
        Map                 _mapSettledAmounts,
        Map                 _mapRoundAmounts,
        Map                 _mapMapSettledAmounts,
        Map                 _mapUnroundSettledAmounts,
        CustVendSettlement  _custVendSettlement = null)
    {
        #ISOCountryRegionCodes

        BookStructSmallVATAmounts_RU    transAmounts,
                                        roundAmounts,
                                        unRoundAmounts,
                                        settledAmounts,
                                        unroundSettledAmounts;

        MapEnumerator                   me;

        Amount      amountInclVAT;
        Amount      totalAmountInclVAT;
        Amount      totalSettledAmount = _totalSettledAmount;
        Amount      totalUnroundAmountInclVAT;

        TaxBase     amountLiableToVAT;
        TaxAmount   taxAmount;
        Factor      factor;
        Factor      markedLineFactor;

        int         remainElts;
        AmountCur   totalOrigLineAmount;
        AmountCur   totalMarkedLineAmount;
        Map         virtualTransMap;
        AmountCur   virtualTotalTransAmount;
        container   virtualTransCon;
        str         errorTxt;

        if (abs(_amount + totalSettledAmount) > abs(_totalTransAmount))
        {
            errorTxt = strFmt(
                "@GLS102570",
                mainTrans.AccountNum,
                mainTrans.Voucher,
                _totalTransAmount,
                totalSettledAmount,
                _amount);

            if (throwOnError)
            {
                throw error(errorTxt);
            }

            warning(errorTxt);
            return 0;
        }

        if (_custVendSettlement)
        {
            if (settlementLinesMap && settlementLinesMap.exists(_custVendSettlement.RecId))
            {
                [virtualTotalTransAmount, virtualTransCon] = settlementLinesMap.lookup(_custVendSettlement.RecId);
                virtualTransMap = Map::create(virtualTransCon);
            }
        }
        else
        {
            virtualTransMap         = sourceTransMap;
            virtualTotalTransAmount = totalSourceTransAmount;
        }

        if (virtualTransMap && virtualTotalTransAmount)
        {
            factor = (_amountCur ? _amountCur : _amount) / virtualTotalTransAmount;

            me = _mapTransAmounts.getEnumerator();
            while (me.moveNext())
            {
                if (virtualTransMap.exists(me.currentKey()))
                {
                    remainElts++;
                }
            }
        }
        else
        {
            remainElts          = mapTransAmountsMST.elements();
            markedLineFactor    = _totalTransAmount ? /*abs*/(_amount / _totalTransAmount) : 0;
            virtualTransMap     = null;
        }

        me = _mapTransAmounts.getEnumerator();
        while (me.moveNext())
        {
            if (virtualTransMap)
            {
                if (virtualTransMap.exists(me.currentKey()))
                {
                    [totalOrigLineAmount, totalMarkedLineAmount] = virtualTransMap.lookup(me.currentKey());
                    markedLineFactor = factor * (totalOrigLineAmount ? totalMarkedLineAmount / totalOrigLineAmount : 0);
                }
                else
                {
                    continue;
                }
            }

            transAmounts = BookStructSmallVATAmounts_RU::create(me.currentValue()); // trans amounts
            unroundSettledAmounts = new BookStructSmallVATAmounts_RU();

            remainElts--;
            if (remainElts)
            {
                amountInclVAT   = CurrencyExchangeHelper::amount(transAmounts.amountInclVAT() * markedLineFactor, _currencyCode);
                unroundSettledAmounts.amountInclVAT(transAmounts.amountInclVAT() * markedLineFactor);
                amountInclVAT = CurrencyExchangeHelper::amount(unroundSettledAmounts.amountInclVAT(), _currencyCode);
            }
            else
            {
                amountInclVAT   = _amount - totalAmountInclVAT;
                unroundSettledAmounts.amountInclVAT(_amount - totalUnroundAmountInclVAT);
            }

            unroundSettledAmounts.taxAmountVAT(transAmounts.amountInclVAT() ? (unroundSettledAmounts.amountInclVAT() * transAmounts.taxAmountVAT()) / transAmounts.amountInclVAT() : 0);
            taxAmount           = CurrencyExchangeHelper::amount(transAmounts.amountInclVAT() ? amountInclVAT * transAmounts.taxAmountVAT() / transAmounts.amountInclVAT() : 0, _currencyCode);

            unroundSettledAmounts.amountLiableToVAT(unroundSettledAmounts.amountInclVAT() - unroundSettledAmounts.taxAmountVAT());
            amountLiableToVAT   = amountInclVAT - taxAmount;

            totalUnroundAmountInclVAT   += unroundSettledAmounts.amountInclVAT();
            totalAmountInclVAT += amountInclVAT;
            totalSettledAmount += amountInclVAT;

            this.addAmountsToMap(_mapUnroundSettledAmounts, me.currentKey(), unroundSettledAmounts.amountLiableToVAT(), unroundSettledAmounts.taxAmountVAT(), false);
            this.addAmountsToMap(_mapRoundAmounts,          me.currentKey(), amountLiableToVAT, taxAmount, false);
            this.addAmountsToMap(_mapSettledAmounts,        me.currentKey(), amountLiableToVAT, taxAmount);

            this.addTaxInCostPriceToMap(_mapRoundAmounts, me.currentKey(), transAmounts.taxInCostPrice());
        }

        if (totalSettledAmount == _totalTransAmount)
        {
            // correct last errors (mapTransAmounts = mapRoundAmounts1 + ... + mapRoundAmountsN)
            me = _mapSettledAmounts.getEnumerator();
            while (me.moveNext())
            {
                settledAmounts = BookStructSmallVATAmounts_RU::create(me.currentValue());
                transAmounts   = BookStructSmallVATAmounts_RU::create(_mapTransAmounts.lookup(me.currentKey()));

                if (!transAmounts.equal(settledAmounts))
                {
                    roundAmounts = BookStructSmallVATAmounts_RU::create(_mapRoundAmounts.lookup(me.currentKey()));
                    roundAmounts.addAmounts(transAmounts.amountInclVAT() - settledAmounts.amountInclVAT(),
                                            transAmounts.amountLiableToVAT() - settledAmounts.amountLiableToVAT(),
                                            transAmounts.taxAmountVAT() - settledAmounts.taxAmountVAT());

                    _mapRoundAmounts.insert(me.currentKey(), roundAmounts.pack());

                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoHU, #isoPL]))
                    {
                        unRoundAmounts = BookStructSmallVATAmounts_RU::create(_mapUnroundSettledAmounts.lookup(me.currentKey()));
                        unRoundAmounts.addAmounts(transAmounts.amountInclVAT() - settledAmounts.amountInclVAT(),
                                                transAmounts.amountLiableToVAT() - settledAmounts.amountLiableToVAT(),
                                                transAmounts.taxAmountVAT() - settledAmounts.taxAmountVAT());

                        _mapUnroundSettledAmounts.insert(me.currentKey(), unRoundAmounts.pack());
                    }
                }
            }
        }

        if (_custVendSettlement)
        {
            _mapMapSettledAmounts.insert(#SettledAmountsKey, _mapRoundAmounts); // key sorted by transdate and recid
        }

        return totalSettledAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcVirtualSettlementAccounting</Name>
				<Source><![CDATA[
    private void calcVirtualSettlementAccounting(
        Amount              _amount,
        Amount              _amountCur,
        CustVendSettlement  _custVendSettlement = null)
    {
        mapLastSettledAmountsMST    = new Map(Types::Container, Types::Container);
        mapUnroundSettledAmountsMST = new Map(Types::Container, Types::Container);

        totalSettledAmountsMST = this.calcVirtualSettlement(
            _amount,
            _amountCur,
            currencyCode,
            transAmountMSTInclVAT,
            totalSettledAmountsMST,
            mapTransAmountsMST,
            mapSettledAmountsMST,
            mapLastSettledAmountsMST,
            mapMapSettledAmountsMST,
            mapUnroundSettledAmountsMST,
            _custVendSettlement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcVirtualSettlementReporting</Name>
				<Source><![CDATA[
    private void calcVirtualSettlementReporting(
        Amount              _amount,
        Amount              _amountCur,
        CustVendSettlement  _custVendSettlement = null)
    {
        mapLastSettledAmountsReporting    = new Map(Types::Container, Types::Container);
        mapUnroundSettledAmountsReporting = new Map(Types::Container, Types::Container);

        totalSettledAmountsReporting = this.calcVirtualSettlement(
            _amount,
            _amountCur,
            reportingCurrencyCode,
            transAmountReportingInclVAT,
            totalSettledAmountsReporting,
            mapTransAmountsReporting,
            mapSettledAmountsReporting,
            mapLastSettledAmountsReporting,
            mapMapSettledAmountsReporting,
            mapUnroundSettledAmountsReporting,
            _custVendSettlement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcVirtualSettlementTransaction</Name>
				<Source><![CDATA[
    private void calcVirtualSettlementTransaction(
        Amount              _amount,
        Amount              _amountCur,
        CustVendSettlement  _custVendSettlement = null)
    {
        mapLastSettledAmountsCur    = new Map(Types::Container, Types::Container);
        mapUnroundSettledAmountsCur = new Map(Types::Container, Types::Container);

        totalSettledAmountsCur = this.calcVirtualSettlement(
            _amount,
            _amountCur,
            mainTrans.CurrencyCode,
            transAmountCurInclVAT,
            totalSettledAmountsCur,
            mapTransAmountsCur,
            mapSettledAmountsCur,
            mapLastSettledAmountsCur,
            mapMapSettledAmountsCur,
            mapUnroundSettledAmountsCur,
            _custVendSettlement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dsName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns data source name.
    /// </summary>
    /// <param name="_tableName">
    /// Name of table.
    /// </param>
    /// <param name="_relationshipType">
    /// Type of relationship to the tax transactions.
    /// </param>
    /// <returns>
    /// A string with name of table and type of relation.
    /// </returns>
    protected str dsName(str _tableName, TaxTransRelationshipType _relationshipType)
    {
        return _tableName + int2str(_relationshipType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillDistributionsFromGeneralJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds distributions from General Journal for given Tax trans record to the list.
    /// </summary>
    /// <param name="_taxTrans">
    /// Tax transactions table record.
    /// </param>
    /// <param name="_list">
    /// The list which a new object should be added to.
    /// </param>
    protected void fillDistributionsFromGeneralJournal(TaxTrans _taxTrans, List _list)
    {
        LedgerDimensionAccount                      ledgerDimension;
        LedgerDimensionAccount                      offsetLedgerDimension;
        TaxTransGeneralJournalAccountEntry          taxTransGeneralJournalAccountEntry;
        GeneralJournalAccountEntry                  generalJournalAccountEntry;

        const SysFlightName SkipTransactionsWithMissingLedgerDimension = 'SkipTransactionsWithMissingLedgerDimension';

        select firstOnly LedgerDimension from taxTransGeneralJournalAccountEntry
                where taxTransGeneralJournalAccountEntry.TaxTrans                   == _taxTrans.RecId
                   && taxTransGeneralJournalAccountEntry.TaxTransRelationship       == TaxTransRelationshipType::Tax
            outer join LedgerDimension from generalJournalAccountEntry
                where taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId;

        ledgerDimension = taxTransGeneralJournalAccountEntry.LedgerDimension != 0 ?
            taxTransGeneralJournalAccountEntry.LedgerDimension :
            generalJournalAccountEntry.LedgerDimension;

        if (!taxTransGeneralJournalAccountEntry)
        {
            LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::findRecId(_taxTrans.SourceRecId, false);

            if (ledgerJournalTrans)
            {
                LedgerJournalTaxDocument ledgerJournalTaxDocument = LedgerJournalTaxDocument::constructForPosting(ledgerJournalTrans.JournalNum, ledgerJournalTrans.Voucher);
                LedgerJournalTaxLine ledgerJournalTaxLine = LedgerJournalTaxLine::construct(ledgerJournalTaxDocument, ledgerJournalTrans, ledgerJournalTaxDocument.getTaxOnPrepayment());
                TaxLedgerAccountGroup taxLedgerAccountGroup = TaxLedgerAccountGroup::find(TaxTable::find(_taxTrans.TaxCode).TaxAccountGroup);
                ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(taxLedgerAccountGroup.taxLedgerDimension(_taxTrans.TaxDirection), ledgerJournalTaxLine.getDefaultDimension());
            }
        }

        select firstOnly LedgerDimension from taxTransGeneralJournalAccountEntry
                where taxTransGeneralJournalAccountEntry.TaxTrans                   == _taxTrans.RecId
                   && taxTransGeneralJournalAccountEntry.TaxTransRelationship       == TaxTransRelationshipType::Offset_RU
            outer join LedgerDimension from generalJournalAccountEntry
                where taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId;

        offsetLedgerDimension = taxTransGeneralJournalAccountEntry.LedgerDimension != 0 ?
            taxTransGeneralJournalAccountEntry.LedgerDimension :
            generalJournalAccountEntry.LedgerDimension;

        if (!isFlightEnabled(SkipTransactionsWithMissingLedgerDimension) || ledgerDimension != 0)
        {
            // Missing ledger dimension means that tax transaction somehow did not make it in ledger - probably due to zero amounts; hence skipping
            _list.addEnd(new CustVendTransCorrespondentDistribution(ledgerDimension, offsetLedgerDimension, 1));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillDistributionsFromSublegder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds distributions from Subledger for given Tax trans record to the list.
    /// </summary>
    /// <param name="_taxTrans">
    /// Tax transactions table record.
    /// </param>
    /// <param name="_list">
    /// The list which a new object should be added to.
    /// </param>
    protected void fillDistributionsFromSublegder(TaxTrans _taxTrans, List _list)
    {
        AccountingDistribution                      distribution;
        AccountingDistribution                      oldDistribution;
        LedgerDimensionAccount                      ledgerDimension;
        LedgerDimensionAccount                      offsetLedgerDimension;
        SubledgerJournalAccountEntryDistribution    accountEntryDistribution;
        SubledgerJournalAccountEntry                accountEntry;
        TaxTrans_RU                                 taxTrans_RU;
        void addDistribution()
        {
            _list.addEnd(new CustVendTransCorrespondentDistribution(
                ledgerDimension,
                offsetLedgerDimension,
                oldDistribution.AllocationFactor));
        }
        boolean isDirectTransaction()
        {
            return (!accountEntry.IsCorrection &&
                        ((accountEntry.Side == DebitCredit::Debit  && _taxTrans.TaxAmount > 0 ) ||
                         (accountEntry.Side == DebitCredit::Credit && _taxTrans.TaxAmount < 0))
                    )
                    ||
                    (accountEntry.IsCorrection &&
                        ((accountEntry.Side ==DebitCredit::Debit  && _taxTrans.TaxAmount < 0 ) ||
                         (accountEntry.Side ==DebitCredit::Credit && _taxTrans.TaxAmount > 0))
                    );
        }
        boolean isOffsetTransaction()
        {
            return taxTrans_RU.OffsetLedgerDimension_RU &&
                    (!accountEntry.IsCorrection &&
                        ((accountEntry.Side == DebitCredit::Debit  && _taxTrans.TaxAmount < 0 ) ||
                         (accountEntry.Side == DebitCredit::Credit && _taxTrans.TaxAmount > 0))
                    )
                    ||
                    (accountEntry.IsCorrection &&
                        ((accountEntry.Side ==DebitCredit::Debit  && _taxTrans.TaxAmount > 0 ) ||
                         (accountEntry.Side ==DebitCredit::Credit && _taxTrans.TaxAmount < 0))
                    );
        }

        if (_taxTrans.TaxDirection == TaxDirection::UseTax)
        {
            return;
        }
        taxTrans_RU = _taxTrans.taxTrans_RU();

        // if scheduled batch posting there can be no TaxTransGeneralJournalAccountEntry record
        // see also TaxTransGeneralJournalAccountEntry::create
        while select RecId, AllocationFactor from distribution order by recID
            where distribution.SourceDocumentLine == _taxTrans.SourceDocumentLine &&
                  distribution.AccountingEvent    == AccountingDistribution::getLastSourceDocumentLineEvent(_taxTrans.SourceDocumentLine).RecId
            join TableId from accountEntryDistribution
                where accountEntryDistribution.AccountingDistribution == distribution.RecId
            join ledgerDimension, Side, IsCorrection from accountEntry
                where accountEntry.RecId == accountEntryDistribution.SubledgerJournalAccountEntry
        {
            if (oldDistribution.RecId != distribution.RecID)
            {
                if (oldDistribution.RecId)
                {
                    addDistribution();
                }
                oldDistribution.data(distribution);
            }

            if (isDirectTransaction())
            {
                ledgerDimension = accountEntry.LedgerDimension;
            }
            if (isOffsetTransaction())
            {
                offsetLedgerDimension = accountEntry.LedgerDimension;
            }
        }
        if (oldDistribution.recID)
        {
            addDistribution();
        }

        // if VAT0,  no subledgers exist
        if (!_taxTrans.TaxAmount)
        {
            _list.addEnd(new CustVendTransCorrespondentDistribution(
                (select firstOnly LedgerDimension from TaxTransGeneralJournalAccountEntry
                    where TaxTransGeneralJournalAccountEntry.TaxTrans               == _taxTrans.RecId
                       && TaxTransGeneralJournalAccountEntry.TaxTransRelationship   == TaxTransRelationshipType::Tax
                ).LedgerDimension,
                (select firstOnly LedgerDimension from TaxTransGeneralJournalAccountEntry
                    where TaxTransGeneralJournalAccountEntry.TaxTrans               == _taxTrans.RecId
                       && TaxTransGeneralJournalAccountEntry.TaxTransRelationship   == TaxTransRelationshipType::Offset_RU
                ).LedgerDimension,
                1));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillDistributionsFromTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds distributions from <c>tmpTaxLedgerDimensions</c> for given Tax trans record to the list.
    /// </summary>
    /// <param name="_taxTrans">
    /// Tax transactions table record.
    /// </param>
    /// <param name="_list">
    /// The list which a new object should be added to.
    /// </param>
    protected void fillDistributionsFromTmp(RecID _taxTrans, List _list)
    {
        select tmpTaxLedgerDimensions
            where tmpTaxLedgerDimensions.TaxTrans           == _taxTrans
               && tmpTaxLedgerDimensions.RelationshipType   ==  TaxTransRelationshipType::Tax
            outer join tmpTaxLedgerDimensionsOffset
                where tmpTaxLedgerDimensionsOffset.TaxTrans         == _taxTrans
                   && tmpTaxLedgerDimensionsOffset.RelationshipType ==  TaxTransRelationshipType::Offset_RU;

        _list.addEnd(new CustVendTransCorrespondentDistribution(
            tmpTaxLedgerDimensions.LedgerDimension,
            tmpTaxLedgerDimensionsOffset.LedgerDimension,
            1));
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillTmpTaxTransLedgerDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills temporary tables for unposted tax transaction
    /// </summary>
    protected void fillTmpTaxTransLedgerDimensions()
    {
        if (this.useTmpForTaxTransLedgerDimension())
        {
            tmpTaxLedgerDimensions.fillFromLedgerVoucherObject(ledgerVoucherObject);

            insert_recordset tmpTaxLedgerDimensionsOffset
                (TaxTrans, RelationshipType, LedgerDimension)
            select TaxTrans, RelationshipType, LedgerDimension from tmpTaxLedgerDimensions;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates list of distributions for a given Tax trans record
    /// </summary>
    /// <param name="_taxTrans">
    /// Tax transactions table record.
    /// </param>
    /// <returns>
    /// List of distributions.
    /// </returns>
    protected List getDistributions(TaxTrans _taxTrans)
    {
        List distributions = new List(Types::Class);
        if (this.useTmpForTaxTransLedgerDimension())
        {
            this.fillDistributionsFromTmp(_taxTrans.RecId, distributions);
        }
        else if (_taxTrans.SourceDocumentLine)
        {
            this.fillDistributionsFromSublegder(_taxTrans, distributions);
        }
        else
        {
            this.fillDistributionsFromGeneralJournal(_taxTrans, distributions);
        }
        return distributions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    protected void init(NoYes _useSourceRecId, Query _transAmountsQuery)
    {
        mapTransAmountsMST          = new Map(Types::Container, Types::Container);
        mapTransAmountsCur          = new Map(Types::Container, Types::Container);
        mapTransAmountsReporting    = new Map(Types::Container, Types::Container);

        mapSettledAmountsMST        = new Map(Types::Container, Types::Container);
        mapSettledAmountsCur        = new Map(Types::Container, Types::Container);
        mapSettledAmountsReporting  = new Map(Types::Container, Types::Container);

        mapMapSettledAmountsMST         = new Map(Types::Container, Types::Class);
        mapMapSettledAmountsCur         = new Map(Types::Container, Types::Class);
        mapMapSettledAmountsReporting   = new Map(Types::Container, Types::Class);

        currencyCode            = Ledger::accountingCurrency();
        reportingCurrencyCode   = Ledger::reportingCurrency();

        queryRun                = new QueryRun(this.query());
        queryRunTransAmounts    = new QueryRun(_transAmountsQuery ? _transAmountsQuery : this.queryTransAmountsGet(_useSourceRecId));

        this.fillTmpTaxTransLedgerDimensions();
        this.setQueryRunBuffers(queryRunTransAmounts);
        this.calcTransAmounts();
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryTransAmountsGet</Name>
				<Source><![CDATA[
    private Query queryTransAmountsGet(NoYes _useSourceRecId)
    {
        #ISOCountryRegionCodes
        Query transAmount = this.queryTransAmounts(_useSourceRecId);
        
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoHU, #isoPL]))
        {
            QueryBuildDataSource qBd = transAmount.dataSourceTable(tableNum(TaxTable));
            qBd.addRange(fieldNum(TaxTable,TaxType_W)).value(queryValue(TaxType_W::Other));
        }

        return transAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInvoiceJour</Name>
				<Source><![CDATA[
    protected void initFromInvoiceJour(CustVendInvoiceJour  _custVendInvoiceJour)
    {
        if (mainTrans.TableId)
        {
            select firstonly mainTrans
                where mainTrans.AccountNum == _custVendInvoiceJour.InvoiceAccount &&
                      mainTrans.Invoice    == _custVendInvoiceJour.InvoiceId      &&
                      mainTrans.TransDate  == _custVendInvoiceJour.InvoiceDate    &&
                      mainTrans.Voucher    == _custVendInvoiceJour.LedgerVoucher;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTrans</Name>
				<Source><![CDATA[
    private void initFromTrans(CustVendTrans _custVendTrans)
    {
        mainTrans = _custVendTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMapTransAmounts</Name>
				<Source><![CDATA[
    protected container initMapTransAmounts()
    {
        return [0, 0, 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>mainTrans</Name>
				<Source><![CDATA[
    public CustVendTrans mainTrans()
    {
        return mainTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapLastSettledAmountsCur</Name>
				<Source><![CDATA[
    public Map mapLastSettledAmountsCur()
    {
        return mapLastSettledAmountsCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapLastSettledAmountsMST</Name>
				<Source><![CDATA[
    public Map mapLastSettledAmountsMST()
    {
        return mapLastSettledAmountsMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapLastSettledAmountsReporting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns map mapLastSettledAmountsReporting.
    /// </summary>
    /// <returns>
    /// Returns map mapLastSettledAmountsReporting.
    /// </returns>
    public Map mapLastSettledAmountsReporting()
    {
        return mapLastSettledAmountsReporting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapMapSettledAmountsCur</Name>
				<Source><![CDATA[
    public Map mapMapSettledAmountsCur()
    {
        return mapMapSettledAmountsCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapMapSettledAmountsMST</Name>
				<Source><![CDATA[
    public Map mapMapSettledAmountsMST()
    {
        return mapMapSettledAmountsMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapTransAmountsMST</Name>
				<Source><![CDATA[
    public Map mapTransAmountsMST()
    {
        return mapTransAmountsMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapUnroundSettledAmountsCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns map with settled amounts in transaction currency
    /// </summary>
    /// <returns>
    /// Map with settled amounts in transaction currency
    /// </returns>
    public Map mapUnroundSettledAmountsCur()
    {
        return mapUnroundSettledAmountsCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapUnroundSettledAmountsMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns map with settled amounts in accounting currency
    /// </summary>
    /// <returns>
    /// Map with settled amounts in accounting currency
    /// </returns>
    public Map mapUnroundSettledAmountsMST()
    {
        return mapUnroundSettledAmountsMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        throwOnError = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucherObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// <c>LedgerVoucherObject</c> used as source of ledger dimensions of tax transaction
    /// </summary>
    /// <param name="_value"><c>LedgerVoucherObject</c> used as source of ledger dimensions of tax transaction or null if use saved ledgerdimensions</param>
    /// <returns><c>LedgerVoucherObject</c></returns>
    LedgerVoucherObject parmLedgerVoucherObject(LedgerVoucherObject _value = ledgerVoucherObject)
    {
        ledgerVoucherObject = _value;
        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMapTransAmountsMST</Name>
				<Source><![CDATA[
    public Map parmMapTransAmountsMST(Map _mapTransAmountsMST)
    {
        mapTransAmountsMST = Map::create(_mapTransAmountsMST.pack());
        return mapTransAmountsMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxTransKeyExt</Name>
				<Source><![CDATA[
    public boolean parmTaxTransKeyExt(boolean _taxTransKeyExt = taxTransKeyExt)
    {
        ;
        taxTransKeyExt = _taxTransKeyExt;
        return taxTransKeyExt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmThrowOnError</Name>
				<Source><![CDATA[
    private boolean parmThrowOnError(boolean _throwOnError = throwOnError)
    {
        throwOnError = _throwOnError;
        return throwOnError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseParentSourceDocumentLine</Name>
				<Source><![CDATA[
    public boolean parmUseParentSourceDocumentLine(boolean _value = useParentSourceDocumentLine)
    {
        useParentSourceDocumentLine = _value;
        return useParentSourceDocumentLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>query</Name>
				<Source><![CDATA[
    abstract protected Query query()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryTransAmounts</Name>
				<Source><![CDATA[
    protected Query queryTransAmounts(NoYes _useSourceRecId)
    {
        Query                query = new Query();
        QueryBuildDataSource taxTransDS;
        QueryBuildDataSource qBd;

        qBd = query.addDataSource(tableNum(TaxTrans), tableStr(TaxTrans));
        TaxTrans::addDataSource(qBd, tableNum(TaxTrans_RU), JoinMode::OuterJoin);
        taxTransDS = qBd;
        qBd.addSortField(fieldNum(TaxTrans,TaxCode));

        if (taxTransKeyExt)
        {
            qBd.addSortField(fieldNum(TaxTrans,TaxGroup));
            qBd.addSortField(fieldNum(TaxTrans,TaxItemGroup));
        }

        qBd.addSortField(fieldNum(TaxTrans,TaxAutogenerated));
        qBd.addSortField(fieldNum(TaxTrans,euroTriangulation));
        qBd.addSortField(fieldNum(TaxTrans,TaxDirection));
        qBd.addSortField(fieldNum(TaxTrans,SourceCurrencyCode));
        qBd.addSortField(fieldNum(TaxTrans,Source));

        qBd.addRange(fieldNum(TaxTrans,Voucher)).value(queryValue(mainTrans.Voucher));
        qBd.addRange(fieldNum(TaxTrans,TransDate)).value(queryValue(mainTrans.TransDate));
        qBd.addRange(fieldNum(TaxTrans,TaxOrigin)).value(queryValue(TaxOrigin::Tax));

        if (_useSourceRecId)
        {
            qBd.addRange(fieldNum(TaxTrans,SourceRecId)).value(queryValue(mainTrans.RecId));
        }

        qBd = qBd.addDataSource(tableNum(TaxTable));
        qBd.fetchMode(QueryFetchMode::One2One);
        qBd.joinMode(JoinMode::ExistsJoin);
        qBd.relations(true);

        qBd.addRange(fieldNum(TaxTable,TaxType_W)).value(queryValue(TaxType_W::VAT));
        qBd.addRange(fieldNum(TaxTable,TaxType_W)).value(queryValue(TaxType_W::VATReduced));
        qBd.addRange(fieldNum(TaxTable,TaxType_W)).value(queryValue(TaxType_W::VATZero));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseAmounts</Name>
				<Source><![CDATA[
    private void reverseAmounts(CustVendTransPostingLog_RU _custVendTransPostingLog)
    {
        _custVendTransPostingLog.AmountCur        = -_custVendTransPostingLog.AmountCur;
        _custVendTransPostingLog.AmountMST        = -_custVendTransPostingLog.AmountMST;
        _custVendTransPostingLog.AmountMSTSecond  = -_custVendTransPostingLog.AmountMSTSecond;
        _custVendTransPostingLog.TaxBaseAmountCur = -_custVendTransPostingLog.TaxBaseAmountCur;
        _custVendTransPostingLog.TaxBaseAmountMST = -_custVendTransPostingLog.TaxBaseAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQueryRunBuffers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets table buffers of a query run object.
    /// </summary>
    /// <param name="_queryRun">
    /// Query Run object
    /// </param>
    /// <remarks>
    /// The method can be overriden in descendants to provide additional buffers of temporary tables.
    /// </remarks>
    protected void setQueryRunBuffers(QueryRun _queryRun)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>transAmountMSTInclVAT</Name>
				<Source><![CDATA[
    public AmountMST transAmountMSTInclVAT()
    {
        return transAmountMSTInclVAT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTmpForTaxTransLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if temporary table should be used as source for ledger dimensions
    /// </summary>
    /// <returns>
    /// True if temporary table should be used as source for ledger dimensions; Otherwise false
    /// </returns>
    /// <remarks>
    /// Should return true if data is not saved yet to <c>GeneralJournalAccountEntry</c> but held in voucher
    /// </remarks>
    boolean useTmpForTaxTransLedgerDimension()
    {
        return
            ledgerVoucherObject &&
            ledgerVoucherObject.parmSubledgerVoucher()  == mainTrans.Voucher &&
            ledgerVoucherObject.parmAccountingDate()    == mainTrans.TransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CustVendCalcSettledAmounts_RU construct(Common                _common,
                                                          NoYes                 _useSourceRecId     = NoYes::No,
                                                          boolean               _throwOnError       = true,
                                                          Query                 _transAmountsQuery  = null,
                                                          boolean               _taxTransKeyExt     = false,
                                                          LedgerVoucherObject   _ledgerVoucherObject= null,
                                                          boolean               _useParentSourceDocumentLine = false)
    {
        CustVendCalcSettledAmounts_RU   custVendCalcSettledAmounts;

        switch (_common.TableId)
        {
            case tableNum(CustInvoiceJour) :
                custVendCalcSettledAmounts = new CustVendCalcSettledAmounts_Cust_RU();
                custVendCalcSettledAmounts.initFromInvoiceJour(_common);
                break;

            case tableNum(VendInvoiceJour)  :
                custVendCalcSettledAmounts = new CustVendCalcSettledAmounts_Vend_RU();
                custVendCalcSettledAmounts.initFromInvoiceJour(_common);
                break;

            case tableNum(CustTrans)       :
                custVendCalcSettledAmounts = new CustVendCalcSettledAmounts_Cust_RU();
                custVendCalcSettledAmounts.initFromTrans(_common);
                break;

            case tableNum(VendTrans)       :
                custVendCalcSettledAmounts = new CustVendCalcSettledAmounts_Vend_RU();
                custVendCalcSettledAmounts.initFromTrans(_common);
                break;

            default                        :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        custVendCalcSettledAmounts.parmThrowOnError(_throwOnError);
        custVendCalcSettledAmounts.parmTaxTransKeyExt(_taxTransKeyExt);
        custVendCalcSettledAmounts.parmLedgerVoucherObject(_ledgerVoucherObject);
        custVendCalcSettledAmounts.parmUseParentSourceDocumentLine(_useParentSourceDocumentLine);

        custVendCalcSettledAmounts.init(_useSourceRecId, _transAmountsQuery);

        return custVendCalcSettledAmounts;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>