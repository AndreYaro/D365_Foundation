<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailTransactionServiceAX63</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Application.Instrumentation;
using Microsoft.Dynamics.Commerce.Runtime.Services.CustomerOrder;

/// <summary>
///    The <c>RetailTransactionServiceAX63</c> class is a support class for the <c>CDXRealTimeService</c> class.
/// </summary>
/// <remarks>
///    This class is used for CDX realtime service APIs in AX63.
/// </remarks>
// This is a framework class. Customizing this class may cause problems Real-Time Service in channels.
public class RetailTransactionServiceAX63
{
    private const str dateTimeBeginXmlTag = '<a:DateTime>';
    private const str dateTimeEndXmlTag = '</a:DateTime>';
    private const str offsetBeginXmlTag = '<a:OffsetMinutes>';
    private const str offsetEndXmlTag = '</a:OffsetMinutes>';
    private const str EchoDefaultValue = '__EchoDefaultValue__';
    private const int tableNum_DirOrganization_AX63 = 2978;
    private const int tableNum_DirPerson_AX63 = 2975;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>ValidateServiceClient</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates service client.
    /// </summary>
    /// <param name = "_userName">ID of the RetailTransactionServiceProfile.profileId field.</param>
    /// <param name = "_password">Password for RetailTransactionServiceProfile or RetailStaffTable.</param>
    /// <returns>Validation status and message.</returns>
    public static container ValidateServiceClient(str _userName, str _password)
    {
        // this method is NOT a facade for a method of the interface ITransactionServices
        // NEVER expose this method as part of an interface
        RetailTransactionServiceProfile tsTable;
        RetailStaffTable            rboStaffTable;
        HcmWorker                   hcmWorker;
        HcmPositionWorkerAssignment hcmPositionWorkerAssignment;
        RetailStoreAddressBook      storeAddressBook;
        DirAddressBookParty         addressBookParty;
        RetailStaffExtendedLogon    staffExtendedLogon;
        str message;
        boolean success, isInAddressBook, isUserValid;
        str 256 expectedpassword, hashedPassword, hashedLogonKey;
        container result;

        if (strLen(_userName) == 0)
        {
            message = "@Retail:RetailRealtimeService63UserNameEmptyError";
            success = false;
            result = [success, message, ''];
            return result;
        }
        else if (strLen(_password) == 0)
        {
            message = "@Retail:RetailRealtimeService63PasswordEmptyError";
            success = false;
            result = [success, message, ''];
            return result;
        }

        // Validate the passphrase based on the real time service profile id.
        select firstonly tsTable
            where tsTable.ProfileId == _userName
            && tsTable.IsCustomerRecord == NoYes::Yes;

        if (tsTable)
        {
            expectedpassword = tsTable.RetailTSData;

            if (strLen(expectedpassword) == 0)
            {
                message = strFmt("@Retail:RetailRealtimeService63ExpectedPasswordEmptyError", _userName);
                success = false;
            }
            else if (_password != expectedpassword)
            {
                message = strfmt("@Retail:RetailRealtimeService63ExpectedPasswordEmptyError");
                success = false;
            }
            else if (_password == expectedpassword)
            {
                success = true;
                message = '';
            }
        }
        else
        {
            // Do not return here. The validation should go to staff check if profile is not found.
            message = strFmt("@Retail:RetailRealtimeService63PasswordValidationError", _userName);
            success = false;
        }

        // Validate the passphrase or extended logon key based on the staff id.
        if (!success)
        {
            rboStaffTable = RetailStaffTable::find(_userName);

            if (rboStaffTable)
            {
                // Staff password hash is calculated based on the random salt.
                // Since AX 2012 channel sends clear text password, this can be hashed using the random salt.
                hashedPassword = RetailData::HashUnified(_password, RetailSharedParameters::find(false).StaffPasswordHash, _userName, rboStaffTable.passwordSalt, rboStaffTable.LegacyLocalContext, rboStaffTable.LegacyRegKeyData2Value);
                expectedpassword = rboStaffTable.passwordData;

                if (strLen(expectedpassword) == 0 || !RetailTransactionService::staffIsPasswordValid(hashedPassword, expectedpassword))
                {
                    // If the staff password does not match, check if the logonkey matches.
                    // Extended log on key is hashed using staff table local context.
                    // So this hash should be calculated based on that.
                    select firstonly LogOnData, LogOnType
                    from staffExtendedLogon
                    where staffExtendedLogon.Staff == rboStaffTable.RecId;
                    hashedLogonKey = RetailData::HashData2(_password, RetailSharedParameters::find().StaffPasswordHash, int2str(enum2int(staffExtendedLogon.LogOnType)), RetailStaffTable::localContext());

                    if (RetailTransactionService::staffIsPasswordValid(hashedLogonKey, staffExtendedLogon.LogOnData))
                    {
                        isUserValid = true;
                    }
                    else
                    {
                        isUserValid = false;
                    }
                }
                else if (RetailTransactionService::staffIsPasswordValid(hashedPassword, expectedpassword))
                {
                    isUserValid = true;
                }
                else
                {
                    isUserValid = false;
                }

                if (isUserValid)
                {
                    // Perform address book check only if the password or logon key is valid for the user.
                    hcmWorker = HcmWorker::findByPersonnelNumber(rboStaffTable.StaffId);
                    select Worker from hcmPositionWorkerAssignment
                where hcmPositionWorkerAssignment.Worker == hcmWorker.RecId;

                    isInAddressBook = false;
                    while select AddressBook from storeAddressBook
                where storeAddressBook.AddressBookType == RetailAddressBookType::Employee
                    {
                        select firstonly addressBookParty
                        where addressBookParty.Party == hcmWorker.Person
                        && addressBookParty.AddressBook == storeAddressBook.AddressBook;

                        if (addressBookParty && !rboStaffTable.blocked)
                        {
                            isInAddressBook = true;
                            break;
                        }
                    }

                    if (isInAddressBook)
                    {
                        success = true;
                        message = '';
                    }
                    else
                    {
                        message = strfmt("@Retail:RetailRealtimeService63StaffValidationError", _userName);
                        success = false;
                    }
                }
                else
                {
                    message = strfmt("@Retail:RetailRealtimeService63StaffValidationError", _userName);
                    success = false;
                }
            }
            else
            {
                success = false;
            }
        }

        result = [success, message, ''];

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>activateDevice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Activate the device.
    /// </summary>
    /// <param name="deviceId">
    /// ID of the Device.
    /// </param>
    /// <param name="terminalId">
    /// ID of the terminal.
    /// </param>
    /// <param name="staffId">
    /// ID of the staff.
    /// </param>
    /// <returns>
    /// A container object containing status of activation, error message (if any) and the details of the device - terminal, store
    /// </returns>
    /// <remarks>
    /// Validates the Device with the activation code and generates a token.
    /// </remarks>
    public static container activateDevice(RetailDeviceId _deviceId, RetailTerminalId _terminalId, RetailStaffId _staffId)
    {
        return RetailTransactionServiceDevice::activateDevice63(_deviceId, _terminalId, _staffId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the record in <c>RetailGiftCardTransactions</c> table.
    /// Initially the gift card is marked as reserved.  Call giftCardRelease to clear the reservation.
    /// </summary>
    /// <param name="_cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailGiftCardTransactions.storeId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTransactions.terminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailGiftCardTransactions.staffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailGiftCardTransactions.transactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailGiftCardTransactions.receiptId field.
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <param name="_amountMST">
    /// Value of the RetailGiftCardTransactions.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value of the RetailGiftCardTransactions.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value of the RetailGiftCardTransactions.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTransactions.channel field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container addToGiftCard(     RetailGiftCardId   _cardNumber,
                                               RetailStoreId       _storeId,
                                               RetailTerminalId    _terminalId,
                                               RetailStaffId       _staffId,
                                               RetailTransactionId _transactionId,
                                               RetailReceiptId     _receiptId,
                                               CurrencyCode     _currencyCode,
                                               AmountMST        _amountMST,
                                               str              _transDate,
                                               str              _transTime,
                                               int              _dateSequence = 321,
                                               RetailChannelRecId  _channelId = 0)
    {
        return RetailTransactionService::addToGiftCard( _cardNumber,
                                                        _storeId,
                                                        _terminalId,
                                                        _staffId,
                                                        _transactionId,
                                                        _receiptId,
                                                        _currencyCode,
                                                        _amountMST,
                                                        _transDate,
                                                        _transTime,
                                                        _dateSequence,
                                                        _channelId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>authenticateDevice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Authenticate the device.
    /// </summary>
    /// <param name="deviceId">
    /// ID of the Device.
    /// </param>
    /// <param name="terminalRecId">
    /// terminal record id.
    /// </param>
    /// <param name="activationGuid">
    /// activation GUID separated by dashes and enclosed in braces.
    /// </param>
    /// <returns>
    /// A container object containing status of authentication, error message (if any)
    /// </returns>
    public static container authenticateDevice(RetailDeviceId deviceId, RefRecId terminalRecId, str activationGuid = '')
    {
        RetailDevice device;
        RetailTerminalTable terminal;
        container deviceAuthenticationResponse = [false, "", "", "", ""]; // Status, ErrorMsg, terminalRecId, storeRecId

        device = retailDevice::find(deviceId);
        terminal = RetailTerminalTable::find(device.Terminal);

        if (device)
        {
            if (device.ActivationStatus != RetailDeviceActivationStatusBase::Activated)
            {
                // Device is not in Activated state
                deviceAuthenticationResponse = [false, "@REX4040052"];
            }
            else if (terminalRecId == 0 || terminal.RecId != terminalRecId)
            {
                deviceAuthenticationResponse = [false, "@REX36"];
            }
            else if (activationGuid != '' && activationGuid != guid2str(device.ActivationGuid))
            {
                // Device's current activation GUID is same as the input
                deviceAuthenticationResponse = [false, "@REX36"];
            }
            else
            {
                deviceAuthenticationResponse = [true, "", terminal.RecId, terminal.StoreRecId];
            }
        }
        else
        {
            // Device is not found
            deviceAuthenticationResponse = [false, "@REX30"];
            ApplicationEventSource::EventWriteRetailTransactionServiceAX63Warning(funcName(), 'Invalid device id', deviceId);
        }

        return deviceAuthenticationResponse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels the sales order.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the header, line details and charges, payments associated with the sales order to be canceled.
    /// </param>
    /// <returns>
    /// A container having the status of order cancellation.
    /// </returns>
    public static container cancelCustomerOrder(str custOrderXmlStr)
    {
        return RetailTransactionService::cancelCustomerOrder(custOrderXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDisbursementSlipExist_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the specified disbursement order number exists in Cash transactions.
    /// </summary>
    /// <param name="_storeId">
    /// The rerail store number identifier.
    /// </param>
    /// <param name="_cashDocId">
    /// The disbursement slip number identifier.
    /// </param>
    /// <param name="_amountCur">
    /// Amount in transaction currency.
    /// </param>
    /// <param name="_currencyCode">
    /// Currency code.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date.
    /// </param>
    /// <param name="_custAccount">
    /// Customer account.
    /// </param>
    /// <returns>
    /// A <c>container</c> containing the check result.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message,
    /// 3 - check result status.
    /// </remarks>
    // <GEERU>
    [SysObsolete('Returns in next shift processing is not required in Russia any longer.', false, 13\05\2023)]
    public static container cashDisbursementSlipExist_RU(RetailStoreId _storeId, RCashDocId _cashDocId, AmountCur _amountCur, CurrencyCode _currencyCode, TransDate _transDate, CustAccount _custAccount)
    {
        return RetailTransactionService::cashDisbursementSlipExist_RU(_storeId, _cashDocId, _amountCur, _currencyCode, _transDate, _custAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDisbursementSlipIsUsedInPayment_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the specified disbursement order number is used in payment transactions.
    /// </summary>
    /// <param name="_retailStoreId">
    /// Retail store number identifier.
    /// </param>
    /// <param name="_cashDocId">
    /// Cash slip order ID.
    /// </param>
    /// <returns>
    /// A <c>container</c> containing the check result.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message,
    /// 3 - check result status.
    /// </remarks>
    // <GEERU>
    [SysObsolete('Returns in next shift processing is not required in Russia any longer.', false, 13\05\2023)]
    public static container cashDisbursementSlipIsUsedInPayment_RU(RetailStoreId _retailStoreId, RCashDocId _cashDocId)
    {
        return RetailTransactionService::cashDisbursementSlipIsUsedInPayment_RU(_retailStoreId, _cashDocId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeStoreForTerminal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Change the store for a terminal.
    /// </summary>
    /// <param name="terminalRecId">
    /// RecId of the terminal.
    /// </param>
    /// <param name="storeRecId">
    /// RecId of the store.
    /// </param>
    /// <returns>
    /// A container object containing status and error message (if any)
    /// </returns>
    public static container changeStoreForTerminal(RefRecId terminalRecId, RefRecId storeRecId)
    {
        return RetailTransactionService::changeStoreForTerminal(terminalRecId, storeRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clockIn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers clock-in for the worker specified.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id, where worker makes a time registration.
    /// </param>
    /// <returns>
    /// A container having information whether registration is successful.
    /// </returns>
    /// <remarks>
    /// If time registration fails, returned container will also have error message.
    /// </remarks>
    public static container clockIn(HcmPersonnelNumberId _personnelNumber, RetailTerminalId _terminalId)
    {
        return RetailTransactionService::clockIn(_personnelNumber, _terminalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clockOut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers clock-out for the worker specified.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id, where worker makes a time registration.
    /// </param>
    /// <returns>
    /// A container having information whether registration is successful.
    /// </returns>
    /// <remarks>
    /// If time registration fails, returned container will also have error message.
    /// </remarks>
    public static container clockOut(HcmPersonnelNumberId _personnelNumber, RetailTerminalId _terminalId)
    {
        return RetailTransactionService::clockOut(_personnelNumber, _terminalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertCustomerQuoteToOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a quotation to sales order.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the header, line details and charges, payments associated with the sales order to be created.
    /// </param>
    /// <returns>
    /// A container having the status of quote conversion and salesId of the sales order.
    /// </returns>
    public static container convertCustomerQuoteToOrder(str custOrderXmlStr)
    {
        return RetailTransactionService::convertCustomerQuoteToOrder(custOrderXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAddressExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create address for customer with extended properties.
    /// </summary>
    /// <param name="custAccount">Customer account</param>
    /// <param name="custName">Customer name</param>
    /// <param name="street">Street</param>
    /// <param name="city">City</param>
    /// <param name="county">County</param>
    /// <param name="state">State</param>
    /// <param name="zip">Zip</param>
    /// <param name="country"> Country</param>
    /// <param name="phone">Phone</param>
    /// <param name="email">Email</param>
    /// <param name="url">URL </param>
    /// <param name="taxGroup">Tax group</param>
    /// <param name="role"> Role</param>
    /// <param name="streetNumber">Street number</param>
    /// <param name="districtName">District name</param>
    /// <param name="buildingCompliment">Building compliment</param>
    /// <param name="makePostalAddressPrimary">
    /// Optional. True if this should become the new primary address </param>
    /// <param name="extensionProperties"> Optional. Extension properties XML.</param>
    /// <returns>A container with entity keys</returns>
    /// <remarks>
    /// Original parameter list consisted of a single _paramList parameter of type container.
    /// </remarks>
    public static container createAddressExt(CustAccount                 custAccount,
                                             CustName                    custName,
                                             AddressStreet               street,
                                             AddressCity                 city,
                                             AddressCountyId             county,
                                             AddressStateId              state,
                                             AddressZipCodeId            zip,
                                             AddressCountryRegionId      country,
                                             Phone                       phone,
                                             Email                       email,
                                             URL                         url,
                                             TaxGroup                    taxGroup,
                                             LogisticsLocationRoleType   role,
                                             LogisticsAddressStreetNumber        streetNumber        = '',
                                             LogisticsAddressDistrictName        districtName        = '',
                                             LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                             // preserve default previous version behaviour
                                             boolean                     makePostalAddressPrimary = false,
                                             str                         extensionProperties = '')
    {
        return RetailTransactionServiceAX63::createAddress(
            custAccount,
            custName,
            street,
            city,
            county,
            state,
            zip,
            country,
            phone,
            email,
            url,
            taxGroup,
            role,
            streetNumber,
            districtName,
            buildingCompliment,
            makePostalAddressPrimary);
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating an existing customer, with extension properties.
    /// </summary>
    /// <param name="custTableRecId">CustTable RecId.</param>
    /// <param name="custName">Customer Name.</param>
    /// <param name="custGroup"> Customer group</param>
    /// <param name="currency">Currency</param>
    /// <param name="languageId">Language ID</param>
    /// <param name="phone">Phone</param>
    /// <param name="phoneRecId">Phone recid</param>
    /// <param name="cellularPhone">Cell phone</param>
    /// <param name="email"> Email</param>
    /// <param name="emailRecId">Email recid</param>
    /// <param name="url">URL</param>
    /// <param name="urlRecId">Url recid</param>
    /// <param name="multiLineDisc">Multiline discount</param>
    /// <param name="endDisc">End discount</param>
    /// <param name="lineDisc">Line discount</param>
    /// <param name="priceGroup">Price Group</param>
    /// <param name="taxGroup"> Tax Group</param>
    /// <param name="creditMax">Credit Max</param>
    /// <param name="blocked">Blocked</param>
    /// <param name="orgId">Org ID</param>
    /// <param name="usePurchRequest">Use purchase request</param>
    /// <param name="vatNum">Vat Number</param>
    /// <param name="invoiceAccount">Invoice account</param>
    /// <param name="mandatoryCreditLimit">Mandotory credit limit</param>
    /// <param name="contactPersonId">]Contact person ID</param>
    /// <param name="useOrderNumberReference">Use order number reference </param>
    /// <param name="receiptOption">Receipt option</param>
    /// <param name="receiptEmail">Receipt Email</param>
    /// <param name="identificationNumber">Identification Number</param>
    /// <param name="firstName">First name</param>
    /// <param name="middleName">Middle name</param>
    /// <param name="lastName">Last name</param>
    /// <param name="phoneExtension">Phone extension</param>
    /// <param name="cellphoneRecId">Cell phone record id</param>
    /// <param name="retailCustAffiliations">A XML string having the details of customer affiliation list</param>
    /// <param name="doNotContact">Do not contact</param>
    /// <param name="extensionProperties">Optional. Extension properties XML.</param>
    /// <returns>Results in container.</returns>
    public static container updateCustomerExt(int64                    custTableRecId,
                                              DirPartyName                custName,
                                              CustGroupId                 custGroup,
                                              CustCurrencyCode            currency,
                                              CustLanguageId              languageId,
                                              Phone                       phone,
                                              int64                       phoneRecId,
                                              PhoneMobile                 cellularPhone,
                                              LogisticsElectronicAddressLocator  email,
                                              int64                       emailRecId,
                                              URL                         url,
                                              int64                       urlRecId,
                                              CustMultiLineDiscCode       multiLineDisc,
                                              CustEndDiscCode             endDisc,
                                              CustLineDiscCode            lineDisc,
                                              CustPriceGroup              priceGroup,
                                              TaxGroup                    taxGroup,
                                              CustCreditMaxMST            creditMax,
                                              CustBlocked                 blocked,
                                              OrgId                       orgId,
                                              RetailUsePurchRequest       usePurchRequest,
                                              VATNum                      vatNum,
                                              CustInvoiceAccount          invoiceAccount,
                                              MandatoryCreditLimit        mandatoryCreditLimit,
                                              ContactPersonId             contactPersonId,
                                              RetailUseOrderNumberReference  useOrderNumberReference,
                                              RetailReceiptOption            receiptOption,
                                              RetailReceiptEmail             receiptEmail,
                                              CustIdentificationNumber    identificationNumber,
                                              FirstName firstName = '',
                                              MiddleName middleName = '',
                                              LastName lastName = '',
                                              PhoneLocal phoneExtension = '',
                                              int64 cellphoneRecId = 0,
                                              str retailCustAffiliations = '',
                                              NoYesId doNotContact = NoYes::No,
                                              str extensionProperties = '')
    {
        return RetailTransactionServiceAX63::updateCustomer(
            custTableRecId,
            custName,
            custGroup,
            currency,
            languageId,
            phone,
            phoneRecId,
            cellularPhone,
            email,
            emailRecId,
            url,
            urlRecId,
            multiLineDisc,
            endDisc,
            lineDisc,
            priceGroup,
            taxGroup,
            creditMax,
            blocked,
            orgId,
            usePurchRequest,
            vatNum,
            invoiceAccount,
            mandatoryCreditLimit,
            contactPersonId,
            useOrderNumberReference,
            receiptOption,
            receiptEmail,
            identificationNumber,
            firstName,
            middleName,
            lastName,
            phoneExtension,
            cellphoneRecId,
            retailCustAffiliations);
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAddressExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update address, implementation with extension properties.
    /// </summary>
    /// <param name="addressRecId">Address RecId</param>
    /// <param name="custName">Customer Name</param>
    /// <param name="street">Street</param>
    /// <param name="city">City</param>
    /// <param name="county">County</param>
    /// <param name="state">State</param>
    /// <param name="zip">Zip</param>
    /// <param name="country">Country</param>
    /// <param name="phone">Phone</param>
    /// <param name="email">Email</param>
    /// <param name="url">URL </param>
    /// <param name="taxGroup">Tax group</param>
    /// <param name="role">Role</param>
    /// <param name="phoneRecId">Phone RecId</param>
    /// <param name="emailRecId">Email RecId</param>
    /// <param name="urlRecId">URL RecId</param>
    /// <param name="streetNumber">Street Number </param>
    /// <param name="districtName">District Name</param>
    /// <param name="buildingCompliment">Building Complement</param>
    /// <param name="makePostalAddressPrimary">Optional. True if this should become the new primary address</param>
    /// <param name="extensionProperties">Optional. Extension properties XML. </param>
    /// <returns>A container with entity keys</returns>
    /// <remarks>
    /// Original parameter list consisted of a single _paramList parameter of type container.
    /// </remarks>
    public static container updateAddressExt(RefRecId                    addressRecId,
                                             CustName                    custName,
                                             AddressStreet               street,
                                             AddressCity                 city,
                                             AddressCountyId             county,
                                             AddressStateId              state,
                                             AddressZipCodeId            zip,
                                             AddressCountryRegionId      country,
                                             Phone                       phone,
                                             LogisticsElectronicAddressLocator  email,
                                             URL                         url,
                                             TaxGroup                    taxGroup,
                                             LogisticsLocationRoleType   role,
                                             int64                       phoneRecId,
                                             int64                       emailRecId,
                                             int64                       urlRecId,
                                             LogisticsAddressStreetNumber        streetNumber        = '',
                                             LogisticsAddressDistrictName        districtName        = '',
                                             LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                             boolean                     makePostalAddressPrimary    = false,
                                             str                         extensionProperties = '')
    
    {
        return RetailTransactionServiceAX63::updateAddress(
            addressRecId,
            custName,
            street,
            city,
            county,
            state,
            zip,
            country,
            phone,
            email,
            url,
            taxGroup,
            role,
            phoneRecId,
            emailRecId,
            urlRecId,
            streetNumber,
            districtName,
            buildingCompliment,
            makePostalAddressPrimary);

    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustomerExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating new customer with extension properties.
    /// </summary>
    /// <param name="custName">Customer name.</param>
    /// <param name="custGroup">Customer group</param>
    /// <param name="currency">Currency</param>
    /// <param name="languageId">Language ID</param>
    /// <param name="street">Street</param>
    /// <param name="zipCode">Zip code</param>
    /// <param name="state">State</param>
    /// <param name="county">County</param>
    /// <param name="phone">Phone</param>
    /// <param name="cellularPhone">Cell phone</param>
    /// <param name="email">Email</param>
    /// <param name="url">URL</param>
    /// <param name="multiLineDisc">Multiline discount</param>
    /// <param name="endDisc">End discount</param>
    /// <param name="lineDisc">Line discount</param>
    /// <param name="priceGroup">Price Group</param>
    /// <param name="taxGroup">Tax Group</param>
    /// <param name="creditMax">Credit Max</param>
    /// <param name="blocked">Blocked</param>
    /// <param name="orgId">Org ID</param>
    /// <param name="usePurchRequest">Use purchase request </param>
    /// <param name="vatNum">Vat Number</param>
    /// <param name="invoiceAccount">Invoice account</param>
    /// <param name="mandatoryCreditLimit">Mandotory credit limit</param>
    /// <param name="contactPersonId">Contact person ID</param>
    /// <param name="useOrderNumberReference">Use order number reference</param>
    /// <param name="receiptOption">Receipt option</param>
    /// <param name="receiptEmail">Receipt Email </param>
    /// <param name="city"> City</param>
    /// <param name="country">Country</param>
    /// <param name="identificationNumber">Identification Number </param>
    /// <param name="storeRecId">Store Rec ID</param>
    /// <param name="relationType">Relation Type</param>
    /// <param name="streetNumber">Street Number</param>
    /// <param name="districtName">District Name</param>
    /// <param name="buildingCompliment">Building Complement</param>
    /// <param name="cnpjCpfNum_BR">CNPJ/CPF (Brazilian tax ID)</param>
    /// <param name="addressName">Address Name</param>
    /// <param name="addressType"> Address Type </param>
    /// <param name="addressPhone">Address Phone</param>
    /// <param name="addressEmail">Address Email </param>
    /// <param name="addressUrl">Address URL</param>
    /// <param name="addressTaxGroup">Address Tax group</param>
    /// <param name="firstName">First name</param>
    /// <param name="middleName">Middle name </param>
    /// <param name="lastName">Last name </param>
    /// <param name="phoneExtension">Phone extension</param>
    /// <param name="retailCustAffiliations">A XML string having the details of customer affiliation list</param>
    /// <param name = "doNotContact">Do not contact</param>
    /// <param name="extensionProperties">Optional. Extension properties XML.</param>
    /// <returns>Container with entity keys </returns>
    public static container newCustomerExt(DirPartyName                 custName,
                                           //NameAlias                 custTableAlias,
                                           CustGroupId                 custGroup,
                                           CustCurrencyCode            currency,
                                           CustLanguageId              languageId,
                                           AddressStreet               street,
                                           AddressZipCodeId            zipCode,
                                           AddressStateId              state,
                                           AddressCountyId             county,
                                           Phone                       phone,
                                           PhoneMobile                 cellularPhone,
                                           LogisticsElectronicAddressLocator  email,
                                           URL                         url,
                                           CustMultiLineDiscCode       multiLineDisc,
                                           CustEndDiscCode             endDisc,
                                           CustLineDiscCode            lineDisc,
                                           CustPriceGroup              priceGroup,
                                           TaxGroup                    taxGroup,
                                           CustCreditMaxMST            creditMax,
                                           CustBlocked                 blocked,
                                           OrgId                       orgId,
                                           RetailUsePurchRequest       usePurchRequest,
                                           VATNum                      vatNum,
                                           CustInvoiceAccount          invoiceAccount,
                                           MandatoryCreditLimit        mandatoryCreditLimit,
                                           ContactPersonId             contactPersonId,
                                           RetailUseOrderNumberReference  useOrderNumberReference,
                                           RetailReceiptOption            receiptOption,
                                           RetailReceiptEmail             receiptEmail,
                                           AddressCity                 city,
                                           AddressCountryRegionId      country,
                                           CustIdentificationNumber    identificationNumber,
                                           int64                       storeRecId,
                                           RelationType                relationType,
                                           LogisticsAddressStreetNumber        streetNumber        = '',
                                           LogisticsAddressDistrictName        districtName        = '',
                                           LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                           CNPJCPFNum_BR                       cnpjCpfNum_BR       = '',
                                           CustName                    addressName = '',
                                           LogisticsLocationRoleType   addressType = LogisticsLocationRoleType::None,
                                           Phone                       addressPhone = '',
                                           LogisticsElectronicAddressLocator addressEmail = '',
                                           URL                         addressUrl = '',
                                           TaxGroup                    addressTaxGroup = '',
                                           FirstName firstName = '',
                                           MiddleName middleName = '',
                                           LastName lastName = '',
                                           PhoneLocal phoneExtension = '',
                                           str retailCustAffiliations = '',
                                           NoYesId doNotContact = NoYes::No,
                                           str extensionProperties = '')
    
    {
        return RetailTransactionServiceAX63::newCustomer(
           custName,
           custGroup,
           currency,
           languageId,
           street,
           zipCode,
           state,
           county,
           phone,
           cellularPhone,
           email,
           url,
           multiLineDisc,
           endDisc,
           lineDisc,
           priceGroup,
           taxGroup,
           creditMax,
           blocked,
           orgId,
           usePurchRequest,
           vatNum,
           invoiceAccount,
           mandatoryCreditLimit,
           contactPersonId,
           useOrderNumberReference,
           receiptOption,
           receiptEmail,
           city,
           country,
           identificationNumber,
           storeRecId,
           relationType,
           streetNumber,
           districtName,
           buildingCompliment,
           cnpjCpfNum_BR,
           addressName,
           addressType,
           addressPhone,
           addressEmail,
           addressUrl,
           addressTaxGroup,
           firstName,
           middleName,
           lastName,
           phoneExtension,
           retailCustAffiliations,
           '',
           '',
           '',
           NoYes::No,
           doNotContact);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create address for customer.
    /// </summary>
    /// <param name="custAccount">
    /// Customer account
    /// </param>
    /// <param name="custName">
    /// Customer name
    /// </param>
    /// <param name="street">
    /// Street
    /// </param>
    /// <param name="city">
    /// City
    /// </param>
    /// <param name="county">
    /// County
    /// </param>
    /// <param name="state">
    /// State
    /// </param>
    /// <param name="zip">
    /// Zip
    /// </param>
    /// <param name="country">
    /// Country
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="taxGroup">
    /// Tax group
    /// </param>
    /// <param name="role">
    /// Role
    /// </param>
    /// <param name="streetNumber">
    /// Street number
    /// </param>
    /// <param name="districtName">
    /// District name
    /// </param>
    /// <param name="buildingCompliment">
    /// Building compliment
    /// </param>
    /// <param name="makePostalAddressPrimary">
    /// Optional. True if this should become the new primary address
    /// </param>
    /// <returns>
    /// A container with entity keys
    /// </returns>
    /// <remarks>
    /// Original parameter list consisted of a single _paramList parameter of type container.
    /// </remarks>
    public static container createAddress(  CustAccount                 custAccount,
                                            CustName                    custName,
                                            AddressStreet               street,
                                            AddressCity                 city,
                                            AddressCountyId             county,
                                            AddressStateId              state,
                                            AddressZipCodeId            zip,
                                            AddressCountryRegionId      country,
                                            Phone                       phone,
                                            Email                       email,
                                            URL                         url,
                                            TaxGroup                    taxGroup,
                                            LogisticsLocationRoleType   role,
                                            LogisticsAddressStreetNumber        streetNumber        = '',
                                            LogisticsAddressDistrictName        districtName        = '',
                                            LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                            // preserve default previous version behaviour
                                            boolean                     makePostalAddressPrimary = false)
    {
        return RetailTransactionServiceCustomer::createAddress(
            custAccount,
            custName,
            street,
            city,
            county,
            state,
            zip,
            country,
            phone,
            email,
            url,
            taxGroup,
            role,
            streetNumber,
            districtName,
            buildingCompliment,
            makePostalAddressPrimary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCashDisbursementSlip_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates cash disbursement slip.
    /// </summary>
    /// <param name="_storeId">
    /// Retail store ID.
    /// </param>
    /// <param name="_currencyCode">
    /// Currency code
    /// </param>
    /// <param name="_amountCur">
    /// Amount in currency
    /// </param>
    /// <param name="_transDate">
    /// Transaction date
    /// </param>
    /// <param name="_custAccount">
    /// Customer account
    /// </param>
    /// <param name="_reasonOfReturn">
    /// Reason of cash return.
    /// </param>
    /// <param name="_represPersonName">
    /// The name of the representative person.
    /// </param>
    /// <param name="_represPersonCardInfo">
    /// Representative person card info.
    /// </param>
    /// <param name="_documentNum">
    /// Document number.
    /// </param>
    /// <param name="_documentDate">
    /// Document date.
    /// </param>
    /// <returns>
    /// A <c>Container</c> holding result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional),
    /// 3 - created disbursement slip ID.
    /// </remarks>
    // <GEERU>
    [SysObsolete('Returns in next shift processing is not required in Russia any longer.', false, 13\05\2023)]
    public static container createCashDisbursementSlip_RU(
        RetailStoreId _storeId,
        CurrencyCode _currencyCode,
        AmountCur _amountCur,
        TransDate _transDate,
        CustAccount _custAccount,
        BankCentralBankPurposeText _reasonOfReturn,
        PersonName _represPersonName,
        PayeeDocument_RU _represPersonCardInfo,
        DocumentNum _documentNum,
        DocumentDate _documentDate)
    
    {
        return RetailTransactionService::createCashDisbursementSlip_RU(
                _storeId, _currencyCode, _amountCur, _transDate, _custAccount, _reasonOfReturn, _represPersonName, _represPersonCardInfo, _documentNum, _documentDate);
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a customer order from the given details.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the header, line details and charges, payments associated with the sales order to be created.
    /// </param>
    /// <returns>
    /// A container having the status and sales id of the order created.
    /// </returns>
    public static container createCustomerOrder(str custOrderXmlStr)        
    {
        str updatedCustOrderXmlStr = RetailTransactionServiceAX63::adjustCustomerOrder(custOrderXmlStr, true, true);
        
        return RetailTransactionService::createCustomerOrder(updatedCustOrderXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerQuote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a sales quotation from the given details.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the header, line details and charges associated with the quote to be created.
    /// </param>
    /// <returns>
    /// A container having the status and quotation id of the quotation created.
    /// </returns>
    public static container createCustomerQuote(str custOrderXmlStr)
    {
        str updatedCustOrderXmlStr = RetailTransactionServiceAX63::adjustCustomerOrder(custOrderXmlStr);

        return RetailTransactionService::createCustomerQuote(updatedCustOrderXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerReturnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a customer return order from the given details.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the header, line details and charges, payments associated with the retrn order to be created.
    /// </param>
    /// <returns>
    /// A container having the status and sales id of the order created.
    /// </returns>
    public static container createCustomerReturnOrder(str custOrderXmlStr)
    {
        str updatedCustOrderXmlStr = RetailTransactionServiceAX63::adjustCustomerOrder(custOrderXmlStr, true);

        updatedCustOrderXmlStr = RetailTransactionServiceAX63::adjustCustomerReturnOrder(custOrderXmlStr);

        return RetailTransactionService::createCustomerReturnOrder(updatedCustOrderXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createExtendedLogOn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a record in <c>RetailStaffExtendedLogOn</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// Staff ID.
    /// </param>
    /// <param name="_logOnKey">
    /// LogOn key.
    /// </param>
    /// <param name="_logOnType">
    /// LogOn key type.
    /// </param>
    /// <param name="_extraData">
    /// Device specific extra data as base 64 string.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container createExtendedLogOn(RetailStaffId _staffId, RetailStaffExtendedLogOnKey _logOnKey, RetailStaffExtendedLogOnType _logOnType, str _extraData)
    {
        return RetailTransactionService::createExtendedLogOn(_staffId, _logOnKey, _logOnType, _extraData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventoryJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an inventory journal.
    /// </summary>
    /// <param name="inventLocationId">
    /// Identification of the warehouse.
    /// </param>
    /// <param name="description">
    /// Description of the journal.
    /// </param>
    /// <param name="source">
    /// Inventory journal source.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the creation of record is successful; else false and appropriate xml string.
    /// </returns>
    public static container createInventoryJournal(InventLocationId inventLocationId, JournalDescription description = '', InventJournalSource source = '')
    {
        return RetailTransactionService::createInventoryJournal(inventLocationId, description, source);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPackingSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the PackingSlip for sales order transaction.
    /// </summary>
    /// <param name="_salesId">
    /// ID of the SalesTable.SalesId field.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse for which to create the packing list.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the value true and empty string if the PackingSlip creation is success; else false wih the appropriate string message.
    /// </returns>
    public static container createPackingSlip(SalesId _salesId, InventLocationId _inventLocationId = '')
    {
        RetailStoreTable retailstore;
        SalesTable salesTable;

        if (!_inventLocationId)
        {
            salesTable = SalesTable::find(_salesId);
            _inventLocationId = salesTable.InventLocationId;
        }

        select firstonly retailstore where
           (retailstore.inventLocation == _inventLocationId || retailstore.InventLocationIdForCustomerOrder == _inventLocationId)
            && retailstore.inventLocationDataAreaId == curExt();

        return RetailTransactionService::createPackingSlipFromChannel(_salesId, retailstore.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPickingList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the PickingList for sales order transaction.
    /// </summary>
    /// <param name="_salesId">
    /// ID of the SalesTable.SalesId field.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse for which to create the picking list.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the value true and empty string if the PickingList creation is success; else false wih the appropriate string message.
    /// </returns>
    public static container createPickingList(SalesId _salesId, InventLocationId _inventLocationId)
    {
        RetailStoreTable retailstore;

        select firstonly retailstore where
            (retailstore.inventLocation == _inventLocationId || retailstore.InventLocationIdForCustomerOrder == _inventLocationId)
            && retailstore.inventLocationDataAreaId == curExt();

        return RetailTransactionService::createPickingListFromChannel(_salesId, retailstore.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPickListForCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates picking list for the given items.
    /// </summary>
    /// <param name="paramList">
    /// XML string having the items and pickup quantity details.
    /// </param>
    /// <returns>
    /// A container having the status of Pick list creation.
    /// </returns>
    public static container createPickListForCustomerOrder(container paramList)
    {
        return RetailTransactionService::createPickListForCustomerOrder(paramList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWishList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a wish list.
    /// </summary>
    /// <param name="wishListXml">
    /// The input xml string containing the wish list field information.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the creation of record is successful and false otherwise.
    /// </returns>
    public static container createWishList(str wishListXml)
    {
        return RetailTransactionService::createWishList(wishListXml);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWishListLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a wish list line.
    /// </summary>
    /// <param name="wishListLineXml">
    /// The input xml string containing the wish list line field information.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the creation of record is successful and false otherwise.
    /// </returns>
    public static container createWishListLine(str wishListLineXml)
    {
        return RetailTransactionService::createWishListLine(wishListLineXml, '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>dateToDateTimeStringWithOffset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Convert a date value to a standard datetime string format plus offset based on timezone setting of the current leagl entity.
    /// </summary>
    /// <param name="theDate">
    /// Date to convert to string with osffset.
    /// </param>
    /// <param name="channelId">
    /// Retail channel identifier.
    /// </param>
    /// <returns>
    /// Date in string format "dd-mm-yyyy" + OffsetMinutes.
    /// </returns>
    public static str dateToDateTimeStringWithOffset(date theDate, RecId channelId)
    {
        str dateTimeStr, offsetStr;
        Timezone tz;
        utcDateTime convertedUtcDateTime;
        RetailChannelTable retailChannelTable;
        
        dateTimeStr = dateTimeBeginXmlTag + RetailTransactionServiceAX63::dateToString(theDate) + dateTimeEndXmlTag;
        
        select ChannelTimeZone from retailChannelTable
        where retailChannelTable.RecId == channelId;
        tz = retailChannelTable.ChannelTimeZone;
        
        convertedUtcDateTime = Global::datetobeginUtcDateTime(theDate, tz);
        offsetStr = offsetBeginXmlTag + int2str(DateTimeUtil::getTimeZoneOffset(convertedUtcDateTime, tz)) + offsetEndXmlTag;
        
        return dateTimeStr + offsetStr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dateToString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Convert date to a standard string format.
    /// </summary>
    /// <param name="theDate">
    /// Date to convert to string.
    /// </param>
    /// <returns>
    /// Date in string format "dd-mm-yyyy".
    /// </returns>
    public static str dateToString(TransDate theDate)
    {
        return date2str(
                theDate,
                321,
                DateDay::Digits2,
                DateSeparator::Hyphen, // separator1
                DateMonth::Digits2,
                DateSeparator::Hyphen, // separator2
                DateYear::Digits4,
                DateFlags::None);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deactivateAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for deactivating a record in <c>LogisticsPostalAddress</c> table.
    /// </summary>
    /// <param name="addressRecId">
    /// The LogisticsPostalAddress Record Id.
    /// </param>
    /// <param name="custTableRecId">
    /// The CUSTTABLE Record Id.
    /// </param>
    /// <returns>
    /// Success or failure result.
    /// </returns>
    /// <remarks>
    /// Updates the ValidTo date making the record no longer valid.
    /// </remarks>
    public static container deactivateAddress(RefRecId addressRecId, RefRecId custTableRecId)
    {
        return RetailTransactionServiceCustomer::deactivateAddress(addressRecId, custTableRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deactivateDevice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Activate the device.
    /// </summary>
    /// <param name="deviceId">
    /// ID of the Device.
    /// </param>
    /// <param name="terminalId">
    /// ID of the terminal.
    /// </param>
    /// <param name="staffId">
    /// ID of the staff.
    /// </param>
    /// <returns>
    /// A container object containing status of activation, error message (if any) and the details of the device - terminal, store
    /// </returns>
    /// <remarks>
    /// Validates the Device with the activation code and generates a token.
    /// </remarks>
    public static container deactivateDevice(RetailDeviceId deviceId, RetailTerminalId terminalId, RetailStaffId staffId)
    {
        return RetailTransactionServiceDevice::deactivateDevice(deviceId, terminalId, staffId, '', false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteExtendedLogOn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove records from <c>RetailStaffExtendedLogOn</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// Staff ID.
    /// </param>
    /// <param name="_logOnType">
    /// LogOn key type.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container deleteExtendedLogOn(RetailStaffId _staffId, RetailStaffExtendedLogOnType _logOnType)
    {
        return RetailTransactionService::deleteExtendedLogOn(_staffId, _logOnType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInventoryJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete a journal record from <c>InventJournalTable</c> and <c>InventJournalTrans</c> tables.
    /// </summary>
    /// <param name="_journalId">
    /// The journal ID of the journal record to be deleted.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the delete of record is successful and false otherwise.
    /// </returns>
    public static container deleteInventoryJournal(InventJournalId _journalId)
    {
        return RetailTransactionService::deleteInventoryJournal(_journalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWishList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a wish list.
    /// </summary>
    /// <param name="wishListId">
    /// The id of the wish list to be deleted.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the delete of record is successful and false otherwise.
    /// </returns>
    public static container deleteWishList(RecId wishListId)
    {
        return RetailTransactionService::deleteWishList(wishListId, '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWishListLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a wish list line.
    /// </summary>
    /// <param name="lineId">
    /// The id of the line to be deleted.
    /// </param>
    /// <param name="wishListId">
    /// The id of the list to be deleted.  This is only used if line id is 0.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the delete of record is successful and false otherwise.
    /// </returns>
    public static container deleteWishListLine(RecId lineId, RefRecId wishListId)
    {
        return RetailTransactionService::deleteWishListLine(lineId, wishListId, '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>echoRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// An echo method that respond with a container of the first ten string parameters.
    /// </summary>
    /// <param name="parameter0">
    /// Parameter 0.
    /// </param>
    /// <param name="parameter1">
    /// Parameter 1.
    /// </param>
    /// <param name="parameter2">
    /// Parameter 2.
    /// </param>
    /// <param name="parameter3">
    /// Parameter 3.
    /// </param>
    /// <param name="parameter4">
    /// Parameter 4.
    /// </param>
    /// <param name="parameter5">
    /// Parameter 5.
    /// </param>
    /// <param name="parameter6">
    /// Parameter 6.
    /// </param>
    /// <param name="parameter7">
    /// Parameter 7.
    /// </param>
    /// <param name="parameter8">
    /// Parameter 8.
    /// </param>
    /// <param name="parameter9">
    /// Parameter 9.
    /// </param>
    /// <returns>
    /// A container of the first 10 parameters.
    /// </returns>
    /// <remarks>
    /// This method serves as a test hook.
    /// </remarks>
    public static container echoRequest(str parameter0 = EchoDefaultValue,
                                        str parameter1 = EchoDefaultValue,
                                        str parameter2 = EchoDefaultValue,
                                        str parameter3 = EchoDefaultValue,
                                        str parameter4 = EchoDefaultValue,
                                        str parameter5 = EchoDefaultValue,
                                        str parameter6 = EchoDefaultValue,
                                        str parameter7 = EchoDefaultValue,
                                        str parameter8 = EchoDefaultValue,
                                        str parameter9 = EchoDefaultValue)
    {
        return RetailTransactionService::echoRequest(parameter0, parameter1, parameter2, parameter3, parameter4, parameter5, parameter6, parameter7, parameter8, parameter9);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChannelSalesOrderDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get channel appropriate details for a sales order
    /// </summary>
    /// <param name="salesId">
    /// Sales Id of the sales order to retrieve
    /// </param>
    /// <param name="channelId">
    /// The channel id where the sales order originated
    /// </param>
    /// <param name="channelRefId">
    /// The channel reference id of the sales order to retrieve
    /// </param>
    /// <returns>
    /// container: [succees, errormessage, xml]
    /// </returns>
    /// <remarks>
    /// success = True if the sales order was retrieved successfully, false otherwise
    /// errormessage = empty if success == True, otherwise an error message
    /// xml = xml document describing the sales order
    /// </remarks>
    public server static container getChannelSalesOrderDetail(SalesId salesId, RefRecId channelId, RetailOrderChannelReferenceId channelRefId = "")
    {
        return RetailTransactionService::getChannelSalesOrderDetail(salesId, channelId, channelRefId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get credit memo balance and currency code.
    /// </summary>
    /// <param name="dataEntryId">
    /// Credit memo identifier (RetailCreditVoucherTable.entryId field).
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    public static container getCreditMemo(RetailDataEntryId dataEntryId)
    {
        return RetailTransactionService::getCreditMemo(dataEntryId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customer details for a given customer account.
    /// </summary>
    /// <param name="custAccount">
    /// The value of CustAccount for which customer details has to be fetched.
    /// </param>
    /// <returns>
    /// A container having the customer details in a XML string.
    /// </returns>
    public static container getCustomer(CustAccount custAccount)
    {
        return RetailTransactionService::getCustomer(custAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method will retrive the customer account balance.
    /// </summary>
    /// <param name="_accountNum">
    /// The account for which we want the balance and credit limit.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency used to return the balance in.
    /// </param>
    /// <param name="_storeId">
    /// The store id of the store where this call originates from.
    /// </param>
    /// <returns>
    /// A container that contains the account balance, account credit limit, invoice account balance, invoice account credit limit.
    /// In addition returns the maximum counter of the payment transactions that we pulled in Ax form the store.
    /// </returns>
    /// <remarks>
    /// If the customer has also an invoice account, it will return
    /// the balance and the credit limit for that account too.
    /// The counter is used in POS to help identify the local transactions
    /// that were not yet pulled in AX.
    /// </remarks>
    public static container getCustomerBalance(AccountNum _accountNum, CurrencyCode _currencyCode, RetailStoreId _storeId)
    {
        return RetailTransactionService::getCustomerBalance(_accountNum, _currencyCode, _storeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get customer history summary and sales orders
    /// </summary>
    /// <param name="_customerId">
    /// CustAccount id for the customer
    /// </param>
    /// <param name="_historyType">
    /// How much history to return
    /// </param>
    /// <returns>
    /// XML document containing history summary and list of sales orders
    /// </returns>
    /// <remarks>
    /// Returns a summary of history activity and list of sales orders for the configured period (30, 60, 90 days)
    /// </remarks>
    public static server container getCustomerHistory(CustAccount _customerId, RetailCustomerHistoryType _historyType = RetailCustomerHistoryType::Days30)
    {
        return RetailTransactionService::getCustomerHistory(_customerId, _historyType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customer order for the given Id.
    /// </summary>
    /// <param name="_salesId">
    /// Value of the SalesId for which order needs to be fetched.
    /// </param>
    /// <param name="includeOnlineOrders">
    /// whether or not to include online orders in the search
    /// </param>
    /// <returns>
    /// A container having the order details in a XML string.
    /// </returns>
    public static container getCustomerOrder(SalesId _salesId, boolean includeOnlineOrders = false)
    {
        return RetailTransactionService::getCustomerOrder(_salesId, includeOnlineOrders);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerOrderList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customer order details for the given customer.
    /// </summary>
    /// <param name="_custAccount">
    /// Customer account number.
    /// </param>
    /// <param name="_startDate">
    /// The starting date to return orders (default is DateTimeUtil::minValue).
    /// </param>
    /// <param name="_endDate">
    /// The starting date to return orders (default is today's date).
    /// </param>
    /// <param name="_resultsMaxCount">
    /// The maximum amount of rows to return (default is 100).
    /// </param>
    /// <param name="_includeQuotes">
    /// Whether or not quotes should be included in the results (default is False, quotes are not included).
    /// </param>
    /// <returns>
    /// A container having the customer order details for the given customer.
    /// </returns>
    public static container getCustomerOrderList(CustAccount _custAccount, str _startDate = "", str _endDate = "", int _resultsMaxCount = 100, boolean _includeQuotes = false)
    {
        return RetailTransactionService::getCustomerOrderList(_custAccount, _startDate, _endDate, _resultsMaxCount, _includeQuotes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerOrdersForPackSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get customer orders for pack slip creation
    /// </summary>
    /// <param name="_custAccount">
    /// Customer account
    /// </param>
    /// <returns>
    /// list of customer orders
    /// </returns>
    /// <remarks>
    /// Retrieves a list of all customer orders for the given customer which are available for packslip creation.
    /// </remarks>
    public static container getCustomerOrdersForPackSlip(CustAccount _custAccount)
    {
        return RetailTransactionService::getCustomerOrdersForPackSlip(_custAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerQuote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the quotation for the given Quotation Id.
    /// </summary>
    /// <param name="_quotationId">
    /// Value of the QuotationId for which quote needs to be fetched.
    /// </param>
    /// <returns>
    /// A container having the quote details in a XML string.
    /// </returns>
    public static container getCustomerQuote(QuotationIdBase _quotationId)
    {
        return RetailTransactionService::getCustomerQuote(_quotationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEFDocumentXML_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a list of Electronic Fiscal Documents on XML format.
    /// </summary>
    /// <param name="_startDate">
    /// The start of the range date.
    /// </param>
    /// <param name="_endDate">
    /// The end of the range date.
    /// </param>
    /// <param name="_fiscalEstablishmentId">
    /// The fiscal establishment from where the fiscal documents should be retrieved from.
    /// </param>
    /// <returns>
    /// A container with a success flag, a comment string, the list of XMLs.
    /// </returns>
    // <GBR>
    public static container getEFDocumentXML_BR(
        TransDate                   _startDate,
        TransDate                   _endDate,
        FiscalEstablishmentId_BR    _fiscalEstablishmentId)
    {
        return RetailTransactionService::getEFDocumentXML_BR(_startDate, _endDate, _fiscalEstablishmentId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGenericCustomerData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customer details for a given customer account.
    /// </summary>
    /// <param name="custAccount">
    /// The customer account number for which customer details have to be fetched.
    /// </param>
    /// <returns>
    /// A container having the customer details in a XML string. The xml string conforms
    /// to the GenericDatabaseTables schema.
    /// </returns>
    public static container getGenericCustomerData(CustAccount custAccount)
    {
        return RetailTransactionServiceCustomerAX63::getGenericCustomerData(custAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGiftCardBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the status of the gift card.
    /// </summary>
    /// <param name="cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container getGiftCardBalance(RetailGiftCardId cardNumber)
    {
        return RetailTransactionService::getGiftCardBalance(cardNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInfologMessages</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Infolog messages.
    /// </summary>
    /// <param name="fromLine">
    /// Line in the Infolog buffer.
    /// </param>
    /// <returns>
    /// Infolog message.
    /// </returns>
    public static str getInfologMessages(int fromLine)
    {
        str ret = '', currentMsg;
        int toLine, msgStart;
        container infoLogData;
        SysInfologEnumerator infoLogEnumerator;
        
        toLine = Global::infologLine();
        if(toLine > fromLine)
        {
            // Delete the data in the InfoLog from the given line, so that we can add them
            // as part of error structure
            infoLogData = infolog.cut(fromLine + 1, Global::infologLine());
        
            if(infoLogData)
            {
                infoLogEnumerator = SysInfologEnumerator::newData(infoLogData);
        
                while(infoLogEnumerator.moveNext())
                {
                    currentMsg = infoLogEnumerator.currentMessage();
        
                    // trim the tabs and spaces from the begining
                    msgStart = strNFind(currentMsg, '\t ', 1, strLen(currentMsg));
                    currentMsg = msgStart? subStr(currentMsg, msgStart, strLen(currentMsg)) : currentMsg;
        
                    ret += currentMsg + '\n';
                }
            }
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDimValues</Name>
				<Source><![CDATA[
    public static void getInventDimValues(ItemId itemId, InventDim inventDim, XmlElement xmlRecord)
    {
        RetailTransactionService::getInventDimValues(itemId, inventDim, xmlRecord);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get an inventory journal object in XML format
    /// </summary>
    /// <param name="journalId">
    /// A journalID
    /// </param>
    /// <param name="storeId">
    /// A storeId
    /// </param>
    /// <returns>
    /// A container object with the details of a journal object in XML format
    /// </returns>
    /// <remarks>
    /// Get an inventory journal document in XML format
    /// </remarks>
    public server static container getInventJournal(JournalId journalId, InventLocationId storeId)
    {
        return RetailTransactionService::getInventJournal(journalId, storeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventJournals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of inventory journals for stock counting
    /// </summary>
    /// <param name="storeId">
    /// A storeId
    /// </param>
    /// <returns>
    /// A list of inventory journals for stock counting
    /// </returns>
    public server static container getInventJournals(InventLocationId storeId)
    {
        return RetailTransactionService::getInventJournals(storeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetLoyaltyCardRewardPointsStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the reward point status of the loyalty card(s) including Issued, Used, Expired, and Active points.
    /// </summary>
    /// <param name="channelLocalDateStr">
    /// The channel local date in 213 sequence.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_excludeBlocked">
    /// The flag indicating whether to exclude the card status if the card is blocked.
    /// </param>
    /// <param name="_excludeNoTender">
    /// The flag indicating whether to exclude the card status if the card is no tender.
    /// </param>
    /// <param name="_includeRelatedCardsForContactTender">
    /// The flag indicating whether to include the status of the related cards if the given card is contact tender.
    /// </param>
    /// <param name="_includeNonRedeemablePoints">
    /// The flag indicating whether to include non-redeemable points status in the result.
    /// </param>
    /// <param name="_includeActivePointsOnly">
    /// The flag indicating whether to return only the active points; otherwise, returns the status of issued, used and expired points as well.
    /// </param>
    /// <param name="_languageId">
    /// The language ID of the reward point description.
    /// </param>
    /// <returns>
    /// The result container contains [isSuccess, Message, PointStatusXML].
    /// A sample of XML is provided in the source code.
    /// </returns>
    public static container GetLoyaltyCardRewardPointsStatus(
        str channelLocalDateStr,
        RetailLoyaltyCardNumber _cardNumber,
        boolean _excludeBlocked,
        boolean _excludeNoTender,
        boolean _includeRelatedCardsForContactTender,
        boolean _includeNonRedeemablePoints,
        boolean _includeActivePointsOnly,
        LanguageIdAll _languageId = SystemParameters::getSystemLanguageId())
    {
        return RetailTransactionService::GetLoyaltyCardRewardPointsStatus(
                channelLocalDateStr,
                _cardNumber,
                _excludeBlocked,
                _excludeNoTender,
                _includeRelatedCardsForContactTender,
                _includeNonRedeemablePoints,
                _includeActivePointsOnly,
                _languageId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetLoyaltyCardTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get loyalty card transaction
    /// </summary>
    /// <param name="_cardNumber">
    /// The card number.
    /// </param>
    /// <param name="_rewardPointId">
    /// The reward point Id.
    /// </param>
    /// <param name="_top">
    /// The top count, i.e. the number of transactions to get.
    /// </param>
    /// <param name="_skip">
    /// The skip number, i.e. the number of transactions to skip.
    /// </param>
    /// <param name="_calculateTotalCount">
    /// The flag indicating whether the result should contains the total number of the transactions.
    /// </param>
    /// <returns>
    /// A container having the result.
    /// </returns>
    /// <remarks>
    /// The result container contains [isSuccess, Message, xmlResultString].
    /// A sample of the result XML is provided in the source code.
    /// </remarks>
    public static container GetLoyaltyCardTransactions(
        RetailLoyaltyCardNumber _cardNumber,
        RetailLoyaltyRewardPointId _rewardPointId,
        int64 _top = 1,
        int64 _skip = 0,
        boolean _calculateTotalCount = false)
    {
        return RetailTransactionService::GetLoyaltyCardTransactions(_cardNumber, _rewardPointId, _top, _skip, _calculateTotalCount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLoyaltyPointsStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// The function calculates the used, issued, expired points, depending on the table and baseEnum (Used; Issued; Expired).
    /// </summary>
    /// <param name="pLoyaltyCardNo">
    /// ID of the RetailLoyaltyMSRCardTable.cardNumber field.
    /// </param>
    /// <returns>
    /// <c>Container</c> having calculated points.
    /// </returns>
    public static container getLoyaltyPointsStatus(RetailCardNumber    pLoyaltyCardNo)
    {
        return RetailTransactionService::getLoyaltyPointsStatus(pLoyaltyCardNo);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getManagerHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a logbook of time registrations for the manager.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_storeIds">
    /// Ids of stores, where time registration can be viewed (comma separated value CSV of store IDs).
    /// </param>
    /// <param name="_regTypesStr">
    /// The type of time registration (comma separated value CSV of filters - up to 10 len).
    /// </param>
    /// <param name="_fromDate">
    /// Lower bound of the history returned.
    /// </param>
    /// <param name="_toDate">
    /// Upper bound of the history returned.
    /// </param>
    /// <param name="_jobId">
    /// Job Id of the specific break.
    /// </param>
    /// <returns>
    /// A container having history of time registrations.
    /// </returns>
    /// <remarks>
    /// _jobId parameter is used only if _regType == JmgTermRegType::BrkFlowStart, otherwise it will be skipped
    ///  if _regType == JmgTermRegType::BrkFlowStart and _jobId param is empty or not set, the method will return all the records with break activity disregarding the kind of break.
    /// </remarks>
    public static container getManagerHistory(HcmPersonnelNumberId _personnelNumber = '',
                str _storeIds = '',
                str _regTypesStr = '',
                utcDateTime _fromDate = DateTimeUtil::newDateTime(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), 0), // start of the current day
                utcDateTime _toDate = DateTimeUtil::addHours(DateTimeUtil::newDateTime(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), 0), 24), // end of the current day
                JmgJobId _jobId = '')
    {
        return RetailTransactionService::getManagerHistory(_personnelNumber,
                    _storeIds,
                    _regTypesStr,
                    _fromDate,  // start of the current day
                    _toDate,    // end of the current day
                    _jobId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getManagerHistoryUtc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a logbook of time registrations for the manager in UTC time zone.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_storeIds">
    /// Ids of stores, where time registration can be viewed (comma separated value CSV of store IDs).
    /// </param>
    /// <param name="_regTypesStr">
    /// The type of time registration (comma separated value CSV of filters - up to 10 len).
    /// </param>
    /// <param name="_fromDate">
    /// Lower bound of the history returned.
    /// </param>
    /// <param name="_toDate">
    /// Upper bound of the history returned.
    /// </param>
    /// <param name="_jobIds">
    /// Job Ids of the break activities (comma separated value CSV of store IDs).
    /// </param>
    /// <param name="_top">
    /// The top count, i.e. the number of employee activities to get.
    /// </param>
    /// <param name="_skip">
    /// The skip number, i.e. the number of employee activities to skip.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <returns>
    /// A container having history of time registrations.
    /// </returns>
    /// <remarks>
    /// _jobId parameter is used only if _regType == JmgTermRegType::BrkFlowStart, otherwise it will be skipped
    ///  if _regType == JmgTermRegType::BrkFlowStart and _jobId param is empty or not set, the method will return all the records with break activity disregarding the kind of break
    /// </remarks>
    public static container getManagerHistoryUtc(HcmPersonnelNumberId _personnelNumber = '',
                    str _storeIds = '',
                    str _regTypesStr = '',
                    utcdatetime _fromDate = DateTimeUtil::newDateTime(DateTimeUtil::date(DateTimeUtil::getSystemDateTime()), 0), // start of the current date and time (UTC time zone)
                    utcdatetime _toDate = DateTimeUtil::addHours(DateTimeUtil::newDateTime(DateTimeUtil::date(DateTimeUtil::getSystemDateTime()), 0), 24), // end of the current date and time (UTC time zone)
                    str _jobIds = '',
                    int64 _top = 100,
                    int64 _skip = 0,
                    str _orderByField = fieldStr(JmgTermReg, RegDateTime),
                    SortOrder _sortOrder = SortOrder::Descending)
    {
        return RetailTransactionService::getManagerHistoryUtc(_personnelNumber,
                    _storeIds,
                    _regTypesStr,
                    _fromDate, // start of the current day
                    _toDate, // end of the current day
                    _jobIds,
                    _top,
                    _skip,
                    _orderByField,
                    _sortOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberSequenceSeedData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the number sequence seed data for a terminal.
    /// </summary>
    /// <param name="_terminalId">
    /// ID of the terminal.
    /// </param>
    /// <returns>
    /// A container object containing the xml with the available number sequence seed data.
    /// </returns>
    public static container getNumberSequenceSeedData(RetailTerminalId _terminalId)
    {
        return RetailTransactionServiceDevice::getNumberSequenceSeedData(_terminalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpenPurchaseOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of open purchase orders for a location
    /// </summary>
    /// <param name="locationId">
    /// A locationId
    /// </param>
    /// <returns>
    /// A list of purchase orders in XML format in a container object
    /// </returns>
    public static server container getOpenPurchaseOrders(InventLocationId locationId)
    {
        return RetailTransactionService::getOpenPurchaseOrders(locationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpenTransferOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of open transfer orders for a store
    /// </summary>
    /// <param name="inventLocationId">
    /// A inventLocationId
    /// </param>
    /// <returns>
    /// A list of open transfer orders for a store
    /// </returns>
    /// <remarks>
    /// This is to get open transfer orders
    /// </remarks>
    public static server container getOpenTransferOrders(InventLocationId inventLocationId)
    {
        return RetailTransactionService::getOpenTransferOrders(inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderHistoryList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the history of all transactions and orders for a given customer.
    /// </summary>
    /// <param name="_xmlAgrumentString">
    /// XML document containing the arguments for the method call.  See remarks for example.
    /// </param>
    /// <returns>
    /// Collection of orders.
    /// </returns>
    /// <remarks>
    /// Argument xml example:
    ///     <Arguments>
    ///         <CustomerAccountNumber>"1234"</CustomerAccountNumber>
    ///         <IncludeDetails>"true"</IncludeDetails>
    ///         <PagingInfo>
    ///             <Skip>1</Skip>
    ///             <Top>100</Top>
    ///         </PagingInfo>
    ///     </Arguments>
    /// </remarks>
    public static container getOrderHistoryList(str _xmlAgrumentString = '')
    {
        return RetailTransactionServiceTransactionsAX63::getOrderHistoryList(_xmlAgrumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPackingSlips</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list of Packingslip journals for the given location.
    /// </summary>
    /// <param name="_storeId">
    /// Unique identification value of the Inventory location.
    /// </param>
    /// <returns>
    /// A container having the packing slip details in XML string.
    /// </returns>
    public static container getPackingSlips(InventLocationId _storeId)
    {
        return RetailTransactionService::getPackingSlips(_storeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPickingList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the details of a picking list
    /// </summary>
    /// <param name="pickingId">
    /// A pickingId
    /// </param>
    /// <param name="_inventLocationId">
    /// A inventLocationId
    /// </param>
    /// <returns>
    /// A container object containing the details of a picking list
    /// </returns>
    /// <remarks>
    /// The picking list status is still atctive
    /// </remarks>
    public server static container getPickingList(WMSPickingRouteID pickingId, InventLocationId _inventLocationId)
    {
        return RetailTransactionService::getPickingList(pickingId, _inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPickingLists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of picking lists for a store
    /// </summary>
    /// <param name="inventLocationId">
    /// A inventLocationId
    /// </param>
    /// <returns>
    /// A container object containing a list of picking list in XML format
    /// </returns>
    /// <remarks>
    /// These picking lists are for a specific store
    /// </remarks>
    public server static container getPickingLists(InventLocationId inventLocationId)
    {
        return RetailTransactionService::getPickingLists(inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the product details based on item ID range.
    /// </summary>
    /// <param name="_rangeValue">
    /// The range value of the search critieria field for which product details need to be fetched.
    /// </param>
    /// <param name="_includeDataSourceMap">
    /// Whether to include the mapping from data source names to table names.
    /// </param>
    /// <param name="_rangeFieldName">
    /// The search critieria field name.
    /// </param>
    /// <returns>
    /// A container having the product details in a XML string.
    /// </returns>
    public static container getProductData(str _rangeValue, boolean _includeDataSourceMap = false, str _rangeFieldName = 'ItemId')
    {
        return RetailTransactionService::getProductData(_rangeValue, _includeDataSourceMap, _rangeFieldName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsByCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the products by category.
    /// </summary>
    /// <param name="_currentChannelRecId">
    /// The record ID of current channel.
    /// </param>
    /// <param name="_categoryRecId">
    /// The record id of current category.
    /// </param>
    /// <param name="_startPosition">
    /// The starting record position.
    /// </param>
    /// <param name="_pageSize">
    /// The page size.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <param name="_includeTotalCount">
    /// Whether to include total number of records in the return value.
    /// </param>
    /// <param name="_languageId">
    /// The language to search in.
    /// </param>
    /// <param name="_otherChannelRecId">
    /// The record if for other store to search in.
    /// </param>
    /// <param name="_catalogRecId">
    /// The record ID of the catalog to search products from.
    /// </param>
    /// <param name="_attributeRecIdRangeValue">
    /// The attribute record ID range value to filter product attribute values by.
    /// </param>
    /// <returns>
    /// A container having the products in a XML string.
    /// </returns>
    public static container getProductsByCategory(
            RetailChannelRecId  _currentChannelRecId,
            RefRecId            _categoryRecId,
            int64               _startPosition,
            int64               _pageSize,
            str                 _orderByField = 'ItemId',
            SortOrder           _sortOrder = SortOrder::Ascending,
            boolean             _includeTotalCount = false,
            str                 _languageId = '',
            RetailChannelRecId  _otherChannelRecId = 0,
            CatalogRefRecId     _catalogRecId = 0,
            str _attributeRecIdRangeValue = '')
    {
        return RetailTransactionService::getProductsByCategory(
                _currentChannelRecId,
                _categoryRecId,
                _startPosition,
                _pageSize,
                _orderByField,
                _sortOrder,
                _includeTotalCount,
                _languageId,
                _otherChannelRecId,
                _catalogRecId,
                _attributeRecIdRangeValue
            );
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsByKeyword</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the products by keyword search.
    /// </summary>
    /// <param name="_currentChannelRecId">
    /// The record ID of current channel.
    /// </param>
    /// <param name="_keyword">
    /// The keyword to search for.
    /// </param>
    /// <param name="_startPosition">
    /// The starting record position.
    /// </param>
    /// <param name="_pageSize">
    /// The page size.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <param name="_includeTotalCount">
    /// Whether to include total number of records in the return value.
    /// </param>
    /// <param name="_languageId">
    /// The language to search in.
    /// </param>
    /// <param name="_otherChannelRecId">
    /// The record ID of other channel.
    /// </param>
    /// <param name="_catalogRecId">
    /// The record ID of the catalog to search products from.
    /// </param>
    /// <param name="_attributeRecIdRangeValue">
    /// The attribute record ID range value to filter product attribute values by.
    /// </param>
    /// <returns>
    /// A container having the products in a XML string.
    /// </returns>
    public static container getProductsByKeyword(
        RetailChannelRecId _currentChannelRecId,
        str _keyword,
        int64 _startPosition,
        int64 _pageSize,
        str _orderByField = 'ItemId',
        SortOrder _sortOrder = SortOrder::Ascending,
        boolean _includeTotalCount = false,
        str _languageId = '',
        RetailChannelRecId _otherChannelRecId = 0,
        CatalogRefRecId _catalogRecId = 0,
        str _attributeRecIdRangeValue = '')
    {
        return RetailTransactionService::getProductsByKeyword(
                _currentChannelRecId,
                _keyword,
                _startPosition,
                _pageSize,
                _orderByField,
                _sortOrder,
                _includeTotalCount,
                _languageId,
                _otherChannelRecId,
                _catalogRecId,
                _attributeRecIdRangeValue
            );
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the details of a purchase order
    /// </summary>
    /// <param name="purchId">
    /// A purchId
    /// </param>
    /// <param name="inventLocationId">
    /// A inventLocationId
    /// </param>
    /// <returns>
    /// A container object containing the details of a purchase order in XML format
    /// </returns>
    /// <remarks>
    /// This is get an open purchase order
    /// </remarks>
    public static server container getPurchaseOrder(PurchId purchId, InventLocationId inventLocationId = '')
    {
        return RetailTransactionService::getPurchaseOrder(purchId, inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnLocationByInfocode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds return policy and new location for print labels
    /// </summary>
    /// <param name="_returnLocationPrintParameterXmlStr">
    /// XML string of serialized  LSRetailPosis.BusinessLogic.ReturnLocationPrintParameter object
    /// </param>
    /// <returns>
    /// Container with "Status", "ErrorMsg", "print return label" flag and "return location text"
    /// </returns>
    public static container getReturnLocationByInfocode(str _returnLocationPrintParameterXmlStr)
    {
        return RetailTransactionService::getReturnLocationByInfocode(_returnLocationPrintParameterXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnLocationByReasonCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds return policy and new location for print labels
    /// </summary>
    /// <param name="_storeId">
    /// Transaction store id
    /// </param>
    /// <param name="_itemId">
    /// Product id
    /// </param>
    /// <param name="_reasonCodeId">
    /// Return reason code id
    /// </param>
    /// <returns>
    /// Container with "Status", "ErrorMsg", "print return label" flag and "return location text"
    /// </returns>
    public static container getReturnLocationByReasonCode(RetailStoreId _storeId, ItemId _itemId, ReturnReasonCodeId _reasonCodeId)
    {
        return RetailTransactionService::getReturnLocationByReasonCode(_storeId, _itemId, _reasonCodeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnReasonCodes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the reason codes.
    /// </summary>
    /// <returns>
    /// A container having the quote details in a XML string.
    /// </returns>
    public static container getReturnReasonCodes()
    {
        return RetailTransactionService::getReturnReasonCodes();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the container <c>salesInvoice</c> having the data of the <c>CustTrans</c> and <c>CustTable</c>.
    /// </summary>
    /// <param name="_invoiceId">
    /// ID of the CustTrans.Invoice field.
    /// </param>
    /// <returns>
    /// Container <c>salesInvoice</c> having the data of the <c>CustTrans</c> and <c>CustTable</c>.
    /// </returns>
    public static container getSalesInvoice(InvoiceId _invoiceId)
    {
        return RetailTransactionService::getSalesInvoice(_invoiceId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesInvoiceDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the details of a sales invoice
    /// </summary>
    /// <param name="invoiceId">
    /// An invoiceId
    /// </param>
    /// <returns>
    /// A container object containing the details of a sales invoice in XML format
    /// </returns>
    /// <remarks>
    /// This is to get a sales invoice
    /// </remarks>
    public static server container getSalesInvoiceDetail(InvoiceId invoiceId)
    {
        return RetailTransactionServiceOrdersAX63::getSalesInvoiceDetail63(invoiceId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesInvoiceList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method loops the <c>CustTrans</c> table to get the list of the sales invoices.
    /// </summary>
    /// <param name="_custAccount">
    /// ID of the CustTrans.AccountNum field.
    /// </param>
    /// <returns>
    /// Container <c>salesInvoice</c> having the data of the <c>CustTrans</c> and <c>CustTable</c>.
    /// </returns>
    /// <remarks>
    /// RetailTransactionService::getSalesInvoice method returns the container <c>salesInvoice</c> having the data of the <c>CustTrans</c> and
    /// <c>CustTable</c>.
    /// </remarks>
    public static container getSalesInvoiceList(CustAccount _custAccount)
    {
        return RetailTransactionService::getSalesInvoiceList(_custAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesInvoicesBySalesId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of sales invoices for a sales order
    /// </summary>
    /// <param name="_salesId">
    /// A salesId
    /// </param>
    /// <returns>
    /// A container object containing the list of sales invoices in XML format
    /// </returns>
    /// <remarks>
    /// This is to get a list of sales invoices
    /// </remarks>
    public static container getSalesInvoicesBySalesId(SalesId _salesId)
    {
        return RetailTransactionService::getSalesInvoicesBySalesId(_salesId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the container <c>salesOrder</c> having the data of the <c>SalesTable</c> and <c>CustTable</c>.
    /// </summary>
    /// <param name="_salesId">
    /// ID of the SalesTable.SalesId field.
    /// </param>
    /// <returns>
    /// Container <c>salesOrder</c> having the data of the <c>SalesTable</c> and <c>CustTable</c>.
    /// </returns>
    public static container getSalesOrder(SalesId _salesId)
    {
        return RetailTransactionService::getSalesOrder(_salesId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrderDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the details of a sales order
    /// </summary>
    /// <param name="salesId">
    /// A salesId
    /// </param>
    /// <param name="storeId">
    /// A storeId
    /// </param>
    /// <returns>
    /// A container object containing the details of a sales order in XML format
    /// </returns>
    /// <remarks>
    /// This is to get open sales order
    /// </remarks>
    public server static container getSalesOrderDetail(SalesId salesId, InventLocationId storeId)
    {
        return RetailTransactionService::getSalesOrderDetail(salesId, storeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrderList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method loops the <c>SalesTable</c> to get the list of the sales orders.
    /// </summary>
    /// <param name="_custAccount">
    /// ID of the SalesTable.CustAccount field.
    /// </param>
    /// <returns>
    /// Container <c>salesOrder</c> having the data of the <c>SalesTable</c> and <c>CustTable</c>.
    /// </returns>
    public static container getSalesOrderList(CustAccount _custAccount)
    {
        return RetailTransactionService::getSalesOrderList(_custAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrderListForPrepayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method loops the <c>SalesTable</c> to get the list of the sales orders for prepayments.
    /// </summary>
    /// <param name="_custAccount">
    /// ID of the SalesTable.CustAccount field.
    /// </param>
    /// <returns>
    /// Container <c>salesOrder</c> having the data of the <c>SalesTable</c> and <c>CustTable</c>.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container getSalesOrderListForPrepayments(CustAccount _custAccount)
    {
        return RetailTransactionService::getSalesOrderListForPrepayments(_custAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getShipments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the shipping information of delivered sales orders.
    /// </summary>
    /// <param name="salesOrderId">
    /// Sales id of the shipments to get.
    /// </param>
    /// <param name="shipmentId">
    /// Packing slip id of the shipments to get.
    /// </param>
    /// <returns>
    /// A <c>container</c> with success status, error message and xml result of data returned by the query.
    /// </returns>
    /// <remarks>
    /// Method runs the <c>RetailGetShipmentInfo</c> query and forms the xml result of the data.
    /// </remarks>
    public static container getShipments(str salesOrderId = '', str shipmentId = '')
    {
        return RetailTransactionService::getShipments(salesOrderId, shipmentId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTerminalData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the container <c>result</c> with the value RetailTransactionServiceProfile.RetailTSData if the record exists.
    /// </summary>
    /// <param name="_profileId">
    /// ID of the RetailTransactionServiceProfile.profileId field.
    /// </param>
    /// <returns>
    /// Container <c>result</c> with the value RetailTransactionServiceProfile.RetailTSData if the record exists.
    /// </returns>
    public static container getTerminalData(RetailTransactionServiceProfileId _profileId)
    {
        // this method is NOT a facade for a method of the interface ITransactionServices
        // NEVER expose this method as part of an interface
        RetailTransactionServiceProfile tsTable;
        // result, comment, RetailTSData
        container result = [false, '', ''];
        ;
        
        select firstonly tsTable
        where tsTable.ProfileId == _profileId;
        
        if (tsTable)
        {
            result = [true, '', tsTable.RetailTSData];
        }
        
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for retrieving the sales transactions. Performs the following:
    /// 1.Adds transaction details.
    /// 2.Adds item details.
    /// 3.Adds loyalty.
    /// Performs the following validations:
    /// 1.No transactions for the receipt ID.
    /// 2.Too many transactions were found for receipt ID.
    /// </summary>
    /// <param name="receiptId">
    /// ID of the RetailTransactionTable.receiptId field.
    /// </param>
    /// <param name="storeId">
    /// ID of the RetailTransactionTable.store field.
    /// </param>
    /// <param name="terminalId">
    /// ID of the RetailTransactionTable.terminal field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <remarks>
    /// RetailTransactionService.fillTransactionTable method returns the container <c>transTable</c> having the data of the <c>RetailTransactionTable</c>.
    /// RetailTransactionService.fillSalesTrans method returns the container <c>salesTrans</c> having the data of the <c>RetailTransactionSalesTrans</c> table.
    /// RetailTransactionService.fillLoyaltyTrans method returns <c>container</c> with the value in the RetailTransactionLoyaltyPointsTrans.cardNumber field.
    /// </remarks>
    public static container getTransaction( RetailReceiptId   receiptId,
                                            RetailStoreId     storeId    = '',
                                            RetailTerminalId  terminalId = '')
    {
        return RetailTransactionServiceTransactionsAX63::getTransactionByReceiptId(receiptId, storeId, terminalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionByTransactionId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for retrieving the sales transactions. Performs the following:
    /// 1.Adds transaction details.
    /// 2.Adds item details.
    /// 3.Adds loyalty.
    /// Performs the following validation:
    /// 1.No transaction for the transaction ID.
    /// </summary>
    /// <param name="transactionId">
    /// The <c>transactionId</c> field of the <c>RetailTransactionTable</c> table.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container getTransactionByTransactionId(RetailTransactionId transactionId)
    {
        return RetailTransactionService::getTransactionByTransactionId(transactionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the details of a transfer order
    /// </summary>
    /// <param name="transferId">
    /// A transferId
    /// </param>
    /// <param name="inventLocationId">
    /// The invent loation id
    /// </param>
    /// <returns>
    /// A container object containing the details of a transfer order
    /// </returns>
    /// <remarks>
    /// This is to get an open transfer order
    /// </remarks>
    public static container getTransferOrder(InventTransferId transferId, InventLocationId inventLocationId = '')
    {
        return RetailTransactionService::getTransferOrder(transferId, inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWishLists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of wish lists
    /// </summary>
    /// <param name="wishListId">
    /// A wish list id.
    /// </param>
    /// <param name="customerId">
    /// A customer id.
    /// </param>
    /// <param name="favoriteFilter">
    /// Indicates whether or not to filter by favorite.
    /// </param>
    /// <param name="publicFilter">
    /// Indicates whether or not to filter by public.
    /// </param>
    /// <returns>
    /// A list of wish lists matching the parameters
    /// </returns>
    public static container getWishLists(RecId wishListId,
                                         AccountNum customerId,
                                         boolean favoriteFilter,
                                         boolean publicFilter)
    {
        return RetailTransactionService::getWishLists(wishListId, customerId, favoriteFilter, publicFilter);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkerCurrentTimeRegistrationState</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an information about the current worker's time registration status.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id associated with the time registration.
    /// </param>
    /// <returns>
    /// A container having information about the type of latest worker's time registration.
    /// </returns>
    /// <remarks>
    /// If time registration fails, returned container will also have an error message.
    /// </remarks>
    public static container getWorkerCurrentTimeRegistrationState(HcmPersonnelNumberId _personnelNumber, RetailTerminalId _terminalId = '')
    {
        return RetailTransactionService::getWorkerCurrentTimeRegistrationState(_personnelNumber, _terminalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkerHistoryUtc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a history of time registrations for the worker specified in UTC time zone.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_storeId">
    /// Number of the store, where time registration has been made.
    /// </param>
    /// <param name="_fromDate">
    /// Lower bound of the history returned.
    /// </param>
    /// <param name="_toDate">
    /// Upper bound of the history returned.
    /// </param>
    /// <param name="_top">
    /// The top count, i.e. the number of employee activities to get.
    /// </param>
    /// <param name="_skip">
    /// The skip number, i.e. the number of employee activities to skip.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <returns>
    /// A container having history of worker's registrations.
    /// </returns>
    public static container getWorkerHistoryUtc(HcmPersonnelNumberId _personnelNumber,
                                                RetailStoreId _storeId,
                                                utcdatetime _fromDate = DateTimeUtil::newDateTime(DateTimeUtil::date(DateTimeUtil::getSystemDateTime()), 0), // start of the current date and time (UTC time zone)
                                                utcdatetime _toDate = DateTimeUtil::addHours(DateTimeUtil::newDateTime(DateTimeUtil::date(DateTimeUtil::getSystemDateTime()), 0), 24), // end of the current date and time (UTC time zone)
                                                int64 _top = 100,
                                                int64 _skip = 0,
                                                str _orderByField = fieldStr(JmgTermReg, RegDateTime),
                                                SortOrder _sortOrder = SortOrder::Descending)
    {
        return RetailTransactionService::getWorkerHistoryUtc(
                _personnelNumber,
                _storeId,
                _fromDate,
                _toDate,
                _top,
                _skip,
                _orderByField,
                _sortOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>giftCardPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the record in <c>RetailGiftCardTransactions</c> table.
    /// </summary>
    /// <param name="_cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailGiftCardTransactions.storeId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTransactions.terminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailGiftCardTransactions.staffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailGiftCardTransactions.transactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailGiftCardTransactions.receiptId field.
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <param name="_amountMST">
    /// Value of the RetailGiftCardTransactions.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value of the RetailGiftCardTransactions.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value of the RetailGiftCardTransactions.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTransactions.channel field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container giftCardPayment(RetailGiftCardId   _cardNumber,
                                            RetailStoreId       _storeId,
                                            RetailTerminalId    _terminalId,
                                            RetailStaffId       _staffId,
                                            RetailTransactionId _transactionId,
                                            RetailReceiptId     _receiptId,
                                            CurrencyCode     _currencyCode,
                                            AmountMST        _amountMST,
                                            str              _transDate,
                                            str              _transTime,
                                            int              _dateSequence = 321,
                                            RetailChannelRecId  _channelId = 0)
    {
        // Get the channel id from storeid if the channelid is not set
        return RetailTransactionService::giftCardPayment(
            _cardNumber,
            _storeId,
            _terminalId,
            _staffId,
            _transactionId,
            _receiptId,
            _currencyCode,
            _amountMST,
            _transDate,
            _transTime,
            _dateSequence);
    }

]]></Source>
			</Method>
			<Method>
				<Name>giftCardRelease</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used to release a gift card, after it has been issued.
    /// </summary>
    /// <param name="_cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container giftCardRelease(RetailGiftCardId   _cardNumber)
    {
        return RetailTransactionService::giftCardRelease(_cardNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventoryLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for initializing the fields of <c>InventDim</c> with the values of <c>InventDimCombination</c> fields. Method checks for the
    /// available physical inventory.
    /// </summary>
    /// <param name="_itemId">
    /// <c>ItemId</c>
    /// </param>
    /// <param name="_variantId">
    /// ID of the inventDimCombination.RetailVariantId field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fail to initialize the values and on check for the available physical inventory.
    /// </exception>
    public static container inventoryLookup(ItemId _itemId, RetailVariantId _variantId = '')
    {
        return RetailTransactionService::inventoryLookup(_itemId, _variantId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>InventoryLookupOnDate_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for initializing the fields of <c>InventDim</c> with the values of <c>InventDimCombination</c> fields. Method checks for the
    /// on hand inventory on a specific date.
    /// </summary>
    /// <param name="_itemId">
    /// <c>ItemId</c>
    /// </param>
    /// <param name="_variantId">
    /// ID of the inventDimCombination.RetailVariantId field.
    /// </param>
    /// <param name="_transDate">
    /// A <c>string</c> representing the date for the status of the inventory.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fail to initialize the values and on check for the available physical inventory.
    /// </exception>
    public static container InventoryLookupOnDate_BR(   ItemId          _itemId,
                                                        RetailVariantId _variantId,
                                                        TransDate       _transDate)
    {
        return RetailTransactionService::InventoryLookupOnDate_BR(
            _itemId,
            _variantId,
            _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>issueCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the record in <c>RetailCreditVoucherTable</c>.
    /// </summary>
    /// <param name="_storeId">
    /// ID of the RetailCreditVoucherTable.createdInStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailCreditVoucherTable.createdByTerminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailCreditVoucherTable.createdByStaffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailCreditVoucherTable.createdByTransactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailCreditVoucherTable.createdByReceipId field.
    /// </param>
    /// <param name="_lineNum">
    /// ID of the RetailCreditVoucherTable.createdByLineNum field.
    /// </param>
    /// <param name="_currencyCode">
    /// ID of the RetailCreditVoucherTable.currencyCode field.
    /// </param>
    /// <param name="_amountMST">
    /// Value for the RetailCreditVoucherTable.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value for the RetailCreditVoucherTable.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value for the RetailCreditVoucherTable.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container issueCreditMemo(//RetailDataEntryId   _entryId,
                                                   RetailStoreId       _storeId,
                                                   RetailTerminalId    _terminalId,
                                                   RetailStaffId       _staffId,
                                                   RetailTransactionId _transactionId,
                                                   RetailReceiptId     _receiptId,
                                                   RetailLineNum       _lineNum,
                                                   CurrencyCode     _currencyCode,
                                                   AmountMST        _amountMST,
                                                   str              _transDate,//RBOTransDate     _transDate,
                                                   str              _transTime,//RetailTransTime     _transTime)
                                                   int              _dateSequence = 321)
    {
        return RetailTransactionService::issueCreditMemo(
            _storeId,
            _terminalId,
            _staffId,
            _transactionId,
            _receiptId,
            _lineNum,
            _currencyCode,
            _amountMST,
            _transDate,
            _transTime,
            _dateSequence);
    }

]]></Source>
			</Method>
			<Method>
				<Name>issueGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// This issues a gift card that is not reserved to a terminal / store. This is used for supporting POS 5/61/62
    /// To issue a reserved gift card use the method <c>issueReservedGiftCard</c>
    /// </summary>
    /// <param name="_cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailGiftCardTransactions.storeId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTransactions.terminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailGiftCardTransactions.staffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailGiftCardTransactions.transactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailGiftCardTransactions.receiptId field.
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <param name="_amountMST">
    /// Value of the RetailGiftCardTransactions.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value of the RetailGiftCardTransactions.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value of the RetailGiftCardTransactions.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTransactions.channel field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container issueGiftCard( RetailGiftCardId   _cardNumber,
                                           RetailStoreId       _storeId,
                                           RetailTerminalId    _terminalId,
                                           RetailStaffId       _staffId,
                                           RetailTransactionId _transactionId,
                                           RetailReceiptId     _receiptId,
                                           CurrencyCode     _currencyCode,
                                           AmountMST        _amountMST,
                                           str              _transDate,
                                           str              _transTime,
                                           int              _dateSequence = 321,
                                           RetailChannelRecId  _channelId = 0)
    {
        return RetailTransactionService::issueGiftCard(
                                                        _cardNumber,
                                                        _storeId,
                                                        _terminalId,
                                                        _staffId,
                                                        _transactionId,
                                                        _receiptId,
                                                        _currencyCode,
                                                        _amountMST,
                                                        _transDate,
                                                        _transTime,
                                                        _dateSequence,
                                                        _channelId); // Parameter: _reserved. Issue an unlocked gift card. Used for POS5,61,62
    }

]]></Source>
			</Method>
			<Method>
				<Name>IssueLoyaltyCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Issues a loyalty card, and joins the loyalty programs that are associated to the specificed channel.
    /// If channel recId is not provided, joins all available loyalty programs.
    /// </summary>
    /// <param name="_cardNumber">
    /// The card number.
    /// </param>
    /// <param name="_cardTenderType">
    /// The tender type of the loyalty card.
    /// </param>
    /// <param name="_partyRecId">
    /// The record identifier of the party of the card owner.
    /// </param>
    /// <param name="_channelRecId">
    /// The record identifier of the channel where the loyalty card is issued.
    /// </param>
    /// <returns>
    /// A container having the result.
    /// </returns>
    /// <remarks>
    /// The result container contains [isSuccess, Message, cardContainer, cardTierListContainer].
    /// The cardContainer contains [retailLoyaltyCard.RecId, retailLoyaltyCard.CardNumber, retailLoyaltyCard.CardTenderType, retailLoyaltyCard.Party].
    /// The cardTierListContainer contains a list of cardTierContainer.
    /// The cardTierContainer contains [cardTier.RecId, cardTier.Affiliation, cardTier.LoyaltyCard, cardTier.LoyaltyTier, cardTier.ValidFrom, cardTier.ValidTo].
    /// </remarks>
    public static container IssueLoyaltyCard(
        RetailLoyaltyCardNumber _cardNumber = '',
        RetailLoyaltyTenderType _cardTenderType = RetailLoyaltyTenderTypeBase::AsCardTender,
        DirPartyRecId _partyRecId = 0,
        RefRecid _channelRecId = 0)
    {
        return RetailTransactionService::IssueLoyaltyCard(_cardNumber, _cardTenderType, _partyRecId, _channelRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>issueReservedGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the record in <c>RetailGiftCardTransactions</c> table.
    /// Initially the gift card is marked as reserved.  Call giftCardRelease to clear the reservation.
    /// </summary>
    /// <param name="_cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailGiftCardTransactions.storeId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTransactions.terminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailGiftCardTransactions.staffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailGiftCardTransactions.transactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailGiftCardTransactions.receiptId field.
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <param name="_amountMST">
    /// Value of the RetailGiftCardTransactions.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value of the RetailGiftCardTransactions.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value of the RetailGiftCardTransactions.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTransactions.channel field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container issueReservedGiftCard( RetailGiftCardId   _cardNumber,
                                                   RetailStoreId       _storeId,
                                                   RetailTerminalId    _terminalId,
                                                   RetailStaffId       _staffId,
                                                   RetailTransactionId _transactionId,
                                                   RetailReceiptId     _receiptId,
                                                   CurrencyCode     _currencyCode,
                                                   AmountMST        _amountMST,
                                                   str              _transDate,
                                                   str              _transTime,
                                                   int              _dateSequence = 321,
                                                   RetailChannelRecId  _channelId = 0)
    {
        return RetailTransactionService::issueReservedGiftCard(
                                                                _cardNumber,
                                                                _storeId,
                                                                _terminalId,
                                                                _staffId,
                                                                _transactionId,
                                                                _receiptId,
                                                                _currencyCode,
                                                                _amountMST,
                                                                _transDate,
                                                                _transTime,
                                                                _dateSequence,
                                                                _channelId); // Parameter: _reserved. Issue a locked gift card.
    }

]]></Source>
			</Method>
			<Method>
				<Name>MarkItemsReturned</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method updates the RetailTransactionSalesTrans.returnQty with the value in <c>returnQty</c> if the RetailTransactionSalesTrans.returnQty + returnQty > RetailTransactionSalesTrans.qty field.
    /// </summary>
    /// <param name="itemReturnXmlStr">
    /// Return items serialized to xml string.
    /// Example:
    /// <ArrayOfItemReturn>
    ///   <ItemReturn>
    ///     <TransactionId>100001</TransactionId>
    ///     <StoreId>1001</StoreId>
    ///     <TerminalId>1001</TerminalId>
    ///     <LineNumber>1</LineNumber>
    ///     <Quantity>1.00</Quantity>
    ///   </ItemReturn>
    ///   <ItemReturn>
    ///     <TransactionId>100002</TransactionId>
    ///     <StoreId>1001</StoreId>
    ///     <TerminalId>1001</TerminalId>
    ///     <LineNumber>2</LineNumber>
    ///     <Quantity>2.00</Quantity>
    ///   </ItemReturn>
    /// </ArrayOfItemReturn>
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container MarkItemsReturned(str itemReturnXmlStr)
    {
        return RetailTransactionService::MarkItemsReturned(itemReturnXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating new customer.
    /// </summary>
    /// <param name="custName">
    /// Customer name.
    /// </param>
    /// <param name="custGroup">
    /// Customer group
    /// </param>
    /// <param name="currency">
    /// Currency
    /// </param>
    /// <param name="languageId">
    /// Language ID
    /// </param>
    /// <param name="street">
    /// Street
    /// </param>
    /// <param name="zipCode">
    /// Zip code
    /// </param>
    /// <param name="state">
    /// State
    /// </param>
    /// <param name="county">
    /// County
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="cellularPhone">
    /// Cell phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="multiLineDisc">
    /// Multiline discount
    /// </param>
    /// <param name="endDisc">
    /// End discount
    /// </param>
    /// <param name="lineDisc">
    /// Line discount
    /// </param>
    /// <param name="priceGroup">
    /// Price Group
    /// </param>
    /// <param name="taxGroup">
    /// Tax Group
    /// </param>
    /// <param name="creditMax">
    /// Credit Max
    /// </param>
    /// <param name="blocked">
    /// Blocked
    /// </param>
    /// <param name="orgId">
    /// Org ID
    /// </param>
    /// <param name="usePurchRequest">
    /// Use purchase request
    /// </param>
    /// <param name="vatNum">
    /// Vat Number
    /// </param>
    /// <param name="invoiceAccount">
    /// Invoice account
    /// </param>
    /// <param name="mandatoryCreditLimit">
    /// Mandotory credit limit
    /// </param>
    /// <param name="contactPersonId">
    /// Contact person ID
    /// </param>
    /// <param name="useOrderNumberReference">
    /// Use order number reference
    /// </param>
    /// <param name="receiptOption">
    /// Receipt option
    /// </param>
    /// <param name="receiptEmail">
    /// Receipt Email
    /// </param>
    /// <param name="city">
    /// City
    /// </param>
    /// <param name="country">
    /// Country
    /// </param>
    /// <param name="identificationNumber">
    /// Identification Number
    /// </param>
    /// <param name="storeRecId">
    /// Store Rec ID
    /// </param>
    /// <param name="relationType">
    /// Relation Type
    /// </param>
    /// <param name="streetNumber">
    /// Street Number
    /// </param>
    /// <param name="districtName">
    /// District Name
    /// </param>
    /// <param name="buildingCompliment">
    /// Building Complement
    /// </param>
    /// <param name="cnpjCpfNum_BR">
    /// CNPJ/CPF (Brazilian tax ID)
    /// </param>
    /// <param name="addressName">
    /// Address Name
    /// </param>
    /// <param name="addressType">
    /// Address Type
    /// </param>
    /// <param name="addressPhone">
    /// Address Phone
    /// </param>
    /// <param name="addressEmail">
    /// Address Email
    /// </param>
    /// <param name="addressUrl">
    /// Address URL
    /// </param>
    /// <param name="addressTaxGroup">
    /// Address Tax group
    /// </param>
    /// <param name="firstName">
    /// First name
    /// </param>
    /// <param name="middleName">
    /// Middle name
    /// </param>
    /// <param name="lastName">
    /// Last name
    /// </param>
    /// <param name="phoneExtension">
    /// Phone extension
    /// </param>
    /// <param name="retailCustAffiliations">
    /// A XML string having the details of customer affiliation list
    /// </param>
    /// <returns>
    /// Container with entity keys
    /// </returns>
    public static container newCustomer(    DirPartyName                custName,
                                                //NameAlias                   custTableAlias,
                                                CustGroupId                 custGroup,
                                            CustCurrencyCode            currency,
                                            CustLanguageId              languageId,
                                            AddressStreet               street,
                                            AddressZipCodeId            zipCode,
                                            AddressStateId              state,
                                            AddressCountyId             county,
                                            Phone                       phone,
                                            PhoneMobile                 cellularPhone,
                                            LogisticsElectronicAddressLocator  email,
                                            URL                         url,
                                            CustMultiLineDiscCode       multiLineDisc,
                                            CustEndDiscCode             endDisc,
                                            CustLineDiscCode            lineDisc,
                                            CustPriceGroup              priceGroup,
                                            TaxGroup                    taxGroup,
                                            CustCreditMaxMST            creditMax,
                                            CustBlocked                 blocked,
                                            OrgId                       orgId,
                                            RetailUsePurchRequest       usePurchRequest,
                                            VATNum                      vatNum,
                                            CustInvoiceAccount          invoiceAccount,
                                            MandatoryCreditLimit        mandatoryCreditLimit,
                                            ContactPersonId             contactPersonId,
                                            RetailUseOrderNumberReference  useOrderNumberReference,
                                            RetailReceiptOption            receiptOption,
                                            RetailReceiptEmail             receiptEmail,
                                            AddressCity                 city,
                                            AddressCountryRegionId      country,
                                            CustIdentificationNumber    identificationNumber,
                                            int64                       storeRecId,
                                            RelationType                relationType,  // to be translated to DirPartyType
                                            LogisticsAddressStreetNumber        streetNumber        = '',
                                            LogisticsAddressDistrictName        districtName        = '',
                                            LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                            CNPJCPFNum_BR                       cnpjCpfNum_BR       = '',
                                            CustName                    addressName = '',
                                            LogisticsLocationRoleType   addressType = LogisticsLocationRoleType::None,
                                            Phone                       addressPhone = '',
                                            LogisticsElectronicAddressLocator addressEmail = '',
                                            URL                         addressUrl = '',
                                            TaxGroup                    addressTaxGroup = '',
                                            FirstName firstName = '',
                                            MiddleName middleName = '',
                                            LastName lastName = '',
                                            PhoneLocal phoneExtension = '',
                                            str retailCustAffiliations = '',
                                            EFDocForeignerId_BR                 efDocForeignerId_BR = '',         // feature not ported yet. ignore.
                                            IENum_BR                            ieNum_BR            = '',         // feature not ported yet. ignore.
                                            CCMNum_BR                           ccmNum_BR           = '',         // feature not ported yet. ignore.
                                            ICMSContributor_BR                  icmsContributor_BR  = NoYes::No,  // feature not ported yet. ignore.
                                            NoYesId                             doNotContact =        NoYes::No)  // feature not ported yet. ignore.
    {
        DirPartyType dpType;

        switch (relationType)
        {
            case tableNum_DirOrganization_AX63: // This is the hard-coded value for Organization used in AX 2012 R3 clients
                dpType = DirPartyType::Organization;
                break;

            case tableNum_DirPerson_AX63: // This is the hard-coded value for Person used in AX 2012 R3 clients
                dpType = DirPartyType::Person;
                break;

            default:
                // unexpected: should never be passed by AX 2012 R3 clients.
                throw Global::error("@Retail:PartyTypeNotSupported");
        }
        
        return RetailTransactionService::newCustomer(
            custName,
            custGroup,
            currency,
            languageId,
            street,
            zipCode,
            state,
            county,
            phone,
            cellularPhone,
            email,
            url,
            multiLineDisc,
            endDisc,
            lineDisc,
            priceGroup,
            taxGroup,
            creditMax,
            blocked,
            orgId,
            usePurchRequest,
            vatNum,
            invoiceAccount,
            mandatoryCreditLimit,
            contactPersonId,
            useOrderNumberReference,
            receiptOption,
            receiptEmail,
            city,
            country,
            identificationNumber,
            storeRecId,
            dpType,
            streetNumber,
            districtName,
            buildingCompliment,
            cnpjCpfNum_BR,
            addressName,
            addressType,
            addressPhone,
            addressEmail,
            addressUrl,
            addressTaxGroup,
            firstName,
            middleName,
            lastName,
            phoneExtension,
            retailCustAffiliations);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustomerFromDirParty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating new customer using existing dirParty record.
    /// </summary>
    /// <param name="dirPartyNumber">
    /// dirParty number.
    /// </param>
    /// <param name="storeRecId">
    /// Store Rec ID
    /// </param>
    /// <param name="cnpjCpfNum_BR">
    /// CNPJ/CPF (Brazilian tax ID).
    /// </param>
    /// <returns>
    /// Container with entity keys
    /// </returns>
    public static container newCustomerFromDirParty(
                    DirPartyNumber      dirPartyNumber,
                    int64               storeRecId,
                    CNPJCPFNum_BR       cnpjCpfNum_BR = '')
    {
        return RetailTransactionService::newCustomerFromDirParty(
                dirPartyNumber,
                storeRecId,
                cnpjCpfNum_BR);
    }

]]></Source>
			</Method>
			<Method>
				<Name>packingSlipForCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates packing slip for the customer order.
    /// </summary>
    /// <param name="_salesId">
    /// Identification of the sales order.
    /// </param>
    /// <returns>
    /// A Container with the status of pack slip creation.
    /// </returns>
    public static container packingSlipForCustomerOrder(SalesId _salesId)
    {
        return RetailTransactionService::packingSlipForCustomerOrder(_salesId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>paySalesInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for calculating the payment for the sales invoice, create and post the payment journal.
    /// </summary>
    /// <param name="_invoiceId">
    /// ID of the CustTrans.Invoice field.
    /// </param>
    /// <param name="_paymentAmount">
    /// Amount stored in LedgerJournalTrans.AmountCurDebit if <c>_paymentAmount</c> is less than 0; else LedgerJournalTrans.AmountCurCredit.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailTerminalTable.TerminalId field.
    /// </param>
    /// <param name="_storeId">
    /// <c>RetailStoreId</c>
    /// </param>
    /// <param name="_transactionId">
    /// <c>RetailTransactionId</c>
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container paySalesInvoice(InvoiceId           _invoiceId,
                                            AmountCur           _paymentAmount,
                                            RetailTerminalId       _terminalId,
                                            RetailStoreId          _storeId,
                                            RetailTransactionId    _transactionId)
    {
        return RetailTransactionService::paySalesInvoice(
            _invoiceId,
            _paymentAmount,
            _terminalId,
            _storeId,
            _transactionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>paySalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for payment of sales order. Method performs the following:
    /// 1.Creates and posts payment journal.
    /// 2.Return error if the total prepayment exceed the sales order total.
    /// </summary>
    /// <param name="_salesId">
    /// ID of the SalesTable.SalesId firld.
    /// </param>
    /// <param name="_paymentAmount">
    /// Amount stored in LedgerJournalTrans.AmountCurDebit if <c>_paymentAmount</c> is less than 0; else LedgerJournalTrans.AmountCurCredit.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailTerminalTable.TerminalId field.
    /// </param>
    /// <param name="_storeId">
    /// <c>RetailStoreId</c>
    /// </param>
    /// <param name="_transactionId">
    /// <c>RetailTransactionId</c>
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container paySalesOrder(SalesId           _salesId,
                                          AmountCur         _paymentAmount,
                                          RetailTerminalId     _terminalId,
                                          RetailStoreId        _storeId,
                                          RetailTransactionId  _transactionId)
    {
        return RetailTransactionService::paySalesOrder(
            _salesId,
            _paymentAmount,
            _terminalId,
            _storeId,
            _transactionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>PostLoyaltyCardRewardPointTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts reward points to the <c>PostLoyaltyCardRewardPointTrans</c> table.
    /// </summary>
    /// <param name="_rewardPointTransXmlStr">
    /// The XML string that contains a list of reward point lines.
    /// </param>
    /// <returns>
    /// A container having the result.
    /// </returns>
    /// <remarks>
    /// The XML string has a root node RetailLoyaltyCardRewardPointTransList, which contains
    /// a list of RetailLoyaltyCardRewardPointTrans nodes. Each child node conains the field
    /// values of a <c>PostLoyaltyCardRewardPointTrans</c> record. Refer to the
    /// <c>PostLoyaltyCardRewardPointTrans</c> table for the meaning of each field.
    ///
    /// A sample of XML is provided in the source code of <c>RetailTransactionServiceLoyalty</c> class.
    /// </remarks>
    public static container PostLoyaltyCardRewardPointTrans(str _rewardPointTransXmlStr)
    {
        return RetailTransactionService::PostLoyaltyCardRewardPointTrans(_rewardPointTransXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>realToString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Convert a money value to a standard string format
    /// </summary>
    /// <param name="moneyValue">
    /// Money value to convert to string
    /// </param>
    /// <returns>
    /// Money in string format "1000.000"
    /// </returns>
    public static str realToString(real moneyValue)
    {
        return RetailTransactionServiceUtilities::realToString(moneyValue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>record2XmlNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a table record to an <c>XmlElement</c>.
    /// </summary>
    /// <param name="_common">
    /// The record buffer.
    /// </param>
    /// <param name="_xml">
    /// The <c>XmlDocument</c> to which the <c>XmlElement</c> is added.
    /// </param>
    /// <param name="_includeFields">
    /// A <c>Set</c> containing fields to include. Leave null to include all fields.
    /// </param>
    /// <returns>
    /// The <c>XmlElement</c> representing the record.
    /// </returns>
    /// <remarks>
    /// This is a generic function which can be modified to handle more scenarios.
    /// </remarks>
    public static XmlElement record2XmlNode(Common _common, XmlDocument _xml, Set _includeFields = null)
    {
        return RetailTransactionServiceUtilities::record2XmlNode(_common, _xml, _includeFields);
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailServerStaffInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method gets the staff Id and returns detail information about the staff and permissions for staff.
    /// </summary>
    /// <param name="_staffId">
    /// Staff Id.
    /// </param>
    /// <returns>
    /// The Staff Information as a container.
    /// </returns>
    public static container retailServerStaffInfo(RetailStaffId _staffId)
    {
        return RetailTransactionService::retailServerStaffInfo(_staffId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailServerStaffLogOff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method deletes the record from <c>RetailStaffLoginLog</c> table.
    /// </summary>
    /// <param name="_staffId">
    /// ID of the RetailStaffLoginLog.staffId field.
    /// </param>
    /// <param name="_storeRecId">
    /// RecID of the RetailStaffLoginLog.storeId field.
    /// </param>
    /// <param name="_terminalRecId">
    /// RecID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <param name="_logoffFromStore">
    /// True to logoff from store, false otherwise
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to delete.
    /// </exception>
    public static container retailServerStaffLogOff(RetailStaffId _staffId, RetailChannelRecId _storeRecId, RefRecId _terminalRecId, boolean _logoffFromStore = true)
    {
        return RetailTransactionServiceEmployee::retailServerStaffLogOff(_staffId, _storeRecId, _terminalRecId, _logoffFromStore);
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailServerStaffLogOn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating the RetailStaffLoginLog.staffId with the value in <c>_staffId</c> if the record exists in <c>RetailStaffLoginLog</c>;
    /// else creates the record in <c>RetailStaffLoginLog</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// ID of the RetailStaffLoginLog.staffId field.
    /// </param>
    /// <param name="_storeRecId">
    /// RecID of the RetailStaffLoginLog.storeId field.
    /// </param>
    /// <param name="_terminalRecId">
    /// RecID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <param name="_password">
    /// <c>RetailStaffPassword</c>
    /// </param>
    /// <param name="_loginToStore">
    /// True to login to a store, false to login without store association
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to create/update.
    /// </exception>
    public static container retailServerStaffLogOn(RetailStaffId _staffId, RetailChannelRecId _storeRecId, RefRecId _terminalRecId, RetailStaffPassword _password, boolean _loginToStore=true)
    {
        RetailStoreId       storeNumber;
        RetailTerminalId    terminalId;
        RetailTerminalTable terminalTable;
        container           results;

        select firstOnly terminalId from terminalTable where terminalTable.RecId == _terminalRecId;
        terminalId = terminalTable.terminalId;
        storeNumber = RetailStoreTable::findRecId(_storeRecId).StoreNumber;

        ttsBegin;
        try
        {
            // Call RetailTransactionServiceEmployee::staffLogOn directly, in order to use its _useLegacyHash argument
            boolean skipPasswordValidation = false;
            boolean useLegacyHash = true;
            results = RetailTransactionService::staffLogOn(_staffId, storeNumber, terminalId, _password, _loginToStore, skipPasswordValidation, useLegacyHash);

            if (conPeek(results, 1)  == true)
            {
                ttsCommit; // Commit on success
            }
            else
            {
                ttsAbort; // Abort on failure
            }
        }
        catch
        {
            ttsAbort; // Abort on failure
            throw error("@RET2382");
        }

        // Rainier API RetailTransactionServiceEmployee::staffLogOn returns password changing date, which breaks 6.3 compatilibity, so we remove this element from the container.
        if(conLen(results) > 40) // Expected length: 41
        {
            results = conDel(results,38,1);
        }

        return results;
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchCustomerOrderList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Search for customer sales orders.
    /// </summary>
    /// <param name="_custTerm">
    /// The customer name search term.
    /// </param>
    /// <param name="_orderTerm">
    /// The order search term.
    /// </param>
    /// <param name="_fromDate">
    /// The date to search from.
    /// </param>
    /// <param name="_toDate">
    /// The date to search to.
    /// </param>
    /// <param name="_resultsMaxCount">
    /// The maximum amount of rows to return (default is 100).
    /// </param>
    /// <returns>
    /// Container with the success, error and results.
    /// </returns>
    /// <remarks>
    /// Searches for sales orders using the given search terms/criteria
    /// </remarks>
    public static container searchCustomerOrderList(str _custTerm, str _orderTerm, str _fromDate, str _toDate, int _resultsMaxCount = 100)
    {
        return RetailTransactionService::searchCustomerOrderList(_custTerm, _orderTerm, _fromDate, _toDate, _resultsMaxCount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchCustomers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a keyword search of customers,
    /// and returns a list of customers matching all search terms provided.
    /// </summary>
    /// <param name="_searchString">
    /// A string of keywods to be searched (space delimited). To use this string
    /// in a query, it is constrained to a max length of 255 characters.
    /// </param>
    /// <param name="_pageNumber">
    /// The page of results to seek to and return.
    /// </param>
    /// <param name="_pageSize">
    /// The number of results to return with a page.
    /// </param>
    /// <returns>
    /// A container containing a list of basic customer info in XML.
    /// </returns>
    public static container searchCustomers(str 255 _searchString, int _pageNumber = 0, int _pageSize = 50)
    {
        int                         recCount = 0;
        boolean                     success = true;
        str                         error = '';
        Counter                     infologline = infolog.num();
        int                         fromLine;
        
        RetailTmpCustomerSearchDirPartyData matchingPartyData;
        
        CustTable                   custTableSearch;
        CustTable                   custTableExists;
        CustTable                   custTable;
        DirPartyTable               dirPartyTableSearch;
        DirPartyTable               dirPartyTable;
        DirPartyLocation            dirPartyLocation;
        DirPartyPostalAddressView   addressView;
        LogisticsElectronicAddress  logisticsElectronicAddressSearch;
        LogisticsElectronicAddress  logisticsElectronicAddressEmail;
        LogisticsElectronicAddress  logisticsElectronicAddressPhone;
        LogisticsPostalAddress      logisticsPostalAddressSearch;
        RetailLoyaltyCard           loyaltyCardSearch;
        
        XmlDocument                 doc = XmlDocument::newBlank();
        XmlElement                  rootNode = doc.createElement('SearchResults');
        XmlElement                  recordNode;
        XmlElement                  fieldNode;
        
        if(strLTrim(_searchString) == '')
        {
            doc.appendChild(rootNode);
            return [false, 'Invalid argument: searchString cannot be empty or whitespace', doc.xml()];
        }
        else if(_pageNumber < 0)
        {
            doc.appendChild(rootNode);
            return [false, 'Invalid argument: pageNumber must be >= 0', doc.xml()];
        }
        else if(_pageSize < 0)
        {
            doc.appendChild(rootNode);
            return [false, 'Invalid argument: page size must be >= 0', doc.xml()];
        }

        try
        {
            fromLine = Global::infologLine();
            
            // Get the RecIds of DirPartyTable entries that match our search criteria.
            // Do an exists join with CustTable (where necessary) to ensure those parties are customers.
            
            // Search for a matching customer account number
            while select Party from custTableSearch
                where custTableSearch.accountNum == _searchString
            {
                matchingPartyData.addRecId(custTableSearch.Party);
                
            }

            // Search for a matching loyalty card number
            while select crossCompany Party from loyaltyCardSearch
                where loyaltyCardSearch.CardNumber == _searchString
            {
                matchingPartyData.addRecId(loyaltyCardSearch.Party);
                
            }

            // Search for a matching email, phone, url...
            while select crossCompany Party from dirPartyLocation
                group by dirPartyLocation.Party
            exists join logisticsElectronicAddressSearch
                where dirPartyLocation.Location == logisticsElectronicAddressSearch.Location
                && dirPartyLocation.IsPostalAddress == NoYes::No
                && logisticsElectronicAddressSearch.locator like '*' + strReplace(strRTrim(strLTrim(_searchString)), ' ', '* ') + '*'
            exists join custTableExists
                where dirPartyLocation.Party == custTableExists.Party
            {
                matchingPartyData.addRecId(dirPartyLocation.Party);
            }
            
            // Search for a customer address
            while select crossCompany Party from dirPartyLocation
                group by dirPartyLocation.Party
            exists join logisticsPostalAddressSearch
                where dirPartyLocation.Location == logisticsPostalAddressSearch.Location
                && logisticsPostalAddressSearch.Street like '*' + strReplace(strRTrim(strLTrim(_searchString)), ' ', '* ') + '*'
            exists join custTableExists
                where dirPartyLocation.Party == custTableExists.Party
            {
                matchingPartyData.addRecId(dirPartyLocation.Party);
            }
            
            //If non-whitespace characters lower than 10, search by zipCode
            if(strLen(strReplace(_searchString, ' ', '')) <= 10)
            {
                while select crossCompany Party from dirPartyLocation
                    group by dirPartyLocation.Party
                exists join logisticsPostalAddressSearch
                    where dirPartyLocation.Location == logisticsPostalAddressSearch.Location
                    && logisticsPostalAddressSearch.ZipCode like '*' + strReplace(strRTrim(strLTrim(_searchString)), ' ', '* ') + '*'
                exists join custTableExists
                    where dirPartyLocation.Party == custTableExists.Party
                {
                    matchingPartyData.addRecId(dirPartyLocation.Party);
                }
            }
            
            // Search by name
            // If 4 or more non-whitespace characters are provided, use a wildcard search
            if(strLen(strReplace(_searchString, ' ', '')) >= 4)
            {
                // Search by name with wildcards between each word
                while select crossCompany RecId from dirPartyTableSearch
                    index NameIdx
                    where dirPartyTableSearch.name like '*' + strReplace(strRTrim(strLTrim(_searchString)), ' ', '* ') + '*'
                exists join custTableExists
                    where dirPartyTableSearch.RecId == custTableExists.Party
                {
                    matchingPartyData.addRecId(dirPartyTableSearch.RecId);
                }
            }
            else
            {
                // Search for an exact match of name
                while select crossCompany RecId from dirPartyTableSearch
                    where dirPartyTableSearch.name == _searchString
                exists join custTableExists
                    where dirPartyTableSearch.RecId == custTableExists.Party
                {
                    matchingPartyData.addRecId(dirPartyTableSearch.RecId);
                }
            }
            
            // Join with the needed fields, sort, and iterate the search results
            while select * from matchingPartyData
            join Name, PartyNumber from dirPartyTable
                order by dirPartyTable.Name asc
                where matchingPartyData.Party == dirPartyTable.RecId
            outer join AccountNum from custTable
                where dirPartyTable.RecId == custTable.Party
                && custTable.dataAreaId == curext()
            outer join Address from addressView
                where dirPartyTable.RecId == addressView.Party
                && addressView.IsPrimary == NoYes::Yes
            outer join locator from logisticsElectronicAddressEmail
                where dirPartyTable.PrimaryContactEmail == logisticsElectronicAddressEmail.recid
            outer join locator from logisticsElectronicAddressPhone
                where dirPartyTable.PrimaryContactPhone == logisticsElectronicAddressPhone.RecId
            {
                if(recCount >= (_pageNumber + 1) * _pageSize)
                {
                    break;
                }
                if(recCount >= _pageNumber * _pageSize)
                {
                    recordNode = doc.createElement('SearchResult');
                    
                    fieldNode = doc.createElement('AccountNumber');
                    fieldNode.text(custTable ? custTable.AccountNum : '');
                    recordNode.appendChild(fieldNode);
                    
                    fieldNode = doc.createElement('Email');
                    fieldNode.text(logisticsElectronicAddressEmail ? logisticsElectronicAddressEmail.Locator : '');
                    recordNode.appendChild(fieldNode);
                    
                    fieldNode = doc.createElement('FullAddress');
                    fieldNode.text(addressView.Address);
                    recordNode.appendChild(fieldNode);
                    
                    fieldNode = doc.createElement('FullName');
                    fieldNode.text(dirPartyTable.Name);
                    recordNode.appendChild(fieldNode);
                    
                    fieldNode = doc.createElement('PartyNumber');
                    fieldNode.text(dirPartyTable.PartyNumber);
                    recordNode.appendChild(fieldNode);
                    
                    fieldNode = doc.createElement('Phone');
                    fieldNode.text(logisticsElectronicAddressPhone ? logisticsElectronicAddressPhone.Locator : '');
                    recordNode.appendChild(fieldNode);
           
                    rootNode.appendChild(recordNode);
                }

                recCount++;
            }
        }

        catch(Exception::Error)
        {
            success = false;
            error = 'An exception was caught in RetailTransactionServiceCustomer::searchCustomers(). The messages are: ';
            error += RetailTransactionServiceUtilities::getInfologMessages(fromLine);
        }
        
        doc.appendChild(rootNode);
        return [success, error, doc.xml()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchOrderList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns a list of retail transactions that match the passed in criteria.
    /// </summary>
    /// <param name="_transactionId">
    /// TransactionID to match against the RetailTransactionTable.TransactionId field.
    /// </param>
    /// <param name="_salesId">
    /// SalesID to match against the SalesTable.SalesId field.
    /// </param>
    /// <param name="_receiptId">
    /// ReceiptID to match against the RetailTransactionTable.ReceiptId field.
    /// </param>
    /// <param name="_channelRefId">
    /// Channel Reference ID to match against the SalesOrder.ChannelReferenceId field.
    /// </param>
    /// <param name="_custAccount">
    /// Customer Account Number to match against the RetailTransactionTable.CustAccount field.
    /// </param>
    /// <param name="_custFirstName">
    /// First name of customer who is linked to the RetailTransactionTable.
    /// </param>
    /// <param name="_custLastName">
    /// Last name of customer who is linked to the RetailTransactionTable.
    /// </param>
    /// <param name="_storeId">
    /// StoreId to match against the RetailTransactionTable.Store field.
    /// </param>
    /// <param name="_terminalId">
    /// TerminalId to match against the RetailTransactionTable.Terminal field.
    /// </param>
    /// <param name="_itemId">
    /// ItemId to match against the RetailTransactionSalesTrans.ItemId field.
    /// </param>
    /// <param name="_barcode">
    /// Barcode to match against the RetailTransactionSalesTrans.Barcode field.
    /// </param>
    /// <param name="_staffId">
    /// StaffId to match against the RetailTransactionTable.Staff field.
    /// </param>
    /// <param name="_startDate">
    /// RetailTransactionTable.CreatedDateTime field greater than or equal to startDate.
    /// </param>
    /// <param name="_endDate">
    /// RetailTransactionTable.CreatedDateTime field less than or equal to endDate.
    /// </param>
    /// <param name="_includeDetails">
    /// Whether to include all order information including order lines and attributes.
    /// </param>
    /// <param name="_receiptEmailAddress">
    /// ReceiptEmailAddress to match against the RetailTransactionTable.ReceiptEmail field.
    /// </param>
    /// <param name="_seachIdentifiers">
    /// SeachIdentifiers to math against the RetailTransactionTable with the following fields
    /// TransactionId
    /// ReceiptId
    /// SalesId
    /// CustomerAccount
    /// ChannelRefId
    /// </param>
    /// <param name="_resultsMaxCount">
    /// The maximum amount of rows to return (default is 20).
    /// </param>
    /// <param name="_retailTransactionTypes">
    /// Transaction types to be returned.
    /// </param>
    /// <param name="_serialNumber">
    /// SerialNumber to match against the RetailTransactionSalesTrans.InventSerialId field.
    /// </param>
    /// <param name="_transactionStatusTypes">
    /// Transaction's entry status to match against the RetailTransactionTable.EntryStatus field.
    /// </param>
    /// <param name="_includeNonTransactions">
    /// Whether or not to include non-transaction records (ie, records from SalesTable).  TRUE by default.
    /// </param>
    /// <returns>
    /// A list of orders that match all of the criteria parameters.
    /// </returns>
    public static container searchOrderList(RetailTransactionId _transactionId,
                                            SalesId _salesId,
                                            RetailReceiptId _receiptId,
                                            RetailOrderChannelReferenceId _channelRefId,
                                            CustAccount _custAccount,
                                            str _custFirstName,
                                            str _custLastName,
                                            RetailStoreId _storeId,
                                            RetailTerminalId _terminalId,
                                            RetailItemId _itemId,
                                            RetailBarcode _barcode,
                                            RetailStaffId _staffId,
                                            str _startDate,
                                            str _endDate,
                                            boolean _includeDetails,
                                            RetailReceiptEmail _receiptEmailAddress = '',
                                            String50 _seachIdentifiers = '',
                                            int _resultsMaxCount = 20,
                                            str _retailTransactionTypes = '',
                                            InventSerialId _serialNumber = '',
                                            str _transactionStatusTypes = '',
                                            boolean _includeNonTransactions = true)
    {
        return RetailTransactionServiceTransactionsAX63::searchOrderList(_transactionId,
                                                            _salesId,
                                                            _receiptId,
                                                            _channelRefId,
                                                            _custAccount,
                                                            _custFirstName,
                                                            _custLastName,
                                                            _storeId,
                                                            _terminalId,
                                                            _itemId,
                                                            _barcode,
                                                            _staffId,
                                                            _startDate,
                                                            _endDate,
                                                            _includeDetails,
                                                            _receiptEmailAddress,
                                                            _seachIdentifiers,
                                                            _resultsMaxCount,
                                                            _retailTransactionTypes,
                                                            _serialNumber,
                                                            _transactionStatusTypes,
                                                            _includeNonTransactions);
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendEmail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Send an email using the specified template.
    /// </summary>
    /// <param name="emailId">
    /// The SysEmailMessageTable EmailId.
    /// </param>
    /// <param name="languageId">
    /// The Langauge of the email.
    /// </param>
    /// <param name="email">
    /// The Email Address to send to.
    /// </param>
    /// <param name="serializedMappings">
    /// The mappings to use in the substitution of tokens in the message.
    /// </param>
    /// <param name="xmlData">
    /// The xml data to use in the transform of the message.
    /// </param>
    /// <param name="isTraceable">
    /// Is the email traced.
    /// </param>
    /// <param name="isWithRetries">
    /// Should the email be retried.
    /// </param>
    /// <returns>
    /// Container with the success and error.
    /// </returns>
    /// <remarks>
    /// Schedules an email to be sent by the email distribution batch job.
    /// </remarks>
    public static container sendEmail(SysEmailId emailId, CustLanguageId languageId, Email email, str serializedMappings, str xmlData, boolean isTraceable, boolean isWithRetries)
    {
        return RetailTransactionService::sendEmail(emailId, languageId, email, serializedMappings, xmlData, isTraceable, isWithRetries);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxInformationForJournalLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets India tax information of journal lines based on the set up on retail store.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record to be updated.
    /// </param>
    /// <param name="_storeId">
    /// The specific retail store Id.
    /// </param>
    // <GIN>
    public static void setTaxInformationForJournalLine_IN(LedgerJournalTrans _ledgerJournalTrans, RetailStoreId _storeId)
    {
        RetailTransactionService::setTaxInformationForJournalLine_IN(_ledgerJournalTrans, _storeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Settle a customer order
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML document for the order
    /// </param>
    /// <returns>
    /// container [success, error]
    /// </returns>
    /// <remarks>
    /// Settles a customer order after pickup
    /// </remarks>
    public static container settleCustomerOrder(str custOrderXmlStr)
    {
        str updatedCustOrderXmlStr = RetailTransactionServiceAX63::adjustCustomerOrder(custOrderXmlStr, true);
        
        return RetailTransactionService::settleCustomerOrder(updatedCustOrderXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>staffChangePassword</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating the RetailStaffLoginLog.staffId with the value in <c>_staffId</c> if the record exists in <c>RetailStaffLoginLog</c>;
    /// else creates the record in <c>RetailStaffLoginLog</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// ID of the RetailStaffLoginLog.staffId field.
    /// </param>
    /// <param name="_oldPassword">
    /// ID of the RetailStaffLoginLog.storeId field.
    /// </param>
    /// <param name="_newPassword">
    /// ID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <param name="changePassword">
    /// A flag indicating if the user has to change the password at next POS login.
    /// </param>
    /// <param name="_loginToStore">
    /// Boolean set to true to login to a particular store, set to false to login with only staffId and Password
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to create/update.
    /// </exception>
    public static container staffChangePassword(RetailStaffId _staffId, RetailStaffPassword _oldPassword, RetailStaffPassword _newPassword,boolean changePassword, boolean _loginToStore = true)
    {
        return RetailTransactionService::staffChangePassword(_staffId, _oldPassword, _newPassword, changePassword, _loginToStore, 0, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>staffIsPasswordValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns true if the <c>_password</c> is equal to <c>_realPassword</c>; else false.
    /// </summary>
    /// <param name="_password">
    /// <c>RetailStaffPassword</c>
    /// </param>
    /// <param name="_realPassword">
    /// <c>RetailStaffPassword</c>
    /// </param>
    /// <returns>
    /// true if the <c>_password</c> is equal to <c>_realPassword</c>; else false.
    /// </returns>
    public static boolean staffIsPasswordValid(RetailStaffPassword _password, RetailStaffPassword _realPassword)
    {
        return RetailTransactionService::staffIsPasswordValid(_password, _realPassword);
    }

]]></Source>
			</Method>
			<Method>
				<Name>staffLogOff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method deletes the record from <c>RetailStaffLoginLog</c> table.
    /// </summary>
    /// <param name="_staffId">
    /// ID of the RetailStaffLoginLog.staffId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailStaffLoginLog.storeId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <param name="_logoffFromStore">
    /// Boolean logintostore. True to log-off from particular store/terminal.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to delete.
    /// </exception>
    public static container staffLogOff(RetailStaffId _staffId, RetailStoreId _storeId, RetailTerminalId _terminalId, boolean _logoffFromStore = true)
    {
        return RetailTransactionService::staffLogOff(_staffId, _storeId, _terminalId, _logoffFromStore);
    }

]]></Source>
			</Method>
			<Method>
				<Name>staffLogOn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating the RetailStaffLoginLog.staffId with the value in <c>_staffId</c> if the record exists in <c>RetailStaffLoginLog</c>;
    /// else creates the record in <c>RetailStaffLoginLog</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// ID of the RetailStaffLoginLog.staffId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailStaffLoginLog.storeId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <param name="_password">
    /// <c>RetailStaffPassword</c>
    /// </param>
    /// <param name="_loginToStore">
    /// Boolean set to true to login to a particular store, set to false to login with only staffId and Password
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to create/update.
    /// </exception>
    public static container staffLogOn(RetailStaffId _staffId, RetailStoreId _storeId, RetailTerminalId _terminalId, RetailStaffPassword _password, boolean _loginToStore = true)
    {
        return RetailTransactionService::staffLogOn(_staffId, _storeId, _terminalId, _password, _loginToStore, false, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>startBreak</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers break for the worker specified.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id, where time registration is made.
    /// </param>
    /// <param name="_breakJobId">
    /// The job id of the break.
    /// </param>
    /// <returns>
    /// A container having information whether registration is successful.
    /// </returns>
    /// <remarks>
    /// With the job id we can specify the kind of break (e.g. break for lunch, break from work etc.).
    /// Currently, any kind of break can be added in JmgIpcActivity table.
    /// </remarks>
    public static container startBreak(HcmPersonnelNumberId _personnelNumber, RetailTerminalId _terminalId, JmgJobId _breakJobId)
    {
        return RetailTransactionService::startBreak(_personnelNumber, _terminalId, _breakJobId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update address
    /// </summary>
    /// <param name="addressRecId">
    /// Address RecId
    /// </param>
    /// <param name="custName">
    /// Customer Name
    /// </param>
    /// <param name="street">
    /// Street
    /// </param>
    /// <param name="city">
    /// City
    /// </param>
    /// <param name="county">
    /// County
    /// </param>
    /// <param name="state">
    /// State
    /// </param>
    /// <param name="zip">
    /// Zip
    /// </param>
    /// <param name="country">
    /// Country
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="taxGroup">
    /// Tax group
    /// </param>
    /// <param name="role">
    /// Role
    /// </param>
    /// <param name="phoneRecId">
    /// Phone RecId
    /// </param>
    /// <param name="emailRecId">
    /// Email RecId
    /// </param>
    /// <param name="urlRecId">
    /// URL RecId
    /// </param>
    /// <param name="streetNumber">
    /// Street Number
    /// </param>
    /// <param name="districtName">
    /// District Name
    /// </param>
    /// <param name="buildingCompliment">
    /// Building Complement
    /// </param>
    /// <param name="makePostalAddressPrimary">
    /// Optional. True if this should become the new primary address
    /// </param>
    /// <returns>
    /// A container with entity keys
    /// </returns>
    /// <remarks>
    /// Original parameter list consisted of a single _paramList parameter of type container.
    /// </remarks>
    public static container updateAddress(  RefRecId                    addressRecId,
                                            CustName                    custName,
                                            AddressStreet               street,
                                            AddressCity                 city,
                                            AddressCountyId             county,
                                            AddressStateId              state,
                                            AddressZipCodeId            zip,
                                            AddressCountryRegionId      country,
                                            Phone                       phone,
                                            LogisticsElectronicAddressLocator  email,
                                            URL                         url,
                                            TaxGroup                    taxGroup,
                                            LogisticsLocationRoleType   role,
                                            int64                       phoneRecId,
                                            int64                       emailRecId,
                                            int64                       urlRecId,
                                            LogisticsAddressStreetNumber        streetNumber        = '',
                                            LogisticsAddressDistrictName        districtName        = '',
                                            LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                            boolean                     makePostalAddressPrimary    = false)
    {
        return RetailTransactionService::updateAddress(
            addressRecId,
            custName,
            street,
            city,
            county,
            state,
            zip,
            country,
            phone,
            email,
            url,
            taxGroup,
            role,
            phoneRecId,
            emailRecId,
            urlRecId,
            streetNumber,
            districtName,
            buildingCompliment,
            makePostalAddressPrimary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateChannelPublishingStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Update the publishing status of a channel
    /// </summary>
    /// <param name="_channelId">
    ///     Channel Id
    /// </param>
    /// <param name="_publisingStatus">
    ///     New publishing status
    /// </param>
    /// <param name="_publisingStatusMessage">
    ///     The publishing status message
    /// </param>
    /// <returns>
    ///     A container which stores a Boolean result and the update result message in the following format
    ///     [result, message]
    /// </returns>
    public static container updateChannelPublishingStatus(
        RefRecId _channelId,
        RetailOnlineChannelPublishStatusType _publisingStatus,
        RetailOnlineChannelPublishStatusMessage _publisingStatusMessage = '')
    {
        return RetailTransactionService::updateChannelPublishingStatus(_channelId, _publisingStatus, _publisingStatusMessage);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating the record in <c>RetailCreditVoucherTable</c>.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailCreditVoucherTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailCreditVoucherTable.createdInStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailCreditVoucherTable.createdByTerminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailCreditVoucherTable.createdByStaffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailCreditVoucherTable.createdByTransactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailCreditVoucherTable.createdByReceipId field.
    /// </param>
    /// <param name="_lineNum">
    /// ID of the RetailCreditVoucherTable.createdByLineNum field.
    /// </param>
    /// <param name="_amountMST">
    /// Value for the RetailCreditVoucherTable.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value for the RetailCreditVoucherTable.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value for the RetailCreditVoucherTable.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container updateCreditMemo(  RetailDataEntryId   _dataEntryId,
                                               RetailStoreId       _storeId,
                                               RetailTerminalId    _terminalId,
                                               RetailStaffId       _staffId,
                                               RetailTransactionId _transactionId,
                                               RetailReceiptId     _receiptId,
                                               RetailLineNum       _lineNum,
                                               AmountMST        _amountMST,
                                               str              _transDate,//RBOTransDate     _transDate,
                                               str              _transTime,//RetailTransTime     _transTime)
                                               int              _dateSequence = 321)
    {
        return RetailTransactionService::updateCreditMemo(
            _dataEntryId,
            _storeId,
            _terminalId,
            _staffId,
            _transactionId,
            _receiptId,
            _lineNum,
            _amountMST,
            _transDate,
            _transTime,
            _dateSequence);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating an existing customer.
    /// </summary>
    /// <param name="custTableRecId">
    /// CustTable RecId.
    /// </param>
    /// <param name="custName">
    /// Customer Name.
    /// </param>
    /// <param name="custGroup">
    /// Customer group
    /// </param>
    /// <param name="currency">
    /// Currency
    /// </param>
    /// <param name="languageId">
    /// Language ID
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="phoneRecId">
    /// Phone recid
    /// </param>
    /// <param name="cellularPhone">
    /// Cell phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="emailRecId">
    /// Email recid
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="urlRecId">
    /// Url recid
    /// </param>
    /// <param name="multiLineDisc">
    /// Multiline discount
    /// </param>
    /// <param name="endDisc">
    /// End discount
    /// </param>
    /// <param name="lineDisc">
    /// Line discount
    /// </param>
    /// <param name="priceGroup">
    /// Price Group
    /// </param>
    /// <param name="taxGroup">
    /// Tax Group
    /// </param>
    /// <param name="creditMax">
    /// Credit Max
    /// </param>
    /// <param name="blocked">
    /// Blocked
    /// </param>
    /// <param name="orgId">
    /// Org ID
    /// </param>
    /// <param name="usePurchRequest">
    /// Use purchase request
    /// </param>
    /// <param name="vatNum">
    /// Vat Number
    /// </param>
    /// <param name="invoiceAccount">
    /// Invoice account
    /// </param>
    /// <param name="mandatoryCreditLimit">
    /// Mandotory credit limit
    /// </param>
    /// <param name="contactPersonId">
    /// Contact person ID
    /// </param>
    /// <param name="useOrderNumberReference">
    /// Use order number reference
    /// </param>
    /// <param name="receiptOption">
    /// Receipt option
    /// </param>
    /// <param name="receiptEmail">
    /// Receipt Email
    /// </param>
    /// <param name="identificationNumber">
    /// Identification Number
    /// </param>
    /// <param name="firstName">
    /// First name
    /// </param>
    /// <param name="middleName">
    /// Middle name
    /// </param>
    /// <param name="lastName">
    /// Last name
    /// </param>
    /// <param name="phoneExtension">
    /// Phone extension
    /// </param>
    /// <param name="cellphoneRecId">
    /// Cell phone record id
    /// </param>
    /// <param name="retailCustAffiliations">
    /// A XML string having the details of customer affiliation list
    /// </param>
    /// <returns>
    /// Results in container.
    /// </returns>
    public static container updateCustomer( int64                       custTableRecId,
                                            DirPartyName                custName,
                                            CustGroupId                 custGroup,
                                            CustCurrencyCode            currency,
                                            CustLanguageId              languageId,
                                            Phone                       phone,
                                            int64                       phoneRecId,
                                            PhoneMobile                 cellularPhone,
                                            LogisticsElectronicAddressLocator  email,
                                            int64                       emailRecId,
                                            URL                         url,
                                            int64                       urlRecId,
                                            CustMultiLineDiscCode       multiLineDisc,
                                            CustEndDiscCode             endDisc,
                                            CustLineDiscCode            lineDisc,
                                            CustPriceGroup              priceGroup,
                                            TaxGroup                    taxGroup,
                                            CustCreditMaxMST            creditMax,
                                            CustBlocked                 blocked,
                                            OrgId                       orgId,
                                            RetailUsePurchRequest       usePurchRequest,
                                            VATNum                      vatNum,
                                            CustInvoiceAccount          invoiceAccount,
                                            MandatoryCreditLimit        mandatoryCreditLimit,
                                            ContactPersonId             contactPersonId,
                                            RetailUseOrderNumberReference  useOrderNumberReference,
                                            RetailReceiptOption            receiptOption,
                                            RetailReceiptEmail             receiptEmail,
                                            CustIdentificationNumber    identificationNumber,
                                            FirstName firstName = '',
                                            MiddleName middleName = '',
                                            LastName lastName = '',
                                            PhoneLocal phoneExtension = '',
                                            int64 cellphoneRecId = 0,
                                            str retailCustAffiliations = '')
    {
        return RetailTransactionService::updateCustomer(
            custTableRecId,
            custName,
            custGroup,
            currency,
            languageId,
            phone,
            phoneRecId,
            cellularPhone,
            email,
            emailRecId,
            url,
            urlRecId,
            multiLineDisc,
            endDisc,
            lineDisc,
            priceGroup,
            taxGroup,
            creditMax,
            blocked,
            orgId,
            usePurchRequest,
            vatNum,
            invoiceAccount,
            mandatoryCreditLimit,
            contactPersonId,
            useOrderNumberReference,
            receiptOption,
            receiptEmail,
            identificationNumber,
            firstName,
            middleName,
            lastName,
            phoneExtension,
            cellphoneRecId,
            retailCustAffiliations);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the customer order.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the details of order to be updated.
    /// </param>
    /// <returns>
    /// A container having the status and sales id of the order updated.
    /// </returns>
    public static container updateCustomerOrder(str custOrderXmlStr)
    {
        str updatedCustOrderXmlStr = RetailTransactionServiceAX63::adjustCustomerOrder(custOrderXmlStr, true, true);
        
        return RetailTransactionService::updateCustomerOrder(updatedCustOrderXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerQuote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a sales quotation from the given details.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the header, line details and charges associated with the quote to be updated.
    /// </param>
    /// <returns>
    /// A container having the status and quotation id of the quotation updated.
    /// </returns>
    public static container updateCustomerQuote(str custOrderXmlStr)
    {
        str updatedCustOrderXmlStr = RetailTransactionServiceAX63::adjustCustomerOrder(custOrderXmlStr, true);
        
        return RetailTransactionService::updateCustomerQuote(updatedCustOrderXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update an inventory journal document in AX
    /// </summary>
    /// <param name="ijXmlStr">
    /// An XML string with inventory journal line information
    /// </param>
    /// <returns>
    /// A container object with True or False as the first element
    /// </returns>
    /// <remarks>
    /// This method is used to update the counting journal on AX
    /// </remarks>
    public server static container updateInventoryJournal(str ijXmlStr)
    {
        return RetailTransactionService::updateInventoryJournal(ijXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateIssuedLoyaltyPoints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the record in <c>RetailLoyaltyMSRCardTrans</c> table for Issued points.
    /// </summary>
    /// <param name="pTransactionId">
    /// ID of the RetailLoyaltyMSRCardTrans.transactionId field.
    /// </param>
    /// <param name="pLineNum">
    /// ID of the RetailLoyaltyMSRCardTrans.loyaltyPointTranslineNum field.
    /// </param>
    /// <param name="pStoreId">
    /// ID of the RetailLoyaltyMSRCardTrans.storeId field.
    /// </param>
    /// <param name="pTerminalId">
    /// ID of the RetailLoyaltyMSRCardTrans.terminalId field.
    /// </param>
    /// <param name="pLoyaltyCardNo">
    /// ID of the RetailLoyaltyMSRCardTable.cardNumber field.
    /// </param>
    /// <param name="pTransDate">
    /// Transaction date for the RetailLoyaltyMSRCardTrans.dateOfIssue field.
    /// </param>
    /// <param name="pDateSequence">
    /// Format of the date.
    /// </param>
    /// <param name="pIssuedPoints">
    /// Loyalty points of the RetailLoyaltyMSRCardTrans.points field.
    /// </param>
    /// <param name="pReceiptId">
    /// ID of the RetailLoyaltyMSRCardTrans.receiptId field.
    /// </param>
    /// <param name="pStaffId">
    /// ID of the RetailLoyaltyMSRCardTrans.staffId field.
    /// </param>
    /// <param name="pTime">
    /// Time value for the RetailLoyaltyMSRCardTrans.timeOfIssue field.
    /// </param>
    /// <returns>
    /// Container with the true and string message if the record is created in <c>RetailLoyaltyMSRCardTrans</c> table successfully; else false with
    /// appropriate string message.
    /// </returns>
    public static container updateIssuedLoyaltyPoints(  RetailTransactionId    pTransactionId,
                                                        LineNum             pLineNum,
                                                        RetailStoreId          pStoreId,
                                                        RetailTerminalId       pTerminalId,
                                                        RetailCardNumber       pLoyaltyCardNo,
                                                        str                 pTransDate,
                                                        int                 pDateSequence = 123,
                                                        RetailLoyaltyPoints    pIssuedPoints = 0,
                                                        RetailReceiptId        pReceiptId = "",
                                                        RetailStaffId          pStaffId = "",
                                                        str                 pTime = "00:00:00")
    {
        return RetailTransactionService::updateIssuedLoyaltyPoints( pTransactionId,
                                                                    pLineNum,
                                                                    pStoreId,
                                                                    pTerminalId,
                                                                    pLoyaltyCardNo,
                                                                    pTransDate,
                                                                    pDateSequence,
                                                                    pIssuedPoints,
                                                                    pReceiptId,
                                                                    pStaffId,
                                                                    pTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePickingList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the picking list in Ax.
    /// </summary>
    /// <param name="xmlPickListStr">
    /// An XML string having the details of picking list.
    /// </param>
    /// <returns>
    /// A container having the status of updation.
    /// </returns>
    public static container updatePickingList(str xmlPickListStr)
    {
        return RetailTransactionService::updatePickingList(xmlPickListStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update a purchase order
    /// </summary>
    /// <param name="poXmlStr">
    /// An XML string for Purchase Order details
    /// </param>
    /// <returns>
    /// A container object to indicate update success or failure
    /// </returns>
    /// <remarks>
    /// This method is used to update a purchase order's receive now quantity
    /// </remarks>
    public server static container updatePurchaseOrder(str poXmlStr)
    {
        return RetailTransactionService::updatePurchaseOrder(poXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStaffPassword</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates employee password.
    /// </summary>
    /// <param name="staffId">
    /// The staff identifier.
    /// </param>
    /// <param name="password">
    /// The new password
    /// </param>
    /// <param name="changePassword">
    /// A flag indicating if the user has to change the password at next POS login.
    /// </param>
    /// <returns>
    /// A container with the status and error message.
    /// </returns>
    public static container updateStaffPassword(  str staffId,
                                                  str password,
                                                  int changePassword)
    {
        return RetailTransactionService::updateStaffPassword(staffId, password, changePassword);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransferOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update a transfer order
    /// </summary>
    /// <param name="toXmlStr">
    /// An Xml string containing details of a transfer order
    /// </param>
    /// <returns>
    /// A container object to indicate success or failure
    /// </returns>
    /// <remarks>
    /// This allows updates for transfer order's ship now and receive now quantities
    /// </remarks>
    public static server container updateTransferOrder(str toXmlStr)
    {
        return RetailTransactionService::updateTransferOrder(toXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateUsedLoyaltyPoints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the record in <c>RetailLoyaltyMSRCardTrans</c> table for Issued points.
    /// </summary>
    /// <param name="pTransactionId">
    /// ID of the RetailLoyaltyMSRCardTrans.transactionId field.
    /// </param>
    /// <param name="pLineNum">
    /// ID of the RetailLoyaltyMSRCardTrans.loyaltyPointTranslineNum field.
    /// </param>
    /// <param name="pStoreId">
    /// ID of the RetailLoyaltyMSRCardTrans.storeId field.
    /// </param>
    /// <param name="pTerminalId">
    /// ID of the RetailLoyaltyMSRCardTrans.terminalId field.
    /// </param>
    /// <param name="pLoyaltyCardNo">
    /// ID of the RetailLoyaltyMSRCardTable.cardNumber field.
    /// </param>
    /// <param name="pTransDate">
    /// Transaction date for the RetailLoyaltyMSRCardTrans.dateOfIssue field.
    /// </param>
    /// <param name="pDateSequence">
    /// Format of the date.
    /// </param>
    /// <param name="pIssuedPoints">
    /// Loyalty points of the RetailLoyaltyMSRCardTrans.points field.
    /// </param>
    /// <param name="pReceiptId">
    /// ID of the RetailLoyaltyMSRCardTrans.receiptId field.
    /// </param>
    /// <param name="pStaffId">
    /// ID of the RetailLoyaltyMSRCardTrans.staffId field.
    /// </param>
    /// <param name="pTime">
    /// Time value for the RetailLoyaltyMSRCardTrans.timeOfIssue field.
    /// </param>
    /// <returns>
    /// Container with the true and string message if the record is created in <c>RetailLoyaltyMSRCardTrans</c> table successfully; else false with
    /// appropriate string message.
    /// </returns>
    public static container updateUsedLoyaltyPoints(    RetailTransactionId    pTransactionId,
                                                        LineNum                pLineNum,
                                                        RetailStoreId          pStoreId,
                                                        RetailTerminalId       pTerminalId,
                                                        RetailCardNumber       pLoyaltyCardNo,
                                                        str                    pTransDate,
                                                        int                    pDateSequence = 123,
                                                        RetailLoyaltyPoints    pIssuedPoints = 0,
                                                        RetailReceiptId        pReceiptId = "",
                                                        RetailStaffId          pStaffId = "",
                                                        str                    pTime = "00:00:00")
    {
        return RetailTransactionService::updateUsedLoyaltyPoints(pTransactionId,
                                                                pLineNum,
                                                                pStoreId,
                                                                pTerminalId,
                                                                pLoyaltyCardNo,
                                                                pTransDate,
                                                                pDateSequence,
                                                                pIssuedPoints,
                                                                pReceiptId,
                                                                pStaffId,
                                                                pTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWishList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a wish list.
    /// </summary>
    /// <param name="wishListXml">
    /// The input xml string containing updated field information.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the update of record is successful and false otherwise.
    /// </returns>
    public static container updateWishList(str wishListXml)
    {
        return RetailTransactionService::updateWishList(wishListXml, '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWishListLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a wish list line.
    /// </summary>
    /// <param name="wishListLineXml">
    /// The input xml string containing updated field information.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the update of record is successful and false otherwise.
    /// </returns>
    public static container updateWishListLine(str wishListLineXml)
    {
        return RetailTransactionService::updateWishListLine(wishListLineXml, '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>upsertLogisticsElectronicAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts or updates the electronic address based on the locator.
    /// </summary>
    /// <param name="logisticsElectronicAddressRecId">
    /// RecId of LogisticsElectronic address.
    /// </param>
    /// <param name="value">
    /// Value of the loator.
    /// </param>/// <param name="parentLogisticsLocationId">
    /// Value of the Parent location Id.
    /// </param>
    /// <param name="type">
    /// Type of the electronic address.
    /// </param>
    /// <returns>
    /// A container object with Location Id and electronic address id.
    /// </returns>
    public static container upsertLogisticsElectronicAddress(
            RecId logisticsElectronicAddressRecId,
            LogisticsElectronicAddressLocator value,
            LogisticsLocationRecId parentLogisticsLocationId,
            LogisticsElectronicAddressMethodType type)
    {
        return RetailTransactionService::upsertLogisticsElectronicAddress(
                logisticsElectronicAddressRecId,
                value,
                parentLogisticsLocationId,
                type);
    }

]]></Source>
			</Method>
			<Method>
				<Name>utcDateTimeToDateTimeStringWithOffset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Convert a utc datetime value to a standard datetime string format plus offset based on timezone setting of the UTC.
    /// </summary>
    /// <param name="theDateTime">
    /// UtcDateTime to convert to string with offset.
    /// </param>
    /// <returns>
    /// Date in string format "dd-mm-yyyy" + OffsetMinutes.
    /// </returns>
    public static str utcDateTimeToDateTimeStringWithOffset(utcDateTime theDateTime)
    {
        return RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(theDateTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>utcDateTimeToString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Convert date-time to a standard string format
    /// </summary>
    /// <param name="theDateTime">
    /// Date Time to convert to string
    /// </param>
    /// <returns>
    /// Date Time in string format "dd/mm/yyyy hh:mm:ss"
    /// </returns>
    public static str utcDateTimeToString(utcdatetime theDateTime)
    {
        return RetailTransactionServiceUtilities::utcDateTimeToString(theDateTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for validating the credit vouchers.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailCreditVoucherTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailCreditVoucherTable.reservedByStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailCreditVoucherTable.reservedByTerminalId field.
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container validateCreditMemo(RetailDataEntryId _dataEntryId, RetailStoreId _storeId, RetailTerminalId _terminalId)
    {
        return RetailTransactionService::validateCreditMemo(_dataEntryId, _storeId, _terminalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustomerStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for checking the status of the customer account i.e.,
    /// 1.Existence of the customer
    /// 2.Blocked/Unblocked
    /// 3.Credit limit
    /// </summary>
    /// <param name="_custAccount">
    /// ID of the CustTable.AccountNum field.
    /// </param>
    /// <param name="_salesAmount">
    /// <c>AmountMST</c>
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to check the status of the customer account.
    /// </exception>
    public static container validateCustomerStatus(CustAccount _custAccount, AmountMST  _salesAmount, CurrencyCode _currencyCode)
    {
        return RetailTransactionService::validateCustomerStatus(_custAccount, _salesAmount, _currencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for validating the gift cards.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailGiftCardTable.reservedByStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTable.reservedByTerminalId field.
    /// </param>
    /// <param name="_skipReserveValidation">
    /// Skip gift card reserve validation sign.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTable.channel field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container validateGiftCard(RetailGiftCardId _dataEntryId, RetailStoreId _storeId, RetailTerminalId _terminalId
                                             , boolean _skipReserveValidation = false
                                             ,RetailChannelRecId _channelId = 0
    )
    {
        return RetailTransactionService::validateGiftCard(_dataEntryId, _storeId, _terminalId, _skipReserveValidation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used to check the status of the credit voucher i.e., voucher exists or voided or not voided.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailCreditVoucherTable.entryId field.
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container voidCreditMemo(RetailDataEntryId _dataEntryId)
    {
        return RetailTransactionService::voidCreditMemo(_dataEntryId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidCreditMemoPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method checks for the status of the credit voucher i.e., voucher is in use or the voucher has any errors or the voucher does not exists.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailCreditVoucherTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailCreditVoucherTable.reservedByStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailCreditVoucherTable.reservedByTerminalId field.
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container voidCreditMemoPayment(RetailDataEntryId _dataEntryId, RetailStoreId _storeId, RetailTerminalId _terminalId)
    {
        return RetailTransactionService::voidCreditMemoPayment(_dataEntryId, _storeId, _terminalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used to check the status of the gift card i.e., card exists or voided or not voided.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container voidGiftCard(RetailGiftCardId _dataEntryId)
    {
        return RetailTransactionServiceTransactions::voidGiftCard(_dataEntryId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidGiftCardPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method checks for the status of the gift card i.e., card exists or the gift card has any errors.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailGiftCardTable.reservedByStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTable.reservedByTerminalId field.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTable.channel field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container voidGiftCardPayment(RetailGiftCardId _dataEntryId, RetailStoreId _storeId, RetailTerminalId _terminalId, RetailChannelRecId _channelId = 0)
    {
        return RetailTransactionService::voidGiftCardPayment(_dataEntryId, _storeId, _terminalId, _channelId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// AX63 CRT sends a limited XML representation of CustomerOrderInfo
    /// Before passing the XML to RetailTransactionService we need to adjust or add information on it.
    /// </summary>
    /// <param name ="_custOrderXmlStr">a CustomerOrderInfo XML serialized as string.</param>
    /// <param name ="_adjustPayments">Optional parameter to adjust payments with prepayment defaults.</param>
    /// <param name ="_isPrepayment">Optional parameter to define payments as prepayments or not.</param>
    /// <returns>The adjusted CustomerOrderInfo serialized as XML.</returns>
    private static str adjustCustomerOrder(str _custOrderXmlStr, boolean _adjustPayments = false, boolean _isPrepayment = false)
    {
        // AX63 RTS does not send channel id, so it must be retrieved from the store ID.
        CustomerOrderInfo custOrderInfo = CustomerOrderInfo::FromXml(_custOrderXmlStr);

        custOrderInfo.ChannelRecordId = int642Str(RetailStoreTable::find(custOrderInfo.StoreId).RecId);

        // AX63 RTS does not send these payments attributes, so they must be filled with a default
        if (_adjustPayments)
        {
            PaymentInfoCollection payments = custOrderInfo.Payments;
            for (int i = 0; i < payments.get_Count(); i++)
            {
                PaymentInfo paymentInfo = payments.get_Item(i) as PaymentInfo;

                paymentInfo.PaymentCaptured = true;
                paymentInfo.Prepayment      = _isPrepayment;
            }
        }
        
        return custOrderInfo.ToXml();
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustCustomerReturnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// ReturnInventTransId needs to be set in order to properly associate the return with the original transaction
    /// </summary>
    /// <param name ="_custOrderXmlStr">a CustomerOrderInfo XML serialized as string.</param>
    /// <returns>The adjusted CustomerOrderInfo serialized as XML.</returns>
    private static str adjustCustomerReturnOrder(str _custOrderXmlStr)
    {
        CustomerOrderInfo custOrderInfo = CustomerOrderInfo::FromXml(_custOrderXmlStr);

        ItemInfoCollection itemCollection = custOrderInfo.Items;

        for (int i=0; i < itemCollection.get_Count(); i++)
        {
            ItemInfo itemInfo = itemCollection.get_Item(i) as ItemInfo;

            itemInfo.ReturnInventTransId = itemInfo.InventTransId;

        }
        
        return custOrderInfo.ToXml();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>