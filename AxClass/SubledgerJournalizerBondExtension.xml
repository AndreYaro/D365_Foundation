<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SubledgerJournalizerBondExtension</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>SubledgerJournalizerBondExtension</c> class handles correspondence information.
/// </summary>
[SourceDocumentExtension()]
public class SubledgerJournalizerBondExtension extends SubledgerJournalizerExtension
{
    #ISOCountryRegionCodes
    RecId                       distributionRecID;
    Set                         journalizationRecIDs;
    LedgerBondBatchTransNum_RU  bondBatchTrans;
    Map                         importedBond;
    SubledgerBondMapTmp         bondMap;
    LedgerBondBatchTransNum_RU  lastDebit;
    LedgerBondBatchTransNum_RU  lastCredit;
    DebitCredit                 distributedSign;
    boolean                     isFirstTmp;
    boolean                     insertedAccountEntryDistributionsWillBeRecreated;

    SubledgerJournalAccountEntryRelievingTmpExt_RU relievingTmpExt;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>applyRoundingToSubledgerJournalTmpDetail</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Applies Russian rounding logic to created <c>SubledgerJournalAccountEntryTmpDetail</c>. The difference with core logic is that Russian logic takes into account transaction bonding.
    /// </summary>
    /// <param name="_subledgerJournalAccountEntryTmpDetail">
    ///   The <c>SubledgerJournalAccountEntryTmpDetail</c> buffer.
    /// </param>
    /// <param name="_accountingCurrencyAmountToRound">
    ///   The amount of rounding in accounting currency.
    /// </param>
    /// <param name="_reportingCurrencyAmountToRound">
    ///   The amount of rounding in reporting currency.
    /// </param>
    /// <param name="_applyRoundingToNonTaxLineOnly">
    ///   Determines if rounding can be applied to lines, related to tax.
    /// </param>
    /// <param name="_roundingApplied">
    ///   Flag which indicates that rounding was made.
    /// </param>
    /// <remarks>
    ///   The method, in general, repeats logic of <c>SubledgerJournalizer</c> applyRoundingToSubledgerJournalTmpDetail method, except that it uses bonding for finding offset transaction
    /// and rounds both debit and credit at one time.
    /// </remarks>
    private void applyRoundingToSubledgerJournalTmpDetail(
        SubledgerJournalAccountEntryTmpDetail _subledgerJournalAccountEntryTmpDetail,
        AmountMST                             _accountingCurrencyAmountToRound,
        AmountMST                             _reportingCurrencyAmountToRound,
        boolean                               _applyRoundingToNonTaxLineOnly = true,
        boolean                               _roundingApplied          = false)
    {
        boolean roundingApplied = _roundingApplied;
        SubledgerJournalAccountEntryTmpDetail   roundingEntrySubledgerJournalAccountEntryTmpDetail, roundingEntrySubledgerJournalAccountEntryTmpDetailOffset;
        SubledgerJournalAccountEntryTmpDetail   updateEntrySubledgerJournalAccountEntryTmpDetail, updateEntrySubledgerJournalAccountEntryTmpDetailOffset;

        roundingEntrySubledgerJournalAccountEntryTmpDetail.linkPhysicalTableInstance(_subledgerJournalAccountEntryTmpDetail);
        updateEntrySubledgerJournalAccountEntryTmpDetail.linkPhysicalTableInstance(_subledgerJournalAccountEntryTmpDetail);
        roundingEntrySubledgerJournalAccountEntryTmpDetailOffset.linkPhysicalTableInstance(_subledgerJournalAccountEntryTmpDetail);
        updateEntrySubledgerJournalAccountEntryTmpDetailOffset.linkPhysicalTableInstance(_subledgerJournalAccountEntryTmpDetail);

        while select maxof(RecId) from roundingEntrySubledgerJournalAccountEntryTmpDetail
                group by TransactionCurrencyCode,
                        ExchangeRate1,
                        ExchangeRate2,
                        ReportingExchangeRate1,
                        ReportingExchangeRate2,
                        ExchangeRateDate
            where roundingEntrySubledgerJournalAccountEntryTmpDetail.Ledger == _subledgerJournalAccountEntryTmpDetail.Ledger
                && roundingEntrySubledgerJournalAccountEntryTmpDetail.FiscalCalendarPeriod == _subledgerJournalAccountEntryTmpDetail.FiscalCalendarPeriod
                && roundingEntrySubledgerJournalAccountEntryTmpDetail.PostingLayer == _subledgerJournalAccountEntryTmpDetail.PostingLayer
                && roundingEntrySubledgerJournalAccountEntryTmpDetail.SubledgerJournalEntryType == _subledgerJournalAccountEntryTmpDetail.SubledgerJournalEntryType
                && roundingEntrySubledgerJournalAccountEntryTmpDetail.IsReversal == NoYes::No   //reversal/relieving entries should not be modified, don't pick them to apply difference to
                && roundingEntrySubledgerJournalAccountEntryTmpDetail.TransactionCurrencyCode == _subledgerJournalAccountEntryTmpDetail.TransactionCurrencyCode // only apply rounding if currencies match
                && roundingEntrySubledgerJournalAccountEntryTmpDetail.TransactionCurrencyAmount != 0
                && roundingEntrySubledgerJournalAccountEntryTmpDetail.ExchangeRate1 != 0
                && roundingEntrySubledgerJournalAccountEntryTmpDetail.DebitCredit == DebitCredit::Debit
                && (!_applyRoundingToNonTaxLineOnly ||
                    // Do not apply the rounding adjustment to tax line
                    (roundingEntrySubledgerJournalAccountEntryTmpDetail.PostingType != LedgerPostingType::Tax
                    && roundingEntrySubledgerJournalAccountEntryTmpDetail.PostingType != LedgerPostingType::TaxReport
                    && roundingEntrySubledgerJournalAccountEntryTmpDetail.PostingType != LedgerPostingType::TaxWithhold))
        notExists join roundingEntrySubledgerJournalAccountEntryTmpDetailOffset
            where roundingEntrySubledgerJournalAccountEntryTmpDetailOffset.Ledger == _subledgerJournalAccountEntryTmpDetail.Ledger
                && roundingEntrySubledgerJournalAccountEntryTmpDetailOffset.FiscalCalendarPeriod == _subledgerJournalAccountEntryTmpDetail.FiscalCalendarPeriod
                && roundingEntrySubledgerJournalAccountEntryTmpDetailOffset.PostingLayer == _subledgerJournalAccountEntryTmpDetail.PostingLayer
                && roundingEntrySubledgerJournalAccountEntryTmpDetailOffset.SubledgerJournalEntryType == _subledgerJournalAccountEntryTmpDetail.SubledgerJournalEntryType
                && roundingEntrySubledgerJournalAccountEntryTmpDetailOffset.IsReversal == NoYes::No   //reversal/relieving entries should not be modified, don't pick them to apply difference to
                && roundingEntrySubledgerJournalAccountEntryTmpDetailOffset.TransactionCurrencyCode == _subledgerJournalAccountEntryTmpDetail.TransactionCurrencyCode // only apply rounding if currencies match
                && roundingEntrySubledgerJournalAccountEntryTmpDetailOffset.BondBatchTrans_RU == roundingEntrySubledgerJournalAccountEntryTmpDetail.BondBatchTrans_RU
                && roundingEntrySubledgerJournalAccountEntryTmpDetailOffset.DebitCredit == DebitCredit::Credit
                && ((_applyRoundingToNonTaxLineOnly
                    // Do not apply the rounding adjustment to tax line
                    && (roundingEntrySubledgerJournalAccountEntryTmpDetailOffset.PostingType == LedgerPostingType::Tax
                     || roundingEntrySubledgerJournalAccountEntryTmpDetailOffset.PostingType == LedgerPostingType::TaxReport
                     || roundingEntrySubledgerJournalAccountEntryTmpDetailOffset.PostingType == LedgerPostingType::TaxWithhold))
                   ||
                    (!_applyRoundingToNonTaxLineOnly && false))

        {
            select firstonly forupdate updateEntrySubledgerJournalAccountEntryTmpDetail
                where updateEntrySubledgerJournalAccountEntryTmpDetail.RecId == roundingEntrySubledgerJournalAccountEntryTmpDetail.RecId;

            if (updateEntrySubledgerJournalAccountEntryTmpDetail)
            {
                //updateEntrySubledgerJournalAccountEntryTmpDetail is Debit transaction
                updateEntrySubledgerJournalAccountEntryTmpDetail.AccountingCurrencyAmount += _accountingCurrencyAmountToRound;
                updateEntrySubledgerJournalAccountEntryTmpDetail.ReportingCurrencyAmount += _reportingCurrencyAmountToRound;
                updateEntrySubledgerJournalAccountEntryTmpDetail.update();

                //selecting offset transaction
                select firstOnly forUpdate updateEntrySubledgerJournalAccountEntryTmpDetailOffset
                    where updateEntrySubledgerJournalAccountEntryTmpDetailOffset.Ledger == _subledgerJournalAccountEntryTmpDetail.Ledger
                        && updateEntrySubledgerJournalAccountEntryTmpDetailOffset.FiscalCalendarPeriod == _subledgerJournalAccountEntryTmpDetail.FiscalCalendarPeriod
                        && updateEntrySubledgerJournalAccountEntryTmpDetailOffset.PostingLayer == _subledgerJournalAccountEntryTmpDetail.PostingLayer
                        && updateEntrySubledgerJournalAccountEntryTmpDetailOffset.SubledgerJournalEntryType == _subledgerJournalAccountEntryTmpDetail.SubledgerJournalEntryType
                        && updateEntrySubledgerJournalAccountEntryTmpDetailOffset.IsReversal == NoYes::No   //reversal/relieving entries should not be modified, don't pick them to apply difference to
                        && updateEntrySubledgerJournalAccountEntryTmpDetailOffset.TransactionCurrencyCode == _subledgerJournalAccountEntryTmpDetail.TransactionCurrencyCode // only apply rounding if currencies match
                        && updateEntrySubledgerJournalAccountEntryTmpDetailOffset.BondBatchTrans_RU == updateEntrySubledgerJournalAccountEntryTmpDetail.BondBatchTrans_RU
                        && updateEntrySubledgerJournalAccountEntryTmpDetailOffset.DebitCredit == DebitCredit::Credit;

                if (updateEntrySubledgerJournalAccountEntryTmpDetailOffset)
                {
                    updateEntrySubledgerJournalAccountEntryTmpDetailOffset.AccountingCurrencyAmount -= _accountingCurrencyAmountToRound;
                    updateEntrySubledgerJournalAccountEntryTmpDetailOffset.ReportingCurrencyAmount  -= _reportingCurrencyAmountToRound;
                    updateEntrySubledgerJournalAccountEntryTmpDetailOffset.update();

                    roundingApplied = true;
                }
            }
        }

        // Check if rounding was applied. If not then do a recursive call to this method again,
        // but this time remove the restriction for non tax lines by setting _applyRoundingToNonTaxLineOnly to false
        // To avoid infinite recursion, call to function made only if _applyRoundingToNonTaxLineOnly is true, i. e. only at first pass
        if (_applyRoundingToNonTaxLineOnly && !roundingApplied)
        {
            this.applyRoundingToSubledgerJournalTmpDetail(_subledgerJournalAccountEntryTmpDetail, _accountingCurrencyAmountToRound, _reportingCurrencyAmountToRound, false, roundingApplied);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyRoundingToTmpDetailEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles rounding of created <c>SubledgerJournalAccountEntryTmpDetail</c> records.
    /// </summary>
    /// <param name="_sysEventOverride">
    ///   Insertion override status.
    /// </param>
    /// <param name="_subledgerJournalAccountEntryTmpDetail">
    ///   The <c>SubledgerJournalAccountEntryTmpDetail</c> buffer.
    /// </param>
    /// <param name="_accountingCurrencyAmountToRound">
    ///   The amount of rounding in accounting currency.
    /// </param>
    /// <param name="_reportingCurrencyAmountToRound">
    ///   The amount of rounding in reporting currency.
    /// </param>
    public void applyRoundingToTmpDetailEventHandler(
        SysEventOverride                        _sysEventOverride,
        SubledgerJournalAccountEntryTmpDetail   _subledgerJournalAccountEntryTmpDetail,
        AmountMST                               _accountingCurrencyAmountToRound,
        AmountMSTSecondary                      _reportingCurrencyAmountToRound)
    {
        _sysEventOverride.markAsOverridden();
        this.applyRoundingToSubledgerJournalTmpDetail(_subledgerJournalAccountEntryTmpDetail, _accountingCurrencyAmountToRound, _reportingCurrencyAmountToRound);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSubscribe</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether to subscribe the journalizer event.
    /// </summary>
    /// <returns>
    /// True if we can subscribe the journalizer event; otherwise, false.
    /// </returns>
    protected boolean canSubscribe()
    {
        return SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
                && LedgerParameters::find().Correspondence_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInsertedAccountEntryDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles deletion of <c>SubledgerJournalAccountEntryTmpDetail</c> records regarding distributions.
    /// </summary>
    /// <param name="_tmpDetail">
    /// Subledger journal line detail record.
    /// </param>
    protected void deleteInsertedAccountEntryDistributions(SubledgerJournalAccountEntryTmpDetail _tmpDetail)
    {
        SubledgerJournalAccountEntryDistribution    accountEntryDistribution;
        SubledgerJournalAccountEntry                accountEntry;
        delete_from accountEntryDistribution
            exists join accountEntry
                where accountEntry.RecId == accountEntryDistribution.SubledgerJournalAccountEntry
            exists join _tmpDetail
                where _tmpDetail.SubledgerJournalEntry == accountEntry.SubledgerJournalEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInsertedSubledgerJourAccEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles deletion of <c>SubledgerJournalAccountEntryTmpDetail</c> records.
    /// </summary>
    /// <param name="_tmpDetail">
    /// Subledger journal line detail table.
    /// </param>
    protected void deleteInsertedSubledgerJourAccEntries(SubledgerJournalAccountEntryTmpDetail _tmpDetail)
    {
        SubledgerJournalAccountEntry entry;
        delete_from entry exists join _tmpDetail
            where _tmpDetail.SubledgerJournalEntry == entry.SubledgerJournalEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillBondTmpForSummarize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts grouped data into <c>SubledgerBondTmp</c> for summary preview.
    /// </summary>
    /// <param name="_tmpDetail">
    /// Subledger journal line detail record.
    /// </param>
    /// <param name="_bondTmp">
    /// A temporary cursor containing data for <c>SubledgerJournalAccountEntry</c> table.
    /// </param>
    /// <param name="_accountingEventState">
    /// A state of accounting event.
    /// </param>
    protected void fillBondTmpForSummarize(SubledgerJournalAccountEntryTmpDetail _tmpDetail, SubledgerBondTmp _bondTmp, AccountingEventState _accountingEventState)
    {
        SubledgerJournalAccountEntryTmpDetail   creditTmpDetail;
        AccountingEvent                         accountingEvent;
        AccountingEvent                         accountingEventCredit;

        creditTmpDetail.linkPhysicalTableInstance(_tmpDetail);

        insert_recordset _bondTmp (
            DebitLedgerDimension,
            DebitPostingType,
            DebitTransferPolicy,
            DebitIsCorrection,
            DebitLegalEntity,
            DebitAccountingDate,
            DebitCurrencyCode,
            DebitSubledgerJournalEntry,
            DebitAccountingEvent,
            DebitExchangeRate1,
            DebitReportingExchangeRate1,
            DebitFiscalCalendarPeriod,
            DebitPostingLayer,
            DebitLedgerName,
            DebitLedger,
            DebitAccountingCurrency,
            DebitReportingCurrency,
            DebitJournalNumber,
            DebitSubledgerJournalEntryType,
            DebitExchangeRateDate,
            DebitExchangeRate2,
            DebitReportingExchangeRate2,
            AccountingCurrencyAmount, TransactionCurrencyAmount, ReportingCurrencyAmount,
            AccountingCurrencyAmountUnrounded, ReportingCurrencyAmountUnrounded,
            DebitRoundingLevel,
            DebitSkipAccountValidation,
            CreditLedgerDimension,
            CreditPostingType,
            CreditTransferPolicy,
            CreditIsCorrection,
            CreditLegalEntity,
            CreditAccountingDate,
            CreditCurrencyCode,
            CreditSubledgerJournalEntry,
            CreditAccountingEvent,
            CreditExchangeRate1,
            CreditReportingExchangeRate1,
            CreditFiscalCalendarPeriod,
            CreditPostingLayer,
            CreditLedgerName,
            CreditLedger,
            CreditAccountingCurrency,
            CreditReportingCurrency,
            CreditJournalNumber,
            CreditSubledgerJournalEntryType,
            CreditExchangeRateDate,
            CreditExchangeRate2,
            CreditReportingExchangeRate2,
            CreditTransactionCurrencyAmount,
            CreditAccountingCurrencyAmount,
            CreditReportingCurrencyAmount,
            CreditAccountingCurrencyAmountUnrounded,
            CreditReportingCurrencyAmountUnrounded,
            CreditRoundingLevel,
            CreditSkipAccountValidation
        ) select
            LedgerDimension,
            PostingType,
            TransferPolicy,
            IsCorrection,
            LegalEntity,
            AccountingDate,
            TransactionCurrencyCode,
            SubledgerJournalEntry,
            AccountingEvent,
            ExchangeRate1,
            ReportingExchangeRate1,
            FiscalCalendarPeriod,
            PostingLayer,
            LedgerName,
            Ledger,
            AccountingCurrency,
            ReportingCurrency,
            JournalNumber,
            SubledgerJournalEntryType,
            ExchangeRateDate,
            ExchangeRate2,
            ReportingExchangeRate2,
            sum(AccountingCurrencyAmount), sum(TransactionCurrencyAmount), sum(ReportingCurrencyAmount),
            sum(AccountingCurrencyAmountUnrounded), sum(ReportingCurrencyAmountUnrounded),
            RoundingLevel,
            SkipAccountValidation
            from _tmpDetail group by
            LedgerDimension,
            PostingType,
            TransferPolicy,
            IsCorrection,
            LegalEntity,
            AccountingDate,
            TransactionCurrencyCode,
            SubledgerJournalEntry,
            AccountingEvent,
            ExchangeRate1,
            ReportingExchangeRate1,
            FiscalCalendarPeriod,
            PostingLayer,
            LedgerName,
            Ledger,
            AccountingCurrency,
            ReportingCurrency,
            JournalNumber,
            SubledgerJournalEntryType,
            ExchangeRateDate,
            ExchangeRate2,
            ReportingExchangeRate2,
            RoundingLevel,
            SkipAccountValidation
            where _tmpDetail.DebitCredit == DebitCredit::Debit
            join
            LedgerDimension,
            PostingType,
            TransferPolicy,
            IsCorrection,
            LegalEntity,
            AccountingDate,
            TransactionCurrencyCode,
            SubledgerJournalEntry,
            AccountingEvent,
            ExchangeRate1,
            ReportingExchangeRate1,
            FiscalCalendarPeriod,
            PostingLayer,
            LedgerName,
            Ledger,
            AccountingCurrency,
            ReportingCurrency,
            JournalNumber,
            SubledgerJournalEntryType,
            ExchangeRateDate,
            ExchangeRate2,
            ReportingExchangeRate2,
            sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount),  sum(ReportingCurrencyAmount),
            sum(AccountingCurrencyAmountUnrounded), sum(ReportingCurrencyAmountUnrounded),
            RoundingLevel,
            SkipAccountValidation
        from creditTmpDetail
        group by
            LedgerDimension,
            PostingType,
            TransferPolicy,
            IsCorrection,
            LegalEntity,
            AccountingDate,
            TransactionCurrencyCode,
            SubledgerJournalEntry,
            AccountingEvent,
            ExchangeRate1,
            ReportingExchangeRate1,
            FiscalCalendarPeriod,
            PostingLayer,
            LedgerName,
            Ledger,
            AccountingCurrency,
            ReportingCurrency,
            JournalNumber,
            SubledgerJournalEntryType,
            ExchangeRateDate,
            ExchangeRate2,
            ReportingExchangeRate2,
            RoundingLevel,
            SkipAccountValidation
        where creditTmpDetail.DebitCredit == DebitCredit::Credit &&
                creditTmpDetail.BondBatchTrans_RU == _tmpDetail.BondBatchTrans_RU
            exists join accountingEvent
            where accountingEvent.RecId == _tmpDetail.AccountingEvent &&
                accountingEvent.State == _accountingEventState
            exists join accountingEventCredit
            where accountingEventCredit.RecId == creditTmpDetail.AccountingEvent &&
                accountingEventCredit.State == _accountingEventState;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillBondTmpForSummaryPreview</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts grouped data into <c>SubledgerBondTmp</c> for summary preview.
    /// </summary>
    /// <param name="_tmpDetail">
    /// Subledger journal line detail record.
    /// </param>
    /// <param name="_bondTmp">
    /// A temporary cursor containing data for <c>SubledgerJournalAccountEntry</c> table.
    /// </param>
    protected void fillBondTmpForSummaryPreview(SubledgerJournalAccountEntryTmpDetail _tmpDetail, SubledgerBondTmp _bondTmp)
    {
        SubledgerJournalAccountEntryTmpDetail   creditTmpDetail;
        creditTmpDetail.linkPhysicalTableInstance(_tmpDetail);

        insert_recordset _bondTmp (
            DebitLedgerDimension,
            DebitPostingType,
            DebitTransferPolicy,
            DebitIsCorrection,
            DebitLegalEntity,
            DebitAccountingDate,
            DebitCurrencyCode,
            DebitSubledgerJournalEntry,
            DebitAccountingEvent,
            DebitExchangeRate1,
            DebitReportingExchangeRate1,
            DebitFiscalCalendarPeriod,
            DebitPostingLayer,
            DebitLedgerName,
            DebitLedger,
            DebitAccountingCurrency,
            DebitReportingCurrency,
            DebitJournalNumber,
            DebitSubledgerJournalEntryType,
            DebitExchangeRateDate,
            DebitExchangeRate2,
            DebitReportingExchangeRate2,
            AccountingCurrencyAmount, TransactionCurrencyAmount, ReportingCurrencyAmount,
            AccountingCurrencyAmountUnrounded, ReportingCurrencyAmountUnrounded,
            DebitRoundingLevel,
            DebitSkipAccountValidation,
            CreditLedgerDimension,
            CreditPostingType,
            CreditTransferPolicy,
            CreditIsCorrection,
            CreditLegalEntity,
            CreditAccountingDate,
            CreditCurrencyCode,
            CreditSubledgerJournalEntry,
            CreditAccountingEvent,
            CreditExchangeRate1,
            CreditReportingExchangeRate1,
            CreditFiscalCalendarPeriod,
            CreditPostingLayer,
            CreditLedgerName,
            CreditLedger,
            CreditAccountingCurrency,
            CreditReportingCurrency,
            CreditJournalNumber,
            CreditSubledgerJournalEntryType,
            CreditExchangeRateDate,
            CreditExchangeRate2,
            CreditReportingExchangeRate2,
            CreditAccountingCurrencyAmount,
            CreditTransactionCurrencyAmount,
            CreditReportingCurrencyAmount,
            CreditAccountingCurrencyAmountUnrounded,
            CreditReportingCurrencyAmountUnrounded,
            CreditRoundingLevel,
            CreditSkipAccountValidation
        ) select
            LedgerDimension,
            PostingType,
            TransferPolicy,
            IsCorrection,
            LegalEntity,
            AccountingDate,
            TransactionCurrencyCode,
            SubledgerJournalEntry,
            AccountingEvent,
            ExchangeRate1,
            ReportingExchangeRate1,
            FiscalCalendarPeriod,
            PostingLayer,
            LedgerName,
            Ledger,
            AccountingCurrency,
            ReportingCurrency,
            JournalNumber,
            SubledgerJournalEntryType,
            ExchangeRateDate,
            ExchangeRate2,
            ReportingExchangeRate2,
            sum(AccountingCurrencyAmount), sum(TransactionCurrencyAmount), sum(ReportingCurrencyAmount),
            sum(AccountingCurrencyAmountUnrounded), sum(ReportingCurrencyAmountUnrounded),
            RoundingLevel,
            SkipAccountValidation
            from _tmpDetail group by
            LedgerDimension,
            PostingType,
            TransferPolicy,
            IsCorrection,
            LegalEntity,
            AccountingDate,
            TransactionCurrencyCode,
            SubledgerJournalEntry,
            AccountingEvent,
            ExchangeRate1,
            ReportingExchangeRate1,
            FiscalCalendarPeriod,
            PostingLayer,
            LedgerName,
            Ledger,
            AccountingCurrency,
            ReportingCurrency,
            JournalNumber,
            SubledgerJournalEntryType,
            ExchangeRateDate,
            ExchangeRate2,
            ReportingExchangeRate2,
            RoundingLevel,
            SkipAccountValidation
            where _tmpDetail.DebitCredit == DebitCredit::Debit &&
                _tmpDetail.AccountingEvent == 0
            join
            LedgerDimension,
            PostingType,
            TransferPolicy,
            IsCorrection,
            LegalEntity,
            AccountingDate,
            TransactionCurrencyCode,
            SubledgerJournalEntry,
            AccountingEvent,
            ExchangeRate1,
            ReportingExchangeRate1,
            FiscalCalendarPeriod,
            PostingLayer,
            LedgerName,
            Ledger,
            AccountingCurrency,
            ReportingCurrency,
            JournalNumber,
            SubledgerJournalEntryType,
            ExchangeRateDate,
            ExchangeRate2,
            ReportingExchangeRate2,
            sum(AccountingCurrencyAmount), sum(TransactionCurrencyAmount), sum(ReportingCurrencyAmount),
            sum(AccountingCurrencyAmountUnrounded), sum(ReportingCurrencyAmountUnrounded),
            RoundingLevel,
            SkipAccountValidation
        from creditTmpDetail
        group by
            LedgerDimension,
            PostingType,
            TransferPolicy,
            IsCorrection,
            LegalEntity,
            AccountingDate,
            TransactionCurrencyCode,
            SubledgerJournalEntry,
            AccountingEvent,
            ExchangeRate1,
            ReportingExchangeRate1,
            FiscalCalendarPeriod,
            PostingLayer,
            LedgerName,
            Ledger,
            AccountingCurrency,
            ReportingCurrency,
            JournalNumber,
            SubledgerJournalEntryType,
            ExchangeRateDate,
            ExchangeRate2,
            ReportingExchangeRate2,
            RoundingLevel,
            SkipAccountValidation
        where creditTmpDetail.DebitCredit       == DebitCredit::Credit          &&
                creditTmpDetail.BondBatchTrans_RU == _tmpDetail.BondBatchTrans_RU &&
                creditTmpDetail.AccountingEvent   == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBondBatchTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets Bond Batch Trans num for a given key.
    /// </summary>
    /// <param name="_keyRecId">
    /// Record Id of a disribution or other key used to split transactions(like source document line).
    /// </param>
    /// <param name="_entry">
    /// Record Id of account entry.
    /// </param>
    /// <param name="_externalBondBatchTrans_RU">
    /// External Bond batch trans number.
    /// </param>
    /// <returns>
    /// Returns Bond Batch Trans num for a given key.
    /// </returns>
    protected LedgerBondBatchTransNum_RU getBondBatchTrans(RecId _keyRecId, RecId _entry, LedgerBondBatchTransNum_RU _externalBondBatchTrans_RU)
    {
        LedgerBondBatchTransNum_RU ret;
        container key = [_keyRecId, _entry, _externalBondBatchTrans_RU];
        if (importedBond.exists(key))
        {
            ret = importedBond.lookup(key);
        }
        else
        {
            bondBatchTrans ++;
            ret = bondBatchTrans;
            importedBond.insert(key, ret);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupIntoTmpBond</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts grouped data into <c>SubledgerBondTmp</c>.
    /// </summary>
    /// <param name="_tmpDetail">
    /// Source of records.
    /// </param>
    /// <param name="_bondTmp">
    /// A temporary cursor containing data for <c>SubledgerJournalAccountEntry</c> table.
    /// </param>
    protected void groupIntoTmpBond(SubledgerJournalAccountEntryTmpDetail _tmpDetail, SubledgerBondTmp _bondTmp)
    {
        SubledgerJournalAccountEntryTmpDetail creditTmpDetail;
        creditTmpDetail.linkPhysicalTableInstance(_tmpDetail);
        insert_recordset _bondTmp (
            DebitSubledgerJournalEntry,
            DebitLedgerDimension,
            DebitPostingType,
            DebitExchangeRateDate,
            DebitExchangeRate1,
            DebitCurrencyCode,
            DebitReportingExchangeRate1,
            DebitExchangeRate2,
            DebitReportingExchangeRate2,
            DebitTransferPolicy,
            DebitIsCorrection,
            AccountingCurrencyAmount, TransactionCurrencyAmount, ReportingCurrencyAmount,
            CreditSubledgerJournalEntry,
            CreditLedgerDimension,
            CreditPostingType,
            CreditExchangeRateDate,
            CreditExchangeRate1,
            CreditCurrencyCode,
            CreditReportingExchangeRate1,
            CreditExchangeRate2,
            CreditReportingExchangeRate2,
            CreditTransferPolicy,
            CreditIsCorrection,
            CreditAccountingCurrencyAmount, CreditTransactionCurrencyAmount, CreditReportingCurrencyAmount
        ) select
            SubledgerJournalEntry,
            LedgerDimension,
            PostingType,
            ExchangeRateDate,
            ExchangeRate1,
            TransactionCurrencyCode,
            ReportingExchangeRate1,
            ExchangeRate2,
            ReportingExchangeRate2,
            TransferPolicy,
            IsCorrection,
            sum(AccountingCurrencyAmount), sum(TransactionCurrencyAmount), sum(ReportingCurrencyAmount)
            from _tmpDetail group by
            SubledgerJournalEntry,
            LedgerDimension,
            PostingType,
            ExchangeRateDate,
            ExchangeRate1,
            TransactionCurrencyCode,
            ReportingExchangeRate1,
            ExchangeRate2,
            ReportingExchangeRate2,
            TransferPolicy,
            IsCorrection
            where _tmpDetail.DebitCredit == DebitCredit::Debit
            join
            SubledgerJournalEntry,
            LedgerDimension,
            PostingType,
            ExchangeRateDate,
            ExchangeRate1,
            TransactionCurrencyCode,
            ReportingExchangeRate1,
            ExchangeRate2,
            ReportingExchangeRate2,
            TransferPolicy,
            IsCorrection,
            sum(AccountingCurrencyAmount), sum(TransactionCurrencyAmount), sum(ReportingCurrencyAmount)
            from creditTmpDetail
            group by
                SubledgerJournalEntry,
                LedgerDimension,
                PostingType,
                ExchangeRateDate,
                ExchangeRate1,
                TransactionCurrencyCode,
                ReportingExchangeRate1,
                ExchangeRate2,
                ReportingExchangeRate2,
                TransferPolicy,
                IsCorrection
            where creditTmpDetail.DebitCredit == DebitCredit::Credit &&
                    creditTmpDetail.BondBatchTrans_RU == _tmpDetail.BondBatchTrans_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupIntoTmpBondFromSLJAESummary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts grouped data into <c>SubledgerBondTmp</c>.
    /// </summary>
    /// <param name="_tmpSLJAE">
    /// Source of records.
    /// </param>
    /// <param name="_bondTmp">
    /// A temporary cursor containing data for <c>SubledgerJournalAccountEntry</c> table.
    /// </param>
    protected void groupIntoTmpBondFromSLJAESummary(SubledgerJournalAccountEntryTmpSummary _tmpSLJAE, SubledgerBondTmp _bondTmp)
    {
        SubledgerJournalAccountEntryTmpSummary creditTmpSLJAE;
        creditTmpSLJAE.linkPhysicalTableInstance(_tmpSLJAE);
        insert_recordset _bondTmp (
            DebitSubledgerJournalEntry,
            DebitLedgerDimension,
            DebitPostingType,
            DebitExchangeRateDate,
            DebitExchangeRate1,
            DebitCurrencyCode,
            DebitReportingExchangeRate1,
            DebitExchangeRate2,
            DebitReportingExchangeRate2,
            DebitTransferPolicy,
            DebitIsCorrection,
            AccountingCurrencyAmount, TransactionCurrencyAmount, ReportingCurrencyAmount,
            CreditSubledgerJournalEntry,
            CreditLedgerDimension,
            CreditPostingType,
            CreditExchangeRateDate,
            CreditExchangeRate1,
            CreditCurrencyCode,
            CreditReportingExchangeRate1,
            CreditExchangeRate2,
            CreditReportingExchangeRate2,
            CreditTransferPolicy,
            CreditIsCorrection,
            CreditAccountingCurrencyAmount, CreditTransactionCurrencyAmount, CreditReportingCurrencyAmount
        ) select
            SubledgerJournalEntry,
            LedgerDimension,
            PostingType,
            ExchangeRateDate,
            ExchangeRate1,
            TransactionCurrencyCode,
            ReportingExchangeRate1,
            ExchangeRate2,
            ReportingExchangeRate2,
            TransferPolicy,
            IsCorrection,
            sum(AccountingCurrencyAmount), sum(TransactionCurrencyAmount), sum(ReportingCurrencyAmount)
            from _tmpSLJAE group by
            SubledgerJournalEntry,
            LedgerDimension,
            PostingType,
            ExchangeRateDate,
            ExchangeRate1,
            TransactionCurrencyCode,
            ReportingExchangeRate1,
            ExchangeRate2,
            ReportingExchangeRate2,
            TransferPolicy,
            IsCorrection
            where _tmpSLJAE.DebitCredit == DebitCredit::Debit
            join
            SubledgerJournalEntry,
            LedgerDimension,
            PostingType,
            ExchangeRateDate,
            ExchangeRate1,
            TransactionCurrencyCode,
            ReportingExchangeRate1,
            ExchangeRate2,
            ReportingExchangeRate2,
            TransferPolicy,
            IsCorrection,
            sum(AccountingCurrencyAmount), sum(TransactionCurrencyAmount), sum(ReportingCurrencyAmount)
            from creditTmpSLJAE
            group by
                SubledgerJournalEntry,
                LedgerDimension,
                PostingType,
                ExchangeRateDate,
                ExchangeRate1,
                TransactionCurrencyCode,
                ReportingExchangeRate1,
                ExchangeRate2,
                ReportingExchangeRate2,
                TransferPolicy,
                IsCorrection
            where creditTmpSLJAE.DebitCredit == DebitCredit::Credit &&
                    creditTmpSLJAE.BondBatchTrans_RU == _tmpSLJAE.BondBatchTrans_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>importCorrespondenceLinkFromSubledger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets Bond Batch Trans num from linked subledger.
    /// </summary>
    /// <param name="_subledgerJournalEntry">
    /// <c>SubledgerJournalEntry</c> record.
    /// </param>
    /// <param name="_subledgerJournalAccountEntry">
    /// Subledger journal account entry record.
    /// </param>
    /// <param name="_splitKey">
    /// Record Id of target accounting distribution or other key used to split transactions.
    /// </param>
    /// <returns>
    /// Returns Bond Batch Trans num.
    /// </returns>
    protected LedgerBondBatchTransNum_RU importCorrespondenceLinkFromSubledger(SubledgerJournalEntry _subledgerJournalEntry, SubledgerJournalAccountEntry _subledgerJournalAccountEntry, RecId _splitKey)
    {
        SubledgerJournalAccountEntryBond    entryBond;

        while select entryBond
        where entryBond.SubledgerJournalAccountEntry == _subledgerJournalAccountEntry.RecId
        {
            return this.getBondBatchTrans(_splitKey, _subledgerJournalEntry.RecId, entryBond.BondBatchTrans);
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>incLastBatchTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Increments last batch numbers for debit or credit.
    /// </summary>
    /// <param name="_record">
    /// The <c>AccountingDistributionTmp</c> table holds the accounting distributions.
    /// </param>
    protected void incLastBatchTrans(AccountingDistributionTmp _record)
    {
        if (_record.AmountSign == DebitCredit::Debit)
        {
            lastDebit++;
        }
        else
        {
            lastCredit++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertAccountEntriesFromTmpSummary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the event insertion of subledger journal account entries.
    /// </summary>
    /// <param name="_tmpSummary">
    /// The summarized source temporary table.
    /// </param>
    /// <param name="_tmpDetail">
    /// The detailed source temporary table.
    /// </param>
    public void insertAccountEntriesFromTmpSummary(SubledgerJournalAccountEntryTmpSummary _tmpSummary, SubledgerJournalAccountEntryTmpDetail _tmpDetail)
    {
        SubledgerBondTmp                        bondTmp;

        bondTmp.skipDatabaseLog(true);
        bondTmp.skipDataMethods(true);
        bondTmp.skipEvents(true);

        this.deleteInsertedSubledgerJourAccEntries(_tmpDetail);
        this.groupIntoTmpBondFromSLJAESummary(_tmpSummary, bondTmp);
        this.insertSubledgerJournalAccountEntry(bondTmp);
        this.insertSubledgerJournalAccountEntryBond(bondTmp);
        this.insertBondMap(_tmpDetail, bondTmp);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertBondMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles insertion of <c>SubledgerBondMapTmp</c> table.
    /// </summary>
    /// <param name="_tmpDetail">
    /// Subledger journal line detail record.
    /// </param>
    /// <param name="_bondTmp">
    /// A temporary cursor containing data for <c>SubledgerBondMapTmp</c> table.
    /// </param>
    protected void insertBondMap(SubledgerJournalAccountEntryTmpDetail _tmpDetail, SubledgerBondTmp _bondTmp)
    {
        SubledgerJournalAccountEntryTmpDetail creditTmpDetail;
        creditTmpDetail.linkPhysicalTableInstance(_tmpDetail);
        delete_from bondMap;
        insert_recordset bondMap (NewBatchTrans, OriginalBatchTrans)
            select RecId from _bondTmp group by RecId
                join BondBatchTrans_RU from _tmpDetail group by BondBatchTrans_RU
                    where
                        _tmpDetail.DebitCredit == DebitCredit::Debit                                &&
                        _tmpDetail.SubledgerJournalEntry == _bondTmp.DebitSubledgerJournalEntry      &&
                        _tmpDetail.LedgerDimension == _bondTmp.DebitLedgerDimension                  &&
                        _tmpDetail.PostingType == _bondTmp.DebitPostingType                          &&
                        _tmpDetail.ExchangeRateDate == _bondTmp.DebitExchangeRateDate                &&
                        _tmpDetail.ExchangeRate1 == _bondTmp.DebitExchangeRate1                      &&
                        _tmpDetail.TransactionCurrencyCode == _bondTmp.DebitCurrencyCode             &&
                        _tmpDetail.ReportingExchangeRate1 == _bondTmp.DebitReportingExchangeRate1    &&
                        _tmpDetail.ExchangeRate2 == _bondTmp.DebitExchangeRate2                      &&
                        _tmpDetail.ReportingExchangeRate2 == _bondTmp.DebitReportingExchangeRate2    &&
                        _tmpDetail.TransferPolicy == _bondTmp.DebitTransferPolicy                    &&
                        _tmpDetail.IsCorrection == _bondTmp.DebitIsCorrection
                join creditTmpDetail where
                    creditTmpDetail.DebitCredit == DebitCredit::Credit                              &&
                    creditTmpDetail.SubledgerJournalEntry == _bondTmp.CreditSubledgerJournalEntry    &&
                    creditTmpDetail.LedgerDimension == _bondTmp.CreditLedgerDimension                &&
                    creditTmpDetail.PostingType == _bondTmp.CreditPostingType                        &&
                    creditTmpDetail.ExchangeRateDate == _bondTmp.CreditExchangeRateDate              &&
                    creditTmpDetail.ExchangeRate1 == _bondTmp.CreditExchangeRate1                    &&
                    creditTmpDetail.TransactionCurrencyCode == _bondTmp.CreditCurrencyCode           &&
                    creditTmpDetail.ReportingExchangeRate1 == _bondTmp.CreditReportingExchangeRate1  &&
                    creditTmpDetail.ExchangeRate2 == _bondTmp.CreditExchangeRate2                    &&
                    creditTmpDetail.ReportingExchangeRate2 == _bondTmp.CreditReportingExchangeRate2  &&
                    creditTmpDetail.TransferPolicy == _bondTmp.CreditTransferPolicy                  &&
                    creditTmpDetail.IsCorrection == _bondTmp.CreditIsCorrection                      &&
                    creditTmpDetail.BondBatchTrans_RU == _tmpDetail.BondBatchTrans_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCreditToTmpSummary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles insertion of credit subledger journal account entry.
    /// </summary>
    /// <param name="_bondTmp">
    /// A temporary cursor containing data for <c>SubledgerJournalAccountEntry</c> table.
    /// </param>
    /// <param name="_tmpSummary">
    /// The SubledgerJournalAccountEntryTmpSummary table holds the subledger journal account entries.
    /// </param>
    protected void insertCreditToTmpSummary(SubledgerBondTmp _bondTmp, SubledgerJournalAccountEntryTmpSummary  _tmpSummary)
    {
        DebitCredit debitCredit = DebitCredit::Credit;
        insert_recordset _tmpSummary (
            LedgerDimension,
            PostingType,
            TransferPolicy,
            IsCorrection,
            LegalEntity,
            AccountingDate,
            TransactionCurrencyCode,
            SubledgerJournalEntry,
            AccountingEvent,
            ExchangeRate1,
            ReportingExchangeRate1,
            FiscalCalendarPeriod,
            PostingLayer,
            LedgerName,
            Ledger,
            AccountingCurrency,
            ReportingCurrency,
            JournalNumber,
            SubledgerJournalEntryType,
            ExchangeRateDate,
            ExchangeRate2,
            ReportingExchangeRate2,
            DebitCredit,
            TransactionCurrencyAmount,
            AccountingCurrencyAmount,
            ReportingCurrencyAmount,
            BondBatchTrans_RU,
            AccountingCurrencyAmountUnrounded,
            ReportingCurrencyAmountUnrounded,
            RoundingLevel,
            SkipAccountValidation,
            IsRoundingAdjustment
        )
        select
            CreditLedgerDimension,
            CreditPostingType,
            CreditTransferPolicy,
            CreditIsCorrection,
            CreditLegalEntity,
            CreditAccountingDate,
            CreditCurrencyCode,
            CreditSubledgerJournalEntry,
            CreditAccountingEvent,
            CreditExchangeRate1,
            CreditReportingExchangeRate1,
            CreditFiscalCalendarPeriod,
            CreditPostingLayer,
            CreditLedgerName,
            CreditLedger,
            CreditAccountingCurrency,
            CreditReportingCurrency,
            CreditJournalNumber,
            CreditSubledgerJournalEntryType,
            CreditExchangeRateDate,
            CreditExchangeRate2,
            CreditReportingExchangeRate2,
            debitCredit,
            CreditTransactionCurrencyAmount,
            CreditAccountingCurrencyAmount,
            CreditReportingCurrencyAmount,
            RecId,
            CreditAccountingCurrencyAmountUnrounded,
            CreditReportingCurrencyAmountUnrounded,
            CreditRoundingLevel,
            CreditSkipAccountValidation,
            CreditIsRoundingAdjustment
        from _bondTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDebitToTmpSummary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles insertion of debit subledger journal account entry.
    /// </summary>
    /// <param name="_bondTmp">
    /// A temporary cursor containing data for <c>SubledgerJournalAccountEntry</c> table.
    /// </param>
    /// <param name="_tmpSummary">
    /// The SubledgerJournalAccountEntryTmpSummary table holds the subledger journal account entries.
    /// </param>
    protected void insertDebitToTmpSummary(SubledgerBondTmp _bondTmp, SubledgerJournalAccountEntryTmpSummary  _tmpSummary)
    {
        DebitCredit debitCredit = DebitCredit::Debit;
        insert_recordset _tmpSummary (
            LedgerDimension,
            PostingType,
            TransferPolicy,
            IsCorrection,
            LegalEntity,
            AccountingDate,
            TransactionCurrencyCode,
            SubledgerJournalEntry,
            AccountingEvent,
            ExchangeRate1,
            ReportingExchangeRate1,
            FiscalCalendarPeriod,
            PostingLayer,
            LedgerName,
            Ledger,
            AccountingCurrency,
            ReportingCurrency,
            JournalNumber,
            SubledgerJournalEntryType,
            ExchangeRateDate,
            ExchangeRate2,
            ReportingExchangeRate2,
            DebitCredit,
            TransactionCurrencyAmount,
            AccountingCurrencyAmount,
            ReportingCurrencyAmount,
            BondBatchTrans_RU,
            AccountingCurrencyAmountUnrounded,
            ReportingCurrencyAmountUnrounded,
            RoundingLevel,
            SkipAccountValidation,
            IsRoundingAdjustment
        )
        select
            DebitLedgerDimension,
            DebitPostingType,
            DebitTransferPolicy,
            DebitIsCorrection,
            DebitLegalEntity,
            DebitAccountingDate,
            DebitCurrencyCode,
            DebitSubledgerJournalEntry,
            DebitAccountingEvent,
            DebitExchangeRate1,
            DebitReportingExchangeRate1,
            DebitFiscalCalendarPeriod,
            DebitPostingLayer,
            DebitLedgerName,
            DebitLedger,
            DebitAccountingCurrency,
            DebitReportingCurrency,
            DebitJournalNumber,
            DebitSubledgerJournalEntryType,
            DebitExchangeRateDate,
            DebitExchangeRate2,
            DebitReportingExchangeRate2,
            debitCredit,
            TransactionCurrencyAmount,
            AccountingCurrencyAmount,
            ReportingCurrencyAmount,
            RecId,
            AccountingCurrencyAmountUnrounded,
            ReportingCurrencyAmountUnrounded,
            DebitRoundingLevel,
            DebitSkipAccountValidation,
            DebitIsRoundingAdjustment
        from _bondTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertingDistributedTmpEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Handles the <c>insertingDistributedTmp</c> event.
    /// </summary>
    /// <param name="_record">
    ///    The record being inserted.
    /// </param>
    public void insertingDistributedTmpEventHandler(AccountingDistributionTmp _record)
    {
        this.processToTmp(_record);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertingImportedSubAccEntryEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the <c>insertingImportedSubledgerJournalAccountEntry</c> event.
    /// </summary>
    /// <param name="_subledgerJournalEntry">
    /// The subledger journal entry.
    /// </param>
    /// <param name="_subledgerJournalAccountEntry">
    /// The subledger journal account entry.
    /// </param>
    /// <param name="_accountingDistributionTmp">
    /// A temporary table.
    /// </param>
    /// <param name="_recordInsertList">
    /// An instance of the <c>RecordInsertList</c> class.
    /// </param>
    public void insertingImportedSubAccEntryEventHandler(SubledgerJournalEntry _subledgerJournalEntry, SubledgerJournalAccountEntry _subledgerJournalAccountEntry, AccountingDistributionTmp _accountingDistributionTmp, RecordInsertList _recordInsertList)
    {
        _accountingDistributionTmp.BondBatchTrans_RU = this.importCorrespondenceLinkFromSubledger(_subledgerJournalEntry, _subledgerJournalAccountEntry, _accountingDistributionTmp.AccountingDistribution);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertingJournalizingTmpEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the insert of journalized transactions to the temporary table.
    /// </summary>
    /// <param name="_record">
    /// The record being inserted.
    /// </param>
    public void insertingJournalizingTmpEventHandler(AccountingDistributionTmp _record)
    {
        this.processToTmp(_record);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertNewAccountEntryDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles insertion of <c>SubledgerJournalAccountEntryDistribution</c> table.
    /// </summary>
    /// <param name="_tmpDetail">
    /// Subledger journal line detail record.
    /// </param>
    /// <param name="_accountingEvent">
    /// Accounting event.
    /// </param>
    protected void insertNewAccountEntryDistributions(SubledgerJournalAccountEntryTmpDetail _tmpDetail, AccountingEvent _accountingEvent)
    {
        SubledgerJournalAccountEntry                accountEntry;
        SubledgerJournalAccountEntryBond            accountEntryBond_RU;
        SubledgerJournalAccountEntryDistribution    accountEntryDistribution;
        insert_recordset accountEntryDistribution(
            AccountingDistribution,
            ParentDistribution,
            AccountingCurrencyAmount,
            ReportingCurrencyAmount,
            SubledgerJournalAccountEntry
        )
        select AccountingDistribution,
                ParentDistribution,
                sum(AccountingCurrencyAmount),
                sum(ReportingCurrencyAmount)
            from _tmpDetail
            group by AccountingDistribution, ParentDistribution
            where _tmpDetail.AccountingEvent == _accountingEvent.RecId &&
                _tmpDetail.IsRoundingAdjustment == NoYes::No
            join RecId from accountEntry
            group by RecId
            where accountEntry.SubledgerJournalEntry    == _tmpDetail.SubledgerJournalEntry &&
                    accountEntry.LedgerDimension          == _tmpDetail.LedgerDimension &&
                    accountEntry.PostingType              == _tmpDetail.PostingType &&
                    accountEntry.ExchangeRate1            == _tmpDetail.ExchangeRate1 &&
                    accountEntry.TransactionCurrency      == _tmpDetail.TransactionCurrencyCode &&
                    accountEntry.ReportingExchangeRate1   == _tmpDetail.ReportingExchangeRate1 &&
                    accountEntry.IsCorrection             == _tmpDetail.IsCorrection &&
                    accountEntry.ExchangeRateDate         == _tmpDetail.ExchangeRateDate &&
                    accountEntry.ExchangeRate2            == _tmpDetail.ExchangeRate2 &&
                    accountEntry.ReportingExchangeRate2   == _tmpDetail.ReportingExchangeRate2 &&
                    accountEntry.Side                     == _tmpDetail.DebitCredit
            exists join accountEntryBond_RU
                where accountEntryBond_RU.SubledgerJournalAccountEntry == accountEntry.RecId
                exists join bondMap
                where bondMap.OriginalBatchTrans == _tmpDetail.BondBatchTrans_RU             &&
                        bondMap.NewBatchTrans == accountEntryBond_RU.BondBatchTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSubledgerJourAccEntryEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the event insertion of subledger journal account entries.
    /// </summary>
    /// <param name="_tmpDetail">
    /// A temporary table.
    /// </param>
    public void insertSubledgerJourAccEntryEventHandler(SubledgerJournalAccountEntryTmpDetail _tmpDetail)
    {
        SubledgerBondTmp                        bondTmp;
        bondTmp.skipDatabaseLog(true);
        bondTmp.skipDataMethods(true);
        bondTmp.skipEvents(true);
        this.deleteInsertedSubledgerJourAccEntries(_tmpDetail);
        this.groupIntoTmpBond(_tmpDetail, bondTmp);
        this.insertSubledgerJournalAccountEntry(bondTmp);
        this.insertSubledgerJournalAccountEntryBond(bondTmp);
        this.insertBondMap(_tmpDetail, bondTmp);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSubledgerJournalAccountEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles insertion of <c>SubledgerJournalAccountEntry</c> table.
    /// </summary>
    /// <param name="_bondTmp">
    /// A temporary cursor containing data for <c>SubledgerJournalAccountEntry</c> table.
    /// </param>
    protected void insertSubledgerJournalAccountEntry(SubledgerBondTmp _bondTmp)
    {
        SubledgerJournalAccountEntry accountEntry;
        DebitCredit                  debitSide = DebitCredit::Debit;
        DebitCredit                  creditSide = DebitCredit::Credit;
        accountEntry.skipDataMethods(true);

        insert_recordset accountEntry (
                SubledgerJournalEntry,
                LedgerDimension,
                PostingType,
                ExchangeRateDate,
                ExchangeRate1,
                TransactionCurrency,
                ReportingExchangeRate1,
                ExchangeRate2,
                ReportingExchangeRate2,
                IsTransferredInDetail,
                IsCorrection,
                Side,
                TransactionCurrencyAmount,
                AccountingCurrencyAmount,
                ReportingCurrencyAmount,
                OriginalTransferPolicy
        )
        select
            DebitSubledgerJournalEntry,
            DebitLedgerDimension,
            DebitPostingType,
            DebitExchangeRateDate,
            DebitExchangeRate1,
            DebitCurrencyCode,
            DebitReportingExchangeRate1,
            DebitExchangeRate2,
            DebitReportingExchangeRate2,
            DebitTransferPolicy,
            DebitIsCorrection,
            debitSide,
            TransactionCurrencyAmount,
            AccountingCurrencyAmount,
            ReportingCurrencyAmount,
            DebitTransferPolicy
        from _bondTmp;

        insert_recordset accountEntry (
            SubledgerJournalEntry,
            LedgerDimension,
            PostingType,
            ExchangeRateDate,
            ExchangeRate1,
            TransactionCurrency,
            ReportingExchangeRate1,
            ExchangeRate2,
            ReportingExchangeRate2,
            IsTransferredInDetail,
            IsCorrection,
            Side,
            TransactionCurrencyAmount,
            AccountingCurrencyAmount,
            ReportingCurrencyAmount,
            OriginalTransferPolicy
        )
        select
            CreditSubledgerJournalEntry,
            CreditLedgerDimension,
            CreditPostingType,
            CreditExchangeRateDate,
            CreditExchangeRate1,
            CreditCurrencyCode,
            CreditReportingExchangeRate1,
            CreditExchangeRate2,
            CreditReportingExchangeRate2,
            CreditTransferPolicy,
            CreditIsCorrection,
            creditSide,
            CreditTransactionCurrencyAmount,
            CreditAccountingCurrencyAmount,
            CreditReportingCurrencyAmount,
            CreditTransferPolicy
        from _bondTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSubledgerJournalAccountEntryBond</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles insertion of <c>SubledgerJournalAccountEntryBond</c> table.
    /// </summary>
    /// <param name="_bondTmp">
    /// A temporary cursor containing data for <c>SubledgerJournalAccountEntry</c> table.
    /// </param>
    /// <param name="_usedBondBatchTrans">
    /// Last bond batch used for this subledgerJournalEntry; optional.
    /// </param>
    protected void insertSubledgerJournalAccountEntryBond(SubledgerBondTmp _bondTmp, LedgerBondBatchTransNum_RU _usedBondBatchTrans = 0)
    {
        SubledgerJournalAccountEntryBond    subledgerBond;
        SubledgerJournalAccountEntry        accountEntry;
        Set                                 addedEntries = new Set(typeName2Type(extendedTypeStr(RecId)));
        Set                                 addedBatches = new Set(typeName2Type(extendedTypeStr(LedgerBondBatchTransNum_RU)));
        while select RecId from accountEntry group by RecId order by RecId
            where accountEntry.Side == DebitCredit::Debit
            join RecId from _bondTmp group by RecId
                where
                    accountEntry.SubledgerJournalEntry == _bondTmp.DebitSubledgerJournalEntry    &&
                    accountEntry.LedgerDimension == _bondTmp.DebitLedgerDimension                &&
                    accountEntry.PostingType == _bondTmp.DebitPostingType                        &&
                    accountEntry.ExchangeRateDate == _bondTmp.DebitExchangeRateDate              &&
                    accountEntry.ExchangeRate1 == _bondTmp.DebitExchangeRate1                    &&
                    accountEntry.TransactionCurrency == _bondTmp.DebitCurrencyCode               &&
                    accountEntry.ReportingExchangeRate1 == _bondTmp.DebitReportingExchangeRate1  &&
                    accountEntry.ExchangeRate2 == _bondTmp.DebitExchangeRate2                    &&
                    accountEntry.ReportingExchangeRate2 == _bondTmp.DebitReportingExchangeRate2  &&
                    accountEntry.IsTransferredInDetail == _bondTmp.DebitTransferPolicy           &&
                    accountEntry.IsCorrection == _bondTmp.DebitIsCorrection                      &&
                    _bondTmp.TransactionCurrencyAmount == accountEntry.TransactionCurrencyAmount &&
                    _bondTmp.AccountingCurrencyAmount == accountEntry.AccountingCurrencyAmount   &&
                    _bondTmp.ReportingCurrencyAmount == accountEntry.ReportingCurrencyAmount
        {
            if (! addedEntries.in(accountEntry.RecId) && ! addedBatches.in(_bondTmp.RecId + _usedBondBatchTrans))
            {
                subledgerBond.SubledgerJournalAccountEntry  = accountEntry.RecId;
                subledgerBond.BondBatchTrans                = _bondTmp.RecId + _usedBondBatchTrans;
                subledgerBond.insert();
                addedEntries.add(accountEntry.RecId);
                addedBatches.add(_bondTmp.RecId + _usedBondBatchTrans);
            }
        }

        addedEntries = new Set(typeName2Type(extendedTypeStr(RecId)));
        addedBatches = new Set(typeName2Type(extendedTypeStr(LedgerBondBatchTransNum_RU)));

        while select RecId from accountEntry group by RecId order by RecId
            where accountEntry.Side == DebitCredit::Credit
            join RecId from _bondTmp group by RecId
                where
                    accountEntry.SubledgerJournalEntry == _bondTmp.CreditSubledgerJournalEntry   &&
                    accountEntry.LedgerDimension == _bondTmp.CreditLedgerDimension               &&
                    accountEntry.PostingType == _bondTmp.CreditPostingType                       &&
                    accountEntry.ExchangeRateDate == _bondTmp.CreditExchangeRateDate             &&
                    accountEntry.ExchangeRate1 == _bondTmp.CreditExchangeRate1                   &&
                    accountEntry.TransactionCurrency == _bondTmp.CreditCurrencyCode              &&
                    accountEntry.ReportingExchangeRate1 == _bondTmp.CreditReportingExchangeRate1 &&
                    accountEntry.ExchangeRate2 == _bondTmp.CreditExchangeRate2                   &&
                    accountEntry.ReportingExchangeRate2 == _bondTmp.CreditReportingExchangeRate2 &&
                    accountEntry.IsTransferredInDetail == _bondTmp.CreditTransferPolicy          &&
                    accountEntry.IsCorrection == _bondTmp.CreditIsCorrection                     &&
                    _bondTmp.CreditTransactionCurrencyAmount == accountEntry.TransactionCurrencyAmount &&
                    _bondTmp.CreditAccountingCurrencyAmount == accountEntry.AccountingCurrencyAmount   &&
                    _bondTmp.CreditReportingCurrencyAmount == accountEntry.ReportingCurrencyAmount
        {
            if (! addedEntries.in(accountEntry.RecId) && ! addedBatches.in(_bondTmp.RecId + _usedBondBatchTrans))
            {
                subledgerBond.SubledgerJournalAccountEntry  = accountEntry.RecId;
                subledgerBond.BondBatchTrans                = _bondTmp.RecId + _usedBondBatchTrans;
                subledgerBond.insert();
                addedEntries.add(accountEntry.RecId);
                addedBatches.add(_bondTmp.RecId + _usedBondBatchTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadedAccDistTmpRelievAccrEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles events when the <c>_subledgerJournalAccountEntryTmpDetail</c> argument is loaded.
    /// </summary>
    /// <param name="_subledgerJournalAccountEntryRelievingTmp">
    /// The destination <c>SubledgerJournalAccountEntryRelievingTmp</c> table.
    /// </param>
    public void loadedAccDistTmpRelievAccrEventHandler(SubledgerJournalAccountEntryRelievingTmp _subledgerJournalAccountEntryRelievingTmp)
    {
        SubledgerJournalEntry subledgerJournalEntry;
        SubledgerJournalAccountEntry subledgerJournalAccountEntry;

        this.startingLoadAccDstrTmpForFinEventHandler();

        while select forUpdate _subledgerJournalAccountEntryRelievingTmp
        join RecId from subledgerJournalAccountEntry
            where subledgerJournalAccountEntry.RecId == _subledgerJournalAccountEntryRelievingTmp.SubledgerJournalAccountEntry
        join RecId from subledgerJournalEntry
            where subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
        {
            relievingTmpExt.clear();
            relievingTmpExt.SubledgerJournalAccountEntryRelievingTmp = _subledgerJournalAccountEntryRelievingTmp.RecId;
            relievingTmpExt.BondBatchTrans = this.importCorrespondenceLinkFromSubledger(
            subledgerJournalEntry,
            subledgerJournalAccountEntry,
            _subledgerJournalAccountEntryRelievingTmp.IndependentSourceDocumentLine); //using source doc line to generate new Bond Batches

            relievingTmpExt.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSublJourAccEntryDistrEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles insertion of the <c>SubledgerJournalAcountEntryDistribution</c> table.
    /// </summary>
    /// <param name="_tmpDetail">
    /// The source of records.
    /// </param>
    /// <param name="_accountingEvent">
    /// The accounting event.
    /// </param>
    public void insertSublJourAccEntryDistrEventHandler(SubledgerJournalAccountEntryTmpDetail _tmpDetail, AccountingEvent _accountingEvent)
    {
        this.deleteInsertedAccountEntryDistributions(_tmpDetail);
        this.insertNewAccountEntryDistributions(_tmpDetail, _accountingEvent);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insImpSubledgerAccEntryToDetEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Imports subledger journal account entry and inserts it into the <c>_tmpDetail</c> record.
    /// </summary>
    /// <param name="_subledgerJournalEntry">
    /// The <c>sublegerJournal</c> entry being imported.
    /// </param>
    /// <param name="_subledgerJournalAccountEntry">
    /// The subledger journal account entry being imported
    /// </param>
    /// <param name="_tmpDetail">
    /// The record being inserted
    /// </param>
    void insImpSubledgerAccEntryToDetEventHandler(SubledgerJournalEntry _subledgerJournalEntry, SubledgerJournalAccountEntry _subledgerJournalAccountEntry, SubledgerJournalAccountEntryTmpDetail _tmpDetail)
    {
        _tmpDetail.BondBatchTrans_RU = this.importCorrespondenceLinkFromSubledger(_subledgerJournalEntry, _subledgerJournalAccountEntry, _tmpDetail.AccountingDistribution);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insImpSubledgerAccEntryToSumEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Imports subledger journal account entry being inserted to the <c>_tmpSummary</c> record.
    /// </summary>
    /// <param name="_subledgerJournalizerExtensionArgs">
    /// An instance of <c>SubledgerJournalizerExtensionArgs</c> class.
    /// </param>
    void insImpSubledgerAccEntryToSumEventHandler(SubledgerJournalizerExtensionArgs _subledgerJournalizerExtensionArgs)
    {
        SubledgerJournalAccountEntry                subledgerJournalAccountEntry;
        AccountingEvent                             accountingEvent;
        AccountingDistribution                      accountingDistribution;
        SubledgerJournalAccountEntryDistribution    subledgerJournalAccountEntryDistribution;
        SubledgerJournalEntry                       subledgerJournalEntry;
        SubledgerJournalAccountEntryTmpSummary      tmpSummary;
        AccountingEventRecId                        accountingEventRecId;
        Ledger                                      ledger;

        tmpSummary = _subledgerJournalizerExtensionArgs.parmSubledgerJournalAccEntryTmpSummary();
        accountingEventRecId = _subledgerJournalizerExtensionArgs.parmAccountingEvent().RecId;

        // The minOf is used since the original implemantation needs only the first distribution of SLJAE.
        while select minof(AccountingDistribution) from subledgerJournalAccountEntryDistribution
            group by ledger.PrimaryForLegalEntity, ledger.Name, ledger.AccountingCurrency, ledger.ReportingCurrency,
                accountingEvent.AccountingDate, accountingEvent.RecId, subledgerJournalEntry.Type, subledgerJournalEntry.RecId,
                subledgerJournalEntry.JournalNumber, subledgerJournalAccountEntry.Side,
                subledgerJournalAccountEntry.PostingType, subledgerJournalAccountEntry.IsCorrection,
                subledgerJournalAccountEntry.TransactionCurrency, subledgerJournalAccountEntry.RecId,
                subledgerJournalAccountEntry.LedgerDimension, subledgerJournalAccountEntry.TransactionCurrencyAmount,
                subledgerJournalAccountEntry.AccountingCurrencyAmount, subledgerJournalAccountEntry.ReportingCurrencyAmount
            join RecId, LedgerDimension, PostingType, Side, TransactionCurrency, TransactionCurrencyAmount, AccountingCurrencyAmount,
                ReportingCurrencyAmount, IsCorrection
                from subledgerJournalAccountEntry
                where subledgerJournalAccountEntry.RecId == subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry
            join RecId, Type, JournalNumber from subledgerJournalEntry
                where subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
                    && subledgerJournalEntry.AccountingEvent == accountingEventRecId
            join RecId, AccountingDate from accountingEvent
                where accountingEvent.RecId == subledgerJournalEntry.AccountingEvent
            join PrimaryForLegalEntity, Name, AccountingCurrency, ReportingCurrency from ledger
                where ledger.RecId == subledgerJournalEntry.Ledger
        {
            tmpSummary.initFromSubledgerJournalAccountEntry(subledgerJournalAccountEntry,
                accountingDistribution,
                accountingEvent,
                subledgerJournalEntry,
                ledger,
                subledgerJournalAccountEntryDistribution.AccountingDistribution);

            tmpSummary.BondBatchTrans_RU = this.importCorrespondenceLinkFromSubledger(subledgerJournalEntry, subledgerJournalAccountEntry, subledgerJournalAccountEntryDistribution.AccountingDistribution);

            tmpSummary.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastBatchTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a value of last BondBatch transaction for debit or credit transactions.
    /// </summary>
    /// <param name="_record">
    /// A record of accounting distribution.
    /// </param>
    /// <returns>
    /// Returns a value of last BondBatch transaction for debit or credit trransactions.
    /// </returns>
    protected LedgerBondBatchTransNum_RU lastBatchTrans(AccountingDistributionTmp _record)
    {
        return _record.AmountSign == DebitCredit::Debit ? lastDebit : lastCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadedSubledgerJourTmpDetailEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles events when the <c>_subledgerJournalAccountEntryTmpDetail</c> argument is loaded.
    /// </summary>
    /// <param name="_accountingEvent">
    /// An accounting event.
    /// </param>
    /// <param name="_accountingDistributionTmp">
    /// A temporary table.
    /// </param>
    /// <param name="_subledgerJournalAccountEntryTmpDetail">
    /// A destination table.
    /// </param>
    public void loadedSubledgerJourTmpDetailEventHandler(AccountingEvent _accountingEvent, AccountingDistributionTmp _accountingDistributionTmp, SubledgerJournalAccountEntryTmpDetail _subledgerJournalAccountEntryTmpDetail)
    {
        ttsbegin;
        update_recordset _subledgerJournalAccountEntryTmpDetail setting BondBatchTrans_RU = _accountingDistributionTmp.BondBatchTrans_RU
            join   _accountingDistributionTmp
            where  _subledgerJournalAccountEntryTmpDetail.SourceAccountingDistributionTmp == _accountingDistributionTmp.RecId   &&
                   _subledgerJournalAccountEntryTmpDetail.AccountingEvent                 == _accountingEvent.RecId             &&
                   _accountingDistributionTmp.AccountingEvent                             == _accountingEvent.RecId;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadingDistributionToTmpEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Handles start of loading distribution to a temporary table.
    /// </summary>
    public void loadingDistributionToTmpEventHandler()
    {
        isFirstTmp = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadRelievingDetailsExtension</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Method used to override standard insertion of records to <c>SubledgerJournalAccountEntryTmpDetail</c> table.
    /// </summary>
    /// <param name="_sysEventOverride">
    ///   Insertion override status.
    /// </param>
    /// <param name="_subledgerJournalAccountEntryTmpDetail">
    ///   <c>_subledgerJournalAccountEntryTmpDetail</c> table instance.
    /// </param>
    /// <param name="_relievingTmp">
    ///   <c>SubledgerJournalAccountEntryRelievingTmp</c> table instance.
    /// </param>
    /// <param name="_accountingEvent">
    ///   Record id of accounting event.
    /// </param>
    public void loadRelievingDetailsExtension(
        SysEventOverride _sysEventOverride,
        SubledgerJournalAccountEntryTmpDetail _subledgerJournalAccountEntryTmpDetail,
        SubledgerJournalAccountEntryRelievingTmp _relievingTmp,
        AccountingEventRecId _accountingEvent)
    {
        _sysEventOverride.markAsOverridden();

        insert_recordset _subledgerJournalAccountEntryTmpDetail (AccountingCurrencyAmount,
                                                            AccountingDate,
                                                            AccountingEvent,
                                                            ExchangeRate1,
                                                            ExchangeRate2,
                                                            ExchangeRateDate,
                                                            HistoricalExchangeRateDate,
                                                            IsCorrection,
                                                            LedgerDimension,
                                                            PostingType,
                                                            ReportingCurrencyAmount,
                                                            ReportingExchangeRate1,
                                                            TransactionCurrencyAmount,
                                                            DebitCredit,
                                                            TransactionCurrencyCode,
                                                            TransferPolicy,
                                                            LegalEntity,
                                                            AccountingCurrency,
                                                            ReportingCurrency,
                                                            FiscalCalendarPeriod,
                                                            PostingLayer,
                                                            LedgerName,
                                                            Ledger,
                                                            SubledgerJournalEntryType,
                                                            BondBatchTrans_RU)
                select AccountingCurrencyAmount,
                    DependentAccountingDate,
                    AccountingEvent,
                    ExchangeRate1,
                    ExchangeRate2,
                    ExchangeRateDate,
                    HistoricalExchangeRateDate,
                    IsCorrection,
                    LedgerDimension,
                    PostingType,
                    ReportingCurrencyAmount,
                    ReportingExchangeRate1,
                    TransactionCurrencyAmount,
                    Side,
                    TransactionCurrency,
                    OriginalTransferPolicy,
                    LegalEntity,
                    AccountingCurrency,
                    ReportingCurrency,
                    FiscalCalendarPeriod,
                    PostingLayer,
                    LedgerName,
                    Ledger,
                    SubledgerJournalEntryType
                from _relievingTmp
                    where _relievingTmp.AccountingEvent == _accountingEvent
                join BondBatchTrans from relievingTmpExt
                    where relievingTmpExt.SubledgerJournalAccountEntryRelievingTmp == _relievingTmp.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>minSigned</Name>
				<Source><![CDATA[
    /// <summary>
    /// MFunction returns minimum absolute value of arguments with the sign of first argument.
    /// </summary>
    /// <param name="_first">
    /// First amount value.
    /// </param>
    /// <param name="_second">
    /// Second amount value.
    /// </param>
    /// <returns>
    /// Minimum absolute value of arguments with the sign of first argument.
    /// </returns>
    protected Amount minSigned(Amount _first, Amount _second)
    {
        Debug::assert(sign(_first) != sign(_second) || _first == 0 || _second == 0);
        return sign(_first) * min(abs(_first), abs(_second));
    }

]]></Source>
			</Method>
			<Method>
				<Name>performDetailLevelRoundAdjEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Handles rounding adjustment of <c>SubledgerJournalAccountEntryTmpDetail</c> records.
    /// </summary>
    /// <param name="_sysEventOverride">
    ///   Insertion override status.
    /// </param>
    /// <param name="_sourceDocument">
    ///   A reference to an instance of the <c>SourceDocument</c> class.
    /// </param>
    /// <param name="_tmpDetail">
    ///   The <c>SubledgerJournalAccountEntryTmpDetail</c> buffer.
    /// </param>
    public void performDetailLevelRoundAdjEventHandler(
        SysEventOverride _sysEventOverride,
        SourceDocument _sourceDocument,
        SubledgerJournalAccountEntryTmpDetail _tmpDetail)
    {
        _sysEventOverride.markAsOverridden();
        this.performDetailLevelRoundingAdjustment(_sourceDocument, _tmpDetail);
    }

]]></Source>
			</Method>
			<Method>
				<Name>performDetailLevelRoundingAdjustment</Name>
				<Source><![CDATA[
    private void performDetailLevelRoundingAdjustment(
        SourceDocument _sourceDocument,
        SubledgerJournalAccountEntryTmpDetail _tmpDetail)
    {
        SubledgerJourDetailRoundingAdjuster detailRoundingAdjuster;
        SubledgerJourIDetailRoundingAdjustEntry detailRoundingAdjustmentEntry;
        SubledgerJournalAccountEntryTmpDetail tmpDetail;

        detailRoundingAdjuster = SubledgerJourDetailRoundingAdjuster::newFromDocument(_sourceDocument);
        detailRoundingAdjustmentEntry = SubledgerJourDetailRoundingAdjustEntry::newFromTmpDetail(_tmpDetail);

        //Pass the buffer linked to tmp table (instead of copy) to allow detailRoundingAdjusters using results of detailRoundingAdjustmentEntry.
        tmpDetail.linkPhysicalTableInstance(_tmpDetail);
        detailRoundingAdjuster.performAdjustment(tmpDetail, detailRoundingAdjustmentEntry);
    }

]]></Source>
			</Method>
			<Method>
				<Name>performSummaryLevelRoundingAdjustEvHandl</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Handles summary level rounding of <c>SubledgerJournalAccountEntryTmpSummary</c> records.
    /// </summary>
    /// <param name="_sysEventOverride">
    ///   Insertion override status.
    /// </param>
    /// <param name="_sourceDocument">
    ///   A reference to an instance of the <c>SourceDocument</c> class.
    /// </param>
    /// <param name="_tmpSummary">
    ///   <c>SubledgerJournalAccountEntryTmpSummary</c> buffer being rounded.
    /// </param>
    public void performSummaryLevelRoundingAdjustEvHandl(
        SysEventOverride _sysEventOverride,
        SourceDocument _sourceDocument,
        SubledgerJournalAccountEntryTmpSummary _tmpSummary)
    {
        _sysEventOverride.markAsOverridden();
        this.performSummaryLevelRoundingAdjustment(_sourceDocument, _tmpSummary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>performSummaryLevelRoundingAdjustment</Name>
				<Source><![CDATA[
    private void performSummaryLevelRoundingAdjustment(
        SourceDocument _sourceDocument,
        SubledgerJournalAccountEntryTmpSummary _tmpSummary)
    {
        SubledgerJourSummaryRoundingAdjuster summaryRoundingAdjuster;
        SubledgerJourISummaryRoundingAdjustEntry summaryRoundingAdjustmentEntry;
        SubledgerJournalAccountEntryTmpSummary tmpSummaryCopy;

        summaryRoundingAdjuster = SubledgerJourSummaryRoundingAdjuster::newFromDocument(_sourceDocument);
        summaryRoundingAdjustmentEntry = SubledgerJourSummaryRoundingAdjustEntry::newFromTmpSummarySourceDocument(_tmpSummary, _sourceDocument);

        summaryRoundingAdjuster.performAdjustment(tmpSummaryCopy, summaryRoundingAdjustmentEntry);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFirstToTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds first distribution record to <c>AccountingDistributionTmp</c> table.
    /// </summary>
    /// <param name="_record">
    /// A record in <c>AccountingDistributionTmp</c> table corresponding to the accounting distribution.
    /// </param>
    protected void processFirstToTmp(AccountingDistributionTmp _record)
    {
        bondBatchTrans++;
        _record.BondBatchTrans_RU = bondBatchTrans;
        distributedSign = _record.AmountSign;
        if (_record.AmountSign == DebitCredit::Debit)
        {
            lastDebit   = bondBatchTrans;
            lastCredit  = bondBatchTrans - 1;
        }
        else
        {
            lastCredit  = bondBatchTrans;
            lastDebit   = bondBatchTrans - 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processNotFirstToTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds other distribution records to <c>AccountingDistributionTmp</c> table.
    /// </summary>
    /// <param name="_record">
    /// A record in <c>AccountingDistributionTmp</c> table corresponding to the accounting distribution.
    /// </param>
    protected void processNotFirstToTmp(AccountingDistributionTmp _record)
    {
        if (this.lastBatchTrans(_record) == bondBatchTrans)
        {
            bondBatchTrans ++;
        }
        this.incLastBatchTrans(_record);
        _record.BondBatchTrans_RU = this.lastBatchTrans(_record);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processToTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes insertion to a temporary table.
    /// </summary>
    /// <param name="_record">
    /// The temporary table record being inserted.
    /// </param>
    public void processToTmp(AccountingDistributionTmp _record)
    {
        if (isFirstTmp)
        {
            this.processFirstToTmp(_record);
        }
        else
        {
            this.processNotFirstToTmp(_record);
        }

        isFirstTmp = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordCorrectionRelievingExtension</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Serves as a subledger journal account entry recorded delegate.
    /// </summary>
    /// <param name="_sysEventOverride">
    ///   <c>SysEventOverride</c> object containing  status of override.
    /// </param>
    /// <param name="_subledgerJournalEntry">
    ///  Record Id of account entry.
    /// </param>
    /// <param name="_relievingTmp">
    ///  The source <c>SubledgerJournalAccountEntryRelievingTmp</c> table.
    /// </param>
    /// <remarks>
    ///  First, inserted but not bonded transactions deleted from subledger. Then, transactions in temporary table bonded using link from original journal - this time it's packing slip correction.
    /// Transactions are summarized to tmpBond and inserted back to subledger. Finally, records in <c>SubledgerJournalAccountEntryBond</c> added, and max bond used as offset. That's done to avoid usage of the same bond.
    /// </remarks>
    public void recordCorrectionRelievingExtension(SysEventOverride _sysEventOverride, RefRecId _subledgerJournalEntry, SubledgerJournalAccountEntryRelievingTmp _relievingTmp)
    {
        SubledgerBondTmp      bondTmp;
        SubledgerJournalEntry subledgerJournalEntry;
        SubledgerJournalAccountEntry subledgerJournalAccountEntry;
        SubledgerJournalAccountEntryRelievingTmp relievingTmpCredit;
        SubledgerJournalAccountEntryBond entryBond;
        SubledgerJournalAccountEntryRelievingTmpExt_RU relievingTmpExtDebit, relievingTmpExtCredit;


        relievingTmpCredit.linkPhysicalTableInstance(_relievingTmp);

        select firstOnly RecId from relievingTmpCredit;

        if (!relievingTmpCredit.RecId)
        {
            return;
        }

        _sysEventOverride.markAsOverridden();

        this.startingLoadAccDstrTmpForFinEventHandler();

        while select RecId from _relievingTmp
        join RecId from subledgerJournalAccountEntry
            where subledgerJournalAccountEntry.RecId == _relievingTmp.SubledgerJournalAccountEntry
        join RecId from subledgerJournalEntry
            where subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
        {
            relievingTmpExtDebit.clear();
            relievingTmpExtDebit.SubledgerJournalAccountEntryRelievingTmp = _relievingTmp.RecId;
            relievingTmpExtDebit.BondBatchTrans = this.importCorrespondenceLinkFromSubledger(subledgerJournalEntry, subledgerJournalAccountEntry, 0);
            relievingTmpExtDebit.insert();
        }

        relievingTmpExtCredit.linkPhysicalTableInstance(relievingTmpExtDebit);

        insert_recordset bondTmp(
        DebitSubledgerJournalEntry,
        DebitLedgerDimension,
        DebitPostingType,
        DebitExchangeRateDate,
        DebitExchangeRate1,
        DebitCurrencyCode,
        DebitReportingExchangeRate1,
        DebitExchangeRate2,
        DebitReportingExchangeRate2,
        DebitTransferPolicy,
        DebitIsCorrection,
        AccountingCurrencyAmount, TransactionCurrencyAmount, ReportingCurrencyAmount,
        CreditSubledgerJournalEntry,
        CreditLedgerDimension,
        CreditPostingType,
        CreditExchangeRateDate,
        CreditExchangeRate1,
        CreditCurrencyCode,
        CreditReportingExchangeRate1,
        CreditExchangeRate2,
        CreditReportingExchangeRate2,
        CreditTransferPolicy,
        CreditIsCorrection,
        CreditAccountingCurrencyAmount, CreditTransactionCurrencyAmount, CreditReportingCurrencyAmount
    ) select
        _subledgerJournalEntry,
        LedgerDimension,
        PostingType,
        ExchangeRateDate,
        ExchangeRate1,
        TransactionCurrency,
        ReportingExchangeRate1,
        ExchangeRate2,
        ReportingExchangeRate2,
        OriginalTransferPolicy,
        IsCorrection,
        sum(AccountingCurrencyAmount), sum(TransactionCurrencyAmount), sum(ReportingCurrencyAmount)
        from _relievingTmp group by
        LedgerDimension,
        PostingType,
        ExchangeRateDate,
        ExchangeRate1,
        TransactionCurrency,
        ReportingExchangeRate1,
        ExchangeRate2,
        ReportingExchangeRate2,
        OriginalTransferPolicy,
        IsCorrection
        where _relievingTmp.Side == DebitCredit::Debit
        join
        _subledgerJournalEntry,
        LedgerDimension,
        PostingType,
        ExchangeRateDate,
        ExchangeRate1,
        TransactionCurrency,
        ReportingExchangeRate1,
        ExchangeRate2,
        ReportingExchangeRate2,
        OriginalTransferPolicy,
        IsCorrection,
        sum(AccountingCurrencyAmount), sum(TransactionCurrencyAmount), sum(ReportingCurrencyAmount)
        from relievingTmpCredit
        group by
            LedgerDimension,
            PostingType,
            ExchangeRateDate,
            ExchangeRate1,
            TransactionCurrency,
            ReportingExchangeRate1,
            ExchangeRate2,
            ReportingExchangeRate2,
            OriginalTransferPolicy,
            IsCorrection
        where relievingTmpCredit.Side == DebitCredit::Credit
            exists join relievingTmpExtCredit
                where relievingTmpExtCredit.SubledgerJournalAccountEntryRelievingTmp == relievingTmpCredit.RecId
            exists join relievingTmpExtDebit
                where relievingTmpExtDebit.SubledgerJournalAccountEntryRelievingTmp == _relievingTmp.RecId
                    && relievingTmpExtDebit.BondBatchTrans == relievingTmpExtCredit.BondBatchTrans;

        select maxOf(BondBatchTrans) from entryBond
        exists join subledgerJournalAccountEntry
        where subledgerJournalAccountEntry.RecId == entryBond.SubledgerJournalAccountEntry
            && subledgerJournalAccountEntry.SubledgerJournalEntry == _subledgerJournalEntry;


        this.insertSubledgerJournalAccountEntry(bondTmp);
        this.insertSubledgerJournalAccountEntryBond(bondTmp, entryBond.BondBatchTrans);

    }

]]></Source>
			</Method>
			<Method>
				<Name>startingLoadAccDstrTmpForFinEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Starts loading subledger to temporary table.
    /// </summary>
    public void startingLoadAccDstrTmpForFinEventHandler()
    {
        importedBond = new Map(Types::Container, typeName2Type(extendedTypeStr(LedgerBondBatchTransNum_RU)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundSJAELvlAccAndRptAmtsInTmpSummary</Name>
				<Source><![CDATA[
    private void roundSJAELvlAccAndRptAmtsInTmpSummary(SubledgerJournalAccountEntryTmpSummary _tmpSummary)
    {
        SubledgerJournalAccountEntryTmpSummary summarizedSubledgerJournalAccountEntries,
                                           summarizedSubledgerJournalAccountEntriesOffset;

        summarizedSubledgerJournalAccountEntries.linkPhysicalTableInstance(_tmpSummary);
        summarizedSubledgerJournalAccountEntriesOffset.linkPhysicalTableInstance(_tmpSummary);

        while select forupdate summarizedSubledgerJournalAccountEntries
        where summarizedSubledgerJournalAccountEntries.RoundingLevel == SubledgerJournalRoundingLevel::SubledgerJournalAccountEntry &&
                summarizedSubledgerJournalAccountEntries.DebitCredit == DebitCredit::Debit
        join forUpdate summarizedSubledgerJournalAccountEntriesOffset
            where summarizedSubledgerJournalAccountEntriesOffset.BondBatchTrans_RU == summarizedSubledgerJournalAccountEntries.BondBatchTrans_RU &&
                    summarizedSubledgerJournalAccountEntriesOffset.RecId != summarizedSubledgerJournalAccountEntries.RecId &&
                    summarizedSubledgerJournalAccountEntriesOffset.RoundingLevel == SubledgerJournalRoundingLevel::SubledgerJournalAccountEntry
        {
            summarizedSubledgerJournalAccountEntries.AccountingCurrencyAmount = CurrencyExchangeHelper::amount(
            summarizedSubledgerJournalAccountEntries.AccountingCurrencyAmountUnrounded,
            summarizedSubledgerJournalAccountEntries.AccountingCurrency);

            summarizedSubledgerJournalAccountEntries.ReportingCurrencyAmount = CurrencyExchangeHelper::amount(
            summarizedSubledgerJournalAccountEntries.ReportingCurrencyAmountUnrounded,
            summarizedSubledgerJournalAccountEntries.ReportingCurrency);

            summarizedSubledgerJournalAccountEntries.update();

            summarizedSubledgerJournalAccountEntriesOffset.AccountingCurrencyAmount = -summarizedSubledgerJournalAccountEntries.AccountingCurrencyAmount;
            summarizedSubledgerJournalAccountEntriesOffset.ReportingCurrencyAmount = -summarizedSubledgerJournalAccountEntries.ReportingCurrencyAmount;

            summarizedSubledgerJournalAccountEntriesOffset.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundSJAELvlAccAndRptAmtsInTmpSummaryHnd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles rounding of <c>SubledgerJournalAccountEntryTmpSummary</c> records on subledgre journal account entry level.
    /// </summary>
    /// <param name="_sysEventOverride">
    ///   Insertion override status.
    /// </param>
    /// <param name="_tmpSummary">
    ///   The <c>SubledgerJournalAccountEntryTmpSummary</c> buffer.
    /// </param>
    public void roundSJAELvlAccAndRptAmtsInTmpSummaryHnd(
        SysEventOverride _sysEventOverride,
        SubledgerJournalAccountEntryTmpSummary _tmpSummary)
    {
        _sysEventOverride.markAsOverridden();
        this.roundSJAELvlAccAndRptAmtsInTmpSummary(_tmpSummary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitOppositeSignRecords</Name>
				<Source><![CDATA[
    private void splitOppositeSignRecords(SubledgerBondTmp  _bondTmp)
    {
        SubledgerBondTmp    bondTmpInsert;

        Boolean splitReportingValue, splitAccountingValue;

        bondTmpInsert.linkPhysicalTableInstance(_bondTmp);

        while select forUpdate _bondTmp
        where ((_bondTmp.AccountingCurrencyAmount > 0 && _bondTmp.TransactionCurrencyAmount < 0) ||
               (_bondTmp.AccountingCurrencyAmount < 0 && _bondTmp.TransactionCurrencyAmount > 0) ||
               (_bondTmp.ReportingCurrencyAmount < 0 && _bondTmp.TransactionCurrencyAmount > 0) ||
               (_bondTmp.ReportingCurrencyAmount > 0 && _bondTmp.TransactionCurrencyAmount < 0))
        {
            bondTmpInsert.data(_bondTmp);

            if (_bondTmp.AccountingCurrencyAmount * _bondTmp.TransactionCurrencyAmount < 0)
            {
                splitAccountingValue = true;

            }
            if (_bondTmp.ReportingCurrencyAmount * _bondTmp.TransactionCurrencyAmount < 0)
            {
                splitReportingValue = true;

            }

            bondTmpInsert.TransactionCurrencyAmount = 0;
            bondTmpInsert.CreditTransactionCurrencyAmount = 0;

            if (splitAccountingValue)
            {
                _bondTmp.AccountingCurrencyAmount = 0;
                _bondTmp.CreditAccountingCurrencyAmount = 0;
            }
            else
            {
                bondTmpInsert.AccountingCurrencyAmount = 0;
                bondTmpInsert.CreditAccountingCurrencyAmount = 0;
            }

            if (splitReportingValue)
            {
                _bondTmp.ReportingCurrencyAmount = 0;
                _bondTmp.CreditReportingCurrencyAmount = 0;
            }
            else
            {
                bondTmpInsert.ReportingCurrencyAmount = 0;
                bondTmpInsert.CreditReportingCurrencyAmount = 0;
            }

            _bondTmp.update();

            if (bondTmpInsert.DebitIsCorrection)
            {
                bondTmpInsert.DebitIsCorrection = NoYes::No;
                bondTmpInsert.CreditIsCorrection = NoYes::No;
            }
            else
            {
                bondTmpInsert.DebitIsCorrection = NoYes::Yes;
                bondTmpInsert.CreditIsCorrection = NoYes::Yes;
            }
            bondTmpInsert.doInsert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>subscribe</Name>
				<Source><![CDATA[
    /// <summary>
    /// Subscribes to the subledger journalizer extension events.
    /// </summary>
    protected void subscribe()
    {
        super();
        if (this.canSubscribe() && !subledgerJournalizer.insertingDistributedTmp)
        {
            subledgerJournalizer.insertingDistributedTmp                    += eventhandler(this.insertingDistributedTmpEventHandler);
            subledgerJournalizer.insertingJournalizingTmp                   += eventhandler(this.insertingJournalizingTmpEventHandler);
            subledgerJournalizer.loadedSubledgerJournalTmpDetail            += eventhandler(this.loadedSubledgerJourTmpDetailEventHandler);
            subledgerJournalizer.summarizedPreviewJourAccEntryDetail        += eventhandler(this.summedPrevwJourAccEntryDetEventHandler);
            subledgerJournalizer.summarizedJournalAccountEntryDetail        += eventhandler(this.summedJourAccEntryDetailEventHandler);
            subledgerJournalizer.insertedSubledgerJournalAccountEntry       += eventhandler(this.insertSubledgerJourAccEntryEventHandler);
            subledgerJournalizer.startingLoadAccDistrTmpForFinalization     += eventhandler(this.startingLoadAccDstrTmpForFinEventHandler);
            subledgerJournalizer.insertingImportedSubledgerAccEntryToDet    += eventhandler(this.insImpSubledgerAccEntryToDetEventHandler);
            subledgerJournalizer.insertingImportedSubledgerAccEntryToSum    += eventhandler(this.insImpSubledgerAccEntryToSumEventHandler);
            subledgerJournalizer.insertingImportedSubledgerAccEntry         += eventhandler(this.insertingImportedSubAccEntryEventHandler);

            subledgerJournalizer.insertedSubledgerJourAccEntryDistr         += eventhandler(this.insertSublJourAccEntryDistrEventHandler);
            insertedAccountEntryDistributionsWillBeRecreated                = true;

            subledgerJournalizer.loadingDistributionToTmp                   += eventhandler(this.loadingDistributionToTmpEventHandler);
            subledgerJournalizer.applyRoundingToSubledgerJourTmpDetail      += eventhandler(this.applyRoundingToTmpDetailEventHandler);
            subledgerJournalizer.loadedAccDistTmpRelieveAccrual             += eventhandler(this.loadedAccDistTmpRelievAccrEventHandler);
            subledgerJournalizer.recordCorrectionRelievingExtension         += eventhandler(this.recordCorrectionRelievingExtension);
            subledgerJournalizer.loadRelievingDetailsExtension              += eventhandler(this.loadRelievingDetailsExtension);

            subledgerJournalizer.performDetailLevelRoundingAdjustmentExtension         += eventhandler(this.performDetailLevelRoundAdjEventHandler);
            subledgerJournalizer.insertedSubledgerJournalAccountEntryForRounding       += eventhandler(this.insertAccountEntriesFromTmpSummary);
            subledgerJournalizer.roundSJAELevelAccAndRptAmtsInTmpSummaryExtension      += eventhandler(this.roundSJAELvlAccAndRptAmtsInTmpSummaryHnd);
            subledgerJournalizer.shouldCreateSubledgerJourAccEntryDistrDelegate        += eventhandler(this.shouldCreateSubledgerJourAccEntryDistrDelegateHandler);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>summedJourAccEntryDetailEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles summarization from a detail table to a summary table.
    /// </summary>
    /// <param name="_tmpDetail">
    /// The source table.
    /// </param>
    /// <param name="_tmpSummary">
    /// The destination table.
    /// </param>
    /// <param name="_accountingEventState">
    /// An accounting event state.
    /// </param>
    public void summedJourAccEntryDetailEventHandler(
        SubledgerJournalAccountEntryTmpDetail   _tmpDetail,
        SubledgerJournalAccountEntryTmpSummary  _tmpSummary,
        AccountingEventState                    _accountingEventState)
    {
        SubledgerBondTmp    bondTmp;

        this.fillBondTmpForSummarize(_tmpDetail, bondTmp, _accountingEventState);

        this.splitOppositeSignRecords(bondTmp);

        delete_from _tmpSummary;

        this.insertDebitToTmpSummary(bondTmp, _tmpSummary);
        this.insertCreditToTmpSummary(bondTmp, _tmpSummary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>summedPrevwJourAccEntryDetEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles summarization for subledgers preview.
    /// </summary>
    /// <param name="_tmpDetail">
    /// The source table.
    /// </param>
    /// <param name="_tmpSummary">
    /// The destination table.
    /// </param>
    public void summedPrevwJourAccEntryDetEventHandler(SubledgerJournalAccountEntryTmpDetail  _tmpDetail,
                                                       SubledgerJournalAccountEntryTmpSummary _tmpSummary)
    {
        SubledgerBondTmp                        bondTmp;
        this.fillBondTmpForSummaryPreview(_tmpDetail, bondTmp);
        delete_from _tmpSummary;
        this.insertDebitToTmpSummary(bondTmp, _tmpSummary);
        this.insertCreditToTmpSummary(bondTmp, _tmpSummary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateSubledgerJourAccEntryDistrDelegateHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if subledger account entry distribution should be created in <c>SubledgerJournalizer</c> class.
    /// </summary>
    /// <param name="_eventHandlerResult">
    /// Event handler result.
    /// </param>
    /// <remarks>
    /// When correspondence is enabled, records created in the SubledgerJournalizer.recordSubledgerJournalAcctEntriesDist() method
    /// are deleted and then recreated. In case there is a big amount of data being posted it may lead to excessive load to the database.
    /// This method returns false if records will be recreated, so that the <c>SubledgerJournalizer</c> class won't create these records at all.
    /// </remarks>
    public void shouldCreateSubledgerJourAccEntryDistrDelegateHandler(EventHandlerResult _eventHandlerResult)
    {
        _eventHandlerResult.booleanResult(!insertedAccountEntryDistributionsWillBeRecreated);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static SubledgerJournalizerBondExtension construct()
    {
        return new SubledgerJournalizerBondExtension();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>