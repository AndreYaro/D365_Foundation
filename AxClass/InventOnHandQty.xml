<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventOnHandQty</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Use this class if only interested in quantities as it is often faster than InventOnHand
/// </summary>
class InventOnHandQty implements InventIAvailability, PdsCWInventIAvailability
{
    ItemId                          itemId;
    InventDimId                     inventDimId;

    InventSum                       inventSum;

    InventDim                       inventDimCriteria;
    InventDimParm                   inventDimParm;
    InventOnHandCompositeCriteria   advancedCriteria;
    boolean                         sumRead;
    boolean                         availabilityRead;
    boolean                         cwItem;
    private boolean                 skipDisplayWarningIfWHSCheckReservationHandlingQtyFails;

    // Declare global for reservations
    WHSInventReserve                inventReserve;
    boolean                         itemUsesWHS;
    boolean                         useInventSumDirectly;
    boolean                         skipDelta;
    boolean                         delayAvailabilityCalculation;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>cannotPickEnoughInventoryError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for specifying a contextual error message when quantity cannot be picked.
    /// </summary>
    /// <param name = "_errorParameters">The provided error details.</param>
    delegate void cannotPickEnoughInventoryError(InventOnHandQtyErrorParameters _errorParameters)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDepreciateOrderedCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ensures that inventory on hand is checked for deprecated ordered quantity during final commit.
    /// </summary>
    /// <param name="_negativePhysical">
    /// NoYes::Yes if negative physical inventory is allowed; otherwise NoYes::No
    /// </param>
    public void addDepreciateOrderedCheck(NoYes _negativePhysical)
    {
        if (_negativePhysical)
        {
            return;
        }

        if (!InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().isFinalCommit())
        {
            InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().addDepreciateOrderedCheck(itemId, inventDimCriteria, inventDimParm);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventSumDelta</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds values from <c>InventSumDelta</c> to the current <c>InventSum</c> record.
    /// </summary>
    public void addInventSumDelta()
    {
        if (!itemId || InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(itemId))
        {
            InventSumDelta inventSumDelta = this.findSumJoinDelta();
            inventSum.addInventSumDeltaQty(inventSumDelta);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addReservationCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ensures that inventory on hand is checked for reserved quantity during final commit.
    /// </summary>
    /// <param name="_negativePhysical">
    /// NoYes::Yes if negative physical inventory is allowed; otherwise NoYes::No
    /// </param>
    public void addReservationCheck(NoYes _negativePhysical)
    {
        if (_negativePhysical)
        {
            return;
        }

        if (!InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().isFinalCommit())
        {
            InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().addReservationCheck(itemId, inventDimCriteria, inventDimParm);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>arrived</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>Arrived</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>Arrived</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>Arrived field</c> field.
    /// </remarks>
    public InventQty  arrived()
    {
        this.setInventSum();

        return inventSum.Arrived;
    }

]]></Source>
			</Method>
			<Method>
				<Name>availFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the financially available quantity.
    /// </summary>
    /// <returns>
    /// A quantity in the inventory unit.
    /// </returns>
    public InventQty availFinancial()
    {
        return this.postedQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>availOrdered</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the quantity reserved against ordered on hand.
    /// </summary>
    /// <param name="_inclAvailPhysical">
    /// A boolean value indicating whether the physical availability should be included.
    /// </param>
    /// <returns>
    /// The quantity in the inventory unit.
    /// </returns>
    /// <remarks>
    /// The quantity includes both physical and ordered goods that are available for reservation.
    /// </remarks>
    public InventQtyAvailOrdered availOrdered(boolean _inclAvailPhysical = true)
    {
        // Don't do math for this quantity, instead use the value in InventSum
        // because it's the correct number for WHS Items

        if (itemUsesWHS)
        {
            this.setInventSum();
            this.setAvailability();

            return _inclAvailPhysical ? inventSum.AvailOrdered : inventSum.AvailOrdered - inventSum.AvailPhysical;
        }
        else
        {
            return (_inclAvailPhysical ? this.availPhysical() : 0) + this.ordered() + this.arrived() - this.reservOrdered();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>availPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the the quantity available for physical reservation.
    /// </summary>
    /// <returns>
    /// The quantity in the inventory unit.
    /// </returns>
    public InventQtyAvailPhysical availPhysical()
    {
        // Don't do math for this quantity, instead use the value in InventSum
        // because it's the correct number for WHS Items
        if (itemUsesWHS)
        {
            this.setInventSum();
            this.setAvailability();

            return inventSum.AvailPhysical;
        }
        else
        {
            return (this.physicalInvent() - this.reservPhysical());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>availReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the quantity available for reservation.
    /// </summary>
    /// <param name="_allowReserveOrdered">
    /// A value indicating wither the result should include
    /// the ordered goods that are available for reservation; optional.
    /// </param>
    /// <returns>
    /// The quantity in the inventory unit.
    /// </returns>
    public InventQty availReservation(NoYes _allowReserveOrdered = NoYes::Yes)
    {
        if (_allowReserveOrdered)
        {
            return this.availOrdered();
        }
        return this.availPhysical();
    }

]]></Source>
			</Method>
			<Method>
				<Name>availTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total available quantity.
    /// </summary>
    /// <returns>
    /// The quantity in the inventory unit.
    /// </returns>
    /// <remarks>
    /// The total available quantity is the total quantity available for reservation
    /// minus the quantity that is on order but not reserved.
    /// </remarks>
    public InventQtyAvailOrdered availTotal()
    {
        this.setInventSum();

        return this.availOrdered() - this.onOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDepreciateOrdered</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the specified quantities can be subtracted from ordered quantities without violating reservations.
    /// </summary>
    /// <param name="_inventQty">
    /// The quantity known to be present after update.
    /// </param>
    /// <param name="_negativePhysical">
    /// NoYes::Yes if negative physical inventory is allowed; otherwise NoYes::No
    /// </param>
    /// <param name="_estimated">
    /// The quantity expected to be present after update
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity known to be present after update.
    /// </param>
    /// <param name="_cwEstimated">
    /// The catch weight quantity expected to be present after update
    /// </param>
    /// <returns>
    /// true if validation succeeded; otherwise false.
    /// </returns>
    public boolean  checkDepreciateOrdered(
        InventQty               _inventQty,
        InventNegativePhysical  _negativePhysical,
        InventQty               _estimated      = _inventQty,
        PdsCWInventQty          _cwQty          = 0,
        PdsCWInventQty          _cwEstimated    = _cwQty
        )
    {
        PdsCWInventQty  cwAvailOrderedPost;

        #PmfHelp

        if (! _negativePhysical)
        {
            // If WHS item, perform different check
            if (itemUsesWHS)
            {
                if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), itemId, _cwQty))
                {
                    WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), itemId);

                    return this.whsCheckDepreciateOrderedHandlingQty(_inventQty);
                }

                return this.whsCheckDepreciateOrderedHandlingQty(_cwQty);
            }

            InventQty availOrderedPost = this.availOrdered();

            if (cwItem)
            {
                cwAvailOrderedPost = this.pdsCWAvailOrdered();
            }

            if (availOrderedPost < -_inventQty
            || (cwItem && cwAvailOrderedPost < -_cwQty))
            {
                setPrefix("@SYS53920");

                setPrefix(inventDimCriteria.preFix());

                if (!InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().isFinalCommit())
                {
                    if (cwItem)
                    {
                        return checkFailed(strFmt("@PDS89", -_cwEstimated), #InventOnHandItemHelp);
                    }

                    return checkFailed(strFmt("@SYS12934", -_estimated), 'appldoc://Forms/InventOnhandItem');
                }
                else
                {
                    InventSumDelta inventSumDelta = this.findSumJoinDelta();
                    inventSum.clear();
                    inventSum.addInventSumDeltaQty(inventSumDelta);
                    InventQty availOrderedDelta = this.availOrdered();

                    if (cwItem)
                    {
                        PdsCWInventQty cwAvailOrderedDelta = this.pdsCWAvailOrdered();
                        return checkFailed(strFmt("@PDS89", -cwAvailOrderedDelta), #InventOnHandItemHelp);
                    }

                    return checkFailed(strFmt("@SYS12934", -availOrderedDelta), 'appldoc://Forms/InventOnhandItem');
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemDraw</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if given quantity can be picked.
    /// </summary>
    /// <param name="_inventQty">
    ///     Requested quantity.
    /// </param>
    /// <param name="_negativePhysical">
    ///     NoYes::Yes if negative physical inventory is allowed; otherwise NoYes::No.
    /// </param>
    /// <param name="_addInfo">
    ///     Set to true to add info to infolog.
    /// </param>
    /// <param name="_cwQty">
    ///     Requested catch weight quantity.
    /// </param>
    /// <returns>
    ///     true, if it is possible to pick; otherwise, false.
    /// </returns>
    public boolean  checkItemDraw(
        InventQty       _inventQty,
        NoYes           _negativePhysical,
        boolean         _addInfo = true,
        PdsCWInventQty  _cwQty = 0
        )
    {
        PdsCWInventQty  cwAvailPhysPost;

        if (! _negativePhysical)
        {
            // If WHS item, perform different check
            if (itemUsesWHS)
            {
                if (cwItem)
                {
                    return this.whsCheckItemDrawHandlingQty(_cwQty, _addInfo);
                }

                return this.whsCheckItemDraw(_inventQty, _addInfo);
            }

            if
                (!cwItem && (this.availPhysical() < (-_inventQty))
              || (cwItem && (this.pdsCWAvailPhysical() < -_cwQty)))
            {
                if (! _addInfo)
                {
                    return false;
                }

                setPrefix("@SYS70390");

                setPrefix(inventDimCriteria.preFix());

                if (!InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().isFinalCommit())
                {
                    if (cwItem)
                    {
                        return checkFailed(strFmt("@PDS87", -_cwQty, this.pdsCWAvailPhysical()));
                    }

                    return checkFailed(strFmt("@SCM:CannotPickWithEnoughInventory", real2double(-_inventQty).ToString(), real2double(this.availPhysical()).ToString(), itemId));
                }
                else
                {
                    InventQty availPhysPost = this.availPhysical();

                    if (cwItem)
                    {
                        cwAvailPhysPost   = this.pdsCWAvailPhysical();
                    }

                    InventSumDelta inventSumDelta = this.findSumJoinDelta();
                    inventSum.clear();
                    inventSum.addInventSumDeltaQty(inventSumDelta);
                    inventSum.addInventSumDeltaValues(inventSumDelta);
                    InventQty availPhysDelta = this.availPhysical();

                    if (cwItem)
                    {
                        PdsCWInventQty cwAvailPhysDelta = this.pdsCWAvailPhysical();
                        return checkFailed(strFmt("@PDS87", -cwAvailPhysDelta, cwAvailPhysPost-cwAvailPhysDelta));
                    }

                    return checkFailed(strFmt("@SCM:CannotPickWithEnoughInventory", real2double(-availPhysDelta).ToString(), real2double(availPhysPost-availPhysDelta).ToString(), itemId));
                }
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReservation</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether it is possible to reserve given quantity.
    /// </summary>
    /// <param name="_inventQty">
    ///     Requested quantity.
    /// </param>
    /// <param name="_negativePhysical">
    ///     NoYes::Yes if negative physical inventory is allowed; otherwise NoYes::No.
    /// </param>
    /// <param name="_reserveOnOrdered">
    ///     NoYes::Yes if reserving on ordered is allowed; otherwise NoYes::No.
    /// </param>
    /// <param name="_addOnhandQty">
    ///     Additional on hand quantity.
    /// </param>
    /// <param name="_cwQty">
    ///     Requested catch weight quantity.
    /// </param>
    /// <param name="_cwAddonHandQty">
    ///     Additional on hand catch weight quantity.
    /// </param>
    /// <returns>
    ///     True if it is possible to reserve.
    /// </returns>
    public boolean  checkReservation(
        InventQty           _inventQty,         // Negative value
        NoYes               _negativePhysical,
        NoYes               _reserveOnOrdered,
        InventQty           _addOnhandQty   = 0,
        PdsCWInventQty      _cwQty          = 0,
        PdsCWInventQty      _cwAddonHandQty = 0
        )
    {
        InventQty       cwAvailReservationPost;

        if (! _negativePhysical)
        {
            // If WHS item, perform different check
            if (itemUsesWHS)
            {
                if (cwItem)
                {
                    return this.whsCheckReservationHandlingQty(_cwQty, _reserveOnOrdered, _cwAddonHandQty);
                }
                else
                {
                    return this.whsCheckReservation(_inventQty, _reserveOnOrdered, _addOnhandQty);
                }
            }

            InventQty availReservationPost = this.availReservation(_reserveOnOrdered);

            if (cwItem)
            {
                cwAvailReservationPost = this.pdsCWAvailReservation(_reserveOnOrdered);
            }

            boolean canReserveByInventQty = (availReservationPost + _addOnhandQty < -_inventQty);
            boolean canReserveByCwQty = (cwAvailReservationPost + _cwAddonHandQty < -_cwQty);

            if (    (!cwItem && canReserveByInventQty)
                ||  ( cwItem && canReserveByInventQty && canReserveByCwQty))
            {
                setPrefix("@SYS7120");

                setPrefix(inventDimCriteria.preFix());

                if (!InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().isFinalCommit())
                {
                    if (cwItem)
                    {
                        checkFailed(strFmt("@PDS90", -_cwQty, cwAvailReservationPost + _cwAddonHandQty));
                    }
                    else
                    {
                        checkFailed(strFmt("@SYS54812",-_inventQty,availReservationPost+_addOnhandQty));
                    }
                }
                else
                {
                    InventSumDelta inventSumDelta = this.findSumJoinDelta();
                    inventSum.clear();
                    inventSum.addInventSumDeltaQty(inventSumDelta);
                    inventSum.addInventSumDeltaValues(inventSumDelta);
                    InventQty availReservationDelta = this.availReservation(_reserveOnOrdered);

                    if (cwItem)
                    {
                        InventQty cwAvailReservationDelta = this.pdsCWAvailReservation(_reserveOnOrdered);
                        checkFailed(strFmt("@PDS90", -cwAvailReservationDelta, cwAvailReservationPost - cwAvailReservationDelta));
                    }
                    else
                    {
                        checkFailed(strFmt("@SYS54812",-availReservationDelta,availReservationPost-availReservationDelta));
                    }
                }
                return false;
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deducted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>Deducted</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>Deducted</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>Deducted field</c> field.
    /// </remarks>
    public InventQty  deducted()
    {
        this.setInventSum();

        return inventSum.Deducted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSumDeltaWithAdvancedCriteria</Name>
				<Source><![CDATA[
    private InventSumDelta findSumDeltaWithAdvancedCriteria()
    {
        InventDim       inventDimCriteriaLocal;
        InventDimParm   inventDimParmLocal;

        [inventDimCriteriaLocal, inventDimParmLocal] = this.getDimCriteriaForAdvancedQuery();

        Query onHandQuery = InventSumDelta::newQuery(itemId, inventDimCriteriaLocal, inventDimParmLocal, null);

        advancedCriteria.applyToOnHand(onHandQuery);

        return advancedCriteria.mergeMatchingRecords(onHandQuery, tableNum(InventSumDelta));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSumJoin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the internal on hand buffer based on parameters specified earlier.
    /// </summary>
    protected void findSumJoin()
    {
        if (advancedCriteria && advancedCriteria.mustBeApplied())
        {
            inventSum = this.findSumWithAdvancedCriteria();
        }
        else if (inventDimId)
        {
            inventSum = InventSum::find(itemId,inventDimId);
        }
        else if (inventDimParm.ItemIdFlag)
        {
            inventSum = this.findSumWithItemAndDimCriteria();
        }
        else
        {
            inventSum = this.findSumJoinWithBatchIdOrSerialId();
        }

        if (inventDimParm.ItemIdFlag)
        {
            inventSum.ItemId = itemId;
        }

        this.addInventSumDelta();

        if (!delayAvailabilityCalculation)
        {
            this.setAvailability();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSumJoinDelta</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves summarized on hand for uncommitted changes.
    /// </summary>
    /// <returns>
    /// An <c>InventSumDelta</c> record.
    /// </returns>
    protected InventSumDelta findSumJoinDelta()
    {
        InventSumDelta  inventSumDelta;

        if (advancedCriteria && advancedCriteria.mustBeApplied())
        {
            inventSumDelta = this.findSumDeltaWithAdvancedCriteria();
        }
        else if (inventDimId)
        {
            inventSumDelta = InventSumDelta::findSumDeltaDimId(itemId,inventDimId,InventSumFields::All);
        }
        else if (inventDimParm.ItemIdFlag)
        {
            inventSumDelta = InventSumDelta::findSumDelta(itemId,inventDimCriteria,inventDimParm,InventSumFields::All);
        }
        else
        {
            inventSumDelta = this.findSumJoinDeltaWithBatchIdOrSerialId();
        }

        if (inventDimParm.ItemIdFlag)
        {
            inventSumDelta.ItemId = itemId;
        }

        return inventSumDelta;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSumWithAdvancedCriteria</Name>
				<Source><![CDATA[
    private InventSum findSumWithAdvancedCriteria()
    {
        InventDim       dimCriteriaLocal;
        InventDimParm   dimParmCriteriaLocal;

        [dimCriteriaLocal, dimParmCriteriaLocal] = this.getDimCriteriaForAdvancedQuery();

        Query onHandQuery = InventSum::newQuery(null, itemId, dimCriteriaLocal, dimParmCriteriaLocal, null);

        advancedCriteria.applyToOnHand(onHandQuery);

        return advancedCriteria.mergeMatchingRecords(onHandQuery, tableNum(InventSum));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findWHSAvailQtyWithAdvancedCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the available quantities in WHSInventReserve based on the advanced criteria.
    /// </summary>
    /// <param name="_hierarchyProvider">
    /// Reservation hierarchy provider.
    /// </param>
    /// <returns>
    /// A <c>WHSInventReserve</c> record holding summed values for the available quantities.
    /// </returns>
    private WHSInventReserve findWHSAvailQtyWithAdvancedCriteria(WHSItemReservationHierarchyProvider _hierarchyProvider)
    {
        InventDim                       inventDimCriteriaLocal;
        InventDimParm                   inventDimParmLocal;

        [inventDimCriteriaLocal, inventDimParmLocal] = this.getDimCriteriaForAdvancedQuery();

        // Modify inventDim criteria so that only dimensions at or above the batch hierarchy level are used.
        inventDimParm batchAndAboveParm = WHSReservationHierarchyInventDimUtil::initInventDimParmBatchAndAbove(InventTable::find(itemId));
        inventDimParmLocal = InventDimParm::andParms(inventDimParmLocal, batchAndAboveParm);

        Query sysQuery = WHSInventReserve::newAvailQuery(itemId, inventDimCriteriaLocal, inventDimParmLocal, true);

        InventOnHandQueryWHSStandard onHandQuery = InventOnHandQueryWHSStandard::newFromQuery(sysQuery);
        onHandQuery.parmInventTable(_hierarchyProvider.parmInventTable());
        onHandQuery.parmHierarchyProvider(_hierarchyProvider);
        onHandQuery.setReservationLevelRange(_hierarchyProvider.batchLevelAboveLocation());

        advancedCriteria.applyToOnHandQuery(onHandQuery);

        return advancedCriteria.mergeMatchingRecords(onHandQuery.parmSysQuery(), tableNum(WHSInventReserve));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimCriteriaForAdvancedQuery</Name>
				<Source><![CDATA[
    private container getDimCriteriaForAdvancedQuery()
    {
        InventDim       dimCriteriaLocal;
        InventDimParm   dimParmCriteriaLocal;

        if (inventDimId)
        {
            dimCriteriaLocal        = InventDim::find(inventDimId);
            dimParmCriteriaLocal    = dimCriteriaLocal.toDimParm();
        }
        else
        {
            dimCriteriaLocal        = inventDimCriteria;
            dimParmCriteriaLocal    = inventDimParm;
        }

        return [dimCriteriaLocal, dimParmCriteriaLocal];
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an <c>InventSum</c> buffer with the on-hand inventory values.
    /// </summary>
    /// <param name="setKey">Set to true to initialize the key, ItemId and InventDimId, in the returned <c>InventSum</c> buffer; optional.</param>
    /// <returns>An <c>InventSum</c> buffer with the on-hand inventory values.</returns>
    public InventSum inventSum(boolean setKey = false)
    {
        return this.getInventSum(setKey, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventSumWithoutAvailability</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an <c>InventSum</c> buffer with the on-hand inventory values without including available quantities.
    /// </summary>
    /// <param name="_setKey">Set to true to initialize the key, ItemId and InventDimId, in the returned <c>InventSum</c> buffer.</param>
    /// <returns>An <c>InventSum</c> buffer with the on-hand inventory values.</returns>
    public InventSum inventSumWithoutAvailability(boolean _setKey)
    {
        return this.getInventSum(_setKey, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventSum</Name>
				<Source><![CDATA[
    private InventSum getInventSum(boolean _setKey, boolean _setAvailability)
    {
        if (_setAvailability)
        {
            this.setInventSum();
            this.setAvailability();
        }
        else
        {
            this.parmDelayAvailabilityCalculation(true);
            this.setInventSum();
            this.parmDelayAvailabilityCalculation(false);
        }

        if (_setKey)
        {
            this.setInventSumKey();
        }

        return inventSum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckFinancialOnhand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if financial on hand must be checked during final commit.
    /// </summary>
    /// <returns>
    /// true if a final check must be made; otherwise false.
    /// </returns>
    public boolean mustCheckFinancialOnhand()
    {
        return this.availFinancial() < 0 ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckPhysicalOnhand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if physical on hand must be checked during final commit.
    /// </summary>
    /// <returns>
    /// true if a final check must be made; otherwise false.
    /// </returns>
    public boolean mustCheckPhysicalOnhand()
    {
        return this.availPhysical() < 0 ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>onOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>OnOrder</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>OnOrder</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>OnOrder field</c> field.
    /// </remarks>
    public InventQty onOrder()
    {
        this.setInventSum();

        return inventSum.OnOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ordered</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ordered quantity.
    /// </summary>
    /// <returns>
    /// The quantity in the inventory unit.
    /// </returns>
    public InventQtyOrdered ordered()
    {
        this.setInventSum();

        return inventSum.Ordered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>orderedSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the quantity that was ordered
    /// but is not physically available in the warehouse yet.
    /// </summary>
    /// <returns>
    /// The quantity in the inventory unit.
    /// </returns>
    /// <remarks>
    /// Goods that are in the Arrived status are not physically available
    /// in the warehouse yet so the result of this method is the Ordered + Arrived quantity.
    /// </remarks>
    public InventQtyOrderedSum orderedSum()
    {
        return this.ordered() + this.arrived();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdvancedCriteria</Name>
				<Source><![CDATA[
    public InventOnHandCompositeCriteria parmAdvancedCriteria(InventOnHandCompositeCriteria _advancedCriteria = advancedCriteria)
    {
        advancedCriteria = _advancedCriteria;

        if (!advancedCriteria)
        {
            advancedCriteria = InventOnHandCompositeCriteria::newStandard();
        }

        return advancedCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBatchId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the specified batch ID to the criterias used.
    /// </summary>
    /// <param name="_inventBatchId">
    /// The batch ID.
    /// </param>
    void parmBatchId(InventBatchId _inventBatchId)
    {
        inventDimCriteria.InventBatchId = _inventBatchId;
        inventDimParm.InventBatchIdFlag = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDelayAvailabilityCalculation</Name>
				<Source><![CDATA[
    public boolean parmDelayAvailabilityCalculation(boolean _delayAvailabilityCalculation = delayAvailabilityCalculation)
    {
        delayAvailabilityCalculation = _delayAvailabilityCalculation;

        return delayAvailabilityCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the inventory dimensions to be used as criterias when selecting.
    /// </summary>
    /// <param name="_inventDimCriteria">
    /// The <c>InventDim</c> record holding the dimensions values.
    /// </param>
    public void parmInventDim(InventDim _inventDimCriteria)
    {
        inventDimCriteria = _inventDimCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the inventory dimension ID to be used as criteria when selecting.
    /// </summary>
    /// <param name="_inventDimId">
    /// The dimension ID to be used.
    /// </param>
    void parmInventDimId(InventDimId _inventDimId)
    {
        inventDimId = _inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimParm</Name>
				<Source><![CDATA[
    public InventDimParm parmInventDimParm(InventDimParm _inventDimParm = inventDimParm)
    {
        inventDimParm = _inventDimParm;

        return inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventLocationId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the specified warehouse to the criterias used.
    /// </summary>
    /// <param name="_inventLocationId">
    /// The warehouse.
    /// </param>
    public void parmInventLocationId(InventLocationId _inventLocationId)
    {
        inventDimCriteria.InventLocationId = _inventLocationId;
        inventDimParm.InventLocationIdFlag = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventSum</Name>
				<Source><![CDATA[
    public InventSum parmInventSum(InventSum _inventSum = inventSum)
    {
        inventSum = _inventSum;

        sumRead = true;

        return inventSum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the item to be used as a range when selecting.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID to be used.
    /// </param>
    public void parmItemId(ItemId _itemId)
    {
        itemId = _itemId;
        inventDimParm.ItemIdFlag = true;

        // Set flag for WHS enabled
        itemUsesWHS = WHSInventEnabled::exist(itemId);

        cwItem = PdsGlobal::pdsIsCWItem(itemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLocationId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the specified warehouse location to the criterias used.
    /// </summary>
    /// <param name="_wmsLocationId">
    /// The warehouse location.
    /// </param>
    public void parmLocationId(WMSLocationId _wmsLocationId)
    {
        inventDimCriteria.wmsLocationId = _wmsLocationId;
        inventDimParm.wmsLocationIdFlag = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPalletId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the specified pallet ID to the criterias used.
    /// </summary>
    /// <param name="_wmsPalletId">
    /// The pallet ID.
    /// </param>
    [SysObsolete('Functionality related to Warehouse Management II is not supported', false, 7\11\2016)]
    public void parmPalletId(WMSPalletId _wmsPalletId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWArrived</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>PdsCWArrived</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>PdsCWArrived</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>PdsCWArrived field</c> field.
    /// </remarks>
    public PdsCWInventQty pdsCWArrived()
    {
        this.setInventSum();

        return inventSum.PdsCWArrived;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAvailFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves value of the <c>PdsCWPostedQty</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>PdsCWPostedQty</c> field.
    /// </returns>
    public PdsCWInventQty pdsCWAvailFinancial()
    {
        return this.pdsCWPostedQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAvailOrdered</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the catch weight ordered quantity available for order.
    /// </summary>
    /// <param name="_inclAvailPhysical">
    /// Whether the available physical inventory must be included in the ordered quantity.
    /// </param>
    /// <returns>
    /// The catch weight quantity of available ordered inventory.
    /// </returns>
    /// <remarks>
    /// The method looks to see if to include available physical inventory and if yes,
    /// the available ordered quantity is computed.
    /// </remarks>
    public PdsCWInventQty pdsCWAvailOrdered(boolean _inclAvailPhysical = true)
    {
        if (itemUsesWHS && cwItem)
        {
            this.setInventSum();
            this.setAvailability();

            return _inclAvailPhysical ? inventSum.PdsCwAvailOrdered : inventSum.PdsCWAvailOrdered - inventSum.PdsCWAvailPhysical;
        }
        
        return (_inclAvailPhysical ? this.pdsCWAvailPhysical() : 0) + this.pdsCWOrdered() + this.pdsCWArrived() - this.pdsCWReservOrdered();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAvailPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the catch weight physical quantity available.
    /// </summary>
    /// <returns>
    /// The value of catch weight quantity physically available.
    /// </returns>
    /// <remarks>
    /// The method computes the physical available quantity from the physical
    /// inventory minus the physical reserved.
    /// </remarks>
    public PdsCWAvailPhysical pdsCWAvailPhysical()
    {
        if (itemUsesWHS && cwItem)
        {
            this.setInventSum();
            this.setAvailability();

            return inventSum.PdsCWAvailPhysical;
        }

        return (this.pdsCWPhysicalInvent() - this.pdsCWReservPhysical());
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAvailReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the catch weight physical quantity available.
    /// </summary>
    /// <param name="_reserveOnOrdered">
    /// A <c>NoYes</c> parameter that specifies if reservation against ordered items should be allowed; optional.
    /// </param>
    /// <returns>
    /// The value of catch weight quantity physically available.
    /// </returns>
    public PdsCWAvailReservation pdsCWAvailReservation(NoYes _reserveOnOrdered = NoYes::Yes)
    {
        if (_reserveOnOrdered)
        {
            return this.pdsCWAvailOrdered();
        }
        return this.pdsCWAvailPhysical();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWRequiredInventQtyCorrection</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Calculates the inventory quantity correction necessary to get the quantity back between minimum and maximum value.
    /// </summary>
    /// <returns>The required inventory quantity correction.</returns>
    public InventQty pdsCWRequiredInventQtyCorrection()
    {
        if (!cwItem)
        {
            return 0;
        }

        var pdsCwItem = PdsCatchWeightItem::find(itemId);
        var cwPhysical = this.pdsCWPhysicalInvent();
        var negativeFactor = cwPhysical < 0 ? -1 : 1; // Factor used to make all numbers positive

        var inventPhysical = this.physicalInvent() * negativeFactor;
        var minAllowed = cwPhysical * pdsCwItem.PdsCWMin * negativeFactor;
        var maxAllowed = cwPhysical * pdsCwItem.PdsCwMax * negativeFactor;

        InventQty ret = 0;

        if (inventPhysical < minAllowed)
        {
            ret = minAllowed - inventPhysical;
        }
        else if (inventPhysical > maxAllowed)
        {
            // When cwPhysical is 0, then maxAllowed is also 0 and the result is -inventPhysical,
            // which will bring inventory quantity to 0 as expected.
            ret = maxAllowed - inventPhysical;
        }

        return ret * negativeFactor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWDeducted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>PdsCWDeducted</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>PdsCWDeducted</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>PdsCWDeducted</c> field.
    /// </remarks>
    public PdsCWInventQty pdsCWDeducted()
    {
        this.setInventSum();

        return inventSum.PdsCWDeducted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWOnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>PdsCWOnOrder</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>PdsCWOnOrder</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>PdsCWOnOrder</c> field.
    /// </remarks>
    public PdsCWInventQty pdsCWOnOrder()
    {
        this.setInventSum();

        return inventSum.PdsCWOnOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWOrdered</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>PdsCWOrdered</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>PdsCWOrdered</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>PdsCWOrdered</c> field.
    /// </remarks>
    public PdsCWOrdered pdsCWOrdered()
    {
        this.setInventSum();

        return inventSum.PdsCWOrdered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWPhysicalInvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the catch weight physical inventory quantity.
    /// </summary>
    /// <returns>
    /// The catch weight physical inventory quantity.
    /// </returns>
    /// <remarks>
    /// The method computes catch weight physical inventory quantity from the
    /// pdsCWPostedQty, pdsCWReceived, pdsCWDeducted, pdsCWRegistered and pdsCWPicked methods.
    /// </remarks>
    public  PdsCWInventQty  pdsCWPhysicalInvent()
    {
        return this.pdsCWPostedQty() + this.pdsCWReceived() - this.pdsCWDeducted() + this.pdsCWRegistered() - this.pdsCWPicked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWPicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>PdsCWPicked</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>PdsCWPicked</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>PdsCWPicked</c> field.
    /// </remarks>
    public  PdsCWInventQty pdsCWPicked()
    {
        this.setInventSum();

        return inventSum.PdsCWPicked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWPostedQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>PdsCWPostedQty</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>PdsCWPostedQty</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>PdsCWPostedQty</c> field.
    /// </remarks>
    public PdsCWInventQty pdsCWPostedQty()
    {
        this.setInventSum();

        return inventSum.PdsCWPostedQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQuotationIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>PdsCWQuotationIssue</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>PdsCWQuotationIssue</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>PdsCWQuotationIssue</c> field.
    /// </remarks>
    public PdsCWInventQty pdsCWQuotationIssue()
    {
        this.setInventSum();

        return inventSum.PdsCWQuotationIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQuotationReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>PdsCWQuotationReceipt</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>PdsCWQuotationReceipt</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>PdsCWQuotationReceipt</c> field.
    /// </remarks>
    public PdsCWInventQty  pdsCWQuotationReceipt()
    {
        this.setInventSum();

        return inventSum.PdsCWQuotationReceipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWReceived</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>PdsCWReceived</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>PdsCWReceived</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>PdsCWReceived</c> field.
    /// </remarks>
    public PdsCWInventQty  pdsCWReceived()
    {
        this.setInventSum();

        return inventSum.PdsCWReceived;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWRegistered</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>PdsCWRegistered</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>PdsCWRegistered</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>PdsCWRegistered</c> field.
    /// </remarks>
    public PdsCWInventQty pdsCWRegistered()
    {
        this.setInventSum();

        return inventSum.PdsCWRegistered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWReservOrdered</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the reserved against ordered inventory quantity in catch weight unit.
    /// </summary>
    /// <returns>
    /// The reserved against ordered inventory quantity in catch weight unit.
    /// </returns>
    public PdsCWReservOrdered pdsCWReservOrdered()
    {
        this.setInventSum();
        this.setAvailability();

        return inventSum.PdsCWReservOrdered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWReservPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>PdsCWReservPhysical</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>PdsCWReservPhysical</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>PdsCWReservPhysical</c> field.
    /// </remarks>
    public PdsCWReservPhysical pdsCWReservPhysical()
    {
        this.setInventSum();
        this.setAvailability();

        return inventSum.PdsCWReservPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsParmCWItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Specifies whether this is a catch weight item.
    /// </summary>
    /// <param name="_cwItem">
    ///     True if it is a catch weight item; false otherwise.
    /// </param>
    /// <returns>
    ///     True if it is a catch weight item; false otherwise.
    /// </returns>
    protected boolean pdsParmCWItem(boolean _cwItem = cwItem)
    {
        cwItem = _cwItem;
        return cwItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalInvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the physical inventory quantity.
    /// </summary>
    /// <returns>
    /// The physical inventory quantity.
    /// </returns>
    public InventQty physicalInvent()
    {
        return this.postedQty() + this.received() - this.deducted() + this.registered() - this.picked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>picked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>Picked</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>Picked</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>Picked field</c> field.
    /// </remarks>
    public InventQty  picked()
    {
        this.setInventSum();

        return inventSum.Picked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postedQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>PostedQty</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>PostedQty</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>PostedQty field</c> field.
    /// </remarks>
    public InventQty  postedQty()
    {
        this.setInventSum();

        return inventSum.PostedQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>received</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>Received</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>Received</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>Received field</c> field.
    /// </remarks>
    public InventQty  received()
    {
        this.setInventSum();

        return inventSum.Received;
    }

]]></Source>
			</Method>
			<Method>
				<Name>registered</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the <c>Registered</c> field.
    /// </summary>
    /// <returns>
    /// The value of the <c>Registered</c> field.
    /// </returns>
    /// <remarks>
    /// The method first retrieves an <c>InventSum</c> record and then returns
    /// the value of the <c>Registered field</c> field.
    /// </remarks>
    public InventQty  registered()
    {
        this.setInventSum();

        return inventSum.Registered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reservOrdered</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the quantity reserved against ordered on hand.
    /// </summary>
    /// <returns>
    /// Quantity in the inventory unit.
    /// </returns>
    public InventQtyReservOrdered reservOrdered()
    {
        this.setInventSum();
        this.setAvailability();

        return inventSum.ReservOrdered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reservPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the quantity reserved against on hand that is physically available.
    /// </summary>
    /// <returns>
    /// The quantity in the inventory unit.
    /// </returns>
    public InventQtyReservPhysical reservPhysical()
    {
        this.setInventSum();
        this.setAvailability();

        return inventSum.ReservPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAvailability</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the available quantities.
    /// </summary>
    protected void setAvailability()
    {
        if (availabilityRead || useInventSumDirectly)
        {
            return;
        }

        if (itemUsesWHS)
        {
            if (advancedCriteria
                || !WHSReservationHierarchyInventDimUtil::inventDimHasGaps(InventTable::find(itemId), inventDimCriteria, inventDimParm))
            {
                this.setWHSSumReserve();
            }
            else
            {
                this.setWHSSumReserveWithDimGaps();
            }
        }

        availabilityRead = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the internal on hand buffer based on parameters specified earlier.
    /// </summary>
    protected void setInventSum()
    {
        if (sumRead)
        {
            return;
        }

        this.findSumJoin();

        sumRead = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventSumKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the key fields, ItemId and InventDimId in the <c>inventSum</c> buffer.
    /// </summary>
    protected void setInventSumKey()
    {
        InventDim   inventDimTmp;

        // Fields might not have been selected on the specified buffers, or might have been updated since selection
        inventSum.checkInvalidFieldAccess(false);

        inventSum.ItemId = itemId;

        if (!inventSum.InventDimId && inventDimId)
        {
            inventSum.InventDimId = inventDimId;
        }

        if (!inventSum.InventDimId && inventDimCriteria.InventDimId && inventDimParm.isInventDimEqualInventDimParm(inventDimCriteria))
        {
            inventSum.InventDimId = inventDimCriteria.InventDimId;
        }

        if (!inventSum.InventDimId)
        {
            inventDimTmp.data(inventDimCriteria);
            inventDimTmp.clearNotSelectedDim(inventDimParm);
            inventSum.InventDimId = InventDim::findOrCreate(inventDimTmp).InventDimId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsCheckDepreciateOrderedHandlingQty</Name>
				<Source><![CDATA[
    private boolean whsCheckDepreciateOrderedHandlingQty(InventHandlingQty  _inventHandlingQty)
    {
        boolean ret = true;

        InventQty availOrdered = WHSInventOnHand::getOrderedAvailHandlingQty(itemId, inventDimCriteria, !skipDelta, false);

        if (availOrdered < (-_inventHandlingQty))
        {
            setPrefix("@SYS53920");

            setPrefix(inventDimCriteria.preFix());

            ret = checkFailed(strFmt("@SYS12934", availOrdered), 'appldoc://Forms/InventOnhandItem');
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsCheckItemDraw</Name>
				<Source><![CDATA[
    /// <summary>
    /// Custom check Item Draw method for WHS items:
    /// checks against the item's physical availability if provided quantity can be picked.
    /// </summary>
    /// <param name="_inventQty">
    /// Quantity to check.
    /// </param>
    /// <param name="_addInfo">
    /// When True, info log message will be added if check failed.
    /// </param>
    /// <returns>
    /// true if it is possible to pick _inventQty for item; otherwise, false.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Please file an extensibility request if access is required.', false, 30\9\2019)]
    public boolean whsCheckItemDraw(InventQty _inventQty, boolean _addInfo)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), itemId);

        return this.whsCheckItemDrawHandlingQty(_inventQty, _addInfo);
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsCheckItemDrawHandlingQty</Name>
				<Source><![CDATA[
    private boolean whsCheckItemDrawHandlingQty(
        InventHandlingQty  _inventHandlingQty,
        boolean            _addInfo)
    {
        boolean     ret = true;
        boolean     includeDeltaRecords;

        if (skipDelta)
        {
            includeDeltaRecords = false;
        }
        else
        {
            includeDeltaRecords = InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(itemId);
        }

        InventHandlingQty availHandlingQty = WHSInventOnHand::getPhysicalAvailHandlingQty(itemId,
                                                                                          inventDimCriteria,
                                                                                          includeDeltaRecords,
                                                                                          false);

        if (availHandlingQty < (-_inventHandlingQty))
        {
            if (_addInfo)
            {
                setPrefix("@SYS70390");

                setPrefix(inventDimCriteria.preFix());

                ret = checkFailed(strFmt("@SCM:CannotPickWithEnoughInventory", real2double(-_inventHandlingQty).ToString(), real2double(availHandlingQty).ToString(), itemId));

                this.cannotPickEnoughInventoryError(this.constructErrorParameters(-_inventHandlingQty, availHandlingQty));
            }
            else
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructErrorParameters</Name>
				<Source><![CDATA[
    private InventOnHandQtyErrorParameters constructErrorParameters(
        InventQty _requestedQuantity,
        InventQty _availablePhysicalQuantity)
    {
        InventOnHandQtyErrorParameters errorParameters = InventOnHandQtyErrorParameters::construct();

        errorParameters.requestedQuantity = _requestedQuantity;
        errorParameters.availablePhysicalQuantity = _availablePhysicalQuantity;
        errorParameters.inventDimCriteria = inventDimCriteria;
        errorParameters.itemId = itemId;

        return errorParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsCheckReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Custom check Reservation method for WHS items.
    /// </summary>
    /// <param name="_inventQty">
    /// Requested quantity.
    /// </param>
    /// <param name="_reserveOnOrdered">
    /// Yes if reserving on ordered is allowed; otherwise NoYes::No.
    /// </param>
    /// <param name="_addOnhandQty">
    /// Additional on hand quantity.
    /// </param>
    /// <returns>
    /// true, if it is possible to reserve; otherwise, false.
    /// </returns>
    public boolean whsCheckReservation(InventQty         _inventQty,         // Negative value
                                NoYes             _reserveOnOrdered,
                                InventQty         _addOnhandQty)
    {
        return this.whsCheckReservationHandlingQty(_inventQty, _reserveOnOrdered, _addOnhandQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsCheckReservationHandlingQty</Name>
				<Source><![CDATA[
    private boolean whsCheckReservationHandlingQty(
        InventHandlingQty _inventHandlingQty, // Negative value
        NoYes             _reserveOnOrdered,
        InventHandlingQty _addOnhandHandlingQty)
    {
        boolean         ret = true;

        InventQty availQty = WHSInventOnHand::getReserveHandlingQty(itemId,
                                                                    inventDimCriteria,
                                                                    _reserveOnOrdered,
                                                                    !skipDelta,
                                                                    false);

        if ((availQty + _addOnhandHandlingQty) < (-_inventHandlingQty))
        {
            if(skipDisplayWarningIfWHSCheckReservationHandlingQtyFails)
            {
                ret = false;
            }
            else
            {
                setPrefix("@SYS7120");

                setPrefix(inventDimCriteria.preFix());

                ret = checkFailed(strFmt("@SYS54812", -_inventHandlingQty, availQty));
            }
            
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipDisplayWarningIfWHSCheckReservationHandlingQtyFails</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmSkipDisplayWarningIfWHSCheckReservationHandlingQtyFails(boolean _skipDisplayWarningIfWHSCheckReservationHandlingQtyFails = skipDisplayWarningIfWHSCheckReservationHandlingQtyFails)
    {
        skipDisplayWarningIfWHSCheckReservationHandlingQtyFails = _skipDisplayWarningIfWHSCheckReservationHandlingQtyFails;

        return skipDisplayWarningIfWHSCheckReservationHandlingQtyFails;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsFindReserveDelta</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a corresponding <c>WHSInventReserveDelta</c> record.
    /// </summary>
    /// <returns>
    /// A corresponding <c>WHSInventReserveDelta</c> record.
    /// </returns>
    public WHSInventReserveDelta whsFindReserveDelta()
    {
        WHSInventReserveDelta   inventReserveDelta;

        if (inventDimId)
        {
            inventReserveDelta = WHSInventReserveDelta::sumReserveDeltaByDimId(itemId,inventDimId);
        }
        else
        {
            inventReserveDelta = WHSInventReserveDelta::sumReserveDeltaByInventDim(itemId,inventDimCriteria);
        }

        inventReserveDelta.ItemId = itemId;

        return inventReserveDelta;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsParmInventReserve</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the value for <c>inventReserve</c> property.
    /// </summary>
    /// <param name="_inventReserve">
    /// The value to be set for <c>inventReserve</c> property (for getter).
    /// </param>
    /// <returns>
    /// Current value for <c>inventReserve</c> property.
    /// </returns>
    public WHSInventReserve whsParmInventReserve(WHSInventReserve _inventReserve = inventReserve)
    {
        inventReserve = _inventReserve;

        return inventReserve;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsParmItemUsesWHS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the <c>itemUsesWHS</c> field to be used as criteria when selecting.
    /// </summary>
    /// <param name="_itemUsesWHS">
    /// The boolean value that defines if the item uses WHS.
    /// </param>
    /// <returns>
    /// true, if item uses WHS; otherwise, false.
    /// </returns>
    public boolean whsParmItemUsesWHS(boolean _itemUsesWHS = itemUsesWHS)
    {
        itemUsesWHS = _itemUsesWHS;
        return itemUsesWHS;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsParmSkipDelta</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the boolean value for <c>skipDelta</c> property.
    /// </summary>
    /// <param name="_skipDelta">
    /// New boolean value to be set for <c>skipDelta</c> property.
    /// </param>
    /// <returns>
    /// The current value of <c>skipDelta</c> property.
    /// </returns>
    public boolean whsParmSkipDelta(boolean _skipDelta = skipDelta)
    {
        skipDelta = _skipDelta;
        return skipDelta;
    }

]]></Source>
			</Method>
			<Method>
				<Name>availReservationDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets on hand quantities available for reservation
    /// </summary>
    /// <param name="_itemId">
    /// The item for which quantities are calculated.
    /// </param>
    /// <param name="_inventDimPacked">
    /// The inventory dimensions used as ranges.
    /// </param>
    /// <param name="_reserveOnOrdered">
    /// NoYes::Yes if reservation against <c>OnOrdered</c> on hands are allowed; otherwise, NoYes::No.
    /// </param>
    /// <param name="_isTransfer">
    /// NoYes::Yes if the reservation is for a transfer; otherwise, NoYes::No.
    /// </param>
    /// <param name="_shelfLifeCriteria">
    /// Additional requirements for the shelf life of the product.
    /// </param>
    /// <param name="_batchDispositionCriteria">
    /// An <c>InventBatchDispositionCriteria</c> if batch disposition status criteria should be
    /// applied to the on hand query for the reservation quantities; optional.
    /// </param>
    /// <param name="_inventOnHandCriteria">
    /// An <c>InventOnHandCriteria</c> class instance that is used to define additional reservation criteria; optional.
    /// </param>
    /// <returns>
    /// A container with quantities in inventory unit and catch weight unit.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Wrong use of this method as item must be specified.
    /// </exception>
    public static container availReservationDimensions(
        ItemId                          _itemId,
        container                       _inventDimPacked, // InventDim passed in as container to avoid a call back to client to release reference.
        NoYes                           _reserveOnOrdered,
        NoYes                           _isTransfer,
        InventShelfLifeCriteria         _shelfLifeCriteria        = null,
        InventBatchDispositionCriteria  _batchDispositionCriteria = null,
        InventOnHandCriteria            _inventOnHandCriteria     = null)
    {
        InventDim       inventDimCriteria;
        InventDimParm   inventDimParmPhysicalInvent;

        if (!_itemId)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        [inventDimCriteria] = _inventDimPacked;

        //only take the physical dimensions that have been specified into consideration when looking for on-hand
        inventDimParmPhysicalInvent.initPhysicalDimensionsFromInventDim(InventDimGroupSetup::newItemId(_itemId), inventDimCriteria);

        // Transfers need to enforce warehouse for the reservation even when they may have not
        // have it set as physical inventory. Otherwise circular reservations may occur.
        if (   inventDimCriteria.InventLocationId != ''
            && _isTransfer)
        {
            inventDimParmPhysicalInvent.InventLocationIdFlag = NoYes::Yes;
        }

        InventOnhandQty inventOnhand = InventOnHandQty::newParameters(_itemId,inventDimCriteria,inventDimParmPhysicalInvent);

        if (_inventOnHandCriteria is InventOnHandCompositeCriteria)
        {
            inventOnhand.parmAdvancedCriteria(_inventOnHandCriteria);
        }
        else
        {
            inventOnhand.parmAdvancedCriteria().addCriteria(_inventOnHandCriteria);
        }
        inventOnhand.parmAdvancedCriteria().addCriteria(_shelfLifeCriteria);
        inventOnhand.parmAdvancedCriteria().addCriteria(_batchDispositionCriteria);

        return [inventOnhand.availReservation(_reserveOnOrdered), inventOnhand.pdsCWAvailReservation(_reserveOnOrdered)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static InventOnHandQty construct()
    {
        return new InventOnHandQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newBOMReportFinish</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>InventOnHandQty</c> class based on the specified BOM journal line.
    /// </summary>
    /// <param name="_inventJournalTrans">
    /// The BOM journal line for which on hand is to be retrieved.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventOnHandQty</c> class.
    /// </returns>
    public static InventOnHandQty newBOMReportFinish(InventJournalTrans _inventJournalTrans)
    {
        InventDimParm   inventDimParm;

        InventDim inventDim = InventDim::find(_inventJournalTrans.InventDimId);
        inventDimParm.initFromInventDim(inventDim);

        return InventOnHandQty::newParameters(_inventJournalTrans.ItemId, inventDim, inventDimParm);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newEstimatedUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an instance of the <c>InventOnHandQty</c> class.
    /// </summary>
    /// <param name="_movement">
    ///    An instance of the <c>InventMovement</c> class.
    /// </param>
    /// <param name="_inventDim">
    ///    An <c>InventDim</c> record that is used by the <c>InventOnHand</c> class.
    /// </param>
    /// <param name="_inventDimFixed">
    ///    An <c>InventDimFixed</c> value.
    /// </param>
    /// <returns>
    ///    An instance of the <c>InventOnHandQty</c> class.
    /// </returns>
    /// <remarks>
    ///    If the <paramref name="_InventdimFixed" /> parameter is specified then the fixed dimensions will be
    ///    included by the <c>InventOnHandQty</c> class.
    /// </remarks>
    public static InventOnHandQty newEstimatedUpdate(
        InventMovement  _movement,
        InventDim       _inventDim,
        InventDimFixed  _inventDimFixed = 0)
    {
        InventDimParm   inventDimParm;
        InventDimParm   inventDimParmFixedDimensions;

        inventDimParm.initPhysicalDimensionsFromInventDim(_movement.inventDimGroupSetup(),_inventDim);

        // if fixed dimensions were passed the inventDimParm also needs to include these
        if (_inventDimFixed)
        {
            inventDimParmFixedDimensions.initFromInventDimFixed(_inventDimFixed);
            inventDimParm = InventDimParm::orParms(inventDimParm,inventDimParmFixedDimensions);
        }

        return InventOnHandQty::newParameters(_movement.itemId(), _inventDim, inventDimParm);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>InventOnHandQty</c> class based on the specified batch.
    /// </summary>
    /// <param name="_inventBatch">
    /// The batch for which on hand is to be retrieved.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventOnHandQty</c> class.
    /// </returns>
    public static InventOnHandQty newInventBatch(InventBatch _inventBatch)
    {
        InventOnHandQty     inventOnHandQty = InventOnHandQty::construct();

        inventOnHandQty.parmItemId(_inventBatch.ItemId);
        inventOnHandQty.parmBatchId(_inventBatch.InventBatchId);

        return inventOnHandQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newItemDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>InventOnHandQty</c> class based on the specified parameters.
    /// </summary>
    /// <param name="_itemId">
    /// The item for which on hand is to be retrieved.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimensions for which on hand is to be retrieved.
    /// </param>
    /// <param name="_inventDimParm">
    /// The identification of dimensions for which on hand is to be retrieved.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventOnHandQty</c> class.
    /// </returns>
    public static InventOnHandQty newItemDim(
        ItemId             _itemId,
        InventDim          _inventDim,
        InventDimParm      _inventDimParm)
    {
        return InventOnHandQty::newParameters(_itemId, _inventDim, _inventDimParm);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newItemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>InventOnHandQty</c> class based on the specified parameters.
    /// </summary>
    /// <param name="_itemId">
    /// The item for which on hand is to be retrieved.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventOnHandQty</c> class.
    /// </returns>
    public static InventOnHandQty newItemId(ItemId _itemId)
    {
        InventOnHandQty     inventOnHandQty = InventOnHandQty::construct();

        inventOnHandQty.parmItemId(_itemId);

        return inventOnHandQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>InventOnHandQty</c> class based on the specified parameters.
    /// </summary>
    /// <param name="_itemId">
    /// The item for which on hand is to be retrieved.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimensions for which on hand is to be retrieved.
    /// </param>
    /// <param name="_inventDimParm">
    /// The identification of dimensions for which on hand is to be retrieved.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventOnHandQty</c> class.
    /// </returns>
    public static InventOnHandQty newParameters(
        ItemId             _itemId,
        InventDim          _inventDim,
        InventDimParm      _inventDimParm = _inventDim.toDimParm())
    {
        InventOnHandQty     inventOnHandQty = InventOnHandQty::construct();

        inventOnHandQty.parmInventDim(_inventDim);
        inventOnHandQty.parmInventDimParm(_inventDimParm);
        //this will set the itemId flag on inventDimParm
        inventOnHandQty.parmItemId(_itemId);

        return inventOnHandQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newParametersActive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>InventOnHandQty</c> class based on the specified parameters.
    /// </summary>
    /// <param name="_itemId">
    /// The item for which on hand is to be retrieved.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimensions for which on hand is to be retrieved.
    /// </param>
    /// <param name="_inventDimParm">
    /// The identification of dimensions for which on hand is to be retrieved.
    /// </param>
    /// <param name="_inventDimParmActive">
    /// The identification of active dimensions which are compared to the <c>_inventDimParm</c> parameter.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventOnHandQty</c> class.
    /// </returns>
    public static InventOnHandQty newParametersActive(
        ItemId             _itemId,
        InventDim          _inventDim,
        InventDimParm      _inventDimParm,
        InventDimParm      _inventDimParmActive)
    {
        InventOnHandQty inventOnHandQty = InventOnHandQty::newParameters(_itemId,_inventDim,_inventDimParm);

        if (_inventDim.InventDimId)
        {
            if (InventDimParm::isInventDimParmEqual(_inventDimParm,_inventDimParmActive))
            {
                inventOnHandQty.parmInventDimId(_inventDim.InventDimId);
            }
        }

        return inventOnHandQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPhysicalInvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>InventOnHandQty</c> class based on the specified parameters.
    /// </summary>
    /// <param name="_movement">
    /// The inventory movement for which on hand is to be retrieved.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimensions for which on hand is to be retrieved.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventOnHandQty</c> class.
    /// </returns>
    public static InventOnHandQty newPhysicalInvent(
        InventMovement  _movement,
        InventDim       _inventDim)
    {
        return InventOnHandQty::newPhysicalUpdate(_movement,_inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPhysicalUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>InventOnHandQty</c> class based on the specified parameters.
    /// </summary>
    /// <param name="_movement">
    /// The inventory movement for which on hand is to be retrieved.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimensions for which on hand is to be retrieved.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventOnHandQty</c> class.
    /// </returns>
    public static InventOnHandQty newPhysicalUpdate(
        InventMovement  _movement,
        InventDim       _inventDim)
    {
        InventDimParm       inventDimParmActivePhyscicalInvent;
        InventDimParm       inventDimParmActive;

        // Fields might not have been selected on the specified buffers, or might have been updated since selection
        _inventDim.checkInvalidFieldAccess(false);

        _movement.inventDimGroupSetup().inventDimParmActivePhysicalInventory(inventDimParmActivePhyscicalInvent);
        inventDimParmActivePhyscicalInvent.setAllProductDimensions(); // All updates must match all product dimensions

        InventOnHandQty inventOnHandQty = InventOnHandQty::newParameters(_movement.itemId(), _inventDim, inventDimParmActivePhyscicalInvent);

        if (_inventDim.InventDimId)
        {
            _movement.inventDimGroupSetup().inventDimParmActive(inventDimParmActive);

            if (InventDimParm::isInventDimParmEqual(inventDimParmActivePhyscicalInvent,inventDimParmActive))
            {
                inventOnHandQty.parmInventDimId(_inventDim.InventDimId);
            }
        }

        return inventOnHandQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemDrawPhysicalInvent</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if given quantity can be picked or deducted.
    /// </summary>
    /// <param name="_inventQty">
    ///     Requested quantity.
    /// </param>
    /// <returns>
    ///     true, if it is possible to pick/deduct; otherwise, false.
    /// </returns>
    public boolean checkItemDrawPhysicalInvent(InventQty _inventQty)
    {
        if (this.physicalInvent() < -_inventQty)
        {
            setPrefix("@SYS70390");

            setPrefix(inventDimCriteria.preFix());

            if (!InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().isFinalCommit())
            {
                return checkFailed(strFmt("@SCM:CannotPickWithEnoughInventory", real2double(-_inventQty).ToString(), real2double(this.physicalInvent()).ToString(), itemId));
            }
            else
            {
                InventQty physicalInventPost = this.physicalInvent();

                InventSumDelta inventSumDelta = this.findSumJoinDelta();
                inventSum.clear();
                inventSum.addInventSumDeltaQty(inventSumDelta);
                inventSum.addInventSumDeltaValues(inventSumDelta);
                InventQty physicalInventDelta = this.physicalInvent();

                return checkFailed(strFmt("@SCM:CannotPickWithEnoughInventory", real2double(-physicalInventDelta).ToString(), real2double(physicalInventPost-physicalInventDelta).ToString(), itemId));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSumJoinDeltaWithBatchIdOrSerialId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the summarized on hand based on batch ID or serial ID.
    /// </summary>
    /// <returns>An <c>InventSumDelta</c> record.</returns>
    /// <remarks>If you replace this method you also need to replace the InventOnhand.findSumJoinDeltaWithBatchIdOrSerialId().</remarks>
    [Replaceable]
    protected InventSumDelta findSumJoinDeltaWithBatchIdOrSerialId()
    {
        InventDim       inventDim;
        InventSumDelta  inventSumDelta;

        SysDaQueryObject queryObject = new SysDaQueryObject(inventSumDelta);
        InventDim::dimAddInventSumDeltaFieldsQuantityQueryProjection(queryObject);
        
        SysDaQueryExpression whereClause =
            new SysDaEqualsExpression(
                new SysDaFieldExpression(inventSumDelta, fieldStr(InventSumDelta, SQLTransactionId)),
                new SysDaValueExpression(InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().sqlTransactionId()));
        if (inventDimParm.ItemIdFlag)
        {
            whereClause = whereClause.and(
                new SysDaEqualsExpression(new SysDaFieldExpression(inventSumDelta, fieldStr(InventSumDelta, ItemId)), new SysDaValueExpression(itemId)));
        }

        if (InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
        {
            whereClause = whereClause.and(InventSumDelta::addInventSumDeltaQueryObject(inventSumDelta, inventDimCriteria, inventDimParm));
            queryObject.whereClause(whereClause);
        }
        else
        {
            queryObject.whereClause(whereClause);

            InventDim::dimAddInventDimExistsJoin(queryObject,
                new SysDaFieldExpression(inventSumDelta, fieldStr(InventSumDelta, InventDimId)),
                inventDim,
                inventDimCriteria,
                inventDimParm);
        }

        SysDaFindStatement findStatement = new SysDaFindStatement();
        findStatement.execute(new SysDaFindObject(queryObject));

        return inventSumDelta;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSumJoinWithBatchIdOrSerialId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the summarized on hand based on batch ID or serial ID.
    /// </summary>
    /// <returns>An <c>InventSum</c> record.</returns>
    /// <remarks>If you replace this method you also need to replace the InventOnhand.findSumJoinWithBatchIdOrSerialId().</remarks>
    [Replaceable]
    protected InventSum findSumJoinWithBatchIdOrSerialId()
    {
        InventDim   inventDim;
        InventSum   inventSumLocal;

        SysDaQueryObject queryObject = new SysDaQueryObject(inventSumLocal);
        InventDim::dimAddInventSumFieldsQuantityQueryProjection(queryObject);
        
        SysDaQueryExpression whereClause =
            new SysDaEqualsExpression(
                    new SysDaFieldExpression(inventSumLocal, fieldStr(InventSum, Closed)),
                    new SysDaValueExpression(NoYes::No));
        if (inventDimParm.ItemIdFlag)
        {
            whereClause = whereClause
                .and(new SysDaEqualsExpression(new SysDaFieldExpression(inventSumLocal, fieldStr(InventSum, ItemId)), new SysDaValueExpression(itemId)));
        }

        if (InventUseDimOfInventSumForPublicQueryToggle::instance().isEnabled())
        {
            whereClause = whereClause.and(InventSum::addInventSumQueryObject(inventSumLocal, inventDimCriteria, inventDimParm));
            queryObject.whereClause(whereClause);
        }
        else
        {
            queryObject.whereClause(whereClause);

            InventDim::dimAddInventDimExistsJoin(queryObject,
                new SysDaFieldExpression(inventSumLocal, fieldStr(InventSum, InventDimId)),
                inventDim,
                inventDimCriteria,
                inventDimParm);
        }

        SysDaFindStatement findStatement = new SysDaFindStatement();
        findStatement.execute(new SysDaFindObject(queryObject));

        return inventSumLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSumWithItemAndDimCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the summarized on hand for items where dimension ID has not been specified.
    /// </summary>
    /// <returns>
    /// An <c>InventSum</c> record.
    /// </returns>
    protected InventSum findSumWithItemAndDimCriteria()
    {
        return InventSum::findSumQty(itemId,inventDimCriteria,inventDimParm);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseInventSumDirectly</Name>
				<Source><![CDATA[
    public boolean parmUseInventSumDirectly(boolean _useInventSumDirectly = useInventSumDirectly)
    {
        useInventSumDirectly = _useInventSumDirectly;

        return useInventSumDirectly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAvailTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the catch weight total quantity available for order.
    /// </summary>
    /// <returns>
    /// The catch weight quantity of available total inventory.
    /// </returns>
    public PdsCWAvailOrdered pdsCWAvailTotal()
    {
        this.setInventSum();

        return this.pdsCWAvailOrdered() - this.pdsCWOnOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWOrderedSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the quantity that was ordered
    /// but is not physically available in the warehouse yet.
    /// </summary>
    /// <returns>
    /// The quantity in the catch weight unit.
    /// </returns>
    /// <remarks>
    /// Goods that are in the Arrived status are not physically available
    /// in the warehouse yet so the result of this method is the Ordered + Arrived quantity.
    /// </remarks>
    public PdsCWOrdered pdsCWOrderedSum()
    {
        return this.pdsCWOrdered() + this.pdsCWArrived();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWHSAvailableQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the <c>AvailPhysical</c> and <c>AvailOrdered</c> quantities on the internal on hand buffer for Warehouse management enabled items
    ///     based on values held in the <c>WHSInventReserve</c> record.
    /// </summary>
    /// <param name="_includeDelta">
    ///     A Boolean value that specifies whether or not delta records should be used in the calculation.
    /// </param>
    protected void setWHSAvailableQuantities(boolean _includeDelta)
    {
        WHSInventReserveQuantities quantities = whsInventOnHand::getAllAvailQuantities(itemId, inventDimCriteria, _includeDelta);
        
        inventSum.AvailPhysical = quantities.AvailPhysical;
        inventSum.AvailOrdered  = quantities.AvailOrdered;
        inventSum.PdsCWAvailPhysical = quantities.CWAvailPhysical;
        inventSum.PdsCWAvailOrdered = quantities.CWAvailOrdered;
        
        if (advancedCriteria && advancedCriteria.mustBeApplied())
        {
            WHSItemReservationHierarchyProvider hierarchyProvider = WHSItemReservationHierarchyProvider::newFromInventTable(InventTable::find(itemId));
            if (hierarchyProvider.isBatchAboveLocation())
            {
                WHSInventReserve advancedCriteriaSum = this.findWHSAvailQtyWithAdvancedCriteria(hierarchyProvider);

                inventSum.AvailPhysical = min(inventSum.AvailPhysical, advancedCriteriaSum.AvailPhysical);
                inventSum.AvailOrdered = min(inventSum.AvailOrdered, advancedCriteriaSum.AvailOrdered);
                inventSum.PdsCWAvailPhysical = min(inventSum.PdsCWAvailPhysical, advancedCriteriaSum.CWAvailPhysical);
                inventSum.PdsCWAvailOrdered = min(inventSum.PdsCWAvailOrdered, advancedCriteriaSum.CWAvailOrdered);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWHSReservedQuantities</Name>
				<Source><![CDATA[
    private void setWHSReservedQuantities(boolean _includeDelta)
    {
        if (inventDimId)
        {
            inventReserve = WHSInventReserve::find(itemId, inventDimId);
        }
        else
        {
            inventReserve = WHSInventReserve::findByInventDim(itemId, inventDimCriteria);
        }

        if (_includeDelta)
        {
            inventReserve.addInventReserveDelta(this.whsFindReserveDelta());
        }

        // Reserved quantities are taken from the exact level of the dimension hierarchy
        // Taking minimums is only needed for available quantities
        inventSum.ReservPhysical = inventReserve.ReservPhysical;
        inventSum.ReservOrdered = inventReserve.ReservOrdered;
        inventSum.PdsCWReservPhysical = inventReserve.CWReservPhysical;
        inventSum.PdsCWReservOrdered = inventReserve.CWReservOrdered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWHSSumReserve</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set availPhysical, availOrdered, reservPhysical and reservOrdered values on internal on hand buffer for Warehouse management enabled items
    /// based on values held in the <c>WHSInventReserve</c>
    /// </summary>
    protected void setWHSSumReserve()
    {
        boolean includeDelta = InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(itemId);

        this.setWHSReservedQuantities(includeDelta);
        this.setWHSAvailableQuantities(includeDelta);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWHSSumReserveWithDimGaps</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets availPhysical and availOrdered values on internal on hand buffer for warehouse management enabled items
    /// based on values held in the <c>WHSInventReserve</c> table when there are gaps in the criteria dimensions.
    /// </summary>
    protected void setWHSSumReserveWithDimGaps()
    {
        WHSInventReserveQty inventReserveQty = WHSInventReserveQty::newFromParms(InventTable::find(itemId), inventDimCriteria, inventDimParm, inventSum);

        inventSum.AvailOrdered = inventReserveQty.availOrdered();
        inventSum.AvailPhysical = inventReserveQty.availPhysical();
        inventSum.ReservOrdered = inventReserveQty.reservOrdered();
        inventSum.ReservPhysical = inventReserveQty.reservPhysical();
        inventSum.PdsCWAvailOrdered = inventReserveQty.PdsCWAvailOrdered();
        inventSum.PdsCWAvailPhysical = inventReserveQty.PdsCWAvailPhysical();
        inventSum.PdsCWReservOrdered = inventReserveQty.PdsCWReservOrdered();
        inventSum.PdsCWReservPhysical = inventReserveQty.PdsCWReservPhysical();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>