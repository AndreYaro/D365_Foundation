<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BankAccountTransDateChange_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Use of transit account for changing the date of transaction.
/// </summary>
final class BankAccountTransDateChange_RU extends RunBase
{
    BankAccountTrans              bankAccountTrans,
                                  bankAccountTransDebit,
                                  bankAccountTransCredit;
    TransDate                     transDate;
    BankTransactionType           bankTransType;
    DialogField                   dialogFieldTransDate,
                                  dialogFieldBankTransType,
                                  dialogFieldDocIdStorno,
                                  dialogFieldDocIdNew;
    boolean                       periodIsOpen, isLedger2Bank, isManualSequence;

    LedgerDimensionDefaultAccount transitDefaultAccount;
    container                     docIdCon;
    container                     voucherCon;
    #define.ConPos1(1)
    #define.ConPos2(2)
    #define.ConPos3(3)
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addLedgerVoucherObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds new <c>LedgerVoucherObject</c> object to <c>LedgerVoucher</c> and
    /// adds voucher Id to container of vouchers
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// <c>LedgerVoucher</c> types value
    /// </param>
    /// <param name="_transDate">
    /// Date of new voucher
    /// </param>
    /// <returns>
    /// Voucher Id of new voucher
    /// </returns>
    private Voucher addLedgerVoucherObject(LedgerVoucher _ledgerVoucher, TransDate _transDate)
    {
        Voucher                newVoucher;

        newVoucher = NumberSeq::newGetVoucherFromCode(_ledgerVoucher.parmVoucherSeriesCode()).voucher();

        _ledgerVoucher.addVoucher(LedgerVoucherObject::newVoucher(newVoucher,
                                                                  _transDate,
                                                                  SysModule::Bank,
                                                                  LedgerTransType::Bank));

        voucherCon += newVoucher;

        return newVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateRCashDocId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets cash document number from Number sequence
    /// </summary>
    /// <param name="_rCashTrans">
    /// Cash transaction record
    /// </param>
    /// <param name="_checkManual">
    /// Check number sequence Manual field, if true - sets isManualSequence variable
    /// </param>
    /// <remarks>
    /// Adds Doc Id twise - for storno and new transactions
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// throw exception if ref of number sequence doesn't contain number sequence code
    /// </exception>
    private void allocateRCashDocId(RCashTrans _rCashTrans, boolean _checkManual = false)
    {
        NumberSequenceReference numberSequenceReference = RCashParameters::numRefDocCorrectionId();
        NumberSequenceGroupId   numberSequenceGroup     = RCashTable::find(_rCashTrans.AccountNum).NumberSequenceGroup;
        NumberSequenceGroupRef  numberSequenceGroupRef;
        NumberSequenceTable     numberSequenceTableNum;
        RefRecId                scopeId                 = NumberSeqScopeFactory::createDefaultScope().getId();
        Num                     num;
        ;

        if (numberSequenceGroup)
        {
            numberSequenceGroupRef = NumberSequenceGroupRef::findNaturalKey(numberSequenceReference.NumberSequenceDatatype,
                scopeId,
                numberSequenceGroup);

            if (numberSequenceGroupRef.NumberSequenceId)
            {
                numberSequenceReference.NumberSequenceId = numberSequenceGroupRef.NumberSequenceId;
            }
        }

        if (! numberSequenceReference.NumberSequenceId)
        {
            throw error("@SYS54052");
        }

        numberSequenceTableNum = NumberSequenceTable::find(numberSequenceReference.NumberSequenceId);

        if (numberSequenceTableNum.Manual && _checkManual)
        {
            isManualSequence = true;
        }
        else if (! _checkManual)
        {
            num = NumberSeq::newGetNumFromId(numberSequenceReference.NumberSequenceId).num();

            docIdCon += num;

            num = NumberSeq::newGetNumFromId(numberSequenceReference.NumberSequenceId).num();

            docIdCon += num;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateVouchers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new instance of <c>LedgerVoucher</c> and adds <c>LedgerVoucherObject</c>
    /// object for storno, new and transit operations
    /// </summary>
    /// <returns>
    /// Returns <c>LedgerVoucher</c> type object
    /// </returns>
    /// <remarks>
    /// Gets number sequence code from source journal, if there is no code - from parameters of Bank module
    /// </remarks>
    public LedgerVoucher allocateVouchers()
    {
        LedgerVoucher           ledgerVoucher;
        NumberSequenceCode      numberSequenceCode;
        GeneralJournalEntry     generalJournalEntry;
        LedgerJournalTable      ledgerJournalTable;

        generalJournalEntry = GeneralLedgerExtension::findByReferenceNumberAccountingDate(bankAccountTrans.Voucher, bankAccountTrans.TransDate);

        if (generalJournalEntry)
        {
            ledgerJournalTable = LedgerJournalTable::find(LedgerEntryJournal::find(generalJournalEntry.LedgerEntryJournal).JournalNumber);
            numberSequenceCode = NumberSequenceTable::find(ledgerJournalTable.NumberSequenceTable).NumberSequence;
        }

        if (!numberSequenceCode)
        {
            numberSequenceCode = BankParameters::numRefBankReconcileVoucher().numberSequenceTable().NumberSequence;
        }

        ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail,
                                                     SysModule::Bank,
                                                     numberSequenceCode);

        this.addLedgerVoucherObject(ledgerVoucher, this.bankAccountTransDate()); // voucher for storno operations

        this.addLedgerVoucherObject(ledgerVoucher, transDate); // voucher for new operations

        if (bankAccountTrans.isBank2Bank_RU() || bankAccountTrans.isCash2Bank_RU())
        {
            this.addLedgerVoucherObject(ledgerVoucher, this.bankAccountTransDate()); // voucher for operations on transit account
        }

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankAccountTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines trans date for transactions
    /// </summary>
    /// <param name="_bankAccountTrans">
    /// Bank trans record
    /// </param>
    /// <returns>
    /// Transaction date
    /// </returns>
    /// <remarks>
    /// If ledger fiscal period is open then returns date
    /// from source transaction, otherwise from dialog
    /// </remarks>
    private TransDate bankAccountTransDate(BankAccountTrans _bankAccountTrans = bankAccountTrans)
    {
        return periodIsOpen ? _bankAccountTrans.TransDate : transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankAccountTransDebitCredit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets debit and credit bank transactions
    /// </summary>
    /// <param name="_bankAccountTrans">
    /// Bank transaction record
    /// </param>
    /// <param name="_refRecId">
    /// Reference to initial record the record is derived from
    /// </param>
    /// <returns>
    /// Couple bank transactions in container
    /// </returns>
    private container bankAccountTransDebitCredit(BankAccountTrans _bankAccountTrans = bankAccountTrans,
                                                  RefRecId         _refRecId         = 0)
    {
        BankAccountTrans bankAccountTransLocalDebit, bankAccountTransLocalCredit;
        ;

        while select bankAccountTransLocalDebit
            where bankAccountTransLocalDebit.Voucher      == _bankAccountTrans.Voucher   &&
                  bankAccountTransLocalDebit.TransDate    == _bankAccountTrans.TransDate &&
                  bankAccountTransLocalDebit.AccountId    == _bankAccountTrans.AccountId &&
                  (bankAccountTransLocalDebit.RefRecId_RU == _refRecId                   ||
                  (_refRecId ? true : false))
        {
            select firstonly bankAccountTransLocalCredit
                where bankAccountTransLocalCredit.Voucher               == bankAccountTransLocalDebit.Voucher               &&
                      bankAccountTransLocalCredit.TransDate             == bankAccountTransLocalDebit.TransDate             &&
                      bankAccountTransLocalCredit.AccountId             != bankAccountTransLocalDebit.AccountId             &&
                      bankAccountTransLocalCredit.BankTransCurrencyCode == bankAccountTransLocalDebit.BankTransCurrencyCode &&
                      bankAccountTransLocalCredit.BankTransAmountCur    == - bankAccountTransLocalDebit.BankTransAmountCur  &&
                      (bankAccountTransLocalCredit.RefRecId_RU          == _refRecId                                        ||
                      (_refRecId ? true : false));
            if (bankAccountTransLocalCredit)
                break;
        }

        return bankAccountTransLocalDebit.BankTransAmountCur >= 0   ?
               [bankAccountTransLocalDebit,  bankAccountTransLocalCredit] :
               [bankAccountTransLocalCredit, bankAccountTransLocalDebit];
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check source bank transaction date
    /// </summary>
    /// <returns>
    /// Container of warning messages
    /// </returns>
    private container check()
    {
        LedgerFiscalCalendarPeriod  ledgerFiscalCalendarPeriod;
        container                   messageCon;
        RecordSortedList            relatedList;
        BankAccountTrans            bankAccountTransLocalDebit,
                                    bankAccountTransLocalCredit,
                                    bankAccountTransLocal;
        Set                         transDateSet;
        SetEnumerator               transDateSetEnumerator;
        int                         counter;
        ;

        ledgerFiscalCalendarPeriod = LedgerFiscalCalendar::findLedgerPeriodByPeriodTypeDate(CompanyInfoHelper::fiscalCalendarRecId(),
                                                                                       bankAccountTrans.TransDate,
                                                                                       FiscalPeriodType::Operating);

        if (ledgerFiscalCalendarPeriod.Status != FiscalPeriodStatus::Open)
        {
            messageCon = conPoke(messageCon, conLen(messageCon) + 1, strFmt("@SYS17615", bankAccountTrans.TransDate));
        }

        periodIsOpen = ! conLen(messageCon);

        transDateSet = new Set(Types::Date);

        relatedList = bankAccountTrans.findRelatedTrans_RU();
        while (relatedList.next(bankAccountTransLocal))
        {
            if (bankAccountTransLocal.RefRecId_RU == bankAccountTransLocal.RecId)
            {
                break;
            }
        }

        [bankAccountTransLocalDebit, bankAccountTransLocalCredit] = this.bankAccountTransDebitCredit(bankAccountTransLocal, 1);

        if (bankAccountTrans.AccountId == bankAccountTransLocalCredit.AccountId)
        {
            relatedList = bankAccountTransLocalDebit.findRelatedTrans_RU();
            while (relatedList.next(bankAccountTransLocal))
            {
                transDateSet.add(bankAccountTransLocal.TransDate);
            }
            transDateSetEnumerator = transDateSet.getEnumerator();
            counter = 0;
            while (transDateSetEnumerator.moveNext())
            {
                counter ++;
                if (counter == transDateSet.elements())
                    break;
            }
            if (transDate > transDateSetEnumerator.current())
            {
                messageCon = conPoke(messageCon, conLen(messageCon) + 1, strFmt("@GLS108401",
                                                                         bankAccountTransLocalDebit.AccountId,
                                                                         transDateSetEnumerator.current()));
            }
        }

        return messageCon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBankAccountTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates storno and new bank transaction
    /// </summary>
    private void createBankAccountTrans()
    {
        BankAccountTrans        bankAccountTransLocal, bankAccountTransLocalNew;
        CompanyBankAccountId    accountIdCredit;
        Voucher                 currentVoucher;
        TransDate               currentTransDate;
        ;

        if (bankAccountTransDebit && bankAccountTransCredit)
        {
            accountIdCredit = bankAccountTransCredit.AccountId;
        }

        while select forupdate bankAccountTransLocal
            where bankAccountTransLocal.Voucher   == bankAccountTrans.Voucher &&
                  bankAccountTransLocal.TransDate == bankAccountTrans.TransDate
        {
            if ((bankAccountTransLocal.AccountId != bankAccountTrans.AccountId &&
                 bankAccountTransLocal.RefRecId_RU)                            ||
                 ! bankAccountTransLocal.isEditable_RU())
            {
                continue;
            }
            currentVoucher   = conPeek(voucherCon, #ConPos1);
            currentTransDate = this.bankAccountTransDate();
            if (! BankAccountTable::checkIsActive(bankAccountTransLocal.AccountId, currentTransDate))
            {
                continue;
            }

            // create storno transaction
            bankAccountTransLocalNew.data(bankAccountTransLocal);

            bankAccountTransLocalNew.Voucher   = currentVoucher;
            bankAccountTransLocalNew.TransDate = currentTransDate;

            bankAccountTransLocalNew.RefRecId_RU        =   bankAccountTransLocal.RecId;

            bankAccountTransLocalNew.AmountCur          = - bankAccountTransLocal.AmountCur;
            bankAccountTransLocalNew.AmountMST          = - bankAccountTransLocal.AmountMST;
            bankAccountTransLocalNew.BankTransAmountCur = - bankAccountTransLocal.BankTransAmountCur;

            if (bankAccountTransLocal.Reconciled)
            {
                bankAccountTransLocalNew.Included             = NoYes::Yes;
                bankAccountTransLocalNew.Reconciled           = NoYes::Yes;
                bankAccountTransLocalNew.AccountStatement     = bankAccountTransLocal.AccountStatement;
                bankAccountTransLocalNew.AccountStatementDate = bankAccountTransLocal.AccountStatementDate;
            }

            bankAccountTransLocalNew.doInsert();

            // create new transaction
            currentVoucher   = conPeek(voucherCon, #ConPos2);
            currentTransDate = transDate;

            if (bankAccountTransLocal.AccountId == accountIdCredit)
            {
                currentVoucher = conPeek(voucherCon, #ConPos3);

                if (bankAccountTransLocal.AccountId != bankAccountTrans.AccountId)
                {
                    currentTransDate = this.bankAccountTransDate();
                }
            }

            bankAccountTransLocalNew.data(bankAccountTransLocal);

            bankAccountTransLocalNew.Voucher       = currentVoucher;
            bankAccountTransLocalNew.TransDate     = currentTransDate;

            bankAccountTransLocalNew.RefRecId_RU   = bankAccountTransLocal.RecId;
            bankAccountTransLocalNew.BankTransType = isLedger2Bank                       ?
                                                     bankAccountTransLocal.BankTransType :
                                                     bankTransType;

            if (bankAccountTransLocal.Reconciled)
            {
                bankAccountTransLocalNew.Included             = NoYes::Yes;
                bankAccountTransLocalNew.Reconciled           = NoYes::Yes;
                bankAccountTransLocalNew.AccountStatement     = bankAccountTransLocal.AccountStatement;
                bankAccountTransLocalNew.AccountStatementDate = bankAccountTransLocal.AccountStatementDate;
            }

            bankAccountTransLocalNew.doInsert();

            if (! bankAccountTransLocal.RefRecId_RU)
            {
                bankAccountTransLocal.RefRecId_RU = bankAccountTransLocal.RecId;
                bankAccountTransLocal.doUpdate();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerTransNew</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new Ledger transactions
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// <c>LedgerVoucher</c> types object
    /// </param>
    private void createLedgerTransNew(LedgerVoucher _ledgerVoucher)
    {
        LedgerVoucherObject             ledgerVoucherObject;
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        LedgerBondClient_RU             ledgerBondClient;

        GeneralJournalEntry             generalJournalEntry, generalJournalEntryCorr;

        LedgerEntry                     ledgerEntry, ledgerEntryCorr;

        GeneralJournalAccountEntry      generalJournalAccountEntry, generalJournalAccountEntryCorr;
        GeneralJournalAccountEntry_W    generalJournalAccountEntryW;

        SubledgerVoucherGeneralJournalEntry voucherLink;

        LedgerEntryJournal              ledgerEntryJournalCorr;
        /*LedgerDimensionDefaultAccount*/
        LedgerJournalAC                 transDefaultAccount,
                                        transDefaultAccountCorr;

        /*LedgerDimensionDefaultAccount*/
        LedgerJournalAC                 creditDefaultAccount,
                                        debitDefaultAccount,
                                        cashDefaultAccount;

        BankAccountTrans                bankAccountTransLocal;
        Voucher                         currentVoucherDebit, currentVoucherCredit;
        TransDate                       currentTransDateDebit, currentTransDateCredit;
        LedgerPostingType               oldPostingType;
        CompanyBankAccountId            bankAccountIdCredit;
        boolean                         onCredit = false, addCredit = false, addDebit = false;
        RCashTrans                      rCashTransLocal;

        if (bankAccountTransDebit && bankAccountTransCredit)
        {
            creditDefaultAccount = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(bankAccountTransCredit.LedgerDimension);
            debitDefaultAccount  = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(bankAccountTransDebit.LedgerDimension);
        }
        else if (bankAccountTrans.isCash2Bank_RU())
        {
            select firstonly LedgerDimension, CurrencyCode, AmountCur, AmountMST from rCashTransLocal
                where rCashTransLocal.Voucher   == bankAccountTrans.Voucher   &&
                      rCashTransLocal.TransDate == bankAccountTrans.TransDate &&
                      rCashTransLocal.AmountCur <  0;

             cashDefaultAccount  = rCashTransLocal.AccountNum; // DimensionStorage::ledgerDimension2AccountNum();
             debitDefaultAccount = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(bankAccountTrans.LedgerDimension);
        }

        if (LedgerParameters::find().Correspondence_RU == NoYes::No)
        {
            if (bankAccountIdCredit)
            {
                select count(RecId) from bankAccountTransLocal
                    where bankAccountTransLocal.Voucher   == bankAccountTransCredit.Voucher   &&
                          bankAccountTransLocal.TransDate == bankAccountTransCredit.TransDate &&
                          bankAccountTransLocal.AccountId == bankAccountTransCredit.AccountId;
                onCredit = bankAccountTransLocal.RecId > 1 ? true : false;
            }

            while select RecId from voucherLink
                where voucherLink.VoucherDataAreaId   == bankAccountTrans.DataAreaId &&
                      voucherLink.Voucher             == bankAccountTrans.Voucher    &&
                      voucherLink.AccountingDate      == bankAccountTrans.TransDate
                join RecId from generalJournalEntry
                    where generalJournalEntry.RecId == voucherLink.GeneralJournalEntry &&
                          generalJournalEntry.Ledger == Ledger::current()
                join generalJournalAccountEntry
                    where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                outer join ledgerEntry
                    where ledgerEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
            {
                 currentVoucherDebit    = conPeek(voucherCon, #ConPos2);
                 currentTransDateDebit  = transDate;

                transDefaultAccount = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(generalJournalAccountEntry.LedgerDimension);

                if (bankAccountIdCredit                                   &&
                    (transDefaultAccount == creditDefaultAccount        ||
                    (transDefaultAccount != creditDefaultAccount        &&
                    transDefaultAccount  != debitDefaultAccount         &&
                    onCredit)))
                {
                     currentVoucherDebit = conPeek(voucherCon, #ConPos3);
                    if (bankAccountIdCredit != bankAccountTrans.AccountId)
                    {
                        currentTransDateDebit = this.bankAccountTransDate();
                    }
                }
                else if (transDefaultAccount == cashDefaultAccount)
                {
                    currentVoucherDebit   = conPeek(voucherCon, #ConPos3);
                    currentTransDateDebit = this.bankAccountTransDate();
                }

                ledgerVoucherTransObject    = LedgerVoucherTransObject::newGeneralJournal(generalJournalAccountEntry, ledgerEntry);
                ledgerVoucherTransObject.parmIsCorrection(NoYes::No);

                ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject(currentVoucherDebit, currentTransDateDebit);
                ledgerVoucherObject.parmAccountingDate(currentTransDateDebit);

                ledgerVoucherObject.addTrans(ledgerVoucherTransObject);

                if ((bankAccountIdCredit &&
                    ((transDefaultAccount                           == creditDefaultAccount                         &&
                      generalJournalAccountEntry.TransactionCurrencyCode    == bankAccountTransCredit.BankTransCurrencyCode &&
                      generalJournalAccountEntry.TransactionCurrencyAmount  == bankAccountTransCredit.BankTransAmountCur    &&
                      generalJournalAccountEntry.AccountingCurrencyAmount   == bankAccountTransCredit.AmountMST             &&
                      ! addCredit)                                                             ||
                    (transDefaultAccount                            == debitDefaultAccount                          &&
                     generalJournalAccountEntry.TransactionCurrencyCode     == bankAccountTransDebit.BankTransCurrencyCode  &&
                     generalJournalAccountEntry.TransactionCurrencyAmount   == bankAccountTransDebit.BankTransAmountCur     &&
                     generalJournalAccountEntry.AccountingCurrencyAmount    == bankAccountTransDebit.AmountMST              &&
                     ! addDebit)))                                                             ||
                     // for cash2bank -->
                    ((transDefaultAccount                           == cashDefaultAccount                           &&
                     ! addCredit)                                                              ||
                    (transDefaultAccount                           == debitDefaultAccount                          &&
                     generalJournalAccountEntry.TransactionCurrencyCode     == rCashTransLocal.CurrencyCode                 &&
                     generalJournalAccountEntry.TransactionCurrencyAmount   == - rCashTransLocal.AmountCur                  &&
                     generalJournalAccountEntry.AccountingCurrencyAmount    == - rCashTransLocal.AmountMST                  &&
                     ! addDebit)))
                {
                    if (transDefaultAccount == creditDefaultAccount ||
                        transDefaultAccount == cashDefaultAccount)
                    {
                        addCredit = true;
                    }
                    if (transDefaultAccount == debitDefaultAccount)
                    {
                        addDebit = true;
                    }

                    ledgerVoucherTransObject = LedgerVoucherTransObject::newGeneralJournal(generalJournalAccountEntry, ledgerEntry);
                    ledgerVoucherTransObject.parmPostingType(LedgerPostingType::LedgerJournal);
                    ledgerVoucherTransObject.parmLedgerDimensionId(
                        LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(transitDefaultAccount, generalJournalAccountEntry.LedgerDimension));

                    ledgerVoucherTransObject.invertAmounts();
                    ledgerVoucherObject.addTrans(ledgerVoucherTransObject);
                }
            }
        }
        else
        {
            while select RecId from voucherLink
                where voucherLink.VoucherDataAreaId   == bankAccountTrans.DataAreaId    &&
                      voucherLink.Voucher             == bankAccountTrans.Voucher       &&
                      voucherLink.AccountingDate      == bankAccountTrans.TransDate
                join RecId from generalJournalEntry
                    where generalJournalEntry.RecId == voucherLink.GeneralJournalEntry  &&
                          generalJournalEntry.Ledger == Ledger::current()
                join generalJournalAccountEntry
                    where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId &&
                          generalJournalAccountEntry.IsCredit            == false
                outer join * from generalJournalAccountEntryW
                    where generalJournalAccountEntryW.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
                outer join ledgerEntry
                    where ledgerEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
            {
                currentVoucherDebit    = conPeek(voucherCon, #ConPos2);
                currentTransDateDebit  = transDate;
                currentVoucherCredit   = conPeek(voucherCon, #ConPos2);
                currentTransDateCredit = transDate;

                oldPostingType         = generalJournalAccountEntry.PostingType;

                generalJournalAccountEntryCorr = generalJournalAccountEntryW.bondedLine_RU();

                transDefaultAccount     = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(generalJournalAccountEntry.LedgerDimension);
                transDefaultAccountCorr = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(generalJournalAccountEntryCorr.LedgerDimension);

                if ((transDefaultAccount     == creditDefaultAccount  ||
                    transDefaultAccountCorr  == creditDefaultAccount) ||
                    (transDefaultAccount     == cashDefaultAccount    ||
                    transDefaultAccountCorr  == cashDefaultAccount))
                {
                    if (generalJournalAccountEntry.PostingType     == LedgerPostingType::Bank &&
                        generalJournalAccountEntryCorr.PostingType == LedgerPostingType::Bank)
                    {
                        if (transDefaultAccount == creditDefaultAccount)
                        {
                            currentVoucherDebit   = conPeek(voucherCon, #ConPos3);
                            if (bankAccountIdCredit != bankAccountTrans.AccountId)
                            {
                                currentTransDateDebit = this.bankAccountTransDate();
                            }
                        }
                        if (transDefaultAccountCorr == creditDefaultAccount)
                        {
                            currentVoucherCredit = conPeek(voucherCon, #ConPos3);
                            if (bankAccountIdCredit != bankAccountTrans.AccountId)
                            {
                                currentTransDateCredit = this.bankAccountTransDate();
                            }
                        }
                    }
                    else if ((generalJournalAccountEntry.PostingType            == LedgerPostingType::Bank   &&
                              generalJournalAccountEntryCorr.PostingType        == LedgerPostingType::RCash) ||
                             (generalJournalAccountEntry.PostingType            == LedgerPostingType::RCash  &&
                              generalJournalAccountEntryCorr.PostingType        == LedgerPostingType::Bank))
                    {
                        if (transDefaultAccount == cashDefaultAccount)
                        {
                            currentVoucherDebit   = conPeek(voucherCon, #ConPos3);
                            currentTransDateDebit = this.bankAccountTransDate();
                        }
                        if (transDefaultAccountCorr == cashDefaultAccount)
                        {
                            currentVoucherCredit   = conPeek(voucherCon, #ConPos3);
                            currentTransDateCredit = this.bankAccountTransDate();
                        }
                    }
                    else
                    {
                        currentVoucherDebit    = conPeek(voucherCon, #ConPos3);
                        currentVoucherCredit   = conPeek(voucherCon, #ConPos3);
                        if (bankAccountIdCredit != bankAccountTrans.AccountId)
                        {
                            currentTransDateDebit  = this.bankAccountTransDate();
                            currentTransDateCredit = this.bankAccountTransDate();
                        }
                    }
                }

                generalJournalAccountEntry.IsCorrection       = NoYes::No;

                ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject(currentVoucherDebit, currentTransDateDebit);
                ledgerVoucherObject.parmAccountingDate(currentTransDateDebit);

                ledgerBondClient    = ledgerVoucherObject.ledgerBondClient_RU();

                ledgerVoucherObject.addTrans(LedgerVoucherTransObject::newGeneralJournal(generalJournalAccountEntry,
                                                                                         ledgerEntry));

                if ((generalJournalAccountEntry.PostingType     == LedgerPostingType::Bank   &&
                     generalJournalAccountEntryCorr.PostingType == LedgerPostingType::Bank)  ||
                    (generalJournalAccountEntry.PostingType     == LedgerPostingType::Bank   &&
                     generalJournalAccountEntryCorr.PostingType == LedgerPostingType::RCash) ||
                    (generalJournalAccountEntry.PostingType     == LedgerPostingType::RCash  &&
                     generalJournalAccountEntryCorr.PostingType == LedgerPostingType::Bank))
                {
                    generalJournalAccountEntry.TransactionCurrencyAmount    = - generalJournalAccountEntry.TransactionCurrencyAmount;
                    generalJournalAccountEntry.AccountingCurrencyAmount     = - generalJournalAccountEntry.AccountingCurrencyAmount;
                    generalJournalAccountEntry.ReportingCurrencyAmount      = - generalJournalAccountEntry.ReportingCurrencyAmount;
                    generalJournalAccountEntry.PostingType                  = LedgerPostingType::LedgerJournal;
                    generalJournalAccountEntry.LedgerDimension              =
                        LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(transitDefaultAccount, generalJournalAccountEntry.LedgerDimension);

                    ledgerVoucherObject.addTrans(LedgerVoucherTransObject::newGeneralJournal(generalJournalAccountEntry,
                                                                                             ledgerEntry));
                    ledgerBondClient.bondLast2();
                }

                [generalJournalAccountEntryCorr, ledgerEntryJournalCorr, generalJournalEntryCorr, ledgerEntryCorr] =
                    GeneralLedgerExtension::findRelated(generalJournalAccountEntryCorr.RecId);

                generalJournalAccountEntryCorr.IsCorrection       = NoYes::No;

                ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject(currentVoucherCredit, currentTransDateCredit);
                ledgerVoucherObject.parmAccountingDate(currentTransDateCredit);
                ledgerBondClient    = ledgerVoucherObject.ledgerBondClient_RU();

                ledgerVoucherObject.addTrans(LedgerVoucherTransObject::newGeneralJournal(generalJournalAccountEntryCorr,
                                                                                         ledgerEntryCorr));

                if ((oldPostingType                     == LedgerPostingType::Bank   &&
                     generalJournalAccountEntryCorr.PostingType == LedgerPostingType::Bank)  ||
                    (oldPostingType                     == LedgerPostingType::Bank   &&
                     generalJournalAccountEntryCorr.PostingType == LedgerPostingType::RCash) ||
                    (oldPostingType                     == LedgerPostingType::RCash  &&
                     generalJournalAccountEntryCorr.PostingType == LedgerPostingType::Bank))
                {
                    [generalJournalAccountEntryCorr, ledgerEntryJournalCorr, generalJournalEntryCorr, ledgerEntryCorr] =
                        GeneralLedgerExtension::findRelated(generalJournalAccountEntryCorr.RecId);

                    generalJournalAccountEntryCorr.TransactionCurrencyAmount    = - generalJournalAccountEntryCorr.TransactionCurrencyAmount;
                    generalJournalAccountEntryCorr.AccountingCurrencyAmount     = - generalJournalAccountEntryCorr.AccountingCurrencyAmount;
                    generalJournalAccountEntryCorr.ReportingCurrencyAmount      = - generalJournalAccountEntryCorr.ReportingCurrencyAmount;
                    generalJournalAccountEntryCorr.PostingType                  = LedgerPostingType::LedgerJournal;
                    generalJournalAccountEntryCorr.LedgerDimension              =
                            LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(transitDefaultAccount, generalJournalAccountEntryCorr.LedgerDimension);

                    ledgerVoucherObject.addTrans(LedgerVoucherTransObject::newGeneralJournal(generalJournalAccountEntryCorr,
                                                                                             ledgerEntryCorr));

                    ledgerBondClient.bondLast2();
                }
                else
                {
                    ledgerBondClient.bondLast2();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerTransStorno</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates storno Ledger transactions
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// <c>LedgerVoucher</c> types object
    /// </param>
    private void createLedgerTransStorno(LedgerVoucher _ledgerVoucher)
    {
        LedgerVoucherObject    ledgerVoucherObject;

        ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject(conPeek(voucherCon, 1), this.bankAccountTransDate());

        LedgerUtils_RU::createLedgerTransStorno_RU(ledgerVoucherObject,
                                                   bankAccountTrans.TransDate,
                                                   bankAccountTrans.Voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRCashTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new and storno Cash transactions
    /// </summary>
    private void createRCashTrans()
    {
        RCashTrans    rCashTransLocal, rCashTransLocalNew;
        ;

        if (! bankAccountTrans.isCash2Bank_RU())
        {
            return;
        }

        select firstonly forupdate rCashTransLocal
            where rCashTransLocal.Voucher   == bankAccountTrans.Voucher        &&
                  rCashTransLocal.TransDate == bankAccountTrans.TransDate      &&
                  rCashTransLocal.AmountCur <  0                               &&
                  (rCashTransLocal.DocType  == RCashDocType::ReimbursementSlip ||
                   rCashTransLocal.DocType  == RCashDocType::DisbursementSlip);

        rCashTransLocal.RefRecId = rCashTransLocal.RecId;
        rCashTransLocal.update();

        if (! conLen(docIdCon))
        {
            this.allocateRCashDocId(rCashTransLocal);
        }

        // create storno transaction
        rCashTransLocalNew.data(rCashTransLocal);

        rCashTransLocalNew.DocId     =   conPeek(docIdCon, #ConPos1);
        rCashTransLocalNew.DocType   =   RCashDocType::Correction;

        rCashTransLocalNew.Voucher   =   conPeek(voucherCon, #ConPos1);
        rCashTransLocalNew.TransDate =   this.bankAccountTransDate();

        rCashTransLocalNew.AmountCur = - rCashTransLocalNew.AmountCur;
        rCashTransLocalNew.AmountMST = - rCashTransLocalNew.AmountMST;

        rCashTransLocalNew.RefRecId  =   rCashTransLocal.RecId;

        rCashTransLocalNew.insert();

        // create new transaction
        rCashTransLocalNew.data(rCashTransLocal);

        rCashTransLocalNew.DocId               = conPeek(docIdCon, #ConPos2);
        rCashTransLocalNew.DocType             = RCashDocType::Correction;

        rCashTransLocalNew.Voucher             = conPeek(voucherCon, #ConPos3);
        rCashTransLocalNew.TransDate           = this.bankAccountTransDate();
    /*
        rCashTransLocalNew.OffsetLedgerDimensionNum = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(transitDefaultAccount,
                                                                                                                       rCashTransLocalNew.OffsetLedgerDimension);
    */
        rCashTransLocalNew.OffsetLedgerDimensionNum = transitDefaultAccount;

        rCashTransLocalNew.OffsetAccountType        = LedgerJournalACType::Ledger;
        rCashTransLocalNew.OffsetLedgerDimension    = rCashTransLocalNew.OffsetLedgerDimensionNum;

        rCashTransLocalNew.RefRecId                 = rCashTransLocal.RecId;

        rCashTransLocalNew.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    public Object dialog()
    {
        DialogRunbase dialog = new DialogRunbase(BankAccountTransDateChange_RU::description(), this);
        RCashTrans    rCashTransLocal;
        ;

        isLedger2Bank = ! (bankAccountTrans.isBank2Bank_RU() || bankAccountTrans.isCash2Bank_RU());

        dialogFieldTransDate = dialog.addFieldValue(extendedTypeStr(TransDate), bankAccountTrans.TransDate, "@GLS100986");

        if (! isLedger2Bank)
        {
            dialogFieldBankTransType = dialog.addField(extendedTypeStr(BankTransactionType));
        }

        if (bankAccountTrans.isCash2Bank_RU())
        {
            select firstonly rCashTransLocal
                where rCashTransLocal.Voucher   == bankAccountTrans.Voucher        &&
                      rCashTransLocal.TransDate == bankAccountTrans.TransDate      &&
                      rCashTransLocal.AmountCur <  0                               &&
                      (rCashTransLocal.DocType  == RCashDocType::ReimbursementSlip ||
                       rCashTransLocal.DocType  == RCashDocType::DisbursementSlip);

            this.allocateRCashDocId(rCashTransLocal, true);

            if (isManualSequence)
            {
                dialogFieldDocIdStorno = dialog.addField(extendedTypeStr(RCashDocId), "@GLS108402");
                dialogFieldDocIdNew    = dialog.addField(extendedTypeStr(RCashDocId), "@GLS108403");
            }
        }

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets values, that have been chosen in dialog and assigns they to class's variables
    /// </summary>
    /// <returns>
    /// Returns true if all checks are OK, otherwise false
    /// </returns>
    public boolean getFromDialog()
    {
        boolean    ret = true;
        ;

        transDate      = dialogFieldTransDate.value();

        if (! isLedger2Bank)
        {
            bankTransType  = dialogFieldBankTransType.value();
        }

        if (! transDate)
        {
            ret = checkFailed("@SYS16668");
        }
        if (transDate <= bankAccountTrans.TransDate)
        {
            ret = checkFailed("@SYS19456");
        }

        if (! isLedger2Bank)
        {
            if (! bankTransType)
            {
                ret = checkFailed("@GLS107816");
            }

            transitDefaultAccount = BankTransType::find(bankTransType).LedgerDimension;

            if (! transitDefaultAccount)
            {
                ret = checkFailed("@GLS108404");
            }
        }

        if (isManualSequence)
        {
            if (! dialogFieldDocIdStorno.value() || ! dialogFieldDocIdNew.value() ||
                dialogFieldDocIdStorno.value() == dialogFieldDocIdNew.value())
            {
                ret = checkFailed("@GLS108405");
            }

            docIdCon += dialogFieldDocIdStorno.value();
            docIdCon += dialogFieldDocIdNew.value();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankAccountTrans</Name>
				<Source><![CDATA[
    public BankAccountTrans parmBankAccountTrans(BankAccountTrans _bankAccountTrans = bankAccountTrans)
    {
        ;
        bankAccountTrans = _bankAccountTrans;
        return bankAccountTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankTransType</Name>
				<Source><![CDATA[
    public BankTransactionType parmBankTransType(BankTransactionType _bankTransType = bankTransType)
    {
        ;
        bankTransType = _bankTransType;
        return bankTransType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocIdCon</Name>
				<Source><![CDATA[
    public container parmDocIdCon(container _docIdCon = docIdCon)
    {
        ;
        docIdCon = _docIdCon;
        return docIdCon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucherCon</Name>
				<Source><![CDATA[
    public container parmVoucherCon(container _voucherCon = voucherCon)
    {
        ;
        voucherCon = _voucherCon;
        return voucherCon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        LedgerVoucher    ledgerVoucher;
        container        messageCon;
        ;

        messageCon = this.check();
        if (conLen(messageCon))
        {
            messageCon = conPoke(messageCon, conLen(messageCon) + 1, "");
            messageCon = conPoke(messageCon, conLen(messageCon) + 1, "@GLS102396");
            if (Box::yesNo(con2Str(messageCon, '\n'), DialogButton::No,"@GLS107793") == DialogButton::No)
            {
                return;
            }
        }

        ttsbegin;

        [bankAccountTransDebit, bankAccountTransCredit] = this.bankAccountTransDebitCredit();

        ledgerVoucher = this.allocateVouchers();

        this.createLedgerTransStorno(ledgerVoucher);

        this.createLedgerTransNew(ledgerVoucher);

        this.createBankAccountTrans();

        this.createRCashTrans();

        ledgerVoucher.end();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@GLS107793";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        BankAccountTransDateChange_RU    bankAccountTransDateChange;
        Object                           callerForm;
        ;

        callerForm = _args.caller();

        if (callerForm && callerForm.name() == formStr(BankReconciliation_RU))
        {
            bankAccountTransDateChange = new BankAccountTransDateChange_RU();

            bankAccountTransDateChange.parmBankAccountTrans(_args.record());
        }
        else
        {
            throw error("@SYS53138");
        }

        if (bankAccountTransDateChange.prompt())
        {
            bankAccountTransDateChange.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>