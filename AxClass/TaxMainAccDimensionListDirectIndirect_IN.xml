<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxMainAccDimensionListDirectIndirect_IN</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// This class handles SLJL based posting for India taxes[Both Direct Taxes/IndirectTaxes].
/// All localization based voucher entries thru SLJL should be modified here to avoid coding in SYS classes.
/// Included Taxes - [IndirectTax - Customs, Excise, VAT, SalesTax, ServiceTax],
/// [Exim - AA, DFIA, DEPB, EPCG], [LoadOnInventory for all taxes]
/// ApplyExcise functionality for Customs is also handled here.
/// -------------------------------------------------------ApplyExcise-------------------------------------------------------------------------------
/// Customs Taxcode has Customs TaxComponent attached to it. Against Customs component multiple Excise taxcodes can be attached to facilitate
/// the ApplyExcise functionality. If so, then the TaxAmount generated by the original Customs Taxcode should be distributed against the Excise recoverable
/// accounts determined by each excise taxcomponent(attached to individual Excise taxcodes in the ApplyExcise group). The complexity adds to when there is
/// Claim % defined on the respective Excise Components. If so, then that much percentage of the 'alloted Tax' for individual excise taxcodes where the
/// claim % is applicable should hit the Excise deffered A/C. And only the remaining portion alloted for the respective Excise Taxcode should hit Recoverable
/// A/C. If Claim % is 0 or 100, then full amount alloted to the Excise TaxCode should hit Recoverable and not deffered A/C.
/// </summary>

class TaxMainAccDimensionListDirectIndirect_IN
{
    TaxTable                        taxTableLoc;
    RecordInsertList                taxEntryList;
    TaxAccountType_IN               taxAccountTypeLoc;
    ServiceTaxBasis_IN              serviceTaxBasis;
    TaxMap                          taxMap;
    TaxLedgerAccounts_IN            taxLedgerAccounts;
    TaxLedgerAccountSetup_IN        taxLedgerAccountSetup;
    AccountingDistributionTmp       accountingDistributionTmp;
    RefRecId                        taxRegistrationNumber;
    AmountCur                       loiAmount2HitCur;
    CustInvoiceLine                 custInvoiceLineLoc;
    PurchLine                       purchLineLoc;
    AccountingRule                  accountingRule;
    TaxDirection                    taxDirection;
    TaxUncommitted_IN               taxUncommittedIN;
    TaxUncommitted                  taxUncommitted;
    TaxTrans                        taxTrans;
    boolean                         isAccountMissing;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getDefaultAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method visited per Taxcode to pick distribution side accounts. For eg. customs during Confirmation/distribution the
    /// PO side Customs duty expense A/C is picked here. The payable A/C and Exim recievables are done in this.process().
    /// </summary>
    /// <param name="_taxTable">
    /// The Taxcode table buffer.
    /// </param>
    /// <returns>
    /// Container with A/cs populated.
    /// </returns>
    public container getDefaultAccount(TaxTable         _taxTable = null)
    {
        LedgerDimensionDefaultAccount   taxAccount;
        container                       postingAccountsCon;
        boolean                         isApplyExciseMarked;
        AccountingRuleType              accountingRuleType = accountingRule.parmAccountingRuleType();

        // TaxNonRecoverable for India (ie, LOI) accounts are not picked here. Its already done by standard logic.
        // Only indirect tax A/Cs are addressed here.
        if ((accountingRule.parmMonetaryAmount()    == MonetaryAmount::TaxNonRecoverableVariance
             || accountingRule.parmMonetaryAmount() == MonetaryAmount::TaxNonRecoverable)
             && accountingRuleType!= AccountingRuleType::Journalizing)
        {
            return conNull();
        }
        taxTableLoc = _taxTable;
        // Indirect TAXes
        if (_taxTable.TaxType_IN != TaxType_IN::None)
        {
            switch (_taxTable.TaxType_IN)
            {
                case TaxType_IN::Customs    :
                                              // For Customs its respective account (Customs and Exim Accounts) are being set in this method.
                                              taxAccount = this.postingAccountsForCustoms(accountingRuleType == AccountingRuleType::Journalizing);
                break;
                case TaxType_IN::Excise     : this.postingAccountsForExcise();    break;
                case TaxType_IN::VAT        : this.postingAccountsForVAT();       break;
                case TaxType_IN::SalesTax   : this.postingAccountsForSalesTax();  break;
                case TaxType_IN::ServiceTax : this.postingAccountsForServiceTax(accountingRuleType == AccountingRuleType::Journalizing); break;
            }
            // Get A/C corresponding to TmpTaxWorkTrans.LedgerDimension ie, Default A/C.
            // Don't get the above A/Cs for Apply excise and Exim features.
            if (!isApplyExciseMarked && !taxAccount)
            {
                // get A/C when AccountCode = Table in posting profile. Depends on Registration number.
                taxAccount = TaxLedgerAccounts_IN::findByTaxAccounts(TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTableLoc.TaxLedgerAccountGroup_IN,
                                                                                                                     TaxAccountCode_IN::Table,
                                                                                                                     taxRegistrationNumber).RecId,
                                                                     taxAccountTypeLoc,
                                                                     taxTableLoc.TaxComponentTable_IN).LedgerDimension;
                // get A/C when AccountCode = ALL in posting profile. This is indepenedent of Registration number.
                if (!taxAccount)
                {
                    select firstonly LedgerDimension from taxLedgerAccounts
                        join RecId from taxLedgerAccountSetup
                        where taxLedgerAccountSetup.TaxLedgerAccountGroup  == taxTableLoc.TaxLedgerAccountGroup_IN
                            && taxLedgerAccountSetup.AccountCode           == TaxAccountCode_IN::All
                            && taxLedgerAccounts.TaxLedgerAccountSetup     == taxLedgerAccountSetup.RecId
                            && taxLedgerAccounts.AccountType               == taxAccountTypeLoc
                            && taxLedgerAccounts.TaxComponentTable         == taxTableLoc.TaxComponentTable_IN;
                    taxAccount = taxLedgerAccounts.LedgerDimension;
                }
            }
        }

        if (taxAccount)
        {
            postingAccountsCon += taxAccount;
        }
        else
        {
            isAccountMissing = true && !isApplyExciseMarked;
        }
        this.validate();
        // Depending on the elements(A/Cs) in the container, the total amount will be distributed across them, controlled by
        // the factor value set by ledgerDimensionAllocation.parmAllocationfactor(..); in \Classes\DimensionDerivationRule\buildDimCombFromMainAccountProvider
        return postingAccountsCon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEximAccounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method finds out the Exim related A/cs required for posting exim payable amounts considered during posting.
    /// Only expense entries are shown in distribution.
    /// </summary>
    /// <returns>
    /// Container with available exim Ledger Accounts.(Not LedgerDimensions).
    /// </returns>
    public LedgerDimensionDefaultAccount getEximAccounts()
    {
        EximIncentiveScheme_IN incentiveScheme;
        LedgerDimensionAccount depbReceivableAccount;
        LedgerDimensionAccount eximRecievableAccount;
        LedgerDimensionDefaultAccount taxAccountLoc;
        container              eximAccountsCon;

        // Cater to Mappings on TaxMap
        if (taxMap.TableId == tableNum(TaxUncommitted))// Case: PO
        {
            incentiveScheme = taxUncommittedIN.EximIncentiveScheme;
        }
        else if (taxMap.TableId == tableNum(TaxTrans))
        {
            incentiveScheme = EximTaxTrans_IN::findRefRecId(taxMap.RecId).IncentiveScheme;
        }
            if (incentiveScheme != EximIncentiveScheme_IN::None)
            {
                if (incentiveScheme == EximIncentiveScheme_IN::EPCG)// EPCG is expense so should come from distribution side.
                {
                taxAccountTypeLoc = TaxAccountType_IN::CustomsImportDutyPayableAccount;
                    if (taxUncommittedIN.EximDEPBAmount)
                    {
                        if (TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTableLoc.TaxLedgerAccountGroup_IN,
                                                                            TaxAccountCode_IN::Table,
                                                                            taxRegistrationNumber))

                        {
                            depbReceivableAccount = TaxLedgerAccounts_IN::findByTaxAccounts(TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTableLoc.TaxLedgerAccountGroup_IN,
                                                                                            TaxAccountCode_IN::Table,
                                                                                            taxRegistrationNumber).RecId,
                                                                                            TaxAccountType_IN::EximDEPBReceivableAccount,
                                                                                            taxTableLoc.TaxComponentTable_IN).LedgerDimension;
                        }
                        else
                        {
                            select firstonly LedgerDimension from taxLedgerAccounts
                                    join RecId, TaxLedgerAccountGroup from taxLedgerAccountSetup
                                    where taxLedgerAccountSetup.TaxLedgerAccountGroup == taxTableLoc.TaxLedgerAccountGroup_IN
                                        && taxLedgerAccountSetup.AccountCode           == TaxAccountCode_IN::All
                                        && taxLedgerAccounts.TaxLedgerAccountSetup     == taxLedgerAccountSetup.RecId
                                        && taxLedgerAccounts.AccountType               == TaxAccountType_IN::EximDEPBReceivableAccount
                                        && taxLedgerAccounts.TaxComponentTable         == taxTableLoc.TaxComponentTable_IN;

                            depbReceivableAccount = taxLedgerAccounts.LedgerDimension;
                        }
                    if (depbReceivableAccount)
                    {
                        taxAccountTypeLoc = TaxAccountType_IN::EximDEPBReceivableAccount;
                    }
                    }
                }
                else if (incentiveScheme == EximIncentiveScheme_IN::AA)
                {
                taxAccountTypeLoc = TaxAccountType_IN::EximAAReceivableAccount;
                }
                else if (incentiveScheme == EximIncentiveScheme_IN::DFIA)
                {
                taxAccountTypeLoc = TaxAccountType_IN::EximDFIAReceivableAccount;
                }
                else if (incentiveScheme == EximIncentiveScheme_IN::DEPB)
                {
                taxAccountTypeLoc = TaxAccountType_IN::EximDEPBReceivableAccount;
                }

                eximRecievableAccount = TaxLedgerAccounts_IN::findByTaxAccounts(TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTableLoc.TaxLedgerAccountGroup_IN,
                                                                                                                                TaxAccountCode_IN::Table,
                                                                                                                                taxRegistrationNumber).RecId,
                                                                        taxAccountTypeLoc,
                                                                                taxTableLoc.TaxComponentTable_IN).LedgerDimension;
                if (!eximRecievableAccount)
                {
                    eximRecievableAccount = TaxLedgerAccounts_IN::findByTaxAccounts(TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTableLoc.TaxLedgerAccountGroup_IN,
                                                                                                                                    TaxAccountCode_IN::All).RecId,
                                                                            taxAccountTypeLoc,
                                                                                    taxTableLoc.TaxComponentTable_IN).LedgerDimension;
                }
            }

        if (eximRecievableAccount && !conFind(eximAccountsCon, eximRecievableAccount))
        {
            eximAccountsCon +=eximRecievableAccount;
        }
        if (depbReceivableAccount && !conFind(eximAccountsCon, depbReceivableAccount))
        {
            eximAccountsCon += depbReceivableAccount;
        }
        if (!eximRecievableAccount || (taxUncommittedIN.EximDEPBAmount && !depbReceivableAccount))
        {
            isAccountMissing = true;
        }

        if (incentiveScheme != EximIncentiveScheme_IN::None
            && incentiveScheme != EximIncentiveScheme_IN::EPCG
            && conPeek(eximAccountsCon, 2))
        {
            return conPeek(eximAccountsCon, 2);
        }
        else if (incentiveScheme != EximIncentiveScheme_IN::None
                && conPeek(eximAccountsCon, 1))
        {
            return conPeek(eximAccountsCon, 1);
        }

        return taxAccountLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchLineINFromTaxUncommitted</Name>
				<Source><![CDATA[
    private PurchLine_IN getPurchLineINFromTaxUncommitted(TaxUncommitted _taxUncommitted)
    {
        return PurchLine_IN::findByPurchLine(PurchLine::findRecId(_taxUncommitted.SourceRecId).RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendInvoiceLineTaxExtensionFromTax</Name>
				<Source><![CDATA[
    private VendInvoiceInfoLineTaxExtension_IN getVendInvoiceLineTaxExtensionFromTax(TaxUncommitted _taxUncommitted)
    {
        return VendInvoiceInfoLineTaxExtension_IN::findByVendInvoiceInfoLineRecId(VendInvoiceInfoLine::findRecId(_taxUncommitted.SourceRecId).RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the taxMap buffer.
    /// </summary>
    /// <returns>
    /// The taxMap buffer.
    /// </returns>

    private TaxMap initTaxMap()
    {
        TaxSourceDocSublineItem            taxSourceDocSublineItem;

        if (accountingRule)
        {
            if (accountingRule.parmSourceDocumentLineItem() is TaxSourceDocSublineItem)
            {
                taxSourceDocSublineItem = accountingRule.parmSourceDocumentLineItem() as TaxSourceDocSublineItem;
                taxMap = taxSourceDocSublineItem.parmTaxMap_IN();
            }
        }

        return taxMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isHitExpenseAccount</Name>
				<Source><![CDATA[
    private boolean isHitExpenseAccount(TaxUncommitted _taxUncommitted)
    {
        TransTaxInformation transTaxInformation;

        if (_taxUncommitted.SourceTableId == tableNum(PurchLine) || _taxUncommitted.SourceTableId == tableNum(VendInvoiceInfoLine))
        {
            transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformation(_taxUncommitted.SourceTableId, _taxUncommitted.SourceRecId);
            return transTaxInformation.ServiceTaxGTAServiceCategory == GTAServiceCategory_IN::Others;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingDistributionTmp</Name>
				<Source><![CDATA[
    public AccountingDistributionTmp parmAccountingDistributionTmp(AccountingDistributionTmp _accountingDistributionTmp = accountingDistributionTmp)
    {
        accountingDistributionTmp = _accountingDistributionTmp;

        return accountingDistributionTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingRule</Name>
				<Source><![CDATA[
    public AccountingRule parmAccountingRule(AccountingRule _accountingRule = accountingRule)
    {
        accountingRule = _accountingRule;

        return accountingRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustInvoiceLine</Name>
				<Source><![CDATA[
    public CustInvoiceLine parmCustInvoiceLine(CustInvoiceLine _custInvoiceLine = custInvoiceLineLoc)
    {
        custInvoiceLineLoc = _custInvoiceLine;

        return custInvoiceLineLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLoadOnInventoryCur</Name>
				<Source><![CDATA[
    public AmountCur parmLoadOnInventoryCur(AmountCur _loiAmount2HitCur = loiAmount2HitCur)
    {
        loiAmount2HitCur = _loiAmount2HitCur;

        return loiAmount2HitCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchLine</Name>
				<Source><![CDATA[
    public PurchLine parmPurchLine(PurchLine _purchLine = purchLineLoc)
    {
        purchLineLoc = _purchLine;

        return purchLineLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmServiceTaxBasis</Name>
				<Source><![CDATA[
    public ServiceTaxBasis_IN parmServiceTaxBasis(ServiceTaxBasis_IN _serviceTaxBasis = serviceTaxBasis)
    {
        serviceTaxBasis = _serviceTaxBasis;

        return serviceTaxBasis;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxDirection</Name>
				<Source><![CDATA[
    public TaxDirection parmTaxDirection(TaxDirection _taxDirection = taxDirection)
    {
        taxDirection = _taxDirection;

        return taxDirection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxEntryList</Name>
				<Source><![CDATA[
    public RecordInsertList parmTaxEntryList(RecordInsertList _taxEntryList = taxEntryList)
    {
        taxEntryList = _taxEntryList;

        return taxEntryList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxRegistrationNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets/Gets the tax registrationNumber.
    /// </summary>
    /// <param name="_taxRegistrationNumber">
    /// Tax registration number table record id.
    /// </param>
    /// <returns>
    /// Tax registration number table record id.
    /// </returns>
    public RefRecId parmTaxRegistrationNumber(RefRecId _taxRegistrationNumber = taxRegistrationNumber)
    {
        taxRegistrationNumber = _taxRegistrationNumber;
        return taxRegistrationNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxTable</Name>
				<Source><![CDATA[
    public TaxTable parmTaxTable(TaxTable _taxTable = taxTableLoc)
    {
        taxTableLoc = _taxTable;

        return taxTableLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxTrans</Name>
				<Source><![CDATA[
    public TaxTrans parmTaxTrans(TaxTrans _taxTrans = taxTrans)
    {
        taxTrans = _taxTrans;

        return taxTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxUncommitted</Name>
				<Source><![CDATA[
    public TaxUncommitted parmTaxUncommitted(TaxUncommitted _taxUncommitted = taxUncommitted)
    {
        taxUncommitted = _taxUncommitted;

        return taxUncommitted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxUncommittedIN</Name>
				<Source><![CDATA[
    public TaxUncommitted_IN parmTaxUncommittedIN(TaxUncommitted_IN _taxUncommittedIN = taxUncommittedIN)
    {
        taxUncommittedIN = _taxUncommittedIN;

        return taxUncommittedIN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingAccountsForCustoms</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets default account for posting customs tax.
    /// </summary>
    /// <param name="_isCreditTaxEntry">
    /// determines if the Accounting Rule is Journalise or Distribution.
    /// </param>
    /// <returns>
    /// Default Account
    /// </returns>
    /// <remarks>
    /// Gets default account for posting customs tax.
    /// </remarks>
    public LedgerDimensionDefaultAccount postingAccountsForCustoms(boolean _isCreditTaxEntry)
    {
        TaxUncommitted                  taxUncommittedBufferLoc;
        LedgerDimensionDefaultAccount   taxAccount;
        TaxModuleType                   source = any2Enum((taxTrans.RecId != 0) ? taxTrans.source : taxUncommitted.Source);

        if (source == TaxModuleType::Purch)
        {
            // For Customs SLJL uptake Exim IncentiveScheme account is fetched in case the Exim Amount is available and the Monetory amount is Incentiveschemetax_IN.
            if (accountingRule.parmMonetaryAmount() == MonetaryAmount::Incentiveschemetax_IN
                && (taxUncommittedIN.EximTaxAmount
                || taxUncommittedIN.EximBalanceTaxCorrectedAmount))
            {
                taxAccount = this.getEximAccounts();
            }
            else
            {
                if (taxUncommittedIN)
                {
                    if (taxMap.TableId == tableNum(TaxUncommitted))
                    {
                        taxUncommittedBufferLoc = taxMap;
                    }
                    else
                    {
                        taxUncommittedBufferLoc.LedgerDimension_IN = TaxTrans_IN::findRefRecId(taxMap.RecId).IndirectTaxLedgerDimension;
                        taxUncommittedBufferLoc.TaxDirection       = TaxDirection::OutgoingTax;
                    }
                    taxAccountTypeLoc = TaxAccountType_IN::CustomsImportDutyPayableAccount;
                    taxAccount = taxUncommittedBufferLoc.LedgerDimension_IN;
                }
            }
        }
        else if (source != TaxModuleType::Purch)
        {
            if (taxDirection == TaxDirection::OutgoingTax)
            {
                if (_isCreditTaxEntry)
                {
                    taxAccountTypeLoc = TaxAccountType_IN::CustomsExportDutyExpenseAccount;
                }
                else
                {
                    taxAccountTypeLoc = TaxAccountType_IN::CustomsExportDutyPayableAccount;
                }
            }
        }

        return taxAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingAccountsForExcise</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets default account for posting excise tax
    /// </summary>
    public void postingAccountsForExcise()
    {
        SalesPurchJournalLine               salesPurchJournalLine;
        TaxAccountType_IN                   taxAccountTypeExcise;
        VendInvoiceInfoLine                 vendInvoiceInfoLine;
        PurchLine                           purchLineExcise;
        ExciseRecordType_IN                 exciseRecordType;
        ExciseType_IN                       exciseType;
        DirectSettlement_IN                 directSettlement;
        boolean                             isCreditNote;
        boolean                             isCENVATCreditAvailed;
        TransTaxInformation                 transTaxInformation;

        transTaxInformation     = TransTaxInformationHelper::findOrCreateTransTaxInformation(taxMap.SourceTableId, taxMap.SourceRecId);
        exciseRecordType        = transTaxInformation.ExciseRecordType;
        exciseType              = transTaxInformation.ExciseType;
        isCENVATCreditAvailed   = transTaxInformation.ExciseCENVATCreditAvailed;
        directSettlement        = transTaxInformation.ExciseDirectSettlement;

        switch (taxMap.SourceTableId)
        {
            case tableNum(PurchLine):
                purchLineExcise         = PurchLine::findRecId(taxMap.SourceRecId);

                if (directSettlement == DirectSettlement_IN::None
                    && purchLineExcise.LineAmount < 0
                    && purchLineExcise.InventRefId
                    && TaxTrans_IN::isTaxSettledForTransaction(tableNum(VendInvoiceTrans), VendInvoiceTrans::findInventTransId(purchLineExcise.InventRefTransId).RecId))
                {
                    isCreditNote = true;
                }

                break;

            case tableNum(VendInvoiceInfoLine):
                vendInvoiceInfoLine = VendInvoiceInfoLine::findRecId(taxMap.SourceRecId);

                if (!vendInvoiceInfoLine.isNonPO()
                    && directSettlement == DirectSettlement_IN::None)
                {
                    purchLineExcise = PurchLine::findRecId(VendInvoiceInfoLine::findRecId(taxMap.SourceRecId).PurchLineRecId);

                    if (purchLineExcise.LineAmount < 0
                        && purchLineExcise.InventRefId
                        && TaxTrans_IN::isTaxSettledForTransaction(tableNum(VendInvoiceTrans), VendInvoiceTrans::findInventTransId(purchLineExcise.InventRefTransId).RecId))
                    {
                        isCreditNote = true;
                    }
                }

                break;

            default:
                break;
        }

        switch (exciseRecordType)
        {
            // Account type for Register RG23D
            case ExciseRecordType_IN::RG23D:

                switch (taxDirection)
                {
                    case TaxDirection::IncomingTax :
                        // If PLA is not marked and register is RG23D, then it should pick ExciseRG23DRecoverableAccount
                        taxAccountTypeExcise = TaxAccountType_IN::ExciseRG23DRecoverableAccount;
                        break;

                    case TaxDirection::OutgoingTax :
                        // If PLA is not marked and register is RG23D, then it should pick ExciseRG23DPayableAccount
                        taxAccountTypeExcise = TaxAccountType_IN::ExciseRG23DPayableAccount;
                        break;

                    default:
                        break;
                }
                break;

            // Account type for Register RG23A and RG23C
            case ExciseRecordType_IN::RG23A,
                 ExciseRecordType_IN::RG23C:

                if (accountingRule.parmMonetaryAmount() == MonetaryAmount::Tax)
                {
                    switch (directSettlement)
                    {
                        case DirectSettlement_IN::PLA:
                            taxAccountTypeExcise = TaxAccountType_IN::ExcisePLAAccount;
                            break;

                        case DirectSettlement_IN::RG23A,
                             DirectSettlement_IN::RG23C:
                            taxAccountTypeExcise = TaxAccountType_IN::ExciseRecoverableAccount;
                            break;

                        case DirectSettlement_IN::None:

                            switch (taxDirection)
                            {
                                case TaxDirection::IncomingTax:
                                    if (isCreditNote)
                                    {
                                        taxAccountTypeExcise = TaxAccountType_IN::ExcisePayableAccount;
                                    }
                                    else
                                    {
                                        taxAccountTypeExcise = TaxAccountType_IN::ExciseRecoverableAccount;
                                    }
                                    break;

                                case TaxDirection::OutgoingTax:
                                    taxAccountTypeExcise = TaxAccountType_IN::ExcisePayableAccount;
                                    break;
                            }
                            break;

                        default:
                            break;
                    }
                }
                else if (accountingRule.parmMonetaryAmount() == MonetaryAmount::TaxDeferred_IN || accountingRule.parmMonetaryAmount() == MonetaryAmount::TaxDeferredVariance_IN)
                {
                    switch (ExciseRecordType)
                    {
                        case ExciseRecordType_IN::RG23A:
                            taxAccountTypeExcise = TaxAccountType_IN::ExciseDeferredRG23AAccount;
                            break;

                        case ExciseRecordType_IN::RG23C:
                            if (!isCENVATCreditAvailed)
                            {
                                taxAccountTypeExcise = TaxAccountType_IN::ExciseDeferredRG23CAccount;
                            }
                            break;

                        default:
                            break;
                    }
                }
                break;

            // Account type for Register None
            case ExciseRecordType_IN::None:

                switch (directSettlement)
                {
                    case DirectSettlement_IN::PLA:
                        taxAccountTypeExcise = TaxAccountType_IN::ExcisePLAAccount;
                        break;

                    case DirectSettlement_IN::RG23A :
                    case DirectSettlement_IN::RG23C :
                        taxAccountTypeExcise = TaxAccountType_IN::ExciseRecoverableAccount;
                        break;

                    case DirectSettlement_IN::None:
                        switch (taxDirection)
                        {
                            case TaxDirection::IncomingTax:
                                if (isCreditNote)
                                {
                                    taxAccountTypeExcise = TaxAccountType_IN::ExcisePayableAccount;
                                }
                                else
                                {
                                    taxAccountTypeExcise = TaxAccountType_IN::ExciseRecoverableAccount;
                                }
                                break;

                            case TaxDirection::OutgoingTax:
                                taxAccountTypeExcise = TaxAccountType_IN::ExcisePayableAccount;
                                break;

                            default:
                                break;
                        }
                        break;
                }

            default:
                break;
        }

        taxAccountTypeLoc = taxAccountTypeExcise;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingAccountsForSalesTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets default account for posting sales tax.
    /// </summary>
    public void postingAccountsForSalesTax()
    {
        if (taxDirection == TaxDirection::OutgoingTax)
        {
            taxAccountTypeLoc = TaxAccountType_IN::SalesTaxPayableAccount;
        }
        else if (taxDirection == TaxDirection::IncomingTax)
        {
            taxAccountTypeLoc = TaxAccountType_IN::SalesTaxExpenseAccount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingAccountsForServiceTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts accounts for the service tax.
    /// </summary>
    /// <param name="_isCreditTaxEntry">
    /// True if the account has credit tax entry.
    /// </param>
    public void postingAccountsForServiceTax(boolean _isCreditTaxEntry)
    {
        RefRecId      taxLedgerAccountsetupRecId;
        TaxModuleType source = any2Enum((taxTrans.RecId != 0) ? taxTrans.source : taxUncommitted.Source);
        TaxItemGroup  taxItemGroup = (taxTrans.RecId != 0) ? taxTrans.TaxItemGroup : taxUncommitted.TaxItemGroup;
        boolean       isAccruePayableAtInvoicing = TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(taxItemGroup);

        taxLedgerAccountsetupRecId = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTableLoc.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxRegistrationNumber).RecId;
        if (!taxLedgerAccountsetupRecId)
        {
            taxLedgerAccountsetupRecId = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTableLoc.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
        }
        // if POT 2 cases are there
                // a. Advance amount is available -> AC = interim
                // b. Advance amount is ZERO -> AC = Actual
        // if cash basis
                // get interim AC
        if (serviceTaxBasis != ServiceTaxBasis_IN::None)
        {
            if (accountingRule != null)
            {
                if (source == TaxModuleType::Purch)
                {
                    // If MonetaryAmount::ServiceTaxInterimAmount_IN is coming that means the entire tax amount shud hit the interim.
                    if (accountingRule.parmMonetaryAmount() == MonetaryAmount::ServiceTaxInterimAmount_IN
                        || accountingRule.parmMonetaryAmount() == MonetaryAmount::ServiceTaxInterimAmountVariance_IN)
                    {
                        taxAccountTypeLoc = TaxAccountType_IN::ServiceTaxInterimRecoverableAccount;
                    }
                    else if (accountingRule.parmMonetaryAmount() == MonetaryAmount::Tax
                             || accountingRule.parmMonetaryAmount() == MonetaryAmount::TaxVariance)
                    {
                        taxAccountTypeLoc = TaxAccountType_IN::ServiceTaxRecoverableAccount;
                    }
                    else if (accountingRule.parmMonetaryAmount() == MonetaryAmount::ServiceTaxExpense_IN
                        || accountingRule.parmMonetaryAmount() == MonetaryAmount::ServiceTaxExpenseVariance_IN
                        || accountingRule.parmMonetaryAmount() == MonetaryAmount::ServiceTaxInterimExpense_IN
                        || accountingRule.parmMonetaryAmount() == MonetaryAmount::ServiceTaxInterimExpenseVariance_IN)
                    {
                        taxAccountTypeLoc = TaxAccountType_IN::ServiceTaxExpenseAccount;
                    }
                    if (
                        _isCreditTaxEntry
                        &&
                        (
                            accountingRule.parmMonetaryAmount() == MonetaryAmount::ServiceTaxInterimAmount_IN
                                        ||
                            accountingRule.parmMonetaryAmount() == MonetaryAmount::ServiceTaxNonRecoverable_IN
                                        ||
                            accountingRule.parmMonetaryAmount() == MonetaryAmount::ServiceTaxInterimExpense_IN
                                        ||
                            accountingRule.parmMonetaryAmount() == MonetaryAmount::TaxNonRecoverable
                                        ||
                            accountingRule.parmMonetaryAmount() == MonetaryAmount::ServiceTaxInterimAmountVariance_IN
                                        ||
                            accountingRule.parmMonetaryAmount() == MonetaryAmount::ServiceTaxNonRecoverableVariance_IN
                                        ||
                            accountingRule.parmMonetaryAmount() == MonetaryAmount::ServiceTaxInterimExpenseVariance_IN
                                        ||
                            accountingRule.parmMonetaryAmount() == MonetaryAmount::TaxNonRecoverableVariance)

                      )
                    {
                        taxAccountTypeLoc = isAccruePayableAtInvoicing ? TaxAccountType_IN::ServiceTaxPayableAccount : TaxAccountType_IN::ServiceTaxInterimPayableAccount;
                    }
                    // GTA, Credit, then Payable.
                }
                else if (source == TaxModuleType::FreeTxtInvoice)
                {
                    if (accountingRule.parmMonetaryAmount() == MonetaryAmount::ServiceTaxInterimAmount_IN
                       || accountingRule.parmMonetaryAmount() == MonetaryAmount::ServiceTaxInterimAmountVariance_IN)
                    {
                        taxAccountTypeLoc = TaxAccountType_IN::ServiceTaxInterimPayableAccount;
                    }
                    else if (accountingRule.parmMonetaryAmount() == MonetaryAmount::Tax
                            || accountingRule.parmMonetaryAmount() == MonetaryAmount::TaxVariance)
                    {
                        taxAccountTypeLoc = TaxAccountType_IN::ServiceTaxPayableAccount;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingAccountsForVAT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets default account for posting VAT tax.
    /// </summary>
    public void postingAccountsForVAT()
    {
        PurchLine                           purchLineVat;
        VendInvoiceInfoLine                 vendInvoiceInfoLine;
        TransTaxInformation                 transTaxInformation;

        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformation(taxMap.SourceTableId, taxMap.SourceRecId);

        taxAccountTypeLoc = TaxAccountType_IN::VATPayableAccount;

        switch (taxMap.SourceTableId)
        {
            case tableNum(PurchLine):
                purchLineVat = PurchLine::findRecId(taxMap.SourceRecId);

                if (purchLineVat.LineAmount > 0)
                {
                    taxAccountTypeLoc = transTaxInformation.VATGoodsType == VATGoodsType_IN::Input
                                        ? TaxAccountType_IN::VATRecoverableAccount
                                        : TaxAccountType_IN::VATDeferredAccount;
                }
                else if (purchLineVat.LineAmount < 0
                        && (!purchLineVat.InventRefId
                            || (purchLineVat.InventRefId
                                && !TaxTrans_IN::isTaxSettledForTransaction(tableNum(VendInvoiceTrans), VendInvoiceTrans::findInventTransId(purchLineVat.InventRefTransId).RecId))))
                {
                    taxAccountTypeLoc = transTaxInformation.VATGoodsType == VATGoodsType_IN::Input
                                            ? TaxAccountType_IN::VATRecoverableAccount
                                            : TaxAccountType_IN::VATDeferredAccount;
                }
                break;

            case tableNum(VendInvoiceInfoLine):
                vendInvoiceInfoLine = VendInvoiceInfoLine::findRecId(taxMap.SourceRecId);

                if (vendInvoiceInfoLine.LineAmount > 0 )
                {
                    taxAccountTypeLoc = transTaxInformation.VATGoodsType == VATGoodsType_IN::Input
                                        ? TaxAccountType_IN::VATRecoverableAccount
                                        : TaxAccountType_IN::VATDeferredAccount;
                }
                else if (! vendInvoiceInfoLine.isNonPO())
                {
                    purchLineVat = PurchLine::findRecId(VendInvoiceInfoLine::findRecId(taxMap.SourceRecId).PurchLineRecId);

                    if (purchLineVat.LineAmount < 0
                            && (!purchLineVat.InventRefId
                                 || ( purchLineVat.InventRefId
                                    && !TaxTrans_IN::isTaxSettledForTransaction(tableNum(VendInvoiceTrans), VendInvoiceTrans::findInventTransId(purchLineVat.InventRefTransId).RecId))))
                    {
                        taxAccountTypeLoc = transTaxInformation.VATGoodsType == VATGoodsType_IN::Input
                                                ? TaxAccountType_IN::VATRecoverableAccount
                                                : TaxAccountType_IN::VATDeferredAccount;
                    }
                }
                break;

            case tableNum(PurchReqLine):
                taxAccountTypeLoc = transTaxInformation.VATGoodsType == VATGoodsType_IN::Input
                                    ? TaxAccountType_IN::VATRecoverableAccount
                                    : TaxAccountType_IN::VATDeferredAccount;
                break;

            default:
                break;
        }

        if (accountingRule.parmMonetaryAmount() == MonetaryAmount::TaxDeferred_IN
            || accountingRule.parmMonetaryAmount() == MonetaryAmount::TaxDeferredVariance_IN)
        {
            taxAccountTypeLoc = TaxAccountType_IN::VATDeferredAccount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates for missing accounts.
    /// </summary>
    public void validate()
    {
        if (isAccountMissing)
        {
            throw error(strFmt("@GLS5582", TaxRegistrationNumbers_IN::find(taxRegistrationNumber).RegistrationNumber) + "@SYS21533");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs new instance of the <c>TaxMainAccDimensionListDirectIndirect_IN</c> class.
    /// </summary>
    /// <param name="_distributionAccountingRule">
    /// The distribution accounting rule.
    /// </param>
    /// <param name="_accountingDistributionTmp">
    /// The temporary accouting distribution.
    /// </param>
    /// <param name="_recordInsertList">
    /// The record insert list.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxMainAccDimensionListDirectIndirect_IN</c> class.
    /// </returns>
    public static TaxMainAccDimensionListDirectIndirect_IN construct(
        AccountingRule             _distributionAccountingRule,
        AccountingDistributionTmp  _accountingDistributionTmp = null,
        RecordInsertList           _recordInsertList = null)
    {
        TaxMap                                   taxMap;
        TaxUncommitted_IN                        taxUncommittedIN;
        TaxUncommitted                           taxUncommitted;
        TaxTable                                 taxTableLoc;
        TaxTrans                                 taxTrans;
        TaxMainAccDimensionListDirectIndirect_IN taxMainAccDimensionListDirectIndirect = new TaxMainAccDimensionListDirectIndirect_IN();

        if (taxMainAccDimensionListDirectIndirect != null)
        {
            taxMainAccDimensionListDirectIndirect.parmAccountingRule(_distributionAccountingRule);
            taxMainAccDimensionListDirectIndirect.parmAccountingDistributionTmp(_accountingDistributionTmp);
            taxMainAccDimensionListDirectIndirect.parmTaxEntryList(_recordInsertList);
            taxMap = taxMainAccDimensionListDirectIndirect.initTaxMap();
            taxMainAccDimensionListDirectIndirect.parmTaxDirection(taxMap.TaxDirection);

            if (taxMap.TaxDirection == TaxDirection::OutgoingTax
                && taxMap.TableId == tableNum(TaxTrans))
            {
                taxTrans = taxMap;
                taxMainAccDimensionListDirectIndirect.parmTaxTrans(taxTrans);
                taxTableLoc = TaxTable::find(taxTrans.TaxCode);
                taxMainAccDimensionListDirectIndirect.parmTaxTable(taxTableLoc);
                taxMainAccDimensionListDirectIndirect.parmTaxRegistrationNumber(taxTrans.taxTrans_W().TaxRegistrationNumberTable_IN);
                taxMainAccDimensionListDirectIndirect.parmServiceTaxBasis(TaxItemGroupHeading::find(taxTrans.TaxItemGroup).ServiceTaxBasis_IN);
            }
            else if (taxMap.TableId == tableNum(TaxUncommitted))
            {
                taxUncommitted   = TaxUncommitted::find(taxMap.RecId);
                taxUncommittedIN = TaxUncommitted_IN::findByTaxUncommitted(taxUncommitted.RecId);
                taxTableLoc      = TaxTable::find(taxUncommitted.TaxCode);
                taxMainAccDimensionListDirectIndirect.parmTaxTable(taxTableLoc);
                taxMainAccDimensionListDirectIndirect.parmLoadOnInventoryCur(taxUncommittedIN.LoadOnInventoryTax);
                taxMainAccDimensionListDirectIndirect.parmTaxUncommittedIN(taxUncommittedIN);
                taxMainAccDimensionListDirectIndirect.parmTaxUncommitted(taxUncommitted);
                taxMainAccDimensionListDirectIndirect.parmTaxRegistrationNumber(taxUncommittedIN.TaxRegistrationNumberTable_IN);
                taxMainAccDimensionListDirectIndirect.parmServiceTaxBasis(TaxItemGroupHeading::find(taxUncommitted.TaxItemGroup).ServiceTaxBasis_IN);
            }
        }

        return taxMainAccDimensionListDirectIndirect;
    }

]]></Source>
			</Method>
			<Method>
				<Name>negateTaxEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the exim and balance tax entries from the original tax entry.
    /// </summary>
    /// <param name="_accountingDistributionTmp">
    /// The AccountingDistributionTmp buffer passed.
    /// </param>
    /// <param name="_eximFactor">
    /// Factor that determines the balance and exim taxes.
    /// </param>
    /// <returns>
    /// Modified AccountingDistributionTmp buffer for voucher creation.
    /// </returns>
    public static AccountingDistributionTmp negateTaxEntries(
        AccountingDistributionTmp _accountingDistributionTmp,
        AllocationFactor          _eximFactor = 1)
    {
        if (_accountingDistributionTmp.TransactionCurrencyAmount)
        {
            _accountingDistributionTmp.TransactionCurrencyAmount                  = CurrencyExchangeHelper::amount(-_accountingDistributionTmp.TransactionCurrencyAmount * _eximFactor);
            _accountingDistributionTmp.AccountingCurrencyAmount                   = CurrencyExchangeHelper::amount(-_accountingDistributionTmp.AccountingCurrencyAmount * _eximFactor);
            _accountingDistributionTmp.ReportingCurrencyAmount                    = CurrencyExchangeHelper::amount(-_accountingDistributionTmp.ReportingCurrencyAmount * _eximFactor);
            _accountingDistributionTmp.NegativeAccountingCurrencyAmount           = CurrencyExchangeHelper::amount(-_accountingDistributionTmp.NegativeAccountingCurrencyAmount * _eximFactor);
            _accountingDistributionTmp.NegativeReportingCurrencyAmount            = CurrencyExchangeHelper::amount(-_accountingDistributionTmp.NegativeReportingCurrencyAmount * _eximFactor);
            _accountingDistributionTmp.NegativeTransactionCurrencyAmount          = CurrencyExchangeHelper::amount(-_accountingDistributionTmp.NegativeTransactionCurrencyAmount * _eximFactor);
            _accountingDistributionTmp.SourceDocLineAccountingCurrencyAmount      = CurrencyExchangeHelper::amount(-_accountingDistributionTmp.SourceDocLineAccountingCurrencyAmount * _eximFactor);
            _accountingDistributionTmp.SourceDocLineReportingCurrencyAmount       = CurrencyExchangeHelper::amount(-_accountingDistributionTmp.SourceDocLineReportingCurrencyAmount * _eximFactor);
            _accountingDistributionTmp.SourceDocLineNegReportingCurrencyAmount    = CurrencyExchangeHelper::amount(-_accountingDistributionTmp.SourceDocLineNegReportingCurrencyAmount * _eximFactor);
            _accountingDistributionTmp.SourceDocLineNegAccountingCurrencyAmount   = CurrencyExchangeHelper::amount(-_accountingDistributionTmp.SourceDocLineNegAccountingCurrencyAmount * _eximFactor);
            _accountingDistributionTmp.AmountSign                                 = (_accountingDistributionTmp.AmountSign         == DebitCredit::Credit)? DebitCredit::Debit  : DebitCredit::Credit;
            _accountingDistributionTmp.NegativeAmountSign                         = (_accountingDistributionTmp.NegativeAmountSign == DebitCredit::Debit) ? DebitCredit::Credit : DebitCredit::Debit;
        }

        return _accountingDistributionTmp;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>