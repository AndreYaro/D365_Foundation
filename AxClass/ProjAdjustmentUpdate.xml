<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjAdjustmentUpdate</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class ProjAdjustmentUpdate
{
    #OCCRetryCount

    TmpProjAdjustmentCreate     tmpProjAdjustmentCreate;
    TmpProjAdjustmentCreateCost tmpProjAdjustmentCreateCost;
    TmpProjAdjustmentCreateSale tmpProjAdjustmentCreateSale;
    TmpProjAdjustment           tmpProjAdjustment;
    TmpProjAdjustmentCost       tmpProjAdjustmentCost;
    TmpProjAdjustmentSale       tmpProjAdjustmentSale;

    protected boolean inventoryFinancialPosted = true;

    NoYes                   post;
    Qty                     totalQty;

    NumberSeq               numberSeq;

    Num                     parmJournalEmplId, parmJournalRevenueId, parmJournalItemId;
    LedgerVoucher           ledgerVoucher;
    TransactionTxt          transTxt;

    Voucher                 voucher;

    ProjPost                projPost;
    ProjTransIdBase         transId;

    ProjJournalTable        journalTable;
    ProjJournalTrans        journalTrans;
    ProjJournalTableData    journalTableData;
    ProjJournalTransData    journalTransData;

    LineNum                 lineNum;
    boolean                 checkFailed;
    Integer                 logPoint;

    InventQty               remainQty, inventRemainQty;
    boolean                 first;
    CostAmount              inventUsedCost;

    Map inventTransMapOrig, inventTransMapNegative, inventTransMapNew;

    boolean                 useInfolog;

    //Which receipt(could be purchase order) the item transaction linked to.
    InventTransId           inventRefTransIdOrig;

    // <GIN>
    boolean                 isCountryRegion_IN;
    boolean					postToLedger = true;
    private ProjNoneNoYes   onlyDefaultDimensionAdjusted;
    #ISOcountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmOnlyDefaultDimAdjusted</Name>
				<Source><![CDATA[
    public ProjNoneNoYes parmOnlyDefaultDimAdjusted(ProjNoneNoYes _onlyDefaultDimensionAdjusted = onlyDefaultDimensionAdjusted)
    {
        onlyDefaultDimensionAdjusted = _onlyDefaultDimensionAdjusted;
        return onlyDefaultDimensionAdjusted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTransItemCostStocked</Name>
				<Source><![CDATA[
	private ProjPost postTransItemCostStocked(TmpProjAdjustmentCreate _tmpProjAdjustmentCreate,
                                    List                    _fundingSourceList,
                                    boolean					_isAdjustmentCorrection,
                                    boolean                 _countryRegion_EU)
    {
        ProjPost projPostItem;
        
        if (onlyDefaultDimensionAdjusted == ProjNoneNoYes::Yes)
        {
            ProjItemTrans projItemTransOrig = ProjItemTrans::find(_tmpProjAdjustmentCreate.TransID);
            ProjItemTransCost projItemTransCost = ProjItemTransCost::find(projItemTransOrig.InventTransId, projItemTransOrig.ProjAdjustRefId, 1);
            if (this.checkUnequalLedgerStatusCost(_tmpProjAdjustmentCreate.ProjId, projItemTransCost.LedgerStatusCost, ProjAdjustmentType::Item))
            {
                    projPostItem = ProjPost::newCreateProjTransItemCostAdjustWithSameLedger(_tmpProjAdjustmentCreate,
                        _fundingSourceList, ledgerVoucher, projItemTransCost.LedgerStatusCost, 1);

                    projPostItem.parmLedgerStatusCostOrig(true);
            }
            else
            {
                projPostItem = ProjPost::newCreateProjTransItemCostAdjust(_tmpProjAdjustmentCreate, _fundingSourceList, ledgerVoucher,true);
            }
        }
        else
        {
            projPostItem = ProjPost::newCreateProjTransItemCostAdjust(_tmpProjAdjustmentCreate, _fundingSourceList, ledgerVoucher,true);
        }
        projPostItem.parmAdjustment(true);
        // <GEEU>
        if (_countryRegion_EU)
        {
            projPostItem.parmAdjustCorrection(_isAdjustmentCorrection);
        }
        // </GEEU>
        projPostItem.parmAdjustmentDate(tmpProjAdjustment.TransDateAdjustment);
        projPostItem.postTrans();

        ProjPost::postItemReverseTransaction(projPostItem);

        return projPostItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerVoucher</Name>
				<Source><![CDATA[
	/// <summary>
    ///  Getter method to access <c>LedgerVoucher</c> object.
    /// </summary>
    /// <returns>
    /// <c>LedgerVoucher</c> object associated with the update.
	/// </returns>
    public LedgerVoucher getLedgerVoucher()
    {
        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVoucher</Name>
				<Source><![CDATA[
	/// <summary>
    /// Voucher number associated with the <c>LedgerVoucher</c> object.
    /// </summary>
    /// <returns>
    /// Voucher number.
	/// </returns>
    public Voucher getVoucher()
    {
        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingDate</Name>
				<Source><![CDATA[
    public AccountingDate parmAccountingDate()
    {
        AccountingDate accountingDate;

        if (projparameters::find().IsAccountingDateUpdateAllowed ||
            ProjParameters::find().AllowDateCorrection)
        {
            RecId fiscalCalendarRecId = CompanyInfoHelper::fiscalCalendarRecId();

            if (!LedgerFiscalCalendar::checkLedgerPeriodDateModule(fiscalCalendarRecId, tmpProjAdjustment.TransDateAdjustment, SysModule::Ledger, false))
            {
                accountingDate = LedgerFiscalCalendar::findFirstOpenStartDateModule(fiscalCalendarRecId, tmpProjAdjustment.TransDateAdjustment, SysModule::Ledger);
            }
            else
            {
                accountingDate = tmpProjAdjustment.TransDateAdjustment;
            }
        }
        else
        {
            accountingDate = tmpProjAdjustment.TransDateAdjustment;
        }

        return accountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustStatus</Name>
				<Source><![CDATA[
    ProjTransStatus adjustStatus()
    {
        TmpProjAdjustmentCost   tmpProjAdjustmentCostLocal;
        TmpProjAdjustmentSale   tmpProjAdjustmentSaleLocal;
        TmpProjAdjustmentCreate tmpProjAdjustmentCreateLocal;

        tmpProjAdjustmentCostLocal.linkPhysicalTableInstance(tmpProjAdjustmentCost);
        tmpProjAdjustmentSaleLocal.linkPhysicalTableInstance(tmpProjAdjustmentSale);
        tmpProjAdjustmentCreateLocal.linkPhysicalTableInstance(tmpProjAdjustmentCreate);

        while select tmpProjAdjustmentSaleLocal where tmpProjAdjustmentSaleLocal.TransId ==tmpProjAdjustment.TransId
        {
            if (this.verifyProjAdjustmentSaleTransStatus(tmpProjAdjustmentSaleLocal))
            {
                return ProjTransStatus::Posted;
            }
        }

        return ProjTransStatus::Adjusted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>verifyProjAdjustmentSaleTransStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies the project transaction status of <c>TmpProjAdjustmentSale</c> table record.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentSaleLocal">
    ///     An instance of <c>TmpProjAdjustmentSale</c> table buffer.
    /// </param>
    /// <returns>
    ///     true, if <c>TmpProjAdjustmentSale</c> transaction status and project transaction status is matched; otherwise, false.
    /// </returns>
    protected boolean verifyProjAdjustmentSaleTransStatus(TmpProjAdjustmentSale _tmpProjAdjustmentSaleLocal)
    {
        return (_tmpProjAdjustmentSaleLocal.TransStatus == ProjTransStatus::Eliminated
            ||  _tmpProjAdjustmentSaleLocal.TransStatus == ProjTransStatus::Estimated
            ||  _tmpProjAdjustmentSaleLocal.TransStatus == ProjTransStatus::Invoiced
            ||  _tmpProjAdjustmentSaleLocal.TransStatus == ProjTransStatus::InvoiceProposal
            ||  _tmpProjAdjustmentSaleLocal.TransStatus == ProjTransStatus::CreditnoteProposal
            ||  _tmpProjAdjustmentSaleLocal.TransStatus == ProjTransStatus::MarkedCreditNote);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDefaultDimensionChanged</Name>
				<Source><![CDATA[
	/// <summary>
    /// Detects a change in default dimension in the adjusted transaction.
    /// </summary>
    /// <param name = "_origDimension"> Original transaction's default dimension.</param>
    /// <param name = "_newDimension"> Adjusted transaction's default dimension.</param>
    /// <returns>true if dimensions are different; otherwise, false.</returns>
	protected internal boolean checkDefaultDimensionChanged(DimensionDefault _origDimension,
												DimensionDefault _newDimension)
    {
        return _origDimension != _newDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransChangedNoDefaultDim</Name>
				<Source><![CDATA[
	/// <summary>
    /// The method checks for any changes in the adjusted transaction
    /// excluding default dimension changes.
    /// </summary>
    /// <returns>
    /// true if there is any change; otherwise, false.
	/// </returns>
	private boolean checkTransChangedNoDefaultDim()
    {
        TmpProjAdjustmentCreate     tmpProjAdjustmentCreateLocal;
        TmpProjAdjustmentCreateCost tmpProjAdjustmentCreateCostLocal;
        TmpProjAdjustmentCreateSale tmpProjAdjustmentCreateSaleLocal;
        TmpProjAdjustmentCost       tmpProjAdjustmentCostLocal;
        TmpProjAdjustmentSale       tmpProjAdjustmentSaleLocal;
        ProjTrans                   projTransCost;
        ProjTrans                   projTransSale;

        // <GIN>
        TransTaxInformation         transTaxInformationAdjustment;
        TransTaxInformation         transTaxInformationAdjustmentCreate;
        // </GIN>

        tmpProjAdjustmentCreateLocal.linkPhysicalTableInstance(tmpProjAdjustmentCreate);
        tmpProjAdjustmentCreateCostLocal.linkPhysicalTableInstance(tmpProjAdjustmentCreateCost);
        tmpProjAdjustmentCreateSaleLocal.linkPhysicalTableInstance(tmpProjAdjustmentCreateSale);
        tmpProjAdjustmentCostLocal.linkPhysicalTableInstance(tmpProjAdjustmentCost);
        tmpProjAdjustmentSaleLocal.linkPhysicalTableInstance(tmpProjAdjustmentSale);

        // <GTE>
        if (TaxIntegrationUtils::isTaxInformationEnabled())
        {
            transTaxInformationAdjustment = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(tmpProjAdjustment);
        }
        // </GTE>
        boolean ret;
        while select tmpProjAdjustmentCreateLocal
        where tmpProjAdjustmentCreateLocal.TransID == tmpProjAdjustment.TransId
			&& tmpProjAdjustmentCreateLocal.AdjustOrig != NoYes::Yes
        {
            // <GTE>
            if (TaxIntegrationUtils::isTaxInformationEnabled())
            {
                transTaxInformationAdjustmentCreate = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(tmpProjAdjustmentCreateLocal);
            }
            // </GTE>

            if ((tmpProjAdjustment.ProjId!= tmpProjAdjustmentCreateLocal.ProjId) ||
            // <GIN>
            (isCountryRegion_IN
                && (this.checkProjAdjustmentCountrySpecificFields_IN(tmpProjAdjustment, tmpProjAdjustmentCreateLocal)
                    || this.checkTransTaxInformationFieldsChanged(transTaxInformationAdjustment, transTaxInformationAdjustmentCreate))
            ))
            // </GIN>
			{
                ret = true;
                break;
            }

            if (tmpProjAdjustment.CategoryId != tmpProjAdjustmentCreateLocal.CategoryId ||
                tmpProjAdjustment.ResourceCategory != tmpProjAdjustmentCreateLocal.ResourceCategory ||
                tmpProjAdjustment.Qty != tmpProjAdjustmentCreateLocal.Qty ||
                tmpProjAdjustment.LinePropertyId != tmpProjAdjustmentCreateLocal.LinePropertyId)
            {
                ret = true;
                break;
            }

            // A change in Indirect component group will have an increase or decrease in total cost and sales price.
            if (tmpProjAdjustment.AdjustmentType == ProjAdjustmentType::Hour
                && tmpProjAdjustment.PSAIndirectComponentGroup != tmpProjAdjustmentCreateLocal.PSAIndirectComponentGroup)
            {
                ret = true;
                break;
            }

            select firstonly tmpProjAdjustmentCreateCostLocal
            where tmpProjAdjustmentCreateCostLocal.RefRecId == tmpProjAdjustmentCreateLocal.RecId;

            select firstonly tmpProjAdjustmentCostLocal
            where tmpProjAdjustmentCostLocal.TransId == tmpProjAdjustment.TransId;

            if ((tmpProjAdjustmentCreateCostLocal && !tmpProjAdjustmentCostLocal) ||
            (!tmpProjAdjustmentCreateCostLocal && tmpProjAdjustmentCostLocal))
            {
                ret = true;
                break;
            }

            if (tmpProjAdjustment.TransDate != tmpProjAdjustmentCreateLocal.Transdate)
            {
                ret = true;
                break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransTaxInformationFieldsChanged</Name>
				<Source><![CDATA[
    private boolean checkTransTaxInformationFieldsChanged(TransTaxInformation _adjustment, TransTaxInformation _adjustmentCreate)
    {
        return (
            (_adjustment.CompanyLocation             != _adjustmentCreate.CompanyLocation)
            || (_adjustment.TaxInformation           != _adjustmentCreate.TaxInformation)
            || (_adjustment.ServiceCode              != _adjustmentCreate.ServiceCode)
            || (_adjustment.VATCommodityCode         != _adjustmentCreate.VATCommodityCode)
            || (_adjustment.SalesTaxFormTypes        != _adjustmentCreate.SalesTaxFormTypes)
            || (_adjustment.ExciseType               != _adjustmentCreate.ExciseType)
            || (_adjustment.ExciseRecordType         != _adjustmentCreate.ExciseRecordType)
            || (_adjustment.ExciseTariffCodes        != _adjustmentCreate.ExciseTariffCodes)
            || (_adjustment.ExciseDirectSettlement   != _adjustmentCreate.ExciseDirectSettlement)
            || (_adjustment.CustomsTariffCode        != _adjustmentCreate.CustomsTariffCode)
            || (_adjustment.ExciseDSA                != _adjustmentCreate.ExciseDSA)
            || (_adjustment.InclTax                  != _adjustmentCreate.InclTax)
            );
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjAdjustmentCountrySpecificFields_IN</Name>
				<Source><![CDATA[
    private boolean checkProjAdjustmentCountrySpecificFields_IN(TmpProjAdjustment _adjustment, TmpProjAdjustmentCreate _adjustmentCreate)
    {
        return (
            (_adjustment.AssessableValue_IN         != _adjustmentCreate.AssessableValue_IN)
            || (_adjustment.MaximumRetailPrice_IN   != _adjustmentCreate.MaximumRetailPrice_IN)
            || (_adjustment.tcsGroup_IN             != _adjustmentCreate.tcsGroup_IN)
            || (_adjustment.tdsGroup_IN             != _adjustmentCreate.tdsGroup_IN)
            );
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCreateNewTrans</Name>
				<Source><![CDATA[
    boolean checkCreateNewTrans(
    ProjTrans         _projTrans)
    {
        TmpProjAdjustmentCreate     tmpProjAdjustmentCreateLocal;
        TmpProjAdjustmentCreateCost tmpProjAdjustmentCreateCostLocal;
        TmpProjAdjustmentCreateSale tmpProjAdjustmentCreateSaleLocal;
        TmpProjAdjustmentCost       tmpProjAdjustmentCostLocal;
        TmpProjAdjustmentSale       tmpProjAdjustmentSaleLocal;
        ProjTrans                   projTransCost;
        ProjTrans                   projTransSale;

        // <GIN>
        TransTaxInformation         transTaxInformationAdjustment;
        TransTaxInformation         transTaxInformationAdjustmentCreate;
        // </GIN>

        tmpProjAdjustmentCreateLocal.linkPhysicalTableInstance(tmpProjAdjustmentCreate);
        tmpProjAdjustmentCreateCostLocal.linkPhysicalTableInstance(tmpProjAdjustmentCreateCost);
        tmpProjAdjustmentCreateSaleLocal.linkPhysicalTableInstance(tmpProjAdjustmentCreateSale);
        tmpProjAdjustmentCostLocal.linkPhysicalTableInstance(tmpProjAdjustmentCost);
        tmpProjAdjustmentSaleLocal.linkPhysicalTableInstance(tmpProjAdjustmentSale);

		if (this.checkTransChangedNoDefaultDim())
        {
            onlyDefaultDimensionAdjusted = ProjNoneNoYes::No;
			return true;
        }

        boolean ret;
        while select tmpProjAdjustmentCreateLocal
        where tmpProjAdjustmentCreateLocal.TransID == tmpProjAdjustment.TransId 
            && tmpProjAdjustmentCreateLocal.AdjustOrig != NoYes::Yes
        {
            // Create reversing entry when funding sources change.
            if (tmpProjAdjustmentCreateLocal.FundingSource == NoYes::Yes && this.checkTransChanged())
            {
                ret = true;
                break;
            }

            select firstonly RecId from tmpProjAdjustmentCreateCostLocal
            where tmpProjAdjustmentCreateCostLocal.RefRecId == tmpProjAdjustmentCreateLocal.RecId 
                && !tmpProjAdjustmentCreateCostLocal.CostRefRecId;
            if (tmpProjAdjustmentCreateCostLocal.RecId)
            {
                onlyDefaultDimensionAdjusted = ProjNoneNoYes::No;
                ret = true;
                break;
            }
            else
            {
                while select tmpProjAdjustmentCreateCostLocal
                where tmpProjAdjustmentCreateCostLocal.RefRecId == tmpProjAdjustmentCreateLocal.RecId
                    join tmpProjAdjustmentCostLocal
                        where tmpProjAdjustmentCostLocal.TransId == tmpProjAdjustment.TransId 
                            && tmpProjAdjustmentCostLocal.CostRefRecId == tmpProjAdjustmentCreateCostLocal.CostRefRecId
                {
                    projTransCost = this.projTransCost(_projTrans.buffer(), tmpProjAdjustmentCreateCostLocal.CostRefRecId);
                    if (this.checkCreateNewTransCost(projTransCost, tmpProjAdjustmentCostLocal, tmpProjAdjustmentCreateLocal, tmpProjAdjustmentCreateCostLocal))
                    {
                        ret = true;
                    }
                }
                if (ret && onlyDefaultDimensionAdjusted == ProjNoneNoYes::No)
                {
                    break;
                }
            }

            select firstonly RecId from tmpProjAdjustmentCreateSaleLocal
            where tmpProjAdjustmentCreateSaleLocal.RefRecId == tmpProjAdjustmentCreateLocal.RecId;

            select firstonly RecId from tmpProjAdjustmentSaleLocal
            where tmpProjAdjustmentSaleLocal.TransId == tmpProjAdjustment.TransId;

            if ((tmpProjAdjustmentCreateSaleLocal.RecId && !tmpProjAdjustmentSaleLocal.RecId) ||
            (!tmpProjAdjustmentCreateSaleLocal.RecId && tmpProjAdjustmentSaleLocal.RecId))
            {
                onlyDefaultDimensionAdjusted = ProjNoneNoYes::No;
                ret = true;
                break;
            }
            
            select firstonly RecId from tmpProjAdjustmentCreateSaleLocal
            where tmpProjAdjustmentCreateSaleLocal.RefRecId == tmpProjAdjustmentCreateLocal.RecId
                && !tmpProjAdjustmentCreateSaleLocal.SaleRefRecId;
            if (tmpProjAdjustmentCreateSaleLocal.RecId)
            {
                onlyDefaultDimensionAdjusted = ProjNoneNoYes::No;
                ret = true;
                break;
            }
            else
            {
                while select tmpProjAdjustmentCreateSaleLocal
                where tmpProjAdjustmentCreateSaleLocal.RefRecId == tmpProjAdjustmentCreateLocal.RecId
                    join tmpProjAdjustmentSaleLocal
                        where tmpProjAdjustmentSaleLocal.TransId == tmpProjAdjustment.TransId
                            && tmpProjAdjustmentSaleLocal.SaleRefRecId == tmpProjAdjustmentCreateSaleLocal.SaleRefRecId
                {
                    projTransSale = this.projTransSale(_projTrans.buffer(), tmpProjAdjustmentCreateSaleLocal.SaleRefRecId);
                    if (this.checkCreateNewTransSale(projTransSale, tmpProjAdjustmentSaleLocal, tmpProjAdjustmentCreateLocal, tmpProjAdjustmentCreateSaleLocal))
                    {
                        ret = true;
                    }
                }
                if (ret && onlyDefaultDimensionAdjusted == ProjNoneNoYes::No)
                {
                    break;
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLinePropertyChangedForCost</Name>
				<Source><![CDATA[
	/// <summary>
    /// For a cost component of the transaction, this method
    /// determines if a change in line property should be recorded.
    /// </summary>
    /// <param name = "_projTrans"><c>ProjTrans</c> instance.</param>
    /// <param name = "_tmpProjAdjustmentCreate"><c>TmpProjAdjustmentCreate</c> table buffer.</param>
    /// <returns>true if line property changes are recorded; otherwise, false.</returns>
	private boolean checkLinePropertyChangedForCost(ProjTrans _projTrans,
										            TmpProjAdjustmentCreate _tmpProjAdjustmentCreate)
    {
        boolean ret;
        if (tmpProjAdjustment.LinePropertyId != _tmpProjAdjustmentCreate.LinePropertyId &&
        _projTrans.ledgerStatusCost() == ProjLedgerStatus::BalanceSheet &&
        !ProjLineProperty::find(_tmpProjAdjustmentCreate.LinePropertyId).ToBeAccrued)
        {
            ret = true;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCostPriceChangedForCost</Name>
				<Source><![CDATA[
    private boolean checkCostPriceChangedForCost(ProjTrans _projTrans,
												TmpProjAdjustmentCost       _tmpProjAdjustmentCost,
												TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost)
    {
        boolean ret;
        if ((_tmpProjAdjustmentCost.CostPrice != _tmpProjAdjustmentCreateCost.CostPrice) &&
             _projTrans.ledgerStatusCost())
        {
            ret=true;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLinePropertyChangedForSale</Name>
				<Source><![CDATA[
    private boolean checkLinePropertyChangedForSale(ProjTrans _projTrans,
													TmpProjAdjustmentCreate _tmpProjAdjustmentCreate)
    {
        boolean ret;
        if (tmpProjAdjustment.LinePropertyId != _tmpProjAdjustmentCreate.LinePropertyId &&
        _projTrans.ledgerSalesPosted() &&
        !ProjLineProperty::find(_tmpProjAdjustmentCreate.LinePropertyId).ToBeAccrued)
        {
            ret = true;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCreateNewTransCost</Name>
				<Source><![CDATA[
    boolean checkCreateNewTransCost(
    ProjTrans                   _projTrans,
    TmpProjAdjustmentCost       _tmpProjAdjustmentCost,
    TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
    TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost
)
    {
        boolean ret;
        if (this.checkLinePropertyChangedForCost(_projTrans, _tmpProjAdjustmentCreate) ||
			this.checkCostPriceChangedForCost(_projTrans, _tmpProjAdjustmentCost, _tmpProjAdjustmentCreateCost))
        {
            onlyDefaultDimensionAdjusted = ProjNoneNoYes::No;
            ret = true;
        }
		else if (this.checkDefaultDimensionChanged(tmpProjAdjustment.DefaultDimension, _tmpProjAdjustmentCreate.DefaultDimension) && 
				 _projTrans.ledgerStatusCost())
        {
            if (onlyDefaultDimensionAdjusted == ProjNoneNoYes::None)
            {
                onlyDefaultDimensionAdjusted = ProjNoneNoYes::Yes;
            }
            ret = true;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSalesPriceChanged</Name>
				<Source><![CDATA[
	private boolean checkSalesPriceChanged(TmpProjAdjustmentSale _tmpProjAdjustmnentSale,
										   TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale)
    {
        return _tmpProjAdjustmnentSale.SalesPrice != _tmpProjAdjustmentCreateSale.SalesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSalesCurrencyChanged</Name>
				<Source><![CDATA[
	private boolean checkSalesCurrencyChanged(TmpProjAdjustment _tmpProjAdjustment,
											  TmpProjAdjustmentCreate _tmpProjAdjustmentCreate)
    {
        return _tmpProjAdjustment.CurrencyId != _tmpProjAdjustmentCreate.CurrencyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFundingSourceIdChanged</Name>
				<Source><![CDATA[
    private boolean checkFundingSourceIdChanged(TmpProjAdjustmentSale _tmpProjAdjustmentSale,
                                                TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale)
    {
        return _tmpProjAdjustmentSale.FundingSource != _tmpProjAdjustmentCreateSale.FundingSource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCreateNewTransSale</Name>
				<Source><![CDATA[
    boolean checkCreateNewTransSale(
    ProjTrans                   _projTrans,
    TmpProjAdjustmentSale       _tmpProjAdjustmentSale,
    TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
    TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale
)
    {
        TmpProjAdjustment tmpProjAdjustmentLoc;
        tmpProjAdjustmentLoc.linkPhysicalTableInstance(tmpProjAdjustment);
        boolean ret;

        if (!tmpProjAdjustmentLoc.RecId)
        {
            select firstonly tmpProjAdjustmentLoc
                where tmpProjAdjustmentLoc.TransId == _tmpProjAdjustmentCreate.TransID;
        }

        if ((this.checkLinePropertyChangedForSale(_projTrans, _tmpProjAdjustmentCreate) ||
            this.checkSalesPriceChanged(_tmpProjAdjustmentSale, _tmpProjAdjustmentCreateSale) ||
            this.checkSalesCurrencyChanged(tmpProjAdjustmentLoc, _tmpProjAdjustmentCreate)) &&
            _projTrans.ledgerSalesPosted())
        {
            onlyDefaultDimensionAdjusted = ProjNoneNoYes::No;
            ret = true;
        }
        else if (this.checkDefaultDimensionChanged(tmpProjAdjustmentLoc.DefaultDimension, _tmpProjAdjustmentCreate.DefaultDimension) &&
                 _projTrans.ledgerSalesPosted())
        {
            if (onlyDefaultDimensionAdjusted == ProjNoneNoYes::None)
            {
                onlyDefaultDimensionAdjusted = ProjNoneNoYes::Yes;
            }
            ret = true;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDefaultJournal</Name>
				<Source><![CDATA[
    boolean checkDefaultJournal(ProjAdjustmentType   _adjustmentType)
    {
        boolean ret;

        switch (_adjustmentType)
        {
            case ProjAdjustmentType::Hour:
                if (ProjParameters::find().EmplJournalNameId)
                {
                    ret = true;
                }
                break;

            case ProjAdjustmentType::Revenue:
                if (ProjParameters::find().RevenueJournalNameId)
                {
                    ret = true;
                }
                break;

            case ProjAdjustmentType::Item:
                if (ProjParameters::find().InventJournalNameId)
                {
                    ret = true;
                }
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalExist</Name>
				<Source><![CDATA[
    boolean checkJournalExist(
    ProjAdjustmentType   _adjustmentType)
    {
        if (this.parmJournalEmplId()    && (_adjustmentType == ProjAdjustmentType::Hour))
        {
            return true;
        }

        if (this.parmJournalRevenueId() && (_adjustmentType == ProjAdjustmentType::Revenue))
        {
            return true;
        }

        if (this.parmJournalItemId() && (_adjustmentType == ProjAdjustmentType::Item))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for quantity for adjustment type.
    /// </summary>
    /// <param name = "_isTimecard">A boolean flag to validate the new and old quantity; optional.</param>
    /// <returns>true if adjustment type does not need to be validated or old and new quantity are equal; otherwise, false.</returns>
    boolean checkQty(boolean _isTimecard = false)
    {
        Qty         sumNew, sumOld;
        boolean     ok  = true;

        while select  tmpProjAdjustment
        {
            sumNew  = 0;

            if (this.mustValidateQuantity(tmpProjAdjustment))
            {
                while select tmpProjAdjustmentCreate
                where tmpProjAdjustmentCreate.TransID   == tmpProjAdjustment.TransId
                    && tmpProjAdjustmentCreate.AdjustOrig != NoYes::Yes
                {
                    sumNew  += tmpProjAdjustmentCreate.Qty;
                }

                sumOld  = tmpProjAdjustment.Qty;

                if (isConfigurationkeyEnabled(configurationKeyNum(Project)) && _isTimecard)
                {
                    if (sumNew != sumOld)
                    {
                        ok = checkFailed(strFmt("@SYS54754",tmpProjAdjustment.TransId));
                    }
                }
                else
            if (sumNew && (sumNew != sumOld))
                {
                    ok = checkFailed(strFmt("@SYS54754",tmpProjAdjustment.TransId));
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustValidateQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if quantity validation must be done for the <c>TmpProjAdjustment</c> buffer.
    /// </summary>
    /// <param name = "_tmpProjAdjustment">The <c>TmpProjAdjustment</c> buffer.</param>
    /// <returns>true if adjustment type requires quantity validation; otherwise, false.</returns>
    protected boolean mustValidateQuantity(TmpProjAdjustment _tmpProjAdjustment)
    {
        return !_tmpProjAdjustment.checkAdjustmentType(ProjAdjustmentType::Revenue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjectTransactionAccruesRevenue</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method checks if a transaction accrues revenue or not.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentCreate">
    /// <c>TmpProjAdjustmentCreate</c> table buffer.
    /// </param>
    /// <returns>
    /// true if the transaction accrues revenue based on the different settings set in the UI by the user; otherwise, false.
    /// </returns>
    protected boolean checkProjectTransactionAccruesRevenue(TmpProjAdjustmentCreate _tmpProjAdjustmentCreate)
    {
        boolean ret = false;
        if (_tmpProjAdjustmentCreate)
        {
            ProjTable projTableBuffer =  ProjTable::find(_tmpProjAdjustmentCreate.ProjId);

            if (!ProjLineProperty::find(_tmpProjAdjustmentCreate.LinePropertyId).ToBeAccrued)
            {
                return false;
            }

            switch (_tmpProjAdjustmentCreate.AdjustmentType)
            {
                case ProjAdjustmentType::Cost:
                    ret = ProjRevRecHelper::postWIPCostForProject(projTableBuffer, false);
                    break;

                case ProjAdjustmentType::Hour:
                    ret = ProjRevRecHelper::postWIPEmplForProject(projTableBuffer, false);
                    break;

                case ProjAdjustmentType::Item:
                    ret = ProjRevRecHelper::postWIPItemForProject(projTableBuffer, false);
                    break;

                case ProjAdjustmentType::Revenue:
                    ret = ProjRevRecHelper::postWIPFeeForProject(projTableBuffer, false);
                    break;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxInformationChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the trans tax information for adjustment was changed.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentCreate">
    /// <c>TmpProjAdjustmentCreate</c> table buffer.
    /// </param>
    /// <returns>
    /// True if the trans tax information was changed; otherwise, false.
    /// </returns>
    protected boolean checkTaxInformationChanged(TmpProjAdjustmentCreate _tmpProjAdjustmentCreate)
    {
        boolean ret = false;

        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            return ret;
        }
        
        TransTaxInformationRelationView taxInformationView;
        TransTaxInformation taxInformation;

        select firstonly taxInformationView
            join firstonly taxInformation
        where taxInformation.RecId == taxInformationView.TransTaxInformationRefRecId
            && taxinformationView.TransactionRefTableId == _tmpProjAdjustmentCreate.TableId
            && taxInformationview.TransactionRefRecId == _tmpProjAdjustmentCreate.RecId;

        TransTaxInformationRelationView taxInformationViewAdj;
        TransTaxInformation taxInformationAdj;

        select firstonly taxInformationViewAdj
            join firstonly taxInformationAdj
        where taxInformationAdj.RecId == taxInformationViewAdj.TransTaxInformationRefRecId
            && taxInformationViewAdj.TransactionRefTableId == tmpProjAdjustment.TableId
            && taxInformationViewAdj.TransactionRefRecId == tmpProjAdjustment.RecId;

        return this.checkTransTaxInformationFieldsChanged(taxInformation, taxInformationAdj);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransChanged</Name>
				<Source><![CDATA[
    boolean checkTransChanged()
    {
        TmpProjAdjustmentCreate     tmpProjAdjustmentCreateLocal;
        TmpProjAdjustmentCreateCost tmpProjAdjustmentCreateCostLocal;
        TmpProjAdjustmentCreateSale tmpProjAdjustmentCreateSaleLocal;

        tmpProjAdjustmentCreateLocal.linkPhysicalTableInstance(tmpProjAdjustmentCreate);
        tmpProjAdjustmentCreateCostLocal.linkPhysicalTableInstance(tmpProjAdjustmentCreateCost);
        tmpProjAdjustmentCreateSaleLocal.linkPhysicalTableInstance(tmpProjAdjustmentCreateSale);
        
		boolean ret;
        while select tmpProjAdjustmentCreateLocal
        where tmpProjAdjustmentCreateLocal.TransID == tmpProjAdjustment.TransId 
            && tmpProjAdjustmentCreateLocal.AdjustOrig != NoYes::Yes
        {
            if (this.checkProjAdjustmentCreateDiffererenceFromExistingProjAdjustment(tmpProjAdjustmentCreateLocal))
            {
                ret = true;
            }

            select firstonly RecId, FundingSource from tmpProjAdjustmentCreateCostLocal
            where tmpProjAdjustmentCreateCostLocal.RefRecId == tmpProjAdjustmentCreateLocal.RecId;

            select firstonly RecId, FundingSource from tmpProjAdjustmentCost
            where tmpProjAdjustmentCost.TransId == tmpProjAdjustment.TransId;

            if ((tmpProjAdjustmentCreateCostLocal.RecId && !tmpProjAdjustmentCost.RecId) ||
            (!tmpProjAdjustmentCreateCostLocal.RecId && tmpProjAdjustmentCost.RecId) ||
            (tmpProjAdjustmentCreateCostLocal.FundingSource != tmpProjAdjustmentcost.FundingSource))
            {
                onlyDefaultDimensionAdjusted = ProjNoneNoYes::No;
                ret = true;
                break;
            }

            select firstonly RecId from tmpProjAdjustmentCreateCost
            where tmpProjAdjustmentCreateCost.RefRecId == tmpProjAdjustmentCreateLocal.RecId
                && !tmpProjAdjustmentCreateCost.CostRefRecId;
            if (tmpProjAdjustmentCreateCost.RecId)
            {
                onlyDefaultDimensionAdjusted = ProjNoneNoYes::No;
                ret = true;
                break;
            }
            else
            {
                while select tmpProjAdjustmentCreateCost
                where tmpProjAdjustmentCreateCost.RefRecId == tmpProjAdjustmentCreateLocal.RecId
                    join tmpProjAdjustmentCost
                        where tmpProjAdjustmentCost.TransId == tmpProjAdjustment.TransId
                            && tmpProjAdjustmentCost.CostRefRecId == tmpProjAdjustmentCreateCost.CostRefRecId
                {
                    if (this.checkProjAdjustmentCreateCostDifferenceFromExistingProjAdjustmentCost()
                        || this.checkTaxInformationChanged(tmpProjAdjustmentCreateLocal))
                    {
                        onlyDefaultDimensionAdjusted = ProjNoneNoYes::No;
                        ret = true;
                        break;
                    }
                }

                if (ret && onlyDefaultDimensionAdjusted == ProjNoneNoYes::No)
                {
                    break;
                }
            }

            select firstonly RecId, FundingSource from tmpProjAdjustmentCreateSaleLocal
            where tmpProjAdjustmentCreateSaleLocal.RefRecId == tmpProjAdjustmentCreateLocal.RecId;

            select firstonly RecId, FundingSource from tmpProjAdjustmentSale
            where tmpProjAdjustmentSale.TransId == tmpProjAdjustment.TransId;

            if ((tmpProjAdjustmentCreateSaleLocal.RecId && !tmpProjAdjustmentSale.RecId) ||
            (!tmpProjAdjustmentCreateSaleLocal.RecId && tmpProjAdjustmentSale.RecId) ||
            (tmpProjAdjustmentCreateSaleLocal.FundingSource != tmpProjAdjustmentSale.FundingSource)) //For fee transactions as they don't have cost
            {
                onlyDefaultDimensionAdjusted = ProjNoneNoYes::No;
                ret = true;
                break;
            }
            
            select firstonly RecId from tmpProjAdjustmentCreateSale
            where tmpProjAdjustmentCreateSale.RefRecId == tmpProjAdjustmentCreateLocal.RecId
                && !tmpProjAdjustmentCreateSale.SaleRefRecId;
            if (tmpProjAdjustmentCreateSale.RecId)
            {
                onlyDefaultDimensionAdjusted = ProjNoneNoYes::No;
                ret = true;
                break;
            }
            else
            {
                while select tmpProjAdjustmentCreateSale
                where tmpProjAdjustmentCreateSale.RefRecId == tmpProjAdjustmentCreateLocal.RecId
                    join tmpProjAdjustmentSale
                        where tmpProjAdjustmentSale.TransId == tmpProjAdjustment.TransId
                            && tmpProjAdjustmentSale.SaleRefRecId == tmpProjAdjustmentCreateSale.SaleRefRecId
                {
                    if (this.checkProjAdjustmentCreateSalesDifferenceFromExistingProjAdjustmentSales() ||
                            this.checkTaxInformationChanged(tmpProjAdjustmentCreateLocal) ||
                            this.checkFundingSourceIdChanged(tmpProjAdjustmentSale, tmpProjAdjustmentCreateSale) ||
                            this.checkProjAdjustmentCreateSalesCurrencyDifferenceFromExistingProjAdjustment(tmpProjAdjustment, tmpProjAdjustmentCreateLocal)
                        )
                    {
                        onlyDefaultDimensionAdjusted = ProjNoneNoYes::No;
                        ret = true;
                        break;
                    }
                }
                if (ret && onlyDefaultDimensionAdjusted == ProjNoneNoYes::No)
                {
                    break;
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjAdjustmentCreateSalesCurrencyDifferenceFromExistingProjAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the new project adjustment sales currency is different from the existing one.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentCreateLocal">
    /// <c>TmpProjAdjustmentCreate</c> table buffer.
    /// </param>
    /// <param name = "_tmpProjAdjustment">
    /// <c>TmpProjAdjustment</c> table buffer.
    /// </param>
    /// <returns>
    /// true if sales currencies are different; otherwise, false.
    /// </returns>
    protected boolean checkProjAdjustmentCreateSalesCurrencyDifferenceFromExistingProjAdjustment(TmpProjAdjustment _tmpProjAdjustment, TmpProjAdjustmentCreate _tmpProjAdjustmentCreateLocal)
    {
        if (_tmpProjAdjustment.CurrencyId == _tmpProjAdjustmentCreateLocal.CurrencyId)
        {
            return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjAdjustmentCreateDiffererenceFromExistingProjAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the new project adjustment to be created is different than the existing project adjustment.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentCreateLocal">The <c>TmpProjAdjustmentCreate</c> buffer containing the new project adjustment to be created.</param>
    /// <returns>true if the new project adjustment is different than the existing project adjustment; otherwise false.</returns>
    protected boolean checkProjAdjustmentCreateDiffererenceFromExistingProjAdjustment(TmpProjAdjustmentCreate _tmpProjAdjustmentCreateLocal)
    {
        boolean ret;
        if ((tmpProjAdjustment.TaxGroupId != _tmpProjAdjustmentCreateLocal.TaxgroupId) ||
            (tmpProjAdjustment.LinePropertyId != _tmpProjAdjustmentCreateLocal.LinePropertyId) ||
            (tmpProjAdjustment.Qty != _tmpProjAdjustmentCreateLocal.Qty) ||
            (tmpProjAdjustment.CategoryId != _tmpProjAdjustmentCreateLocal.CategoryId) ||
            (tmpProjAdjustment.ResourceCategory != _tmpProjAdjustmentCreateLocal.ResourceCategory) ||
            (tmpProjAdjustment.ProjId != _tmpProjAdjustmentCreateLocal.ProjId) ||
            (tmpProjAdjustment.TaxItemGroupId != _tmpProjAdjustmentCreateLocal.TaxItemGroupId) ||
            (tmpProjAdjustment.ActivityNumber != _tmpProjAdjustmentCreateLocal.ActivityNumber) ||
            (tmpProjAdjustment.Txt != _tmpProjAdjustmentCreateLocal.Txt) ||
            (tmpProjAdjustment.smaBasePrice != _tmpProjAdjustmentCreateLocal.smaBasePrice) ||
            (tmpProjAdjustment.smaIndex != _tmpProjAdjustmentCreateLocal.smaIndex) ||
            (tmpProjAdjustment.smaStartDate != _tmpProjAdjustmentCreateLocal.smaStartDate) ||
            (tmpProjAdjustment.smaEnddate != _tmpProjAdjustmentCreateLocal.smaEnddate) ||
            (tmpProjAdjustment.TransDate != _tmpProjAdjustmentCreateLocal.Transdate) ||
            (tmpProjAdjustment.PSAIndirectComponentGroup != _tmpProjAdjustmentCreateLocal.PSAIndirectComponentGroup) ||
            (tmpProjAdjustment.IndirectCosts != _tmpProjAdjustmentCreateLocal.IndirectCost) ||
            (tmpProjAdjustment.IndirectSales != _tmpProjAdjustmentCreateLocal.IndirectSales))
        {
            onlyDefaultDimensionAdjusted = ProjNoneNoYes::No;
            ret = true;
        }
        else if (this.checkDefaultDimensionChanged(tmpProjAdjustment.DefaultDimension, _tmpProjAdjustmentCreateLocal.DefaultDimension))
        {
            if (onlyDefaultDimensionAdjusted == ProjNoneNoYes::None)
            {
                onlyDefaultDimensionAdjusted = ProjNoneNoYes::Yes;
            }
            ret = true;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjAdjustmentCreateCostDifferenceFromExistingProjAdjustmentCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the new project adjustment cost component to be created is different than the existing project adjustment cost component.
    /// </summary>
    /// <returns>true if the new project adjustment cost component differs from the existing project adjustment cost component; otherwise false.</returns>
    protected boolean checkProjAdjustmentCreateCostDifferenceFromExistingProjAdjustmentCost()
    {
        return tmpProjAdjustmentCost.CostPrice != tmpProjAdjustmentCreateCost.CostPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjAdjustmentCreateSalesDifferenceFromExistingProjAdjustmentSales</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the new project adjustment sales component to be created is different than the existing project adjustment sales component.
    /// </summary>
    /// <returns>true if the new project adjustment sales component differs from the existing project adjustment sales component; otherwise false.</returns>
    protected boolean checkProjAdjustmentCreateSalesDifferenceFromExistingProjAdjustmentSales()
    {
        return tmpProjAdjustmentSale.SalesPrice != tmpProjAdjustmentCreateSale.SalesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createContractFundingAllocationList</Name>
				<Source><![CDATA[
    private List createContractFundingAllocationList(TmpProjAdjustmentCreate _tmpProjAdjustmentCreate)
    {
        MapEnumerator           mapEnumerator;
        ProjSplitAllocation     allocation;
        AmountCur               totalContractAmount;
        AmountCur               amountToMap;
        List                    fundingSourceAllocation;
        Map                     fundingList;
        boolean                 firstRecord = true;

        fundingList = new Map(Types::Int64, Types::Real);
        fundingSourceAllocation = new List( Types::Class );

        while select tmpProjAdjustmentCreateSale
            where tmpProjAdjustmentCreateSale.RefRecId == _tmpProjAdjustmentCreate.RecId
        {
            totalContractAmount = totalContractAmount + tmpProjAdjustmentCreateSale.LineAmount;
            amountToMap = tmpProjAdjustmentCreateSale.LineAmount;
            if (fundingList.exists(tmpProjAdjustmentCreateSale.FundingSource))
            {
                //Update value to map
                amountToMap = fundingList.lookup(tmpProjAdjustmentCreateSale.FundingSource) + amountToMap;
                fundingList.remove(tmpProjAdjustmentCreateSale.FundingSource);
            }
            fundingList.insert(tmpProjAdjustmentCreateSale.FundingSource, amountToMap);
        }

        //Traverse the funding sources and create the list and percentages
        mapEnumerator = fundingList.getEnumerator();
        while ( mapEnumerator.moveNext() )
        {
            if (totalContractAmount != 0.00)
            {
                allocation = ProjSplitAllocation::construct( mapEnumerator.currentKey(),
                                                         mapEnumerator.currentValue()/totalContractAmount * 100,
                                                         0,
                                                         firstRecord ? NoYes::Yes : NoYes::No );
            }
            else
            {
                //
                // This code should not be executed as contract values should not be 0.00.
                // Handle possible divide by zero error
                //
                allocation = ProjSplitAllocation::construct( mapEnumerator.currentKey(),
                                                         100,
                                                         0,
                                                         firstRecord ? NoYes::Yes : NoYes::No );
            }
            fundingSourceAllocation.addEnd( allocation );
            firstRecord = false;
        }

        return fundingSourceAllocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates journal for adjustment type as hour and revenue.
    /// </summary>
    /// <param name = "_adjustmentType">
    ///     Adjustment type.
    /// </param>
    void createJournal(ProjAdjustmentType  _adjustmentType)
    {
        ProjJournalType journalType;

        if (ProjAdjSetExpenseTransAdjStatusFlight::instance().isEnabled())
        {
            if (TmpProjAdjustment::createReverseTrans(_adjustmentType))
            {
                journalType = TmpProjAdjustment::adjustmentType2JournalType(_adjustmentType);

                if (this.checkJournalExist(_adjustmentType))
                {
                    journalTransData    = journalTableData.journalStatic().newJournalTransData(journalTrans,journalTableData);
                }
                else
                {
                    if (!this.checkDefaultJournal(_adjustmentType))
                    {
                        throw error ("@SYS81796");
                    }

                    journalTableData    = JournalTableData::newTable(journalTable);
                    journalTransData    = journalTableData.journalStatic().newJournalTransData(journalTrans,journalTableData);
                    this.journalTableInsert(journalType);

                    if (this.checkAdjustmentTypeForHour(_adjustmentType))
                    {
                        this.parmJournalEmplId(journalTable.JournalId);
                    }
                    else if (_adjustmentType == ProjAdjustmentType::Revenue)
                    {
                        this.parmJournalRevenueId(journalTable.JournalId);
                    }
                    lineNum = 0;
                }
            }
        }
        else
        {
            this.createJournalSetExpenseTransAdjStatusWhenOrigAdjFlightDisabled(_adjustmentType);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalSetExpenseTransAdjStatusWhenOrigAdjFlightDisabled</Name>
				<Source><![CDATA[
    private void createJournalSetExpenseTransAdjStatusWhenOrigAdjFlightDisabled(ProjAdjustmentType  _adjustmentType)
    {
        // Delete this method and its references when ProjAdjSetExpenseTransAdjStatusFlight is removed

        ProjJournalType journalType;

        if (TmpProjAdjustment::createReverseTrans(_adjustmentType))
        {
            // Only Hours and Revenue use the ProjJournalTable, ProjJournalTrans to post reversals.
            if (_adjustmentType == ProjAdjustmentType::Hour
                || _adjustmentType == ProjAdjustmentType::Revenue)
            {
                journalType = TmpProjAdjustment::adjustmentType2JournalType(_adjustmentType);

                if (this.checkJournalExist(_adjustmentType))
                {
                    journalTransData    = journalTableData.journalStatic().newJournalTransData(journalTrans,journalTableData);
                }
                else
                {
                    if (!this.checkDefaultJournal(_adjustmentType))
                    {
                        throw error ("@SYS81796");
                    }

                    journalTableData    = JournalTableData::newTable(journalTable);
                    journalTransData    = journalTableData.journalStatic().newJournalTransData(journalTrans,journalTableData);
                    this.journalTableInsert(journalType);

                    if (this.checkAdjustmentTypeForHour(_adjustmentType))
                    {
                        this.parmJournalEmplId(journalTable.JournalId);
                    }
                    else
                    {
                        this.parmJournalRevenueId(journalTable.JournalId);
                    }
                    lineNum = 0;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteJournal</Name>
				<Source><![CDATA[
    void deleteJournal()
    {
        if (this.mustDeleteJournal())
        {
            journalTable.delete();
            this.parmJournalEmplId('');
            this.parmJournalItemId('');
            this.parmJournalRevenueId('');
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDeleteJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the journal should be deleted.
    /// </summary>
    /// <returns>
    ///     A Boolean indicating whether the journal should be deleted.
    /// </returns>
    protected boolean mustDeleteJournal()
    {
        return (journalTableData && journalTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>docuCopy</Name>
				<Source><![CDATA[
    void docuCopy(ProjEmplTrans _projEmplTrans, ProjJournalTrans  _projJournalTrans)
    {
        return;
        //  don't call super
    }

]]></Source>
			</Method>
			<Method>
				<Name>fundingSourceList</Name>
				<Source><![CDATA[
    private List fundingSourceList(TmpProjAdjustmentCreate  _tmpProjAdjustmentCreate)
    {
        Map                     fundingList;
        List                    fundingSourceAllocation;
        AmountCur               totalTrxAmount;
        AmountCur               amountToMap;
        MapEnumerator           mapEnumerator;
        ProjSplitAllocation     allocation;
        boolean                 firstRecord = true;

        fundingList = new Map(Types::Int64, Types::Real);
        fundingSourceAllocation = new List( Types::Class );

        if (_tmpProjAdjustmentCreate.TotalCostAmountCur)
        {
            while select LineAmount, FundingSource from tmpProjAdjustmentCreateCost
            where tmpProjAdjustmentCreateCost.RefRecId == _tmpProjAdjustmentCreate.RecId
            {
                totalTrxAmount = totalTrxAmount + tmpProjAdjustmentCreateCost.LineAmount;
                amountToMap = tmpProjAdjustmentCreateCost.LineAmount;
                if (fundingList.exists(tmpProjAdjustmentCreateCost.FundingSource))
                {
                    amountToMap = fundingList.lookup(tmpProjAdjustmentCreateCost.FundingSource) + amountToMap;
                    fundingList.remove(tmpProjAdjustmentCreateCost.FundingSource);
                }
                fundingList.insert(tmpProjAdjustmentCreateCost.FundingSource, amountToMap);
            }
        }
        else if (_tmpProjAdjustmentCreate.TotalSalesAmountCur)
        {
            while select LineAmount, FundingSource from tmpProjAdjustmentCreateSale
            where tmpProjAdjustmentCreateSale.RefRecId == _tmpProjAdjustmentCreate.RecId
            {
                totalTrxAmount = totalTrxAmount + tmpProjAdjustmentCreateSale.LineAmount;
                amountToMap = tmpProjAdjustmentCreateSale.LineAmount;
                if (fundingList.exists(tmpProjAdjustmentCreateSale.FundingSource))
                {
                    amountToMap = fundingList.lookup(tmpProjAdjustmentCreateSale.FundingSource) + amountToMap;
                    fundingList.remove(tmpProjAdjustmentCreateSale.FundingSource);
                }
                fundingList.insert(tmpProjAdjustmentCreateSale.FundingSource, amountToMap);
            }
        }

        mapEnumerator = fundingList.getEnumerator();
        while ( mapEnumerator.moveNext() )
        {
            if (totalTrxAmount != 0.00)
            {
                allocation = ProjSplitAllocation::construct( mapEnumerator.currentKey(),
                                                         mapEnumerator.currentValue()/totalTrxAmount * 100,
                                                         0,
                                                         firstRecord ? NoYes::Yes : NoYes::No );
            }
            else
            {
                allocation = ProjSplitAllocation::construct( mapEnumerator.currentKey(),
                                                         100,
                                                         0,
                                                         firstRecord ? NoYes::Yes : NoYes::No );
            }
            fundingSourceAllocation.addEnd( allocation );
            firstRecord = false;
        }

        return fundingSourceAllocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>infoError</Name>
				<Source><![CDATA[
    void infoError()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInfologAction</Name>
				<Source><![CDATA[
    void initInfologAction(TmpProjAdjustment _tmpProjAdjustment)
    {
        container                   c;
        Integer                     line;
        SysInfologEnumerator        enum;
        ProjAdjustmentInfoAction    projAdjustmentInfoAction = ProjAdjustmentInfoAction::newProjAdjustment(_tmpProjAdjustment);

        line = infologLine();
        c    = infolog.copy(logPoint+1,line);
        enum = SysInfologEnumerator::newData(c);

        infolog.clear(logPoint);

        while (enum.moveNext())
        {
            switch (enum.currentException())
            {
                case Exception::Info:
                    info(enum.currentMessage(),'',projAdjustmentInfoAction);
                    break;

                case Exception::Warning:
                    warning(enum.currentMessage(),'',projAdjustmentInfoAction);
                    break;

                default:
                    error(enum.currentMessage(),'',projAdjustmentInfoAction);
                    break;
            }
        }

        logPoint = line;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExchangeRateInformationFromOriginalExpenseReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the exchange rate information to what was originally used on the original expense report.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
	/// The new transaction on which exchange rate information needs to be set.
	/// </param>
    /// <param name = "_projCostTransOrig">
	/// The offsetting expense transaction for the transaction being adjusted.
	/// </param>
    /// <returns>
    /// True when exchange rates is defined on the expense transaction, otherwise false.
	/// </returns>
    protected boolean setExchangeRateInformationFromOriginalExpenseReport(LedgerJournalTrans _ledgerJournalTrans, ProjCostTrans _projCostTransOrig)
    {
        TrvExpTrans trvExpTrans;
        CompanyInfo companyInfo;

        select firstonly trvExpTrans
            where trvExpTrans.ProjTransId == _projCostTransOrig.TransIdRef
            exists join companyInfo
                where companyInfo.RecId == trvExpTrans.LegalEntity
                   && CompanyInfo.DataArea == _projCostTransOrig.DataAreaId;

        if (trvExpTrans.ExchangeRate)
        {
            _ledgerJournalTrans.ExchRate = trvExpTrans.ExchangeRate;
        }

        return trvExpTrans.ExchangeRate != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExchangeRateInformationFromOriginalJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the exchange rate information to what was originally used on the original ledger journal.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
	/// The new transaction on which exchange rate information needs to be set.
	/// </param>
    /// <param name = "_projCostTransOrig">
	/// The offsetting expense transaction for the transaction being adjusted.
	/// </param>
    /// <returns>
    /// True if the exchange rate is defined on the <c>LedgerJournalTrans</c> record, otherwise false.
	/// </returns>
    protected boolean setExchangeRateInformationFromOriginalJournal(LedgerJournalTrans _ledgerJournalTrans, ProjCostTrans _projCostTransOrig)
    {
        LedgerJournalTrans          localLedgerJournalTrans;
        LedgerJournalTrans_Project  localLedgerJournalTrans_Project;

        // If adjusting an already adjusted transaction, this information is only available on the original journal, as we
        // delete the LedgerJournalTrans used for adjusting right after posting, in transCostNew().
        select firstonly ExchRate, ExchRateSecond, Triangulation from localledgerJournalTrans
            exists join localLedgerJournalTrans_Project
            where
                localLedgerJournalTrans_Project.RefRecId == localledgerJournalTrans.RecId &&
                localLedgerJournalTrans_Project.TransId  == _projCostTransOrig.TransIdRef &&
                localledgerJournalTrans.ExchRate;
        if (localledgerJournalTrans)
        {
            _ledgerJournalTrans.ExchRate                 = localledgerJournalTrans.ExchRate;
            _ledgerJournalTrans.ExchRateSecond           = localledgerJournalTrans.ExchRateSecond;
            _ledgerJournalTrans.Triangulation            = localledgerJournalTrans.Triangulation;
        }

        return localledgerJournalTrans.ExchRate != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExchangeRateInformationFromDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defaults the exchange rate information from setup, using the date of the original transaction.
    /// This is used when the original exchange rate cannot be determined.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The new transaction on which exchange rate information needs to be set.</param>
    /// <param name = "_projCostTransOrig">The offsetting expense transaction for the transaction being adjusted.</param>
    protected void setExchangeRateInformationFromDefault(LedgerJournalTrans _ledgerJournalTrans, ProjCostTrans _projCostTransOrig)
    {
        // Use the original transaction date for currency exchange rate. Otherwise the voucher will not balance if the exchange rate has changed.
        while (_projCostTransOrig.AdjRefTransId)
        {
            _projCostTransOrig = ProjCostTrans::find(_projCostTransOrig.AdjRefTransId);
        }

        ProjCostTransCost projCostTransCostLoc;
        select firstonly LedgerTransdate from projCostTransCostLoc
        where projCostTransCostLoc.TransId == _projCostTransOrig.TransId;

        if (projCostTransCostLoc.LedgerTransdate)
        {
            _ledgerJournalTrans.ExchRate = ExchangeRateHelper::exchRate(_projCostTransOrig.CurrencyIdCost, projCostTransCostLoc.LedgerTransdate);
            _ledgerJournalTrans.ExchRateSecond = ExchangeRateHelper::exchRateSecond(_projCostTransOrig.CurrencyIdCost, projCostTransCostLoc.LedgerTransdate);
            _ledgerJournalTrans.Triangulation = Currency::triangulation(_projCostTransOrig.CurrencyIdCost, projCostTransCostLoc.LedgerTransdate);
        }
        else
        {
            throw error(strFmt("@Proj:AdjustmentLedgerTransDateNotFoundError", _projCostTransOrig.TransId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExchangeRateInformationFromOriginalTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines origin of transaction and sets the exchange rate information to the same as what was originally used.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The new transaction on which exchange rate information needs to be set.</param>
    /// <param name = "_projCostTransOrig">The offsetting expense transaction for the transaction being adjusted.</param>
    protected void setExchangeRateInformationFromOriginalTransaction(LedgerJournalTrans _ledgerJournalTrans, ProjCostTrans _projCostTransOrig)
    {
        boolean exchangeRateSet = false;

        switch (_projCostTransOrig.TransactionOrigin)
        {
            case ProjOrigin::ExpenseManagement:
                exchangeRateSet = this.setExchangeRateInformationFromOriginalExpenseReport(_ledgerJournalTrans, _projCostTransOrig);
                break;

            default:
                exchangeRateSet = this.setExchangeRateInformationFromOriginalJournal(_ledgerJournalTrans, _projCostTransOrig);
        }

        if (!exchangeRateSet)
        {
            this.setExchangeRateInformationFromDefault(_ledgerJournalTrans, _projCostTransOrig);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerJournalNew</Name>
				<Source><![CDATA[
    protected LedgerJournalTrans initLedgerJournalNew(
    TmpProjAdjustmentCreate _tmpProjAdjustmentCreate)
    {
        LedgerJournalTrans          ledgerJournalTrans;
        ProjCostTrans               projCostTransOrig;
        // <GIN>
        LedgerJournalTransTaxExtensionIN    ledgerJournalTransTaxExtensionIN;
        // </GIN>

        projCostTransOrig = ProjCostTrans::find(_tmpProjAdjustmentCreate.TransID, false);

        ledgerJournalTrans.initValue();
        ledgerJournalTrans.Txt                      = _tmpProjAdjustmentCreate.Txt;
        ledgerJournalTrans.CurrencyCode             = _tmpProjAdjustmentCreate.CurrencyIdCost;
        ledgerJournalTrans.DefaultDimension         = _tmpProjAdjustmentCreate.DefaultDimension;
        ledgerJournalTrans.parmAccount(_tmpProjAdjustmentCreate.ProjId, LedgerJournalACType::Project);

        this.setExchangeRateInformationFromOriginalTransaction(ledgerJournalTrans, projCostTransOrig);
        

        if (projCostTransOrig.TransactionOrigin == ProjOrigin::CostJournal)
        {
            LedgerJournalTrans localLedgerTrans = LedgerJournalTrans::findRecId(projCostTransOrig.LedgerJournalTrans, false);
            ledgerJournalTrans.TaxItemGroup = localLedgerTrans.TaxItemGroup;
            ledgerJournalTrans.TaxGroup = localLedgerTrans.TaxGroup;

            LedgerJournalTransTaxExtension ledgerJournalTransTaxExt = ledgerJournalTrans.ledgerJournalTransTaxExtension();
            ledgerJournalTransTaxExt.OverrideSalesTax = localLedgerTrans.ledgerJournalTransTaxExtension().OverrideSalesTax;
            ledgerJournalTrans.packExtensionTable(ledgerJournalTransTaxExt);
        }
        else if (projCostTransOrig.TransactionOrigin == ProjOrigin::ProjAdvancedJournal)
        {
            ProjAdvancedJournalLine projAdvancedJournalLine = ProjAdvancedJournalLine::findByVoucher(projCostTransOrig.VoucherJournal);
            ledgerJournalTrans.TaxItemGroup = projAdvancedJournalLine.TaxItemGroup;
            ledgerJournalTrans.TaxGroup = projAdvancedJournalLine.TaxGroup;

            LedgerJournalTransTaxExtension ledgerJournalTransTaxExt = ledgerJournalTrans.ledgerJournalTransTaxExtension();
            ledgerJournalTransTaxExt.OverrideSalesTax = projAdvancedJournalLine.OverrideSalesTax;
            ledgerJournalTrans.packExtensionTable(ledgerJournalTransTaxExt);
        }
        else
        {
            ledgerJournalTrans.TaxItemGroup = _tmpProjAdjustmentCreate.TaxItemGroupId;
            ledgerJournalTrans.TaxGroup = _tmpProjAdjustmentCreate.TaxgroupId;
        }

        ledgerJournalTrans.TransDate                = tmpProjAdjustment.TransDate;

        // <GIN>
        if (TaxParameters::checkTaxParameters_IN() || TaxWithholdParameters_IN::checkTaxParameters())
        {
            ledgerJournalTransTaxExtensionIN = ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
            ledgerJournalTransTaxExtensionIN.AssessableValueTransactionCurrency        = _tmpProjAdjustmentCreate.AssessableValue_IN;
            ledgerJournalTransTaxExtensionIN.MaximumRetailPrice                        = _tmpProjAdjustmentCreate.MaximumRetailPrice_IN;
            ledgerJournalTransTaxExtensionIN.tcsGroup                                  = _tmpProjAdjustmentCreate.tcsGroup_IN;
            ledgerJournalTransTaxExtensionIN.tdsGroup                                  = _tmpProjAdjustmentCreate.tdsGroup_IN;
            ledgerJournalTrans.packledgerJournalTransTaxExtensionIN(ledgerJournalTransTaxExtensionIN);
        }
        // </GIN>

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerJournalProjectNew</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new <c>LedgerJournalTrans_Project</c> table buffer from default values passed in.
    /// </summary>
    /// <param name="_tmpProjAdjustmentCreate">
    ///    A structure that contains default project values that will be used when initializing the project
    ///    table buffer.
    /// </param>
    /// <returns>
    ///    An initialized <c>LedgerJournalTrans_Project</c> table buffer.
    /// </returns>
    protected LedgerJournalTrans_Project initLedgerJournalProjectNew(
    TmpProjAdjustmentCreate _tmpProjAdjustmentCreate)
    {
        LedgerJournalTrans_Project    ledgerJournalTransProject;
        RecId                         legalEntity;
        // <GIN>
        LedgerJournalTrans_ProjectTaxExtensionIN ledgerJourTrans_ProjTaxExt;
        // </GIN>

        legalEntity = CompanyInfo::findDataArea(curext()).RecId;

        ledgerJournalTransProject.ProjTransDate     = tmpProjAdjustment.TransDate;
        ledgerJournalTransProject.CategoryId        = _tmpProjAdjustmentCreate.CategoryId;
        ledgerJournalTransProject.SalesCurrencyId   = _tmpProjAdjustmentCreate.CurrencyId;
        ledgerJournalTransProject.LinePropertyId    = _tmpProjAdjustmentCreate.LinePropertyId;
        ledgerJournalTransProject.ProjId            = _tmpProjAdjustmentCreate.ProjId;
        ledgerJournalTransProject.Qty               = _tmpProjAdjustmentCreate.Qty;
        ledgerJournalTransProject.TaxGroupSales     = _tmpProjAdjustmentCreate.TaxgroupId;
        ledgerJournalTransProject.TaxItemGroupSales = _tmpProjAdjustmentCreate.TaxItemGroupId;
        ledgerJournalTransProject.Resource          = _tmpProjAdjustmentCreate.Resource;
        ledgerJournalTransProject.Module            = _tmpProjAdjustmentCreate.Module;
        ledgerJournalTransProject.ActivityNumber    = _tmpProjAdjustmentCreate.ActivityNumber;
        if (_tmpProjAdjustmentCreate.Qty)
        {
            ledgerJournalTransProject.CostPrice         = _tmpProjAdjustmentCreate.TotalCostAmountCur /_tmpProjAdjustmentCreate.Qty;
            ledgerJournalTransProject.SalesPrice        = _tmpProjAdjustmentCreate.TotalSalesAmountCur /_tmpProjAdjustmentCreate.Qty;
        }

        // <GIN>
        if (TaxParameters::checkTaxParameters_IN() || TaxWithholdParameters_IN::checkTaxParameters())
        {
            ledgerJourTrans_ProjTaxExt.AssessableValueTransactionCurrency              = _tmpProjAdjustmentCreate.AssessableValue_IN;
            ledgerJourTrans_ProjTaxExt.MaximumRetailPrice           = _tmpProjAdjustmentCreate.MaximumRetailPrice_IN;
            ledgerJournalTransProject.packLedgerJournalTrans_Project_IN(ledgerJourTrans_ProjTaxExt);
        }
        // </GIN>

        return ledgerJournalTransProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerJournalTableNew</Name>
				<Source><![CDATA[
    protected LedgerJournalTable initLedgerJournalTableNew()
    {
        LedgerJournalName   ledgerJournalName;
        LedgerJournalTable  ledgerJournalTable;

        select firstonly ledgerJournalName
        where ledgerJournalName.JournalType == LedgerJournalType::Cost;

        if (!ledgerJournalName)
        {
            throw error(strFmt("@SYS311347", LedgerJournalType::Cost));
        }

        ledgerJournalTable.clear();
        ledgerJournalTable.initValue();
        ledgerJournalTable.JournalNum = JournalTableData::newTable(ledgerJournalTable).nextJournalId();
        ledgerJournalTable.initFromLedgerJournalName(ledgerJournalName.JournalName);
        ledgerJournalTable.Name = ledgerJournalName.Name;
        ledgerJournalTable.JournalType = LedgerJournalType::Cost;

        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertInventTransMap</Name>
				<Source><![CDATA[
    Map insertInventTransMap(
    InventTransOriginId   _inventTransOriginId,
    ProjAdjustRefId       _projAdjustRefId)
    {
        Map                 inventTransMap;
        InventTrans         inventTrans;

        inventTransMap     = new Map(Types::Int64,Types::Record);

        while select forupdate inventTrans
        where inventTrans.InventTransOrigin == _inventTransOriginId &&
              inventTrans.ProjAdjustRefId   == _projAdjustRefId     &&
              inventTrans.Qty               != 0

        {
            inventTransMap.insert(inventTrans.RecId,inventTrans);
        }

        return inventTransMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventQty</Name>
				<Source><![CDATA[
    container inventQty(
    InventQty   _inventQty,
    InventQty   _projQty)
    {
        InventQty   inventQty, projTransQty = _projQty;
        boolean     readInventTrans;

        if (_projQty == remainQty)
        {
            inventQty       = remainQty;
            remainQty       = 0;
            projTransQty    = 0;
        }
        else if (abs(_projQty) < abs(remainQty))
        {
            inventQty       = _projQty;
            remainQty       = remainQty - _projQty;
            projTransQty    = 0;
        }
        else  // projQty >= -inventQty
        {
            inventQty       = remainQty;
            remainQty       = 0;
            projTransQty    = projTransQty - inventQty;

            readInventTrans = true;
        }

        return [inventQty,projTransQty, readInventTrans];
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAdjustmentCorrection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether an adjustment transaction should be a correction.
    /// </summary>
    /// <param name="_adjustmentCorrectionEnabled">
    /// A Boolean value that indicates whether a dialog box option to post adjustment as correction was
    /// selected.
    /// </param>
    /// <param name="_wasPreviousCorrection">
    /// A Boolean value that indicates whether the previous transaction was a correction.
    /// </param>
    /// <param name="_isReversalTrans">
    /// A Boolean value that indicates whether to post a reversal of the original transaction or a new one
    /// during adjustment; optional.
    /// </param>
    /// <returns>
    /// true if the transaction should be a correction; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If the parameter to create reversal transaction during adjustment is enabled, the adjustment
    /// process creates a reversal of the original transaction and a new transaction. If the original
    /// transaction was a correction, the reversal should not be a correction and the new transaction
    /// should be a correction and vice versa.
    /// </remarks>
    public LedgerCorrection isAdjustmentCorrection(
    boolean _adjustmentCorrectionEnabled,
    boolean _wasPreviousCorrection,
    boolean _isReversalTrans = false)
    {
        return (LedgerParameters::isStornoEnabledEE() && _adjustmentCorrectionEnabled)
        && (_isReversalTrans
        ? !_wasPreviousCorrection   // reversal transaction : correction setting should be opposite of previous
        : _wasPreviousCorrection);   // new transaction : correction setting should be same as previous
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears and populates the journalTable member variable.
    /// </summary>
    /// <param name = "_journalType">A journal type.</param>
    /// <param name = "_resourceRecId">A resource record ID.</param>
    protected void populateJournalTable(ProjJournalType _journalType, ResourceRecId _resourceRecId)
    {
        journalTable.clear();
        journalTable.JournalId      = journalTableData.nextJournalId();
        journalTable.JournalType    = _journalType;
        journalTable.JournalNameId  = ProjJournalName::standardJournalName(_journalType);
        journalTable.Resource       = _resourceRecId;
        journalTable.initFromProjJournalName(journalTableData.journalStatic().findJournalName(journalTable.JournalNameId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalTableInsert</Name>
				<Source><![CDATA[
    private void journalTableInsert(ProjJournalType _journalType, ResourceRecId _resourceRecId = 0)
    {
        this.populateJournalTable(_journalType, _resourceRecId);
        journalTable.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalTransInsert</Name>
				<Source><![CDATA[
    public void journalTransInsert(TmpProjAdjustmentCreate _tmpProjAdjustmentCreate)
    {
        Voucher voucher_last;

        journalTrans.clear();
        journalTransData.initFromJournalTable();

        journalTrans.initFromAdjustment(_tmpProjAdjustmentCreate);

        journalTrans.LineNum        = this.parmLineNum();                   // LineNum must be assigned
        journalTrans.TransDate      = tmpProjAdjustment.TransDateAdjustment;
        journalTrans.FromTime       = tmpProjAdjustment.FromTime;
        journalTrans.ToTime         = tmpProjAdjustment.ToTime;

        if (journalTable.VoucherDraw == JournalVoucherDraw::Entering)
        {
            journalTransData.initVoucher(voucher_last,false,false);         // Voucher is assigned
        }

        journalTransData.addTotal(true);                                    // Totals are update on table and voucher

        if (! journalTrans.validateWrite())
        {
            throw error("@SYS25904");
        }

        journalTrans.insert();

        // <GTE>
        if (TaxIntegrationUtils::isTaxInformationEnabled())
        {
            TransTaxInformationHelper::copyTransTaxInformation(_tmpProjAdjustmentCreate, journalTrans);
        }
        // </GTE>

        if (_tmpProjAdjustmentCreate.checkAdjustmentType(ProjAdjustmentType::Hour))
        {
            this.docuCopy(ProjEmplTrans::find(_tmpProjAdjustmentCreate.TransID),journalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerVoucher</Name>
				<Source><![CDATA[
    LedgerVoucher ledgerVoucher()
    {        
        LedgerVoucher   newLedgerVoucher;
        DetailSummary   detailSummary = ProjParameters::find().LineTotalAdjustment == ProjLineTotal::Line ? DetailSummary::Detail : DetailSummary::Summary ;

        newLedgerVoucher =  LedgerVoucher::newLedgerPost(detailSummary,
                                                     SysModule::Project,
                                                     numberSeq.parmVoucherSequenceCode(),
                                                     this.transactionLogType(),
                                                     this.transactionLogTxt());

        newLedgerVoucher.parmCheckBlockedDimensions(false);
        newLedgerVoucher.parmSkipBlockedForManualEntryCheck(true);

        return newLedgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerVoucherTransCreate</Name>
				<Source><![CDATA[
    public void ledgerVoucherTransCreate(
    TransDate _transDate)
    {
        LedgerVoucherObject     ledgerVoucherObject;
        TransDate               transDate = _transDate ? _transDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

        numberSeq =  NumberSeq::newGetVoucher(ProjParameters::numRefProjAdjustmentId());
        transTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);

        try
        {   
            voucher = numberSeq.voucher();

            transTxt.setDate(transDate);
            transTxt.setVoucher(voucher);

            ledgerVoucher = this.ledgerVoucher();

            ledgerVoucherObject = LedgerVoucherObject::newVoucher(voucher,
                                                                transDate,
                                                                SysModule::Project,
                                                                LedgerTransType::Project);
            ledgerVoucherObject.lastTransTxt(transTxt.txt());
            ledgerVoucher.addVoucher(ledgerVoucherObject);            
        }

        catch (Exception::Error)
        {
            throw error("@SYS21628");
        }

        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }

        catch (Exception::Deadlock)
        {
            retry;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerVoucherTransEnd</Name>
				<Source><![CDATA[
    public void ledgerVoucherTransEnd()
    {
        // <GEERU>
        LedgerBondClient_RU ledgerBondClient;
        // </GEERU>
        if (this.parmPost())
        {
            if (ledgerVoucher)
            {
                // <GEERU>
                ledgerBondClient = ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
                if (ledgerBondClient)
                {
                    ledgerBondClient.bondLog2Log();
                }
                // </GEERU>
                ledgerVoucher.end();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        useInfolog = true;

        // <GIN>
        isCountryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        // </GIN>

        if (LedgerParameters::isStornoEnabledEE())
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceEEU00015, funcName());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInfolog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Turn on or off the infolog
    /// </summary>
    /// <param name="_infolog">
    /// set to false if no infolog should be shown
    /// </param>
    /// <returns>
    /// the current value
    /// </returns>
    public boolean parmInfolog(boolean _infolog = useInfolog)
    {
        useInfolog = _infolog;

        return useInfolog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventRefTransIdOrig</Name>
				<Source><![CDATA[
    public InventTransId parmInventRefTransIdOrig(InventTransId   _inventRefTransIdOrig  = inventRefTransIdOrig)
    {
        inventRefTransIdOrig   = _inventRefTransIdOrig;

        return inventRefTransIdOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalEmplId</Name>
				<Source><![CDATA[
    public Num parmJournalEmplId(Num   _journalId  = parmJournalEmplId)
    {
        parmJournalEmplId   = _journalId;

        return parmJournalEmplId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalItemId</Name>
				<Source><![CDATA[
    public Num parmJournalItemId(Num   _journalId  = parmJournalItemId)
    {
        parmJournalItemId   = _journalId;

        return parmJournalItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalRevenueId</Name>
				<Source><![CDATA[
    public Num parmJournalRevenueId(Num   _journalId  = parmJournalRevenueId)
    {
        parmJournalRevenueId   = _journalId;

        return parmJournalRevenueId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineNum</Name>
				<Source><![CDATA[
    public LineNum parmLineNum(LineNum    _lineNum    = lineNum)
    {
        lineNum = _lineNum;

        return lineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPost</Name>
				<Source><![CDATA[
    public NoYes parmPost(NoYes _post = post)
    {
        post    = _post;

        return post;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostToLedger</Name>
				<Source><![CDATA[
    public boolean parmPostToLedger(boolean _postToLedger = postToLedger)
    {
        postToLedger = _postToLedger;
        return postToLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    public void post()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNew</Name>
				<Source><![CDATA[
    public void postNew(TmpProjAdjustmentCreate _tmpProjAdjustmentCreate)
    {
        boolean projAdjSetExpenseTransAdjStatusFlightEnabled  = ProjAdjSetExpenseTransAdjStatusFlight::instance().isEnabled();

        if (!projAdjSetExpenseTransAdjStatusFlightEnabled)
        {
            this.createJournal(_tmpProjAdjustmentCreate.AdjustmentType);
        }

        switch (_tmpProjAdjustmentCreate.AdjustmentType)
        {
            case ProjAdjustmentType::Hour :
                if (projAdjSetExpenseTransAdjStatusFlightEnabled)
                {
                    this.createJournal(_tmpProjAdjustmentCreate.AdjustmentType);
                }
                this.transEmplNew(_tmpProjAdjustmentCreate);
                break;

            case ProjAdjustmentType::Revenue:
                if (projAdjSetExpenseTransAdjStatusFlightEnabled)
                {
                    this.createJournal(_tmpProjAdjustmentCreate.AdjustmentType);
                }
                this.transRevenueNew(_tmpProjAdjustmentCreate);
                break;

            case ProjAdjustmentType::Cost:
                this.transCostNew(_tmpProjAdjustmentCreate);
                break;

            case ProjAdjustmentType::Item:
                this.transItemNew(_tmpProjAdjustmentCreate);
                break;
        }

		// Update the limit as the transactions have been posted and remove the tracking information
		if (ProjFlightStateHelper::isProjUseFundingLimitTrackingForAdjustmentsFlightEnabled())
        {
            ttsbegin;
            ProjFundingLimitTracking projFundingLimitTracking;
            while select projFundingLimitTracking where projFundingLimitTracking.TransId == _tmpProjAdjustmentCreate.TmpTransId
            {
                ProjFundingLimit projFundingLimit = ProjFundingLimit::find(projFundingLimitTracking.ProjFundingLimit, true);
                if (projFundingLimit)
                {
                    projFundingLimit.LimitSpent += projFundingLimitTracking.Amount;
                    projFundingLimit.update();
                }
            }

            delete_from projFundingLimitTracking where projFundingLimitTracking.TransId == _tmpProjAdjustmentCreate.TmpTransId;
            ttscommit;
        }
               
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the <c>ProjTrans</c> class instance.
    /// </summary>
    /// <param name = "_adjustmentType">
    /// Enum value of type <c>ProjAdjustmentType</c>.
    /// </param>
    /// <param name = "_transId">
    /// A value of type <c>ProjTransIdBase</c>.
    /// </param>
    /// <returns>
    /// An instance of <c>ProjTrans</c>.
    /// </returns>
    protected ProjTrans projTrans(ProjAdjustmentType _adjustmentType, ProjTransIdBase _transId)
    {
        ProjTrans projTrans;

        projTrans = this.initializeProjTrans(_adjustmentType, _transId);
        
        if(!projTrans)
        {
            throw error("@SYS21628");
        }

        projTrans.parmAdjustmentStatus(this.adjustStatus());

        return projTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the <c>ProjTrans</c> class instance based on <c>ProjAdjustmentType</c>.
    /// </summary>
    /// <param name = "_adjustmentType">
    /// Enum value of type <c>ProjAdjustmentType</c>.
    /// </param>
    /// <param name = "_transId">
    /// A value of type <c>ProjTransIdBase</c>.
    /// </param>
    /// <returns>
    /// An instance of <c>ProjTrans</c>.
    /// </returns>
    protected ProjTrans initializeProjTrans(ProjAdjustmentType _adjustmentType, ProjTransIdBase _transId)
    {
        ProjTrans projTrans;

        switch (_adjustmentType)
        {
            case ProjAdjustmentType::Hour :
                projTrans = ProjTrans::newProjEmplTrans(ProjEmplTrans::find(_transId));
                break;

            case ProjAdjustmentType::Cost:
                projTrans = ProjTrans::newProjCostTrans(ProjCostTrans::find(_transId));
                break;

            case ProjAdjustmentType::Revenue:
                projTrans = ProjTrans::newProjRevenueTrans(ProjRevenueTrans::find(_transId));
                break;

            case ProjAdjustmentType::Item:
                projTrans = ProjTrans::newProjItemTrans(ProjItemTrans::find(_transId));
                break;
        }

        return projTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransCost</Name>
				<Source><![CDATA[
    protected ProjTrans projTransCost(Common _buffer, RefRecId _recId)
    {
        ProjTrans projTrans;

        switch (_buffer.TableId)
        {
            case tableNum(ProjEmplTrans):
                projTrans = ProjTrans::newProjEmplTransCost(_buffer, ProjEmplTransCost::find(_recId));
                break;

            case tableNum(ProjCostTrans):
                projTrans = ProjTrans::newProjCostTransCost(_buffer, ProjCostTransCost::find(_recId));
                break;

            case tableNum(ProjItemTrans):
                projTrans = ProjTrans::newProjItemTransCost(ProjItemTransCost::findRecId(_recId));
                break;

            default:
                throw error("@SYS21628");
        }

        return projTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransSale</Name>
				<Source><![CDATA[
    protected ProjTrans projTransSale(Common _buffer, RefRecId _recId)
    {
        ProjTrans projTrans;

        switch (_buffer.TableId)
        {
            case tableNum(ProjEmplTrans):
                projTrans = ProjTrans::newProjEmplTransSale(_buffer, ProjEmplTransSale::find(_recId));
                break;

            case tableNum(ProjCostTrans):
                projTrans = ProjTrans::newProjCostTransSale(_buffer, ProjCostTransSale::find(_recId));
                break;

            case tableNum(ProjRevenueTrans):
                projTrans = ProjTrans::newProjRevenueTransSale(_buffer, ProjRevenueTransSale::find(_recId));
                break;

            case tableNum(ProjItemTrans):
                projTrans = ProjTrans::newProjItemTransSale(_buffer, ProjItemTransSale::find(_recId));
                break;

            default:
                throw error("@SYS21628");
        }

        return projTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaIndirectComponentTransCreate</Name>
				<Source><![CDATA[
    protected void psaIndirectComponentTransCreate(List  _fundingSourceList, RefRecId _dueToCompany = 0, boolean _costUseOrig = 0, ProjTransIdBase _transIdOrig = '')
    {
        this.psaIndirectComponentJournalTransCreate(_fundingSourceList, _dueToCompany, _costUseOrig, _transIdOrig, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaParmInfolog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Turn on or off the infolog
    /// </summary>
    /// <param name="_infolog">
    /// set to false if no infolog should be shown
    /// </param>
    /// <returns>
    /// the current value
    /// </returns>
    public boolean psaParmInfolog(boolean _infolog = useInfolog)
    {
        useInfolog = _infolog;

        return useInfolog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>research</Name>
				<Source><![CDATA[
    void research(Object _callerForm)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    //  Declare method public for use in cap invoicing
    public void run(Args _args)
    {
        Object                  callerForm;

        if (_args)
        {
            callerForm  = _args.caller();
        }

        try
        {
            ttsbegin;
            logPoint = infolog.num();

            if (this.checkQty())
            {
                this.updateAdjusted();
                this.post();
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            #if.never #SpeedTest
            if (speedExecute)
            {
                speedExecute.timing(SpeedInventJournalTiming::DeadLockCheckPost,journalTable.journalId);
        }
            #endif
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }

        catch (Exception::Error)
        {
            if (callerForm)
            {
                callerForm.research();
            }
            this.infoError();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTmpProjAdjustment</Name>
				<Source><![CDATA[
    //  Declare method public for use in cap invoicing
    public void setTmpProjAdjustment(TmpProjAdjustment _tmpProjAdjustment)
    {
        tmpProjAdjustment.linkPhysicalTableInstance(_tmpProjAdjustment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTmpProjAdjustmentCost</Name>
				<Source><![CDATA[
    public void setTmpProjAdjustmentCost(TmpProjAdjustmentCost _tmpProjAdjustmentCost)
    {
        tmpProjAdjustmentCost.linkPhysicalTableInstance(_tmpProjAdjustmentCost);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTmpProjAdjustmentCreate</Name>
				<Source><![CDATA[
    // Declare method public for use in cap invoicing
    public void setTmpProjAdjustmentCreate(TmpProjAdjustmentCreate _tmpProjAdjustmentCreate)
    {
        tmpProjAdjustmentCreate.linkPhysicalTableInstance(_tmpProjAdjustmentCreate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTmpProjAdjustmentCreateCost</Name>
				<Source><![CDATA[
    public void setTmpProjAdjustmentCreateCost(TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost)
    {
        tmpProjAdjustmentCreateCost.linkPhysicalTableInstance(_tmpProjAdjustmentCreateCost);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTmpProjAdjustmentCreateSale</Name>
				<Source><![CDATA[
    public void setTmpProjAdjustmentCreateSale(TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale)
    {
        tmpProjAdjustmentCreateSale.linkPhysicalTableInstance(_tmpProjAdjustmentCreateSale);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTmpProjAdjustmentSale</Name>
				<Source><![CDATA[
    public void setTmpProjAdjustmentSale(TmpProjAdjustmentSale _tmpProjAdjustmentSale)
    {
        tmpProjAdjustmentSale.linkPhysicalTableInstance(_tmpProjAdjustmentSale);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogTxt</Name>
				<Source><![CDATA[
    protected TransTxt  transactionLogTxt()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogType</Name>
				<Source><![CDATA[
    protected TransactionLogType  transactionLogType()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>transCostNew</Name>
				<Source><![CDATA[
    public void transCostNew(
        TmpProjAdjustmentCreate   _tmpProjAdjustmentCreate,
        boolean                   _reverseCommittedCost = true)
    {
        LedgerJournalTrans          ledgerJournalTrans;
        LedgerJournalTrans_Project  ledgerJournalTrans_Project;
        ProjPost                    projPostLedger;
        ProjCostTrans               projCostTransOrig;
        ProjCostTrans               projCostTransNew;
        LedgerJournalTable          ledgerJournalTable;
        // <GIN>
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtensionIN;
        // </GIN>

        ledgerJournalTrans.clear();
        ledgerJournalTrans_Project.clear();

        ledgerJournalTable = this.initLedgerJournalTableNew();
        ledgerJournalTable.insert();
        ledgerJournalTrans = this.initLedgerJournalNew(_tmpProjAdjustmentCreate);
        ledgerJournalTrans.JournalNum = ledgerJournalTable.JournalNum;
        ledgerJournalTrans_Project = this.initLedgerJournalProjectNew(_tmpProjAdjustmentCreate);

        if (LedgerParameters::isChineseVoucher_CN())
        {
            ledgerJournalTrans.createVoucherType_CN();
        }

        if (!ledgerJournalTrans.validateWrite())
        {
            throw error("@SYS21628");
        }

        ledgerJournalTrans.insert();

        // <GIN>
        if (TaxParameters::checkTaxParameters_IN() || TaxWithholdParameters_IN::checkTaxParameters())
        {
            ledgerJournalTransTaxExtensionIN = ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
            ledgerJournalTransTaxExtensionIN.SysExtensionSerializerExtensionMap::insertAfterBaseTable(ledgerJournalTrans);
        }
        // </GIN>

        ledgerJournalTrans_Project.RefRecId = ledgerJournalTrans.RecId;
        if (!ledgerJournalTrans_Project.validateWrite())
        {
            throw error("@SYS21628");
        }

        ledgerJournalTrans_Project.insert();

        projCostTransOrig = ProjCostTrans::find(_tmpProjAdjustmentCreate.TransID);
        projPostLedger  =  this.instantiateProjPostForTransCostNew(
                                                    _tmpProjAdjustmentCreate,
                                                    _reverseCommittedCost,
                                                    ledgerJournalTrans, 
                                                    projCostTransOrig);
        if (projPostLedger.checkTrans())
        {
            this.transNew_Update(projPostLedger);
        }
        else
        {
            this.initInfologAction(tmpProjAdjustment);
            checkFailed = true;
            if (this.parmPost())
            {
                throw error("@SYS18447");
            }
        }

        this.deleteLedgerJournal(ledgerJournalTrans, ledgerJournalTable);

        projCostTransNew = ProjCostTrans::find(projPostLedger.parmTransIdNew());

        while select tmpProjAdjustmentCreateCost
            where tmpProjAdjustmentCreateCost.RefRecId == _tmpProjAdjustmentCreate.RecId
        {
            this.transCostNewCost(projCostTransNew, _tmpProjAdjustmentCreate, tmpProjAdjustmentCreateCost, _reverseCommittedCost, ledgerJournalTrans.ExchRate);
        }

        while select tmpProjAdjustmentCreateSale
            where tmpProjAdjustmentCreateSale.RefRecId == _tmpProjAdjustmentCreate.RecId
        {
            this.transCostNewSale(projCostTransNew, _tmpProjAdjustmentCreate, tmpProjAdjustmentCreateSale, _reverseCommittedCost);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLedgerJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete ledger journals table records.
    /// </summary>
    /// <param name = "_ledgerJournalTrans"><c>LedgerJournalTrans</c> table buffer to be removed.</param>
    /// <param name = "_ledgerJournalTable"><c>LedgerJournalTable</c> table buffer to be removed.</param>
    protected void deleteLedgerJournal(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTable _ledgerJournalTable)
    {
        try
        {
            // We do not need to run delete for the Project record as there is a
            // cascading delete setup on LedgerJournalTrans.
        
            // Skipping the delete method for LedgerJournalTrans as this is a temp record and it doesn't need to run the delete method.
            if (_ledgerJournalTrans)
            {
                _ledgerJournalTrans.skipDeleteMethod();
                _ledgerJournalTrans.delete(false);
            }
            if (_ledgerJournalTable)
            {
                // Not skipping the delete method for LedgerJournalTable as the delete method will release the temp record number sequence.
                _ledgerJournalTable.delete();
            }
        }

        catch (Exception::Error)
        {
            throw error("@SYS21628");
        }

        catch (Exception::UpdateConflict)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateProjPostForTransCostNew</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the <c>ProjPost</c> class for the TransCostNew method.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentCreate">Record for the <c>TmpProjAdjustmentCreate</c> buffer.</param>
    /// <param name = "_reverseCommittedCost">Flag for reverse committed cost.</param>
    /// <param name = "_ledgerJournalTrans">Record for the <c>LedgerJournalTrans</c> buffer.</param>
    /// <param name = "_projCostTransOrig">Record for the <c>ProjCostTrans</c> buffer.</param>
    /// <returns>An instance of <c>ProjPost</c>.</returns>
    protected ProjPost instantiateProjPostForTransCostNew(
        TmpProjAdjustmentCreate   _tmpProjAdjustmentCreate,
        boolean                   _reverseCommittedCost,
        LedgerJournalTrans        _ledgerJournalTrans, 
        ProjCostTrans             _projCostTransOrig)
    {
        ProjPost projPostLedger  =  ProjPost::newCreateProjCostAndLedgerAdj(
                                _ledgerJournalTrans,
                                ledgerVoucher,
                                ProjCostTrans::originCost2LedgerJournalType(_tmpProjAdjustmentCreate.OriginCost),
                                _reverseCommittedCost,
                                _projCostTransOrig.TransactionOrigin);

        projPostLedger.parmAdjustment(true);
        projPostLedger.parmAdjustmentDate(this.parmAccountingDate());
        projPostLedger.parmTransIdRef(_projCostTransOrig.TransIdRef);
        projPostLedger.parmAdjRefTransId(_projCostTransOrig.TransId);
        // <GEEU>
        projPostLedger.parmAdjustCorrection(this.isAdjustmentCorrection(
                                                _tmpProjAdjustmentCreate.AdjustCorrection,
                                                tmpProjAdjustment.AdjustCorrection));
        // </GEEU>

        return projPostLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transCostNewCost</Name>
				<Source><![CDATA[
    void transCostNewCost(
        ProjCostTrans               _projCostTransNew,
        TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
        TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
        boolean                     _reverseCommittedCost,
        ExchRate                    _exchangeRate = 0
    )
    {
        ProjPost                    projPostLedger;
        ProjCostTrans               projCostTransOrig;

        projCostTransOrig = ProjCostTrans::find(_tmpProjAdjustmentCreate.TransID);

        projPostLedger  =  this.instantiateProjPostForTransCostNewCost(
                                                    _projCostTransNew,
                                                    _tmpProjAdjustmentCreate,
                                                    _tmpProjAdjustmentCreateCost,
                                                    _reverseCommittedCost,
                                                    _exchangeRate,
                                                    projCostTransOrig);

        if (ProjFlightStateHelper::isProjUseFundingLimitTrackingForAdjustmentsFlightEnabled()
            && !ProjAdjSetExpenseTransAdjStatusFlight::instance().isEnabled()
            && _tmpProjAdjustmentCreate.AdjustOrig == NoYes::Yes)
        {
            projPostLedger.parmTransStatus(ProjTransStatus::Adjusted);
        }

        if (projPostLedger.checkTrans())
        {
            this.transNew_Update(projPostLedger);
        }
        else
        {
            this.initInfologAction(tmpProjAdjustment);
            checkFailed = true;
            if (this.parmPost())
            {
                throw error("@SYS18447");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUnequalLedgerStatusCost</Name>
				<Source><![CDATA[
	/// <summary>
    /// Checks if the given ledger status for cost is same as what is 
	/// defined in the setup for the given project.
    /// </summary>
    /// <param name = "_projId">project ID.</param>
    /// <param name = "_costLedgerStatus"><c>ProjLedgerStatus</c> enum value.</param>
    /// <param name = "_projTransType"><c>ProjAdjustmentType</c> enum value to distinguish the type of transaction.</param>
    /// <returns>true if ledger status cost is different; otherwise, false.</returns>
    protected boolean checkUnequalLedgerStatusCost(ProjIdBase _projId, ProjLedgerStatus _costLedgerStatus, ProjAdjustmentType _projTransType)
    {
        
        ProjTable projTable = ProjTable::find(_projId);
        ProjLedgerStatus costLedgerStatus;

		switch (_projTransType)
        {
            case ProjAdjustmentType::Cost:
				costLedgerStatus = ProjRevRecHelper::getCostLedgerStatus(projTable);
                break;
            case ProjAdjustmentType::Item:
                costLedgerStatus = ProjRevRecHelper::getItemLedgerStatus(projTable);
                break;
            case ProjAdjustmentType::Hour:
                costLedgerStatus = ProjRevRecHelper::getEmplLedgerStatus(projTable);
                break;
            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

		return costLedgerStatus != _costLedgerStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateProjPostForTransCostNewCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the <c>ProjPost</c> class for the transCostNewCost method.
    /// </summary>
    /// <param name = "_projCostTransNew">Record for the new <c>ProjCostTrans</c> buffer.</param>
    /// <param name = "_tmpProjAdjustmentCreate">Record for the <c>TmpProjAdjustmentCreate</c> buffer.</param>
    /// <param name = "_tmpProjAdjustmentCreateCost">Record for the <c>TmpProjAdjustmentCreateCost</c> buffer.</param>
    /// <param name = "_reverseCommittedCost">Flag for reverse committed cost.</param>
    /// <param name = "_exchangeRate">The exchange rate for the <c>ProjPost</c> class.</param>
    /// <param name = "_projCostTransOrig">Record for the original <c>ProjCostTrans</c> buffer.</param>
    /// <returns>An instance of <c>ProjPost</c>.</returns>
    protected ProjPost instantiateProjPostForTransCostNewCost(
        ProjCostTrans               _projCostTransNew,
        TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
        TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
        boolean                     _reverseCommittedCost,
        ExchRate                    _exchangeRate,
        ProjCostTrans               _projCostTransOrig
        )
    {
        ProjPost projPostLedger;
        if (onlyDefaultDimensionAdjusted == ProjNoneNoYes::Yes)
        {
            RefRecId costRefRecId;
            // In case, costRefRecId = 0, we need to get the costRefRecId of the original trans - tmpProjAdjustmentCost.CostRefRecId.
            if (_tmpProjAdjustmentCreateCost.CostRefRecId)
            {
                costRefRecId = _tmpProjAdjustmentCreateCost.CostRefRecId;
            }
            else
            {
                costRefRecId = tmpProjAdjustmentCost.CostRefRecId;
            }

            ProjCostTransCost projCostTransCostOrig = ProjCostTransCost::find(costRefRecId);
            if (this.checkUnequalLedgerStatusCost(_projCostTransNew.ProjId, projCostTransCostOrig.LedgerStatusCost, ProjAdjustmentType::Cost))
            {
                projPostLedger = projPost::newCreateProjCostAndLedgerCostAdjForBalance(
                                    _projCostTransNew,
                                    _tmpProjAdjustmentCreateCost,
                                    ledgerVoucher,
                                    ProjCostTrans::originCost2LedgerJournalType(_tmpProjAdjustmentCreate.OriginCost),
                                    projCostTransCostOrig.LedgerStatusCost,
                                    _projCostTransOrig.TransactionOrigin);
            }
            else
            {
                projPostLedger = ProjPost::newCreateProjCostAndLedgerCost(
                                    _projCostTransNew,
                                    _tmpProjAdjustmentCreateCost,
                                    ledgerVoucher,
                                    ProjCostTrans::originCost2LedgerJournalType(_tmpProjAdjustmentCreate.OriginCost),
                                    _reverseCommittedCost,
                                    _projCostTransOrig.TransactionOrigin);
            }
        }
	    else
	    {
		    projPostLedger = ProjPost::newCreateProjCostAndLedgerCost(
									_projCostTransNew,
									_tmpProjAdjustmentCreateCost,
									ledgerVoucher,
									ProjCostTrans::originCost2LedgerJournalType(_tmpProjAdjustmentCreate.OriginCost),
									_reverseCommittedCost,
									_projCostTransOrig.TransactionOrigin);
	    }

		projPostLedger.parmAdjustment(true);
		// <GEEU>
		projPostLedger.parmAdjustCorrection(this.isAdjustmentCorrection(
												_tmpProjAdjustmentCreate.AdjustCorrection,
												tmpProjAdjustment.AdjustCorrection));
		// </GEEU>
		projPostLedger.parmAdjustmentDate(this.parmAccountingDate());
		projPostLedger.parmTransIdRef(_projCostTransOrig.TransIdRef);
		projPostLedger.parmAdjRefTransId(_projCostTransOrig.TransId);
		projPostLedger.parmTransIdOrig(_projCostTransOrig.TransId);
		projPostLedger.parmExchangeRate(_exchangeRate);

        if (ProjAdjustmentUpdateOverrideReportingExchRateFlight::instance().isEnabled())
        {
            ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curExt()).RecId), projPostLedger.currencyIdCost(), _projCostTransOrig.TransDate);
            exchangeRateHelper.parmToCurrency(Ledger::reportingCurrency());
            exchangeRateHelper.parmExchangeRateTypeRecId(Ledger::reportingCurrencyExchangeRateType());
            projPostLedger.parmReportingExchangeRate(exchangeRateHelper.getExchangeRate1());
        }

        // Reversal of original transaction needs to be set to adjusted only if original transaction is in adjusted state
        if (ProjAdjSetExpenseTransAdjStatusFlight::instance().isEnabled()
            && _tmpProjAdjustmentCreate.AdjustOrig == NoYes::Yes
            && this.adjustStatus() == ProjTransStatus::Adjusted)
        {
            projPostLedger.parmTransStatus(ProjTransStatus::Adjusted);
        }
        
		return projPostLedger;
	}

]]></Source>
			</Method>
			<Method>
				<Name>transCostNewSale</Name>
				<Source><![CDATA[
    void transCostNewSale(
    ProjCostTrans               _projCostTransNew,
    TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
    TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale,
    boolean                     _reverseCommittedCost
)
    {
        ProjPost                    projPostLedger;
        ProjCostTrans               projCostTransOrig;

        projCostTransOrig = ProjCostTrans::find(_tmpProjAdjustmentCreate.TransID);

        projPostLedger  =  this.instantiateProjPostForTransCostNewSale(
                                                    _projCostTransNew,
                                                    _tmpProjAdjustmentCreate,
                                                    _tmpProjAdjustmentCreateSale,
                                                    _reverseCommittedCost,
                                                    projCostTransOrig);

        if (ProjFlightStateHelper::isProjUseFundingLimitTrackingForAdjustmentsFlightEnabled()
            && !ProjAdjSetExpenseTransAdjStatusFlight::instance().isEnabled()
            && _tmpProjAdjustmentCreate.AdjustOrig == NoYes::Yes)
        {
            projPostLedger.parmTransStatus(ProjTransStatus::Adjusted);
        }
 
        if (projPostLedger.checkTrans())
        {
            this.transNew_Update(projPostLedger);
        }
        else
        {
            this.initInfologAction(tmpProjAdjustment);
            checkFailed = true;
            if (this.parmPost())
            {
                throw error("@SYS18447");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateProjPostForTransCostNewSale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the <c>ProjPost</c> class for the transCostNewSale method.
    /// </summary>
    /// <param name = "_projCostTransNew">Record for the new <c>ProjCostTrans</c> buffer.</param>
    /// <param name = "_tmpProjAdjustmentCreate">Record for the <c>TmpProjAdjustmentCreate</c> buffer.</param>
    /// <param name = "_tmpProjAdjustmentCreateSale">Record for the <c>TmpProjAdjustmentCreateSale</c> buffer.</param>
    /// <param name = "_reverseCommittedCost">Flag for reverse committed cost.</param>
    /// <param name = "_projCostTransOrig">Record for the original <c>ProjCostTrans</c> buffer.</param>
    /// <returns>An instance of <c>ProjPost</c>.</returns>
    protected ProjPost instantiateProjPostForTransCostNewSale(
        ProjCostTrans               _projCostTransNew,
        TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
        TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale,
        boolean                     _reverseCommittedCost,
        ProjCostTrans               _projCostTransOrig
        )
    {
        ProjPost projPostLedger  =  ProjPost::newCreateProjCostAndLedgerSale(
                            _projCostTransNew,
                            _tmpProjAdjustmentCreateSale,
                            ledgerVoucher,
                            ProjCostTrans::originCost2LedgerJournalType(_tmpProjAdjustmentCreate.OriginCost),
                            _reverseCommittedCost,
                            _projCostTransOrig.TransactionOrigin);

        projPostLedger.parmAdjustment(true);
        // <GEEU>
        projPostLedger.parmAdjustCorrection(this.isAdjustmentCorrection(_tmpProjAdjustmentCreate.AdjustCorrection,
                                                                        tmpProjAdjustment.AdjustCorrection));
        // </GEEU>
        projPostLedger.parmAdjustmentDate(this.parmAccountingDate());
        projPostLedger.parmTransIdRef(_projCostTransOrig.TransIdRef);
        projPostLedger.parmAdjRefTransId(_projCostTransOrig.TransId);

        // Reversal of original transaction needs to be set to adjusted only if original transaction is in adjusted state
        if (ProjAdjSetExpenseTransAdjStatusFlight::instance().isEnabled()
            && _tmpProjAdjustmentCreate.AdjustOrig == NoYes::Yes 
            && this.adjustStatus() == ProjTransStatus::Adjusted)
        {
            projPostLedger.parmTransStatus(ProjTransStatus::Adjusted);
        }

        return projPostLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transEmplNew</Name>
				<Source><![CDATA[
    void transEmplNew(
        TmpProjAdjustmentCreate  _tmpProjAdjustmentCreate)
    {
        ProjPost        projPostJournal;
        ProjEmplTrans   projEmplTransOrig;
        ProjEmplTrans   projEmplTransNew;
        container       splitTransQtyCon;
        List fundingSourceList;
        boolean         costUseOrig;
        ProjEmplTransCost   projEmplTransCostOrig;
        boolean         salesUseOrig;

       
        lineNum++;
        this.journalTransInsert(_tmpProjAdjustmentCreate);

        if (journalTrans)
        {
            projEmplTransOrig = ProjEmplTrans::find(_tmpProjAdjustmentCreate.TransID);
            projPostJournal = this.instantiateProjPostForTransEmplNew(_tmpProjAdjustmentCreate, projEmplTransOrig);

            if (projPostJournal.checkTrans())
            {
                this.transNew_Update(projPostJournal);
            }
            else
            {
                this.initInfologAction(tmpProjAdjustment);
                checkFailed = true;
                if (this.parmPost())
                {
                    throw error("@SYS18447");
                }
            }

            if (this.mustDeleteJournalTransaction())
            {
                journalTrans.delete();
            }

            projEmplTransNew = ProjEmplTrans::find(projPostJournal.parmTransIdNew());

            splitTransQtyCon = ProjFundingEngine::distributeQty(this.fundingSourceList(_tmpProjAdjustmentCreate), _tmpProjAdjustmentCreate.Qty).pack();


            if (_tmpProjAdjustmentCreate.AdjustOrig)
            {
                costUseOrig = true;
                salesUseOrig = true;
            }

            while select tmpProjAdjustmentCreateCost
                where tmpProjAdjustmentCreateCost.RefRecId == _tmpProjAdjustmentCreate.RecId
            {
                this.transEmplNewCost(projEmplTransNew, _tmpProjAdjustmentCreate, tmpProjAdjustmentCreateCost, splitTransQtyCon);
            }

            while select tmpProjAdjustmentCreateSale
                where tmpProjAdjustmentCreateSale.RefRecId == _tmpProjAdjustmentCreate.RecId
            {
                this.transEmplNewSale(projEmplTransNew, _tmpProjAdjustmentCreate, tmpProjAdjustmentCreateSale, splitTransQtyCon);
            }
            if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
            {
                if (isConfigurationkeyEnabled(configurationKeyNum(Project)) && _tmpProjAdjustmentCreate.psaProjOrigTransId)
                {
                    select sum(CostPrice) from tmpProjAdjustmentCreateCost
                        where _tmpProjAdjustmentCreate.RecId == tmpProjAdjustmentCreateCost.RefRecId;

                    select sum(SalesPrice) from tmpProjAdjustmentCreateSale
                        where _tmpProjAdjustmentCreate.RecId == tmpProjAdjustmentCreateSale.RefRecId;

                    journalTrans.CostPrice  = tmpProjAdjustmentCreateCost.CostPrice;
                    journalTrans.SalesPrice = tmpProjAdjustmentCreateSale.SalesPrice;
                }

                //create the fundingsourcelist to split indirect costs between funding sources
                fundingSourceList=this.createContractFundingAllocationList(_tmpProjAdjustmentCreate);
                if (ResourceFacade::getLegalEntity(projEmplTransOrig.Resource) != CompanyInfo::current())
                {
                    this.psaIndirectComponentJournalTransCreate(fundingSourceList, ResourceFacade::getLegalEntity(projEmplTransOrig.Resource), costUseOrig, tmpProjAdjustmentCreate.TransID, salesUseOrig);
                }
                else
                {
                    this.psaIndirectComponentJournalTransCreate(fundingSourceList, 0, costUseOrig, tmpProjAdjustmentCreate.TransID, salesUseOrig);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateProjPostForTransEmplNew</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the <c>ProjPost</c> class for the transEmplNew method.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentCreate">Record for the <c>TmpProjAdjustmentCreate</c> buffer.</param>
    /// <param name = "_projEmplTransOrig">Record for the original <c>ProjEmplTrans</c> buffer.</param>
    /// <returns>An instance of <c>ProjPost</c>.</returns>
    protected ProjPost instantiateProjPostForTransEmplNew(TmpProjAdjustmentCreate  _tmpProjAdjustmentCreate, ProjEmplTrans _projEmplTransOrig)
    {
        ProjPost        projPostJournal;

        if (_tmpProjAdjustmentCreate.AdjustOrig == NoYes::Yes)
        {
            if (this.adjustStatus() == ProjTransStatus::Adjusted)
            {
                // create new negative projEmplTrans
                projPostJournal     = ProjPost::newTransAdjNegativeJournal(
                                                                journalTrans,
                                                                ledgerVoucher,
                                                                _projEmplTransOrig.TransId,
                                                                _projEmplTransOrig.TransactionOrigin);

                if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                {
                    journalTrans.PSAIndirectComponentGroup = _projEmplTransOrig.PSAIndirectComponentGroup;
                }
            }
            else if (this.adjustStatus() == ProjTransStatus::Posted)
            {
                projPostJournal = ProjPost::newCreateProjTransAndLedgerAdj(journalTrans, ledgerVoucher, _projEmplTransOrig.TransactionOrigin,false);
                projPostJournal.parmTransIdOrig(_projEmplTransOrig.TransId);
            }
            // <GEEU>
            projPostJournal.parmAdjustCorrection(this.isAdjustmentCorrection(_tmpProjAdjustmentCreate.AdjustCorrection,
                                                                                    tmpProjAdjustment.AdjustCorrection,
                                                                                    true));
            // </GEEU>
        }
        else
        {
            projPostJournal = ProjPost::newCreateProjTransAndLedgerAdj(journalTrans, ledgerVoucher, _projEmplTransOrig.TransactionOrigin,true);
            // <GEEU>
            projPostJournal.parmAdjustCorrection(this.isAdjustmentCorrection(_tmpProjAdjustmentCreate.AdjustCorrection,
                                                                                    tmpProjAdjustment.AdjustCorrection));
            // </GEEU>
        }

        this.updateProjPostJournal(projPostJournal, _projEmplTransOrig, _tmpProjAdjustmentCreate);

        if (projPostJournal is ProjPostEmplJournal && ResourceFacade::getLegalEntity(_projEmplTransOrig.Resource) != CompanyInfo::current())
        {
            ProjPostEmplJournal  projPostEmplJournal = projPostJournal as ProjPostEmplJournal;

            projPostEmplJournal.parmIntercompanyDueToCompany(ResourceFacade::getLegalEntity(_projEmplTransOrig.Resource));
        }

        return projPostJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDeleteJournalTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the project journal transaction must be deleted
    /// </summary>
    /// <returns>true if the transaction must be deleted; otherwise, false.</returns>
    protected boolean mustDeleteJournalTransaction()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transEmplNewCost</Name>
				<Source><![CDATA[
    void transEmplNewCost(
    ProjEmplTrans               _projEmplTransNew,
    TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
    TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
    container                   _splitTransQtyCon
)
    {
        ProjEmplTrans projEmplTransOrig = ProjEmplTrans::find(_tmpProjAdjustmentCreate.TransID);
        ProjPost      projPostJournal = this.instantiateProjPostForTransEmplNewCost(
                                                                        _projEmplTransNew,
                                                                        _tmpProjAdjustmentCreate,
                                                                        _tmpProjAdjustmentCreateCost,
                                                                        _splitTransQtyCon,
                                                                         projEmplTransOrig);

        if (projPostJournal.checkTrans())
        {
            this.transNew_Update(projPostJournal);
        }
        else
        {
            this.initInfologAction(tmpProjAdjustment);
            checkFailed = true;
            if (this.parmPost())
            {
                throw error("@SYS18447");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateProjPostForTransEmplNewCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the <c>ProjPost</c> class for the transEmplNewCost method.
    /// </summary>
    /// <param name = "_projEmplTransNew">Record for the new <c>ProjEmplTrans</c> buffer.</param>
    /// <param name = "_tmpProjAdjustmentCreate">Record for the <c>TmpProjAdjustmentCreate</c> buffer.</param>
    /// <param name = "_tmpProjAdjustmentCreateCost">Record for the <c>TmpProjAdjustmentCreateCost</c> buffer.</param>
    /// <param name = "_splitTransQtyCon">A container of a packed map that contains the founding sources.</param>
    /// <param name = "_projEmplTransOrig">Record for the original <c>ProjEmplTrans</c> buffer.</param>
    /// <returns>An instance of <c>ProjPost</c>.</returns>
    protected ProjPost instantiateProjPostForTransEmplNewCost(
            ProjEmplTrans               _projEmplTransNew,
            TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
            TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
            container                   _splitTransQtyCon,
            ProjEmplTrans               _projEmplTransOrig)
    {
        ProjPost            projPostJournal;
        ProjEmplTransCost   projEmplTransCostOrig = ProjEmplTransCost::find(_tmpProjAdjustmentCreateCost.CostRefRecId, true);
        boolean             enterCost;
        ProjPostEmplJournal  projPostEmplJournal;

        if (_tmpProjAdjustmentCreate.AdjustOrig == NoYes::Yes)
        {
            if (this.adjustStatus() == ProjTransStatus::Adjusted)
            {
                enterCost = ((projEmplTransCostOrig.LedgerStatusCost == ProjLedgerStatus::BalanceSheet) ||
                                   (projEmplTransCostOrig.LedgerStatusCost == ProjLedgerStatus::Operations)) ? true : false;

                // create new negative projEmplTransCost
                projPostJournal     = ProjPost::newTransAdjNegativeJournalCost(
                                                        _projEmplTransNew,
                                                        _tmpProjAdjustmentCreateCost,
                                                        ledgerVoucher,
                                                        enterCost,
                                                        projEmplTransCostOrig.LedgerStatusCost,
                                                        _projEmplTransOrig.TransId,
                                                        _projEmplTransOrig.TransactionOrigin);
            }
            else if (this.adjustStatus() == ProjTransStatus::Posted)
            {
                projPostJournal = ProjPost::newCreateProjTransAndLedgerAdjCost(
                                                        _projEmplTransNew,
                                                        _tmpProjAdjustmentCreateCost,
                                                        ledgerVoucher,
                                                        _projEmplTransOrig.TransactionOrigin,
                                                        false);
                projPostJournal.parmTransIdOrig(_projEmplTransOrig.TransId);
            }
            // <GEEU>
            projPostJournal.parmAdjustCorrection(this.isAdjustmentCorrection(_tmpProjAdjustmentCreate.AdjustCorrection,
                                                                            tmpProjAdjustment.AdjustCorrection,
                                                                            true));
            // </GEEU>
        }
        else
        {
            projPostJournal = ProjPost::newCreateProjTransAndLedgerAdjCost(
                                                    _projEmplTransNew,
                                                    _tmpProjAdjustmentCreateCost,
                                                    ledgerVoucher,
                                                    _projEmplTransOrig.TransactionOrigin,
                                                    true);
            // <GEEU>
            projPostJournal.parmAdjustCorrection(this.isAdjustmentCorrection(_tmpProjAdjustmentCreate.AdjustCorrection,
                                                                            tmpProjAdjustment.AdjustCorrection));
            // </GEEU>
        }

        boolean checkUnequalLedgerStatusCost = this.checkUnequalLedgerStatusCost(_projEmplTransNew.ProjId,
                                                                                 projEmplTransCostOrig.LedgerStatusCost,
                                                                                 ProjAdjustmentType::Hour);
        // When financial dimensions is the 'only' field adjusted and when 
        // ledger status cost of the original posted transaction is different from the newly adjusted one,
        // we need to honour the LedgerStatusCost of the original transaction.
        if (checkUnequalLedgerStatusCost
            && onlyDefaultDimensionAdjusted == ProjNoneNoYes::Yes)
        {
            projPostJournal.parmLedgerStatusCost(projEmplTransCostOrig.LedgerStatusCost);
            projPostJournal.parmLedgerStatusCostOrig(true);
        }

        this.updateProjPostJournal(projPostJournal, _projEmplTransOrig, _tmpProjAdjustmentCreate);
        projPostJournal.parmSplitTransQtyCon(_splitTransQtyCon);

        if (projPostJournal is ProjPostEmplJournal && ResourceFacade::getLegalEntity(_projEmplTransOrig.Resource) != CompanyInfo::current())
        {
            projPostEmplJournal = projPostJournal as ProjPostEmplJournal;

            projPostEmplJournal.parmIntercompanyDueToCompany(ResourceFacade::getLegalEntity(_projEmplTransOrig.Resource));
        }
        return projPostJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transEmplNewSale</Name>
				<Source><![CDATA[
    void transEmplNewSale(
    ProjEmplTrans               _projEmplTransNew,
    TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
    TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale,
    container                   _splitTransQtyCon
)
    {
        ProjEmplTrans projEmplTransOrig = ProjEmplTrans::find(_tmpProjAdjustmentCreate.TransID);
        ProjPost      projPostJournal = this.instantiateProjPostForTransEmplNewSale(
                                                                        _projEmplTransNew,
                                                                        _tmpProjAdjustmentCreate,
                                                                        _tmpProjAdjustmentCreateSale,
                                                                        _splitTransQtyCon,
                                                                         projEmplTransOrig);


        if (projPostJournal.checkTrans())
        {
            this.transNew_Update(projPostJournal);
        }
        else
        {
            this.initInfologAction(tmpProjAdjustment);
            checkFailed = true;
            if (this.parmPost())
            {
                throw error("@SYS18447");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateProjPostForTransEmplNewSale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the <c>ProjPost</c> class for the transEmplNewSale method.
    /// </summary>
    /// <param name = "_projEmplTransNew">Record for the new <c>ProjEmplTrans</c> buffer.</param>
    /// <param name = "_tmpProjAdjustmentCreate">Record for the <c>TmpProjAdjustmentCreate</c> buffer.</param>
    /// <param name = "_tmpProjAdjustmentCreateSale">Record for the <c>TmpProjAdjustmentCreateSale</c> buffer.</param>
    /// <param name = "_splitTransQtyCon">A container of a packed map that contains the founding sources.</param>
    /// <param name = "_projEmplTransOrig">Record for the original <c>ProjEmplTrans</c> buffer.</param>
    /// <returns>An instance of <c>ProjPost</c>.</returns>
    protected ProjPost instantiateProjPostForTransEmplNewSale(
            ProjEmplTrans               _projEmplTransNew,
            TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
            TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale,
            container                   _splitTransQtyCon,
            ProjEmplTrans               _projEmplTransOrig)
    {
        ProjPost            projPostJournal;
        ProjEmplTransSale   projEmplTransSaleOrig;

        if (_tmpProjAdjustmentCreate.AdjustOrig == NoYes::Yes)
        {
            if (this.adjustStatus() == ProjTransStatus::Adjusted)
            {
                projEmplTransSaleOrig = ProjEmplTransSale::find(_tmpProjAdjustmentCreateSale.SaleRefRecId, true);

                // create new negative projRevenueTransSale
                projPostJournal     = ProjPost::newTransAdjNegativeJournalSale(
                                                        _projEmplTransNew,
                                                        _tmpProjAdjustmentCreateSale,
                                                        ledgerVoucher,
                                                        projEmplTransSaleOrig.LedgerSalesPosted,
                                                        projEmplTransSaleOrig.LedgerSalesAmount,
                                                        projEmplTransSaleOrig.LineAmount,
                                                        _projEmplTransOrig.TransId,
                                                        _projEmplTransOrig.TransactionOrigin);
            }
            else if (this.adjustStatus() == ProjTransStatus::Posted)
            {
                projPostJournal = ProjPost::newCreateProjTransAndLedgerAdjSale(
                                                    _projEmplTransNew,
                                                    _tmpProjAdjustmentCreateSale,
                                                    ledgerVoucher,
                                                    _projEmplTransOrig.TransactionOrigin,
                                                    false);
                projPostJournal.parmTransIdOrig(_projEmplTransOrig.TransId);
            }
            // <GEEU>
            projPostJournal.parmAdjustCorrection(this.isAdjustmentCorrection(_tmpProjAdjustmentCreate.AdjustCorrection,
                                                                            tmpProjAdjustment.AdjustCorrection,
                                                                            true));
            // </GEEU>
        }
        else
        {
            projPostJournal = ProjPost::newCreateProjTransAndLedgerAdjSale(
                                                    _projEmplTransNew,
                                                    _tmpProjAdjustmentCreateSale,
                                                    ledgerVoucher,
                                                    _projEmplTransOrig.TransactionOrigin,
                                                    true);
            // <GEEU>
            projPostJournal.parmAdjustCorrection(this.isAdjustmentCorrection(_tmpProjAdjustmentCreate.AdjustCorrection,
                                                                            tmpProjAdjustment.AdjustCorrection));
            // </GEEU>
        }

        this.updateProjPostJournal(projPostJournal, _projEmplTransOrig, _tmpProjAdjustmentCreate);
        projPostJournal.parmSplitTransQtyCon(_splitTransQtyCon);

        if (projPostJournal is ProjPostEmplJournal && ResourceFacade::getLegalEntity(_projEmplTransOrig.Resource) != CompanyInfo::current())
        {
            ProjPostEmplJournal projPostEmplJournal = projPostJournal as ProjPostEmplJournal;

            projPostEmplJournal.parmIntercompanyDueToCompany(ResourceFacade::getLegalEntity(_projEmplTransOrig.Resource));
        }
        return projPostJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transItemNew</Name>
				<Source><![CDATA[
    void transItemNew(
    TmpProjAdjustmentCreate   _tmpProjAdjustmentCreate)
    {
        MapIterator             mi;

        ProjItemTrans           projItemTrans;

        ProjPost                projPostItem;
        InventTrans             inventTrans;
        InventQty               inventQty, projTransQty, projTransQtyOrig;
        InventQty               markQty;
        boolean                 readInventTrans = true;
        CostAmount              costAmount, projCostAmountOrig;
        CostAmount              transCostAmount;
        ProjAdjustRefId         projAdjustRefIdOrig;
        InventTransId           inventTransIdOrig;
        Map                     fundingSourceMap = new Map( Types::Int64,Types::Real );
        ProjLedger              projLedger;
        ProjItemTrans           projItemTransOrig;

        // Record InventTrans from inventTransMapOrig which has been processed totally.
        Set                     inventTransSet = new Set(Types::Int64);
        SetEnumerator           se;
        boolean                 isStocked = ProjItemTrans::isStocked(_tmpProjAdjustmentCreate.InventTransId);
        List                    fundingSourceList;
        // <GEEU>
        Correct                 isAdjustmentCorrection;
        

        #ISOCountryRegionCodes

        boolean                 countryRegion_EU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL, #isoCZ, #isoHU, #isoLT, #isoLV, #isoEE]);
        // </GEEU>

        void initFundingSourceList()
        {
            ProjSplitAllocation         allocation;
            boolean                     firstRecord = true;

            fundingSourceList = new List(Types::Class);

            while select tmpProjAdjustmentCreateCost
            where tmpProjAdjustmentCreateCost.RefRecId == _tmpProjAdjustmentCreate.RecId
            {
                if (_tmpProjAdjustmentCreate.TotalCostAmountCur != 0.00)
                {
                    allocation = ProjSplitAllocation::construct(tmpProjAdjustmentCreateCost.FundingSource,
                                                            (tmpProjAdjustmentCreateCost.LineAmount / _tmpProjAdjustmentCreate.TotalCostAmountCur) * 100,
                                                            0,
                                                            firstRecord ? NoYes::Yes : NoYes::No );
                }
                else
                {
                    allocation = ProjSplitAllocation::construct(tmpProjAdjustmentCreateCost.FundingSource,
                                                            100,
                                                            0,
                                                            firstRecord ? NoYes::Yes : NoYes::No );
                }
                fundingSourceList.addEnd(allocation);
                firstRecord = false;
            }
        }

        lineNum++;

        //  create the new transaction with no ledger posting
        projPostItem = this.instantiateProjPostForTransItemNewWithNoLedgerPosting(_tmpProjAdjustmentCreate);

        if (!projPostItem.checkTrans())
        {
            this.initInfologAction(tmpProjAdjustment);
            checkFailed = true;
            if (this.parmPost())
            {
                throw error("@SYS18447");
            }
        }

        projPostItem.parmAdjustment(true);
        // <GEEU>
        if (countryRegion_EU)
        {
            isAdjustmentCorrection = this.isAdjustmentCorrection(_tmpProjAdjustmentCreate.AdjustCorrection, tmpProjAdjustment.AdjustCorrection);
            projPostItem.parmAdjustCorrection(isAdjustmentCorrection);
        }
        // </GEEU>

        projPostItem.parmAdjRefTransId(_tmpProjAdjustmentCreate.TransID);
        if (!isStocked)
        {
            projPostItem.parmAdjustRefId(NumberSeq::newGetNum(CompanyInfo::numRefParmId()).num());
        }

        projPostItem.postTrans();

        projItemTrans       = projPostItem.newTrans();

        if (isStocked)
        {
            projTransQty = this.convertProjTransQtyForTransItemNew(projItemTrans, NoYes::Yes);

            // Old behavior behind <c>ProjAllowAdjustmentOfReturnedItemTransFlight</c>
            // Can cause inventory on-hand inconsistency if enabled
            if (ProjAllowAdjustmentOfReturnedItemTransFlight::instance().isEnabled())
            {
                inventTransIdOrig = ProjItemTrans::find(projItemTrans.ProjTransIdRef).InventTransId;

                // Reducing quantity based on inventory transactions for WHS item which are not marked as reference for project transaction.
                if (inventTransIdOrig)
                {
                    InventTrans inventTransOrig;
                    InventTransOrigin inventTransOriginOrig;
                    WHSWorkTable workTable;
                    SalesLine salesLine;

                    select sum(qty) from inventTransOrig
                        exists join inventTransOriginOrig
                            where inventTransOriginOrig.RecId == inventTransOrig.InventTransOrigin
                            && inventTransOriginOrig.InventTransId == inventTransIdOrig
                            && !inventTransOrig.MarkingRefInventTransOrigin
                        exists join salesLine
                            where inventTransOriginOrig.InventTransId == salesLine.InventTransId
                        exists join workTable
                            where workTable.OrderNum == salesLine.SalesId;

                    if (inventTransOrig.Qty)
                    {
                        projTransQty += inventTransOrig.Qty;
                    }
                }
            }

            projTransQtyOrig = this.convertProjTransQtyOrigForTransItemNew(tmpProjAdjustment, NoYes::Yes);

            projCostAmountOrig  = ProjItemTrans::costAmountTotalStatic(
                                tmpProjAdjustment.InventTransId,
                                tmpProjAdjustment.ProjAdjustRefid);

            mi = new MapIterator(inventTransMapOrig);
            mi.begin();

            // For equally distributed adjusted transactions, system should processed as per number of element in Map.
            // Map iterator next() method should execute only when more then one element exists in map to avoid "value cannot be null" error.
            if (!first && inventTransMapOrig.elements() == 1)
            {
                first = true;
            }

            //  inventTrans had more in qty than earlier project transaction needed
            //  "old" inventTrans is read again
            if (remainQty)
            {
                inventQty   = remainQty;
                inventTrans = inventTransMapOrig.lookup(mi.key());
            }

            while (readInventTrans)
            {
                if (! remainQty)
                {
                    if (! (inventQty || first))
                    {
                        mi.next();
                    }

                    inventTrans     = inventTransMapOrig.lookup(mi.key());
                    inventQty       = -inventTrans.Qty;
                    remainQty       = -inventTrans.Qty;
                }

                [inventQty, projTransQty, readInventTrans] = this.inventQty(inventQty, projTransQty);

                // Record InventTrans from inventTransMapOrig to be removed when its qty has been covered totally by projTransQty
                // in order to avoide this inventTrans will be processed duplicately for splited projItemTrans.
                if (!remainQty)
                {
                    inventTransSet.add(inventTrans.RecId);
                }

                inventRemainQty     = inventRemainQty - inventQty;

                // costAmount = qty updated on stock * total posted on orig transaction / qty on orig transaction
                if (inventRemainQty == 0)
                {
                    costAmount = CurrencyExchangeHelper::amount(projCostAmountOrig - inventUsedCost);
                }
                else
                {
                    costAmount = CurrencyExchangeHelper::amount(inventQty * projCostAmountOrig / projTransQtyOrig);
                }

                inventUsedCost += costAmount;

                markQty = 0;

                if (this.parmInventRefTransIdOrig())
                {
                    projItemTransOrig = ProjItemTrans::find(_tmpProjAdjustmentCreate.TransID);
                    if (projItemTransOrig && projItemTransOrig.VendInvoiceTransRecId)
                    {
                        VendInvoiceTrans vendInvoiceTrans = VendInvoiceTrans::findRecId(projItemTransOrig.VendInvoiceTransRecId);
                        SysTransactionScopeCache::set(classStr(ProjAdjustmentUpdate), inventTrans.InventTransOrigin, vendInvoiceTrans.invoiceId);
                        markQty = InventTransOrigin::deleteMarking(InventTransOrigin::findByInventTransId(this.parmInventRefTransIdOrig()).RecId,
                                                            inventTrans.InventTransOrigin, inventQty,
                                                            true, null, null, false,
                                                            false, 0, new PmfQtyDataCarrier(), false, SortOrder::Descending);
                        SysTransactionScopeCache::remove(classStr(ProjAdjustmentUpdate), inventTrans.InventTransOrigin);
                    }
                    else
                    {
                        markQty = InventTransOrigin::deleteMarking(InventTransOrigin::findByInventTransId(this.parmInventRefTransIdOrig()).RecId,
                                                                    inventTrans.InventTransOrigin, inventQty,
                                                                    true, null, null, false,
                                                                    false, 0, new PmfQtyDataCarrier(), false, SortOrder::Descending);
                    }
                }

                InventMov_ProjItemTrans invent_Mov = this.instantiateInventMov_ProjItemTransForTransItemNew(projItemTrans, inventTrans, inventQty, costAmount);

                // <GEEU>
                if (countryRegion_EU)
                {
                    invent_Mov.parmProjAdjustCorrection(isAdjustmentCorrection);
                }
                // </GEEU>

                // In case the original transaction that is being adjusted is just physically inventory posted
                // The new transaction should also be physically inventory posted
                if (!inventoryFinancialPosted
                    && projItemTrans.TransactionOrigin == ProjOrigin::ItemRequirement)
                {
                    invent_Mov.parmInventoryPhysicalPostingRequired(true);
                    InventUpd_Physical physical = InventUpd_Physical::newAdjustProjItemTrans(invent_Mov, projItemTrans);
                    physical.updateNow(ledgerVoucher);
                }
                else
                {
                    InventUpd_Financial::newAdjustProjItemTrans(invent_Mov, ledgerVoucher, -costAmount).updateNow();
                }

                projItemTrans.ProjAdjustRefId   = invent_Mov.projAdjustRefId();
                projItemTrans.update();

                inventTransMapNew = this.insertInventTransMap(inventTrans.InventTransOrigin, inventTrans.ProjAdjustRefId);

                if (readInventTrans)
                {
                    mi.next();
                }
            }

            se = inventTransSet.getEnumerator();
            while (se.moveNext())
            {
                inventTransMapOrig.remove(se.current());
            }
        }

        // Move new transaction to balance sheet and post turnover
        projAdjustRefIdOrig                         = _tmpProjAdjustmentCreate.ProjAdjustRefId;
        inventTransIdOrig                           = _tmpProjAdjustmentCreate.InventTransId;

        _tmpProjAdjustmentCreate.ProjAdjustRefId    = projItemTrans.ProjAdjustRefId;
        _tmpProjAdjustmentCreate.InventTransId      = projItemTrans.InventTransId;

        if (isStocked)
        {
            initFundingSourceList();
            projPostItem = this.postTransItemCostStocked(_tmpProjAdjustmentCreate, fundingSourceList, isAdjustmentCorrection, countryRegion_EU);
            if (!inventoryFinancialPosted
                && projItemTrans.TransactionOrigin == ProjOrigin::ItemRequirement)
            {
                projPostItem.parmPostItemPhysically(true);
            }
        }

        if (ProjTable::find(_tmpProjAdjustmentCreate.ProjId).UseBudgeting)
        {
            projPostItem.budgetUpdate();
        }

        while select tmpProjAdjustmentCreateCost
        where tmpProjAdjustmentCreateCost.RefRecId == _tmpProjAdjustmentCreate.RecId
        {
            if (tmpProjAdjustmentCreateCost.FundingSource)
            {
                fundingSourceMap.insert(tmpProjAdjustmentCreateCost.FundingSource, CurrencyExchangeHelper::amount(tmpProjAdjustmentCreateCost.CostPrice * _tmpProjAdjustmentCreate.Qty, _tmpProjAdjustmentCreate.CurrencyIdCost));
                transCostAmount += CurrencyExchangeHelper::amount(tmpProjAdjustmentCreateCost.CostPrice * _tmpProjAdjustmentCreate.Qty, _tmpProjAdjustmentCreate.CurrencyIdCost);
            }

            if (!isStocked)
            {
                projItemTransOrig = ProjItemTrans::find(_tmpProjAdjustmentCreate.TransID);

                projPostItem = ProjPost::newTransAdjNotStockedCost(
                                                        projItemTrans,
                                                        tmpProjAdjustmentCreateCost,
                                                        ledgerVoucher,
                                                        projItemTransOrig.TransactionOrigin,
                                                        true);

                ProjItemTransCost projItemTransCostOrig = ProjItemTransCost::findRecId(tmpProjAdjustmentCreateCost.CostRefRecId);
                if (this.parmOnlyDefaultDimAdjusted() == ProjNoneNoYes::Yes &&
                    this.checkUnequalLedgerStatusCost(_tmpProjAdjustmentCreate.ProjId,projItemTransCostOrig.LedgerStatusCost,ProjAdjustmentType::Item))
                {
                    projPostItem.parmLedgerStatusCost(projItemTransCostOrig.LedgerStatusCost);
                    projPostItem.parmLedgerStatusCostOrig(true);
                }
                projPostItem.parmAdjustmentDate(_tmpProjAdjustmentCreate.Transdate);
                projPostItem.parmAdjustment(true);
                // <GEEU>
                if (countryRegion_EU)
                {
                    projPostItem.parmAdjustCorrection(isAdjustmentCorrection);
                }
                // </GEEU>
                projPostItem.parmAdjustmentDate(tmpProjAdjustment.TransDateAdjustment);
                projPostItem.parmTransIdRef(projItemTransOrig.ProjTransIdRef);
                projPostItem.parmAdjRefTransId(projItemTransOrig.ProjTransId);
                projPostItem.parmExchangeRate(ExchangeRateHelper::exchRate(projPostItem.currencyIdCost(), projItemTransOrig.TransDate));

                if (ProjAdjustmentUpdateOverrideReportingExchRateFlight::instance().isEnabled())
                {
                    ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curExt()).RecId), projPostItem.currencyIdCost(), projItemTransOrig.TransDate);
                    exchangeRateHelper.parmToCurrency(Ledger::reportingCurrency());
                    exchangeRateHelper.parmExchangeRateTypeRecId(Ledger::reportingCurrencyExchangeRateType());
                    projPostItem.parmReportingExchangeRate(exchangeRateHelper.getExchangeRate1());
                }
        
                projPostItem.postTrans();
            }
        }

        while select tmpProjAdjustmentCreateSale
        where tmpProjAdjustmentCreateSale.RefRecId == _tmpProjAdjustmentCreate.RecId
        {
            projPostItem=ProjPost::newCreateProjTransItemSaleAdjust(projItemTrans, _tmpProjAdjustmentCreate, tmpProjAdjustmentCreateSale, ledgerVoucher, projItemTrans.ProjTransId,true);
            projPostItem.parmAdjustment(true);
            // <GEEU>
            projPostItem.parmAdjustCorrection(isAdjustmentCorrection);
            // </GEEU>
            projPostItem.parmAdjustmentDate(tmpProjAdjustment.TransDateAdjustment);
            projPostItem.postTrans();
        }

        if (this.isNeverLedgerPosting(projItemTrans, isStocked))
        {
            // Never Ledger posting of item for project
            projLedger = ProjLedger::newInventCostAdjust(projItemTrans.ProjId, projItemTrans.InventTransId, projItemTrans.ProjAdjustRefId,
                                                          projItemTrans.TransactionOrigin, true);

            if (projLedger)
            {
                ProjLedgerUpdate::newNeverLedger(projLedger,
                                            LedgerPostingType::ProjNeverLedger,
                                            projItemTrans.DefaultDimension,
                                            ledgerVoucher.lastVoucher(),
                                            tmpProjAdjustment.TransDateAdjustment,
                                            transCostAmount).insert();
            }
            ProjItemTrans::splitNeverLedger(projItemTrans.InventTransId, projItemTrans.ProjAdjustRefId) ;
        }

        _tmpProjAdjustmentCreate.ProjAdjustRefId    = projAdjustRefIdOrig;
        _tmpProjAdjustmentCreate.InventTransId      = inventTransIdOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertProjTransQtyForTransItemNew</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the project transaction quantity value for the TransItemNew method.
    /// </summary>
    /// <param name = "_projItemTrans">Record for the <c>ProjItemTrans</c> buffer.</param>
    /// <param name = "_roundAbsoluteValue">A Boolean that determines if rounding should be done according to the absolute value; optional.</param>
    /// <param name = "_applyRounding">A Boolean that determines if rounding should be performed after conversion; optional.</param>
    /// <returns>The converted value.</returns>
    protected real convertProjTransQtyForTransItemNew(
        ProjItemTrans _projItemTrans,
        NoYes         _roundAbsoluteValue = NoYes::No,
        NoYes         _applyRounding = NoYes::Yes)
    {
        _projItemTrans.SalesQty = _projItemTrans.Qty;
        if (ProjAdjustmentUpdateWithDiffUOMFlight::instance().isEnabled()
                    && _projItemTrans.TransactionOrigin == ProjOrigin::PurchaseOrder)
        {
            PurchLine purchLine;
            select firstonly ProjSalesUnitId, PurchUnit from purchLine
                    where purchLine.ProjTransId == _projItemTrans.ProjTransIdRef;
            _projItemTrans.SalesUnit = purchLine.ProjSalesUnitId;

            if (_projItemTrans.SalesUnit != purchLine.PurchUnit)
            {
                _projItemTrans.SalesQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_projItemTrans.ItemId,
                                                                                     _projItemTrans.InventDimId,
                                                                                     _projItemTrans.Qty,
                                                                                     purchLine.PurchUnit,
                                                                                     _projItemTrans.SalesUnit,
                                                                                     NoYes::Yes);
            }
        }
        return EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_projItemTrans.ItemId,
                                                                                     _projItemTrans.InventDimId,
                                                                                     _projItemTrans.SalesQty,
                                                                                     _projItemTrans.SalesUnit,
                                                                                     InventTable::find(_projItemTrans.ItemId).inventUnitId(),
                                                                                     _roundAbsoluteValue,
                                                                                     _applyRounding);
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertProjTransQtyOrigForTransItemNew</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the original project transaction quantity value for the TransItemNew method.
    /// </summary>
    /// <param name = "_tmpProjAdjustment">Record for the <c>TmpProjAdjustment</c> buffer.</param>
    /// <param name = "_roundAbsoluteValue">A Boolean that determines if rounding should be done according to the absolute value; optional.</param>
    /// <param name = "_applyRounding">A Boolean that determines if rounding should be performed after conversion; optional.</param>
    /// <returns>The converted value.</returns>
    protected real convertProjTransQtyOrigForTransItemNew(
        TmpProjAdjustment _tmpProjAdjustment,
        NoYes             _roundAbsoluteValue = NoYes::No,
        NoYes             _applyRounding = NoYes::Yes)
    {
        return EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_tmpProjAdjustment.ItemId,
                                                                                     _tmpProjAdjustment.InventDimid,
                                                                                     _tmpProjAdjustment.Qty,
                                                                                     _tmpProjAdjustment.SalesUnit,
                                                                                     InventTable::find(_tmpProjAdjustment.ItemId).inventUnitId(),
                                                                                     _roundAbsoluteValue,
                                                                                     _applyRounding);
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateProjPostForTransItemNewWithNoLedgerPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the <c>ProjPost</c> class for the TransItemNew method with no ledger posting.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentCreate">Record for the <c>TmpProjAdjustmentCreate</c> buffer.</param>
    /// <returns>An instance of <c>ProjPost</c>.</returns>
    protected ProjPost instantiateProjPostForTransItemNewWithNoLedgerPosting(TmpProjAdjustmentCreate _tmpProjAdjustmentCreate)
    {
        return ProjPost::newCreateProjTransItemAdjust(_tmpProjAdjustmentCreate,ledgerVoucher,true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateInventMov_ProjItemTransForTransItemNew</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the <c>InventMov_ProjItemTrans</c> class for the TransItemNew method.
    /// </summary>
    /// <param name = "_projItemTrans">Record for the <c>ProjItemTrans</c> buffer.</param>
    /// <param name = "_inventTrans">Record for the <c>InventTrans</c> buffer.</param>
    /// <param name = "_inventQty">Inventory quantity for the movement class.</param>
    /// <param name = "_costAmount">Cost amount for the movement class.</param>
    /// <returns>An instance of <c>InventMov_ProjItemTrans</c>.</returns>
    protected InventMov_ProjItemTrans instantiateInventMov_ProjItemTransForTransItemNew(
                                            ProjItemTrans           _projItemTrans, 
                                            InventTrans             _inventTrans, 
                                            InventQty               _inventQty, 
                                            CostAmount              _costAmount)
    {
        InventMov_ProjItemTrans invent_Mov = InventMov_ProjItemTrans::newProjItemTransNew(_projItemTrans, _inventTrans, -_inventQty, -_costAmount);
        invent_Mov.parmInventRefTransId(this.parmInventRefTransIdOrig());
        return invent_Mov;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNeverLedgerPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if never ledger posting of item for project is required.
    /// </summary>
    /// <param name = "_projItemTrans">Record for the <c>ProjItemTrans</c> buffer.</param>
    /// <param name = "_isStocked">Flag if the source document line item is a stocked product.</param>
    /// <returns>true if never ledger posting of item for project is required; otherwise, false.</returns>
    protected boolean isNeverLedgerPosting(ProjItemTrans _projItemTrans, boolean _isStocked)
    {
        return _isStocked && !InventTable::find(_projItemTrans.ItemId).modelGroup().PostOnhandFinancial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transNew_Update</Name>
				<Source><![CDATA[
    void transNew_Update(ProjPost  projPostUpdate)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>transRevenueNew</Name>
				<Source><![CDATA[
    void transRevenueNew(TmpProjAdjustmentCreate  _tmpProjAdjustmentCreate)
    {
        ProjPost            projPostJournal;
        ProjRevenueTrans    projRevenueTransOrig;
        ProjRevenueTrans    projRevenueTransNew;

        lineNum++;
        this.journalTransInsert(_tmpProjAdjustmentCreate);

        if (journalTrans)
        {
            if (_tmpProjAdjustmentCreate.AdjustOrig)
            {
                if (this.adjustStatus() == ProjTransStatus::Adjusted)
                {
                    projRevenueTransOrig    = ProjRevenueTrans::find(_tmpProjAdjustmentCreate.TransID, true);

                    // create new negative projRevenueTrans
                    projPostJournal     = ProjPost::newTransAdjNegativeJournal(
                                                            journalTrans,
                                                            ledgerVoucher,
                                                            projRevenueTransOrig.TransId,
                                                            projRevenueTransOrig.TransactionOrigin);
                }
                else if (this.adjustStatus() == ProjTransStatus::Posted)
                {
                    projRevenueTransOrig = ProjRevenueTrans::find(_tmpProjAdjustmentCreate.TransID);
                    projPostJournal = ProjPost::newCreateProjTransAndLedgerAdj(journalTrans, ledgerVoucher, projRevenueTransOrig.TransactionOrigin);
                }
                // <GEEU>
                projPostJournal.parmAdjustCorrection(this.isAdjustmentCorrection(_tmpProjAdjustmentCreate.AdjustCorrection,
                                                                                tmpProjAdjustment.AdjustCorrection,
                                                                                true));
                // </GEEU>
            }
            else
            {
                projRevenueTransOrig = ProjRevenueTrans::find(_tmpProjAdjustmentCreate.TransID);
                projPostJournal = ProjPost::newCreateProjTransAndLedgerAdj(journalTrans, ledgerVoucher, projRevenueTransOrig.TransactionOrigin);
                // <GEEU>
                projPostJournal.parmAdjustCorrection(this.isAdjustmentCorrection(_tmpProjAdjustmentCreate.AdjustCorrection,
                                                                                tmpProjAdjustment.AdjustCorrection));
                // </GEEU>
            }

            projPostJournal.parmAdjustment(true);
            projPostJournal.parmAdjustmentDate(tmpProjAdjustment.TransDateAdjustment);
            projPostJournal.parmTransIdRef(projRevenueTransOrig.TransIdRef);
            projPostJournal.parmAdjRefTransId(projRevenueTransOrig.TransId);

            if (projPostJournal.checkTrans())
            {
                this.transNew_Update(projPostJournal);
            }
            else
            {
                this.initInfologAction(tmpProjAdjustment);
                checkFailed = true;
                if (this.parmPost())
                {
                    throw error("@SYS18447");
                }
            }

            if (this.mustDeleteJournalTransaction())
            {
                journalTrans.delete();
            }

            projRevenueTransNew = ProjRevenueTrans::find(projPostJournal.parmTransIdNew());

            while select tmpProjAdjustmentCreateSale
            where tmpProjAdjustmentCreateSale.RefRecId == _tmpProjAdjustmentCreate.RecId
            {
                this.transRevenueNewSale(projRevenueTransNew, _tmpProjAdjustmentCreate, tmpProjAdjustmentCreateSale);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transRevenueNewSale</Name>
				<Source><![CDATA[
    void transRevenueNewSale(
    ProjRevenueTrans            _projRevenueTransNew,
    TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
    TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale
)
    {
        ProjPost                projPostJournal;
        ProjRevenueTrans        projRevenueTransOrig;
        ProjRevenueTransSale    projRevenueTransSaleOrig;

        // <GEEU>
        #EECountryRegionCodes
        boolean                 countryRegion_EU = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll);
        // </GEEU>

        if (_tmpProjAdjustmentCreate.AdjustOrig)
        {
            if (this.adjustStatus() == ProjTransStatus::Adjusted)
            {
                projRevenueTransOrig = ProjRevenueTrans::find(_tmpProjAdjustmentCreate.TransID, true);
                projRevenueTransSaleOrig = ProjRevenueTransSale::find(_tmpProjAdjustmentCreateSale.SaleRefRecId, true);

                // create new negative projEmplTransSale
                projPostJournal     = ProjPost::newTransAdjNegativeJournalSale(
                                                        _projRevenueTransNew,
                                                        _tmpProjAdjustmentCreateSale,
                                                        ledgerVoucher,
                                                        projRevenueTransSaleOrig.LedgerSalesPosted,
                                                        projRevenueTransSaleOrig.LedgerSalesAmount,
                                                        projRevenueTransSaleOrig.LineAmount,
                                                        projRevenueTransOrig.TransId,
                                                        projRevenueTransOrig.TransactionOrigin);
            }
            else if (this.adjustStatus() == ProjTransStatus::Posted)
            {
                projRevenueTransOrig = ProjRevenueTrans::find(_tmpProjAdjustmentCreate.TransID);

                projPostJournal = ProjPost::newCreateProjTransAndLedgerAdjSale(
                                                    _projRevenueTransNew,
                                                    _tmpProjAdjustmentCreateSale,
                                                    ledgerVoucher);
                projPostJournal.parmAdjustmentDate(_tmpProjAdjustmentCreate.Transdate);
            }
            // <GEEU>
            if (countryRegion_EU)
            {
                projPostJournal.parmAdjustCorrection(this.isAdjustmentCorrection(_tmpProjAdjustmentCreate.AdjustCorrection,
                                                                                tmpProjAdjustment.AdjustCorrection,
                                                                                true));
            }
            // </GEEU>
        }
        else
        {
            projRevenueTransOrig = ProjRevenueTrans::find(_tmpProjAdjustmentCreate.TransID);

            projPostJournal = ProjPost::newCreateProjTransAndLedgerAdjSale(
                                                    _projRevenueTransNew,
                                                    _tmpProjAdjustmentCreateSale,
                                                    ledgerVoucher);
            projPostJournal.parmAdjustmentDate(_tmpProjAdjustmentCreate.Transdate);
            // <GEEU>
            if (countryRegion_EU)
            {
                projPostJournal.parmAdjustCorrection(this.isAdjustmentCorrection(_tmpProjAdjustmentCreate.AdjustCorrection,
                                                                                tmpProjAdjustment.AdjustCorrection));
            }
            // </GEEU>
        }

        projPostJournal.parmAdjustment(true);
        projPostJournal.parmAdjustmentDate(tmpProjAdjustment.TransDateAdjustment);
        projPostJournal.parmTransIdRef(projRevenueTransOrig.TransIdRef);
        projPostJournal.parmAdjRefTransId(projRevenueTransOrig.TransId);

        if (projPostJournal.checkTrans())
        {
            this.transNew_Update(projPostJournal);
        }
        else
        {
            this.initInfologAction(tmpProjAdjustment);
            checkFailed = true;
            if (this.parmPost())
            {
                throw error("@SYS18447");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAdjusted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the adjusted field on the related <c>TmpProjAdjustment</c>.
    /// </summary>
    protected void updateAdjusted()
    {
        while select tmpProjAdjustmentCreate
        group by TransID
        {
            update_recordset tmpProjAdjustment
            setting Adjusted  = NoYes::Yes
            where tmpProjAdjustment.TransId == tmpProjAdjustmentCreate.TransID;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCheckAdjustment</Name>
				<Source><![CDATA[
    public static boolean newCheckAdjustment(
    TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
    TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
    TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale,
    TmpProjAdjustment           _tmpProjAdjustment,
    TmpProjAdjustmentCost       _tmpProjAdjustmentCost,
    TmpProjAdjustmentSale       _tmpProjAdjustmentSale,
    Args                        _args)
    {
        FormDataSource              tmpProjAdjustment_DS;

        ProjAdjustmentUpdate        projAdjustmentUpdate;
        TmpProjAdjustment           tmpProjAdjustment, tmpPA;
        TmpProjAdjustmentCost       tmpPACost;
        TmpProjAdjustmentSale       tmpPASale;
        TmpProjAdjustmentCreate     tmpPAC;
        TmpProjAdjustmentCreateCost tmpPACCost;
        TmpProjAdjustmentCreateSale tmpPACSale;

        void processtmpProjAdjustment()
        {
            tmpPAC = null;
            tmpPACCost = null;
            tmpPACSale = null;
            tmpPA  = null;
            tmpPACost  = null;
            tmpPASale  = null;

            // find TmpProjAdjustmentCreate
            while select _tmpProjAdjustmentCreate
            where _tmpProjAdjustmentCreate.TransID == tmpProjAdjustment.TransId
            {
                tmpPAC.data(_tmpProjAdjustmentCreate);
                tmpPAC.insert();

                while select _tmpProjAdjustmentCreateCost
                where _tmpProjAdjustmentCreateCost.RefRecId == _tmpProjAdjustmentCreate.RecId
                {
                    tmpPACCost.data(_tmpProjAdjustmentCreateCost);
                    tmpPACCost.RefRecId = tmpPAC.RecId;
                    tmpPACCost.insert();
                }

                while select _tmpProjAdjustmentCreateSale
                where _tmpProjAdjustmentCreateSale.RefRecId == _tmpProjAdjustmentCreate.RecId
                {
                    tmpPACSale.data(_tmpProjAdjustmentCreateSale);
                    tmpPACSale.RefRecId = tmpPAC.RecId;
                    tmpPACSale.insert();
                }
            }

            tmpPA.data(tmpProjAdjustment);
            tmpPA.insert();

            while select _tmpProjAdjustmentCost
            where _tmpProjAdjustmentCost.TransId == tmpProjAdjustment.TransId
            {
                tmpPACost.data(_tmpProjAdjustmentCost);
                tmpPACost.insert();
            }

            while select _tmpProjAdjustmentSale
            where _tmpProjAdjustmentSale.TransId == tmpProjAdjustment.TransId
            {
                tmpPASale.data(_tmpProjAdjustmentSale);
                tmpPASale.insert();
            }

            projAdjustmentUpdate.parmPost(NoYes::Yes);
            projAdjustmentUpdate.setTmpProjAdjustment(tmpPA);
            projAdjustmentUpdate.setTmpProjAdjustmentCost(tmpPACost);
            projAdjustmentUpdate.setTmpProjAdjustmentSale(tmpPASale);
            projAdjustmentUpdate.setTmpProjAdjustmentCreate(tmpPAC);
            projAdjustmentUpdate.setTmpProjAdjustmentCreateCost(tmpPACCost);
            projAdjustmentUpdate.setTmpProjAdjustmentCreateSale(tmpPACSale);
            projAdjustmentUpdate.run(_args);
        }

        projAdjustmentUpdate = new ProjAdjustmentUpdate_Check();
        tmpProjAdjustment_DS = FormDataUtil::getFormDataSource(_args.record());

        if (tmpProjAdjustment_DS)
        {
            tmpProjAdjustment = tmpProjAdjustment_DS.getFirst(true) ? tmpProjAdjustment_DS.getFirst(true) : _args.record();
            while (tmpProjAdjustment)
            {
                processtmpProjAdjustment();
                tmpProjAdjustment = tmpProjAdjustment_DS.getNext();
            }
        }
        else
        {
            tmpProjAdjustment = _args.record();
            processtmpProjAdjustment();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processtmpProjAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Asynchronous process for posting adjustments
    /// </summary>
    /// <param name = "_projAdjustmentUpdate">Record buffer for ProjAdjustmentUpdate</param>///
    /// <param name = "_tmpProjAdjustmentCreate">Record buffer for TmpProjAdjustmentCreate</param>
    /// <param name = "_tmpProjAdjustmentCreateCost">Record buffer for TmpProjAdjustmentCreateCost</param>
    /// <param name = "_tmpProjAdjustmentCreateSale">Record buffer for TmpProjAdjustmentCreateSale</param>
    /// <param name = "_tmpProjAdjustment">>Record buffer for TmpProjAdjustment</param>
    /// <param name = "_tmpProjAdjustmentCost">>Record buffer for TmpProjAdjustmentCost</param>
    /// <param name = "_tmpProjAdjustmentSale">Record buffer for TmpProjAdjustmentSale</param>
    /// <param name = "_args">Args from thr caller.</param>
    protected static void processtmpProjAdjustment(ProjAdjustmentUpdate _projAdjustmentUpdate,
        TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
        TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
        TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale,
        TmpProjAdjustment           _tmpProjAdjustment,
        TmpProjAdjustmentCost       _tmpProjAdjustmentCost,
        TmpProjAdjustmentSale       _tmpProjAdjustmentSale,
        Args                        _args)
    {
        TmpProjAdjustment tmpPA = null;
        TmpProjAdjustmentCost tmpPACost = null;
        TmpProjAdjustmentSale tmpPASale = null;
        TmpProjAdjustmentCreate tmpPAC = null;
        TmpProjAdjustmentCreateCost tmpPACCost = null;
        TmpProjAdjustmentCreateSale tmpPACSale = null;
  
        // find TmpProjAdjustmentCreate
        while select _tmpProjAdjustmentCreate
                where _tmpProjAdjustmentCreate.TransID == _tmpProjAdjustment.TransId
        {
            tmpPAC.data(_tmpProjAdjustmentCreate);
            tmpPAC.insert();

            if (TaxIntegrationUtils::isTaxInformationEnabled()
                && !(TaxProjAdjustmentTaxInfoFlight::instance().isEnabled()
                    && _tmpProjAdjustmentCreate.TableId == tmpPAC.TableId
                    && _tmpProjAdjustmentCreate.RecId == tmpPAC.RecId))
            {
                TransTaxInformationHelper::copyTransTaxInformation(_tmpProjAdjustmentCreate, tmpPAC);
            }

            while select _tmpProjAdjustmentCreateCost
                    where _tmpProjAdjustmentCreateCost.RefRecId == _tmpProjAdjustmentCreate.RecId
            {
                tmpPACCost.data(_tmpProjAdjustmentCreateCost);
                tmpPACCost.RefRecId = tmpPAC.RecId;
                tmpPACCost.insert();
            }

            while select _tmpProjAdjustmentCreateSale
                    where _tmpProjAdjustmentCreateSale.RefRecId == _tmpProjAdjustmentCreate.RecId
            {
                tmpPACSale.data(_tmpProjAdjustmentCreateSale);
                tmpPACSale.RefRecId = tmpPAC.RecId;
                tmpPACSale.insert();
            }
        }

        tmpPA.data(_tmpProjAdjustment);
        tmpPA.insert();

        while select _tmpProjAdjustmentCost
                where _tmpProjAdjustmentCost.TransId == _tmpProjAdjustment.TransId
        {
            tmpPACost.data(_tmpProjAdjustmentCost);
            tmpPACost.insert();
        }

        while select _tmpProjAdjustmentSale
                where _tmpProjAdjustmentSale.TransId == _tmpProjAdjustment.TransId
        {
            tmpPASale.data(_tmpProjAdjustmentSale);
            tmpPASale.insert();
        }

        if (_args.parmEnumType() == enumNum(ProjInfoLog) && _args.parmEnum() == ProjInfoLog::DoNotShow)
        {
            _projAdjustmentUpdate.parmInfolog(false);
        }
        _projAdjustmentUpdate.parmPost(NoYes::Yes);
        _projAdjustmentUpdate.setTmpProjAdjustment(tmpPA);
        _projAdjustmentUpdate.setTmpProjAdjustmentCost(tmpPACost);
        _projAdjustmentUpdate.setTmpProjAdjustmentSale(tmpPASale);
        _projAdjustmentUpdate.setTmpProjAdjustmentCreate(tmpPAC);
        _projAdjustmentUpdate.setTmpProjAdjustmentCreateCost(tmpPACCost);
        _projAdjustmentUpdate.setTmpProjAdjustmentCreateSale(tmpPACSale);
        _projAdjustmentUpdate.run(_args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Asynchronous process for posting adjustments
    /// </summary>
    /// <param name = "_tmpProjAdjustmentCreate">Record buffer for TmpProjAdjustmentCreate</param>
    /// <param name = "_tmpProjAdjustmentCreateCost">Record buffer for TmpProjAdjustmentCreateCost</param>
    /// <param name = "_tmpProjAdjustmentCreateSale">Record buffer for TmpProjAdjustmentCreateSale</param>
    /// <param name = "_tmpProjAdjustment">>Record buffer for TmpProjAdjustment</param>
    /// <param name = "_tmpProjAdjustmentCost">>Record buffer for TmpProjAdjustmentCost</param>
    /// <param name = "_tmpProjAdjustmentSale">Record buffer for TmpProjAdjustmentSale</param>
    /// <param name = "_args">Args from thr caller.</param>
    public static void newPostAdjustment(
        TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
        TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
        TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale,
        TmpProjAdjustment           _tmpProjAdjustment,
        TmpProjAdjustmentCost       _tmpProjAdjustmentCost,
        TmpProjAdjustmentSale       _tmpProjAdjustmentSale,
        Args                        _args)
    {
        ProjAdjustmentUpdate        projAdjustmentUpdate;
        FormDataSource              formDataSource;
        TmpProjAdjustment           tmpProjAdjustment;

        projAdjustmentUpdate = new ProjAdjustmentUpdate_Post();

        // Handle multiselect in form
        formDataSource = FormDataUtil::getFormDataSource(_args.record());

        if (formDataSource)
        {
            tmpProjAdjustment = formDataSource.getFirst(true) ? formDataSource.getFirst(true) : _args.record();
        }
        else
        {
            tmpProjAdjustment = _args.record();
        }

        try
        {
            ttsbegin;

            if (formDataSource)
            {
                while (tmpProjAdjustment)
                {
                    if (ProjAdjustmentUpdate::shouldProcessNewPostAdjustment(tmpProjAdjustment, _tmpProjAdjustmentCreate))
                    {
                        ProjAdjustmentUpdate::processtmpProjAdjustment(projAdjustmentUpdate,
                            _tmpProjAdjustmentCreate,
                            _tmpProjAdjustmentCreateCost,
                            _tmpProjAdjustmentCreateSale,
                            tmpProjAdjustment,
                            _tmpProjAdjustmentCost,
                            _tmpProjAdjustmentSale,
                            _args);
                    }
                    tmpProjAdjustment = formDataSource.getNext();
                }
            }
            else
            {
                if (ProjAdjustmentUpdate::shouldProcessNewPostAdjustment(tmpProjAdjustment, _tmpProjAdjustmentCreate))
                {
                    ProjAdjustmentUpdate::processtmpProjAdjustment(projAdjustmentUpdate,
                            _tmpProjAdjustmentCreate,
                            _tmpProjAdjustmentCreateCost,
                            _tmpProjAdjustmentCreateSale,
                            tmpProjAdjustment,
                            _tmpProjAdjustmentCost,
                            _tmpProjAdjustmentSale,
                            _args);
                }
            }

            projAdjustmentUpdate.ledgerVoucherTransEnd();

            ttscommit;
        }
        catch (Exception::Error)
        {
            if (tmpProjAdjustment 
                && tmpProjAdjustment.AdjustmentType == ProjAdjustmentType::Item 
                && FeatureStateProvider::isFeatureEnabled(ProjThrowErrorAdjustmentOfReturnTransFlight::instance())
                && InventTable::find(tmpProjAdjustment.ItemId).isStocked()
                && ProjAdjustmentUpdate::isTransactionReturned(tmpProjAdjustment.InventTransId))
            {
                throw error("@Proj:NoAdjustmentReturnTransaction");  
            }
            else
            {
                throw;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransactionReturned</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the related inventory transaction affected physical on-hand and was returned.
    /// </summary>
    /// <param name = "_inventTransId">
    /// The invent transaction id.
    /// </param>
    /// <returns>
    /// true if the transaction was returned, partially or completely, false otherwise.
    /// </returns>
    private static boolean isTransactionReturned(InventTransId _inventTransId)
    {
        if (!_inventTransId)
        {
            return false;
        }

        InventTransOrigin inventTransOrigin;
        InventTrans inventTrans;

        select firstonly RecId
        from inventTransOrigin
            where inventTransOrigin.InventTransId == _inventTransId
        join RecId from inventTrans
            where inventTrans.InventTransOrigin == inventTransOrigin.RecId
            && (inventTrans.StatusIssue == StatusIssue::Picked
                || inventTrans.StatusIssue == StatusIssue::Deducted
                || inventTrans.StatusIssue == StatusIssue::Sold)
            && inventTrans.ReturnInventTransOrigin != 0;

        return inventTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostAdjustmentAsync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls an asynchronous process for posting adjustments
    /// </summary>
    /// <param name = "_tmpProjAdjustmentCreate">
	/// Record buffer for TmpProjAdjustmentCreate
	/// </param>
    /// <param name = "_tmpProjAdjustmentCreateCost">
	/// Record buffer for TmpProjAdjustmentCreateCost
	/// </param>
    /// <param name = "_tmpProjAdjustmentCreateSale">
	/// Record buffer for TmpProjAdjustmentCreateSale
	/// </param>
    /// <param name = "_tmpProjAdjustment">
	/// Record buffer for TmpProjAdjustment
	/// </param>
    /// <param name = "_tmpProjAdjustmentCost">
	/// Record buffer for TmpProjAdjustmentCost
	/// </param>
    /// <param name = "_tmpProjAdjustmentSale">
	/// Record buffer for TmpProjAdjustmentSale
	/// </param>
    /// <param name = "_args">
    /// The <c>Args</c> object passed from the caller. 
	/// </param>
    public server static void newPostAdjustmentAsync(
        TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
        TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
        TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale,
        TmpProjAdjustment           _tmpProjAdjustment,
        TmpProjAdjustmentCost       _tmpProjAdjustmentCost,
        TmpProjAdjustmentSale       _tmpProjAdjustmentSale,
        Args                        _args)
    {
        ProjAdjustmentUpdate        projAdjustmentUpdate;
        FormDataSource              formDataSource;
        TmpProjAdjustment           tmpProjAdjustment;

        // Handle multiselect in form
        formDataSource = FormDataUtil::getFormDataSource(_args.record());

        guid processId;

        if (_args.parm())
        {
            processId = str2Guid(_args.parm());
        }
        else
        {
            processId = newGuid();
        }

        if (formDataSource)
        {
            tmpProjAdjustment = formDataSource.getFirst(true) ? formDataSource.getFirst(true) : _args.record();

            while (tmpProjAdjustment)
            {
                if (ProjAdjustmentUpdate::shouldProcessNewPostAdjustment(tmpProjAdjustment, _tmpProjAdjustmentCreate))
                {
                    ProjAdjustmentUpdate_PostAsync::processAdjustmentBeforePosting(processId,
                                                                                   _tmpProjAdjustmentCreate,
                                                                                    _tmpProjAdjustmentCreateCost,
                                                                                    _tmpProjAdjustmentCreateSale,
                                                                                    tmpProjAdjustment,
                                                                                    _tmpProjAdjustmentCost,
                                                                                    _tmpProjAdjustmentSale);
                }
                tmpProjAdjustment = formDataSource.getNext();
            }
        }
        else
        {
            tmpProjAdjustment = _args.record();

            if (ProjAdjustmentUpdate::shouldProcessNewPostAdjustment(tmpProjAdjustment, _tmpProjAdjustmentCreate))
            {
                ProjAdjustmentUpdate_PostAsync::processAdjustmentBeforePosting(processId,
                                                                                    _tmpProjAdjustmentCreate,
                                                                                    _tmpProjAdjustmentCreateCost,
                                                                                    _tmpProjAdjustmentCreateSale,
                                                                                    tmpProjAdjustment,
                                                                                    _tmpProjAdjustmentCost,
                                                                                    _tmpProjAdjustmentSale);
            }
        }

        MenuFunction menuFunction = new MenuFunction(menuitemActionStr(ProjAdjustmentUpdate_PostService), MenuItemType::Action);

        if (menuFunction && menuFunction.checkAccessRights())
        {
            Args menuArgs = new Args();
            menuArgs.parm(guid2Str(processId));
            menuFunction.run(menuArgs);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldProcessNewPostAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the adjustment should be processed.
    /// </summary>
    /// <param name = "_tmpProjAdjustment">
    /// A <c>TmpProjAdjustment</c> record buffer.
    /// </param>
    /// <param name = "_tmpProjAdjustmentCreate">
    /// A <c>TmpProjAdjustmentCreate</c> record buffer.
    /// </param>
    /// <returns>
    /// true.
    /// </returns>
    [HookableAttribute(true)]
    protected static boolean shouldProcessNewPostAdjustment(TmpProjAdjustment _tmpProjAdjustment, TmpProjAdjustmentCreate _tmpProjAdjustmentCreate)
    {
        // This method is used for extensibility.
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaNewPostAdjustment</Name>
				<Source><![CDATA[
    public static void psaNewPostAdjustment(
        TmpProjAdjustmentCreate    _tmpProjAdjustmentCreate,
        TmpProjAdjustment          _tmpProjAdjustment,
        Args                       _args)
    {
        ProjAdjustmentUpdate    projAdjustmentUpdate;

        if (!isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            return;
        }

        projAdjustmentUpdate = new ProjAdjustmentUpdate_Post();

        ttsbegin;
        projAdjustmentUpdate.ledgerVoucherTransCreate(_tmpProjAdjustment.TransDateAdjustment);
        projAdjustmentUpdate.parmPost(NoYes::Yes);
        projAdjustmentUpdate.parmInfolog(false);
        projAdjustmentUpdate.setTmpProjAdjustment(_tmpProjAdjustment);
        projAdjustmentUpdate.setTmpProjAdjustmentCreate(_tmpProjAdjustmentCreate);
        projAdjustmentUpdate.run(_args);

        projAdjustmentUpdate.ledgerVoucherTransEnd();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaIndirectComponentJournalTransCreate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts journal transaction for indirect components
    /// </summary>
    /// <param name = "_fundingSourceList">Funding source associated with the project contract to be used</param>
    /// <param name = "_dueToCompany">Legal entity of the due to company</param>
    /// <param name = "_costUseOrig">Boolean value which indicates to use cost original</param>
    /// <param name = "_transIdOrig">Transaction id of the original transaction</param>
    /// <param name = "_salesUseOrig">Boolean value which indicates to use sales original</param>
    protected void psaIndirectComponentJournalTransCreate(List  _fundingSourceList,
                                                        RefRecId _dueToCompany = 0,
                                                        boolean _costUseOrig = 0,
                                                        ProjTransIdBase _transIdOrig = '',
                                                        boolean _salesUseOrig = 0)
    {
        //PA copied from ProjJournalCheckPost Class so that same process may be done for both entered journals
        // (from timecard or manually) as well as from adjustments
        if (journalTrans &&
        journalTrans.psaIndirectComponentGroup &&
        isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            ProjPost psaProjPostEmplIndirectJournal= ProjPost::psaNewCreateProjIndirectCostAndRevenue(journalTrans, ledgerVoucher);
            
            if (_dueToCompany)
            {
                PSAProjPostEmplIndirectJournal psaProjPostEmplIndirectJournalInstance = psaProjPostEmplIndirectJournal as PSAProjPostEmplIndirectJournal;
                psaProjPostEmplIndirectJournalInstance.parmIntercompanyDueToCompany(_dueToCompany);
            }
            
            psaProjPostEmplIndirectJournal.parmFundingSourceList(_fundingSourceList);
            
            if (_costUseOrig)
            {
                psaProjPostEmplIndirectJournal.parmTransIdOrig(_transIdOrig);
                psaProjPostEmplIndirectJournal.parmCostUseOrig(_costUseOrig);
            }

            if (_salesUseOrig)
            {
                psaProjPostEmplIndirectJournal.parmsalesUseOrig(_salesUseOrig);
            }

            psaProjPostEmplIndirectJournal.postTrans();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAdjustmentTypeForHour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for the adjustment type.
    /// </summary>
    /// <param name = "_adjustmentType"><c>ProjAdjustmentType</c> enum</param>
    /// <returns>true if adjustment type is hour; otherwise, false.</returns>
    protected boolean checkAdjustmentTypeForHour(ProjAdjustmentType  _adjustmentType)
    {
        return (_adjustmentType == ProjAdjustmentType::Hour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjPostJournal</Name>
				<Source><![CDATA[
    private void updateProjPostJournal(ProjPost _projPostJournal, ProjEmplTrans _projEmplTransOrig, TmpProjAdjustmentCreate _tmpProjAdjustmentCreate)
    {
        _projPostJournal.parmAdjustment(true);
        if (ProjAdjustmentUpdateEmplLedgerTransDateFlight::instance().isEnabled())
        {
            _projPostJournal.parmAdjustmentDate(this.parmAccountingDate());
        }
        else
        {
            _projPostJournal.parmAdjustmentDate(_tmpProjAdjustmentCreate.Transdate);
        }
        _projPostJournal.parmTransIdRef(_projEmplTransOrig.TransIdRef);
        _projPostJournal.parmAdjRefTransId(_projEmplTransOrig.TransId);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>