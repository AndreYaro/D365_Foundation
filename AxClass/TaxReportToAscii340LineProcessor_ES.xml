<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxReportToAscii340LineProcessor_ES</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///     The class <c>TaxReportToAscii340LineProcessor_ES</c> processes the TaxReport340 data before writing it to an ASCII file.
/// </summary>
public class TaxReportToAscii340LineProcessor_ES
{
    int                             creditNotesCount;
    int                             countRegs;
    LogisticsAddressCountryRegion   countryRegion;
    CountryRegionType               countryRegionType;
    CustTable                       custTable;
    CustTrans                       custTrans;
    CustVendTrans                   custVendTransOrig;
    boolean                         isCreditNote;
    boolean                         isDifferentVAT;
    boolean                         isCashRegime;
    recId                           recId;
    Name                            relationName;
    InvoiceDate                     reportingDate;
    TaxBookTaxCodes                 taxBookTaxCodes;
    TaxReportLines                  taxReportLines;
    TaxReportTable                  taxReportTable;
    TaxTrans                        taxTrans;
    TaxTrans                        taxTransTotal;
    VendTable                       vendTable;
    VendTrans                       vendTrans;

    str                             collectionMethod, collectionMethodInfo;

    #Characters
    #TaxReport340
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>amount2StrLoc</Name>
				<Source><![CDATA[
    private str amount2StrLoc(AmountCur _amount, int _length)
    {
        return TaxReportToAscii340LineProcessor_ES::amount2Str(_amount, _length);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashRegimeCollectionAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the Collection amount.
    /// </summary>
    /// <param name="_isOutgoingTax">
    /// Boolean indicating if it is outgoing tax.
    /// </param>
    /// <returns>
    /// The Collection amount.
    /// </returns>
    public str cashRegimeCollectionAmount(boolean _isOutgoingTax)
    {
        Amount               totalInvoiceAmount;
        str                  ret = #BlankText;

        if (this.isCashRegimeReported())
        {
            if (taxReportLines.UnpaidInvoiceAmount)
            {
                totalInvoiceAmount = taxReportLines.UnpaidInvoiceAmount;
            }
            else
            {
                if (_isOutgoingTax)
                {
                    totalInvoiceAmount = taxReportLines.TaxBase + taxReportLines.TaxAmount + taxReportLines.TaxAmountEq;
                }
                else
                {
                    totalInvoiceAmount = taxReportLines.TaxBase + taxReportLines.TaxAmount;
                }
            }
        }
        ret = TaxReportToAscii340LineProcessor_ES::amount2StrWithoutSign(totalInvoiceAmount, #TotalInvoiceAmountLength);

        return TaxReportToAscii340LineProcessor_ES::convert(ret);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashRegimeCollectionDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the Collection date.
    /// </summary>
    /// <returns>
    /// The Collection date.
    /// </returns>
    public str cashRegimeCollectionDate()
    {
        str collectionDate = '0';

        if (this.isCashRegimeReported())
        {
            if (taxReportLines.UnpaidInvoiceAmount)
            {
                collectionDate = date2str(taxReportTable.ToDate,321,2,0,2,0,4,DateFlags::None);
            }
            else
            {
                collectionDate = date2str(taxReportLines.TransDate,321,2,0,2,0,4,DateFlags::None);
            }
        }

        return strLFix(TaxReportToAscii340LineProcessor_ES::convert(collectionDate), #DateLength, '0');
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashRegimeCollectionMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the Payment method type.
    /// </summary>
    /// <returns>
    /// The Payment method type.
    /// </returns>
    public str cashRegimeCollectionMethod()
    {
        str ret;
        if (taxReportLines.OperationType == #OperationType_UnSettledInvoice)
        {
            ret = #BlankText;
        }
        else
        {
            ret = collectionMethod;
        }
        return strLFix(TaxReportToAscii340LineProcessor_ES::convert(ret), #collectionMethod);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashRegimeCollectionMethodInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the Bank Account or Payment Method Used.
    /// </summary>
    /// <returns>
    /// The Bank Account or Payment Method Used.
    /// </returns>
    public str cashRegimeCollectionMethodInfo()
    {
        str method;

        if (this.isCashRegimeReported())
        {
            method = TaxReportToAscii340LineProcessor_ES::convert(collectionMethodInfo);
        }
        else
        {
            method = #BlankText;
        }

        return strLFix(method, #collectionMethodInfo);
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertLoc</Name>
				<Source><![CDATA[
    private str convertLoc(str _value)
    {
        return TaxReportToAscii340LineProcessor_ES::convert(_value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldAmountPropertyVat</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the AmountPropertyVat value.
    /// </summary>
    /// <returns>
    ///     The amountPropertyVat value.
    /// </returns>
    public str fieldAmountPropertyVat()
    {
        str ret = #BlankText;

        if (taxReportTable.isOperationCode2012Supported())
        {
            ret = TaxReportToAscii340LineProcessor_ES::amount2StrWithoutSign(taxReportLines.AmountPropertyVAT, #AmountPropertyVATLength);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldCashCollectable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the cashCollectable value.
    /// </summary>
    /// <returns>
    ///     The cashCollectable value.
    /// </returns>
    public str fieldCashCollectable()
    {
        str value = #BlankText;

        if (taxReportTable.isOperationCode2012Supported())
        {
            value = TaxReportToAscii340LineProcessor_ES::amount2StrWithoutSign(taxReportLines.CashCollectable, #CashCollectableLength);
        }

        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldCashInvoiceYear</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the cashInvoiceYear value.
    /// </summary>
    /// <returns>
    ///     The cashInvoiceYear value.
    /// </returns>
    public str fieldCashInvoiceYear()
    {
        return taxReportTable.isOperationCode2012Supported() ? num2Str0(taxReportLines.CashInvoiceYear, #FiscalYearLength) : #BlankText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldCompanyVatNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the companyVatNum value.
    /// </summary>
    /// <returns>
    ///     The companyVatNum value.
    /// </returns>
    public str fieldCompanyVatNum()
    {
        str result;

        if (countryRegion.RecId && countryRegionType == CountryRegionType::Domestic)
        {
            result = strRFix(this.convertLoc(taxReportLines.vatNum), #CompanyVATNumberLength, #0);
        }
        else
        {
            result = strLFix(#BlankText, #CompanyVATNumberLength);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldCorrectedInvoiceId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the correctedInvoiceId value.
    /// </summary>
    /// <returns>
    ///     The correctedInvoiceId value.
    /// </returns>
    public str fieldCorrectedInvoiceId()
    {
        str value;

        if (isCreditNote)
        {
            if (creditNotesCount == 1)
            {
                value = strLFix(this.convertLoc(CustVendCreditInvoicingJour::findInvoiceId(tableNum(CustInvoiceJour), recId).CustVendCorrectedInvoiceId), #CorrectiveLength);
            }
            else
            {
                value = strLFix(#BlankText, #CorrectiveLength);
            }
        }
        else
        {
            value = strLFix(#BlankText, #CorrectiveLength);
        }

        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldCorrelationNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the correlationNumber value.
    /// </summary>
    /// <returns>
    ///     The correlationNumber value.
    /// </returns>
    public str fieldCorrelationNum()
    {
        return strLFix(#BlankText, #FirstNumber + #LastNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldCountryIsoCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the country ISO code.
    /// </summary>
    /// <returns>
    ///     The country ISO code.
    /// </returns>
    public str fieldCountryIsoCode()
    {
        return strLFix(this.convertLoc(countryRegion.isOcode), #CountryLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldInvoiceDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the invoice date.
    /// </summary>
    /// <returns>
    ///     The invoice date.
    /// </returns>
    public str fieldInvoiceDate()
    {
        TransDate invoiceDate;

        if (this.isCashRegime())
        {
            if (taxReportLines.InvoiceDate &&
                !(custTrans.Invoice || vendTrans.Invoice))
            {
                invoiceDate = taxReportLines.InvoiceDate;
            }
            else
            {
                invoiceDate = taxReportLines.TransDate;
            }
        }
        else
        {
            if (taxReportLines.CashInvoiceYear)
            {
                invoiceDate = taxReportTable.ToDate;
            }
            else
            {
                invoiceDate = taxReportLines.TransDate;
            }
        }

        return this.formatDateLoc(invoiceDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldInvoiceId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the invoice id.
    /// </summary>
    /// <returns>
    ///     The invoice id.
    /// </returns>
    public str fieldInvoiceId()
    {
        return strLFix(this.convertLoc(taxReportLines.DocumentNum), #InvoiceIdLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldLegalRepresentativeVatNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the legalRepresentativeVatNum value.
    /// </summary>
    /// <returns>
    ///     The legalRepresentativeVatNum value.
    /// </returns>
    public str fieldLegalRepresentativeVatNum()
    {
        return strLFix(#BlankText, #CompanyVATNumberLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldNumberOfInvoices</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Formats the numberOfInvoices value.
    /// </summary>
    /// <param name="_invoiceNumberLength">
    ///     The invoice number length.
    /// </param>
    /// <returns>
    ///     The numberOfInvoices value.
    /// </returns>
    public str fieldNumberOfInvoices(int _invoiceNumberLength)
    {
        return num2Str0(1,_invoiceNumberLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldOperationDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the operationDate value.
    /// </summary>
    /// <returns>
    ///     The operationDate value.
    /// </returns>
    public str fieldOperationDate()
    {
        str                 value;
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;
        TaxTrans            taxTransLocal;

        if (this.isCashRegime())
        {
            return this.fieldInvoiceDate();
        }
        else
        {
            if (taxReportLines.CashInvoiceYear)
            {
                value = num2Str0(0, #DateLength);
            }
            else if (isCreditNote)
            {
                if (creditNotesCount == 1)
                {
                    value = this.formatDateLoc(reportingDate);
                }
                else
                {
                    value = this.formatDateLoc(dateEndMth(reportingDate));
                }
            }
            else
            {
                select firstonly DatePhysical from inventTrans
                order by DatePhysical asc
                    where  inventTrans.Voucher == taxReportLines.Voucher
                        && inventTrans.DateFinancial == taxReportLines.TransDate
                exists join inventTransOrigin
                    where  inventTransOrigin.RecId == inventTrans.InventTransOrigin
                join RecId from taxTransLocal
                    where  taxTransLocal.InventTransId == inventTransOrigin.InventTransId
                        && taxTransLocal.Voucher == inventTrans.Voucher
                        && taxTransLocal.TransDate == inventTrans.DateFinancial;

                if (inventTrans.DatePhysical)
                {
                    value = this.formatDateLoc(inventTrans.DatePhysical);
                }
                else
                {
                    value = this.formatDateLoc(taxReportLines.TransDate);
                }
            }
        }

        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldOperationType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the operationType value.
    /// </summary>
    /// <returns>
    ///     The operationtype value.
    /// </returns>
    public str fieldOperationType()
    {
        if (taxReportTable.isOperationCode2012Supported())
        {
            return strLFix(strupr(taxReportLines.OperationType), #OperationTypeLength);
        }

        return this.getOperationType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldPropertyTaxNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the propertyTaxNumber value.
    /// </summary>
    /// <returns>
    ///     The propertyTaxNumber value.
    /// </returns>
    public str fieldPropertyTaxNumber()
    {
        str ret = #BlankText;

        if (taxReportTable.isOperationCode2012Supported())
        {
            ret = strLFix(TaxReportToAscii340LineProcessor_ES::convert(taxReportLines.PropertyTaxNumber),#PropertyTaxNumberLength);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldRegisterId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the registerId value.
    /// </summary>
    /// <returns>
    ///     The registerId value.
    /// </returns>
    public str fieldRegisterId()
    {
        return strLFix(this.convertLoc(taxReportLines.ReportRecord), #RegisterIdLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldRegisterNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the number of tax report lines with cashInvoiceYear.
    /// </summary>
    /// <returns>
    ///     The number of tax report lines with cashInvoiceYear.
    /// </returns>
    public str fieldRegisterNum()
    {
        if (isDifferentVAT)
            return num2Str0(countRegs, #RegisterNumberLength);

        return num2Str0(1, #RegisterNumberLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldRelationName</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the relationName value.
    /// </summary>
    /// <returns>
    ///     The relationName value.
    /// </returns>
    public str fieldRelationName()
    {
        return strLFix(this.convertLoc(relationName), #NameLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldSituationCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the situationCode value.
    /// </summary>
    /// <returns>
    ///     The situationCode value.
    /// </returns>
    public str fieldSituationCode()
    {
        str ret = #BlankText;

        if (taxReportTable.isOperationCode2012Supported())
        {
            if (taxReportLines.SituationCode == TaxReportSituationCode_ES::None)
            {
                ret = num2Str0(0, #SituationCodeLength);
            }
            else
            {
                ret = strLFix(int2str(taxReportLines.SituationCode), #SituationCodeLength);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the taxAmount value.
    /// </summary>
    /// <returns>
    ///     The taxAmount value.
    /// </returns>
    public str fieldTaxAmount()
    {
        return this.amount2StrLoc(taxReportLines.TaxAmount, #VATAmountLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldTaxAmountDeductible</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the deductible tax amount value.
    /// </summary>
    /// <returns>
    ///     The deductible tax amount value.
    /// </returns>
    public str fieldTaxAmountDeductible()
    {
        if (!taxBookTaxCodes.NonDeductible)
        {
            return this.amount2StrLoc(taxTransTotal.TaxAmount - taxTransTotal.TaxInCostPriceMST, #DeductibleLength);
        }

        return this.amount2StrLoc(0, #DeductibleLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldTaxAmountEq</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the equivalence charge tax.
    /// </summary>
    /// <returns>
    ///     The equivalence charge tax.
    /// </returns>
    public str fieldTaxAmountEq()
    {
        return this.amount2StrLoc(taxReportLines.TaxAmountEq, #ECAmountLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldTaxBase</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the taxBase value.
    /// </summary>
    /// <returns>
    ///     The taxBase value.
    /// </returns>
    public str fieldTaxBase()
    {
        return this.amount2StrLoc(taxReportLines.TaxBase, #VATBaseLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldTaxBookType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the tax book type value.
    /// </summary>
    /// <param name="_capitalLetter">
    ///     The tax book type.
    /// </param>
    /// <returns>
    ///     The tax book type.
    /// </returns>
    public str fieldTaxBookType(str _capitalLetter)
    {
        return strLFix(_capitalLetter,#BookTypeLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldTaxValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the tax value.
    /// </summary>
    /// <returns>
    ///     The tax value.
    /// </returns>
    public str fieldTaxValue()
    {
        return strrem(num2Str0(abs(taxReportLines.TaxValue), #VATValueLength + 1, #DecimalLength, 2), #Comma);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldTaxValueEq</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the equivalence charge value.
    /// </summary>
    /// <returns>
    ///     The equivalence charge value.
    /// </returns>
    public str fieldTaxValueEq()
    {
        return strrem(num2Str0(abs(taxReportLines.TaxValueEq), #ECValue + 1, #DecimalLength, 2), #Comma);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldTotalInvoiceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the total invoice amount.
    /// </summary>
    /// <param name="_isOutgoingTax">
    ///     Boolean indicating if it is outgoing tax.
    /// </param>
    /// <returns>
    ///     The total invoice amount.
    /// </returns>
    public str fieldTotalInvoiceAmount(boolean _isOutgoingTax)
    {
        str value;

        if (_isOutgoingTax)
        {
            value = this.amount2StrLoc(taxReportLines.TaxBase + taxReportLines.TaxAmount + taxReportLines.TaxAmountEq, #TotalInvoiceAmountLength);
        }
        else
        {
            value = this.amount2StrLoc(taxReportLines.TaxBase + taxReportLines.TaxAmount, #TotalInvoiceAmountLength);
        }

        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldTypeOfIdInResidenceCountry</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the residence country type value.
    /// </summary>
    /// <returns>
    ///     The  residence country type value.
    /// </returns>
    public str fieldTypeOfIdInResidenceCountry()
    {
        #define.TypeOfIdInResidenceCountry_Domestic('1')
        #define.TypeOfIdInResidenceCountry_EU('2')
        #define.TypeOfIdInResidenceCountry_Other('6')

        str result;

        if (countryRegion.RecId)
        {
            switch (countryRegionType)
            {
                case CountryRegionType::Domestic:
                    result = #TypeOfIdInResidenceCountry_Domestic;
                    break;

                case CountryRegionType::EU:
                    result = #TypeOfIdInResidenceCountry_EU;
                    break;

                default:
                    result = #TypeOfIdInResidenceCountry_Other;
            }
        }
        else
        {
            result = #TypeOfIdInResidenceCountry_Other;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldVatCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the vat cost value.
    /// </summary>
    /// <returns>
    ///     The  vat cost value.
    /// </returns>
    public str fieldVatCost()
    {
        return this.amount2StrLoc(0, #VATCostLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldVatNumInResidenceCountry</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the vat number.
    /// </summary>
    /// <returns>
    ///     The vat number.
    /// </returns>
    public str fieldVatNumInResidenceCountry()
    {
        str             result;
        str             vatNumberWithoutCountryCode;
        EUSalesListTax  countryCode;

        if (countryRegion.RecId && countryRegionType == CountryRegionType::EU)
        {
            countryCode = TaxCountryRegionParameters::find(countryRegion.CountryRegionId).SalesTaxCode;

            vatNumberWithoutCountryCode = taxReportLines.VATNum;

            // If VAT number already contains country code then country code should be stripped from the vat number
            if (subStr(vatNumberWithoutCountryCode, 0, 2) == countryCode)
            {
                vatNumberWithoutCountryCode = strDel(vatNumberWithoutCountryCode, 0, 2);
            }

            result = strLFix(this.convertLoc(countryCode), #CountryLength);
            result += strLFix(this.convertLoc(vatNumberWithoutCountryCode), #VATRegLength);
            result += strLFix(#BlankText, #Space2Length);
        }
        else
        {
            result = strLFix(#BlankText, #CountryLength + #VATRegLength + #Space2Length);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formatDateLoc</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the given date.
    /// </summary>
    /// <param name="_date">
    ///     The given date.
    /// </param>
    /// <returns>
    ///     The formatted date.
    /// </returns>
    private str formatDateLoc(date _date)
    {
        return TaxReportToAscii340LineProcessor_ES::formatDate(_date);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOperationType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the operation type based on the type of invoice.
    /// </summary>
    /// <returns>
    ///     The operation type.
    /// </returns>
    public char getOperationType()
    {
        str operationType = #BlankText;

        if (this.isCashRegimeReported())
        {
            if (isDifferentVAT)
            {
                operationType = strLFix(#OperationType_MultipleVatCodesCashRegime, #OperationTypeLength);
            }

            else if (isCreditNote)
            {
                operationType = strLFix(#OperationType_CreditNoteCashRegime, #OperationTypeLength);
            }
            else
            {
                operationType = strLFix(#OperationType_UnSettledInvoice, #OperationTypeLength);
            }
        }
        else if (TaxReportToAscii340LineProcessor_ES::isAutoInvoice(taxReportLines) && taxBookTaxCodes.ReverseCharge)
        {
            operationType = strLFix(#OperationType_ReverseCharge, #OperationTypeLength);
        }
        else if (isDifferentVAT)
        {
            operationType = strLFix(#OperationType_MultipleVatCodes, #OperationTypeLength);
        }
        else if (isCreditNote)
        {
            operationType = strLFix(#OperationType_CreditNote, #OperationTypeLength);
        }

        if (! operationType)
        {
            operationType = strLFix(#BlankText, #OperationTypeLength);
        }
        return operationType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxBookType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the type of tax book.
    /// </summary>
    /// <returns>
    ///     The tax book type.
    /// </returns>
    public TaxBookType_ES getTaxBookType()
    {
        return taxReportLines.TaxBookType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCollectionMethodData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the values of collection data: method type and Bank Account or Payment Method Used.
    /// </summary>
    public void initCollectionMethodData()
    {
        Description      paymDescr;
        BankAccountTrans bankAccountTrans;
        CustVendTrans    custVendPaym;

        if (! this.isCashRegimeReported())
        {
            return;
        }

        if (custTrans)
        {
            custVendPaym = custTrans;
        }
        else
        {
            custVendPaym = vendTrans;
        }

        select firstonly ChequeNum, AccountId from bankAccountTrans
            where bankAccountTrans.Voucher   == custVendPaym.Voucher &&
                  bankAccountTrans.TransDate == custVendPaym.TransDate;

        if (bankAccountTrans.ChequeNum)
        {
            collectionMethod     = #ChequeMethod;
            collectionMethodInfo = bankAccountTrans.ChequeNum;
        }
        else if (bankAccountTrans.AccountId)
        {
            collectionMethod     = #BankAccountMethod;
            collectionMethodInfo = BankAccountTable::find(bankAccountTrans.AccountId).AccountNum;
        }
        else
        {
            paymDescr = CustVendPaymModeTable::findModule(custTrans ? ModuleCustVend::Cust : ModuleCustVend::Vend, custVendPaym.PaymMode).Description;
            paymDescr = paymDescr ? paymDescr : custVendPaym.PaymMode;
            collectionMethod     = #OtherMethod;
            collectionMethodInfo = paymDescr;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCorrectedCountCust</Name>
				<Source><![CDATA[
    private void initCorrectedCountCust()
    {
        CustInvoiceJour custInvoiceJour;
        CustTrans       custTransCount;

        void lookAtInvoiceJour(Voucher _voucher, TransDate _transDate)
        {
            while select RecId, InvoiceAmount, InvoiceDate from custInvoiceJour
                where custInvoiceJour.LedgerVoucher == _voucher
                && custInvoiceJour.InvoiceDate      == _transDate
            {
                if (custInvoiceJour.InvoiceAmount < 0)
                {
                    isCreditNote = true;

                    if (creditNotesCount == 0 || custInvoiceJour.InvoiceDate > reportingDate)
                    {
                        reportingDate = custVendTransOrig ? custVendTransOrig.TransDate : custInvoiceJour.InvoiceDate;
                        recId = custInvoiceJour.RecId;
                    }

                    creditNotesCount++;
                }
            }
        }

        creditNotesCount = 0;
        lookAtInvoiceJour(taxReportLines.Voucher, taxReportLines.TransDate);

        if (!creditNotesCount)            // If posted through GL without Invoice ID
        {
            while select RecId from custTransCount
                where custTransCount.Voucher == taxReportLines.Voucher
                    && custTransCount.TransDate == taxReportLines.TransDate
                    && custTransCount.Invoice
                    && custTransCount.AmountMST <  0
            {
                isCreditNote = true;

                if (creditNotesCount == 0)
                {
                    reportingDate = custVendTransOrig ? custVendTransOrig.TransDate : taxReportLines.TransDate;
                    recId   = 0;
                }

                creditNotesCount++;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCorrectedCountVend</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the number of vendor credit notes.
    /// </summary>
    public void initCorrectedCountVend()
    {
        VendInvoiceJour vendInvoiceJour;
        VendTrans       vendTransCount;

        void lookAtInvoiceJour(Voucher _voucher, TransDate _transDate)
        {
            while select InvoiceAmount, InvoiceDate from vendInvoiceJour
                where vendInvoiceJour.LedgerVoucher == _voucher
                    && vendInvoiceJour.InvoiceDate == _transDate
            {
                if (vendInvoiceJour.InvoiceAmount < 0)
                {
                    isCreditNote = true;

                    if (creditNotesCount == 0 || vendInvoiceJour.InvoiceDate > reportingDate)
                    {
                        reportingDate = custVendTransOrig ? custVendTransOrig.TransDate : vendInvoiceJour.InvoiceDate;
                    }

                    creditNotesCount++;
                }
            }
        }

        creditNotesCount = 0;
        lookAtInvoiceJour(taxReportLines.Voucher, taxReportLines.TransDate);

        // If posted through GL without Invoice ID
        if (creditNotesCount == 0)
        {
            select count(RecId) from vendTransCount
                where vendTransCount.Voucher == taxReportLines.Voucher
                    && vendTransCount.TransDate == taxReportLines.TransDate
                    && vendTransCount.Invoice
                    && vendTransCount.AmountMST > 0;

            if (vendTransCount.RecId > 0)
            {
                isCreditNote        = true;
                reportingDate       = custVendTransOrig ? custVendTransOrig.TransDate : taxReportLines.TransDate;
                creditNotesCount    = any2int(vendTransCount.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCountRegs</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the number of tax report lines having cash collectables.
    /// </summary>
    public void initCountRegs()
    {
        TaxReportLines taxReportLinesCount;

        select count(RecId) from taxReportLinesCount
            where  taxReportLinesCount.RefRecId == taxReportLines.RefRecId
                && taxReportLinesCount.Excluded == NoYes::No
                && taxReportLinesCount.Voucher   == taxReportLines.Voucher
                && taxReportLinesCount.TransDate == taxReportLines.TransDate
                && taxReportLinesCount.CashInvoiceYear == taxReportLines.CashInvoiceYear
                && taxReportLinesCount.AccountNum == taxReportLines.AccountNum;

        if (any2int(taxReportLinesCount.RecId) > 1)
        {
            countRegs = any2int(taxReportLinesCount.RecId);
            isDifferentVAT = true;
        }
        else
        {
            countRegs = 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCurrentTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the taxtrans and taxtranstotal from the current taxreport line.
    /// </summary>
    public void initCurrentTransaction()
    {
        TaxReportLinesTaxTrans_ES taxReportLinesTaxTrans;

        select firstonly TaxDirection, IntracomVAT from taxTrans
            where taxTrans.Voucher == taxReportLines.Voucher
                && taxTrans.TransDate == taxReportLines.TransDate
            exists join taxReportLinesTaxTrans
                  where taxReportLinesTaxTrans.TaxReportLines == taxReportLines.RecId
                    &&  taxReportLinesTaxTrans.TaxTrans == taxTrans.RecId;

        select sum(TaxAmount), sum(TaxInCostPriceMST) from taxTransTotal
            where taxTransTotal.Voucher        == taxReportLines.Voucher     &&
                    taxTransTotal.TransDate      == taxReportLines.TransDate   &&
                    taxTransTotal.TaxDirection   == taxTrans.TaxDirection      &&
                    taxTransTotal.IntracomVAT    == taxTrans.IntracomVAT
            exists join taxReportLinesTaxTrans
                where taxReportLinesTaxTrans.TaxReportLines == taxReportLines.RecId
                    && taxReportLinesTaxTrans.TaxTrans == taxTransTotal.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustTrans</Name>
				<Source><![CDATA[
    private void initCustTrans()
    {
        if (!taxReportLines.CashInvoiceYear)
        {
            if (taxReportLines.SourceTableId == tableNum(CustTrans) && taxReportLines.SourceRecId)

            {
                custTrans = CustTrans::find(taxReportLines.SourceRecId);
            }
            else
            {
                custTrans = CustTrans::findVoucherDate(taxReportLines.Voucher, taxReportLines.TransDate);
            }
            custVendTransOrig = conPeek(TransactionReversalTrans::findCustTransOrig(custTrans), 1);
            custTable         = CustTable::find(custTrans.AccountNum);
        }
        else
        {
            custTable = CustTable::find(taxReportLines.AccountNum);
        }

        isCashRegime        = CashAccountingRegime_ES::isEnabled(taxReportLines.TransDate);
        countryRegion       = LogisticsAddressCountryRegion::find(custTable.postalAddress().CountryRegionId);
        countryRegionType   = IntrastatCountryRegionParameters::type(countryRegion.CountryRegionId);
        relationName        = taxReportLines.Name ? taxReportLines.Name : custTable.name();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the customer/vendor transaction based on the type of transaction.
    /// </summary>
    public void initCustVendTransaction()
    {
        // Check if this is actually a vendor transaction using IntracomVAT
        if (taxTrans.IntracomVAT)
        {
            this.initVendorTrans();
            this.initCorrectedCountVend();
        }
        else
        {
            this.initCustTrans();
            this.initCorrectedCountCust();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVendorTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the vendor transaction details.
    /// </summary>
    public void initVendorTrans()
    {
        if (taxReportLines.SourceTableId == tableNum(VendTrans) && taxReportLines.SourceRecId)
        {
            vendTrans = VendTrans::find(taxReportLines.SourceRecId);
        }
        else
        {
            vendTrans = VendTrans::findVoucherDate(taxReportLines.Voucher, taxReportLines.TransDate);
        }
        custVendTransOrig   = conPeek(TransactionReversalTrans::findVendTransOrig(vendTrans), 1);
        vendTable           = VendTable::find(vendTrans.AccountNum);
        isCashRegime        = CashAccountingRegime_ES::isEnabled(taxReportLines.TransDate) ||
                              CashAccountingRegime_ES::isEnabled(taxReportLines.TransDate, vendTable.Party);
        countryRegion       = LogisticsAddressCountryRegion::find(vendTable.postalAddress().CountryRegionId);
        countryRegionType   = IntrastatCountryRegionParameters::type(countryRegion.CountryRegionId);
        relationName        = taxReportLines.Name ? taxReportLines.Name : vendTable.name();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCashRegime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the legal entity or vendor are in Cash Accounting Regime.
    /// </summary>
    /// <returns>
    /// true if the legal entity or vendor are in Cash Accounting Regime; otherwise, false.
    /// </returns>
    public boolean isCashRegime()
    {
        return isCashRegime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUnSettledInvoice</Name>
				<Source><![CDATA[
    private boolean isUnSettledInvoice()
    {
        if (taxReportLines.UnpaidInvoiceAmount)
        {
            return false;
        }

        if (custTrans.Invoice || vendTrans.Invoice)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCountryRegion</Name>
				<Source><![CDATA[
    public LogisticsAddressCountryRegion parmCountryRegion(LogisticsAddressCountryRegion _countryRegion = countryRegion)
    {
        countryRegion = _countryRegion;
        return countryRegion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCountryRegionType</Name>
				<Source><![CDATA[
    public CountryRegionType parmCountryRegionType(CountryRegionType _countryRegionType = countryRegionType)
    {
        countryRegionType = _countryRegionType;
        return countryRegionType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxBookTaxCodes</Name>
				<Source><![CDATA[
    public TaxBookTaxCodes parmTaxBookTaxCodes(TaxBookTaxCodes _taxBookTaxCodes = taxBookTaxCodes)
    {
        taxBookTaxCodes = _taxBookTaxCodes;
        return taxBookTaxCodes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxReportLines</Name>
				<Source><![CDATA[
    public TaxReportLines parmTaxReportLines(TaxReportLines _taxReportLines = taxReportLines)
    {
        taxReportLines = _taxReportLines;
        return taxReportLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxReportTable</Name>
				<Source><![CDATA[
    public TaxReportTable parmTaxReportTable(TaxReportTable _taxReportTable = taxReportTable)
    {
        taxReportTable = _taxReportTable;
        return taxReportTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxTrans</Name>
				<Source><![CDATA[
    public TaxTrans parmTaxTrans(TaxTrans _taxTrans = taxTrans)
    {
        taxTrans = _taxTrans;
        return taxTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Resets all the local parmeters used in the report.
    /// </summary>
    public void resetParameters()
    {
        creditNotesCount = 0;
        isDifferentVAT = false;
        isCreditNote = false;
        recId  = 0;

        select taxReportTable
            where taxReportTable.RecId == taxReportLines.RefRecId;

        taxBookTaxCodes = TaxBookTaxCodes::findByTaxBookCodes(taxReportTable.TaxBookTable,
                                                                taxReportLines.TaxCode,
                                                                taxReportLines.TaxCodeEq);
    }

]]></Source>
			</Method>
			<Method>
				<Name>amount2Str</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the amount to string with the sign.
    /// </summary>
    /// <param name="_amount">
    ///     The amount.
    /// </param>
    /// <param name="_lengthOfIntegerPart">
    ///     The length of the interger part in the amount.
    /// </param>
    /// <returns>
    ///     The formatted amount.
    /// </returns>
    public static str amount2Str(AmountCur _amount, int _lengthOfIntegerPart)
    {
        str sign = _amount >= 0 ? ' ' : #capitalN;

        return sign + TaxReportToAscii340LineProcessor_ES::amount2StrWithoutSign(_amount, _lengthOfIntegerPart);
    }

]]></Source>
			</Method>
			<Method>
				<Name>amount2StrWithoutSign</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the amount to string without the sign.
    /// </summary>
    /// <param name="_amount">
    ///     The amount.
    /// </param>
    /// <param name="_lengthOfIntegerPart">
    ///     The length of the interger part in the amount.
    /// </param>
    /// <returns>
    ///     The formatted amount.
    /// </returns>
    public static str amount2StrWithoutSign(AmountCur _amount, int _lengthOfIntegerPart)
    {
        int length = _lengthOfIntegerPart + 2;

        return strRfix(num2Str0(abs(round(_amount * 100, 0)), length), length);
    }

]]></Source>
			</Method>
			<Method>
				<Name>convert</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the given string value by substituting alternative characters to special characters.
    /// </summary>
    /// <param name="_value">
    ///     Given string value.
    /// </param>
    /// <returns>
    ///     The formatted string.
    /// </returns>
    public static str convert(str _value)
    {
        str         upperCasedValue;
        str         result;
        int         valueLength;
        int         charPosition;
        int         specialCharacterIndex;
        str         char;
        container   specialCharacters;
        container   specialCharactersSubstitutes;

        #Define.CharactersToKeepAsIs('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-ÑÇ')

        specialCharacters               = ['Â', 'À', 'Ä', 'Å', 'Á', 'Æ', 'É', 'Ê', 'Ë', 'È', 'Ï', 'Î', 'Ì', 'Í', 'Ô', 'Ö', 'Ò', 'Ó', 'Ø', 'Û', 'Ù', 'Ü', 'Ú', 'Ÿ'];
        specialCharactersSubstitutes    = ['A', 'A', 'A', 'A', 'A', 'A', 'E', 'E', 'E', 'E', 'I', 'I', 'I', 'I', 'O', 'O', 'O', 'O', 'O', 'U', 'U', 'U', 'U', 'Y'];

        valueLength     = strlen(_value);
        upperCasedValue = strupr(_value);

        for (charPosition = 1; charPosition <= valueLength; charPosition++)
        {
            char = substr(upperCasedValue, charPosition, 1);

            // Characters a-zA-Z0-9, minus sign (-), Ñ and Ç should not be modified
            if (strfind(char, #CharactersToKeepAsIs, 1, 1))
            {
                result += char;
                continue;
            }

            // Characters 'A', 'E', 'I', 'O', 'U', 'A', 'E', 'I', 'O', 'O', 'U' must  be converted to a,e,i,o,u.
            specialCharacterIndex = confind(specialCharacters, char);
            if (specialCharacterIndex)
            {
                result += conpeek(specialCharactersSubstitutes, specialCharacterIndex);
                continue;
            }

            // All other characters should be converted to spaces
            result += ' ';
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formatDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Formats the given date.
    /// </summary>
    /// <param name="_date">
    ///  The given date.
    /// </param>
    /// <returns>
    /// The date value.
    /// </returns>
    public static str formatDate(date _date)
    {
        return strLFix(date2str(_date, 321, 2, 0, 2, 0, 4, DateFlags::None), #DateLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAutoInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the tax report line is an auto invoice.
    /// </summary>
    /// <param name="_taxReportLine">
    ///     The tax report line.
    /// </param>
    /// <returns>
    ///     True if the line is an autoinvoice; otherwise, false.
    /// </returns>
    public static boolean isAutoInvoice(TaxReportLines _taxReportLine)
    {
        TaxTrans taxTransWithPositiveTaxValue;
        TaxTrans taxTransWithNegativeTaxValue;

        select firstOnly RecId from taxTransWithPositiveTaxValue
            where  taxTransWithPositiveTaxValue.Voucher == _taxReportLine.Voucher
                && taxTransWithPositiveTaxValue.TransDate == _taxReportLine.TransDate
                && taxTransWithPositiveTaxValue.TaxValue > 0;

        select firstOnly RecId from taxTransWithNegativeTaxValue
            where  taxTransWithNegativeTaxValue.Voucher == _taxReportLine.Voucher
                && taxTransWithNegativeTaxValue.TransDate == _taxReportLine.TransDate
                && taxTransWithNegativeTaxValue.TaxValue < 0;

        // Whenever we have at least one pair of sales tax transactions (positive and negative) we have auto-invoice/creditnote
        // We act under assumption that we are not allowed to combine an autoinvoice and a normal invoice within a single purchase order.
        return taxTransWithPositiveTaxValue.RecId != 0 && taxTransWithNegativeTaxValue.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCashRegimeReported</Name>
				<Source><![CDATA[
    private boolean isCashRegimeReported()
    {
        boolean ret = false;

        if (this.isCashRegime())
        {
            ret = taxReportLines.UnpaidInvoiceAmount ||
                  !(custTrans.Invoice || vendTrans.Invoice);
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>