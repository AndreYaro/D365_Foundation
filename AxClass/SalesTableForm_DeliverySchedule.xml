<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesTableForm_DeliverySchedule</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>SalesTableForm_DeliverySchedule</c> class is used to manage delivery schedules.
/// </summary>
/// <remarks>
///    This class is used by the <c>SalesDeliverySchedule</c> form.
/// </remarks>
class   SalesTableForm_DeliverySchedule
extends SalesTableForm_DlvScheduleSyncEnabled
{
    private LineNum                 lastScheduleLineNum;
    private SalesQty                totalQty;
    private SalesQty                allocateQtyRemain;
    private SalesMarkup             salesMarkupAllocateRemain;
    private SalesLineAmount         lineAmountAllocateRemain;
    private Map                     fixedMarkupRemainMap;

    SalesLine                       callerSalesLine;
    SalesLine                       orderLine;
    List                            scheduleLines;
    DlvScheduleMarkupConversionMode dlvScheduleMarkupConversionMode;
    LineNum                         minLineNum;

    #define.CurrentVersion(1)
    #localmacro.CurrentList
        dlvScheduleMarkupConversionMode
    #endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkAgreementDisassociation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the update of the <c>SalesLine</c> table with the values that are stored in the
    ///    temporary form data source results in a disassociation from an agreement.
    /// </summary>
    /// <returns>
    ///    true if an agreement disassociation is needed otherwise; false.
    /// </returns>
    boolean checkAgreementDisassociation()
    {
        SalesQty            qtyDiff;
        SalesLine           tmpSalesLine;
        boolean             linkOk = true;
        ListEnumerator      scheduleLinesEnumerator = scheduleLines.getEnumerator();

        if (!callerSalesLine.isLinkedToAgreement())
        {
            return false;
        }

        AgreementLine agreementLine = AgreementLine::find(callerSalesLine.MatchingAgreementLine);

        scheduleLinesEnumerator.reset();
        while (linkOk && scheduleLinesEnumerator.moveNext())
        {
            [tmpSalesLine] = scheduleLinesEnumerator.current();
            // testing each line against agreement conditions with Qty modified by the cumulative Qty delta of all the previous lines
            SalesLine testSalesLine = SalesLine::findInventTransId(tmpSalesLine.InventTransId, false);
            if (testSalesLine)
            {
                testSalesLine.initFromSalesLine(tmpSalesLine, true, true, true);
                testSalesLine.ReceiptDateRequested     = tmpSalesLine.ReceiptDateRequested;
                testSalesLine.ShippingDateRequested    = tmpSalesLine.ShippingDateRequested;
                testSalesLine.ShippingDateConfirmed    = tmpSalesLine.ShippingDateConfirmed;
                testSalesLine.ReceiptDateConfirmed     = tmpSalesLine.ReceiptDateConfirmed;
            }
            else
            {
                testSalesLine = tmpSalesLine;
            }

            testSalesLine.SalesQty += qtyDiff;
            linkOk = agreementLine.isLinkValid(testSalesLine, false);
            testSalesLine.SalesQty -= qtyDiff;

            qtyDiff += tmpSalesLine.SalesQty - testSalesLine.orig().SalesQty;
        }

        return !linkOk;
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextCreationSequenceNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the next unique LineCreationSequenceNumber per SalesId.
    /// </summary>
    /// <param name = "_line">Sales line buffer to get the next LineCreationSequenceNumber from.</param>
    /// <param name = "_salesId">SalesId of the SalesOrder.</param>
    /// <returns>Next unique LineCreationSequenceNumber for the given SalesId.</returns>
    public int nextCreationSequenceNumber(SalesLine _line, SalesID _salesId)
    {
        select maxof(LineCreationSequenceNumber)
            from _line
            where _line.SalesId == _salesId;

        return _line.LineCreationSequenceNumber + 1;

    }

]]></Source>
			</Method>
			<Method>
				<Name>closeOk</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the business logic triggered by pressing the OK button on the delivery schedule form.
    /// </summary>
    /// <param name="_formDataSource">
    ///    The data source of the delivery schedule form.
    /// </param>
    /// <param name="_extensionTableformDataSource">
    ///    The data source of the extension table.
    /// </param>
    /// <returns>
    ///    true if the form should be closed; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method is called from the client. It just packs and passes all the data to a server method.
    /// </remarks>
    boolean closeOk(FormDataSource _formDataSource, FormDataSource _extensionTableformDataSource = null)
    {
        List        newScheduleLines = new List(Types::Container);
        SalesLine   salesLine;
        // <GBR>
        SalesLine_BR salesLine_BR;
        // </GBR>
        // <GIN>
        SalesLine_IN    salesLine_IN;
        // </GIN>
        // <GEECZ>
        SalesLine_Intrastat salesLine_Intrastat;
        // </GEECZ>

        salesLine.setTmp();
        salesLine.setTmpData(_formDataSource.cursor());

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            salesLine_BR.setTmp();
            salesLine_BR.setTmpData(_extensionTableformDataSource.cursor());
        }
        // </GBR>
        // <GIN>
        else if (_extensionTableformDataSource
            && _extensionTableformDataSource.table() == tableNum(SalesLine_IN))
        {
            salesLine_IN.setTmp();
            salesLine_IN.setTmpData(_extensionTableformDataSource.cursor());
        }
        // </GIN>
        // <GEECZ>
        else if (_extensionTableformDataSource
            && _extensionTableformDataSource.table() == tableNum(SalesLine_Intrastat))
        {
            salesLine_Intrastat.setTmp();
            salesLine_Intrastat.setTmpData(_extensionTableformDataSource.cursor());
        }
        // </GEECZ>

        while select salesLine
        {
            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                select firstOnly salesLine_BR
                    where salesLine_BR.SalesLine == salesLine.RecId;

                salesline.packSalesLine_BR(salesLine_BR);
            }
            // </GBR>
            // <GIN>
            else if (_extensionTableformDataSource
                && _extensionTableformDataSource.table() == tableNum(SalesLine_IN))
            {
                select firstOnly salesLine_IN
                    where salesLine_IN.SalesLine == salesLine.RecId;

                salesline.packSalesLine_IN(salesLine_IN);
            }
            // </GIN>
            // <GEECZ>
            else if (_extensionTableformDataSource
                && _extensionTableformDataSource.table() == tableNum(SalesLine_Intrastat))
            {
                select firstOnly salesLine_Intrastat
                    where salesLine_Intrastat.SalesLine == salesLine.RecId;

                salesline.packSalesLine_Intrastat(salesLine_Intrastat);
            }
            // <GEECZ>
            newScheduleLines.addEnd([salesLine]);
        }

        return SalesTableForm_DeliverySchedule::closeOkServer(callerSalesLine,
            newScheduleLines.pack(),
            dlvScheduleMarkupConversionMode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLineAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a new order line can be created.
    /// </summary>
    /// <param name="_salesLine">
    ///     The currently selected sales order line.
    /// </param>
    /// <returns>
    ///     true when order lines can be edited, the intercompany settings allow line creation
    ///     and the order is not a return order; otherwise, false.
    /// </returns>
    public boolean createLineAllowed(SalesLine _salesLine)
    {
        boolean ret = this.editLineAllowed()
            && !salesTable.returnItem()
            && !salesTable.interCompanyAllowIndirectCreationOrig();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLineAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified order line can be deleted.
    /// </summary>
    /// <param name="_salesLine">
    ///    The order line to be checked for deletion.
    /// </param>
    /// <returns>
    ///    true when order lines can be edited, the intercompany settings enable line deletion, and the
    ///    <c>checkDelete</c> method returns true; otherwise, false.
    /// </returns>
    boolean deleteLineAllowed(SalesLine _salesLine)
    {
        boolean  deleteLine = true;

        if (_salesLine.InterCompanyOrigin == InterCompanyOrigin::Derived
            && salesTable.isInterCompanyOrder())
        {
            deleteLine = false;
        }
        else
        {
            deleteLine = this.editLineAllowed();
        }

        return deleteLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderLineQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the committed total quantity of the Delivery Schedule.
    /// </summary>
    /// <returns>
    /// The quantity on the order line that was captured at the time of opening the form.
    /// </returns>
    public SalesQty getOrderLineQty()
    {
        return orderLine.SalesQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueElementName</Name>
				<Source><![CDATA[
    public identifierName lastValueElementName()
    {
        return formstr(SalesDeliverySchedule);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a <c>SalesTableForm_DeliverySchedule</c> object.
    /// </summary>
    /// <param name="_source">
    /// The line for which the form was opened.
    /// </param>
    void new(Common _source)
    {
        callerSalesLine     = _source;
        scheduleLines       = new List(Types::Container);

        switch (callerSalesLine.LineDeliveryType)
        {
            case LineDeliveryType::OrderLineWithMultipleDeliveries:
                orderLine.data(callerSalesLine);
                break;
            case LineDeliveryType::DeliveryLine:
                orderLine = SalesDeliverySchedule::findOrderLineForDeliveryLine(callerSalesLine.InventTransId);
                if (!orderLine)
                {
                    // The order line of the selected delivery line was deleted.
                    throw error("@SYS131419");
                }
                break;
            default:
                // called for an order line without delivery lines
                orderLine.data(callerSalesLine);
        }

        super (callerSalesLine.salesTable());
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkupConversionMode</Name>
				<Source><![CDATA[
    DlvScheduleMarkupConversionMode parmMarkupConversionMode(DlvScheduleMarkupConversionMode _dlvScheduleMarkupConversionMode = dlvScheduleMarkupConversionMode)
    {
        dlvScheduleMarkupConversionMode = _dlvScheduleMarkupConversionMode;
        return dlvScheduleMarkupConversionMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmScheduleLines</Name>
				<Source><![CDATA[
    public List parmScheduleLines(List _scheduleLines = scheduleLines)
    {
        scheduleLines = _scheduleLines;

        return scheduleLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWTotalQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total catch weight quantity of the delivery schedule.
    /// </summary>
    /// <returns>
    ///    The sum of the catch weight quantities of all the lines in the delivery schedule.
    /// </returns>
    protected PdsCWInventQty pdsCWTotalQty()
    {
        PdsCWInventQty  qty;
        ListEnumerator  scheduleLinesEnumerator = scheduleLines.getEnumerator();

        scheduleLinesEnumerator.reset();
        while (scheduleLinesEnumerator.moveNext())
        {
            SalesLine salesLine = scheduleLinesEnumerator.current();
            qty += salesLine.PdsCWQty;
        }

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsGetCWQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves committed total catch weight quantity of the Delivery Schedule.
    /// </summary>
    /// <returns>
    ///     The catch weight quantity on the order line captured at the time of opening the form.
    /// </returns>
    public PdsCWInventQty pdsGetCWQty()
    {
        return orderLine.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesLine_Init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the data source of the form.
    /// </summary>
    /// <param name="_salesLine">
    /// The cursor of the data source to initialize.
    /// </param>
    /// <param name="_extensionTable">
    /// The cursor of the extension table data source to initialize.
    /// </param>
    /// <remarks>
    /// It sets the data source table buffer to temporary mode and then populates it with delivery lines of
    /// the schedule the form was called for or with the line it was called for in case it was an order
    /// line without delivery lines.
    /// </remarks>
    public void salesLine_Init(SalesLine _salesLine, SysExtensionSerializerExtensionMap _extensionTable = null)
    {
        SalesLine               localSalesLine;
        SalesDeliverySchedule   salesDeliverySchedule;
        boolean                 isMinLineNumSet = false;
        SalesLineCreationSequenceNumber creationSequenceNumber;
        _salesLine.setTmp();
        delete_from _salesLine;

        _extensionTable.setTmp();
        delete_from _extensionTable;

        if (callerSalesLine.LineDeliveryType != LineDeliveryType::OrderLine)
        {
            while select localSalesLine
                exists join salesDeliverySchedule
                    where salesDeliverySchedule.OrderLine    == orderLine.InventTransId
                       && salesDeliverySchedule.DeliveryLine == localSalesLine.InventTransId
            {
                creationSequenceNumber = this.nextCreationSequenceNumber(_salesLine, localSalesLine.SalesId);
                _salesLine.data(localSalesLine);
                _salesLine.LineCreationSequenceNumber = creationSequenceNumber;
                _salesLine.doInsert();

                // <GBR>
                if (BrazilParameters::isEnabled())
                {
                    buf2Buf(localSalesLine.salesLine_BR(), _extensionTable);
                    _extensionTable.BaseRecId = _salesLine.RecId;
                    _extensionTable.doInsert();
                }
                // </GBR>
                // <GIN>
                else if (_extensionTable.TableId == tableNum(SalesLine_IN))
                {
                    buf2Buf(localSalesLine.salesLine_IN(), _extensionTable);
                    _extensionTable.BaseRecId = _salesLine.RecId;
                    _extensionTable.doInsert();
                }
                // </GIN>
                // <GEECZ>
                else if (_extensionTable.TableId == tableNum(SalesLine_Intrastat))
                {
                    buf2Buf(localSalesLine.salesLine_Intrastat(), _extensionTable);
                    _extensionTable.BaseRecId = _salesLine.RecId;
                    _extensionTable.doInsert();
                }
                // </GEECZ>
                else if (_extensionTable.TableId == tableNum(MCRSalesLine))
                {
                    buf2Buf(localSalesLine.mcrSalesLine(), _extensionTable);
                    _extensionTable.BaseRecId = _salesLine.RecId;
                    _extensionTable.doInsert();
                }

                if (!isMinLineNumSet || _salesLine.LineNum < minLineNum)
                {
                    minLineNum = _salesLine.LineNum;
                    isMinLineNumSet = true;
                }
            }
            if (!isMinLineNumSet)
            {
                minLineNum = orderLine.LineNum + 1;
            }
        }
        else
        {
            creationSequenceNumber = this.nextCreationSequenceNumber(_salesLine, callerSalesLine.SalesId);
            _salesLine.data(callerSalesLine);
            _salesLine.LineDeliveryType = LineDeliveryType::DeliveryLine;
            _salesLine.LineCreationSequenceNumber = creationSequenceNumber;
            _salesLine.doInsert();

            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                buf2Buf(callerSalesLine.salesLine_BR(), _extensionTable);
                _extensionTable.BaseRecId = _salesLine.RecId;
                _extensionTable.doInsert();
            }
            // </GBR>
            // <GIN>
            else if (_extensionTable.TableId == tableNum(SalesLine_IN))
            {
                buf2Buf(callerSalesLine.salesLine_IN(), _extensionTable);
                _extensionTable.BaseRecId = _salesLine.RecId;
                _extensionTable.doInsert();
            }
            // </GIN>
            // <GEECZ>
            else if (_extensionTable.TableId == tableNum(SalesLine_Intrastat))
            {
                buf2Buf(callerSalesLine.salesLine_Intrastat(), _extensionTable);
                _extensionTable.BaseRecId = _salesLine.RecId;
                _extensionTable.doInsert();
            }
            // </GEECZ>
            else if (_extensionTable.TableId == tableNum(MCRSalesLine))
            {
                buf2Buf(localSalesLine.mcrSalesLine(), _extensionTable);
                _extensionTable.BaseRecId = _salesLine.RecId;
                _extensionTable.doInsert();
            }

            minLineNum = _salesLine.LineNum;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesLine_InitValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes new delivery line.
    /// </summary>
    /// <param name="_salesLine">
    /// The delivery line to initialize.
    /// </param>
    void salesLine_InitValue(SalesLine _salesLine)
    {
        if (_salesLine.LineNum < minLineNum)
        {
            _salesLine.LineNum = minLineNum;
        }

        _salesLine.initFromOrderLineWithMultipleDeliveries(orderLine);

        InventMovement::bufferSetTransQtyUnit(_salesLine);
        InventMovement::bufferSetRemainQty(_salesLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total quantity of the delivery schedule.
    /// </summary>
    /// <returns>
    ///    The sum of the quantities of all the lines in the delivery schedule.
    /// </returns>
    protected SalesQty totalQty()
    {
        SalesQty        qty;
        ListEnumerator  scheduleLinesEnumerator = scheduleLines.getEnumerator();

        scheduleLinesEnumerator.reset();
        while (scheduleLinesEnumerator.moveNext())
        {
            SalesLine salesLine = scheduleLinesEnumerator.current();
            qty += salesLine.SalesQty;
        }

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        boolean ret;
        Integer version = conpeek(packedClass,1);

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = packedClass;
                    ret = true;
                    break;
                default:
                    ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesLineTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfers an accepted delivery from the temporary form data source to the <c>SalesLine</c> table in
    /// the database.
    /// </summary>
    /// <param name="_agreementDisassociationNeeded">
    /// A Boolean value that indicates whether delivery schedule needs to be unlinked from an agreement
    /// before being updated.
    /// </param>
    /// <remarks>
    /// If the form was opened for an order line without delivery lines it is first converted to a delivery
    /// schedule.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// The delivery schedule update failed.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// The delivery schedule update violates the referenced Agreement constraints.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// The insertion of the delivery line failed.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// The deletion of the delivery line failed.
    /// </exception>
    void updateSalesLineTable(boolean _agreementDisassociationNeeded)
    {
        #OCCRetryCount

        SalesLine                   tmpSalesLine;
        SalesLine                   dbSalesLine;
        SalesDeliverySchedule       salesDeliverySchedule;
        Set                         inventTransIds = new Set(Types::String);
        boolean                     initialConversion = false;
        ListEnumerator              scheduleLinesEnumerator = scheduleLines.getEnumerator();
        DocuRef                     callerSalesLineDocuRef;
        SalesLine                   orderLineDocuOrig;

        try
        {
            ttsbegin;

            if (_agreementDisassociationNeeded)
            {
                AgreementLineReleasedLine::unlinkSalesDeliverySchedule(orderLine.InventTransId);
                orderLine.reread();
                callerSalesLine.reread();
            }

            boolean isTaxInformationEnabled = TaxIntegrationUtils::isTaxInformationEnabled();

            if (callerSalesLine.LineDeliveryType == LineDeliveryType::OrderLine)
            {
                orderLine = callerSalesLine.convertToDeliverySchedule();
                if (isTaxInformationEnabled)
                {
                    TransTaxInformationHelper::copyTransTaxInformation(callerSalesLine, orderLine);
                }
                initialConversion = true;
                totalQty = this.totalQty();
                allocateQtyRemain = totalQty;
                salesMarkupAllocateRemain = orderLine.SalesMarkup;
                lineAmountAllocateRemain = callerSalesLine.LineAmount;
                Markup::delete(callerSalesLine);
                orderLine.SalesQty = this.totalQty(); // set totalQty for misc charges allocation purposes
                fixedMarkupRemainMap = new Map(Types::Int64, Types::Container);

                // Since callerSalesLine becomes from the first delivery line we have to create copy of DocuRef for orderLine which becomes header line.
                if (callerSalesLine.RecId != orderLine.RecId)
                {
                    this.copyAttachmentToOrderLine(callerSalesLine, orderLine);
                }
            }

            lastScheduleLineNum = SalesLine::lastDeliveryScheduleLineNum(orderLine.InventTransId);

            orderLineDocuOrig = SalesDeliverySchedule::findOrderLineForDeliveryLine(callerSalesLine.InventTransId);

            scheduleLinesEnumerator.reset();
            while (scheduleLinesEnumerator.moveNext())
            {
                [tmpSalesLine] = scheduleLinesEnumerator.current();
                dbSalesLine = this.writeDeliveryLine(tmpSalesLine, initialConversion, lastScheduleLineNum);
                if (isTaxInformationEnabled)
                {
                    TransTaxInformationHelper::copyTransTaxInformation(orderLine, dbSalesLine);
                }
                inventTransIds.add(dbSalesLine.InventTransId);

                // Create copy of DocuRef for each delivery line if the attachment for the main line.                
                if (orderLineDocuOrig.RecId != dbSalesLine.RecId && callerSalesLine.RecId != dbSalesLine.RecId)
                {
                    this.copyAttachmentToOrderLine(orderLineDocuOrig, dbSalesLine);
                }                
            }

            while select forupdate dbSalesLine
                join salesDeliverySchedule
                    where salesDeliverySchedule.OrderLine    == orderLine.InventTransId
                       && salesDeliverySchedule.DeliveryLine == dbSalesLine.InventTransId
            {
                if (!inventTransIds.in(dbSalesLine.InventTransId))
                {
                    if (dbSalesLine.validateDelete())
                    {
                        dbSalesLine.deleteWithoutUpdatingDeliveryScheduleLines();
                    }
                    else
                    {
                        // The deletion of the delivery line failed.
                        throw error("@SYS131423");
                    }
                }
            }

            orderLine = SalesLine::findRecId(orderLine.RecId, true);
            // recalculate price on order line if it was disassociated from a agreement.
            if (_agreementDisassociationNeeded)
            {
                SalesLine::modifySalesQty(orderLine, orderLine.inventDim());
            }

            if (initialConversion)
            {
                Markup::delete(orderLine);
                orderLine.SalesMarkup = 0;

                // <GIN>
                orderLine.updateAndPackAccessableValue_IN();
                // </GIN>
            }

            this.updateOrderLineAndRecalculateDeliverySchedule(orderLine);

            if (!RetailPricingKillSwitch::disableRecalculationWhenSalesLineSplitByDeliverySchedule())
            {
                this.recalculateRetailSalesOrder(salesTable);
            }

            this.setTouched(salesTable);

            if (FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance()))
            {
                this.kittingUpdateParts_delegate(orderLine);
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::Error)
        {
            ttsabort;
            throw error("@SYS93835");
        }

        this.deliveryLinesSync(orderLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeDeliveryLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates or creates the delivery line.
    /// </summary>
    /// <param name = "_tmpSalesLine">The <c>SalesLine</c> record to initialize from.</param>
    /// <param name = "_initialConversion">A boolean value that indicates whether it is an initial conversion.</param>
    /// <param name = "_lastScheduleLineNum">The line number of the last scheduled order line.</param>
    /// <returns>The delivery line.</returns>
    protected SalesLine writeDeliveryLine(SalesLine _tmpSalesLine, boolean _initialConversion, LineNum _lastScheduleLineNum)
    {
        SalesLine                     dbSalesLine;
        SalesMarkup                   salesMarkupAllocateHere;
        SalesLineAmount               lineAmountAllocateHere;
        SalesLine                     firstLineAfterSchedule;
        SalesDeliverySchedule         salesDeliverySchedule;
        SalesLineForeignTradeCategory salesLineForeignTradeCategory;

        // <GEEPL>
        #ISOCountryRegionCodes
        // </GEEPL>
        
        select firstonly LineNum from firstLineAfterSchedule
                order by LineNum
                where firstLineAfterSchedule.SalesId == orderLine.SalesId
                   && firstLineAfterSchedule.LineNum > _lastScheduleLineNum;

        if (_initialConversion)
        {
            // for split markup allocation calculate the markup for the current line.
            if (dlvScheduleMarkupConversionMode == DlvScheduleMarkupConversionMode::Split)
            {
                if (_tmpSalesLine.SalesQty >= allocateQtyRemain)
                {
                    salesMarkupAllocateHere = CurrencyExchangeHelper::amount(salesMarkupAllocateRemain, _tmpSalesLine.CurrencyCode);
                }
                else
                {
                    salesMarkupAllocateHere = CurrencyExchangeHelper::amount(orderLine.SalesMarkup * _tmpSalesLine.SalesQty / totalQty, _tmpSalesLine.CurrencyCode);
                }
                salesMarkupAllocateRemain -= salesMarkupAllocateHere;
            }

            // when converting a line without unit price allocate the LineAmount according to quantity
            if (!callerSalesLine.SalesPrice && callerSalesLine.LineAmount)
            {
                if (_tmpSalesLine.SalesQty >= allocateQtyRemain)
                {
                    lineAmountAllocateHere = CurrencyExchangeHelper::amount(lineAmountAllocateRemain, _tmpSalesLine.CurrencyCode);
                }
                else
                {
                    lineAmountAllocateHere = CurrencyExchangeHelper::amount(callerSalesLine.LineAmount * _tmpSalesLine.SalesQty / totalQty, _tmpSalesLine.CurrencyCode);
                }
                lineAmountAllocateRemain -= lineAmountAllocateHere;
            }

            allocateQtyRemain -= _tmpSalesLine.SalesQty;
        }

        dbSalesLine = SalesLine::findInventTransId(_tmpSalesLine.InventTransId,true);

        if (dbSalesLine)
        {
            dbSalesLine.initFromSalesLine(_tmpSalesLine, true, true, true);
            dbSalesLine.DeliveryDateControlType  = _tmpSalesLine.DeliveryDateControlType;
            dbSalesLine.ReceiptDateRequested     = _tmpSalesLine.ReceiptDateRequested;
            dbSalesLine.ShippingDateRequested    = _tmpSalesLine.ShippingDateRequested;
            dbSalesLine.ShippingDateConfirmed    = _tmpSalesLine.ShippingDateConfirmed;
            dbSalesLine.ReceiptDateConfirmed     = _tmpSalesLine.ReceiptDateConfirmed;
            dbSalesLine.ConfirmedDlv             = _tmpSalesLine.ConfirmedDlv;

            if (_initialConversion && dlvScheduleMarkupConversionMode == DlvScheduleMarkupConversionMode::Split)
            {
                dbSalesLine.SalesMarkup = salesMarkupAllocateHere;
                dbSalesLine.LineAmount  = dbSalesLine.calcLineAmountForced();
            }

            if (_initialConversion && !callerSalesLine.SalesPrice && callerSalesLine.LineAmount)
            {
                dbSalesLine.LineAmount = lineAmountAllocateHere;
            }

            this.salesLine_Write(dbSalesLine);

            if (dbSalesLine.validateWrite())
            {
                dbSalesLine.updateWithoutUpdatingDeliveryScheduleLines();
            }
            else
            {
                // Delivery Schedule update failed.
                throw error("@SYS131420");
            }

            if (!dbSalesLine.refreshAgreementLink(new AgreementAutolinkHelperSalesLine(), true))
            {
                // Delivery Schedule update violates the referenced Agreement constrains.
                throw error("@SYS131421");
            }
        }
        else
        {
            dbSalesLine.data(_tmpSalesLine.data());
            dbSalesLine.LineCreationSequenceNumber = 0;
            dbSalesLine.RecId = 0;
            dbSalesLine.MatchingAgreementLine = orderLine.MatchingAgreementLine;

            // <GIN>
            // This <GIN/> block and the <GIN/> block following are a workaround
            // to avoid AssessableValueTransactionCurrency to be overwritten.
            AmountCur assessableValueTransactionCurrency = 0.0;
            if (TaxParameters::checkTaxParameters_IN())
            {
                SalesLine_IN dbSalesLine_IN = dbSalesLine.salesLine_IN();
                assessableValueTransactionCurrency = dbSalesLine_IN.AssessableValueTransactionCurrency;
            }
            // </GIN>

            dbSalesLine.SysExtensionSerializerMap::copyExtensionTableData(callerSalesLine);

            // <GIN>
            if (TaxParameters::checkTaxParameters_IN())
            {
                SalesLine_IN dbSalesLine_IN = dbSalesLine.salesLine_IN();
                dbSalesLine_IN.AssessableValueTransactionCurrency = assessableValueTransactionCurrency;
                dbSalesLine.packSalesLine_IN(dbSalesLine_IN);
            }
            // </GIN>

            if (_initialConversion && dlvScheduleMarkupConversionMode == DlvScheduleMarkupConversionMode::Split)
            {
                dbSalesLine.SalesMarkup = salesMarkupAllocateHere;
                dbSalesLine.LineAmount = dbSalesLine.calcLineAmountForced();
            }

            if (_initialConversion && !callerSalesLine.SalesPrice && callerSalesLine.LineAmount)
            {
                dbSalesLine.LineAmount = lineAmountAllocateHere;
            }

            // adjust line number if it would mix delivery lines with order lines following the schedule.
            if (dbSalesLine.LineNum > _lastScheduleLineNum && firstLineAfterSchedule)
            {
                dbSalesLine.LineNum = (_lastScheduleLineNum  + firstLineAfterSchedule.LineNum) / 2;
            }

            lastScheduleLineNum = max(_lastScheduleLineNum, dbSalesLine.LineNum);

            this.salesLine_Write(dbSalesLine);

            if (dbSalesLine.validateWrite())
            {
                this.insertDeliveryLine(dbSalesLine);
                if (FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance()))
                {
                    this.kittingProcessCopy_delegate(orderLine, dbSalesLine);
                }
            }
            else
            {
                // The insertion of the delivery line failed.
                throw error("@SYS131422");
            }

            // <GEEPL>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
            {
                TaxServiceTariff::insertTaxServiceTariffForNewParent(callerSalesLine.TableId, callerSalesLine.RecId, dbSalesLine.TableId, dbSalesLine.RecId);
            }
            // </GEEPL>

            if (!dbSalesLine.refreshAgreementLink(new AgreementAutolinkHelperSalesLine(), true))
            {
                // Delivery Schedule update violates the referenced Agreement constrains.
                throw error("@SYS131421");
            }

            salesDeliverySchedule.OrderLine    = orderLine.InventTransId;
            salesDeliverySchedule.DeliveryLine = dbSalesLine.InventTransId;
            salesDeliverySchedule.insert();

            if (dbSalesLine.isCategoryBased())
            {
                salesLineForeignTradeCategory.initFromSalesLine(dbSalesLine);
                salesLineForeignTradeCategory.insert();
            }
        }

        if (_initialConversion)
        {
            Markup::copyFromOrderLineWithMultipleDeliveries(orderLine, dbSalesLine, dlvScheduleMarkupConversionMode, fixedMarkupRemainMap);
        }

        return dbSalesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDeliveryLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the given <c>SalesLine</c> record.
    /// </summary>
    /// <param name = "_deliverySalesLine">
    /// The record to be inserted.
    /// </param>
    protected void insertDeliveryLine(SalesLine _deliverySalesLine)
    {
        _deliverySalesLine.insert(false, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes the changes made to the given order line.
    /// </summary>
    /// <param name = "_orderLine">
    /// The order line that should be updated.
    /// </param>
    protected void writeOrderLine(SalesLine _orderLine)
    {
        this.salesLine_Write(_orderLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOrderLineAndRecalculateDeliverySchedule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the given order line, and re calculates the delivery schedule.
    /// </summary>
    /// <param name = "_orderLine">
    /// The order line that should be updated.
    /// </param>
    protected void updateOrderLineAndRecalculateDeliverySchedule(SalesLine _orderLine)
    {
        this.writeOrderLine(orderLine);
        _orderLine.recalculateDeliveryScheduleOrderLine(true);
        _orderLine.updateWithoutUpdatingDeliveryScheduleLines();
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalculateRetailSalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculates prices and discounts on the sales order if it is retail order.
    /// </summary>
    /// <param name = "_salesTable">The sales order to be recalculated.</param>
    protected void recalculateRetailSalesOrder(SalesTable _salesTable)
    {
        RetailSalesTable retailSales = _salesTable.retailSalesTable();
        if (RetailParameters::isRetailEnabledAndInUse() && retailSales.RetailOrder == NoYes::Yes)
        {
            // Unlock price for all lines associated with the delivery schedule so that recalculation will take effect.
            RetailSalesLine retailSalesLine;
            SalesLine salesLine;
            SalesDeliverySchedule salesDeliverySchedule;

            update_recordset retailSalesLine
                setting IsPriceLocked = NoYes::No
                exists join salesLine
                    where salesLine.RecId == retailSalesLine.SalesLine
                exists join salesDeliverySchedule
                    where (salesDeliverySchedule.DeliveryLine == salesLine.InventTransId || salesDeliverySchedule.OrderLine == salesLine.InventTransId)
                        && salesDeliverySchedule.OrderLine == orderLine.InventTransId;

            RetailSalesOrderCalculator::setPricesDiscountsOnOrderOnServer(_salesTable.SalesId, retailSales.TotalManualDiscountPercentage);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the business logic triggered by pressing the OK button on the delivery schedule form.
    /// </summary>
    /// <returns>
    ///    true if the form should be closed; otherwise, false.
    /// </returns>
    boolean updateSchedule()
    {
        boolean ret = false;
        boolean agreementDisassociationNeeded = this.checkAgreementDisassociation();

        // Your changes break constrains of the referenced Agreement. Do you want to disassociate the Delivery Schedule from the Agreement?
        if (!agreementDisassociationNeeded
            || Box::yesNo("@SYS131413", DialogButton::No) == DialogButton::Yes)
        {
             this.updateSalesLineTable(agreementDisassociationNeeded);
             ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useAlternativeItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls whether the item in question should be replaced with the alternative item that is set up
    /// in the Item Details form.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    /// <remarks>
    /// New delivery lines should never use Alternative Items.
    /// </remarks>
    public boolean useAlternativeItem()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeOkServer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the business logic that was triggered by pressing the OK button on the delivery schedule
    /// form.
    /// </summary>
    /// <param name="_callerSalesLine">
    /// The line for which the form was opened.
    /// </param>
    /// <param name="_scheduleLines">
    /// A list of lines from the data source of the form.
    /// </param>
    /// <param name="_dlvScheduleMarkupConversionMode">
    /// The mode of converting markup from order line to delivery lines.
    /// </param>
    /// <returns>
    /// true if the form should be closed; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method creates the object of the class on the server based on the serialized data passed by
    /// the client and then calls the <c>updateSchedule</c> method.
    /// </remarks>
    static boolean closeOkServer(
        SalesLine _callerSalesLine,
        container _scheduleLines,
        DlvScheduleMarkupConversionMode _dlvScheduleMarkupConversionMode)
    {
        SalesTableForm_DeliverySchedule salesTableForm_DeliverySchedule = new SalesTableForm_DeliverySchedule(_callerSalesLine);

        salesTableForm_DeliverySchedule.parmScheduleLines(List::create(_scheduleLines));
        salesTableForm_DeliverySchedule.parmMarkupConversionMode(_dlvScheduleMarkupConversionMode);

        return salesTableForm_DeliverySchedule.updateSchedule();
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingProcessCopy_delegate</Name>
				<Source><![CDATA[
    delegate void kittingProcessCopy_delegate(SalesLine _origLine, SalesLine _newLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingUpdateParts_delegate</Name>
				<Source><![CDATA[
    delegate void kittingUpdateParts_delegate(SalesLine _orderLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyAttachmentToOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copy the attachment to the delivery line
    /// </summary>
    /// <param name = "_salesLineFrom">The sales line which attachment is copied</param>
    /// <param name = "_salesLineTo">The sales line to copy the attachment</param>
    private void copyAttachmentToOrderLine(SalesLine _salesLineFrom, SalesLine _salesLineTo)
    {
        DocuRef salesLineDocuRef;

        while select salesLineDocuRef
            where salesLineDocuRef.RefCompanyId == _salesLineFrom.DataAreaId &&
                  salesLineDocuRef.RefTableId   == _salesLineFrom.TableId    &&
                  salesLineDocuRef.RefRecId     == _salesLineFrom.RecId
        {
            DocuRef::createFromDocuRef(salesLineDocuRef, _salesLineTo.RecId, _salesLineTo.TableId);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>