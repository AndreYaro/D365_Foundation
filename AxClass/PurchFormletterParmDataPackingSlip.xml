<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchFormletterParmDataPackingSlip</Name>
	<SourceCode>
		<Declaration><![CDATA[
[DocumentStatusFactoryAttribute(DocumentStatus::PackingSlip)]
class PurchFormletterParmDataPackingSlip extends PurchFormletterParmData
implements FormLetterParmDataCorrectable
{
    // <GEERU>
    OfficialsServ_RU offSrv;
    // </GEERU>
    InterCompanyEndpointActionPolicyTransfer actionPolicyTransfer;

    // <GIN>
    // this variable determines if this PackingSlip is for BOE
    boolean                 isFromBillOfEntryforPackingSlip;
    // Map for holding the CustomsVendBOETrans records
    Map                     subLinesMap;
    // Current source table and line. These are used since chooseLines will point to the next records.
    Common                  currentSourceLine;
    Common                  currentSourceTable;
    // Is chooselines pointing at the end?
    boolean                 chooseLinesEOF;
    // Is current source table changed? (Saved value of chooseLines.changed(tablenum(PurchTable))
    boolean                 currentSourceTableChanged;
    RecordInsertList        recordInsertParmSubLine;
    PurchQty                newPostingPurchQtyPCK;
    InventQty               newPostingInventQtyPCK;
    PurchQty                newPostingPreVerPurchQtyPCK;
    InventQty               newPostingPreVerInventQtyPCK;
    CustomsVendBOETrans_IN  parmCustomsVendBOETrans;
    RecordInsertList        puchParmLineINRecordList;
    // </GIN>

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>chooseLinesChangedSourceTable</Name>
				<Source><![CDATA[
    protected boolean chooseLinesChangedSourceTable()
    {
        if (isFromBillOfEntryforPackingSlip)
        {
            return currentSourceTableChanged;
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesFromWMSJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Chooses lines for Product receipt posting based on posted <c>WMSJournalTable</c> journals.
    /// </summary>
    /// <remarks>
    /// The sum of quantities from lines in selected journals may exceed the currently Registered quantities for a given purchase order line.
    /// In that case ensure we don't post quantities exceeding what is Registered.
    /// </remarks>
    protected void  chooseLinesFromWMSJournalTable()
    {
        WMSJournalTable     localWMSJournalTable;
        WMSJournalTrans     localWMSJournalTrans;
        PurchParmLine       localPurchParmLine;
        PurchId             localPurchId;
        PurchLine           localPurchLine;
        PackingSlipId       localPackingSlipId;
        TradeLineRefId      tableRefId;
        List                list;
        ListEnumerator      listEnumerator;
        real                lineNumIncrement;
        // <GEERU>
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        InventTrans         localInventTrans;
        InventTransOrigin   localInventTransOrigin;
        Map                 map = new Map(Types::String, Types::Container);
        MapEnumerator       mapEnumerator;
        PurchLine           tempPurchLine;
        InventQty           tempQty;
        TradeLineRefId      tempTableRefId;
        PdsCWInventQty      tempPdsCwQty;
        InventDimId         tempInventDimId;
        str                 hashKey;
        InventQty           qtyForPosting;
        PdsCWInventQty      cWQtyForPosting;
        boolean             poNeedsToBeConfirmed;

        ttsbegin;
        this.initRecordLists();
        list = List::create(this.parmLineList());
        listEnumerator = list.getEnumerator();

        setPrefix("@SYS332874");
        while (listEnumerator.moveNext())
        {
            localWMSJournalTable = listEnumerator.current();
            setPrefix(localWMSJournalTable.JournalId);

            if (localWMSJournalTable.Posted)
            {
                if (localPackingSlipId != localWMSJournalTable.PackingSlip)
                {
                    localPackingSlipId  = localWMSJournalTable.PackingSlip;
                    localPurchId        = '';
                }

                while select InventTransId, sum(Qty), sum(PdsCWQty) from localWMSJournalTrans
                    group by InventTransId, inventTransRefId
                    order by inventTransRefId
                    where localWMSJournalTrans.JournalId        == localWMSJournalTable.JournalId
                        && localWMSJournalTrans.InventTransType  == InventTransType::Purch
                notExists join localPurchParmLine
                    where  localPurchParmLine.ParmId         == parmId
                        && localPurchParmLine.InventTransId  == localWMSJournalTrans.InventTransId
                {
                    localPurchLine = PurchLine::findInventTransId(localWMSJournalTrans.InventTransId);
                    if (localPurchLine.purchTable().DocumentState != VersioningDocumentState::Confirmed)
                    {
                        poNeedsToBeConfirmed = true;
                        error(strFmt("@SCM:PONotConfirmed", localPurchLine.PurchId));
                        continue;
                    }

                    if (!localPurchLine.Blocked && !poNeedsToBeConfirmed)
                    {
                        // <GEERU>
                        if (countryRegion_RU)
                        {
                            tableRefId = this.getTableRefId(localPurchLine);
                            if (! parmTableMap.exists(this.parmTableMapKey(localPurchLine)))
                            {
                                this.createParmTable(PurchTable::find(localPurchLine.PurchId),
                                                        localPurchLine,
                                                        tableRefId,
                                                        false,
                                                        false,
                                                        false,
                                                        localPackingSlipId);
                            }
                        }
                        else
                        {
                            // </GEERU>
                            if (localPurchId != localPurchLine.PurchId)
                            {
                                localPurchId = localPurchLine.PurchId;
                                tableRefId = this.getTableRefId(localPurchLine, false);
                                this.createParmTable(PurchTable::find(localPurchId), localPurchLine, tableRefId, false, false, false,localPackingSlipId);
                            }
                            // <GEERU>
                        }
                        // </GEERU>

                        while select TableId from localInventTransOrigin
                        where localInventTransOrigin.InventTransId  == localWMSJournalTrans.inventTransId
                        join sum(Qty), sum(PdsCwQty), InventDimId from localInventTrans
                            group by InventDimId
                            where  localInventTrans.StatusReceipt        == StatusReceipt::Registered
                                && localInventTrans.StatusIssue          == StatusIssue::None
                                && localInventTrans.InventTransOrigin    == localInventTransOrigin.RecId
                        {
                            // Don't proceed unless there are any Registered quantities to post
                            if (localInventTrans.Qty == 0 && localInventTrans.PdsCWQty == 0)
                            {
                                continue;
                            }

                            hashKey = strFmt('%1,%2', localPurchLine.RecId, localInventTrans.inventDimId);
                            if (map.exists(hashKey))
                            {
                                [tempPurchLine, tempQty, tempTableRefId, tempPdsCwQty, tempInventDimId] = map.lookup(hashKey);
                            }

                            // localInventTrans has the total Registered quantity. If sum of WMSJournalTrans lines qty exceeds Registered qty then use only the Registered quantity
                            qtyForPosting    = min(localInventTrans.Qty,      localWMSJournalTrans.Qty      + tempQty);
                            cWQtyForPosting  = min(localInventTrans.PdsCWQty, localWMSJournalTrans.PdsCWQty + tempPdsCwQty);

                            map.insert(hashKey, [localPurchLine, qtyForPosting, tableRefId, cWQtyForPosting, localInventTrans.inventDimId]);
                        }
                    }
                }
            }
        }

        if (poNeedsToBeConfirmed)
        {
            throw Exception::Error;
        }

        mapEnumerator = map.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            [tempPurchLine, tempQty, tempTableRefId, tempPdsCwQty, tempInventDimId] = mapEnumerator.currentValue();
            // Don't proceed unless there are any quantities to post
            if (tempQty == 0 && tempPdsCwQty == 0)
            {
                continue;
            }

            this.createParmLineFromWMSJournalTrans(tempPurchLine, tempQty, tempTableRefId, tempPdsCwQty, tempInventDimId, lineNumIncrement);
            lineNumIncrement += 0.00001;
        }

        this.insertRecordLists();
        // Do not clear totals in reArrange
        clearTotals = false;
        this.reArrange();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesGetSourceLine</Name>
				<Source><![CDATA[
    protected Common chooseLinesGetSourceLine()
    {
        if (isFromBillOfEntryforPackingSlip)
        {
            return currentSourceLine;
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesGetSourceTable</Name>
				<Source><![CDATA[
    protected Common chooseLinesGetSourceTable()
    {
        if (isFromBillOfEntryforPackingSlip)
        {
            return currentSourceTable;
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesNext</Name>
				<Source><![CDATA[
    protected boolean chooseLinesNext()
    {
        boolean                 ret;
        CustomsVendBOETrans_IN      customsVendBOETransCopy;

        if (!isFromBillOfEntryforPackingSlip)
        {
            ret = super();
        }
        else
        {
            // Reset map
            subLinesMap = this.initSubLinesMap_IN();

            // Invariant: chooseLines either points to a new PurchLine and possibly a new PurchTable OR it is at eof.
            // If at eof then latest super() returned false.
            // Since chooseLines the very first time points before the next, we have to call super() once.
            // First run?
            if (!currentSourceTable.RecId)
            {
                chooseLinesEOF = !super();
            }
            // any records left?
            ret = !chooseLinesEOF;
            // Also cache whether we have a new sourceTable.
            currentSourceTableChanged = chooseLines.changed(tableNum(PurchTable));

            // process next couple of records.
            while (!chooseLinesEOF)
            {
                // copy records since we will go to next.
                currentSourceTable = chooseLines.get(this.sourceTableTableId()).data();
                currentSourceLine = chooseLines.get(this.sourceLineTableId()).data();

                while select customsVendBOETransCopy
                    where customsVendBOETransCopy.PurchLineRecId == currentSourceLine.RecId
                        && customsVendBOETransCopy.RemainingQty != 0
                        && customsVendBOETransCopy.Status != CustomsVendBOEStatus_IN::Canceled
                {
                    if (versioningStrategy.parmVersioningUpdateType() == VersioningUpdateType::Correction ||
                        versioningStrategy.parmVersioningUpdateType() == VersioningUpdateType::Cancel)
                    {
                        if (this.findPackingSlipForBOECorr_IN(customsVendBOETransCopy.RecId, currentSourceLine))
                        {
                            subLinesMap.insert(customsVendBOETransCopy.RecId, customsVendBOETransCopy);
                        }
                    }
                    else
                    {
                        subLinesMap.insert(customsVendBOETransCopy.RecId, customsVendBOETransCopy);
                    }
                }
                // Go to to next or eof
                chooseLinesEOF = !super();
                if (!chooseLinesEOF)
                {
                    // if next is different, stop the loop.
                    if (chooseLines.changed(tableNum(PurchLine))
                            || chooseLines.changed(tableNum(PurchTable)))
                    {
                        break;
                    }
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromHistoryParmLine_Asset</Name>
				<Source><![CDATA[
    protected void createFromHistoryParmLine_Asset(RefRecId _parmLineRecId, RefRecId _newParmLineRecId)
    {
        PurchParmLine_Asset     purchParmLine_Asset;
        PurchParmLine_Asset     purchParmLine_AssetNew;

        purchParmLine_Asset = PurchParmLine_Asset::findByPurchParmLineRecId(_parmLineRecId);
        if (purchParmLine_Asset.RecId)
        {
            purchParmLine_AssetNew = purchParmLine_Asset.data();
            purchParmLine_AssetNew.PurchParmLineRecId = _newParmLineRecId;
            this.insertParmLine_Asset(purchParmLine_AssetNew);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmLine</Name>
				<Source><![CDATA[
    protected boolean createParmLine(Common         _purchLine,
                                     TradeLineRefId _tableRef   = '',
                                     boolean        _callFromCreateParmLineAndSubLines = false)
    {
        boolean                 createdLine;
        CustomsVendBOETrans_IN  customsVendBOETransCopy;
        PurchLine               purchLineCopy = _purchLine;

        if (!isFromBillOfEntryforPackingSlip
            || _callFromCreateParmLineAndSubLines)
        {
            createdLine = super(_purchLine, _tableRef);
        }
        else
        {
            subLinesMap = this.initSubLinesMap_IN();

            while select customsVendBOETransCopy
                where customsVendBOETransCopy.PurchLineRecId == purchLineCopy.RecId
                    && customsVendBOETransCopy.RemainingQty != 0
                    && customsVendBOETransCopy.Status != CustomsVendBOEStatus_IN::Canceled
            {
                subLinesMap.insert(customsVendBOETransCopy.RecId, customsVendBOETransCopy);
            }

            createdLine = this.createParmLineAndSubLines_IN(_purchLine, subLinesMap.pack(), _tableRef);
        }
        return createdLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmLineAndSubLines_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates parm line and sub lines.
    /// </summary>
    /// <param name="_purchLine">
    /// The purch line information.
    /// </param>
    /// <param name="_packedSubLinesMap">
    /// The packed sub line map.
    /// </param>
    /// <param name="_tableRef">
    /// The table ref id.
    /// </param>
    /// <returns>
    /// Returns true if the creation succeed.
    /// </returns>
    protected boolean createParmLineAndSubLines_IN(PurchLine      _purchLine,
                                                container      _packedSubLinesMap,
                                                TradeLineRefId _tableRef)
    {
        MapEnumerator           me, mee;
        PurchParmSubLine        purchParmSubLine;
        PurchParmLine           purchParmLine;

        CustomsVendBOETrans_IN  customsVendBOETrans;
        PurchQty                purchQty;
        InventQty               inventQty;
        Set                     subLineSet = new Set(Types::Record);
        SetEnumerator           se;
        boolean                 lineCreated, anyLineCreated;
        container               packedPArmLinesMap;

        newPostingPurchQtyPCK  = 0;
        newPostingInventQtyPCK = 0;

        if (_purchLine.RecId)
        {
            me = Map::create(_packedSubLinesMap).getEnumerator();

            while (me.moveNext())
            {
                customsVendBOETrans = me.currentValue();
                if (versioningStrategy.parmVersioningUpdateType() == VersioningUpdateType::Correction ||
                    versioningStrategy.parmVersioningUpdateType() == VersioningUpdateType::Cancel)
                {
                    customsVendBOETrans.BillOfEntryQty = this.findPackingSlipForBOECorr_IN(customsVendBOETrans.RecId, _purchLine).Qty;
                }
                else
                {
                    customsVendBOETrans.BillOfEntryQty = CustomsVendBOETrans_IN::getRemainingQuantityForPackingSlipUpdate(_purchLine.PurchId,
                                                                                                                            _purchLine.InventTransId,
                                                                                                                            _purchLine.RemainPurchPhysical,
                                                                                                                            customsVendBOETrans.RecId);
                }
                subLineSet.add(customsVendBOETrans);

                inventQty   += customsVendBOETrans.BillOfEntryQty;
                purchQty    += customsVendBOETrans.BillOfEntryQty;
            }

            newPostingPurchQtyPCK  = purchQty;
            newPostingInventQtyPCK = inventQty;

            lineCreated = this.createParmLine(_purchLine, _tableRef, true);

            anyLineCreated = anyLineCreated || lineCreated;

            if (lineCreated)
            {
                packedPArmLinesMap = parmLineMap.pack();
                mee  = Map::create(packedPArmLinesMap).getEnumerator();
                while (mee.moveNext())
                {
                    purchParmLine = mee.currentValue();

                    if (purchParmLine.PurchLineRecId == _purchLine.RecId
                        && purchParmLine.InventTransId && _purchLine.InventTransId)
                    {
                        se = subLineSet.getEnumerator();
                        while (se.moveNext())
                        {
                            customsVendBOETrans = se.current();
                            if (parmLineBOEMap.exists(this.parmLineBOEMapKey_IN(purchParmLine, customsVendBOETrans.RecId)))
                            {
                                purchParmSubLine.clear();
                                purchParmSubLine.initFromLine_IN(purchParmLine);
                                purchParmSubLine.initFromCustomsBillOfEntryTrans_IN(customsVendBOETrans);
                                purchParmSubLine.ReceiveNow = purchParmSubLine.ReceiveNow;
                                purchParmSubLine.InventNow = purchParmSubLine.InventNow;
                                this.insertParmSubLine_IN(purchParmSubLine);
                            }
                        }
                    }
                }
            }
        }
        return anyLineCreated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmLineFromWMSJournalTrans</Name>
				<Source><![CDATA[
    protected void  createParmLineFromWMSJournalTrans(  PurchLine       _purchLine,
                                                        InventQty       _qtyReceived,
                                                        TradeLineRefId  _tableRef,
                                                        PdsCWInventQty  _cwQtyReceived = 0,
                                                        InventDimId     _inventDimId = '',
                                                        real            _lineNumIncrement = 0)
    {
        PurchParmLine               localPurchParmLine;
        VendDocumentLineAssetMap    localParmLine_Asset = this.initParmLine_Asset();
        boolean                     setInventQtyNow = true;

        if (_purchLine.RecId)
        {
            _purchLine.PdsCWInventReceivedNow = _cwQtyReceived;
            _purchLine.PurchReceivedNow = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_purchLine.ItemId,
																												_purchLine.InventDimId,
																												_qtyReceived,
																											    _purchLine.inventTable().inventUnitId(),
																											    _purchLine.PurchUnit,
																											    NoYes::Yes);

            localPurchParmLine.clear();
            localPurchParmLine.TableRefId = _tableRef;

            [localPurchParmLine.InventNow,   localPurchParmLine.RemainBeforeInvent, localPurchParmLine.RemainAfterInvent] = this.qtyInvent(_purchLine, naReal());
            if (PdsGlobal::pdsIsCWItem(_purchLine.ItemId))
            {
                [localPurchParmLine.PdsCWReceiveNow, localPurchParmLine.PdsCWRemainBeforeInvent, localPurchParmLine.PdsCWRemainAfterInvent] = this.pdsCWQtyInvent(_purchLine, naReal());
            }

            if (localPurchParmLine.InventNow > _qtyReceived)
            {
                // Don't suggest more than what was received
                [localPurchParmLine.InventNow,   localPurchParmLine.RemainBeforeInvent, localPurchParmLine.RemainAfterInvent] = this.qtyInvent(_purchLine, _qtyReceived);
                if (PdsGlobal::pdsIsCWItem(_purchLine.ItemId))
                {
                    [localPurchParmLine.PdsCWReceiveNow, localPurchParmLine.PdsCWRemainBeforeInvent, localPurchParmLine.PdsCWRemainAfterInvent] = this.pdsCWQtyInvent(_purchLine, _cwQtyReceived);
                }
                [localPurchParmLine.ReceiveNow,  localPurchParmLine.RemainBefore      , localPurchParmLine.RemainAfter      ] = this.qtyPurch (_purchLine, _purchLine.PurchReceivedNow);
            }
            else
            {
                [localPurchParmLine.ReceiveNow,  localPurchParmLine.RemainBefore      , localPurchParmLine.RemainAfter      ] = this.qtyPurch (_purchLine, naReal());
            }

            if (localPurchParmLine.ReceiveNow || localPurchParmLine.RemainBefore)
            {
                localPurchParmLine.ParmId = purchParmUpdate.ParmId;
                localPurchParmLine.initFromPurchLine(_purchLine);

                if (_inventDimId)
                {
                    localPurchParmLine.InventDimId = _inventDimId;
                }
                localPurchParmLine.LineNum += _lineNumIncrement;

                localPurchParmLine.setQty(DocumentStatus::PackingSlip, purchParmUpdate.CreditRemaining);

                if (!localPurchParmLine.VendDocumentLineMap::isNonPO() && _purchLine.isStocked())
                {
                    setInventQtyNow = false;
                }
                localPurchParmLine.setInventReceiveNow(setInventQtyNow);

                localPurchParmLine.setLineAmount();
                this.insertParmLine(localPurchParmLine);

                this.createParmLineAsset(localParmLine_Asset, _purchLine, localPurchParmLine);

                this.allowCreateParmTable(true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmTable</Name>
				<Source><![CDATA[
    protected Common createParmTable(Common             _purchTable,
                                     Common             _purchLine,
                                     TradeLineRefId     _tableRefId,
                                     boolean            _skipParmSubTable = false,
                                     boolean            _hold = false,
                                     boolean            _notApproved = false,
    Num                   _purchSummaryFormLetterId = '',
                                     VendPostingProfile    _postingProfile           = '',
                                     InventProfileType_RU  _inventProfileType        = InventProfileType_RU::General)
    {
        PurchTable           localPurchTable = _purchTable as PurchTable;
        PurchLine            localPurchLine  = _purchLine  as PurchLine;
        #ISOCountryRegionCodes
        boolean              countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        PurchParmTable       purchParmTable;

        if (countryRegion_RU)
        {
            purchParmTable = super(_purchTable,
                                   _purchLine,
                                   _tableRefId,
                                   _skipParmSubTable,
                                   false,
                                   false,
                                   _purchSummaryFormLetterId,
                                   prmisDefault(_postingProfile)                                                            ?
                                   this.postingProfile_RU(localPurchLine.purchLine_W().PostingProfile_RU, localPurchTable.PostingProfile) :
                                   _postingProfile,
                                   prmisDefault(_inventProfileType)          ?
                                   this.inventProfileType_RU(localPurchLine) :
                                   _inventProfileType);
        }
        else
        {
            purchParmTable = super(_purchTable, _purchLine, _tableRefId, _skipParmSubTable,false,false,_purchSummaryFormLetterId);

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLT, #isoLV]))
            {
                purchParmTable.DocAutoNumbering_LT = localPurchTable.PackingSlipAutoNumbering_LT;
            }
        }

            return purchParmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultParmTable</Name>
				<Source><![CDATA[
    protected void defaultParmTable(VendDocumentTableMap _parmTable, PurchTable _purchTable)
    {
        PurchParmTable purchParmTable;

        super(_parmTable, _purchTable);

        if (this.parmCallerTable().TableId == tableNum(VendPackingSlipJour))
        {
            purchParmTable = _parmTable;
            purchParmTable.VendPackingSlipJour = this.parmCallerTable().RecId;

            this.initBankLC(purchParmTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBankLC</Name>
				<Source><![CDATA[
    private void initBankLC(PurchParmTable _purchParmTable)
    {
        if (this.parmVersioningStrategy()
            && this.parmVersioningStrategy().parmVersioningUpdateType() == VersioningUpdateType::Cancel
            && BankLCImportFeatureChecker::checkBankLCImportEnabled())
        {
            _purchParmTable.BankLCImportLine = VendPackingSlipJour::findRecId(_purchParmTable.VendPackingSlipJour).BankLCImportLine;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultStorno</Name>
				<Source><![CDATA[
    protected NoYesId defaultStorno()
    {
        return LedgerParameters::find().TransactionReversalCorrection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCorrectionLineQuantities</Name>
				<Source><![CDATA[
    public container getCorrectionLineQuantities(Common _purchLine)
    {
        VendPackingSlipTrans vendPackingSlipTrans = chooseLines.get(tableNum(VendPackingSlipTrans));

        return [vendPackingSlipTrans.Qty, vendPackingSlipTrans.InventQty, vendPackingSlipTrans.Qty, vendPackingSlipTrans.InventQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCorrectionInventoryDimensions</Name>
				<Source><![CDATA[
    internal InventDimId getCorrectionInventoryDimensions(PurchLine _purchLine)
    {
        VendPackingSlipTrans vendPackingSlipTrans = chooseLines.get(tableNum(VendPackingSlipTrans));

        return vendPackingSlipTrans.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineQuantities</Name>
				<Source><![CDATA[
    protected container getLineQuantities(PurchLine _purchLine)
    {
        if (!isFromBillOfEntryforPackingSlip)
        {
            return super(_purchLine);
        }
        else
        {
            if (versioningStrategy.parmVersioningUpdateType() == VersioningUpdateType::Correction)
            {
                return [newPostingPurchQtyPCK, newPostingInventQtyPCK, newPostingPreVerPurchQtyPCK, newPostingPreVerInventQtyPCK];
            }
            else if (versioningStrategy.parmVersioningUpdateType() == VersioningUpdateType::Cancel)
            {
                return [0, 0, newPostingPreVerPurchQtyPCK, newPostingPreVerInventQtyPCK];
            }
            else
            {
                return [newPostingPurchQtyPCK, newPostingInventQtyPCK, 0, 0];
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParmTableNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>Num</c> value of the header to use in the <c>createParmTable</c> method.
    /// </summary>
    /// <param name="_num">
    /// The current header <c>Num</c> value.
    /// </param>
    /// <param name="_purchTable">
    /// The current <c>PurchTable</c> table.
    /// </param>
    /// <param name="_overrideNum">
    /// A Boolean value that indicates whether the <c>Num</c> value should be overridden in this method.
    /// </param>
    /// <returns>
    /// The new header <c>Num</c> value.
    /// </returns>
    protected Num getParmTableNum(Num _num, PurchTable _purchTable, Num _overrideNum)
    {
        Num ret;
        VendPackingSlipJour vendPackingSlipJour;

        // If not already overridden, check IC. (Is overridden by chooseLinesFromWMSJournalTable)
        if (!_overrideNum)
        {
            if (_purchTable.isInterCompanyOrder())
            {
                changecompany(_purchTable.InterCompanyCompanyId)
                {
                    _overrideNum = this.parmTableNum ? this.parmTableNum : _purchTable.interCompanySalesTable().lastPackingSlip();
                }
            }
        }

        if (this.parmCallerTable() is VendPackingSlipJour)
        {
            vendPackingSlipJour = this.parmCallerTable();
            _overrideNum = vendPackingSlipJour.PackingSlipId;
        }

        ret = super(_num, _purchTable, _overrideNum);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitInventProfileType_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if a packing slip should be separated for each kind of activity.
    /// </summary>
    /// <returns>
    ///    true if a packing slip should be separated for each kind of activity; otherwise, false.
    /// </returns>
    protected NoYes getSplitInventProfileType_RU()
    {
        return PurchParameters::find().SplitInventProfileTypePackingSlip_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitPostingProfile_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether packing slip journals will be separated for each posting profile.
    /// </summary>
    /// <returns>
    ///    true if the packing slip journals will be separated for each posting profile; otherwise, false.
    /// </returns>
    protected NoYes getSplitPostingProfile_RU()
    {
        return PurchParameters::find().SplitPostingProfilePackingSlip_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOfficials_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method initializes officials for given <c>PurchParmTable</c> record or for all update
    /// </summary>
    /// <param name="_purchParmTable">
    /// <c>PurchParmTable</c> record for which officials should be initialized
    /// </param>
    public void initOfficials_RU(Common _purchParmTable = null)
    {
        PurchParmTable      localPurchParmTable = _purchParmTable as PurchParmTable;
        VendPackingSlipJour vendPackingSlipJour;

        void updatePurchParmTable()
        {
            boolean newId = true;

            if (this.parmCallerTable().TableId == tableNum(VendPackingSlipJour))
            {
                vendPackingSlipJour = this.parmCallerTable();
                localPurchParmTable.OffSessionId_RU = OfficialsServ_RU::sessionClone(vendPackingSlipJour.OffSessionId_RU);
            }
            else
            {
                if (localPurchParmTable.OffSessionId_RU)
                {
                    newId = false;
                    offSrv.newId(localPurchParmTable.OffSessionId_RU);
                    localPurchParmTable.OffSessionId_RU = "";
                }

                localPurchParmTable.OffReportType_RU =
                    offSrv.initTablePurch(localPurchParmTable,
                                          purchParmUpdate,
                                          newId);
                if (! localPurchParmTable.OffSessionId_RU)
                {
                    localPurchParmTable.OffSessionId_RU = offSrv.newId();
                }
            }

            if (PurchParmTable::findRecId(localPurchParmTable.RecId) && localPurchParmTable.selectForUpdate())
            {
                localPurchParmTable.update();
            }
        }

        if (! OfficialsServ_RU::isFeatureEnabled())
            return;

        if (! offSrv)
        {
            offSrv = new OfficialsServ_RU();
        }

        ttsbegin;

        if (localPurchParmTable) // Editing parmTable
        {
        updatePurchParmTable();
    }
    else                 // Creating parmTables
        {
    while select forupdate localPurchParmTable
                where localPurchParmTable.ParmId    == purchParmUpdate.ParmId    &&
                      localPurchParmTable.Ordering  == this.parmDocumentStatus() &&
                    ! localPurchParmTable.OffSessionId_RU
    {
        updatePurchParmTable();
    }
}

ttscommit;
}

]]></Source>
			</Method>
			<Method>
				<Name>initOnCorrection</Name>
				<Source><![CDATA[
    public void initOnCorrection()
{
    InterCompanyEndpointActionPolicy    fromInterCompanyEndpointActionPolicy;
    InterCompanyTradingPartner          fromInterCompanyTradingPartner;
    InterCompanyTradingPartner          toInterCompanyTradingPartner;
    VendPackingSlipJour                 vendPackingSlipJour = this.parmCallerTable() as VendPackingSlipJour;

    this.parmCreditRemaining(true);

    if (vendPackingSlipJour.InterCompanyPosted)
    {
        toInterCompanyTradingPartner            = VendTable::find(vendPackingSlipJour.OrderAccount).interCompanyTradingPartner();
        fromInterCompanyTradingPartner          = InterCompanyTradingRelation::getRelatedTradingPartner(toInterCompanyTradingPartner);
        fromInterCompanyEndpointActionPolicy    = InterCompanyEndpointActionPolicy::findPartner(fromInterCompanyTradingPartner.RecId);
        actionPolicyTransfer                    = fromInterCompanyEndpointActionPolicy.getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::External);
    }
}

]]></Source>
			</Method>
			<Method>
				<Name>initRecordLists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the record list and map variables.
    /// </summary>
    protected void initRecordLists()
    {
        super();
        if (isFromBillOfEntryforPackingSlip)
        {
            recordInsertParmSubLine     = new RecordInsertList(this.parmSubLineTableId_IN(), true, true, true);
        }

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            puchParmLineINRecordList = new RecordInsertList(tableNum(PurchParmLine_IN), true, true, true);
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSourceLineOnConnection</Name>
				<Source><![CDATA[
    public void initSourceLineOnConnection(Common _purchLine)
    {
        PurchLine purchLine = _purchLine as PurchLine;
        VendPackingSlipTrans vendPackingSlipTrans;
        // <GIN>
        if (isFromBillOfEntryforPackingSlip
            && (versioningStrategy.parmVersioningUpdateType() == VersioningUpdateType::Correction
                || versioningStrategy.parmVersioningUpdateType() == VersioningUpdateType::Cancel)
            && purchLine.purchTable().purchTable_W().CustomsImportOrder_IN)
        {
            vendPackingSlipTrans = this.findPackingSlipForBOECorr_IN(parmCustomsVendBOETrans.RecId, _purchLine);
        }
        else
        {
            // </GIN>
            vendPackingSlipTrans = chooseLines.get(tableNum(VendPackingSlipTrans));
            // <GIN>
        }
        // </GIN>

        purchLine.RemainPurchPhysical += vendPackingSlipTrans.Qty;
        purchLine.RemainInventPhysical += vendPackingSlipTrans.InventQty;

        purchLine.PdsCWRemainInventPhysical += vendPackingSlipTrans.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSubLinesMap_IN</Name>
				<Source><![CDATA[
    private Map initSubLinesMap_IN()
    {
        return new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmSubLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts parm information of sub line.
    /// </summary>
    /// <param name="_parmSubLine">
    /// The subline parameter.
    /// </param>
    protected void insertParmSubLine_IN(Common _parmSubLine)
    {
        PurchParmSubLine  purchParmSubLine = _parmSubLine;

        if (purchParmSubLine.ReceiveNow == 0.0)
        {
            return;
        }

        recordInsertParmSubLine.add(_parmSubLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRecordLists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records in the record lists into the database.
    /// </summary>
    protected void insertRecordLists()
    {
        if (isFromBillOfEntryforPackingSlip)
        {
            recordInsertParmSubLine.insertDatabase();
        }

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            puchParmLineINRecordList.insertDatabase();
        }
        // </GIN>

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyParmLineQty</Name>
				<Source><![CDATA[
    public Qty interCompanyParmLineQty(Common _common, boolean _isInventQty = false)
    {
        PurchLine               purchLineLocal = _common;
        CustPackingSlipTrans    custPackingSlipTrans;
        CustPackingSlipJour     custPackingSlipJour;
        Qty                     inventQty;
        UnitOfMeasureRecId      toUnitOfMeasureRecId;
        UnitOfMeasureRecId      fromUnitOfMeasureRecId;

        if (interCompanyCompanyId)
        {
            if (_isInventQty)
            {
                toUnitOfMeasureRecId = UnitOfMeasure::unitOfMeasureIdBySymbol(purchLineLocal.inventTable().inventUnitId());
            }

            changecompany(interCompanyCompanyId)
            {
                select forceplaceholders InventQty, Qty, ItemId from custPackingSlipTrans
                       where custPackingSlipTrans.InventTransId == purchLineLocal.InterCompanyInventTransId
                exists join custPackingSlipJour
                       where custPackingSlipJour.PackingSlipId == custPackingSlipTrans.PackingSlipId
                       &&    custPackingSlipJour.DeliveryDate  == custPackingSlipTrans.DeliveryDate
                       &&    custPackingSlipJour.SalesId       == custPackingSlipTrans.SalesId
                       &&    custPackingSlipJour.ParmId        == interCompanyParmId
                       &&    custPackingSlipJour.PackingSlipId == number;

                inventQty = custPackingSlipTrans.InventQty;

                if (_isInventQty)
                {
                    fromUnitOfMeasureRecId = UnitOfMeasure::unitOfMeasureIdBySymbol(custPackingSlipTrans.inventTable().inventUnitId());
                    if (fromUnitOfMeasureRecId != toUnitOfMeasureRecId)
                    {
                        inventQty = EcoResProductUnitConverter::convertForReleasedProduct(custPackingSlipTrans.ItemId,
																						  custPackingSlipTrans.InventDimId,
																						  inventQty,
																						  fromUnitOfMeasureRecId,
																						  toUnitOfMeasureRecId,
																						  NoYes::Yes);
                    }
                }
            }
        }
        else
        {
            select forceplaceholders InventQty, Qty from custPackingSlipTrans
                   where custPackingSlipTrans.InventTransId == purchLineLocal.InventRefTransId
            exists join custPackingSlipJour
                   where custPackingSlipJour.PackingSlipId == custPackingSlipTrans.PackingSlipId
                   &&    custPackingSlipJour.DeliveryDate  == custPackingSlipTrans.DeliveryDate
                   &&    custPackingSlipJour.SalesId       == custPackingSlipTrans.SalesId
                   &&    custPackingSlipJour.ParmId        == interCompanyParmId
                   &&    custPackingSlipJour.PackingSlipId == number;

            inventQty = custPackingSlipTrans.InventQty;
        }

        return _isInventQty ? inventQty : custPackingSlipTrans.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOrigPackingSlipCoveringMultipleOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether packing slip covers multiple purchase orders.
    /// </summary>
    /// <returns>
    /// true if packing slip covers multiple purchase orders; otherwise, false.
    /// </returns>
    protected boolean isOrigPackingSlipCoveringMultipleOrders()
{
    VendPackingSlipPurchLink vendPackingSlipPurchLinkLocal;
    VendPackingSlipJour      vendPackingSlipJourLocal;

    if (callerTable && callerTable.TableId == tableNum(VendPackingSlipJour))
    {
        vendPackingSlipJourLocal = callerTable;

        select firstonly RecId from vendPackingSlipPurchLinkLocal
                where vendPackingSlipPurchLinkLocal.VendPackingSlipJour ==  vendPackingSlipJourLocal.RecId
                   && vendPackingSlipPurchLinkLocal.OrigPurchId         !=  vendPackingSlipJourLocal.PurchId;

        return vendPackingSlipPurchLinkLocal.RecId != 0;
    }

    return false;
}

]]></Source>
			</Method>
			<Method>
				<Name>mayJournalBePosted</Name>
				<Source><![CDATA[
    protected boolean mayJournalBePosted(Common _sourceTable)
    {
        PurchTable sourceTable = _sourceTable as PurchTable;

        //interCompanyMapPacked contains ICPO if posting is triggered from ICSO packing slip posting,
        //and then the posting should be enabled.
        return super(sourceTable)
            && sourceTable.mayPackingSlipBeUpdated(versioningStrategy.parmVersioningUpdateType())
            && (interCompanyMapPacked || sourceTable.mayInterCompanyBeUpdated());
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayJournalTransBePosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to create a parameter line for a given source line.
    /// </summary>
    /// <param name="_sourceLineTable">
    /// The source line record.
    /// </param>
    /// <returns>
    /// true if a parameter line should be created for the source line; otherwise, false.
/// </returns>
[HookableAttribute(true)]
protected boolean mayJournalTransBePosted(Common _sourceLineTable)
    {
PurchLine sourceLineTable = _sourceLineTable as PurchLine;
boolean ret;

if (sourceLineTable.isInterCompanyOrder() && sourceLineTable.isCategoryBased())
{
    return false;
}

ret = super(_sourceLineTable);

// <GIN>
        if (isFromBillOfEntryforPackingSlip)
{
    return (subLinesMap.elements() > 0);
}
// </GIN>

        if (ret && purchParmUpdate.SpecQty == PurchUpdate::ReceiveNow)
{
    ret = sourceLineTable.checkInventReceivedNow() && sourceLineTable.checkPurchReceivedNow();
}

return ret;
}

]]></Source>
			</Method>
			<Method>
				<Name>parmParmUpdate</Name>
				<Source><![CDATA[
    public Common parmParmUpdate(Common _purchParmUpdate = purchParmUpdate)
    {
        PurchParmUpdate ret;

        ret = super(_purchParmUpdate);

        // this boolean variable Controls the complete logic Of creating ParmSubline for the packing slip when the Quantity is Bill Of Entry
        if (TaxParameters::isCustomsEnable_IN())
        {
            isFromBillOfEntryforPackingSlip = ret.SpecQty == PurchUpdate::BillOfEntryQuantity_IN;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSubLineTableId_IN</Name>
				<Source><![CDATA[
    protected TableId parmSubLineTableId_IN()
    {
        return tableNum(PurchParmSubLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWGetCorrectionLineQuantities</Name>
				<Source><![CDATA[
    public container pdsCWGetCorrectionLineQuantities(Common _purchLine)
    {
        VendPackingSlipTrans vendPackingSlipTrans = chooseLines.get(tableNum(VendPackingSlipTrans));

        return [vendPackingSlipTrans.PdsCWQty, vendPackingSlipTrans.PdsCWQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWInterCompanyParmLineQty</Name>
				<Source><![CDATA[
    public PdsCWInventQty pdsCWInterCompanyParmLineQty(Common _common)
    {
        PurchLine               purchLineLocal = _common;
        CustPackingSlipTrans    custPackingSlipTrans;
        CustPackingSlipJour     custPackingSlipJour;

        if (interCompanyCompanyId)
        {
            changecompany(interCompanyCompanyId)
            {
                select forceplaceholders PdsCWQty from custPackingSlipTrans
                    where  custPackingSlipTrans.InventTransId   == purchLineLocal.InterCompanyInventTransId
                exists join custPackingSlipJour
                    where  custPackingSlipJour.PackingSlipId    == custPackingSlipTrans.PackingSlipId
                        && custPackingSlipJour.DeliveryDate     == custPackingSlipTrans.DeliveryDate
                        && custPackingSlipJour.SalesId          == custPackingSlipTrans.SalesId
                        && custPackingSlipJour.ParmId           == interCompanyParmId
                        && custPackingSlipJour.PackingSlipId    == number;
            }
        }
        else
        {
            select forceplaceholders PdsCWQty from custPackingSlipTrans
                where  custPackingSlipTrans.InventTransId   == purchLineLocal.InventRefTransId
            exists join custPackingSlipJour
                where  custPackingSlipJour.PackingSlipId    == custPackingSlipTrans.PackingSlipId
                    && custPackingSlipJour.DeliveryDate     == custPackingSlipTrans.DeliveryDate
                    && custPackingSlipJour.SalesId          == custPackingSlipTrans.SalesId
                    && custPackingSlipJour.ParmId           == interCompanyParmId
                    && custPackingSlipJour.PackingSlipId    == number;
        }

        return custPackingSlipTrans.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyDeviation_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns deviation qty for current line update
    /// </summary>
    /// <param name="_purchLine">
    /// <c>PurchLine</c> record to take officials from
    /// </param>
    /// <returns>
    /// Deviation qty for current line update
    /// </returns>
    /// <remarks>
    /// Deviation qty used in M4/M7/TORG1-2-3 reports
    /// </remarks>
    public InventQty qtyDeviation_RU(PurchLine _purchLine)
    {
        InventQty ret;
        VendPackingSlipTrans vendPackingSlipTransLocal;

        switch (versioningStrategy.parmVersioningUpdateType())
        {
            case VersioningUpdateType::Correction:
                vendPackingSlipTransLocal = chooseLines.get(tableNum(VendPackingSlipTrans));
                ret = vendPackingSlipTransLocal.DeviationQty_RU;
                break;
            default:
                ret = _purchLine.purchLine_W().DeviationQty_RU;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyInvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates inventory quantity.
    /// </summary>
    /// <param name="_purchLine">
    /// <c>PurchLine</c> record.
    /// </param>
    /// <param name="_qty">
    /// Quantity of item in inventory unit; optional.
    /// </param>
    /// <returns>
    /// Calculated quantity.
    /// </returns>
    public  container qtyInvent(PurchLine _purchLine, InventQty _qty = 0)
    {
        if (isFromBillOfEntryforPackingSlip)
        {
            _qty = newPostingInventQtyPCK;
        }
        return super(_purchLine, _qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyPurch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates purchase quantity.
    /// </summary>
    /// <param name="_purchLine">
    /// <c>PurchLine</c> record.
    /// </param>
    /// <param name="_qty">
    /// Number of puchase units; optional.
    /// </param>
    /// <param name="_specQty">
    /// <c>PurchUpdate</c> enum; optional.
    /// </param>
    /// <returns>
    /// Calculated quantity.
    /// </returns>
    public container qtyPurch(PurchLine _purchLine, PurchQty _qty = 0, PurchUpdate _specQty = purchParmUpdate.SpecQty)
    {
        if (_specQty == PurchUpdate::BillOfEntryQuantity_IN)
        {
            _qty = newPostingPurchQtyPCK;
        }
        return super(_purchLine, _qty, _specQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelectLines</Name>
				<Source><![CDATA[
    [Replaceable]
    protected void reSelectLines(PurchId _origOrderId)
    {
        TradeLineRefId              tableRefId;
        PurchLine                   localPurchLine,prevPurchLine;
        CustomsVendBOETrans_IN      customsVendBOETrans;
        Map                         map = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record);

        if (!isFromBillOfEntryforPackingSlip)
        {
            super(_origOrderId);
        }
        else
        {
            // When creating from Bill Of Entry collect inventtrans to create sub lines.
            while select localPurchLine
                where localPurchLine.PurchId    == _origOrderId
                    && localPurchLine.Blocked   == NoYes::No
                    && !localPurchLine.IsDeleted
                    join customsVendBOETrans
                        where localPurchLine.RecId == customsVendBOETrans.PurchLineRecId
                           && localPurchLine.InventTransId == customsVendBOETrans.InventTransId
                           && customsVendBOETrans.RemainingQty  != 0
                           && customsVendBOETrans.Status != CustomsVendBOEStatus_IN::Canceled
            {
                tableRefId = this.getTableRefId(localPurchLine);
                if (CustomsVendBOETrans_IN::getRemainingQuantityForPackingSlipUpdate(localPurchLine.PurchId, localPurchLine.InventTransId, localPurchLine.RemainPurchPhysical, customsVendBOETrans.RecId))
                {
                    if (localPurchLine.RecId != prevPurchLine.RecId)
                    {
                        if (map.elements() > 0)
                        {
                            this.createParmLineAndSubLines_IN(prevPurchLine,map.pack(),tableRefId);
                        }
                        prevPurchLine   = localPurchLine.data();
                        map = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record);
                    }

                    map.insert(customsVendBOETrans.RecId, customsVendBOETrans);
                }
            }

            if (prevPurchLine.RecId && map.elements() > 0)
            {
                this.createParmLineAndSubLines_IN(prevPurchLine,map.pack(),tableRefId);
                prevPurchLine = null;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelectEnd</Name>
				<Source><![CDATA[
    protected void reSelectEnd()
    {
        super();

        // Raise event initCharges if this is not a Correction
        if (versioningStrategy.parmVersioningUpdateType() != VersioningUpdateType::Correction)
        {
            this.initCharges(purchParmUpdate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectChooseLines</Name>
				<Source><![CDATA[
    protected void selectChooseLines(boolean _append = false)
    {
        if (this.lineListTableId() == tableNum(WMSJournalTable))
        {
            this.chooseLinesFromWMSJournalTable();
        }
        else
        {
            super(_append);
        }

        if (versioningStrategy &&
           (versioningStrategy.parmVersioningUpdateType() == VersioningUpdateType::Cancel ||
            versioningStrategy.parmVersioningUpdateType() == VersioningUpdateType::Correction) &&
            this.isOrigPackingSlipCoveringMultipleOrders())
        {
            purchParmUpdate.SumBy = AccountOrder::Account;
            this.reArrange();
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.validate_BR();
        }
        // </GBR>

        //Raise event initCharges if this is not a Correction
        if (versioningStrategy.parmVersioningUpdateType() != VersioningUpdateType::Correction)
        {
            this.initCharges(purchParmUpdate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInterCompanyInventDim</Name>
				<Source><![CDATA[
    protected void setInterCompanyInventDim(VendDocumentLineMap _parmLine, SalesParmLine _salesParmLine)
    {
        InventTable             inventTable;
        InventDimGroupSetup     inventDimGroupSetup;
        InventDim               toInventDim;
        InventDim               fromInventDim;
        boolean                 transferSerial;
        boolean                 transferBatch;

        if (actionPolicyTransfer && (actionPolicyTransfer.InventBatchId || actionPolicyTransfer.InventSerialId))
        {
            inventTable         = _parmLine.inventTable();
            inventDimGroupSetup = InventDimGroupSetup::newInventTable(inventTable);

            transferBatch  =    actionPolicyTransfer.InventBatchId
                             && inventDimGroupSetup.isDimensionActive(fieldNum(InventDim,InventBatchId))
                             && !WHSReservationHierarchyInventDimUtil::isBatchBelowLocation(inventTable);

            transferSerial =    actionPolicyTransfer.InventSerialId
                             && inventDimGroupSetup.isDimensionActive(fieldNum(InventDim,InventSerialId))
                             && !WHSReservationHierarchyInventDimUtil::isSerialBelowLocation(inventTable);

            if (transferBatch || transferSerial)
            {
                changecompany(interCompanyCompanyId)
                {
                    fromInventDim = _salesParmLine.inventDim();
                }
                toInventDim = _parmLine.inventDim();

                if (transferBatch)
                {
                    toInventDim.InventBatchId      = fromInventDim.InventBatchId;
                }
                if (transferSerial)
                {
                    toInventDim.InventSerialId     = fromInventDim.InventSerialId;
                }

                _parmLine.InventDimId = InventDim::findOrCreate(toInventDim).InventDimId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setnewPostingPurchAndInventQty_IN</Name>
				<Source><![CDATA[
    protected void setnewPostingPurchAndInventQty_IN(RefRecId _customsVendBOETrans)
    {
        PurchLine               purchlinecopy;
        CustomsQty_IN           customsQtyforPackingSlip;
        VendPackingSlipTrans    vendPackingSlipTrans;

        if (isFromBillOfEntryforPackingSlip)
        {
            parmCustomsVendBOETrans.clear();
            purchlinecopy = CustomsVendBOETrans_IN::find(_customsVendBOETrans).purchLine();
            if (versioningStrategy.parmVersioningUpdateType() == VersioningUpdateType::Correction ||
                versioningStrategy.parmVersioningUpdateType() == VersioningUpdateType::Cancel)
            {
                vendPackingSlipTrans = this.findPackingSlipForBOECorr_IN(_customsVendBOETrans, purchlinecopy);
                if (vendPackingSlipTrans)
                {
                    newPostingPurchQtyPCK  = vendPackingSlipTrans.Qty;
                    newPostingInventQtyPCK = vendPackingSlipTrans.InventQty;
                    newPostingPreVerPurchQtyPCK = vendPackingSlipTrans.Qty;
                    newPostingPreVerInventQtyPCK = vendPackingSlipTrans.InventQty;
                    parmCustomsVendBOETrans = CustomsVendBOETrans_IN::find(_customsVendBOETrans);
                }
            }
            else
            {
                customsQtyforPackingSlip =
                    CustomsVendBOETrans_IN::getRemainingQuantityForPackingSlipUpdate(purchlinecopy.PurchId,
                                                                                    purchlinecopy.InventTransId,
                                                                                    purchlinecopy.RemainPurchPhysical,
                                                                                    _customsVendBOETrans);
                if (customsQtyforPackingSlip)
                {
                    newPostingPurchQtyPCK  = customsQtyforPackingSlip;
                    if (purchlinecopy.PurchUnit != purchlinecopy.inventTable().inventUnitId())
                    {
                        newPostingInventQtyPCK = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(purchlinecopy.ItemId,
																													   purchlinecopy.InventDimId,
																													   customsQtyforPackingSlip,
																													   purchlinecopy.PurchUnit,
																													   purchlinecopy.inventTable().inventUnitId(),
																													   NoYes::Yes);
                    }
                    else
                    {
                        newPostingInventQtyPCK = customsQtyforPackingSlip;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPreviousVersionQuantityFields</Name>
				<Source><![CDATA[
    protected void setPreviousVersionQuantityFields(
                                                    VendDocumentLineMap     _vendDocumentLineMap,
                                                    PurchQty                _previousPurchQty,
                                                    InventQty            _previousInventQty
                                                    , PdsCWInventQty     _previousCWQty
                                                    )
    {
        PurchParmLine purchParmLine = _vendDocumentLineMap;

        purchParmLine.PreviousReceiveNow        = _previousPurchQty;
        purchParmLine.PreviousInventNow         = _previousInventQty;

        purchParmLine.PdsCWPreviousReceiveNow   = _previousCWQty;
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
            versioningStrategy.parmVersioningUpdateType() == VersioningUpdateType::Correction)
        {
            purchParmLine.PreviousDeviationQty   = this.qtyDeviation_RU(null);
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryBuildOnCorrection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the query that is used to populate the parameter tables.
    /// </summary>
    /// <remarks>
    /// An additional <c>VendPackingSlipTrans</c> data source is added to the query.
    /// </remarks>
    public void updateQueryBuildOnCorrection()
    {
        #Query
        Query                query;
        QueryBuildDataSource qbds;
        VendPackingSlipJour  vendPackingSlipJour = this.parmCallerTable() as VendPackingSlipJour;

        this.initQueryBuild();

        query = chooseLines.query();
        query.interactive(showQueryForm);
        chooseLines.literals(#queryForcePlaceholders);

        qbds = query.dataSourceTable(tableNum(PurchLine)).addDataSource(tableNum(VendPackingSlipTrans));
        qbds.fetchMode(QueryFetchMode::One2One);
        qbds.addLink(fieldNum(PurchLine, InventTransId), fieldNum(VendPackingSlipTrans, InventTransId));
        qbds.addRange(fieldNum(VendPackingSlipTrans, VendPackingSlipJour)).value(queryValue(vendPackingSlipJour.RecId));
        
        this.addAllIntercompanyOrderProductReceiptsRanges(vendPackingSlipJour, qbds);
               
        qbds.addRange(fieldNum(VendPackingSlipTrans, FullyMatched)).value(queryValue(NoYes::No));
        qbds.addOrderByField(fieldNum(VendPackingSlipTrans, LineNum), SortOrder::Ascending);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addAllIntercompanyOrderProductReceiptsRanges</Name>
				<Source><![CDATA[
    private void addAllIntercompanyOrderProductReceiptsRanges(VendPackingSlipJour _vendPackingSlipJour,  QueryBuildDataSource _qbds)
    {
        if (interCompanyMapPacked
            && InterCompanyVendPackingSlipJourCheckFlight::instance().isEnabled())
        {
            Map map = Map::create(interCompanyMapPacked);
            MapEnumerator mapEnumerator = map.getEnumerator();
            while (mapEnumerator.moveNext())
            {
                Common interCompanyPurchTable = mapEnumerator.currentValue();
                var intercompanyProductReceiptPurchId = interCompanyPurchTable.(this.fieldIdSourceTable_OrderId());
                if (intercompanyProductReceiptPurchId != _vendPackingSlipJour.PurchId)
                {
                    VendPackingSlipJour localVendPackingSlipJour;
                    select firstonly RecId from localVendPackingSlipJour
                        where localVendPackingSlipJour.PurchId == intercompanyProductReceiptPurchId
                            && localVendPackingSlipJour.PackingSlipId == _vendPackingSlipJour.PackingSlipId;
                   
                    if (localVendPackingSlipJour)
                    {
                        _qbds.addRange(fieldNum(VendPackingSlipTrans, VendPackingSlipJour)).value(queryValue(localVendPackingSlipJour.RecId));
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate_BR</Name>
				<Source><![CDATA[
    private void validate_BR()
        {
            boolean                 ret = true;
            PurchParmTable          purchParmTable;

            while select purchParmTable
              where purchParmTable.ParmId == this.parmId()
            {
                setPrefix(strFmt("@SYS27357", purchParmTable.PurchId));

                if (conLen(purchParmTable.getFiscalEstablishment_BR()) > 1)
                {
                    checkFailed("@SYS4000651");
                }
            }
        }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    [SysObsolete('Use PurchFormletterParmData::construct() instead.', false, 30\06\2018)]
    static PurchFormletterParmDataPackingSlip construct()
    {
        return new PurchFormletterParmDataPackingSlip();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCharges</Name>
				<Source><![CDATA[
    delegate void initCharges(PurchParmUpdate _purchParmUpdate)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMayJournalTrEventHandlerChkInv_PL</Name>
				<Source><![CDATA[
    [PostHandlerFor(classStr(PurchFormletterParmDataPackingSlip), methodStr(PurchFormletterParmDataPackingSlip, mayJournalTransBePosted))]
    /// <summary>
    /// Handles
    /// </summary>
    /// <param name="_args">
    /// Event handler args
    /// </param>
    public static void postMayJournalTrEventHandlerChkInv_PL(XppPrePostArgs _args)
    {
        PurchFormletterParmDataPackingSlip purchFormletterParmDataPackingSlip;
        PurchLine                          purchLine;

        if (PurchParameters::find().PackingSlipByInvent_PL)
        {
            purchFormletterParmDataPackingSlip = _args.getThis();
            purchLine                          = _args.getArg('_sourceLineTable');

            if (purchFormletterParmDataPackingSlip.parmVersioningStrategy().parmVersioningUpdateType() == VersioningUpdateType::Initial &&
                purchFormletterParmDataPackingSlip.parmInventLocationId_PL() != InventDim::find(purchLine.InventDimId).InventLocationId)
            {
                _args.setReturnValue(false);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmLine</Name>
				<Source><![CDATA[
    protected void insertParmLine(Common _parmLine)
    {
        PurchParmLine   purchParmLineBase;
        PurchParmLine_IN    purchParmLine;
        super(_parmLine);
        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]) && _parmLine.TableId == tableNum(PurchParmLine))
        {
            purchParmLineBase = _parmLine;
            purchParmLine = purchParmLineBase.purchParmLine_IN();
            purchParmLine.initFromPurchParmLine(purchParmLineBase);

            if (!purchParmLine.RecId && purchParmLine.PurchParmLine)
            {
                puchParmLineINRecordList.add(purchParmLine);
            }

            purchParmLinebase.packPurchParmLine_IN(purchParmLine);
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSubTableSourceAccountingEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the accounting event value in the <c>PurchParmSubTable</c> if it has not already been set.
    /// </summary>
    /// <param name="_purchParmSubTable">
    /// The <c>PurchParmSubTable</c> table to update.
    /// </param>
    private void initSubTableSourceAccountingEvent(Common _purchParmSubTable)
    {
        PurchParmSubTable purchParmSubTable = _purchParmSubTable;
    
        if (purchParmSubTable.SourceAccountingEvent == 0 && purchParmSubTable.OrigPurchId != '')
        {
            AccountingEvent localAccountingEvent = AccountingEvent::getLastEvent(PurchTable::find(purchParmSubTable.OrigPurchId).SourceDocumentHeader);
            purchParmSubTable.SourceAccountingEvent = localAccountingEvent.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmSubTable</Name>
				<Source><![CDATA[
    protected void insertParmSubTable(Common _purchParmSubTable)
    {
        this.initSubTableSourceAccountingEvent(_purchParmSubTable);
        super(_purchParmSubTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeRecIdSuspension</Name>
				<Source><![CDATA[
    protected void removeRecIdSuspension()
    {
        super();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>