<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BudgetControlProcessor</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>BudgetControlProcessor</c> class provides the interface to interact with the budgetary control.
/// </summary>
/// <remarks>
///    This class is to be called by integrators to budgetary control to check for available budget and
///    remove the budgetary control data related to a budget source when it is deleted.
/// </remarks>
public class BudgetControlProcessor
{
    #define.FirstBudgetCheckGroupSequence(1)

    // ********************************
    // Inputs
    // ********************************
    Map ledgersToCleanupDrafts;
    Set ledgersToCleanupUntrackedDrafts;
    BudgetControlCheckRequestCollection budgetCheckRequestsToProcess;
    Set budgetSourcesToRemove;
    Map budgetSourcesToReturnRemaining;

    BudgetControlResultCollection budgetControlResultCollection;

    boolean doBudgetCheckForConfirmation;
    boolean doBudgetCheckAsSimulation;
    boolean doDisplayMessagesFromBudgetCheck;
    boolean isPurchYearEndProcess;

    // ********************************
    // Processing helpers
    // ********************************
    Types recIdTypes;
    boolean isProcessingNeeded;
    boolean arePendingDeletionsPrepared;
    boolean areRelievingDetailsPrepared;
    boolean areTrackingDetailsPrepared;
    boolean areReturnDetailsPrepared;

    // arePendingDeletionsPrepared value can be derived from areRelievingPendingDeletionsPrepared value,
    // but NOT vice versa. areRelievingPendingDeletionsPrepared flag is needed for setting correct
    // isAnyRelieved parameter value when calling budget control budget check stored procedure.

    boolean areRelievingPendingDeletionsPrepared;

    // ********************************
    // Details for currentCheckRequest
    // ********************************
    BudgetControlCheckRequest currentCheckRequest;
    BudgetSource currentSource;
    BudgetModel currentSourceModel;
    NoYes currentIsOverrunApproved;

    boolean currentIsBudgetAvailableCheckValidated;
    BudgetControlTrackingUpdate currentTrackingUpdate;

    BudgetCheckResult currentSourceResult;
    BudgetControlErrorWarningType currentErrorWarningType;
    BudgetControlErrorWarning currentErrorWarning;
    Set currentErrorMessages;
    Set currentWarningMessages;
    BudgetControlResult currentControlResult;
    // Map used to cache budget source records with results
    // Value: BudgetSource (Record)
    Map budgetSourcesWithResultsBySource;

    // ********************************
    // Caches by BudgetSource
    // ********************************
    // All map keys are Budget Source ID (Int64)

    // Map used to cache whether budget source is approved for overrun
    // Value: NoYes (Enum)
    Map isOverrunApprovedBySource;

    // Map used to cache budget models by budget source
    // Value: BudgetModel (Record)
    Map sourceModelsBySource;

    // Map used to cache budget control tracking update strategies
    // Value: BudgetControlTrackingUpdate
    Map trackingUpdateStrategiesBySource;

    // Map used to cache result by budget source
    // Value: BudgetCheckResult (Enum)
    Map sourceResults;

    // Maps used to cache the error warning type & warning by budget source
    // Value: BudgetControlErrorWarningType (Enum) & BudgetControlErrorWarning (Enum)
    Map errorWarningTypesBySource;
    Map errorWarningsBySource;

    // Maps used to cache the error & warning message sets by budget source
    // Value: Set(Class)
    Map errorMessagesBySource;
    Map warningMessagesBySource;

    // ********************************
    // Caches used for details during processing
    // ********************************
    // Map used to cache control ledger dimension amount details that require budget check
    // Key: Primary ledger Id
    // Value: Map
    //          Key: budget control ledger dimension Id
    //          Value: BudgetControlDetail
    Map currentControlDetails;

    // Map used to cache control ledger dimension amount details that require budget check per budget source
    // Key: Budget Source ID (Int64)
    // Value: Map (Class)
    //          Key: Primary ledger Id
    //          Value: Map
    //              Key: budget control ledger dimension Id
    //              Value: BudgetControlDetail
    Map controlDetailsBySource;

    // Map used to cache control ledger dimension amount details that require budget return
    // Key: Primary ledger Id
    // Value: Map
    //          Key: budget control ledger dimension Id
    //          Value: BudgetControlDetail
    Map currentReturnDetails;

    // Map used to cache control ledger dimension amount details that require budget return per budget source
    // Key: Budget Source ID (Int64)
    // Value: Map (Class)
    //          Key: Primary ledger Id
    //          Value: Map
    //              Key: budget control ledger dimension Id
    //              Value: BudgetControlDetail
    Map controlReturnDetailsBySource;

    // Map used to cache control ledger dimension amount details that requires budget funds relieving
    // and budget check
    // Key: Primary ledger Id
    // Value: Map
    //          Key: budget control ledger dimension Id
    //          Value: BudgetControlDetail
    Map currentControlDetailsToRelieve;

    // Map used to cache control ledger dimension amount details that requires budget funds relieving and budget check per budget source
    // Key: Budget Source ID (Int64)
    // Value: Map (Class)
    //          Key: Primary ledger Id
    //          Value: Map
    //              Key: budget control ledger dimension Id
    //              Value: BudgetControlDetail
    Map controlDetailsToRelieveBySource;

    // Set used to cache the source ledger dimension amount details that requires budget funds relieving
    // but no budget check is required
    Set currentSourceDetailsToRelieve;

    // Map used to cache the source ledger dimension amount details that requires budget funds relieving per budget source
    // but no budget check is required
    // Key: Budget Source ID (Int64)
    // Value: Set (Class)
    Map sourceDetailsToRelieveBySource;

    // Map used to cache source detail's legal entity and source ledger dimension Id segments
    // for their combination strings
    // Key: String (source legal entity Id, source ledger dimension Id)
    // Value: Container [source legal entity Id, source ledger dimension Id]
    Map budgetCheckLedgerDimensions;

    // Map used to cache source detail's source legal entity Id, source ledger dimension Id,
    // relieving budget source Id, relieving source legal entity Id, relieving source ledger dimension Id
    // segments for their combination strings.
    // Key: String (source legal entity Id, source ledger dimension Id, relieving budget source Id, relieving legal entity Id, relieving source ledger dimension Id)
    // Value: container [source legal entity Id, source ledger dimension Id, relieving budget source Id, relieving legal entity Id, relieving source ledger dimension Id]
    Map budgetCheckAndRelievingLedgerDimensions;

    // Map used to map a source ledger dimension to a control ledger dimension
    // Key: String (source ledger dimension legal entity Id, source ledger dimension Id)
    // Value: control ledger dimension Id
    Map controlLedgerDimensions;

    // Map used to map a source ledger dimension to a control rule
    // Key: String (source ledger dimension legal entity Id, source ledger dimension Id)
    // Value: budget control rule
    Map controlRules;

    // Map used to cache budget group associated with each control ledger dimension
    // Key: Primary ledger Id
    // Value: Map
    //      Key: budget control ledger dimension Id
    //      Value: budget group
    Map controlGroups;

    // Map used to cache the top budget group member Id by budget group
    // Key: Budget group Id (Int64)
    // Value: BudgetGroupMember (Record)
    Map topGroupMembers;

    // Map used to cache the top budget group member name by budget group member Id
    // Key: Budget group member Id (Int64)
    // Value: BudgetGroupMember Name (String)
    Map topGroupMemberNames;

    // Map used to cache budget model associated with each control rule.
    // Key: String (control rule Id, budget date)
    // Value: budget model
    Map controlRuleDateBudgetModels;

    // ********************************
    // Caches used to hold validated data during processing
    // ********************************
    // Map used to cache currencies that are validated
    // Key: Legal entity Id (Int64)
    // Value: Map (Class)
    //      Key: Currency code (String)
    //      Value: boolean (Enum)
    Map validatedCurrencies;

    // Map used to cache valid currencies with their corresponding currency exchange helpers
    // Key: PrimaryLedgerId (Int64)
    // Value: CurrencyExchangeHelper (Class)
    Map validCurrencyHelpers;

    // Map used to cache legal entities and whether they are valid.
    // Key: Legal entity Id (Int64)
    // Value: boolean (Enum)
    Map validatedLegalEntities;

    // Map used to cache source ledger dimensions that are validated.
    // Key: String (source ledger dimension legal entity Id, source ledger dimension Id, budget date)
    // Value: boolean (Enum)
    Map validatedSourceLedgerDimensionDates;

    // Map used to cache validated legal entity and budget date combinations
    // Key: String (legal entity, budget date)
    // Value: isValid
    Map validatedBudgetDates;

    // ********************************
    // Caches used to hold collection level data
    // ********************************
    // Map used to cache budget control enabled primary ledgers for budget check
    // Key: LegalEntityId (Int64)
    // Value: PrimaryLedgerId (Int64)
    Map primaryLedgersToCheckBudget;

    // Map used to cache budget control enabled primary ledgers for relieving budget
    // Key: LegalEntityId (Int64)
    // Value: PrimaryLedgerId (Int64)
    Map primaryLedgersToRelieveBudget;

    // Map used to track budget control configuration for budget control enabled primary ledgers for budget check
    // Key: PrimaryLedgerId
    // Value: BudgetControlConfiguration (Record)
    Map primaryLedgerConfigurations;

    // Map used to cache legal entities with their corresponding DataAreaIds
    // Key: LegalEntityId (Int64)
    // Value: DataAreaId (String)
    Map dataAreas;

    // Map used to cache primary ledgers with their corresponding accounting currency
    // Key: PrimaryLedgerId (Int64)
    // Value: CurrencyCode (String)
    Map primaryLedgerCurrencies;

    // Map used to cache primary ledgers with their corresponding budget exchange rate types
    // Key: PrimaryLedgerId (Int64)
    // Value: BudgetExchangeRateTypeId (Int64)
    Map primaryLedgerBudgetRateTypes;

    // Map used to cache primary ledgers with their corresponding fiscal calendar
    // Key: LegalEntityId (Int64)
    // Value: FiscalCalendarRecId (Int64)
    Map legalEntityLedgerCalendars;

    // Map used to cache whether warnings are suppressed by user per configuration
    // Key: BudgetControlConfigurationId (Int64)
    // Value: Map (Class)
    //      Key: UserId (String)
    //      Value: boolean (Enum)
    Map configurationUserSuppressWarnings;

    sequenceNum budgetCheckGroup;
    sequenceNum budgetCheckGroupSequence;

    /// Boolean to identify if processing completed without hard errors.
    /// Processing is still complete even if intentional errors are thrown by the processor.
    boolean isProcessingComplete;

    // Const for code returned by stored procedure when it finished successfully
    private const int ReturnCodeSuccess = 0;
    
    private BudgetControlInstrumentationLogger logger;
    private BudgetControlProcessingLogController logController;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>abortProcessForBudgetCheckFailure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the process must be aborted for a budget check failure.
    /// </summary>
    /// <returns>
    /// true if the process must be aborted; otherwise, false.
    /// </returns>
    protected boolean abortProcessForBudgetCheckFailure()
    {
        boolean doAbortProcess;

        if (doBudgetCheckForConfirmation &&
            budgetControlResultCollection != null &&
            budgetControlResultCollection.getOverallBudgetCheckResult() == BudgetCheckResult::Failed)
        {
            // Budget check is for confirmation & the budget check failed
            doAbortProcess = true;
        }

        return doAbortProcess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>activateTracking</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Activates budget source details tracking.
    /// </summary>
    /// <param name="_isBudgetSourceValid">
    /// A boolean value indicating whether the <c>BudgetSource</c> is valid.
    /// </param>
    protected void activateTracking(boolean _isBudgetSourceValid)
    {
        currentTrackingUpdate = BudgetControlTrackingUpdate::newForBudgetControlProcessing(
                                currentSource.RecId,
                                !doBudgetCheckForConfirmation,
                                currentCheckRequest.parmBudgetControlCategory(),
                                currentCheckRequest.parmBudgetDate(),
                                currentCheckRequest.parmUser(),
                                currentCheckRequest.parmTransactionNumber(),
                                currentControlDetailsToRelieve.elements() > 0 || currentSourceDetailsToRelieve.elements() > 0,
                                currentSourceModel,
                                currentCheckRequest.parmIsCarryforward(),
                                doBudgetCheckAsSimulation,
                                currentCheckRequest.parmSimulatedBudgetSourceId());

        // Cache the tracking update strategy by budget source for subsequent processing
        trackingUpdateStrategiesBySource.insert(currentCheckRequest.parmBudgetSourceId(), currentTrackingUpdate);

        currentTrackingUpdate.activateTracking(_isBudgetSourceValid);

        if (!arePendingDeletionsPrepared)
        {
            arePendingDeletionsPrepared = currentTrackingUpdate.arePendingDeletionsPrepared();
        }

        if (!areRelievingPendingDeletionsPrepared)
        {
            areRelievingPendingDeletionsPrepared = currentTrackingUpdate.areRelievingPendingDeletionsPrepared();
        }

        if (!areReturnDetailsPrepared)
        {
            areReturnDetailsPrepared = currentTrackingUpdate.areReturnDetailsPrepared();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBudgetCheckRequestToProcessAtCommit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the <c>BudgetControlCheckRequest</c> instance to the collection to be processed on transaction commit.
    /// </summary>
    /// <param name="_budgetCheckRequest">
    /// The <c>BudgetControlCheckRequest</c> instance to be processed.
    /// </param>
    public void addBudgetCheckRequestToProcessAtCommit(BudgetControlCheckRequest _budgetCheckRequest)
    {
        if (appl.ttsLevel() > 0)
        {
            if (_budgetCheckRequest)
            {
                budgetCheckRequestsToProcess.addBudgetControlCheckRequest(_budgetCheckRequest);
                isProcessingNeeded = true;
            }
        }
        else
        {
            // Budget control processing details must be added within a tts scope
            Debug::assert(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBudgetControlDetailsToProcessCheck</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the budget control details with the budget checking transaction currency totals for
    ///    each source ledger dimension for later budget checking processing.
    /// </summary>
    /// <param name="_budgetCheckTransactionCurrencyTotals">
    ///    The transaction currency totals to check budget for each budget source ledger dimensions
    ///    checking budget.
    /// </param>
    protected void addBudgetControlDetailsToProcessCheck(Map _budgetCheckTransactionCurrencyTotals)
    {
        str localBudgetSourceDetailKey;
        container localBudgetSourceDetail;

        // Key: transaction currency code
        // Value: Map
        //          Key: transaction currency code
        //          Value: transaction currency amount
        // Used to calculate budget currency amounts per transaction currency
        Map localCurrencyDetails;

        MapEnumerator localBudgetSourceDetailsEnumerator;
        LedgerDimensionBase sourceLedgerDimension;
        MapEnumerator localCurrencyDetailsEnumerator;
        AmountMST totalBudgetCurrencyAmount;
        BudgetCheckDetail summarizedBudgetCheckDetail;
        BudgetControlDetail budgetControlDetail;
        LedgerDimensionBudgetControl controlLedgerDimension;
        LegalEntityRecId legalEntityId;
        LedgerRecId primaryLedgerId;
        Map primaryLedgerControlDetails;
        Map primaryLedgerGroups;
        BudgetGroup localBudgetGroup;

        // Source ledger dimension detail with same transaction currency code are validated and
        // its transaction currency amount summed up. Now calculate the budget currency amount
        // for the source ledger dimension detail.
        if (_budgetCheckTransactionCurrencyTotals.elements() > 0)
        {
            localBudgetSourceDetailsEnumerator = _budgetCheckTransactionCurrencyTotals.getEnumerator();

            while (localBudgetSourceDetailsEnumerator.moveNext())
            {
                localBudgetSourceDetailKey = localBudgetSourceDetailsEnumerator.currentKey();
                localCurrencyDetails = localBudgetSourceDetailsEnumerator.currentValue();

                localBudgetSourceDetail = budgetCheckLedgerDimensions.lookup(localBudgetSourceDetailKey);

                legalEntityId = conpeek(localBudgetSourceDetail, 1);
                sourceLedgerDimension = conpeek(localBudgetSourceDetail, 2);

                primaryLedgerId = primaryLedgersToCheckBudget.lookup(legalEntityId);

                if (localCurrencyDetails.elements() > 0)
                {
                    localCurrencyDetailsEnumerator = localCurrencyDetails.getEnumerator();

                    totalBudgetCurrencyAmount = 0;

                    // Retrieve parmExchangeRate1() value which is the 3rd value in the container.
                    ExchRate fixedExchRate = conpeek(localBudgetSourceDetail, 3);

                    // Summarize source ledger dimension budget currency amount.
                    while (localCurrencyDetailsEnumerator.moveNext())
                    {
                        totalBudgetCurrencyAmount += this.convertAmountCurToAmountMst(
                            primaryLedgerId,
                            localCurrencyDetailsEnumerator.currentValue(),
                            localCurrencyDetailsEnumerator.currentKey(),
                            fixedExchRate);
                    }

                    // Organize control ledger dimension with corresponding source ledger dimensions.
                    summarizedBudgetCheckDetail = BudgetCheckDetail::newBudgetCheckDetail(
                                                    legalEntityId,
                                                    sourceLedgerDimension,
                                                    totalBudgetCurrencyAmount,
                                                    primaryLedgerCurrencies.lookup(primaryLedgerId));

                    if (controlLedgerDimensions.exists(localBudgetSourceDetailKey))
                    {
                        controlLedgerDimension = controlLedgerDimensions.lookup(localBudgetSourceDetailKey);

                        // Source ledger dimension requires budget check.
                        if (currentControlDetails.exists(primaryLedgerId))
                        {
                            primaryLedgerControlDetails = currentControlDetails.lookup(primaryLedgerId);

                            if (primaryLedgerControlDetails.exists(controlLedgerDimension))
                            {
                                budgetControlDetail = primaryLedgerControlDetails.lookup(controlLedgerDimension);
                                totalBudgetCurrencyAmount += budgetControlDetail.parmBudgetCurrencyAmount();
                            }
                            else
                            {
                                budgetControlDetail = BudgetControlDetail::construct();
                            }
                        }
                        else
                        {
                            primaryLedgerControlDetails = new Map(recIdTypes, Types::Class);
                            budgetControlDetail = BudgetControlDetail::construct();
                        }

                        budgetControlDetail.parmBudgetCurrencyAmount(totalBudgetCurrencyAmount);
                        budgetControlDetail.parmPrimaryLedgerId(primaryLedgerId);
                        budgetControlDetail.parmBudgetControlRule(controlRules.lookup(localBudgetSourceDetailKey));
                        budgetControlDetail.parmControlLedgerDimension(controlLedgerDimension);

                        if (controlGroups.exists(primaryLedgerId))
                        {
                            primaryLedgerGroups = controlGroups.lookup(primaryLedgerId);

                            if (primaryLedgerGroups.exists(controlLedgerDimension))
                            {
                                localBudgetGroup = primaryLedgerGroups.lookup(controlLedgerDimension);

                                if (localBudgetGroup)
                                {
                                    budgetControlDetail.parmBudgetGroupMember(topGroupMembers.lookup(localBudgetGroup.RecId));
                                }
                            }
                        }

                        budgetControlDetail.addBudgetSourceDetail(summarizedBudgetCheckDetail);

                        primaryLedgerControlDetails.insert(controlLedgerDimension, budgetControlDetail);
                        currentControlDetails.insert(primaryLedgerId, primaryLedgerControlDetails);
                    }
                }
            }
        }

        if (currentControlDetails.elements() > 0)
        {
            controlDetailsBySource.insert(currentCheckRequest.parmBudgetSourceId(), currentControlDetails);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBudgetControlDetailsToProcessRelief</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds budget control details with the budget checking transaction currency totals for
    ///    each source ledger dimension to check budget and the budget relieving transaction currency
    ///    totals for each source ledger dimension whose budget funds are to be relieved for later
    ///    budget funds relieving processing.
    /// </summary>
    /// <param name="_budgetCheckTransactionCurrencyTotals">
    ///    The transaction currency totals to check budget for each budget source ledger dimensions
    ///    checking budget.
    /// </param>
    /// <param name="_budgetRelievingTransactionCurrencyTotals">
    ///    The transaction currency totals to relieve budget for each budget source ledger dimensions
    ///    whose budget funds are to be relieved.
    /// </param>
    protected void addBudgetControlDetailsToProcessRelief(
        Map _budgetCheckTransactionCurrencyTotals,
        Map _budgetRelievingTransactionCurrencyTotals)
    {
        str localSourceRelievingDetailsKey;

        // Key: transaction currency code
        // Value: summarized transaction current amount
        Map localCurrencyDetails;

        // Key: transaction currency code
        // Value: summarized transaction current amount
        Map localRelievingCurrencyDetails;

        MapEnumerator budgetCheckTransactionCurrencyTotalsEnumerator;
        MapEnumerator localCurrencyDetailsEnumerator;
        MapEnumerator localRelievingCurrencyDetailsEnumerator;
        AmountMST totalBudgetCurrencyAmount;
        AmountMST totalBudgetRelievingCurrencyAmount;
        BudgetRelievingDetail summarizedBudgetRelievingDetail;
        container localSourceLedgerDimensionDetail;

        LegalEntityRecId legalEntityId;
        LegalEntityRecId legalEntityIdToRelieve;
        LedgerDimensionBase sourceLedgerDimension;
        LedgerDimensionBudgetControl controlLedgerDimension;
        CurrencyCode sourceDetailAccountingCurrency;
        CurrencyCode relievingDetailAccountingCurrency;
        BudgetControlDetail budgetControlDetail;

        LedgerRecId primaryLedgerId;
        LedgerRecId primaryLedgerIdToRelieve;
        str localBudgetSourceDetailKey;
        BudgetGroup localBudgetGroup;

        Map primaryLedgerControlDetails;
        Map primaryLedgerRelievingDetails;
        Map primaryLedgerGroups;

        if (_budgetCheckTransactionCurrencyTotals.elements() > 0)
        {
            budgetCheckTransactionCurrencyTotalsEnumerator = _budgetCheckTransactionCurrencyTotals.getEnumerator();

            while (budgetCheckTransactionCurrencyTotalsEnumerator.moveNext())
            {
                totalBudgetCurrencyAmount = 0;
                totalBudgetRelievingCurrencyAmount = 0;

                localSourceRelievingDetailsKey = budgetCheckTransactionCurrencyTotalsEnumerator.currentKey();

                localSourceLedgerDimensionDetail = budgetCheckAndRelievingLedgerDimensions.lookup(localSourceRelievingDetailsKey);

                legalEntityId = conpeek(localSourceLedgerDimensionDetail, 1);
                sourceLedgerDimension = conpeek(localSourceLedgerDimensionDetail, 2);
                legalEntityIdToRelieve = conpeek(localSourceLedgerDimensionDetail, 4);
                primaryLedgerId = primaryLedgersToCheckBudget.lookup(legalEntityId);
                primaryLedgerIdToRelieve = primaryLedgersToRelieveBudget.lookup(legalEntityIdToRelieve);

                localCurrencyDetails = budgetCheckTransactionCurrencyTotalsEnumerator.currentValue();

                // Calculate the budget currency amount for the source detail transaction currency
                localCurrencyDetailsEnumerator = localCurrencyDetails.getEnumerator();

                // Retrieve parmExchangeRate1() value which is the 6th value in the container.
                ExchRate fixedExchRate = conpeek(localSourceLedgerDimensionDetail, 6);

                while (localCurrencyDetailsEnumerator.moveNext())
                {
                    totalBudgetCurrencyAmount += this.convertAmountCurToAmountMst(
                        primaryLedgerId,
                        localCurrencyDetailsEnumerator.currentValue(),
                        localCurrencyDetailsEnumerator.currentKey(),
                        fixedExchRate);
                }

                if (_budgetRelievingTransactionCurrencyTotals.exists(localSourceRelievingDetailsKey))
                {
                    localRelievingCurrencyDetails = _budgetRelievingTransactionCurrencyTotals.lookup(localSourceRelievingDetailsKey);

                    // Calculate the budget relieving currency amount for the source relieving detail transaction currency
                    localRelievingCurrencyDetailsEnumerator = localRelievingCurrencyDetails.getEnumerator();

                    // Retrieve parmExchangeRate1() value which is the 6th value in the container.
                    fixedExchRate = conpeek(localSourceLedgerDimensionDetail, 6);

                    while (localRelievingCurrencyDetailsEnumerator.moveNext())
                    {
                        totalBudgetRelievingCurrencyAmount += this.convertAmountCurToAmountMst(
                            primaryLedgerIdToRelieve,
                            localRelievingCurrencyDetailsEnumerator.currentValue(),
                            localRelievingCurrencyDetailsEnumerator.currentKey(),
                            fixedExchRate);
                    }
                }

                sourceDetailAccountingCurrency = primaryLedgerCurrencies.lookup(primaryLedgerId);
                relievingDetailAccountingCurrency = primaryLedgerCurrencies.lookup(primaryLedgerIdToRelieve);

                summarizedBudgetRelievingDetail = BudgetRelievingDetail::newBudgetRelievingDetail(
                                                    legalEntityId,
                                                    sourceLedgerDimension,
                                                    totalBudgetCurrencyAmount,
                                                    sourceDetailAccountingCurrency,
                                                    conpeek(localSourceLedgerDimensionDetail, 3),
                                                    legalEntityIdToRelieve,
                                                    conpeek(localSourceLedgerDimensionDetail, 5),
                                                    totalBudgetRelievingCurrencyAmount,
                                                    relievingDetailAccountingCurrency);

                localBudgetSourceDetailKey = this.getBudgetSourceDetailKey(legalEntityId, sourceLedgerDimension);

                if (controlLedgerDimensions.exists(localBudgetSourceDetailKey))
                {
                    // Source ledger dimension requires budget check.
                    controlLedgerDimension = controlLedgerDimensions.lookup(localBudgetSourceDetailKey);

                    if (currentControlDetails.exists(primaryLedgerId))
                    {
                        primaryLedgerControlDetails = currentControlDetails.lookup(primaryLedgerId);

                        if (primaryLedgerControlDetails.exists(controlLedgerDimension))
                        {
                            // Add the budget check amount to the control ledger dimension's budget control detail.
                            budgetControlDetail = primaryLedgerControlDetails.lookup(controlLedgerDimension);

                            // Add relieving detail's budget check amount to the control detail total budget check amount.
                            totalBudgetCurrencyAmount += budgetControlDetail.parmBudgetCurrencyAmount();
                        }
                        else
                        {
                            budgetControlDetail = BudgetControlDetail::construct();
                        }
                    }
                    else
                    {
                        primaryLedgerControlDetails = new Map(recIdTypes, Types::Class);
                        budgetControlDetail = BudgetControlDetail::construct();
                    }

                    budgetControlDetail.parmBudgetCurrencyAmount(totalBudgetCurrencyAmount);
                    budgetControlDetail.parmPrimaryLedgerId(primaryLedgerId);
                    budgetControlDetail.parmBudgetControlRule(controlRules.lookup(localBudgetSourceDetailKey));
                    budgetControlDetail.parmControlLedgerDimension(controlLedgerDimension);
                    budgetControlDetail.addBudgetSourceDetail(summarizedBudgetRelievingDetail);

                    if (controlGroups.exists(primaryLedgerId))
                    {
                        primaryLedgerGroups = controlGroups.lookup(primaryLedgerId);

                        if (primaryLedgerGroups.exists(controlLedgerDimension))
                        {
                            localBudgetGroup = primaryLedgerGroups.lookup(controlLedgerDimension);

                            if (localBudgetGroup)
                            {
                                budgetControlDetail.parmBudgetGroupMember(topGroupMembers.lookup(localBudgetGroup.RecId));
                            }
                        }
                    }

                    // Add budget control detail to budget check details pool.
                    primaryLedgerControlDetails.insert(controlLedgerDimension, budgetControlDetail);
                    currentControlDetails.insert(primaryLedgerId, primaryLedgerControlDetails);

                    if (currentControlDetailsToRelieve.exists(primaryLedgerId))
                    {
                        primaryLedgerRelievingDetails = currentControlDetailsToRelieve.lookup(primaryLedgerId);
                    }
                    else
                    {
                        primaryLedgerRelievingDetails = new Map(recIdTypes, Types::Class);
                    }

                    primaryLedgerRelievingDetails.insert(budgetControlDetail.parmControlLedgerDimension(), budgetControlDetail);
                    currentControlDetailsToRelieve.insert(primaryLedgerId, primaryLedgerRelievingDetails);
                }
                else
                {
                    // Source ledger dimension is not enabled for budget control.
                    currentSourceDetailsToRelieve.add(summarizedBudgetRelievingDetail);
                }
            }
        }

        if (currentControlDetails.elements() > 0)
        {
            controlDetailsBySource.insert(currentCheckRequest.parmBudgetSourceId(), currentControlDetails);
        }

        if (currentControlDetailsToRelieve.elements() > 0)
        {
            controlDetailsToRelieveBySource.insert(currentCheckRequest.parmBudgetSourceId(), currentControlDetailsToRelieve);
        }

        if (currentSourceDetailsToRelieve.elements() > 0)
        {
            sourceDetailsToRelieveBySource.insert(currentCheckRequest.parmBudgetSourceId(), currentSourceDetailsToRelieve);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBudgetReturnDetailsToProcessCheck</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the budget return details with the budget checking transaction currency totals for
    ///    each source ledger dimension for later budget checking processing.
    /// </summary>
    /// <param name="_budgetCheckTransactionCurrencyTotals">
    ///    The transaction currency totals to return budget for each budget source ledger dimensions
    ///    checking budget.
    /// </param>
    protected void addBudgetReturnDetailsToProcessCheck(Map _budgetCheckTransactionCurrencyTotals)
    {
        str localBudgetSourceDetailKey;
        container localBudgetSourceDetail;

        // Key: transaction currency code
        // Value: Map
        //          Key: transaction currency code
        //          Value: transaction currency amount
        // Used to calculate budget currency amounts per transaction currency
        Map localCurrencyDetails;

        MapEnumerator localBudgetSourceDetailsEnumerator;
        LedgerDimensionBase sourceLedgerDimension;
        MapEnumerator localCurrencyDetailsEnumerator;
        AmountMST totalBudgetCurrencyAmount;
        BudgetReturnDetail summarizedBudgetReturnDetail;
        BudgetControlDetail budgetControlDetail;
        LedgerDimensionBudgetControl controlLedgerDimension;
        recId legalEntityId;
        recId primaryLedgerId;
        Map primaryLedgerControlDetails;

        // Source ledger dimension detail with same transaction currency code are validated and
        // its transaction currency amount summed up. Now calculate the budget currency amount
        // for the source ledger dimension detail.
        if (_budgetCheckTransactionCurrencyTotals.elements() > 0)
        {
            localBudgetSourceDetailsEnumerator = _budgetCheckTransactionCurrencyTotals.getEnumerator();

            while (localBudgetSourceDetailsEnumerator.moveNext())
            {
                localBudgetSourceDetailKey = localBudgetSourceDetailsEnumerator.currentKey();
                localCurrencyDetails = localBudgetSourceDetailsEnumerator.currentValue();

                localBudgetSourceDetail = budgetCheckLedgerDimensions.lookup(localBudgetSourceDetailKey);

                legalEntityId = conpeek(localBudgetSourceDetail, 1);
                sourceLedgerDimension = conpeek(localBudgetSourceDetail, 2);

                primaryLedgerId = primaryLedgersToCheckBudget.lookup(legalEntityId);

                if (localCurrencyDetails.elements() > 0)
                {
                    localCurrencyDetailsEnumerator = localCurrencyDetails.getEnumerator();

                    totalBudgetCurrencyAmount = 0;

                    // Retrieve parmExchangeRate1() value which is the 3rd value in the container.
                    ExchRate fixedExchRate = conpeek(localBudgetSourceDetail, 3);

                    // Summarize source ledger dimension budget currency amount.
                    while (localCurrencyDetailsEnumerator.moveNext())
                    {
                        totalBudgetCurrencyAmount += this.convertAmountCurToAmountMst(
                            primaryLedgerId,
                            localCurrencyDetailsEnumerator.currentValue(),
                            localCurrencyDetailsEnumerator.currentKey(),
                            fixedExchRate);
                    }

                    // Organize control ledger dimension with corresponding source ledger dimensions.
                    summarizedBudgetReturnDetail = BudgetReturnDetail::newBudgetReturnDetail(
                                                    legalEntityId,
                                                    sourceLedgerDimension,
                                                    totalBudgetCurrencyAmount,
                                                    primaryLedgerCurrencies.lookup(primaryLedgerId));

                    if (controlLedgerDimensions.exists(localBudgetSourceDetailKey))
                    {
                        controlLedgerDimension = controlLedgerDimensions.lookup(localBudgetSourceDetailKey);

                        // Source ledger dimension requires budget check.
                        if (currentReturnDetails.exists(primaryLedgerId))
                        {
                            primaryLedgerControlDetails = currentReturnDetails.lookup(primaryLedgerId);

                            if (primaryLedgerControlDetails.exists(controlLedgerDimension))
                            {
                                budgetControlDetail = primaryLedgerControlDetails.lookup(controlLedgerDimension);
                                totalBudgetCurrencyAmount += budgetControlDetail.parmBudgetCurrencyAmount();
                            }
                            else
                            {
                                budgetControlDetail = BudgetControlDetail::construct();
                            }
                        }
                        else
                        {
                            primaryLedgerControlDetails = new Map(recIdTypes, Types::Class);
                            budgetControlDetail = BudgetControlDetail::construct();
                        }

                        budgetControlDetail.parmBudgetCurrencyAmount(totalBudgetCurrencyAmount);
                        budgetControlDetail.parmPrimaryLedgerId(primaryLedgerId);
                        budgetControlDetail.parmControlLedgerDimension(controlLedgerDimension);
                        budgetControlDetail.addBudgetSourceDetail(summarizedBudgetReturnDetail);

                        primaryLedgerControlDetails.insert(controlLedgerDimension, budgetControlDetail);
                        currentReturnDetails.insert(primaryLedgerId, primaryLedgerControlDetails);
                    }
                }
            }
        }

        if (currentReturnDetails.elements() > 0)
        {
            controlReturnDetailsBySource.insert(currentCheckRequest.parmBudgetSourceId(), currentReturnDetails);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBudgetSourceError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the specified error message, error type, and error to the collection for the current budget source.
    /// </summary>
    /// <param name="_errorMessage">
    /// The error message to add to the collection.
    /// </param>
    /// <param name="_errorWarningType">
    /// The error type for the error message.
    /// </param>
    /// <param name="_errorWarning">
    /// The error for the error message.
    /// </param>
    protected void addBudgetSourceError(
        str _errorMessage,
        BudgetControlErrorWarningType _errorWarningType,
        BudgetControlErrorWarning _errorWarning)
    {
        currentErrorMessages.add(_errorMessage);
        errorMessagesBySource.insert(currentCheckRequest.parmBudgetSourceId(), currentErrorMessages);
        currentErrorWarning = _errorWarning;
        currentErrorWarningType = _errorWarningType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBudgetSourceToRemoveAtCommit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the record ID of the <c>BudgetSource</c> record to the collection to be removed on transaction commit.
    /// </summary>
    /// <param name="_budgetSourceId">
    /// The record ID of the <c>BudgetSource</c> record.
    /// </param>
    public void addBudgetSourceToRemoveAtCommit(BudgetSourceRecId _budgetSourceId)
    {
        if (appl.ttsLevel() > 0)
        {
            if (_budgetSourceId)
            {
                budgetSourcesToRemove.add(_budgetSourceId);
                isProcessingNeeded = true;
            }
        }
        else
        {
            // Budget control processing details must be added within a tts scope
            Debug::assert(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBudgetSourceToReturnRemainingAtCommit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the budget source details to the collection to be processed for return on transaction commit.
    /// </summary>
    /// <param name="_budgetSourceId">
    /// The record ID of the <c>BudgetSource</c> record.
    /// </param>
    /// <param name="_returnRemainingDate">
    /// The date to account for the return.
    /// </param>
    /// <param name="_returnRemainingUser">
    /// The user who performing the budget return.
    /// </param>
    /// <param name="_doReturnAsClosing">
    /// A boolean indicating whether to return the funds as a closing entry; optional.
    /// </param>
    public void addBudgetSourceToReturnRemainingAtCommit(
        BudgetSourceRecId _budgetSourceId,
        TransDate _returnRemainingDate,
        userId _returnRemainingUser,
        boolean _doReturnAsClosing = false)
    {
        container returnDateUser;

        if (appl.ttsLevel() > 0)
        {
            if (_budgetSourceId && _returnRemainingDate && _returnRemainingUser)
            {
                returnDateUser = [_returnRemainingDate, _returnRemainingUser, _doReturnAsClosing];

                budgetSourcesToReturnRemaining.insert(_budgetSourceId, returnDateUser);
                isProcessingNeeded = true;
            }
        }
        else
        {
            // Budget control processing details must be added within a tts scope
            Debug::assert(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCheckDetailToTransCurrencyTotal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds budget source detail transaction currency amount to check budget to the transaction currency total.
    /// </summary>
    /// <param name="_checkDetailsTransactionCurrencyTotals">
    ///    The transaction currency totals to check budget for each budget source ledger dimension checking budget.
    /// </param>
    /// <param name="_budgetSourceDetail">
    ///    The budget source ledger dimension detail that is checking budget.
    /// </param>
    protected void addCheckDetailToTransCurrencyTotal(
        Map _checkDetailsTransactionCurrencyTotals,
        BudgetSourceDetail _budgetSourceDetail)
    {
        // Key: transaction currency code
        // Value: Map
        //          Key: transaction currency code
        //          Value: transaction currency amount
        // Used to calculate budget currency amounts per transaction currency
        Map localCurrencyDetails;

        AmountCur totalTransactionCurrencyAmount;
        str localBudgetSourceDetailKey = this.getBudgetSourceDetailKey(
            _budgetSourceDetail.parmLegalEntityId(),
            _budgetSourceDetail.parmLedgerDimension());

        // Validate source ledger dimension
        if (_checkDetailsTransactionCurrencyTotals.exists(localBudgetSourceDetailKey))
        {
            localCurrencyDetails = _checkDetailsTransactionCurrencyTotals.lookup(localBudgetSourceDetailKey);

            if (localCurrencyDetails.exists(_budgetSourceDetail.parmCurrency()))
            {
                totalTransactionCurrencyAmount = localCurrencyDetails.lookup(
                    _budgetSourceDetail.parmCurrency());
                totalTransactionCurrencyAmount += _budgetSourceDetail.parmCurrencyAmount();
            }
            else
            {
                totalTransactionCurrencyAmount = _budgetSourceDetail.parmCurrencyAmount();
            }
        }
        else
        {
            localCurrencyDetails = new Map(Types::String, Types::Real);
            totalTransactionCurrencyAmount = _budgetSourceDetail.parmCurrencyAmount();
        }

        localCurrencyDetails.insert(_budgetSourceDetail.parmCurrency(), totalTransactionCurrencyAmount);
        _checkDetailsTransactionCurrencyTotals.insert(localBudgetSourceDetailKey, localCurrencyDetails);
        
        budgetCheckLedgerDimensions.insert(
            localBudgetSourceDetailKey,
            [_budgetSourceDetail.parmLegalEntityId(),
            _budgetSourceDetail.parmLedgerDimension(),
            _budgetSourceDetail.parmExchangeRate1()]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerToCleanupDrafts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the ledger to be processed for draft reservation cleanup on transaction commit.
    /// </summary>
    /// <param name="_ledgerToCleanup">
    /// The record ID of the <c>Ledger</c> record.
    /// </param>
    /// <param name="_integratorsToCleanup">
    /// A <c>Set</c> of budget control integrators for which to cleanup draft reservations; optional.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Invalid value for <c>BudgetControlSourceIntegrator</c> enumeration included in the collection.
    /// </exception>
    /// <remarks>
    /// If a collection of integrator values is provided, only the integrators designated will be affected.
    /// If no collection of integrator values is provided, all integrators will be affected.
    /// </remarks>
    public void addLedgerToCleanupDrafts(LedgerRecId _ledgerToCleanup, Set _integratorsToCleanup = null)
    {
        SetEnumerator integratorsToCleanupEnumerator;
        DictEnum dictEnum;
        BudgetControlSourceIntegrator integrator;
        Set validatedIntegratorsToCleanup;

        if (appl.ttsLevel() > 0)
        {
            if (_ledgerToCleanup)
            {
                if (_integratorsToCleanup)
                {
                    // Specific integrator types were specified for cleanup
                    validatedIntegratorsToCleanup = new Set(Types::Enum);
                    integratorsToCleanupEnumerator = _integratorsToCleanup.getEnumerator();

                    dictEnum = new DictEnum(enumnum(BudgetControlSourceIntegrator));

                    while (integratorsToCleanupEnumerator.moveNext())
                    {
                        integrator = integratorsToCleanupEnumerator.current();

                        if (dictEnum.value2Symbol(enum2int(integrator)) != '')
                        {
                            validatedIntegratorsToCleanup.add(integrator);
                        }
                        else
                        {
                            if (Debug::debugMode())
                            {
                                throw error(Error::wrongUseOfFunction(funcName()));
                            }
                        }
                    }
                }

                // Add ledger to collection for cleanup, if cleanup if for all drafts, validatedIntegratorsToCleanup will be null
                ledgersToCleanupDrafts.insert(_ledgerToCleanup, validatedIntegratorsToCleanup);
                isProcessingNeeded = true;
            }
        }
        else
        {
            // Budget control processing details must be added within a tts scope
            Debug::assert(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerToCleanupUntrackedDrafts</Name>
				<Source><![CDATA[
    internal void addLedgerToCleanupUntrackedDrafts(LedgerRecId _ledgerToCleanup)
    {
        if (appl.ttsLevel() > 0)
        {
            if (_ledgerToCleanup)
            {
                ledgersToCleanupUntrackedDrafts.add(_ledgerToCleanup);
                isProcessingNeeded = true;
            }
        }
        else
        {
            // Budget control processing details must be added within a tts scope
            Debug::assert(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRelievingDetailToTransCurrencyTotal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds budget source detail transaction currency amount to check budget to the budget check
    ///    transaction currency total and the amount to relieve budget to the budget relieving
    ///    transaction currency total.
    /// </summary>
    /// <param name="_relievingDetailsBudgetCheckTransCurrencyTotals">
    ///    The transaction currency totals to check budget for each budget source ledger dimension checking budget.
    /// </param>
    /// <param name="_relievingDetailsBudgetRelievingTransCurrencyTotals">
    ///    The transaction currency totals to relieve budget for each budget source ledger dimension whose budget funds are to be relieved.
    /// </param>
    /// <param name="_budgetRelievingDetail">
    ///    The budget relieving detail that is relieving budget.
    /// </param>
    protected void addRelievingDetailToTransCurrencyTotal(
        Map _relievingDetailsBudgetCheckTransCurrencyTotals,
        Map _relievingDetailsBudgetRelievingTransCurrencyTotals,
        BudgetRelievingDetail _budgetRelievingDetail)
    {
        Map localCurrencyDetails;

        // Key: String (source legal entity Id, source ledger dimension Id, relieving budget source Id, relieving legal entity Id, relieving source ledger dimension Id)
        // Value: Map
        //          Key: budget relieving transaction currency code
        //          Value: summarized budget relieving transaction currency amount
        Map localRelievingCurrencyDetails;

        str localSourceRelievingDetailsKey;
        Amount totalCurrencyAmount;
        Amount totalRelievingCurrencyAmount;

        localSourceRelievingDetailsKey = this.getBudgetRelievingDetailKey(
            _budgetRelievingDetail.parmLegalEntityId(),
            _budgetRelievingDetail.parmLedgerDimension(),
            _budgetRelievingDetail.parmBudgetSourceIdToRelieve(),
            _budgetRelievingDetail.parmLegalEntityIdToRelieve(),
            _budgetRelievingDetail.parmLedgerDimensionToRelieve());

        // Summarize budget relieving detail per unique pair of source ledger dimension and relieving ledger dimension.
        if (_relievingDetailsBudgetCheckTransCurrencyTotals.exists(localSourceRelievingDetailsKey))
        {
            localCurrencyDetails = _relievingDetailsBudgetCheckTransCurrencyTotals.lookup(localSourceRelievingDetailsKey);
            localRelievingCurrencyDetails = _relievingDetailsBudgetRelievingTransCurrencyTotals.lookup(localSourceRelievingDetailsKey);

            if (localCurrencyDetails.exists(_budgetRelievingDetail.parmCurrency()))
            {
                totalCurrencyAmount = localCurrencyDetails.lookup(_budgetRelievingDetail.parmCurrency());
            }

            totalCurrencyAmount += _budgetRelievingDetail.parmCurrencyAmount();

            if (localRelievingCurrencyDetails.exists(_budgetRelievingDetail.parmCurrencyToRelieve()))
            {
                totalRelievingCurrencyAmount = localRelievingCurrencyDetails.lookup(_budgetRelievingDetail.parmCurrencyToRelieve());
            }

            totalRelievingCurrencyAmount += _budgetRelievingDetail.parmCurrencyAmountToRelieve();
        }
        else
        {
            localCurrencyDetails = new Map(Types::String, Types::Real);
            localRelievingCurrencyDetails = new Map(Types::String, Types::Real);
            totalCurrencyAmount = _budgetRelievingDetail.parmCurrencyAmount();
            totalRelievingCurrencyAmount = _budgetRelievingDetail.parmCurrencyAmountToRelieve();
        }

        localCurrencyDetails.insert(_budgetRelievingDetail.parmCurrency(), totalCurrencyAmount);
        _relievingDetailsBudgetCheckTransCurrencyTotals.insert(localSourceRelievingDetailsKey, localCurrencyDetails);
        localRelievingCurrencyDetails.insert(_budgetRelievingDetail.parmCurrencyToRelieve(), totalRelievingCurrencyAmount);
        _relievingDetailsBudgetRelievingTransCurrencyTotals.insert(localSourceRelievingDetailsKey, localRelievingCurrencyDetails);

        budgetCheckAndRelievingLedgerDimensions.insert(
            localSourceRelievingDetailsKey,
            [_budgetRelievingDetail.parmLegalEntityId(),
            _budgetRelievingDetail.parmLedgerDimension(),
            _budgetRelievingDetail.parmBudgetSourceIdToRelieve(),
            _budgetRelievingDetail.parmLegalEntityIdToRelieve(),
            _budgetRelievingDetail.parmLedgerDimensionToRelieve(),
            _budgetRelievingDetail.parmExchangeRate1()]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>areProcessingDetailsPrepared</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether there are any processing details prepared for budget check.
    /// </summary>
    /// <returns>
    /// true if there are any processing details prepared for budget check; otherwise, false.
    /// </returns>
    private boolean areProcessingDetailsPrepared()
    {
        boolean areProcessingDetailsPrepared;

        areProcessingDetailsPrepared = arePendingDeletionsPrepared ||
            areReturnDetailsPrepared ||
            areRelievingDetailsPrepared ||
            areTrackingDetailsPrepared;

        return areProcessingDetailsPrepared;
    }

]]></Source>
			</Method>
			<Method>
				<Name>areProcessingDetailsPreparedForCurrent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether there are any processing details prepared for the current budget source.
    /// </summary>
    /// <returns>
    /// true if there are any processing details prepared for current budget source; otherwise, false.
    /// </returns>
    private boolean areProcessingDetailsPreparedForCurrent()
    {
        boolean isPrepared = false;

        isPrepared = currentTrackingUpdate && (
                        currentTrackingUpdate.arePendingDeletionsPrepared() ||
                        currentTrackingUpdate.areReturnDetailsPrepared() ||
                        currentTrackingUpdate.areRelievingDetailsPrepared() ||
                        currentTrackingUpdate.areTrackingDetailsPrepared());

        return isPrepared;
    }

]]></Source>
			</Method>
			<Method>
				<Name>areWarningsSuppressed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether warnings are suppressed for the specified user and budget control configuration.
    /// </summary>
    /// <param name="_configurationRecId">
    /// The record ID of the <c>BudgetControlConfiguration</c> record for which to determine if warnings are suppressed.
    /// </param>
    /// <param name="_userId">
    /// The user ID for which to determine if warnings are suppressed.
    /// </param>
    /// <returns>
    /// true if warnings are suppressed; otherwise false.
    /// </returns>
    protected boolean areWarningsSuppressed(recId _configurationRecId, userId _userId)
    {
        Map userSuppressWarnings;
        boolean suppressWarnings;

        if (configurationUserSuppressWarnings.exists(_configurationRecId))
        {
            userSuppressWarnings = configurationUserSuppressWarnings.lookup(_configurationRecId);

            if (userSuppressWarnings.exists(_userId))
            {
                suppressWarnings = userSuppressWarnings.lookup(_userId);
            }
            else
            {
                suppressWarnings = BudgetControlUserGroupSuppressWarnings::doSuppressWarningsForUser(_configurationRecId, _userId);
            }
        }
        else
        {
            userSuppressWarnings = new Map(Types::String, Types::Enum);
            suppressWarnings = BudgetControlUserGroupSuppressWarnings::doSuppressWarningsForUser(_configurationRecId, _userId);
        }

        userSuppressWarnings.insert(_userId, suppressWarnings);
        configurationUserSuppressWarnings.insert(_configurationRecId, userSuppressWarnings);

        return suppressWarnings;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheCurrentBudgetResultDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Caches the current result related details for the current budget source.
    /// </summary>
    protected void cacheCurrentBudgetResultDetails()
    {
        BudgetSourceRecId localBudgetSourceId = currentCheckRequest.parmBudgetSourceId();

        sourceResults.insert(localBudgetSourceId, currentSourceResult);
        errorMessagesBySource.insert(localBudgetSourceId, currentErrorMessages);
        warningMessagesBySource.insert(localBudgetSourceId, currentWarningMessages);
        errorWarningTypesBySource.insert(localBudgetSourceId, currentErrorWarningType);
        errorWarningsBySource.insert(localBudgetSourceId, currentErrorWarning);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTableCache</Name>
				<Source><![CDATA[
    private void clearTableCache()
    {
        // Table cache must be flushed in order to force the refresh for changes made in the stored procedure
        Dictionary::dataFlush(tablenum(BudgetSource));
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertAmountCurToAmountMst</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the specified amount in the specified currency to the accounting currency of the ledger
    /// using the budget exchange rate type.
    /// </summary>
    /// <param name="_primaryLedgerId">
    /// The primary ledger for the accounting currency.
    /// </param>
    /// <param name="_amountToConvert">
    /// The amount to be converted to the accounting currency of the ledger.
    /// </param>
    /// <param name="_currency">
    /// The currency to be converted from.
    /// </param>
    /// <param name="_fixedExchRate">
    /// Fixed exchange rate to be used to calculate amount in the accounting currency.
    /// </param>
    /// <returns>
    /// The amount converted to the accounting currency of the ledger.
    /// </returns>
    protected AmountMST convertAmountCurToAmountMst(
        LedgerRecId _primaryLedgerId,
        AmountCur _amountToConvert,
        CurrencyCode _currency,
        ExchRate _fixedExchRate)
    {
        AmountMST amountMST;
        CurrencyExchangeHelper currencyHelper;

        if (_currency == primaryLedgerCurrencies.lookup(_primaryLedgerId))
        {
            // Currency is the same as the budget currency - no conversion needed
            amountMST = _amountToConvert;
        }
        else
        {
            currencyHelper = validCurrencyHelpers.lookup(_primaryLedgerId);

            // Use the _fixedExchRate value to calculate the amount in the accounting currency; otherwise, follow default behaviour when the _fixedExchRate value is zero
            if (_fixedExchRate > 0)
            {
                currencyHelper.parmExchangeRate1(_fixedExchRate);
            }

            amountMST = currencyHelper.calculateTransactionToAccounting(_currency, _amountToConvert, true);
        }

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineBudgetCheckMessages</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines messages resulting from the budget check for the specified budget source.
    /// </summary>
    /// <param name="_budgetSourceId">
    /// The record ID of the budget source for which to determine messages.
    /// </param>
    protected void determineBudgetCheckMessages(BudgetSourceRecId _budgetSourceId)
    {
        BudgetSource budgetSource;
        BudgetCheckResultErrorWarningDetail errorWarningDetail;
        BudgetCheckResultErrorWarningDetail groupErrorWarningDetail;
        Map localPrimaryLedgerControlGroups;
        BudgetGroup budgetGroup;
        str resultMessageCacheKey;
        Map detailResultsForMsgByGroupControlDim = new Map(Types::String, Types::Record);
        Map groupResultsForMsgByGroupControlDim = new Map(Types::String, Types::Record);

        MapEnumerator detailResults;

        while select budgetSource
            where budgetSource.RecId == _budgetSourceId &&
                  BudgetSource.CheckResultErrorWarningType != BudgetControlErrorWarningType::InvalidRequest
            outer join errorWarningDetail
                order by SequenceNumber
                    where errorWarningDetail.BudgetSource == budgetSource.RecId &&
                          errorWarningDetail.BudgetSourceLedgerDimension != 0
        {
            // Get the overall source results to return with the BudgetControlResult
            currentSourceResult = budgetSource.CheckResult;
            currentErrorWarning = budgetSource.CheckResultErrorWarning;
            currentErrorWarningType = budgetSource.CheckResultErrorWarningType;

            // Cache record for budget source for reference in case of failure
            budgetSourcesWithResultsBySource.insert(budgetSource.RecId, budgetSource);

            if (errorWarningDetail)
            {
                // Error or warning resulted from ledger dimension budget check
                if (controlGroups.exists(errorWarningDetail.PrimaryLedger))
                {
                    localPrimaryLedgerControlGroups = controlGroups.lookup(errorWarningDetail.PrimaryLedger);

                    if (localPrimaryLedgerControlGroups.exists(errorWarningDetail.BudgetControlLedgerDimension))
                    {
                        budgetGroup = localPrimaryLedgerControlGroups.lookup(errorWarningDetail.BudgetControlLedgerDimension);
                    }
                }

                // Build cache key for messaging cache - this will ensure messages are produced per detail+group pairing
                // Using the BudgetGroupMember ensures that messaging will be preserved across ledgers even if the BudgetControlLedgerDimension is the same
                resultMessageCacheKey = strfmt('%1,%2,', errorWarningDetail.BudgetGroupMember, errorWarningDetail.BudgetControlLedgerDimension);

                if (budgetGroup.RecId)
                {
                    // Ledger dimension has budget group cached, find group result to use for determining messages
                    groupErrorWarningDetail = BudgetCheckResultErrorWarningDetail::findGroupBudgetCheckErrorWarningDetail(
                                                errorWarningDetail.BudgetSource,
                                                errorWarningDetail.SequenceNumber);

                    if (groupErrorWarningDetail)
                    {
                        // Cache record for group result on current control result for reference in case of failure
                        currentControlResult.addResultDetail(groupErrorWarningDetail);

                        // Cache record for group result for messaging
                        groupResultsForMsgByGroupControlDim.insert(resultMessageCacheKey, groupErrorWarningDetail);
                    }
                }

                // Cache record for detail after group result on current control result for reference in case of failure
                currentControlResult.addResultDetail(errorWarningDetail);

                // Cache record for detail result for messaging
                detailResultsForMsgByGroupControlDim.insert(resultMessageCacheKey, errorWarningDetail);
            }
        }

        // Determine messages based on cache details
        if (detailResultsForMsgByGroupControlDim.elements() > 0)
        {
            detailResults = detailResultsForMsgByGroupControlDim.getEnumerator();

            while (detailResults.moveNext())
            {
                errorWarningDetail.clear();
                groupErrorWarningDetail.clear();

                errorWarningDetail = detailResults.currentValue();

                if (groupResultsForMsgByGroupControlDim.elements() > 0 &&
                    groupResultsForMsgByGroupControlDim.exists(detailResults.currentKey()))
                {
                    groupErrorWarningDetail = groupResultsForMsgByGroupControlDim.lookup(detailResults.currentKey());
                }

                // Determine messages based on BudgetCheckResultErrorWarningDetail records for detail & group
                this.determineMessagesForCheckResultDetails(errorWarningDetail.PrimaryLedger, errorWarningDetail, groupErrorWarningDetail);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDetailGroupStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the result of the check of the available budget based on the specified
    ///    <c>BudgetCheckResult</c> values for the detail and the group.
    /// </summary>
    /// <param name="_detailCheckResult">
    ///    The budget check result value from the detail budget check.
    /// </param>
    /// <param name="_groupCheckResult">
    ///    The budget check result value from the group budget check.
    /// </param>
    /// <returns>
    ///    The combined budget check result for the specified detail and group results.
    /// </returns>
    protected BudgetCheckResult determineDetailGroupStatus(
        BudgetCheckResult _detailCheckResult,
        BudgetCheckResult _groupCheckResult)
    {
        BudgetCheckResult detailGroupResult = BudgetCheckResult::NoCheck;

        if (_groupCheckResult != BudgetCheckResult::NoCheck)
        {
            if (_groupCheckResult == BudgetCheckResult::Failed)
            {
                detailGroupResult = BudgetCheckResult::Failed;
            }
            else if (_groupCheckResult == BudgetCheckResult::Passed &&
                     _detailCheckResult == BudgetCheckResult::Passed)
            {
                // Request passed budget at detail & group
                detailGroupResult = BudgetCheckResult::Passed;
            }
            else
            {
                detailGroupResult = BudgetCheckResult::PassedWithWarnings;
            }
        }
        else
        {
            detailGroupResult = _detailCheckResult;
        }

        return detailGroupResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineErrorMessages</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the error messages for the check of the available budget based on the specified
    ///    <c>BudgetCheckResultErrorWarningDetail</c> records.
    /// </summary>
    /// <param name="_primaryLedgerId">
    ///    The record ID for the primary ledger.
    /// </param>
    /// <param name="_detailResult">
    ///    The <c>BudgetCheckResultErrorWarningDetail</c> record associated with the detail budget check result.
    /// </param>
    /// <param name="_groupResult">
    ///    The <c>BudgetCheckResultErrorWarningDetail</c> record associated with the group budget check result.
    /// </param>
    protected void determineErrorMessages(
        LedgerRecId _primaryLedgerId,
        BudgetCheckResultErrorWarningDetail _detailResult,
        BudgetCheckResultErrorWarningDetail _groupResult)
    {
        CurrencyCode budgetCurrency = primaryLedgerCurrencies.lookup(_primaryLedgerId);
        BudgetGroupMemberName groupMemberName;

        void determineOverAvailableErrorMessage(boolean _isGroup)
        {
            // Add error - detail is over available budget, but overrun budget available is not allowed
            if (_isGroup)
            {
                // Add error to message set - group over budget available
                currentErrorMessages.add(
                    strFmt("@SYS128635",
                        groupMemberName,
                        this.getDimensionDisplayValue(_detailResult.BudgetControlLedgerDimension),
                        _groupResult.AccountingCurrencyAmountOverAvailable,
                        currentCheckRequest.parmTransactionNumber(),
                        budgetCurrency));
            }
            else
            {
                // Add error to message set - detail over budget available
                currentErrorMessages.add(
                    strFmt("@SYS128612",
                        currentCheckRequest.parmTransactionNumber(),
                        this.getDimensionDisplayValue(_detailResult.BudgetControlLedgerDimension),
                        _detailResult.AccountingCurrencyAmountOverAvailable,
                        budgetCurrency));
            }
        }

        void determineOverThresholdErrorMessage(boolean _isGroup)
        {
            if (_isGroup)
            {
                // Add error to message set - detail with group over threshold
                currentErrorMessages.add(
                    strFmt("@SYS128637",
                        groupMemberName,
                        this.getDimensionDisplayValue(_detailResult.BudgetControlLedgerDimension),
                        _groupResult.AccountingCurrencyAmountOverThreshold,
                        currentCheckRequest.parmTransactionNumber(),
                        budgetCurrency));
            }
            else
            {
                // Add error to message set - detail without group over threshold
                currentErrorMessages.add(
                    strFmt("@SYS128613",
                        currentCheckRequest.parmTransactionNumber(),
                        this.getDimensionDisplayValue(_detailResult.BudgetControlLedgerDimension),
                        _detailResult.AccountingCurrencyAmountOverThreshold,
                        budgetCurrency));
            }
        }

        void determineApportionmentExceedsErrorMessage()
        {
            currentErrorMessages.add("@SPS2397");
        }

        void determineOverAvailableOverThresholdErrorMessage(
            BudgetControlErrorWarning _errorWarning,
            boolean _isGroup)
        {
            switch (_errorWarning)
            {
                case BudgetControlErrorWarning::BudgetFundsAvailableExceeded:
                    determineOverAvailableErrorMessage(_isGroup);
                    break;

                case BudgetControlErrorWarning::BudgetThresholdExceeded:
                    determineOverThresholdErrorMessage(_isGroup);
                    break;

                case BudgetControlErrorWarning::ApportionmentBudgetExceeds:
                    determineApportionmentExceedsErrorMessage();
                    break;

                default:
                    // All other error-warning types handled by other cases
                    break;
            }
        }

        void determineErrorMessage(
            boolean _isAmountWithinThreshold,
            boolean _isAmountWithinAvailable,
            boolean _isGroup)
        {
            if (_isAmountWithinThreshold == true)
            {
                determineOverAvailableErrorMessage(_isGroup);
            }
            else if (_isAmountWithinAvailable == true)
            {
                determineOverThresholdErrorMessage(_isGroup);
            }
            else if ((_isAmountWithinAvailable == false) && (_isAmountWithinThreshold == false))
            {
                determineOverAvailableOverThresholdErrorMessage(
                    _isGroup ? _groupResult.CheckResultErrorWarning : _detailResult.CheckResultErrorWarning,
                    _isGroup);
            }
            // else error handling is not required.
        }

        void addDetailErrorMessages()
        {
            switch (_detailResult.CheckResult)
            {
                case BudgetCheckResult::Failed:
                    if (!_groupResult)
                    {
                        // If the detail has a group, detail-level errors should be down graded to warnings.
                        // Only add detail-level errors when it does not have a group.
                        determineErrorMessage(
                            this.isAmountWithinBoundary(_detailResult.AccountingCurrencyAmountOverThreshold),
                            this.isAmountWithinBoundary(_detailResult.AccountingCurrencyAmountOverAvailable),
                            false);
                    }
                    break;

                case BudgetCheckResult::Passed:
                case BudgetCheckResult::PassedWithWarnings:
                case BudgetCheckResult::NoCheck:
                // Error handling is not required.
                default:
                    break;
            }
        }

        void addGroupDetailErrorMessages()
        {
            determineErrorMessage(
                this.isAmountWithinBoundary(_groupResult.AccountingCurrencyAmountOverThreshold),
                this.isAmountWithinBoundary(_groupResult.AccountingCurrencyAmountOverAvailable),
                true);
        }

        //
        // End of local methods
        //

        if (_groupResult)
        {
            if (topGroupMemberNames.exists(_groupResult.BudgetGroupMember))
            {
                groupMemberName = topGroupMemberNames.lookup(_groupResult.BudgetGroupMember);
            }

            switch (_groupResult.CheckResult)
            {
                case BudgetCheckResult::Failed:
                    addGroupDetailErrorMessages();
                    break;

                case BudgetCheckResult::Passed:
                case BudgetCheckResult::PassedWithWarnings:
                // Any detail level error should be down graded to warning.
                case BudgetCheckResult::NoCheck:
                    // Error handling is not required.
                    break;

                default:
                    // Not implemented.
                    Debug::assert(false);
                    break;
            }
        }
        else
        {
            addDetailErrorMessages();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineMessagesForCheckResultDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determine messages based on the specified <c>BudgetCheckResultErrorWarningDetail</c> records.
    /// </summary>
    /// <param name="_primaryLedgerId">
    ///    The record ID for the primary ledger.
    /// </param>
    /// <param name="_detailResult">
    ///    The <c>BudgetCheckResultErrorWarningDetail</c> record associated with the detail budget check result.
    /// </param>
    /// <param name="_groupResult">
    ///    The <c>BudgetCheckResultErrorWarningDetail</c> record associated with the group budget check result.
    /// </param>
    /// <returns>
    ///    false if the result has the <c>failed</c> status; otherwise, true.
    /// </returns>
    protected boolean determineMessagesForCheckResultDetails(
        LedgerRecId _primaryLedgerId,
        BudgetCheckResultErrorWarningDetail _detailResult,
        BudgetCheckResultErrorWarningDetail _groupResult)
    {
        boolean detailPassed = true;
        BudgetCheckResult detailGroupResult;

        // Determine combination status of detail & group pair for messaging purposes
        detailGroupResult = this.determineDetailGroupStatus(
                            _detailResult.CheckResult,
                            _groupResult.CheckResult ? _groupResult.CheckResult : BudgetCheckResult::NoCheck);

        switch (detailGroupResult)
        {
            case BudgetCheckResult::Failed:
                // Determine error messages to be added for detail & group pair
                this.determineErrorMessages(_primaryLedgerId, _detailResult, _groupResult);

                // Determine warning messages to be added for detail & group pair
                this.determineWarningMessages(_primaryLedgerId, _detailResult, _groupResult);

                // Return to indicate failure
                detailPassed = false;

                break;

            case BudgetCheckResult::PassedWithWarnings:
                // Determine warning messages to be added for detail & group pair
                this.determineWarningMessages(_primaryLedgerId, _detailResult, _groupResult);

                break;

            case BudgetCheckResult::Passed:
            // No messaging is required
            case BudgetCheckResult::NoCheck:
                // Source does not require budgetary control.

                break;

            default:
                // Not implemented.
                Debug::assert(false);

                break;
        }

        return detailPassed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineWarningMessages</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the warning messages for the check of the available budget based on the specified
    ///    <c>BudgetCheckResultErrorWarningDetail</c> records.
    /// </summary>
    /// <param name="_primaryLedgerId">
    ///    The record ID for the primary ledger.
    /// </param>
    /// <param name="_detailResult">
    ///    The <c>BudgetCheckResultErrorWarningDetail</c> record associated with the detail budget check result.
    /// </param>
    /// <param name="_groupResult">
    ///    The <c>BudgetCheckResultErrorWarningDetail</c> record associated with the group budget check result.
    /// </param>
    protected void determineWarningMessages(
        LedgerRecId _primaryLedgerId,
        BudgetCheckResultErrorWarningDetail _detailResult,
        BudgetCheckResultErrorWarningDetail _groupResult)
    {
        CurrencyCode budgetCurrency = primaryLedgerCurrencies.lookup(_primaryLedgerId);
        BudgetControlConfiguration configuration = primaryLedgerConfigurations.lookup(_primaryLedgerId);
        BudgetGroupMemberName groupMemberName;

        void determineOverAvailableWarningMessage(boolean _isGroup)
        {
            if (_isGroup)
            {
                if (_groupResult.CheckResultErrorWarning == BudgetControlErrorWarning::BudgetFundsAvailableExceededAllowed)
                {
                    currentWarningMessages.add(strfmt("@SYS317162",
                        groupMemberName));
                }
                else
                {
                    currentWarningMessages.add(
                        strFmt("@SYS128635",
                            groupMemberName,
                            this.getDimensionDisplayValue(_detailResult.BudgetControlLedgerDimension),
                            _groupResult.AccountingCurrencyAmountOverAvailable,
                            currentCheckRequest.parmTransactionNumber(),
                            budgetCurrency));
                }
            }
            else
            {
                if (_detailResult.CheckResultErrorWarning == BudgetControlErrorWarning::BudgetFundsAvailableExceededAllowed ||
                    _detailResult.CheckResultErrorWarning == BudgetControlErrorWarning::BudgetFundsRuleOverGroupUnderAvailable)
                {
                    // Only use less severe warning message when the user is allowed to overrun budget or
                    // the group passed the budget check without warnings

                    currentWarningMessages.add(
                        strFmt("@SYS128624",
                        this.getDimensionDisplayValue(_detailResult.BudgetControlLedgerDimension)));
                }
                else
                {
                    currentWarningMessages.add(
                        strFmt("@SYS128612",
                            currentCheckRequest.parmTransactionNumber(),
                            this.getDimensionDisplayValue(_detailResult.BudgetControlLedgerDimension),
                            _detailResult.AccountingCurrencyAmountOverAvailable,
                            budgetCurrency));
                }
            }
        }

        void determineOverThresholdWarningMessage(boolean _isGroup)
        {
            if (_isGroup)
            {
                if (_groupResult.CheckResultErrorWarning == BudgetControlErrorWarning::BudgetThresholdExceededAllowed  ||
                    _groupResult.CheckResultErrorWarning == BudgetControlErrorWarning::BudgetThresholdExceededApproved)
                {
                    // Threshold can be exceeded for group
                    // Configuration is set to warn on budget over threshold.
                    // User's group overbudget option does not prevent processing over budget threshold, only on over budget available
                    // User's group overbudget option allows budget overrun
                    // Or the budget source has been approved to overrun budget
                    currentWarningMessages.add(
                        strFmt("@SYS128636",
                            groupMemberName,
                            this.getDimensionDisplayValue(_detailResult.BudgetControlLedgerDimension),
                            _groupResult.AccountingCurrencyAmountOverThreshold,
                            currentCheckRequest.parmTransactionNumber(),
                            budgetCurrency));
                }
            }
            else
            {
                if (_groupResult)
                {
                    if (_groupResult.CheckResult != BudgetCheckResult::Failed)
                    {
                        currentWarningMessages.add(
                            strFmt("@SYS128611",
                                currentCheckRequest.parmTransactionNumber(),
                                this.getDimensionDisplayValue(_detailResult.BudgetControlLedgerDimension),
                                _detailResult.AccountingCurrencyAmountOverThreshold,
                                budgetCurrency));
                    }
                    // else suppress threshold warning messages if group result is failed.
                    // Group would receive its own error.
                }
                else
                {
                    if (_detailResult.CheckResultErrorWarning == BudgetControlErrorWarning::BudgetThresholdExceededAllowed ||
                        _detailResult.CheckResultErrorWarning == BudgetControlErrorWarning::BudgetFundsRuleOverGroupUnderAvailable ||
                        _detailResult.CheckResultErrorWarning == BudgetControlErrorWarning::BudgetThresholdExceededApproved)
                    {
                        // Threshold can be exceeded for detail
                        // Configuration is set to warn on budget over threshold.
                        // User's detail overbudget option does not prevent budget posting over budget threshold, only on over budget available
                        // User's detail overbudget option allows budget overrun
                        // Or the budget source has been approved to overrun budget
                        currentWarningMessages.add(
                            strFmt("@SYS128611",
                                currentCheckRequest.parmTransactionNumber(),
                                this.getDimensionDisplayValue(_detailResult.BudgetControlLedgerDimension),
                                _detailResult.AccountingCurrencyAmountOverThreshold,
                                budgetCurrency));
                    }
                    // else the detail should receive error
                }
            }
        }

        void determineWarningMessage(boolean _isAmountWithinThreshold, boolean _isAmountWithinAvailable, boolean _isGroup)
        {
            if (_isAmountWithinThreshold == true)
            {
                determineOverAvailableWarningMessage(_isGroup);
            }
            else if (_isAmountWithinAvailable == true)
            {
                determineOverThresholdWarningMessage(_isGroup);
            }
            else if ((_isAmountWithinAvailable == false) && (_isAmountWithinThreshold == false))
            {
                // Warn on amount over budget available regardless the threshold is greater or
                // less than 100 percent.
                determineOverAvailableWarningMessage(_isGroup);
            }
            // else no warning is required.
        }

        //
        // End of local methods
        //

        if (!this.areWarningsSuppressed(configuration.RecId, currentCheckRequest.parmUser()))
        {
            if (_groupResult)
            {
                if (topGroupMemberNames.exists(_groupResult.BudgetGroupMember))
                {
                    groupMemberName = topGroupMemberNames.lookup(_groupResult.BudgetGroupMember);
                }

                switch (_groupResult.CheckResult)
                {
                    case BudgetCheckResult::Passed:
                        if (_detailResult.CheckResult == BudgetCheckResult::PassedWithWarnings ||
                            _detailResult.CheckResult == BudgetCheckResult::Failed)
                        {
                            // Add messages for detail only as group passed & needs no messages.
                            determineWarningMessage(
                                this.isAmountWithinBoundary(_detailResult.AccountingCurrencyAmountOverThreshold),
                                this.isAmountWithinBoundary(_detailResult.AccountingCurrencyAmountOverAvailable),
                                false);
                        }
                        break;

                    case BudgetCheckResult::PassedWithWarnings:
                        // Add messages for group & detail as group passed so both may need messages.
                        determineWarningMessage(
                            this.isAmountWithinBoundary(_groupResult.AccountingCurrencyAmountOverThreshold),
                            this.isAmountWithinBoundary(_groupResult.AccountingCurrencyAmountOverAvailable),
                            true);

                        if (_detailResult.CheckResult == BudgetCheckResult::PassedWithWarnings ||
                            _detailResult.CheckResult == BudgetCheckResult::Failed)
                        {
                            determineWarningMessage(
                                this.isAmountWithinBoundary(_detailResult.AccountingCurrencyAmountOverThreshold),
                                this.isAmountWithinBoundary(_detailResult.AccountingCurrencyAmountOverAvailable),
                                false);
                        }
                        break;

                    case BudgetCheckResult::Failed:
                        if (_detailResult.CheckResult == BudgetCheckResult::PassedWithWarnings ||
                            _detailResult.CheckResult == BudgetCheckResult::Failed)
                        {
                            // Group failure is handled in error messages method.
                            // Add messages for detail over threshold or over budget available warnings.
                            determineWarningMessage(
                                this.isAmountWithinBoundary(_detailResult.AccountingCurrencyAmountOverThreshold),
                                this.isAmountWithinBoundary(_detailResult.AccountingCurrencyAmountOverAvailable),
                                false);
                        }
                        break;

                    case BudgetCheckResult::NoCheck:
                    // No warning handling is required.
                    default:
                        break;
                }
            }
            else
            {
                switch (_detailResult.CheckResult)
                {
                    case BudgetCheckResult::PassedWithWarnings:
                        determineWarningMessage(
                            this.isAmountWithinBoundary(_detailResult.AccountingCurrencyAmountOverThreshold),
                            this.isAmountWithinBoundary(_detailResult.AccountingCurrencyAmountOverAvailable),
                            false);

                        break;

                    case BudgetCheckResult::Passed:
                    case BudgetCheckResult::Failed:
                    case BudgetCheckResult::NoCheck:
                    // No warning messages are required for these cases.
                    default:
                        break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayBudgetCheckMessages</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays error and warning messages resulting from the budget check.
    /// </summary>
    protected void displayBudgetCheckMessages()
    {
        SetEnumerator messagesToDisplay;

        if (budgetControlResultCollection != null &&
            budgetControlResultCollection.elements() > 0 &&
            doDisplayMessagesFromBudgetCheck)
        {
            budgetControlResultCollection.initializeEnumerator();

            while (budgetControlResultCollection.moveNext())
            {
                currentControlResult = budgetControlResultCollection.currentBudgetControlResult();

                messagesToDisplay = currentControlResult.errorMessages().getEnumerator();

                while (messagesToDisplay.moveNext())
                {
                    error(messagesToDisplay.current());
                }

                messagesToDisplay = currentControlResult.warningMessages().getEnumerator();

                while (messagesToDisplay.moveNext())
                {
                    warning(messagesToDisplay.current());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetRelievingDetailKey</Name>
				<Source><![CDATA[
    private str getBudgetRelievingDetailKey(
        LegalEntityRecId _legalEntityId,
        LedgerDimensionBase _ledgerDimension,
        BudgetSourceRecId _budgetSourceIdToRelieve,
        LegalEntityRecId _legalEntityIdToRelieve,
        LedgerDimensionBase _ledgerDimensionToRelieve)
    {
        return strfmt(
            '%1,%2,%3,%4,%5',
            _legalEntityId,
            _ledgerDimension,
            _budgetSourceIdToRelieve,
            _legalEntityIdToRelieve,
            _ledgerDimensionToRelieve);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetSourceDetailKey</Name>
				<Source><![CDATA[
    private str getBudgetSourceDetailKey(
        LegalEntityRecId _legalEntityId,
        LedgerDimensionBase _ledgerDimensionRecId)
    {
        return strfmt('%1,%2', _legalEntityId, _ledgerDimensionRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetSourceTrackingToRelieve</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the budget source tracking record whose budget source tracking ledger dimension
    ///    budget funds are to be relieved.
    /// </summary>
    /// <param name="_budgetSourceIdToRelieve">
    ///    The ID for the budget source record whose budget source tracking ledger dimension
    ///    budget funds are to be relieved.
    /// </param>
    /// <returns>
    ///    The budget source tracking record.
    /// </returns>
    protected BudgetSourceTracking getBudgetSourceTrackingToRelieve(BudgetSourceRecId _budgetSourceIdToRelieve)
    {
        BudgetSourceTracking sourceTrackingToRelieve = BudgetSourceTracking::findByBudgetSource(
                                                        _budgetSourceIdToRelieve,
                                                        false);

        return sourceTrackingToRelieve;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionDisplayValue</Name>
				<Source><![CDATA[
    private DimensionDisplayValue getDimensionDisplayValue(LedgerDimensionBase _dimension)
    {
        return LedgerDimensionFacade::getDisplayValueForLedgerDimension(_dimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the instance.
    /// </summary>
    protected void initialize()
    {
        budgetCheckRequestsToProcess = BudgetControlCheckRequestCollection::construct();
        budgetSourcesToRemove = new Set(recIdTypes);
        ledgersToCleanupDrafts = new Map(recIdTypes, Types::Class);
        ledgersToCleanupUntrackedDrafts = new Set(recIdTypes);
        budgetSourcesToReturnRemaining = new Map(recIdTypes, Types::Container);
        budgetControlResultCollection = null;
        budgetSourcesWithResultsBySource = new Map(recIdTypes, Types::Record);

        doBudgetCheckForConfirmation = false;
        doBudgetCheckAsSimulation = false;
        doDisplayMessagesFromBudgetCheck = true;

        isProcessingNeeded = false;
        arePendingDeletionsPrepared = false;
        areRelievingDetailsPrepared = false;
        areTrackingDetailsPrepared = false;
        areReturnDetailsPrepared = false;

        primaryLedgersToCheckBudget = new Map(recIdTypes, recIdTypes);
        primaryLedgersToRelieveBudget = new Map(recIdTypes, recIdTypes);
        primaryLedgerCurrencies = new Map(recIdTypes, Types::String);
        primaryLedgerBudgetRateTypes = new Map(recIdTypes, recIdTypes);
        primaryLedgerConfigurations = new Map(recIdTypes, Types::Record);
        dataAreas = new Map(recIdTypes, Types::String);
        legalEntityLedgerCalendars = new Map(recIdTypes, recIdTypes);
        configurationUserSuppressWarnings = new Map(recIdTypes, Types::Class);

        validatedLegalEntities = new Map(recIdTypes, Types::Enum);
        validatedCurrencies = new Map(recIdTypes, Types::Class);
        validCurrencyHelpers = new Map(recIdTypes, Types::Class);
        validatedSourceLedgerDimensionDates = new Map(Types::String, Types::Enum);
        validatedBudgetDates = new Map(Types::String, Types::Enum);

        controlGroups = new Map(recIdTypes, Types::Class);
        topGroupMembers = new Map(recIdTypes, Types::Record);
        topGroupMemberNames = new Map(recIdTypes, Types::String);
        controlLedgerDimensions = new Map(Types::String, recIdTypes);
        controlRules = new Map(Types::String, Types::Record);
        controlRuleDateBudgetModels = new Map(Types::String, Types::Record);
        budgetCheckLedgerDimensions = new Map(Types::String, Types::Container);
        budgetCheckAndRelievingLedgerDimensions = new Map(Types::String, Types::Container);

        trackingUpdateStrategiesBySource = new Map(recIdTypes, Types::Class);
        trackingUpdateStrategiesBySource = new Map(recIdTypes, Types::Class);

        isOverrunApprovedBySource = new Map(recIdTypes, Types::Enum);
        sourceModelsBySource = new Map(recIdTypes, Types::Record);

        controlDetailsBySource = new Map(recIdTypes, Types::Class);
        controlReturnDetailsBySource = new Map(recIdTypes, Types::Class);
        controlDetailsToRelieveBySource = new Map(recIdTypes, Types::Class);
        sourceDetailsToRelieveBySource = new Map(recIdTypes, Types::Class);

        sourceResults = new Map(recIdTypes, Types::Enum);
        errorWarningTypesBySource = new Map(recIdTypes, Types::Enum);
        errorWarningsBySource = new Map(recIdTypes, Types::Enum);
        errorMessagesBySource = new Map(recIdTypes, Types::Class);
        warningMessagesBySource = new Map(recIdTypes, Types::Class);

        budgetCheckGroup = 0;
        budgetCheckGroupSequence = 0;

        isProcessingComplete = true;
        
        logger = BudgetControlInstrumentationLogger::createLogger(classStr(BudgetControlProcessor));

        logController = BudgetControlProcessingLogController::construct();

        // Reset all current class variables
        this.resetCurrentMembers();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAmountWithinBoundary</Name>
				<Source><![CDATA[
    private boolean isAmountWithinBoundary(AmountMST _amountOverBoundary)
    {
        return _amountOverBoundary <= 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadCurrentBudgetControlDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the control processing related details for the current budget source.
    /// </summary>
    protected void loadCurrentBudgetControlDetails()
    {
        BudgetSourceRecId localBudgetSourceId = currentCheckRequest.parmBudgetSourceId();

        if (controlDetailsBySource.exists(localBudgetSourceId))
        {
            currentControlDetails = controlDetailsBySource.lookup(localBudgetSourceId);
        }

        if (controlReturnDetailsBySource.exists(localBudgetSourceId))
        {
            currentReturnDetails = controlReturnDetailsBySource.lookup(localBudgetSourceId);
        }

        if (controlDetailsToRelieveBySource.exists(localBudgetSourceId))
        {
            currentControlDetailsToRelieve = controlDetailsToRelieveBySource.lookup(localBudgetSourceId);
        }

        if (sourceDetailsToRelieveBySource.exists(localBudgetSourceId))
        {
            currentSourceDetailsToRelieve = sourceDetailsToRelieveBySource.lookup(localBudgetSourceId);
        }

        if (sourceModelsBySource.exists(localBudgetSourceId))
        {
            currentSourceModel = sourceModelsBySource.lookup(localBudgetSourceId);
        }

        if (trackingUpdateStrategiesBySource.exists(localBudgetSourceId))
        {
            currentTrackingUpdate = trackingUpdateStrategiesBySource.lookup(localBudgetSourceId);
        }

        if (isOverrunApprovedBySource.exists(localBudgetSourceId))
        {
            currentIsOverrunApproved = isOverrunApprovedBySource.lookup(localBudgetSourceId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadCurrentBudgetResultDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the result processing related details for the current budget source.
    /// </summary>
    protected void loadCurrentBudgetResultDetails()
    {
        BudgetSourceRecId localBudgetSourceId = currentCheckRequest.parmBudgetSourceId();

        if (sourceResults.exists(localBudgetSourceId))
        {
            currentSourceResult = sourceResults.lookup(localBudgetSourceId);
        }

        if (errorMessagesBySource.exists(localBudgetSourceId))
        {
            currentErrorMessages = errorMessagesBySource.lookup(localBudgetSourceId);
        }

        if (warningMessagesBySource.exists(localBudgetSourceId))
        {
            currentWarningMessages = warningMessagesBySource.lookup(localBudgetSourceId);
        }

        if (errorWarningTypesBySource.exists(localBudgetSourceId))
        {
            currentErrorWarningType = errorWarningTypesBySource.lookup(localBudgetSourceId);
        }

        if (errorWarningsBySource.exists(localBudgetSourceId))
        {
            currentErrorWarning = errorWarningsBySource.lookup(localBudgetSourceId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markDraftsForCleanupByIntegrator</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the draft budget source tracking data for deletion.
    /// </summary>
    /// <param name="_primaryLedgerRecId">
    /// The record ID of the primary <c>Ledger</c> record.
    /// </param>
    /// <param name="_integrator">
    /// The budget control source integrator values for which to mark draft tracking data for deletion.
    /// </param>
    protected void markDraftsForCleanupByIntegrator(LedgerRecId _primaryLedgerRecId, BudgetControlSourceIntegrator _integrator)
    {
        BudgetSourceTrackingRelievingDetail relievingDetail;
        BudgetSourceTrackingDetail detail;
        BudgetSourceTrackingDetail nonPrimaryLedgerDetail;
        BudgetSourceTracking tracking;
        BudgetSourceTracking nonDraftTracking;
        BudgetCheckResultErrorWarningDetail resultDetail;
        BudgetCheckResultErrorWarningDetail nonPrimaryLedgerResultDetail;
        BudgetSource source;

        // Set connection on table buffers & skip data methods & delete actions on buffers with updates
        detail.skipDataMethods(true);
        detail.skipDeleteActions(true);
        relievingDetail.skipDataMethods(true);
        relievingDetail.skipDeleteActions(true);
        tracking.skipDataMethods(true);
        tracking.skipDeleteActions(true);
        resultDetail.skipDataMethods(true);
        resultDetail.skipDeleteActions(true);
        source.skipDataMethods(true);
        source.skipDeleteActions(true);

        // Remove all BudgetSource records that have a status of unprocessed or not checked.
        // The records can be deleted because they have no impact to summary as there are no check details or result details.
        delete_from source
            where source.BudgetControlSourceIntegrator == _integrator
                && (source.CheckResult == 0
                || source.CheckResult == BudgetCheckResult::NoCheck);

        // Mark BudgetSourceTrackingDetail related to draft BudgetSourceTracking for the integrator type for deletion
        update_recordSet detail
            setting IsDeletePending = NoYes::Yes
            where detail.PrimaryLedger == _primaryLedgerRecId
            exists join tracking
                where tracking.RecId == detail.BudgetSourceTracking &&
                      tracking.Status == BudgetSourceTrackingStatus::Draft
                exists join source
                    where tracking.BudgetSource == source.RecId &&
                          source.BudgetControlSourceIntegrator == _integrator;

        // Mark RelievingDetail related to a draft BudgetSourceTracking for the integrator type for deletion
        update_recordSet relievingDetail
            setting IsDeletePending = NoYes::Yes
            exists join detail
                where relievingDetail.RelievedBudgetSourceTrackingDetail == detail.RecId &&
                      detail.PrimaryLedger == _primaryLedgerRecId
                exists join tracking
                    where relievingDetail.RelievingBudgetSourceTracking == tracking.RecId &&
                          tracking.Status == BudgetSourceTrackingStatus::Draft
                    exists join source
                        where tracking.BudgetSource == source.RecId &&
                              source.BudgetControlSourceIntegrator == _integrator;

        // Mark draft BudgetSourceTracking for the integrator type for deletion
        update_recordSet tracking
            setting IsDeletePending = NoYes::Yes
            where tracking.Status == BudgetSourceTrackingStatus::Draft
            exists join source
                where tracking.BudgetSource == source.RecId &&
                      source.BudgetControlSourceIntegrator == _integrator
            notexists join nonPrimaryLedgerDetail
                where nonPrimaryLedgerDetail.BudgetSourceTracking == tracking.RecId &&
                      nonPrimaryLedgerDetail.PrimaryLedger != _primaryLedgerRecId;

        // Determine BudgetSource records to process for cleanup & mark if should also be deleted with processing
        while select forupdate source
            where source.BudgetControlSourceIntegrator == _integrator
            join RecId from tracking
                where tracking.BudgetSource == source.RecId &&
                      tracking.Status == BudgetSourceTrackingStatus::Draft
                exists join detail
                    where detail.PrimaryLedger == _primaryLedgerRecId &&
                          detail.BudgetSourceTracking == tracking.RecId
        {
            if (!budgetCheckGroup)
            {
                budgetCheckGroup = source.RecId;
            }

            source.BudgetCheckGroup = budgetCheckGroup;
            source.BudgetCheckGroupSequence = budgetCheckGroupSequence;

            select firstOnly nonDraftTracking
                where nonDraftTracking.BudgetSource == source.RecId &&
                        nonDraftTracking.Status == BudgetSourceTrackingStatus::Confirmed;

            select firstonly RecId from nonPrimaryLedgerDetail
                where nonPrimaryLedgerDetail.BudgetSourceTracking == tracking.RecId &&
                      nonPrimaryLedgerDetail.PrimaryLedger != _primaryLedgerRecId;

            select firstonly RecId from nonPrimaryLedgerResultDetail
                where nonPrimaryLedgerResultDetail.BudgetSource == source.RecId &&
                      nonPrimaryLedgerResultDetail.PrimaryLedger != _primaryLedgerRecId;

            if (!nonPrimaryLedgerDetail && !nonPrimaryLedgerResultDetail && !nonDraftTracking)
            {
                // The budget source has no tracking details or result details from a different primary ledger.
                source.IsDeletePending = NoYes::Yes;
            }

            source.update();

            budgetCheckGroupSequence++;
        }

        // Delete BudgetCheckResultErrorWarningDetail related to a draft BudgetSourceTracking via BudgetSource
        // can be deleted because they have no impact to Summary to be handled by processing.
        delete_from resultDetail
            where resultDetail.PrimaryLedger == _primaryLedgerRecId
            exists join source
                where resultDetail.BudgetSource == source.RecId &&
                        source.BudgetControlSourceIntegrator == _integrator
                exists join tracking
                    where tracking.BudgetSource == source.RecId &&
                          tracking.Status == BudgetSourceTrackingStatus::Draft;

        // Delete BudgetCheckResultErrorWarningDetail related to BudgetSource with no BudgetSourceTracking
        delete_from resultDetail
            where resultDetail.PrimaryLedger == _primaryLedgerRecId
            exists join source
                where resultDetail.BudgetSource == source.RecId &&
                        source.BudgetControlSourceIntegrator == _integrator
            notExists join tracking
                where tracking.BudgetSource == source.RecId;

        // Delete BudgetSource where no BudgetSourceTracking exist
        // The records can be deleted because they have no impact to Summary
        while select forupdate source
            where source.BudgetControlSourceIntegrator == _integrator
            notexists join tracking
                where tracking.BudgetSource == source.RecId
        {
            select firstonly RecId from nonPrimaryLedgerResultDetail
                where nonPrimaryLedgerResultDetail.BudgetSource == source.RecId &&
                    nonPrimaryLedgerResultDetail.PrimaryLedger != _primaryLedgerRecId;

            if (!nonPrimaryLedgerResultDetail)
            {
                source.delete();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markDraftsForCleanupByLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the draft budget source tracking data for deletion.
    /// </summary>
    /// <param name="_primaryLedgerRecId">
    /// The record ID of the primary <c>Ledger</c> record.
    /// </param>
    protected void markDraftsForCleanupByLedger(LedgerRecId _primaryLedgerRecId)
    {
        BudgetSourceTrackingRelievingDetail relievingDetail;
        BudgetSourceTrackingDetail detail;
        BudgetSourceTrackingDetail nonPrimaryLedgerDetail;
        BudgetSourceTracking tracking;
        BudgetSourceTracking nonDraftTracking;
        BudgetCheckResultErrorWarningDetail resultDetail;
        BudgetCheckResultErrorWarningDetail nonPrimaryLedgerResultDetail;
        BudgetSource source;

        // Set connection on table buffers & skip data methods & delete actions on buffers with updates
        detail.skipDataMethods(true);
        detail.skipDeleteActions(true);
        relievingDetail.skipDataMethods(true);
        relievingDetail.skipDeleteActions(true);
        tracking.skipDataMethods(true);
        tracking.skipDeleteActions(true);
        resultDetail.skipDataMethods(true);
        resultDetail.skipDeleteActions(true);
        source.skipDataMethods(true);
        source.skipDeleteActions(true);

        // Remove all BudgetSource records that have a status of unprocessed or not checked.
        // The records can be deleted because they have no impact to summary as there are no check details or result details.
        delete_from source
            where source.CheckResult == 0
                || source.CheckResult == BudgetCheckResult::NoCheck;

        // Mark BudgetSourceTrackingDetail related to draft BudgetSourceTracking for deletion
        update_recordSet detail
            setting IsDeletePending = NoYes::Yes
            where detail.PrimaryLedger == _primaryLedgerRecId
            exists join tracking
                where tracking.RecId == detail.BudgetSourceTracking &&
                      tracking.Status == BudgetSourceTrackingStatus::Draft;

        // Mark RelievingDetail related to a draft BudgetSourceTracking for deletion
        update_recordSet relievingDetail
            setting IsDeletePending = NoYes::Yes
            exists join detail
                where relievingDetail.RelievedBudgetSourceTrackingDetail == detail.RecId &&
                      detail.PrimaryLedger == _primaryLedgerRecId
                exists join tracking
                    where relievingDetail.RelievingBudgetSourceTracking == tracking.RecId &&
                          tracking.Status == BudgetSourceTrackingStatus::Draft;

        // Mark draft BudgetSourceTracking for deletion
        update_recordSet tracking
            setting IsDeletePending = NoYes::Yes
            where tracking.Status == BudgetSourceTrackingStatus::Draft
            notexists join nonPrimaryLedgerDetail
                where nonPrimaryLedgerDetail.BudgetSourceTracking == tracking.RecId &&
                      nonPrimaryLedgerDetail.PrimaryLedger != _primaryLedgerRecId;

        // Determine BudgetSource records to process for cleanup & mark if should also be deleted with processing
        while select forupdate source
            join RecId from tracking
                where tracking.BudgetSource == source.RecId &&
                      tracking.Status == BudgetSourceTrackingStatus::Draft
                exists join detail
                    where detail.PrimaryLedger == _primaryLedgerRecId &&
                          detail.BudgetSourceTracking == tracking.RecId
        {
            if (!budgetCheckGroup)
            {
                budgetCheckGroup = source.RecId;
            }

            source.BudgetCheckGroup = budgetCheckGroup;
            source.BudgetCheckGroupSequence = budgetCheckGroupSequence;

            select firstOnly nonDraftTracking
                where nonDraftTracking.BudgetSource == source.RecId &&
                      nonDraftTracking.Status == BudgetSourceTrackingStatus::Confirmed;

            select firstonly RecId from nonPrimaryLedgerDetail
                where nonPrimaryLedgerDetail.BudgetSourceTracking == tracking.RecId &&
                    nonPrimaryLedgerDetail.PrimaryLedger != _primaryLedgerRecId;

            select firstonly RecId from nonPrimaryLedgerResultDetail
                where nonPrimaryLedgerResultDetail.BudgetSource == source.RecId &&
                    nonPrimaryLedgerResultDetail.PrimaryLedger != _primaryLedgerRecId;

            if (!nonPrimaryLedgerDetail && !nonPrimaryLedgerResultDetail && !nonDraftTracking)
            {
                // The budget source has no tracking details or result details from a different primary ledger.
                source.IsDeletePending = NoYes::Yes;
            }

            source.update();

            budgetCheckGroupSequence++;
        }

        // Remove BudgetCheckResultErrorWarningDetail related to a draft BudgetSourceTracking via BudgetSource
        // can be deleted because they have no impact to Summary to be handled by processing.
        delete_from resultDetail
            where resultDetail.PrimaryLedger == _primaryLedgerRecId
            exists join source
                where resultDetail.BudgetSource == source.RecId
                exists join tracking
                    where tracking.BudgetSource == source.RecId &&
                          tracking.Status == BudgetSourceTrackingStatus::Draft;

        // Remove result detail related to budget source with no budget source tracking
        delete_from resultDetail
            where resultDetail.PrimaryLedger == _primaryLedgerRecId
            exists join source
                where resultDetail.BudgetSource == source.RecId
            notExists join tracking
                where tracking.BudgetSource == source.RecId;

        // Remove BudgetSource where no BudgetSourceTracking exist
        // The records can be deleted because they have no impact to Summary
        while select forupdate source
            notexists join tracking
                where tracking.BudgetSource == source.RecId
        {
            select firstonly RecId from nonPrimaryLedgerResultDetail
                where nonPrimaryLedgerResultDetail.BudgetSource == source.RecId &&
                    nonPrimaryLedgerResultDetail.PrimaryLedger != _primaryLedgerRecId;

            if (!nonPrimaryLedgerResultDetail)
            {
                source.delete();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markUntrackedDraftsForCleanup</Name>
				<Source><![CDATA[
    private void markUntrackedDraftsForCleanup(LedgerRecId _primaryLedgerRecId)
    {
        BudgetControlConfigurationDraftCategoryView draftCategoryView;
        BudgetSourceTrackingRelievingDetail relievingDetail;
        BudgetSourceTrackingDetail detail;
        BudgetSourceTrackingDetail nonPrimaryLedgerDetail;
        BudgetSourceTracking tracking;
        BudgetSourceTracking nonDraftTracking;
        BudgetCheckResultErrorWarningDetail resultDetail;
        BudgetCheckResultErrorWarningDetail nonPrimaryLedgerResultDetail;
        BudgetSource source;

        // Set connection on table buffers & skip data methods & delete actions on buffers with updates
        detail.skipDataMethods(true);
        detail.skipDeleteActions(true);
        relievingDetail.skipDataMethods(true);
        relievingDetail.skipDeleteActions(true);
        tracking.skipDataMethods(true);
        tracking.skipDeleteActions(true);
        resultDetail.skipDataMethods(true);
        resultDetail.skipDeleteActions(true);
        source.skipDataMethods(true);
        source.skipDeleteActions(true);

        // Mark BudgetSourceTrackingDetail related to draft BudgetSourceTracking for the integrator type for deletion
        update_recordSet detail
            setting IsDeletePending = NoYes::Yes
            where detail.PrimaryLedger == _primaryLedgerRecId
            exists join tracking
                where tracking.RecId == detail.BudgetSourceTracking
                    && tracking.Status == BudgetSourceTrackingStatus::Draft
            notexists join draftCategoryView
                where draftCategoryView.Category == tracking.Category
                    && draftCategoryView.IsDraft == NoYes::Yes
                    && draftCategoryView.PrimaryLedger == _primaryLedgerRecId;

        // Mark RelievingDetail related to a draft BudgetSourceTracking for the integrator type for deletion
        update_recordSet relievingDetail
            setting IsDeletePending = NoYes::Yes
            exists join detail
                where relievingDetail.RelievedBudgetSourceTrackingDetail == detail.RecId
                    && detail.PrimaryLedger == _primaryLedgerRecId
                exists join tracking
                    where relievingDetail.RelievingBudgetSourceTracking == tracking.RecId
                        && tracking.Status == BudgetSourceTrackingStatus::Draft
                notexists join draftCategoryView
                    where draftCategoryView.Category == tracking.Category
                        && draftCategoryView.IsDraft == NoYes::Yes
                        && draftCategoryView.PrimaryLedger == _primaryLedgerRecId;

        // Mark draft BudgetSourceTracking for the integrator type for deletion
        update_recordSet tracking
            setting IsDeletePending = NoYes::Yes
            where tracking.Status == BudgetSourceTrackingStatus::Draft
            notexists join draftCategoryView
                where draftCategoryView.Category == tracking.Category
                    && draftCategoryView.IsDraft == NoYes::Yes
                    && draftCategoryView.PrimaryLedger == _primaryLedgerRecId
            notexists join nonPrimaryLedgerDetail
                where nonPrimaryLedgerDetail.BudgetSourceTracking == tracking.RecId
                    && nonPrimaryLedgerDetail.PrimaryLedger != _primaryLedgerRecId;

        // Determine BudgetSource records to process for cleanup & mark if should also be deleted with processing
        while select forupdate source
            join RecId from tracking
                where tracking.BudgetSource == source.RecId &&
                      tracking.Status == BudgetSourceTrackingStatus::Draft
                notexists join draftCategoryView
                    where draftCategoryView.Category == tracking.Category
                        && draftCategoryView.IsDraft == NoYes::Yes
                        && draftCategoryView.PrimaryLedger == _primaryLedgerRecId
                exists join detail
                    where detail.PrimaryLedger == _primaryLedgerRecId &&
                          detail.BudgetSourceTracking == tracking.RecId
        {
            if (!budgetCheckGroup)
            {
                budgetCheckGroup = source.RecId;
            }

            source.BudgetCheckGroup = budgetCheckGroup;
            source.BudgetCheckGroupSequence = budgetCheckGroupSequence;

            select firstOnly nonDraftTracking
                where nonDraftTracking.BudgetSource == source.RecId 
                    && nonDraftTracking.Status == BudgetSourceTrackingStatus::Confirmed;

            select firstonly RecId from nonPrimaryLedgerDetail
                where nonPrimaryLedgerDetail.BudgetSourceTracking == tracking.RecId &&
                      nonPrimaryLedgerDetail.PrimaryLedger != _primaryLedgerRecId;

            select firstonly RecId from nonPrimaryLedgerResultDetail
                where nonPrimaryLedgerResultDetail.BudgetSource == source.RecId &&
                      nonPrimaryLedgerResultDetail.PrimaryLedger != _primaryLedgerRecId;

            if (!nonPrimaryLedgerDetail && !nonPrimaryLedgerResultDetail && !nonDraftTracking)
            {
                // The budget source has no tracking details or result details from a different primary ledger.
                source.IsDeletePending = NoYes::Yes;
            }

            source.update();

            budgetCheckGroupSequence++;
        }

        // Delete BudgetCheckResultErrorWarningDetail related to a draft BudgetSourceTracking via BudgetSource
        // can be deleted because they have no impact to Summary to be handled by processing.
        delete_from resultDetail
            where resultDetail.PrimaryLedger == _primaryLedgerRecId
            exists join source
                where resultDetail.BudgetSource == source.RecId
            exists join tracking
                where tracking.BudgetSource == source.RecId
                    && tracking.Status == BudgetSourceTrackingStatus::Draft
            notexists join draftCategoryView
                where draftCategoryView.Category == tracking.Category
                    && draftCategoryView.IsDraft == NoYes::Yes
                    && draftCategoryView.PrimaryLedger == _primaryLedgerRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        recIdTypes = typeName2Type(extendedtypestr(recId));

        this.initialize();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsPurchYearEndProcess</Name>
				<Source><![CDATA[
    internal boolean parmIsPurchYearEndProcess(boolean _isPurchYearEndProcess = isPurchYearEndProcess)
    {
        isPurchYearEndProcess = _isPurchYearEndProcess;

        return isPurchYearEndProcess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDoBudgetCheckAsSimulation</Name>
				<Source><![CDATA[
    public boolean parmDoBudgetCheckAsSimulation(boolean _doBudgetCheckAsSimulation = doBudgetCheckAsSimulation)
    {
        doBudgetCheckAsSimulation = _doBudgetCheckAsSimulation;

        return doBudgetCheckAsSimulation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDoBudgetCheckForConfirmation</Name>
				<Source><![CDATA[
    public boolean parmDoBudgetCheckForConfirmation(boolean _doBudgetCheckForConfirmation = doBudgetCheckForConfirmation)
    {
        if (!doBudgetCheckForConfirmation)
        {
            // Only change the budget check for confirmation if it is not already for confirmation
            doBudgetCheckForConfirmation = _doBudgetCheckForConfirmation;
        }

        return doBudgetCheckForConfirmation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDoDisplayMessagesFromBudgetCheck</Name>
				<Source><![CDATA[
    public boolean parmDoDisplayMessagesFromBudgetCheck(boolean _doDisplayMessagesFromBudgetCheck = doDisplayMessagesFromBudgetCheck)
    {
        doDisplayMessagesFromBudgetCheck = _doDisplayMessagesFromBudgetCheck;

        return doDisplayMessagesFromBudgetCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postProcessForBudgetAvailableCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs post-processing logic after the budget check including determining error and warning messages.
    /// </summary>
    /// <param name="_isProcessSuccessful">
    /// A Boolean value indicating that the budget check processing completed successfully.
    /// </param>
    protected void postProcessForBudgetAvailableCheck(boolean _isProcessSuccessful)
    {
        BudgetCheckResult defaultCheckResult;

        budgetControlResultCollection = BudgetControlResultCollection::construct();
        budgetCheckRequestsToProcess.reset();

        while (budgetCheckRequestsToProcess.moveNext())
        {
            currentCheckRequest = budgetCheckRequestsToProcess.current();

            if (_isProcessSuccessful)
            {
                // Load cached results for the BudgetSource
                this.loadCurrentBudgetResultDetails();

                // Process all budget check error and warning details for error and warning messages.
                this.determineBudgetCheckMessages(currentCheckRequest.parmBudgetSourceId());
            }
            else
            {
                this.resetCurrentMembers();
                currentSourceResult = defaultCheckResult; 

                currentErrorMessages.add("@SYS331024");
            }

            // Set results & messages on current control result
            currentControlResult.initialize(currentSourceResult, currentErrorWarningType, currentErrorWarning, currentErrorMessages, currentWarningMessages);

            // When _isProcessSuccessful = false, currentCheckRequest is reset to null in this.resetCurrentMembers();
            if (currentCheckRequest != null)
            {
                budgetControlResultCollection.addBudgetControlResult(currentCheckRequest.parmBudgetSourceId(), currentControlResult);
            }

            // Reset current member variables before next source manager post-processing is performed
            this.resetCurrentMembers();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postProcessForBudgetControlRemoval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs post-processing logic after processing for removal.
    /// </summary>
    protected void postProcessForBudgetControlRemoval()
    {
        BudgetSource sourceToRemove;
        BudgetCheckResultErrorWarningDetail resultDetailToRemove;

        sourceToRemove.skipDataMethods(true);
        resultDetailToRemove.skipDataMethods(true);

        delete_from resultDetailToRemove
                exists join sourceToRemove
                where sourceToRemove.BudgetCheckGroup == budgetCheckGroup &&
                      sourceToRemove.IsDeletePending == NoYes::Yes &&
                      resultDetailToRemove.BudgetSource ==  sourceToRemove.RecId;

        // Budget sources with Failed status may not require processing by the stored procedure depending
        // on the other requests in the processing collection. Must cleanup these records in post
        // processing in case no other processing was required.
        delete_from sourceToRemove
            where sourceToRemove.BudgetCheckGroup == budgetCheckGroup &&
                  sourceToRemove.IsDeletePending == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareBudgetSourceForRemoval</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Prepares the budget source record ID for removal processing.
    /// </summary>
    /// <param name="_budgetSourceId">
    ///    The record ID for the budget source.
    /// </param>
    protected void prepareBudgetSourceForRemoval(BudgetSourceRecId _budgetSourceId)
    {
        select firstOnly pessimisticLock currentSource
            where currentSource.RecId == _budgetSourceId;

        if (currentSource)
        {
            if (!budgetCheckGroup)
            {
                // Set the first BudgetSource record identity as the budget check group id.
                budgetCheckGroup = _budgetSourceId;
            }

            // Always reset check result, budget check group, and budget check group sequence prior to removing.
            currentSource.CheckResult = 0;
            currentSource.CheckResultErrorWarning = 0;
            currentSource.CheckResultErrorWarningType = 0;
            currentSource.BudgetCheckGroup = budgetCheckGroup;
            currentSource.BudgetCheckGroupSequence = budgetCheckGroupSequence;
            currentSource.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareBudgetSourceForReturn</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Prepares the budget source record ID for removal processing.
    /// </summary>
    /// <param name="_budgetSourceId">
    ///    The record ID for the budget source.
    /// </param>
    protected void prepareBudgetSourceForReturn(
        BudgetSourceRecId _budgetSourceId)
    {
        select firstOnly pessimisticLock currentSource
            where currentSource.RecId == _budgetSourceId;

        if (currentSource)
        {
            if (!budgetCheckGroup)
            {
                // Set the first BudgetSource record identity as the budget check group id.
                budgetCheckGroup = _budgetSourceId;
            }

            // Always reset check result, budget check group, and budget check group sequence prior to removing.
            currentSource.CheckResult = 0;
            currentSource.CheckResultErrorWarning = 0;
            currentSource.CheckResultErrorWarningType = 0;
            currentSource.BudgetCheckGroup = budgetCheckGroup;
            currentSource.BudgetCheckGroupSequence = budgetCheckGroupSequence;
            currentSource.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preProcessForBudgetAvailableCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs pre-processing logic in preparation for the budget check including validation of details to be
    /// checked, marking details for deletion and return, and tracking of relieving details and budget check details.
    /// </summary>
    protected void preProcessForBudgetAvailableCheck()
    {
        boolean isBudgetSourceValid;
        List validBudgetSources = new List(recIdTypes);
        ListEnumerator budgetSourcesToTrack;

        // Initialize budget check group sequence for the budget check group.
        budgetCheckRequestsToProcess.initializeEnumerator();

        while (budgetCheckRequestsToProcess.moveNext())
        {
            currentCheckRequest = budgetCheckRequestsToProcess.current();

            if (!budgetSourcesToRemove.in(currentCheckRequest.parmBudgetSourceId()))
            {
                // Only process budget check requests if there is no pending budget
                // removal request for the same budget source.

                if (this.validateBudgetSource())
                {
                    // Validate Budget source details
                    isBudgetSourceValid = this.validateBudgetSourceDetails();

                    // Cleanup & process return funds from previous budget check
                    if (primaryLedgersToCheckBudget.elements() > 0)
                    {
                        this.activateTracking(isBudgetSourceValid);

                        if (isBudgetSourceValid)
                        {
                            // Cache source as valid - add to list to maintain ordering for processing
                            validBudgetSources.addEnd(currentCheckRequest.parmBudgetSourceId());
                        }
                    }
                }
                else
                {
                    isBudgetSourceValid = false;

                    // Validation error exists in one of the BudgetSource in the collection.
                    // None of the BudgetSource in the collection can confirm budget.
                }

                if (!isBudgetSourceValid)
                {
                    // BudgetSource failed validation - budget check result is failed
                    currentSourceResult = BudgetCheckResult::Failed;

                    // Cache results from pre-processing
                    this.cacheCurrentBudgetResultDetails();

                    this.updateBudgetSourceForInvalidRequest();
                }

                // Reset the current member variables before next source manager validation and pending deletion preparation is performed
                this.resetCurrentMembers();

                // Increment budget check group sequence for the next check request budget source.
                budgetCheckGroupSequence++;
            }
        }

        budgetSourcesToTrack = validBudgetSources.getEnumerator();

        while (budgetSourcesToTrack.moveNext())
        {
            currentCheckRequest = budgetCheckRequestsToProcess.getBudgetControlCheckRequest(budgetSourcesToTrack.current());

            this.loadCurrentBudgetControlDetails();

            // Track simulation budget source to return simulated budget funds
            this.trackSimulatingBudgetSource();

            // Track budget returns in preparation for budget check
            this.trackBudgetReturnDetails();

            // Track relieving details in preparation for budget check
            this.trackBudgetControlDetailsToRelieve();

            // Track control details in preparation for budget check
            this.trackBudgetControlDetails();

            if (!this.areProcessingDetailsPreparedForCurrent())
            {
                if (currentControlDetails.elements() > 0)
                {
                    // Budget source is valid and has control ledger dimension that requires budget check but the amounts to check is 0.
                    // Set budget source result to Passed.
                    currentSourceResult = BudgetCheckResult::Passed;
                }
                else
                {
                    // Budget source is valid but does not have any control ledger dimension that requires budget check.
                    // Set budget source result to NoCheck.
                    currentSourceResult = BudgetCheckResult::NoCheck;
                }

                // Cache results from pre-processing
                this.cacheCurrentBudgetResultDetails();

                this.updateBudgetSourceForPreProcessResult();
            }
            else
            {
                // Track maintained carry-forward details in preparation for budget check.
                this.trackMaintainedCarryforwardDetails();
            }

            // Reset the current member variables before next source manager tracking is performed
            this.resetCurrentMembers();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preProcessForBudgetControlRemoval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs pre-processing for removal of the <c>BudgetSource</c> records designated to remove on transaction commit.
    /// </summary>
    protected void preProcessForBudgetControlRemoval()
    {
        SetEnumerator budgetSourcesToRemoveEnumerator = budgetSourcesToRemove.getEnumerator();

        while (budgetSourcesToRemoveEnumerator.moveNext())
        {
            this.prepareBudgetSourceForRemoval(budgetSourcesToRemoveEnumerator.current());
            currentTrackingUpdate = BudgetControlTrackingUpdate::newForBudgetControlRemoval(budgetSourcesToRemoveEnumerator.current());
            currentTrackingUpdate.removeTracking(true);

            if (!arePendingDeletionsPrepared)
            {
                arePendingDeletionsPrepared = currentTrackingUpdate.arePendingDeletionsPrepared();
            }

            if (!areRelievingPendingDeletionsPrepared)
            {
                areRelievingPendingDeletionsPrepared = currentTrackingUpdate.areRelievingPendingDeletionsPrepared();
            }

            // Increment budget check group sequence for the next budget source.
            budgetCheckGroupSequence++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preProcessForBudgetControlReturn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs pre-processing for return for the <c>BudgetSource</c> records designated to return remaining funds on transaction commit.
    /// </summary>
    protected void preProcessForBudgetControlReturn()
    {
        MapEnumerator budgetSourcesToReturnEnumerator = budgetSourcesToReturnRemaining.getEnumerator();
        container returnDateUser;
        BudgetSourceRecId budgetSourceIdToReturn;

        while (budgetSourcesToReturnEnumerator.moveNext())
        {
            budgetSourceIdToReturn = budgetSourcesToReturnEnumerator.currentKey();

            if (!budgetSourcesToRemove.in(budgetSourceIdToReturn))
            {
                // Only process budget return requests if there is no pending budget
                // removal request for the same budget source.

                returnDateUser = budgetSourcesToReturnEnumerator.currentValue();

                currentTrackingUpdate = BudgetControlTrackingUpdate::newForBudgetControlReturnRemaining(
                                        budgetSourceIdToReturn,
                                        conPeek(returnDateUser, 1),
                                        conPeek(returnDateUser, 2),
                                        conPeek(returnDateUser, 3));

                currentTrackingUpdate.returnRemainingFunds();

                if (currentTrackingUpdate.areReturnDetailsPrepared())
                {
                    this.prepareBudgetSourceForReturn(budgetSourceIdToReturn);
                    areReturnDetailsPrepared = true;
                }

                // Increment budget check group sequence for the next budget source.
                budgetCheckGroupSequence++;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processForBudgetControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Invokes the stored procedure for performing the budget check.
    /// </summary>
    /// <returns>
    ///    A Boolean that indicates whether the stored procedure completed successfully.
    /// </returns>
    protected boolean processForBudgetControl()
    {
        boolean isStoredProcedureSuccessful = true;

        // The stored procedure must be called in the case where pending deletions are prepared or return details or
        // relieving details are prepared regardless of whether there are control details to be checked
        if (this.areProcessingDetailsPrepared())
        {
            isStoredProcedureSuccessful = BudgetControlProcessor::invokeBudgetCheckStoredProcedure(
                budgetCheckGroup,
                areRelievingDetailsPrepared || areRelievingPendingDeletionsPrepared,
                this.logger,
                this.logController);

            if (BudgetControlRetryBudgetCheckFlight::instance().isEnabled())
            {
                this.checkForBudgetControlAndLogTelemetry();
            }
        }

        return isStoredProcedureSuccessful;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetCurrentMembers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the state of the class variables caching details about the current budget source.
    /// </summary>
    protected void resetCurrentMembers()
    {
        currentCheckRequest = null;

        currentControlDetails = new Map(recIdTypes, Types::Class);
        currentReturnDetails = new Map(recIdTypes, Types::Class);
        currentControlDetailsToRelieve = new Map(recIdTypes, Types::Class);
        currentSourceDetailsToRelieve = new Set(Types::Class);

        currentSourceResult = BudgetCheckResult::NoCheck;
        currentErrorMessages = new Set(Types::String);
        currentWarningMessages = new Set(Types::String);
        currentControlResult = BudgetControlResult::construct();
        currentErrorWarningType = 0;
        currentErrorWarning = 0;

        currentIsBudgetAvailableCheckValidated = false;

        currentSource = null;
        currentSourceModel = null;
        currentTrackingUpdate = null;
        currentIsOverrunApproved = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetProcessor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the class variables for the instance.
    /// </summary>
    protected void resetProcessor()
    {
        // Reset object by reinitializing class variables
        this.initialize();
    }

]]></Source>
			</Method>
			<Method>
				<Name>runBudgetControlProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the budget control processing for budget sources to be removed, budget sources for which to return
    /// remaining funds and budget check requests.
    /// </summary>
    /// <returns>
    /// true if processing completed; otherwise, false.
    /// </returns>
    protected boolean runBudgetControlProcessing()
    {
        boolean isSuccessful = true;

        using (var activityContext = logger.processing().budgetCheckProcessing(doBudgetCheckForConfirmation, budgetSourcesToRemove.elements(), budgetSourcesToReturnRemaining.elements(), budgetCheckRequestsToProcess.elements()))
        {
            budgetCheckGroupSequence = #FirstBudgetCheckGroupSequence;

            // Perform preprocessing for all collections requiring budget control processing as this sets
            // the sequence during processing

            // Perform preprocessing of removals from budget control in the same check group first to make available
            // all possible budget amounts targeted for removal.
            if (budgetSourcesToRemove.elements() > 0)
            {
                this.preProcessForBudgetControlRemoval();
            }

            // Perform preprocessing of new check requests second to update budget control tracking with latest relieving details
            // prior to processing return remaining requests in the same check group which could be affected
            // by those new relieving details.
            if (budgetCheckRequestsToProcess.elements() > 0)
            {
                this.preProcessForBudgetAvailableCheck();
            }

            // Perform preprocessing of return remaining requests last to have latest relieving details in place from new check requests
            // in the same check group prior to determining remaining amounts to return.
            if (budgetSourcesToReturnRemaining.elements() > 0)
            {
                this.preProcessForBudgetControlReturn();
            }

            // Perform processing
            isSuccessful = this.processForBudgetControl();

            // Perform post-processing
            if (budgetSourcesToRemove.elements() > 0)
            {
                this.postProcessForBudgetControlRemoval();
            }

            if (budgetCheckRequestsToProcess.elements() > 0)
            {
                this.postProcessForBudgetAvailableCheck(isSuccessful);
            }

            if (this.areProcessingDetailsPrepared())
            {
                // Table cache must be flushed in order to force the refresh for changes made in the stored procedure
                this.clearTableCache();
            }

            if (logController.processingHeaderRecId != 0)
            {
                activityContext.addCustomProperty(BudgetControlInstrumentationConstants::BudgetControlProcessingHeader, any2Str(logController.processingHeaderRecId));
            }
        }

        return isSuccessful;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runDraftBudgetCleanup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the cleanup of draft budget reservations.
    /// </summary>
    /// <returns>
    /// true if processing completed; otherwise, false.
    /// </returns>
    protected boolean runDraftBudgetCleanup()
    {
        boolean isSuccessful = true;
        MapEnumerator ledgersToCleanupDraftsEnumerator;
        Set integratorsToCleanup;
        SetEnumerator integratorsToCleanupEnumerator;

        if (ledgersToCleanupUntrackedDrafts.elements() > 0)
        {
            SetEnumerator untrackedDraftsEnumerator = ledgersToCleanupUntrackedDrafts.getEnumerator();
            while (untrackedDraftsEnumerator.moveNext())
            {
                // Mark drafts not in budget funds available for cleanup
                this.markUntrackedDraftsForCleanup(untrackedDraftsEnumerator.current());
            }
        }

        if (ledgersToCleanupDrafts.elements() > 0)
        {
            // There are ledgers needing to perform draft cleanup
            ledgersToCleanupDraftsEnumerator = ledgersToCleanupDrafts.getEnumerator();

            while (ledgersToCleanupDraftsEnumerator.moveNext())
            {
                integratorsToCleanup = ledgersToCleanupDraftsEnumerator.currentValue();

                if (integratorsToCleanup != null)
                {
                    integratorsToCleanupEnumerator = integratorsToCleanup.getEnumerator();

                    while (integratorsToCleanupEnumerator.moveNext())
                    {
                        // Mark drafts for specific integrator for cleanup
                        this.markDraftsForCleanupByIntegrator(
                            ledgersToCleanupDraftsEnumerator.currentKey(),
                            integratorsToCleanupEnumerator.current());
                    }
                }
                else
                {
                    // Mark all drafts for the ledger for cleanup
                    this.markDraftsForCleanupByLedger(ledgersToCleanupDraftsEnumerator.currentKey());
                }
            }
        }

        if (budgetCheckGroup)
        {
            // Must invoke the stored procedure to update tracking & summary as there are budget sources to be processed
            isSuccessful = BudgetControlProcessor::invokeBudgetCheckStoredProcedure(budgetCheckGroup, NoYes::Yes, this.logger, this.logController, NoYes::Yes);
        }

        // Table cache must be flushed in order to force the refresh for changes made in the stored procedure
        this.clearTableCache();

        return isSuccessful;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveBudgetCheckResultErrorWarningDetails</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void saveBudgetCheckResultErrorWarningDetails()
    {
        BudgetSource budgetSource;
        BudgetCheckResultErrorWarningDetail resultDetail;
        ListEnumerator resultDetailsToSave;
        str resultDetailsStrArray;
        int resultDetailsCount;
        int resultDetailsBatchCount;
        UserConnection userConnection;

        if (budgetControlResultCollection != null &&
            budgetControlResultCollection.elements() > 0)
        {
            // Must use a user connection to prevent resetting the data that occurs in the ttsbegin.
            userConnection = new UserConnection();

            try
            {
                budgetSource.setConnection(userConnection);
                resultDetail.setConnection(userConnection);

                userConnection.ttsbegin();

                // Get the max number of records that should be submitted to the proc at one time.
                resultDetailsBatchCount = BudgetControlSQLObjects::getBudgetControlSaveErrorWarnBatchCount();

                budgetControlResultCollection.initializeEnumerator();

                while (budgetControlResultCollection.moveNext())
                {
                    budgetSource = BudgetSource::find(
                                    budgetControlResultCollection.currentBudgetSourceId(),
                                    true,
                                    ConcurrencyModel::Auto,
                                    userConnection);

                    if (!budgetSource &&
                        budgetSourcesWithResultsBySource &&
                        budgetSourcesWithResultsBySource.exists(budgetControlResultCollection.currentBudgetSourceId()))
                    {
                        budgetSource = budgetSourcesWithResultsBySource.lookup(budgetControlResultCollection.currentBudgetSourceId());

                        if (budgetSource.existSourceIntegratorReference())
                        {
                            // The budget source was not committed, but the source integrator reference exists
                            // Create the budget source to save the check result error warning details
                            budgetSource.setConnection(userConnection);
                            budgetSource.insert();
                        }
                        else
                        {
                            // Clear the buffer to prevent further processing
                            budgetSource.clear();
                        }
                    }

                    if (budgetSource)
                    {
                        currentControlResult = budgetControlResultCollection.currentBudgetControlResult();

                        // Update the result, error-warning type, error-warning substatus for the budget check just completed
                        budgetSource.CheckResult = currentControlResult.budgetSourceAvailableCheckResult();
                        budgetSource.CheckResultErrorWarningType = currentControlResult.budgetControlErrorWarningType();
                        budgetSource.CheckResultErrorWarning = currentControlResult.budgetControlErrorWarning();
                        budgetSource.update();

                        // Remove previous check result error warning details for the budget source
                        resultDetail.setConnection(userConnection);
                        delete_from resultDetail
                            where resultDetail.BudgetSource == budgetSource.RecId;

                        if (budgetSource.CheckResult == BudgetCheckResult::PassedWithWarnings ||
                            budgetSource.CheckResult == BudgetCheckResult::Failed)
                        {
                            // There are result details to save from the budget check
                            resultDetailsToSave = currentControlResult.getResultDetails().getEnumerator();

                            while (resultDetailsToSave.moveNext())
                            {
                                // Update the budget source reference.
                                resultDetail = resultDetailsToSave.current();
                                resultDetail.BudgetSource = budgetSource.RecId;

                                resultDetailsStrArray += BudgetControlSQLObjects::getBudgetControlSaveErrorWarnStrArray(resultDetail);
                                resultDetailsCount++;

                                if (resultDetailsCount mod resultDetailsBatchCount == 0)
                                {
                                    // Save the result details for the current batch.
                                    BudgetControlProcessor::invokeBudgetControlSaveErrorWarnProc(resultDetailsStrArray, userConnection, logger);

                                    // Reset the str array.
                                    resultDetailsStrArray = '';
                                }
                            }
                        }
                    }
                }

                if (resultDetailsStrArray)
                {
                    // Save the final result details batch if it has not been done already
                    // in the case the batch contains less than RecordBatchCount records.
                    BudgetControlProcessor::invokeBudgetControlSaveErrorWarnProc(resultDetailsStrArray, userConnection, logger);
                }

                userConnection.ttscommit();
            }
            finally
            {
                userConnection.finalize();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackBudgetControlDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Tracks all budget control details associated with the current budget source.
    /// </summary>
    protected void trackBudgetControlDetails()
    {
        MapEnumerator controlDetailsEnumerator;
        Map primaryLedgerControlDetails;
        MapEnumerator primaryLedgerControlDetailsEnumerator;
        BudgetControlDetail controlDetail;

        if (currentControlDetails.elements() > 0)
        {
            controlDetailsEnumerator = currentControlDetails.getEnumerator();

            while (controlDetailsEnumerator.moveNext())
            {
                primaryLedgerControlDetails = controlDetailsEnumerator.currentValue();

                primaryLedgerControlDetailsEnumerator = primaryLedgerControlDetails.getEnumerator();

                while (primaryLedgerControlDetailsEnumerator.moveNext())
                {
                    controlDetail = primaryLedgerControlDetailsEnumerator.currentValue();

                    currentTrackingUpdate.trackLedgerDimension(
                        controlDetail.parmPrimaryLedgerId(),
                        controlDetail.parmBudgetControlRule().RecId,
                        controlDetail.parmBudgetGroupMember().RecId,
                        controlDetail.parmControlLedgerDimension(),
                        controlDetail.getBudgetSourceDetails());
                }
            }
        }

        if (!areTrackingDetailsPrepared)
        {
            areTrackingDetailsPrepared = currentTrackingUpdate.areTrackingDetailsPrepared();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackBudgetControlDetailsToRelieve</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Tracks all relieving budget control details associated with the current budget source.
    /// </summary>
    protected void trackBudgetControlDetailsToRelieve()
    {
        MapEnumerator controlDetailsEnumerator;
        SetEnumerator sourceDetailsToRelieveEnumerator;
        Map primaryLedgerControlDetails;
        MapEnumerator primaryLedgerControlDetailsEnumerator;
        BudgetControlDetail controlDetailToRelieve;
        SetEnumerator sourceDetailsEnumerator;
        BudgetSourceDetail sourceDetail;
        BudgetRelievingDetail relievingDetail;

        if (currentControlDetailsToRelieve.elements() > 0)
        {
            controlDetailsEnumerator = currentControlDetailsToRelieve.getEnumerator();

            while (controlDetailsEnumerator.moveNext())
            {
                primaryLedgerControlDetails = controlDetailsEnumerator.currentValue();

                primaryLedgerControlDetailsEnumerator = primaryLedgerControlDetails.getEnumerator();

                while (primaryLedgerControlDetailsEnumerator.moveNext())
                {
                    controlDetailToRelieve = primaryLedgerControlDetailsEnumerator.currentValue();

                    if (controlDetailToRelieve.getBudgetSourceDetails().elements() > 0)
                    {
                        sourceDetailsEnumerator = controlDetailToRelieve.getBudgetSourceDetails().getEnumerator();

                        while (sourceDetailsEnumerator.moveNext())
                        {
                            sourceDetail = sourceDetailsEnumerator.current();

                            if (sourceDetail is BudgetRelievingDetail)
                            {
                                relievingDetail = sourceDetail as BudgetRelievingDetail;

                                currentTrackingUpdate.relieveSourceLedgerDimensionAmount(
                                    primaryLedgersToRelieveBudget.lookup(relievingDetail.parmLegalEntityIdToRelieve()),
                                    controlDetailToRelieve.parmControlLedgerDimension(),
                                    relievingDetail);
                            }
                        }
                    }
                }
            }
        }

        if (currentSourceDetailsToRelieve.elements() > 0)
        {
            sourceDetailsToRelieveEnumerator = currentSourceDetailsToRelieve.getEnumerator();

            while (sourceDetailsToRelieveEnumerator.moveNext())
            {
                relievingDetail = sourceDetailsToRelieveEnumerator.current();

                currentTrackingUpdate.relieveSourceLedgerDimensionAmount(
                    primaryLedgersToRelieveBudget.lookup(relievingDetail.parmLegalEntityIdToRelieve()),
                    0,
                    relievingDetail);
            }
        }

        if (!areRelievingDetailsPrepared)
        {
            areRelievingDetailsPrepared = currentTrackingUpdate.areRelievingDetailsPrepared();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackBudgetReturnDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Tracks all budget return details associated with the current budget source.
    /// </summary>
    protected void trackBudgetReturnDetails()
    {
        Map                 primaryLedgerReturnDetails;
        MapEnumerator       returnDetailsEnumerator;
        MapEnumerator       primaryLedgerReturnDetailsEnumerator;
        BudgetControlDetail returnDetail;

        if (currentReturnDetails.elements() > 0)
        {
            returnDetailsEnumerator = currentReturnDetails.getEnumerator();

            while (returnDetailsEnumerator.moveNext())
            {
                primaryLedgerReturnDetails = returnDetailsEnumerator.currentValue();

                primaryLedgerReturnDetailsEnumerator = primaryLedgerReturnDetails.getEnumerator();

                while (primaryLedgerReturnDetailsEnumerator.moveNext())
                {
                    returnDetail = primaryLedgerReturnDetailsEnumerator.currentValue();

                    currentTrackingUpdate.trackReturnLedgerDimension(
                        returnDetail.parmPrimaryLedgerId(),
                        returnDetail.parmControlLedgerDimension(),
                        returnDetail.getBudgetSourceDetails());
                }
            }
        }

        if (!areReturnDetailsPrepared)
        {
            areReturnDetailsPrepared = currentTrackingUpdate.areReturnDetailsPrepared();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackMaintainedCarryforwardDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Tracks all maintained carry-forward details associated with the current budget source.
    /// </summary>
    protected void trackMaintainedCarryforwardDetails()
    {
        MapEnumerator controlDetailsEnumerator;
        Map primaryLedgerControlDetails;
        MapEnumerator primaryLedgerControlDetailsEnumerator;
        BudgetControlDetail controlDetail;
        Set primaryLedgers = new Set(Types::Int64);
        SetEnumerator primaryLedgersEnumerator;

        if (currentControlDetails.elements() > 0)
        {
            controlDetailsEnumerator = currentControlDetails.getEnumerator();

            while (controlDetailsEnumerator.moveNext())
            {
                primaryLedgerControlDetails = controlDetailsEnumerator.currentValue();

                primaryLedgerControlDetailsEnumerator = primaryLedgerControlDetails.getEnumerator();

                while (primaryLedgerControlDetailsEnumerator.moveNext())
                {
                    controlDetail = primaryLedgerControlDetailsEnumerator.currentValue();

                    primaryLedgers.add(controlDetail.parmPrimaryLedgerId());
                }
            }

            primaryLedgersEnumerator = primaryLedgers.getEnumerator();

            while (primaryLedgersEnumerator.moveNext())
            {
                currentTrackingUpdate.trackMaintainedCarryforwardDetails(primaryLedgersEnumerator.current());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackSimulatingBudgetSource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Tracks the simulating budget source that simulates budget fund reservations from another budget source.
    /// </summary>
    protected void trackSimulatingBudgetSource()
    {
        if (currentCheckRequest.parmSimulatedBudgetSourceId())
        {
            // The current budget check request simulates an existing budget source.
            // The budget fund reservations from the simulated budget source must be
            // returned and be tracked as such.
            currentTrackingUpdate.trackSimulatingBudgetSource();

            if (!areReturnDetailsPrepared)
            {
                areReturnDetailsPrepared = currentTrackingUpdate.areReturnDetailsPrepared();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ttsNotifyAbort</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs processing for budget control in case of a transaction abort.
    /// </summary>
    public void ttsNotifyAbort()
    {
        if (isProcessingNeeded)
        {
            if (!isProcessingComplete)
            {
                // Log a failure if processing did not complete as expected
                logger.processing().budgetCheckProcessingFailed();
            }

            // Set the processing state to not needed to avoid executing a budget check
            // during the save of the check result error or warning details.
            // Only set isProcessingNeeded to false instead of calling resetProcessor
            // to maintain the check result error or warning details until they are saved.
            isProcessingNeeded = false;

            // Save the BudgetCheckResultErrorWarningDetail records.
            this.saveBudgetCheckResultErrorWarningDetails();

            // Save the log records.
            logController.saveAllProcessingInfo();

            // Display the messages resulting from the budget check
            this.displayBudgetCheckMessages();

            // Reset the instance
            this.resetProcessor();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ttsNotifyCommit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs processing for budget control in case of a transaction commit.
    /// </summary>
    public void ttsNotifyCommit()
    {
        if (this.isTtsNotifyCommitValid())
        {
            // Display the messages resulting from the budget check
            this.displayBudgetCheckMessages();

            // Reset the instance
            this.resetProcessor();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTtsNotifyCommitValid</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected boolean isTtsNotifyCommitValid()
    {
        return isProcessingNeeded && (appl.ttsLevel() == 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ttsNotifyPreCommit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs processing for budget control during the transaction commit sequence.
    /// </summary>
    /// <exception cref="Exception::Error">
    /// Budget control processing failure occurred.
    /// </exception>
    public void ttsNotifyPreCommit()
    {
        boolean isSuccessful = true;

        if (this.isTtsNotifyPreCommitValid())
        {
            // Perform processing if this is the outermost tts scope
            if (ledgersToCleanupDrafts.elements() > 0 ||
                ledgersToCleanupUntrackedDrafts.elements() > 0)
            {
                isSuccessful = this.runDraftBudgetCleanup();
            }
            else if (budgetSourcesToRemove.elements() > 0 ||
                     budgetSourcesToReturnRemaining.elements() > 0 ||
                     budgetCheckRequestsToProcess.elements() > 0)
            {
                isProcessingComplete = false;

                isSuccessful = this.runBudgetControlProcessing();

                isProcessingComplete = true;
            }

            if (!isSuccessful || this.abortProcessForBudgetCheckFailure())
            {
                // Transaction will be aborted - store any logging in a temp table.
                logController.storeAllProcessingInfo();
            }

            if (!isSuccessful)
            {
                throw error("@Budget:BudgetControlProcessingFailedError");
            }
            else if (this.abortProcessForBudgetCheckFailure())
            {
                throw error("@SYS339055"); // budget control processing failed
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTtsNotifyPreCommitValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not a call to ttsNotifyPreCommit is valid at the current state.
    /// </summary>
    /// <returns>True if the call is valid; otherwise, false.</returns>
    [Hookable(false)]
    protected boolean isTtsNotifyPreCommitValid()
    {
        return isProcessingNeeded && (appl.ttsLevel() == 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBudgetSourceForInvalidRequest</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the current <c>BudgetSource</c> record with the overall budget control result of
    ///    invalid request.
    /// </summary>
    private void updateBudgetSourceForInvalidRequest()
    {
        BudgetSource budgetSource;

        if (currentCheckRequest.parmBudgetSourceId() &&
            currentErrorWarningType == BudgetControlErrorWarningType::InvalidRequest)
        {
            select firstonly forupdate budgetSource
                where budgetSource.RecId == currentCheckRequest.parmBudgetSourceId();

            if (budgetSource.RecId)
            {
                // Budget source exists & update with results
                budgetSource.CheckResult = currentSourceResult;
                budgetSource.CheckResultErrorWarningType = currentErrorWarningType;
                budgetSource.CheckResultErrorWarning = currentErrorWarning;

                if (budgetSource.validateWrite())
                {
                    budgetSource.write();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBudgetSourceForPreProcessResult</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the current <c>BudgetSource</c> record with the overall budget control result
    ///    determined by pre-processing.
    /// </summary>
    private void updateBudgetSourceForPreProcessResult()
    {
        BudgetSourceRecId localBudgetSourceId;
        BudgetSource budgetSource;
        BudgetCheckResultErrorWarningDetail resultDetailToRemove;

        localBudgetSourceId = currentCheckRequest.parmBudgetSourceId();

        if (localBudgetSourceId)
        {
            budgetSource = BudgetSource::find(localBudgetSourceId, true);

            if (budgetSource)
            {
                if (currentSourceResult == BudgetCheckResult::NoCheck ||
                    currentSourceResult == BudgetCheckResult::Passed)
                {
                    // Remove any old budget check error or warning details.
                    // Keep the BudgetSource record because it might be referenced by the integrations.
                    resultDetailToRemove.skipDataMethods(true);
                    resultDetailToRemove.skipDeleteActions(true);

                    delete_from resultDetailToRemove
                        where resultDetailToRemove.BudgetSource == localBudgetSourceId;
                }

                // Budget source is valid but do not require invoking budget available check processing.
                budgetSource.BudgetCheckGroup = 0;
                budgetSource.BudgetCheckGroupSequence = 0;
                budgetSource.CheckResult = currentSourceResult;
                budgetSource.CheckResultErrorWarningType = currentErrorWarningType;
                budgetSource.CheckResultErrorWarning = currentErrorWarning;

                if (budgetSource.validateWrite())
                {
                    budgetSource.write();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetCheckDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the budget check details input from the <c>BudgetControlCheckRequest</c> class instance.
    /// </summary>
    /// <returns>
    ///    true if all budget check details are valid; otherwise, false.
    /// </returns>
    protected boolean validateBudgetCheckDetails()
    {
        boolean isValid = true;

        SetEnumerator localBudgetCheckDetailsEnumerator;
        BudgetSourceDetail budgetSourceDetail;
        Set localBudgetCheckDetails = currentCheckRequest.parmLedgerDimensionDetails();

        // Map used to calculate budget currency amounts per legal entity + source ledger dimension + transaction currency
        // Key: String (source legal entity Id, source ledger dimension Id)
        // Value: Map
        //          Key: transaction currency code
        //          Value: transaction currency amount
        Map localBudgetSourceLedgerDimensionTransCurrencyTotals = new Map(Types::String, Types::Class);

        if (localBudgetCheckDetails.elements() > 0)
        {
            localBudgetCheckDetailsEnumerator = localBudgetCheckDetails.getEnumerator();

            while (localBudgetCheckDetailsEnumerator.moveNext())
            {
                budgetSourceDetail = localBudgetCheckDetailsEnumerator.current();

                if (budgetSourceDetail.parmLedgerDimension())
                {
                    // The source detail includes a ledger dimension value - continue validation & processing
                    if (validatedLegalEntities.exists(budgetSourceDetail.parmLegalEntityId()))
                    {
                        isValid = validatedLegalEntities.lookup(budgetSourceDetail.parmLegalEntityId());
                    }
                    else
                    {
                        isValid = this.validateLegalEntityToCheckBudget(budgetSourceDetail.parmLegalEntityId());
                        validatedLegalEntities.insert(budgetSourceDetail.parmLegalEntityId(), isValid);
                    }

                    if (isValid)
                    {
                        if (primaryLedgersToCheckBudget.exists(budgetSourceDetail.parmLegalEntityId()))
                        {
                            isValid = this.validateBudgetSourceDetail(budgetSourceDetail);

                            if (isValid)
                            {
                                this.addCheckDetailToTransCurrencyTotal(localBudgetSourceLedgerDimensionTransCurrencyTotals, budgetSourceDetail);
                            }
                            else
                            {
                                // Budget check detail is not valid.
                                break;
                            }
                        }
                    }
                }
            }

            if (isValid)
            {
                this.addBudgetControlDetailsToProcessCheck(localBudgetSourceLedgerDimensionTransCurrencyTotals);
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetModel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the budget model ID input from the <c>BudgetControlCheckRequest</c> class instance.
    /// </summary>
    /// <returns>
    ///    true if the budget model ID is not specified or the budget model ID corresponds to an existing
    ///    <c>BudgetModel</c> record; otherwise, false.
    /// </returns>
    protected boolean validateBudgetModel()
    {
        boolean isValid = true;

        if (currentCheckRequest.parmBudgetModelId() != '')
        {
            changecompany(currentCheckRequest.parmBudgetModelDataAreaId())
            {
                currentSourceModel = BudgetModel::find(
                    HeadingSub::Heading,
                    currentCheckRequest.parmBudgetModelId(),
                    currentCheckRequest.parmBudgetModelId());
            }

            if (currentSourceModel.RecId == 0)
            {
                // Model does not exist
                this.addBudgetSourceError(
                    strfmt("@SYS128619", currentCheckRequest.parmBudgetModelId()),
                    BudgetControlErrorWarningType::InvalidRequest,
                    BudgetControlErrorWarning::BudgetModelInvalid);

                isValid = false;
            }
            else
            {
                sourceModelsBySource.insert(
                    currentCheckRequest.parmBudgetSourceId(),
                    currentSourceModel);
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetRelievingDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates budget relieving details.
    /// </summary>
    /// <returns>
    ///    true if all budget relieving details are valid; otherwise, false.
    /// </returns>
    protected boolean validateBudgetRelievingDetails()
    {
        SetEnumerator localBudgetRelievingDetailsEnumerator;
        BudgetRelievingDetail budgetRelievingDetail;
        boolean isValid = true;
        boolean isCurrencyValidated;
        Map legalEntityValidatedCurrencies;
        boolean isBudgetControlEnabledForPrimaryLedgerToCheckBudget;
        boolean isBudgetControlEnabledForPrimaryLedgerToRelieveBudget;
        boolean isBudgetRelievingRequired;
        Set localBudgetRelievingDetails = currentCheckRequest.parmRelievingLedgerDimensionDetails();
        Set validatedBudgetSourcesToRelieve = new Set(recIdTypes);

        // Key: String (source legal entity Id, source ledger dimension Id, relieving budget source Id, relieving legal entity Id, relieving source ledger dimension Id)
        // Value: Map
        //          Key: budget check transaction currency code
        //          Value: summarized budget check transaction currency amount
        Map relievingTransCurrencyTotalsForBudgetCheck;

        // Key: String (source legal entity Id, source ledger dimension Id, relieving budget source Id, relieving legal entity Id, relieving source ledger dimension Id)
        // Value: Map
        //          Key: budget relieving transaction currency code
        //          Value: summarized budget relieving transaction currency amount
        Map relievingTransCurrencyTotalsForRelieving;

        // Key: String (source legal entity Id, source ledger dimension Id)
        // Value: Map
        //          Key: transaction currency code
        //          Value: transaction currency amount
        // Used to calculate budget currency amounts per legal entity + source ledger dimension + transaction currency
        Map budgetCheckTransCurrencyTotals;

        if (localBudgetRelievingDetails.elements() > 0)
        {
            relievingTransCurrencyTotalsForBudgetCheck = new Map(Types::String, Types::Class);
            relievingTransCurrencyTotalsForRelieving = new Map(Types::String, Types::Class);
            budgetCheckTransCurrencyTotals = new Map(Types::String, Types::Class);

            localBudgetRelievingDetailsEnumerator = localBudgetRelievingDetails.getEnumerator();

            while (localBudgetRelievingDetailsEnumerator.moveNext())
            {
                isBudgetControlEnabledForPrimaryLedgerToCheckBudget = false;
                isBudgetControlEnabledForPrimaryLedgerToRelieveBudget = false;
                isBudgetRelievingRequired = false;

                budgetRelievingDetail = localBudgetRelievingDetailsEnumerator.current();

                if (budgetRelievingDetail.parmLedgerDimension())
                {
                    if (validatedLegalEntities.exists(budgetRelievingDetail.parmLegalEntityId()))
                    {
                        isValid = validatedLegalEntities.lookup(budgetRelievingDetail.parmLegalEntityId());
                    }
                    else
                    {
                        // Validate the legal entity to check budget.
                        isValid = this.validateLegalEntityToCheckBudget(budgetRelievingDetail.parmLegalEntityId());
                        validatedLegalEntities.insert(budgetRelievingDetail.parmLegalEntityId(), isValid);
                    }

                    if (isValid)
                    {
                        if (validatedLegalEntities.exists(budgetRelievingDetail.parmLegalEntityIdToRelieve()))
                        {
                            // The legal entity to relieve budget is valid.
                            // But it might not have been added to the legal entity to relieve budget collection
                            // It could have been validated when we validate the legal entity to check budget.
                            if (!primaryLedgersToRelieveBudget.exists(budgetRelievingDetail.parmLegalEntityIdToRelieve()) &&
                                primaryLedgersToCheckBudget.exists(budgetRelievingDetail.parmLegalEntityIdToRelieve()))
                            {
                                primaryLedgersToRelieveBudget.insert(
                                    budgetRelievingDetail.parmLegalEntityIdToRelieve(),
                                    primaryLedgersToCheckBudget.lookup(budgetRelievingDetail.parmLegalEntityIdToRelieve()));
                            }
                        }
                        else
                        {
                            // Validate the legal entity to relieve budget.
                            isValid = this.validateLegalEntityToRelieveBudget(budgetRelievingDetail.parmLegalEntityIdToRelieve());
                            validatedLegalEntities.insert(budgetRelievingDetail.parmLegalEntityIdToRelieve(), isValid);
                        }
                    }

                    if (isValid)
                    {
                        if (primaryLedgersToCheckBudget.exists(budgetRelievingDetail.parmLegalEntityId()))
                        {
                            isBudgetControlEnabledForPrimaryLedgerToCheckBudget = true;
                            isValid = this.validateBudgetSourceDetail(budgetRelievingDetail);
                        }
                    }

                    if (isValid && isBudgetControlEnabledForPrimaryLedgerToCheckBudget)
                    {
                        if (primaryLedgersToRelieveBudget.exists(budgetRelievingDetail.parmLegalEntityIdToRelieve()))
                        {
                            // Further validation on relieving detail is required because budget control is enabled for the relieving detail's primary ledger.
                            isBudgetControlEnabledForPrimaryLedgerToRelieveBudget = true;
                            isBudgetRelievingRequired = true;

                            // Validate the budget date is in open fiscal period for the relieving legal entity primary ledger.
                            isValid = this.validateDateForOpenFiscalPeriod(
                                        budgetRelievingDetail.parmLegalEntityIdToRelieve(),
                                        currentCheckRequest.parmBudgetDate());

                            // Validate budget source to relieve.
                            if (!validatedBudgetSourcesToRelieve.in(budgetRelievingDetail.parmBudgetSourceIdToRelieve()))
                            {
                                isValid = isValid && this.validateBudgetSourceToRelieve(budgetRelievingDetail.parmBudgetSourceIdToRelieve());
                                validatedBudgetSourcesToRelieve.add(budgetRelievingDetail.parmBudgetSourceIdToRelieve());
                            }

                            if (isValid && currentWarningMessages.elements() > 0)
                            {
                                // There are warnings on relieving budget source.  Only budget funds check would be required.
                                isBudgetRelievingRequired = false;
                            }
                            else if (isValid)
                            {
                                if (validatedCurrencies.exists(budgetRelievingDetail.parmLegalEntityIdToRelieve()))
                                {
                                    legalEntityValidatedCurrencies = validatedCurrencies.lookup(budgetRelievingDetail.parmLegalEntityIdToRelieve());

                                    if (legalEntityValidatedCurrencies.exists(budgetRelievingDetail.parmCurrencyToRelieve()))
                                    {
                                        isCurrencyValidated = true;
                                        isValid = legalEntityValidatedCurrencies.lookup(budgetRelievingDetail.parmCurrencyToRelieve());
                                    }
                                }
                                else
                                {
                                    legalEntityValidatedCurrencies = new Map(typeName2Type(extendedtypestr(CurrencyCode)), Types::Enum);
                                }

                                if (!isCurrencyValidated)
                                {
                                    isValid = this.validateCurrency(
                                                primaryLedgersToCheckBudget.lookup(budgetRelievingDetail.parmLegalEntityIdToRelieve()),
                                                budgetRelievingDetail.parmCurrencyToRelieve());

                                    legalEntityValidatedCurrencies.insert(budgetRelievingDetail.parmCurrencyToRelieve(), isValid);
                                    validatedCurrencies.insert(budgetRelievingDetail.parmLegalEntityIdToRelieve(), legalEntityValidatedCurrencies);
                                }
                            }
                        }
                    }

                    if (isValid)
                    {
                        if (isBudgetControlEnabledForPrimaryLedgerToCheckBudget)
                        {
                            if (isBudgetControlEnabledForPrimaryLedgerToRelieveBudget &&
                                isBudgetRelievingRequired)
                            {
                                this.addRelievingDetailToTransCurrencyTotal(
                                    relievingTransCurrencyTotalsForBudgetCheck,
                                    relievingTransCurrencyTotalsForRelieving,
                                    budgetRelievingDetail);
                            }
                            else
                            {
                                this.addCheckDetailToTransCurrencyTotal(
                                    budgetCheckTransCurrencyTotals,
                                    budgetRelievingDetail);
                            }
                        }
                    }
                    else
                    {
                        // Budget relieving detail is not valid.
                        break;
                    }
                }
            }

            if (isValid)
            {
                // Create budget control details for the relieving details that only require budget check but not relieving budget.
                this.addBudgetControlDetailsToProcessCheck(budgetCheckTransCurrencyTotals);

                // Create budget control details for the relieving details that require both budget check and relieving budget.
                this.addBudgetControlDetailsToProcessRelief(
                    relievingTransCurrencyTotalsForBudgetCheck,
                    relievingTransCurrencyTotalsForRelieving);
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetReturnDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the budget return details input from the <c>BudgetControlCheckRequest</c> class instance.
    /// </summary>
    /// <returns>
    ///    true if all budget return details are valid; otherwise, false.
    /// </returns>
    protected boolean validateBudgetReturnDetails()
    {
        boolean isValid = true;

        SetEnumerator localBudgetReturnDetailsEnumerator;
        BudgetSourceDetail budgetSourceDetail;
        Set localBudgetReturnDetails = currentCheckRequest.parmReturnLedgerDimensionDetails();

        // Map used to calculate budget currency amounts per legal entity + source ledger dimension + transaction currency
        // Key: String (source legal entity Id, source ledger dimension Id)
        // Value: Map
        //          Key: transaction currency code
        //          Value: transaction currency amount
        Map localBudgetSourceLedgerDimensionTransCurrencyTotals = new Map(Types::String, Types::Class);

        if (localBudgetReturnDetails.elements() > 0)
        {
            localBudgetReturnDetailsEnumerator = localBudgetReturnDetails.getEnumerator();

            while (localBudgetReturnDetailsEnumerator.moveNext())
            {
                budgetSourceDetail = localBudgetReturnDetailsEnumerator.current();

                if (validatedLegalEntities.exists(budgetSourceDetail.parmLegalEntityId()))
                {
                    isValid = validatedLegalEntities.lookup(budgetSourceDetail.parmLegalEntityId());
                }
                else
                {
                    isValid = this.validateLegalEntityToCheckBudget(budgetSourceDetail.parmLegalEntityId());
                    validatedLegalEntities.insert(budgetSourceDetail.parmLegalEntityId(), isValid);
                }

                if (isValid)
                {
                    if (primaryLedgersToCheckBudget.exists(budgetSourceDetail.parmLegalEntityId()))
                    {
                        isValid = this.validateBudgetSourceDetail(budgetSourceDetail);

                        if (isValid)
                        {
                            this.addCheckDetailToTransCurrencyTotal(localBudgetSourceLedgerDimensionTransCurrencyTotals, budgetSourceDetail);
                        }
                        else
                        {
                            // Budget return detail is not valid.
                            break;
                        }
                    }
                }
            }

            if (isValid)
            {
                this.addBudgetReturnDetailsToProcessCheck(localBudgetSourceLedgerDimensionTransCurrencyTotals);
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetSource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the budget source record ID specified by an instance of the <c>BudgetControlCheckRequest</c>
    ///    class instance.
    /// </summary>
    /// <returns>
    ///    true if the record ID corresponds to an existing <c>BudgetSource</c> record; otherwise, false.
    /// </returns>
    protected boolean validateBudgetSource()
    {
        boolean isValid = true;

        // BudgetSource exists
        select firstOnly pessimisticLock currentSource
            where currentSource.RecId == currentCheckRequest.parmBudgetSourceId();

        if (currentSource.RecId == 0)
        {
            // BudgetSource does not exist
            this.addBudgetSourceError(
                strfmt("@SYS128626", tablestr(BudgetSource)),
                BudgetControlErrorWarningType::InvalidRequest,
                BudgetControlErrorWarning::BudgetSourceInvalid);

            isValid = false;
        }
        else
        {
            isOverrunApprovedBySource.insert(currentCheckRequest.parmBudgetSourceId(), currentSource.IsOverrunApproved);

            if (!budgetCheckGroup)
            {
                // Set the first BudgetSource record identity as the budget check group id.
                budgetCheckGroup = currentCheckRequest.parmBudgetSourceId();
            }

            // Always reset check result, budget check group, and budget check group sequence prior to checking budget.
            currentSource.CheckResult = 0;
            currentSource.CheckResultErrorWarning = 0;
            currentSource.CheckResultErrorWarningType = 0;
            currentSource.BudgetCheckGroup = budgetCheckGroup;
            currentSource.BudgetCheckGroupSequence = budgetCheckGroupSequence;
            currentSource.update();
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetSourceDetail</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the budget source ledger dimension detail.
    /// </summary>
    /// <param name="_budgetSourceDetail">
    ///    The budget source detail.
    /// </param>
    /// <returns>
    ///    true if the budget source ledger dimension detail is valid; otherwise, false.
    /// </returns>
    protected boolean validateBudgetSourceDetail(BudgetSourceDetail _budgetSourceDetail)
    {
        boolean isValid = true;
        str localValidationBudgetSourceDetailDateKey;
        boolean isCurrencyValidated;
        Map legalEntityValidatedCurrencies;

        isValid = this.validateDateForOpenFiscalPeriod(_budgetSourceDetail.parmLegalEntityId(), currentCheckRequest.parmBudgetDate());
        isValid = isValid && this.validateForBudgetAvailableCheck();

        if (isValid)
        {
            if (validatedCurrencies.exists(_budgetSourceDetail.parmLegalEntityId()))
            {
                legalEntityValidatedCurrencies = validatedCurrencies.lookup(_budgetSourceDetail.parmLegalEntityId());

                if (legalEntityValidatedCurrencies.exists(_budgetSourceDetail.parmCurrency()))
                {
                    isValid = legalEntityValidatedCurrencies.lookup(_budgetSourceDetail.parmCurrency());
                    isCurrencyValidated = true;
                }
            }
            else
            {
                legalEntityValidatedCurrencies = new Map(typeName2Type(extendedtypestr(CurrencyCode)), Types::Enum);
            }

            if (!isCurrencyValidated)
            {
                isValid = this.validateCurrency(
                            primaryLedgersToCheckBudget.lookup(_budgetSourceDetail.parmLegalEntityId()),
                            _budgetSourceDetail.parmCurrency());

                legalEntityValidatedCurrencies.insert(_budgetSourceDetail.parmCurrency(), isValid);
                validatedCurrencies.insert(_budgetSourceDetail.parmLegalEntityId(), legalEntityValidatedCurrencies);
            }
        }

        if (isValid)
        {
            // Cache for validation must include legal entity, ledger dimension and date
            localValidationBudgetSourceDetailDateKey = strfmt('%1,%2,%3',
                                            _budgetSourceDetail.parmLegalEntityId(),
                                            _budgetSourceDetail.parmLedgerDimension(),
                                            currentCheckRequest.parmBudgetDate());

            // Validate budget source budget check ledger dimension.
            if (!validatedSourceLedgerDimensionDates.exists(localValidationBudgetSourceDetailDateKey) ||
                (validatedSourceLedgerDimensionDates.exists(localValidationBudgetSourceDetailDateKey) &&
                 validatedSourceLedgerDimensionDates.lookup(localValidationBudgetSourceDetailDateKey) == false))
            {
                // The legal entity, source ledger dimension & date combination has not been validated
                // Or it has been validated as failed pass to validate to get correct error-warning result & message for failure
                isValid = this.validateBudgetSourceLedgerDimension(
                            _budgetSourceDetail.parmLegalEntityId(),
                            _budgetSourceDetail.parmLedgerDimension(),
                            (_budgetSourceDetail is BudgetReturnDetail));

                if (!(_budgetSourceDetail is BudgetReturnDetail))
                {
                    // The source ledger dimension validation for the budget return detail is not complete
                    // and the result should not be cached.
                    validatedSourceLedgerDimensionDates.insert(localValidationBudgetSourceDetailDateKey, isValid);
                }
            }
            else
            {
                // The legal entity, source ledger dimension & date combination has been validated as passed
                isValid = validatedSourceLedgerDimensionDates.lookup(localValidationBudgetSourceDetailDateKey);
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetSourceDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates all budget source details input from the <c>BudgetControlCheckRequest</c> class instance,
    ///    including budget check details and budget relieving details.
    /// </summary>
    /// <returns>
    ///    true if all budget source details are valid; otherwise, false.
    /// </returns>
    protected boolean validateBudgetSourceDetails()
    {
        boolean isValid = true;

        isValid = isValid && this.validateBudgetCheckDetails();
        isValid = isValid && this.validateBudgetReturnDetails();
        isValid = isValid && this.validateBudgetRelievingDetails();

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetSourceLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates a budget source ledger dimension.
    /// </summary>
    /// <param name="_legalEntityId">
    ///    The legal entity associated with the source ledger dimension.
    /// </param>
    /// <param name="_sourceLedgerDimensionId">
    ///    The source ledger dimension record ID.
    /// </param>
    /// <param name="_isReturn">
    ///    Determines if the source ledger dimension is associated with a return of budget funds.
    /// </param>
    /// <returns>
    ///    true if the source ledger dimension is valid.
    /// </returns>
    protected boolean validateBudgetSourceLedgerDimension(
        LegalEntityRecId _legalEntityId,
        LedgerDimensionBase _sourceLedgerDimensionId,
        boolean _isReturn)
    {
        LedgerRecId primaryLedgerId = primaryLedgersToCheckBudget.lookup(_legalEntityId);
        BudgetControlConfiguration configuration = primaryLedgerConfigurations.lookup(primaryLedgerId);
        dataAreaId dataAreaId = dataAreas.lookup(_legalEntityId);
        BudgetControlRule controlRule;
        BudgetGroup budgetGroup;
        BudgetGroupMember topGroupMember;
        LedgerDimensionBudgetControl controlLedgerDimension;
        BudgetCycle cycle;
        BudgetModel cycleModel;
        BudgetControlBudgetCycle controlBudgetCycle;
        str sourceLedgerDimensionKey;
        str controlRuleDateKey;
        boolean isValid = true;
        Map controlLedgerDimensionGroup;

        controlRule = BudgetControlLedgerDimensionHelper::findBudgetControlRuleByLedgerDimension(
                        primaryLedgerId,
                        _sourceLedgerDimensionId);

        if (controlRule.RecId != 0)
        {
            sourceLedgerDimensionKey = this.getBudgetSourceDetailKey(
                                        _legalEntityId,
                                        _sourceLedgerDimensionId);

            // Budget control rule found, get budget control ledger dimension
            controlLedgerDimension = BudgetControlLedgerDimensionHelper::findBudgetControlLedgerDimension(
                                        primaryLedgerId,
                                        _sourceLedgerDimensionId);

            // Budget control ledger dimension may not be found for the budget control rule - no error, just a no check situation
            if (controlLedgerDimension != 0)
            {
                // Save the budget control rule to budget control ledger dimension result. The find will create the record if it does not exist.
                BudgetControlLedgerDimensionHelper::findBudgetControlRuleLedgerDimension(primaryLedgerId, _sourceLedgerDimensionId);

                // Budget control configured for ledger dimension
                controlRuleDateKey = strFmt('%1,%2', controlRule.RecId, currentCheckRequest.parmBudgetDate());

                // Validate timespan from control rule if this is not for a return of budget funds.
                if (!_isReturn && !controlRuleDateBudgetModels.exists(controlRuleDateKey))
                {
                    if (!controlRule.BudgetCycleTimeSpan ||
                        !BudgetCycleTimeSpan::exist(controlRule.BudgetCycleTimeSpan))
                    {
                        // Rule does not have a valid timespan
                        this.addBudgetSourceError(
                            strfmt("@SYS317159", this.getDimensionDisplayValue(_sourceLedgerDimensionId)),
                            BudgetControlErrorWarningType::InvalidRequest,
                            BudgetControlErrorWarning::BudgetCycleInvalid);

                        isValid = false;
                    }
                    else
                    {
                        // Validate date for timespan
                        cycle = BudgetCycle::findBudgetCycleByDate(controlRule.BudgetCycleTimeSpan, currentCheckRequest.parmBudgetDate());

                        if (!cycle)
                        {
                            // Budget date not in a cycle for the timespan
                            this.addBudgetSourceError(
                                "@SYS317161",
                                BudgetControlErrorWarningType::InvalidRequest,
                                BudgetControlErrorWarning::BudgetCycleInvalid);

                            isValid = false;
                        }
                        else
                        {
                            if (curext() != dataAreaId)
                            {
                                changecompany(dataAreaId)
                                {
                                    // Validate the budget model associated with the budget cycle
                                    select firstonly RecId from controlBudgetCycle
                                        where controlBudgetCycle.BudgetControlConfiguration == configuration.RecId &&
                                              controlBudgetCycle.BudgetCycle == cycle.RecId
                                        join cycleModel
                                            where cycleModel.ModelId == controlBudgetCycle.BudgetModelId &&
                                                  cycleModel.SubModelId == controlBudgetCycle.BudgetModelSubModelId &&
                                                  cycleModel.Type == controlBudgetCycle.BudgetModelType &&
                                                  cycleModel.DataAreaId == controlBudgetCycle.BudgetModelDataAreaId;
                                }
                            }
                            else
                            {
                                // Validate the budget model associated with the budget cycle
                                select firstonly RecId from controlBudgetCycle
                                    where controlBudgetCycle.BudgetControlConfiguration == configuration.RecId &&
                                          controlBudgetCycle.BudgetCycle == cycle.RecId
                                    join cycleModel
                                        where cycleModel.ModelId == controlBudgetCycle.BudgetModelId &&
                                              cycleModel.SubModelId == controlBudgetCycle.BudgetModelSubModelId &&
                                              cycleModel.Type == controlBudgetCycle.BudgetModelType &&
                                              cycleModel.DataAreaId == controlBudgetCycle.BudgetModelDataAreaId;
                            }

                            if (cycleModel == null)
                            {
                                // Budget cycle doesn't have a valid budget model
                                this.addBudgetSourceError(
                                    strfmt("@SYS317160",
                                        this.getDimensionDisplayValue(_sourceLedgerDimensionId),
                                        currentCheckRequest.parmBudgetDate()),
                                    BudgetControlErrorWarningType::InvalidRequest,
                                    BudgetControlErrorWarning::BudgetCycleInvalid);

                                isValid = false;
                            }
                            else
                            {
                                controlRuleDateBudgetModels.insert(controlRuleDateKey, cycleModel);
                            }
                        }
                    }
                }

                if (isValid)
                {
                    if (!_isReturn)
                    {
                        // Determine if control ledger dimension is in a budget group
                        if (controlGroups.exists(primaryLedgerId))
                        {
                            controlLedgerDimensionGroup = controlGroups.lookup(primaryLedgerId);
                        }
                        else
                        {
                            controlLedgerDimensionGroup = new Map(recIdTypes, Types::Record);
                        }

                        if (!controlLedgerDimensionGroup.exists(controlLedgerDimension))
                        {
                            // Group for control ledger dimension hasn't yet been cached - find it
                            budgetGroup = BudgetControlLedgerDimensionHelper::findBudgetGroupByMemberLedgerDimension(
                                            primaryLedgerId,
                                            controlLedgerDimension);

                            controlLedgerDimensionGroup.insert(controlLedgerDimension, budgetGroup);
                            controlGroups.insert(primaryLedgerId, controlLedgerDimensionGroup);

                            if (budgetGroup)
                            {
                                // Budget group was found, get top group member & cache record & Name
                                topGroupMember = BudgetGroupMember::findTopBudgetGroupMember(budgetGroup.RecId);
                                topGroupMembers.insert(budgetGroup.RecId, topGroupMember);
                                topGroupMemberNames.insert(topGroupMember.RecId, topGroupMember.Name);
                            }
                        }
                    }

                    // Cache control ledger dimension per legal entity and source ledger dimension combination.
                    controlLedgerDimensions.insert(sourceLedgerDimensionKey, controlLedgerDimension);

                    // Cache control rule per legal entity and source ledger dimension combination.
                    controlRules.insert(sourceLedgerDimensionKey, controlRule);
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetSourceToRelieve</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the budget source whose ledger dimension budget funds are to be relieved.
    /// </summary>
    /// <param name="_budgetSourceIdToRelieve">
    ///    The ID of the budget source record.
    /// </param>
    /// <returns>
    ///    true if the budget source is valid; otherwise, false.
    /// </returns>
    protected boolean validateBudgetSourceToRelieve(BudgetSourceRecId _budgetSourceIdToRelieve)
    {
        BudgetSource sourceToRelieve = BudgetSource::find(_budgetSourceIdToRelieve, false);
        BudgetSourceTracking sourceTrackingToRelieve;
        boolean isValid = true;

        if (sourceToRelieve.RecId != 0)
        {
            // Source found, get last source tracking record
            sourceTrackingToRelieve = BudgetSourceTracking::findByBudgetSource(_budgetSourceIdToRelieve, false);

            if (sourceTrackingToRelieve.RecId != 0)
            {
                // Validate category of current budget source & last category tracked for source to be relieved
                isValid = this.validateRelievingCategories(sourceTrackingToRelieve.Category);
            }
        }
        else
        {
            // Relieving budget source does not exist - add warning message
            // but don't set error-warning type as it will prevent processing of the budget check
            currentWarningMessages.add(strfmt("@SYS132627", tablestr(BudgetSource)));
            currentErrorWarning = BudgetControlErrorWarning::RelievingBudgetSourceInvalid;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the currency specified.
    /// </summary>
    /// <param name="_primaryLedgerId">
    ///    The record ID for the primary ledger.
    /// </param>
    /// <param name="_currency">
    ///    The currency to validate.
    /// </param>
    /// <returns>
    ///    true if the currency is valid for converting to the accounting currency of the ledger for budget; otherwise false.
    /// </returns>
    protected boolean validateCurrency(
        LedgerRecId _primaryLedgerId,
        CurrencyCode _currency)
    {
        boolean isValid = true;
        ExchRate validationRate;
        ExchangeRateHelper rateValidationHelper;
        CurrencyExchangeHelper currencyHelper;
        ExchangeRateTypeRecId exchangeRateTypeRecId;

        if (Currency::exist(_currency) == false)
        {
            // Currency does not exist
            this.addBudgetSourceError(
                strfmt("@SYS128621", _currency),
                BudgetControlErrorWarningType::InvalidRequest,
                BudgetControlErrorWarning::CurrencyInvalid);

            isValid = false;
        }
        else
        {
            exchangeRateTypeRecId = primaryLedgerBudgetRateTypes.lookup(_primaryLedgerId);
            rateValidationHelper = ExchangeRateHelper::newExchangeDate(_primaryLedgerId, _currency, currentCheckRequest.parmBudgetDate());
            rateValidationHelper.parmExchangeRateTypeRecId(exchangeRateTypeRecId);

            // Set error type to None to prevent exceptions & messages from automatically going to infolog
            rateValidationHelper.parmErrorType(AifErrorType::None);

            // Get the cross rate to determine if exchange rates exist for the ledger, rate type, currency & date
            validationRate = rateValidationHelper.getCrossRate();

            if (validationRate == 0)
            {
                // One or more exchange rates needed to convert from _currency to accounting currency do not exist for rate type
                this.addBudgetSourceError(
                    strfmt("@SYS321719",
                        ExchangeRateType::find(exchangeRateTypeRecId).Name,
                        _currency,
                        primaryLedgerCurrencies.lookup(_primaryLedgerId),
                        date2StrUsr(currentCheckRequest.parmBudgetDate(), DateFlags::FormatAll)),
                    BudgetControlErrorWarningType::InvalidRequest,
                    BudgetControlErrorWarning::CurrencyInvalid);

                isValid = false;
            }
            else
            {
                // Instantiate currency exchange helper
                currencyHelper = CurrencyExchangeHelper::newExchangeDate(_primaryLedgerId, currentCheckRequest.parmBudgetDate());
                currencyHelper.parmExchangeRateTypeRecId(exchangeRateTypeRecId);
            }
        }

        if (isValid)
        {
            validCurrencyHelpers.insert(_primaryLedgerId, currencyHelper);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the date input from the <c>BudgetControlCheckRequest</c> class.
    /// </summary>
    /// <returns>
    ///    true if the date is a valid date; otherwise, false.
    /// </returns>
    protected boolean validateDate()
    {
        boolean isValid = true;

        if (currentCheckRequest.parmBudgetDate() == dateNull())
        {
            // Budget date not a valid date
            this.addBudgetSourceError(
                "@SYS106613",
                BudgetControlErrorWarningType::InvalidRequest,
                BudgetControlErrorWarning::DateInvalid);

            isValid = false;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDateForOpenFiscalPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the specified date is in an open fiscal period for the ledger of the specified legal entity.
    /// </summary>
    /// <param name="_legalEntityId">
    /// The legal entity for which to validate the date.
    /// </param>
    /// <param name="_budgetDate">
    /// The date to validate.
    /// </param>
    /// <returns>
    /// true if the date is valid for the legal entity; otherwise, false.
    /// </returns>
    protected boolean validateDateForOpenFiscalPeriod(LegalEntityRecId _legalEntityId, Date _budgetDate)
    {
        boolean isValid = true;
        DataAreaId localLegalEntityDataArea;
        FiscalCalendarRecId localFiscalCalendarRecId;
        str legalEntityBudgetDateKey = strfmt('%1,%2', _legalEntityId, _budgetDate);

        if (validatedBudgetDates.exists(legalEntityBudgetDateKey))
        {
            isValid = validatedBudgetDates.lookup(legalEntityBudgetDateKey);
        }
        else
        {
            localLegalEntityDataArea = dataAreas.lookup(_legalEntityId);
            localFiscalCalendarRecId = legalEntityLedgerCalendars.lookup(_legalEntityId);

            changecompany(localLegalEntityDataArea)
            {
                if (!LedgerFiscalCalendar::checkDateIsValid(
                    localFiscalCalendarRecId,
                    _budgetDate,
                    FiscalPeriodType::Operating,
                    false))
                {
                    // Budget date is not in an open period for the fiscal calendar
                    this.addBudgetSourceError(
                        "@SYS329299",
                        BudgetControlErrorWarningType::InvalidRequest,
                        BudgetControlErrorWarning::DateInvalid);

                    isValid = false;
                }
            }

            validatedBudgetDates.insert(legalEntityBudgetDateKey, isValid);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateForBudgetAvailableCheck</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the user, date and budget model inputs from the <c>BudgetControlCheckRequest</c>
    ///    class instance to check budget funds available.
    /// </summary>
    /// <returns>
    ///    true if the user, date, and budget model are valid; otherwise, false.
    /// </returns>
    protected boolean validateForBudgetAvailableCheck()
    {
        boolean isValid = true;

        if (!currentIsBudgetAvailableCheckValidated)
        {
            isValid = isValid && this.validateUser();
            isValid = isValid && this.validateDate();
            isValid = isValid && this.validateBudgetModel();

            currentIsBudgetAvailableCheckValidated = true;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLegalEntityToCheckBudget</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the legal entity associated with the ledger dimension to check budget.
    /// </summary>
    /// <param name="_legalEntityId">
    ///    The ID of a legal entity record.
    /// </param>
    /// <returns>
    ///    true if the legal entity is valid; otherwise, false.
    /// </returns>
    protected boolean validateLegalEntityToCheckBudget(LegalEntityRecId _legalEntityId)
    {
        CompanyInfo legalEntity;
        Ledger primaryLedger;
        BudgetControlConfiguration configuration;
        boolean isValid = true;

        // Get DataArea for LegalEntity & RecId for Ledger
        // Use table find methods to hit table cache
        legalEntity = CompanyInfo::find(false, _legalEntityId);
        primaryLedger = Ledger::findByLegalEntity(_legalEntityId);

        if (legalEntity.RecId == 0)
        {
            this.addBudgetSourceError(
                "@SYS314097",
                BudgetControlErrorWarningType::InvalidRequest,
                BudgetControlErrorWarning::LegalEntityInvalid);

            isValid = false;
        }
        else if (primaryLedger.RecId == 0)
        {
            this.addBudgetSourceError(
                strfmt("@SYS313963", legalEntity.DataArea),
                BudgetControlErrorWarningType::InvalidRequest,
                BudgetControlErrorWarning::LegalEntityInvalid);

            isValid = false;
        }
        else if (primaryLedger.BudgetExchangeRateType == 0 || !ExchangeRateType::exist(primaryLedger.BudgetExchangeRateType))
        {
            this.addBudgetSourceError(
                strfmt("@SYS323934", primaryLedger.Name),
                BudgetControlErrorWarningType::InvalidRequest,
                BudgetControlErrorWarning::LegalEntityInvalid);

            isValid = false;
        }
        else
        {
            if (primaryLedger.IsBudgetControlEnabled)
            {
                configuration = BudgetControlConfiguration::findActiveByPrimaryLedger(primaryLedger.RecId);

                primaryLedgersToCheckBudget.insert(legalEntity.RecId, primaryLedger.RecId);
                primaryLedgerConfigurations.insert(primaryLedger.RecId, configuration);
            }

            dataAreas.insert(legalEntity.RecId, legalEntity.DataArea);
            primaryLedgerCurrencies.insert(primaryLedger.RecId, primaryLedger.AccountingCurrency);
            primaryLedgerBudgetRateTypes.insert(primaryLedger.RecId, primaryLedger.BudgetExchangeRateType);
            legalEntityLedgerCalendars.insert(legalEntity.RecId, primaryLedger.FiscalCalendar);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLegalEntityToRelieveBudget</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the legal entity associated with the ledger dimension
    ///    whose budget funds are to be relieved.
    /// </summary>
    /// <param name="_legalEntityToRelieveBudget">
    ///    The ID of a legal entity record.
    /// </param>
    /// <returns>
    ///    true if the legal entity is valid; otherwise, false.
    /// </returns>
    protected boolean validateLegalEntityToRelieveBudget(LegalEntityRecId _legalEntityToRelieveBudget)
    {
        CompanyInfo legalEntity;
        Ledger primaryLedger;
        boolean isValid = true;

        if (!primaryLedgersToRelieveBudget.exists(_legalEntityToRelieveBudget))
        {
            // Get DataArea for LegalEntity & RecId for Ledger
            // Use table find methods to hit table cache
            legalEntity = CompanyInfo::find(false, _legalEntityToRelieveBudget);
            primaryLedger = Ledger::findByLegalEntity(legalEntity.RecId);

            if (legalEntity.RecId == 0)
            {
                this.addBudgetSourceError(
                    "@SYS314097",
                    BudgetControlErrorWarningType::InvalidRequest,
                    BudgetControlErrorWarning::LegalEntityInvalid);

                isValid = false;
            }
            else if (primaryLedger.RecId == 0)
            {
                this.addBudgetSourceError(
                    strfmt("@SYS313963", legalEntity.DataArea),
                    BudgetControlErrorWarningType::InvalidRequest,
                    BudgetControlErrorWarning::LegalEntityInvalid);

                isValid = false;
            }
            else if (primaryLedger.BudgetExchangeRateType == 0)
            {
                this.addBudgetSourceError(
                    strfmt("@SYS323934", primaryLedger.Name),
                    BudgetControlErrorWarningType::InvalidRequest,
                    BudgetControlErrorWarning::LegalEntityInvalid);

                isValid = false;
            }
            else
            {
                if (primaryLedger.IsBudgetControlEnabled)
                {
                    primaryLedgersToRelieveBudget.insert(legalEntity.RecId, primaryLedger.RecId);
                }

                dataAreas.insert(legalEntity.RecId, legalEntity.DataArea);
                primaryLedgerCurrencies.insert(primaryLedger.RecId, primaryLedger.AccountingCurrency);
                primaryLedgerBudgetRateTypes.insert(primaryLedger.RecId, primaryLedger.BudgetExchangeRateType);
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateRelievingCategories</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the specified budget control category with the current budget source.
    /// </summary>
    /// <param name="_toBeRelievedCategory">
    ///    The category to validate.
    /// </param>
    /// <returns>
    ///    true if the specified category can be relieved by the current budget source; otherwise false.
    /// </returns>
    protected boolean validateRelievingCategories(BudgetControlCategory _toBeRelievedCategory)
    {
        boolean isValid = true;
        BudgetControlCategory localCategory = currentCheckRequest.parmBudgetControlCategory();
        boolean isFrenchRegulatoryEnabled = PublicSectorUtils::isFrenchRegulatoryEnabled();

        switch (_toBeRelievedCategory)
        {
            case BudgetControlCategory::PreEncumbrance:
                if (!(localCategory == BudgetControlCategory::Encumbrance ||
                    localCategory == BudgetControlCategory::EncumbranceReduction ||
                    localCategory == BudgetControlCategory::PreEncumbrance  ||
                    // The French Commitments feature needs to relieve pre-encumbrance from Non-PO Vendor Invoices
                    (isFrenchRegulatoryEnabled && localCategory == BudgetControlCategory::ActualExpenditure)))
                {
                    isValid = false;
                }

                break;

            case BudgetControlCategory::Encumbrance,
                 BudgetControlCategory::EncumbranceReduction:
                if (!(localCategory == BudgetControlCategory::ActualExpenditure ||
                    localCategory == BudgetControlCategory::Encumbrance ||
                    localCategory == BudgetControlCategory::EncumbranceReduction ||
                    (PublicSectorUtils::isBudgetReservationEnabled() && localCategory == BudgetControlCategory::PreEncumbrance)))
                {
                    isValid = false;
                }

                break;

            case BudgetControlCategory::ActualExpenditure:
                if (localCategory != BudgetControlCategory::ActualExpenditure)
                {
                    isValid = false;
                }

                break;

            default:
                // Relieving cannot be performed on this category.
                isValid = false;

                break;
        }

        if (!isValid)
        {
            // Relieving cannot be performed on this category.
            this.addBudgetSourceError(
                strFmt("@SYS132629", enum2str(_toBeRelievedCategory), enum2str(localCategory)),
                BudgetControlErrorWarningType::InvalidRequest,
                BudgetControlErrorWarning::RelievingBudgetCategoryInvalid);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateUser</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the user input from the <c>BudgetControlCheckRequest</c> class instance.
    /// </summary>
    /// <returns>
    ///    true if the user exists; otherwise, false.
    /// </returns>
    protected boolean validateUser()
    {
        boolean isValid = true;

        if (SysUserInfo::find(currentCheckRequest.parmUser()).RecId == 0)
        {
            // User does not exist
            this.addBudgetSourceError(
                strfmt("@SYS128623", currentCheckRequest.parmUser()),
                BudgetControlErrorWarningType::InvalidRequest,
                BudgetControlErrorWarning::UserIdInvalid);

            isValid = false;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instance</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the <c>BudgetControlProcessor</c> class instance for the current transaction scope.
    /// </summary>
    /// <returns>
    ///   The <c>BudgetControlProcessor</c> class instance.
    /// </returns>
    public static BudgetControlProcessor instance()
    {
        BudgetControlProcessor processor;
        str cacheScope = classstr(BudgetControlProcessor);
        str cacheKey = funcname();
        SysTransactionScope transactionScope;

        if (SysTransactionScopeCache::isSet(cacheScope, cacheKey))
        {
            processor = SysTransactionScopeCache::get(cacheScope, cacheKey);
        }
        else if (appl.ttsLevel() > 0)
        {
            // Construct a new processor and subscribe to transaction scope events
            transactionScope = appl.transactionScope();
            processor = new BudgetControlProcessor();

            transactionScope.ttsCommitted += eventhandler(processor.ttsNotifyCommit);
            transactionScope.ttsCommitting += eventhandler(processor.ttsNotifyPreCommit);
            transactionScope.ttsAborted += eventhandler(processor.ttsNotifyAbort);

            // Cache for future use in this transaction scope
            SysTransactionScopeCache::set(cacheScope, cacheKey, processor);

            BudgetControlInstrumentationLogger::createLogger(classStr(BudgetControlProcessor)).processing().processingInstanceCreated();
        }
        else
        {
            // TTS level should always be greater than zero when the budget control processor is used
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        return processor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invokeBudgetCheckStoredProcedure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Invokes budget check stored procedure to perform budget check.
    /// </summary>
    /// <param name="_budgetCheckGroup">
    /// The group of budget sources to be budget checked.
    /// </param>
    /// <param name="_relieveBudget">
    /// An flag indicating whether budget relieving needs to be performed.
    /// </param>
    /// <param name="_logger">
    /// Budget control instrumentation object that logs telemetry data for this process. 
    /// </param>
    /// <param name="_budgetControlProcessingHeader">
    /// RecId for the <c>BudgetControlProcessingHeader</c> to log to.
    /// </param>
    /// <param name="_cleanupDraft">
    /// An flag indicating whether draft cleanup needs to be performed; optional.
    /// </param>
    /// <returns>
    ///    true, if the budget check stored procedure completed successfully; otherwise, false.
    /// </returns>
    private static boolean invokeBudgetCheckStoredProcedure(sequenceNum _budgetCheckGroup, NoYes _relieveBudget, BudgetControlInstrumentationLogger _logger, BudgetControlProcessingLogController _logController, NoYes _cleanupDraft = NoYes::No)
    {
        Connection connection;
        Statement statement;
        boolean isSuccessful;
        SqlStatementExecutePermission permission;
        str sql;

        if (BudgetControlSQLObjects::createAll())
        {
            _logController.createBudgetControlProcessingHeader(_budgetCheckGroup);

            // The SQL objects have been created successfully.
            sql = strfmt('EXEC %1 @PartitionId = %2, @BudgetCheckGroup = %3, @IsAnyRelieved = %4, @IsDraftCleanupRun = %5, @ApplockTimeoutMs = %6, @BudgetControlProcessingHeader = %7, @IsPurchYearEndProcess = %8',
                    BudgetControlSQLObjects::getBudgetControlProcessProcName(),
                    getcurrentpartitionrecid(),
                    _budgetCheckGroup,
                    enum2int(_relieveBudget),
                    enum2int(_cleanupDraft),
                    BudgetControlParameters::getApplockTimeout(),
                    _logController.processingHeaderRecId,
                    enum2int(BudgetControlProcessor::instance().parmIsPurchYearEndProcess()));

            connection = new Connection();

            // Open the code access permission scope.
            permission = new SqlStatementExecutePermission(sql);
            permission.assert();

            statement = connection.createStatement();

            ResultSet rs;
            using (var activityContext = _logger.processing().invokeStoredProcedure())
            {
                rs = statement.executeQueryWithParameters(sql, SqlParams::create());

                // If the stored procedure doesn't have output variables, rs.next() will throw error:
                // Microsoft.Dynamics.Ax.Xpp.ErrorException: 'Cannot select a record in  (). The SQL database has issued an error.'
                // But since this is inside of a transaction, the exception cannot be caught and handled here, it will jump to ttsabort directly. 
                // Consider this is a rare edge case, we will let the exception thrown.
                // If there are more customer problems caused by this issue, we will investigate again for solution.
                rs.next();
            
                int storedProcedureResultCode = rs.getInt(1);
                str storedProcedureResultMsg = rs.getString(2);
           
                // Close the code access permission scope.
                CodeAccessPermission::revertAssert();

                // Invoke force applock stored procedure to release applock immediately after budget check
                // Should be invoked whether SP completed or returned errors
                sql = strfmt('EXEC %1', BudgetControlSQLObjects::getForceApplockReleaseProcName());

                // Open the code access permission scope.
                permission = new SqlStatementExecutePermission(sql);
                permission.assert();

                statement.executeUpdateWithParameters(sql, SqlParams::create());

                // Close the code access permission scope.
                CodeAccessPermission::revertAssert();

                rs.close();
                statement.close();

                //Budget control process stored procedure will return 0 when it completed successfully, otherwise -1
                if (storedProcedureResultCode == ReturnCodeSuccess)
                {
                    isSuccessful = true;
                }
                else 
                {
                    isSuccessful = false;
                    _logger.processing().storedProcedureError(storedProcedureResultCode, storedProcedureResultMsg);
                }
            }
        }

        return isSuccessful;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invokeBudgetControlSaveErrorWarnProc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Invokes the budget control save error warning results stored procedure.
    /// </summary>
    /// <param name="_resultDetailsStrArray">
    ///    A string representation of an array that contains the details of the
    ///    <c>BudgetCheckResultErrorWarningDetail</c> records.
    /// </param>
    /// <param name="_userConnection">
    /// The user connection used to execute the stored procedure.
    /// </param>
    /// <param name="_logger">
    /// Budget control instrumentation object that log telemetry data for this process.
    /// </param>
    /// <returns>
    ///    true, if the budget control save error warning results stored procedure completed successfully; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The result details string array is expected to be in the format that the budget control save error warning results
    ///    stored procedure is expecting.  If it is not an exception may be thrown or the data may not be persisted correctly.
    /// </remarks>
    private static boolean invokeBudgetControlSaveErrorWarnProc(
        str _resultDetailsStrArray,
        UserConnection _userConnection,
        BudgetControlInstrumentationLogger _logger)
    {
        UserConnection userConnectionLocal;
        Statement statement;
        boolean isSuccessful;
        SqlStatementExecutePermission permission;
        str sql;

        try
        {
            if (_userConnection)
            {
                statement = _userConnection.createStatement();
            }
            else
            {
                userConnectionLocal = new UserConnection();
                statement = userConnectionLocal.createStatement();
            }

            // The SQL objects have been created successfully.
            sql = strfmt(@"EXEC %1 @PartitionId = %2, @ResultRecordsArray = '%3'",
                    BudgetControlSQLObjects::getBudgetControlSaveErrorWarnProcName(),
                    getcurrentpartitionrecid(),
                    _resultDetailsStrArray);

            // Open the code access permission scope.
            permission = new SqlStatementExecutePermission(sql);
            permission.assert();

            ResultSet rs = statement.executeQueryWithParameters(sql, SqlParams::create());
            
            // If the stored procedure doesn't have output variables, rs.next() will throw error:
            // Microsoft.Dynamics.Ax.Xpp.ErrorException: 'Cannot select a record in  (). The SQL database has issued an error.'
            // But since this is inside of a transaction, the exception cannot be caught and handled here, it will jump to ttsabort directly.
            // Consider this is a rare edge case, we will let the exception thrown.
            // If there are more customer problems caused by this issue, we will investigate again for solution.
            rs.next();
            
            int storedProcedureResultCode = rs.getInt(1);
            str storedProcedureResultMsg = rs.getString(2);

            // Close the code access permission scope.
            CodeAccessPermission::revertAssert();

            rs.close();
            statement.close();

            if (storedProcedureResultCode == ReturnCodeSuccess)
            {
                isSuccessful = true;
            }
            else 
            {
                isSuccessful = false;
                _logger.processing().storedProcedureError(storedProcedureResultCode, storedProcedureResultMsg);
            }
        }
        finally
        {
            if (userConnectionLocal)
            {
                userConnectionLocal.finalize();
            }
        }

        return isSuccessful;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForBudgetControlAndLogTelemetry</Name>
				<Source><![CDATA[
    private void checkForBudgetControlAndLogTelemetry()
    {
        if (BudgetControlConfiguration::isControlConfigured() && Ledger::isLedgerBudgetControlEnabled())
        {
            BudgetSource budgetSource;
            BudgetTransactionLine budgetTransactionLine;
            AccountingDistribution accountingDistribution;

            while select CheckResult, RecId, BudgetSourceType, BudgetTransactionLine, SourceDocumentLine from budgetSource
                where budgetSource.RecId == budgetCheckGroup
                    && (budgetSource.CheckResult == 0 || budgetSource.CheckResult == 1)
            {
                LedgerDimensionBase ledgerDimension = 0;
                RecId recId = 0;

                if (budgetSource.BudgetSourceType == BudgetSourceType::BudgetTransactionLine)
                {
                    budgetTransactionLine.clear();
                    select firstonly LedgerDimension, RecId from budgetTransactionLine
                        where budgetTransactionLine.RecId == budgetSource.BudgetTransactionLine;

                    recId = budgetTransactionLine.RecId;
                    ledgerDimension = budgetTransactionLine.LedgerDimension;
                }
                else if (budgetSource.BudgetSourceType == BudgetSourceType::SourceDocumentLine)
                {
                    accountingDistribution.clear();
                    select firstonly LedgerDimension, RecId from accountingDistribution
                        where accountingDistribution.SourceDocumentLine == budgetSource.SourceDocumentLine;

                    recId = accountingDistribution.RecId;
                    ledgerDimension = accountingDistribution.LedgerDimension;
                }

                if (BudgetControlLedgerDimensionHelper::isLedgerDimensionEnabledForBudgetControl(Ledger::current(), ledgerDimension))
                {
                    logger.processing().logBudgetCheckSkippedDocumentDetails(budgetSource.CheckResult, budgetSource.RecId, recId, budgetSource.BudgetSourceType);

                    // Budget check retry will be implemented based on the analysis of the log in future
                }
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>