<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>Markup</Name>
	<SourceCode>
		<Declaration><![CDATA[
class  Markup
{
    LedgerVoucher                           ledgerVoucher;
    LedgerCoverage                          ledgerCoverage;
    DimensionDefault                        dimensionDefault;
    Common                                  source;
    Common                                  destin;

    Tax                                     tax;

    CurrencyExchangeHelper                  documentCurrencyExchange;
    CurrencyCode                            documentCurrencyCode;
    CurrencyCode                            currencyCode;
    ExchRate                                exchRate;
    ExchrateSecondary                       exchrateSecondary;
    ExchRatesTriangulation                  exchRatesTriangulation;
    private ExchRate                        reportingCurrencyExchangeRate;
    TransDate                               covDate;
    TransDate                               transDate;
    TaxModuleType                           taxModuleType;

    MarkupAmount                            markupItem;
    MarkupAmount                            markupCustVend;
    MarkupAmount                            markupOtherCharges;
    TaxAmountCur                            markupTax;
    TaxAmountCur                            markupTaxTotal;
    TaxAmountCur                            markupTaxInCostPrice;

    boolean                                 postCoverage;
    boolean                                 postInvoice;
    boolean                                 postJournal;
    boolean                                 onlyIncludeConnected;
    boolean                                 createPostedOnly;

    RefTableId                              transTableId;
    RefRecId                                transRecId;

    // <GBR>
    MarkupAmount                            totalMarkupMST;
    MarkupAmount                            totalMarkupCur;
    Map                                     markupAmountByClassification_BR;
    Map                                     markupAmountMap_BR;
    // </GBR>

    // <GEERU>
    boolean                                 initMarkupTrans;
    boolean                                 initTaxAmount;
    MarkupAmount                            markUpItemLine;
    MarkupAmount                            markUpCustVendLine;
    LedgerBondLog_RU                        itemLedgerBondLog;
    MarkupAmount                            markUpCustVendPositive;
    MarkupAmount                            markUpCustVendNegative;
    // </GEERU>

    Map                                     markupItemLedgerMap;
    Map                                     markupAccountMap;

    TradeTotalsIMarkupEnumerableProvider    markupEnumerableProvider;
    // cached configuration value.
    // it shouldn't change during markup calculation
    boolean                                 mcrCallCenterEnabled;
    boolean                                 configPublicSectorEnabled;


    // <GIN>
    boolean                                 countryRegion_IN;
    //</GIN><GEEU>
    boolean                                 countryRegion_EEU;
    boolean                                 countryRegion_FR;
    // </GEEU>
    // <GEERU>
    boolean                                 allowPosting;
    boolean                                 countryRegion_RU;

    Map                                     markupItemLedgerMap_RU;
    Map                                     markupBondRefMap_RU;

    SalesInvoicePostingType_RU              invoicePostingType;
    GoodsInRouteId_RU                       goodsInRouteId;
    CustInvoiceAccount                      custInvoiceAccount;
    Map                                     covMarkupCustVendMap;

    boolean                                 isProforma;
    boolean                                 postNegativeMarkupAsCorrection;
    // </GEERU>
    // <GIN>
    NoYes                                   creditNote;
    MarkupAmount                            markupAmountLoc;
    // </GIN>
    // <GIN><GEERU>
    #ISOcountryRegionCodes
    // </GEERU></GIN>
    // <GEEU>
    #EECountryRegionCodes
    boolean                                 countryRegion_EE;
    // </GEEU>
    MarkupAmount                            markupPostage;
    MarkupAmount                            markupSurcharge;
    MarkupAmount                            markupRestocking;
    MarkupAmount                            markupReturnPostage;
    MarkupAmount                            markupCoupon;
    RecordSortedList                        markupInstallEligibleList;
    MarkupAmount                            markupInstallPostage;
    MarkupAmount                            markupInstallSurcharge;
    MarkupAmount                            markupInstallRestocking;
    MarkupAmount                            markupInstallReturnPostage;
    MarkupAmount                            markupInstallCoupon;
    MarkupAmount                            markupInstallItem;
    MarkupAmount                            markupInstallCustVend;
    TaxAmountCur                            markupInstallTax;
    TaxAmountCur                            markupInstallTaxInCostPrice;
    boolean                                 inserted;
  
    static Map                              salesTotalsMap; //Not used anymore, only exists to avoid breaking backward compatibilty.
    int                                     numberOfMarkupTransInCalculation;
    private static InventDim                inventDimParameters;

    private boolean                         isLedgerCovCalcOnlyKeep;
    private AmountCur                       ledgerCovTotalMarkupAmount;

    internal MarkupBaseValueCalcEngineProvider  markupBaseValueCalcEngineProvider;
    private boolean                             isAutoChargesSetupSequenceCompoundFeatureEnabled = AutoChargesSetupSequenceCompoundFeature::instance().IsEnabled();
    private boolean                             markupCalcPerInvoiceForSummaryUpdate = SalesParameters::find().IsMarkupCalculationPerInvoiceForSummaryUpdateEnabled;

    internal MarkupAmount markupAmountPerLine;
    internal boolean isCalcWHTInInvoiceWithChargeEnabled = TaxWithholdingGlobalFeature::isCalcWHTInInvoiceWithChargeEnabled();

    private MarkupInstrumentationLogger instrumentationLogger;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>isLedgerCovCalcOnlyKeep</Name>
				<Source><![CDATA[
    internal boolean isLedgerCovCalcOnlyKeep(boolean _isLedgerCovCalcOnlyKeep = isLedgerCovCalcOnlyKeep)
    {
        isLedgerCovCalcOnlyKeep = _isLedgerCovCalcOnlyKeep;

        return isLedgerCovCalcOnlyKeep;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerCovTotalMarkupAmount</Name>
				<Source><![CDATA[
    internal AmountCur getLedgerCovTotalMarkupAmount()
    {
        return ledgerCovTotalMarkupAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateMarkupType</Name>
				<Source><![CDATA[
    protected void allocateMarkupType(MarkupTrans      _markupTrans,
                                      MarkupAmount     _markupAmount
                                      ,boolean _negativeQty = false
                                      )
    {
        MarkupTable     markupTable;

        // <GEERU>
        if (countryRegion_RU)
        {
            markUpItemLine          = 0;
            markUpCustVendLine      = 0;
        }
        // </GEERU>

        if (isCalcWHTInInvoiceWithChargeEnabled)
        {
            markupAmountPerLine = 0;
        }

        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().allocateMarkupType())
        {
            if (transTableId && transRecId)
            {
                // Use the MarkupTrans that this _markupTrans is the origin for, on the specified transaction
                if (_markupTrans.isIntercompanyVirtualCharge())
                {
                    MarkupTrans icsoOrigChargeFromVirtualCharge = _markupTrans.getICSOOrigChargeFromICPOVirtualCharge();
                    if (icsoOrigChargeFromVirtualCharge.Keep == NoYes::Yes)
                    {
                        // If we are checking an IC virtual charge, the invoice origRecId will point to the original charge proportional to the qty
                        // (percent, pcs, proportional, etc) and not to the virtual fixed charge created for sync and invoicing purposes
                        markupTable = MarkupTrans::findOrigTrans(_markupTrans.TableId,
                                                                 icsoOrigChargeFromVirtualCharge.InterCompanyRefRecId,
                                                                 transTableId,
                                                                 transRecId).markupTable();
                    }
                }
                else
                {
                    markupTable = MarkupTrans::findOrigTrans(_markupTrans.TableId,
                                                             _markupTrans.RecId,
                                                             transTableId,
                                                             transRecId).markupTable();
                }
            }
            else
            {
                markupTable = _markupTrans.markupTable();
            }

            if (markupTable.isMarkupOfTypeItemLedger())
            {
                if (markupTable.CustType == MarkupType::Item)
                {
                    this.updateMarkupMap(markupItemLedgerMap, _markupTrans.CurrencyCode, _markupAmount);
                    this.updateMarkupMap(markupAccountMap, _markupTrans.CurrencyCode, -_markupAmount);
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        this.updateMarkupMap_RU(_markupTrans, _markupAmount);
                    }
                    // </GEERU>
                }
                else
                {
                    this.updateMarkupMap(markupItemLedgerMap, _markupTrans.CurrencyCode, -_markupAmount);
                    this.updateMarkupMap(markupAccountMap, _markupTrans.CurrencyCode, _markupAmount);
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        this.updateMarkupMap_RU(_markupTrans, -_markupAmount);
                    }
                    // </GEERU>
                }

                return;
            }

            switch (markupTable.CustType)
            {
                case MarkupType::Item           :   markupItem        += _markupAmount;
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        markUpItemLine     = _markupAmount;
                    }
                    // </GEERU>
                    break;
                case MarkupType::LedgerAccount  :   this.updateMarkupMap(markupAccountMap, _markupTrans.CurrencyCode, _markupAmount);
                    break;
                case MarkupType::CustVend       :   markupCustVend    += _markupAmount;
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        markUpCustVendLine = _markupAmount;
                        this.registerMarkupCustVendChange_RU(_markupAmount < 0, _markupAmount);
                    }
                    // </GEERU>

                    if (isCalcWHTInInvoiceWithChargeEnabled)
                    {
                        markupAmountPerLine = _markupAmount;
                    }
                    break;
            }

            switch (markupTable.VendType)
            {
                case MarkupType::Item           :   markupItem        -= _markupAmount;
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        markUpItemLine     = -_markupAmount;
                    }
                    // </GEERU>
                    break;
                case MarkupType::LedgerAccount  :
                    // <GEERU>
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]))
                    {
                        if (_negativeQty)
                        {
                            this.updateMarkupMap(markupItemLedgerMap, _markupTrans.CurrencyCode, _markupAmount);
                        }
                    }
                    // </GEERU>
                    this.updateMarkupMap(markupAccountMap, _markupTrans.CurrencyCode, -_markupAmount);
                    break;
                case MarkupType::CustVend       :
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        markUpCustVendLine = -_markupAmount;
                        this.registerMarkupCustVendChange_RU(_markupAmount < 0, markUpCustVendLine);
                    }
                    // </GEERU>

                    markupCustVend    -= _markupAmount;

                    if (isCalcWHTInInvoiceWithChargeEnabled)
                    {
                        markupAmountPerLine -= _markupAmount;
                    }
                    break;
            }
            // Add LedgerAccount misc charges to misc charge type subtotals
            if (markupTable.CustType == MarkupType::LedgerAccount
                && _markupTrans.MCRCouponMarkup)
            {
                markupCoupon += _markupAmount;
            }

            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                this.postAllocateMarkupType_BR(_markupTrans, _markupAmount);
            }
            // </GBR>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipMarkupTransCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a MarkupTrans calculation should be skipped.
    /// </summary>
    /// <param name = "_markupTrans">The MarkupTrans record.</param>
    /// <returns>true if the calculation should be skipped; otherwise, false</returns>
    protected boolean skipMarkupTransCalculation(MarkupTrans _markupTrans)
    {
        if (isAutoChargesSetupSequenceCompoundFeatureEnabled 
            && tax 
            && tax is ITaxMarkupCompound 
            && _markupTrans.mustBeSkippedForSummaryUpdate((tax as ITaxMarkupCompound).getMarkupAutoOriginSource().RecId))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfMarkupTransactionsInCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the number of markup transactions involved in the calculation.
    /// </summary>
    /// <returns>The number of markup transactions involved in the calculation.</returns>
    internal int getNumberOfMarkupTransactionsInCalculation()
    {
        return numberOfMarkupTransInCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    public void calc(Qty               _qty,
                     AmountCur         _value,
                     Common            _source,
                     DocumentStatus    _documentStatus = DocumentStatus::None,
                     AmountCur         _interCompanyValue = 0,
                     InvoiceId         _invoiceId         = '',
                     AmountCur         _absoluteValue     = 0,
                     ParmId            _parmId            = '',
                     TradeLineRefId    _parmMCRTableRefId  = '',
                     boolean           _isInterCompanyMarkup = true)
    {
        source = _source;

        markupCustVend               = 0;
        markupItem                   = 0;
        markupTax                    = 0;
        markupTaxTotal               = 0;
        markupTaxInCostPrice         = 0;
        markupInstallCustVend        = 0;
        markUpInstallItem            = 0;
        markupInstallTax             = 0;
        markupInstallTaxInCostPrice  = 0;
        markupInstallPostage         = 0;
        markupInstallSurcharge       = 0;
        markupInstallRestocking      = 0;
        markupInstallReturnPostage   = 0;
        markupInstallCoupon          = 0;
        markupPostage                = 0;
        markupSurcharge              = 0;
        markupRestocking             = 0;
        markupReturnPostage          = 0;
        markupCoupon                 = 0;
        if (configPublicSectorEnabled)
        {
            markupOtherCharges       = 0;
        }

        markupItemLedgerMap     = new Map(Types::String, Types::Real);
        markupAccountMap        = new Map(Types::String,Types::Real);

        // <GEERU>
        markupItemLedgerMap_RU  = new Map(Types::Container, Types::Real);
        markupBondRefMap_RU     = new Map(Types::Int64, Types::Integer);
        markUpItemLine          = 0;
        markUpCustVendLine      = 0;
        markUpCustVendNegative  = 0;
        markUpCustVendPositive  = 0;
        // </GEERU>

        // Initialize a record sorted list that can hold the markuptrans records that are installment eligible.
        if (mcrCallCenterEnabled
            && !markupInstallEligibleList)
        {
            this.mcrInitInstallElgibleMarkUpList();
        }

        // <GEERU>
        boolean selectForUpdate = false;
        if ((postInvoice && (ledgerVoucher || createPostedOnly)) ||
            (countryRegion_RU && initMarkupTrans) ||
            (countryRegion_EEU && initMarkupTrans))
        // </GEERU>
        {
            selectForUpdate = true;
        }

        boolean searchInvoiceId = false;
        if (_invoiceId)
        {
            searchInvoiceId = true;
        }

        numberOfMarkupTransInCalculation = 0;

        this.calcInternal(_qty, _value, _source, _documentStatus, _interCompanyValue, _invoiceId, _absoluteValue, _parmId, _parmMCRTableRefId, _isInterCompanyMarkup, searchInvoiceId, selectForUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates charges for the <c>MarkupTrans</c> record.
    /// </summary>
    /// <param name = "_markupTrans">A <c>MarkupTrans</c> record.</param>
    /// <param name = "_qty">A <c>Qty</c> value.</param>
    /// <param name = "_value">An <c>AmountCur</c> value.</param>
    /// <param name = "_source">The source record.</param>
    /// <param name = "_documentStatus">A <c>DocumentStatus</c> value.</param>
    /// <param name = "_interCompanyValue">An <c>AmountCur</c> value which is the intercompany value.</param>
    /// <param name = "_invoiceId">An <c>InvoiceId</c> value.</param>
    /// <param name = "_absoluteValue">An <c>AmountCur</c> value which is the absolute value.</param>
    /// <param name = "_parmId">A <c>ParmId</c> value.</param>
    /// <param name = "_parmMCRTableRefId">A MCR table reference id.</param>
    /// <param name = "_isInterCompanyMarkup">A boolean value indicating if it is an intercompany markup record calculation.</param>
    /// <param name = "_searchInvoiceId">A boolean value indicating whether to search invoice id.</param>
    protected void calculateMarkup(MarkupTrans _markupTrans,
                     Qty               _qty,
                     AmountCur         _value,
                     Common            _source,
                     DocumentStatus    _documentStatus,
                     AmountCur         _interCompanyValue,
                     InvoiceId         _invoiceId,
                     AmountCur         _absoluteValue,
                     ParmId            _parmId,
                     TradeLineRefId    _parmMCRTableRefId,
                     boolean           _isInterCompanyMarkup,
                     boolean           _searchInvoiceId)
    {
        MarkupAmount    markupAmount;
        AmountCur       value = _value;

        MarkupBaseValueCalcEngine   markupBaseValueCalcEngine;

        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().calculateMarkup())
        {
            if (this.isAutoChargesSequenceAndCompoundFeatureEnabledForSource(_source)
                && !_markupTrans.isInterCompanyAndPercentCategory())
            {
                markupBaseValueCalcEngine = markupBaseValueCalcEngineProvider.getInstance(this.getSourceRecordForMarkupBaseValueCalcEngine(_source), MarkupBaseValueCalcEngine::resolveTaxForMarkup(tax));

                if (markupBaseValueCalcEngine)
                {
                    markupBaseValueCalcEngine.setTaxIncludedInItemPrice(false);
                    value = markupBaseValueCalcEngine.calculateBaseAmount(value, _markupTrans);
                }
            }

            if (configPublicSectorEnabled)
            {
                //Sum other misc charges before discarding line
                this.sumOtherMiscCharges(_markupTrans, _qty, value, _interCompanyValue, _isInterCompanyMarkup);
            }

            // <GEERU>
            if (countryRegion_RU && goodsInRouteId && !_markupTrans.GoodsInRouteId_RU)
            {
                return;
            }
            // </GEERU>

            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                this.calcMarkupAmount_BR(_source, _markupTrans, _qty, value);
            }
            // </GBR>

            if (this.checkDiscardLine(_markupTrans, _documentStatus, _searchInvoiceId, _invoiceId)) // watch out for the Markup_Adjust instance of this class as the check is different
            {
                return;
            }

            // <GEERU>
            if (countryRegion_RU && _markupTrans.isMarkupOfTypeCustVend() && covMarkupCustVendMap)
            {
                if (!covMarkupCustVendMap.elements())
                {
                    return;
                }
                ledgerCoverage.copyLinesMap_RU(covMarkupCustVendMap);
            }
            // </GEERU>

            numberOfMarkupTransInCalculation++;

            // Use document currency information if provided
            if (documentCurrencyExchange != null)
            {
                markupAmount            = Markup::calcMarkupAmount(_markupTrans, _qty, value, _interCompanyValue, this.isInclTax(source), NoYes::No,
                                                                this.parmDocumentCurrencyCode(),
                                                                documentCurrencyExchange.parmExchangeDate(),
                                                                documentCurrencyExchange.parmExchangeRate1(),
                                                                documentCurrencyExchange.parmExchangeRate2()
                                                                , tax
                                                                // <GEERU>
                                                                , (countryRegion_RU ? this.calcTax_RU(source) : false)
                                                                // </GEERU>
                                                                ,_absoluteValue,
                                                                _parmId,
                                                                postInvoice,
                                                                _isInterCompanyMarkup);
            }
            else
            {
                markupAmount            = Markup::calcMarkupAmount(_markupTrans,
                                                                _qty,
                                                                value,
                                                                _interCompanyValue,
                                                                this.isInclTax(source)
                                                                // <GEERU>
                                                                , NoYes::No,
                                                                _markupTrans.CurrencyCode,
                                                                _markupTrans.TransDate,
                                                                0,
                                                                0
                                                                // </GEERU>
                                                                , tax
                                                                // <GEERU>
                                                                ,(countryRegion_RU ? this.calcTax_RU(source) : false)
                                                                // </GEERU>
                                                                ,_absoluteValue,
                                                                _parmId,
                                                                postInvoice,
                                                                _isInterCompanyMarkup);
            }

            if (tax)
            {
                markupTax               = -tax.taxPrLine(_markupTrans.TableId, _markupTrans.RecId);

                markupTaxTotal += markupTax;

                markupTaxInCostPrice    =  tax.taxInCostPrice(_markupTrans.TableId, _markupTrans.RecId);
            }

            if (markupBaseValueCalcEngine)
            {
                markupBaseValueCalcEngine.compoundMarkupValue(markupAmount, _markupTrans);
            }

            // <GTE>
            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                ITaxableDocument    taxableDocument;
                switch (_markupTrans.TransTableId)
                {
                    case tableNum(PurchLine):
                        taxableDocument = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(PurchLine::findRecId(_markupTrans.TransRecId).purchTable()));
                        break;

                    case tableNum(SalesLine):
                        taxableDocument = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(SalesLine::findRecId(_markupTrans.TransRecId).salesTable()));
                        break;

                    case tableNum(VendInvoiceInfoLine):
                        taxableDocument = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(VendInvoiceInfoLine::findRecId(_markupTrans.TransRecId).vendInvoiceInfoTable()));
                        break;

                    case tableNum(CustInvoiceLine):
                        taxableDocument = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(CustInvoiceLine::find(_markupTrans.TransRecId).custInvoiceTable()));
                        break;

                    default:
                        break;
                }

                if (taxableDocument)
                {
                    ITaxDocument taxDocumentObj = TaxBusinessService::calculateTax(taxableDocument);
                    if (taxDocumentObj)
                    {
                        ITaxDocumentLine taxDocumentLineObj = taxDocumentObj.findLineBySource(_markupTrans.TableId, _markupTrans.RecId);
                        if (taxDocumentLineObj)
                        {
                            markupTaxInCostPrice = taxDocumentLineObj.getInclTax().value();
                            if (sign(markupAmount) == sign(markupTaxInCostPrice))
                            {
                                markupTaxInCostPrice = markupTaxInCostPrice * -1;
                            }
                        }
                    }
                }
            }
            // </GTE>

            // If a markup is installment eligible store it in the record list
            // it will be used later by the trade totals to calculate the taxes on markup lines
            // that are installment eligible.
            if (mcrCallCenterEnabled
                    && _markupTrans.MCRInstallmentEligible
                    && markupInstallEligibleList)
            {
                MarkupTrans     markupInstallTrans = _markupTrans;
                this.mcrSetInstallmentMarkUpValues(markupInstallTrans, markupAmount);
            }

            // <GIN>
            if (TaxParameters::checkTaxParameters_IN() && tax)
            {
                // </GIN>

                AmountCur taxOnCharges = abs(markupAmount) - this.getTaxOnCharges_IN(_source, _markupTrans);

                markupAmountLoc = 0;
                if (taxOnCharges)
                {
                    if (markupAmount > 0)
                    {
                        markupAmountLoc = markupAmount;
                        markupAmount = abs(taxOnCharges);
                    }
                    else
                    {
                        markupAmountLoc = markupAmount;
                        markupAmount = -abs(taxOnCharges);
                    }
                }
            }

            // <GEERU>
            if (countryRegion_RU)
            {
                this.allocateMarkupType(_markupTrans, markupAmount + markupTaxInCostPrice
                                            , _qty<0
                                            );
            }
            else
            {
                // </GEERU>
                this.allocateMarkupType(_markupTrans, markupAmount + markupTaxInCostPrice);
                // <GEERU>
            }
            // </GEERU>

            if (postInvoice && (ledgerVoucher || createPostedOnly))
            {
                this.postInvoiceTrans(_markupTrans, markupAmount + markupTaxInCostPrice);
            }

            // If doing a proforma, post as if posting a journal.
            if (postJournal)
            {
                if (!mcrCallCenterEnabled
                        || !isProforma)
                {
                    this.postJournalTrans(_markupTrans, markupAmount + markupTaxInCostPrice);
                }
            }

            // <GEERU>
            if (countryRegion_RU
                    && initMarkupTrans)
            {
                this.initMarkupTrans_RU(_markupTrans);
                _markupTrans.write();
            }

            // </GEERU>

            // <GEEU>
            if ((countryRegion_EEU || countryRegion_FR)
                    && initMarkupTrans)
            {
                this.calcAmountMST(_markupTrans);
                _markupTrans.write();
            }
            // </GEEU>

            if (postCoverage && ledgerCoverage)
            {
                // <GEERU>
                if (countryRegion_RU)
                {
                    this.covTrans(_markupTrans, markupAmount + markupTaxInCostPrice, markupTax);
                }
                else
                {
                    // </GEERU>
                    this.covTrans(_markupTrans, markupAmount + markupTaxInCostPrice);
                    // <GEERU>
                }
                // </GEERU>
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAutoChargesSequenceAndCompoundFeatureEnabledForSource</Name>
				<Source><![CDATA[
    private boolean isAutoChargesSequenceAndCompoundFeatureEnabledForSource(Common _source)
    {
        return (Markup::isSequenceAndCompoundEnabledForHeaderSource(_source.TableId)
            || Markup::isSequenceAndCompoundEnabledForLineSource(_source.TableId))
            && isAutoChargesSetupSequenceCompoundFeatureEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSequenceAndCompoundEnabledForHeaderSource</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static boolean isSequenceAndCompoundEnabledForHeaderSource(TableId _sourceTableId)
    {
        return _sourceTableId == tableNum(SalesTable) || _sourceTableId == tableNum(SalesQuotationTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSequenceAndCompoundEnabledForLineSource</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static boolean isSequenceAndCompoundEnabledForLineSource(TableId _sourceTableId)
    {
        return _sourceTableId == tableNum(SalesLine) || _sourceTableId == tableNum(SalesQuotationLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceRecordForMarkupBaseValueCalcEngine</Name>
				<Source><![CDATA[
    private Common getSourceRecordForMarkupBaseValueCalcEngine(Common _source)
    {
        if (markupCalcPerInvoiceForSummaryUpdate && tax && tax is ITaxMarkupCompound)
        {
            return (tax as ITaxMarkupCompound).getMarkupAutoOriginSource();
        }
        else
        {
            return _source;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Sets the <c>CalculatedAmountMST_W</c> field on the passed in <c>MarkupTrans</c> record.
    /// </summary>
    /// <param name="_markupTrans">
    ///   A record.
    /// </param>
    protected void calcAmountMST(MarkupTrans  _markupTrans)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().calcAmountMST())
        {
            MarkupTable             markupTable = _markupTrans.markupTable();

            ExchRate                currencyExchRate;
            ExchrateSecondary       currencyExchrateSecondary;
            ExchRatesTriangulation  currencyExchRatesTriangulation;
            TransDate               currencyExchDate;

            currencyExchDate = _markupTrans.TransDate ? _markupTrans.TransDate :
                                   (ledgerVoucher ? ledgerVoucher.lastTransDate() : this.transDate());
            if (currencyExchDate)
            {
                if (markupTable.isMarkupOfTypeCustVend())
                {
                    currencyExchRate                = exchRate;
                    currencyExchrateSecondary       = exchrateSecondary;
                    currencyExchRatesTriangulation  = exchRatesTriangulation;
                }
                else
                {
                    currencyExchRate                = 0;
                    currencyExchrateSecondary       = 0;
                    currencyExchRatesTriangulation  = UnknownNoYes::Unknown;
                }
                _markupTrans.CalculatedAmountMST_W = CurrencyExchangeHelper::mstAmount(_markupTrans.CalculatedAmount, _markupTrans.CurrencyCode, currencyExchDate, exchRatesTriangulation, exchRate, exchrateSecondary);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMarkupAmount_BR</Name>
				<Source><![CDATA[
    protected void calcMarkupAmount_BR(Common      _source,
                                       MarkupTrans _markupTrans,
                                       Qty         _qty,
                                       AmountCur   _value)
    {
        // discard charges not charged by customer/vendor with exception of direct import
        if (_source is VendInvoiceInfoLine)
        {
            VendInvoiceInfoLine line = _source;

            if (line.vendInvoiceInfoTable().isForeignerVendor_BR() == false
                    && _markupTrans.isMarkupOfTypeCustVend() == false)
            {
                return;
            }
        }

        AmountCur markupAmount = Markup::calcTrans(_markupTrans, _qty, _value);
        AmountMST markupAmountMST;

        if (_markupTrans.CurrencyCode != CompanyInfoHelper::standardCurrency())
        {
            markupAmountMST =  CurrencyExchangeHelper::amountCur2MST(markupAmount, _markupTrans.CurrencyCode, exchRate, transDate);
        }
        else
        {
            markupAmountMST = markupAmount;
            markupAmount    = CurrencyExchangeHelper::curAmount(markupAmountMST, currencyCode, transDate, UnknownNoYes::Unknown, exchRate);
        }

        if (_markupTrans.markupTable().ModuleType == MarkupModuleType::Vend
            && _markupTrans.markupTable().VendType == MarkupType::LedgerAccount)
        {
            this.markupAmountByClassification_BR(_markupTrans, markupAmount);
        }

        if (_markupTrans.markupTable().MarkupClassification_BR != MarkupClassification_BR::Blank)
        {
            totalMarkupMST += markupAmountMST;
            totalMarkupCur += markupAmount;
        }

        markupAmountMap_BR.insert(_markupTrans.RecId, markupAmountMST);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMarkupAmount_RU</Name>
				<Source><![CDATA[
    public AmountCur calcMarkupAmount_RU(Common      _source,
                                         Qty         _qty,
                                         AmountCur   _value)
    {
        MarkupTrans markupTrans;
        AmountCur   markupAmount;

        while select markupTrans
            index hint TableRecIdIdx
            where markupTrans.TransTableId  == _source.TableId    &&
                markupTrans.TransRecId    == _source.RecId      &&
                !markupTrans.IsDeleted
        {
            if (this.checkDiscardLine(markupTrans))
                continue;

            markupAmount += Markup::calcTrans(markupTrans, _qty, _value);
        }

        return markupAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTax_RU</Name>
				<Source><![CDATA[
    protected boolean calcTax_RU(Common _source)
    {
        PurchLine           purchLine;
        PurchParmLine       purchParmLine;
        SalesLine           salesLine;
        SalesParmLine       salesParmLine;

        switch (_source.TableId)
        {
            case (tableNum(PurchLine)) :
                purchLine = _source;
                if (purchLine.inventDim().inventProfile_RU().taxUpdateIncoming() == TaxUpdateMode_RU::NoCalc)
                {
                    return false;
                }
                break;
            case (tableNum(PurchParmLine)) :
                purchParmLine = _source;
                if (purchParmLine.inventDim().inventProfile_RU().taxUpdateIncoming() == TaxUpdateMode_RU::NoCalc)
                {
                    return false;
                }
                break;
            case (tableNum(SalesLine)) :
                salesLine = _source;
                if (salesLine.inventDim().inventProfile_RU().taxUpdateOutgoing() == TaxUpdateMode_RU::NoCalc)
                {
                    return false;
                }
                break;
            case (tableNum(SalesParmLine)) :
                salesParmLine = _source;
                if (salesParmLine.inventDim().inventProfile_RU().taxUpdateOutgoing() == TaxUpdateMode_RU::NoCalc)
                {
                    return false;
                }
                break;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether posting a <c>MarkupTrans</c> record can update the ledger.
    /// </summary>
    /// <param name="_transTableId">
    ///    The <c>TransTableId</c> value of the <c>MarkupTrans</c> record under consideration.
    /// </param>
    /// <returns>
    ///    true if the posting can update the ledger; otherwise, false.
    /// </returns>
    public boolean canPostLedger(TableId _transTableId)
    {
        if (ledgerVoucher)
        {
            switch (_transTableId)
            {
                case tableNum(PurchTable):
                case tableNum(PurchLine):

                    return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDiscardLine</Name>
				<Source><![CDATA[
    protected boolean checkDiscardLine(MarkupTrans      _markupTrans,
                                       DocumentStatus   _documentStatus = DocumentStatus::None,
                                       boolean          _searchInvoice  = false,
                                       InvoiceId        _invoiceId      = '')
    {
        boolean     ret = false;
        MarkupTable markupTable = _markupTrans.markupTable();

        ret = markupTable.isMarkupOfTypeItemLedger() && !createPostedOnly;

        if (_searchInvoice
        && (markupTable.CustType == MarkupType::CustVend
         || markupTable.VendType == MarkupType::CustVend)
        &&  _markupTrans.InterCompanyInvoiceId != _invoiceId)
            ret = true;

        // <GEERU>
        if (countryRegion_RU)
        {
            if (markupTable.isMarkupOfTypeItemLedger()
             && this.costAdjustmentLocked_RU())
            {
                throw error("@GLS115689");
            }

            if (_markupTrans.markupTable().isMarkupOfTypeCustVend()
             && this.markupCustVendLocked_RU())
            {
                throw error("@GLS115690");
            }
        }
        // </GEERU>

        // Check if _markupTrans is the origin for a MarkupTrans record on the specified transaction
        if (!ret && onlyIncludeConnected)
        {
            if (_markupTrans.isIntercompanyVirtualCharge())
            {
                MarkupTrans icsoOrigChargeFromVirtualCharge = _markupTrans.getICSOOrigChargeFromICPOVirtualCharge();
                if (icsoOrigChargeFromVirtualCharge.Keep == NoYes::Yes)
                {
                    // If we are checking an IC virtual charge, the invoice origRecId will point to the original charge proportional to the qty
                    // (percent, pcs, proportional, etc) and not to the virtual fixed charge created for sync and invoicing purposes
                    if (!MarkupTrans::existOrigTrans(_markupTrans.TableId, icsoOrigChargeFromVirtualCharge.InterCompanyRefRecId, transTableId, transRecId))
                    {
                        ret = true;
                    }
                }
            }
            else
            {
                if (!MarkupTrans::existOrigTrans(_markupTrans.TableId, _markupTrans.RecId, transTableId, transRecId))
                {
                    ret = true;
                }
            }
        }

        if (ret)
            return ret;

        ret = _markupTrans.excludeFromUpdate(_documentStatus);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForCurrencyMismatch</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Compares the currency code on a <c>MarkupTrans</c> record and associated records.
    /// </summary>
    /// <param name="_markupTrans">
    ///    A <c>MarkupTrans</c> record.
    /// </param>
    /// <param name="_source">
    ///    A source record related to the <c>MarkupTrans</c> record.
    /// </param>
    /// <param name="_dest">
    ///    A destination record related to the <c>MarkupTrans</c> record.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    A mismatch exists between the currency code on a <c>MarkupTrans</c> record and another record.
    /// </exception>
    //
    // This method is really a work around for bug # 48959.  The problem is that if the user has
    // an invoice open or saved and changes the currency on the PO, when the lines on the PO are recreated
    // (say by changing the Quantity dropdown list), the lines will pickup the new currency but
    // the miscellaneous charges (MarkupTrans) will not.  The check informs the user of the problem
    // so that the user can manually fix the MarkupTrans or create the invoice from the updated PO.
    // This method can go away if bug # 48959 (or one like it) is implemented but it shouldn't be harmful
    // if it remains, just useless!
    //
    protected void checkForCurrencyMismatch(MarkupTrans _markupTrans, Common _source, Common _dest)
    {
        PurchId purchId;
        PurchTable purchTable;
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceInfoSubTable vendInvoiceInfoSubTable;
        CurrencyCodeMap sourceMap = _source;
        CurrencyCodeMap destMap = _dest;

        void showError(CurrencyCode cc)
        {
            switch (_markupTrans.TransTableId)
            {
                case tableNum(VendInvoiceInfoTable):
                    purchId = VendInvoiceInfoTable::findRecId(_markupTrans.TransRecId).PurchId;
                    break;
                case tableNum(VendInvoiceInfoSubTable):
                    purchId = VendInvoiceInfoSubTable::findRecId(_markupTrans.TransRecId).OrigPurchId;
                    break;
                case tableNum(VendInvoiceInfoLine):
                    purchId = VendInvoiceInfoLine::findRecId(_markupTrans.TransRecId).OrigPurchId;
                    break;
            }
            error(strFmt("@SYS125784", _markupTrans.CurrencyCode, cc));
            throw error(strFmt("@SYS62710", PurchTable::find(purchId).PurchaseType, purchId));
        }

        // <GEERU>
        //No need to do further check for EE countries if Table is CustInvoiceTrans.
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]) &&
            (_source.TableId == tableNum(CustInvoiceTrans) || _source.TableId == tableNum(CustInvoiceJour)))
        {
            return;
        }
        // </GEERU>

        if (_markupTrans.isMarkupOfTypeCustVend())
        {
            if (_markupTrans.CurrencyCode != destMap.CurrencyCode)
            {
                showError(destMap.CurrencyCode);
            }
            else if (_source.TableId == tableNum(VendInvoiceInfoSubTable)) // No currency code, check header
            {
                vendInvoiceInfoSubTable = _source;

                if (vendInvoiceInfoSubTable.isNonPO())
                {
                    vendInvoiceInfoTable = vendInvoiceInfoSubTable.vendInvoiceInfoTable();
                    if (_markupTrans.CurrencyCode != vendInvoiceInfoTable.CurrencyCode)
                    {
                        showError(vendInvoiceInfoTable.CurrencyCode);
                    }
                }
                else
                {
                    purchTable = PurchTable::find(vendInvoiceInfoSubTable.OrigPurchId);
                    if (_markupTrans.CurrencyCode != purchTable.CurrencyCode)
                    {
                        showError(purchTable.CurrencyCode);
                    }
                }
            }
            else if (_source.TableId == tableNum(VendInvoiceInfoTable)) // Currency code doesn't reflect the problem, check PurchTable
            {
                vendInvoiceInfoTable = _source;

                if (vendInvoiceInfoTable.isNonPO())
                {
                    if (_markupTrans.CurrencyCode != vendInvoiceInfoTable.CurrencyCode)
                    {
                        showError(vendInvoiceInfoTable.CurrencyCode);
                    }
                }
                else
                {
                    purchTable = PurchTable::find(vendInvoiceInfoTable.PurchId);
                    if (_markupTrans.CurrencyCode != purchTable.CurrencyCode)
                    {
                        showError(purchTable.CurrencyCode);
                    }
                }
            }
            else
            {
                if (this.checkForCurrencyMismatchWhenSourceNotMappedToCurrencyCodeMap())
                {
                    if (_markupTrans.CurrencyCode != sourceMap.CurrencyCode)
                    {
                        showError(sourceMap.CurrencyCode);
                    }
                }
                else if (this.checkForCurrencyMismatchWhenSourceMappedToCurrencyCodeMap()
                    && SysDictTable::isTableMapped(tablenum(CurrencyCodeMap), _source.TableId)
                    && _markupTrans.CurrencyCode != sourceMap.CurrencyCode)
                {
                    showError(sourceMap.CurrencyCode);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForCurrencyMismatchWhenSourceNotMappedToCurrencyCodeMap</Name>
				<Source><![CDATA[
    [Replaceable(true)]
    protected boolean checkForCurrencyMismatchWhenSourceNotMappedToCurrencyCodeMap()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForCurrencyMismatchWhenSourceMappedToCurrencyCodeMap</Name>
				<Source><![CDATA[
    [Replaceable(true)]
    protected boolean checkForCurrencyMismatchWhenSourceMappedToCurrencyCodeMap()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAdjustmentLocked_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the cost adjustment is locked.
    /// </summary>
    /// <returns>
    ///    true if the cost adjustment is locked; otherwise, false.
    /// </returns>
    protected boolean costAdjustmentLocked_RU()
    {
        PurchLine           purchLine;
        PurchParmLine       purchParmLine;
        VendInvoiceTrans    vendInvoiceTrans;
        SalesLine           salesLine;
        SalesParmLine       salesParmLine;
        CustInvoiceTrans    custInvoiceTrans;
        VendInvoiceInfoLine vendInvoiceInfoLine;

        switch (source.TableId)
        {
            case tableNum(PurchLine):
                purchLine = source;
                return purchLine.inventDim().inventProfile_RU().LockCostAdjustment;
            case tableNum(PurchParmLine):
                purchParmLine = source;
                return purchParmLine.inventDim().inventProfile_RU().LockCostAdjustment;
            case tableNum(VendInvoiceTrans):
                vendInvoiceTrans = source;
                return vendInvoiceTrans.inventDim().inventProfile_RU().LockCostAdjustment;
            case tableNum(SalesLine):
                salesLine = source;
                return salesLine.inventDim().inventProfile_RU().LockCostAdjustment;
            case tableNum(SalesParmLine):
                salesParmLine = source;
                return salesParmLine.inventDim().inventProfile_RU().LockCostAdjustment;
            case tableNum(CustInvoiceTrans):
                custInvoiceTrans = source;
                return custInvoiceTrans.inventDim().inventProfile_RU().LockCostAdjustment;
            case tableNum(VendInvoiceInfoLine):
                vendInvoiceInfoLine = source;
                return vendInvoiceInfoLine.inventDim().inventProfile_RU().LockCostAdjustment;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cov</Name>
				<Source><![CDATA[
    public void cov(TransDate         _covDate,
                    Qty               _qty,
                    AmountCur         _value,
                    Common            _source,
                    LedgerCoverage    _ledgerCoverage,
                    DimensionDefault  _dimensionDefault)
    {
        covDate                 = _covDate;
        ledgerCoverage          = _ledgerCoverage;
        dimensionDefault        = _dimensionDefault;

        postCoverage            = true;
        ledgerCovTotalMarkupAmount = 0.00;

        this.calc(_qty,
                  _value,
                  _source);

        postCoverage            = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covMarkupCustVendMap_RU</Name>
				<Source><![CDATA[
    public void covMarkupCustVendMap_RU(Map _covMarkupCustVendMap)
    {
        covMarkupCustVendMap = _covMarkupCustVendMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covTrans</Name>
				<Source><![CDATA[
    protected void covTrans(MarkupTrans  markupTrans,
                            AmountCur    markupAmount,
                            AmountCur    _markupTaxAmount_RU = 0)
    {
        MainAccount             mainAccount;
        // <GEERU>
        LedgerDimensionDefaultAccount ledgerDimension;
        // </GEERU>
        MarkupTable markupTable = markupTrans.markupTable();
        
        // <GEERU>
        if (countryRegion_RU)
        {
            ledgerCoverage.parmPostingProfile_RU(markupTrans.postingProfile_RU());
            ledgerCoverage.parmInventProfileType_RU(markupTrans.inventProfileType_RU());
        }
        // </GEERU>

        if (markupTable.CustType == MarkupType::LedgerAccount)
        {
            mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(markupTable.parmCustomerLedgerDimension());
            DimensionDefault dimensionDefaultCust = this.getDimensionDefaultCust();

            // <GEERU>
            if (countryRegion_RU                             &&
                TaxParameters::find().TaxSpecPosting_RU      &&
                markupTable.VendType == MarkupType::CustVend &&
                custInvoiceAccount)
            {
                ledgerCoverage.updateSum(covDate,
                                         markupTable.CustPosting,
                                         mainAccount.RecId,
                                         dimensionDefaultCust,
                                         markupTrans.CurrencyCode,
                                         markupAmount);

                ledgerDimension = MarkupCustPosting_RU::findLedger(MarkupCustPostingType_RU::SalesConsumption,
                                                                   custInvoiceAccount,
                                                                   markupTable.MarkupCode).LedgerDimension;

                ledgerCoverage.updateSum(covDate,
                                         LedgerPostingType::SalesConsump,
                                         LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerDimension).RecId,
                                         dimensionDefaultCust,
                                         markupTrans.CurrencyCode,
                                         -markupAmount);

                ledgerDimension = MarkupCustPosting_RU::findLedger(MarkupCustPostingType_RU::SalesRevenue,
                                                                   custInvoiceAccount,
                                                                   markupTable.MarkupCode).LedgerDimension;

                ledgerCoverage.updateSum(covDate,
                                         LedgerPostingType::SalesRevenue,
                                         LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerDimension).RecId,
                                         dimensionDefaultCust,
                                         markupTrans.CurrencyCode,
                                         markupAmount + _markupTaxAmount_RU);
            }
            else
            {
                // </GEERU>
                if (!isLedgerCovCalcOnlyKeep || markupTrans.Keep == NoYes::Yes)
                {
                    ledgerCoverage.updateSum(
                        covDate,
                        markupTable.CustPosting,
                        mainAccount.RecId,
                        dimensionDefaultCust,
                        markupTrans.CurrencyCode,
                        markupAmount);

                    ledgerCovTotalMarkupAmount += markupAmount;
                }
                // <GEERU>
            }
            // </GEERU>
        }

        if (markupTable.VendType == MarkupType::LedgerAccount)
        {
            mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(markupTable.parmVendorLedgerDimension());
            DimensionDefault dimensionDefaultVend = this.getDimensionDefaultVend();

            // <GEERU>
            if (countryRegion_RU                             &&
                TaxParameters::find().TaxSpecPosting_RU      &&
                markupTable.CustType == MarkupType::CustVend &&
                custInvoiceAccount)
            {
                ledgerCoverage.updateSum(covDate,
                                         markupTable.VendPosting,
                                         mainAccount.RecId,
                                         dimensionDefaultVend,
                                         markupTrans.CurrencyCode,
                                        -markupAmount);

                ledgerDimension = MarkupCustPosting_RU::findLedger(MarkupCustPostingType_RU::SalesConsumption,
                                                                   custInvoiceAccount,
                                                                   markupTable.MarkupCode).LedgerDimension;

                ledgerCoverage.updateSum(covDate,
                                         LedgerPostingType::SalesConsump,
                                         LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerDimension).RecId,
                                         dimensionDefaultVend,
                                         markupTrans.CurrencyCode,
                                         markupAmount);

                ledgerDimension = MarkupCustPosting_RU::findLedger(MarkupCustPostingType_RU::SalesRevenue,
                                                                   custInvoiceAccount,
                                                                   markupTable.MarkupCode).LedgerDimension;

                ledgerCoverage.updateSum(covDate,
                                         LedgerPostingType::SalesRevenue,
                                         LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerDimension).RecId,
                                         dimensionDefaultVend,
                                         markupTrans.CurrencyCode,
                                        -(markupAmount + _markupTaxAmount_RU));
            }
            else
            {
                // </GEERU>
                if (!isLedgerCovCalcOnlyKeep || markupTrans.Keep == NoYes::Yes)
                {
                    ledgerCoverage.updateSum(
                        covDate,
                        markupTable.VendPosting,
                        mainAccount.RecId,
                        dimensionDefaultVend,
                        markupTrans.CurrencyCode,
                        -markupAmount);

                    ledgerCovTotalMarkupAmount += markupAmount;
                }
                // <GEERU>
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMarkupEnumerable</Name>
				<Source><![CDATA[
    protected TradeTotalsIMarkupEnumerableProvider createMarkupEnumerable()
    {
        return PurchTotalsMarkupEnumerableProvider::newProvider();
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineTotalIncludedTaxAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines total included tax amount for Brazilian companies.
    /// </summary>
    /// <param name="_markupTrans">
    /// The charge transaction.
    /// </param>
    /// <returns>
    /// The total included tax amount.
    /// </returns>
    protected TaxAmount determineTotalIncludedTaxAmount_BR(MarkupTrans _markupTrans)
    {
        TaxAmount       totalIncludedTaxAmount, totalIncludedTaxAmountCopy;
        MarkupTable     markupTable = _markupTrans.markupTable();

        totalIncludedTaxAmountCopy = tax.taxInCostPrice_BR(_markupTrans.TableId, _markupTrans.RecId);

        switch (markupTable.CustType)
        {
            case MarkupType::Item           :
                totalIncludedTaxAmount = 0;
                if (markupTable.VendType != MarkupType::LedgerAccount)
                {
                    totalIncludedTaxAmount = totalIncludedTaxAmountCopy;
                }
                break;
            case MarkupType::LedgerAccount  :
                totalIncludedTaxAmount = 0;
                if (markupTable.VendType != MarkupType::LedgerAccount)
                {
                    totalIncludedTaxAmount = totalIncludedTaxAmountCopy;
                }
                break;
        }

        switch (markupTable.VendType)
        {
            case MarkupType::LedgerAccount  :
                totalIncludedTaxAmount = 0;
                if (markupTable.CustType != MarkupType::Item)
                {
                    totalIncludedTaxAmount -= totalIncludedTaxAmountCopy;
                }
                break;
        }

        return totalIncludedTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineTotalTaxAmount</Name>
				<Source><![CDATA[
    protected TaxAmount determineTotalTaxAmount(MarkupTrans _markupTrans)
    {
        TaxAmount       totalTaxAmount;
        MarkupTable     markupTable = _markupTrans.markupTable();

        switch (markupTable.VendType)
        {
            case MarkupType::LedgerAccount  :
                if (markupTable.CustType != MarkupType::Item)
                {
                    totalTaxAmount -= tax.taxInCostPrice_BR(_markupTrans.TableId, _markupTrans.RecId);
                }
                break;
        }

        return totalTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to get the tax instance.
    /// </summary>
    /// <returns>
    /// Returns the tax instance if set or null otherwise.
    /// </returns>
    public Tax getTax_IN()
    {
        return tax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxOnCharges_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to get the taxes on charge for the specific markup code.
    /// </summary>
    /// <param name="_source">
    /// A table buffer.
    /// </param>
    /// <param name="_markupTrans">
    /// A <c>MarkupTrans</c> table buffer.
    /// </param>
    /// <returns>
    /// Returns the markup amount.
    /// </returns>
    public MarkupAmount getTaxOnCharges_IN(Common        _source,
                                           MarkupTrans  _markupTrans)
    {
        PurchLine       purchLineCur;
        SalesLine       salesLineCur;
        CustInvoiceLine custInvoiceLineCur;
        TmpTaxCalc_IN   tmpCalcTax;

        // <GTE>
        boolean isGTEEnabled = TaxSolutionScopeIntegrationUtil::isCompanyEnabled();
        // <GTE>

        if (source.TableId == tableNum(PurchLine))
        {
            purchLineCur = PurchLine::findRecId(source.RecId);
        }

        if (source.TableId == tableNum(PurchParmLine))
        {
            purchLineCur = PurchLine::findRecId(PurchParmLine::findRecId(source.RecId).PurchLineRecId);
        }

        if (source.TableId == tableNum(SalesLine))
        {
            salesLineCur = SalesLine::findRecId(source.RecId);
        }

        if (source.TableId == tableNum(SalesParmLine))
        {
            salesLineCur = SalesLine::findRecId(SalesParmLine::findRecId(source.RecId).SalesLineRecId);
        }

        if (source.TableId == tableNum(VendInvoiceInfoLine))
        {
            purchLineCur = PurchLine::findRecId(VendInvoiceInfoLine::findRecId(_markupTrans.TransRecId).PurchLineRecId);
        }

        // <GTE>
        if (isGTEEnabled && source.TableId == tableNum(CustInvoiceLine))
        {
            custInvoiceLineCur = CustInvoiceLine::find(_markupTrans.TransRecId);
        }
        // </GTE>

        tmpCalcTax = tax.tmpTaxCalc_IN();

        if (source.TableId == tableNum(SalesLine) || source.TableId == tableNum(SalesParmLine))
        {
            select tmpCalcTax where
                tmpCalcTax.ChargeCode       == _markupTrans.MarkupCode   &&
                tmpCalcTax.SourceTableID    == salesLineCur.TableId     &&
                tmpCalcTax.SourceRecID      == salesLineCur.RecId;
        }
        else if (source.TableId == tableNum(PurchLine) || source.TableId == tableNum(PurchParmLine) || source.TableId == tableNum(VendInvoiceInfoLine))
        {
            select tmpCalcTax where
                tmpCalcTax.ChargeCode       == _markupTrans.MarkupCode   &&
                tmpCalcTax.SourceTableID    == purchLineCur.TableId     &&
                tmpCalcTax.SourceRecID      == purchLineCur.RecId;
        }
        // <GTE>
        else if (isGTEEnabled && source.TableId == tableNum(CustInvoiceLine))
        {
            select tmpCalcTax where
                tmpCalcTax.ChargeCode       == _markupTrans.MarkupCode   &&
                tmpCalcTax.SourceTableID    == custInvoiceLineCur.TableId     &&
                tmpCalcTax.SourceRecID      == custInvoiceLineCur.RecId;
        }
        // </GTE>

        return CurrencyExchangeHelper::amount(abs(tmpCalcTax.TaxOnCharges));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMarkupTrans_RU</Name>
				<Source><![CDATA[
    protected void initMarkupTrans_RU(MarkupTrans  _markupTrans)
    {
        MarkupTable         markupTable = _markupTrans.markupTable();
        TmpTaxWorkTrans     taxWorkTrans;
        CalcTaxes_RU        calcTaxes;
        int                 sign;

        ExchRate                currencyExchRate;
        ExchrateSecondary       currencyExchrateSecondary;
        ExchRatesTriangulation  currencyExchRatesTriangulation;
        TransDate               currencyExchDate;

        if (invoicePostingType                       == SalesInvoicePostingType_RU::GoodsInRoute &&
            markupTable.UseCustPostingTypeTransit_RU == NoYes::Yes)
        {
            _markupTrans.GoodsInRouteToDelivery_RU = NoYes::Yes;
        }

        _markupTrans.CustVendPosted_RU = markupTable.ModuleType == MarkupModuleType::Vend ?
                                            - markUpCustVendLine :
                                              markUpCustVendLine;
        _markupTrans.ItemPosted_RU     = markUpItemLine;

        sign = (_markupTrans.CustVendPosted_RU + _markupTrans.ItemPosted_RU) >= 0 ? 1 : -1;
        _markupTrans.TaxVATType_RU = VATType_RU::NonLiable;
        if (tax)
        {
            taxWorkTrans = tax.tmpTaxWorkTrans();
            select taxWorkTrans
                where taxWorkTrans.SourceTableId    == _markupTrans.TableId &&
                      taxWorkTrans.SourceRecId      == _markupTrans.RecId   &&
                      taxWorkTrans.TaxDirection     != TaxDirection::UseTax &&
                      taxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed;

            calcTaxes = CalcTaxes_RU::construct(taxWorkTrans);
            calcTaxes.calc();

            _markupTrans.TaxAmountVAT_RU       = abs(calcTaxes.taxAmountCur_VAT()        +
                                                     calcTaxes.taxAmountCur_VATReduced() +
                                                     calcTaxes.taxAmountCur_VATZero() ) * sign;
            _markupTrans.TaxAmountVATMST_RU    = abs(calcTaxes.taxAmount_VAT()           +
                                                     calcTaxes.taxAmount_VATReduced()    +
                                                     calcTaxes.taxAmount_VATZero() )    * sign;
            _markupTrans.TaxValueVAT_RU        = calcTaxes.taxValue_VAT();

            _markupTrans.TaxAmountExcise_RU    = abs(calcTaxes.taxAmountCur_Excise()) * sign;
            _markupTrans.TaxAmountExciseMST_RU = abs(calcTaxes.taxAmount_Excise())    * sign;

            if (initTaxAmount)
            {
                _markupTrans.TaxAmount             = abs(calcTaxes.totalTaxAmountCur())   * sign;
            }
            _markupTrans.TaxAmountMST_W        = abs(calcTaxes.totalTaxAmount())      * sign;

            _markupTrans.TaxVATType_RU         = calcTaxes.taxBaseAmountCur_VAT()          ? VATType_RU::Full    :
                                                  (calcTaxes.taxBaseAmountCur_VATReduced() ? VATType_RU::Reduced :
                                                    (calcTaxes.taxBaseAmount_VATZero()     ? VATType_RU::Zero    :
                                                                                             VATType_RU::NonLiable));
        }

        currencyExchDate = _markupTrans.TransDate ? _markupTrans.TransDate :
                               (ledgerVoucher ? ledgerVoucher.lastTransDate() : this.transDate());
        if (currencyExchDate)
        {
            if (markupTable.isMarkupOfTypeCustVend())
            {
                currencyExchRate                = exchRate;
                currencyExchrateSecondary       = exchrateSecondary;
                currencyExchRatesTriangulation  = exchRatesTriangulation;
                _markupTrans.ExchRate_RU        = exchRate          ? exchRate          : ExchangeRateHelper::exchRate(_markupTrans.CurrencyCode, currencyExchDate);
                _markupTrans.ExchrateSecond_RU  = exchrateSecondary ? exchrateSecondary : ExchangeRateHelper::exchRateSecond(_markupTrans.CurrencyCode, currencyExchDate);
            }
            else
            {
                currencyExchRate                = 0;
                currencyExchrateSecondary       = 0;
                currencyExchRatesTriangulation  = UnknownNoYes::Unknown;
                _markupTrans.ExchRate_RU        = ExchangeRateHelper::exchRate(_markupTrans.CurrencyCode, currencyExchDate);
                _markupTrans.ExchrateSecond_RU  = ExchangeRateHelper::exchRateSecond(_markupTrans.CurrencyCode, currencyExchDate);
            }
            _markupTrans.CalculatedAmountMST_W = CurrencyExchangeHelper::mstAmount(_markupTrans.CalculatedAmount, _markupTrans.CurrencyCode, currencyExchDate, exchRatesTriangulation, exchRate, exchrateSecondary);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertJournalMarkupTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new markup that points to the posted journal or transaction record.
    /// </summary>
    /// <param name="_markupTrans">
    ///    The <c>MarkupTrans</c> record to be posted.
    /// </param>
    /// <param name="_destin">
    ///    The posted journal or transaction record to which the new <c>MarkupTrans</c> record points.
    /// </param>
    /// <param name="_calculatedAmount">
    ///    The calculated markup amount.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher number.
    /// </param>
    /// <param name="_transDate">
    ///    The last transaction date of the ledger voucher to which the <c>MarkupTrans</c> record belongs.
    /// </param>
    /// <param name="_posted">
    ///    The posted markup amount.
    /// </param>
    /// <param name="_originalMarkupTrans">
    ///    The original <c>MarkupTrans</c> record.
    /// </param>
    /// <returns>
    /// The new <c>MarkupTrans</c> record.
    /// </returns>
    protected MarkupTrans insertJournalMarkupTrans(MarkupTrans _markupTrans,
                                            Common _destin,
                                            AmountCur _calculatedAmount,
                                            Voucher _voucher = '',
                                            TransDate _transDate = dateNull(),
                                            AmountCur _posted = 0,
                                            MarkupTrans _originalMarkupTrans = null)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().insertJournalMarkupTrans())
        {
            MarkupTrans newMarkupTrans = this.initJournalMarkupTrans(_markupTrans, _destin, _calculatedAmount, _voucher, _transDate, _posted, _originalMarkupTrans);
        
            newMarkupTrans.insert();

            TMSFreightBillMarkupTrans  fbMarkup;

            // Modify Reference on Freight Bill - Markup Trans reference table
            switch (_markupTrans.TransTableId)
            {
                case  tableNum(SalesLine):
                    update_recordset fbMarkup
                    setting MarkupTransRecId = newMarkupTrans.RecId
                    where fbMarkup.MarkupTransRecId == _markupTrans.RecId;

                    break;

                default:
                    update_recordset fbMarkup
                    setting MarkupTransRecId = newMarkupTrans.RecId
                    where fbMarkup.MarkupTransRecId == _markupTrans.OrigRecId;

                    break;
            }

            // <GIN>
            if (TaxParameters::checkTaxParameters_IN())
            {
                MarkupTrans_IN::copyMarkupTransExtension(_markupTrans, newMarkupTrans);
            }
            // </GIN>

            // <GTE>
            if (TaxIntegrationUtils::isTransitDocumentEnabled())
            {
                if (SysDictTable::isTableMapped(tableNum(SalesPurchJournalLine), _destin.TableId))
                {
                    SalesPurchJournalLine salesPurchJournalLine = _destin;
                    TransitDocumentManager_IN::newManager().transit(_markupTrans, newMarkupTrans, salesPurchJournalLine.SalesPurchJournalLine::salesPurchJournalTable());
                }
            }
            // </GTE>

            // <GEERU>
            if (!countryRegion_RU || !this.parmIsProforma_RU())
            {
                // </GEERU>
                if (_markupTrans.TaxGroup && _markupTrans.TaxItemGroup)
                {
                    TaxUncommitted::resetSourceRecId(newMarkupTrans.TableId, newMarkupTrans.RecId, _markupTrans.RecId);
                    TaxTrans::resetSourceRecId(newMarkupTrans.TableId, newMarkupTrans.RecId, _markupTrans.RecId);

                    // <GMY>
                    if (TaxGSTFeatureChecker_MY::isCountryRegionMY())
                    {
                        TaxGSTTaxInformation_MY::resetSourceRecId(newMarkupTrans.TableId, newMarkupTrans.RecId, _markupTrans.RecId);
                    }
                    // </GMY>
                }
                // <GEERU>
            }
            // </GEERU>

            return newMarkupTrans;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initJournalMarkupTrans</Name>
				<Source><![CDATA[
    protected MarkupTrans initJournalMarkupTrans(MarkupTrans _markupTrans,
                                            Common _destin,
                                            AmountCur _calculatedAmount,
                                            Voucher _voucher = '',
                                            TransDate _transDate = dateNull(),
                                            AmountCur _posted = 0,
                                            MarkupTrans _originalMarkupTrans = null)
    {
        MarkupTrans     localMarkupTrans;

        localMarkupTrans                  = _markupTrans.data();
        if (MCROrderParameters::isCallCenterEnabledAndInUse())
        {
            // used the calculated amount for fixed misc. charges (see
            // header comment for more detail).
            if (localMarkupTrans.MarkupCategory == MarkupCategory::Fixed
                && localMarkupTrans.markupTable().MCRProRate)
            {
                localMarkupTrans.Value            = _calculatedAmount;
                localMarkupTrans.Value            = CurrencyExchange::roundWithRuleType(localMarkupTrans.Value,
                                                                                  localMarkupTrans.CurrencyCode,CurrencyRoundingRuleType::SalesOrder);
            }

            // save off the original record id's before replacing them with the destination ID's
            localMarkupTrans.MCRSavedRecID     = localMarkupTrans.TransRecId;
            localMarkupTrans.MCRSavedTableID   = localMarkupTrans.TransTableId;
        }
        localMarkupTrans.OrigTableId      = _markupTrans.TableId;
        localMarkupTrans.OrigRecId        = _markupTrans.RecId;
        localMarkupTrans.TransTableId     = _destin.TableId;
        localMarkupTrans.TransRecId       = _destin.RecId;
        localMarkupTrans.SourceDocumentLine = _markupTrans.SourceDocumentLine ? _markupTrans.SourceDocumentLine : _originalMarkupTrans.SourceDocumentLine;

        localMarkupTrans.CalculatedAmount = _calculatedAmount;
        localMarkupTrans.Voucher          = _voucher;
        localMarkupTrans.TransDate        = _transDate;
        localMarkupTrans.Posted           = _posted;
        localMarkupTrans.LineNum          = MarkupTrans::lastLineNum(_destin.TableId, _destin.RecId) + 1;

        if (localMarkupTrans.TransTableId == tableNum(VendInvoiceTrans)
            && markupTaxInCostPrice
            && localMarkupTrans.TaxAmount != markupTaxInCostPrice)
        {
            localMarkupTrans.TaxAmount = markupTaxInCostPrice;
        }

        // <GEERU>
        if (countryRegion_RU)
        {
            this.initMarkupTrans_RU(localMarkupTrans);
        }
        // </GEERU>

        // <GEEU>
        if (IntrastatParameters::isLegalEntityInEEU() || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoFR]))
        {
            this.calcAmountMST(localMarkupTrans);
        }
        // </GEEU>

        return localMarkupTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInclTax</Name>
				<Source><![CDATA[
    boolean isInclTax(Common _source)
    {
        PurchTable          purchTable;
        PurchLine           purchLine;
        PurchRFQTable       purchRFQTable;
        PurchRFQLine        purchRFQLine;
        PurchRFQCaseTable   purchRFQCaseTable;
        PurchRFQCaseLine    purchRFQCaseLine;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        VendInvoiceInfoSubTable vendInvoiceInfoSubTable;
        VendInvoiceInfoTable    vendInvoiceInfoTable;
        SalesTable          salesTable;
        SalesLine           salesLine;
        SalesQuotationTable salesQuotationTable;
        SalesQuotationLine  salesQuotationLine;
        // <GEERU>
        CustInvoiceTrans    custInvoiceTrans;
        CustInvoiceTable    custInvoiceTable;
        CustInvoiceLine     custInvoiceLine;
        CustInvoiceJour     custInvoiceJour;
        // </GEERU>

        switch (_source.TableId)
        {
            case (tableNum(SalesQuotationTable)) :
                taxModuleType = TaxModuleType::Sales;
                salesQuotationTable = _source;
                return salesQuotationTable.InclTax;

            case (tableNum(SalesQuotationLine)) :
                taxModuleType = TaxModuleType::Sales;
                salesQuotationLine = _source;
                return salesQuotationLine.salesQuotationTable().InclTax;

            case (tableNum(SalesTable)) :
                taxModuleType = TaxModuleType::SalesInvoice;
                salesTable = _source;
                return salesTable.InclTax;

            case (tableNum(SalesLine)) :
                taxModuleType = TaxModuleType::SalesInvoice;
                salesLine = _source;
                return salesLine.salesTable().InclTax;

            case (tableNum(CustInvoiceTrans)) :
                if (countryRegion_RU)
                {
                    taxModuleType = TaxModuleType::SalesInvoice;
                    custInvoiceTrans = _source;
                    return custInvoiceTrans.custInvoiceJour().InclTax;
                }
                break;

            case (tableNum(CustInvoiceTable)) :
                custInvoiceTable = _source;
                taxModuleType = TaxModuleType::FreeTxtInvoice;
                return custInvoiceTable.InclTax;

            case (tableNum(CustInvoiceJour)) :
                custInvoiceJour = _source;
                taxModuleType = TaxModuleType::FreeTxtInvoice;
                return custInvoiceJour.InclTax;

            case (tableNum(CustInvoiceLine)) :
                custInvoiceLine = _source;
                taxModuleType = TaxModuleType::FreeTxtInvoice;
                return custInvoiceLine.custInvoiceTable().InclTax;

            case (tableNum(PurchTable)) :
                taxModuleType = TaxModuleType::PurchInvoice;
                purchTable = _source;
                return purchTable.InclTax;

            case (tableNum(PurchLine)) :
                taxModuleType = TaxModuleType::PurchInvoice;
                purchLine = _source;
                return purchLine.purchTable().InclTax;

            case (tableNum(PurchRFQTable)) :
                taxModuleType = TaxModuleType::PurchInvoice;
                purchRFQTable = _source;
                return purchRFQTable.InclTax;

            case (tableNum(PurchRFQLine)) :
                taxModuleType = TaxModuleType::PurchInvoice;
                purchRFQLine = _source;
                return purchRFQLine.purchRFQTable().InclTax;

            case (tableNum(PurchRFQCaseTable)) :
                taxModuleType = TaxModuleType::PurchInvoice;
                purchRFQCaseTable = _source;
                return purchRFQCaseTable.InclTax;

            case (tableNum(PurchRFQCaseLine)) :
                taxModuleType = TaxModuleType::PurchInvoice;
                purchRFQCaseLine = _source;
                return purchRFQCaseLine.purchRFQCaseTable().InclTax;

            case (tableNum(VendInvoiceInfoLine)) :
                taxModuleType = TaxModuleType::PurchInvoice;
                vendInvoiceInfoLine = _source;
                return vendInvoiceInfoLine.VendDocumentLineMap::includeTax();

            case (tableNum(VendInvoiceInfoSubTable)) :
                taxModuleType = TaxModuleType::PurchInvoice;
                vendInvoiceInfoSubTable = _source;
                return vendInvoiceInfoSubTable.isInclTax();

            case (tableNum(VendInvoiceInfoTable)) :
                taxModuleType = TaxModuleType::PurchInvoice;
                vendInvoiceInfoTable = _source;
                return vendInvoiceInfoTable.isInclTax();
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemLedgerBondLog_RU</Name>
				<Source><![CDATA[
    public LedgerBondLog_RU itemLedgerBondLog_RU()
    {
        return itemLedgerBondLog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupAmountByClassification_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sums the markup amounts grouped by their classification.
    /// </summary>
    /// <param name="_markupTrans">
    /// The <c>MarkupTrans</c> record to determine the markup classification.
    /// </param>
    /// <param name="_markupAmount">
    /// The amount of the markup.
    /// </param>
    void markupAmountByClassification_BR(MarkupTrans    _markupTrans,
                                      MarkupAmount      _markupAmount)
    {
        MarkupTable     markupTable = _markupTrans.markupTable();
        MarkupAmount    amount;

        if (markupAmountByClassification_BR.exists(markupTable.MarkupClassification_BR))
        {
            amount = markupAmountByClassification_BR.lookup(markupTable.MarkupClassification_BR);
        }

        markupAmountByClassification_BR.insert(markupTable.MarkupClassification_BR, amount + _markupAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupAmountMap_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns a map with markup amounts by <c>MarkupClassification_BR</c>
    /// </summary>
    /// <returns>
    ///     The markup amounts map
    /// </returns>

    public Map markupAmountMap_BR()
    {
        return markupAmountMap_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupBondRefMap_RU</Name>
				<Source><![CDATA[
    Map markupBondRefMap_RU()
    {
        return markupBondRefMap_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupCustVend</Name>
				<Source><![CDATA[
    public MarkupAmount markupCustVend()
    {
        return markupCustVend;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupCustVendLocked_RU</Name>
				<Source><![CDATA[
    protected boolean markupCustVendLocked_RU()
    {
        PurchLine           purchLine;
        PurchParmLine       purchParmLine;
        VendInvoiceTrans    vendInvoiceTrans;
        SalesLine           salesLine;
        SalesParmLine       salesParmLine;
        CustInvoiceTrans    custInvoiceTrans;
        VendInvoiceInfoLine vendInvoiceInfoLine;

        switch (source.TableId)
        {
            case tableNum(PurchLine):
                purchLine = source;
                return purchLine.inventDim().inventProfile_RU().LockMarkupCustVend;
            case tableNum(PurchParmLine):
                purchParmLine = source;
                return purchParmLine.inventDim().inventProfile_RU().LockMarkupCustVend;
            case tableNum(VendInvoiceTrans):
                vendInvoiceTrans = source;
                return vendInvoiceTrans.inventDim().inventProfile_RU().LockMarkupCustVend;
            case tableNum(SalesLine):
                salesLine = source;
                return salesLine.inventDim().inventProfile_RU().LockMarkupCustVend;
            case tableNum(SalesParmLine):
                salesParmLine = source;
                return salesParmLine.inventDim().inventProfile_RU().LockMarkupCustVend;
            case tableNum(CustInvoiceTrans):
                custInvoiceTrans = source;
                return custInvoiceTrans.inventDim().inventProfile_RU().LockMarkupCustVend;
            case tableNum(VendInvoiceInfoLine):
                vendInvoiceInfoLine = source;
                return vendInvoiceInfoLine.inventDim().inventProfile_RU().LockMarkupCustVend;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupFreight_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves freight type markup amount.
    /// </summary>
    /// <returns>
    /// The freight type markup amount.
    /// </returns>
    MarkupAmount markupFreight_BR()
    {
        if (markupAmountByClassification_BR.exists(MarkupClassification_BR::Freight))
        {
            return markupAmountByClassification_BR.lookup(MarkupClassification_BR::Freight);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupInsurance_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves insurance type markup amount.
    /// </summary>
    /// <returns>
    /// The insurance type markup amount.
    /// </returns>
    MarkupAmount markupInsurance_BR()
    {
        if (markupAmountByClassification_BR.exists(MarkupClassification_BR::Insurance))
        {
            return markupAmountByClassification_BR.lookup(MarkupClassification_BR::Insurance);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupItem</Name>
				<Source><![CDATA[
    public MarkupAmount markupItem()
    {
        return markupItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupItemLedgerMap</Name>
				<Source><![CDATA[
    public Map markupItemLedgerMap()
    {
        return markupItemLedgerMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupItemLedgerMap_RU</Name>
				<Source><![CDATA[
    public Map markupItemLedgerMap_RU()
    {
        return markupItemLedgerMap_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupOther_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves other types markup amount.
    /// </summary>
    /// <returns>
    /// The other types markup amount.
    /// </returns>
    MarkupAmount markupOther_BR()
    {
        if (markupAmountByClassification_BR.exists(MarkupClassification_BR::Others))
        {
            return markupAmountByClassification_BR.lookup(MarkupClassification_BR::Others);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupOtherCharges</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the sum of miscellaneous charges that are not charged to the vendor.
    /// </summary>
    /// <returns>
    ///    The sum of other miscellaneous charges converted to the document currency.
    /// </returns>
    /// <remarks>
    ///    Other miscellaneous charges include miscellaneous charges with a <c>Credit</c> type of Ledger when
    ///    the <c>Debit</c> type is not Customer or Vendor.
    /// </remarks>
    public MarkupAmount markupOtherCharges()
    {
        return markupOtherCharges;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupSiscomex_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves SISCOMEX type markup amount.
    /// </summary>
    /// <returns>
    /// The SISCOMEX type markup amount.
    /// </returns>
    MarkupAmount markupSiscomex_BR()
    {
        if (markupAmountByClassification_BR.exists(MarkupClassification_BR::SISCOMEX))
        {
            return markupAmountByClassification_BR.lookup(MarkupClassification_BR::SISCOMEX);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupTax_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the markup tax.
    /// </summary>
    /// <returns>
    /// Tax amount.
    /// </returns>
    public TaxAmountCur markupTax_W()
    {
        return markupTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupTaxTotal</Name>
				<Source><![CDATA[
    public TaxAmountCur markupTaxTotal()
    {
        return markupTaxTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrAllocateInstallmentMarkupType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allocates installment markup ammounts.
    /// </summary>
    /// <param name="_markupTrans">
    /// A record to use for determining how to process the markup value.
    /// </param>
    /// <param name="_markupAmount">
    /// The Value of markup amount to include.
    /// </param>
    protected void mcrAllocateInstallmentMarkupType(MarkupTrans _markupTrans, MarkupAmount _markupAmount)
    {
        MarkupTable markupTable;

        markupTable = _markupTrans.markupTable();
        switch (markupTable.CustType)
        {
            case MarkupType::Item:
                markUpInstallItem += _markupAmount;
                break;
            case MarkupType::CustVend:
                markupInstallCustVend += _markupAmount;
                break;
        }

        switch (markupTable.VendType)
        {
            case MarkupType::Item:
                markUpInstallItem -= _markupAmount;
                break;
            case MarkupType::CustVend:
                markupInstallCustVend -= _markupAmount;
                break;
        }

        if (markupTable.CustType == MarkupType::CustVend)
        {
            if (_markupTrans.MCRCouponMarkup)
            {
                markupInstallCoupon += _markupAmount;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrInitInstallElgibleMarkUpList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the record list with the appropriate <c>MarkupTrans</c> records.
    /// </summary>
    public void mcrInitInstallElgibleMarkUpList()
    {
        markupInstallEligibleList = new RecordSortedList(tableNum(MarkupTrans));
        markupInstallEligibleList.sortOrder(fieldNum(MarkupTrans, RecId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMarkupCoupon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the markup amount of the coupon.
    /// </summary>
    /// <returns>
    /// The <c>MarkupAmount</c> of the coupon.
    /// </returns>
    public MarkupAmount mcrMarkupCoupon()
    {
        return markupCoupon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMarkupInstallEligibleList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the record list containing installment
    /// eligible <c>MarkupTrans</c> records.
    /// </summary>
    /// <returns>
    /// The record list containing installment
    /// eligible <c>MarkupTrans</c> records.
    /// </returns>
    public RecordSortedList  mcrMarkupInstallEligibleList()
    {
        return markupInstallEligibleList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMarkupInstallmentCoupon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the markup amount of the installment coupon.
    /// </summary>
    /// <returns>
    /// The markup amount of the insallment coupon.
    /// </returns>
    public MarkupAmount mcrMarkupInstallmentCoupon()
    {
        return markupInstallCoupon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMarkupInstallmentCustVend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the markup amount of the installment order for a customer or vendor.
    /// </summary>
    /// <returns>
    /// The markup amount of the installment order for a customer or vendor.
    /// </returns>
    public MarkupAmount mcrMarkupInstallmentCustVend()
    {
        return markupInstallCustVend;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMarkupInstallmentPostage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the markup amount of postage on an insallment order.
    /// </summary>
    /// <returns>
    /// The markup amount of postage on an installment order.
    /// </returns>
    public MarkupAmount mcrMarkupInstallmentPostage()
    {
        return markupInstallPostage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMarkupInstallmentRestocking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the markup amount of the restocking fee for an installment order.
    /// </summary>
    /// <returns>
    /// The markup amount of the restocking fee for an installment order.
    /// </returns>
    public MarkupAmount mcrMarkupInstallmentRestocking()
    {
        return markupInstallRestocking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMarkupInstallmentReturnPostage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the markup amount of the return postage for an installment order
    /// </summary>
    /// <returns>
    /// The markup amount of the return postage for an installment order.
    /// </returns>
    public MarkupAmount mcrMarkupInstallmentReturnPostage()
    {
        return markupInstallReturnPostage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMarkupInstallmentSurcharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the markup amount before tax for an installment order.
    /// </summary>
    /// <returns>
    /// The markup amount before tax for an installment order.
    /// </returns>
    public MarkupAmount mcrMarkupInstallmentSurcharge()
    {
        return markupInstallSurcharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMarkupInstallmentTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the amount of tax on an installment order.
    /// </summary>
    /// <returns>
    /// The amount of tax on an installment order.
    /// </returns>
    public TaxAmountCur  mcrMarkupInstallmentTax()
    {
        return markupInstallTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMarkupPostage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the markup amount of postage.
    /// </summary>
    /// <returns>
    /// The markup amount of postage.
    /// </returns>
    public MarkupAmount mcrMarkupPostage()
    {
        return markupPostage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMarkupRestocking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the markup amount of the restocking fee for an order.
    /// </summary>
    /// <returns>
    /// The markup amount of the restocking fee for an order.
    /// </returns>
    public MarkupAmount mcrMarkupRestocking()
    {
        return markupRestocking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMarkupReturnPostage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the markup amount of the return postage for an order.
    /// </summary>
    /// <returns>
    /// The markup amount of the return postage for an order.
    /// </returns>
    public MarkupAmount mcrMarkupReturnPostage()
    {
        return markupReturnPostage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMarkupSurcharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the markup amount before tax for an order.
    /// </summary>
    /// <returns>
    /// The markup amount before tax for an order.
    /// </returns>
    public MarkupAmount mcrMarkupSurcharge()
    {
        return markupSurcharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPostJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs setup logic to post the <c>MarkupTrans</c> journal.
    /// </summary>
    /// <param name="_qty">
    /// The quantity for which to post the journal.
    /// </param>
    /// <param name="_value">
    /// The value for which to post the journal.
    /// </param>
    /// <param name="_source">
    /// The source for which to post the journal.
    /// </param>
    /// <param name="_dimensionDefault">
    /// The default dimension for which to post the journal.
    /// </param>
    /// <param name="_destin">
    /// The destination of the journal post; optional.
    /// </param>
    /// <param name="_interCompanyValue">
    /// The intercompany value for which to post the journal; optional.
    /// </param>
    /// <param name="_absoluteValue">
    /// The absolute value of the journal post; optional.
    /// </param>
    /// <param name="_parmId">
    /// The <c>ParmId</c> object for which to post the journal; optional.
    /// </param>
    /// <param name="_parmMCRTableRefId">
    /// The <c>TradeLineRefId</c> object for which to post the journal; optional.
    /// </param>
    public void mcrPostJournal(Qty              _qty,
                            AmountCur           _value,
                            Common              _source,
                            DimensionDefault    _dimensionDefault,
                            Common              _destin = _destin,
                            AmountCur           _interCompanyValue = 0,
                            AmountCur           _absoluteValue = 0,
                            ParmId              _parmId = '',
                            TradeLineRefId      _parmMCRTableRefId = '')
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().mcrPostJournal())
        {
            dimensionDefault = _dimensionDefault;
            source = _source;
            destin = _destin;
            postJournal = true;

            this.calc(_qty, _value, source, DocumentStatus::None, _interCompanyValue, '', // invoice id
                        _absoluteValue, _parmId, _parmMCRTableRefId);

            postJournal = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrProforma</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs setup logic to post the proforma <c>MarkupTrans</c> journal.
    /// </summary>
    /// <param name="_qty">
    /// The quantity for which to post the journal.
    /// </param>
    /// <param name="_value">
    /// The value for which to post the journal.
    /// </param>
    /// <param name="_source">
    /// The source for which to post the journal.
    /// </param>
    /// <param name="_destin">
    /// The destination of the journal post; optional.
    /// </param>
    /// <param name="_absoluteValue">
    /// The absolute value of the journal post; optional.
    /// </param>
    /// <param name="_parmId">
    /// The <c>ParmId</c> object for which to post the journal; optional.
    /// </param>
    public void mcrProforma(Qty         _qty,
                            AmountCur   _value,
                            Common      _source,
                            Common      _destin = _destin,
                            AmountCur   _absoluteValue = 0,
                            ParmId      _parmId = '')
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().mcrProforma())
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
            {
                source = _source;
                destin = _destin;
                isProforma = true;

                this.calc(_qty, _value, source, DocumentStatus::None, 0, '', _absoluteValue, _parmId);

                isProforma = false;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSetInstallmentMarkUpValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets up the installment order markup values.
    /// </summary>
    /// <param name="_markupTrans">
    /// The <c>MarkupTrans</c> record for which this method sets up installment order values.
    /// </param>
    /// <param name="_markUpInstallmentAmount">
    /// The markup amount to be set on the <c>MarkupTrans</c> record.
    /// </param>
    public void mcrSetInstallmentMarkUpValues(MarkupTrans _markupTrans, MarkupAmount _markUpInstallmentAmount)
    {
        if (tax)
        {
            markupInstallTax += tax.totalTaxAmountSingleLine(_markupTrans.TableId, _markupTrans.RecId);
            markupInstallTaxInCostPrice += markupTaxInCostPrice;
        }
        markupInstallEligibleList.ins(_markupTrans);
        this.mcrAllocateInstallmentMarkupType(_markupTrans, _markUpInstallmentAmount + markupTaxInCostPrice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(CurrencyCode _currencyCode)
    {
        currencyCode            = _currencyCode;
        exchRate                = 0;
        exchrateSecondary       = 0;
        exchRatesTriangulation  = UnknownNoYes::Unknown;
        transDate               = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());


        mcrCallCenterEnabled = MCROrderParameters::isCallCenterEnabledAndInUse();
        configPublicSectorEnabled = isConfigurationkeyEnabled(configurationKeyNum(PublicSector));


        // <GIN>
        countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        // </GIN>
        // <GEERU>
        // <GEEU>
        countryRegion_EE = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll);
        if (!countryRegion_EE)
        {
            countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        }

        countryRegion_EEU = IntrastatParameters::isLegalEntityInEEU();
        countryRegion_FR = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoFR]);

        // </GEEU>
        if (countryRegion_RU)
        {
            this.parmAllowPosting_RU(true);
            this.parmInitTaxAmount_RU(true);
        }
        // </GEERU>

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.postNew_BR(_currencyCode);
        }
        // </GBR>

        if (AutoChargesSetupSequenceCompoundFeature::instance().IsEnabled())
        {
            markupBaseValueCalcEngineProvider = MarkupBaseValueCalcEngineProvider::construct();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowPosting_RU</Name>
				<Source><![CDATA[
    public boolean parmAllowPosting_RU(boolean _allowPosting = allowPosting)
    {
        allowPosting = _allowPosting;

        return allowPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimParameters</Name>
				<Source><![CDATA[
    public static InventDim parmInventDimParameters(InventDim _inventDimParameters = inventDimParameters)
    {
        inventDimParameters = _inventDimParameters;

        return inventDimParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreditNote_IN</Name>
				<Source><![CDATA[
    public NoYes parmCreditNote_IN(NoYes _creditNote = NoYes::No)
    {
        creditNote = _creditNote;

        return creditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustInvoiceAccount_RU</Name>
				<Source><![CDATA[
    public CustInvoiceAccount parmCustInvoiceAccount_RU(CustInvoiceAccount _custInvoiceAccount = custInvoiceAccount)
    {
        custInvoiceAccount = _custInvoiceAccount;

        return custInvoiceAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocumentCurrencyCode</Name>
				<Source><![CDATA[
    public CurrencyCode parmDocumentCurrencyCode(CurrencyCode _documentCurrencyCode = documentCurrencyCode)
    {
        documentCurrencyCode = _documentCurrencyCode;

        return documentCurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocumentCurrencyExch</Name>
				<Source><![CDATA[
    public CurrencyExchangeHelper parmDocumentCurrencyExch(CurrencyExchangeHelper _documentCurrencyExchange = documentCurrencyExchange)
    {
        documentCurrencyExchange = _documentCurrencyExchange;

        return documentCurrencyExchange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchRate</Name>
				<Source><![CDATA[
    public void parmExchRate(ExchRate _exchRate, ExchrateSecondary _exchrateSecondary, ExchRatesTriangulation _exchRatesTriangulation)
    {
        exchRate                = _exchRate;
        exchrateSecondary       = _exchrateSecondary;
        exchRatesTriangulation  = _exchRatesTriangulation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReportingCurrencyExchangeRate</Name>
				<Source><![CDATA[
    internal void setReportingCurrencyExchangeRate(ExchRate _reportingCurrencyExchangeRate)
    {
        reportingCurrencyExchangeRate = _reportingCurrencyExchangeRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGoodsInRouteId_RU</Name>
				<Source><![CDATA[
    public GoodsInRouteId_RU parmGoodsInRouteId_RU(GoodsInRouteId_RU _goodsInRouteId = goodsInRouteId)
    {
        goodsInRouteId = _goodsInRouteId;

        return goodsInRouteId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInitMarkupTrans_RU</Name>
				<Source><![CDATA[
    public boolean parmInitMarkupTrans_RU(boolean _initMarkupTrans = initMarkupTrans)
    {
        initMarkupTrans = _initMarkupTrans;

        return initMarkupTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInitTaxAmount_RU</Name>
				<Source><![CDATA[
    public boolean parmInitTaxAmount_RU(boolean _initTaxAmount = initTaxAmount)
    {
        initTaxAmount = _initTaxAmount;

        return initTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoicePostingType_RU</Name>
				<Source><![CDATA[
    public SalesInvoicePostingType_RU parmInvoicePostingType_RU(SalesInvoicePostingType_RU _invoicePostingType = invoicePostingType)
    {
        invoicePostingType = _invoicePostingType;

        return invoicePostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsProforma_RU</Name>
				<Source><![CDATA[
    public boolean parmIsProforma_RU(boolean _isProforma = isProforma)
    {
        isProforma = _isProforma;

        return isProforma;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkupCustVendNegative_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Returns a negative part of total amount.
    /// </summary>
    /// <returns>
    ///   A negative markup amount.
    /// </returns>
    public MarkupAmount parmMarkupCustVendNegative_RU()
    {
        return markUpCustVendNegative;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkupCustVendPositive_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Returns a positive part of total amount.
    /// </summary>
    /// <returns>
    ///   A positive markup amount.
    /// </returns>
    public MarkupAmount parmMarkupCustVendPositive_RU()
    {
        return markUpCustVendPositive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkupEnumerable</Name>
				<Source><![CDATA[
    public TradeTotalsIMarkupEnumerableProvider parmMarkupEnumerable(TradeTotalsIMarkupEnumerableProvider _markupEnumerableProvider = markupEnumerableProvider)
    {
        markupEnumerableProvider = _markupEnumerableProvider;

        if (!markupEnumerableProvider)
        {
            markupEnumerableProvider = this.createMarkupEnumerable();
        }

        return markupEnumerableProvider;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOnlyIncludeConnected</Name>
				<Source><![CDATA[
    public boolean parmOnlyIncludeConnected(boolean _onlyIncludeConnected = onlyIncludeConnected)
    {
        onlyIncludeConnected = _onlyIncludeConnected;

        return onlyIncludeConnected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostNegativeMarkupAsCorrection_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets or sets ptoperty: is the negative amout is posted with corection sign.
    /// </summary>
    /// <param name="_value">
    ///   new value.
    /// </param>
    /// <returns>
    ///  Current value.
    /// </returns>
    public boolean parmPostNegativeMarkupAsCorrection_RU(boolean _value = postNegativeMarkupAsCorrection)
    {
        postNegativeMarkupAsCorrection = _value;
        return postNegativeMarkupAsCorrection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransIds</Name>
				<Source><![CDATA[
    public void parmTransIds(RefTableId _tableId, RefRecId _recId)
    {
        transTableId = _tableId;
        transRecId   = _recId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAllocateMarkupType_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allocates the charges type.
    /// </summary>
    /// <param name="_markupTrans">
    /// The charge transaction.
    /// </param>
    /// <param name="_markupAmount">
    /// The charge amount.
    /// </param>
    protected void postAllocateMarkupType_BR(MarkupTrans _markupTrans, MarkupAmount _markupAmount)
    {
        MarkupTable     markupTable = _markupTrans.markupTable();

        if (markupTable.isMarkupOfTypeItemLedger())
        {
            if (markupTable.CustType == MarkupType::Item)
            {
                if (tax)
                {
                    _markupAmount  += this.determineTotalTaxAmount(_markupTrans);
                }
            }
        }

        switch (markupTable.CustType)
        {
            case MarkupType::Item :
                if (tax)
                {
                    markupItem  -= this.determineTotalIncludedTaxAmount_BR(_markupTrans);
                    markupItem  += this.determineTotalTaxAmount(_markupTrans);
                }
                break;

            case MarkupType::CustVend :
                if (tax)
                {
                    _markupAmount -= tax.taxInCostPrice(_markupTrans.TableId, _markupTrans.RecId);
                }
                this.markupAmountByClassification_BR(_markupTrans, _markupAmount);
                break;
        }

        switch (markupTable.VendType)
        {
            case MarkupType::CustVend :
                if (tax)
                {
                    _markupAmount -= tax.taxInCostPrice(_markupTrans.TableId, _markupTrans.RecId);
                }
                this.markupAmountByClassification_BR(_markupTrans, _markupAmount);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postChargeAndCustomerLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the markup on the charge account and offsets the stock variation account
    /// if debit type is item and a credit ledger dimension is defined.
    /// </summary>
    /// <param name="_markupTable">
    /// The <c>MarkupTable</c> record.
    /// </param>
    /// <param name="_markupTrans">
    /// The <c>MarkupTrans</c> record.
    /// </param>
    /// <param name="_postAmount">
    /// The amount to post.
    /// </param>
    /// <param name="_exchangeRateHelper">
    /// A <c>CurrencyExchangeHelper</c> object.
    /// </param>
    protected void postChargeAndCustomerLedger(
        MarkupTable             _markupTable,
        MarkupTrans             _markupTrans,
        AmountCur               _postAmount,
        CurrencyExchangeHelper  _exchangeRateHelper
    )
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().postChargeAndCustomerLedger())
        {
            LedgerVoucherTransObject    ledgerVoucherTransObject;
            InventMovement              inventMovement;
            LedgerDimensionAccount      mergedLedgerDimension;
            // <GEERU>
            LedgerBondClient_RU         ledgerBondClient;
            // </GEERU>

            if (_markupTable.CustType == MarkupType::Item && _markupTable.parmCustomerLedgerDimension())
            {
                inventMovement = _markupTrans.inventMovement();

                if (inventMovement && inventMovement.mustBeBookedCharge())
                {
                    DimensionDefault dimensionDefaultCust = this.getDimensionDefaultCust();

                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        ledgerBondClient = ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
                    }
                    // </GEERU>

                    mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_markupTable.CustomerLedgerDimension, dimensionDefaultCust);

                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                    ledgerVoucher.findLedgerVoucherObject(),
                                                    _markupTable.CustPosting,
                                                    mergedLedgerDimension,
                                                    _markupTrans.CurrencyCode,
                                                    _postAmount,
                                                    _exchangeRateHelper);
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        ledgerVoucherTransObject.parmIsCorrection(NoYes::Yes);
                    }
                    // </GEERU>
                    ledgerVoucher.addTrans(ledgerVoucherTransObject);

                    mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(inventMovement.accountCharge(), dimensionDefaultCust);

                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                    ledgerVoucher.findLedgerVoucherObject(),
                                                    inventMovement.postingCharge(),
                                                    mergedLedgerDimension,
                                                    _markupTrans.CurrencyCode,
                                                   -_postAmount,
                                                    _exchangeRateHelper);
                    ledgerVoucherTransObject.parmIsCorrection(NoYes::Yes);
                    ledgerVoucher.addTrans(ledgerVoucherTransObject);
                    // <GEERU>
                    if (ledgerBondClient)
                    {
                        ledgerBondClient.bondLast2();
                    }
                    // </GEERU>
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postChargeAndVendorLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the markup on the charge account and offsets the stock variation account
    /// if credit type is item and a debit ledger dimension is defined.
    /// </summary>
    /// <param name="_markupTable">
    /// The <c>MarkupTable</c> record.
    /// </param>
    /// <param name="_markupTrans">
    /// The <c>MarkupTrans</c> record.
    /// </param>
    /// <param name="_postAmount">
    /// The amount to post.
    /// </param>
    /// <param name="_exchangeRateHelper">
    /// A <c>CurrencyExchangeHelper</c> object.
    /// </param>
    protected void postChargeAndVendorLedger(
        MarkupTable             _markupTable,
        MarkupTrans             _markupTrans,
        AmountCur               _postAmount,
        CurrencyExchangeHelper  _exchangeRateHelper)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().postChargeAndVendorLedger())
        {
            LedgerVoucherTransObject    ledgerVoucherTransObject;
            InventMovement              inventMovement;
            LedgerDimensionAccount      mergedLedgerDimension;
            // <GEERU>
            LedgerBondClient_RU         ledgerBondClient;
            // </GEERU>

            if (_markupTable.VendType == MarkupType::Item && _markupTable.parmVendorLedgerDimension())
            {
                inventMovement = _markupTrans.inventMovement();

                if (inventMovement && inventMovement.mustBeBookedCharge())
                {
                    DimensionDefault dimensionDefaultVend = this.getDimensionDefaultVend();

                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        ledgerBondClient = ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
                    }
                    // </GEERU>
                    mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_markupTable.VendorLedgerDimension, dimensionDefaultVend);

                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                    ledgerVoucher.findLedgerVoucherObject(),
                                                    _markupTable.VendPosting,
                                                    mergedLedgerDimension,
                                                    _markupTrans.CurrencyCode,
                                                   -_postAmount,
                                                    _exchangeRateHelper);
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        ledgerVoucherTransObject.parmIsCorrection(NoYes::Yes);
                    }
                    // </GEERU>
                    ledgerVoucher.addTrans(ledgerVoucherTransObject);

                    mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(inventMovement.accountCharge(), dimensionDefaultVend);

                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                    ledgerVoucher.findLedgerVoucherObject(),
                                                    inventMovement.postingCharge(),
                                                    mergedLedgerDimension,
                                                    _markupTrans.CurrencyCode,
                                                    _postAmount,
                                                    _exchangeRateHelper);
                    ledgerVoucherTransObject.parmIsCorrection(NoYes::Yes);
                    ledgerVoucher.addTrans(ledgerVoucherTransObject);
                    // <GEERU>
                    if (ledgerBondClient)
                    {
                        ledgerBondClient.bondLast2();
                    }
                    // </GEERU>
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInvoice</Name>
				<Source><![CDATA[
    public void postInvoice(Qty             _qty,
                            AmountCur       _value,
                            Common          _source,
                            LedgerVoucher   _ledgerVoucher,
                            DimensionDefault _defaultDimension,
                            Common          _destin            = _destin,
                            AmountCur       _interCompanyValue = 0,
                            InvoiceId       _invoiceId         = '',
                            boolean         _createPostedOnly = false
                            , AmountCur       _absoluteValue      = 0,
                            ParmId          _parmId             = '',
                            TradeLineRefId  _parmMCRTableRefId   = ''
                            )
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().postInvoice())
        {
            ledgerVoucher   = _ledgerVoucher;
            dimensionDefault = _defaultDimension;
            destin          = _destin;
            createPostedOnly = _createPostedOnly;

            postInvoice     = true;

            // <GEERU>
            if (countryRegion_RU
                && initMarkupTrans)
            {
                itemLedgerBondLog = conNull();
            }
            // </GEERU>
            this.calc(_qty,
                      _value,
                      _source,
                      DocumentStatus::None,
                      _interCompanyValue,
                      _invoiceId,
                      _absoluteValue,
                      _parmId,
                      _parmMCRTableRefId);

            postInvoice     = false;

            if (_source.TableId == tableNum(SalesTable) && salesTotalsMap != null && salesTotalsMap.exists(_source.RecId))
            {
                salesTotalsMap.remove(_source.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInvoiceAmount</Name>
				<Source><![CDATA[
    protected void postInvoiceAmount(
        MarkupTrans                 markupTrans,
        AmountCur                   postAmount,
        MarkupTrans                 newMarkupTrans)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().postInvoiceAmount())
        {
            MarkupTable                 markupTable = markupTrans.markupTable();
            ExchRate                    currencyExchRate;
            ExchrateSecondary           currencyExchrateSecondary;
            ExchRatesTriangulation      currencyExchRatesTriangulation;
            ExchRate                    currencyExchRateReporting;
            CurrencyExchangeHelper      exchangeRateHelperCust;
            CurrencyExchangeHelper      exchangeRateHelperVend;
            LedgerVoucherTransObject    ledgerVoucherTransObject;

            // <GEERU>
            #define.LogLengthPostingLedgerLedger(2)
            TaxAmountCur                amountTaxPosted;
            LedgerBondClient_RU         ledgerBondClient;
            MarkupCustPosting_RU        markupCustPosting;

            if (countryRegion_RU)
            {
                if (allowPosting)
                {
                    ledgerBondClient = ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();

                    if (ledgerBondClient)
                    {
                        ledgerBondClient.addNewLogObject();
                    }
                }
                if (markupTable.ModuleType == MarkupModuleType::Cust &&
                    TaxParameters::find().TaxSpecPosting_RU == NoYes::Yes)
                {
                    amountTaxPosted = - markupTax;
                }
            }
            // </GEERU>

            if (markupTable.isMarkupOfTypeCustVend())
            {
                currencyExchRate                = exchRate;
                currencyExchrateSecondary       = exchrateSecondary;
                currencyExchRatesTriangulation  = exchRatesTriangulation;
                currencyExchRateReporting = reportingCurrencyExchangeRate;
            }
            // <GBR>
            else if (BrazilParameters::isEnabled() && markupTable.CustType == MarkupType::LedgerAccount)
            {
                currencyExchRate    = exchRate;
            }
            // </GBR>
            else
            {
                currencyExchRate                = 0;
                currencyExchrateSecondary       = 0;
                currencyExchRatesTriangulation  = UnknownNoYes::Unknown;
                currencyExchRateReporting = 0;
            }

            if (markupTable.CustType == MarkupType::LedgerAccount || markupTable.CustType == MarkupType::Item)
            {
                exchangeRateHelperCust = this.getCurrencyExchangeHelperCust(transDate, currencyExchRate, currencyExchrateSecondary, currencyExchRateReporting);
            }

            if (markupTable.CustType == MarkupType::LedgerAccount)
            {
                DimensionDefault dimensionDefaultCust = this.getDimensionDefaultCust();

                // <GEERU>
                if (countryRegion_RU)
                {
                    if (allowPosting && postAmount)
                    {
                        if (markupTable.UseCustPostingTypeTransit_RU == NoYes::Yes &&
                            custInvoiceAccount &&
                            invoicePostingType == SalesInvoicePostingType_RU::GoodsInRoute)
                        {
                            markupCustPosting = MarkupCustPosting_RU::findLedger(MarkupCustPostingType_RU::Transit,
                                                                                 custInvoiceAccount,
                                                                                 markupTable.MarkupCode);
                            if (! markupCustPosting.LedgerDimension)
                            {
                                throw error(strFmt("@GLS114804", markupTable.MarkupCode));
                            }

                            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                ledgerVoucher.findLedgerVoucherObject(),
                                                                markupCustPosting.LedgerPostingType,
                                                                LedgerDimensionFacade::serviceCreateLedgerDimension(markupCustPosting.LedgerDimension, dimensionDefaultCust),
                                                                markupTrans.CurrencyCode,
                                                                postAmount + amountTaxPosted,
                                                                exchangeRateHelperCust);

                            ledgerVoucher.addTrans(ledgerVoucherTransObject);
                        }
                        else
                        if (TaxParameters::find().TaxSpecPosting_RU &&
                            markupTable.VendType == MarkupType::CustVend &&
                            custInvoiceAccount)
                        {
                            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                ledgerVoucher.findLedgerVoucherObject(),
                                                                markupTable.CustPosting,
                                                                LedgerDimensionFacade::serviceCreateLedgerDimension(markupTable.CustomerLedgerDimension, dimensionDefaultCust),
                                                                markupTrans.CurrencyCode,
                                                                postAmount,
                                                                exchangeRateHelperCust);

                            ledgerVoucher.addTrans(ledgerVoucherTransObject);

                            markupCustPosting = MarkupCustPosting_RU::findLedger(MarkupCustPostingType_RU::SalesConsumption,
                                                                                    custInvoiceAccount,
                                                                                    markupTable.MarkupCode);
                            if (! markupCustPosting.LedgerDimension)
                            {
                                throw error(strFmt("@GLS114839", markupTable.MarkupCode));
                            }

                            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                ledgerVoucher.findLedgerVoucherObject(),
                                                                LedgerPostingType::SalesConsump,
                                                                LedgerDimensionFacade::serviceCreateLedgerDimension(markupCustPosting.LedgerDimension, dimensionDefaultCust),
                                                                markupTrans.CurrencyCode,
                                                                -postAmount,
                                                                exchangeRateHelperCust);

                            ledgerVoucher.addTrans(ledgerVoucherTransObject);

                            ledgerVoucher.bondLast2_RU();

                            markupCustPosting = MarkupCustPosting_RU::findLedger(MarkupCustPostingType_RU::SalesRevenue,
                                                                                    custInvoiceAccount,
                                                                                    markupTable.MarkupCode);
                            if (! markupCustPosting.LedgerDimension)
                            {
                                throw error(strFmt("@GLS114840", markupTable.MarkupCode));
                            }

                            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                ledgerVoucher.findLedgerVoucherObject(),
                                                                LedgerPostingType::SalesRevenue,
                                                                LedgerDimensionFacade::serviceCreateLedgerDimension(markupCustPosting.LedgerDimension, dimensionDefaultCust),
                                                                markupTrans.CurrencyCode,
                                                                postAmount + amountTaxPosted,
                                                                exchangeRateHelperCust);

                            ledgerVoucher.addTrans(ledgerVoucherTransObject);

                            if (ledgerBondClient)
                            {
                                markupBondRefMap_RU.insert(markupTrans.RecId, ledgerBondClient.lastVrefId());
                            }
                        }
                        else
                        {
                            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                ledgerVoucher.findLedgerVoucherObject(),
                                                                markupTable.CustPosting,
                                                                LedgerDimensionFacade::serviceCreateLedgerDimension(markupTable.CustomerLedgerDimension, dimensionDefaultCust),
                                                                markupTrans.CurrencyCode,
                                                                postAmount + amountTaxPosted,
                                                                exchangeRateHelperCust);

                            ledgerVoucher.addTrans(ledgerVoucherTransObject);
                        }
                    }
                }
                else
                {
                    // </GEERU>
                    MainAccount mainAccount = MainAccount::findByLedgerDimension(markupTable.CustomerLedgerDimension);

                    MainAccountLegalEntity mainAccountLegalEntity = MainAccountLegalEntity::findByMainAccountLegalEntity(mainAccount.RecId, CompanyInfo::current());

                    // Build ledgerDimension from financial dimension from markup table and Main Account financial dimensions.
                    LedgerDimensionAccount mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(markupTable.CustomerLedgerDimension, dimensionDefaultCust, mainAccountLegalEntity.DefaultDimension);

                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                   ledgerVoucher.findLedgerVoucherObject(),
                                                   markupTable.CustPosting,
                                                   mergedLedgerDimension,
                                                   markupTrans.CurrencyCode,
                                                   postAmount,
                                                   exchangeRateHelperCust);

                    ledgerVoucherTransObject.parmTaxParentReferenceTableId(newMarkupTrans.TableId);
                    ledgerVoucherTransObject.parmTaxParentReferenceRecId(newMarkupTrans.RecId);

                    ledgerVoucher.addTrans(ledgerVoucherTransObject);
                    // <GEERU>
                }
                // </GEERU>
            }

            if (markupTable.VendType == MarkupType::LedgerAccount || markupTable.VendType == MarkupType::Item)
            {
                exchangeRateHelperVend = this.getCurrencyExchangeHelperVend(transDate, currencyExchRate, currencyExchrateSecondary, currencyExchRateReporting);
            }

            if (markupTable.VendType == MarkupType::LedgerAccount)
            {
                DimensionDefault dimensionDefaultVend = this.getDimensionDefaultVend();

                // <GEERU>
                if (countryRegion_RU)
                {
                    if (allowPosting && postAmount)
                    {
                        if (markupTable.UseCustPostingTypeTransit_RU == NoYes::Yes &&
                            markupTable.CustType == MarkupType::CustVend &&
                            custInvoiceAccount &&
                            invoicePostingType == SalesInvoicePostingType_RU::GoodsInRoute)
                        {
                            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                ledgerVoucher.findLedgerVoucherObject(),
                                                                markupTable.VendPosting,
                                                                LedgerDimensionFacade::serviceCreateLedgerDimension(markupTable.VendorLedgerDimension, dimensionDefaultVend),
                                                                markupTrans.CurrencyCode,
                                                                -postAmount,
                                                                exchangeRateHelperVend);

                            ledgerVoucher.addTrans(ledgerVoucherTransObject);

                            markupCustPosting = MarkupCustPosting_RU::findLedger(MarkupCustPostingType_RU::Transit,
                                                                                 custInvoiceAccount,
                                                                                 markupTable.MarkupCode);
                            if (! markupCustPosting.LedgerDimension)
                            {
                                throw error(strFmt("@GLS114837", markupTable.MarkupCode));
                            }

                            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                ledgerVoucher.findLedgerVoucherObject(),
                                                                markupCustPosting.LedgerPostingType,
                                                                LedgerDimensionFacade::serviceCreateLedgerDimension(markupCustPosting.LedgerDimension, dimensionDefaultVend),
                                                                markupTrans.CurrencyCode,
                                                                postAmount,
                                                                exchangeRateHelperVend);

                            ledgerVoucher.addTrans(ledgerVoucherTransObject);

                            ledgerVoucher.bondLast2_RU();
                        }
                        else
                        if (TaxParameters::find().TaxSpecPosting_RU &&
                            markupTable.CustType == MarkupType::CustVend &&
                            custInvoiceAccount)
                        {
                            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                ledgerVoucher.findLedgerVoucherObject(),
                                                                markupTable.VendPosting,
                                                                LedgerDimensionFacade::serviceCreateLedgerDimension(markupTable.VendorLedgerDimension, dimensionDefaultVend),
                                                                markupTrans.CurrencyCode,
                                                                -postAmount,
                                                                exchangeRateHelperVend);

                            ledgerVoucher.addTrans(ledgerVoucherTransObject);

                            markupCustPosting = MarkupCustPosting_RU::findLedger(MarkupCustPostingType_RU::SalesConsumption,
                                                                                    custInvoiceAccount,
                                                                                    markupTable.MarkupCode);
                            if (! markupCustPosting.LedgerDimension)
                            {
                                throw error(strFmt("@GLS114839", markupTable.MarkupCode));
                            }

                            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                ledgerVoucher.findLedgerVoucherObject(),
                                                                LedgerPostingType::SalesConsump,
                                                                LedgerDimensionFacade::serviceCreateLedgerDimension(markupCustPosting.LedgerDimension, dimensionDefaultVend),
                                                                markupTrans.CurrencyCode,
                                                                postAmount,
                                                                exchangeRateHelperVend);

                            ledgerVoucher.addTrans(ledgerVoucherTransObject);

                            ledgerVoucher.bondLast2_RU();

                            markupCustPosting = MarkupCustPosting_RU::findLedger(MarkupCustPostingType_RU::SalesRevenue,
                                                                                    custInvoiceAccount,
                                                                                    markupTable.MarkupCode);
                            if (! markupCustPosting.LedgerDimension)
                            {
                                throw error(strFmt("@GLS114840", markupTable.MarkupCode));
                            }

                            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                ledgerVoucher.findLedgerVoucherObject(),
                                                                LedgerPostingType::SalesRevenue,
                                                                LedgerDimensionFacade::serviceCreateLedgerDimension(markupCustPosting.LedgerDimension, dimensionDefaultVend),
                                                                markupTrans.CurrencyCode,
                                                                -postAmount + amountTaxPosted,
                                                                exchangeRateHelperVend);

                            ledgerVoucher.addTrans(ledgerVoucherTransObject);

                            if (ledgerBondClient)
                            {
                                markupBondRefMap_RU.insert(markupTrans.RecId, ledgerBondClient.lastVrefId());
                            }
                        }
                        else
                        {
                            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                           ledgerVoucher.findLedgerVoucherObject(),
                                                           markupTable.VendPosting,
                                                           LedgerDimensionFacade::serviceCreateLedgerDimension(markupTable.VendorLedgerDimension, dimensionDefaultVend),
                                                           markupTrans.CurrencyCode,
                                                           -postAmount + amountTaxPosted,
                                                           exchangeRateHelperVend);

                            ledgerVoucher.addTrans(ledgerVoucherTransObject);
                            if (ledgerBondClient)
                            {
                                markupBondRefMap_RU.insert(markupTrans.RecId, ledgerBondClient.lastVrefId());
                            }
                        }
                    }
                }
                else
                {
                    // </GEERU>
                    // <GBR>
                    if (BrazilParameters::isEnabled())
                    {
                        if (markupTrans.markupTable().ModuleType == MarkupModuleType::Cust && markupTable.CustType == MarkupType::CustVend)
                        {
                            postAmount += tax.taxInSalesRevenue_BR(tableNum(MarkupTrans), markupTrans.RecId);
                        }
                    }
                    // </GBR>

                    if (markupTrans)
                    {
                        MainAccount postingMainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(LedgerDimensionFacade::serviceCreateLedgerDimension(markupTable.VendorLedgerDimension, dimensionDefaultVend));
                        if (!Tax::checkNoTax(postingMainAccount, markupTrans.TaxGroup, MarkupTrans.TaxItemGroup))
                        {
                            throw error("@SYS21533");
                        }
                    }

                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                   ledgerVoucher.findLedgerVoucherObject(),
                                                   markupTable.VendPosting,
                                                   LedgerDimensionFacade::serviceCreateLedgerDimension(markupTable.VendorLedgerDimension, dimensionDefaultVend),
                                                   markupTrans.CurrencyCode,
                                                  -postAmount,
                                                   exchangeRateHelperVend);

                    ledgerVoucherTransObject.parmTaxParentReferenceTableId(newMarkupTrans.TableId);
                    ledgerVoucherTransObject.parmTaxParentReferenceRecId(newMarkupTrans.RecId);

                    ledgerVoucher.addTrans(ledgerVoucherTransObject);
                    // <GEERU>
                }
                // </GEERU>
            }

            // <GEERU>
            if (countryRegion_RU && ledgerBondClient)
            {
                if (ledgerBondClient.currentLogLength() == #LogLengthPostingLedgerLedger)
                {
                    ledgerBondClient.bondLast2();
                }
                else
                {
                    if ((markupTable.CustType == MarkupType::LedgerAccount && markupTable.VendType == MarkupType::Item) ||
                        (markupTable.CustType == MarkupType::Item && markupTable.VendType == MarkupType::LedgerAccount))
                    {
                        itemLedgerBondLog += [ledgerBondClient.lastVrefId()];
                    }
                }
                ledgerBondClient.removeCurrentLogObject();
            }
            // </GEERU>

            this.postChargeAndCustomerLedger(markupTable, markupTrans, postAmount, exchangeRateHelperCust);
            this.postChargeAndVendorLedger(markupTable, markupTrans, postAmount, exchangeRateHelperVend);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyExchangeHelperCust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns Currency Exchange helper parameters for Cust type.
    /// </summary>
    /// <param name = "_transDate"></param>
    /// <param name = "_currencyExchRate"></param>
    /// <param name = "_currencyExchrateSecondary"></param>
    /// <param name = "_currencyExchRateReporting"></param>
    /// <returns>CurrencyExchangeRateHelper parameters for Cust type.</returns>
    [Hookable(true)]
    protected  CurrencyExchangeHelper getCurrencyExchangeHelperCust(TransDate _transDate, ExchRate _currencyExchRate, ExchrateSecondary _currencyExchrateSecondary, ExchRate _currencyExchRateReporting)
    {
        CurrencyExchangeHelper exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _transDate);
        exchangeRateHelper.parmExchangeRate1(_currencyExchRate);
        exchangeRateHelper.parmExchangeRate2(_currencyExchrateSecondary);

        if (_currencyExchRateReporting)
        {
            exchangeRateHelper.parmReportingExchangeRate1(_currencyExchRateReporting);
        }

        return exchangeRateHelper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyExchangeHelperVend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns Currency Exchange helper parameters for Vend type.
    /// </summary>
    /// <param name = "_transDate"></param>
    /// <param name = "_currencyExchRate"></param>
    /// <param name = "_currencyExchrateSecondary"></param>
    /// <param name = "_currencyExchRateReporting"></param>
    /// <returns>CurrencyExchangeRateHelper parameters for Vend type.</returns>
    [Hookable(true)]
    protected CurrencyExchangeHelper getCurrencyExchangeHelperVend(TransDate _transDate, ExchRate _currencyExchRate, ExchrateSecondary _currencyExchrateSecondary, ExchRate _currencyExchRateReporting)
    {
        CurrencyExchangeHelper exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _transDate);
        exchangeRateHelper.parmExchangeRate1(_currencyExchRate);
        exchangeRateHelper.parmExchangeRate2(_currencyExchrateSecondary);

        if (_currencyExchRateReporting)
        {
            exchangeRateHelper.parmReportingExchangeRate1(_currencyExchRateReporting);
        }

        return exchangeRateHelper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionDefaultCust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves dimensionDefault object for customer type.
    /// </summary>
    /// <returns>The dimensionDefault for customer type.</returns>
    [Hookable(true)]
    protected DimensionDefault getDimensionDefaultCust()
    {
        return dimensionDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionDefaultVend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves dimensionDefault object for vendor type.
    /// </summary>
    /// <returns>The dimensionDefault for vendor type.</returns>
    [Hookable(true)]
    protected DimensionDefault getDimensionDefaultVend()
    {
        return dimensionDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInvoiceTrans</Name>
				<Source><![CDATA[
    protected void postInvoiceTrans(MarkupTrans    markupTrans,
                                    AmountCur      postAmount)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().postInvoiceTrans())
        {
            MarkupTrans origTrans;
            MarkupTrans newMarkupTrans;
            Voucher lastVoucher;
            TransDate lastTransDate;
            // <GEERU>
            boolean origCreatePostedOnly = createPostedOnly;
            boolean oldCorrection;

            // If nothing to post then skip
            if (MCROrderParameters::isCallCenterEnabledAndInUse())
            {
                boolean shouldUseLegacyLogic = markupTrans.RecId == 0 ? true : RetailTaxKillSwitch::isUseLegacyLogicInMarkupPostInvoiceTrans();
                if (shouldUseLegacyLogic)
                {
                    if (postAmount == 0)
                    {
                        return;
                    }
                }
            }

            if (postNegativeMarkupAsCorrection)
            {
                oldCorrection = ledgerVoucher.findLedgerVoucherObject().parmCorrection();

                ledgerVoucher.findLedgerVoucherObject().parmCorrection(postAmount < 0);
            }
            // </GEERU>

            if (!createPostedOnly && ledgerVoucher)
            {
                this.checkForCurrencyMismatch(markupTrans, source, destin);
                // <GEERU>
                if (countryRegion_RU)
                {
                    if (this.markupCustVendLocked_RU() && markupTrans.isMarkupOfTypeCustVend())
                    {
                        throw error("@GLS115690");
                    }
                }

                createPostedOnly = origCreatePostedOnly;
                // </GEERU>
            }

            if (ledgerVoucher)
            {
                lastVoucher = ledgerVoucher.lastVoucher();
                lastTransDate = ledgerVoucher.lastTransDate();
            }

            if (destin)
            {
                origTrans = markupTrans.findOrig(true);
                // <GIN>
                if (TaxParameters::checkTaxParameters_IN()
                    && tax
                    && markupAmountLoc)
                {
                    newMarkupTrans = this.insertJournalMarkupTrans(markupTrans,
                                                destin,
                                                markupTrans.signedValue(markupAmountLoc),
                                                lastVoucher,
                                                lastTransDate,
                                                markupTrans.ledgerAccountAmount(postAmount));
                }
                else
                {
                    //</GIN>
                    newMarkupTrans = this.insertJournalMarkupTrans(markupTrans,
                                                  destin,
                                                  markupTrans.signedValue(postAmount),
                                                  lastVoucher,
                                                  lastTransDate,
                                                  markupTrans.ledgerAccountAmount(postAmount),
                                                  origTrans);

                    //<GIN>
                }
                //</GIN>
                this.updateOrigMarkupTrans(origTrans);
                // If it's a fixed, pro-rated misc charge, then
                // -subtract postAmount from value (will handle positive and negative misc charges)
                // -if the resulting value is 0 then delete the record, otherwise just update
                if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter))
                    && markupTrans.MarkupCategory == MarkupCategory::Fixed
                    && !markupTrans.Keep
                    && markupTrans.mcrIsProRated())
                {
                    ttsBegin;
                    markupTrans.Value -= postAmount;
                    if (markupTrans.Value == 0)
                    {
                        markupTrans.SourceDocumentLine = 0;
                        markupTrans.delete(true);
                    }
                    else
                    {
                        markupTrans.update();
                    }
                    ttsCommit;
                }
                else
                {
                    // Delete MarkupTrans if not "Keep", but always leave MarkupTrans on an Invoice (VendInvoiceInfo*)
                    if (!markupTrans.Keep &&
                    // <GEERU>
                    (! countryRegion_RU || allowPosting) &&
                    // </GEERU>
                    markupTrans.TransTableId != tableNum(VendInvoiceInfoTable) &&
                            markupTrans.TransTableId != tableNum(VendInvoiceInfoSubTable) &&
                            markupTrans.TransTableId != tableNum(VendInvoiceInfoLine))
                    {
                        markupTrans.SourceDocumentLine = 0;
                        markupTrans.delete(true);
                    }
                }
            }
            else
            {
                this.updateJournalMarkupTrans(markupTrans,
                                              markupTrans.signedValue(postAmount),
                                              lastVoucher,
                                              lastTransDate,
                                              markupTrans.ledgerAccountAmount(postAmount));
            }

            if (!createPostedOnly && ledgerVoucher)
            {
                // Now that we have the newMarkupTrans, we can post the markup and any newMarkupTrans taxes to the GL.
                this.postInvoiceAmount(markupTrans, postAmount, newMarkupTrans);
            }

            // <GEERU>
            if (postNegativeMarkupAsCorrection)
            {
                ledgerVoucher.findLedgerVoucherObject().parmCorrection(oldCorrection);
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournal</Name>
				<Source><![CDATA[
    public void postJournal(Qty                  _qty,
                            AmountCur            _value,
                            Common               _source,
                            DimensionDefault     _dimension,
                            Common               _destin = _destin,
                            LedgerVoucher        _ledgerVoucher = null,
                            boolean            _isInterCompanyMarkup = true)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().postJournal())
        {
            dimensionDefault    = _dimension;
            source              = _source;
            destin              = _destin;

            postJournal         = true;

            ledgerVoucher   = _ledgerVoucher;

            this.calc(_qty,
                      _value,
                      source,
                      DocumentStatus::None,
                      0,
                      '',
                      _isInterCompanyMarkup);

            postJournal         = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournalTrans</Name>
				<Source><![CDATA[
    protected void postJournalTrans(MarkupTrans    markupTrans,
                                    AmountCur      postAmount)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().postJournalTrans())
        {
            SubledgerJournalAccountEntry                subledgerJournalAccountEntry;
            SubledgerJournalAccountEntryDistribution    subledgerJournalAccountEntryDistribution;
            AccountingDistribution                      accountingDistribution;
            AccountingEvent                             accountingEvent;
            LedgerVoucherTransObject                    ledgerVoucherTransObject;
            PurchTable                                  purchTable;

            if (destin)
            {
                this.insertJournalMarkupTrans(markupTrans,
                                              destin,
                                              markupTrans.signedValue(postAmount));
            }

            if (this.canPostLedger(markupTrans.TransTableId))
            {
                switch (markupTrans.TransTableId)
                {
                    case tableNum(PurchTable):
                        purchTable = PurchTable::findRecId(markupTrans.TransRecId);
                        break;

                    case tableNum(PurchLine):
                        purchTable = PurchLine::findRecId(markupTrans.TransRecId).purchTable();
                        break;
                }

                accountingEvent = AccountingEvent::getActiveEvent(purchTable.SourceDocumentHeader);

                while select subledgerJournalAccountEntry
                                exists join accountingDistribution where
                                    subledgerJournalAccountEntryDistribution.AccountingDistribution == accountingDistribution.RecId &&
                                    subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry == subledgerJournalAccountEntry.RecId &&
                                    subledgerJournalAccountEntry.IsTransferredInDetail != TransferPolicy::DoNotTransfer &&
                                    accountingDistribution.SourceDocumentLine == markupTrans.SourceDocumentLine &&
                                    accountingDistribution.AccountingEvent == accountingEvent.RecId

                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newSubLedgerJournalAccountEntryDefault(
                        ledgerVoucher.findLedgerVoucherObject(),
                        subledgerJournalAccountEntry);

                    ledgerVoucherTransObject.parmText(markupTrans.Txt);
                    ledgerVoucherTransObject.parmTaxParentReferenceTableId(markupTrans.TableId);
                    ledgerVoucherTransObject.parmTaxParentReferenceRecId(markupTrans.RecId);

                    ledgerVoucher.addTrans(ledgerVoucherTransObject);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNew_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the map of markup amounts by classification.
    /// </summary>
    /// <param name="_currencyCode">
    /// The <c>CurrencyCode</c> parameter of the main method.
    /// </param>
    public void postNew_BR(CurrencyCode _currencyCode)
    {
        markupAmountByClassification_BR         = new Map(Types::Enum, Types::Real);
        markupAmountMap_BR                      = new Map(Types::Int64, Types::Real);
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerMarkupCustVendChange_RU</Name>
				<Source><![CDATA[
    private void registerMarkupCustVendChange_RU(boolean _negative, MarkupAmount _delta)
    {
        if (_negative)
        {
            markUpCustVendNegative += _delta;
        }
        else
        {
            markUpCustVendPositive += _delta;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTax</Name>
				<Source><![CDATA[
    public void setTax(Tax _tax)
    {
        tax = _tax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumOtherMiscCharges</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the miscellaneous charges is another miscellaneous charge and adds the value to the
    ///    other miscellaneous charges total.
    /// </summary>
    /// <param name="_markupTrans">
    ///    The miscellaneous charge record to add to the total.
    /// </param>
    /// <param name="_qty">
    ///    The quantity of items with which the miscellaneous charge is associated.
    /// </param>
    /// <param name="_value">
    ///    The miscellaneous charge value.
    /// </param>
    /// <param name="_interCompanyValue">
    ///    The intercompany percent value for this miscellaneous charge.
    /// </param>
    /// <param name="_isInterCompanyMarkup">
    ///     Boolean value, states if check is performed for intercompany purchase order; optional.
    /// </param>
    void sumOtherMiscCharges(MarkupTrans _markupTrans,
                             Qty _qty,
                             AmountCur _value,
                             AmountCur _interCompanyValue = 0,
                             boolean _isInterCompanyMarkup = true)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().sumOtherMiscCharges())
        {
            MarkupAmount    markupAmount;
            MarkupTable     markupTable;

            markupAmount = Markup::calcTrans(_markupTrans,
                                             _qty,
                                             _value,
                                             _interCompanyValue,
                                             DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                             _isInterCompanyMarkup);

            if (tax)
            {
                markupAmount += tax.taxInCostPrice(_markupTrans.TableId, _markupTrans.RecId);
            }

            markupTable = _markupTrans.markupTable();

            //Track a running total of non-vendor misc. charges. Can be in different currency, so convert if needed.
            if ((markupTable.VendType == MarkupType::LedgerAccount) && (markupTable.CustType != MarkupType::CustVend))
            {
                if (_markupTrans.CurrencyCode == currencyCode)
                {
                    markupOtherCharges -= markupAmount;
                }
                else
                {
                    markupOtherCharges -= CurrencyExchangeHelper::curAmount2CurAmount(markupAmount, _markupTrans.CurrencyCode, currencyCode);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxModuleType</Name>
				<Source><![CDATA[
    public TaxModuleType taxModuleType()
    {
        return taxModuleType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalMarkupAmountCur_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total markup amount in the transaction currency, including debit: item credit: ledger misc. charges
    /// </summary>.
    /// <returns>Total markup amount.</returns>
    public AmountCur totalMarkupAmountCur_BR()
    {
        return totalMarkupCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalMarkupAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total markup amount in the transaction currency, including debit: item credit: ledger misc. charges
    /// </summary>.
    /// <returns>Total markup amount.</returns>
    public AmountCur totalMarkupAmountMST_BR()
    {
        return totalMarkupMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDate</Name>
				<Source><![CDATA[
    TransDate transDate(TransDate _transDate = transDate)
    {
        transDate = _transDate;

        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalMarkupTrans</Name>
				<Source><![CDATA[
    protected void updateJournalMarkupTrans(MarkupTrans _markupTrans, AmountCur _calculatedAmount, Voucher _voucher = '', TransDate _transDate = dateNull(), AmountCur _posted = 0)
    {
        _markupTrans.CalculatedAmount = _calculatedAmount;
        _markupTrans.Voucher          = _voucher;
        _markupTrans.TransDate        = _transDate;
        _markupTrans.Posted           = _posted;

        // <GEERU>
        if (countryRegion_RU)
        {
            this.initMarkupTrans_RU(_markupTrans);
        }
        // </GEERU>

        // <GEEU>
        if (IntrastatParameters::isLegalEntityInEEU() || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoFR]))
        {
            this.calcAmountMST(_markupTrans);
        }
        // </GEEU>

        _markupTrans.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarkupMap</Name>
				<Source><![CDATA[
    private void updateMarkupMap(Map _markupMap, CurrencyCode _currencyCode, Amount _amount)
    {
        Amount  sumAmount;

        if (_markupMap.exists(_currencyCode))
        {
            sumAmount = _markupMap.lookup(_currencyCode);
        }

        sumAmount += _amount;

        _markupMap.insert(_currencyCode, sumAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarkupMap_RU</Name>
				<Source><![CDATA[
    private void updateMarkupMap_RU(MarkupTrans _trans, Amount _amount)
    {
        Amount      sumAmount;
        container   key = [_trans.CurrencyCode, _trans.MarkupCode, _trans.RecId];

        if (markupItemLedgerMap_RU.exists(key))
        {
            sumAmount = markupItemLedgerMap_RU.lookup(key);
        }

        sumAmount += _amount;

        markupItemLedgerMap_RU.insert(key, sumAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOrigMarkupTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Marks the <c>MarkupTrans</c> record that is connected to a <c>PurchTable</c> or <c>PurchLine</c>
    ///    record as invoiced.
    /// </summary>
    /// <param name="_origMarkupTrans">
    ///    The <c>MarkupTrans</c> record that is connected to a <c>PurchTable</c> or <c>PurchLine</c> record.
    /// </param>
    protected void updateOrigMarkupTrans(MarkupTrans _origMarkupTrans)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().updateOrigMarkupTrans())
        {
            InterCompanyMarkup  interCompanyMarkup;

            // <GEERU>
            if ((! countryRegion_RU || allowPosting)
                && _origMarkupTrans
                && !_origMarkupTrans.Keep
                && (_origMarkupTrans.TransTableId == tableNum(PurchTable)
                    || _origMarkupTrans.TransTableId == tableNum(PurchLine)
                    || _origMarkupTrans.isBOERelated()))
            // </GEERU>
            {
                _origMarkupTrans.DocumentStatus = DocumentStatus::Invoice;

                if (_origMarkupTrans.InterCompanyRefRecId)
                {
                    //Deleting Misc. charges for the intercompany sales order.
                    interCompanyMarkup = InterCompanyMarkup::construct(InterCompanyMarkupAction::Delete,_origMarkupTrans);
                    interCompanyMarkup.run();
                }
                _origMarkupTrans.doUpdate();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountRelation</Name>
				<Source><![CDATA[
    static CustVendRel accountRelation(TableGroupAll       accountCode,
                                       CustVendAC          account,
                                       MarkupGroupId       groupId)
    {
        switch (accountCode)
        {
            case TableGroupAll::Table       :   return account;
            case TableGroupAll::GroupId     :   return groupId;
            case TableGroupAll::All         :   return '';
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>activated</Name>
				<Source><![CDATA[
    static boolean  activated(HeadingLine       moduleCategory,
                              MarkupModule      moduleType)
    {
        boolean  activated = false;

        if (moduleType ==
                    MarkupModuleType::Vend
           )
            activated = (moduleCategory == HeadingLine::Heading
                                        ? PurchParameters::find().MarkupHeading
                                        : PurchParameters::find().MarkupLine);
        else
            if (moduleType==
                        MarkupModuleType::Cust || moduleType == MarkupModuleType::Delivery
               )
                activated = (moduleCategory == HeadingLine::Heading
                                            ? SalesParameters::find().MarkupHeading
                                            : SalesParameters::find().MarkupLine);

        return activated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMarkupAmount</Name>
				<Source><![CDATA[
    public static MarkupAmount calcMarkupAmount(MarkupTrans _markupTrans, Qty _qty, AmountCur _amount, AmountCur _intercompanyAmount, boolean _isInclTax,
                                    NoYes _convertSign = NoYes::No,
                                    CurrencyCode _documentCurrencyCode = _markupTrans.CurrencyCode,
                                    TransDate _documentTransDate = _markupTrans.TransDate,
                                    ExchRate _mstCurToDestinationCurExchRate = 0,
                                    ExchrateSecondary _mstCurToDestinationCurExchRateSecondary = 0,
                                    Tax _tax = null
                                    , boolean _calcTax_RU = false
                                    ,AmountCur      _absoluteValue = 0,
                                    ParmId         _parmId = '',
                                    boolean        _mcrPostingInvoice = false,
                                    boolean _isInterCompanyMarkup = true)
    {
        MarkupAmount                        markupAmount;
        AmountMST                           amountMST;
        CurrencyExchangeHelper              mstCurrencyExchangeHelper;
        CurrencyExchangeHelper              curCurrencyExchangeHelper;
        TransDate                           transDate;
        CurrencyCode                        currencyCode;
        TaxBase                             origin;
        // <GIN>
        boolean                             isIndiaTaxMarked = TaxParameters::checkTaxParameters_IN();
        boolean                             isInclTaxIN = isIndiaTaxMarked &&  _markupTrans.isPriceInclTax_IN();
        // </GIN>

        using (SysInstrumentationActivityContext activityContext = MarkupInstrumentationLogger::createLogger(classStr(Markup)).chargeCalculationActivities().calcMarkupAmount())
        {
            markupAmount = Markup::calcTrans(
                _markupTrans,
                _qty,
                _amount,
                _intercompanyAmount,
                _markupTrans.TransDate,
                _absoluteValue,
                _parmId,
                _mcrPostingInvoice,
                _isInterCompanyMarkup);

            // convert currency
            if (_markupTrans.CurrencyCode != _documentCurrencyCode)
            {
                currencyCode = _documentCurrencyCode;

                //Get the transaction date
                if (_documentTransDate)
                {
                    transDate = _documentTransDate;
                }
                else
                {
                    transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                }

                //Convert from originating currency to master company currency
                mstCurrencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_markupTrans.company()).RecId), transDate);
                amountMST = mstCurrencyExchangeHelper.calculateTransactionToAccounting(_markupTrans.CurrencyCode, markupAmount, false);

                //Convert from master company currency to destination currency
                if (_mstCurToDestinationCurExchRate != 0 || _mstCurToDestinationCurExchRateSecondary != 0)
                {
                    curCurrencyExchangeHelper = CurrencyExchangeHelper::construct();
                    curCurrencyExchangeHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(_markupTrans.company()).RecId));
                    curCurrencyExchangeHelper.parmExchangeDate(transDate);
                    curCurrencyExchangeHelper.parmExchangeRate1(_mstCurToDestinationCurExchRate);
                    curCurrencyExchangeHelper.parmExchangeRate2(_mstCurToDestinationCurExchRateSecondary);
                    markupAmount = curCurrencyExchangeHelper.calculateAccountingToTransaction(_documentCurrencyCode, amountMST, true);
                }
                else
                {
                    curCurrencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_markupTrans.company()).RecId), transDate);
                    markupAmount = curCurrencyExchangeHelper.calculateAccountingToTransaction(_documentCurrencyCode, amountMST, true);
                }
            }
            else
            {
                currencyCode = _markupTrans.CurrencyCode;
            }

            // exclude taxes
            if (_isInclTax && _markupTrans.isInclTax(_markupTrans))
            {
                // <GEERU>
                if ( !SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
                    || _calcTax_RU)
                {
                    // </GEERU>
                    if (_tax)
                    {
                        origin = _tax.getOriginForSourceLine(_markupTrans.TableId, _markupTrans.RecId, false, markupAmount);
                    }
                    if (!origin)
                    {
                        origin = TaxUncommitted::getOriginForSourceLine(_markupTrans.TableId, _markupTrans.RecId, false, markupAmount);
                        if (!origin)
                        {
                            origin = Tax::baseAmountExclTax(_markupTrans.TaxGroup, _markupTrans.TaxItemGroup, _markupTrans.TransDate, currencyCode, markupAmount, _markupTrans.taxModuleType());
                        }
                    
                        origin = Markup::calculateChargeAmountForPurchaseLineProportionalOrPiecesCharge(origin, _markupTrans, _qty);
                    }
           
                    if (sign(origin) != sign(markupAmount))
                    {
                        origin = origin * -1;
                    }
                    markupAmount = origin;
                    // <GEERU>
                }
                // </GEERU>
            }

            // <GIN>
            if (isIndiaTaxMarked && isInclTaxIN)
            {
                //  tax and markupAmount is in different sig and tax is negative.
                markupAmount += Tax::getpriceInclTaxAmount_IN(
                                    _markupTrans.TableId,
                                    _markupTrans.RecId,
                                    _markupTrans.TaxItemGroup,
                                    _tax.tmpTaxWorkTrans(),
                                    _tax.tmpTaxCalc_IN());
            }
            // </GIN>

            // convert sign
            if (_convertSign)
            {
                switch (_markupTrans.ModuleType)
                {
                    case MarkupModuleType::Vend  :
                        if (_markupTrans.markupTable().CustType == MarkupType::CustVend)
                        {
                            markupAmount = -markupAmount;
                        }
                        break;
                }
            }

            return markupAmount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateChargeAmountForPurchaseLineProportionalOrPiecesCharge</Name>
				<Source><![CDATA[
    private static MarkupAmount calculateChargeAmountForPurchaseLineProportionalOrPiecesCharge(MarkupAmount _markupAmount, MarkupTrans _markupTrans, Qty _qty)
    {
        MarkupAmount markupAmount = _markupAmount;

        if (_markupAmount
            && _markupTrans.TransTableId == tableNum(PurchLine)
            && (_markupTrans.MarkupCategory == MarkupCategory::Pcs
                || _markupTrans.MarkupCategory == MarkupCategory::Proportional))
        {
            Qty originalQuantity = Markup::resolveOriginalQuantity(_markupTrans, _qty);
            
            // If it is not full quantity charge, the markup amount must be proportional to posted quantity 
            if (originalQuantity && _qty != originalQuantity)
            {
                markupAmount = CurrencyExchangeHelper::amount(_qty / originalQuantity * markupAmount, _markupTrans.CurrencyCode);
            }
        }

        return markupAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chargeInitialized</Name>
				<Source><![CDATA[
    delegate void chargeInitialized(MarkupTrans charge, MarkupTrans chargeOrigin, Common origin, Common destination, NoYes reverseSign)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>chargeInitializedInvoke</Name>
				<Source><![CDATA[
    private void chargeInitializedInvoke(MarkupTrans charge, MarkupTrans chargeOrigin, Common origin, Common destination, NoYes reverseSign)
    {
        this.chargeInitialized(charge, chargeOrigin, origin, destination, reverseSign);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the calculated miscellaneous charges amount for an miscellaneous charges transaction.
    /// </summary>
    /// <param name="_markupTrans">
    ///    The miscellaneous charges transaction to calculate miscellaneous charges amount from.
    /// </param>
    /// <param name="_qty">
    ///    The quantity to calculate miscellaneous charges amount from.
    /// </param>
    /// <param name="_value">
    ///    The value to calculate miscellaneous charges amount from.
    /// </param>
    /// <param name="_interCompanyValue">
    ///    The intercompany value to calculate miscellaneous charges amount from; optional.
    /// </param>
    /// <param name="_transDate">
    ///    The date that is used to convert miscellaneous charges from one currency to another currency;
    ///    optional.
    /// </param>
    /// <param name="_absoluteValue">
    ///     The absolute value of the related markup transaction.
    /// </param>
    /// <param name="_parmId">
    ///     The ID for the relating markup transaction.
    /// </param>
    /// <param name="_mcrPostingInvoice">
    ///     The posting invoice record of the related markup transaction.
    /// </param>
    /// <param name="_isInterCompanyMarkup">
    ///     Boolean value, states if calculation is performed for intercompany purchase order; optional.
    /// </param>
    /// <returns>
    ///    The calculated miscellaneous charges amount.
    /// </returns>
    static MarkupAmount  calcTrans(MarkupTrans    _markupTrans,
                                   Qty            _qty,
                                   AmountCur      _value,
                                   AmountCur      _interCompanyValue = _value,
                                   TransDate      _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                   AmountCur      _absoluteValue = 0,
                                   ParmId         _parmId = '',
                                   boolean        _mcrPostingInvoice = false,
                                   boolean        _isInterCompanyMarkup = true)
    {
        MarkupAmount markupAmount;

        using (SysInstrumentationActivityContext activityContext = MarkupInstrumentationLogger::createLogger(classStr(Markup)).chargeCalculationActivities().calcTrans())
        {
            if (_markupTrans.InterCompanyMarkupUseValue)
            {
                markupAmount =  _markupTrans.InterCompanyMarkupValue;
            }
            else
            {
                _markupTrans.InterCompanyMarkupValue = 0;

                RefReturnInvoiceTrans_W refReturnInvoiceTrans_W;
                if ((_markupTrans.TransTableId == tableNum(CustInvoiceLine) || _markupTrans.TransTableId == tableNum(CustInvoiceTrans)) &&
                    SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU,#isoPL,#isoHU,#isoCZ,#isoLT,#isoLV,#isoEE,#isoRU]))
                {
                    if (_markupTrans.TransTableId == tableNum(CustInvoiceLine))
                    {
                        refReturnInvoiceTrans_W = CustInvoiceLine::find(_markupTrans.TransRecId).RefReturnInvoiceTrans_W;
                    }
                    else
                    {
                        refReturnInvoiceTrans_W = CustInvoiceTrans::findRecId(_markupTrans.TransRecId).custInvoiceTrans_W().RefReturnInvoiceTrans_W;
                    }
                }

                markupAmount = Markup::getMarkupAmountFromMarkupCategory(_markupTrans, refReturnInvoiceTrans_W, _qty, _value, _interCompanyValue, _transDate,
                                                                            _absoluteValue, _parmId, _mcrPostingInvoice, _isInterCompanyMarkup);
            }
            if (_isInterCompanyMarkup)
            {
                InterCompanyMarkup::updateFromMarkupTrans(_markupTrans, markupAmount);
            }
        }

        return markupAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkupAmountFromMarkupCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the calculated miscellaneous charges amount for an miscellaneous charges transaction based on charge category.
    /// </summary>
    /// <param name="_markupTrans">
    ///    The miscellaneous charges transaction to calculate miscellaneous charges amount from.
    /// </param>
    /// <param name = "_refReturnInvoiceTrans_W">
    ///     An instance of <c>RefReturnInvoiceTrans_W</c> class.
    /// </param>
    /// <param name="_qty">
    ///    The quantity to calculate miscellaneous charges amount from.
    /// </param>
    /// <param name="_value">
    ///    The value to calculate miscellaneous charges amount from.
    /// </param>
    /// <param name="_interCompanyValue">
    ///    The intercompany value to calculate miscellaneous charges amount from; optional.
    /// </param>
    /// <param name="_transDate">
    ///    The date that is used to convert miscellaneous charges from one currency to another currency;
    ///    optional.
    /// </param>
    /// <param name="_absoluteValue">
    ///     The absolute value of the related markup transaction.
    /// </param>
    /// <param name="_parmId">
    ///     The ID for the relating markup transaction.
    /// </param>
    /// <param name="_mcrPostingInvoice">
    ///     The posting invoice record of the related markup transaction.
    /// </param>
    /// <param name="_isInterCompanyMarkup">
    ///     Boolean value, states if calculation is performed for intercompany purchase order; optional.
    /// </param>
    /// <returns>
    ///    The calculated miscellaneous charges amount.
    /// </returns>
    protected static MarkupAmount getMarkupAmountFromMarkupCategory(MarkupTrans             _markupTrans,
                                                                    RefReturnInvoiceTrans_W _refReturnInvoiceTrans_W,
                                                                    Qty                     _qty,
                                                                    AmountCur               _value,
                                                                    AmountCur               _interCompanyValue,
                                                                    TransDate               _transDate,
                                                                    AmountCur               _absoluteValue,
                                                                    ParmId                  _parmId,
                                                                    boolean                 _mcrPostingInvoice,
                                                                    boolean                 _isInterCompanyMarkup)
    {
        MarkupAmount markupAmount;

        switch (_markupTrans.MarkupCategory)
        {
            case MarkupCategory::Fixed:
                if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
                {
                    markupAmount =  Markup::MCRCalcFixedMiscCharge(_markupTrans, _absoluteValue, _qty, _mcrPostingInvoice, _parmId);
                }
                else
                {
                    markupAmount = _markupTrans.Value;
                }
                break;
            case MarkupCategory::Pcs:
                markupAmount = Markup::markupAmountByCurrency(_markupTrans, _qty, _refReturnInvoiceTrans_W);
                break;
            
            case MarkupCategory::UnitSpecific:
            case MarkupCategory::UnitSpecificMatch:
                if (AutoChargesSetupLineLevelUnitOfMeasureFeature::instance().IsEnabled())
                {
                    real qtySpecificUoM = Markup::markupUnitOfMeasureQuantity(_markupTrans, _qty);
                    markupAmount = Markup::markupAmountByCurrency(_markupTrans, qtySpecificUoM, _refReturnInvoiceTrans_W);
                }
                break;

            case MarkupCategory::Percent:
                CurrencyCode parentCurrencyCode = _markupTrans.parentCurrencyCode();

                Markup::setMarkupTransValueForProjSales(_markupTrans);

                markupAmount = CurrencyExchangeHelper::amount(_value * _markupTrans.Value / 100, parentCurrencyCode); //Rounding happening in Transaction currency
                // calculated markup amount must be converted from parent currency to currency defined by the misc. charges transaction
                if (_markupTrans.CurrencyCode != parentCurrencyCode)
                {
                    if (!_transDate)
                    {
                        _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    }

                    // <GIN>
                    if (TaxParameters::checkTaxParameters_IN()
                        && (_markupTrans.TableId == tableNum(PurchLine) || _markupTrans.TableId == tableNum(VendInvoiceInfoLine))
                        && _markupTrans.CurrencyCode == Ledger::find(Ledger::current()).AccountingCurrency)
                    {
                        PurchTable_W purchTableW;
                        if (_markupTrans.TableId == tableNum(PurchLine))
                        {
                            purchTableW = PurchTable_W::findByPurchTable(PurchTable::find(PurchLine::findRecId(_markupTrans.TransRecId).PurchId).RecId);
                        }
                        else if (_markupTrans.TableId == tableNum(VendInvoiceInfoLine))
                        {
                            purchTableW = PurchTable_W::findByPurchTable(PurchTable::find(VendInvoiceInfoLine::findRecId(_markupTrans.TransRecId).OrigPurchId).RecId);
                        }

                        if (purchTableW && purchTableW.CustomsImportOrder_IN)
                        {
                            markupAmount = CustomsImportAssessableValue_IN::getMarkupValueForCurrencySameWithAccounting(markupAmount, _markupTrans.CurrencyCode, parentCurrencyCode, _transDate);
                        }
                        else
                        {
                            markupAmount = CurrencyExchangeHelper::curAmount2CurAmount(markupAmount, parentCurrencyCode, _markupTrans.CurrencyCode, _transDate);
                        }
                    }
                    else
                    {
                        //</GIN>
                        markupAmount = CurrencyExchangeHelper::curAmount2CurAmount(markupAmount, parentCurrencyCode, _markupTrans.CurrencyCode, _transDate);
                        // <GIN>
                    }
                    // <GIN>
                }
                if (_refReturnInvoiceTrans_W)
                {
                    markupAmount = -markupAmount;
                }
                break;
            case MarkupCategory::InterCompanyPercent:
                markupAmount = CurrencyExchangeHelper::amount(_interCompanyValue * _markupTrans.Value / 100, _markupTrans.CurrencyCode);
                break;
            case MarkupCategory::Proportional:
                Qty origQty = Markup::resolveOriginalQuantity(_markupTrans, _qty);

                //Prevent division by Zero situation
                if (origQty == 0)
                {
                    markupAmount = 0;
                }
                else
                {
                    markupAmount = CurrencyExchangeHelper::amount(_qty / origQty * _markupTrans.Value, _markupTrans.CurrencyCode);
                }
                break;
        }

        if (_markupTrans.RetailShippingPromotionDiscount > 0)
        {
            Amount effectiveAmount = decRound(markupAmount * _markupTrans.RetailShippingPromotionDiscount/100, 2);
            markupAmount -= effectiveAmount;
        }

        return markupAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupAmountByCurrency</Name>
				<Source><![CDATA[
    private static MarkupAmount markupAmountByCurrency(MarkupTrans _markupTrans, Qty _qty, RefReturnInvoiceTrans_W _returnInvoiceTrans_W)
    {
        MarkupAmount markupAmount = CurrencyExchangeHelper::amount(_qty * _markupTrans.Value, _markupTrans.CurrencyCode);

        if (_returnInvoiceTrans_W)
        {
            markupAmount = -markupAmount;
        }

        return markupAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupUnitOfMeasureQuantity</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static real markupUnitOfMeasureQuantity(MarkupTrans _markupTrans, Qty _qty)
    {
        ItemId                  itemId;
        InventDimId             inventDimId;
        UnitOfMeasureSymbol     unitSymbol;
        
        switch (_markupTrans.TransTableId)
        {
            case tableNum(SalesLine) :
                SalesLine salesLine = SalesLine::findRecId(_markupTrans.TransRecId);
                if (salesLine.RecId)
                {
                    itemId = salesLine.ItemId;
                    inventDimId = salesLine.InventDimId;
                    unitSymbol = salesLine.SalesUnit;
                }
                break;

            case tableNum(SalesQuotationLine) :
                SalesQuotationLine salesQuotationLine = SalesQuotationLine::findRecId(_markupTrans.TransRecId);
                if (salesQuotationLine.RecId)
                {
                    itemId = salesQuotationLine.ItemId;
                    inventDimId = salesQuotationLine.InventDimId;
                    unitSymbol = salesQuotationLine.SalesUnit;
                }
                break;

            case tableNum(PurchLine) :
                PurchLine purchLine = PurchLine::findRecId(_markupTrans.TransRecId);
                if (purchLine.RecId)
                {
                    itemId = purchLine.ItemId;
                    inventDimId = purchLine.InventDimId;
                    unitSymbol = purchLine.PurchUnit;
                }
                break;

            case tableNum(PurchRFQLine) :
                PurchRFQLine purchRFQLine = PurchRFQLine::findRecId(_markupTrans.TransRecId);
                if (purchRFQLine.RecId)
                {
                    itemId = purchRFQLine.ItemId;
                    inventDimId = purchRFQLine.InventDimId;
                    unitSymbol = purchRFQLine.PurchUnit;
                }
                break;

            case tableNum(PurchReqLine) :
                PurchReqLine purchReqLine = PurchReqLine::find(_markupTrans.TransRecId);
                if (purchReqLine.RecId)
                {
                    itemId = purchReqLine.ItemId;
                    inventDimId = purchReqLine.InventDimId;
                    unitSymbol = UnitOfMeasure::find(purchReqLine.PurchUnitOfMeasure).Symbol;
                }
                break;

            case tableNum(PurchRFQCaseLine) :
                PurchRFQCaseLine purchRFQCaseLine = PurchRFQCaseLine::findRecId(_markupTrans.TransRecId);
                if (purchRFQCaseLine.RecId)
                {
                    itemId = purchRFQCaseLine.ItemId;
                    inventDimId = purchRFQCaseLine.InventDimId;
                    unitSymbol = purchRFQCaseLine.PurchUnit;
                }
                break;

            case tableNum(CustInvoiceTrans) :
                CustInvoiceTrans custInvoiceTrans = CustInvoiceTrans::findRecId(_markupTrans.TransRecId);
                if (custInvoiceTrans.RecId)
                {
                    itemId = custInvoiceTrans.ItemId;
                    inventDimId = custInvoiceTrans.InventDimId;
                    unitSymbol = custInvoiceTrans.SalesUnit;
                }
                break;

            case tableNum(VendInvoiceTrans) :
                VendInvoiceTrans vendInvoiceTrans = VendInvoiceTrans::findRecId(_markupTrans.TransRecId);
                if (vendInvoiceTrans.RecId)
                {
                    itemId = vendInvoiceTrans.ItemId;
                    inventDimId = vendInvoiceTrans.InventDimId;
                    unitSymbol = vendInvoiceTrans.PurchUnit;
                }
                break;

            case tableNum(VendInvoiceInfoLine) :
                VendInvoiceInfoLine vendInvoiceInfoLine = VendInvoiceInfoLine::findRecId(_markupTrans.TransRecId);
                if (vendInvoiceInfoLine.RecId)
                {
                    itemId = vendInvoiceInfoLine.ItemId;
                    inventDimId = vendInvoiceInfoLine.InventDimId;

                    if (PurchInvoiceMarkupUnitOfMeasureQuantityFlight::instance().isEnabled())
                    {
                        unitSymbol = vendInvoiceInfoLine.PurchLineRecId ? vendInvoiceInfoLine.purchLine().PurchUnit
                            : vendInvoiceInfoLine.PurchUnit;
                    }
                    else
                    {
                        unitSymbol = vendInvoiceInfoLine.PurchUnit;
                    }
                }
                break;

            case tableNum(PurchParmLine) :
                if (PurchParmLineAutoChargesUnitConversionFlight::instance().isEnabled())
                {
                    PurchParmLine purchParmLine = PurchParmLine::findRecId(_markupTrans.TransRecId);
                    if (purchParmLine.RecId)
                    {
                        itemId = purchParmLine.ItemId;
                        inventDimId = purchParmLine.InventDimId;
                        unitSymbol = purchParmLine.purchLine().PurchUnit;
                    }
                }
                break;

            case tableNum(VendPackingSlipTrans) :
                if (PurchProductReceiptJourAutoChargesUnitConversionFlight::instance().isEnabled())
                {
                    VendPackingSlipTrans vendPackingSlipTrans = VendPackingSlipTrans::findRecId(_markupTrans.TransRecId);
                    if (vendPackingSlipTrans.RecId)
                    {
                        itemId = vendPackingSlipTrans.ItemId;
                        inventDimId = vendPackingSlipTrans.InventDimId;
                        unitSymbol = vendPackingSlipTrans.PurchUnit;
                    }
                }
                break;
        }

        if (itemId && inventDimId && unitSymbol)
        {
            if (_markupTrans.MarkupCategory == MarkupCategory::UnitSpecificMatch
                    && unitSymbol != _markupTrans.SpecificUnitSymbol)
            {
                return 0;
            }

            EcoResProductUnitConverter ecoResProductUnitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(
                    itemId,
                    inventDimId,
                    unitSymbol,
                    _markupTrans.SpecificUnitSymbol);

            if (ecoResProductUnitConverter.canValueBeConverted())
            {
                return ecoResProductUnitConverter.convertValue(_qty);
            }
            else
            {
                return 0;
            }
        }

        return _qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>connectCustVendTo</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Connects the <c>MarkupTrans</c> table records of type Cust/Vend on an invoice to purchase order.
    /// </summary>
    /// <param name="_bufferPO">
    ///    A purchase order record buffer.
    /// </param>
    /// <param name="_bufferInvoice">
    ///    An invoice record buffer.
    /// </param>
    /// <remarks>
    ///    Only header to header and line to line connections are allowed, and only unconnected
    ///    <c>MarkupTrans</c> record which have exactly one other <c>MarkupTrans</c> record with the same
    ///    <c>MarkupCode</c> value are connected.
    /// </remarks>
    public static void connectCustVendTo(
        Common      _bufferPO,
        Common      _bufferInvoice)
    {
        MarkupTrans markupTransInvoice;
        MarkupTrans markupTransPO;
        TmpMarkupTransConnection tmpMarkupTransConnection;

        // Ensure we are connecting header to header or line to line MarkupTrans
        Debug::assert(
            (_bufferPO.TableId == tableNum(PurchTable) && _bufferInvoice.TableId == tableNum(VendInvoiceInfoSubTable)) ||
            (_bufferPO.TableId == tableNum(PurchLine)  && _bufferInvoice.TableId == tableNum(VendInvoiceInfoLine)));

        ttsbegin;

        while select forupdate markupTransInvoice
                where markupTransInvoice.TransTableId == _bufferInvoice.TableId &&
                        markupTransInvoice.TransRecId == _bufferInvoice.RecId   &&
                       !markupTransInvoice.IsDeleted
        {
            // Only connect Cust/Vend charge codes and MarkupTrans that are not already connected
            if (!markupTransInvoice.isMarkupOfTypeCustVend() || markupTransInvoice.OrigRecId != 0)
            {
                continue;
            }

            // Find all potentially connectable MarkupTrans
            // NOTE: markupTransInvoice.OrigRecId should only be zero, i.e. not connected.
            tmpMarkupTransConnection.fill(_bufferPO.TableId, _bufferPO.RecId, markupTransInvoice.OrigRecId);
            select count(RecId) from tmpMarkupTransConnection
                where tmpMarkupTransConnection.MarkupCode == markupTransInvoice.MarkupCode;

            // Connect if there is one and only one MarkupTrans with the same MarkupCode
            if (tmpMarkupTransConnection.RecId != 1)
            {
                continue;
            }

            select MarkupTransRecId from tmpMarkupTransConnection
                where tmpMarkupTransConnection.MarkupCode == markupTransInvoice.MarkupCode;

            // Update the connection information: point the Invoice MarkupTrans at the PO MarkupTrans
            markupTransInvoice.OrigTableId = markupTransPO.TableId;
            markupTransInvoice.OrigRecId = tmpMarkupTransConnection.MarkupTransRecId;
            markupTransInvoice.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildMarkupTransCopyQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a query for copying the <c>MarkupTrans</c> records from the given table record.
    /// </summary>
    /// <param name = "_bufferFrom">The source table record to copy the markup transactions from.</param>
    /// <returns>A <c>Query</c> object.</returns>
    protected static Query buildMarkupTransCopyQuery(Common _bufferFrom)
    {
        Query query = new Query();
        QueryBuildDataSource markUpTransDataSource = query.addDataSource(tableNum(MarkupTrans));

        markUpTransDataSource.addRange(fieldNum(MarkupTrans, TransTableId)).value(queryValue(_bufferFrom.TableId));
        markUpTransDataSource.addRange(fieldNum(MarkupTrans, TransRecId)).value(queryValue(_bufferFrom.RecId));
        markUpTransDataSource.addRange(fieldNum(MarkupTrans, IsDeleted)).value(queryValue(NoYes::No));
        markUpTransDataSource.addRange(fieldNum(MarkupTrans, MCRBrokerContractFee)).value(queryValue(NoYes::No));

        markUpTransDataSource.addRange(fieldNum(MarkupTrans, InterCompanyCompanyId)).value(strFmt('!((%1 != "%2") && (%3 == %4))',
                fieldStr(MarkupTrans, InterCompanyCompanyId),
                queryvalue(SysQuery::valueEmptyString()),
                fieldStr(MarkupTrans, SourceDocumentLine),
                queryValue(0)));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies <c>MarkupTrans</c> table records that are associated with one table record to another table.
    /// </summary>
    /// <param name="_reverseSign">
    ///    A <c>NoYes</c> enumeration value that determines whether the sign of the value will be reversed on
    ///    the copied records.
    /// </param>
    /// <param name="_bufferFrom">
    ///    The source table record.
    /// </param>
    /// <param name="_bufferTo">
    ///    The destination table record.
    /// </param>
    /// <param name="_copyPostingFields">
    ///    A Boolean value that determines whether the posting fields will be copied; otherwise, they will be
    ///    initialized to default values; optional.
    /// </param>
    /// <param name="_currencyCode">
    ///    The currency code to use during the conversion to the destination table record; optional.
    /// </param>
    /// <param name="_targetAccountingStatus">
    ///    The desired SourceDocumentLineAccountingStatus; optional.
    /// </param>
    /// <param name="_initCalculatedAmount">
    ///    Determines if CalculatedAmount from <c>MarkupTrans</c> should be recalculated; optional.
    /// </param>
    /// <returns>
    ///    The number of <c>MarkupTrans</c> table records copied.
    /// </returns>
    /// <remarks>
    ///    If no <c>currencyCode</c> is provided, the currency code of the destination table record will be
    ///    used for conversion.
    /// </remarks>
    static int copy(
        NoYes _reverseSign,
        Common _bufferFrom,
        Common _bufferTo,
        boolean _copyPostingFields = false,
        CurrencyCode _currencyCode = '',
        SourceDocumentLineAccountingStatus _targetAccountingStatus = SourceDocumentLineAccountingStatus::None,
        boolean _initCalculatedAmount = false
        )
    {
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        int     counter = 0;
        boolean mcrCallCenterEnabled = MCROrderParameters::isCallCenterEnabledAndInUse();

        if ((!mcrCallCenterEnabled
                && !MarkupTrans::existAutoCharges(_bufferTo.TableId, _bufferTo.RecId))
            || (mcrCallCenterEnabled
                && !MarkupTrans::mcrExistNotUserOrOverride(_bufferTo.TableId, _bufferTo.RecId)))
        {
            ttsbegin;

            if (_currencyCode == '')
            {
                CurrencyCodeMap currencyCodeMap = new DictTable(_bufferTo.TableId).fieldName2Id('CurrencyCode') ? _bufferTo : _bufferFrom;
                _currencyCode = currencyCodeMap.CurrencyCode;
            }

            Query query = Markup::buildMarkupTransCopyQuery(_bufferFrom);
            QueryRun queryRun = new QueryRun(query);
            while (queryRun.next())
            {
                MarkupTrans oldMarkupTrans = queryRun.get(tableNum(MarkupTrans));

                MarkupTrans newMarkupTrans;

                if (prmisDefault(_targetAccountingStatus))
                {
                    newMarkupTrans = Markup::copySingleMarkupTrans(_reverseSign, oldMarkupTrans, _currencyCode, _bufferFrom, _bufferTo, _copyPostingFields, _bufferFrom);
                }
                else
                {
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        newMarkupTrans = Markup::copySingleMarkupTrans(_reverseSign, oldMarkupTrans, _currencyCode, _bufferFrom, _bufferTo, _copyPostingFields, _bufferFrom, _targetAccountingStatus, false, _initCalculatedAmount);
                    }
                    else
                    {
                        // </GEERU>
                        newMarkupTrans = Markup::copySingleMarkupTrans(_reverseSign, oldMarkupTrans, _currencyCode, _bufferFrom, _bufferTo, _copyPostingFields, _bufferFrom, _targetAccountingStatus);
                        // <GEERU>
                    }
                    // </GEERU>
                }

                if (SysCountryRegionCode::isLegalEntityInConsolidatedCountryRegion())
                {
                    // Copy line level tax adjustments for miscellaneous charges for country regions that support line level tax adjustments.
                    TaxWorkRegulation::copy(oldMarkupTrans, newMarkupTrans);
                }
                counter++;
            }

            ttscommit;
        }

        return counter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyFromOrderLineWithMultipleDeliveries</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies <c>MarkupTrans</c> table records that are associated with an order line with multiple
    ///    deliveries to the specified delivery line.
    /// </summary>
    /// <param name="orderLine">
    ///    The order line record based on which to create the <c>MarkupTrans</c> records.
    /// </param>
    /// <param name="deliveryLine">
    ///    The delivery line record for which to create the <c>MarkupTrans</c> records.
    /// </param>
    /// <param name="_dlvScheduleMarkupConversionMode">
    ///    The delivery schedule markup conversion mode. In the copy mode, all the <c>MarkupTrans</c> records
    ///    are copied without value changes.
    /// </param>
    /// <param name="_fixedMarkupRemainMap">
    ///    A map to use to store remaining quantities and fixed amounts per <c>RecId</c> value of the
    ///    <c>MarkupTrans</c> record that is associated with the order line.
    /// </param>
    /// <returns>
    ///    The number of <c>MarkupTrans</c> table records that were copied.
    /// </returns>
    /// <remarks>
    ///    Markup records should be copied as part of the order line to delivery schedule conversion
    ///    process.Order line with multiple deliveries should not have any <c>Markup</c> records assigned to
    ///    it after the conversion is completed.
    /// </remarks>
    static int copyFromOrderLineWithMultipleDeliveries(
        SalesPurchLine orderLine,
        SalesPurchLine deliveryLine,
        DlvScheduleMarkupConversionMode _dlvScheduleMarkupConversionMode,
        Map _fixedMarkupRemainMap)
    {
        MarkupTrans oldMarkupTrans;
        Qty         allocateQtyRemain;
        PriceMarkup allocateMarkupRemain;
        MarkupTrans newMarkupTrans;

        int counter = 0;

        if (!MarkupTrans::exist(deliveryLine.TableId, deliveryLine.RecId))
        {
            SalesPurchLineInterface deliverySalesPurchLineInterface = deliveryLine.salesPurchLineInterface();
            SalesPurchLineInterface orderSalesPurchLineInterface = orderLine.salesPurchLineInterface();

            while select oldMarkupTrans
                where oldMarkupTrans.TransTableId == orderLine.TableId &&
                      oldMarkupTrans.TransRecId   == orderLine.RecId
            {
                if ((oldMarkupTrans.MarkupCategory == MarkupCategory::Fixed || oldMarkupTrans.MarkupCategory == MarkupCategory::Proportional)
                    && _dlvScheduleMarkupConversionMode == DlvScheduleMarkupConversionMode::Split)
                {
                    newMarkupTrans.clear();
                    newMarkupTrans = oldMarkupTrans.data();
                    newMarkupTrans.TransTableId = deliveryLine.TableId;
                    newMarkupTrans.TransRecId = deliveryLine.RecId;
                    newMarkupTrans.OrigTableId = orderLine.TableId;
                    newMarkupTrans.OrigRecId = orderLine.RecId;
                    newMarkupTrans.CalculatedAmount = 0;
                    newMarkupTrans.Posted = 0;
                    newMarkupTrans.Voucher = '';
                    newMarkupTrans.TransDate = dateNull();
                    newMarkupTrans.LineNum = MarkupTrans::lastLineNum(newMarkupTrans.TransTableId, newMarkupTrans.TransRecId) + 1;

                    if (_fixedMarkupRemainMap.exists(oldMarkupTrans.RecId))
                    {
                        [allocateQtyRemain, allocateMarkupRemain] = _fixedMarkupRemainMap.lookup(oldMarkupTrans.RecId);
                    }
                    else
                    {
                        allocateQtyRemain = orderSalesPurchLineInterface.parmQty();
                        allocateMarkupRemain = oldMarkupTrans.Value;
                    }

                    if (deliverySalesPurchLineInterface.parmQty() >= allocateQtyRemain)
                    {
                        newMarkupTrans.Value = CurrencyExchangeHelper::amount(allocateMarkupRemain, deliverySalesPurchLineInterface.parmCurrencyCode());
                    }
                    else
                    {
                        newMarkupTrans.Value = CurrencyExchangeHelper::amount(oldMarkupTrans.Value * deliverySalesPurchLineInterface.parmQty() / orderSalesPurchLineInterface.parmQty(), deliverySalesPurchLineInterface.parmCurrencyCode());
                    }

                    newMarkupTrans.insert();

                    // update the remain map
                    allocateQtyRemain       -= deliverySalesPurchLineInterface.parmQty();
                    allocateMarkupRemain    -= newMarkupTrans.Value;
                    _fixedMarkupRemainMap.insert(oldMarkupTrans.RecId, [allocateQtyRemain, allocateMarkupRemain]);
                }
                else
                {
                    newMarkupTrans = Markup::copySingleMarkupTrans(NoYes::No, oldMarkupTrans, orderSalesPurchLineInterface.parmCurrencyCode(), orderLine, deliveryLine, false, orderLine);
                }
                // <GIN>
                if (TaxParameters::checkTaxParameters_IN())
                {
                    newMarkupTrans.updateAssessableValue_IN();
                }
                // </GIN>
                counter++;
            }
        }

        return counter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyFromPurchOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies <c>MarkupTrans</c> table records that are associated with a purchase order table record,
    ///    either <c>PurchTable</c> or <c>PurchLine</c>, to another table record.
    /// </summary>
    /// <param name="_bufferFrom">
    ///    The source table record.
    /// </param>
    /// <param name="_bufferTo">
    ///    The destination table record.
    /// </param>
    /// <param name="_interCompanyInvoiceNum">
    ///    The invoice number used by an intercompany invoice.
    /// </param>
    /// <param name="_currencyCode">
    ///    The currency code to use during conversion to the destination table record; optional.
    /// </param>
    /// <param name="_targetAccountingStatus">
    ///    The desired <c>SourceDocumentLineAccountingStatus</c>; optional.
    /// </param>
    /// <param name="_purchTable">
    ///     The Purchase Order used to resolve the _interCompanyInvoiceNum (last invoice) if it wasn't provided in the method call
    /// </param>
    /// <param name="_interCompanyInvoiceNumPassed">
    ///     A boolean which indicates if defaulting of _interCompanyInvoiceNum should be skipped
    /// </param>
    /// <returns>
    ///    The number of <c>MarkupTrans</c> table records copied.
    /// </returns>
    /// <remarks>
    ///    If no currency code is provided, the currency code of the destination table record will be used for
    ///    conversion.
    /// </remarks>
    [SysObsolete('This method is obsolete. Use MarkupCopy.copyFromPurchOrder() instead.', false, 30\06\2018)]
    static int  copyFromPurchOrder(
        Common _bufferFrom,
        Common _bufferTo,
        Num _interCompanyInvoiceNum,
        CurrencyCode _currencyCode = '',
        SourceDocumentLineAccountingStatus _targetAccountingStatus = SourceDocumentLineAccountingStatus::None,
        PurchTable  _purchTable = null,
        boolean     _interCompanyInvoiceNumPassed = true)
    {
        int counter;
        MarkupCopyFromPurchOrderParameters markupCopyFromPurchOrderParameters;
        MarkupCopy markupCopy;

        markupCopyFromPurchOrderParameters = MarkupCopyFromPurchOrderParameters::createCopyFromPurchOrderParameters(
            _bufferFrom,
            _bufferTo,
            _interCompanyInvoiceNum,
            _currencyCode,
            _targetAccountingStatus,
            _purchTable,
            _interCompanyInvoiceNumPassed);
        markupCopy = MarkupCopy::construct();
        counter = MarkupCopy.copyFromPurchOrder(markupCopyFromPurchOrderParameters);

        return counter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyGoodsInRoute_RU</Name>
				<Source><![CDATA[
    static int copyGoodsInRoute_RU(Common        _bufferFrom,
                                          Common        _bufferTo,
                                          CurrencyCode  _currencyCode)
    {
        MarkupTrans     markupTrans;
        MarkupTable     markupTable;
        int             counter = 0;

        if (!MarkupTrans::exist(_bufferTo.TableId, _bufferTo.RecId))
        {
            ttsbegin;

            while select forupdate markupTrans
                where markupTrans.TransTableId                  == _bufferFrom.TableId
                   && markupTrans.TransRecId                    == _bufferFrom.RecId
                   && markupTrans.GoodsInRouteToDelivery_RU     == NoYes::Yes
            join markupTable
                where markupTable.MarkupCode                    == markupTrans.MarkupCode
                   && markupTable.UseCustPostingTypeTransit_RU  == NoYes::Yes
            {
                Markup::copySingleMarkupTrans(NoYes::Yes,
                                              markupTrans,
                                              _currencyCode,
                                              _bufferFrom,
                                              _bufferTo,
                                              false,
                                              _bufferFrom);
                counter++;
            }

            ttscommit;
        }

        return counter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyGoodsInRouteCancel_RU</Name>
				<Source><![CDATA[
    static int copyGoodsInRouteCancel_RU(Common            _bufferFrom,
                                                Common            _bufferTo,
                                                CurrencyCode      _currencyCode,
                                                GoodsInRouteId_RU _goodsInRouteId)
    {
        MarkupTrans     markupTrans, newMarkupTrans;
        MarkupTable     markupTable;
        int             counter = 0;

        ttsbegin;

        while select forupdate markupTrans
            where markupTrans.TransTableId                  == _bufferFrom.TableId
               && markupTrans.TransRecId                    == _bufferFrom.RecId
               && markupTrans.GoodsInRouteToDelivery_RU     == NoYes::Yes
        join markupTable
            where markupTable.MarkupCode                    == markupTrans.MarkupCode
               && markupTable.UseCustPostingTypeTransit_RU  == NoYes::Yes
        {
            newMarkupTrans = Markup::copySingleMarkupTrans(NoYes::Yes,
                                                           markupTrans,
                                                           _currencyCode,
                                                           _bufferFrom,
                                                           _bufferTo,
                                                           false,
                                                           null,
                                                           SourceDocumentLineAccountingStatus::None,
                                                           true);

            newMarkupTrans.GoodsInRouteId_RU            = _goodsInRouteId;
            newMarkupTrans.Keep                         = NoYes::No;
            newMarkupTrans.update();

            counter++;
        }

        ttscommit;

        return counter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfLineNumberMustBeAssigned</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether need to assign LineNum to MarkupTrans.
    /// </summary>
    /// <param name="_markupTrans">
    /// A <c>MarkupTrans</c> record for which check is performed.
    /// </param>
    /// <returns>
    /// True if need to assign LineNum to MarkupTrans. Otherwise, false.
    /// </returns>
    protected static boolean checkIfLineNumberMustBeAssigned(MarkupTrans _markupTrans)
    {
        // Since MarkupTrans table index TableRecIdIdx is enforcing LineNum to be unique
        if (_markupTrans.TransTableId == tableNum(VendInvoiceInfoSubTable)
            && TaxIntegrationUtils::isChargeOnBOEEnabled())
        {
            return VendInvoiceInfoSubTable::findRecId(_markupTrans.TransRecId).purchTable().isCustomsImportOrder_IN();
        }

        return _markupTrans.TransTableId == tableNum(PurchReqLine) || _markupTrans.TransTableId == tableNum(SalesLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>copySingleMarkupTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies one <c>MarkupTrans</c> table record associated with one table record to another.
    /// </summary>
    /// <param name="_reverseSign">
    ///    A <c>NoYes</c> enumeration value that determines whether the sign of the value will be reversed on
    ///    the copied records.
    /// </param>
    /// <param name="_oldMarkupTrans">
    ///    The source <c>MarkupTrans</c> table record.
    /// </param>
    /// <param name="_currencyCode">
    ///    The currency code to use during the conversion to the destination table record.
    /// </param>
    /// <param name="_bufferFrom">
    ///    The source table record.
    /// </param>
    /// <param name="_bufferTo">
    ///    The destination table record.
    /// </param>
    /// <param name="_copyPostingFields">
    ///    A Boolean value that determines whether the posting fields will be copied; otherwise, they will be
    ///    initialized to default values; optional.
    /// </param>
    /// <param name="_bufferOrig">
    ///    The original document table record that is required if the <paramref name="_copyPostingFields" />
    ///    parameter is false; optional.
    /// </param>
    /// <param name="_targetAccountingStatus">
    ///    The desired SourceDocumentLineAccountingStatus; optional.
    /// </param>
    /// <param name="_initLineNum_RU">
    /// Determines if new markup trans line number neeeded to prevent index dub violation.
    /// </param>
    /// <param name="_initCalculatedAmount">
    ///    Determines if CalculatedAmount from <c>MarkupTrans</c> should be recalculated; optional.
    /// </param>
    /// <returns>
    /// Created MarkupTrans record.
    /// </returns>
    /// <remarks>
    ///    If no <c>currencyCode</c> is provided, the currency code of the destination table record will be
    ///    used for conversion.
    /// </remarks>
    public static MarkupTrans copySingleMarkupTrans(
        NoYes _reverseSign,
        MarkupTrans _oldMarkupTrans,
        CurrencyCode _currencyCode,
        Common _bufferFrom,
        Common _bufferTo,
        boolean _copyPostingFields = false,
        Common _bufferOrig = null,
        SourceDocumentLineAccountingStatus _targetAccountingStatus = SourceDocumentLineAccountingStatus::None,
        boolean _initLineNum_RU = false,
        boolean _initCalculatedAmount = false)
    {
        MarkupTrans newMarkupTrans;
        PurchLine   purchLine;
        boolean     copyPurchReqReferences;
        SalesLine   salesLine;
        SalesTable  salesTableOfSalesLine;
        Markup      markup;
        MarkupTrans icsoOrigChargeFromVirtualCharge;

        // <GEERU>
        boolean     countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        if (_bufferTo.TableId == tableNum(PurchLine))
        {
            purchLine = _bufferTo;
            if (purchLine.LineDeliveryType == LineDeliveryType::DeliveryLine && purchLine.PurchReqId != '')
            {
                copyPurchReqReferences = true;
            }
        }

        newMarkupTrans.clear();
        newMarkupTrans = _oldMarkupTrans.data();

        newMarkupTrans.TransTableId = _bufferTo.TableId;
        newMarkupTrans.TransRecId = _bufferTo.RecId;

        if (Markup::checkIfLineNumberMustBeAssigned(newMarkupTrans))
        {
            newMarkupTrans.LineNum = MarkupTrans::lastLineNum(newMarkupTrans.TransTableId, newMarkupTrans.TransRecId) + 1;
        }

        newMarkupTrans.modifiedField(fieldNum(MarkupTrans, MarkupCategory));
        // <GIN>
        // Following fields for india are reset in the ModifiedField. So, copying below.
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            newMarkupTrans.NotionalCharges_IN    = _oldMarkupTrans.NotionalCharges_IN;
            newMarkupTrans.NotionalPct_IN        = _oldMarkupTrans.NotionalPct_IN;
        }
        // </GIN>

        if (!_copyPostingFields)
        {
            if (copyPurchReqReferences)
            {
                newMarkupTrans.OrigTableId = _oldMarkupTrans.OrigTableId;
                newMarkupTrans.OrigRecId   = _oldMarkupTrans.OrigRecId;
            }
            else
            {
                newMarkupTrans.OrigTableId = _bufferOrig.TableId;
                newMarkupTrans.OrigRecId   = _bufferOrig.RecId;

                if (newMarkupTrans.IntercompanyCompanyId && _bufferOrig is MarkupTrans)
                {
                    icsoOrigChargeFromVirtualCharge = _bufferOrig.getICSOOrigChargeFromICPOVirtualCharge();
                    if (icsoOrigChargeFromVirtualCharge.Keep == NoYes::Yes)
                    {
                        // If we are copying from an IC virtual charge, origRecId should point to the original charge proportional to the qty
                        // (percent, pcs, proportional, etc) and not to the virtual fixed charge created for sync and invoicing purposes
                        newMarkupTrans.OrigRecId = icsoOrigChargeFromVirtualCharge.InterCompanyRefRecId;
                    }
                }
            }

            newMarkupTrans.CalculatedAmount = 0;
            newMarkupTrans.Posted = 0;
            newMarkupTrans.Voucher = '';
            newMarkupTrans.TransDate = dateNull();
            newMarkupTrans.DocumentStatus = DocumentStatus::None;
            newMarkupTrans.CustInvoiceLineIdRef = 0;
            newMarkupTrans.CorrectedMarkupTrans = 0;

            // <GEERU>
            if (countryRegion_RU)
            {
                newMarkupTrans.FacturedAmount_RU = 0;
            }
            // </GEERU>
        }

        if (_reverseSign)
        {
            if (newMarkupTrans.MarkupCategory == MarkupCategory::Fixed
                || newMarkupTrans.MarkupCategory == MarkupCategory::Proportional)
            {
                newMarkupTrans.Value = -_oldMarkupTrans.Value;
            }
            else if (_bufferFrom is ProjInvoiceJour &&
                    newMarkupTrans.MarkupCategory == MarkupCategory::Percent)
            {
                if (_oldMarkupTrans.Keep == NoYes::Yes)
                {
                    newMarkupTrans.Value = -_oldMarkupTrans.Value;
                }
                else
                {
                    // The line of percent markup category apply to all sales order lines which is causing a deviation between original invoice and credit note invoice. Therefore updates MarkupCategory to fixed.
                    // Then charges amount will copied to the new markuptrans record and since markup category also changing to fixed so that amount will calculate correctly.
                    // This is done with the assumption of project credit note line quantity does not allow partial line correction.
                    newMarkupTrans.Value = -_oldMarkupTrans.CalculatedAmount;
                    newMarkupTrans.MarkupCategory = MarkupCategory::Fixed;
                }
            }

            // For credit note and return order process, override sales tax should be yes to ensure the sales tax is the same as original ones.
            newMarkupTrans.OverrideSalesTax = NoYes::Yes;
        }

        newMarkupTrans.convertCurrencyCode(_currencyCode);

        newMarkupTrans.SourceDocumentLine = 0;
        // <GEERU>
        if (countryRegion_RU)
        {
            if (_initCalculatedAmount)
            {
                newMarkupTrans.CalculatedAmount = newMarkupTrans.signedValue(newMarkupTrans.Value);
                newMarkupTrans.CalculatedAmountMST_W = CurrencyExchangeHelper::mstAmount(newMarkupTrans.CalculatedAmount, newMarkupTrans.CurrencyCode, newMarkupTrans.TransDate);
            }
            if (_initLineNum_RU)
            {
                newMarkupTrans.LineNum = MarkupTrans::lastLineNum(newMarkupTrans.TransTableId, newMarkupTrans.TransRecId) + 1;
            }

            newMarkupTrans.GoodsInRouteId_RU = '';
            newMarkupTrans.GoodsInRouteToDelivery_RU = NoYes::No;
        }
        // </GEERU>
        // When the return line is being created from the original line
        // copy the markups with a created type of other.
        if (_bufferTo.TableId == tableNum(SalesLine))
        {
            salesLine = _bufferTo;
            salesTableOfSalesLine = salesLine.salesTable();
            if (salesTableOfSalesLine
               && salesTableOfSalesLine.SalesType == SalesType::ReturnItem)
            {
                newMarkupTrans.MCRMarkupTransCreatedBy = MCRMarkupTransCreatedBy::Other;
            }
        }

        if (!Markup::mcrOverriden(_bufferTo.TableId,
                                 _bufferTo.RecId,
                                 _bufferFrom.TableId,
                                 _bufferFrom.RecId))
        {
            if (prmisDefault(_targetAccountingStatus))
            {
                newMarkupTrans.insert();
            }
            else
            {
                newMarkupTrans.insert(_targetAccountingStatus);
            }
        }

        // Copy tax information to the new line.
        if (TaxIntegrationUtils::isTaxInformationEnabled())
        {
            if (_bufferFrom.TableId != tableNum(PurchRFQCaseLine))
            {
                TransTaxInformationHelper::copyTransTaxInformation(_oldMarkupTrans, newMarkupTrans);
            }
        }

        // <GIN>
        if (TaxParameters::checkTaxParameters_IN())
        {
            MarkupTrans_IN::copyMarkupTransExtension(_oldMarkupTrans, newMarkupTrans);
        }
        // </GIN>

        // If this copying is triggered from a creditnote generation or copying from vendor invoice line
        // and the charge is a Proportional raise the chargeInitialized event
        if (_bufferFrom.TableId == tableNum(VendInvoiceTrans)
           && _bufferTo.TableId == tableNum(PurchLine)
           && newMarkupTrans.MarkupCategory == MarkupCategory::Proportional)
        {
            markup = new Markup(newMarkupTrans.CurrencyCode);
            markup.chargeInitializedInvoke(newMarkupTrans, _oldMarkupTrans, _bufferFrom, _bufferTo, _reverseSign);
        }

        // <GEERU>
        return newMarkupTrans;
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveOriginalQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resolves the original quantity.
    /// </summary>
    /// <param name = "_markupTrans">The <c>MarkupTrans</c> record.</param>
    /// <param name = "_postingQty">The posting quantity.</param>
    /// <returns>The original quantity.</returns>
    protected static Qty resolveOriginalQuantity(MarkupTrans _markupTrans, Qty _postingQty)
    {
        Qty             ret = _postingQty;
        MarkupTrans     ancestorMarkupTrans;
        PurchLine       purchLine;

        // If _markupTrans is original one from PurchLine
        if (_markupTrans.TransTableId == tableNum(PurchLine))
        {
            select firstOnly RecId, PurchQty from purchLine
                where purchLine.Recid == _markupTrans.TransRecId
                    && !purchLine.IsDeleted;
        }
        else
        {
            select RecId, PurchQty from purchLine
            exists join ancestorMarkupTrans
                Where ancestorMarkupTrans.TransRecId    == purchLine.RecId
                    && ancestorMarkupTrans.TransTableId == tableNum(PurchLine)
                    && ancestorMarkupTrans.RecId        == _markupTrans.OrigRecId;
        }

        if (purchLine)
        {
            ret = purchLine.PurchQty;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDeletionDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for allowing deletion of <c>MarkupTrans</c> records.
    /// </summary>
    /// <param name = "_markupTrans">The record to be deleted.</param>
    /// <param name = "_result">A <c>EventHandlerRejectResult</c> instance, where subscribers can reject the deletion.</param>
    static delegate void allowDeletionDelegate(MarkupTrans _markupTrans, EventHandlerRejectResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDeletion</Name>
				<Source><![CDATA[
    private static boolean allowDeletion(MarkupTrans _markupTrans)
    {
        EventHandlerRejectResult result = EventHandlerRejectResult::newDefault();
        Markup::allowDeletionDelegate(_markupTrans, result);
        return !result.isRejected();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteReasonCodeAutoCharges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the auto markups associated with the specified SalesTable record that are auto charges from return reason code.
    /// Needed to prevent adding duplicate charges and avoid deleting user created ones.
    /// </summary>
    /// <param name="_salesTable">
    /// The SalesTable record to delete the markups for.
    /// </param>
    [Hookable(false)]
    internal static void deleteReasonCodeAutoCharges(SalesTable  _salesTable)
    {
        MarkupTrans markupTrans;

        ttsbegin;
       
        while select forupdate markupTrans
            where markupTrans.TransTableId == _salesTable.TableId 
                && markupTrans.TransRecId == _salesTable.RecId
                && (markupTrans.MarkupAutoLineRecId || markupTrans.MarkupAutoTableRecId)
                && markupTrans.IsAutoCharge == NoYes::No
        {
            if (Markup::allowDeletion(markupTrans))
            {
                markupTrans.delete();
            }
        }
        
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the markups associated with the specified record.
    /// </summary>
    /// <param name="_buffer">
    /// The record to delete the markups for.
    /// </param>
    /// <param name="_deleteAutoChargesOnly">
    /// true to delete the automatically generated markups only; otherwise false.
    /// </param>
    public static void delete(Common buffer, boolean _deleteAutoChargesOnly = false)
    {
        Markup::deleteMarkupTrans(buffer, _deleteAutoChargesOnly);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteMarkupTrans</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static void deleteMarkupTrans(Common _buffer, boolean _deleteAutoChargesOnly = false, boolean _deleteCopiedRecords = true)
    {
        MarkupTrans markupTrans;

        ttsbegin;

        while select forupdate markupTrans
            index hint TableRecIdIdx
            where markupTrans.TransTableId == _buffer.TableId 
                  && markupTrans.TransRecId == _buffer.RecId   
                  && (!_deleteAutoChargesOnly || markupTrans.IsAutoCharge == NoYes::Yes)
                  && (_deleteCopiedRecords || !markupTrans.OrigRecId)
        {
            if (Markup::allowDeletion(markupTrans))
            {
                markupTrans.delete();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dlvModeRelation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the DlvModeRelation based on the DlvModeCode
    /// </summary>
    /// <param name="_dlvModeCode">
    /// The delivery mode code - Table/Group/All
    /// </param>
    /// <param name="_dlvMode">
    /// The Delivery mode
    /// </param>
    /// <param name="_groupId">
    /// The delivery charges group
    /// </param>
    /// <returns>
    /// The Delivery mode relation.
    /// </returns>
    static DlvModeRelation dlvModeRelation(TableGroupAll      _dlvModeCode,
                                           DlvModeRelation    _dlvMode,
                                           MarkupGroupId      _groupId)
    {
        switch (_dlvModeCode)
        {
            case TableGroupAll::Table       :   return _dlvMode;
            case TableGroupAll::GroupId     :   return _groupId;
            case TableGroupAll::All         :   return '';
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>fshSkipConcessionMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Skip Concession Markup?
    /// </summary>
    /// <param name="_sourceTable">
    /// Source Table
    /// </param>
    /// <param name="_markupAutoTable">
    /// Markup Auto Table
    /// </param>
    /// <returns>
    /// true if skip concession markup
    /// </returns>
    static boolean fshSkipConcessionMarkup(Common _sourceTable, MarkupAutoTable _markupAutoTable)
    {
        PurchTable      tPurchTable;
        PurchLine       tPurchLine;
        boolean         bRet = false;

        if ( _sourceTable.TableId == tableNum(PurchLine))
        {
            tPurchLine.data( _sourceTable );

            bRet = true;
        }
        else if (_sourceTable.TableId == tableNum(PurchTable) )
        {
            tPurchTable.data( _sourceTable );

            bRet = true;
        }

        return bRet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasMarkupTypeItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether a record has any associated <c>MarkupTrans</c> table records of the item type.
    /// </summary>
    /// <param name="_buffer">
    ///    The record to check.
    /// </param>
    /// <returns>
    ///    true if the record has <c>MarkupTrans</c> table records of type <c>item</c>; otherwise, false.
    /// </returns>
    public static boolean hasMarkupTypeItem(Common _buffer)
    {
        MarkupTrans markupTrans;
        MarkupTable markupTable;

        select firstonly RecId from markupTrans
            where
                markupTrans.TransTableId == _buffer.TableId &&
                markupTrans.TransRecId == _buffer.RecId &&
               !markupTrans.IsDeleted
            exists join markupTable
                 where markupTable.MarkupCode == markupTrans.MarkupCode &&
                    (markupTable.CustType == MarkupType::Item ||
                    markupTable.VendType == MarkupType::Item);

        return markupTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertMarkupTrans</Name>
				<Source><![CDATA[
    public static void insertMarkupTrans(
        HeadingLine         _moduleCategory,
        MarkupModule        _moduleType,
        Common              _source,
        CustVendAC          _account,
        MarkupGroupId       _accountGroup,
        CurrencyCode        _currency,
        LanguageId          _languageId = CompanyInfo::languageId(),
        ItemId              _item = '',
        MarkupGroupId       _itemGroup = '',
        boolean             _invertSign = false,
        boolean             _deleteExistingMarkupTrans = true,
        DlvModeId           _dlvModeId   = '',
        MarkupGroupId       _dlvModeGroup = '',
        Amount              _totalAmount = 0,
        NoYesId             _mcrReturnMarkup  = false)
    {
        MarkupTransInsertParameters parameters = MarkupTransInsertParameters::construct();
        InventDim locInventDimParameters       = Markup::parmInventDimParameters();

        parameters.ModuleCategory = _moduleCategory;
        parameters.ModuleType = _moduleType;
        parameters.Source = _source;
        parameters.Account = _account;
        parameters.AccountGroup = _accountGroup;
        parameters.Currency = _currency;
        parameters.LanguageId = _languageId;
        parameters.Item = _item;
        parameters.InventSiteId = locInventDimParameters.InventSiteId;
        parameters.InventLocationId = locInventDimParameters.InventLocationId;
        parameters.ItemGroup = _itemGroup;
        parameters.InvertSign = _invertSign;
        parameters.DeleteExistingMarkupTrans = _deleteExistingMarkupTrans;
        parameters.DlvModeId = _dlvModeId;
        parameters.DlvModeGroup = _dlvModeGroup;
        parameters.TotalAmount = _totalAmount;
        parameters.McrReturnMarkup = _mcrReturnMarkup;

        MarkupTransInsert markupTransInsert = MarkupTransInsert::construct();
        markupTransInsert.insert(parameters);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findMarkupAutoTableOnInsertReturnMarkupTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the auto charges transaction record on inserting the charges transaction record.
    /// </summary>
    /// <param name = "_moduleCategory">The category in module.</param>
    /// <param name = "_moduleType">Specifies which module the charges group is attached to.</param>
    /// <param name = "_accountCode">The account code.</param>
    /// <param name = "_itemCode">The item code.</param>
    /// <param name = "_itemRelation">The item or group the charges apply to.</param>
    /// <param name = "_markupReturn">Specifies which module the charges group is attached to.</param>
    /// <param name = "_returnRelation">The code identifier.</param>
    /// <returns>The auto charges transaction record if found.</returns>
    static MarkupAutoTable findMarkupAutoTableOnInsertReturnMarkupTrans(
        HeadingLine         _moduleCategory,
        MarkupModule        _moduleType,
        TableGroupAll       _accountCode,
        TableGroupAll       _itemCode,
        ItemRelation        _itemRelation,
        MarkupReturnType    _markupReturn,
        ReturnCode          _returnRelation)
    {
        MarkupAutoTable searchParameters, resultTable;
        searchParameters.initValue();

        searchParameters.ModuleCategory    = _moduleCategory;
        searchParameters.ModuleType        = _moduleType;
        searchParameters.AccountCode       = _accountCode;
        searchParameters.ItemCode          = _itemCode;
        searchParameters.ItemRelation      = _itemRelation;
        searchParameters.MarkupReturn      = _markupReturn;
        searchParameters.ReturnRelation    = _returnRelation;

        if (FeatureStateProvider::isFeatureEnabled(RetailFilterAutoChargesByChannelEnableFeature::instance()))
        {
            searchParameters.RetailChannelCode = TableGroupAll::All;
            searchParameters.RetailChannelRelation = '';
            resultTable = Markup::findMarkupAutoTableOnInsertReturnMarkupTransByNaturalKey(searchParameters);
        }

        if (resultTable.RecId == 0)
        {
            // These search parameters are set to the default upgrade values to support backwards compatibility
            searchParameters.RetailChannelCode = TableGroupAll::Table;
            searchParameters.RetailChannelRelation = '';
            resultTable = Markup::findMarkupAutoTableOnInsertReturnMarkupTransByNaturalKey(searchParameters);
        }

        return resultTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findMarkupAutoTableOnInsertReturnMarkupTransByNaturalKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a <c>MarkupAutoTable</c> record based on provided search parameters.
    /// </summary>
    /// <param name = "_searchParameter">A search parameter.</param>
    /// <returns>A <c>MarkupAutoTable</c> record.</returns>
    protected static MarkupAutoTable findMarkupAutoTableOnInsertReturnMarkupTransByNaturalKey(MarkupAutoTable _searchParameters)
    {
        return MarkupAutoTable::findByNaturalKey(_searchParameters);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertReturnMarkupTrans</Name>
				<Source><![CDATA[
    static void  insertReturnMarkupTrans(
        HeadingLine     moduleCategory,
        MarkupModule    moduleType,
        Common          source,
        CustVendAC      account,
        MarkupGroupId   accountGroup,
        LanguageId      languageId        = CompanyInfo::languageId())
    {
        // RECORd
        MarkupAutoTable         markupAutoTable;
        MarkupAutoLine          markupAutoLine;
        MarkupTrans             markupTrans;

        SalesTable              salesTable;
        SalesLine               salesLine;
        CurrencyCode            salesCurrency;

        // VAr
        TableGroupAll       accountCode = TableGroupAll::Table;
        TableGroupAll       itemCode;

        CustVendRel         accountRelation;
        ItemRelation        itemRelation;
        InventSiteId        inventSiteId;
        InventLocationId    inventLocationId;

        ttsbegin;

        switch (source.TableId)
        {
            case tableNum(SalesTable)       :
                salesTable = source;
                salesCurrency = salesTable.CurrencyCode;
                moduleCategory = HeadingLine::Heading;
                itemCode = TableGroupAll::All;
                inventSiteId = salesTable.InventSiteId;
                InventLocationId = salesTable.InventLocationId;
                break;

            case tableNum(SalesLine)        :
                salesLine = source;
                salesCurrency = salesLine.CurrencyCode;
                moduleCategory = HeadingLine::Line;
                itemCode = TableGroupAll::Table;

                InventDim inventDim = salesLine.inventDim();
                inventSiteId = inventDim.InventSiteId;
                InventLocationId = inventDim.InventLocationId;
                break;
        }

        if (Markup::activated(moduleCategory, moduleType))
        {
            while (accountCode <= TableGroupAll::All)
            {
                while (itemCode <= TableGroupAll::All)
                {
                    accountRelation     = Markup::accountRelation(accountCode, account, accountGroup);
                    itemRelation        = Markup::itemRelation(itemCode,'','');

                    if (Markup::validateRelation(accountCode, accountRelation)  &&
                        Markup::validateRelation(itemCode, itemRelation))
                    {
                        if (salesTable)
                        {
                            markupAutoTable = Markup::findMarkupAutoTableOnInsertReturnMarkupTrans(moduleCategory,
                                                                                                   moduleType,
                                                                                                   accountCode,
                                                                                                   itemCode,
                                                                                                   itemRelation,
                                                                                                   ReturnCodeType::Reason,
                                                                                                   salesTable.ReturnReasonCodeId);
                        }
                        if (salesLine)
                        {
                            markupAutoTable = Markup::findMarkupAutoTableOnInsertReturnMarkupTrans(moduleCategory,
                                                                                                   moduleType,
                                                                                                   accountCode,
                                                                                                   itemCode,
                                                                                                   itemRelation,
                                                                                                   ReturnCodeType::Disposition,
                                                                                                   salesLine.ReturnDispositionCodeId);
                        }
                        if (markupAutoTable)
                        {
                            boolean checkInventDim = SalesReturnChargesWithInventDimFlight::instance().isEnabled();

                            while select markupAutoLine
                                index hint TableIdx
                                where markupAutoLine.TableTableId == markupAutoTable.TableId
                                    && markupAutoLine.TableRecId == markupAutoTable.RecId
                                    && markupAutoLine.CurrencyCode == salesCurrency
                                    && (!checkInventDim || !markupAutoLine.InventSiteId || markupAutoLine.InventSiteId == inventSiteId)  
                                    && (!checkInventDim || !markupAutoLine.InventLocationId || markupAutoLine.InventLocationId == inventLocationId)

                            {
                                markupTrans.clear();
                                markupTrans.initFromMarkupTable(markupAutoLine.markupTable());
                                markupTrans.initFromMarkupAutoLine(markupAutoLine);
                                markupTrans.initSequenceCompoundSpecificUoMFromMarkupAutoLine(markupAutoLine, source);

                                switch (source.TableId)
                                {
                                    case tableNum(SalesTable)       :
                                        markupTrans.initFromSalesTable(source);
                                        break;
                                    case tableNum(SalesLine)        :
                                        markupTrans.initFromSalesLine(source);
                                        if (salesLine.ReturnDispositionCodeId)
                                        {
                                            markupTrans.IsAutoCharge = true;
                                        }
                                        break;
                                }
                                // Preserve original set up currency
                                if (markupTrans.markupTable().CustType != MarkupType::CustVend &&
                                    markupTrans.markupTable().VendType != MarkupType::CustVend)
                                {
                                    markupTrans.CurrencyCode    = markupAutoLine.MarkupCurrencyCode;
                                }

                                markupTrans.TransTableId    = source.TableId;
                                markupTrans.TransRecId      = source.RecId;
                                markupTrans.LineNum         = MarkupTrans::lastLineNum(source.TableId, source.RecId) + 1;

                                if (languageId)
                                    markupTrans.Txt = LanguageTxt::languageId(tableNum(MarkupAutoTable), markupAutoLine.RecId, languageId);

                                if (! markupTrans.Txt)
                                    markupTrans.Txt = MarkupTable::find(markupAutoLine.ModuleType, markupAutoLine.MarkupCode).Txt;

                                markupTrans.insert();
                            }
                        }
                        // if ((ItemRelation ....
                    }
                    // while (ItemCode ....
                    itemCode += 1;
                }
                accountCode += 1;
            }

            MarkupTransInsert::applyCompoundingPositionNumberToAutoCharges(moduleCategory, source);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPercentageMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the given <c>MarkupTrans</c> table record has an intercompany or regular percent
    ///    markup.
    /// </summary>
    /// <param name="_markupTrans">
    ///    The <c>MarkupTrans</c> table record to test.
    /// </param>
    /// <returns>
    ///    true if the <c>MarkupTrans</c> table record has an intercompany or regular percent markup;
    ///    otherwise, false.
    /// </returns>
    public static boolean isPercentageMarkup(MarkupTrans _markupTrans)
    {
        if (_markupTrans.MarkupCategory == MarkupCategory::InterCompanyPercent || _markupTrans.MarkupCategory == MarkupCategory::Percent)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemRelation</Name>
				<Source><![CDATA[
    static ItemRelation itemRelation(TableGroupAll      itemCode,
                                     ItemRelation       item,
                                     MarkupGroupId      groupId)
    {
        switch (itemCode)
        {
            case TableGroupAll::Table       :   return item;
            case TableGroupAll::GroupId     :   return groupId;
            case TableGroupAll::All         :   return '';
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCalcFixedMiscCharge</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates all of the miscellaneous charges of type fixed.
    /// </summary>
    /// <param name="_markupTrans">
    ///     The fixed miscellaneous charge record for which the amount is calculated.
    /// </param>
    /// <param name="_absoluteValue">
    ///     The numerator of the pro-rated equation.
    /// </param>
    /// <param name="_qty">
    ///     The inventory quantity for which the markup amount will be calculated.
    /// </param>
    /// <param name="_postingInvoice">
    ///     The posting invoice related to the reference record.
    /// </param>
    /// <param name="_parmId">
    ///     The parameter ID for which the markup amount will be calculated.
    /// </param>
    /// <returns>
    ///     The sum of all fixed miscellaneous charges for the record.
    /// </returns>
    internal static MarkupAmount mcrCalcFixedMiscCharge(MarkupTrans      _markupTrans,
                                                       AmountCur        _absoluteValue,
                                                       Qty              _qty,
                                                       boolean          _postingInvoice = false,
                                                       ParmId           _parmId = '')
    {
        MarkupAmount markupAmount;

        if (_markupTrans.mcrIsProRated())
        {
            markupAmount = Markup::mcrCalcFixedProRated(_markupTrans, _absoluteValue, _qty, _postingInvoice, _parmId);
        }
        else
        {
            markupAmount = _markupTrans.Value;
        }

        markupAmount = CurrencyExchangeHelper::amount(markupAmount, _markupTrans.CurrencyCode);

        return markupAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCalcFixedProRated</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates pro-rated misc charges for SalesLine and SalesTable.
    /// </summary>
    /// <param name="_markupTrans">
    ///     The markup transaction record on which the pro-rated markup calculation will be performed.
    /// </param>
    /// <param name="_absoluteValue">
    ///     The absolute value of the current order markup.
    /// </param>
    /// <param name="_qty">
    ///     The inventory quantity of the order.
    /// </param>
    /// <param name="_postingInvoice">
    ///     A value indicating if the invoice is in the process of being invoiced.
    /// </param>
    /// <param name="_parmId">
    ///     The parm value used in child methods only.
    /// </param>
    /// <returns>
    ///     The calculated pro rated markup amount.
    /// </returns>
    /// <remarks>
    ///     Pro-rated misc charges always store the REMAINING misc charge in the value field.  The
    ///     pro-rated amount is calculated in this method.
    ///     During invoicing the pro-rated amount is copied to the value field of a new MarkupTrans
    ///     record in the insertJournalMarkupTrans method.  The pro-rated amount is subtracted from
    ///     the original remaining amount to find the new remaining amount.
    ///     Calculating percentage of pro-rated misc charges using a "remaining amount" approach
    ///     rather than a "total amount" approach.
    ///     a) In the total amount approach the denominator of proportion is total order amount.  The
    ///     proportion is multiplied by the total value of the misc. charge.
    ///     b) In the remaining amount approach the denominator of the proportion is the remaining order
    ///     amount.  The proportion is multiplied by the remaining value of the misc. charge.
    ///     Procedure for pro-rating SalesTable charges
    ///     1) Calculate remaining sales balance
    ///     2) Make SalesTotals object from _salesTable and calculate absolute value balance.
    /// </remarks>
    private static MarkupAmount mcrCalcFixedProRated(MarkupTrans    _markupTrans,
                                                     AmountCur      _absoluteValue,
                                                     Qty            _qty,
                                                     boolean        _postingInvoice = false,
                                                     ParmId         _parmId = '')
    {
        SalesLine           salesLine;
        SalesTotals         salesTotals;
        MarkupAmount        markupAmount;
        AmountCur           remainingSalesBalance;
        SalesTable          salesTable;

        if (_markupTrans.TransTableId == tableNum(SalesLine) && _qty != 0)
        {
            // Handling of sales line misc charge pro-ration.
            salesLine = SalesLine::findRecId(_markupTrans.TransRecId);
            if (_postingInvoice)
            {
                // If posting the invoiced is in a mixed state, the remaining sales has been lowered but the value has not
                markupAmount = ((_qty / (_qty + salesLine.RemainSalesFinancial + salesLine.RemainSalesPhysical))
                                * _markupTrans.Value);
            }
            else
            {
                if (salesLine.RemainSalesFinancial + salesLine.RemainSalesPhysical == 0)
                {
                    markupAmount = _markupTrans.Value;
                }
                else
                {
                    markupAmount = ((_qty / (salesLine.RemainSalesFinancial + salesLine.RemainSalesPhysical))
                                * _markupTrans.Value);
                }
            }
        }
        else if (_markupTrans.TransTableId == tableNum(SalesTable))
        {
            salesTable  = SalesTable::findRecId(_markupTrans.TransRecId);
            salesTotals = SalesTotals::construct(salesTable);

            remainingSalesBalance = salesTotals.mcrTotalBalanceAbsoluteValue();

            if (_postingInvoice)
            {
                if (_absoluteValue + remainingSalesBalance)
                {
                    // If posting the invoiced is in a mixed state, the remaining sales has been lowered but the value has not.
                    markupAmount = (_absoluteValue / (_absoluteValue + remainingSalesBalance) * _markupTrans.Value);
                }
                else
                {
                    // The markup amount should be return '0' if all lines are posted.
                    return markupAmount;
                }
            }
            else
            {
                if (remainingSalesBalance == 0)
                {
                    markupAmount = _markupTrans.Value;
                }
                else
                {
                    markupAmount = (_absoluteValue / remainingSalesBalance) * _markupTrans.Value;
                }
            }
        }
        else
        {
            markupAmount = _markupTrans.Value;
        }

        return markupAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCopyForReturn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies the passed <c>Common</c> buffer information to the other passed <c>Common</c> buffer.
    /// </summary>
    /// <param name="_bufferFrom">
    /// The <c>Common</c> buffer being copied from.
    /// </param>
    /// <param name="_bufferTo">
    /// The <c>Common</c> buffer being copied to.
    /// </param>
    public static void mcrCopyForReturn(Common _bufferFrom, Common _bufferTo)
    {
        MCRMarkupCopyForReturn::construct().copy(_bufferFrom, _bufferTo);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDeleteNonUser</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Deletes all the markuptrans records tied to the buffer's record that are not user created.
    /// </summary>
    /// <param name="_buffer">
    ///     The record whose markup transactions are being deleted.
    /// </param>
    static public void mcrDeleteNonUser(Common  _buffer)
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            ttsbegin;

            QueryRun queryRun = new QueryRun(Markup::mcrDeleteNonUserQuery(_buffer));
            while (queryRun.next())
            {
                MarkupTrans markupTrans = queryRun.get(tableNum(MarkupTrans));
                markupTrans.delete();
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDeleteNonUserQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a query for deleting all the markuptrans records tied to the buffer's record that are not user created.
    /// </summary>
    /// <param name="_buffer">The record whose markup transactions are being deleted.</param>
    /// <returns>The query.</returns>
    static protected Query mcrDeleteNonUserQuery(Common  _buffer)
    {
        Query query = new Query();

        QueryBuildDataSource qbds = query.addDataSource(tableNum(MarkupTrans));
        qbds.update(true);
        qbds.addRange(fieldNum(MarkupTrans, TransRecId)).value(queryValue(_buffer.RecId));
        qbds.addRange(fieldNum(MarkupTrans, TransTableId)).value(queryValue(_buffer.TableId));
        qbds.addRange(fieldNum(MarkupTrans, MCRMarkupTransCreatedBy)).value(SysQuery::valueNot(MCRMarkupTransCreatedBy::User));
        qbds.addRange(fieldNum(MarkupTrans, MCRMiscChargeOverride)).value(queryValue(NoYes::No));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrOverriden</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether miscellaneous charges are already attached to this record and have been overridden.
    /// </summary>
    /// <param name="_tableId">
    /// The <c>TableId</c> object to check for miscellaneous charge overrides.
    /// </param>
    /// <param name="_recId">
    /// The record ID to check for miscellaneous charge overrides.
    /// </param>
    /// <param name="_fromTableId">
    /// The original table ID to check for miscellaneous charge overrides.
    /// </param>
    /// <param name="_fromRecId">
    /// The original record ID to check for miscellaneous charge overrides.
    /// </param>
    /// <returns>
    /// true if the miscellaneous charges exist and have been overridden; otherwise, false.
    /// </returns>
    public static boolean mcrOverriden(TableId _tableId, RecId _recId, TableId _fromTableId, RecId _fromRecId)
    {
        // Returns whether misc. charges are already attached to this record and have been overridden
        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter))
            && _tableId
            && _recId)
        {
            return (select firstonly RecId from markupTrans
                        where markupTrans.TransRecId == _recId
                            && markupTrans.TransTableId == _tableId
                            && markupTrans.OrigRecId == _fromRecId
                            && markupTrans.OrigTableId == _fromTableId
                            && markupTrans.MCRMiscChargeOverride == NoYes::Yes).RecId != 0;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>move</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Moves <c>MarkupTrans</c> table records that are associated with one table record to another table,
    ///    without conditions.
    /// </summary>
    /// <param name="_fromTableId">
    ///    The source <c>TableId</c> value.
    /// </param>
    /// <param name="_fromRecId">
    ///    The source <c>RecId</c> value.
    /// </param>
    /// <param name="_toTableId">
    ///    The destination <c>TableId</c> value.
    /// </param>
    /// <param name="_toRecId">
    ///    The destination <c>RecId</c> value.
    /// </param>
    static void move(
        TableId     _fromTableId,
        RecId       _fromRecId,
        TableId     _toTableId,
        RecId       _toRecId)
    {
        MarkupTrans markupTrans;

        ttsbegin;

        while select forupdate markupTrans
            where markupTrans.TransTableId == _fromTableId &&
                  markupTrans.TransRecId   == _fromRecId   &&
                 !markupTrans.IsDeleted
        {
            markupTrans.TransTableId = _toTableId;
            markupTrans.TransRecId = _toRecId;

            markupTrans.LineNum = MarkupTrans::lastLineNum(_toTableId, _toRecId) + 1;

            markupTrans.update();
        }

        while select forupdate markupTrans
            where markupTrans.OrigTableId == _fromTableId &&
                  markupTrans.OrigRecId   == _fromRecId   &&
                  !markupTrans.IsDeleted
        {
            markupTrans.OrigTableId = _toTableId;
            markupTrans.OrigRecId = _toRecId;
            markupTrans.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recopyFromPurchOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Overwrites the <c>MarkupTrans</c> table records associated with a purchase order table record,
    ///    either <c>PurchTable</c> or <c>PurchLine</c>, to another table record.
    /// </summary>
    /// <param name="_bufferFrom">
    ///    The source table record.
    /// </param>
    /// <param name="_bufferTo">
    ///    The destination table record.
    /// </param>
    /// <param name="_interCompanyInvoiceNum">
    ///    The invoice number used by an intercompany invoice.
    /// </param>
    /// <param name="_currencyCode">
    ///    The currency code to use during conversion to the destination table record; optional.
    /// </param>
    /// <returns>
    ///    The number of <c>MarkupTrans</c> table records copied.
    /// </returns>
    /// <remarks>
    ///    If no <c>currencyCode</c> is provided, the currency code of the destination table record will be
    ///    used for conversion.
    ///    This method clears <c>MarkupTrans</c> records that already exist. The
    ///    <c>MarkupCopy.copyFromPurchOrder</c> method will not overwrite <c>MarkupTrans</c> records that already
    ///    exist.
    /// </remarks>
    static int  recopyFromPurchOrder(
        Common          _bufferFrom,
        Common          _bufferTo,
        Num             _interCompanyInvoiceNum,
        CurrencyCode    _currencyCode = '')
    {
        MarkupTrans     markupTrans;
        int             records;
        MarkupCopy      markupCopy;

        ttsbegin;

        delete_from markupTrans
            where markupTrans.TransTableId == _bufferTo.TableId
               && markupTrans.TransRecId == _bufferTo.RecId;

        MarkupCopyFromPurchOrderParameters copyFromPurchOrderParameters =
            MarkupCopyFromPurchOrderParameters::createCopyFromPurchOrderParameters(
                _bufferFrom,
                _bufferTo,
                _interCompanyInvoiceNum,
                _currencyCode);
        markupCopy = MarkupCopy::construct();
        records = markupCopy.copyFromPurchOrder(copyFromPurchOrderParameters);

        ttscommit;

        return records;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveFromPurchOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves MarkupTrans table records associated with a purchase order table record, either <c>PurchTable</c> or <c>PurchLine</c>, to another table record.
    /// </summary>
    /// <param name="_bufferFrom">
    /// The source table record.
    /// </param>
    /// <param name="_bufferTo">
    /// The destination table record.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code to use during conversion to the destination table record.
    /// </param>
    /// <returns>
    /// The number of MarkupTrans table records copied.
    /// </returns>
    static int saveFromPurchOrder(
        Common          _bufferFrom,
        Common          _bufferTo,
        CurrencyCode    _currencyCode)
    {
        MarkupTrans     oldMarkupTrans;
        MarkupTable     markupTable;
        boolean         skipZeroValueMarkupTrans = _bufferFrom.TableId == tableNum(PurchTable);
        int             counter = 0;

        Debug::assert(_bufferFrom.TableId == tableNum(PurchTable) || _bufferFrom.TableId == tableNum(PurchLine));
        Debug::assert(_bufferTo.TableId == tableNum(VendInvoiceInfoSubTable) || _bufferTo.TableId == tableNum(VendInvoiceInfoLine));

        ttsbegin;

        while select oldMarkupTrans
            where oldMarkupTrans.TransTableId == _bufferFrom.TableId &&
                  oldMarkupTrans.TransRecId == _bufferFrom.RecId &&
                 !oldMarkupTrans.IsDeleted
        {
            if (oldMarkupTrans.Value == 0 && skipZeroValueMarkupTrans)
            {
                continue;
            }

            markupTable = oldMarkupTrans.markupTable();
            if (markupTable.isMarkupOfTypeCustVend())
            {
                continue;
            }

            // Only copy if the MarkupTrans is marked Keep or if it is not connected
            if (!oldMarkupTrans.Keep && !oldMarkupTrans.connectedFromSet().empty())
            {
                continue;
            }

            Markup::copySingleMarkupTrans(false, oldMarkupTrans, _currencyCode, _bufferFrom, _bufferTo, false, oldMarkupTrans);
            counter++;
        }

        ttscommit;

        return counter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMarkupKeepForIntercompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>Keep</c> field on the <c>MarkupTrans</c> records for sales and purchase orders to valid
    ///    values in an intercompany scenario.
    /// </summary>
    /// <param name="_source">
    ///    The source table for which to validate and set the <c>Keep</c> field.
    /// </param>
    static public void setMarkupKeepForIntercompany(Common _source)
    {
        MarkupTrans markupTrans;
        if ((select firstonly markupTrans
            where markupTrans.TransRecId == _source.RecId
                && markupTrans.TransTableId == _source.TableId
                && ((markupTrans.Keep == NoYes::Yes && markupTrans.MarkupCategory == MarkupCategory::Fixed)
                    || (markupTrans.Keep == NoYes::No && markupTrans.MarkupCategory != MarkupCategory::Fixed))).RecId != 0)
        {
            update_recordset markupTrans
                setting Keep = markupTrans.MarkupCategory != MarkupCategory::Fixed
                where markupTrans.TransRecId == _source.RecId
                    && markupTrans.TransTableId == _source.TableId
                    && ((markupTrans.Keep == NoYes::Yes && markupTrans.MarkupCategory == MarkupCategory::Fixed)
                        || (markupTrans.Keep == NoYes::No && markupTrans.MarkupCategory != MarkupCategory::Fixed));
            warning("@SYS331515");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showMiscChargeMaximumLimitWarning</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks the accounts payable parameters using the table ID to determine whether to display or hide
    ///    warning on the saving of miscellaneous charges on purchase orders, invoices, and auto-miscellaneous.
    /// </summary>
    /// <param name="_tableId">
    ///    The table ID of the table to which the miscellaneous charges are associated.
    /// </param>
    public static void showMiscChargeMaximumLimitWarning(TableId _tableId)
    {
        switch (_tableId)
        {
            case tableNum(MarkupAutoLine):
                if (VendParameters::find().PostInvoiceMatchDiscrepancies == InvoiceMatchPostingOption::AllowWithWarning)
                {
                    checkFailed("@SYS134344");
                }
                break;

            case tableNum(VendInvoiceJour):
            case tableNum(VendInvoiceTrans):
            case tableNum(VendInvoiceInfoTable):
            case tableNum(VendInvoiceInfoSubTable):
            case tableNum(VendInvoiceInfoLine):

                if (VendParameters::find().PostInvoiceMatchDiscrepancies == InvoiceMatchPostingOption::AllowWithWarning)
                {
                    checkFailed("@SYS134344");
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarkupAsPosted</Name>
				<Source><![CDATA[
    public static void updateMarkupAsPosted(Common _line, DocumentStatus _documentStatus = DocumentStatus::None  )
    {
        MarkupTrans markupTrans;

        if (_documentStatus == DocumentStatus::PickingList)
        {
            ttsbegin;

            markupTrans.skipDataMethods(true);

            update_recordset markupTrans
                setting DocumentStatus = _documentStatus
                where markupTrans.TransTableId      == _line.TableId &&
                      markupTrans.TransRecId        == _line.RecId   &&
                      markupTrans.Keep              == NoYes::No     &&
                      markupTrans.DocumentStatus    != DocumentStatus::PickingList &&
                      markupTrans.DocumentStatus    != DocumentStatus::PackingSlip;

            ttscommit;
        }
        else if (_documentStatus == DocumentStatus::PackingSlip)
        {
            ttsbegin;

            markupTrans.skipDataMethods(true);

            update_recordset markupTrans
                setting DocumentStatus = _documentStatus
                where markupTrans.TransTableId      == _line.TableId &&
                      markupTrans.TransRecId        == _line.RecId   &&
                      markupTrans.Keep              == NoYes::No     &&
                      markupTrans.DocumentStatus    != DocumentStatus::PackingSlip;

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateRelation</Name>
				<Source><![CDATA[
    static boolean  validateRelation(
        TableGroupAll   code,
        str             relation)
    {
        boolean         ok = true;

        if ( relation  &&  code == TableGroupAll::All)
            ok = false;

        if (!relation  &&  code != TableGroupAll::All)
            ok = false;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertChargeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a charge value from one currency to another currency.
    /// </summary>
    /// <param name = "_value">
    /// A charge value to convert.
    /// </param>
    /// <param name = "_markupCategory">
    /// The charge value category.
    /// </param>
    /// <param name = "_fromCurrencyCode">
    /// A currency to convert from.
    /// </param>
    /// <param name = "_fromCurrencyCode">
    /// A currency to convert from.
    /// </param>
    /// <param name = "_toCurrencyCode">
    /// A currency to convert to.
    /// </param>
    /// <param name = "_exchRateDate">
    /// An exchange rate date to use to retrieve exchange rate information.
    /// </param>
    /// <returns>
    /// The converted charge value.
    /// </returns>
    static public MarkupValue convertChargeValue(MarkupValue    _value,
                                                 MarkupCategory _markupCategory,
                                                 CurrencyCode   _fromCurrencyCode,
                                                 CurrencyCode   _toCurrencyCode,
                                                 TransDate      _exchRateDate)
    {
        MarkupValue value = _value;

        switch (_markupCategory)
        {
            case MarkupCategory::Fixed:
            case MarkupCategory::Proportional:
            case MarkupCategory::External:
                value = CurrencyExchangeHelper::curAmount2CurAmount(_value, _fromCurrencyCode, _toCurrencyCode, _exchRateDate);
                break;

            case MarkupCategory::Pcs:
                value = ExchangeRateHelper::curPrice2CurPrice(_value, _fromCurrencyCode, _toCurrencyCode, _exchRateDate);
                break;
            case MarkupCategory::UnitSpecific:
            case MarkupCategory::UnitSpecificMatch:
                if (AutoChargesSetupLineLevelUnitOfMeasureFeature::instance().IsEnabled())
                {
                    value = ExchangeRateHelper::curPrice2CurPrice(_value, _fromCurrencyCode, _toCurrencyCode, _exchRateDate);
                }
                break;

        }

        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertChargeValueToAccountingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a charge value from a currency to accounting currency.
    /// </summary>
    /// <param name = "_value">
    /// A charge value to convert.
    /// </param>
    /// <param name = "_markupCategory">
    /// The charge value category.
    /// </param>
    /// <param name = "_fromCurrencyCode">
    /// A currency to convert from.
    /// </param>
    /// <param name = "_exchRateDate">
    /// An exchange rate date to use to retrieve exchange rate information.
    /// </param>
    /// <param name = "_fixedExchRate">
    /// A fixed exchange rate to use for the conversion.
    /// </param>
    /// <returns>
    /// The converted charge value in accounting currency.
    /// </returns>
    static public MarkupValue convertChargeValueToAccountingCurrency(MarkupValue    _value,
                                                                     MarkupCategory _markupCategory,
                                                                     CurrencyCode   _fromCurrencyCode,
                                                                     TransDate      _exchRateDate,
                                                                     CustExchRate   _fixedExchRate)
    {
        MarkupValue value = _value;

        switch (_markupCategory)
        {
            case MarkupCategory::Fixed:
            case MarkupCategory::Proportional:
            case MarkupCategory::External:
                value =  CurrencyExchangeHelper::mstAmount(_value, _fromCurrencyCode, _exchRateDate, UnknownNoYes::No, _fixedExchRate, 0);
                break;
            case MarkupCategory::Pcs:
                value = ExchangeRateHelper::mstPrice(_value, _fromCurrencyCode, _exchRateDate, UnknownNoYes::No, _fixedExchRate, 0);
                break;
            case MarkupCategory::UnitSpecific:
            case MarkupCategory::UnitSpecificMatch:
                if (AutoChargesSetupLineLevelUnitOfMeasureFeature::instance().IsEnabled())
                {
                    value = ExchangeRateHelper::mstPrice(_value, _fromCurrencyCode, _exchRateDate, UnknownNoYes::No, _fixedExchRate, 0);
                }
        }

        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundChargeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds off a charge value.
    /// </summary>
    /// <param name = "_value">
    /// A charge value to round off.
    /// </param>
    /// <param name = "_markupCategory">
    /// The charge value category.
    /// </param>
    /// <param name = "_currencyCode">
    /// A currency to use to lookup the rounding rule.
    /// </param>
    /// <returns>
    /// The rounded off charge value.
    /// </returns>
    static public MarkupValue roundChargeValue(MarkupValue    _value,
                                               MarkupCategory _markupCategory,
                                               CurrencyCode   _currencyCode)
    {
        MarkupValue value = _value;

        switch (_markupCategory)
        {
            case MarkupCategory::Fixed:
            case MarkupCategory::Proportional:
            case MarkupCategory::External:
                value =  CurrencyExchangeHelper::amount(_value, _currencyCode);
                break;
            case MarkupCategory::Pcs:
                value = CurrencyExchangeHelper::price(_value, _currencyCode);
                break;
            case MarkupCategory::UnitSpecific:
            case MarkupCategory::UnitSpecificMatch:
                if (AutoChargesSetupLineLevelUnitOfMeasureFeature::instance().IsEnabled())
                {
                    value = CurrencyExchangeHelper::price(_value, _currencyCode);
                }
                break;
        }

        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates charges for the <c>MarkupTrans</c> record.
    /// </summary>
    /// <param name = "_qty">A <c>Qty</c> value.</param>
    /// <param name = "_value">An <c>AmountCur</c> value.</param>
    /// <param name = "_source">The source record.</param>
    /// <param name = "_documentStatus">A <c>DocumentStatus</c> value.</param>
    /// <param name = "_interCompanyValue">An <c>AmountCur</c> value which is the intercompany value.</param>
    /// <param name = "_invoiceId">An <c>InvoiceId</c> value.</param>
    /// <param name = "_absoluteValue">An <c>AmountCur</c> value which is the absolute value.</param>
    /// <param name = "_parmId">A <c>ParmId</c> value.</param>
    /// <param name = "_parmMCRTableRefId">A MCR table reference id.</param>
    /// <param name = "_isInterCompanyMarkup">A boolean value indicating if it is an intercompany markup record calculation.</param>
    /// <param name = "_searchInvoiceId">A boolean value indicating whether to search invoice id.</param>
    /// <param name = "_selectForUpdate">A boolean value that indicates whether to read the record for an update.</param>
    protected void calcInternal(Qty             _qty,
                                AmountCur       _value,
                                Common          _source,
                                DocumentStatus  _documentStatus,
                                AmountCur       _interCompanyValue,
                                InvoiceId       _invoiceId,
                                AmountCur       _absoluteValue,
                                ParmId          _parmId,
                                TradeLineRefId  _parmMCRTableRefId,
                                boolean         _isInterCompanyMarkup,
                                boolean         _searchInvoiceId,
                                boolean         _selectForUpdate)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().chargeCalculationActivities().calcInternal())
        {
            TradeCommonIEnumerator markupTransEnumerator = this.parmMarkupEnumerable().markupEnumerable(_source.TableId, _source.RecId, _selectForUpdate).getEnumerator();

            while (markupTransEnumerator.moveNext())
            {
                MarkupAmount markupAmount;

                MarkupTrans markupTrans = markupTransEnumerator.current();

                if (this.skipMarkupTransCalculation(markupTrans))
                {
                    continue;
                }

                this.calculateMarkup(markupTrans, _qty, _value, _source, _documentStatus, _interCompanyValue, _invoiceId, _absoluteValue, _parmId, _parmMCRTableRefId, _isInterCompanyMarkup, _searchInvoiceId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMarkupTransValueForProjSales</Name>
				<Source><![CDATA[
    internal static void setMarkupTransValueForProjSales(MarkupTrans _markupTrans)
    {
        SalesTable salesTableLoc = SalesTable::findRecId(_markupTrans.TransRecId);

        // When value is negative and keep column is marked in <c>MarkupTrans</c> form,
        // calculate correct transaction currency amount in the invoice proposal for credit note.
        if (salesTableLoc.ProjId
            && _markupTrans.Keep == NoYes::Yes
            && _markupTrans.Value < 0
            && _markupTrans.isMarkupSalesRelated())
        {
            SalesTable salesTable;
            SalesLine salesLine;

            select RecId, SalesId, ProjId, InventTransIdReturn from salesLine
                exists join salesTable
                where salesTable.RecId == _markupTrans.TransRecId
                    && salesTable.TableId == _markupTrans.TransTableId
                    && salesTable.SalesId == salesLine.SalesId
                    && salesLine.ProjId != ''
                    && salesLine.InventTransIdReturn != '';

            if (salesLine.RecId)
            {
                _markupTrans.Value = -_markupTrans.Value;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProratedMarkupTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specific markup trans is prorated or not.
    /// </summary>
    /// <param name = "_markupTrans">The <c>MarkupTrans</c> record.</param>
    /// <returns>true if the markup trans is prorated; otherwise, false.</returns>
    internal static boolean isProratedMarkupTrans(MarkupTrans _markupTrans)
    {
        return _markupTrans.MarkupCategory == MarkupCategory::Fixed
            && isConfigurationkeyEnabled(configurationKeyNum(Retail))
            && _markupTrans.mcrIsProRated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    final internal MarkupInstrumentationLogger instrumentationLogger()
    {
        if (!instrumentationLogger)
        {
            instrumentationLogger = MarkupInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
        }

        return instrumentationLogger;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>