<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReqDemPlanForecastAggregator</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>ReqDemPlanForecastAggregator</c> class is responsible for generating pre-aggregated forecast data
/// and also for deaggregating the results back.
/// </summary>
public class ReqDemPlanForecastAggregator
{
    private static ReqDemPlanAggregatable forecastAggregatable;
    private static ReqDemPlanAggregatable historyAggregatable;
    private static Map aggregatableMap;

    private ReqDemPlanDataProcessingHelper  dataProcessingHelper;
    private ReqDemPlanForecastAttributeManager attributeManager;
    private ReqDemPlanDateConverter dateConverter;
    private boolean reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled;

    #ReqDemPlan

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>typenew</Name>
				<Source><![CDATA[
    static void typenew()
    {
        forecastAggregatable = new ReqDemPlanAggregatable(tableNum(ReqDemPlanForecast),
            fieldNum(ReqDemPlanForecast, Qty),
            fieldNum(ReqDemPlanForecast, ForecastDate),
            fieldNum(ReqDemPlanForecast, Version),
            fieldNum(ReqDemPlanForecast, OriginalQty));
        forecastAggregatable.parmSigmaField(fieldNum(ReqDemPlanForecast, Sigma));
        forecastAggregatable.parmForecastModelField(fieldNum(ReqDemPlanForecast, ModelId));
        forecastAggregatable.parmSupportsDeaggregation(true);

        historyAggregatable = new ReqDemPlanAggregatable(tableNum(ReqDemPlanCubeStagingTable),
            fieldNum(ReqDemPlanCubeStagingTable, TransactionQty),
            fieldNum(ReqDemPlanCubeStagingTable, TransactionDate),
            fieldNum(ReqDemPlanCubeStagingTable, Version));

        aggregatableMap = new Map(Types::String, Types::Class);
        aggregatableMap.insert(tableId2Name(forecastAggregatable.tableId()), forecastAggregatable);
        aggregatableMap.insert(tableId2Name(historyAggregatable.tableId()), historyAggregatable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmForecastAggregatable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected static ReqDemPlanAggregatable parmForecastAggregatable(ReqDemPlanAggregatable _forecastAggregatable = forecastAggregatable)
    {
        forecastAggregatable = _forecastAggregatable;

        return forecastAggregatable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHistoryAggregatable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected static ReqDemPlanAggregatable parmHistoryAggregatable(ReqDemPlanAggregatable _historyAggregatable = historyAggregatable)
    {
        historyAggregatable = _historyAggregatable;

        return historyAggregatable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        attributeManager = ReqDemPlanForecastAttributeManager::construct();
        dataProcessingHelper = new ReqDemPlanDataProcessingHelper();
        dateConverter = ReqDemPlanDateConverter::construct();
        reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled = ReqDemPlanCreateForecastService::isTransientSqlConnectionErrorRetryEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>runService</Name>
				<Source><![CDATA[
    public void runService(ReqDemPlanForecastAggregatorDataContract _dataContract)
    {
        using (var lock = ReqReaderWriterLock::construct())
        {
            if (!lock.tryEnterWriterLock(#DemPlanGlobalLockName))
            {
                error("@DMP1216");
                return;
            }

            try
            {
                this.aggregate(_dataContract.parmGranularity());
            }
            finally
            {
                lock.releaseAllLocks();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>aggregate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Aggregates the data in the supported tables according to the given granularity and pivot attributes.
    /// </summary>
    /// <param name = "_granularity">The date granularity.</param>
    public void aggregate(ReqDemPlanDateGranularity _granularity)
    {
        if (!attributeManager.checkConsistency())
        {
            throw error("@DMP:AggregationFailed");
        }

        int infologLineTry = infologLine();

        try
        {            
            ttsbegin;

            this.cleanAggregationPerCompany();

            Enumerator companyEnumerator = this.findCompanies().getEnumerator();
            while (companyEnumerator.moveNext())
            {
                this.aggregateCompany(companyEnumerator.current(), _granularity);
            }

            ttscommit;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (ReqDemPlanCreateForecastService::canRetryTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled))
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::Error)
        {
            if (ReqDemPlanCreateForecastService::isTransientSqlConnectionError(infologLineTry)//infologStartLine
            && ReqDemPlanCreateForecastService::canRetryTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled))
            {
                retry;
            }
            else
            {
                throw error("@DMP:AggregationError");
            }
        }
        catch
        {
            throw error("@DMP:AggregationError");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>aggregateCompany</Name>
				<Source><![CDATA[
    private void aggregateCompany(str _company, ReqDemPlanDateGranularity _granularity)
    {
        changecompany(_company)
        {
            this.aggregateInternal(_granularity, forecastAggregatable, ReqDemPlanForecastVersion::Forecasted);
            this.aggregateInternal(_granularity, historyAggregatable, ReqDemPlanForecastVersion::Forecasted);
            this.prepareAccuracyData(_granularity);

            Query queryBymodel = this.createAggregationByModelQuery(_granularity, forecastAggregatable, ReqDemPlanForecastVersion::Adjusted);
            this.insertAggregationsByModel(queryBymodel, forecastAggregatable, _granularity);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanAggregationPerCompany</Name>
				<Source><![CDATA[
    private void cleanAggregationPerCompany()
    {
        ReqDemPlanAggregatedForecast aggregation;
        while select crossCompany DataAreaId from aggregation group by DataAreaId
        {
            changecompany(aggregation.company())
            {
                ReqDemPlanAggregatedForecast aggregationPerCompany;
                dataProcessingHelper.skipAll(aggregationPerCompany);
                delete_from aggregationPerCompany;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCompanies</Name>
				<Source><![CDATA[
    private Set findCompanies()
    {
        Set companies = new Set(Types::String);
        MapEnumerator aggregatableEnumerator = aggregatableMap.getEnumerator();
        while (aggregatableEnumerator.moveNext())
        {
            var tableName = aggregatableEnumerator.currentKey();
            Common record = new SysDictTable(tableName2Id(tableName)).makeRecord();
            while select crossCompany DataAreaId from record group by DataAreaId
            {
                companies.add(record.DataAreaId);
            }
        }
        return companies;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareAccuracyData</Name>
				<Source><![CDATA[
    protected void prepareAccuracyData(ReqDemPlanDateGranularity _granularity)
    {
        var operationalForecastVersion = ReqDemPlanForecastVersion::Adjusted;

        this.aggregateInternal(_granularity, forecastAggregatable, operationalForecastVersion);
        this.copyAggregatedOperationalForecastToHistory(operationalForecastVersion);
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyAggregatedOperationalForecastToHistory</Name>
				<Source><![CDATA[
    protected void copyAggregatedOperationalForecastToHistory(ReqDemPlanForecastVersion _operationalForecastVersion)
    {
        ReqDemPlanAggregatedForecast forecast;
        ReqDemPlanAggregatedForecast history;

        var historyTableName    = tableId2Name(historyAggregatable.tableId());
        var historyTableVersion = ReqDemPlanForecastVersion::Forecasted;
        var forecastTableName   = tableId2Name(forecastAggregatable.tableId());

        update_recordset history
            setting OriginalQty = forecast.Qty
                join forecast
                    where  forecast.AttributeKey    == history.AttributeKey
                        && forecast.ForecastDate    == history.ForecastDate
                        && forecast.Version         == _operationalForecastVersion
                        && forecast.SourceTable     == forecastTableName
                        && history.Version          == historyTableVersion
                        && history.SourceTable      == historyTableName;

        insert_recordset history(AllocationKey, Color, Configuration, CustAccount, CustGroupId, ForecastDate, ItemId, LogisticsAddressStateId, LogisticsCountryRegionCode, Qty, Site, Size, StatusId, Style, ProductVersion, Version, Warehouse, AttributeKey, SourceTable, OriginalQty)
            select AllocationKey, Color, Configuration, CustAccount, CustGroupId, ForecastDate, ItemId, LogisticsAddressStateId, LogisticsCountryRegionCode, OriginalQty, Site, Size, StatusId, Style, ProductVersion, historyTableVersion, Warehouse, AttributeKey, historyTableName, Qty
                from forecast
                where  forecast.Version             == _operationalForecastVersion
                    && forecast.SourceTable         == forecastTableName
                notexists join history
                    where  history.AttributeKey     == forecast.AttributeKey
                        && history.ForecastDate     == forecast.ForecastDate
                        && history.Version          == historyTableVersion
                        && history.SourceTable      == historyTableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>aggregateInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Aggregates the data in the <c>ReqDemPlanForecast</c> table according to the given granularity and pivot attributes.
    /// </summary>
    /// <param name = "_granularity">The date granularity.</param>
    /// <param name = "_aggregatable">The aggregatable instance.</param>
    /// <param name = "_version">The version of data to be aggregated.</param>
    private void aggregateInternal(ReqDemPlanDateGranularity _granularity, ReqdemPlanAggregatable _aggregatable, RefRecId _version)
    {
        this.directInsertAggregations(_aggregatable, _version);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deaggregateZeroQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the deaggregating quantity when aggregated forecast is zero.
    /// </summary>
    /// <param name = "_newQty">The new quantity.</param>
    /// <returns>The deaggregated quantity.</returns>
    [Replaceable]
    protected Qty deaggregateZeroQuantity(Qty _newQty)
    {
        throw error("@DMP:ForecastZero");
    }

]]></Source>
			</Method>
			<Method>
				<Name>deaggregate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Deaggregates the given <c>ReqDemPlanAggregatedForecast</c> record by splitting the new quantity over source records.
    /// </summary>
    /// <param name = "_aggregatedForecast">The aggregated record.</param>
    /// <param name = "_newQty">The new quantity to set.</param>
    public void deaggregate(ReqDemPlanAggregatedForecast _aggregatedForecast, Qty _newQty)
    {
        if (!attributeManager.checkConsistency())
        {
            throw error("@DMP:DeaggregationFailed");
        }

        boolean     deaggregateFromOrigQuantity;
        boolean     deaggregateFromZeroQuantity;
        Qty         deaggregateQty;

        if (!_aggregatedForecast.Qty)
        {
            if (ReqDemPlanForecastAggregatorZeroQuantityToggle::instance().isEnabled())
            {
                if (_aggregatedForecast.OriginalQty)
                {
                    deaggregateQty = _newQty / _aggregatedForecast.OriginalQty;
                    deaggregateFromOrigQuantity = true;
                }
                else
                {
                    deaggregateQty = _newQty / this.numberOfReqDemPlanForecastRecords(_aggregatedForecast);
                    deaggregateFromZeroQuantity = true;
                }
            }
            else
            {
                deaggregateQty = this.deaggregateZeroQuantity(_newQty);
            }
        }
        else
        {
            deaggregateQty = (_newQty - _aggregatedForecast.Qty) / _aggregatedForecast.Qty;
        }

        var aggregatable = aggregatableMap.lookup(_aggregatedForecast.SourceTable) as ReqDemPlanAggregatable;
        if (!aggregatable.parmSupportsDeaggregation())
        {
            throw error(strFmt("@DMP:DeaggregationError", _aggregatedForecast.SourceTable));
        }

        var updateBuilder = new ReqDemPlanSqlUpdateStatementBuilder(tableNum(ReqDemPlanForecast));
        updateBuilder.buildUpdateExpression();

        if (deaggregateFromZeroQuantity)
        {
            updateBuilder.addSetValue(fieldNum(ReqDemPlanForecast, Qty), deaggregateQty);
        }
        else if (deaggregateFromOrigQuantity)
        {
            updateBuilder.addIncreaseValueByFromField(fieldNum(ReqDemPlanForecast, Qty), fieldNum(ReqDemPlanForecast, OriginalQty), deaggregateQty);
        }
        else
        {
            updateBuilder.addIncreaseValueBy(fieldNum(ReqDemPlanForecast, Qty), deaggregateQty);
        }

        this.addQueryFilters(updateBuilder, _aggregatedForecast);

        var sqlQuery = updateBuilder.toString();
        new SqlStatementExecutePermission(sqlQuery).assert();

        ttsbegin;

        changecompany(_aggregatedForecast.company())
        {
            _aggregatedForecast.reread();

            if (!_aggregatedForecast)
            {
                throw error("@SYS32808");
            }

            _aggregatedForecast.selectForUpdate(true);
            _aggregatedForecast.Qty = _newQty;
            _aggregatedForecast.update();
        }

        var statement = new Connection().createStatement();
        statement.executeUpdate(sqlQuery);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addQueryFilters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add ranges to the select statement.
    /// </summary>
    /// <param name = "_updateBuilder">The string builder to add ranges for</param>
    /// <param name = "_aggregatedForecast">The aggregated records with range values</param>
    private void addQueryFilters(ReqDemPlanSqlUpdateStatementBuilder _updateBuilder, ReqDemPlanAggregatedForecast _aggregatedForecast)
    {
        _updateBuilder.addFilter(fieldnum(ReqDemPlanForecast, Partition), getCurrentPartitionRecId());
        _updateBuilder.addFilter(fieldnum(ReqDemPlanForecast, ForecastDate), _aggregatedForecast.ForecastDate);
        _updateBuilder.addFilter(fieldnum(ReqDemPlanForecast, Version), _aggregatedForecast.Version);

        var pivotAttributes = attributeManager.getAllPivotAttributes();
        var enumerator = pivotAttributes.getEnumerator();
        while (enumerator.moveNext())
        {
            var forecastFieldId = attributeManager.getAttributeField(tableNum(ReqDemPlanForecast), enumerator.current());
            var aggregationFieldId = attributeManager.getAttributeField(tableNum(ReqDemPlanAggregatedForecast), enumerator.current());
            _updateBuilder.addFilter(forecastFieldId, _aggregatedForecast.(aggregationFieldId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfReqDemPlanForecastRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get number of ReqDemPlanForecast records.
    /// </summary>
    /// <param name = "_aggregatedForecast">The aggregated record.</param>
    /// <returns>Number of records.</returns>
    private int numberOfReqDemPlanForecastRecords(ReqDemPlanAggregatedForecast _aggregatedForecast)
    {
        var updateBuilder = new ReqDemPlanSqlUpdateStatementBuilder(tableNum(ReqDemPlanForecast));

        updateBuilder.buildSelectExpressionWithCountRecIdField();

        this.addQueryFilters(updateBuilder, _aggregatedForecast);

        var sqlQuery = updateBuilder.toString();

        new SqlStatementExecutePermission(sqlQuery).assert();

        var statement = new Connection().createStatement();

        ResultSet resultSet = statement.executeQuery(sqlQuery);

        resultSet.next();
        
        int numOfRec = resultSet.getInt64(1);

        if (numOfRec == 0)
        {
            throw error("@DMP:ForecastZero");
        }

        return numOfRec;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupBaseAggregationQuery</Name>
				<Source><![CDATA[
    private Query setupBaseAggregationQuery(
        ReqDemPlanDateGranularity _granularity, 
        ReqDemPlanAggregatable _aggregatable,
        RefRecId _version, 
        boolean includeAggregatedForecast = false)
    {
        
        Query query = new Query();
        query.clearAllFields();
        QueryBuildDataSource aggregatableDataSource = query.addDataSource(_aggregatable.tableId());
        QueryBuildDataSource bucketDataSource = aggregatableDataSource.addDataSource(tableNum(ReqDemPlanBucket));
        bucketDataSource.joinMode(JoinMode::InnerJoin);
        bucketDataSource.addRange(fieldNum(ReqDemPlanBucket, TableId))
            .value(strFmt('((%1.%2 >= %3.%4) && (%1.%2 < %3.%5))',
                aggregatableDataSource.name(),
                fieldId2Name(_aggregatable.tableId(), _aggregatable.dateField()),
                bucketDataSource.name(),
                fieldStr(ReqDemPlanBucket, CurrentPeriodStartDate),
                fieldStr(ReqDemPlanBucket, NextPeriodStartDate))
            );

        if(includeAggregatedForecast)
        {
            QueryBuildDataSource aggregatedForecast = bucketDataSource.addDataSource(tableNum(ReqDemPlanAggregatedForecast));
            aggregatedForecast.joinMode(JoinMode::OuterJoin);
        }
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupBaseAggregationQueryFields</Name>
				<Source><![CDATA[
    private void setupBaseAggregationQueryFields(
        Query query, 
        ReqDemPlanDateGranularity _granularity,
        ReqDemPlanAggregatable _aggregatable,
        RefRecId _version)
    {
        QueryBuildDataSource aggregatableDataSource = query.dataSourceTable(_aggregatable.tableId());
        QueryBuildFieldList aggregatableFields = aggregatableDataSource.fields();

        aggregatableFields.addField(_aggregatable.versionField());
        query.addQueryFilter(aggregatableDataSource, fieldId2Name(_aggregatable.tableId(), _aggregatable.versionField()))
            .value(queryValue(_version));

        var pivotAttributes = attributeManager.getAllPivotAttributes();
        var enumerator = pivotAttributes.getEnumerator();
        while (enumerator.moveNext())
        {
            ReqDemPlanForecastAttribute attribute = enumerator.current();
            var attributeFieldId = attributeManager.getAttributeField(_aggregatable.tableId(), attribute);
            if (attribute.Attribute != ReqDemPlanForecastAttributeType::DataAreaId)
            {
                aggregatableFields.addField(attributeFieldId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupBaseAggregationQueryGroupByFields</Name>
				<Source><![CDATA[
    private void setupBaseAggregationQueryGroupByFields(
        Query query,
        ReqDemPlanDateGranularity _granularity,
        ReqDemPlanAggregatable _aggregatable,
        RefRecId _version)
    {
        QueryBuildDataSource bucketDataSource = query.dataSourceTable(tableNum(ReqDemPlanBucket));
        var granularityFieldId = dateConverter.getPeriodFieldId(_granularity);
        bucketDataSource.addGroupByField(fieldNum(ReqDemPlanBucket, CurrentPeriodStartDate));
        
        QueryBuildDataSource aggregatableDataSource = query.dataSourceTable(_aggregatable.tableId());
        QueryBuildFieldList aggregatableFields = aggregatableDataSource.fields();

        aggregatableDataSource.addGroupByField(_aggregatable.versionField());

        var pivotAttributes = attributeManager.getAllPivotAttributes();
        var enumerator = pivotAttributes.getEnumerator();
        while (enumerator.moveNext())
        {
            ReqDemPlanForecastAttribute attribute = enumerator.current();
            var attributeFieldId = attributeManager.getAttributeField(_aggregatable.tableId(), attribute);
            if (attribute.Attribute != ReqDemPlanForecastAttributeType::DataAreaId)
            {
                aggregatableDataSource.addGroupByField(attributeFieldId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAggregationQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for running aggregation based on the granularities provided.
    /// </summary>
    /// <param name = "_granularity">The date granularity.</param>
    /// <param name = "_aggregatable">The aggregatable instance.</param>
    /// <param name = "_version">The version of data to be aggregated.</param>
    /// <returns>The query object for the aggregation.</returns>
    protected Query createAggregationQuery(ReqDemPlanDateGranularity _granularity, ReqDemPlanAggregatable _aggregatable, RefRecId _version)
    {
        Query query = this.setupBaseAggregationQuery(_granularity, _aggregatable, _version);
        this.setupBaseAggregationQueryFields(query, _granularity, _aggregatable, _version);
        
        QueryBuildDataSource bucketDataSource = query.dataSourceTable(tableNum(ReqDemPlanBucket));
        bucketDataSource.addSelectionField(fieldNum(ReqDemPlanBucket, CurrentPeriodStartDate));
        this.setupBaseAggregationQueryGroupByFields(query, _granularity, _aggregatable, _version);

        QueryBuildDataSource aggregatableDataSource = query.dataSourceTable(_aggregatable.tableId());
        QueryBuildFieldList aggregatableFields = aggregatableDataSource.fields();
        
        aggregatableFields.addField(_aggregatable.qtyField(), SelectionField::Sum);

        if (_aggregatable.originalQtyField())
        {
            aggregatableFields.addField(_aggregatable.originalQtyField(), SelectionField::Sum);
        }
        if (_aggregatable.parmSigmaField())
        {
            aggregatableFields.addField(_aggregatable.parmSigmaField(), SelectionField::Sum);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAggregationByModelQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for running aggregation based on the granularities provided and on the specified forecast model.
    /// This query only groups by the records that are already in the aggregated forecast table, deaggregating each line into multiple resulting lines for each forecast model.
    /// </summary>
    /// <param name = "_granularity">The date granularity.</param>
    /// <param name = "_aggregatable">The aggregatable instance.</param>
    /// <param name = "_version">The version of data to be aggregated.</param>
    /// <returns>The query object for the aggregation.</returns>
    private Query createAggregationByModelQuery(ReqDemPlanDateGranularity _granularity, ReqDemPlanAggregatable _aggregatable, RefRecId _version)
    {
        Query query = this.setupBaseAggregationQuery(_granularity, _aggregatable, _version, true);
        QueryBuildDataSource aggregatableDataSource = query.dataSourceTable(_aggregatable.tableId());
        QueryBuildDataSource aggregatedForecast = query.dataSourceTable(tableNum(ReqDemPlanAggregatedForecast));
        aggregatedForecast.joinMode(JoinMode::InnerJoin);

        this.addBucketRange(query, aggregatedForecast, _aggregatable);

        var pivotAttributes = attributeManager.getAllPivotAttributes();
        var enumerator = pivotAttributes.getEnumerator();
        while (enumerator.moveNext())
        {
            ReqDemPlanForecastAttribute attribute = enumerator.current();
            var attributeFieldId = attributeManager.getAttributeField(_aggregatable.tableId(), attribute);
            var attributeFieldName = fieldid2Name(_aggregatable.tableId(), attributeFieldId);
            FieldId aggregatedFieldId = fieldName2id(tableNum(ReqDemPlanAggregatedForecast), attributeFieldName);
            aggregatedForecast.addRange(aggregatedFieldId).value(strFmt('(%1.%2 == %3.%4)', aggregatableDataSource.name(), attributeFieldName, aggregatedForecast.name(), attributeFieldName));
        }

        query.addQueryFilter(aggregatableDataSource, fieldId2Name(_aggregatable.tableId(), _aggregatable.versionField()))
            .value(queryValue(_version));
        query.addQueryFilter(aggregatedForecast, fieldStr(ReqDemPlanAggregatedForecast, Version))
            .value(queryValue(ReqDemPlanForecastVersion::Forecasted));

        // add fields and extra group by model
        query.clearAllFields();
        aggregatedForecast.addGroupByAndSelectionField(fieldNum(ReqDemPlanAggregatedForecast, RecId));
        aggregatableDataSource.addGroupByAndSelectionField(_aggregatable.parmForecastModelField());
        aggregatableDataSource.fields().addField(_aggregatable.qtyField(), SelectionField::Sum);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBucketRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a range to the aggregated forecast data source that ensures that the date buckets match with aggregatable.
    /// </summary>
    /// <param name = "_query">The query to be run.</param>
    /// <param name = "_aggregatedForecast">The aggregated forecast data source.</param>
    /// <param name = "_aggregatable">The aggregatable instance.</param>
    private void addBucketRange(Query _query, QueryBuildDataSource _aggregatedForecast, ReqDemPlanAggregatable _aggregatable)
    {
        QueryBuildDataSource bucketDataSource = _query.dataSourceTable(tableNum(ReqDemPlanBucket));
        _aggregatedForecast
            .addRange(fieldNum(ReqDemPlanAggregatedForecast, ForecastDate))
            .value(strFmt('((%1.%2 >= %3.%4) && (%1.%2 < %3.%5))',
                _aggregatedForecast.name(),
                fieldId2Name(_aggregatable.tableId(), _aggregatable.dateField()),
                bucketDataSource.name(),
                fieldStr(ReqDemPlanBucket, CurrentPeriodStartDate),
                fieldStr(ReqDemPlanBucket, NextPeriodStartDate))
            );
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFieldMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a field map to inserts the aggregated data based on the supplied query.
    /// </summary>
    /// <param name = "_sourceQuery">The source data query.</param>
    /// <param name = "_aggregatable">The aggregatable instance.</param>
    /// <param name = "_granularity">The date granularity.</param>
    /// <param name = "_version">The version of the data to aggregate.</param>
    /// <returns>A <c>Map</c> between <c>ReqDemPlanAggregatedForecast</c> field names and a container with <c>ReqDemPlanBucket</c> datasource Id and <c>ReqDemPlanBucket</c> field name.</returns>
    protected Map createFieldMap(
        Query _sourceQuery,
        ReqDemPlanAggregatable _aggregatable,
        ReqDemPlanDateGranularity _granularity,
        RefRecId _version)
    {
        var aggregatableDataSource = _sourceQuery.dataSourceTable(_aggregatable.tableId());
        var bucketDataSource = _sourceQuery.dataSourceTable(tableNum(ReqDemPlanBucket));

        var fieldMap = new Map(Types::String, Types::Container);

        fieldMap.insert(fieldStr(ReqDemPlanAggregatedForecast, Version), [
            aggregatableDataSource.uniqueId(),
            fieldId2Name(_aggregatable.tableId(), _aggregatable.versionField())
        ]);
        fieldMap.insert(fieldStr(ReqDemPlanAggregatedForecast, ForecastDate), [
            bucketDataSource.uniqueId(),
            fieldId2Name(bucketDataSource.table(), fieldNum(ReqDemPlanBucket, CurrentPeriodStartDate))
        ]);
        fieldMap.insert(fieldStr(ReqDemPlanAggregatedForecast, Qty), [
            aggregatableDataSource.uniqueId(),
            'SUM(' + fieldId2Name(_aggregatable.tableId(), _aggregatable.qtyField()) + ')'
        ]);

        if (_aggregatable.originalQtyField())
        {
            fieldMap.insert(fieldStr(ReqDemPlanAggregatedForecast, OriginalQty), [
                aggregatableDataSource.uniqueId(),
                'SUM(' + fieldId2Name(_aggregatable.tableId(), _aggregatable.originalQtyField()) + ')'
            ]);
        }

        if (_aggregatable.parmSigmaField())
        {
            fieldMap.insert(fieldStr(ReqDemPlanAggregatedForecast, Sigma), [
                aggregatableDataSource.uniqueId(),
                'SUM(' + fieldId2Name(_aggregatable.tableId(), _aggregatable.parmSigmaField()) + ')'
            ]);
        }

        var pivotAttributes = attributeManager.getAllPivotAttributes();
        var enumerator = pivotAttributes.getEnumerator();
        boolean isProductVersionDimensionEnabled = isConfigurationkeyEnabled(configurationKeyNum(EcoResProductVersion));

        while (enumerator.moveNext())
        {
            ReqDemPlanForecastAttribute attribute = enumerator.current();

            if (!isProductVersionDimensionEnabled && attribute.attribute == ReqDemPlanForecastAttributeType::ProductVersion)
            {
                continue;
            }

            if (attribute.Attribute != ReqDemPlanForecastAttributeType::DataAreaId)
            {
                var attributeFieldId = attributeManager.getAttributeField(_aggregatable.tableId(), attribute);
                var attributeFieldName = fieldid2Name(_aggregatable.tableId(), attributeFieldId);
                fieldMap.insert(attributeFieldName, [aggregatableDataSource.uniqueId(), attributeFieldName]);
            }
        }

        return fieldMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertAggregations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the aggregated data based on the supplied query.
    /// </summary>
    /// <param name = "_sourceQuery">The source data query.</param>
    /// <param name = "_aggregatable">The aggregatable instance.</param>
    /// <param name = "_granularity">The date granularity.</param>
    /// <param name = "_version">The version of the data to aggregate.</param>
    private void insertAggregations(
        Query _sourceQuery,
        ReqDemPlanAggregatable _aggregatable,
        ReqDemPlanDateGranularity _granularity,
        RefRecId _version)
    {
        var fieldMap = this.createFieldMap(_sourceQuery, _aggregatable, _granularity, _version);

        ReqDemPlanAggregatedForecast aggregation;
        dataProcessingHelper.skipAll(aggregation);
        Query::insert_recordset(aggregation, fieldMap, _sourceQuery);
    }

]]></Source>
			</Method>
			<Method>
				<Name>directInsertAggregations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the aggregated data based on the supplied query.
    /// </summary>
    /// <param name = "_aggregatable">The aggregatable instance.</param>
    /// <param name = "_version">The version of the data to aggregate.</param>
    private void directInsertAggregations(ReqDemPlanAggregatable _aggregatable, RefRecId _version)
    {
        Connection connection;
        Statement statement;

        try
        {
            connection = new Connection();
            statement = connection.createStatement();

            Statement.executeUpdateWithParameters(this.createDirectSQLStatement(_aggregatable, _version), SqlParams::create());
        }
        finally
        {
            if (statement)
            {
                statement.close();
            }
            if (connection)
            {
                connection.finalize();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDirectSQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates SQL insert statement.
    /// </summary>
    /// <param name = "_aggregatable">The aggregatable instance.</param>
    /// <param name = "_version">The version of the data to aggregate.</param>
    /// <returns>The created sql statement.</returns>
    /// <remarks>
    /// For instance:
    ///     INSERT INTO ReqDemPlanAggregatedForecast (DATAAREAID, SITE, ALLOCATIONKEY, ITEMID, COLOR, SIZE_, CONFIGURATION, STYLE, PARTITION, ATTRIBUTEKEY, SOURCETABLE, FORECASTDATE, VERSION, QTY, ORIGINALQTY, SIGMA)
    ///     SELECT DATAAREAID,
    ///         SITE,
    ///         ALLOCATIONKEY,
    ///         ITEMID,
    ///         COLOR,
    ///         SIZE_,
    ///         CONFIGURATION,
    ///         STYLE,
    ///         ReqDemPlanForecast.PARTITION,
    ///         (CASE WHEN DATAAREAID = '' THEN N'--' ELSE DATAAREAID END) + N' / ' +
    ///             (CASE WHEN SITE = '' THEN N'--'ELSE SITE END) + N' / ' +
    ///             (CASE WHEN ALLOCATIONKEY = '' THEN N'--' ELSE ALLOCATIONKEY END) + N' / ' +
    ///             (CASE WHEN ITEMID = '' THEN N'--' ELSE ITEMID END) + N' / ' +
    ///             (CASE WHEN COLOR = '' THEN N'--' ELSE COLOR END) + N' / ' +
    ///             (CASE WHEN SIZE_ = '' THEN N'--' ELSE SIZE_ END) + N' / ' +
    ///             (CASE WHEN CONFIGURATION = '' THEN N'--' ELSE CONFIGURATION END) + N' / ' +
    ///             (CASE WHEN STYLE = '' THEN N'--' ELSE STYLE END),
    ///         'ReqDemPlanForecast',
    ///         CURRENTPERIODSTARTDATE,
    ///         VERSION,
    ///         SUM(QTY),
    ///         SUM(ORIGINALQTY),
    ///         SUM(SIGMA)
    ///     FROM ReqDemPlanForecast
    ///     JOIN ReqDemPlanBucket ON FORECASTDATE >= CURRENTPERIODSTARTDATE
    ///         AND NEXTPERIODSTARTDATE > FORECASTDATE
    ///         AND ReqDemPlanForecast.PARTITION = ReqDemPlanBucket.PARTITION
    ///    WHERE VERSION = 0
    ///         AND DATAAREAID = 'frrt'
    ///         AND ReqDemPlanForecast.PARTITION = 5637144576
    ///    GROUP BY CURRENTPERIODSTARTDATE,
    ///         ReqDemPlanForecast.PARTITION,
    ///         VERSION,
    ///         DATAAREAID,
    ///         SITE,
    ///         ALLOCATIONKEY,
    ///         ITEMID,
    ///         COLOR,
    ///         SIZE_,
    ///         CONFIGURATION,
    ///         STYLE
    /// </remarks>
    private str createDirectSQLStatement(ReqDemPlanAggregatable _aggregatable, RefRecId _version)
    {
        str dataAreaIdField = new DictField(_aggregatable.tableId(), fieldName2Id(_aggregatable.tableId(), enum2Symbol(enumNum(ReqDemPlanForecastAttributeType), enum2int(ReqDemPlanForecastAttributeType::DataAreaId)))).name(DbBackend::Sql);
        str pivotFields;

        List pivotAttributes = attributeManager.getAllPivotAttributes();
        ListEnumerator enumerator = pivotAttributes.getEnumerator();
        boolean isProductVersionDimensionEnabled = isConfigurationkeyEnabled(configurationKeyNum(EcoResProductVersion));

        while (enumerator.moveNext())
        {
            ReqDemPlanForecastAttribute attribute = enumerator.current();

            if (!isProductVersionDimensionEnabled && attribute.attribute == ReqDemPlanForecastAttributeType::ProductVersion)
            {
                continue;
            }

            var attributeFieldId = attributeManager.getAttributeField(_aggregatable.tableId(), attribute);
            if (pivotFields)
            {
                pivotFields += ', ';
            }
            pivotFields += new DictField(_aggregatable.tableId(), attributeFieldId).name(DbBackend::Sql);
        }
        
        str sqlStatement =
            'INSERT INTO ' + tableStr(ReqDemPlanAggregatedForecast) + ' (' + this.getAggregationInsertedFieldsStatementText(_aggregatable, pivotFields) + ')'
            + ' SELECT ' + this.getAggregationSelectableFieldsStatementText(_aggregatable, pivotFields, attributeManager.getAttributeFields(tableNum(ReqDemPlanAggregatedForecast), pivotAttributes))
            + ' FROM ' + tableId2Name(_aggregatable.tableId())
            + this.getAggregationJoinedDatasourcesStatementText(_aggregatable)
            + ' WHERE '
                + new DictField(_aggregatable.tableId(), _aggregatable.versionField()).name(DbBackend::Sql) + ' = ' + int642Str(_version)
                + ' AND '
                + dataAreaIdField + ' = \'' + curExt() + '\''
                + ' AND '
                + tableId2Name(_aggregatable.tableId()) + '.' + new DictField(tableNum(ReqDemPlanBucket), fieldNum(ReqDemPlanBucket, Partition)).name(DbBackend::Sql) + ' = ' + int642Str(getCurrentPartitionRecId())
            + this.getAggregationJoinedGrouppedFieldsStatementText(_aggregatable, pivotFields);

        return sqlStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAggregationJoinedDatasourcesStatementText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates SQL statement to add data sources.
    /// </summary>
    /// <param name = "_aggregatable">The aggregatable instance.</param>
    /// <returns>The part of SQL statement to join data sources.</returns>
    protected str getAggregationJoinedDatasourcesStatementText(ReqDemPlanAggregatable _aggregatable)
    {
        str dateField = new DictField(_aggregatable.tableId(), _aggregatable.dateField()).name(DbBackend::Sql);
        str partitionField = new DictField(tableNum(ReqDemPlanBucket), fieldNum(ReqDemPlanBucket, Partition)).name(DbBackend::Sql);

        return ' JOIN ' + tablestr(ReqDemPlanBucket)
            + ' ON '
                + dateField
                + ' >= '
                + new DictField(tableNum(ReqDemPlanBucket), fieldNum(ReqDemPlanBucket, CurrentPeriodStartDate)).name(DbBackend::Sql)
            + ' AND '
                + dateField
                + ' < '
                + new DictField(tableNum(ReqDemPlanBucket), fieldNum(ReqDemPlanBucket, NextPeriodStartDate)).name(DbBackend::Sql)
            + ' AND '
                + tableId2Name(_aggregatable.tableId()) + '.' + partitionField
                + ' = '
                + tablestr(ReqDemPlanBucket) + '.' + partitionField;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAggregationSelectableFieldsStatementText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates SQL statement to select fields.
    /// </summary>
    /// <param name = "_aggregatable">The aggregatable instance.</param>
    /// <param name = "_pivotFields">The list of the pivot attributes selected.</param>
    /// <param name = "_pivotAttributes">The list of fields to concatenate.</param>
    /// <returns>The part of SQL statement to add selectable fields.</returns>
    protected str getAggregationSelectableFieldsStatementText(ReqDemPlanAggregatable _aggregatable, str _pivotFields, List _pivotAttributes)
    {
        str selectableFields =
            _pivotFields + ', '
            + tableId2Name(_aggregatable.tableId()) + '.' + new DictField(tableNum(ReqDemPlanBucket), fieldNum(ReqDemPlanBucket, Partition)).name(DbBackend::Sql) + ', '
            + this.getAggregatedAttributeKey(_aggregatable, _pivotAttributes) + ', \''
            + tableId2Name(_aggregatable.tableId()) + '\', '
            + new DictField(tableNum(ReqDemPlanBucket), fieldNum(ReqDemPlanBucket, CurrentPeriodStartDate)).name(DbBackend::Sql) + ', '
            + new DictField(_aggregatable.tableId(), _aggregatable.versionField()).name(DbBackend::Sql) + ', SUM('
            + new DictField(_aggregatable.tableId(), _aggregatable.qtyField()).name(DbBackend::Sql) + ')';

        if (_aggregatable.originalQtyField())
        {
            selectableFields += ', SUM(' + new DictField(_aggregatable.tableId(), _aggregatable.originalQtyField()).name(DbBackend::Sql) + ')';
        }

        if (_aggregatable.parmSigmaField())
        {
            selectableFields += ', SUM(' + new DictField(_aggregatable.tableId(), _aggregatable.parmSigmaField()).name(DbBackend::Sql) + ')';
        }

        return selectableFields;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAggregatedAttributeKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Concatenates fields to create the attribute key value.
    /// </summary>
    /// <param name = "_aggregatable">The aggregatable instance.</param>
    /// <param name = "_pivotAttributes">The list of fields to concatenate.</param>
    /// <returns>The aggregated attribute key value.</returns>
    protected str getAggregatedAttributeKey(ReqDemPlanAggregatable _aggregatable, List _pivotAttributes)
    {
        return ReqDemPlanDataProcessingHelper::addFieldConcat(tableNum(ReqDemPlanAggregatedForecast), _pivotAttributes, #AttributeKeyDelimiter, #AttributeKeyEmptyValueReplacement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAggregationInsertedFieldsStatementText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates SQL statement to add fields to populate.
    /// </summary>
    /// <param name = "_aggregatable">The aggregatable instance.</param>
    /// <param name = "_pivotFields">The list of the pivot attributes selected.</param>
    /// <returns>The part of SQL statement to add inserted fields.</returns>
    protected str getAggregationInsertedFieldsStatementText(ReqDemPlanAggregatable _aggregatable, str _pivotFields)
    {
        str insertedFields =
            _pivotFields + ', '
            + new DictField(tableNum(ReqDemPlanAggregatedForecast), fieldNum(ReqDemPlanAggregatedForecast, Partition)).name(DbBackend::Sql) + ', '
            + new DictField(tableNum(ReqDemPlanAggregatedForecast), fieldNum(ReqDemPlanAggregatedForecast, AttributeKey)).name(DbBackend::Sql) + ', '
            + new DictField(tableNum(ReqDemPlanAggregatedForecast), fieldNum(ReqDemPlanAggregatedForecast, SourceTable)).name(DbBackend::Sql) + ', '
            + new DictField(tableNum(ReqDemPlanAggregatedForecast), fieldNum(ReqDemPlanAggregatedForecast, ForecastDate)).name(DbBackend::Sql) + ', '
            + new DictField(tableNum(ReqDemPlanAggregatedForecast), fieldNum(ReqDemPlanAggregatedForecast, Version)).name(DbBackend::Sql) + ', '
            + new DictField(tableNum(ReqDemPlanAggregatedForecast), fieldNum(ReqDemPlanAggregatedForecast, Qty)).name(DbBackend::Sql);

        if (_aggregatable.originalQtyField())
        {
            insertedFields += ', ' + new DictField(tableNum(ReqDemPlanAggregatedForecast), fieldNum(ReqDemPlanAggregatedForecast, OriginalQty)).name(DbBackend::Sql);
        }

        if (_aggregatable.parmSigmaField())
        {
            insertedFields += ', ' + new DictField(tableNum(ReqDemPlanAggregatedForecast), fieldNum(ReqDemPlanAggregatedForecast, Sigma)).name(DbBackend::Sql);
        }

        return insertedFields;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAggregationJoinedGrouppedFieldsStatementText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates SQL statement to add fields in group by section.
    /// </summary>
    /// <param name = "_aggregatable">The aggregatable instance.</param>
    /// <param name = "_pivotFields">The list of the pivot attributes selected.</param>
    /// <returns>The part of SQL statement to add fields in group by section.</returns>
    protected str getAggregationJoinedGrouppedFieldsStatementText(ReqDemPlanAggregatable _aggregatable, str _pivotFields)
    {
        return ' GROUP BY '
            + new DictField(tableNum(ReqDemPlanBucket), fieldNum(ReqDemPlanBucket, CurrentPeriodStartDate)).name(DbBackend::Sql) + ', '
            + tableId2Name(_aggregatable.tableId()) + '.' + new DictField(tableNum(ReqDemPlanBucket), fieldNum(ReqDemPlanBucket, Partition)).name(DbBackend::Sql) + ', '
            + new DictField(_aggregatable.tableId(), _aggregatable.versionField()).name(DbBackend::Sql) + ', '
            + _pivotFields;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertAggregationsByModel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the aggregated data based on the supplied query.
    /// </summary>
    /// <param name = "_sourceQuery">The source data query.</param>
    /// <param name = "_aggregatable">The aggregatable instance.</param>
    /// <param name = "_granularity">The date granularity.</param>
    private void insertAggregationsByModel(
        Query _sourceQuery,
        ReqDemPlanAggregatable _aggregatable,
        ReqDemPlanDateGranularity _granularity)
    {
        var aggregatableDataSource = _sourceQuery.dataSourceTable(_aggregatable.tableId());
        var aggregatedForecast = _sourceQuery.dataSourceTable(tableNum(ReqDemPlanAggregatedForecast));

        var fieldMap = new Map(Types::String, Types::Container);

        fieldMap.insert(fieldStr(ReqDemPlanAggregatedForecastHistoryByModel, OriginalQty), [
            aggregatableDataSource.uniqueId(),
            'SUM(' + fieldId2Name(_aggregatable.tableId(), _aggregatable.qtyField()) + ')'
        ]);

        fieldMap.insert(fieldStr(ReqDemPlanAggregatedForecastHistoryByModel, ForecastModelId), [
            aggregatableDataSource.uniqueId(),
            fieldId2Name(_aggregatable.tableId(), _aggregatable.parmForecastModelField())
        ]);
        
        fieldMap.insert(fieldStr(ReqDemPlanAggregatedForecastHistoryByModel, SourceRecId), [
            aggregatedForecast.uniqueId(),
            fieldStr(ReqDemPlanAggregatedForecast, RecId)
        ]);

        ReqDemPlanAggregatedForecastHistoryByModel byplan;
        Query::insert_recordset(byplan, fieldMap, _sourceQuery);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAggregations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the newly aggregated data by setting the AttributeKey field and SourceTable fields.
    /// </summary>
    /// <param name = "_aggregatable">The aggregatable instance.</param>
    /// <param name = "_version">The version of the data.</param>
    private void updateAggregations(ReqDemPlanAggregatable _aggregatable, RefRecId _version)
    {
        var pivotAttributes = attributeManager.getAllPivotAttributes();
        var pivotFields = attributeManager.getAttributeFields(tableNum(ReqDemPlanAggregatedForecast), pivotAttributes);

        var updateBuilder = new ReqDemPlanSqlUpdateStatementBuilder(tableNum(ReqDemPlanAggregatedForecast));
        updateBuilder.buildUpdateExpression();
        updateBuilder.addFieldConcat(fieldNum(ReqDemPlanAggregatedForecast, AttributeKey), pivotFields, #AttributeKeyDelimiter, #AttributeKeyEmptyValueReplacement);
        updateBuilder.addSetValue(fieldNum(ReqDemPlanAggregatedForecast, SourceTable), tableId2Name(_aggregatable.tableId()));

        updateBuilder.addFilter(fieldnum(ReqDemPlanAggregatedForecast, Partition), getCurrentPartitionRecId());
        updateBuilder.addFilter(fieldnum(ReqDemPlanAggregatedForecast, Version), _version);
        updateBuilder.addFilter(fieldnum(ReqDemPlanAggregatedForecast, SourceTable), '');

        var sqlQuery = updateBuilder.toString();
        new SqlStatementExecutePermission(sqlQuery).assert();

        var statement = new Connection().createStatement();
        statement.executeUpdate(sqlQuery);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAggregatedRecordQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds and updates the necessary aggregated forecast record by adding the new quantity.
    /// </summary>
    /// <param name = "_sourceRecord">The aggregatable record for which the aggregated forecast will be searched for.</param>
    /// <param name = "_changedQty">The amount to adjust the aggregation by.</param>
    public void updateAggregatedRecordQuantity(ReqDemPlanForecast _sourceRecord, InventQty _changedQty)
    {
        var aggregatedForecast = this.getAggregatedForecastRecord(_sourceRecord);

        ttsBegin;

        aggregatedForecast.selectForUpdate(true);

        aggregatedForecast.Qty += _changedQty;

        aggregatedForecast.Update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAggregatedForecastRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds a query for getting the necessary aggregated forecast record and returns the record.
    /// </summary>
    /// <param name = "_sourceRecord">The aggregatable record for which the aggregated forecast will be searched for.</param>
    /// <returns>A single <c>ReqDemPlanAggregatedForecast</c> record, corresponding to the input.</returns>
    public ReqDemPlanAggregatedForecast getAggregatedForecastRecord(Common _sourceRecord)
    {
        var aggregatable = aggregatableMap.lookup(tableId2Name(_sourceRecord.TableId));
        ReqDemPlanForecastAttribute forecastAttribute;
        var query = new Query();
        query.allowCrossCompany(true);

        var aggregatedForecastDataSource = query.addDataSource(tableNum(ReqDemPlanAggregatedForecast));

        query.addQueryFilter(aggregatedForecastDataSource, fieldStr(ReqDemPlanAggregatedForecast, ForecastDate)).value(queryValue(_sourceRecord.(aggregatable.dateField())));
        query.addQueryFilter(aggregatedForecastDataSource, fieldStr(ReqDemPlanAggregatedForecast, Version)).value(_sourceRecord.(aggregatable.versionField()));
        query.addQueryFilter(aggregatedForecastDataSource, fieldStr(ReqDemPlanAggregatedForecast, SourceTable)).value(tableId2Name(_sourceRecord.TableId));
        query.addQueryFilter(aggregatedForecastDataSource, fieldStr(ReqDemPlanAggregatedForecast, AttributeKey))
            .value(queryValue(attributeManager.makePivotAttributeKey(_sourceRecord)));

        var queryRun = new QueryRun(query);
        if (queryRun.next())
        {
            return queryRun.get(tableNum(ReqDemPlanAggregatedForecast));
        }
        else
        {
            throw error("@SYS32808");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static ReqDemPlanForecastAggregator construct()
    {
        return new ReqDemPlanForecastAggregator();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>