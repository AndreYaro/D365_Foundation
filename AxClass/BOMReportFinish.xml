<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BomReportFinish</Name>
	<SourceCode>
		<Declaration><![CDATA[
class BomReportFinish extends BOMReportFinishBase
{
    InventJournalTable      parentInventJournalTable;
    InventJournalTrans      parentInventJournalTrans;   // Is set with .data()
    JournalTableData        journalTableData;
    JournalTransData        journalTransData;

    InventJournalTrans      inventJournalTrans;

    Voucher                 voucher_last;

    boolean                 postJournal;

    JournalErrorTransList   journalErrorTransList;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addWarning</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a warning for a specific journal line.
    /// </summary>
    /// <param name="_warning">
    ///    A string that holds the label that contains the warning.
    /// </param>
    /// <param name="_inventJournalTrans">
    ///    A <c>inventJournalTrans</c> record that is the journal line.
    /// </param>
    protected void addWarning(
        str                 _warning,
        InventJournalTrans  _inventJournalTrans)
    {
        JournalError        journalError;
        int                 logPoint = infologLine();

        if (! journalErrorTransList)
        {
            journalErrorTransList = new JournalErrorTransList(journalTableData);
        }

        warning(_warning);

        journalError.RefTableId         =  journalTableData.journalTable().TableId;
        journalError.JournalId          = _inventJournalTrans.JournalId;
        journalError.Voucher            = _inventJournalTrans.Voucher;
        journalError.LineNum            = _inventJournalTrans.LineNum;

        [journalError.Exception,
        journalError.Infolog,
        journalError.InfologAction,
        logPoint]                      = JournalCheckPost::infologPack(_inventJournalTrans.data(),logPoint);

        journalErrorTransList.add(journalError);
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignPreviousUsedDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Assigns inventory dimensions to inventory transactions for a specified journal line.
    /// </summary>
    /// <param name="_jourTrans">
    ///    An <c>inventJournalTrans</c> record.
    /// </param>
    /// <remarks>
    ///    If a journal line will be returned the same inventory dimensions must be assigned.
    /// </remarks>
    protected void assignPreviousUsedDim(InventJournalTrans  _jourTrans)
    {
        Map                         mapDim;
        MapEnumerator               me;

        InventDim                   dimTo;
        InventDimParm               dimParmFixed;

        InventMovement              movement;

        InventTrans                 inventTrans;
        InventTrans                 inventTransSplitted;

        List                        listTrans;
        ListEnumerator              le;

        InventQty                   qtyRemainDim;
        InventQty                   qtyRemainTrans;
        InventQty                   qtyRemainDimTotal;

        real                        factor;

        int                         numOfDecimals = InventTable::inventDecimals(_jourTrans.ItemId) ;

        InventUpdate                inventUpd;
        boolean                     createWarningNewDim;

        // find previous used inventDims and quantity which we want to return
        mapDim = this.getInventDimsAndQtyFromTransId(_jourTrans);

        if (! mapDim)
            return;

        ttsbegin;

        movement = _jourTrans.inventMovement();

        // find inventTrans records to update with new inventory dimensions.
        listTrans = new List(Types::Record);
        while select forupdate inventTrans
            order by InventDimId
            where  inventTrans.InventTransOrigin == movement.inventTransOriginId()
                && inventTrans.TransChildType    == movement.transChildType()
                && inventTrans.TransChildRefId   == movement.transChildRefId()
                && ((inventTrans.StatusReceipt == StatusReceipt::None && inventTrans.StatusIssue > StatusIssue::Deducted)
                || (inventTrans.StatusReceipt > StatusReceipt::Received && inventTrans.StatusIssue == StatusIssue::None))
        {
            listTrans.addEnd(inventTrans);
            qtyRemainTrans += abs(inventTrans.Qty);
        }

        if ( abs(_jourTrans.Qty) != qtyRemainTrans)
        {
            throw error(strFmt("@SYS19378",funcName()));
        }

        qtyRemainDimTotal = abs(_jourTrans.Qty); // _jourTrans.qty is splitted by inventDimId in mapDims

        le = listTrans.getEnumerator();
        me = mapDim.getEnumerator();

        // loop inventTrans and assign new dimensions
        while (le.moveNext())
        {
            inventTrans = le.current();

            // lookup the inventDimId to use
            while (qtyRemainDim <=0 && qtyRemainDimTotal > 0 )
            {
                if (me.moveNext()) // next inventory dimension
                {
                    factor              = qtyRemainTrans/qtyRemainDimTotal;
                    qtyRemainDim        = decRound(abs(factor * me.currentValue()),numOfDecimals);
                    dimTo               = InventDim::find(me.currentKey());
                    qtyRemainDimTotal  -= abs(me.currentValue());
                }
                else
                {
                    break;
                }
            }

            if (qtyRemainDim <= 0)
            {
                break;
            }

            if ( abs(inventTrans.Qty) > abs(qtyRemainDim))
            {
                // split inventTrans
                // current inventTrans becomes a new record - so add the old inventTrans to the list again
                inventTransSplitted = inventTrans.updateSplit( sign(inventTrans.Qty) * abs(qtyRemainDim));

                if (inventTransSplitted != inventTrans)
                {
                    listTrans.addEnd(inventTransSplitted);
                }
            }

            if (inventTrans.InventDimId != dimTo.InventDimId)
            {
                if (   returnFactor != 1
                    && mapDim.elements() > 1 )
                {
                    createWarningNewDim = true;
                }

                if (! inventUpd)
                {
                    inventUpd = InventUpdate::newChangeTransDim(movement);
                    inventUpd.parmAllowReserveReduction(true);
                }

                if (inventTrans.Qty < 0 )
                {
                    // lock dimensions -> reservation can't change them later
                    dimParmFixed.initFromInventDim(inventTrans.inventDim());
                    inventTrans.InventDimFixed =  InventDimFixedClass::inventDimParm2InventDimFixed(dimParmFixed);
                    inventTrans.doUpdate();

                    inventUpd.updateTransDimIssue(inventTrans, inventTrans.inventDim(), dimTo, inventTrans.Qty, true);
                }
                else
                {
                    inventUpd.updateTransDimReceipt(inventTrans, inventTrans.inventDim(), dimTo, inventTrans.Qty);
                }
            }

            qtyRemainDim    -= abs(inventTrans.Qty);
            qtyRemainTrans  -= abs(inventTrans.Qty);
        }

        if (createWarningNewDim)
        {
            this.addWarning("@SYS127881",_jourTrans);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDimsAndQtyFromTransId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds previously used inventory dimensions and distributes a quantity for each of these dimensions
    ///    based on the previous ratio.
    /// </summary>
    /// <param name="_jourTrans">
    ///    An <c>InventJournalTrans</c> record.
    /// </param>
    /// <returns>
    ///    A map that holds inventory dimensions IDs and the calculated quantities.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The quantity could not be distributed to inventory dimensions.
    /// </exception>
    protected Map getInventDimsAndQtyFromTransId(InventJournalTrans     _jourTrans)
    {
        InventTrans                     inventTrans;
        InventDimParm                   dimParm;
        InventDim                       inventDim;
        InventDim                       inventDimCriteria;
        InventTransOriginJournalTrans   inventTransOriginJournalTrans;
        RecordSortedList                sortedListInventTrans;
        boolean                         more;

        int                 numOfDecimals = InventTable::inventDecimals(_jourTrans.ItemId) ;

        InventQty           qtyRemain;
        InventQty           qtyDim;
        InventQty           qtyDistribution;

        real                factor;

        Map                 mapDims      = new Map(Types::String, Types::Real); // InventDimId, qty

        if (! _jourTrans.InventTransIdReturn)
        {
            return mapDims;
        }

        inventDimCriteria = _jourTrans.inventDim();
        dimParm.initFromInventDim(inventDimCriteria);

        sortedListInventTrans = new RecordSortedList(tableNum(InventTrans));
        sortedListInventTrans.sortOrder(fieldNum(InventTrans,Qty));
        sortedListInventTrans.sortOrder(fieldNum(InventTrans,InventDimId));

        // Find inventDim, qty and total qty from the original transactions but limit with specified returned dimensions.
        while select sum(Qty),InventDimId from inventTrans
            group by InventDimId
            where ! inventTrans.PackingSlipReturned
            exists join inventTransOriginJournalTrans
                where inventTransOriginJournalTrans.InventTransOrigin       == inventTrans.InventTransOrigin
                   && inventTransOriginJournalTrans.InventJournalDataAreaId == _jourTrans.DataAreaId
                   && inventTransOriginJournalTrans.InventJournalId         == _jourTrans.JournalId
                   && inventTransOriginJournalTrans.InventJournalLineNum    == _jourTrans.LineNum
        #inventDimExistsJoin(inventTrans.inventDimId,InventDim,inventDimCriteria,dimParm)
        {
            inventTrans.Qty = abs(inventTrans.Qty); // in order to force the order -> beginning with small quantities
            sortedListInventTrans.ins(inventTrans);
            qtyRemain += inventTrans.Qty;
        }

        more = sortedListInventTrans.first(inventTrans);
        qtyDistribution = abs(_jourTrans.Qty); // _jourTrans.qty = the reverting quantity

        while (more && qtyRemain && qtyDistribution <= qtyRemain)
        {
            factor = qtyDistribution / qtyRemain;

            qtyDim = decRound(factor * inventTrans.Qty ,numOfDecimals);
            mapDims.insert(inventTrans.InventDimId, qtyDim);

            qtyRemain       -= abs(inventTrans.Qty);
            qtyDistribution -= abs(qtyDim);
            more = sortedListInventTrans.next(inventTrans);
        }

        if (qtyDistribution != 0)
        {
            throw error("@SYS53004");
        }

        return mapDims;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBOMIssueReturn</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a bill of materials journal line based on a previous record.
    /// </summary>
    /// <param name="_fromTrans">
    ///    A record of any type.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    The specified record is not supported.
    /// </exception>
    void initBOMIssueReturn(Common _fromTrans)
    {
        InventJournalTrans      returnJournalTrans;

        switch (_fromTrans.TableId)
        {
            case tableNum(InventJournalTrans) :

                returnJournalTrans = _fromTrans;

                this.inventJournalTrans(returnJournalTrans);

                lineNum++;

                inventJournalTrans.clear();

                inventJournalTrans.initFromInventJournalTable(parentInventJournalTable);
                inventJournalTrans.initFromBOMReturnLot(InventTransOriginJournalTrans::findInventTransOriginId(inventJourTrans.DataAreaId, inventJourTrans.JournalId, inventJourTrans.LineNum));

                if (returnFactor != 1)
                {
                    inventJournalTrans.Qty          = inventJournalTrans.Qty * returnFactor;
                    inventJournalTrans.Qty          = decRound(inventJournalTrans.Qty, UnitOfMeasure::unitOfMeasureDecimalPrecision(
                        UnitOfMeasure::unitOfMeasureIdBySymbol(inventJournalTrans.unitId())));
                    inventJournalTrans.CostAmount   = inventJournalTrans.calcCostAmount();
                }

                inventJournalTrans.setInventDimId(returnJournalTrans.InventDimId);
                inventJournalTrans.InventTransIdReturn  = this.inventJournalTrans().InventTransId;
                inventJournalTrans.TransDate            = bomParmReportFinish.TransDate;
                inventJournalTrans.bomLine              = NoYes::Yes;
                inventJournalTrans.InventTransIdFather  = parentInventJournalTrans.InventTransId;
                inventJournalTrans.LineNum              = lineNum;

                if (parentInventJournalTable.VoucherDraw == JournalVoucherDraw::Entering)
                    journalTransData.initVoucher(voucher_last,false,false);  // Voucher is assigned

                journalTransData.insert();

                this.assignPreviousUsedDim(inventJournalTrans);

                break;

            /*
            case tablenum(InventTrans) :

                request for new functionality
                Reversal of BOM journals based on Inventory transactions.

                break;
            */

            default : throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBOMReceipt</Name>
				<Source><![CDATA[
    void initBOMReceipt()
    {
        lineNum++;

        inventJournalTrans.clear();
        inventJournalTrans.initFromInventJournalTable(parentInventJournalTable);
        inventJournalTrans.initFromInventTable(bomParmReportFinish.inventTable());

        // Reset fields after initFrom
        inventJournalTrans.CostAmount     = 0;
        inventJournalTrans.SalesAmount    = 0;
        inventJournalTrans.CostPrice      = 0;
        inventJournalTrans.initFromBOMparmReportFinish(this.parmParmBuffer());
        inventJournalTrans.bomLine          = NoYes::No;
        inventJournalTrans.LineNum          = lineNum;

        journalTransData  = journalTableData.journalStatic().newJournalTransData(inventJournalTrans,journalTableData);

        if (parentInventJournalTable.VoucherDraw == JournalVoucherDraw::Entering)
            journalTransData.initVoucher('',false);

        journalTransData.insert();

        // Save it for update of amount fields
        parentInventJournalTrans.data(inventJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBOMReceiptReturn</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a reverting bill of materials journal line.
    /// </summary>
    /// <exception cref="M:Exception::Error">
    ///    The specified return lot ID relates to an item number other than specified.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    The original journal line that has to be reverted does not exist.
    /// </exception>
    void initBOMReceiptReturn()
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;

        [journalId, voucher] = this.getJournalIdAndVoucherFromReturnLotId(bomParmReportFinish.InventTransIdReturn);

        if (this.inventJournalTrans(InventJournalTrans::findInventTransId(bomParmReportFinish.InventTransIdReturn)))
        {
            /*
                Journalline still exist
            */

            lineNum++;

            inventJournalTrans.clear();
            inventJournalTrans.initFromInventJournalTable(parentInventJournalTable);
            inventJournalTrans.initFromBOMparmReportFinish(this.parmParmBuffer());
            inventJournalTrans.initFromBOMReturnLot(InventTransOrigin::findByInventTransId(bomParmReportFinish.InventTransIdReturn).RecId);

            // mark to get cost from receipt
            inventJournalTrans.InventRefTransId = inventJournalTrans.InventTransIdReturn;

            if (inventJournalTrans.ItemId != bomParmReportFinish.ItemId)
                throw error(strFmt("@SYS84670", inventJournalTrans.ItemId, bomParmReportFinish.InventTransIdReturn, bomParmReportFinish.ItemId));

            if (inventJournalTrans.inventTable().modelGroup().StandardCost)
            {
                select firstonly CostAmountStd, CostAmountPosted from inventTrans
                    exists join inventTransOrigin
                       where inventTransOrigin.RecId         == inventTrans.InventTransOrigin
                          && inventTransOrigin.InventTransId == bomParmReportFinish.InventTransIdReturn;

                if (inventTrans.CostAmountStd != inventTrans.CostAmountPosted)
                {
                    inventJournalTrans.CostPrice  = CurrencyExchangeHelper::price(this.inventJournalTrans().CostAmount / (this.inventJournalTrans().Qty ? this.inventJournalTrans().Qty : 1));
                    inventJournalTrans.CostAmount = inventJournalTrans.calcCostAmount();
                }
            }

            // if not whole lot is returned ..
            if (inventJournalTrans.Qty && inventJournalTrans.Qty != bomParmReportFinish.Qty)
            {
                returnFactor = bomParmReportFinish.Qty / inventJournalTrans.Qty;

                inventJournalTrans.Qty              = bomParmReportFinish.Qty;
                inventJournalTrans.CostAmount       = inventJournalTrans.calcCostAmount();
            }
            else
                returnFactor = 1;

            // Reset fields after initFrom
            inventJournalTrans.SalesAmount  = 0;
            inventJournalTrans.bomLine      = NoYes::No;
            inventJournalTrans.LineNum      = lineNum;

            journalTransData  = journalTableData.journalStatic().newJournalTransData(inventJournalTrans,journalTableData);

            if (parentInventJournalTable.VoucherDraw == JournalVoucherDraw::Entering)
                journalTransData.initVoucher('',false);

            // disable reservation as this can overwrite assigned inventory dimensions
            if (parentInventJournalTable.Reservation != ItemReservation::None)
            {
                parentInventJournalTable.Reservation = ItemReservation::None;
                parentInventJournalTable.doUpdate();
            }

            journalTransData.insert();

            // Save it for update of amount fields
            parentInventJournalTrans.data(inventJournalTrans);

            this.assignPreviousUsedDim(inventJournalTrans);
        }
        else
        {
            throw error(strFmt("@SYS84671", this.journalId()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventJournalTable</Name>
				<Source><![CDATA[
    void initInventJournalTable(ItemReservation _itemReservation = ItemReservation::Automatic)
    {
        if (! bomParmReportFinish.JournalId)
        {
            journalTableData                        = JournalTableData::newTable(parentInventJournalTable);
            parentInventJournalTable.JournalId      = journalTableData.nextJournalId();
            parentInventJournalTable.JournalType    = InventJournalType::BOM;
            if (bomParmReportFinish.JournalNameId)
                parentInventJournalTable.JournalNameId  = bomParmReportFinish.JournalNameId;
            else
            {
                parentInventJournalTable.JournalNameId  = journalTableData.journalStatic().standardJournalNameId(enum2int(parentInventJournalTable.JournalType));
                if (!parentInventJournalTable.JournalNameId)
                    throw error("@SYS55001");
            }
            parentInventJournalTable.initFromInventJournalName(InventJournalName::find(parentInventJournalTable.JournalNameId));
            parentInventJournalTable.Reservation    = _itemReservation;
            parentInventJournalTable.insert();
        }
        else
        {
            parentInventJournalTable    = InventJournalTable::find(bomParmReportFinish.JournalId, true);
            journalTableData            = JournalTableData::newTable(parentInventJournalTable);
            lineNum                     = InventJournalTrans::lastLineNum(bomParmReportFinish.JournalId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalTableData</Name>
				<Source><![CDATA[
    JournalTableData  journalTableData()
    {
        return journalTableData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostJournal</Name>
				<Source><![CDATA[
    public boolean parmPostJournal(boolean _postJournal = postJournal)
    {
        postJournal = _postJournal;

        return postJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    void run()
    {
        #OCCRetryCount

        if (! this.validate())
            throw error("@SYS18447");

        setPrefix("@SYS12772");

        try
        {
            ttsbegin;
            setPrefix(#prefixField(BOMparmReportFinish,itemId));

            this.createJournal();
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }

        if (bomParmReportFinish.PostNow && postJournal)
        {
            try
            {
                ttsbegin;
                this.postJournal();
                ttscommit;
            }
            catch (Exception::Deadlock)
            {
                retry;
            }
            catch (Exception::UpdateConflict)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::UpdateConflictNotRecovered;
                    }
                    else
                    {
                        retry;
                    }
                }
                else
                {
                    throw Exception::UpdateConflict;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the inventory BOM journal.
    /// </summary>
    protected void createJournal()
    {
        if (bomParmReportFinish.InventTransIdReturn && bomParmReportFinish.Qty < 0)
        {
            this.initInventJournalTable(ItemReservation::None);
            this.initBOMReceiptReturn();
            this.searchReturnLotId();
        }
        else
        {
            this.initInventJournalTable();
            this.initBOMReceipt();
            this.searchBOM(
                    bomParmReportFinish.bomId,
                    bomParmReportFinish.ItemId,
                    bomParmReportFinish.inventDim(),
                    this.initBOMCalcData());
        }

        this.updateBOMPrice();

        parentInventJournalTable.update();

        if (bomParmReportFinish.Info)
        {
            info(strFmt("@SYS25061", parentInventJournalTrans.JournalId));
        }

        if (journalErrorTransList)
        {
            journalErrorTransList.insertDb();

            // do not post journal as warnings exists
            if (bomParmReportFinish.PostNow == NoYes::Yes)
            {
                this.unmarkBOMJournalForPosting();
                error(strFmt("@SYS95693",journalTableData.journalTable().JournalId));
            }
        }

        if (BOMReportFinishCircularityFlight::instance().isEnabled() &&
            BomReportFinishCircularityCheck::construct().isBOMJournalCyclic(parentInventJournalTrans))
        {
            this.unmarkBOMJournalForPosting();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unmarkBOMJournalForPosting</Name>
				<Source><![CDATA[
    private void unmarkBOMJournalForPosting()
    {
        bomParmReportFinish.selectForUpdate(true);
        bomParmReportFinish.PostNow = NoYes::No;
        bomParmReportFinish.doUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the generated inventory BOM journal.
    /// </summary>
    protected void postJournal()
    {
        // When not blocked then autoblock
        JournalCheckPost journalCheckPost = this.constructJournalCheckPost();
        journalCheckPost.runOperation();

        if (bomParmReportFinish.Info)
        {
            info("@SYS25060");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructJournalCheckPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>JournalCheckPost</c> class.
    /// </summary>
    /// <returns>
    /// An instance of the <c>JournalCheckPost</c> class.
    /// </returns>
    protected JournalCheckPost constructJournalCheckPost()
    {
        if (bomParmReportFinish.JournalId)
        {
            return InventJournalCheckPost::newJournalCheckPost(JournalCheckPostType::Post, parentInventJournalTable);
        }

        return InventJournalCheckPost::newPostJournal(parentInventJournalTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchInventJournalTrans</Name>
				<Source><![CDATA[
    void searchInventJournalTrans()
    {
        InventJournalTrans  inventJournalTransBOMLine;
        InventDim           inventDimBomLine;

        super();

        while select inventJournalTransBOMLine
            index hint VoucherIdx
            where inventJournalTransBOMLine.JournalId              == journalId     &&
                  inventJournalTransBOMLine.Voucher                == voucher       &&
                  inventJournalTransBOMLine.LineNum                                 &&
                  inventJournalTransBOMLine.bomLine                == NoYes::Yes    &&
                  inventJournalTransBOMLine.InventTransIdFather    == bomParmReportFinish.InventTransIdReturn
            join TableId from inventDimBomLine
            index hint DimIdIdx
                where inventDimBomLine.InventDimId == inventJournalTransBOMLine.InventDimId
        {
            setPrefix(#prefixField(inventJournalTransBOMLine,itemId));

            this.initBOMIssueReturn(inventJournalTransBOMLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchInventTrans</Name>
				<Source><![CDATA[
    void searchInventTrans()
    {
        /*
            request for new functionality
            Reversal of BOM journals based on Inventory transactions.
            HQ-740-274-PKLP
        */
            super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBOMConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an <c>InventJournalTrans</c> record from a bill of materials line.
    /// </summary>
    /// <param name="search">
    ///    A <c>BOMSearch</c> object that is used to iterate through a specific bill of materials.
    /// </param>
    /// <param name="parentBOMCalcData">
    ///    A <c>BOMCalcData</c> object that holds parameters as series size in order to calculate consumption
    ///    of each bill of materials line.
    /// </param>
    /// <param name="inventTable">
    ///    An <c>inventTable</c> record that relates to the selected bill of material line.
    /// </param>
    /// <param name="routeId">
    ///    A string that holds the route ID.
    /// </param>
    /// <param name="parentInventDim">
    ///    A <c>InventDim</c> record that holds inventory dimensions for the reported as finished item.
    /// </param>
    /// <returns>
    ///    An <c>InventQty</c> object that holds the consumption for the bill of materials line.
    /// </returns>
    InventQty updateBOMConsumption(
        BOMSearch       search,
        BOMCalcData     parentBOMCalcData,
        InventTable     inventTable,
        RouteId         routeId,
        InventDim       parentInventDim
        )
    {
        InventQty               expandQty;
        BOMCalcCost             calcCost = BOMCalcCost::construct();
        InventOnHandQty         inventOnHandQty;
        BOM                     localBOM;

        inventJournalTrans.clear();

        // Put this at the beginning because the initialization varies depending on this flag
        inventJournalTrans.bomLine              = NoYes::Yes;

        inventJournalTrans.initFromInventJournalTable(parentInventJournalTable);
        inventJournalTrans.initFromInventTable(inventTable);
        inventJournalTrans.initFromBOM(search.bom());
        InventDim inventDim = this.initInventDimFromBOMRoute(search.bom(),
                                                             search.parmParentItemId(),
                                                             parentInventDim,
                                                             routeId,
                                                             bomParmReportFinish.TransDate);
        inventJournalTrans.setInventDimId(inventDim.InventDimId, inventDim);

        inventJournalTrans.TransDate            = bomParmReportFinish.TransDate;
        inventJournalTrans.InventTransIdFather  = parentInventJournalTrans.InventTransId;
        inventJournalTrans.LineNum              = lineNum;

        if (bomParmReportFinish.OverrideDimension)
            inventJournalTrans.DefaultDimension = inventJournalTrans.copyDimension(bomParmReportFinish.DefaultDimension);

        inventJournalTrans.Qty          = this.calcQty(search,parentBOMCalcData,inventTable);
        inventJournalTrans.modifyInventJournalTransUnitQty();

        // Transactions are reserved when inserted, so availPhysical() returns possible onhand

        inventOnHandQty = InventOnHandQty::newBOMReportFinish(inventJournalTrans);
        inventJournalTrans.InventOnHand = inventOnHandQty.availPhysical();
        expandQty                       = this.expandQty(search,inventJournalTrans.Qty,inventJournalTrans.InventOnHand,inventTable);
        inventJournalTrans.Qty          = this.roundQty(inventJournalTrans.Qty,expandQty,inventTable.ItemId);

        if (inventJournalTrans.Qty)
        {
            localBOM = search.bom();
            calcCost.initCalc(bomParmReportFinish.TransDate,
                              inventJournalTrans.ItemId,
                              inventJournalTrans.InventDimId,
                              inventJournalTrans.Qty,
                              inventJournalTrans.Qty,
                              localBOM.vendId(search.parmParentItemId(), search.parmParentConfigId(), routeId, localBOM.inventDim().InventSiteId),
                              inventJournalTrans.ProfitSet);

            calcCost.calc();

            inventJournalTrans.CostPrice    = calcCost.costPrice();
            inventJournalTrans.PriceUnit    = calcCost.costPriceUnit();
            inventJournalTrans.CostMarkup   = calcCost.costMarkup();
            inventJournalTrans.CostAmount   = 0;

            inventJournalTrans.ProfitSet    = bomParmReportFinish.ProfitSet;
            inventJournalTrans.CostAmount   = CurrencyExchangeHelper::amount(calcCost.costAmount() + (inventJournalTrans.Qty >= 0 ? calcCost.costMarkup() : -calcCost.costMarkup()));
            inventJournalTrans.SalesAmount  = CurrencyExchangeHelper::amount(calcCost.salesAmount() + (inventJournalTrans.Qty >= 0 ? calcCost.salesMarkup() : -calcCost.salesMarkup()));

            if (parentInventJournalTable.VoucherDraw == JournalVoucherDraw::Entering)
                journalTransData.initVoucher(voucher_last,false,false);               // Voucher is assigned

            parentInventJournalTrans.CostAmount    -= inventJournalTrans.CostAmount;
            parentInventJournalTrans.SalesAmount   -= inventJournalTrans.SalesAmount;

            journalTransData.insert();
        }

        return expandQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDimFromBOMRoute</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets <c>InventDim</c> from BOM and route version.
    /// </summary>
    /// <param name="_bom">
    ///    A BOM record.
    /// </param>
    /// <param name="_parentItemId">
    ///    A string that holds the parent <c>itemID</c>.
    /// </param>
    /// <param name="_parentInventDim">
    ///    A <c>inventDim</c> record that holds the inventory dimensions related to the parent item.
    /// </param>
    /// <param name="_routeId">
    ///    A string that holds the <c>routeID</c> that must be used to make the parent item.
    /// </param>
    /// <param name="_bomDate">
    ///    The date used to determine the input location.
    /// </param>
    /// <returns>
    /// <c>InventDim</c> updated with found warehouse and location.
    /// </returns>
    public InventDim initInventDimFromBOMRoute(BOM         _bom,
                                                 ItemId      _parentItemId,
                                                 InventDim   _parentInventDim,
                                                 RouteId     _routeId,
                                                 TransDate   _bomDate)
    {
        InventDim   inventDim = _bom.BOMMap::inventDimFinal(_parentItemId, _parentInventDim, _routeId);

        // If warehouse is not returned from default order settings, use the parent warehouse if warehouse is an active storage dimension
        if (!inventDim.InventLocationId && _parentInventDim.InventLocationId)
        {
            InventLocationId inventLocationId  = this.getParentInventLocationId(_bom, _parentInventDim);

            if (inventLocationId)
            {
                inventDim.InventLocationId = inventLocationId;
                inventDim = InventDim::findOrCreate(inventDim);
            }
        }

        if (_routeId)
        {
            WMSLocationId inputWMSLocationId = _bom.BOMMap::routeInputWMSLocationId(_parentItemId,
                                                       _routeId,
                                                       _parentInventDim.ConfigId,
                                                       _parentInventDim.InventSiteId,
                                                       _bom.OprNum,
                                                       _bom.WrkCtrConsumption,
                                                       _bomDate);
            if (inputWMSLocationId)
            {
                inventDim.wmsLocationId = inputWMSLocationId;
                inventDim = InventDim::findOrCreate(inventDim);
            }
        }

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParentInventLocationId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Return <c>InventLocationId</c> from parent BOM Item.
    /// </summary>
    /// <param name="_bom">
    ///    A string that holds the <c>BOM</c>.
    /// </param>
    /// <param name="_parentInventDim">
    ///    A <c>inventDim</c> record that holds the inventory dimensions related to the parent item.
    /// </param>
    /// <returns>
    /// <c>InventLocationId</c> from parent or default order settings if defined on the item.
    /// </returns>
    private InventLocationId getParentInventLocationId(BOM         _bom,
                                                       InventDim   _parentInventDim)
    {
        InventLocationId    inventLocationId;
        InventDimGroupSetup inventDimGroupSetup = InventDimGroupSetup::newItemId(_bom.ItemId);

        if (inventDimGroupSetup.getFieldSetup(fieldNum(InventDim, InventLocationId)).isActive())
        {
            inventLocationId = _parentInventDim.InventLocationId;
        }

        return inventLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBOMPrice</Name>
				<Source><![CDATA[
    void updateBOMPrice()
    {
        InventJournalTrans    updateParentInventJournalTrans;

        // Reselect parent
        select firstonly forupdate updateParentInventJournalTrans
            index hint LineIdx
            where updateParentInventJournalTrans.JournalId == parentInventJournalTrans.JournalId    &&
                  updateParentInventJournalTrans.LineNum   == parentInventJournalTrans.LineNum      &&
                  updateParentInventJournalTrans.bomLine   == NoYes::No;

        if (! updateParentInventJournalTrans)
            return;

        updateParentInventJournalTrans.PriceUnit    = 1;
        updateParentInventJournalTrans.CostMarkup   = 0;

        if (!updateParentInventJournalTrans.inventTable().modelGroup().inventModelType().stdCostBased())
        {
            updateParentInventJournalTrans.CostPrice    = PriceDisc::amount2Price(parentInventJournalTrans.CostAmount,
                                                               0,
                                                               0,
                                                               parentInventJournalTrans.Qty,
                                                               0,
                                                               1,
                                                               '',
                                                               0);
        }
        else
        {
            updateParentInventJournalTrans.setCostPrice(updateParentInventJournalTrans.InventDimId, updateParentInventJournalTrans.inventDim());
        }
        updateParentInventJournalTrans.CostAmount    = parentInventJournalTrans.CostAmount;
        updateParentInventJournalTrans.SalesAmount   = parentInventJournalTrans.SalesAmount;
        updateParentInventJournalTrans.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static ClassDescription description()
    {
        return "@SYS26441";
    }

]]></Source>
			</Method>
			<Method>
				<Name>newAutoReportFinished</Name>
				<Source><![CDATA[
    static BOMReportFinish newAutoReportFinished(
        ItemId              itemId,
        InventDimId         inventDimId,
        TransDate           transDate,
        InventQty           qty,
        DimensionDefault    defaultDimension = 0)
    {
        BOMReportFinish             bomReportFinished;
        BOMParmReportFinish         bomParmReportFinish;

        bomParmReportFinish.ParmBuffer::initParmId();
        bomParmReportFinish.initParmDefault();
        bomParmReportFinish.TransDate           = transDate;
        bomParmReportFinish.ItemId              = itemId;
        bomParmReportFinish.Qty                 = qty;
        bomParmReportFinish.setInventDimId(inventDimId);
        bomParmReportFinish.initFromInventTable(InventTable::find(itemId));
        bomParmReportFinish.Qty                 = qty;

        if (defaultDimension)
        {
            bomParmReportFinish.OverrideDimension = true;
            bomParmReportFinish.DefaultDimension  = bomParmReportFinish.mergeDimension(defaultDimension, bomParmReportFinish.DefaultDimension);
        }
        else
        {
            bomParmReportFinish.OverrideDimension = false;
        }

        bomParmReportFinish.PostNow             = true;
        bomParmReportFinish.Explode             = BOMExplode::Never;
        bomParmReportFinish.insert();

        bomReportFinished  = BOMReportFinish::newParmBuffer(bomParmReportFinish);

        return bomReportFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newParmBuffer</Name>
				<Source><![CDATA[
    static BOMReportFinish newParmBuffer(BOMParmReportFinish    _bomParmReportFinish, boolean _postJournal = true)
    {
        BOMReportFinish   bomReportFinish;
        bomReportFinish = new BOMReportFinish();
        bomReportFinish.parmParmBuffer(_bomParmReportFinish);
        bomReportFinish.parmPostJournal(_postJournal);

        return bomReportFinish;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>