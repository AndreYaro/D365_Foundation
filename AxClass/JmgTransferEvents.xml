<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>JmgTransferEvents</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>JmgTransferEvents</c> class is used to calculate the pay for a worker, according to
///    registrations that are made by the worker.
/// </summary>
/// <remarks>
///    During calculation, an internal event array is built that holds the calculation results.
/// </remarks>
class JmgTransferEvents
{
    Integer             currentEvent;
    Integer             timePayEventCnt;
    JmgWorkerRecId      timePayEventWorker          [];
    StartDate           timePayEventProfileDate     [];
    JmgPaySpecType      timePayEventPaySpecType     [];
    JmgSeconds          timePayEventPaySeconds      [];
    JmgPayCostType      timePayEventPayCType        [];
    Price               timePayEventPayRate         [];
    JmgIpcActivityId    timePayEventAbsType         [];
    RouteOprId          timePayEventOprId           [];
    JmgSeconds          timePayEventPayCntUnitSec   [];
    JmgPayCountId       timePayEventPayCntUnitId    [];
    DimensionDefault    timePayEventDefaultDimension[];
    NoYes               timePayEventCancelPay       [];

    Integer             dimCnt;
    DimensionDefault    defaultDimension            [];
    JmgSeconds          dimSeconds                  [];

    Integer             transidCostCnt;
    Integer             transidCostCntFrom;
    JmgTransId          transidCostid                [];
    JmgPaySpecType      transidCostPayType           [];
    JmgStampTypeSpec    transidCostStampTypeSpec     [];
    real                transidCostNetCost           [];
    JmgSeconds          transidCostNetTime           [];
    NoYesId             transidCostCostSlize         [];

    Integer             transidTimeCnt;
    JmgTransId          transidTimeid                [];
    JmgStampTypeSpec    transidTimeStampTypeSpec     [];
    JmgSeconds          transidTimeNetTime           [];
    RouteOprId          transidTimeOpr               [];
    JmgIpcActivityId    transidTimeAbsenceAct        [];
    HRMAbsenceCodeId    transidTimeHRMAbsenceCode    [];
    ProjId              transidTimeProjId            [];
    ProjActivityId      transidTimeProjActivityId    [];
    JmgIpcActivityIdOnCall transIdTimeOnCallAct      [];
    JmgSpecialDayId     transidTimeSpecialDayId      [];
    JmgJobRef           transidTimeJobRef            [];
    JmgSeconds          transidTimeTimeOut;
    RouteOprId          transidTimeOprOut;
    JmgIpcActivityId    transidTimeAbsenceActOut;
    HRMAbsenceCodeId    transidTimeHRMAbsenceCodeOut;
    ProjActivityId      transidTimeProjActivity;
    ProjId              transidTimeProj;
    JmgIpcActivityIdOnCall transIdTimeOnCallActivity;
    JmgSpecialDayId     transidTimeSpecialDay;
    JmgJobRef           transidTimeCurJobRef;

    Integer             tjCnt;
    JmgJobId            tjJobid             [];
    JmgSeconds          tjNetTime           [];
    JmgSeconds          tjTimeOut;

    StartDate           senToDate;
    Integer             senMth;
    Integer             senDays;

    JmgCostSlizeNoYes   costBuildNormTime_;
    JmgCostSlizeNoYes   costBuildOverTime_;
    JmgCostSlizeNoYes   costBuildBreak_;
    JmgCostSlizeNo      costBuildFlexSub_;
    JmgCostSlizeNoYes   costBuildFlexAdd_;
    JmgCostSlizeNoYes   costBuildPayAdd_;
    JmgCostSlizeNoYes   costBuildPayAddManual_;
    JmgCostSlizeNo      costBuildAbsence_;
    Factor              costBuildFactor_;
    Price               costNormTime;
    Price               costOverTime;
    Price               costBreak;
    Price               costFlexSub;
    Price               costFlexAdd;
    Price               costPayAdd;
    Price               costPayAddManual;
    Price               costAbsence;

    int                 insertedEventsCount;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addJobTimeidCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the job time on the specified job to the internal event array.
    /// </summary>
    /// <param name="tJidIn">
    ///    The job ID of the job for which to add time.
    /// </param>
    /// <param name="tjNetTimeIn">
    ///    The time to add.
    /// </param>
    void addJobTimeidCost(   JmgJobId            tJidIn,
                        JmgSeconds          tjNetTimeIn)
    {
        tjCnt++;
        tjJobid     [tjCnt] = tJidIn;
        tjNetTime   [tjCnt] = tjNetTimeIn;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTimePrDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the time that is used on jobs that are associated to the specified dimensions.
    /// </summary>
    /// <param name="_defaultDimension">
    ///    The dimensions on which to add time.
    /// </param>
    /// <param name="jmgSeconds">
    ///    The time to add.
    /// </param>
    void addTimePrDim(DimensionDefault _defaultDimension, JmgSeconds jmgSeconds)
    {
        if (jmgSeconds)
        {
            dimCnt = 1;
            while (dimSeconds[dimCnt])
            {
                if (_defaultDimension == defaultDimension[dimCnt])
                {
                    dimSeconds[dimCnt] += jmgSeconds;
                    dimCnt = 0;
                    break;
                }
                dimCnt++;
            }
            if (dimCnt)
            {
                defaultDimension [dimCnt] = _defaultDimension;
                dimSeconds     [dimCnt] = jmgSeconds;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTRiDCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the cost on a specified transaction ID.
    /// </summary>
    /// <param name="transidCostidIn">
    ///    The transaction ID to add cost for.
    /// </param>
    /// <param name="transidCostPayTypeIn">
    ///    The pay type of the cost.
    /// </param>
    /// <param name="transidCostStampTypeSpecIn">
    ///    The stamp type specification of the cost.
    /// </param>
    /// <param name="transidCostNetCostIn">
    ///    The cost to add.
    /// </param>
    /// <param name="transidCostNetTimeIn">
    ///    The time to add.
    /// </param>
    /// <param name="transidCostCostSlizeIn">
    ///    The <c>NoYes::Yes</c> enumeration value if the added cost is included in the total cost
    ///    calculation; otherwise, the <c>NoYes::No</c> value.
    /// </param>
    void addTRiDCost(   JmgTransId          transidCostidIn,
                        JmgPaySpecType      transidCostPayTypeIn,
                        JmgStampTypeSpec    transidCostStampTypeSpecIn,
                        real                transidCostNetCostIn,
                        JmgSeconds          transidCostNetTimeIn,
                        NoYesId             transidCostCostSlizeIn= NoYes::No)
    {
        transidCostCnt++;
        transidCostid           [transidCostCnt] = transidCostidIn;
        transidCostPayType      [transidCostCnt] = transidCostPayTypeIn;
        transidCostStampTypeSpec[transidCostCnt] = transidCostStampTypeSpecIn;
        transidCostNetCost      [transidCostCnt] = transidCostNetCostIn;
        transidCostNetTime      [transidCostCnt] = transidCostNetTimeIn;
        transidCostCostSlize    [transidCostCnt] = transidCostCostSlizeIn;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTRiDTimeOpr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds an event to the internal event array.
    /// </summary>
    /// <param name="transidTimeidIn">
    /// The transaction ID of the event to add.
    /// </param>
    /// <param name="transidTimeStampTypeSpecIn">
    /// The stamp type specification of the event to add.
    /// </param>
    /// <param name="transidTimeNetTimeIn">
    /// The time of the event to add.
    /// </param>
    /// <param name="transidTimeOprIn">
    /// The operation ID of the event to add.
    /// </param>
    /// <param name="transidTimeAbsenceActIn">
    /// The absence activity ID of the event to add.
    /// </param>
    /// <param name="transidTimeProjIn">
    /// The project ID of the event to add.
    /// </param>
    /// <param name="transidTimeProjActivityIn">
    /// The project activity ID of the event to add.
    /// </param>
    /// <param name="transIdTimeOnCallActivityIn">
    /// The on call activity ID of the event to add.
    /// </param>
    /// <param name="transidTimeSpecialDayIdIn">
    /// The special day ID of the event to add.
    /// </param>
    /// <param name="transidTimeHRMAbsenceCodeIdIn">
    /// The absence code of the event to add.
    /// </param>
    /// <param name="transidTimeJobRefIn">
    /// The job reference of the ID to add.
    /// </param>
    void addTRiDTimeOpr(JmgTransId              transidTimeidIn,
                        JmgStampTypeSpec        transidTimeStampTypeSpecIn,
                        JmgSeconds              transidTimeNetTimeIn,
                        RouteOprId              transidTimeOprIn,
                        JmgIpcActivityId        transidTimeAbsenceActIn,
                        ProjId                  transidTimeProjIn,
                        ProjActivityId          transidTimeProjActivityIn,
                        JmgIpcActivityIdOnCall  transIdTimeOnCallActivityIn,
                        JmgSpecialDayId         transidTimeSpecialDayIdIn,
                        HRMAbsenceCodeId        transidTimeHRMAbsenceCodeIdIn,
                        JmgJobRef               transidTimeJobRefIn)
    {

        if (transidTimeidIn)
        {
            for (transidTimeCnt = 1; transidTimeid[transidTimeCnt]; transidTimeCnt++)
            {
                if (transidTimeid[transidTimeCnt] == transidTimeidIn)
                {
                    transidTimeStampTypeSpec[transidTimeCnt] = transidTimeStampTypeSpecIn;
                    transidTimeNetTime[transidTimeCnt]       += transidTimeNetTimeIn;
                    transidTimeOpr[transidTimeCnt]           = transidTimeOprIn;
                    transidTimeAbsenceAct[transidTimeCnt]    = transidTimeAbsenceActIn;
                    transidTimeProjId[transidTimeCnt]        = transidTimeProjIn;
                    transidTimeProjActivityId[transidTimeCnt]= transidTimeProjActivityIn;
                    transIdTimeOnCallAct[transidTimeCnt]     = transIdTimeOnCallActivityIn;
                    transidTimeSpecialDayId[transidTimeCnt]  = transidTimeSpecialDayIdIn;
                    transidTimeHRMAbsenceCode[transidTimeCnt]= transidTimeHRMAbsenceCodeIdIn;
                    transidTimeJobRef[transidTimeCnt]        = transidTimeJobRefIn;
                    transidTimeCnt = 0;
                    break;
                }
            }
            if (transidTimeCnt)
            {
                transidTimeid[transidTimeCnt]             = transidTimeidIn;
                transidTimeStampTypeSpec[transidTimeCnt]  = transidTimeStampTypeSpecIn;
                transidTimeNetTime[transidTimeCnt]        = transidTimeNetTimeIn;
                transidTimeOpr[transidTimeCnt]            = transidTimeOprIn;
                transidTimeAbsenceAct[transidTimeCnt]     = transidTimeAbsenceActIn;
                transidTimeProjId[transidTimeCnt]         = transidTimeProjIn;
                transidTimeProjActivityId[transidTimeCnt] = transidTimeProjActivityIn;
                transIdTimeOnCallAct[transidTimeCnt]      = transIdTimeOnCallActivityIn;
                transidTimeSpecialDayId[transidTimeCnt]   = transidTimeSpecialDayIdIn;
                transidTimeHRMAbsenceCode[transidTimeCnt] = transidTimeHRMAbsenceCodeIdIn;
                transidTimeJobRef[transidTimeCnt]         = transidTimeJobRefIn;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCostToSlize</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the cost for events that are added to the internal event array.
    /// </summary>
    /// <remarks>
    ///    The calculated costs are assigned to internal variables.
    /// </remarks>
    public void calcCostToSlize()
    {
        JmgParameters   jmgParameters;
        jmgParameters = JmgParameters::find();

        costBuildNormTime_      = jmgParameters.CostBuildNormTime;
        costBuildOverTime_      = jmgParameters.CostBuildOverTime;
        costBuildBreak_         = jmgParameters.CostBuildBreak;
        costBuildFlexSub_       = jmgParameters.CostBuildFlexSub;
        costBuildFlexAdd_       = jmgParameters.CostBuildFlexAdd;
        costBuildPayAdd_        = jmgParameters.CostBuildPayAdd;
        costBuildPayAddManual_  = jmgParameters.CostBuildPayAddManual;
        costBuildAbsence_       = jmgParameters.CostBuildAbsence;
        costBuildFactor_        = jmgParameters.CostBuildFactor;

        if (transidCostCnt)
        {
            for (transidCostCntFrom = 1; transidCostCntFrom <= transidCostCnt; transidCostCntFrom++)
            {
                if (transidCostCostSlize[transidCostCntFrom])
                {
                    switch (transidCostPayType[transidCostCntFrom])
                    {
                        case JmgPaySpecTypeEnum::WorkTime :
                            costNormTime    += transidCostNetCost[transidCostCntFrom];
                            break;
                        case JmgPaySpecTypeEnum::OverTime :
                            costOverTime    += transidCostNetCost[transidCostCntFrom];
                            break;
                        case JmgPaySpecTypeEnum::Break :
                            costBreak       += transidCostNetCost[transidCostCntFrom];
                            break;
                        case JmgPaySpecTypeEnum::FlexSub :
                            costFlexSub     += transidCostNetCost[transidCostCntFrom];
                            break;
                        case JmgPaySpecTypeEnum::FlexAdd :
                            costFlexAdd     += transidCostNetCost[transidCostCntFrom];
                            break;
                        case JmgPaySpecTypeEnum::AddOn :
                            costPayAdd      += transidCostNetCost[transidCostCntFrom];
                            break;
                        case JmgPaySpecTypeEnum::AddOnManual :
                            costPayAddManual += transidCostNetCost[transidCostCntFrom];
                            break;
                        case JmgPaySpecTypeEnum::Absence :
                            costAbsence     += transidCostNetCost[transidCostCntFrom];
                            break;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCostPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds project hour cost price.
    /// </summary>
    /// <param name = "_parameters">
    /// An instance of <c>ProjPriceParameters</c> containing the search criteria.
    /// </param>
    /// <returns>
    /// The cost price.
    /// </returns>
    protected Price findCostPrice(ProjPriceParameters _parameters)
    {
        return ProjHourCostPrice::findCostPriceByPriceParameters(_parameters);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRouteCostCategoryForProductionJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the route cost category for a production type job.
    /// </summary>
    /// <param name = "_prodJob">The production type job.</param>
    /// <returns>The route cost category.</returns>
    protected RouteCostCategory findRouteCostCategoryForProductionJob(JmgTermJob_Prod _prodJob)
    {
        ProdRoute prodRoute = _prodJob.prodRoute();

        if (_prodJob.prodJobType() == RouteJobType::Setup)
        {
            return RouteCostCategory::find(prodRoute.SetUpCategoryId);
        }
        return RouteCostCategory::find(prodRoute.ProcessCategoryId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcSlizeCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the cost for the specified registration, and then assigns the result on the registration.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record, which refers to the worker and date that is being
    ///    transferred.
    /// </param>
    /// <param name="jmgStampTrans">
    ///    The registration for which to calculate cost.
    /// </param>
    /// <param name="slizeOvertimeManual">
    ///    The <c>NoYes::Yes</c> enumeration value if overtime cost have been manually assigned to
    ///    registrations for the day; otherwise, the <c>NoYes::No</c> value.
    /// </param>
    public void calcSlizeCost(JmgStampJournalTable jmgStampJournalTable,JmgStampTrans jmgStampTrans, NoYesId slizeOvertimeManual = NoYes::No)
    {
        JmgTransferEventsSlizes         jmgTransferEventsSlizes = JmgTransferEventsSlizes::construct();
        ProjActivity                    projActivity;

        boolean                         useStdCost  = false;
        jmgStampTrans.CostNormTime      = 0;
        jmgStampTrans.CostOverTime      = 0;
        jmgStampTrans.CostBreak         = 0;
        jmgStampTrans.CostFlexSub       = 0;
        jmgStampTrans.CostFlexAdd       = 0;
        jmgStampTrans.CostPayAdd        = 0;
        jmgStampTrans.CostPayAddManual  = 0;
        jmgStampTrans.CostAbsence       = 0;

        jmgStampTrans.CostFactor        = costBuildFactor_ ? costBuildFactor_ : 1;

        if (jmgStampTrans.JobPayType    != JmgJobPayTypeEnum::PieceRate)
        {
            jmgStampTrans.PieceRatePayCostTypeMin   = '';
            jmgStampTrans.PieceRatePayMinRate       = 0;
            jmgStampTrans.PieceRatePayRate          = 0;
        }

        this.getTRiDTimeOpr(jmgStampTrans.TransId);

        if (! (transidTimeTimeOut && jmgStampTrans.Seconds))
        {
            return;
        }

        if (transidCostCnt)
        {
            jmgTransferEventsSlizes = this.calculateSlizeVariables(jmgStampTrans, slizeOvertimeManual);
        }

        if (jmgTransferEventsSlizes.slizeNormTime && jmgStampJournalTable.PaySeconds)
            jmgStampTrans.CostNormTime  +=(costNormTime * ((jmgStampTrans.Seconds /  jmgStampJournalTable.PaySeconds) / (jmgStampTrans.Seconds / 3600)));

        JmgSeconds allocatePaySeconds = jmgStampJournalTable.PaySeconds - jmgStampJournalTable.PayAbsenceSeconds - jmgStampJournalTable.paidBreakSeconds;
        
        if (jmgTransferEventsSlizes.slizeOverTime && jmgStampJournalTable.PaySeconds)
        {
            if (slizeOvertimeManual == NoYes::No)
            {
                if (allocatePaySeconds)
                {
                    jmgStampTrans.CostOverTime  +=(costOverTime * ((jmgStampTrans.Seconds /  allocatePaySeconds) / (jmgStampTrans.Seconds / 3600)));
                }
            }
            else
            {
                JmgOvertimeSlize jmgOvertimeSlize;

                select firstonly jmgOvertimeSlize
                    where jmgOvertimeSlize.Worker      == jmgStampTrans.Worker &&
                            jmgOvertimeSlize.ProfileDate == jmgStampTrans.ProfileDate &&
                            jmgOvertimeSlize.JobId       == jmgStampTrans.JobId;

                if (jmgOvertimeSlize)
                {
                    this.getJobTimeJobidTime(jmgStampTrans.JobId);
                    if (tjTimeOut && jmgStampTrans.Seconds)
                    {
                        jmgStampTrans.CostOverTime += (costOverTime *(jmgOvertimeSlize.Percent / 100)*(jmgStampTrans.Seconds / tjTimeOut))/(jmgStampTrans.Seconds / 3600);
                    }
                }
            }
        }

        if (jmgTransferEventsSlizes.slizeBreak && allocatePaySeconds)
            jmgStampTrans.CostBreak     +=(costBreak * ((jmgStampTrans.Seconds /  allocatePaySeconds) / (jmgStampTrans.Seconds / 3600)));

        if (jmgTransferEventsSlizes.slizeFlexSub && jmgStampJournalTable.PaySeconds)
            jmgStampTrans.CostFlexSub   +=(costFlexSub * ((jmgStampTrans.Seconds /  jmgStampJournalTable.PaySeconds) / (jmgStampTrans.Seconds / 3600)));

        if (jmgTransferEventsSlizes.slizeFlexAdd && jmgStampJournalTable.PaySeconds)
            jmgStampTrans.CostFlexAdd   +=(costFlexAdd * ((jmgStampTrans.Seconds /  jmgStampJournalTable.PaySeconds) / (jmgStampTrans.Seconds / 3600)));

        if (jmgTransferEventsSlizes.slizePayAdd && jmgStampJournalTable.PaySeconds)
            jmgStampTrans.CostPayAdd   +=(costPayAdd * ((jmgStampTrans.Seconds /  jmgStampJournalTable.PaySeconds) / (jmgStampTrans.Seconds / 3600)));

        if (jmgTransferEventsSlizes.slizePayAddManual && jmgStampJournalTable.PaySeconds)
            jmgStampTrans.CostPayAddManual +=(costPayAddManual * ((jmgStampTrans.Seconds /  jmgStampJournalTable.PaySeconds) / (jmgStampTrans.Seconds / 3600)));

        if (jmgTransferEventsSlizes.slizeAbsence && jmgStampJournalTable.PaySeconds)
            jmgStampTrans.CostAbsence   +=(costAbsence * ((jmgStampTrans.Seconds /  jmgStampJournalTable.PaySeconds) / (jmgStampTrans.Seconds / 3600)));


        switch (jmgStampTrans.Module)
        {
            case JmgModuleEnum::PROD:
                JmgTermJob_Prod prodJob = JmgTermJob::construct(jmgStampTrans.JobId);
                InventDimId inventSiteInventDimId = prodJob.siteInventDimId();
                if (JmgProdParametersDim::find(inventSiteInventDimId).CostUseStandardCost == NoYes::Yes)
                {
                    RouteCostCategory routeCostCategory = this.findRouteCostCategoryForProductionJob(prodJob);
                    useStdCost                      = true;
                    jmgStampTrans.CostNormTime      = routeCostCategory.costPrice(InventDim::find(inventSiteInventDimId).InventSiteId);
                    jmgStampTrans.HourPrice         = jmgStampTrans.CostNormTime * (jmgStampTrans.CostFactor ? jmgStampTrans.CostFactor : 1);
                }
                break;
        
            case JmgModuleEnum::PROJ:
                if (JmgParameters::find().CostUseStandardCostProj == NoYes::Yes)
                {
                    ProjTable projTable                 = ProjTable::findJobId(jmgStampTrans.JobId);
                    if (! projTable)
                    {
                        projActivity                    = ProjActivity::findJobId(jmgStampTrans.JobId);
                        // hierarchy
                        projTable                       = HierarchyTreeTable_Extension::findAssociation(smmActivities::find(projActivity.ActivityNumber), tablenum(ProjTable));
                    }

                    ProjPriceParameters priceParams     = ProjHourCostPrice::constructPriceParametersForFindCostPrice(projTable.ProjId, ResourceFacade::findByWorker(jmgStampTrans.Worker), projActivity.CategoryDefault,'');
                    JmgStampTrans.CostNormTime			= this.findCostPrice(priceParams);
                    jmgStampTrans.HourPrice             = jmgStampTrans.CostNormTime * (jmgStampTrans.CostFactor ? jmgStampTrans.CostFactor : 1);
                    useStdCost                          = true;
                }
                break;

            case JmgModuleEnum::IPC:
                if (JmgParameters::find().CostUseStandardCostIPC == NoYes::Yes)
                {
                    JmgIpcActivityId activity;

                    if (jmgStampTrans.StampType == JmgStampTypeEnum::Absence)
                    {
                        activity = HRMAbsenceCode::findByJobId(jmgStampTrans.JobIDAbs).hrmAbsenceCodeId;
                    }
                    else
                    {
                        activity = JmgIpcActivity::findJobId(jmgStampTrans.JobId).Activity;
                    }

                    if (activity)
                    {
                        jmgStampTrans.CostNormTime      = JmgIpcActivityCostPrice::find(activity, jmgStampJournalTable.ProfileDate).CostPrice;
                        jmgStampTrans.HourPrice         = jmgStampTrans.CostNormTime * (jmgStampTrans.CostFactor ? jmgStampTrans.CostFactor : 1);
                        useStdCost                      = true;
                    }
                }
                break;
        }

        if (! useStdCost)
        {
            if (jmgStampTrans.JobType == JmgJobTypeEnum::Bundle4) // PayRoll Allocation
            {
                jmgStampTrans.CostNormTime      = ((jmgStampTrans.CostNormTime      * jmgStampTrans.Seconds) / jmgStampTrans.SecondsOnReg);
                jmgStampTrans.CostOverTime      = ((jmgStampTrans.CostOverTime      * jmgStampTrans.Seconds) / jmgStampTrans.SecondsOnReg);
                jmgStampTrans.CostBreak         = ((jmgStampTrans.CostBreak         * jmgStampTrans.Seconds) / jmgStampTrans.SecondsOnReg);
                jmgStampTrans.CostFlexSub       = ((jmgStampTrans.CostFlexSub       * jmgStampTrans.Seconds) / jmgStampTrans.SecondsOnReg);
                jmgStampTrans.CostFlexAdd       = ((jmgStampTrans.CostFlexAdd       * jmgStampTrans.Seconds) / jmgStampTrans.SecondsOnReg);
                jmgStampTrans.CostPayAdd        = ((jmgStampTrans.CostPayAdd        * jmgStampTrans.Seconds) / jmgStampTrans.SecondsOnReg);
                jmgStampTrans.CostPayAddManual  = ((jmgStampTrans.CostPayAddManual  * jmgStampTrans.Seconds) / jmgStampTrans.SecondsOnReg);
                jmgStampTrans.CostAbsence       = ((jmgStampTrans.CostAbsence       * jmgStampTrans.Seconds) / jmgStampTrans.SecondsOnReg);

                JmgSeconds tmpSeconds           = jmgStampTrans.Seconds;
                jmgStampTrans.Seconds           = jmgStampTrans.SecondsOnReg;
                jmgStampTrans.SecondsOnReg      = tmpSeconds;
            }

            jmgStampTrans.HourPrice = ( jmgStampTrans.CostNormTime      +
                                        jmgStampTrans.CostOverTime      +
                                        jmgStampTrans.CostBreak         +
                                        jmgStampTrans.CostFlexSub       +
                                        jmgStampTrans.CostFlexAdd       +
                                        jmgStampTrans.CostPayAdd        +
                                        jmgStampTrans.CostPayAddManual  +
                                        jmgStampTrans.CostAbsence       +
                                        max(jmgStampTrans.PieceRatePayRate,jmgStampTrans.PieceRatePayMinRate)   )
                                            * (jmgStampTrans.CostFactor ? jmgStampTrans.CostFactor : 1);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSlizeVariables</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the different slice variables and assigns the result to a <c>JmgTransferEventsSlizeVariables</c> object.
    /// </summary>
    /// <param name="_jmgStampTrans">
    ///    The registration for which to calculate cost.
    /// </param>
    /// <param name="_slizeOvertimeManual">
    ///    The <c>NoYes::Yes</c> enumeration value if overtime cost have been manually assigned to
    ///    registrations for the day; otherwise, the <c>NoYes::No</c> value.
    /// </param>
    /// <returns>
    ///    A <c>JmgTransferEventsSlizeVariables</c> holding the slice variables.
    /// </returns>
    private JmgTransferEventsSlizes calculateSlizeVariables(JmgStampTrans _jmgStampTrans, NoYesId _slizeOvertimeManual)
    {
        JmgTransferEventsSlizes jmgTransferEventsSlizes = JmgTransferEventsSlizes::construct();
        for (transidCostCntFrom = 1; transidCostCntFrom <= transidCostCnt; transidCostCntFrom++)
        {
            Price slizeCostPrice = ((transidCostNetCost[transidCostCntFrom] * (_jmgStampTrans.Seconds / transidTimeTimeOut)) / (_jmgStampTrans.Seconds / 3600));

            if (_jmgStampTrans.StampTypeSpec == JmgStampTypeSpecEnum::Work)
            {
                switch (transidCostPayType[transidCostCntFrom])
                {
                    case JmgPaySpecTypeEnum::WorkTime :
                        if (costBuildNormTime_)
                        {
                            if (((costBuildNormTime_                            == JmgCostSlizeNoYesEnum::Yes)      ||
                                    (! transidCostCostSlize[transidCostCntFrom]))                                   &&
                                    (transidCostid[transidCostCntFrom]              == _jmgStampTrans.TransId)      &&
                                    (transidCostStampTypeSpec[transidCostCntFrom]   == _jmgStampTrans.StampTypeSpec))
                            {
                                _jmgStampTrans.CostNormTime += slizeCostPrice;
                            }
                            if (costBuildNormTime_ == JmgCostSlizeNoYesEnum::Slize)
                            {
                                jmgTransferEventsSlizes.slizeNormTime = true;
                            }
                        }
                        break;
                    
                    case JmgPaySpecTypeEnum::OverTime :
                        if (costBuildOverTime_)
                        {
                            if (_slizeOvertimeManual == NoYes::No)
                            {
                                if (((costBuildOverTime_                            == JmgCostSlizeNoYesEnum::Yes)      ||
                                        (! transidCostCostSlize[transidCostCntFrom]))                                   &&
                                        (transidCostid[transidCostCntFrom]              == _jmgStampTrans.TransId)      &&
                                        (transidCostStampTypeSpec[transidCostCntFrom]   == _jmgStampTrans.StampTypeSpec))
                                {
                                    _jmgStampTrans.CostOverTime += slizeCostPrice;
                                }
                                if (costBuildOverTime_ == JmgCostSlizeNoYesEnum::Slize)
                                {
                                    jmgTransferEventsSlizes.slizeOverTime = true;
                                }
                            }
                            else
                            {
                                jmgTransferEventsSlizes.slizeOverTime = true;
                            }
                        }
                        break;
                    
                    case JmgPaySpecTypeEnum::Break :
                        if (costBuildBreak_)
                        {
                            if (((costBuildBreak_                               == JmgCostSlizeNoYesEnum::Yes)      ||
                                    (! transidCostCostSlize[transidCostCntFrom]))                                   &&
                                    (transidCostid[transidCostCntFrom]              == _jmgStampTrans.TransId)      &&
                                    (transidCostStampTypeSpec[transidCostCntFrom]   == _jmgStampTrans.StampTypeSpec))
                            {
                                _jmgStampTrans.CostBreak += slizeCostPrice;
                            }
                            if (costBuildBreak_ == JmgCostSlizeNoYesEnum::Slize)
                            {
                                jmgTransferEventsSlizes.slizeBreak = true;
                            }
                        }
                        break;
                    
                    case JmgPaySpecTypeEnum::FlexAdd :
                        if (costBuildFlexAdd_)
                        {
                            if (((costBuildFlexAdd_                             == JmgCostSlizeNoYesEnum::Yes)      ||
                                    (! transidCostCostSlize[transidCostCntFrom]))                                   &&
                                    (transidCostid[transidCostCntFrom]              == _jmgStampTrans.TransId)      &&
                                    (transidCostStampTypeSpec[transidCostCntFrom]   == _jmgStampTrans.StampTypeSpec))
                            {
                                _jmgStampTrans.CostFlexAdd += slizeCostPrice;
                            }
                            if (costBuildFlexAdd_ == JmgCostSlizeNoYesEnum::Slize)
                            {
                                jmgTransferEventsSlizes.slizeFlexAdd = true;
                            }
                        }
                        break;
                    
                    case JmgPaySpecTypeEnum::AddOn :
                        if (costBuildPayAdd_)
                        {
                            if (((costBuildPayAdd_                              == JmgCostSlizeNoYesEnum::Yes)      ||
                                    (! transidCostCostSlize[transidCostCntFrom]))                                   &&
                                    (transidCostid[transidCostCntFrom]              == _jmgStampTrans.TransId)      &&
                                    (transidCostStampTypeSpec[transidCostCntFrom]   == _jmgStampTrans.StampTypeSpec))
                            {
                                _jmgStampTrans.CostPayAdd += slizeCostPrice;
                            }
                            if (costBuildPayAdd_ == JmgCostSlizeNoYesEnum::Slize)
                            {
                                jmgTransferEventsSlizes.slizePayAdd = true;
                            }
                        }
                        break;
                    
                    case JmgPaySpecTypeEnum::AddOnManual :
                        if (costBuildPayAddManual_)
                        {
                            if (((costBuildPayAddManual_                        == JmgCostSlizeNoYesEnum::Yes)      ||
                                    (! transidCostCostSlize[transidCostCntFrom]))                                   &&
                                    (transidCostid[transidCostCntFrom]              == _jmgStampTrans.TransId)      &&
                                    (transidCostStampTypeSpec[transidCostCntFrom]   == _jmgStampTrans.StampTypeSpec))
                            {
                                _jmgStampTrans.CostPayAddManual += slizeCostPrice;
                            }
                            if (costBuildPayAddManual_ == JmgCostSlizeNoYesEnum::Slize)
                            {
                                jmgTransferEventsSlizes.slizePayAddManual = true;
                            }
                        }
                        break;
                    
                    case JmgPaySpecTypeEnum::FlexSub :
                        if (costBuildFlexSub_ == JmgCostSlizeNoEnum::Slize)
                        {
                            jmgTransferEventsSlizes.slizeFlexSub = true;
                        }
                        break;
                    
                    case JmgPaySpecTypeEnum::Absence :
                        if (costBuildAbsence_ == JmgCostSlizeNoEnum::Slize)
                        {
                            jmgTransferEventsSlizes.slizeAbsence = true;
                        }
                        break;
                }
            }

            if (((_jmgStampTrans.StampTypeSpec == JmgStampTypeSpecEnum::AbsLegal)               ||
                    (_jmgStampTrans.StampTypeSpec == JmgStampTypeSpecEnum::AbsIllegal)          ||
                    (_jmgStampTrans.StampTypeSpec == JmgStampTypeSpecEnum::AbsLegalFlex)        ||
                    (_jmgStampTrans.StampTypeSpec == JmgStampTypeSpecEnum::AbsIllegalFlex) )    &&
                    (transidCostid[transidCostCntFrom]              == _jmgStampTrans.TransId)  &&
                    (transidCostStampTypeSpec[transidCostCntFrom]   == _jmgStampTrans.StampTypeSpec))
            {
                switch (transidCostPayType[transidCostCntFrom])
                {
                    case JmgPaySpecTypeEnum::Absence :
                        _jmgStampTrans.CostAbsence += slizeCostPrice;
                        break;
                    case JmgPaySpecTypeEnum::FlexSub :
                        _jmgStampTrans.CostFlexSub += slizeCostPrice;
                        break;
                }
            }

            if ((_jmgStampTrans.StampTypeSpec                       == JmgStampTypeSpecEnum::BreakPayFlow)  &&
                    (transidCostid[transidCostCntFrom]              == _jmgStampTrans.TransId)              &&
                    (transidCostStampTypeSpec[transidCostCntFrom]   == _jmgStampTrans.StampTypeSpec))
            {
                if (transidCostPayType[transidCostCntFrom] == JmgPaySpecTypeEnum::Break)
                {
                    _jmgStampTrans.CostBreak += slizeCostPrice;
                }
            }
        }

        return jmgTransferEventsSlizes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTimePrDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the internal calculated variables.
    /// </summary>
    void clearTimePrDim()
    {
        dimCnt = 1;
        while (dimSeconds[dimCnt])
        {
            defaultDimension[dimCnt] = 0;
            dimSeconds[dimCnt]   = 0;
            dimCnt++;
        }
        dimCnt = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the registrations made by a worker on a specified day.
    /// </summary>
    /// <param name = "_jmgStampJournalTable">
    /// A <c>JmgStampJournalTable</c> record buffer.
    /// </param>
    /// <param name = "_jmgProfiles">
    /// A <c>JmgProfiles</c> object.
    /// </param>
    /// <param name = "_jmgStampTransMap">
    /// A <c>JmgStampTransMap</c> buffer.
    /// </param>
    /// <param name = "_specialDayId">
    /// A <c>JmgSpecialDayId</c> value.
    /// </param>    
    /// <param name = "_payReal">
    /// A real value.
    /// </param>
    protected void loadRegistration(JmgStampJournalTable _jmgStampJournalTable, JmgProfiles _jmgProfiles, JmgStampTransMap _jmgStampTransMap, JmgSpecialDayId _specialDayId, real _payReal)
    {
        JmgSeconds              absencePaySeconds;
        HRMAbsenceCodeId        absenceCode;
        HRMAbsenceCode          hrmAbsenceCode;
        RouteOprId              oprId;
        JmgIpcActivityId        absType;
        JmgPayCostType          jmgPayCostType;
        ProjId                  projId;
        ProjActivityId          projActivityId;

        boolean jmgBreakRegistrationsFlight = JmgBreakRegistrationsFlight::instance().isEnabled();

        JmgBreaks jmgBreaks = _jmgProfiles.getJmgBreaksObject();

        if (jmgBreakRegistrationsFlight && _jmgStampTransMap.JourRegType == JmgJourRegTypeEnum::BreakReg && jmgBreaks.isBreakRegInParallel(_jmgStampJournalTable, _jmgStampTransMap))
        {
            return;
        }

        JmgStampTypeSpec stampTypeSpecIn = _jmgStampTransMap.StampTypeSpec;

        if (jmgBreakRegistrationsFlight 
            && _jmgStampTransMap.JourRegType == JmgJourRegTypeEnum::BreakReg
            && !_jmgStampJournalTable.Transferred)
        {
            stampTypeSpecIn = JmgStampTypeSpecEnum::Work;
        }

        _jmgProfiles.countProfileTimeEvent(_jmgStampTransMap.ProfileDate,
                                           _jmgStampTransMap.CorrStartDate,
                                           _jmgStampTransMap.CorrStopDate,
                                           _jmgStampTransMap.CorrStartTime, 
                                           _jmgStampTransMap.CorrStopTime, 
                                           stampTypeSpecIn,
                                           _jmgStampTransMap.TransId,
                                           _jmgStampTransMap.JobPayType,
                                           true,
                                           _jmgStampTransMap.DefaultDimension);

        if (_jmgStampTransMap.JourRegType == JmgJourRegTypeEnum::Absence)
        {
            hrmAbsenceCode = HRMAbsenceCode::findByJobId(_jmgStampTransMap.JobIDAbs);
            if (hrmAbsenceCode.JmgAbsencePayCType)
            {
                Price payPrice = JmgPayEmployee::getPayCostTypePrice(hrmAbsenceCode.JmgAbsencePayCType,_jmgStampTransMap.Worker, _jmgStampJournalTable.ProfileDate);
                jmgPayCostType = hrmAbsenceCode.JmgAbsencePayCType;
                absType        = hrmAbsenceCode.HrmAbsenceCodeId;

                if (_jmgStampTransMap.AbsencePayQty)
                {
                    if (hrmAbsenceCode.JmgAbsenceMethodEnum == JmgAbsenceMethodEnum::Qty && any2int(_jmgStampJournalTable.ProfileSeconds * _jmgStampTransMap.AbsencePayQty) < _jmgStampTransMap.Seconds)
                    {
                        absencePaySeconds = any2int(_jmgStampJournalTable.ProfileSeconds * _jmgStampTransMap.AbsencePayQty);
                    }
                    else if (hrmAbsenceCode.JmgAbsenceMethodEnum == JmgAbsenceMethodEnum::Hours && _jmgStampTransMap.AbsencePayQty * 3600 < _jmgStampTransMap.Seconds)
                    {
                        absencePaySeconds = any2int(_jmgStampTransMap.AbsencePayQty * 3600);
                    }
                    else
                    {
                        absencePaySeconds = _jmgStampTransMap.Seconds;
                    }
                }
                else
                {
                    absencePaySeconds = _jmgStampTransMap.Seconds;
                }

                this.insertPayEventsArray(_jmgStampTransMap.Worker,_jmgStampTransMap.ProfileDate,
                                              JmgPaySpecTypeEnum::Absence,
                                              absencePaySeconds,
                                              jmgPayCostType,payPrice,
                                              absType,_jmgStampTransMap.ActOprID,0,'',_jmgStampTransMap.DefaultDimension);

                this.addTRiDCost(_jmgStampTransMap.TransId,JmgPaySpecTypeEnum::Absence,_jmgStampTransMap.StampTypeSpec,_payReal,_jmgStampTransMap.Seconds,NoYes::Yes);
            }
        }
        oprId       = '';
        if (_jmgStampTransMap.Module == JmgModuleEnum::PROD)
        {
            oprId   = _jmgStampTransMap.ActOprID;
        }
        absType = '';
        if (_jmgStampTransMap.JourRegType == JmgJourRegTypeEnum::IndActivity || 
           (jmgBreakRegistrationsFlight && _jmgStampTransMap.JourRegType == JmgJourRegTypeEnum::BreakReg))
        {
            absType = _jmgStampTransMap.ActOprID;
        }

        projId         = '';
        projActivityId = '';
        if (_jmgStampTransMap.Module == JmgModuleEnum::PROJ)
        {
            projId          = _jmgStampTransMap.JobRef;
            projActivityId  = _jmgStampTransMap.ActOprID;
        }

        JmgIpcActivityIdOnCall onCallActivity = _jmgStampTransMap.OnCallActivity;

        absenceCode = '';
        if (_jmgStampTransMap.JourRegType == JmgJourRegTypeEnum::Absence)
        {
            absenceCode = _jmgStampTransMap.ActOprID;
        }
        this.addTRiDTimeOpr(_jmgStampTransMap.TransId,_jmgStampTransMap.StampTypeSpec,_jmgStampTransMap.Seconds,oprId,absType,projId,projActivityId, onCallActivity, _specialDayId, absenceCode, _jmgStampTransMap.JobRef);
        this.addJobTimeidCost(_jmgStampTransMap.JobId,_jmgStampTransMap.Seconds);
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectJmgPayAgreementOverrideLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Collects the <c>JmgPayAgreementOverrideLine</c> records.
    /// </summary>
    /// <param name = "_jmgStampJournalTable">
    /// A <c>JmgStampJournalTable</c> record buffer.
    /// </param>
    /// <param name = "_jmgProfiles">
    /// A <c>JmgProfiles</c> object.
    /// </param>
    /// <returns>
    /// The list with the collected <c>JmgPayAgreementOverrideLine</c> records.
    /// </returns>
    protected List collectJmgPayAgreementOverrideLines(JmgStampJournalTable _jmgStampJournalTable, JmgProfiles _jmgProfiles)
    {
        JmgPayAgreementOverrideLine jmgPayAgreementOverrideLine;
        List                        collectedLines = new List(Types::Record);

        while select jmgPayAgreementOverrideLine
                where jmgPayAgreementOverrideLine.Worker        == _jmgStampJournalTable.Worker      &&
                      jmgPayAgreementOverrideLine.ProfileDate   == _jmgStampJournalTable.ProfileDate &&
                      ((  jmgPayAgreementOverrideLine.ProfileId == _jmgStampJournalTable.Profile) ||
                       (! jmgPayAgreementOverrideLine.ProfileId))
        {
            collectedLines.addEnd(jmgPayAgreementOverrideLine);
        }
        return collectedLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectJmgPayAgreementLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Collects the <c>JmgPayAgreementLine</c> records.
    /// </summary>
    /// <param name = "_jmgStampJournalTable">
    /// A <c>JmgStampJournalTable</c> record buffer.
    /// </param>
    /// <param name = "_dayId">
    /// A <c>JmgDayId</c> value.
    /// </param>
    /// <param name = "_jmgProfiles">
    /// A <c>JmgProfiles</c> object.
    /// </param>
    /// <returns>
    /// The list with the collected <c>JmgPayAgreementLine</c> records.
    /// </returns>
    protected List collectJmgPayAgreementLines(JmgStampJournalTable _jmgStampJournalTable, JmgDayId _dayId, JmgProfiles _jmgProfiles)
    {
        JmgPayAgreementLine     jmgPayAgreementLine;
        List                    collectedLines = new List(Types::Record);

        while select jmgPayAgreementLine
                where jmgPayAgreementLine.PayAgreement   == _jmgStampJournalTable.PayAgreement                          &&
                      jmgPayAgreementLine.DayId          == _dayId                                                       &&
                      ((  jmgPayAgreementLine.ProfileId  == _jmgStampJournalTable.Profile) ||
                       (! jmgPayAgreementLine.ProfileId) &&
                      ((!jmgPayAgreementLine.FromDate && !jmgPayAgreementLine.ToDate) || // No date interval
                       (!jmgPayAgreementLine.FromDate && jmgPayAgreementLine.ToDate >= _jmgStampJournalTable.ProfileDate) || // No lower limit
                       (jmgPayAgreementLine.FromDate <= _jmgStampJournalTable.ProfileDate && !jmgPayAgreementLine.ToDate) || // No upper limit
                       (jmgPayAgreementLine.FromDate <= _jmgStampJournalTable.ProfileDate && jmgPayAgreementLine.ToDate >= _jmgStampJournalTable.ProfileDate))) // Lower and upper limit
        {
            collectedLines.addEnd(jmgPayAgreementLine);
        }
        return collectedLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeUnTransferredJournalTransQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes query object for untransferred journal lines.
    /// </summary>
    /// <param name = "_jmgStampJournalTable">
    /// A <c>JmgStampJournalTable</c> record buffer.
    /// </param>
    /// <returns>
    /// A <c>Query</c> object.
    /// </returns>
    protected Query initializeUnTransferredJournalTransQuery(JmgStampJournalTable _jmgStampJournalTable)
    {
        Query journalTransQuery = new Query();
        QueryBuildDataSource journalTransDataSource = journalTransQuery.addDataSource(tableNum(JmgStampJournalTrans));
        
        journalTransDataSource.addRange(fieldNum(JmgStampJournalTrans, ProfileDate)).value(queryValue(_jmgStampJournalTable.ProfileDate));
        journalTransDataSource.addRange(fieldNum(JmgStampJournalTrans, Worker)).value(queryValue(_jmgStampJournalTable.Worker));
        if (!JmgBreakRegistrationsFlight::instance().isEnabled())
        {
            journalTransDataSource.addRange(fieldNum(JmgStampJournalTrans, JourRegType)).value(SysQuery::valueNot(enum2int(JmgJourRegTypeEnum::BreakReg)));
        }

        journalTransDataSource.addSortIndex(indexNum(JmgStampJournalTrans, EmplProfDateIdx));
        journalTransDataSource.indexIsHint(true);

        journalTransDataSource.addSortField(fieldNum(JmgStampJournalTrans, Worker));
        journalTransDataSource.addSortField(fieldNum(JmgStampJournalTrans, ProfileDate));
        journalTransDataSource.addSortField(fieldNum(JmgStampJournalTrans, StartDate));
        journalTransDataSource.addSortField(fieldNum(JmgStampJournalTrans, StartTime));
        journalTransDataSource.addSortField(fieldNum(JmgStampJournalTrans, StopDate));
        journalTransDataSource.addSortField(fieldNum(JmgStampJournalTrans, StopTime));
        journalTransDataSource.addSortField(fieldNum(JmgStampJournalTrans, JourRegType));

        return journalTransQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPayEventsArray</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the internal event array based on registrations made by a worker on a specified day.
    /// </summary>
    /// <param name="_jmgStampJournalTable">
    /// The <c>JmgStampJournalTable</c> record, which refers to the worker and profile date being transferred.
    /// </param>
    void createPayEventsArray(JmgStampJournalTable _jmgStampJournalTable)
    {
        JmgProfiles                 jmgProfiles;
        JmgStampJournalTrans        jmgStampJournalTrans;
        JmgBreaks                   jmgBreaks   = new JmgBreaks();
        JmgPayAgreementLine         jmgPayAgreementLine;
        JmgPayAgreementOverrideLine jmgPayAgreementOverrideLine;
        real                        payTmpReal;
        JmgPayAddTrans              jmgPayAddTrans;
        JmgPayAddTable              jmgPayAddTable;
        JmgDayId                    dayId;
        JmgStampTrans               jmgStampTrans;

        jmgProfiles                             = new JmgProfiles();
        _jmgStampJournalTable.PaySeconds         = 0;
        _jmgStampJournalTable.PayOverTimeSeconds = 0;
        _jmgStampJournalTable.PayAbsenceSeconds  = 0;
        _jmgStampJournalTable.PayFlexAddSeconds  = 0;
        _jmgStampJournalTable.PayFlexSubSeconds  = 0;

        jmgProfiles.loadEventCodes(_jmgStampJournalTable);
        jmgProfiles.getProfile(_jmgStampJournalTable.Profile,JmgProfiles::date2DayId(_jmgStampJournalTable.ProfileDate), _jmgStampJournalTable);

        jmgBreaks = jmgProfiles.getBreaks(_jmgStampJournalTable.Worker, _jmgStampJournalTable.ProfileDate);
        JmgSpecialDayId specialDayId = JmgProfileCalendar::find(JmgEmployee::find(_jmgStampJournalTable.Worker), _jmgStampJournalTable.ProfileDate).SpecialDayId;

        if (_jmgStampJournalTable.Transferred    == NoYes::No)
        {
            QueryRun journalTransQueryRun = new QueryRun(this.initializeUnTransferredJournalTransQuery(_jmgStampJournalTable));
            
            while (journalTransQueryRun.next())
            {
                JmgStampJournalTrans jmgStampJournalTransLocal = journalTransQueryRun.get(tableNum(JmgStampJournalTrans));
                this.loadRegistration(_jmgStampJournalTable, jmgProfiles, jmgStampJournalTransLocal, specialDayId, payTmpReal);
            }
        }
        else
        {
            while select jmgStampTrans
                order by StartDate,StartTime,StopDate,StopTime,JourRegType
                   where jmgStampTrans.ProfileDate   == _jmgStampJournalTable.ProfileDate &&
                         jmgStampTrans.Worker        == _jmgStampJournalTable.Worker &&
                        (JmgBreakRegistrationsFlight::instance().isEnabled() || jmgStampTrans.JourRegType != JmgJourRegTypeEnum::BreakReg)
            {
                this.loadRegistration(_jmgStampJournalTable, jmgProfiles, jmgStampTrans, specialDayId, payTmpReal);
            }
        }
        jmgProfiles.slizeProfileFlexMinus(_jmgStampJournalTable);
        jmgProfiles.checkPayDeduction(_jmgStampJournalTable);
        jmgProfiles.sumerizeCalc(_jmgStampJournalTable);

        this.paySenPeriod2YM(_jmgStampJournalTable.Worker, _jmgStampJournalTable.ProfileDate);

        if (JmgPayAgreementOverride::find(_jmgStampJournalTable.Worker,_jmgStampJournalTable.ProfileDate))
        {
            ListEnumerator jmgPayAgreementOverrideLinesEnumerator = this.collectJmgPayAgreementOverrideLines(_jmgStampJournalTable, jmgProfiles).getEnumerator();

            while (jmgPayAgreementOverrideLinesEnumerator.moveNext())
            {
                jmgPayAgreementOverrideLine = jmgPayAgreementOverrideLinesEnumerator.current();
                this.loadPayAgreementLine(_jmgStampJournalTable,jmgProfiles,jmgPayAgreementOverrideLine);
            }
        }
        else
        {
            if (JmgProfileCalendar::paySpecialDay(JmgEmployee::find(_jmgStampJournalTable.Worker), _jmgStampJournalTable.ProfileDate))
            {
                dayId = JmgDayIdEnum::Special;
            }
            else
            {
                dayId = JmgProfiles::date2DayId(_jmgStampJournalTable.ProfileDate);
            }

            ListEnumerator jmgPayAgreementLinesEnumerator = this.collectJmgPayAgreementLines(_jmgStampJournalTable, dayId, jmgProfiles).getEnumerator();

            while (jmgPayAgreementLinesEnumerator.moveNext())
            {
                this.loadPayAgreementLine(_jmgStampJournalTable,jmgProfiles, jmgPayAgreementLinesEnumerator.current());
            }
        }

        while select jmgPayAddTrans
            where jmgPayAddTrans.Worker == _jmgStampJournalTable.Worker &&
                  jmgPayAddTrans.Date   == _jmgStampJournalTable.ProfileDate
        {
            if (jmgPayAddTrans.PayAddId && jmgPayAddTrans.Qty)
            {
                select firstonly jmgPayAddTable
                    where jmgPayAddTable.PayAddId == jmgPayAddTrans.PayAddId;

                if (jmgPayAddTable)
                {
                    JmgIpcActivityId absType = '';
                    RouteOprId oprId = jmgPayAddTable.PayAddId;
                    Price payPrice = jmgPayAddTrans.Price ? jmgPayAddTrans.Price : JmgPayEmployee::getPayCostTypePrice(jmgPayAddTable.PayCostType,jmgPayAddTrans.Worker, _jmgStampJournalTable.ProfileDate);

                    this.insertPayEventsArray(jmgPayAddTrans.Worker,jmgPayAddTrans.Date,
                                              JmgPaySpecTypeEnum::AddOnManual,
                                              any2int(jmgPayAddTrans.Qty * 3600),
                                              jmgPayAddTable.PayCostType,payPrice,
                                              absType,oprId,0,'',jmgPayAddTable.DefaultDimension);
                    payTmpReal = (jmgPayAddTrans.Qty * payPrice);
                    this.addTRiDCost(jmgPayAddTrans.TransId,JmgPaySpecTypeEnum::AddOnManual,JmgStampTypeSpecEnum::Work,payTmpReal,0,(jmgPayAddTrans.TransId==''));
                }
            }
        }
        JmgFlexCorrection::createFlexCorrectionPayEvents(_jmgStampJournalTable.Worker, _jmgStampJournalTable.ProfileDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>curAbsAct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the absence code ID of the current event.
    /// </summary>
    /// <returns>
    ///    The absence code ID of the current event.
    /// </returns>
    /// <remarks>
    ///    Use the <c>getTRiDTimeOpr</c> method to make this method return the value that is associated to a
    ///    specific transaction ID.
    /// </remarks>
    JmgIpcActivityId curAbsAct()
    {
        return transidTimeAbsenceActOut;
    }

]]></Source>
			</Method>
			<Method>
				<Name>curJobRef</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the job reference of the current event.
    /// </summary>
    /// <returns>
    ///    The job reference of the current event.
    /// </returns>
    /// <remarks>
    ///    Use the <c>getTRiDTimeOpr</c> method to make this method return the value that is associated to a
    ///    specific transaction ID.
    /// </remarks>
    JmgJobRef curJobRef()
    {
        return transidTimeCurJobRef;
    }

]]></Source>
			</Method>
			<Method>
				<Name>curOnCallActivity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the on-call activity of the current event.
    /// </summary>
    /// <returns>
    ///    The on-call activity of the current event.
    /// </returns>
    /// <remarks>
    ///    Use the <c>getTRiDTimeOpr</c> method to make this method return the value that is associated to a
    ///    specific transaction ID.
    /// </remarks>
    public JmgIpcActivityIdOnCall curOnCallActivity()
    {
        return transIdTimeOnCallActivity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>curProjActivityId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the project activity ID of the current event.
    /// </summary>
    /// <returns>
    ///    The project activity ID of the current event.
    /// </returns>
    /// <remarks>
    ///    Use the <c>getTRiDTimeOpr</c> method to make this method return the value that is associated to a
    ///    specific transaction ID.
    /// </remarks>
    public ProjActivityId curProjActivityId()
    {
        return transidTimeProjActivity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>curProjId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the project ID of the current event.
    /// </summary>
    /// <returns>
    ///    The project ID of the current event.
    /// </returns>
    /// <remarks>
    ///    Use the <c>getTRiDTimeOpr</c> method to make this method return the value that is associated to a
    ///    specific transaction ID.
    /// </remarks>
    public ProjId curProjId()
    {
        return transidTimeProj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentAbsenceCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the absence code of the current event.
    /// </summary>
    /// <returns>
    ///    The absence code of the current event.
    /// </returns>
    /// <remarks>
    ///    Use the <c>getTRiDTimeOpr</c> method to make this method return the value that is associated to a
    ///    specific transaction ID.
    /// </remarks>
    public HRMAbsenceCodeGroupId currentAbsenceCode()
    {
        return transidTimeHRMAbsenceCodeOut;
    }

]]></Source>
			</Method>
			<Method>
				<Name>curSpecialDayId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the special day ID of the current event.
    /// </summary>
    /// <returns>
    ///    The special day ID of the current event.
    /// </returns>
    /// <remarks>
    ///    Use the <c>getTRiDTimeOpr</c> method to make this method return the value that is associated to a
    ///    specific transaction ID.
    /// </remarks>
    public JmgSpecialDayId curSpecialDayId()
    {
        return transidTimeSpecialDay;
    }

]]></Source>
			</Method>
			<Method>
				<Name>curTrOpr</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the operation ID of the current event.
    /// </summary>
    /// <returns>
    ///    The operation ID of the current event.
    /// </returns>
    /// <remarks>
    ///    Use the <c>getTRiDTimeOpr</c> method to make this method return the value that is associated to a
    ///    specific transaction ID.
    /// </remarks>
    RouteOprId curTrOpr()
    {
        return transidTimeOprOut;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInsertedEventsCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number of pay events inserted by the last call of <c>insertEvents</c> method.
    /// </summary>
    /// <returns>
    /// Numbers of inserted pay events.
    /// </returns>
    public int getInsertedEventsCount()
    {
        return insertedEventsCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJobTimeJobidTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the job time for the specified job ID.
    /// </summary>
    /// <param name="tJidIn">
    ///    The job ID for which to calculate the job time.
    /// </param>
    void getJobTimeJobidTime(JmgJobId  tJidIn)
    {
        if (tJidIn)
        {
            tjTimeOut = 0;
            for (tjCnt = 1; tjJobid[tjCnt];tjCnt++)
            {
                if (tjJobid[tjCnt] == tJidIn)
                   tjTimeOut += tjNetTime[tjCnt];
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTRiDTimeOpr</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the internal event pointer to point to the specified transaction ID.
    /// </summary>
    /// <param name="transidTimeidIn">
    ///    The transaction ID to which to move the pointer.
    /// </param>
    /// <remarks>
    ///    After calling this method, the <c>cur*</c> method will return the values that are associated to the
    ///    specified transaction ID.
    /// </remarks>
    void getTRiDTimeOpr(JmgTransId  transidTimeidIn)
    {
        if (transidTimeidIn)
        {
            transidTimeCnt              = 1;
            transidTimeTimeOut          = 0;
            transidTimeOprOut           = '';
            transidTimeAbsenceActOut    = '';
            transidTimeHRMAbsenceCodeOut= '';
            transidTimeProj             = '';
            transidTimeProjActivity     = '';
            transIdTimeOnCallActivity   = '';
            transidTimeSpecialDay       = '';
            transidTimeCurJobRef        = '';

            while (transidTimeid[transidTimeCnt])
            {
                if (transidTimeid[transidTimeCnt] == transidTimeidIn)
                {
                    transidTimeTimeOut          = transidTimeNetTime[transidTimeCnt];
                    transidTimeOprOut           = transidTimeOpr[transidTimeCnt];
                    transidTimeAbsenceActOut    = transidTimeAbsenceAct[transidTimeCnt];
                    transidTimeHRMAbsenceCodeOut= transidTimeHRMAbsenceCode[transidTimeCnt];
                    transidTimeProj             = transidTimeProjId[transidTimeCnt];
                    transidTimeProjActivity     = transidTimeProjActivityId[transidTimeCnt];
                    transIdTimeOnCallActivity   = transIdTimeOnCallAct[transidTimeCnt];
                    transidTimeSpecialDay       = transidTimeSpecialDayId[transidTimeCnt];
                    transidTimeCurJobRef        = transidTimeJobRef[transidTimeCnt];
                    break;
                }
                transidTimeCnt++;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeJmgPayEvents</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>JmgPayEvents</c> record buffer.
    /// </summary>
    /// <param name = "_jmgPayEvents">
    /// A <c>JmgPayEvents</c> record buffer.
    /// </param>
    /// <param name = "_wrk_Cnt">
    /// Pay event counter.
    /// </param>
    protected void initializeJmgPayEvents(JmgPayEvents _jmgPayEvents, int _wrk_Cnt)
    {
        _jmgPayEvents.Worker             = timePayEventWorker        [_wrk_Cnt];
        _jmgPayEvents.ProfileDate        = timePayEventProfileDate   [_wrk_Cnt];
        _jmgPayEvents.PaySpecType        = timePayEventPaySpecType   [_wrk_Cnt];
        _jmgPayEvents.PaySeconds         = timePayEventPaySeconds    [_wrk_Cnt];
        _jmgPayEvents.PayCostType        = timePayEventPayCType      [_wrk_Cnt];
        _jmgPayEvents.Price              = timePayEventPayRate       [_wrk_Cnt];
        _jmgPayEvents.AbsenceActivityId  = timePayEventAbsType       [_wrk_Cnt];
        _jmgPayEvents.OprId              = timePayEventOprId         [_wrk_Cnt];
        _jmgPayEvents.PayCountSeconds    = timePayEventPayCntUnitSec [_wrk_Cnt];
        _jmgPayEvents.PayCountId         = timePayEventPayCntUnitId  [_wrk_Cnt];
        _jmgPayEvents.DefaultDimension   = _jmgPayEvents.copyDimension(timePayEventDefaultDimension  [_wrk_Cnt]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertEvents</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts the calculated pay events into the <c>JmgPayEvents</c> table.
    /// </summary>
    /// <param name="_jmgPayCountId">
    ///    The pay count ID to insert pay events for; optional.
    /// </param>
    /// <remarks>
    ///    If the <c>_jmgPayCountId</c> parameter is specified, only pay events that are related to the
    ///    specified pay count ID are inserted.
    /// </remarks>
    void insertEvents(JmgPayCountId _jmgPayCountId = '')
    {
        JmgPayEvents jmgPayEvents;
        Integer      wrk_Cnt;

        insertedEventsCount = 0;

        ttsbegin;

        wrk_Cnt = 1;
        while ((timePayEventWorker[wrk_Cnt]) && (wrk_Cnt<=timePayEventCnt))
        {
            if (!timePayEventCancelPay[wrk_Cnt] &&
                (!_jmgPayCountId || _jmgPayCountId == timePayEventPayCntUnitId[wrk_Cnt]))
            {
                this.initializeJmgPayEvents(jmgPayEvents, wrk_Cnt);

                jmgPayEvents.insert();
                insertedEventsCount++;
            }
            wrk_Cnt++;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPayEventsArray</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a pay event to the internal event array.
    /// </summary>
    /// <param name="_worker">
    ///    The ID of the worker on the pay event.
    /// </param>
    /// <param name="_profileDate">
    ///    The profile date on the event.
    /// </param>
    /// <param name="_paySpecType">
    ///    The pay specification type of the pay event.
    /// </param>
    /// <param name="_paySeconds">
    ///    The pay seconds of the pay event.
    /// </param>
    /// <param name="_payCType">
    ///    The pay cost type of the pay event.
    /// </param>
    /// <param name="_payRate">
    ///    The pay rate of the pay event.
    /// </param>
    /// <param name="_absType">
    ///    The absence code of the pay event.
    /// </param>
    /// <param name="_oprId">
    ///    The operation ID of the pay event.
    /// </param>
    /// <param name="_payCntUnitSec">
    ///    The pay count unit seconds of the pay event.
    /// </param>
    /// <param name="_payCntUnitId">
    ///    The pay count unit ID of the pay event.
    /// </param>
    /// <param name="_defaultDimension">
    ///    The dimension values of the pay event.
    /// </param>
    /// <param name="_cancelPay">
    ///    The <c>NoYes::Yes</c> enumeration value if the added pay event is not included in the final pay
    ///    calculation; otherwise, the <c>NoYes::No</c> value.
    /// </param>
    void insertPayEventsArray(JmgWorkerRecId      _worker,
                              StartDate           _profileDate,
                              JmgPaySpecType      _paySpecType,
                              JmgSeconds          _paySeconds,
                              JmgPayCostType      _payCType,
                              Price               _payRate,
                              JmgIpcActivityId    _absType,
                              RouteOprId          _oprId            = '',
                              JmgSeconds          _payCntUnitSec    = 0,
                              JmgPayCountId       _payCntUnitId     = '',
                              DimensionDefault    _defaultDimension = 0,
                              JmgCancelPay        _cancelPay        = NoYes::No)
    {
        timePayEventCnt++;
        timePayEventWorker              [timePayEventCnt] = _worker;
        timePayEventProfileDate         [timePayEventCnt] = _profileDate;
        timePayEventPaySpecType         [timePayEventCnt] = _paySpecType;
        timePayEventPaySeconds          [timePayEventCnt] = _paySeconds;
        timePayEventPayCType            [timePayEventCnt] = _payCType;
        timePayEventPayRate             [timePayEventCnt] = _payRate;
        timePayEventAbsType             [timePayEventCnt] = _absType;
        timePayEventOprId               [timePayEventCnt] = _oprId;
        timePayEventPayCntUnitSec       [timePayEventCnt] = _payCntUnitSec;
        timePayEventPayCntUnitId        [timePayEventCnt] = _payCntUnitId;
        timePayEventDefaultDimension    [timePayEventCnt] = _defaultDimension;
        timePayEventCancelPay           [timePayEventCnt] = _cancelPay;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayCostTypePrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the hourly cost for the specified pay cost type and worker, at the specified date.
    /// </summary>
    /// <param name="_jmgStampJournalTable">
    /// A <c>JmgStampJournalTable</c> record buffer.
    /// </param>
    /// <param name="_jmgPayAgreementLineMap">
    /// A <c>JmgPayAgreementLineMap</c> object.
    /// </param>
    /// <returns>
    /// The hourly cost for the specified pay cost type, and worker, at the specified date.
    /// </returns>
    protected Price getPayCostTypePrice(JmgStampJournalTable _jmgStampJournalTable, JmgPayAgreementLineMap _jmgPayAgreementLineMap)
    {
        return JmgPayEmployee::getPayCostTypePrice(_jmgPayAgreementLineMap.PayCostType, _jmgStampJournalTable.Worker, _jmgStampJournalTable.ProfileDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadPayAgreementLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the pay that was generated by a specified pay agreement line, and then adds the result
    ///    to the internal event array.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record, which refers to the worker and profile date that is being
    ///    transferred.
    /// </param>
    /// <param name="jmgProfiles">
    ///    A reference to the <c>JmgProfiles</c> object, which is used to calculate the pay.
    /// </param>
    /// <param name="jmgPayAgreementLineMap">
    ///    The pay agreement line for which to calculate pay.
    /// </param>
    void loadPayAgreementLine(JmgStampJournalTable jmgStampJournalTable,JmgProfiles jmgProfiles,JmgPayAgreementLineMap jmgPayAgreementLineMap)
    {
        JmgPayCostType          jmgPayCostType;
        Price                   payPrice;
        real                    payTmpReal;
        JmgSeconds              payEventSec;
        JmgSeconds              cntUnitQtyIn;
        JmgSeconds              cntUnitQtyOut;
        JmgPaySpecType          jmgPaySpecType;

        if ((jmgPayAgreementLineMap.SeniorityInDays     == DayMonth::Month                      &&
             senMth                                     <  jmgPayAgreementLineMap.SeniorityMin) ||
            (jmgPayAgreementLineMap.SeniorityInDays     == DayMonth::Day                        &&
             senDays                                    <  jmgPayAgreementLineMap.SeniorityMin) ||
            (jmgPayAgreementLineMap.MaxSeniorityInDays  == DayMonth::Month                      &&
             jmgPayAgreementLineMap.SeniorityMax                                                &&
             senMth                                     >  jmgPayAgreementLineMap.SeniorityMax) ||
            (jmgPayAgreementLineMap.MaxSeniorityInDays  == DayMonth::Day                        &&
             jmgPayAgreementLineMap.SeniorityMax                                                &&
             senDays                                    >  jmgPayAgreementLineMap.SeniorityMax))
        {
            return;
        }

        transidCostCntFrom      = transidCostCnt;
        payEventSec             = jmgProfiles.sumPayEventsSec(this,jmgPayAgreementLineMap,jmgStampJournalTable);

        if (jmgPayAgreementLineMap.EventCode)
        {
            if (jmgPayAgreementLineMap.SecondaryPayCostType)
            {
                if (jmgProfiles.checkEventCodesIsSet(jmgPayAgreementLineMap.EventCode))
                {
                    jmgPayAgreementLineMap.PayCostType  = jmgPayAgreementLineMap.SecondaryPayCostType;
                    jmgPayAgreementLineMap.Factor       = jmgPayAgreementLineMap.SecondaryFactor;
                }
            }
            else
            {
                if (!jmgProfiles.checkEventCodesIsSet(jmgPayAgreementLineMap.EventCode))
                {
                    payEventSec = 0;
                }
            }
        }

        cntUnitQtyIn    = payEventSec;

        jmgPaySpecType  = jmgPayAgreementLineMap.PaySpecType;

        [cntUnitQtyOut,jmgPaySpecType] = JmgPayEvents::payCountQty(jmgStampJournalTable,jmgPayAgreementLineMap,cntUnitQtyIn);

        if (jmgPayAgreementLineMap.RoundBeforeFactor == NoYes::Yes)
        {
            cntUnitQtyOut    = this.round(jmgPayAgreementLineMap, cntUnitQtyOut);
        }

        cntUnitQtyOut    = jmgPayAgreementLineMap.Factor ? any2int(cntUnitQtyOut * jmgPayAgreementLineMap.Factor) : cntUnitQtyOut;

        if (jmgPayAgreementLineMap.RoundBeforeFactor == NoYes::No)
        {
            cntUnitQtyOut   = this.round(jmgPayAgreementLineMap, cntUnitQtyOut);
        }

        if (! payEventSec)
            return;

        if ((cntUnitQtyOut) && (jmgPayAgreementLineMap.UseConstantPay))
            cntUnitQtyOut       = any2int(JmgPayAgreementLineMap::getFixedQty(jmgPayAgreementLineMap, jmgProfiles));

        if (cntUnitQtyOut || (cntUnitQtyIn && jmgPayAgreementLineMap.PayCountId))
        {
            payPrice        = this.getPayCostTypePrice(jmgStampJournalTable, jmgPayAgreementLineMap);
            jmgPayCostType  = jmgPayAgreementLineMap.PayCostType;
            payTmpReal      = ((cntUnitQtyOut / 3600) * payPrice);
            if (transidCostCnt > 0)
            {
                while (transidCostCntFrom < transidCostCnt)
                {
                    transidCostCntFrom++;
                    transidCostNetCost[transidCostCntFrom] = (payTmpReal * (transidCostNetTime[transidCostCntFrom] / payEventSec));
                    transidCostPayType[transidCostCntFrom] = jmgPaySpecType;
                }
            }

            dimCnt = 1;
            while (dimSeconds[dimCnt])
            {
                this.insertPayEventsArray(jmgStampJournalTable.Worker,jmgStampJournalTable.ProfileDate,
                                      jmgPaySpecType,
                                      any2int(any2real(cntUnitQtyOut) * any2real(dimSeconds[dimCnt]) / any2real(payEventSec)),
                                      jmgPayCostType,
                                      payPrice,jmgPayAgreementLineMap.hrmAbsenceCodeId,jmgPayAgreementLineMap.RouteOprId,
                                      any2int(any2real(cntUnitQtyIn) * any2real(dimSeconds[dimCnt]) / any2real(payEventSec)),
                                      jmgPayAgreementLineMap.PayCountId,defaultDimension[dimCnt],
                                      jmgPayAgreementLineMap.CancelPay);
                dimCnt++;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
        timePayEventCnt = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextEvent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a <c>JmgPayEvents</c> record with values for the next pay event.
    /// </summary>
    /// <param name="jmgPayEvents">
    ///    The <c>JmgPayEvents</c> record to initialize.
    /// </param>
    /// <returns>
    ///    true if the <c>JmgPayEvents</c> record was initialized; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The <c>nextEvent</c> method is used to iterate calculated pay events.When false is returned, no
    ///    more pay events were calculated.
    /// </remarks>
    boolean nextEvent(JmgPayEvents jmgPayEvents)
    {
        currentEvent++;
        jmgPayEvents.clear();

        if (currentEvent > timePayEventCnt)
            return false;

        jmgPayEvents.Worker             = timePayEventWorker        [currentEvent];
        jmgPayEvents.ProfileDate        = timePayEventProfileDate   [currentEvent];
        jmgPayEvents.PaySpecType        = timePayEventPaySpecType   [currentEvent];
        jmgPayEvents.PaySeconds         = timePayEventPaySeconds    [currentEvent];
        jmgPayEvents.PayCostType        = timePayEventPayCType      [currentEvent];
        jmgPayEvents.Price              = timePayEventPayRate       [currentEvent];
        jmgPayEvents.AbsenceActivityId  = timePayEventAbsType       [currentEvent];
        jmgPayEvents.OprId              = timePayEventOprId         [currentEvent];
        jmgPayEvents.PayCountSeconds    = timePayEventPayCntUnitSec [currentEvent];
        jmgPayEvents.PayCountId         = timePayEventPayCntUnitId  [currentEvent];

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paySenPeriod2YM</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the seniority of the specified worker at the specified date.
    /// </summary>
    /// <param name="_worker">
    ///    The ID of the worker for which to calculate seniority.
    /// </param>
    /// <param name="_profileDate">
    ///    The profile date for which to calculate seniority.
    /// </param>
    /// <remarks>
    ///    The calculated seniority is saved to an internal variable.
    /// </remarks>
    protected void paySenPeriod2YM(JmgWorkerRecId _worker, JmgDate _profileDate)
    {
        JmgEmployee                 jmgEmployee;

        senToDate = dateNull();
        senMth    = 0;

        select firstonly jmgEmployee
            where jmgEmployee.Worker == _worker;

        if (jmgEmployee)
        {
            if (jmgEmployee.SeniorityDate)
            {
                senToDate = _profileDate;
                if (senToDate > jmgEmployee.SeniorityDate)
                {
                    senDays=  senToDate - jmgEmployee.SeniorityDate ;
                    senMth =  ((year(senToDate)-year(jmgEmployee.SeniorityDate))*12)+ mthofyr(senToDate)-mthofyr(jmgEmployee.SeniorityDate);
                    if (dayofmth(jmgEmployee.SeniorityDate) > dayofmth(senToDate))
                    {
                        senMth--;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>round</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds the specified value according to the settings on the specified pay agreement line.
    /// </summary>
    /// <param name="_jmgPayAgreementLineMap">
    /// The pay agreement line, which contains the rounding settings.
    /// </param>
    /// <param name="_value">
    /// The value to round.
    /// </param>
    /// <returns>
    /// The rounded value.
    /// </returns>
    private JmgSeconds round(JmgPayAgreementLineMap _jmgPayAgreementLineMap, JmgSeconds _value)
    {
        JmgSeconds ret;
        ret = _value;
        if (_jmgPayAgreementLineMap.Round)
        {
            switch (_jmgPayAgreementLineMap.RoundType)
            {
                case JmgRoundTypeEnum::RoundUp :
                    ret = any2int(round(_value + (_jmgPayAgreementLineMap.Round/2.00001), _jmgPayAgreementLineMap.Round));
                    break;
                case JmgRoundTypeEnum::RoundDown :
                    ret = any2int(round(_value - (_jmgPayAgreementLineMap.Round/2.00001), _jmgPayAgreementLineMap.Round));
                    break;
                case JmgRoundTypeEnum::Minimum :
                    if (_value < _jmgPayAgreementLineMap.Round)
                    {
                        ret = any2int(round(_value + (_jmgPayAgreementLineMap.Round/2.00001), _jmgPayAgreementLineMap.Round));
                    }
                    break;
                case JmgRoundTypeEnum::Normal :
                    ret = any2int(round(_value, _jmgPayAgreementLineMap.Round));
                    break;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>