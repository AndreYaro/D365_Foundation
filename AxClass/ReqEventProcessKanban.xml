<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReqEventProcessKanban</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>ReqEventProcessKanban</c> class processes kanban requirement events.
/// </summary>
/// <remarks>
///    For example, requirement events are demands from a sales order line and could be processed by
///    creating a kanban supply for them.
/// </remarks>
public abstract class ReqEventProcessKanban extends ReqEventProcess
{
    KanbanRule                      kanbanRule;
    KanbanRuleVariable              kanbanRuleVariable;
    KanbanRuleEvent                 kanbanRuleEvent;
    KanbanFlow                      kanbanFlow;
    InventTable                     inventTable;
    InventDimGroupSetup             inventDimGroupSetup;
    KanbanEventQuantityMap          kanbanEventQuantityMap;
    ItemId                          itemId;
    InventDimId                     inventDimId;
    TransDateTime                   dueDateTime;
    InventQty                       inventQtyKanbanRuleLookup;
    InventQty                       markingAdjustQty;
    InventQty                       reserveAvailableOnHandQty;
    boolean                         interactive;
    boolean                         acceptReceiveSemiFinishedKanbanRule;
    boolean                         acceptReceiveFinishedKanbanRule;
    boolean                         mustBeAutoReserved;
    boolean                         kanbanRuleFound;
    boolean                         initInventQtyKanbanRuleLookup;
    boolean                         mustDeleteEvent;
    boolean                         skipRuleMayExistCheck;
    PlanActivityRefRecId            limitToLastPlanActivityRefRecId;
    PlanActivityRefRecId            limitToPlanActivityDownStreamRecId;
    PlanReferenceRefRecId           limitToPlanReferenceRefRecId;
    KanbanRuleRefRecId              limitToKanbanRuleRefRecId;
    KanbanRuleRefRecId              excludeKanbanRuleRefRecId;
    KanbanSourceRequirementParm     kanbanSourceRequirementParm;
    ItemId                          productFamilyItemId;
    InventDimId                     productFamilyInventDimId;

    // results
    Map                             mapInsertedKanban;  //kanbanRule.RecId -> set Kanban.RecId
    Map                             mapUpdatedKanban;   //kanbanRule.RecId -> set Kanban.RecId
    Map                             mapDeletedKanban;   //kanbanRule.RecId -> set Kanban.RecId
    boolean                         canDeletePeggingEvent;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addResultMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds kanban record IDs to the specified map.
    /// </summary>
    /// <param name="_map">
    ///    A <c>Map</c> object to which to add data.
    /// </param>
    /// <param name="_kanbanRuleRefRecId">
    ///    The map key.
    /// </param>
    /// <param name="_kanbanRefRecId">
    ///    The data to add to the map.
    /// </param>
    /// <remarks>
    ///    The map must be a insert result kanban, update result kanban, or a delete result kanban.
    /// </remarks>
    protected void addResultMap(
        Map                _map,
        KanbanRuleRefRecId _kanbanRuleRefRecId,
        KanbanRefRecId     _kanbanRefRecId)
    {
        Set set;

        if (_map)
        {
            if (_map.exists(_kanbanRuleRefRecId))
            {
                set = _map.lookup(_kanbanRuleRefRecId);
            }
            else
            {
                set = new Set(Types::Int64);
            }

            set.add(_kanbanRefRecId);

            _map.insert(_kanbanRuleRefRecId,set);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustMarkingAndReservations</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes marking from event kanban and the related requirement transactions and tries to
    ///    physically reserve the unmarked quantity.
    /// </summary>
    /// <remarks>
    ///    When unreserving quantities, the reservation engine priorities are to keep marked transactions unchanged where possible;
    ///    instead it reduces reserved ordered and reserved physical transactions.
    ///    In the scenario where the kanban rule is set up to allow reduction of quantities supplied by event kanbans through physical
    ///    reservations 'outside' of event kanban supply, this method will unmark the calculated <c>markingAdjustQty</c> and then try
    ///    to physically re-reserve the quantity 'outside'.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void adjustMarkingAndReservations()
    {
        Kanban                          kanban;
        KanbanJob                       kanbanJob;
        InventTransOriginId             receiptInventTransOriginId;
        InventTransIdSum_MarkingRef     inventTransIdSum_MarkingRef;
        SourceDocumentLineRefRecId      receiptSourceDocumentLine;
        MapEnumerator                   me;
        Map                             map;
        InventQty                       peggedQty;
        InventQty                       maxPeggedQty;
        InventQty                       qtyNow;
        InventQty                       qtyRemain = markingAdjustQty;

        if (   markingAdjustQty > 0
            && this.inventTransOriginId())
        {
            map = kanbanEventQuantityMap.mapKanbanQuantities(true);

            if (   map
                && map.elements())
            {
                me = map.getEnumerator();

                while (   me.moveNext()
                        && qtyRemain > 0)
                {
                    kanban    = Kanban::find(me.currentKey());
                    peggedQty = me.currentValue();

                    if (kanban)
                    {
                        kanbanJob                  = kanban.lastKanbanJob();
                        receiptInventTransOriginId = kanbanJob.receiptInventTransOriginId();

                        if (   kanbanJob
                            && receiptInventTransOriginId)
                        {
                            receiptSourceDocumentLine   = kanbanJob.receiptSourceDocumentLine();
                            inventTransIdSum_MarkingRef = InventTransIdSum_MarkingRef::newMarkingRef(this.inventTransOriginId(),receiptInventTransOriginId);
                            qtyNow                      = max(-peggedQty,max(-qtyRemain,inventTransIdSum_MarkingRef.reserveOrdered()));
                            maxPeggedQty                = kanbanJob.QuantityReceived ? kanbanJob.QuantityReceived : kanbanJob.QuantityOrdered;

                            if (qtyNow < 0)
                            {
                                // removes marking and ordered reservation
                                qtyNow = this.markInventoryTransactions(kanban,kanbanJob,qtyNow,receiptInventTransOriginId,true);

                                // update pegging
                                this.writePegging(
                                                receiptSourceDocumentLine,
                                                maxPeggedQty,
                                                this.unitOfMeasureRecId(),
                                                peggedQty+qtyNow,
                                                this.unitOfMeasureRecId(),
                                                this.mustMarkInventoryTransactions(),
                                                this.peggingType());
                            }

                            qtyRemain += qtyNow;
                        }
                    }
                }
            }

            // try to reserve the adjusted quantity, physically where possible
            InventUpd_Reservation::newMovement(this.inventMovement(),-markingAdjustQty+qtyRemain,true).updateNow();
        }

        // reset
        markingAdjustQty = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowReserveAvailableOnHand</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Defines if this class should try to physically reserve on hand quantity on behalf of the event movement.
    /// </summary>
    /// <returns>
    ///    true if the reservation is allowed; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Most events are expected to reserve available on hand before event handling is executed, based on some
    ///    setting, for example the sales line 'reservation' setting.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean allowReserveAvailableOnHand()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bomId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Defines the BOM ID to use.
    /// </summary>
    /// <returns>
    ///    Always returns an empty string.
    /// </returns>
    /// <remarks>
    ///    No specific BOM ID is specified which means that the applicable BOM will be determined when kanbans are created.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected BOMId bomId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>buffer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the table buffer on which the class operates.
    /// </summary>
    /// <returns>
    ///    A <c>Common</c> table buffer.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected abstract Common buffer()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPeggingMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds a map of pegged kanbans and quantities and synchronizes marking.
    /// </summary>
    /// <param name="_mapKanbanQuantities">
    ///    The original map of pegged kanbans and quantities.
    /// </param>
    /// <returns>
    ///    A map of pegged kanbans and quantities.
    /// </returns>
    /// <remarks>
    ///    The map key is the record ID of the pegged kanban, the value is an instance of the <c>ReqEventKanbanData</c> class.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected Map buildPeggingMap(Map _mapKanbanQuantities)
    {
        InventTransOrigin           inventTransOrigin;
        InventTrans                 inventTrans;
        KanbanJob                   kanbanJob;
        Kanban                      kanban;
        MapEnumerator               me;
        InventTransOriginId         issueInventTransOriginId;
        InventQty                   peggedQty;
        ReqEventKanbanData          reqEventKanbanData;
        Set                         setKanbanRecId;
        SetEnumerator               se;
        Map                         mapPegging = new Map(Types::Int64,Types::Class);

        // synchronize pegging to marked quantities
        if (this.mustMarkInventoryTransactions())
        {
            setKanbanRecId           = _mapKanbanQuantities.keySet();
            issueInventTransOriginId = this.inventTransOriginId();

            // find all event kanbans currently marked to the event
            while select sum(Qty), MarkingRefInventTransOrigin from inventTrans
                group by MarkingRefInventTransOrigin
                where inventTrans.InventTransOrigin == issueInventTransOriginId
                    exists join ReferenceCategory from inventTransOrigin
                        where inventTransOrigin.RecId == inventTrans.MarkingRefInventTransOrigin
                           && (inventTransOrigin.ReferenceCategory == InventTransType::KanbanJobProcess
                           ||  inventTransOrigin.ReferenceCategory == InventTransType::KanbanJobTransferReceipt
                           ||  inventTransOrigin.ReferenceCategory == InventTransType::KanbanJobWIP)
            {
                kanbanJob         = null;
                inventTransOrigin = InventTransOrigin::find(inventTrans.MarkingRefInventTransOrigin);

                switch (inventTransOrigin.ReferenceCategory)
                {
                    case InventTransType::KanbanJobProcess:
                        kanbanJob = InventTransOriginKanbanJobProcess::kanbanJob(inventTransOrigin.RecId);
                        break;
                    case InventTransType::KanbanJobTransferReceipt:
                        kanbanJob = InventTransOriginKanbanJobTrsReceipt::kanbanJob(inventTransOrigin.RecId);
                        break;
                    case InventTransType::KanbanJobWIP:
                        kanbanJob = InventTransOriginKanbanJobWIP::kanbanJob(inventTransOrigin.RecId);
                        break;
                }

                if (   kanbanJob
                    && _mapKanbanQuantities.exists(kanbanJob.Kanban))
                {
                    kanban             = kanbanJob.kanban();
                    peggedQty          = _mapKanbanQuantities.lookup(kanban.RecId);
                    reqEventKanbanData = ReqEventKanbanData::newStandard(kanban,kanbanJob,-inventTrans.Qty,peggedQty);
                    mapPegging.insert(kanban.RecId,reqEventKanbanData);
                    setKanbanRecId.remove(kanban.RecId);
                }
            }

            // all remaining kanbans in the set are currently not marked
            if (setKanbanRecId.elements())
            {
                se = setKanbanRecId.getEnumerator();
                while (se.moveNext())
                {
                    kanban    = Kanban::find(se.current());
                    kanbanJob = kanban.lastKanbanJob();

                    if (kanbanJob)
                    {
                        peggedQty          = _mapKanbanQuantities.lookup(kanban.RecId);
                        reqEventKanbanData = ReqEventKanbanData::newStandard(kanban,kanbanJob,0,peggedQty);
                        mapPegging.insert(kanban.RecId,reqEventKanbanData);
                    }
                }
            }

            // synchronize the pegging to the marking
            // all elements of mapPegging are also in _mapKanbanQuantities
            me = mapPegging.getEnumerator();
            while (me.moveNext())
            {
                reqEventKanbanData = me.currentValue();
                kanban             = reqEventKanbanData.parmKanban();
                kanbanJob          = reqEventKanbanData.parmKanbanJob();
                peggedQty          = _mapKanbanQuantities.lookup(kanban.RecId);

                if (reqEventKanbanData.parmPeggedQty() != peggedQty)
                {
                    this.writePegging(
                            kanbanJob.receiptSourceDocumentLine(),
                            reqEventKanbanData.jobQuantity(),
                            this.unitOfMeasureRecId(),
                            reqEventKanbanData.parmPeggedQty(),
                            this.unitOfMeasureRecId(),
                            true,
                            this.peggingType());
                }
            }
        }
        else
        {
            me = _mapKanbanQuantities.getEnumerator();

            while (me.moveNext())
            {
                kanban    = Kanban::find(me.current());
                kanbanJob = kanban.lastKanbanJob();
                peggedQty = _mapKanbanQuantities.lookup(kanban.RecId);

                reqEventKanbanData = ReqEventKanbanData::newStandard(kanban,kanbanJob,peggedQty,peggedQty);

                mapPegging.insert(kanban.RecId,reqEventKanbanData);
            }
        }

        return mapPegging;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateEventQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a <c>List</c> object that splits the total required quantity into kanban-sized chunks.
    /// </summary>
    /// <param name="_inventQty">
    ///    The total required quantity; optional.
    /// </param>
    /// <returns>
    ///    A <c>List</c> of quantities.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected List calculateEventQuantities(InventQty _inventQty = inventQty)
    {
        return ReqSplitQuantities::newMinimumMaximum(_inventQty,
                                                     kanbanRuleVariable.MinimumProductQuantity,
                                                     kanbanRuleVariable.MaximumProductQuantity).parmQuantityDistribution();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelKanbanIfRequiredAndAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if cancelling the kanban is necessary and performs it if needed.
    /// </summary>
    /// <param name="_reqEventKanbanData">
    ///    A <c>ReqEventKanbanData</c> object that holds information about the kanban to be cancelled.
    /// </param>
    /// <param name="_kanban">
    ///    The <c>Kanban</c> to be cancelled.
    /// </param>
    /// <param name="_kanbanJob">
    ///    The <c>KanbanJob</c> to be checked.
    /// </param>
    /// <returns>
    ///    A container with the cancellation result and an autoplan flag.
    /// </returns>
    /// <remarks>
    ///    Automatic cancellation only happens in case the associated kanban rule supports auto-planning.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected container cancelKanbanIfRequiredAndAllowed(
        ReqEventKanbanData _reqEventKanbanData,
        Kanban             _kanban,
        KanbanJob          _kanbanJob)
    {
        boolean result;
        boolean mustAutoPlan = false;

        result = _reqEventKanbanData.canUpdate();

        if (   result
            && _reqEventKanbanData.mustCancelBeforeUpdate())
        {
            // for jobs that belong to a rule with auto-planning enabled, we try cancelling the kanban
            if (_reqEventKanbanData.canCancelBeforeUpdate())
            {
                result = ReqEventProcessKanban::cancelKanban(_kanban,false,false,_kanbanJob);

                if (result)
                {
                    mustAutoPlan = true;
                    _kanban.reread();
                    _kanbanJob.reread();
                    _reqEventKanbanData.parmKanban(_kanban);
                    _reqEventKanbanData.parmKanbanJob(_kanbanJob);
                }
            }
            else
            {
                // otherwise inform the user he needs to manually cancel the kanban
                result = checkFailed(strFmt("@SYS319615",_kanban.KanbanId,_kanban.Status));
            }
        }

        return [result,mustAutoPlan];
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDeletePeggingEvent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determine if the pegging event can be deleted.
    /// </summary>
    /// <returns>
    ///    true if the pegging event can be deleted; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The method is used where the <c>ReqEventProcessKanban</c> instance is not responsible
    ///    for deleting the event itself, but leaves it up to the caller to remove the pegging event.
    ///    This is the case when events are processed by the periodic 'pegging event processing'
    ///    <c>ReqEventProcessBatchKanbanTask</c> class.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean canDeletePeggingEvent()
    {
        return canDeletePeggingEvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReduceInventQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the quantity can be reduced.
    /// </summary>
    /// <returns>
    ///    true if the quantity can be reduced; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean canReduceInventQty()
    {
        return    kanbanRule
               && this.canReserveOnhandQty()
               && this.inventTransOriginId()
               && this.mustProcessNow()
                && (!ReqEventProcessKanbanConsiderOnHandFlight::instance().isEnabled() || !kanbanRuleEvent.ConsiderOnHand);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReserveOnhandQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the OnHandQty is considered
    /// </summary>
    /// <returns>
    ///    true if the OnHandQty is considered; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean canReserveOnhandQty()
    {
        if ((kanbanRuleEvent.SourceRequirementReservation == NoYes::Yes && kanbanRuleEvent.InventoryReservationPolicy   == LeanInventoryReservationPolicy::Always))
        {
            return true;
        }
        else

        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReduceInventQtyKanbanRuleLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the quantity for kanban rule lookup can be reduced.
    /// </summary>
    /// <returns>
    ///    true if the quantity for kanban rule lookup can be reduced; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean canReduceInventQtyKanbanRuleLookup()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteKanban</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes all kanbans that are related to the event, if possible.
    /// </summary>
    /// <returns>
    ///    true if all kanbans were deleted; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean deleteKanban()
    {
        Kanban                  kanban;
        InventQty               peggedQty;
        InventQty               qtyRemain;
        Map                     map;
        MapEnumerator           me;
        boolean                 result = true;
        boolean                 isTopLevelScope;

        using(KanbanJobDeferredSchedulingScope deferredSchedulingScope = new KanbanJobDeferredSchedulingScope())
        {
            isTopLevelScope = deferredSchedulingScope.isTopLevelScope();

            map       = kanbanEventQuantityMap.mapKanbanQuantities();
            qtyRemain = kanbanEventQuantityMap.totalQuantity();

            if (   map
                && map.elements())
            {
                ttsbegin;
                me = map.getEnumerator();
                while (me.moveNext())
                {
                    kanban    = Kanban::find(me.currentKey());
                    peggedQty = me.currentValue();

                    //the full quantity is pegged and a reset is possible
                    if (   (!kanban.QuantityReceived
                        &&  kanban.QuantityOrdered == peggedQty)
                        || (kanban.QuantityReceived
                        &&  kanban.QuantityReceived == peggedQty))
                    {
                        if (ReqEventProcessKanban::cancelKanban(kanban))
                        {
                            kanban = Kanban::find(kanban.RecId,true);
                            kanban.delete();
                            qtyRemain -= peggedQty;
                            this.addResultMap(mapUpdatedKanban,kanban.KanbanRule,kanban.RecId);
                        }
                        else
                        {
                            warning(strFmt("@SYS319613",kanban.KanbanId));
                            result = false;
                        }
                    }
                }

                //try to reduce any remaining kanbans
                if (qtyRemain)
                {
                    this.updateKanban(0,true);
                }

                ttscommit;
            }
        }

        if(isTopLevelScope)
        {
            ReqEventProcessBatchScheduleTask::newStandard(false, true, 0).runOperation();
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteMarkInventoryTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes all marking between the event and a specified event kanban.
    /// </summary>
    /// <param name="_kanbanJob">
    ///    A <c>KanbanJob</c> record that represents the event kanban.
    /// </param>
    /// <param name="_receiptInventTransOriginId">
    ///    The receipt inventory transaction originator; optional.
    /// </param>
    /// <returns>
    ///    The unmarked quantity.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The same quantity could not be unmarked on receipt and issue sides.
    /// </exception>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected InventQty deleteMarkInventoryTransactions(
        KanbanJob           _kanbanJob,
        InventTransOriginId _receiptInventTransOriginId = 0)
    {
        InventTrans         inventTrans;
        InventTransOriginId receiptInventTransOriginId    = _receiptInventTransOriginId;
        InventTransOriginId markingRefInventTransOriginId = this.inventTransOriginId();
        InventQty           markReceiptQty;
        InventQty           markIssueQty;

        if (!receiptInventTransOriginId)
        {
            receiptInventTransOriginId = _kanbanJob.receiptInventTransOriginId();
        }

        if (   markingRefInventTransOriginId
            && receiptInventTransOriginId
            && this.mustMarkInventoryTransactions())
        {
            ttsbegin;
            select sum(Qty), InventTransOrigin from inventTrans
                group by InventTransOrigin
                where inventTrans.InventTransOrigin           == receiptInventTransOriginId
                   && inventTrans.MarkingRefInventTransOrigin == markingRefInventTransOriginId
                   && inventTrans.Qty                         > 0
                   && !inventTrans.PackingSlipReturned;

            if (inventTrans.Qty)
            {
                markReceiptQty = InventTransOrigin::deleteMarking(inventTrans.InventTransOrigin,receiptInventTransOriginId,inventTrans.Qty,true);
                if (markReceiptQty)
                {
                    markIssueQty = InventTransOrigin::deleteMarking(inventTrans.InventTransOrigin,receiptInventTransOriginId,markReceiptQty,true);

                    if (markIssueQty != -markReceiptQty)
                    {
                        throw error(Error::wrongUseOfFunction(funcName()));
                    }
                }
            }
            ttscommit;
        }

        return markReceiptQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deletePeggingEvent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the obsolete <c>ReqPeggingEvent</c> and <c>ReqPeggingAssignment</c> records.
    /// </summary>
    protected void deletePeggingEvent()
    {
        // delete
        super();

        // set flag
        canDeletePeggingEvent = this.mustUsePeggingEvent();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a description for the class.
    /// </summary>
    /// <returns>
    ///    A description of the class.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static Description description()
    {
        return "@SYS328623";
    }

]]></Source>
			</Method>
			<Method>
				<Name>dueDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines the due date and time of the event
    /// </summary>
    /// <returns>
    /// A <c>TransDateTime</c> temporal value.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected TransDateTime dueDateTime()
    {
        return DateTimeUtil::minValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>eventDescription</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a description of the event.
    /// </summary>
    /// <returns>
    ///    A string that represents the event.
    /// </returns>
    protected str eventDescription()
    {
        return strFmt("@SYS4000036",kanbanRule.RuleId,this.id());
    }

]]></Source>
			</Method>
			<Method>
				<Name>eventRefRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines the event.
    /// </summary>
    /// <returns>
    /// A record ID of the <c>KanbanRule</c> table.
    /// </returns>
    protected RefRecId eventRefRecId()
    {
        return kanbanRule.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>id</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a string identification for the buffer.
    /// </summary>
    /// <returns>
    ///    A string value that identifies the buffer.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected abstract str id()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes class variables.
    /// </summary>
    /// <returns>
    /// true if the initialization was successful; otherwise, false.
    /// </returns>
    public boolean init()
    {
        boolean     result              = super();
        boolean     needsKanbanEventMap =    this.canUpdate()
                                          || this.canDelete();

        mapInsertedKanban = new Map(Types::Int64,Types::Class);
        mapUpdatedKanban  = new Map(Types::Int64,Types::Class);
        mapDeletedKanban  = new Map(Types::Int64,Types::Class);

        if (result)
        {
            itemId      = this.itemId();
            inventTable = InventTable::find(itemId);

            result =    itemId
                     && inventTable;

            if (result)
            {
                kanbanEventQuantityMap = needsKanbanEventMap ? KanbanEventQuantityMap::newStandard(this.buffer()) : null;
                this.initActionMode();

                result = this.validateActionMode();
            }

            result =    result
                     && this.initSourceRequirementParm();

            if (result)
            {
                inventDimGroupSetup       = InventDimGroupSetup::newInventTable(inventTable);
                inventDimId               = this.inventDimId();
                dueDateTime               = this.dueDateTime();
                inventQtyKanbanRuleLookup = this.inventQtyKanbanRuleLookup();
                kanbanRuleFound           = this.initKanbanRule();
                inventQty                 = this.inventQty();
            }
        }

        return    result
               && inventDimGroupSetup
               && inventDimId
               && (!needsKanbanEventMap || kanbanEventQuantityMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initActionMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the action mode.
    /// </summary>
    protected void initActionMode()
    {
        Map map;

        super();

        if (actionMode == ReqEventProcessAction::None)
        {
            if (this.canInsert())
            {
                if (kanbanEventQuantityMap)
                {
                    map = kanbanEventQuantityMap.mapKanbanQuantities(true);
                }

                if (   !map
                    || !map.elements()
                    || !kanbanEventQuantityMap.totalQuantity())
                {
                    actionMode = ReqEventProcessAction::Insert;
                }
            }

            if (   actionMode == ReqEventProcessAction::None
                && this.canUpdate())
            {
                actionMode = ReqEventProcessAction::Update;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the event quantity to process.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void initInventQty()
    {
        InventDim           inventDim;
        InventDimParm       inventDimParm;
        InventTransIdSum    inventTransIdSum;
        InventMovement      inventMovement;
        InventQty           qty;
        InventQty           transQty;
        InventQty           originalQty;
        InventQty           reservedNowPhysicalQty;
        InventQty           receiptQty;
        InventQty           adjustForPhysicalReceiptQty;
        InventQty           receiptAvailReservePhysicalQty;
        InventQty           reestablishPhysicalReservQty;
        InventQty           reserveOnHandQty;
        boolean             canReduce;

        inventMovement = this.inventMovement();

        if (   !initInventQty
            && inventMovement)
        {
            inventTransIdSum = inventMovement.transIdSum();
            canReduce        = this.canReduceInventQty();

            switch (actionMode)
            {
                case ReqEventProcessAction::Insert:
                    transQty         = min(0,inventTransIdSum.estimated());
                    qty              = canReduce ? transQty - inventTransIdSum.reservPhysical() : transQty;
                    reserveOnHandQty = this.allowReserveAvailableOnHand() ? -qty : 0;
                    break;
                case ReqEventProcessAction::Update:
                    transQty = min(0,inventTransIdSum.issue() + inventTransIdSum.receipt());

                    if (canReduce)
                    {
                        // initialize the reservation dimensions
                        inventDim     = inventMovement.inventdim();
                        inventDimParm = inventMovement.initDimParmAutoReserv(inventDim);

                        inventDimParm.setAllProductDimensions();
                        inventDimParm.InventLocationIdFlag = inventDim.InventLocationId && inventMovement.isTransfer()
                                                                ? NoYes::Yes
                                                                : inventDimParm.InventLocationIdFlag;

                        // issue
                        originalQty = reqEventProcessParm.originalQuantity();

                        // receipt
                        receiptQty = min(-originalQty,kanbanEventQuantityMap.peggedQuantity(this.itemId(),inventDim,inventDimParm,true));

                        if (originalQty < transQty)
                        {
                            // decrease

                            // quantity that could be physically reserved against existing event kanbans
                            receiptAvailReservePhysicalQty = kanbanEventQuantityMap.availReservePhysicalPegged(
                                                                                                        this.itemId(),
                                                                                                        inventDim,
                                                                                                        inventDimParm);

                            // adjust the quantity to the quantity to be handled by event kanbans, negative
                            qty = min(0, transQty - receiptQty - originalQty);

                            // already physically received quantities should be included where possible, negative
                            adjustForPhysicalReceiptQty  = receiptAvailReservePhysicalQty + qty;
                            qty                          = min(qty,max(transQty,-receiptAvailReservePhysicalQty));
                            adjustForPhysicalReceiptQty -= qty;

                            // quantity for which marking should be removed and physical reservation should be done instead
                            reestablishPhysicalReservQty = max(-receiptQty,reqEventProcessParm.reservedPhysicalQtyDelta());
                            reestablishPhysicalReservQty = min(0,reestablishPhysicalReservQty + adjustForPhysicalReceiptQty);
                        }
                        else if (originalQty == transQty)
                        {
                            if (reqEventProcessParm.parmOrigInventDimId() &&
                                !InventDim::isInventDimEqualCovDim(inventDimGroupSetup, inventDim, InventDim::find(reqEventProcessParm.parmOrigInventDimId())))
                            {
                                // Qty is not changed, but coverage dimension is changed on source line
                                qty = canReduce ? transQty - inventTransIdSum.reservPhysical() : transQty;
                            }
                            else
                            {
                                // Qty and coverage dimension are not changed on source line, no need to reduce qty
                                qty = transQty;
                            }
                        }
                        else
                        {
                            // increase

                            // free quantity that could be physically reserved against existing event kanbans
                            receiptAvailReservePhysicalQty = kanbanEventQuantityMap.availReservePhysicalUnPegged(
                                                                                                        this.itemId(),
                                                                                                        inventDim,
                                                                                                        inventDimParm);

                            // quantity that is physically reserved with the current quantity increase
                            reservedNowPhysicalQty = min(0,-reqEventProcessParm.reservedPhysicalQtyDelta());

                            // quantity to be handled by event kanbans, negative
                            qty = min(0,transQty - receiptQty - originalQty - min(0,reservedNowPhysicalQty + receiptAvailReservePhysicalQty));

                            // quantity that should be attempted to reserve, before event kanbans are created, positive
                            reserveOnHandQty = this.allowReserveAvailableOnHand() ? originalQty - transQty + reservedNowPhysicalQty : 0;
                        }
                    }
                    else
                    {
                        qty = transQty;
                    }
                    break;
                default:
                    transQty = min(0,inventTransIdSum.issue() + inventTransIdSum.receipt());
                    qty      = transQty;
                    break;
            }

            markingAdjustQty          = max(0,-reestablishPhysicalReservQty);   // positive
            reserveAvailableOnHandQty = max(0,reserveOnHandQty);                // positive
            inventQty                 = max(0,-qty);                            // positive
            inventQty                 = inventQty < kanbanRuleEvent.MinimumEventQuantity ? 0 : inventQty;
            initInventQty             = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventQtyKanbanRuleLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the quantity that is used to look up a kanban rule.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void initInventQtyKanbanRuleLookup()
    {
        InventTransIdSum    inventTransIdSum;
        InventMovement      inventMovement;
        InventQty           transQty;

        if (!initInventQtyKanbanRuleLookup)
        {
            inventMovement = this.inventMovement();

            if (inventMovement)
            {
                inventTransIdSum = inventMovement.transIdSum();

                switch (actionMode)
                {
                    case ReqEventProcessAction::Insert:
                        transQty = min(0,inventTransIdSum.estimated());
                        break;
                    default:
                        transQty = min(0,inventTransIdSum.issue() + inventTransIdSum.receipt());
                        break;
                }

                inventQtyKanbanRuleLookup = max(0,-transQty);
            }
            else
            {
                inventQtyKanbanRuleLookup = 0;
            }

            initInventQtyKanbanRuleLookup = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initKanbanRule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a kanban rule and related table buffers.
    /// </summary>
    /// <param name="_inventQtyKanbanRuleLookup">
    ///    The quantity to use to lookup applicable kanban rules; optional.
    /// </param>
    /// <returns>
    ///    true if the initialization was successful; otherwise, false.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The method was called from a subclass that returns an invalid <c>KanbanEventType</c> enumeration
    ///    value.
    /// </exception>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean initKanbanRule(InventQty _inventQtyKanbanRuleLookup = inventQtyKanbanRuleLookup)
    {
        LeanProductionFlowReference     leanProductionFlowReference;
        TransDateTime                   dateTime = DateTimeUtil::getSystemDateTime();
        KanbanFindRulesEvent            kanbanFindRulesEvent;
        InventDimParm                   inventDimParm;
        boolean                         result;

        KanbanEventType kanbanEventType = this.kanbanEventType();

        if (kanbanEventType)
        {
            if (limitToPlanReferenceRefRecId)
            {
                leanProductionFlowReference = LeanProductionFlowReference::findPlanReference(limitToPlanReferenceRefRecId);
            }

            if (   !kanbanRule
                || !limitToKanbanRuleRefRecId
                || kanbanRule.RecId == limitToKanbanRuleRefRecId)
            {
                inventDimParm.initCovPrDimension(inventDimGroupSetup);

                kanbanFindRulesEvent = KanbanFindRulesEvent::newStandard(itemId,
                                                                         _inventQtyKanbanRuleLookup,
                                                                         kanbanEventType,
                                                                         this.mustIncludeManualEvents(),
                                                                         acceptReceiveSemiFinishedKanbanRule,
                                                                         acceptReceiveFinishedKanbanRule,
                                                                         dateTime,
                                                                         inventDimId,
                                                                         inventDimParm,
                                                                         leanProductionFlowReference.RecId,
                                                                         limitToKanbanRuleRefRecId,
                                                                         excludeKanbanRuleRefRecId,
                                                                         limitToLastPlanActivityRefRecId,
                                                                         limitToPlanActivityDownStreamRecId);
                kanbanFindRulesEvent.parmSkipRuleMayExistCheck(skipRuleMayExistCheck);
                kanbanRule = kanbanFindRulesEvent.first();
            }
            else
            {
                kanbanRule = null;
            }

            if (kanbanRule)
            {
                kanbanRuleVariable = KanbanRuleVariable::findParentRecId(kanbanRule.RecId);
                kanbanRuleEvent    = KanbanRuleEvent::findKanbanRule(kanbanRule.RecId);
                kanbanFlow         = kanbanRule.kanbanFlow();
            }
        }
        else
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        result =    kanbanRule
                 && kanbanRuleVariable
                 && kanbanRuleEvent
                 && kanbanFlow;

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSourceRequirementParm</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the source requirement parameters.
    /// </summary>
    /// <returns>
    ///    true if the initialization was successful; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected abstract boolean initSourceRequirementParm()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertKanban</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates one or more kanbans and links them to the pegging tables.
    /// </summary>
    /// <param name="_inventQty">
    ///    The quantity to use to create kanbans; optional.
    /// </param>
    /// <param name="_totalQty">
    ///    The total quantity; optional.
    /// </param>
    /// <param name="_totalMarkedQty">
    ///    The total marked quantity; optional.
    /// </param>
    /// <returns>
    ///    A container that holds the new total and total marked quantities.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected container insertKanban(
        InventQty _inventQty      = inventQty,
        InventQty _totalQty       = 0,
        InventQty _totalMarkedQty = 0)
    {
        Kanban                      kanban;
        ReqEventKanbanData          reqEventKanbanData;
        List                        list;
        ListEnumerator              le;
        InventQty                   qtyNow;
        InventQty                   qtyRemain;
        InventQty                   totalQty       = _totalQty;
        InventQty                   totalMarkedQty = _totalMarkedQty;
        Kanban                      parentKanban;

        if (   _inventQty
            && kanbanRule)
        {
            ttsbegin;

            // adjust marking and reservation
            this.adjustMarkingAndReservations();

            // update pegged kanban due date based on the production flow constraint
            parentKanban = Kanban::findParentKanban(reqPeggingAssignmentRequirement.assignmentOrigin());
            if (parentKanban)
            {
                dueDateTime = KanbanDateCalculation::newKanbanFlow(kanbanFlow, itemId, _inventQty).calculatePeggedKanbanDueDate(parentKanban, dueDateTime);
            }

            //create kanbans
            list = LeanRulesEngine::triggerRuleParameters(kanbanRule,
                                                          itemId,
                                                          inventDimId,
                                                          this.calculateEventQuantities(_inventQty),
                                                          dueDateTime,
                                                          false,        // manual
                                                          NoYes::No,    // priority
                                                          this.bomId(),
                                                          true,
                                                          kanbanSourceRequirementParm);

            // link each kanban to the pegging tables
            if (   list
                && list.elements())
            {
                qtyRemain = _inventQty;
                le        = list.getEnumerator();

                while (   le.moveNext()
                       && qtyRemain)
                {
                    kanban = le.current();
                    this.addResultMap(mapInsertedKanban,kanban.KanbanRule,kanban.RecId);

                    if (qtyRemain)
                    {
                        reqEventKanbanData = ReqEventKanbanData::newStandard(kanban,kanban.lastKanbanJob(),0,0);
                        qtyNow             = min(qtyRemain,kanban.QuantityOrdered);

                        //pegging, marking, reservation
                        [totalQty,totalMarkedQty] = this.updatePeggingMarkingReservation(
                                                                reqEventKanbanData,
                                                                kanban.QuantityOrdered,
                                                                qtyNow,
                                                                qtyNow,
                                                                totalQty,
                                                                totalMarkedQty);

                        qtyRemain -= qtyNow;
                    }
                }

                if (interactive)
                {
                    info(strFmt("@SYS340548", list.elements(), itemId));
                }
            }

            this.sumUpInventTrans();

            ttscommit;
        }

        return [totalQty,totalMarkedQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Defines the inventory dimension for which the event is processed.
    /// </summary>
    /// <returns>
    ///    A <c>InventDimId</c> string value.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected abstract InventDimId inventDimId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventMovement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns an <c>InventMovement</c> object of the source event.
    /// </summary>
    /// <returns>
    ///    A <c>InventMovement</c> object; otherwise, null.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected InventMovement inventMovement()
    {
        InventMovement  inventMovement;

        if (   this.buffer()
            && this.inventTransOriginId())
        {
            inventMovement = InventMovement::construct(this.buffer());
        }

        return inventMovement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Defines the event quantity to process.
    /// </summary>
    /// <returns>
    ///    The quantity to be handled by event kanbans.
    /// </returns>
    protected InventQty inventQty()
    {
        if (!initInventQty)
        {
            this.initInventQty();
        }

        return inventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventQtyKanbanRuleLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Defines the event quantity to use to lookup the rule.
    /// </summary>
    /// <returns>
    ///    The quantity that is used to look up kanban rules.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected InventQty inventQtyKanbanRuleLookup()
    {
        if (!initInventQtyKanbanRuleLookup)
        {
            this.initInventQtyKanbanRuleLookup();
        }

        return inventQtyKanbanRuleLookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransOriginId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the inventory transaction originator of the source event.
    /// </summary>
    /// <returns>
    /// A record ID of the <c>InventTransOrigin</c> table.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected abstract InventTransOriginId inventTransOriginId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Defines the item for which an event is processed.
    /// </summary>
    /// <returns>
    ///    A <c>ItemId</c> string value.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected abstract ItemId itemId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>kanbanEventType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Defines the kanban event type that is processed by the class.
    /// </summary>
    /// <returns>
    ///    A <c>KanbanEventType</c> enumeration value.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected abstract KanbanEventType kanbanEventType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>kanbanRule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the kanban rule that is used by the class.
    /// </summary>
    /// <returns>
    ///    A <c>KanbanRule</c> record; otherwise, an empty buffer.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public KanbanRule kanbanRule()
    {
        return kanbanRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>listMarkingInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a list of prioritized inventory dimensions and quantities to be used for marking.
    /// </summary>
    /// <param name="_kanbanJob">
    ///    The kanban job to be marked.
    /// </param>
    /// <param name="_receiptInventTransOriginId">
    ///    The receipt inventory transaction origin ID of the kanban job.
    /// </param>
    /// <param name="_issueInventTransOriginId">
    ///    The issue inventory transaction origin ID.
    /// </param>
    /// <returns>
    ///    A list of prioritized inventory dimensions and quantities to be used for marking.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected List listMarkingInventDim(
        KanbanJob           _kanbanJob,
        InventTransOriginId _receiptInventTransOriginId,
        InventTransOriginId _issueInventTransOriginId)
    {
        InventTrans     inventTrans;
        InventDim       inventDim;
        InventDim       inventDimCriteria;
        InventDim       inventDimFinancial;
        InventDim       inventDimDefault;
        InventDimParm   inventDimParmCriteria;
        boolean         addedInventDimDefault;
        boolean         addedInventDimFinancial;
        MapEnumerator   me;
        ListEnumerator  le;
        List            listStatusInventDim;
        Map             mapStatusList;
        List            listInventDim;
        List            listResult = new List(Types::Container);

        if (   _receiptInventTransOriginId
            && _issueInventTransOriginId)
        {
            // create prioritized list of inventory dimensions to search for quantities to mark
            listInventDim    = new List(Types::Record);
            inventDimDefault = _kanbanJob.inventDim();
            inventDimFinancial.copyDimFinancial(inventDimGroupSetup,inventDimDefault);

            while select InventDimId from inventTrans
                group by InventDimId
                where inventTrans.InventTransOrigin == _receiptInventTransOriginId
            {
                listInventDim.addEnd(InventDim::find(inventTrans.InventDimId));

                addedInventDimDefault   = addedInventDimDefault || inventDimDefault.InventDimId == inventTrans.InventDimId;
                addedInventDimFinancial = addedInventDimFinancial || inventDimFinancial.InventDimId == inventTrans.InventDimId;
            }

            if (!addedInventDimDefault)
            {
                listInventDim.addEnd(inventDimDefault);
            }

            if (!addedInventDimFinancial)
            {
                listInventDim.addEnd(inventDimFinancial);
            }

            // now prioritize by inventory transaction status and add max. quantity
            le            = listInventDim.getEnumerator();
            mapStatusList = new Map(Types::Integer,Types::Class);

            while (le.moveNext())
            {
                inventDimCriteria = le.current();
                inventDimParmCriteria.initFromInventDim(inventDimCriteria);

                while select sum(Qty) from inventTrans
                    group by StatusIssue
                    order by StatusIssue desc
                    where inventTrans.InventTransOrigin           == _issueInventTransOriginId
                       && inventTrans.MarkingRefInventTransOrigin == 0
                    #inventDimExistsJoin(inventTrans.inventDimId,inventDim,inventDimCriteria,inventDimParmCriteria)
                {
                    if (mapStatusList.exists(-enum2int(inventTrans.StatusIssue)))
                    {
                        listStatusInventDim = mapStatusList.lookup(-enum2int(inventTrans.StatusIssue));
                    }
                    else
                    {
                        listStatusInventDim = new List(Types::Container);
                    }

                    listStatusInventDim.addEnd([inventDimCriteria,-inventTrans.Qty]);
                    mapStatusList.insert(-enum2int(inventTrans.StatusIssue),listStatusInventDim);
                }
            }

            // create the result list
            me = mapStatusList.getEnumerator();
            while (me.moveNext())
            {
                listStatusInventDim = me.currentValue();
                listResult.appendList(listStatusInventDim);
            }
        }

        return listResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapDeleteKanban</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the delete result map.
    /// </summary>
    /// <returns>
    ///    A <c>Map</c> object.
    /// </returns>
    /// <remarks>
    ///    The map key is a kanban rule record ID. The value is a set of kanban record IDs.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Map mapDeleteKanban()
    {
        return mapDeletedKanban;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapInsertedKanban</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the insert result map.
    /// </summary>
    /// <returns>
    ///    A <c>Map</c> object.
    /// </returns>
    /// <remarks>
    ///    The map key is a kanban rule record ID. The value is a set of kanban record IDs.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Map mapInsertedKanban()
    {
        return mapInsertedKanban;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapUpdatedKanban</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the update result map.
    /// </summary>
    /// <returns>
    ///    A <c>Map</c> object.
    /// </returns>
    /// <remarks>
    ///    The map key is a kanban rule record ID. The value is a set of kanban record IDs.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Map mapUpdatedKanban()
    {
        return mapUpdatedKanban;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markInventoryTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Marks or unmarks inventory transactions if required.
    /// </summary>
    /// <param name="_kanban">
    ///    A <c>Kanban</c> table buffer that represents the receipt to mark against.
    /// </param>
    /// <param name="_kanbanJob">
    ///    A <c>KanbanJob</c> table buffer that represents the receipt to mark against.
    /// </param>
    /// <param name="_markQty">
    ///    The quantity to mark in inventory unit.
    /// </param>
    /// <param name="_receiptInventTransOriginId">
    ///    The kanban receipt inventory transaction originator; optional.
    /// </param>
    /// <param name="_silent">
    ///    A Boolean value that specifies whether to add messages to the Infolog.
    /// </param>
    /// <returns>
    ///    The marked quantity.
    /// </returns>
    /// <remarks>
    ///    Provide a positive quantity to increase marking or a negative quantity to decrease marking.
    ///    The return value is positive if marking was increased, negative if marking was decreased.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    The same quantity could not be marked on receipt and issue side.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    The same quantity could not be unmarked on receipt and issue side.
    /// </exception>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected InventQty markInventoryTransactions(
        Kanban              _kanban,
        KanbanJob           _kanbanJob,
        InventQty           _markQty,
        InventTransOriginId _receiptInventTransOriginId = 0,
        boolean             _silent                     = true)
    {
        InventQty               markReceiptQty;
        InventQty               markIssueQty;
        InventQty               markUpdQty;
        InventDim               inventDim;
        InventDimParm           inventDimParm;
        UnitOfMeasure           unitOfMeasure;
        List                    list;
        ListEnumerator          le;
        InventQty               qtyNow;
        InventQty               qtyRemain;
        InventTransOriginId     receiptInventTransOriginId = _receiptInventTransOriginId;
        InventTransOriginId     issueInventTransOriginId   = this.inventTransOriginId();

        if (   _markQty
            && this.mustMarkInventoryTransactions())
        {
            if (!receiptInventTransOriginId)
            {
                receiptInventTransOriginId = _kanbanJob.receiptInventTransOriginId();
            }

            if (   receiptInventTransOriginId
                && issueInventTransOriginId)
            {
                // mark more
                if (_markQty > 0)
                {
                    qtyRemain = _markQty;
                    list      = this.listMarkingInventDim(_kanbanJob,receiptInventTransOriginId,issueInventTransOriginId);
                    le        = list.getEnumerator();

                    if (   list
                        && list.elements())
                    {
                        while (   le.moveNext()
                               && qtyRemain > 0)
                        {
                            [inventDim,qtyNow] = le.current();
                            qtyNow             = qtyRemain >= qtyNow ? qtyNow : qtyRemain;

                            inventDimParm.initFromInventDim(inventDim);

                            // see how much of the requirement can be marked, returns a positive qty
                            markIssueQty = InventTransOrigin::updateMarking(issueInventTransOriginId,receiptInventTransOriginId,-qtyNow,'',
                                                                            SortOrder::Descending,false,inventDim,inventDimParm);

                            qtyRemain -= markIssueQty;

                            if (markIssueQty)
                            {
                                //mark the same quantity on the receipt, returns a negative qty
                                markReceiptQty = InventTransOrigin::updateMarking(receiptInventTransOriginId,issueInventTransOriginId,markIssueQty,'',
                                                                                  SortOrder::Descending,false,inventDim,inventDimParm);
                                if (markIssueQty != -markReceiptQty)
                                {
                                    throw error(Error::wrongUseOfFunction(funcName()));
                                }
                            }
                        }
                    }

                    markUpdQty = _markQty - qtyRemain;
                }
                else
                {
                    // remove marking, returns a negative qty
                    markReceiptQty = InventTransOrigin::deleteMarking(receiptInventTransOriginId,issueInventTransOriginId,-_markQty,true);
                    if (markReceiptQty)
                    {
                        // remove markingAdjustQty, returns a positive qty
                        markIssueQty = InventTransOrigin::deleteMarking(issueInventTransOriginId,receiptInventTransOriginId,markReceiptQty,true);

                        if (markIssueQty != -markReceiptQty)
                        {
                            throw error(Error::wrongUseOfFunction(funcName()));
                        }
                    }

                    markUpdQty = markReceiptQty;
                }
            }

            if (   abs(markReceiptQty) != abs(_markQty)
                && !_silent)
            {
                unitOfMeasure = UnitOfMeasure::find(this.unitOfMeasureRecId());
                warning(strFmt("@SYS319606",_markQty,unitOfMeasure.Symbol,_kanban.KanbanId,-markReceiptQty,unitOfMeasure.Symbol));
            }
        }

        return markUpdQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDeletePeggingEvent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Defines whether the event deletes the <c>ReqPeggingEvent</c> record after processing.
    /// </summary>
    /// <returns>
    ///    true if the event deletes the <c>ReqPeggingEvent</c> record; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The base class always returns true.
    /// </remarks>
    protected boolean mustDeletePeggingEvent()
    {
        return mustDeleteEvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustHandleEvent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the current event must be handled.
    /// </summary>
    /// <returns>
    ///    true if the event must be handled; otherwise, false.
    /// </returns>
    protected boolean mustHandleEvent()
    {
        boolean result = super();

        if (result)
        {
            switch (actionMode)
            {
                case ReqEventProcessAction::Insert:
                    result =    inventQty
                             && inventTable.isStocked()
                             && kanbanRuleFound;
                    break;
            }
        }

        if (interactive)
        {
            if (   !result
                || !this.mustProcessNow())
            {
                info(strFmt("@SYS4000041",itemId));
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustIncludeManualEvents</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the manual events must be included when processing events.
    /// </summary>
    /// <returns>
    ///    true if the manual events must be considered; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean mustIncludeManualEvents()
    {
        // We include manual events when we run in interactive mode (action started by the user)
        // or if the operation is other than creation of event kanbans
        return     interactive
                || actionMode != ReqEventProcessAction::Insert;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustMarkInventoryTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether created kanbans must be marked against the source event.
    /// </summary>
    /// <returns>
    ///    true if created kanbans must be marked; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean mustMarkInventoryTransactions()
    {
        return this.mustReserveInventoryTransactions();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustProcessSynchronously</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the event must be processed synchronously.
    /// </summary>
    /// <returns>
    ///    true if the event must be processed synchronously; otherwise, false.
    /// </returns>
    protected boolean mustProcessSynchronously()
    {
        return    super()
               || actionMode == ReqEventProcessAction::Delete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustReserveInventoryTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether source event lines should be reserved.
    /// </summary>
    /// <returns>
    ///    true if source event lines should be reserved; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean mustReserveInventoryTransactions()
    {
        InventMovement  inventMovement;
        boolean         result;

        //rule does not force zero reservations and origin has inventory transactions
        result =    kanbanRuleEvent
                 && (!kanbanRuleEvent.SourceRequirementReservation
                 ||  kanbanRuleEvent.InventoryReservationPolicy != LeanInventoryReservationPolicy::Never)
                 && this.inventTransOriginId() != 0;

        if (result)
        {
            //movement must allow reservations
            inventMovement = this.inventMovement();
            result         =    inventMovement
                                && inventMovement.canBeReserved()
                                && (mustBeAutoReserved
                                ||  inventMovement.mustBeAutoReserved());
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAcceptReceiveFinishedKanbanRule</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean parmAcceptReceiveFinishedKanbanRule(boolean _acceptReceiveFinishedKanbanRule = acceptReceiveFinishedKanbanRule)
    {
        acceptReceiveFinishedKanbanRule = _acceptReceiveFinishedKanbanRule;
        return acceptReceiveFinishedKanbanRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAcceptReceiveSemiFinishedKanbanRule</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean parmAcceptReceiveSemiFinishedKanbanRule(boolean _acceptReceiveSemiFinishedKanbanRule = acceptReceiveSemiFinishedKanbanRule)
    {
        acceptReceiveSemiFinishedKanbanRule = _acceptReceiveSemiFinishedKanbanRule;
        return acceptReceiveSemiFinishedKanbanRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeKanbanRuleRefRecId</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public KanbanRuleRefRecId parmExcludeKanbanRuleRefRecId(KanbanRuleRefRecId _excludeKanbanRuleRefRecId = excludeKanbanRuleRefRecId)
    {
        excludeKanbanRuleRefRecId = _excludeKanbanRuleRefRecId;
        return excludeKanbanRuleRefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInteractive</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean parmInteractive(boolean _interactive = interactive)
    {
        interactive = _interactive;
        return interactive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLimitToLastPlanActivityRefRecId</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public PlanActivityRefRecId parmLimitToLastPlanActivityRefRecId(PlanActivityRefRecId _limitToLastPlanActivityRefRecId = limitToLastPlanActivityRefRecId)
    {
        limitToLastPlanActivityRefRecId = _limitToLastPlanActivityRefRecId;
        return limitToLastPlanActivityRefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLimitToPKanbanRuleRefRecId</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public KanbanRuleRefRecId parmLimitToPKanbanRuleRefRecId(KanbanRuleRefRecId _limitToKanbanRuleRefRecId = limitToKanbanRuleRefRecId)
    {
        limitToKanbanRuleRefRecId = _limitToKanbanRuleRefRecId;
        return limitToKanbanRuleRefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLimitToPlanActivityDownStreamRecId</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public PlanActivityRefRecId parmLimitToPlanActivityDownStreamRecId(PlanActivityRefRecId _limitToPlanActivityDownStreamRecId = limitToPlanActivityDownStreamRecId)
    {
        limitToPlanActivityDownStreamRecId = _limitToPlanActivityDownStreamRecId;
        return limitToPlanActivityDownStreamRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLimitToPlanReferenceRefRecId</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public PlanReferenceRefRecId parmLimitToPlanReferenceRefRecId(PlanReferenceRefRecId _limitToPlanReferenceRefRecId = limitToPlanReferenceRefRecId)
    {
        limitToPlanReferenceRefRecId = _limitToPlanReferenceRefRecId;
        return limitToPlanReferenceRefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMustBeAutoReserved</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean parmMustBeAutoReserved(boolean _mustBeAutoReserved = mustBeAutoReserved)
    {
        mustBeAutoReserved = _mustBeAutoReserved;
        return mustBeAutoReserved;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMustDeleteEvent</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean parmMustDeleteEvent(boolean _mustDeleteEvent = mustDeleteEvent)
    {
        mustDeleteEvent = _mustDeleteEvent;
        return mustDeleteEvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqEventProcessParm</Name>
				<Source><![CDATA[
    public ReqEventProcessParm parmReqEventProcessParm(ReqEventProcessParm _reqEventProcessParm)
    {
        reqEventProcessParm = _reqEventProcessParm;
        return reqEventProcessParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipRuleMayExistCheck</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean parmSkipRuleMayExistCheck(boolean _skipRuleMayExistCheck = skipRuleMayExistCheck)
    {
        skipRuleMayExistCheck = _skipRuleMayExistCheck;
        return skipRuleMayExistCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>peggingType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the pegging type.
    /// </summary>
    /// <returns>
    ///    A <c>ReqPeggingType</c> enumeration value.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected ReqPeggingType peggingType()
    {
        return ReqPeggingType::Firmed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareProcess</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes any code that needs to run after it was determined if the event must be handled and before the actual processing.
    /// </summary>
    protected void prepareProcess()
    {
        super();

        // reserves on hand if applicable and potentially changes the overall inventory quantity to be handled
        this.reserveAvailableOnHand();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processEvent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes the event.
    /// </summary>
    /// <exception cref="M:Exception::Error">
    ///    An invalid <c>ReqEventProcessAction</c> enumeration type was specified.
    /// </exception>
    protected void processEvent()
    {
        switch (actionMode)
        {
            case ReqEventProcessAction::Insert:
                this.insertKanban();
                break;
            case ReqEventProcessAction::Update:
                this.updateKanban();
                break;
            case ReqEventProcessAction::Delete:
                this.deleteKanban();
                break;
            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyMarked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the marked quantity.
    /// </summary>
    /// <param name="_receiptInventTransOriginId">
    ///    The receipt inventory origin.
    /// </param>
    /// <returns>
    ///    The marked quantity.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected InventQty qtyMarked(InventTransOriginId _receiptInventTransOriginId)
    {
        InventTransOriginId     issueInventTransOriginId = this.inventTransOriginId();
        InventQty               qtyMarked;

        if (   issueInventTransOriginId
            && _receiptInventTransOriginId)
        {
            qtyMarked = InventTransOrigin::qtyMarked(_receiptInventTransOriginId,issueInventTransOriginId);
        }

        return qtyMarked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyReserved</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the reserved quantity.
    /// </summary>
    /// <returns>
    ///     The reserved quantity.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected InventQty qtyReserved()
    {
        InventTransOriginId     issueInventTransOriginId = this.inventTransOriginId();
        InventQty               qtyReserved;

        if (issueInventTransOriginId)
        {
            qtyReserved = InventTransIdSum::newTransOriginId(issueInventTransOriginId).reserved();
        }

        return qtyReserved;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveAvailableOnHand</Name>
				<Source><![CDATA[
    /// <summary>
    ///    The method attempts to physically reserve the requested quantity.
    /// </summary>
    /// <remarks>
    ///    The quantity will not be reserved ordered.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void reserveAvailableOnHand()
    {
        InventMovement  inventMovement;
        InventQty       qtyReservedNow;
        InventQty       qtyReservedPhysicalBefore;
        InventQty       qtyReservedPhysicalAfter;

        if (this.mustProcessNow())
        {
            if (reserveAvailableOnHandQty > 0)
            {
                inventMovement            = this.inventMovement();
                qtyReservedPhysicalBefore = inventMovement.transIdSum().reservPhysical();

                InventUpd_Reservation::newMovement(this.inventMovement(),-reserveAvailableOnHandQty,true,true).updateNow();

                qtyReservedPhysicalAfter = inventMovement.transIdSum(true).reservPhysical();
                qtyReservedNow           = qtyReservedPhysicalAfter - qtyReservedPhysicalBefore;

                if (qtyReservedNow < 0)
                {
                    // adjust overall inventory quantity
                    inventQty += qtyReservedNow;
                    inventQty  = inventQty < kanbanRuleEvent.MinimumEventQuantity ? 0 : inventQty;
                }
            }

            // reset
            reserveAvailableOnHandQty = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveInventoryTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reserves inventory transactions if required.
    /// </summary>
    /// <param name="_reserveQty">
    ///    The quantity to reserve.
    /// </param>
    /// <remarks>
    ///    Provide a positive quantity to increase reservations or a negative quantity to decrease reservations.
    ///    All reservations will be 'reserved ordered'.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void reserveInventoryTransactions(InventQty _reserveQty)
    {
        InventUpd_Reservation   inventUpd_Reservation;

        if (this.mustReserveInventoryTransactions())
        {
            if (this.mustMarkInventoryTransactions())
            {
                // try to reserve all marked transactions of the movement
                // does not change reservations of transactions that are not marked
                InventUpd_Reservation::updateReserveRefTransId(this.inventMovement());
            }
            else
            {
                if (_reserveQty)
                {
                    // 'reserved ordered' reservations only, no physical reservations, because the supply event kanbans are just being
                    // created and can therefore not be physically available yet.
                    inventUpd_Reservation = InventUpd_Reservation::newMovement(this.inventMovement(),-_reserveQty,true);
                    inventUpd_Reservation.parmAllowReserveOrdered(true);
                    inventUpd_Reservation.parmAllowReservePhysical(false);
                    inventUpd_Reservation.updateNow();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumUpInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sums up inventory transactions of the event movement.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void sumUpInventTrans()
    {
        InventTrans     inventTrans;
        InventMovement  inventMovement = this.inventMovement();

        if (inventMovement)
        {
            ttsbegin;

            while select forupdate inventTrans
                where inventTrans.InventTransOrigin == inventMovement.inventTransOriginId()
                   && inventTrans.StatusReceipt     == StatusReceipt::None
            {
                inventTrans.updateSumUp();
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unitOfMeasureRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Defines the unit of measure that is used to create <c>ReqPegging</c> and
    ///    <c>ReqPeggingAssignment</c> records.
    /// </summary>
    /// <returns>
    ///    A record ID of the <c>UnitOfMeasure</c> table.
    /// </returns>
    protected UnitOfMeasureRecId unitOfMeasureRecId()
    {
        return unitOfMeasureRecId
                    ? unitOfMeasureRecId
                    : UnitOfMeasure::unitOfMeasureIdBySymbol(InventTable::find(itemId).inventUnitId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateKanban</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates event kanbans as a response to changes in the event origin.
    /// </summary>
    /// <param name="_inventQty">
    ///    The required kanban quantity; optional.
    /// </param>
    /// <param name="_calledFromDeleteKanban">
    ///    A Boolean value that defines if this method was called from the <c>deleteKanban</c> method; optional.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void updateKanban(
        InventQty _inventQty              = inventQty,
        boolean   _calledFromDeleteKanban = false)
    {
        Kanban                      kanban;
        KanbanJob                   kanbanJob;
        KanbanRuleVariable          kanbanRuleVariableLocal;
        InventDim                   inventDimKanban;
        InventDim                   inventDimEvent;
        KanbanDueDateTime           dueDateTimeEvent;
        Map                         mapKanbanRuleMinMax;
        KanbanRecordList            kanbanRecordListChangeable;
        KanbanRecordList            kanbanRecordListChangeableWithCancel;
        KanbanRecordList            kanbanRecordListUnchangeable;
        InventQty                   invalidQty;
        InventQty                   qtyNow;
        InventQty                   markedQty;
        InventQty                   totalMarkedQty;
        InventQty                   totalQty;
        ItemId                      kanbanItemId;
        BOMId                       bomId;
        ReqEventKanbanData          reqEventKanbanData;
        MapEnumerator               me;
        Map                         mapPegging;
        Map                         mapKanbanQuantities = kanbanEventQuantityMap.mapKanbanQuantities(true);
        InventQty                   totalQtyOriginal    = kanbanEventQuantityMap.totalQuantity();
        Kanban                      parentKanban;

        // adjust marking and reservation
        this.adjustMarkingAndReservations();

        // if there is no quantity to be handled by event kanbans, try to remove all existing kanbans
        if (    _inventQty == 0
            && !_calledFromDeleteKanban)
        {
            this.deleteKanban();
        }
        else
        {
            mapPegging = this.buildPeggingMap(mapKanbanQuantities);
        }

        // the following changes impact existing event kanbans: itemId, inventDimId, quantity, dueDateTime
        if (   mapPegging
            && mapPegging.elements())
        {
            ttsbegin;
            kanbanItemId     = this.itemId();
            bomId            = this.bomId();
            inventDimEvent   = InventDim::find(this.inventDimId());
            dueDateTimeEvent = max(this.dueDateTime(),DateTimeUtil::getSystemDateTime());

            // keep min/max quantity per rule cached
            mapKanbanRuleMinMax = new Map(Types::Int64,Types::Container);
            if (kanbanRule)
            {
                mapKanbanRuleMinMax.insert(kanbanRule.RecId,[kanbanRuleVariable.MinimumProductQuantity,kanbanRuleVariable.MaximumProductQuantity]);
            }

            // keep valid kanbans cached in sorted lists for processing
            kanbanRecordListChangeable           = KanbanRecordList::newStandard([
                                                                        fieldNum(Kanban,QuantityOrdered),
                                                                        fieldNum(Kanban,RecId)]);
            kanbanRecordListChangeableWithCancel = KanbanRecordList::newStandard([
                                                                        fieldNum(Kanban,QuantityOrdered),
                                                                        fieldNum(Kanban,RecId)]);
            kanbanRecordListUnchangeable         = KanbanRecordList::newStandard([
                                                                        fieldNum(Kanban,QuantityOrdered),
                                                                        fieldNum(Kanban,RecId)]);

            // step 1: iterate all event kanbans, analyse the current supply
            me = mapPegging.getEnumerator();
            while (me.moveNext())
            {
                reqEventKanbanData = me.currentValue();
                kanban             = reqEventKanbanData.parmKanban();
                kanbanJob          = reqEventKanbanData.parmKanbanJob();
                markedQty          = this.qtyMarked(reqEventKanbanData.receiptInventTransOriginId());
                totalMarkedQty    += markedQty;
                totalQty          += reqEventKanbanData.parmPeggedQty();

                if (reqEventKanbanData)
                {
                    // if the supply quantity has been reduced, reduce the pegging accordingly
                    // note: per definition, changes on the supply side do not lead to events.
                    // reduced quantities on the supply may therefore lead to 'overpegging'.

                    if (reqEventKanbanData.parmPeggedQty() > reqEventKanbanData.jobQuantity())
                    {
                        qtyNow                     = reqEventKanbanData.parmPeggedQty() - reqEventKanbanData.jobQuantity();
                        [totalQty,totalMarkedQty]  = this.updatePeggingMarkingReservation(
                                                                reqEventKanbanData,
                                                                reqEventKanbanData.jobQuantity(),
                                                                reqEventKanbanData.parmPeggedQty() - qtyNow,
                                                                -qtyNow,
                                                                totalQty,
                                                                totalMarkedQty);
                    }

                    if (reqEventProcessParm.parmOrigInventDimId())
                    {
						inventDimKanban = InventDim::find(reqEventProcessParm.parmOrigInventDimId());
                    }

                    if (!inventDimKanban.RecId)
                    {
						inventDimKanban = kanbanJob.inventDim();
                    }

                    inventDimKanban.clearNotCovPrDim(inventDimGroupSetup);

                    // these kanbans cannot be used for the event anymore, because the item or coverage dimension is different
                    if (   kanban.ItemId != kanbanItemId
                        || !InventDim::isInventDimEqualCovDim(inventDimGroupSetup,inventDimKanban,inventDimEvent)
                        || (bomId
                        &&  kanban.bomId != bomId))
                    {
                        qtyNow = reqEventKanbanData.parmPeggedQty();

                        if (qtyNow > 0 || this.mustMarkInventoryTransactions())
                        {
                            if (qtyNow > 0)
                            {
                                [totalQty,totalMarkedQty] = this.updatePeggingMarkingReservation(
                                                                        reqEventKanbanData,
                                                                        reqEventKanbanData.jobQuantity(),
                                                                        0,
                                                                        -qtyNow,
                                                                        totalQty,
                                                                        totalMarkedQty);
                            }

                            if (ReqEventProcessKanban::cancelKanban(kanban,false,false,kanbanJob))
                            {
                                kanban = Kanban::find(kanban.RecId,true);
                                kanban.delete();
                                this.addResultMap(mapDeletedKanban,kanban.KanbanRule,kanban.RecId);
                                warning(strFmt("@SYS321485",kanban.KanbanId,this.id()));
                            }
                        }
                        else
                        {
                            warning(strFmt("@SYS319611",kanban.KanbanId,this.id()));
                        }

                        invalidQty += qtyNow;
                    }
                    else
                    {
                        // entire kanban is pegged
                        if (reqEventKanbanData.parmPeggedQty() >= kanban.QuantityOrdered)
                        {
                            // Find due date for pegged kanban based on the production flow constraint
                            parentKanban = Kanban::findParentKanban(reqPeggingAssignmentRequirement.assignmentOrigin());
                            if (parentKanban)
                            {
                                dueDateTimeEvent = KanbanDateCalculation::newKanbanFlow(kanbanFlow, itemId, _inventQty).calculatePeggedKanbanDueDate(parentKanban, dueDateTime);
                            }

                            if (kanban.DueDateTime != dueDateTimeEvent)
                            {
                                // update due date if possible
                                if (kanban.Status == LeanKanbanStatus::NotAssigned)
                                {
                                    kanban             = Kanban::find(kanban.RecId,true);
                                    kanban.DueDateTime = dueDateTimeEvent;
                                    kanban.update();
                                    this.addResultMap(mapUpdatedKanban,kanban.KanbanRule,kanban.RecId);
                                }
                            }
                        }

                        // add to one of the three lists
                        // change kanban and pegged qty is allowed even if the expected date does not meet the due date criteria
                        if (reqEventKanbanData.canUpdate())
                        {
                            if (reqEventKanbanData.mustCancelBeforeUpdate())
                            {
                                if (reqEventKanbanData.canCancelBeforeUpdate())
                                {
                                    kanbanRecordListChangeableWithCancel.insert(kanbanJob.Status,kanban);
                                }
                                else
                                {
                                    kanbanRecordListUnchangeable.insert(kanbanJob.Status,kanban);
                                }
                            }
                            else
                            {
                                kanbanRecordListChangeable.insert(kanbanJob.Status,kanban);
                            }
                        }
                        else
                        {
                            kanbanRecordListUnchangeable.insert(kanbanJob.Status,kanban);
                        }

                        // keep cached values
                        if (!mapKanbanRuleMinMax.exists(kanban.KanbanRule))
                        {
                            kanbanRuleVariableLocal = KanbanRuleVariable::findParentRecId(kanban.KanbanRule);
                            mapKanbanRuleMinMax.insert(kanban.KanbanRule,
                                                       [kanbanRuleVariableLocal.MinimumProductQuantity,
                                                       kanbanRuleVariableLocal.MaximumProductQuantity]);
                        }
                    }
                }
            }

            // step 2: increase or decrease current supply
            if (_inventQty > totalQty)
            {
                // pass 'more' quantity as positive value
                this.updateKanbanMore(
                            _inventQty,
                            totalQty,
                            totalMarkedQty,
                            kanbanRecordListChangeable,
                            kanbanRecordListChangeableWithCancel,
                            kanbanRecordListUnchangeable,
                            mapPegging,
                            mapKanbanRuleMinMax);
            }
            else if (_inventQty < totalQty ||
                     totalQty < totalQtyOriginal)
            {
                // invalidQty is already taken out of totalQty
                // pass 'less' qty as positive value
                this.updateKanbanLess(
                            _inventQty,
                            totalQty,
                            totalMarkedQty,
                            kanbanRecordListChangeable,
                            kanbanRecordListChangeableWithCancel,
                            kanbanRecordListUnchangeable,
                            mapPegging,
                            mapKanbanRuleMinMax);
            }

            // sum up
            this.sumUpInventTrans();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateKanbanLess</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates event kanbans as a response to a reduction in the event origin.
    /// </summary>
    /// <param name="_inventQty">
    ///    The required kanban quantity.
    /// </param>
    /// <param name="_totalQty">
    ///    The total quantity.
    /// </param>
    /// <param name="_totalMarkedQty">
    ///    The total marked quantity.
    /// </param>
    /// <param name="_kanbanRecordListChangeable">
    ///    A list of event kanbans that can be updated.
    /// </param>
    /// <param name="_kanbanRecordListChangeableWithCancel">
    ///    A list of event kanbans that can be updated after the kanban is cancelled.
    /// </param>
    /// <param name="_kanbanRecordListUnchangeable">
    ///    A list of event kanbans that cannot be changed.
    /// </param>
    /// <param name="_mapPegging">
    ///    A map of pegged kanbans and quantities.
    /// </param>
    /// <param name="_mapKanbanRuleMinMax">
    ///    A map of minimum and maximum quantities per kanban rule.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void updateKanbanLess(
        InventQty        _inventQty,
        InventQty        _totalQty,
        InventQty        _totalMarkedQty,
        KanbanRecordList _kanbanRecordListChangeable,
        KanbanRecordList _kanbanRecordListChangeableWithCancel,
        KanbanRecordList _kanbanRecordListUnchangeable,
        Map              _mapPegging,
        Map              _mapKanbanRuleMinMax)
    {
        Kanban              kanbanInList;
        ReqEventKanbanData  reqEventKanbanData;
        InventQty           qtyKanbanChange;
        InventQty           qtyApplied;
        boolean             kanbanRecordListNext;
        InventQty           qtyRemain;
        InventQty           totalQty       = _totalQty;
        InventQty           totalMarkedQty = _totalMarkedQty;
        Map                 mapQtyKanban   = new Map(Types::Int64,Types::Container);
        Map                 mapQtyPegging  = new Map(Types::Int64,Types::Real);

        // reset pegging quantities to zero
        InventQty applyResetPeggingQty(KanbanRecordList _kanbanRecordList)
        {
            InventQty   qtyNowPegging;
            InventQty   qtyNowPeggingTotal;
            InventQty   substractedQty;

            kanbanRecordListNext = _kanbanRecordList.first(kanbanInList);
            while (    kanbanInList
                    && kanbanRecordListNext)
            {
                reqEventKanbanData  = _mapPegging.lookup(kanbanInList.RecId);
                qtyNowPegging       = -reqEventKanbanData.parmPeggedQty();

                if (qtyNowPegging < 0)
                {
                    [substractedQty,totalQty,totalMarkedQty] = this.updateOneKanban(
                                                                        kanbanInList,
                                                                        reqEventKanbanData,
                                                                        qtyNowPegging,
                                                                        false,
                                                                        true,
                                                                        totalQty,
                                                                        totalMarkedQty);
                    qtyNowPeggingTotal += substractedQty;
                }

                kanbanRecordListNext = _kanbanRecordList.next(kanbanInList);
            }

            return qtyNowPeggingTotal;
        }

        // insert positive pegging quantities into map
        InventQty addPeggingQty(KanbanRecordList _kanbanRecordList)
        {
            InventQty   qtyNowPegging;
            InventQty   qtyNowPeggingTotal;

            kanbanRecordListNext = _kanbanRecordList.first(kanbanInList);
            while (    kanbanInList
                    && kanbanRecordListNext)
            {
                reqEventKanbanData  = _mapPegging.lookup(kanbanInList.RecId);
                qtyNowPegging       = reqEventKanbanData.jobQuantity() - reqEventKanbanData.parmPeggedQty();

                if (mapQtyKanban.exists(kanbanInList.RecId))
                {
                    qtyNowPegging = max(0,qtyNowPegging - mapQtyKanban.lookup(kanbanInList.RecId));
                }

                qtyNowPeggingTotal += qtyNowPegging;

                if (qtyNowPegging > 0)
                {
                    mapQtyPegging.insert(kanbanInList.RecId,qtyNowPegging);
                }

                kanbanRecordListNext = _kanbanRecordList.next(kanbanInList);
            }

            return qtyNowPeggingTotal;
        }

        // update pegging map quantities
        InventQty substractPeggingQty(
            KanbanRecordList _kanbanRecordList,
            boolean          _respectMinimum)
        {
            InventQty   qtyNowMin;
            InventQty   minQty;
            InventQty   maxQty;
            InventQty   qtyPeggingChange;
            InventQty   qtyNowPegging;
            InventQty   qtyNowPeggingTotal;

            kanbanRecordListNext = _kanbanRecordList.first(kanbanInList);
            while (    kanbanInList
                    && kanbanRecordListNext
                    && qtyRemain + qtyNowPeggingTotal > 0)
            {
                reqEventKanbanData = _mapPegging.lookup(kanbanInList.RecId);

                qtyPeggingChange   = 0;
                if (mapQtyPegging.exists(kanbanInList.RecId))
                {
                    qtyPeggingChange = mapQtyPegging.lookup(kanbanInList.RecId);
                }

                qtyNowPegging = min(qtyRemain + qtyNowPeggingTotal,reqEventKanbanData.parmPeggedQty() + qtyPeggingChange);

                if (   _respectMinimum
                    && qtyPeggingChange - qtyNowPegging > 0)
                {
                    [minQty,maxQty] = _mapKanbanRuleMinMax.lookup(kanbanInList.KanbanRule);
                    qtyNowMin       = minQty > 0 ? reqEventKanbanData.parmPeggedQty() + qtyPeggingChange - minQty : reqEventKanbanData.parmPeggedQty() + qtyPeggingChange;
                    qtyNowMin       = max(0,qtyNowMin);
                    qtyNowPegging   = min(qtyNowPegging,qtyNowMin);
                }

                if (qtyNowPegging != 0)
                {
                    if (   mapQtyPegging.exists(kanbanInList.RecId)
                        && qtyPeggingChange - qtyNowPegging == 0)
                    {
                        mapQtyPegging.remove(kanbanInList.RecId);
                    }
                    else
                    {
                        mapQtyPegging.insert(kanbanInList.RecId,qtyPeggingChange - qtyNowPegging);
                    }
                }

                qtyNowPeggingTotal -= qtyNowPegging;

                kanbanRecordListNext = _kanbanRecordList.next(kanbanInList);
            }

            return qtyNowPeggingTotal;
        }

        // update kanbans quantities
        void applyKanbanQty(KanbanRecordList _kanbanRecordList)
        {
            InventQty   substractedQty;
            InventQty   qtyNowMin;
            InventQty   minQty;
            InventQty   maxQty;

            kanbanRecordListNext = _kanbanRecordList.first(kanbanInList);
            while (    kanbanInList
                    && kanbanRecordListNext)
            {
                reqEventKanbanData = _mapPegging.lookup(kanbanInList.RecId);

                if (reqEventKanbanData.jobQuantity() > reqEventKanbanData.parmPeggedQty())
                {
                    if (reqEventKanbanData.parmPeggedQty() > 0)
                    {
                        [minQty,maxQty] = _mapKanbanRuleMinMax.lookup(kanbanInList.KanbanRule);
                        qtyNowMin       = minQty > 0 ? reqEventKanbanData.jobQuantity() - minQty : reqEventKanbanData.jobQuantity();
                        qtyNowMin       = max(0,qtyNowMin);
                        qtyKanbanChange = reqEventKanbanData.jobQuantity() - reqEventKanbanData.parmPeggedQty();
                        qtyKanbanChange = min(qtyKanbanChange,qtyNowMin);
                    }
                    else
                    {
                        qtyKanbanChange = reqEventKanbanData.jobQuantity();
                    }

                    if (qtyKanbanChange > 0)
                    {
                        [substractedQty,totalQty,totalMarkedQty] = this.updateOneKanban(
                                                                                    kanbanInList,
                                                                                    reqEventKanbanData,
                                                                                    -qtyKanbanChange,
                                                                                    true,
                                                                                    false,
                                                                                    totalQty,
                                                                                    totalMarkedQty);
                    }
                }

                kanbanRecordListNext = _kanbanRecordList.next(kanbanInList);
            }
        }

        // update pegging quantities
        InventQty applyPeggingQty(
            KanbanRecordList _kanbanRecordList,
            boolean          _add)
        {
            InventQty   qtyPeggingChange;
            InventQty   addedOrSubstractedQty;
            InventQty   addedOrSubstractedQtyTotal;

            kanbanRecordListNext = _kanbanRecordList.first(kanbanInList);
            while (    kanbanInList
                    && kanbanRecordListNext)
            {
                reqEventKanbanData = _mapPegging.lookup(kanbanInList.RecId);
                qtyPeggingChange   = 0;

                if (mapQtyPegging.exists(kanbanInList.RecId))
                {
                    qtyPeggingChange = mapQtyPegging.lookup(kanbanInList.RecId);
                }

                if (   (_add &&  qtyPeggingChange > 0)
                    || (!_add && qtyPeggingChange < 0))
                {
                    [addedOrSubstractedQty,totalQty,totalMarkedQty] = this.updateOneKanban(
                                                                                    kanbanInList,
                                                                                    reqEventKanbanData,
                                                                                    qtyPeggingChange,
                                                                                    false,
                                                                                    true,
                                                                                    totalQty,
                                                                                    totalMarkedQty);

                    addedOrSubstractedQtyTotal += addedOrSubstractedQty;
                }

                kanbanRecordListNext = _kanbanRecordList.next(kanbanInList);
            }

            return addedOrSubstractedQtyTotal;
        }

        ttsbegin;
        // step 1: distribute the required pegging quantity so that as much as possible is pegged to
        // already completed or in progress kanbans

        // reset all pegging
        applyResetPeggingQty(_kanbanRecordListUnchangeable);
        applyResetPeggingQty(_kanbanRecordListChangeableWithCancel);
        applyResetPeggingQty(_kanbanRecordListChangeable);

        // add: set all pegging quantities to full quantity
        qtyRemain  = addPeggingQty(_kanbanRecordListUnchangeable);
        qtyRemain += addPeggingQty(_kanbanRecordListChangeableWithCancel);
        qtyRemain += addPeggingQty(_kanbanRecordListChangeable);

        // set remaining quantity
        qtyRemain -=_inventQty;

        // subtract: reduce pegging quantities; starting with the changeable kanbans
        qtyRemain += substractPeggingQty(_kanbanRecordListChangeable,true);
        qtyRemain += substractPeggingQty(_kanbanRecordListChangeableWithCancel,true);
        qtyRemain += substractPeggingQty(_kanbanRecordListChangeable,false);
        qtyRemain += substractPeggingQty(_kanbanRecordListChangeableWithCancel,false);
        qtyRemain += substractPeggingQty(_kanbanRecordListUnchangeable,false);

        // step 2: apply the quantity distribution; reduce pegged and kanban quantities where allowed,
        // preferably kanbans that have not been planned yet

        // add pegging quantities
        qtyApplied += applyPeggingQty(_kanbanRecordListUnchangeable,true);
        qtyApplied += applyPeggingQty(_kanbanRecordListChangeableWithCancel,true);
        qtyApplied += applyPeggingQty(_kanbanRecordListChangeable,true);

        // align kanban quantities to pegging quantities where possible
        applyKanbanQty(_kanbanRecordListChangeable);
        applyKanbanQty(_kanbanRecordListChangeableWithCancel);
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateKanbanMore</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates event kanbans as a response to an increase in the event origin.
    /// </summary>
    /// <param name="_inventQty">
    ///    The required kanban quantity.
    /// </param>
    /// <param name="_totalQty">
    ///    The total quantity.
    /// </param>
    /// <param name="_totalMarkedQty">
    ///    The total marked quantity.
    /// </param>
    /// <param name="_kanbanRecordListChangeable">
    ///    A list of event kanbans that can be updated.
    /// </param>
    /// <param name="_kanbanRecordListChangeableWithCancel">
    ///    A list of event kanbans that can be updated after the kanban is cancelled.
    /// </param>
    /// <param name="_kanbanRecordListUnchangeable">
    ///    A list of event kanbans that cannot be changed.
    /// </param>
    /// <param name="_mapPegging">
    ///    A map of pegged kanbans and quantities.
    /// </param>
    /// <param name="_mapKanbanRuleMinMax">
    ///    A map of minimum and maximum quantities per kanban rule.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void updateKanbanMore(
        InventQty        _inventQty,
        InventQty        _totalQty,
        InventQty        _totalMarkedQty,
        KanbanRecordList _kanbanRecordListChangeable,
        KanbanRecordList _kanbanRecordListChangeableWithCancel,
        KanbanRecordList _kanbanRecordListUnchangeable,
        Map              _mapPegging,
        Map              _mapKanbanRuleMinMax)
    {
        Kanban              kanbanInList;
        ReqEventKanbanData  reqEventKanbanData;
        boolean             kanbanRecordListNext;
        InventQty           qtyRemain      = _inventQty - _totalQty;
        InventQty           totalQty       = _totalQty;
        InventQty           totalMarkedQty = _totalMarkedQty;

        // update pegging with increased quantities
        InventQty addPeggingQty(KanbanRecordList _kanbanRecordList)
        {
            InventQty   qtyNow;
            InventQty   addedQty;
            InventQty   addedQtyTotal;

            kanbanRecordListNext = _kanbanRecordList.first(kanbanInList);
            while (    kanbanInList
                    && kanbanRecordListNext
                    && qtyRemain - addedQtyTotal > 0)
            {
                reqEventKanbanData = _mapPegging.lookup(kanbanInList.RecId);
                qtyNow             = min(qtyRemain - addedQtyTotal,reqEventKanbanData.jobQuantity() - reqEventKanbanData.parmPeggedQty());
                if (qtyNow > 0)
                {
                    [addedQty,totalQty,totalMarkedQty] = this.updateOneKanban(
                                                                kanbanInList,
                                                                reqEventKanbanData,
                                                                qtyNow,
                                                                false,
                                                                true,
                                                                totalQty,
                                                                totalMarkedQty);

                    addedQtyTotal += addedQty;
                }

                kanbanRecordListNext = _kanbanRecordList.next(kanbanInList);
            }

            return addedQtyTotal;
        }

        // update kanban and pegging with increased quantities
        InventQty addKanbanQty(KanbanRecordList _kanbanRecordList)
        {
            InventQty   qtyNow;
            InventQty   addedQty;
            InventQty   addedQtyTotal;
            InventQty   qtyNowMax;
            InventQty   minQty;
            InventQty   maxQty;

            kanbanRecordListNext = _kanbanRecordList.first(kanbanInList);
            while (    kanbanInList
                    && kanbanRecordListNext
                    && qtyRemain - addedQtyTotal > 0)
            {
                reqEventKanbanData = _mapPegging.lookup(kanbanInList.RecId);
                [minQty,maxQty]    = _mapKanbanRuleMinMax.lookup(kanbanInList.KanbanRule);
                qtyNowMax          = maxQty > 0 ? maxQty - reqEventKanbanData.jobQuantity() : qtyRemain - addedQtyTotal;
                qtyNow             = min(qtyRemain - addedQtyTotal,max(0,qtyNowMax));

                if (qtyNow > 0)
                {
                    [addedQty,totalQty,totalMarkedQty] = this.updateOneKanban(
                                                                kanbanInList,
                                                                reqEventKanbanData,
                                                                qtyNow,
                                                                true,
                                                                true,
                                                                totalQty,
                                                                totalMarkedQty);

                    addedQtyTotal += addedQty;
                }

                kanbanRecordListNext = _kanbanRecordList.next(kanbanInList);
            }

            return addedQtyTotal;
        }

        ttsbegin;
        if (qtyRemain > 0)
        {
            // add pegging to kanbans with 'free' quantities
            qtyRemain -= addPeggingQty(_kanbanRecordListUnchangeable);
            qtyRemain -= addPeggingQty(_kanbanRecordListChangeableWithCancel);
            qtyRemain -= addPeggingQty(_kanbanRecordListChangeable);
        }

        if (qtyRemain > 0)
        {
            // update existing kanbans
            qtyRemain -= addKanbanQty(_kanbanRecordListChangeable);
            qtyRemain -= addKanbanQty(_kanbanRecordListChangeableWithCancel);
        }

        if (qtyRemain > 0)
        {
            // still need more, create new kanbans
            if (   kanbanRule
                && kanbanRuleEvent)
            {
                // the remaining quantity must meet the minimum event quantity requirement
                if (qtyRemain >= kanbanRuleEvent.MinimumEventQuantity)
                {
                    [totalQty,totalMarkedQty] = this.insertKanban(qtyRemain,totalQty,totalMarkedQty);
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOneKanban</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the pegging and/or ordered quantities for a given kanban.
    /// </summary>
    /// <param name="_kanban">
    ///    The <c>Kanban</c> record to update.
    /// </param>
    /// <param name="_reqEventKanbanData">
    ///    A <c>ReqEventKanbanData</c> class instance that holds pegging information about the kanban.
    /// </param>
    /// <param name="_adjustQty">
    ///    The quantity change; positive for quantity increase, negative for quantity decrease.
    /// </param>
    /// <param name="_allowUpdateKanban">
    ///    A Boolean flag that indicates whether the kanban ordered quantity can be updated.
    /// </param>
    /// <param name="_allowUpdatePegging">
    ///    A Boolean flag that indicates whether the pegging quantity can be updated.
    /// </param>
    /// <param name="_totalQty">
    ///    The total quantity.
    /// </param>
    /// <param name="_totalMarkedQty">
    ///    The total marked quantity.
    /// </param>
    /// <returns>
    ///    A container with the changed quantity, total quantity and total marked quantity.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected container updateOneKanban(
        Kanban             _kanban,
        ReqEventKanbanData _reqEventKanbanData,
        InventQty          _adjustQty,
        boolean            _allowUpdateKanban,
        boolean            _allowUpdatePegging,
        InventQty          _totalQty,
        InventQty          _totalMarkedQty)
    {
        InventQty       addedOrSubstractedQty;
        InventQty       totalQty       = _totalQty;
        InventQty       totalMarkedQty = _totalMarkedQty;

        if (_adjustQty > 0)
        {
            [addedOrSubstractedQty,totalQty,totalMarkedQty] = this.updateOneKanbanMore(
                                                                        _kanban,
                                                                        _reqEventKanbanData,
                                                                        _adjustQty,
                                                                        _allowUpdateKanban,
                                                                        _allowUpdatePegging,
                                                                        _totalQty,
                                                                        _totalMarkedQty);
        }
        else
        {
            [addedOrSubstractedQty,totalQty,totalMarkedQty] = this.updateOneKanbanLess(
                                                                        _kanban,
                                                                        _reqEventKanbanData,
                                                                        _adjustQty,
                                                                        _allowUpdateKanban,
                                                                        _allowUpdatePegging,
                                                                        _totalQty,
                                                                        _totalMarkedQty);
        }

        return [addedOrSubstractedQty,totalQty,totalMarkedQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOneKanbanLess</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reduces the pegging and/or ordered quantities for a given kanban.
    /// </summary>
    /// <param name="_kanban">
    ///    The <c>Kanban</c> record to update.
    /// </param>
    /// <param name="_reqEventKanbanData">
    ///    A <c>ReqEventKanbanData</c> class instance that holds pegging information about the kanban.
    /// </param>
    /// <param name="_adjustQty">
    ///    The quantity change.
    /// </param>
    /// <param name="_allowUpdateKanban">
    ///    A Boolean flag that indicates whether the kanban ordered quantity can be updated.
    /// </param>
    /// <param name="_allowUpdatePegging">
    ///    A Boolean flag that indicates whether the pegging quantity can be updated.
    /// </param>
    /// <param name="_totalQty">
    ///    The total quantity.
    /// </param>
    /// <param name="_totalMarkedQty">
    ///    The total marked quantity.
    /// </param>
    /// <returns>
    ///    A container with the changed quantity, total quantity and total marked quantity.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected container updateOneKanbanLess(
        Kanban             _kanban,
        ReqEventKanbanData _reqEventKanbanData,
        InventQty          _adjustQty,
        boolean            _allowUpdateKanban,
        boolean            _allowUpdatePegging,
        InventQty          _totalQty,
        InventQty          _totalMarkedQty)
    {
        Kanban          kanban;
        KanbanJob       kanbanJob;
        InventQty       substractedQty;
        InventQty       orderedQty;
        boolean         canUpdate;
        boolean         mustAutoPlan;
        InventQty       totalQty       = _totalQty;
        InventQty       totalMarkedQty = _totalMarkedQty;
        InventQty       qtyRemain      = _adjustQty;
        InventQty       qtyNow;

        ttsbegin;

        if (   _kanban
            && _reqEventKanbanData
            && qtyRemain < 0)
        {
            kanban    = Kanban::find(_kanban.RecId,true);
            kanbanJob = _reqEventKanbanData.parmKanbanJob();

            if (   kanban
                && kanbanJob)
            {
                if (_allowUpdateKanban)
                {
                    [canUpdate,mustAutoPlan] = this.cancelKanbanIfRequiredAndAllowed(_reqEventKanbanData,kanban,kanbanJob);

                    if (canUpdate)
                    {
                        if (kanban.QuantityOrdered + qtyRemain <= 0)
                        {
                            qtyNow = -_reqEventKanbanData.parmPeggedQty();

                            // delete
                            if (_allowUpdatePegging)
                            {
                                [totalQty,totalMarkedQty] = this.updatePeggingMarkingReservation(
                                                                    _reqEventKanbanData,
                                                                    0,
                                                                    0,
                                                                    qtyNow,
                                                                    totalQty,
                                                                    totalMarkedQty);
                            }

                            kanban.delete();
                            this.addResultMap(mapDeletedKanban,kanban.KanbanRule,kanban.RecId);

                            qtyRemain      -= qtyNow;
                            substractedQty += qtyNow;
                        }
                        else
                        {
                            // update

                            orderedQty = kanban.QuantityOrdered;
                            qtyNow     = qtyRemain;

                            // update pegging, marking and reservation
                            if (_allowUpdatePegging)
                            {
                                [totalQty,totalMarkedQty] = this.updatePeggingMarkingReservation(
                                                                    _reqEventKanbanData,
                                                                    orderedQty + qtyNow,
                                                                    _reqEventKanbanData.parmPeggedQty() + qtyNow,
                                                                    qtyNow,
                                                                    totalQty,
                                                                    totalMarkedQty);
                            }

                            // if the quantity is decreased, update the kanban receipt after, so that
                            // this class controls which markings and reservations get removed.
                            kanban.QuantityOrdered += qtyNow;
                            kanban.update();
                            this.addResultMap(mapUpdatedKanban,kanban.KanbanRule,kanban.RecId);

                            qtyRemain      -= qtyNow;
                            substractedQty += qtyNow;
                        }

                        if (mustAutoPlan)
                        {
                            kanban = Kanban::find(kanban.RecId,true);
                            if (kanban)
                            {
                                KanbanJobAutoPlan::newKanban(kanban).run();
                            }
                        }
                    }
                }

                if (_allowUpdatePegging)
                {
                    if (qtyRemain < 0)
                    {
                        qtyNow = max(-_reqEventKanbanData.parmPeggedQty(),qtyRemain);

                        if (qtyNow < 0)
                        {
                            [totalQty,totalMarkedQty] = this.updatePeggingMarkingReservation(
                                                                _reqEventKanbanData,
                                                                _reqEventKanbanData.jobQuantity(),
                                                                _reqEventKanbanData.parmPeggedQty() + qtyNow,
                                                                qtyNow,
                                                                totalQty,
                                                                totalMarkedQty);
                        }

                        qtyRemain      -= qtyNow;
                        substractedQty += qtyNow;
                    }
                }
            }
        }

        ttscommit;

        return [substractedQty,totalQty,totalMarkedQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOneKanbanMore</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Increases the pegging and/or ordered quantities for a given kanban.
    /// </summary>
    /// <param name="_kanban">
    ///    The <c>Kanban</c> record to update.
    /// </param>
    /// <param name="_reqEventKanbanData">
    ///    A <c>ReqEventKanbanData</c> class instance that holds pegging information about the kanban.
    /// </param>
    /// <param name="_adjustQty">
    ///    The quantity change.
    /// </param>
    /// <param name="_allowUpdateKanban">
    ///    A Boolean flag that indicates whether the kanban ordered quantity can be updated.
    /// </param>
    /// <param name="_allowUpdatePegging">
    ///    A Boolean flag that indicates whether the pegging quantity can be updated.
    /// </param>
    /// <param name="_totalQty">
    ///    The total quantity.
    /// </param>
    /// <param name="_totalMarkedQty">
    ///    The total marked quantity.
    /// </param>
    /// <returns>
    ///    A container with the changed quantity, total quantity and total marked quantity.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected container updateOneKanbanMore(
        Kanban             _kanban,
        ReqEventKanbanData _reqEventKanbanData,
        InventQty          _adjustQty,
        boolean            _allowUpdateKanban,
        boolean            _allowUpdatePegging,
        InventQty          _totalQty,
        InventQty          _totalMarkedQty)
    {
        Kanban          kanban;
        KanbanJob       kanbanJob;
        boolean         canUpdate;
        boolean         mustAutoPlan;
        InventQty       qtyNow;
        InventQty       addedQty;
        InventQty       totalQty       = _totalQty;
        InventQty       totalMarkedQty = _totalMarkedQty;
        InventQty       qtyRemain      = _adjustQty;

        ttsbegin;

        if (   _kanban
            && _reqEventKanbanData
            && qtyRemain > 0)
        {
            kanban    = Kanban::find(_kanban.RecId,true);
            kanbanJob = _reqEventKanbanData.parmKanbanJob();

            if (   kanban
                && kanbanJob)
            {
                if (_allowUpdatePegging)
                {
                    // add pegging, if possible
                    qtyNow = max(0,_reqEventKanbanData.jobQuantity() - _reqEventKanbanData.parmPeggedQty());
                    qtyNow = min(qtyNow,qtyRemain);

                    if (qtyNow > 0)
                    {
                        [totalQty,totalMarkedQty] = this.updatePeggingMarkingReservation(
                                                            _reqEventKanbanData,
                                                            _reqEventKanbanData.jobQuantity(),
                                                            _reqEventKanbanData.parmPeggedQty() + qtyNow,
                                                            qtyNow,
                                                            totalQty,
                                                            totalMarkedQty);
                    }

                    qtyRemain -= qtyNow;
                    addedQty  += qtyNow;
                }

                if (qtyRemain > 0)
                {
                    if (_allowUpdateKanban)
                    {
                        [canUpdate,mustAutoPlan] = this.cancelKanbanIfRequiredAndAllowed(_reqEventKanbanData,kanban,kanbanJob);

                        if (canUpdate)
                        {
                            qtyNow = qtyRemain;

                            // if the quantity is increased, update the kanban receipt first, so that
                            // the quantities become available for marking and reservation
                            kanban.QuantityOrdered += qtyNow;
                            kanban.update();
                            this.addResultMap(mapUpdatedKanban,kanban.KanbanRule,kanban.RecId);

                            if (_allowUpdatePegging)
                            {
                                // update pegging, marking and reservation
                                [totalQty,totalMarkedQty] = this.updatePeggingMarkingReservation(
                                                                    _reqEventKanbanData,
                                                                    kanban.QuantityOrdered + qtyNow,
                                                                    _reqEventKanbanData.parmPeggedQty() + qtyNow,
                                                                    qtyNow,
                                                                    totalQty,
                                                                    totalMarkedQty);
                            }

                            if (mustAutoPlan)
                            {
                                kanban = Kanban::find(kanban.RecId,true);
                                if (kanban)
                                {
                                    KanbanJobAutoPlan::newKanban(kanban).run();
                                }
                            }

                            addedQty += qtyNow;
                        }
                    }
                }
            }
        }

        ttscommit;

        return [addedQty,totalQty,totalMarkedQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePeggingMarkingReservation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates pegging, marking and reservation.
    /// </summary>
    /// <param name="_reqEventKanbanData">
    ///    A <c>ReqEventKanbanData</c> class instance that holds pegging information about the kanban.
    /// </param>
    /// <param name="_supplyQty">
    ///    The supply quantity.
    /// </param>
    /// <param name="_peggedQty">
    ///    The pegged quantity.
    /// </param>
    /// <param name="_peggedQtyNow">
    ///    The quantity that is pegged now.
    /// </param>
    /// <param name="_totalQty">
    ///    The total quantity.
    /// </param>
    /// <param name="_totalMarkQty">
    ///    The total marked quantity.
    /// </param>
    /// <returns>
    ///    A container with the total quantity and total marked quantity.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected container updatePeggingMarkingReservation(
        ReqEventKanbanData _reqEventKanbanData,
        InventQty          _supplyQty,
        InventQty          _peggedQty,
        InventQty          _peggedQtyNow,
        InventQty          _totalQty,
        InventQty          _totalMarkQty)
    {
        InventQty   markQty;
        InventQty   totalQty     = _totalQty;
        InventQty   totalMarkQty = _totalMarkQty;

        if (   _reqEventKanbanData
            && _reqEventKanbanData.parmKanban()
            && _reqEventKanbanData.parmKanbanJob())
        {
            // pegging
            this.writePegging(
                        _reqEventKanbanData.receiptSourceDocumentLine(),
                        _supplyQty,
                        this.unitOfMeasureRecId(),
                        _peggedQty,
                        this.unitOfMeasureRecId(),
                        this.mustMarkInventoryTransactions(),
                        this.peggingType());

            // total
            totalQty += _peggedQtyNow;

            // marking
            markQty       = _peggedQty - this.qtyMarked(_reqEventKanbanData.receiptInventTransOriginId());
            totalMarkQty += this.markInventoryTransactions(
                                        _reqEventKanbanData.parmKanban(),
                                        _reqEventKanbanData.parmKanbanJob(),
                                        markQty,
                                        _reqEventKanbanData.receiptInventTransOriginId());

            // reservation
            this.reserveInventoryTransactions(_peggedQtyNow);

            // update data object
            _reqEventKanbanData.parmPeggedQty(_peggedQty);
        }

        return [totalQty,totalMarkQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelKanban</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels a kanban if it has not been assigned and none of its jobs are in progress or completed.
    /// </summary>
    /// <param name="_kanban">
    /// The kanban to cancel.
    /// </param>
    /// <param name="_silentErrors">
    /// A Boolean value that defines if infolog messages are given when there are errors; optional.
    /// </param>
    /// <param name="_silentSuccess">
    /// A Boolean value that defines if infolog messages are given when the operation is successful; optional.
    /// </param>
    /// <param name="_lastKanbanJob">
    /// The last kanban job of the kanban to cancel; optional.
    /// </param>
    /// <returns>
    /// true if the kanban was cancelled; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean cancelKanban(
        Kanban    _kanban,
        boolean   _silentErrors         = false,
        boolean   _silentSuccess        = false,
        KanbanJob _lastKanbanJob = null)
    {
        KanbanJob           kanbanJobCancel;
        KanbanJobStatus     kanbanJobStatus;
        int                 jobsToCancel;
        boolean             result = true;

        kanbanJobCancel = _lastKanbanJob ? _lastKanbanJob : _kanban.lastKanbanJob();

        if (   _kanban.Status         == LeanKanbanStatus::NotAssigned
            && kanbanJobCancel.Status <= LeanKanbanJobStatus::Planned
            && !kanbanJobCancel.existPreviousJobGreaterStatus(LeanKanbanJobStatus::Planned))
        {
            //cancel
            while (kanbanJobCancel)
            {
                if (kanbanJobCancel.Status != LeanKanbanJobStatus::NotPlanned)
                {
                    jobsToCancel++;
                    kanbanJobStatus = kanbanJobCancel.status();
                    if (kanbanJobStatus.isStatusResetAllowed(LeanKanbanJobStatus::NotPlanned))
                    {
                        kanbanJobStatus.runReset(LeanKanbanJobStatus::NotPlanned);
                        kanbanJobCancel = KanbanJob::find(kanbanJobCancel.RecId);
                    }

                    if (kanbanJobCancel.Status != LeanKanbanJobStatus::NotPlanned)
                    {
                        result = _silentErrors ? false : checkFailed(strFmt("@SYS319610",kanbanJobCancel.PlanActivityName,kanbanJobCancel.kanban().KanbanId));
                        break;
                    }
                }
                kanbanJobCancel = kanbanJobCancel.previousJob();
            }
            if (   result
                && jobsToCancel
                && !_silentSuccess)
            {
                info(strFmt("@SYS319614",_kanban.KanbanId));
            }
        }
        else
        {
            result = _silentErrors ? false : checkFailed(strFmt("@SYS319615",_kanban.KanbanId,_kanban.Status));
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHaveEventKanban</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks, if a given table buffer can possibly have event kanbans.
    /// </summary>
    /// <param name="_common">
    ///    A <c>Common</c> table buffer.
    /// </param>
    /// <returns>
    ///    true if the table buffer can possibly have associated event kanbans
    /// </returns>
    /// <remarks>
    ///    The method performs a quick check to determine if event kanbans can possibly be associated to the table buffer.
    ///    The association can be direct, for example for sales lines or indirect, for example for a process kanban job that may
    ///    have a picking list line and the picking list line may have an event kanban.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean canHaveEventKanban(Common _common)
    {
        KanbanRule      kanbanRule;
        KanbanRuleEvent kanbanRuleEvent;
        KanbanJob       kanbanJob;
        Kanban          kanban;
        boolean         result;

        // existing record and configuration key enabled
        result =    _common.RecId
                 && isConfigurationkeyEnabled(configurationKeyNum(LeanManufacturing));

        if (result)
        {
            switch (_common.TableId)
            {
                case tableNum(SalesLine):
                case tableNum(ProdBOM):
                case tableNum(KanbanJobPickingList):
                    result = true;
                    break;
                case tableNum(Kanban):
                    // check picking list and first job
                    kanban = _common as Kanban;
                    result =    kanban.type().canHaveBOM()
                             || ReqEventProcessKanban::canHaveEventKanban(kanban.firstKanbanJob());
                    break;
                case tableNum(KanbanJob):
                    // check picking list and job itself
                    kanbanJob = _common as KanbanJob;
                    result    = kanbanJob.type().canHaveBOM()
                                || (!kanbanJob.existPreviousJob()
                                &&  (kanbanJob.Type == LeanKanbanJobType::Transfer
                                ||   kanbanJob.leanProductionFlowActivity().PickUpSemiFinished));
                    break;
                case tableNum(KanbanRule):
                    kanbanRule      = _common as KanbanRule;
                    kanbanRuleEvent = KanbanRuleEvent::findKanbanRule(kanbanRule.RecId);
                    result          =   kanbanRuleEvent.RecId != 0
                                     && kanbanRuleEvent.StockReplenishmentEvent != KanbanStockReplenishmentEventType::NotActive;
                    break;
                default:
                    result = false;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSupplyPegging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the pegging supply and pegging assignment records of a kanban.
    /// </summary>
    /// <param name="_kanban">
    /// The kanban to delete the pegging from.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static void deleteSupplyPegging(Kanban _kanban)
    {
        KanbanJob                   lastKanbanJob;
        SourceDocumentLineRefRecId  kanbanSourceDocumentLine;

        if (_kanban.kanbanRule().ReplenishmentStrategy == LeanReplenishmentStrategy::Event)
        {
            lastKanbanJob            = _kanban.lastKanbanJob();
            kanbanSourceDocumentLine = lastKanbanJob.receiptSourceDocumentLine();

            ttsbegin;
            ReqEventProcess::deleteReqPegging(0, kanbanSourceDocumentLine);
            ReqEventProcess::deleteReqPeggingEvent(kanbanSourceDocumentLine);
            ReqEventProcess::deleteReqPeggingAssignment(kanbanSourceDocumentLine);
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        if (_args && _args.record())
        {
            ReqEventProcessKanban::newStandard(_args.record(), true).runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromBatch</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of a <c>ReqEventProcessKanban</c> object.
    /// </summary>
    /// <param name="_common">
    ///    A <c>Common</c> table buffer to use for the instantiation.
    /// </param>
    /// <param name="_limitToKanbanRuleRefRecId">
    ///    A record ID for the <c>KanbanRule</c> table buffer that is used to limit kanban rules that are
    ///    processed.
    /// </param>
    /// <param name="_limitToPlanReferenceRefRecId">
    ///    A record ID for the <c>PlanReference</c> table buffer that is used to limit kanban rules that are
    ///    processed.
    /// </param>
    /// <param name="_limitToLastPlanActivityRefRecId">
    ///    A record ID for the <c>PlanActivity</c> table buffer that is used to limit kanban rules that are
    ///    processed.
    /// </param>
    /// <param name="_mustDeleteEvent">
    ///    A Boolean value that specifies whether to delete the event after it processes.
    /// </param>
    /// <param name="_reqEventProcessParm">
    ///    A <c>ReqEventProcessParm</c> class instance; optional.
    /// </param>
    /// <returns>
    ///    A <c>ReqEventProcessKanban</c> object.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The table buffer is not valid for instantiation of this class.
    /// </exception>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static ReqEventProcessKanban newFromBatch(
        Common                _common,
        KanbanRuleRefRecId    _limitToKanbanRuleRefRecId       = 0,
        PlanReferenceRefRecId _limitToPlanReferenceRefRecId    = 0,
        PlanActivityRefRecId  _limitToLastPlanActivityRefRecId = 0,
        boolean               _mustDeleteEvent                 = false,
        ReqEventProcessParm   _reqEventProcessParm             = null)
    {
        ReqEventProcessKanban   reqEventProcessKanban;
        KanbanRule              kanbanRule;
        KanbanRuleEvent         kanbanRuleEvent;

        if (isConfigurationkeyEnabled(configurationKeyNum(LeanManufacturing)))
        {
            switch (_common.TableId)
            {
                case tableNum(SalesLine):
                    reqEventProcessKanban = ReqEventProcessKanbanSalesLine::newStandard(_common,false);
                    break;
                case tableNum(ProdBOM):
                    reqEventProcessKanban = ReqEventProcessKanbanProdBOM::newStandard(_common,false);
                    break;
                case tableNum(KanbanJob):
                    reqEventProcessKanban = ReqEventProcessKanbanJobIssue::newStandard(_common,false);
                    break;
                case tableNum(KanbanJobPickingList):
                    reqEventProcessKanban = ReqEventProcessKanbanJobPickList::newStandard(_common,false);
                    break;
                case tableNum(KanbanRule):
                    kanbanRule      = _common;
                    kanbanRuleEvent = KanbanRuleEvent::findKanbanRule(kanbanRule.RecId);
                    if (kanbanRuleEvent.StockReplenishmentEvent != KanbanStockReplenishmentEventType::NotActive)
                    {
                        reqEventProcessKanban = ReqEventProcessKanbanReplenishment::newStandard(_common);
                    }
                    break;
            }
        }
        else
        {
            reqEventProcessKanban = ReqEventProcessKanbanNull::newStandard();
        }

        if (!reqEventProcessKanban)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (_reqEventProcessParm)
        {
            reqEventProcessKanban.parmReqEventProcessParm(_reqEventProcessParm);
        }
        else
        {
            reqEventProcessKanban.parmReqEventProcessParm(ReqEventProcessParm::newReqPeggingEvent(null));
        }

        reqEventProcessKanban.parmLimitToPKanbanRuleRefRecId(_limitToKanbanRuleRefRecId);
        reqEventProcessKanban.parmLimitToPlanReferenceRefRecId(_limitToPlanReferenceRefRecId);
        reqEventProcessKanban.parmLimitToLastPlanActivityRefRecId(_limitToLastPlanActivityRefRecId);
        reqEventProcessKanban.parmMustDeleteEvent(_mustDeleteEvent);
        reqEventProcessKanban.parmForceProcessNow(true);
        reqEventProcessKanban.parmSetEventDescription(true);

        return reqEventProcessKanban;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newStandard</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of a <c>ReqEventProcessKanban</c> object.
    /// </summary>
    /// <param name="_common">
    ///    A <c>Common</c> table buffer to use to create the object.
    /// </param>
    /// <param name="_interactive">
    ///    A Boolean value that specifies whether the class was called from a form.
    /// </param>
    /// <param name="_skipRuleMayExistCheck">
    ///    A Boolean value that specifies whether to skip the quick check when finding kanban rules.
    /// </param>
    /// <param name="_reqEventProcessParm">
    ///    A <c>ReqEventProcessParm</c> class instance; optional.
    /// </param>
    /// <returns>
    ///    A <c>ReqEventProcessKanban</c> object.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The table buffer is not valid to use to create of this class.
    /// </exception>
    public static ReqEventProcessKanban newStandard(
        Common              _common,
        boolean             _interactive           = false,
        boolean             _skipRuleMayExistCheck = false,
        ReqEventProcessParm _reqEventProcessParm   = null)
    {
        ReqEventProcessKanban   reqEventProcessKanban;

        reqEventProcessKanban = ReqEventProcessKanban::newFromCommon(_common, _interactive);

        if (!reqEventProcessKanban)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (_reqEventProcessParm)
        {
            reqEventProcessKanban.parmReqEventProcessParm(_reqEventProcessParm);
        }
        else if (!(reqEventProcessKanban is ReqEventProcessKanbanNull))
        {
            reqEventProcessKanban.parmReqEventProcessParm(ReqEventProcessParm::newInventMovement(reqEventProcessKanban.inventMovement()));
        }

        reqEventProcessKanban.parmMustDeleteEvent(true);
        reqEventProcessKanban.parmSkipRuleMayExistCheck(_skipRuleMayExistCheck);
        reqEventProcessKanban.parmSetEventDescription(false);

        return reqEventProcessKanban;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeInventDimFromProductFamily</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected InventDimId mergeInventDimFromProductFamily()
    {
        InventDim inventDim = InventDim::find(inventDimId);
        InventDim inventDimProdcutFamily = InventDim::find(productFamilyInventDimId);

        inventDim.initFromInventDim(inventDimProdcutFamily, InventDim::dimProductDimensionEnabledFieldList());
        inventDim = InventDim::findOrCreate(inventDim);
        return inventDim.inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProductFamilyInventDimId</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public InventDimId parmProductFamilyInventDimId(InventDimId _productFamilyInventDimId = productFamilyInventDimId)
    {
        productFamilyInventDimId = _productFamilyInventDimId;
        return productFamilyInventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProductFamilyItemId</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public ItemId parmProductFamilyItemId(ItemId _productFamilyItemId = productFamilyItemId)
    {
        productFamilyItemId = _productFamilyItemId;
        return productFamilyItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromCommon</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Creates a new instance of a <c>ReqEventProcessKanban</c> object.
    /// </summary>
    /// <param name = "_common">
    ///		A <c>Common</c> table buffer to use to create the object.
    /// </param>
    /// <param name = "_interactive">
    ///		A boolean value that specifies whether the class was called from a form.
    /// </param>
    /// <returns>
    ///		An instance of <c>ReqEventProcessKanban</c>.
    /// </returns>
    protected static ReqEventProcessKanban newFromCommon(
        Common              _common,
        boolean             _interactive           = false)
    {
        ReqEventProcessKanban   reqEventProcessKanban;

        if (isConfigurationkeyEnabled(configurationKeyNum(LeanManufacturing)))
        {
            switch (_common.TableId)
            {
                case tableNum(SalesLine):
                    reqEventProcessKanban = ReqEventProcessKanbanSalesLine::newStandard(_common,_interactive);
                    break;
                case tableNum(ProdBOM):
                    reqEventProcessKanban = ReqEventProcessKanbanProdBOM::newStandard(_common,_interactive);
                    break;
                case tableNum(KanbanJob):
                    reqEventProcessKanban = ReqEventProcessKanbanJobIssue::newStandard(_common,_interactive);
                    break;
                case tableNum(KanbanJobPickingList):
                    reqEventProcessKanban = ReqEventProcessKanbanJobPickList::newStandard(_common,_interactive);
                    break;
                case tableNum(KanbanRule):
                    KanbanRule          kanbanRule      = _common;
                    KanbanRuleEvent     kanbanRuleEvent = KanbanRuleEvent::findKanbanRule(kanbanRule.RecId);
                    if (kanbanRuleEvent.StockReplenishmentEvent != KanbanStockReplenishmentEventType::NotActive)
                    {
                        reqEventProcessKanban = ReqEventProcessKanbanReplenishment::newStandard(_common);
                    }
                    break;
            }
        }
        else
        {
            reqEventProcessKanban = ReqEventProcessKanbanNull::newStandard();
        }

        return reqEventProcessKanban;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>