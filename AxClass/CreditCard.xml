<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CreditCard</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The CreditCard class is a collection of static method for credit card implementation.
/// </summary>
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;
using Retail = Microsoft.Dynamics.Retail;
using RetailConst = Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants;

public class CreditCard
{
    #CreditCard

    internal static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

    private const boolean Decrypt = false;
    public static CreditCard_ExtendedParameters extendedParameters = CreditCard_ExtendedParameters::construct();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addCreditCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a new credit card to the <c>CreditCardCust</c> table.
    /// </summary>
    /// <param name="_xmlString">
    /// A string containing the XML for the properties of the new record.
    /// </param>
    /// <param name="_custAccount">
    /// The customer account with which the new record is associated.
    /// </param>
    /// <param name="_processorId">
    /// The processor the credit card.
    /// </param>
    /// <returns>
    /// The newly created record.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Indicates the processor was not found.
    /// </exception>
    public static CreditCardCust addCreditCard(str _xmlString, CustAccount _custAccount, CreditCardProcessorsId _processorId)
    {
        var properties = CreditCardPaymentProperties::fromXmlString(_xmlString);
        str ns = RetailConst.GenericNamespace::get_PaymentCard();
        CreditCardCust creditCardCust;

        ttsbegin;
        creditCardCust.clear();
        creditCardCust.UniqueCardId = properties.find(ns, RetailConst.PaymentCardProperties::get_UniqueCardId()).parmStringValue();

        var cardNumberProperty = properties.find(ns, RetailConst.PaymentCardProperties::get_Last4Digits());
        if (cardNumberProperty != null)
        {
            creditCardCust.CardNumber = cardNumberProperty.parmStringValue();
        }

        creditCardCust.CardToken = properties.toXmlString();
        creditCardCust.CustAccount = _custAccount;
        var property = properties.find(RetailConst.GenericNamespace::get_PaymentCard(), RetailConst.PaymentCardProperties::get_Name());
        creditCardCust.Name = property ? property.parmStringValue() : '';
        creditCardCust.ExpiryDate = strFmt("%1/%2",
                any2int(properties.find(ns, RetailConst.PaymentCardProperties::get_ExpirationMonth()).parmDecimalValue()),
                any2int(properties.find(ns, RetailConst.PaymentCardProperties::get_ExpirationYear()).parmDecimalValue()));
        creditCardCust.CreditCardTypeName = properties.find(ns, RetailConst.PaymentCardProperties::get_CardType()).parmStringValue();
        creditCardCust.CreditCardProcessors = _processorId;
        if (!creditCardCust.CreditCardProcessors)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }
        property = properties.find(ns, #CreditCardPaymentCardPropertyName_Note);
        creditCardCust.Notes = property ? property.parmStringValue() : '';
        creditCardCust.insert();
        ttscommit;

        return creditCardCust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMerchantAccountProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds merchant account properties to a credit card property collection.
    /// </summary>
    /// <param name="_properties">
    /// A <c>CreditCardPaymentProperties</c> class instance.
    /// </param>
    /// <remarks>
    /// The parameter _properties must contain a property MerchantAccount.ServiceAccountId.
    /// The value of this property is looked up, in order, in the following tables:
    /// <list type="bullet">
    /// <item><description>CreditCardAccountSetup</description></item>
    /// <item><description>RetailHardwareProfile</description></item>
    /// <item><description>RetailChannelPaymentConnectorLine</description></item>
    /// </list>
    /// Where the Service Account ID is first found, the merchant account properties are added
    /// or updated in _properties.
    /// NOTE: A cache is utilized so changes to merchant account information should be followed by
    /// a call to the <c>CreditCard::clearMerchantAccountPropertiesCache</c> method.
    /// </remarks>
    /// <returns>
    /// The credit card connector name.
    /// </returns>
    public static CreditCardConnectorName addMerchantAccountProperties(CreditCardPaymentProperties _properties)
    {
        // Add or update properties in _destination from _source
        void mergeProperties(CreditCardPaymentProperties _destination, CreditCardPaymentProperties _source)
        {
            var srcEnum = _source.enumerator();

            while (srcEnum.moveNext())
            {
                CreditCardPaymentProperty sourceProperty = srcEnum.current();
                _destination.remove(sourceProperty.parmNamespace(), sourceProperty.parmName());
                _destination.add(sourceProperty);
            }
        }

        Debug::assert(_properties != null);

        var paymentAccountId = CreditCard::getPaymentAccountId(_properties);

        Debug::assert(strLen(paymentAccountId));

        CreditCardConnectorName connectorName;
        str propertiesAsXmlString;

        [propertiesAsXmlString, connectorName] = CreditCard::findMerchantAccountProperties(paymentAccountId);

        mergeProperties(_properties, CreditCardPaymentProperties::fromXmlString(propertiesAsXmlString));

        return connectorName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExpireDate</Name>
				<Source><![CDATA[
    static boolean checkExpireDate(str _expireMonthYear)
    {
        var parts = strSplit(_expireMonthYear, '/');
        var partsEnum = parts.getEnumerator();
        date expireDate = dateNull();

        if (parts.elements() == 2)
        {
            partsEnum.moveNext();
            str strMonth = partsEnum.current();
            partsEnum.moveNext();
            str strYear = partsEnum.current();
            var strExpireDate = strFmt('%1.%2.%3', 1, strMonth, strYear);
            expireDate = dateEndMth(str2Date(strExpireDate, 123));
        }

        return DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) <= expireDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearMerchantAccountPropertiesCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the merchant account properties cache used by the <c>CreditCard::addMerchantAccountProperties</c> method.
    /// </summary>
    public static void clearMerchantAccountPropertiesCache()
    {
        var cache = new SysGlobalObjectCache();

        cache.clear(#CreditCardMerchantAccountCacheScope);
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertAvsDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the internal address verification detail code corresponding to an external value.
    /// </summary>
    /// <param name="_avsResultStr">
    /// A string value from the <c>Microsoft.Dynamics.Retail.PaymentSDK.Portable.AVSDetail</c> enumeration.
    /// </param>
    /// <returns>
    /// The AVS detail code.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Indicates the value passed in was not recognized.
    /// </exception>
    public static CreditCardMSAVSDetailCode convertAvsDetail(str _avsResultStr)
    {
        str toStr(Retail.PaymentSDK.Portable.AVSDetail _value)
        {
            return System.Convert::ToString(_value);
        }

        if (_avsResultStr == toStr(Retail.PaymentSDK.Portable.AVSDetail::None))
            return CreditCardMSAVSDetailCode::None;
        else if (_avsResultStr == toStr(Retail.PaymentSDK.Portable.AVSDetail::AccountholderName))
            return CreditCardMSAVSDetailCode::AccountHolderName;
        else if (_avsResultStr == toStr(Retail.PaymentSDK.Portable.AVSDetail::BillingAddress))
            return CreditCardMSAVSDetailCode::BillingAddress;
        else if (_avsResultStr == toStr(Retail.PaymentSDK.Portable.AVSDetail::BillingPostalCode))
            return CreditCardMSAVSDetailCode::BillingPostalCode;
        else if (_avsResultStr == toStr(Retail.PaymentSDK.Portable.AVSDetail::BillingAndPostalCode))
            return CreditCardMSAVSDetailCode::BillingPostalCode;

        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertAvsResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the internal address verification result code corresponding to an external value.
    /// </summary>
    /// <param name="_avsResultStr">
    /// A string value from the <c>Microsoft.Dynamics.Retail.PaymentSDK.Portable.AVSResult</c> enumeration.
    /// </param>
    /// <returns>
    /// The AVS result.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Indicates the value passed in was not recognized.
    /// </exception>
    public static CreditCardAddressVerificationResult convertAvsResult(str _avsResultStr)
    {
        str toStr(Retail.PaymentSDK.Portable.AVSResult _value)
        {
            return System.Convert::ToString(_value);
        }

        if (_avsResultStr == toStr(Retail.PaymentSDK.Portable.AVSResult::None))
            return CreditCardAddressVerificationResult::None;
        else if (_avsResultStr == toStr(Retail.PaymentSDK.Portable.AVSResult::NotReturned))
            return CreditCardAddressVerificationResult::NotReturned;
        else if (_avsResultStr == toStr(Retail.PaymentSDK.Portable.AVSResult::Returned))
            return CreditCardAddressVerificationResult::Returned;
        else if (_avsResultStr == toStr(Retail.PaymentSDK.Portable.AVSResult::SystemUnavailable))
            return CreditCardAddressVerificationResult::SystemUnavailable;
        else if (_avsResultStr == toStr(Retail.PaymentSDK.Portable.AVSResult::VerificationNotSupported))
            return CreditCardAddressVerificationResult::VerificationNotSupported;

        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertCvcResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the internal credit card verification code result corresponding to an external value.
    /// </summary>
    /// <param name="_cvvResultStr">
    /// A string value from the <c>Microsoft.Dynamics.Retail.PaymentSDK.Portable.CVV2Result</c> enumeration.
    /// </param>
    /// <returns>
    /// The CVV result.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Indicates the value passed in was not recognized.
    /// </exception>
    public static CreditCardMSCVCResultCode convertCvcResult(str _cvvResultStr)
    {
        str toStr(Retail.PaymentSDK.Portable.CVV2Result _value)
        {
            return System.Convert::ToString(_value);
        }

        // If CVC string is empty then return result code as Unknown.
        if (_cvvResultStr == '')
            return CreditCardMSCVCResultCode::Unknown;
        else if (_cvvResultStr == toStr(Retail.PaymentSDK.Portable.CVV2Result::Failure))
            return CreditCardMSCVCResultCode::Failure;
        else if (_cvvResultStr == toStr(Retail.PaymentSDK.Portable.CVV2Result::IssuerNotRegistered))
            return CreditCardMSCVCResultCode::IssuerNotRegistered;
        else if (_cvvResultStr == toStr(Retail.PaymentSDK.Portable.CVV2Result::NotProcessed))
            return CreditCardMSCVCResultCode::NotProcessed;
        else if (_cvvResultStr == toStr(Retail.PaymentSDK.Portable.CVV2Result::Success))
            return CreditCardMSCVCResultCode::Success;
        else if (_cvvResultStr == toStr(Retail.PaymentSDK.Portable.CVV2Result::Unknown))
            return CreditCardMSCVCResultCode::Unknown;

        throw error(strFmt("@Retail:UnsupportedCVVResult", _cvvResultStr));
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditCardNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the obscured credit card number.
    /// </summary>
    /// <param name="_recId">
    /// The <c>RecId</c> of a record in the <c>CreditCustCust</c> table.
    /// </param>
    /// <returns>
    /// A credit card number which reveals only the last few digits.
    /// </returns>
    public static CreditCardNumber creditCardNumber(RecId _recId)
    {
        return (select CardNumber from creditCardCust where creditCardCust.RecId == _recId).CardNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>expiryDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the expiration date of a credit card.
    /// </summary>
    /// <param name="_recId">
    /// The <c>RecId</c> of a record in the <c>CreditCustCust</c> table.
    /// </param>
    /// <returns>
    /// A credit card's expiration date.
    /// </returns>
    public static str expiryDate(RecId _recId)
    {
        return CreditCardCust::find(_recId).ExpiryDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findMerchantAccountProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the merchant properties for a given service account Id.
    /// </summary>
    /// <param name = "_paymentAccountId">The service account id.</param>
    /// <returns>A container with the Merchant properties and Connector name for the service account id.</returns>
    internal static container findMerchantAccountProperties(SysGuidString _paymentAccountId)
    {
        // Look at Accounts Receivable Processors for a matching Payment Account ID
        container findInCust(SysGuidString _localPaymentAccountId)
        {
            CreditCardProcessors creditCardProcessors;
            CreditCardAccountSetup creditCardAccountSetup;

            while select SecureMerchantProperties, ConnectorName
                from creditCardAccountSetup
                exists join creditCardProcessors
                    where creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors &&
                            !creditCardProcessors.NotUsed
            {
                var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
                var properties = CreditCardPaymentProperties::fromXmlString(merchant);

                if (_localPaymentAccountId == CreditCard::getPaymentAccountId(properties))
                {
                    return [merchant, creditCardAccountSetup.ConnectorName];
                }
            }
            return conNull();
        }

        // Look at Retail Hardware Profiles for a matching Payment Account ID
        container findInRetail(SysGuidString _localPaymentAccountId)
        {
            RetailHardwareProfile retailHardwareProfile;

            while select SecureMerchantProperties, EFTConnectorName, EFT
                from retailHardwareProfile
            {
                if (retailHardwareProfile.EFT == RetailExternalNone::PaymentSDK && retailHardwareProfile.SecureMerchantProperties)
                {
                    var merchant = appl.DecryptForPurpose(retailHardwareProfile.SecureMerchantProperties, CreditCardPaymentProperties::CryptoPurpose);
                    var properties = CreditCardPaymentProperties::fromXmlString(merchant);
                    var enum = properties.enumerator();

                    while (enum.moveNext())
                    {
                        CreditCardPaymentProperty property = enum.current();

                        // Check for multiple connectors.
                        if (property.parmNamespace() == RetailConst.GenericNamespace::get_Connector() && property.parmName() == RetailConst.ConnectorProperties::get_Properties())
                        {
                            var innerProperties = property.parmPropertyListValue();
                            if (_localPaymentAccountId == CreditCard::getPaymentAccountId(innerProperties))
                            {
                                return [innerProperties.toXmlString(), CreditCard::getConnectorName(innerProperties)];
                            }
                        }
                        else
                        {
                            if (_localPaymentAccountId == CreditCard::getPaymentAccountId(properties))
                            {
                                return [merchant, retailHardwareProfile.EFTConnectorName];
                            }
                        }
                    }
                }
            }
            return conNull();
        }

        // Look at SharePoint for a matching Payment Account ID
        container findInSharePoint(SysGuidString _localPaymentAccountId)
        {
            RetailChannelPaymentConnectorLine retailChannelPaymentConnectorLine;

            while select SecureMerchantProperties, PaymentConnectorName
                from retailChannelPaymentConnectorLine
            {
                if (retailChannelPaymentConnectorLine.SecureMerchantProperties)
                {
                    var merchant = appl.DecryptForPurpose(retailChannelPaymentConnectorLine.SecureMerchantProperties, CreditCardPaymentProperties::CryptoPurpose);
                    var properties = CreditCardPaymentProperties::fromXmlString(merchant);
                    
                    if (_localPaymentAccountId == CreditCard::getPaymentAccountId(properties))
                    {
                        return [merchant, retailChannelPaymentConnectorLine.PaymentConnectorName];
                    }
                }
            }
            return conNull();
        }

        var cache = new SysGlobalObjectCache();
        var cacheValue = cache.find(#CreditCardMerchantAccountCacheScope, [_paymentAccountId]);

        if (cacheValue == conNull())
        {
            cacheValue = findInCust(_paymentAccountId);

            if (cacheValue == conNull())
            {
                cacheValue = findInRetail(_paymentAccountId);
            }

            if (cacheValue == conNull())
            {
                cacheValue = findInSharePoint(_paymentAccountId);
            }

            if (cacheValue == conNull())
            {
                throw error(strFmt("@SYS4000965", _paymentAccountId));
            }

            cache.insert(#CreditCardMerchantAccountCacheScope, [_paymentAccountId], cacheValue);
        }

        return cacheValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentAccountId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Extract Service account Id from properties collection.
    /// </summary>
    /// <param name = "_properties">The properties collection.</param>
    /// <returns>A string with Service Account Id.</returns>
    internal static SysGuidString getPaymentAccountId(CreditCardPaymentProperties _properties)
    {
        var property = _properties.find(RetailConst.GenericNamespace::get_MerchantAccount(), RetailConst.MerchantAccountProperties::get_ServiceAccountId());

        return property ? property.parmStringValue() : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCreditCardWithTokenScope</Name>
				<Source><![CDATA[
    internal static CreditCardCust addCreditCardWithTokenScope(
        str _paymentPropertiesXml,
        CustAccount _custAccount,
        SalesTable _salesTable,
        CreditCardProcessorsId _processorId,
        RetailTokenScope _tokenScope,
        boolean _isExtensibilityEnabled = true)
    {
        CreditCardCust ccCust;
        RetailTokenScope tokenScopeValue = _tokenScope;
        boolean isTokenScopeOverridden = false;

        if (_isExtensibilityEnabled)
        {
            eventSource.EventWriteCallOnCreatingCreditCardExtension(_salesTable.RecId, enum2Str(tokenScopeValue));

            CreditCardExtensionParameters params  = CreditCardExtensionParameters::construct(
                _paymentPropertiesXml,
                _custAccount,
                _salesTable.RecId,
                _processorId,
                _tokenScope);

            CreditCardExtensions::onCreatingCreditCard(params);

            tokenScopeValue = params.getTokenScope();
            isTokenScopeOverridden = (tokenScopeValue != _tokenScope);
        }

        ttsbegin;
        ccCust = CreditCard::addCreditCard(_paymentPropertiesXml, _custAccount, _processorId);

        if (ccCust)
        {
            CreditCardCust::scopeCreditCardToken(ccCust.RecId, tokenScopeValue);
            ccCust.reread();
        }
        ttscommit;

        eventSource.EventWriteCreatedCreditCardWithTokenScope(ccCust.RecId, _salesTable.RecId, enum2Str(ccCust.TokenScope), isTokenScopeOverridden);

        return ccCust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getConnectorName</Name>
				<Source><![CDATA[
    private static str getConnectorName(CreditCardPaymentProperties _properties)
    {
        var property = _properties.find(RetailConst.GenericNamespace::Connector, RetailConst.ConnectorProperties::ConnectorName);
        return property ? property.parmStringValue() : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCreditCardAuthTrans</Name>
				<Source><![CDATA[
    private static void initCreditCardAuthTrans(CreditCardAuthTrans _creditCardAuthTrans, CreditCardOperation _operation, CreditCardProcessorsId _processor, CreditCardApprovalRejectReason _description, boolean _succeeded, str _cardTokenRequest)
    {
        _creditCardAuthTrans.clear();
        _creditCardAuthTrans.initValue();
        _creditCardAuthTrans.ApprovalExpired = false;
        _creditCardAuthTrans.ApprovalVoid = false;
        _creditCardAuthTrans.ApprovedDateTime = DateTimeUtil::getSystemDateTime();
        _creditCardAuthTrans.ApprovalType = _operation;
        _creditCardAuthTrans.Description = _description;
        _creditCardAuthTrans.ProcessorStatus = CreditCard::getProcessorStatus(_succeeded);
        _creditCardAuthTrans.CardTokenRequest = _cardTokenRequest;
        _creditCardAuthTrans.CreditCardProcessors = _processor;
        _creditCardAuthTrans.TransactionType = CreditCardTransactionType::Transactional;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcessorStatus</Name>
				<Source><![CDATA[
    private static CreditCardProcessorStatus getProcessorStatus(boolean _succeeded)
    {
        CreditCardProcessorStatus processorStatus;

        if (RetailIncrementalCaptureFeatureExposure::isEnabled() &&
            extendedParameters.parmInitCreditCardAuthTrans_ProcessorErrorCode() == enum2int(Microsoft.Dynamics.Retail.PaymentSDK.Portable.ErrorCode::CommunicationError))
        {
            processorStatus = CreditCardProcessorStatus::TimedOut;
        }
        else
        {
            processorStatus = _succeeded ? CreditCardProcessorStatus::Approved : CreditCardProcessorStatus::Declined;
        }

        return processorStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCreditCardProviderResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values of <c>CreditCardAuthTrans</c> table buffer from <c>CreditCardProviderResult</c>.
    /// </summary>
    /// <param name = "_creditCardAuthTrans">
    /// The buffer of <c>CreditCardAuthTrans</c> table.
    /// </param>
    /// <param name = "_creditCardProviderResult">
    /// The result properties of the operation.
    /// </param>
    /// <remarks>This method uses an optional parameter ApprovedAmount which explicity contains the approved amount for <c>CreditCardAuthtrans</c> record
    /// for captured payments. This parameter can be set using parmInitFromCreditCardProviderResult_ApprovedAmount on <c>CreditCard::extendedParameters.</c></remarks>
    protected static void initFromCreditCardProviderResult(CreditCardAuthTrans _creditCardAuthTrans, CreditCardProviderResult _creditCardProviderResult)
    {
        AmountCur getRequestAmount(CreditCardPaymentCardToken _token)
        {
            var property = CreditCardPaymentProperties::fromXmlString(_token).find(RetailConst.GenericNamespace::get_TransactionData(), RetailConst.TransactionDataProperties::get_Amount());

            return property ? property.parmDecimalValue() : 0;
        }

        if (_creditCardProviderResult)
        {
            _creditCardAuthTrans.AddressVerificationResult = _creditCardProviderResult.parmAvsResult();
            _creditCardAuthTrans.ApprovalAmountCur = _creditCardProviderResult.parmTransactionAmount();

            // Amount is zero on failure or in case of capture, see if it is passed as an extended parameter or if we can get it from the request
            if (_creditCardAuthTrans.ApprovalAmountCur == 0)
            {
                if (extendedParameters.parmInitFromCreditCardProviderResult_ApprovedAmount())
                {
                    _creditCardAuthTrans.ApprovalAmountCur = extendedParameters.parmInitFromCreditCardProviderResult_ApprovedAmount();
                }
                else if (_creditCardAuthTrans.CardTokenRequest)
                {
                    _creditCardAuthTrans.ApprovalAmountCur = getRequestAmount(_creditCardAuthTrans.CardTokenRequest);
                }
            }

            _creditCardAuthTrans.Authorization = _creditCardProviderResult.parmAuthorization();
            _creditCardAuthTrans.CardTokenResult = _creditCardProviderResult.parmProperties().toXmlString();
            _creditCardAuthTrans.CreditCardNumber = _creditCardProviderResult.parmCreditCardNumber();
            _creditCardAuthTrans.CreditCardTypeName = _creditCardProviderResult.parmCreditCardTypeName();
            _creditCardAuthTrans.cvcResult = _creditCardProviderResult.parmCvcResult();
            _creditCardAuthTrans.UniqueCardId = _creditCardProviderResult.parmCreditCardUniqueCardId();
            _creditCardAuthTrans.MCRTrackingId = _creditCardProviderResult.parmMCRPaymentTrackingId();
            _creditCardAuthTrans.ApprovalCode = _creditCardProviderResult.parmApprovalCode();
            _creditCardAuthTrans.ProcessorReference = _creditCardProviderResult.parmProcessorReference();
            _creditCardAuthTrans.ProcessorPayment = _creditCardProviderResult.parmProcessorPayment();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromSalesTable</Name>
				<Source><![CDATA[
    private static void initFromSalesTable(CreditCardAuthTrans _creditCardAuthTrans, SalesTable _salesTable)
    {
        _creditCardAuthTrans.CurrencyCode = _salesTable.CurrencyCode;
        _creditCardAuthTrans.SalesId = _salesTable.SalesId;
        _creditCardAuthTrans.LineNum = CreditCardAuthTrans::lastLineNum(_salesTable.SalesId) + 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrInitFromCustPaymTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the reference on the <c>CreditCardAuthTrans</c> to the payment record.
    /// </summary>
    /// <param name="_creditCardAuthTrans">
    /// The <c>CreditCardAuthTrans</c> buffer to set.
    /// </param>
    /// <param name="_mcrCustPaymTable">
    /// The payment record to be used in initialization.
    /// </param>
    public static void mcrInitFromCustPaymTable(CreditCardAuthTrans _creditCardAuthTrans,
                                                 MCRCustPaymTable _mcrCustPaymTable)
    {
        CustInvoiceTable custInvoiceTable;
        LedgerJournalTrans ledgerJournalTrans;
        CustPaymSched custPaymSched;

        if (_mcrCustPaymTable)
        {
            _creditCardAuthTrans.MCRPaymRecId = _mcrCustPaymTable.RecId;
            _creditCardAuthTrans.CurrencyCode = _mcrCustPaymTable.CurrencyCode;

            if (!_mcrCustPaymTable.isExternalGiftCardPayment() || _mcrCustPaymTable.RefTableId)
            {
                switch (_mcrCustPaymTable.RefTableId)
                {
                    case tableNum(CustInvoiceTable):
                        custInvoiceTable = CustInvoiceTable::findRecId(_mcrCustPaymTable.RefRecId);
                        _creditCardAuthTrans.MCRInvoiceId = custInvoiceTable.InvoiceId;
                        break;
                    case tableNum(LedgerJournalTrans):
                        ledgerJournalTrans = LedgerJournalTrans::findRecId(_mcrCustPaymTable.RefRecId, false);
                        _creditCardAuthTrans.MCRJournalNum = ledgerJournalTrans.JournalNum;
                        break;
                    case tableNum(SalesTable):
                        _creditCardAuthTrans.SalesId = SalesTable::findRecId(_mcrCustPaymTable.RefRecId).SalesId;
                        break;
                    case tableNum(CustPaymSchedLine):
                        custPaymSched = CustPaymSched::mcrFindRecID(_mcrCustPaymTable.RefRecId);
                        _creditCardAuthTrans.MCRCustPaymSchedName = CustPaymSched.Name;
                        break;
                    default:
                        throw error(Error::wrongUseOfFunction(funcName()));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordAuthorization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Stores the results of a credit card authorization request.
    /// </summary>
    /// <param name="_result">
    /// The result properties of the operation.
    /// </param>
    /// <param name="_salesTable">
    /// The sales order which uses a credit card for payment.
    /// </param>
    /// <param name="_processor">
    /// The processor of the credit card.
    /// </param>
    /// <param name="_succeeded">
    /// true if the request was successful; otherwise, false.
    /// </param>
    /// <param name="_description">
    /// Describes the outcome of the request.
    /// </param>
    /// <param name="_cardTokenRequest">
    /// The request parameters.
    /// </param>
    /// <param name="_skipUpdate">
    /// If true, updating the <c>SalesTable</c> table will not occur.
    /// </param>
    /// <param name="_mcrCustPaymTable">
    /// The <c>MCRCustPaymTable</c> record if present; otherwise, null.
    /// </param>
    public static void recordAuthorization(CreditCardProviderResult _result, SalesTable _salesTable, CreditCardProcessorsId _processor, boolean _succeeded, CreditCardApprovalRejectReason _description, str _cardTokenRequest = '', boolean _skipUpdate = false, MCRCustPaymTable _mcrCustPaymTable = null)
    {
        UserConnection connection = new UserConnection();

        try
        {
            CreditCard::recordAuthorizationWithConnection(
                _result,
                _salesTable,
                _processor,
                _succeeded,
                _description,
                _cardTokenRequest,
                _skipUpdate,
                _mcrCustPaymTable,
                connection);
        }
        finally
        {
            connection.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordReauthorization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Stores the results of a credit card reauthorization request.
    /// </summary>
    /// <param name="_result">
    /// The result properties of the operation.
    /// </param>
    /// <param name="_salesTable">
    /// The sales order which uses a credit card for payment.
    /// </param>
    /// <param name="_processor">
    /// The processor of the credit card.
    /// </param>
    /// <param name="_succeeded">
    /// true if the request was successful; otherwise, false.
    /// </param>
    /// <param name="_description">
    /// Describes the outcome of the request.
    /// </param>
    /// <param name="_cardTokenRequest">
    /// The request parameters.
    /// </param>
    /// <param name="_skipUpdate">
    /// If true, updating the <c>SalesTable</c> table will not occur.
    /// </param>
    /// <param name="_mcrCustPaymTable">
    /// The <c>MCRCustPaymTable</c> record if present; otherwise, null.
    /// </param>
    public static void recordReauthorization(CreditCardProviderResult _result, SalesTable _salesTable, CreditCardProcessorsId _processor, boolean _succeeded, CreditCardApprovalRejectReason _description, str _cardTokenRequest = '', boolean _skipUpdate = false, MCRCustPaymTable _mcrCustPaymTable = null)
    {
        UserConnection connection = new UserConnection();

        try
        {
            CreditCard::recordReauthorizationWithConnection(
                _result,
                _salesTable,
                _processor,
                _succeeded,
                _description,
                _cardTokenRequest,
                _skipUpdate,
                _mcrCustPaymTable,
                connection);
        }
        finally
        {
            connection.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordCapture</Name>
				<Source><![CDATA[
    /// <summary>
    /// Stores the results of a credit card capture request.
    /// </summary>
    /// <param name="_result">
    /// The result properties of the operation.
    /// </param>
    /// <param name="_salesTable">
    /// The sales order which uses a credit card for payment.
    /// </param>
    /// <param name="_invoiceId">
    /// The invpoice number of the sales order.
    /// </param>
    /// <param name="_processor">
    /// The processor of the credit card.
    /// </param>
    /// <param name="_AuthorizeAndCaptureTogether">
    /// true of both the authorize and capture operations occured together; otherwise, false.
    /// </param>
    /// <param name="_succeeded">
    /// true if the request was successful; otherwise, false.
    /// </param>
    /// <param name="_description">
    /// Describes the outcome of the request.
    /// </param>
    /// <param name="_cardTokenRequest">
    /// The request parameters.
    /// </param>
    /// <param name="_skipUpdate">
    /// If true, updating the <c>SalesTable</c> and authorization record in the <c>CreditCardAuthTrans</c> tables will not occur.
    /// </param>
    /// <param name="_mcrCustPaymTable">
    /// The customer payment reference ID.
    /// </param>
    public static void recordCapture(CreditCardProviderResult _result, SalesTable _salesTable, SalesInvoiceId _invoiceId, CreditCardProcessorsId _processor, boolean _AuthorizeAndCaptureTogether, boolean _succeeded, CreditCardApprovalRejectReason _description, str _cardTokenRequest = '', boolean _skipUpdate = false, MCRCustPaymTable _mcrCustPaymTable = null)
    {
        UserConnection connection = new UserConnection();

        try
        {
            CreditCard::recordCaptureWithConnection(_result,
                                      _salesTable,
                                      _invoiceId,
                                      _processor,
                                      _AuthorizeAndCaptureTogether,
                                      _succeeded,
                                      _description,
                                      _cardTokenRequest,
                                      _skipUpdate,
                                      _mcrCustPaymTable,
                                      connection);
        }
        finally
        {
            connection.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postRecordCapture</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Closes the credit card transaction and updates the sales table.
    /// </summary>
    /// <param name = "_creditCardAuthorized">
    ///     A record in the <c>CreditCardAuthTrans</c> table.
    /// </param>
    /// <param name = "_skipUpdate">
    ///     If true, updating the <c>SalesTable</c> and authorization record in the <c>CreditCardAuthTrans</c> tables will not occur.
    /// </param>
    /// <param name = "_succeeded">
    ///     true if the request was successful; otherwise, false.
    /// </param>
    /// <param name = "_invoiceId">
    ///     The invoice number of the sales order.
    /// </param>
    /// <param name = "_salesTable">
    ///     The sales order which uses a credit card for payment.
    /// </param>
    /// <param name = "_result">
    ///     The result properties of the operation.
    /// </param>
    protected static void postRecordCapture(
        CreditCardAuthTrans _creditCardAuthorized,
        boolean _skipUpdate,
        boolean _succeeded,
        SalesInvoiceId _invoiceId,
        SalesTable _salesTable,
        CreditCardProviderResult _result)
    {
        if (!_skipUpdate)
        {
            if (_succeeded && _creditCardAuthorized)
            {
                CreditCardAuthTrans::settlePreapprovalTransaction(_creditCardAuthorized.RecId, _invoiceId);
            }
            CreditCard::updateSalesTable(_salesTable.RecId, _result, _succeeded);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordRefund</Name>
				<Source><![CDATA[
    /// <summary>
    /// Stores the results of a credit card refund request.
    /// </summary>
    /// <param name="_result">
    /// The result properties of the operation.
    /// </param>
    /// <param name="_salesTable">
    /// The sales order which uses a credit card for payment.
    /// </param>
    /// <param name="_processor">
    /// The processor of the credit card.
    /// </param>
    /// <param name="_succeeded">
    /// true if the request was successful; otherwise, false.
    /// </param>
    /// <param name="_description">
    /// Describes the outcome of the request.
    /// </param>
    /// <param name="_cardTokenRequest">
    /// The request parameters.
    /// </param>
    /// <param name="_skipUpdate">
    /// If true, updating the <c>SalesTable</c> and <c>CreditCardAuthTrans</c> tables will not occur.
    /// </param>
    /// <param name="_mcrCustPaymTable">
    /// The customer payment reference ID.
    /// </param>
    /// <remarks>This method uses an optional parameter OrigAuthRecId which contains the record identifier of the original captured <c>CreditCardAuthtrans</c> record
    /// for the refund. This parameter can be set using parmRecordRefund_OrigAuthTransId on <c>CreditCard::extendedParameters.</c>
    /// Another optional parameter SalesInvoiceId which contains the sales invoice identifier for the refund.
    /// This parameter can be set using parmRecordRefund_SalesInvoiceId on <c>CreditCard::extendedParameters.</c></remarks>
    public static void recordRefund(
            CreditCardProviderResult _result,
            SalesTable _salesTable,
            CreditCardProcessorsId _processor,
            boolean _succeeded,
            CreditCardApprovalRejectReason _description,
            str _cardTokenRequest = '',
            boolean _skipUpdate = false,
            MCRCustPaymTable _mcrCustPaymTable = null)
    {
        UserConnection connection = new UserConnection();

        try
        {
            CreditCard::recordRefundWithConnection(
                _result,
                _salesTable,
                _processor,
                _succeeded,
                _description,
                _cardTokenRequest,
                _skipUpdate,
                _mcrCustPaymTable,
                connection);
        }
        finally
        {
            connection.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordVoid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Stores the results of a credit card void request.
    /// </summary>
    /// <param name="_result">
    /// The result properties of the operation.
    /// </param>
    /// <param name="_salesTable">
    /// The sales order which uses a credit card for payment.
    /// </param>
    /// <param name="_processor">
    /// The processor of the credit card.
    /// </param>
    /// <param name="_succeeded">
    /// true if the request was successful; otherwise, false.
    /// </param>
    /// <param name="_description">
    /// Describes the outcome of the request.
    /// </param>
    /// <param name="_cardTokenRequest">
    /// The request parameters.
    /// </param>
    /// <param name="_skipUpdate">
    /// If true, updating the <c>SalesTable</c> and authorization record in the <c>CreditCardAuthTrans</c> tables will not occur.
    /// </param>
    /// <param name="_mcrCustPaymTable">
    /// Retail payment trans.
    /// </param>
    public static void recordVoid(CreditCardProviderResult _result, SalesTable _salesTable, CreditCardProcessorsId _processor, boolean _succeeded, CreditCardApprovalRejectReason _description, str _cardTokenRequest = '', boolean _skipUpdate = false, MCRCustPaymTable _mcrCustPaymTable = null)
    {
        UserConnection connection = new UserConnection();

        try
        {
            
            CreditCard::recordVoidWithConnection(
                _result,
                _salesTable,
                _processor,
                _succeeded,
                _description,
                _cardTokenRequest,
                _skipUpdate,
                _mcrCustPaymTable,
                connection);
        }
        finally
        {
            connection.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Stores the results of a credit card Balance request.
    /// </summary>
    /// <param name="_result">
    /// The result properties of the operation.
    /// </param>
    /// <param name="_salesTable">
    /// The sales order which uses a credit card for payment.
    /// </param>
    /// <param name="_processor">
    /// The processor of the credit card.
    /// </param>
    /// <param name="_succeeded">
    /// true if the request was successful; otherwise, false.
    /// </param>
    /// <param name="_description">
    /// Describes the outcome of the request.
    /// </param>
    /// <param name="_cardTokenRequest">
    /// The request parameters.
    /// </param>
    /// <param name="_skipUpdate">
    /// If true, updating the <c>SalesTable</c> and authorization record in the <c>CreditCardAuthTrans</c> tables will not occur.
    /// </param>
    /// <param name="_mcrCustPaymTable">
    /// Retail payment trans.
    /// </param>
    /// <param name="_retailExternalGiftCard">
    /// Retail external gift card.
    /// </param>
    /// <returns>
    /// The newly added credit card history record.
    /// </returns>
    internal static void recordBalance(
        CreditCardProviderResult _result,
        SalesTable _salesTable,
        CreditCardProcessorsId _processor,
        boolean _succeeded,
        CreditCardApprovalRejectReason _description,
        str _cardTokenRequest = '',
        boolean _skipUpdate = false,
        MCRCustPaymTable _mcrCustPaymTable = null,
        RetailExternalGiftCard _retailExternalGiftCard = null)
    {
        UserConnection connection = new UserConnection();

        try
        {
            CreditCard::recordBalanceWithConnection(
                _result,
                _salesTable,
                _processor,
                _succeeded,
                _description,
                _cardTokenRequest,
                _skipUpdate,
                _mcrCustPaymTable,
                _retailExternalGiftCard,
                connection);
        }
        finally
        {
            connection.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordActivation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Stores the results of a credit card Activation request.
    /// </summary>
    /// <param name="_result">
    /// The result properties of the operation.
    /// </param>
    /// <param name="_salesTable">
    /// The sales order which uses a credit card for payment.
    /// </param>
    /// <param name="_processor">
    /// The processor of the credit card.
    /// </param>
    /// <param name="_succeeded">
    /// true if the request was successful; otherwise, false.
    /// </param>
    /// <param name="_description">
    /// Describes the outcome of the request.
    /// </param>
    /// <param name="_cardTokenRequest">
    /// The request parameters.
    /// </param>
    /// <param name="_skipUpdate">
    /// If true, updating the <c>SalesTable</c> and authorization record in the <c>CreditCardAuthTrans</c> tables will not occur.
    /// </param>
    /// <param name="_mcrCustPaymTable">
    /// Retail payment trans.
    /// </param>
    /// <param name="_retailExternalGiftCard">
    /// Retail external gift card.
    /// </param>
    /// <returns>
    /// The newly added credit card history record.
    /// </returns>
    internal static void recordActivation(
        CreditCardProviderResult _result,
        SalesTable _salesTable,
        CreditCardProcessorsId _processor,
        boolean _succeeded,
        CreditCardApprovalRejectReason _description,
        str _cardTokenRequest = '',
        boolean _skipUpdate = false,
        MCRCustPaymTable _mcrCustPaymTable = null,
        RetailExternalGiftCard _retailExternalGiftCard = null)
    {
        UserConnection connection = new UserConnection();

        try
        {
            CreditCard::recordActivationWithConnection(
                _result,
                _salesTable,
                _processor,
                _succeeded,
                _description,
                _cardTokenRequest,
                _skipUpdate,
                _mcrCustPaymTable,
                _retailExternalGiftCard,
                connection);
        }
        finally
        {
            connection.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Stores the results of a credit card operation request.
    /// </summary>
    /// <param name = "_connection">The connection to use for transaction.</param>
    /// <param name = "_operation">The operation.</param>
    /// <param name = "_result">The result properties of the operation.</param>
    /// <param name = "_salesTable">The sales order which uses a credit card for payment.</param>
    /// <param name = "_processor">The processor of the credit card.</param>
    /// <param name = "_succeeded">true if the request was successful; otherwise, false.</param>
    /// <param name = "_description">Describes the outcome of the request.</param>
    /// <param name = "_cardTokenRequest">The request parameters.</param>
    /// <param name = "_mcrCustPaymTable">Retail payment trans.</param>
    /// <param name = "_invoiceId">The invpoice number of the sales order.</param>
    /// <param name = "_retailExternalGiftCard">Retail external gift card.</param>
    /// <param name = "referenceTran">The referenced CreditCardAuthTrans.</param>
    internal static void recordOperation(
        UserConnection _connection,
        CreditCardOperation _operation,
        CreditCardProviderResult _result,
        SalesTable _salesTable,
        CreditCardProcessorsId _processor,
        boolean _succeeded,
        CreditCardApprovalRejectReason _description,
        str _cardTokenRequest = '',
        MCRCustPaymTable _mcrCustPaymTable = null,
        SalesInvoiceId _invoiceId = null,
        RetailExternalGiftCard _retailExternalGiftCard = null,
        CreditCardAuthTrans referenceTran = null)
    {
        CreditCardAuthTrans creditCardAuthTrans;
        RetailActivationLinkTable retailActivationLinkTable;

        if (_result == null)
        {
            checkFailed(strFmt("@Retail:CreditCardPaymentFailed", _operation));
        }
       
        creditCardAuthTrans.setConnection(_connection);
        retailActivationLinkTable.setConnection(_connection);
        _connection.ttsbegin();

        CreditCard::initCreditCardAuthTrans(creditCardAuthTrans, _operation, _processor, _description, _succeeded, _cardTokenRequest);
        CreditCard::initFromCreditCardProviderResult(creditCardAuthTrans, _result);
        CreditCard::initFromSalesTable(creditCardAuthTrans, _salesTable);

        if (_operation == CreditCardOperation::Balance || _operation == CreditCardOperation::Activation)
        {
            // Update the transaction type to informational.
            creditCardAuthTrans.TransactionType = CreditCardTransactionType::Informational;

            // Mask only when card number is available in the result.
            if (_result)
            {
                creditCardAuthTrans.CreditCardNumber = MCRGiftCard::maskCardNum(_result.parmCreditCardNumber());
            }
        }
       
        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)) && _mcrCustPaymTable)
        {
            CreditCard::mcrInitFromCustPaymTable(creditCardAuthTrans, _mcrCustPaymTable);
        }

        if (referenceTran.RecId)
        {
            creditCardAuthTrans.OrigAuthRecId = referenceTran.RecId;
        }

        if (_operation == CreditCardOperation::Refund)
        {
            creditCardAuthTrans.RefundStatus = CreditCardRefundStatus::Processed;
        }
        else
        {
            creditCardAuthTrans.RefundStatus = CreditCardRefundStatus::None;

            if (_operation == CreditCardOperation::Void)
            {
                if (RetailPaymentsReAuthorizeExpiredPreAuthorizationsFlight::instance().isEnabled())
                {
                    if (RetailIncrementalCaptureFeatureExposure::isEnabled())
                    {
                        // Update approval amount on authorization only if it is initialized with amount which is less than or equal to zero.
                        // If _creditCardAuthTrans.ApprovalAmountCur was initialized to positive number in initFromCreditCardProviderResult we don't want to change it
                        if (creditCardAuthTrans.ApprovalAmountCur <= 0)
                        {
                            creditCardAuthTrans.ApprovalAmountCur = referenceTran.ApprovalAmountCur;
                        }
                    }
                    else
                    {
                        creditCardAuthTrans.ApprovalAmountCur = referenceTran.ApprovalAmountCur;
                    }
                }
                else
                {
                    if (RetailIncrementalCaptureFeatureExposure::isEnabled() && _result && _result.parmTransactionAmount() > 0)
                    {
                        creditCardAuthTrans.ApprovalAmountCur = _result.parmTransactionAmount();
                    }
                    else
                    {
                        creditCardAuthTrans.ApprovalAmountCur = referenceTran.ApprovalAmountCur;
                    }
                }
            }
        }

        if (_invoiceId)
        {
            creditCardAuthTrans.SalesInvoiceId = _invoiceId;
        }

        // If missing card number or type, get it from the request
        if (_cardTokenRequest)
        {
            var requestProperties = CreditCardPaymentProperties::fromXmlString(_cardTokenRequest);

            CreditCard::updateCreditCardProperties(creditCardAuthTrans, requestProperties);
            CreditCard::obscureCVV(requestProperties, creditCardAuthTrans);
        }

        if (CreditCardProcessHelper::lifeCycleManagementEnabled())
        {
            CreditCardRequestResult result = CreditCardRequestResult::RequestNone;
            if (_mcrCustPaymTable)
            {
                result = CreditCardResultCacheStore::getLastRequestStatus(new CreditCardResultCacheKey(_mcrCustPaymTable), false);
            }
            else if (_salesTable)
            {
                result = CreditCardResultCacheStore::getLastRequestStatus(new CreditCardResultCacheKey(_salesTable), false);
            }

            if (result == CreditCardRequestResult::RequestNetworkError)
            {
                creditCardAuthTrans.ProcessorStatus = CreditCardProcessorStatus::TimedOut;
            }
        }

        creditCardAuthTrans.insert();

        if (_operation == CreditCardOperation::Activation)
        {
            retailActivationLinkTable.CreditCardAuthTrans = creditCardAuthTrans.RecId;
            retailActivationLinkTable.SalesLine = _retailExternalGiftCard.ActivationSalesLineRecId;
            retailActivationLinkTable.insert();
        }

        if (RetailNonRecurringTokenFeatureExposure::isEnabled()
            && _succeeded
            && _operation == CreditCardOperation::Reauthorize
            && _mcrCustPaymTable)
        {
            CreditCardAuthTrans sourceAuthorization = CreditCardAuthTrans::findLatestValidAuthorization(_mcrCustPaymTable.RecId, true);
            if (sourceAuthorization)
            {
                sourceAuthorization.setConnection(_connection);
                sourceAuthorization.ApprovalAmountCur = creditCardAuthTrans.ApprovalAmountCur;
                sourceAuthorization.update();
            }
        }

        _connection.ttscommit();

        if (_retailExternalGiftCard)
        {
            // Save reference to balance transaction
            _retailExternalGiftCard.CreditCardAuthTransRecId = creditCardAuthTrans.RecId;

            if (_operation == CreditCardOperation::Activation && _result)
            {
                _retailExternalGiftCard.CardNumber = _result.parmCreditCardNumber();
                _retailExternalGiftCard.Expiration = _result.parmExpiration();
                _retailExternalGiftCard.Pin = _result.parmGiftCardPin();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sameCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the same credit card was used in a credit card operation as was specified on a sales order.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order which uses a credit card for payment.
    /// </param>
    /// <param name="_creditCardAuthTrans">
    /// The credit card history record.
    /// </param>
    /// <returns>
    /// true if the same credit card was used on the given sales order and in given credit card operation.
    /// </returns>
    public static boolean sameCard(SalesTable _salesTable, CreditCardAuthTrans _creditCardAuthTrans)
    {
        CreditCardCust creditCardCust;

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRPayment)) && _creditCardAuthTrans)
        {
            creditCardCust = CreditCardCust::find(MCRCustPaymTable::findByRecID(_creditCardAuthTrans.MCRPaymRecId).PaymInfoRecId);
        }

        if (!creditCardCust)
        {
            creditCardCust = CreditCardCust::find(_salesTable.CreditCardCustRefId);
        }

        // Same card as long as they both have a unique card id and the unique card id is not blank.
        return creditCardCust && creditCardCust.UniqueCardId == _creditCardAuthTrans.UniqueCardId && _creditCardAuthTrans.UniqueCardId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the sales table.
    /// </summary>
    /// <param name="_salesTableRefRecId">
    ///    The <c>RecId</c> of a <c>SalesTable</c> record.
    /// </param>
    /// <param name="_creditCardProviderResult">
    ///    The result of a credit card operation.
    /// </param>
    /// <param name="_success">
    ///    True if the credit card operation was successful.
    /// </param>
    /// <returns>
    ///    true if the sales table is updated successfully; otherwise, false.
    /// </returns>
    public static boolean updateSalesTable(SalesTableRefRecId _salesTableRefRecId, CreditCardProviderResult _creditCardProviderResult, boolean _success)
    {
        SalesTable salesTable;
        UserConnection connection = new UserConnection();

        try
        {
            // The call to "ttsbegin" before defining a new connection is necessary to increase the TTSLEVEL,
            // as it is required to have a TTSLEVEL != 0 when updating a Sales Order.
            // The "connection.ttsBegin()" does not increment regular TTSLEVEL.
            ttsbegin;

            // Open a new connection and new tts transaction
            salesTable.setConnection(connection);

            connection.ttsbegin();

            salesTable = SalesTable::findRecId(_salesTableRefRecId, true);
            if (salesTable)
            {
                if (_creditCardProviderResult)
                {
                    salesTable.CreditCardAuthorization = _creditCardProviderResult.parmAuthorization();
                    salesTable.CreditCardApprovalAmount = abs(_creditCardProviderResult.parmTransactionAmount()); // abs() because refunds are negative
                }
                salesTable.CreditCardAuthorizationError = !_success;
                salesTable.update();
            }

            connection.ttscommit();
            ttscommit;
        }
        finally
        {
            connection.finalize();
        }

        return salesTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>obscureCVV</Name>
				<Source><![CDATA[
    /// <summary>
    /// Obscures the CVV, if obtained, from the creditcard blob.
    /// </summary>
    /// <param name="_requestProperties">
    /// The parsed blob string that may or may not contain a CVV.
    /// </param>
    /// <param name="_creditCardAuthTrans">
    /// The table that contains the parsed blob.
    /// </param>
    /// <returns>
    /// Returns a boolean stating whether or not there was a CVV associated with the creditcard blob.
    /// </returns>
    /// <remarks>
    /// Persists the blob back to xml before returning.
    /// </remarks>
    public static boolean obscureCVV(
        CreditCardPaymentProperties _requestProperties,
        CreditCardAuthTrans _creditCardAuthTrans)
    {
        boolean result = false;

        CreditCardPaymentProperty property = _requestProperties.find(
            Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
            Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_CardVerificationValue());

        if (property)
        {
            property.parmStringValue(strRep('*', strLen(property.parmStringValue())));
            _creditCardAuthTrans.CardTokenRequest = _requestProperties.toXmlString();
            result = true;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>FindBestMatchCreditCardProcessorId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the best match among all existing credit card processors based on payment properties.
    /// Search through all existing credit card processors. Pick the best match based on the following sequence:
    /// 1. Find the processor with matching Service Account ID.
    /// 2. If not found, find the processor with matching connector name and it is active.
    /// 3. If not found, find the first processor with matching connector name.
    /// 4. If not found, return the active processor.
    /// 5. If not found, return zero.
    /// </summary>
    /// <param name = "_paymentProperties">The payment properties.</param>
    /// <returns>The record identifier of the best match.</returns>
    public static RecId FindBestMatchCreditCardProcessorId(CreditCardPaymentProperties _paymentProperties)
    {
        if (_paymentProperties != null)
        {
            var paymentAccountId = CreditCard::getPaymentAccountId(_paymentProperties);
            str connectorName = CreditCard::getConnectorName(_paymentProperties);
            if (paymentAccountId && connectorName)
            {
                CreditCardProcessors creditCardProcessors;
                CreditCardAccountSetup creditCardAccountSetup;
                RecId matchWithServiceAccountId;
                RecId matchWithConnectorNameAndActive;
                RecId firstMatchWithConnectorName;

                while select SecureMerchantProperties, ConnectorName
                from creditCardAccountSetup
                join RecId, Active from creditCardProcessors
                    where creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors &&
                          !creditCardProcessors.NotUsed
                {
                    var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
                    var properties = CreditCardPaymentProperties::fromXmlString(merchant);

                    if (paymentAccountId == CreditCard::getPaymentAccountId(properties))
                    {
                        matchWithServiceAccountId = creditCardProcessors.RecId;
                        break;
                    }
                    else if (connectorName == creditCardAccountSetup.ConnectorName)
                    {
                        if (matchWithConnectorNameAndActive == 0 && creditCardProcessors.Active)
                        {
                            matchWithConnectorNameAndActive = creditCardProcessors.RecId;
                        }

                        if (firstMatchWithConnectorName == 0)
                        {
                            firstMatchWithConnectorName = creditCardProcessors.RecId;
                        }
                    }
                }

                if (matchWithServiceAccountId)
                {
                    return matchWithServiceAccountId;
                }
                else if (matchWithConnectorNameAndActive)
                {
                    return matchWithConnectorNameAndActive;
                }
                else if (firstMatchWithConnectorName)
                {
                    return firstMatchWithConnectorName;
                }
                else
                {
                    return CreditCardProcessors::findActiveProcessor().RecId;
                }
            }
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maskCreditCardNumberInProperty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Mask the payment card number to be the last 4 digits in the property bag, we must not store full card numbers to the database.
    /// </summary>
    /// <param name = "_requestProperties">The property bag which contains the credit card number.</param>
    private static void maskCreditCardNumberInProperty(CreditCardPaymentProperties _requestProperties)
    {
        str maskedCardNumber = '';
        var cardNumberProperty = _requestProperties.find(RetailConst.GenericNamespace::get_PaymentCard(), RetailConst.PaymentCardProperties::get_CardNumber());
        if (cardNumberProperty && cardNumberProperty.parmStringValue() != '')
        {
            maskedCardNumber = MCRGiftCard::maskCardNum(cardNumberProperty.parmStringValue());
            cardNumberProperty.parmStringValue(maskedCardNumber);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCreditCardProperties</Name>
				<Source><![CDATA[
    private static void updateCreditCardProperties(CreditCardAuthTrans _creditCardAuthTrans, CreditCardPaymentProperties _requestProperties)
    {
        // Update the credit card number.
        if (!_creditCardAuthTrans.CreditCardNumber)
        {
            var creditCardNumberProperty = _requestProperties.find(RetailConst.GenericNamespace::get_AuthorizationResponse(), RetailConst.AuthorizationResponseProperties::get_Last4Digits());
            _creditCardAuthTrans.CreditCardNumber = creditCardNumberProperty ? creditCardNumberProperty.parmStringValue() : '';
        }

        // Update the credit card type.
        if (!_creditCardAuthTrans.CreditCardTypeName)
        {
            var cardTypeProperty = _requestProperties.find(RetailConst.GenericNamespace::get_PaymentCard(), RetailConst.PaymentCardProperties::get_CardType());
            _creditCardAuthTrans.CreditCardTypeName = cardTypeProperty ? cardTypeProperty.parmStringValue() : '';
        }

        // Mask the card number.
        str maskedCardNumber = '';
        var cardNumberProperty = _requestProperties.find(RetailConst.GenericNamespace::get_PaymentCard(), RetailConst.PaymentCardProperties::get_CardNumber());
        
        if (cardNumberProperty && cardNumberProperty.parmStringValue() != '')
        {
            maskedCardNumber = MCRGiftCard::maskCardNum(cardNumberProperty.parmStringValue());
            cardNumberProperty.parmStringValue(maskedCardNumber);
        }

        if (_creditCardAuthTrans.MCRTrackingId == '' && extendedParameters.parmInitCreditCardAuthTrans_MCRPaymentTrackingId() != '')
        {
            // Connector result did not set the tracking id
            _creditCardAuthTrans.MCRTrackingId = extendedParameters.parmInitCreditCardAuthTrans_MCRPaymentTrackingId();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultExtendedParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets extendedParameters and returns a new object with default properties.
    /// This helps ensure that extendedParameters is not already dirty before using it.
    /// </summary>
    /// <returns>
    /// The newly instantiated extendedParameters with default properties.
    /// </returns>
    internal static CreditCard_ExtendedParameters getDefaultExtendedParameters()
    {
        extendedParameters = CreditCard_ExtendedParameters::construct();
        return extendedParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordRefundWithConnection</Name>
				<Source><![CDATA[
    internal static void recordRefundWithConnection(
            CreditCardProviderResult _result,
            SalesTable _salesTable,
            CreditCardProcessorsId _processor,
            boolean _succeeded,
            CreditCardApprovalRejectReason _description,
            str _cardTokenRequest = '',
            boolean _skipUpdate = false,
            MCRCustPaymTable _mcrCustPaymTable = null,
            UserConnection _userConnection = null)
    {
        CreditCardAuthTrans creditCardAuthTransRefunded;
        CreditCardAuthTransRefRecId origCreditCardAuthTransRecId = extendedParameters.parmRecordRefund_OrigAuthTransId();
        SalesInvoiceId _invoiceId = extendedParameters.parmRecordRefund_SalesInvoiceId();

        if (origCreditCardAuthTransRecId)
        {
            creditCardAuthTransRefunded = CreditCardAuthTrans::find(origCreditCardAuthTransRecId, true);
        }
        else if (RetailTransactionPaymentsHelper::isCallCenterOrCommercePaymentsEnabledOrder(_salesTable) && _mcrCustPaymTable)
        {
            creditCardAuthTransRefunded = CreditCardAuthTrans::mcrFindRefundCharge(_mcrCustPaymTable.RecId);
        }
        else
        {
            creditCardAuthTransRefunded = CreditCardAuthTrans::findRefundCharge(_salesTable.SalesId);
        }
        
        CreditCard::recordOperation(
            _userConnection,
            CreditCardOperation::Refund,
            _result,
            _salesTable,
            _processor,
            _succeeded,
            _description,
            _cardTokenRequest,
            _mcrCustPaymTable,
            _invoiceId,
            null,
            creditCardAuthTransRefunded);

        if (!_skipUpdate)
        {
            if (_succeeded && creditCardAuthTransRefunded)
            {
                CreditCardAuthTrans::markRefundProcessed(creditCardAuthTransRefunded.RecId);
            }
            CreditCard::updateSalesTable(_salesTable.RecId, _result, _succeeded);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordVoidWithConnection</Name>
				<Source><![CDATA[
    internal static void recordVoidWithConnection(
        CreditCardProviderResult _result,
        SalesTable _salesTable,
        CreditCardProcessorsId _processor,
        boolean _succeeded,
        CreditCardApprovalRejectReason _description,
        str _cardTokenRequest = '',
        boolean _skipUpdate = false,
        MCRCustPaymTable _mcrCustPaymTable = null,
        UserConnection _userConnection = null)
    {
        CreditCardAuthTrans creditCardAuthTransVoided;

        if (RetailTransactionPaymentsHelper::isCallCenterOrCommercePaymentsEnabledOrder(_salesTable) && _mcrCustPaymTable)
        {
            if (RetailAllowVoidingofStaleAuthorizationsFeatureExposure::isEnabled())
            {
                creditCardAuthTransVoided = CreditCardAuthTrans::mcrFindAvailablePreApproval(_mcrCustPaymTable.RecId);
            }
            else
            {
                creditCardAuthTransVoided = CreditCardAuthTrans::mcrFindValidPreApproval(_mcrCustPaymTable.RecId);
            }
        }
        else
        {
            creditCardAuthTransVoided = CreditCardAuthTrans::findValidPreApproval(_salesTable.SalesId);
        }

        CreditCard::recordOperation(
            _userConnection,
            CreditCardOperation::Void,
            _result,
            _salesTable,
            _processor,
            _succeeded,
            _description,
            _cardTokenRequest,
            _mcrCustPaymTable,
            null,
            null,
            creditCardAuthTransVoided);

        if (!_skipUpdate)
        {
            if (_succeeded && creditCardAuthTransVoided)
            {
                CreditCardAuthTrans::setVoidApproval(creditCardAuthTransVoided.RecId);
            }

            CreditCard::updateSalesTable(_salesTable.RecId, _result, _succeeded);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordBalanceWithConnection</Name>
				<Source><![CDATA[
    internal static void recordBalanceWithConnection(
        CreditCardProviderResult _result,
        SalesTable _salesTable,
        CreditCardProcessorsId _processor,
        boolean _succeeded,
        CreditCardApprovalRejectReason _description,
        str _cardTokenRequest = '',
        boolean _skipUpdate = false,
        MCRCustPaymTable _mcrCustPaymTable = null,
        RetailExternalGiftCard _retailExternalGiftCard = null,
        UserConnection _userConnection = null)
    {
        CreditCard::recordOperation(
            _userConnection,
            CreditCardOperation::Balance,
            _result,
            _salesTable,
            _processor,
            _succeeded,
            _description,
            _cardTokenRequest,
            _mcrCustPaymTable,
            null,
            _retailExternalGiftCard,
            null);

        if (!_skipUpdate)
        {
            CreditCard::updateSalesTable(_salesTable.RecId, _result, _succeeded);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordActivationWithConnection</Name>
				<Source><![CDATA[
    internal static void recordActivationWithConnection(
        CreditCardProviderResult _result,
        SalesTable _salesTable,
        CreditCardProcessorsId _processor,
        boolean _succeeded,
        CreditCardApprovalRejectReason _description,
        str _cardTokenRequest = '',
        boolean _skipUpdate = false,
        MCRCustPaymTable _mcrCustPaymTable = null,
        RetailExternalGiftCard _retailExternalGiftCard = null,
        UserConnection _userConnection = null)
    {
        CreditCard::recordOperation(
            _userConnection,
            CreditCardOperation::Activation,
            _result,
            _salesTable,
            _processor,
            _succeeded,
            _description,
            _cardTokenRequest,
            _mcrCustPaymTable,
            null,
            _retailExternalGiftCard,
            null);

        if (!_skipUpdate)
        {
            CreditCard::updateSalesTable(_salesTable.RecId, _result, _succeeded);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordAuthorizationWithConnection</Name>
				<Source><![CDATA[
    internal static void recordAuthorizationWithConnection(
        CreditCardProviderResult _result,
        SalesTable _salesTable,
        CreditCardProcessorsId _processor,
        boolean _succeeded,
        CreditCardApprovalRejectReason _description,
        str _cardTokenRequest = '',
        boolean _skipUpdate = false,
        MCRCustPaymTable _mcrCustPaymTable = null,
        UserConnection _userConnection = null)
    {
        CreditCard::recordOperation(
            _userConnection,
            CreditCardOperation::Authorize,
            _result,
            _salesTable,
            _processor,
            _succeeded,
            _description,
            _cardTokenRequest,
            _mcrCustPaymTable,
            null,
            null,
            null);

        if (!_skipUpdate)
        {
            CreditCard::updateSalesTable(_salesTable.RecId, _result, _succeeded);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordCaptureWithConnection</Name>
				<Source><![CDATA[
    internal static void recordCaptureWithConnection(
        CreditCardProviderResult _result,
        SalesTable _salesTable,
        SalesInvoiceId _invoiceId,
        CreditCardProcessorsId _processor,
        boolean _authorizeAndCaptureTogether,
        boolean _succeeded,
        CreditCardApprovalRejectReason _description,
        str _cardTokenRequest = '',
        boolean _skipUpdate = false,
        MCRCustPaymTable _mcrCustPaymTable = null,
        UserConnection _userConnection = null)
    {
        CreditCardAuthTrans creditCardAuthTransAuthorized = CreditCard::findValidPreApproval(_salesTable, _mcrCustPaymTable);

        CreditCard::recordOperation(
            _userConnection,
            _authorizeAndCaptureTogether ? CreditCardOperation::AuthorizeAndCapture : CreditCardOperation::CaptureAfterAuthorize,
            _result,
            _salesTable,
            _processor,
            _succeeded,
            _description,
            _cardTokenRequest,
            _mcrCustPaymTable,
            _invoiceId,
            null,
            creditCardAuthTransAuthorized);

        CreditCard::postRecordCapture(creditCardAuthTransAuthorized, _skipUpdate, _succeeded, _invoiceId, _salesTable, _result);
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordReauthorizationWithConnection</Name>
				<Source><![CDATA[
    internal static void recordReauthorizationWithConnection(
        CreditCardProviderResult _result,
        SalesTable _salesTable,
        CreditCardProcessorsId _processor,
        boolean _succeeded,
        CreditCardApprovalRejectReason _description,
        str _cardTokenRequest = '',
        boolean _skipUpdate = false,
        MCRCustPaymTable _mcrCustPaymTable = null,
        UserConnection _userConnection = null)
    {
        CreditCard::recordOperation(
            _userConnection,
            CreditCardOperation::Reauthorize,
            _result,
            _salesTable,
            _processor,
            _succeeded,
            _description,
            _cardTokenRequest,
            _mcrCustPaymTable,
            null,
            null,
            null);

        if (!_skipUpdate)
        {
            CreditCard::updateSalesTable(_salesTable.RecId, _result, _succeeded);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findValidPreApproval</Name>
				<Source><![CDATA[
    internal static CreditCardAuthTrans findValidPreApproval(SalesTable _salesTable, MCRCustPaymTable _mcrCustPaymTable)
    {
        CreditCardAuthTrans creditCardAuthTransAuthorized;

        if (RetailTransactionPaymentsHelper::isCallCenterOrCommercePaymentsEnabledOrder(_salesTable))
        {
            creditCardAuthTransAuthorized = CreditCardAuthTrans::mcrFindValidPreApproval(_mcrCustPaymTable.RecId);
        }
        else
        {
            creditCardAuthTransAuthorized = CreditCardAuthTrans::findValidPreApproval(_salesTable.SalesId);
        }

        return creditCardAuthTransAuthorized;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNonRecurringCreditCardFromAuthResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a new credit card to the <c>CreditCardCust</c> table.
    /// </summary>
    /// <param name="_providerAuthResult">
    /// An authorization result.
    /// </param>
    /// <param name="_mcrCustPaymTableRecId">
    /// RecId for a record in <c>MCRCustPaymTable</c> table.
    /// </param>
    /// <param name="_custAccount">
    /// The customer account with which the new record is associated.
    /// </param>
    /// <param name="_processorId">
    /// The processor the credit card.
    /// </param>
    /// <returns>
    /// The newly created record.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Indicates the processor was not found.
    /// </exception>
    internal static CreditCardCust createNonRecurringCreditCardFromAuthResponse(CreditCardProviderAuthorizationResult _providerAuthResult, MCRCustPaymTableRecID _mcrCustPaymTableRecId, CustAccount _custAccount, CreditCardProcessorsId _processorId)
    {
        var properties = _providerAuthResult.parmProperties();
        str ns = RetailConst.GenericNamespace::get_PaymentCard();

        CreditCardCust creditCardCust;

        creditCardCust.clear();
        creditCardCust.CardToken = properties.toXmlString();

        creditCardCust.UniqueCardId = properties.find(ns, RetailConst.PaymentCardProperties::get_UniqueCardId()).parmStringValue();

        var cardNumberProperty = properties.find(ns, RetailConst.PaymentCardProperties::get_Last4Digits());
        if (cardNumberProperty != null)
        {
            creditCardCust.CardNumber = cardNumberProperty.parmStringValue();
        }

        var nameProperty = properties.find(RetailConst.GenericNamespace::get_PaymentCard(), RetailConst.PaymentCardProperties::get_Name());
        creditCardCust.Name = nameProperty ? nameProperty.parmStringValue() : '';

        var expirationMonthProperty = properties.find(ns, RetailConst.PaymentCardProperties::get_ExpirationMonth());
        var expirationYearProperty = properties.find(ns, RetailConst.PaymentCardProperties::get_ExpirationYear());
        if (expirationMonthProperty && expirationYearProperty)
        {
            creditCardCust.ExpiryDate = strFmt("%1/%2",
                any2int(expirationMonthProperty.parmDecimalValue()),
                any2int(expirationYearProperty.parmDecimalValue()));
        }

        var cardTypeProperty = properties.find(ns, RetailConst.PaymentCardProperties::get_CardType());
        if (cardTypeProperty)
        {
            creditCardCust.CreditCardTypeName = cardTypeProperty.parmStringValue();
        }

        var noteProperty = properties.find(ns, #CreditCardPaymentCardPropertyName_Note);
        creditCardCust.Notes = noteProperty ? noteProperty.parmStringValue() : '';
        creditCardCust.CustAccount = _custAccount;
        creditCardCust.CreditCardProcessors = _processorId;
        creditCardCust.TokenScope = RetailTokenScope::NonRecurring;
        
        UserConnection connection = new UserConnection();
        try
        {
            creditCardCust.setConnection(connection);
            connection.ttsbegin();
            creditCardCust.insert();
            connection.ttscommit();
        }
        finally
        {
            connection.finalize();
            eventSource.EventWriteRetailNonRecurringCreditCardCustCreated(_mcrCustPaymTableRecId, creditCardCust.RecId);
        }

        // update MCRCustPaymTable in a separate connection to save credit card information in case of error
        MCRCustPaymTable::updatePaymentInformation(_mcrCustPaymTableRecId, creditCardCust.RecId, creditCardCust.TableId);

        return creditCardCust;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>