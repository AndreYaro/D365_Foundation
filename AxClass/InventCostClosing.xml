<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventCostClosing</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>InventCostClosing</c> class starts an inventory closing.
/// </summary>
/// <remarks>
///       This class does the following actions:
///    <list type="bullet">
///       <item>
///          <description>Creates the dialog concerning the inventory closing. </description>
///       </item>
///       <item>
///          <description>
///             Creates a record in the table <c>InventCostList</c> for each item that has to be calculated.
///          </description>
///       </item>
///       <item>
///          <description>
///             Creates a record in the table <c>InventClosing</c> to control that an inventory closing is under
///             progress.
///          </description>
///       </item>
///       <item>
///          <description>
///             Starts an instance of <c>InventCostHelp</c> in order to calculate items in the
///             <c>InventCostList</c>.
///          </description>
///       </item>
///    </list>
///     For example, this class is instantiated when the menu Close_@SYS96906 is activated from the
///    following path:Inventory management/Periodic/Closing and adjustment
/// </remarks>
class InventCostClosing extends RunBaseBatch implements BatchRetryable
{
    // Parameters

    TransDate                   transDate;
    InventAdjustmentSpec        specification;
    NoYes                       prodJournal;
    NoYes                       updateLedger;
    NoYes                       cancelRecalculation;
    NoYes                       runRecalculation;
    NoYes                       shouldSummarizeInfolog;
    FreeTxt                     freeTxt;
    Integer                     maxIterations;
    CostAmount                  minTransferValue;
    InventAdjustmentType        adjustmentType;
    InventTransCurrency_RU      inventTransCurrency;
    boolean                     collapseGroups;
    DateCode                    periodCode;

    // Global objects

    InventClosing               inventClosing;
    RecId                       inventClosingRecId;

    // Dialog

    DialogRunbase               dialog;
    DialogField                 dialogPeriodCode;
    DialogField                 dialogDate;
    DialogField                 dialogSpecification;
    DialogField                 dialogProdJournal;
    DialogField                 dialogLedger;
    DialogField                 dialogCancelRecalculation;
    DialogField                 dialogRunRecalculation;
    DialogField                 dialogNotes;
    DialogField                 dialogShouldSummarizeInfolog;
    DialogField                 dialogMaxIterations;
    DialogField                 dialogMinTransferValue;

    private static boolean isInventCostClosingSkipCreateInventCostListFlightEnabled = InventCostClosingSkipCreateInventCostListFlight::instance().isEnabled();

    #ISOCountryRegionCodes

    InventCostTaskController    inventCostTaskController;

    #DEFINE.CurrentVersion(7)
    #LOCALMACRO.CurrentList
        TransDate,
        Specification,
        ProdJournal,
        UpdateLedger,
        FreeTxt,
        MaxIterations,
        MinTransferValue,
        adjustmentType,
        cancelRecalculation,
        runRecalculation,
        shouldSummarizeInfolog,
        collapseGroups,
        periodCode,
        inventTransCurrency,
        inventClosingRecId
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>cancelRecalculations</Name>
				<Source><![CDATA[
    protected void cancelRecalculations(InventClosing _inventClosing)
    {
        boolean                         countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        if (countryRegion_RU)
        {
            if (! this.isInBatch())
            {
                progress.setText(InventCostClosingCancel::description(inventTransCurrency));
            }
        }
        else
        {
            progress.setText(InventCostClosingCancel::description());
        }
        if (! (countryRegion_RU && this.isInBatch()))
        {
            progress.update(true);
        }

        InventCostClosingCancel_Init inventCostClosingCancel_Init = InventCostClosingCancel_Init::newFromInventClosing(_inventClosing);
        inventCostClosingCancel_Init.runOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMaxIterations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the maximun number of iterations.
    /// </summary>
    /// <returns>
    /// true, if the maximun number of iterations is valid; otherwise false;
    /// </returns>
    protected boolean checkMaxIterations()
    {
        boolean             result = true;

        if (maxIterations < 1)
        {
            result = checkFailed("@SYS117029");
        }

        if (maxIterations > 100)
        {
            if (Box::yesNo(strFmt("@SCM:MaximumNumberOfIterations", 100), DialogButton::No) != DialogButton::Yes)
            {
                result = false;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMinTransferValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the minumum transfer value.
    /// </summary>
    /// <returns>
    /// true, if the minumum transfer value is valid; otherwise false;
    /// </returns>
    protected boolean checkMinTransferValue()
    {
        boolean             result = true;
        RoundOff            unit = Currency::roundingPrecisionAdjusted(Ledger::accountingCurrency());

        if (minTransferValue < unit * 10)
        {
            result = checkFailed(strFmt("@SYS78801", minTransferValue) + '\n' + strFmt("@SYS83597", unit * 10));
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the parameters for the inventory closing.
    /// </summary>
    /// <param name="_ask">
    ///    Enables a dialog box when the parameter for updating the general ledger is not selected; optional.
    /// </param>
    /// <returns>
    ///    true if the parameters are valid; otherwise, false.
    /// </returns>
    boolean checkParameters(boolean _ask = false)
    {
        boolean             result = true;
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        if (countryRegion_RU)
        {
            InventClosing::closingDate(true, inventTransCurrency);
        }
        else
        {
            InventClosing::closingDate(true);
        }

        if ((countryRegion_RU
            && ! InventClosing::checkClosing(transDate, inventTransCurrency))
            || (! countryRegion_RU && ! InventClosing::checkClosing(transDate)))
        {
            return false;
        }

        if (!this.checkStdCostConversion(transDate))
        {
            return false;
        }

        if (!this.checkUpdateLedger())
        {
            return false;
        }

        if (this.showAdvanced())
        {
            if (!this.checkMaxIterations())
            {
                return false;
            }

            if (!this.checkMinTransferValue())
            {
                return false;
            }
        }

        NumberSequenceTable numberSequenceTable = NumberSequenceTable::find(InventParameters::numRefInventSettleTransId().NumberSequenceId);

        if (!numberSequenceTable.RecId)
        {
            return checkFailed(strFmt("@SYS26165", "@SYS53840"));
        }

        if (numberSequenceTable.Continuous)
        {
            result = checkFailed(strFmt("@SYS78804",numberSequenceTable.NumberSequence));
        }

        if (numberSequenceTable.Manual)
        {
            return checkFailed(strFmt("@SYS26209",numberSequenceTable.NumberSequence));
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostingOK</Name>
				<Source><![CDATA[
    boolean checkPostingOK()
    {
        InventClosing       checkInventClosing;
        InventClosing       checkInventRecalc;
        InventClosing       lastInventClosing;

        InventSettlement    inventSettlement;
        InventTransOrigin   inventTransOrigin;
        InventTrans         inventTrans;

        boolean             ok = true;
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        setPrefix("@SYS78798");

        lastInventClosing.selectLocked(false);

        select reverse firstonly TransDate, Executed, Start, RecId from lastInventClosing
            index TypeActiveIdx
            where lastInventClosing.AdjustmentType    == InventAdjustmentType::Closing
               && lastInventClosing.Active            == NoYes::Yes
               && (! countryRegion_RU
               || (countryRegion_RU
               && lastInventClosing.InventTransCurrency_RU == inventTransCurrency))
               && lastInventClosing.RecId             != inventClosing.RecId;

        if (lastInventClosing.RecId)
        {
            //check if transfer receipts has been adjusted manually
            while select checkInventClosing
            where checkInventClosing.AdjustmentType  == InventAdjustmentType::Transaction
               && checkInventClosing.Active          == NoYes::Yes
               && checkInventClosing.TransDate       >  lastInventClosing.TransDate
               && checkInventClosing.TransDate       <= transDate
               && (! countryRegion_RU
               || (countryRegion_RU
               && checkInventClosing.InventTransCurrency_RU == inventTransCurrency))
            {
                select firstonly forceplaceholders RecId from inventSettlement
                where inventSettlement.Voucher              == checkInventClosing.Voucher
                   && inventSettlement.TransDate            == checkInventClosing.TransDate
                   && inventSettlement.Cancelled            == NoYes::No
                   && inventSettlement.CostAmountAdjustment != 0
                   && (! countryRegion_RU
                   || (countryRegion_RU
                   && inventSettlement.InventTransCurrency_RU   == inventTransCurrency))
                join TableId from inventTrans
                    where inventTrans.RecId         ==  inventSettlement.TransRecId
                       && inventTrans.Qty           > 0
                    join TableId from inventTransOrigin
                        where  inventTransOrigin.RecId             == inventTrans.InventTransOrigin
                           && (inventTransOrigin.ReferenceCategory == InventTransType::QuarantineOrder
                           ||  inventTransOrigin.ReferenceCategory     == InventTransType::InventTransfer
                           ||  inventTransOrigin.ReferenceCategory     == InventTransType::WMSTransport);

                if (inventSettlement.RecId)
                {
                    setPrefix(#prefixFieldValue(inventClosing,adjustmentType,checkInventClosing.adjustmentType));
                    setPrefix(#prefixFieldValue(inventClosing,transDate,checkInventClosing.transDate));
                    setPrefix(#prefixFieldValue(inventClosing,voucher,checkInventClosing.voucher));

                    warning("@SYS78799");
                    warning(strFmt("@SYS78800",checkInventClosing.Voucher,date2StrUsr(checkInventClosing.TransDate, DateFlags::FormatAll)));

                    ok = false;
                }
            }

            if (! ok )
            {
                if (Box::yesNo("@SYS90702",DialogButton::No) != DialogButton::Yes)
                {
                    return false;
                }
                ok = true;
            }

            // find recalcs which existed on a later date during previous closing must be canceled

            while select checkInventRecalc
                where checkInventRecalc.AdjustmentType == InventAdjustmentType::Recalculation  &&
                      checkInventRecalc.Active         == NoYes::Yes                           &&
                      (! countryRegion_RU                                                      ||
                       (countryRegion_RU                                                       &&
                        checkInventRecalc.InventTransCurrency_RU == inventTransCurrency))      &&
                      (checkInventRecalc.Executed      <  lastInventClosing.Executed           ||
                       (checkInventRecalc.Executed     == lastInventClosing.Executed           &&
                        checkInventRecalc.Start        <  lastInventClosing.Start ))           &&
                      checkInventRecalc.TransDate      >  lastInventClosing.TransDate          &&
                      checkInventRecalc.TransDate      <= transDate
            {
                setPrefix(#prefixFieldValue(inventClosing,adjustmentType,checkInventRecalc.adjustmentType));
                setPrefix(#prefixFieldValue(inventClosing,transDate,checkInventRecalc.transDate));
                setPrefix(#prefixFieldValue(inventClosing,voucher,checkInventRecalc.voucher));

                warning("@SYS90442");
                warning("@SYS90443");
                ok = false;
            }

            if (! ok )
            {
                if (Box::yesNo("@SYS90702",DialogButton::No) != DialogButton::Yes)
                {
                    return false;
                }
                ok = true;
            }
        }

        // warning that later recalcs will be canceled.
        while select checkInventRecalc
            where checkInventRecalc.AdjustmentType == InventAdjustmentType::Recalculation  &&
                  checkInventRecalc.Active         == NoYes::Yes                           &&
                  (! countryRegion_RU                                                      ||
                   (countryRegion_RU                                                       &&
                    checkInventRecalc.InventTransCurrency_RU == inventTransCurrency))      &&
                  checkInventRecalc.TransDate      >  transDate
        {
            setPrefix(#prefixFieldValue(inventClosing,adjustmentType,checkInventRecalc.adjustmentType));
            setPrefix(#prefixFieldValue(inventClosing,transDate,checkInventRecalc.transDate));
            setPrefix(#prefixFieldValue(inventClosing,voucher,checkInventRecalc.voucher));

            warning(strFmt("@SYS90444",checkInventRecalc.Voucher, date2StrUsr(checkInventRecalc.TransDate, DateFlags::FormatAll)));
            ok = false;
        }

        if (! ok )
        {
            if (!cancelRecalculation)
            {
                if (Box::yesNo("@SYS90445"+'\n'+
                               "@SYS90446"+'\n'+
                               "@SYS90447",
                               DialogButton::No) != DialogButton::Yes)
                {
                    return false;
                }
            }
            else
            {
                if (Box::yesNo("@SYS90448"+'\n'+
                               "@SYS90447",
                               DialogButton::Yes) != DialogButton::Yes)
                {
                    return false;
                }
            }

            ok = true;
        }
        
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLatestRecalculationFromEarlierPeriod</Name>
				<Source><![CDATA[
    private InventClosing findLatestRecalculationFromEarlierPeriod(RefRecId _calendarRecId)
    {
        TransDate startDateCurrentRecalculationPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(_calendarRecId, transDate).StartDate;

        InventClosing recalcFromEarlierPeriod;
        select firstonly TransDate, RecId from recalcFromEarlierPeriod
            order by TransDate desc
            where recalcFromEarlierPeriod.AdjustmentType    == InventAdjustmentType::Recalculation
                && recalcFromEarlierPeriod.Active           == NoYes::Yes
                && recalcFromEarlierPeriod.TransDate        < startDateCurrentRecalculationPeriod;

        return recalcFromEarlierPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkStdCostConversion</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the closing date complies with not completed standard cost conversions.
    /// </summary>
    /// <param name="_transDate">
    ///    The inventory closing date.
    /// </param>
    /// <returns>
    ///    true if the closing date is valid according to any not completed standard cost conversion;
    ///    otherwise, false.
    /// </returns>
    protected boolean checkStdCostConversion(TransDate _transDate)
    {
        InventStdCostConv inventStdCostConv;
        boolean           countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        if (countryRegion_RU)
        {
            inventStdCostConv = InventStdCostConv::firstNotCompletedConversion(inventTransCurrency);
        }
        else
        {
            inventStdCostConv = InventStdCostConv::firstNotCompletedConversion();
        }

        if (inventStdCostConv.RecId && _transDate >= inventStdCostConv.TransitionStartDate)
        {
            if ((countryRegion_RU
                && !InventClosing::findClosingDate(inventStdCostConv.TransitionStartDate - 1, inventTransCurrency))
                || (! countryRegion_RU && !InventClosing::findClosingDate(inventStdCostConv.TransitionStartDate-1)))
            {
                return checkFailed(strFmt("@SYS120629", inventStdCostConv.Status, date2StrUsr(inventStdCostConv.TransitionStartDate, DateFlags::FormatAll), date2StrUsr(inventStdCostConv.TransitionEndDate, DateFlags::FormatAll)));
            }
            if (_transDate != (inventStdCostConv.TransitionEndDate - 1))
            {
                return checkFailed(strFmt("@SYS120630", date2StrUsr(_transDate, DateFlags::FormatAll), date2StrUsr(inventStdCostConv.TransitionEndDate, DateFlags::FormatAll)));
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSystem</Name>
				<Source><![CDATA[
    boolean checkSystem()
    {
        boolean                 ok = true;
        InventClosing           inventClosingCheck;
        FiscalCalendarRecId     fiscalCalendarRecId = CompanyInfoHelper::fiscalCalendarRecId();

        inventClosingCheck.selectLocked(false);

        select firstonly Voucher, InventCostStatus, RecId from inventClosingCheck
            where inventClosingCheck.InventTransCurrency_RU == inventTransCurrency      &&
                  inventClosingCheck.InventCostStatus       >  InventCostStatus::Ended  &&
                  inventClosingCheck.Active                 == NoYes::Yes;

        if (inventClosingCheck.RecId || !InventCostClosing::checkAnotherInventClosingJobRunning(this.parmCurrentBatch().RecId))
        {
            if (inventClosingCheck.RecId)
            {
                return checkFailed(strFmt("@SCM:InventCostClosingRecordRunningJobVoucherWarning", inventClosingCheck.Voucher));
            }

            return checkFailed("@SYS78037");
        }

        select firstonly RecId, Voucher, CancelClosingRefRecId from inventClosingCheck
            where inventClosingCheck.InventTransCurrency_RU == inventTransCurrency
                && inventClosingCheck.InventCostStatus      >  InventCostStatus::Ended
                && inventClosingCheck.Active                == NoYes::No
                && inventClosingCheck.Cancellation          == NoYes::Yes
                && inventClosingCheck.TransDate             >= InventClosing::closingDate(true, inventTransCurrency);

        if (inventClosingCheck.RecId)
        {
            InventClosing inventClosingCancel;
            str inventClosingCancellationName = "@SCM:InventClosingCancellationName";

            select firstonly Voucher from inventClosingCancel
                where inventClosingCancel.RecId == inventClosingCheck.CancelClosingRefRecId;

            return checkFailed(strFmt("@SCM:ExistFailedCancelAfterLatestClosingError", inventClosingCheck.Voucher, inventClosingCancel.Voucher, inventClosingCancellationName));
        }

        if (! InventClosing::checkClosing(transDate, inventTransCurrency))
        {
            return false;
        }

        FiscalCalendarPeriod fiscalCalendarPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(fiscalCalendarRecId, transDate);
        if (fiscalCalendarPeriod.currentLedgerPeriodStatus() != FiscalPeriodStatus::Open)
        {
            return checkFailed(strFmt("@SYS96735", date2StrUsr(transDate, DateFlags::FormatAll)));
        }

        if(!this.isExpenditureAccountFound(InventAccountType::InventProfit) || !this.isExpenditureAccountFound(InventAccountType::InventLoss))
        {
            return checkFailed("@SCM:SettlementAccountMissing");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExpenditureAccountFound</Name>
				<Source><![CDATA[
    private boolean isExpenditureAccountFound(InventAccountType _inventAccountType)
    {
        InventPosting postingAccount = InventPosting::findByAccountTypeAndItemCode(_inventAccountType, InventPostingItemCode::All);

        return postingAccount.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAnotherInventClosingJobRunning</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether other invent closing job is in running or not.
    /// </summary>
    /// <param name="_batchRecId">
    /// Record Id of current batch, optional.
    /// </param>
    /// <returns>
    /// A <c>Boolean</c> value indicates if checking is passed.
    /// </returns>
    public static boolean checkAnotherInventClosingJobRunning(RecId _batchRecId = 0)
    {
        Batch    batch;
        BatchJob batchJob;

        select firstOnly RecId from batchJob
            exists join batch
            where batch.BatchJobId   == batchJob.RecId
               && batch.status       == BatchStatus::Executing
               && batch.Company      == curext()
               && (!_batchRecId      || batch.RecId != _batchRecId)
               && (batch.ClassNumber == classNum(InventCostClosingRecalc)
               ||  batch.ClassNumber == classNum(InventCostClosingResume)
               ||  batch.ClassNumber == classNum(InventCostClosing)
               ||  batch.ClassNumber == classNum(InventCostClosingCancel_Init));

        if (batchJob.RecId)
        {
            warning(strFmt("@SCM:InventCostClosingRecordRunningJobRecIdWarning", batchJob.RecId));

            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the update ledger parameter.
    /// </summary>
    /// <param name="_ask">
    /// Determines if the user is asked to ignore that the update ledger parameter is not set.
    /// </param>
    /// <returns>
    /// true, if the update ledger parameter is valid; otherwise false;
    /// </returns>
    protected boolean checkUpdateLedger(boolean _ask = false)
    {
        boolean             result = true;

        if (_ask && ! updateLedger)
        {
            if (Box::yesNo("@SYS19298"+'\n'+ "@SYS60031"+'\n\n',DialogButton::Yes) != DialogButton::Yes)
            {
                return false;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closingDialogLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the label for the closing dialog.
    /// </summary>
    /// <returns>
    /// The label for the closing dialog.
    /// </returns>
    protected str closingDialogLabel()
    {
        return "@SYS15867";
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventCostList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the initial work list for the inventory closing.
    /// </summary>
    protected void createInventCostList()
    {
        InventCostList          inventCostList;
        RecordInsertList        recordInsertList = new RecordInsertList(tableNum(InventCostList),true,true);

        // Recompute BOM levels from scratch

        BOMLevelCalc::construct().runOperation();

        // Create query to find the items for the initial work list:

        Query query = this.queryRun().query();

        // InventTable: sort in order of descending BOM level
        QueryBuildDataSource inventTableDS = query.dataSourceTable(tableNum(InventTable));
        if (!inventTableDS)
        {
            inventTableDS = query.addDataSource(tableNum(InventTable));
        }
        inventTableDS.addSortField(fieldNum(InventTable,bomLevel),SortOrder::Descending);

        // InventTrans: only items with open transactions
        QueryBuildDataSource inventTransDS = query.dataSourceTable(tableNum(InventTable)).addDataSource(tableNum(InventTrans));
        inventTransDS.addRange(fieldNum(InventTrans,ValueOpen)).value(queryValue(InventTransOpen::Yes));
        inventTransDS.joinMode(JoinMode::ExistsJoin);
        inventTransDS.relations(true);

        // InventModelGroupItem: adding relationship table between InventTable and InventModelGroup to filter on model group values
        QueryBuildDataSource inventModelGroupItemDS = query.dataSourceTable(tableNum(InventTable)).addDataSource(tableNum(InventModelGroupItem));
        inventModelGroupItemDS.joinMode(JoinMode::ExistsJoin);
        inventModelGroupItemDS.relations(true);

        // InventModelGroup: only items which have an Inventory Model Type that requires inventory closing
        QueryBuildDataSource inventModelGroupDS = inventModelGroupItemDS.addDataSource(tableNum(InventModelGroup));
        inventModelGroupDS.addRange(fieldNum(InventModelGroup,InventModel)).value(InventModelType::queryValueMustBeClosed());
        inventModelGroupDS.joinMode(JoinMode::ExistsJoin);
        inventModelGroupDS.relations(true);

        // Execute query and create the initial work list

        QueryRun queryRun = new QueryRun(query);

        while (queryRun.next())
        {
            InventTable inventTable = queryRun.get(tableNum(InventTable)) as InventTable;

            inventCostList.ItemId            = inventTable.ItemId;
            inventCostList.Voucher           = inventClosing.Voucher;
            inventCostList.NumOfIteration    = 0;
            inventCostList.bomLevel          = inventTable.bomLevel;

            inventCostList.insertUsingInsertList(recordInsertList);
        }

        recordInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventCostListRecordSetFromResume</Name>
				<Source><![CDATA[
    [Hookable(false), Wrappable(false)]
    public void createInventCostListRecordSetFromResume()
    {
        if (!isInventCostClosingSkipCreateInventCostListFlightEnabled || this.hasSettleItem())
        {
            this.createInventCostListRecordSet();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasSettleItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if there is settled model item.
    /// </summary>
    /// <returns> Returns true if there is settled model item.
    /// </returns>
    [Hookable(false)]
    protected boolean hasSettleItem()
    {
        InventTable                 inventTable;
        InventModelGroupItem        inventModelGroupItem;
        InventModelGroup            inventModelGroup;

        select firstonly RecId
            from inventTable
            exists join inventModelGroupItem
            where inventTable.DataAreaId == inventModelGroupItem.ItemDataAreaId &&
                inventTable.ItemId == inventModelGroupItem.ItemId
            exists join inventModelGroup
            where inventModelGroupItem.ModelGroupDataAreaId == inventModelGroup.DataAreaId &&
                inventModelGroupItem.ModelGroupId == inventModelGroup.ModelGroupId &&
                (inventModelGroup.InventModel >= InventModel::FIFO &&
                inventModelGroup.InventModel <= InventModel::AverageCostDate ||
                inventModelGroup.InventModel == InventModel::MonthlyAverageCost);

        return inventTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventCostListRecordSet</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the initial work list for the inventory closing.
    /// </summary>
    protected void createInventCostListRecordSet()
    {
        InventCostList              inventCostList;
        InventTable                 inventTable;
        InventCostClosingUpdateView updateView;
        InventModelGroupItem        inventModelGroupItem;
        InventModelGroup            inventModelGroup;
        Voucher                     voucherNumber = inventClosing.Voucher;

        // Recompute BOM levels from scratch
        BOMLevelCalc::construct().runOperation();

        InventClosing prevInventClosing = InventClosing::findPrevClosingDate(inventClosing.TransDate, inventClosing.InventTransCurrency_RU);

        if (InventCostListCreationWithSeparateQueryFlight::instance().isEnabled())
        {
            this.createInventCostListFromSeparateView(prevInventClosing.TransDate, voucherNumber);
        }
        else
        {
            insert_recordset inventCostList
            (ItemId, bomLevel, Voucher)
            select  ItemId, bomLevel, voucherNumber
                from inventTable
                exists join inventModelGroupItem
                where inventTable.DataAreaId == inventModelGroupItem.ItemDataAreaId &&
                      inventTable.ItemId == inventModelGroupItem.ItemId
                exists join inventModelGroup
                where  inventModelGroupItem.ModelGroupDataAreaId == inventModelGroup.DataAreaId &&
                        inventModelGroupItem.ModelGroupId == inventModelGroup.ModelGroupId &&
                        (inventModelGroup.InventModel >= InventModel::FIFO &&
                        inventModelGroup.InventModel <= InventModel::AverageCostDate ||
                        inventModelGroup.InventModel == InventModel::MonthlyAverageCost)
                exists join updateView
                    where updateView.ItemId == inventTable.ItemId
                        && updateView.TransDate > prevInventClosing.TransDate
                        && updateView.TransDate <= inventClosing.TransDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods described by the <c>RunBaseDialogable</c> interface.
    /// </summary>
    /// <returns>
    ///    Returns an object of type <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be either built by using the dialog system or by using a class that is created in the
    ///    Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        dialog = super();

        dialog.addGroup(adjustmentType == InventAdjustmentType::Recalculation ? "@SYS90709" : "@SYS90708");

        if (this.showCancelRecalculation())
        {
            dialogCancelRecalculation  = dialog.addField(enumStr(NoYes), 
                                                         "@SCM:InventClosingCancellationGeneralTabSetUp",
                                                         adjustmentType == InventAdjustmentType::Recalculation ? "@SYS90704"
                                                                                                               : "@SYS90705");
            dialogCancelRecalculation.value(cancelRecalculation);
            dialogCancelRecalculation.enabled(this.enableCancelRecalculation());

            // Hide this field. Do not remove the code.
            dialogCancelRecalculation.visible(NoYes::No);
        }

        DialogGroup dlgClosing = dialog.addGroup(this.closingDialogLabel());

        dialogPeriodCode = dialog.addField(extendedTypeStr(DateCode), "@SYS22717", "@SYS22717");
        FormBuildStringControl formStringControlPeriodCode = dialogPeriodCode.control();
        formStringControlPeriodCode.registerOverrideMethod(
            methodStr(FormStringControl, modified),
            'periodCode_modified',
            this);
        formStringControlPeriodCode.registerOverrideMethod(
            methodStr(FormStringControl, validate),
            'periodCode_validate',
            this);
        dialogPeriodCode.value(periodCode);

        dialogDate          = dialog.addField(extendedTypeStr(TransDate), this.transDateLabel(), this.transDateHelp());
        dialogDate.value(transDate);

        if (this.showSpecification())
        {
            dialogSpecification     = dialog.addField(enumStr(InventAdjustmentSpec), "@SYS78941", "@SYS19204");
            dialogSpecification.value(specification);
        }

        dialogProdJournal       = dialog.addField(enumStr(NoYes), "@SYS17515", "@SYS28265");
        dialogProdJournal.value(prodJournal);
        // Hide this field. Do not remove the code.
        dialogProdJournal.visible(NoYes::No);

        dialogLedger            = dialog.addField(enumStr(NoYes), "@SYS17508", "@SYS28266");
        dialogLedger.value(updateLedger);
        // Hide this field. Do not remove the code.
        dialogLedger.visible(NoYes::No);

        dialogNotes             = dialog.addField(extendedTypeStr(FreeTxt), "@SYS13887", "@SYS27801");
        dialogNotes.value(freeTxt);

        DialogGroup dlgAdv = dialog.addGroup("@SCM:CostIterationParameters",dlgClosing);
        dlgAdv.frameOptionButton(FormFrameOptionButton::Hide);
        dlgAdv.optionValue(collapseGroups ? 0 : 1);
        dlgAdv.visible(this.showAdvanced());

        if (this.showAdvanced())
        {
            dialogMaxIterations     = dialog.addField(extendedTypeStr(Integer), "@SCM:CostMaximumIterations", "@SYS65225");
            dialogMaxIterations.value(maxIterations);

            dialogMinTransferValue  = dialog.addField(extendedTypeStr(CostAmount), "@SCM:MinimumAmounAllowed", "@SYS65227");
            dialogMinTransferValue.value(minTransferValue);
        }

        dialog.addGroup(adjustmentType == InventAdjustmentType::Recalculation ? "@SYS90706" : "@SYS90707");

        if (this.showRunRecalculation())
        {
            dialogRunRecalculation  = dialog.addField(enumStr(NoYes), "@SYS88068", "@SYS88069");
            dialogRunRecalculation.value(runRecalculation);
        }

        dialog.addGroup("@SCM:InfologSetting");
        dialogShouldSummarizeInfolog = dialog.addField(enumStr(NoYes), "@SCM:ShouldSummarizeInfolog", "@SCM:AllowDetailInfolog");
        dialogShouldSummarizeInfolog.value(shouldSummarizeInfolog);

        dialog.defaultButton(DialogDefaultButton::Cancel);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableCancelRecalculation</Name>
				<Source><![CDATA[
    protected boolean enableCancelRecalculation()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        transDate          = dialogDate.value();

        if (this.showSpecification())
        {
            specification      = dialogSpecification.value();
        }

        updateLedger       = dialogLedger.value();

        if (this.showCancelRecalculation())
        {
            cancelRecalculation = dialogCancelRecalculation.value();
        }
        else
        {
            cancelRecalculation = false;
        }

        if (this.showRunRecalculation())
        {
            runRecalculation = dialogRunRecalculation.value();
        }
        else
        {
            runRecalculation = false;
        }

        shouldSummarizeInfolog = dialogShouldSummarizeInfolog.value();

        prodJournal         = dialogProdJournal.value();
        updateLedger        = dialogLedger.value();
        freeTxt             = dialogNotes.value();

        if (this.showAdvanced())
        {
            maxIterations       = dialogMaxIterations.value();
            minTransferValue    = dialogMinTransferValue.value();
        }

        periodCode          = dialogPeriodCode.value();

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventClosing</Name>
				<Source><![CDATA[
    protected void initInventClosing()
    {
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        inventClosing.clear();
        inventClosing.Ledger                = updateLedger;
        inventClosing.Executed              = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        inventClosing.Start                 = DateTimeUtil::getTimeNow(DateTimeUtil::getUserPreferredTimeZone());

        if (countryRegion_RU)
        {
            inventClosing.Voucher           = NumberSeq::newGetNum(InventClosing::numberSequenceReference(adjustmentType, inventTransCurrency)).num();
        }
        else
        {
            inventClosing.Voucher               = NumberSeq::newGetNum(InventClosing::numberSequenceReference(adjustmentType)).num();
        }

        inventClosing.AdjustmentType        = adjustmentType;
        inventClosing.Active                = NoYes::Yes;
        inventClosing.PeriodCode            = periodCode;
        inventClosing.TransDate             = transDate;
        inventClosing.AdjustmentSpec        = specification;
        inventClosing.ProdJournal           = prodJournal;
        inventClosing.Cancellation          = NoYes::No;
        inventClosing.Notes                 = freeTxt;
        inventClosing.ShouldSummarizeInfolog = shouldSummarizeInfolog;
        inventClosing.InventCostStatus      = InventCostStatus::Calculation;
        inventClosing.MaxIterations         = maxIterations;
        inventClosing.MinTransferValue      = minTransferValue;
        inventClosing.CancelRecalculation   = cancelRecalculation;
        inventClosing.RunRecalculation      = inventClosing.TransDate < DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) ? runRecalculation : NoYes::No;

        if (countryRegion_RU)
        {
            inventClosing.InventTransCurrency_RU = inventTransCurrency;
        }

        inventClosing.LedgerCorrection      = LedgerParameters::isStornoEnabledEE();
        if (inventClosing.LedgerCorrection)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceEEU00015, funcName());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Called when no <c>SysLastValue</c> record is found by using the <c>SysLastValue.GetLast</c> method.
    /// </summary>
    /// <remarks>
    ///    This method should initialize the internal variables. Remember to call the <c>super</c> method.
    /// </remarks>
    public void initParmDefault()
    {
        specification       = InventAdjustmentSpec::Total;
        updateLedger        = NoYes::Yes;
        prodJournal         = NoYes::Yes;
        cancelRecalculation = NoYes::Yes;
        runRecalculation    = NoYes::No;

        maxIterations       = 100;
        minTransferValue    = 1;
        adjustmentType      = InventAdjustmentType::Closing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransDate</Name>
				<Source><![CDATA[
    protected void initTransDate(boolean _fallbackToDefaultDate
                               , InventTransCurrency_RU _inventTtransCurrency = InventTransCurrency_RU::PrimaryCur
    )
    {
        if (periodCode != '')
        {
            LedgerPeriodCode ledgerPeriodCode = LedgerPeriodCode::find(periodCode);
            if (ledgerPeriodCode.RecId)
            {
                transDate = ledgerPeriodCode.toDate();
            }
            else
            {
                periodCode = '';
                if (_fallbackToDefaultDate)
                {
                    transDate = InventCostClosing::defaultDate(_inventTtransCurrency);
                }
            }
        }
        else if (_fallbackToDefaultDate)
        {
            transDate = InventCostClosing::defaultDate(_inventTtransCurrency);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventClosing</Name>
				<Source><![CDATA[
    public InventClosing inventClosing()
    {
        return inventClosing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostTaskController</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates an <c>InventCostTaskController</c> object.
    /// </summary>
    /// <returns>
    /// An <c>InventCostTaskController</c> object.
    /// </returns>
    protected InventCostTaskController inventCostTaskController()
    {
        if (this.isInBatch())
        {
            return InventCostTaskController::newFromParameters( this.parmCurrentBatch().BatchJobId,
                                                                this.parmCurrentBatch().RecId,
                                                                inventClosing.Voucher,
                                                                inventClosing.TransDate,
                                                                inventClosing.RunNum);
        }

        return InventCostTaskControllerSingleThread::newController( inventClosing.Voucher,
                                                                    inventClosing.TransDate,
                                                                    inventClosing.RunNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Serializes the current instance of the <c>InventCostClosing</c> class.
    /// </summary>
    /// <returns>
    ///    A container that contains the current instance of the <c>InventCostClosing</c> class.
    /// </returns>
    /// <remarks>
    ///    When
    ///    <c>
    ///       isSwappingPrompt
    ///    </c>
    ///     returns true, you may have to pack some prompt-related variables also.Normally a macro declared in
    ///    the
    ///    <c>
    ///       classDeclaration
    ///    </c>
    ///     is used to list the variables to be packed. Another macro holds a version number. This number
    ///    refers to the version of the variable list.When a new variable is introduced, you should typically
    ///    do the following:
    ///    <list type="number">
    ///       <item>
    ///          <description>Increment the version number in the version macro.</description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             Copy the current list to the <c>unpack</c> method (For details, see the description in that topic).
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>Add the new variable to the bottom of the list.</description>
    ///       </item>
    ///       <item>
    ///          <description>Recompile the class.</description>
    ///       </item>
    ///    </list>
    /// </remarks>
    public container  pack()
    {
        if (!this.isSwappingPrompt())
        {
            collapseGroups = true;
        }

        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjustmentType</Name>
				<Source><![CDATA[
    public InventAdjustmentType parmAdjustmentType(InventAdjustmentType _adjustmentType = adjustmentType)
    {
        adjustmentType = _adjustmentType;
        return adjustmentType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCancelRecalculation</Name>
				<Source><![CDATA[
    public NoYes parmCancelRecalculation(NoYes _cancelRecalculation = cancelRecalculation)
    {
        cancelRecalculation = _cancelRecalculation;
        return cancelRecalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFreeTxt</Name>
				<Source><![CDATA[
    public FreeTxt parmFreeTxt(FreeTxt _freeTxt = freeTxt)
    {
        freeTxt    = _freeTxt;
        return freeTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTransCurrency_RU</Name>
				<Source><![CDATA[
    protected InventTransCurrency_RU parmInventTransCurrency_RU(InventTransCurrency_RU _inventTransCurrency = inventTransCurrency)
    {
        inventTransCurrency = _inventTransCurrency;
        return inventTransCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMaxIterations</Name>
				<Source><![CDATA[
    public Integer parmMaxIterations(Integer   _maxIterations = maxIterations)
    {
        maxIterations = _maxIterations;
        return maxIterations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMinTransferValue</Name>
				<Source><![CDATA[
    public CostAmount parmMinTransferValue(CostAmount _minTransferValue = minTransferValue)
    {
        minTransferValue = _minTransferValue;
        return minTransferValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPeriodCode</Name>
				<Source><![CDATA[
    public DateCode parmPeriodCode(DateCode _periodCode = periodCode)
    {
        periodCode = _periodCode;

        return periodCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProdJournal</Name>
				<Source><![CDATA[
    public NoYes parmProdJournal(NoYes _prodJournal = prodJournal)
    {
        prodJournal = _prodJournal;
        return prodJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRunRecalculation</Name>
				<Source><![CDATA[
    public boolean parmRunRecalculation(boolean _runRecalculation = runRecalculation)
    {
        runRecalculation = _runRecalculation;

        return runRecalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSpecification</Name>
				<Source><![CDATA[
    public InventAdjustmentSpec parmSpecification(InventAdjustmentSpec _specification = specification)
    {
        specification = _specification;
        return specification;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransDate</Name>
				<Source><![CDATA[
    public TransDate parmTransDate(TransDate _transDate = transDate)
    {
        transDate = _transDate;
        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateLedger</Name>
				<Source><![CDATA[
    public NoYes parmUpdateLedger(NoYes _updateLedger = updateLedger)
    {
        updateLedger = _updateLedger;
        return updateLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventClosing</Name>
				<Source><![CDATA[
    [Hookable(false), Wrappable(false)]
    public InventClosing parmInventClosing(InventClosing _inventClosing = inventClosing)
    {
        inventClosing = _inventClosing;
        return inventClosing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodCode_modified</Name>
				<Source><![CDATA[
    private boolean periodCode_modified(FormStringControl _dialogPeriodCode)
    {
        _dialogPeriodCode.modified();

        DateCode dateCode = _dialogPeriodCode.valueStr();
        if (dateCode != "")
        {
            LedgerPeriodCode ledgerPeriodCode = LedgerPeriodCode::find(dateCode);
            if (ledgerPeriodCode.RecId)
            {
                ToDate toDate = ledgerPeriodCode.toDate();
                dialogDate.value(toDate);
                transDate = toDate;
            }
        }

        dialogDate.allowEdit(dateCode == "");

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodCode_validate</Name>
				<Source><![CDATA[
    private boolean periodCode_validate(FormStringControl _dialogPeriodCode)
    {
        boolean             result = true;

        DateCode dateCode = _dialogPeriodCode.valueStr();
        if (dateCode != "")
        {
            LedgerPeriodCode ledgerPeriodCode = LedgerPeriodCode::find(dateCode);
            if (!ledgerPeriodCode.RecId)
            {
                result = checkFailed(strFmt("@SYS312171", dateCode));
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    ///    The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    ///    This method is used if a query prompt is in the dialog and if a select menu item is added to a
    ///    dialog. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it
    ///    in the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    QueryRun queryRun()
    {
        return new QueryRun(new Query());
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        #OCCRetryCount

        Integer logPointBegin = infologLine();
        boolean closingCreated;

        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        if (countryRegion_RU)
        {
            setPrefix(InventCostClosing::prefixText(adjustmentType, inventTransCurrency));
        }
        else
        {
            setPrefix(InventCostClosing::prefixText(adjustmentType));
        }

        // init closing

        try
        {
            this.initTransDate(false);

            ttsbegin;
            select firstonly pessimisticlock inventClosing;

            if (this.checkSystem())
            {
                this.initInventClosing();

                if (LedgerVoucherObject::validateVoucher(inventClosing.Voucher,
                                                         NumberSeq::newGetNum(InventClosing::numberSequenceReference(adjustmentType)).parmNumberSequenceCode(),
                                                         inventClosing.TransDate))
                {
                    inventClosing.insert();
                }

                inventClosingRecId = inventClosing.RecId;
                closingCreated = true;
            }
            ttscommit;

            if (closingCreated)
            {
                if (countryRegion_RU)
                {
                    if (! this.isInBatch())
                    {
                        this.progressInit(InventCostClosing::prefixText(adjustmentType, inventTransCurrency),1,#AviUpdate);
                    }
                }
                else
                {
                    this.progressInit(InventCostClosing::prefixText(adjustmentType),1,#AviUpdate);
                }
                if (! (countryRegion_RU && this.isInBatch()))
                {
                    progress.update();
                }

                if (inventClosing.CancelRecalculation)
                {
                    this.cancelRecalculations(inventClosing);
                }

                this.progressKill();

                ttsbegin;

                // Assuming the WIP calculation can open transactions
                this.runProdWIPCalculation_RU();

                if (!isInventCostClosingSkipCreateInventCostListFlightEnabled || this.hasSettleItem())
                {
                    this.createInventCostListRecordSet();
                }
                ttscommit;

                inventCostTaskController = this.inventCostTaskController();
                inventCostTaskController.run();

                this.progressKill();

                this.writeClosingLog(logPointBegin);
            }
            else
            {
                throw error("@SYS18447");
            }
        }
        catch (Exception::Deadlock)
        {
            ttsbegin;
            if (inventCostTaskController)
            {
                inventCostTaskController.deleteBundles();
            }
            ttscommit;

            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    ttsbegin;
                    if (inventCostTaskController)
                    {
                        inventCostTaskController.deleteBundles();
                    }
                    ttscommit;

                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::Error)
        {
            if (closingCreated   &&
                this.isInBatch())
            {
                this.writeClosingLog(logPointBegin);
            }

            throw Exception::Error;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runProdWIPCalculationFromResume_RU</Name>
				<Source><![CDATA[
    [Hookable(false), Wrappable(false)]
    public void runProdWIPCalculationFromResume_RU()
    {
        this.runProdWIPCalculation_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>runProdWIPCalculation_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes production Work-In-Progress orders adjustment calculation and posting.
    /// </summary>
    protected void runProdWIPCalculation_RU()
    {
        ProdTable                       prodTable;
        ProdWIPHistoricalCostTable_RU   wipHistoricalCostTableEnded;
        ProdWIPHistoricalCostTable_RU   wipHistoricalCostTable;
        InventDim                       prodInventDim;
        InventSiteId                    prevInventSiteId;
        boolean                         prevNotCalculatingWIP;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]))
        {
            ttsbegin;

            NumberSeq numberSeq = NumberSeq::newGetNum(ProdParameters::numRefProdCalcVoucherId());

            while select prodTable
                where prodTable.RealDate    <= inventClosing.TransDate &&
                      prodTable.RealDate    != dateNull()
                join InventSiteId from prodInventDim order by InventSiteId
                    where prodInventDim.InventDimId == prodTable.InventDimId
                exists join wipHistoricalCostTable
                    where wipHistoricalCostTable.ProdId == prodTable.ProdId
                notexists join wipHistoricalCostTableEnded
                     where wipHistoricalCostTableEnded.ProdId    == prodTable.ProdId &&
                           wipHistoricalCostTableEnded.Cancelled == NoYes::No        &&
                           wipHistoricalCostTableEnded.EndJob    == NoYes::Yes
            {
                if (prevInventSiteId == prodInventDim.InventSiteId)
                {
                    if (prevNotCalculatingWIP)
                    {
                        continue;
                    }
                }
                else
                {
                    prevInventSiteId      = prodInventDim.InventSiteId;
                    prevNotCalculatingWIP = false;

                    if (!prodTable.prodParametersDim().CalculatingWIP_RU)
                    {
                        prevNotCalculatingWIP = true;
                        continue;
                    }
                }

                Voucher voucher = numberSeq.num();

                LedgerVoucher ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary,
                                                                          SysModule::Prod,
                                                                          numberSeq.parmNumberSequenceCode());
                ledgerVoucher.parmCheckBlockedDimensions(false);

                TransactionTxt transactionTxt = TransactionTxt::construct();
                transactionTxt.setType(LedgerTransTxt::ProdHistoricalCost);
                transactionTxt.setDate(inventClosing.TransDate);
                transactionTxt.setVoucher(voucher);
                transactionTxt.setKey1(prodTable.ProdId);
                transactionTxt.setKey2(prodTable.ItemId);

                LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(voucher,
                                                                                          inventClosing.TransDate,
                                                                                          SysModule::Prod,
                                                                                          LedgerTransType::Production);
                ledgerVoucherObject.lastTransTxt(transactionTxt.txt());
                ledgerVoucher.addVoucher(ledgerVoucherObject);

                ProdCalculatingWIPEngine_RU::runFromProdTable(prodTable.ProdId, ledgerVoucher, true);

                ledgerVoucher.end();
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the batch task is run on the server or on a client.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    /// <remarks>
    ///    Your classes that extend this class must override the <c>runsImpersonated</c> method and return
    ///    false, if you want those tasks to run on a client.
    /// </remarks>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showAdvanced</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the advanced dialog group should be visible.
    /// </summary>
    /// <returns>
    /// True if the advanced dialog group should be visible; otherwise false.
    /// </returns>
    protected boolean showAdvanced()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showCancelRecalculation</Name>
				<Source><![CDATA[
    protected boolean showCancelRecalculation()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showRunRecalculation</Name>
				<Source><![CDATA[
    protected boolean showRunRecalculation()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showSpecification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the specification field should be visible.
    /// </summary>
    /// <returns>
    /// true, if the specification field should be visible; otherwise false.
    /// </returns>
    protected boolean showSpecification()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDateHelp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the help for the transaction date in the dialog.
    /// </summary>
    /// <returns>
    /// The help for the transaction date in the dialog.
    /// </returns>
    protected str transDateHelp()
    {
        return "@SYS28262";
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDateLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the label for the transaction date in the dialog.
    /// </summary>
    /// <returns>
    /// The label for the transaction date in the dialog.
    /// </returns>
    protected str transDateLabel()
    {
        return "@SYS17636";
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deserializes the <paramref name="packedClass" /> parameter value to an instance of the
    ///    <c>InventCostClosing</c> class.
    /// </summary>
    /// <param name="packedClass">
    ///    The container from which to deserialize the instance.
    /// </param>
    /// <returns>
    ///    true if deserialization was successful; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    When the <c>isSwappingPrompt</c> method returns true, you may have to unpack some prompt-related
    ///    variables also.
    /// </remarks>
    public boolean unpack(container packedClass)
    {
        #LOCALMACRO.Version1List
            TransDate,
            Specification,
            ProdJournal,
            UpdateLedger,
            FreeTxt,
            MaxIterations,
            MinTransferValue,
            adjustmentType,
            del_minSettlePct,
            del_minSettleValue
        #ENDMACRO

        #LOCALMACRO.Version2List
            TransDate,
            Specification,
            ProdJournal,
            UpdateLedger,
            FreeTxt,
            MaxIterations,
            MinTransferValue,
            adjustmentType,
            del_minSettlePct,
            del_minSettleValue,
            cancelRecalculation,
            runRecalculation,
            collapseGroups
        #ENDMACRO

        Percent    del_minSettlePct;
        CostAmount del_minSettleValue;

        boolean         ret;
        Integer         version     = conPeek(packedClass,1);

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = packedClass;
                select firstonly inventClosing where inventClosing.RecId == inventClosingRecId;
                ret = true;
                break;

            case 4:
                [version, #CurrentList] = packedClass;
                periodCode = "";
                ret = true;
                break;

            case 3:
                // List has not changed, just the prodJournal must now always be updated
                [version, #CurrentList] = packedClass;
                prodJournal              = NoYes::Yes;
                updateLedger             = NoYes::Yes;
                ret = true;
                break;

            case 2:
                [version, #Version2List] = packedClass;
                prodJournal              = NoYes::Yes;
                updateLedger             = NoYes::Yes;
                ret = true;
                break;

            case 1:
                [version, #Version1List] = packedClass;
                prodJournal               = NoYes::Yes;
                updateLedger             = NoYes::Yes;
                cancelRecalculation       = NoYes::Yes;
                runRecalculation          = NoYes::No;
                ret = true;
                break;

            default:
                ret = false;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustGoBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls if the class must be run in batch mode.
    /// </summary>
    /// <returns>true if the user is not an developer; otherwise, false.</returns>
    /// <remarks>Running inventory closing/recalculation in a non-batch mode is not supported.</remarks>
    public boolean mustGoBatch()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIncludingDaysThatAreNotOver</Name>
				<Source><![CDATA[
    private boolean isIncludingDaysThatAreNotOver()
    {
        if (transDate >= DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>userAcceptsToIncludeDaysThatAreNotOver</Name>
				<Source><![CDATA[
    private boolean userAcceptsToIncludeDaysThatAreNotOver()
    {
        return Box::confirm(strFmt("@SCM:InventClosingInTheFutureConfirmationMessage", transDate));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object calledFrom = null)
    {
        // <GCN>
        #ISOCountryRegionCodes
        // </GCN>
        
        if (adjustmentType == InventAdjustmentType::Closing &&
            this.isIncludingDaysThatAreNotOver() &&
            !this.userAcceptsToIncludeDaysThatAreNotOver())
        {
            return false;
        }

        if (! this.checkParameters(true))
        {
            return false;
        }

        if (! this.checkPostingOK())
        {
            return false;
        }

        if (! this.checkSystem())
        {
            return false;
        }

        // <GCN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCN]))
        {
            if (! this.validateDateByMonthlyAverage_CN())
            {
                return false;
            }
        }
        // </GCN>

        if (runRecalculation && this.severalRecalculationPeriods())
        {
            str prompt = strFmt("@SCM:RunSeveralInventoryRecalculationsPrompt", transDate, DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()));
            DialogButton answer = Box::yesNo(prompt, DialogButton::No);
            if (answer == DialogButton::No)
            {
                return false;
            }
        }

        if (!InventTransArchiveProcessHistoryTable::checkNotFinishedArchiveJob())
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>severalRecalculationPeriods</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the dates between transDate and Today's date span more than one fiscal period
    /// </summary>
    /// <returns>
    ///     True if the dates span more than one fiscal period; otherwise, false.
    /// </returns>
    private boolean severalRecalculationPeriods()
    {
        FiscalCalendarRecId  calendarRecId = LedgerPeriodCode::fiscalCalendarRecId();
        TransDate today = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
        PeriodDate previousPeriodEndDate = FiscalCalendars::findPrevPeriodEndDateByDate(calendarRecId, today);
        
        return transDate < previousPeriodEndDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDateByMonthlyAverage_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the closing date based on the rule of monthly average cost.
    /// </summary>
    /// <returns>
    /// True if the closing date is valid,; otherwise, false.
    /// </returns>
    protected boolean validateDateByMonthlyAverage_CN()
    {
        InventTable             inventTable;
        InventModelGroup        inventModelGroup;
        InventModelGroupItem    inventModelGroupItem;
        InventTrans             inventTrans;
        boolean                 isOK = true;

        //check if exist item with month average model
        select firstonly RecId, ItemId, DataAreaId from inventTable
            exists join ModelGroupId, ModelGroupDataAreaId from inventModelGroupItem
                where inventModelGroupItem.ItemId               == inventTable.ItemId
                    && inventModelGroupItem.ItemDataAreaId       == inventTable.DataAreaId
            exists join inventModelGroup
                where inventModelGroup.ModelGroupId              == inventModelGroupItem.ModelGroupId
                    && inventModelGroup.DataAreaId               == inventModelGroupItem.ModelGroupDataAreaId
                    && inventModelGroup.InventModel              == InventModel::MonthlyAverageCost;

        if (inventTable.RecId == 0)
        {
            return true;
        }

        TransDate lastDayOfPeriod = LedgerFiscalCalendar::findLastDayofPeriod(CompanyInfoHelper::fiscalCalendarRecId(), transDate);

        switch (adjustmentType)
        {
            case InventAdjustmentType::Closing:
                // must be end date of period
                if (transDate != lastDayOfPeriod)
                {
                    isOK = checkFailed("@GLS63355");
                }
                // must be before the session date
                else if (transDate > DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
                {
                    isOK = checkFailed("@GLS63360");
                }

                break;

            case InventAdjustmentType::Recalculation:
                // Make sure no transactions in this period after the transDate
                select firstonly RecId, ItemId, DataAreaId from inventTable
                    join ItemId, ModelGroupId, ModelGroupDataAreaId from inventModelGroupItem
                        where inventModelGroupItem.ItemId               == inventTable.ItemId
                            && inventModelGroupItem.ItemDataAreaId       == inventTable.DataAreaId
                    exists join inventModelGroup
                        where inventModelGroup.ModelGroupId              == inventModelGroupItem.ModelGroupId
                            && inventModelGroup.DataAreaId               == inventModelGroupItem.ModelGroupDataAreaId
                            && inventModelGroup.InventModel              == InventModel::MonthlyAverageCost
                    exists join inventTrans
                        where inventTrans.ItemId            == inventTable.ItemId
                            && inventTrans.ValueOpen        == InventTransOpen::Yes
                            && inventTrans.StatusReceipt    >= StatusReceipt::None
                            && inventTrans.StatusReceipt    <= StatusReceipt::Purchased
                            && inventTrans.StatusIssue      >= StatusIssue::None
                            && inventTrans.StatusIssue      <= StatusIssue::Sold
                            && !inventTrans.MarkingRefInventTransOrigin
                            && inventTrans.DateFinancial    > transDate
                            && inventTrans.DateFinancial    <= lastDayOfPeriod;

                if (inventTable.RecId != 0)
                {
                    isOK = checkFailed("@GLS63356");
                }

                break;

            default:
                break;
        }

        return isOK;
    }

]]></Source>
			</Method>
			<Method>
				<Name>callerInventTransCurrency_RU</Name>
				<Source><![CDATA[
    public static InventTransCurrency_RU callerInventTransCurrency_RU(Args _args)
    {
        Object                 object = _args.caller();
        InventTransCurrency_RU inventTransCurrency = InventTransCurrency_RU::PrimaryCur;

        if (object && object.name() == formStr(InventClosing))
        {
            inventTransCurrency = object.inventTransCurrency_RU();
        }
        return inventTransCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static InventCostClosing construct(InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur)
    {
        var factoryAttr = new InventTransCurrencyCostClosingFactoryAttribute(_inventTransCurrency);
        var instance = SysExtensionAppClassFactory::getClassFromSysAttribute(classStr(InventCostClosing), factoryAttr);

        if (instance == null)
        {
            instance = new InventCostClosing();
        }

        return instance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDate</Name>
				<Source><![CDATA[
    public static TransDate defaultDate(InventTransCurrency_RU _inventTtransCurrency = InventTransCurrency_RU::PrimaryCur)
    {
        TransDate defaultDate;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            defaultDate = InventClosing::closingDate(true, _inventTtransCurrency);
        }
        else
        {
            defaultDate = InventClosing::closingDate(true);
        }

        if (defaultDate)
        {
            if (defaultDate != endmth(defaultDate))
            {
                defaultDate = endmth(defaultDate);
            }
            else
            {
                defaultDate = endmth(nextMth(defaultDate));
            }
        }
        else
        {
            defaultDate = endmth(prevMth(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())));
        }

        return defaultDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the description of the inventory close task.
    /// </summary>
    /// <returns>
    /// Inventory close task description.
    /// </returns>
    static ClassDescription description()
    {
        return "@SYS1340";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
    {
        InventCostClosing       closing;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            InventTransCurrency_RU inventTransCurrency = InventCostClosing::callerInventTransCurrency_RU(args);
            closing = InventCostClosing::newParameters(inventTransCurrency);
        }
        else
        {
            closing = InventCostClosing::newParameters();
        }

        if (! closing.prompt())
        {
            return;
        }

        try
        {
            closing.runOperation();
        }
        catch
        {
            exceptionTextFallThrough();
        }

        if (args && args.caller() && args.dataset() == tableNum(InventClosing))
        {
            InventClosing inventClosing = args.record() as InventClosing;
            FormDataSource fd = FormDataUtil::getFormDataSource(inventClosing);

            if (fd)
            {
                args.lookupRecord(closing.inventClosing());
                fd.research(false);
                InventClosingLog::showLog(inventClosing.TransDate,inventClosing.Voucher);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventClosing</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <c>InventCostClosing</c> class.
    /// </summary>
    /// <param name="_inventClosing">
    ///    The inventory closing record that provides the parameters that are used to initialize this class.
    /// </param>
    /// <param name="_transDate">
    ///    The transaction date on which the inventory closing should be performed.
    /// </param>
    /// <param name="_inventTransCurrency">
    ///    The transaction currency code for the inventory transaction; Optional.
    /// </param>
    /// <returns>
    ///    An initialized instance of the <c>InventCostClosing</c> class.
    /// </returns>
    /// <remarks>
    ///    This method is used for the standard cost conversion to automatically trigger an inventory closing.
    /// </remarks>
    public static InventCostClosing newInventClosing(InventClosing _inventClosing,
                                                          TransDate                _transDate,
                                                          InventTransCurrency_RU   _inventTransCurrency = InventTransCurrency_RU::PrimaryCur)
    {
        InventCostClosing closing;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            closing = InventCostClosing::construct(_inventTransCurrency);
        }
        else
        {
            closing = InventCostClosing::construct();
        }

        closing.initParmDefault();
        closing.parmAdjustmentType(InventAdjustmentType::Closing);
        closing.parmTransDate(_transDate);
        closing.parmUpdateLedger(_inventClosing.Ledger);
        closing.parmCancelRecalculation(_inventClosing.CancelRecalculation);
        closing.parmRunRecalculation(_inventClosing.RunRecalculation);
        closing.parmSpecification(_inventClosing.AdjustmentSpec);
        closing.parmProdJournal(_inventClosing.ProdJournal);
        closing.parmFreeTxt(_inventClosing.Notes);
        closing.parmMaxIterations(_inventClosing.MaxIterations);
        closing.parmMinTransferValue(_inventClosing.MinTransferValue);

        return closing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newParameters</Name>
				<Source><![CDATA[
    public static InventCostClosing newParameters(
        InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur
    )
    {
        InventCostClosing  closing;
        boolean            countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        if (countryRegion_RU)
        {
            closing = InventCostClosing::construct(_inventTransCurrency);
        }
        else
        {
            closing = InventCostClosing::construct();
        }

        closing.getLast();
        closing.parmAdjustmentType(InventAdjustmentType::Closing);

        if (countryRegion_RU)
        {
            closing.initTransDate(true, _inventTransCurrency);
        }
        else
        {
            closing.initTransDate(true);
        }

        closing.parmFreeTxt('');

        if (countryRegion_RU)
        {
            closing.parmInventTransCurrency_RU(_inventTransCurrency);
        }

        return closing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prefixText</Name>
				<Source><![CDATA[
    static ClassDescription prefixText(InventAdjustmentType   _adjustmentType,
                                       InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur)
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
            && (_inventTransCurrency == InventTransCurrency_RU::SecondaryCur))
        {
            return _adjustmentType == InventAdjustmentType::Closing ? InventCostClosingSecCur_RU::description() : InventCostClosingRecalcSecCur_RU::description();
        }

        return _adjustmentType == InventAdjustmentType::Closing ? InventCostClosing::description() : InventCostClosingRecalc::description();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeClosingLog</Name>
				<Source><![CDATA[
    private void writeClosingLog(Integer _logPointBegin)
    {
        Integer logPointNow = infologLine();
        if (_logPointBegin + 1 <= logPointNow)
        {
            inventClosing.writeLog(infolog.cut(_logPointBegin + 1, logPointNow));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventCostListFromSeparateView</Name>
				<Source><![CDATA[
    private void createInventCostListFromSeparateView(
        TransDate _prevInventClosingTransDate,
        Voucher   _voucherNumber)
    {
        InventTable              inventTable;
        InventModelGroupItem     inventModelGroupItem;
        InventModelGroup         inventModelGroup;
        InventCostListItemTempDB inventCostListItemTempDB;

        insert_recordset inventCostListItemTempDB
            (ItemId, BOMLevel)
            select  ItemId, bomLevel
                from inventTable
                exists join inventModelGroupItem
                where inventTable.DataAreaId == inventModelGroupItem.ItemDataAreaId &&
                      inventTable.ItemId == inventModelGroupItem.ItemId
                exists join inventModelGroup
                where  inventModelGroupItem.ModelGroupDataAreaId == inventModelGroup.DataAreaId &&
                        inventModelGroupItem.ModelGroupId == inventModelGroup.ModelGroupId &&
                        (inventModelGroup.InventModel >= InventModel::FIFO &&
                        inventModelGroup.InventModel <= InventModel::AverageCostDate ||
                        inventModelGroup.InventModel == InventModel::MonthlyAverageCost);

        // Create calculation list from financial view of union view InventCostClosingUpdateView
        InventCostList inventCostList;
        InventCostClosingFinancialUpdateView financialUpdateView;
        insert_recordset inventCostList
            (ItemId, bomLevel, Voucher)
            select  ItemId, bomLevel, _voucherNumber
                from inventCostListItemTempDB
                exists join financialUpdateView
                    where financialUpdateView.ItemId == inventCostListItemTempDB.ItemId
                        && financialUpdateView.TransDate > _prevInventClosingTransDate
                        && financialUpdateView.TransDate <= inventClosing.TransDate;

        this.deleteAlreadyCopiedinventCostListItemTempDBRecords(inventCostListItemTempDB, _voucherNumber);
 
        inventCostList =  null;
        // Create calculation list from physical view of union view InventCostClosingUpdateView
        InventCostClosingPhysicalUpdateView physicalUpdateView;
        insert_recordset inventCostList
            (ItemId, bomLevel, Voucher)
            select  ItemId, bomLevel, _voucherNumber
                from inventCostListItemTempDB
                exists join physicalUpdateView
                    where physicalUpdateView.ItemId == inventCostListItemTempDB.ItemId
                        && physicalUpdateView.TransDate > _prevInventClosingTransDate
                        && physicalUpdateView.TransDate <= inventClosing.TransDate;

        this.deleteAlreadyCopiedinventCostListItemTempDBRecords(inventCostListItemTempDB, _voucherNumber);

        inventCostList =  null;
        // Create calculation list from adjustment view of union view InventCostClosingUpdateView
        InventCostClosingAdjustmentUpdateView adjustmentUpdateView;
        insert_recordset inventCostList
            (ItemId, bomLevel, Voucher)
            select  ItemId, bomLevel, _voucherNumber
                from inventCostListItemTempDB
                exists join adjustmentUpdateView
                    where adjustmentUpdateView.ItemId == inventCostListItemTempDB.ItemId
                        && adjustmentUpdateView.TransDate > _prevInventClosingTransDate
                        && adjustmentUpdateView.TransDate <= inventClosing.TransDate;      
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAlreadyCopiedinventCostListItemTempDBRecords</Name>
				<Source><![CDATA[
    private void deleteAlreadyCopiedinventCostListItemTempDBRecords(InventCostListItemTempDB _inventCostListItemTempDB, Voucher _voucherNumber)
    {
        InventCostList inventClostListLocal;
        delete_from _inventCostListItemTempDB
                exists join inventClostListLocal
                where inventClostListLocal.Voucher == _voucherNumber
                   && inventClostListLocal.NumOfIteration == 0
                   && inventClostListLocal.ItemId == _inventCostListItemTempDB.ItemId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>