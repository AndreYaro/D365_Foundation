<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReqSetupDim</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>ReqSetupDim</c> class contains master planning parameters 
/// for a specific combination of item and coverage dimension values.
/// </summary>
public class ReqSetupDim
{
    ReqSetup                reqSetup;

    ReqCovInventDimId       covInventDimId;

    InventDim               inventDim;

    ReqSetupDimInventItemPurchSetupCacheObject inventItemPurchSetup;
    ReqSetupDimInventItemInventSetupCacheObject inventItemInventSetup;

    Map                     mapLeadTime;

    container               conInfolog;

    Set                     setLeanRuleData;

    // Obsolete
    CalendarId              secondaryCalendarId;
    
    Map                     mainInventLocationIdCache;
    utcdatetime             currentDateTime;
    LeanLocationCache       leanLocationCache;

    protected ReqSetupDimReqGroupCacheObject reqGroup;
    protected ReqSetupDimReqItemTableCacheObject reqItemTableGrouped;
    protected ReqSetupDimInventDistinctProductCacheObject inventDistinctProduct;
    protected ReqSetupDimInventLocationCacheObject inventLocation;
    
    private boolean isShippingCalendarSet;
    private CalendarId shippingCalendarId;
    private boolean isTansportCalendarSet;
    private CalendarId transportCalendarId;
    private boolean isTradeAgreementSet;
    private LeadTime tradeAgreementLeadTime;
    private CalendarDays tradeAgreementCalendarDays;
    private ReqPO   plannedOrder;
    private boolean excludeMultipleFromLowestQtyCalculation;

    private readonly boolean reqUseTradeAgreementLazyLoadPerOrderFlightEnabled;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>actionBasicDateType</Name>
				<Source><![CDATA[
    public ActionBasicDateType actionBasicDateType()
    {
        return reqGroup.ActionBasicDateType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>advanceMargin</Name>
				<Source><![CDATA[
    public Days advanceMargin()
    {
        return reqGroup.ActionAdvanceMargin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bomVersionReq</Name>
				<Source><![CDATA[
    public boolean bomVersionReq()
    {
        return reqGroup.bomVersionReq;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheKeyReqTrans</Name>
				<Source><![CDATA[
    public str cacheKeyReqTrans()
    {
        return ReqTransCache::itemDimId2cachekey(reqSetup.itemId(),covInventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReduceForecast</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the specified requirement type can reduce the specified forecast type.
    /// </summary>
    /// <param name="_forecastType">
    /// An enum of type <c>ForecastTableType</c> that determines if the forecast reduction is regarding a demand forecast or a supply forecast.
    /// </param>
    /// <param name="_reqRefType">
    /// An enum of type <c>ReqRefType</c> that specifies the requirement type.
    /// </param>
    /// <returns>
    /// true if the forecast can be reduced; otherwise, false.
    /// </returns>
    public boolean canReduceForecast(
        ForecastTableType   _forecastType,
        ReqRefType          _reqRefType)
    {
        if (_reqRefType == ReqRefType::None                 ||
            _reqRefType == ReqRefType::SafetyInvent         ||
            _reqRefType == ReqRefType::InventOnHand         ||
            _reqRefType == ReqRefType::BOMPlannedOrder      ||
            _reqRefType == ReqRefType::PmfPlannedProdBatch  ||
            _reqRefType == ReqRefType::ItemPlannedOrder     ||
            _reqRefType == ReqRefType::TransferPlannedOrder ||
            _reqRefType == ReqRefType::PlannedKanban        ||
            _reqRefType == ReqRefType::SalesForecast        ||
            _reqRefType == ReqRefType::Quarantine           ||
            _reqRefType == ReqRefType::RequisitionLine      ||
            _reqRefType == ReqRefType::MCRContinuity        ||
            (_forecastType == ForecastTableType::Demand && _reqRefType == ReqRefType::Purch))
        {
            return false;
        }

        if (this.forecastReducedBy() == ReqForecastReducedBy::All)
        {
            return true;
        }

        if (_forecastType == ForecastTableType::Demand && _reqRefType == ReqRefType::Sales)
        {
            return true;
        }

        if (_forecastType == ForecastTableType::Supply)
        {
            if (_reqRefType == ReqRefType::Purch && this.plannedOrderTypeReq() == ReqRefType::ItemPlannedOrder)
            {
                return true;
            }

            if (_reqRefType == ReqRefType::Production && (this.plannedOrderTypeReq() == ReqRefType::BOMPlannedOrder || this.plannedOrderTypeReq() == ReqRefType::PmfPlannedProdBatch))
            {
                return true;
            }

            if ((_reqRefType == ReqRefType::TransferOrderReceive ||
                 _reqRefType == ReqRefType::InventTransfer)  && this.plannedOrderTypeReq() == ReqRefType::TransferPlannedOrder)
            {
                return true;
            }

            if (_reqRefType == ReqRefType::Kanban && this.plannedOrderTypeReq() == ReqRefType::PlannedKanban)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPlannedOrderType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified planned order type is valid.
    /// </summary>
    /// <param name="_reqPOType">
    /// A <c>ReqPOType</c> enumeration value that holds the planned order type to be checked.
    /// </param>
    /// <param name="_showWarning">
    /// A Boolean that determines whether warnings should be presented; optional.
    /// </param>
    /// <returns>
    /// true if the specified planned order type is valid; otherwise false.
    /// </returns>
    boolean checkPlannedOrderType(
        ReqPOType   _reqPOType,
        boolean     _showWarning = false)
    {
        InventDimParm    inventDimParmCov;

        InventTable      inventTable = InventTable::find(reqSetup.inventTable().ItemId);

        switch (_reqPOType)
        {
            case ReqPOType::Production  :
                if (! reqSetup.inventItemType().canBeProduced())
                {
                    return _showWarning ? checkFailed(strFmt("@SYS78161",reqSetup.inventTable().ItemType)) : false;
                }

                break;

            case ReqPOType::Transfer    :
                inventDimParmCov.initCovReqItemTable(reqSetup.inventDimGroupSetup());
                this.inventDim();

                if (! inventDim.InventSiteId && ! inventDim.InventLocationId)
                {
                    if (inventDimParmCov.InventSiteIdFlag)
                    {
                        return _showWarning ? checkFailed("@SYS117853") : false;
                    }

                    return _showWarning ? checkFailed("@SYS85069") : false;
                }

                if (!inventTable.pmfInventProductType().canBePlannedOrderTypeTransfer())
                {
                    return _showWarning ? checkFailed(strFmt("@PRO2627", inventTable.PmfProductType)) : false;
                }

                break;

            case ReqPOType::Kanban:
                if (_showWarning)
                {
                    inventDimParmCov.initCovReqItemTable(reqSetup.inventDimGroupSetup());
                    if (! inventDimParmCov.InventLocationIdFlag)
                    {
                        // only show warning
                        warning(strFmt("@SYS301774",_reqPOType));
                    }
                }

                if (!inventTable.pmfInventProductType().canBePlannedOrderTypeKanban())
                {
                    return _showWarning ? checkFailed(strFmt("@PRO2630", inventTable.PmfProductType)) : false;
                }

                break;

            case ReqPOType::Purch:
                if (!inventTable.pmfInventProductType().canBePlannedOrderTypePurchase())
                {
                    return _showWarning ? checkFailed(strFmt("@PRO2631", inventTable.PmfProductType)) : false;
                }
                break;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costPricePcs</Name>
				<Source><![CDATA[
    CostPrice costPricePcs()
    {
        return reqSetup.inventTable().costPcsPrice(covInventDimId,inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>covPeriod</Name>
				<Source><![CDATA[
    public ReqCovPeriod covPeriod(boolean _fromForm = false)
    {
        if (reqItemTableGrouped.CovFieldsActive)
            return reqItemTableGrouped.CovPeriod ? reqItemTableGrouped.CovPeriod  : (_fromForm ? 0 : 1);

        return reqGroup.CovPeriod ? reqGroup.CovPeriod : (_fromForm ? 0 : 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>covRule</Name>
				<Source><![CDATA[
    public ReqCovType covRule()
    {
        if (reqItemTableGrouped.CovFieldsActive)
            return reqItemTableGrouped.CovRule;

        return reqGroup.CovRule ? reqGroup.CovRule : ReqCovType::Period;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custForecastIncludedInOverallForecast</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the flag that indicates whether customer forecast is included in overall forecast.
    /// </summary>
    /// <returns>
    /// A <c>ReqCustForecastIncludedInOverallForecast</c> value indicating whether to customer forecast is included in overall forecast.
    /// </returns>
    public ReqCustForecastIncludedInOverallForecast custForecastIncludedInOverallForecast()
    {
        return reqGroup.custForecastIncludedInOverallForecast;
    }

]]></Source>
			</Method>
			<Method>
				<Name>forecastReducedBy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a forecast reduction setting that indicates the transaction types that can reduce a
    ///    forecast.
    /// </summary>
    /// <returns>
    ///    A <c>ReqForecastReducedBy</c> enumeration value that specifies the forecast reduction type.
    /// </returns>
    public ReqForecastReducedBy forecastReducedBy()
    {
        return reqGroup.ForecastReducedBy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqGroupCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the cache of the <c>ReqGroup</c> buffer.
    /// </summary>
    /// <returns>
    /// A <c>ReqGroup</c> buffer cache object.
    /// </returns>
    public ReqSetupDimReqGroupCacheObject reqGroupCache()
    {
        return reqGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReqGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>ReqGroup</c> buffer.
    /// </summary>
    /// <returns>
    /// The <c>ReqGroup</c> buffer.
    /// </returns>
    [SysObsolete('This method is obsolete, use reqGroupCache() instead.', true, 31\03\2018)]
    public ReqGroup getReqGroup()
    {
        return ReqGroup::find(reqGroup.ReqGroupId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>highestQty</Name>
				<Source><![CDATA[
    public QtyHighest highestQty(boolean _fromForm = false)
    {
        InventQty highestQty;

        if (this.plannedOrderTypeReq() == ReqRefType::ItemPlannedOrder)
            highestQty = this.highestQtyPurch();
        else
            highestQty = this.highestQtyInvent();

        return (! _fromForm ? highestQty : (highestQty == realMax() ? 0 : highestQty));
    }

]]></Source>
			</Method>
			<Method>
				<Name>highestQtyInvent</Name>
				<Source><![CDATA[
    public InventQty highestQtyInvent()
    {
        this.setInventItemInventSetupCache();
        return inventItemInventSetup.HighestQty ? decRound(inventItemInventSetup.HighestQty, reqSetup.inventDecimals()): realMax();
    }

]]></Source>
			</Method>
			<Method>
				<Name>highestQtyPurch</Name>
				<Source><![CDATA[
    public InventQty   highestQtyPurch()
    {
        InventQty   highestQty;

        this.setInventItemPurchSetupCache();
        this.setInventItemInventSetupCache();

        if (reqSetup.inventUnitId() != reqSetup.purchUnitId() && inventItemPurchSetup.HighestQty)
        {
            highestQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(reqSetup.itemId(),
                                                                                               this.inventDim().InventDimId,
                                                                                               inventItemPurchSetup.HighestQty,
                                                                                               reqSetup.purchUnitId(),
                                                                                               reqSetup.inventUnitId(),
                                                                                               NoYes::Yes);
        }
        else
        {
            highestQty = inventItemPurchSetup.HighestQty;
        }

        return highestQty  ? decRound(highestQty,reqSetup.inventDecimals())  : realMax();
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    protected boolean init(ReqSetupDimBuilder _builder = null)
    {
        int startLine = infologLine();
        int currentLine;

        if (_builder)
        {
            reqSetup = _builder.reqSetup();
            covInventDimId = _builder.covInventDimId();
            inventDim = _builder.covInventDim();
        }    

        this.setReqItemTableGrouped(_builder);
        this.setReqGroup();
        this.setInventDistinctProduct();

        currentLine = infologLine();

        if (currentLine > startLine)
        {
            conInfolog = infolog.cut(startLine + 1, currentLine);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMapLeadTime</Name>
				<Source><![CDATA[
    protected void initMapLeadTime()
    {
        mapLeadTime = new Map(Types::Container,Types::Container);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDim</Name>
				<Source><![CDATA[
    public InventDim inventDim()
    {
        if (! inventDim.RecId)
            inventDim = InventDim::find(covInventDimId);

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventItemInventSetup</Name>
				<Source><![CDATA[
    [SysObsolete('This method has been obsoleted, use inventItemInventSetupCache() instead.', false, 31\03\2018)]
    public InventItemInventSetup inventItemInventSetup()
    {
        return this.setInventItemInventSetup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventItemInventSetupCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instance of the <c>ReqSetupDimInventItemInventSetupCacheObject</c>.
    /// </summary>
    /// <returns>An instance of the <c>ReqSetupDimInventItemInventSetupCacheObject</c></returns>
    public ReqSetupDimInventItemInventSetupCacheObject inventItemInventSetupCache()
    {
        this.setInventItemInventSetupCache();

        return inventItemInventSetup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventItemPurchSetup</Name>
				<Source><![CDATA[
    [SysObsolete('This method has been obsoleted, use inventItemPurchSetupCache() instead.', false, 31\03\2018)]
    public InventItemPurchSetup inventItemPurchSetup()
    {
        return this.setInventItemPurchSetup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventItemPurchSetupCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instance of the <c>ReqSetupDimInventItemPurchSetupCacheObject</c>.
    /// </summary>
    /// <returns>An instance of the <c>ReqSetupDimInventItemPurchSetupCacheObject</c></returns>
    public ReqSetupDimInventItemPurchSetupCacheObject inventItemPurchSetupCache()
    {
        this.setInventItemPurchSetupCache();

        return inventItemPurchSetup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventLocationCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>ReqSetupDimInventLocationCacheObject</c>.
    /// </summary>
    /// <returns>A <c>ReqSetupDimInventLocationCacheObject</c> instance.</returns>
    public ReqSetupDimInventLocationCacheObject inventLocationCache()
    {
        if (!inventLocation)
        {
            if (this.inventDim().InventLocationId)
            {
                inventLocation = ReqSetupDimInventLocationCacheObject::fromRecord(InventLocation::find(this.inventDim().InventLocationId));
            }
            else
            {
                inventLocation = new ReqSetupDimInventLocationCacheObject();
            }
        }

        return inventLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventLocation</Name>
				<Source><![CDATA[
    [SysObsolete('The record method has been deprecated, uses inventLocationCache() instead.', false, 31\03\2018)]
    public InventLocation inventLocation()
    {
        return InventLocation::find(this.inventLocationCache().InventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryPostalAddress</Name>
				<Source><![CDATA[
    internal LogisticsPostalAddress deliveryPostalAddress()
    {
        LogisticsPostalAddress logisticsAddress;

        if (this.inventLocationCache().InventLocationId)
        {
            InventLocation warehouse = InventLocation::find(this.inventLocationCache().InventLocationId);
            logisticsAddress = warehouse.mcrDefaultDeliveryPostalAddress();
        }
        else if (this.inventDim().InventSiteId)
        {
            InventSite site = InventSite::find(this.inventDim().InventSiteId);
            LogisticsLocationEntity locationEntity = LogisticsLocationEntity::constructFromLocationRecId(LogisticsLocationDefault::findSimpleDefaultByRoleType(site, LogisticsLocationRoleType::Delivery).RecId);
            logisticsAddress = locationEntity.getPostalAddress();
        }

        if (!logisticsAddress)
        {
            logisticsAddress = CompanyInfo::find().postalAddress();
        }

        return logisticsAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>leadTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the lead time base on the planned order type and the warehouse.
    /// </summary>
    /// <param name="_reqRefType">
    /// Planned order type.
    /// </param>
    /// <param name="_fromInventLocationId">
    /// The user-defined warehouse.
    /// </param>
    /// <returns>
    /// Lead time which has been calculated.
    /// </returns>
    /// <remarks>
    /// Consider using leadTimeForOrder method instead as it less dependant on the call context and might include 
    /// lead time set on a trade agreement found based on a specific planned order data.
    /// </remarks>
    public LeadTime leadTime(ReqRefType _reqRefType = this.plannedOrderTypeReq(), InventLocationId _fromInventLocationId = '')
    {
        LeadTime                leadTime;
        CalendarDays            leadTimeCalendarDays;

        if (this.isTradeAgreementSet && !this.primaryVendId() && ReqCalcTradeAgreementLeadTimeDecoupledCalcFlight::instance().isEnabled())
        {
            return this.tradeAgreementLeadTime;
        }
        else
        {
            if (! mapLeadTime)
            {
                this.initMapLeadTime();
            }
            
            if (! mapLeadTime.exists([_reqRefType, _fromInventLocationId]))
            {
                [leadTime, leadTimeCalendarDays] = this.retrieveLeadTime(_reqRefType, _fromInventLocationId);
                mapLeadTime.insert([_reqRefType, _fromInventLocationId],[leadTime,leadTimeCalendarDays]);
            }
            return conPeek(mapLeadTime.lookup([_reqRefType, _fromInventLocationId]),1);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>leadTimeForOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the lead time for a specific planned order data.
    /// </summary>
    /// <param name="_reqDate">The requirement date of the planned order.</param>
    /// <param name="_receiptQty">The quantity of the planned receipt order.</param>
    /// <param name="_reqRefType">The planned order type.</param>
    /// <param name="_fromInventLocationId">The user-defined warehouse.</param>
    /// <returns>
    /// The lead time which has been calculated.
    /// </returns>
    public LeadTime leadTimeForOrder(ReqDate _reqDate, InventQty _receiptQty, ReqRefType _reqRefType = this.plannedOrderTypeReq(), InventLocationId _fromInventLocationId = '')
    {
        LeadTime leadTimeDays;
        boolean foundMatchingTradeAgreement;

        // Purchase trade agreements can be used to determine lead time only if a vendor is not set on an item or its default settings.
        if (reqUseTradeAgreementLazyLoadPerOrderFlightEnabled 
            && !this.primaryVendId()
            && _reqRefType == ReqRefType::ItemPlannedOrder)
        {
            container leadTimeDataFound = this.retrieveCachedTradeAgreementLeadTime(_reqDate, _receiptQty);

            if (leadTimeDataFound != conNull())
            {
                leadTimeDays = conPeek(leadTimeDataFound, 1);
                foundMatchingTradeAgreement = true;
            }
        }

        if (!foundMatchingTradeAgreement)
        {
            leadTimeDays = this.leadTime(_reqRefType, _fromInventLocationId);
        }

        return leadTimeDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>leadTimeCalendarDaysForOrder</Name>
				<Source><![CDATA[
    public CalendarDays leadTimeCalendarDaysForOrder(ReqDate _reqDate, InventQty _receiptQty, ReqRefType _reqRefType = this.plannedOrderTypeReq(), InventLocationId _fromInventLocationId = '')
    {
        CalendarDays leadTimeCalendarDays;
        boolean foundMatchingTradeAgreement;

        if (reqUseTradeAgreementLazyLoadPerOrderFlightEnabled
            && !this.primaryVendId()
            && _reqRefType == ReqRefType::ItemPlannedOrder)
        {
            container leadTimeDataFound = this.retrieveCachedTradeAgreementLeadTime(_reqDate, _receiptQty);

            if (leadTimeDataFound != conNull())
            {
                leadTimeCalendarDays = conPeek(leadTimeDataFound, 2);
                foundMatchingTradeAgreement = true;
            }
        }

        if (!foundMatchingTradeAgreement)
        {
            leadTimeCalendarDays = this.leadTimeCalendarDays(_reqRefType, _fromInventLocationId);
        }

        return leadTimeCalendarDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveLeadTime</Name>
				<Source><![CDATA[
    protected container retrieveLeadTime(ReqRefType _reqRefType, InventLocationId _fromInventLocationId)
    {
        LeadTime                leadTime;
        CalendarDays            leadTimeCalendarDays;
        
        switch (_reqRefType)
        {
            case ReqRefType::ItemPlannedOrder:
                if (reqItemTableGrouped.LeadTimePurchaseActive)
                {
                    leadTime                = reqItemTableGrouped.LeadTimePurchase;
                    leadTimeCalendarDays    = reqItemTableGrouped.CalendarDaysPurchase;
                }
                else
                {
                    leadTime                = this.inventItemPurchSetupCache().LeadTime;
                    leadTimeCalendarDays    = this.inventItemPurchSetupCache().CalendarDays;
                }
                break;
            case ReqRefType::TransferPlannedOrder:
                if (reqItemTableGrouped.LeadTimeTransferActive)
                {
                    leadTime                = reqItemTableGrouped.LeadTimeTransfer;
                    leadTimeCalendarDays    = reqItemTableGrouped.CalendarDaysTransfer;
                }
                else
                {
                    leadTime                = CustVendTransportPointLine::defaultTransportDays('',_fromInventLocationId ? _fromInventLocationId : this.mainInventLocationId(_reqRefType),
                                    '','','','',
                                    this.inventLocationCache().InventLocationId);
                    leadTimeCalendarDays    = this.defaultTransportCalendarDays();
                }
                break;
            case ReqRefType::Kanban:
            case ReqRefType::PlannedKanban:
            case ReqRefType::BOMPlannedOrder:
            case ReqRefType::Production:
            case ReqRefType::PmfCoProduct:
            case ReqRefType::PmfPlannedProdBatch:
                if (reqItemTableGrouped.LeadTimeProductionActive)
                {
                    leadTime                = reqItemTableGrouped.LeadTimeProduction;
                    leadTimeCalendarDays    = reqItemTableGrouped.CalendarDaysProduction;
                }
                else
                {
                    leadTime                = this.inventItemInventSetupCache().LeadTime;
                    leadTimeCalendarDays    = this.inventItemInventSetupCache().CalendarDays;
                }
                break;
            default:
                leadTime                    = 0;
                leadTimeCalendarDays        = false;
        }

        return [leadTime, leadTimeCalendarDays];
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultTransportCalendarDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns default value for the transfer calendar days parameter.
    /// </summary>
    /// <returns>Transfer calendar days default value</returns>
    public CalendarDays defaultTransportCalendarDays()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>leadTimeCalendarDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the lead time calendar days based on the planned order type and the warehouse.
    /// </summary>
    /// <param name="_reqRefType">
    /// Planned order type.
    /// </param>
    /// <param name="_fromInventLocationId">
    /// The user-defined warehouse.
    /// </param>
    /// <returns>The calculated calendar days.</returns>
    /// <remarks>
    /// Consider using leadTimeCalendarDaysForOrder method instead as it less dependant on the call context and might include
    /// parameter value set on a trade agreement found based on a specific planned order data.
    /// </remarks>
    public CalendarDays leadTimeCalendarDays(ReqRefType _reqRefType = this.plannedOrderTypeReq(), InventLocationId _fromInventLocationId = '')
    {
        if (this.isTradeAgreementSet && !this.primaryVendId() && ReqCalcTradeAgreementLeadTimeDecoupledCalcFlight::instance().isEnabled())
        {
            return this.tradeAgreementCalendarDays;
        }
        else
        {
            if (! mapLeadTime || ! mapLeadTime.exists([_reqRefType, _fromInventLocationId]))
                this.leadTime(_reqRefType, _fromInventLocationId);

            return conPeek(mapLeadTime.lookup([_reqRefType, _fromInventLocationId]),2);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>leanRuleData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>LeanRuleData</c> object for the current item and coverage dimension.
    /// </summary>
    /// <param name="_reqDateTime">
    /// A date and time value that holds a requirement date and time.
    /// </param>
    /// <param name="_reqRefType">
    /// An enum value that holds the requirement type.
    /// </param>
    /// <param name="_inventQty">
    /// A minimum required quantity.
    /// </param>
    /// <param name="_replenishmentStrategy">
    /// An enum value that holds the replenishment strategy to filter on; optional.
    /// </param>
    /// <returns>
    /// A <c>LeanRuleData</c> object that holds kanban settings.
    /// </returns>
    public LeanRuleData leanRuleData(
        utcdatetime                 _reqDateTime,
        ReqRefType                  _reqRefType,
        InventQty                   _inventQty,
        LeanReplenishmentStrategy   _replenishmentStrategy = 0)
    {
        SetEnumerator                       se;
        LeanRuleData                        leanRuleData;
        KanbanRule                          kanbanRule;
        KanbanFindRules_MasterScheduling    kanbanRulesFinder;

        if (ReqTrans::refTypeCanHaveKanbanRule(_reqRefType))
        {
            kanbanRulesFinder = KanbanFindRules_MasterScheduling::newStandard(reqSetup.itemId(),_reqDateTime,covInventDimId);
            kanbanRulesFinder.parmReplenishmentStrategy(_replenishmentStrategy);
            kanbanRulesFinder.parmMinimumInventQty(_inventQty);
            kanbanRulesFinder.parmLeanLocationCache(leanLocationCache);

            if (!setLeanRuleData)
            {
                setLeanRuleData = new Set(Types::Class);
            }
            else
            {
                se = setLeanRuleData.getEnumerator();
                while (se.moveNext())
                {
                    leanRuleData = se.current();
                    if (   leanRuleData
                        && leanRuleData.validityPeriodCheck(kanbanRulesFinder.parmDateTimeFrom(),
                                                            kanbanRulesFinder.parmDateTimeTo())
                        && (!_replenishmentStrategy
                        ||  leanRuleData.replenishmentStrategy() == _replenishmentStrategy))
                    {
                        break;
                    }
                    leanRuleData = null;
                }
            }

            if (!leanRuleData)
            {
                kanbanRule = kanbanRulesFinder.first();

                if (kanbanRule)
                {
                    leanRuleData = LeanRuleData::newKanbanRuleRecId(kanbanRule.RecId);
                }

                if (leanRuleData)
                {
                    setLeanRuleData.add(leanRuleData);
                }
            }

            return leanRuleData;
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lowestQty</Name>
				<Source><![CDATA[
    public QtyLowest    lowestQty()
    {
        if (this.plannedOrderTypeReq() == ReqRefType::ItemPlannedOrder)
        {
            return this.lowestQtyPurch();
        }

        return this.lowestQtyInvent();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lowestQtyInvent</Name>
				<Source><![CDATA[
    public Qty lowestQtyInvent()
    {
        this.setInventItemInventSetupCache();

        if (excludeMultipleFromLowestQtyCalculation)
        {
            return decRound(inventItemInventSetup.LowestQty, reqSetup.inventDecimals());
        }

        return decRound(max(inventItemInventSetup.LowestQty, inventItemInventSetup.MultipleQty), reqSetup.inventDecimals());
    }

]]></Source>
			</Method>
			<Method>
				<Name>lowestQtyPurch</Name>
				<Source><![CDATA[
    public Qty lowestQtyPurch()
    {
        InventQty   lowestQty;
        InventQty   quantity;

        this.setInventItemPurchSetupCache();
        this.setInventItemInventSetupCache();

        lowestQty   = inventItemPurchSetup.LowestQty;
        quantity    = inventItemPurchSetup.MultipleQty;

        if (reqSetup.inventUnitId() != reqSetup.purchUnitId())
        {
            EcoResProductUnitConverter unitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(reqSetup.itemId(),
                                                                                                                         this.inventDim().InventDimId,
                                                                                                                         reqSetup.purchUnitId(),
                                                                                                                         reqSetup.inventUnitId(),
                                                                                                                         NoYes::Yes);

            lowestQty = unitConverter.convertValue(lowestQty);

            quantity  = unitConverter.convertValue(quantity);
        }

        if (excludeMultipleFromLowestQtyCalculation)
        {
            return decRound(lowestQty, reqSetup.inventDecimals());
        }

        return decRound(max(lowestQty,quantity),reqSetup.inventDecimals());
    }

]]></Source>
			</Method>
			<Method>
				<Name>standardQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the standard quantity according to the RefType.
    /// </summary>
    /// <returns>
    /// The standard quantity.
    /// </returns>
    internal QtyStandard standardQty()
    {
        return this.plannedOrderTypeReq() == ReqRefType::ItemPlannedOrder ? this.standardQtyPurch() : this.standardQtyInvent();
    }

]]></Source>
			</Method>
			<Method>
				<Name>standardQtyInvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the standard quantity base on InventItemIventSetup.
    /// </summary>
    /// <returns>
    /// The standard quantity.
    /// </returns>
    internal Qty standardQtyInvent()
    {
        this.setInventItemInventSetupCache();
        return decRound(inventItemInventSetup.StandardQty, reqSetup.inventDecimals());
    }

]]></Source>
			</Method>
			<Method>
				<Name>standardQtyPurch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the standard quantity base on InventItemPurchSetup.
    /// </summary>
    /// <returns>
    /// The standard quantity.
    /// </returns>
    internal Qty standardQtyPurch()
    {
        this.setInventItemPurchSetupCache();
        return decRound(inventItemPurchSetup.StandardQty, reqSetup.inventDecimals());
    }

]]></Source>
			</Method>
			<Method>
				<Name>mainInventLocationId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a sourcing warehouse for the specified item and coverage dimension.
    /// </summary>
    /// <param name="_reqRefType">
    /// A <c>ReqRefType</c> enumeration value that represents a planned order type.
    /// </param>
    /// <param name="_asOfDateTime">
    /// A date and time value in UTC timezone which holds the point in time the source warehouse applies.
    /// </param>
    /// <returns>
    /// A string value that holds the source warehouse ID.
    /// </returns>
    public InventLocationIdReqMain mainInventLocationId(
        ReqRefType      _reqRefType   = this.plannedOrderTypeReq(),
        utcdatetime     _asOfDateTime =
                                        currentDateTime
                                        )
    {
        LeanRuleData                            leanRuleData;
        LeanProdFlowFindConsumptionActivity     leanProdFlowFindConsumptionActivity;
        InventLocationIdReqMain result;
        str cacheKey;

        cacheKey = strFmt('%1#%2', _reqRefType, _asOfDateTime);
        if (mainInventLocationIdCache.exists(cacheKey))
        {
            return mainInventLocationIdCache.lookup(cacheKey);
        }

        switch (_reqRefType)
        {
            case ReqRefType::PlannedKanban:
                leanRuleData = this.leanRuleData(_asOfDateTime,_reqRefType, this.lowestQtyInvent());

                if (   leanRuleData
                    && leanRuleData.leanKanbanType() == LeanKanbanType::Withdrawal)
                {
                    leanProdFlowFindConsumptionActivity = LeanProdFlowFindConsumptionActivity::newKanbanFlow(
                                                                                                    reqSetup.inventTable(),
                                                                                                    this.inventDim(),
                                                                                                    leanRuleData.kanbanFlow(),
                                                                                                    leanRuleData.parmKanbanRule(),
                                                                                                    leanRuleData.leanKanbanType());
                    result =
                    leanProdFlowFindConsumptionActivity.inventDimFinal().InventLocationId;
                }
                break;

            case  ReqRefType::TransferPlannedOrder:
                if (   reqItemTableGrouped
                    && reqItemTableGrouped.ReqPOTypeActive
                    && reqItemTableGrouped.ReqPOType == ReqPOType::Transfer
                    && reqItemTableGrouped.InventLocationIdReqMain)
                {
                    result =
                    reqItemTableGrouped.InventLocationIdReqMain;
                }

                else
                if (this.refillActivated())
                {
                    result =
                    this.inventLocationCache().InventLocationIdReqMain;
                }

                break;
        }
        mainInventLocationIdCache.insert(cacheKey, result);

        return
        result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>marginIssue</Name>
				<Source><![CDATA[
    public MarginIssue marginIssue()
    {
        return reqGroup.IssueMargin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>marginOrder</Name>
				<Source><![CDATA[
    public MarginOrder marginOrder()
    {
        return reqGroup.OrderMargin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>marginReceipt</Name>
				<Source><![CDATA[
    public MarginReceipt marginReceipt()
    {
        return reqGroup.ReceiptMargin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxInventOnHand</Name>
				<Source><![CDATA[
    public InventQtyMaxOnhand   maxInventOnHand(boolean _minAsMax = true)
    {
        InventQty maxQty;

        if (reqItemTableGrouped)
        {
            if (! _minAsMax)
                maxQty = reqItemTableGrouped.MaxInventOnhand;
            else
                maxQty = (reqItemTableGrouped.MaxInventOnhand >= reqItemTableGrouped.MinInventOnhand ? reqItemTableGrouped.MaxInventOnhand : reqItemTableGrouped.MinInventOnhand);
        }

        return decRound(maxQty,reqSetup.inventDecimals());
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxInventOnhandDate</Name>
				<Source><![CDATA[
    public InventQty maxInventOnhandDate(
        ReqDate     _reqDate,
        TransDate   _todaysdate
        )
    {
        FromDate                fromDate;
        ToDate                  toDate;
        TransDate               breakEvenDate;

        ReqSafetyLine           reqSafetyLine;
        ReqSafetyLine           prvSafetyLine;

        if (this.maxInventOnHand() == 0 || ! this.maxSafetyKeyId())
            return this.maxInventOnHand();

        breakEvenDate = ReqSafetyKey::find(this.maxSafetyKeyId()).breakEvenDate(_todaysdate);

        while select reqSafetyLine
            order by Sort1980
            where reqSafetyLine.SafetyKeyId == this.maxSafetyKeyId()
        {
            fromDate = reqSafetyLine.fromDate(breakEvenDate,prvSafetyLine);
            toDate   = reqSafetyLine.toDate(breakEvenDate);

            if (fromDate <= _reqDate && toDate >= _reqDate)
                return decRound((this.maxInventOnHand() * reqSafetyLine.SafetyFactor),reqSetup.inventDecimals());

            prvSafetyLine = reqSafetyLine.data();
        }

        return this.maxInventOnHand();
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxNegativeDays</Name>
				<Source><![CDATA[
    public ReqMaxNegativeDays maxNegativeDays(ReqDate     _reqDate      = dateNull(),
                                              TransDate   _todaysDate   = dateNull(),
                                              ReqPlanData _reqPlanData  = null)
    {
        if (_reqPlanData && _reqPlanData.timeFenceMaxNegativeDaysFixed())
        {
            return _reqPlanData.timeFenceMaxNegativeDays();
        }

        if (reqItemTableGrouped.CovFieldsActive)
        {
            return reqItemTableGrouped.MaxNegativeDays;
        }

        return reqGroup.MaxNegativeDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxPositiveDays</Name>
				<Source><![CDATA[
    public ReqMaxPositiveDays  maxPositiveDays(boolean _fromForm = false)
    {
        if (reqItemTableGrouped.CovFieldsActive)
            return reqItemTableGrouped.MaxPositiveDays ? reqItemTableGrouped.MaxPositiveDays : (_fromForm  ? 0 : 1);

        return reqGroup.MaxPositiveDays ? reqGroup.MaxPositiveDays : (_fromForm ? 0 : 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxSafetyKeyId</Name>
				<Source><![CDATA[
    public ReqSafetyKeyId maxSafetyKeyId()
    {
        return reqItemTableGrouped.isCacheInitialized() ? reqItemTableGrouped.MaxSafetyKeyId : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayItemBeActionAdvanced</Name>
				<Source><![CDATA[
    public boolean  mayItemBeActionAdvanced()
    {
        return reqGroup.ActionAdvance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayItemBeActionDecreased</Name>
				<Source><![CDATA[
    public boolean  mayItemBeActionDecreased()
    {
        return reqGroup.ActionDepreciate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayItemBeActionDerived</Name>
				<Source><![CDATA[
    public boolean  mayItemBeActionDerived()
    {
        return reqGroup.ActionDerived;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayItemBeActionIncreased</Name>
				<Source><![CDATA[
    public boolean  mayItemBeActionIncreased()
    {
        return reqGroup.ActionAppreciate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayItemBeActionPostponed</Name>
				<Source><![CDATA[
    public boolean  mayItemBeActionPostponed()
    {
        return reqGroup.ActionPostpone;
    }

]]></Source>
			</Method>
			<Method>
				<Name>minInventOnHand</Name>
				<Source><![CDATA[
    public InventQtyMinOnhand  minInventOnHand()
    {
        return decRound(reqItemTableGrouped.isCacheInitialized() ? reqItemTableGrouped.MinInventOnhand : 0, reqSetup.inventDecimals());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMinInventOnHandSet</Name>
				<Source><![CDATA[
    public boolean isMinInventOnHandSet()
    {
        return reqItemTableGrouped.MinInventOnhand != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>minInventOnhandDate</Name>
				<Source><![CDATA[
    public InventQty minInventOnhandDate(ReqDate _reqDate, TransDate _todaysdate)
    {
        FromDate                fromDate;
        ToDate                  toDate;
        TransDate               breakEvenDate;

        ReqSafetyLine           reqSafetyLine;
        ReqSafetyLine           prvSafetyLine;

        if (!this.isMinInventOnHandSet() || ! this.minSafetyKeyId())
            return this.minInventOnHand();

        breakEvenDate = ReqSafetyKey::find(this.minSafetyKeyId()).breakEvenDate(_todaysdate);

        while select reqSafetyLine
            order by Sort1980
            where reqSafetyLine.SafetyKeyId == this.minSafetyKeyId()
        {
            fromDate = reqSafetyLine.fromDate(breakEvenDate,prvSafetyLine);
            toDate   = reqSafetyLine.toDate(breakEvenDate);

            if (fromDate <= _reqDate && toDate >= _reqDate)
                return this.calculateMinInventOnhandQuantityBasedOnSafetyFactor(reqSafetyLine);

            prvSafetyLine = reqSafetyLine.data();
        }

        return this.minInventOnHand();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateMinInventOnhandQuantityBasedOnSafetyFactor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantity of the minimum inventory on hand value based on the safety key factor.
    /// </summary>
    /// <param name = "_setupDim">The <c>ReqSetupDim</c> instance of the class to be used for getting the quantity.</param>
    /// <param name = "_reqSafetyLine">The <c>ReqSafetyLine</c> instance used for calculation the quantity, associated to the safety stock key.</param>
    /// <param name = "_quantityToSubstract">Quantity to substract from the calculation, for instance if some part is covered at a previous date.</param>
    /// <returns>The quantity to be used as minimum on hand quantity.</returns>
    public InventQty calculateMinInventOnhandQuantityBasedOnSafetyFactor(ReqSafetyLine _reqSafetyLine, InventQty _quantityToSubstract = 0)
    {
        if (!_reqSafetyLine)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        return decRound((this.minInventOnHand() * _reqSafetyLine.SafetyFactor - _quantityToSubstract), reqSetup.inventDecimals());
    }

]]></Source>
			</Method>
			<Method>
				<Name>minSafetyKeyId</Name>
				<Source><![CDATA[
    public ReqSafetyKeyId minSafetyKeyId()
    {
        return reqItemTableGrouped.isCacheInitialized() ? reqItemTableGrouped.MinSafetyKeyId : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>minSafetyPeriod</Name>
				<Source><![CDATA[
    public boolean minSafetyPeriod()
    {
        return reqItemTableGrouped.MinSafetyPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>minSatisfy</Name>
				<Source><![CDATA[
    public ReqMinSatisfy minSatisfy()
    {
        return reqItemTableGrouped.isCacheInitialized() ? reqItemTableGrouped.MinSatisfy : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeCovPlanned</Name>
				<Source><![CDATA[
    public boolean mustBeCovPlanned()
    {
        if (!inventDistinctProduct.IsActiveForPlanning)
        {
            return false;
        }

        if (this.covRule() == ReqCovType::Manual)
        {
            return false;
        }

        if (this.inventLocationCache().Manual)
        {
            return false;
        }

        if (!WHSInventStatus::allowCreatePlannedOrder(this.inventDim().InventStatusId,false))
        {
            return false;
        }

        return reqSetup.mustItemBeCovPlanned();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustItemBeActionMarked</Name>
				<Source><![CDATA[
    public boolean  mustItemBeActionMarked()
    {
        return reqGroup.ActionCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustItemBeFuturesMarked</Name>
				<Source><![CDATA[
    public boolean  mustItemBeFuturesMarked()
    {
        return reqGroup.FuturesCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustItemBeScheduled</Name>
				<Source><![CDATA[
    public boolean  mustItemBeScheduled()
    {
        if (this.parmReqPO())
        {
            return ReqTrans::refTypeCanReserveWorkCenter(this.parmReqPO().RefType);
        }
        else
        {
            return ReqTrans::refTypeCanReserveWorkCenter(this.plannedOrderTypeReq());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustReqBeCreated</Name>
				<Source><![CDATA[
    public boolean  mustReqBeCreated(InventDim  _inventDimComplete = null)
    {
        if (!inventDistinctProduct.IsActiveForPlanning)
        {
            return false;
        }
        
        if (this.inventLocationCache().Manual)
        {
            return false;
        }

        if (this.covRule() == ReqCovType::Manual)
        {
            return false;
        }

        if (   _inventDimComplete.InventLocationId
            && InventLocation::find(_inventDimComplete.InventLocationId).Manual)
        {
            return false;
        }

        if (!WHSInventStatus::allowCreatePlannedOrder(this.inventDim().InventStatusId,false))
        {
            return false;
        }

        return reqSetup.mustItemReqBeCreated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUseLatestPossibleSupplyFirst</Name>
				<Source><![CDATA[
    public ReqMustUseLatestPossibleSupplyFirst mustUseLatestPossibleSupplyFirst()
    {
        if (reqItemTableGrouped.OnHandActive)
        {
            return reqItemTableGrouped.MustUseLatestPossibleSupplyFirst;
        }

        return reqGroup.MustUseLatestPossibleSupplyFirst;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onHandConsumption</Name>
				<Source><![CDATA[
    public ReqOnHandConsumptionStrategy onHandConsumption()
    {
        if (reqItemTableGrouped.OnHandActive)
        {
            return reqItemTableGrouped.OnHandConsumptionStrategy;
        }

        return reqGroup.OnHandConsumptionStrategy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        reqGroup = new ReqSetupDimReqGroupCacheObject();
        inventDistinctProduct = new ReqSetupDimInventDistinctProductCacheObject();
        reqItemTableGrouped = new ReqSetupDimReqItemTableCacheObject();
        inventItemInventSetup = new ReqSetupDimInventItemInventSetupCacheObject();
        inventItemPurchSetup = new ReqSetupDimInventItemPurchSetupCacheObject();

        currentDateTime = DateTimeUtil::getSystemDateTime();
        mainInventLocationIdCache = new Map(Types::String, Types::String);

        reqUseTradeAgreementLazyLoadPerOrderFlightEnabled = ReqUseTradeAgreementLazyLoadPerOrderFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCovInventDimId</Name>
				<Source><![CDATA[
    public ReqCovInventDimId parmCovInventDimId(ReqCovInventDimId _covInventDimId = covInventDimId)
    {
        covInventDimId = _covInventDimId;
        return covInventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDim</Name>
				<Source><![CDATA[
    public InventDim parmInventDim(InventDim _inventDim = inventDim)
    {
        inventDim = _inventDim;

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqPO</Name>
				<Source><![CDATA[
    public ReqPO parmReqPO(ReqPO _reqPO = plannedOrder)
    {
        plannedOrder = _reqPO;
        return plannedOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeMultipleFromLowestQtyCalculation</Name>
				<Source><![CDATA[
    public boolean parmExcludeMultipleFromLowestQtyCalculation(boolean _excludeMultipleFromLowestQtyCalculation = excludeMultipleFromLowestQtyCalculation)
    {
        excludeMultipleFromLowestQtyCalculation = _excludeMultipleFromLowestQtyCalculation;
        return excludeMultipleFromLowestQtyCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqSetup</Name>
				<Source><![CDATA[
    public ReqSetup  parmReqSetup(ReqSetup _reqSetup = reqSetup)
    {
        reqSetup = _reqSetup;
        return reqSetup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodTemplateRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the period template for the specified item ID and coverage dimension.
    /// </summary>
    /// <returns>
    ///    An integer that contains the record ID of a period template.
    /// </returns>
    public RecId periodTemplateRecId()
    {
        if (reqGroup.PeriodTemplate)
        {
            return reqGroup.PeriodTemplate;
        }

        return WorkPeriodTemplate::findDefault(CompanyInfo::current()).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plannedOrderTypeReq</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the planned order type for the current item ID and coverage dimensions.
    /// </summary>
    /// <param name="_derivedDirectly">
    /// A Boolean value that determines if this relates to a directly derived issue.
    /// </param>
    /// <param name="_isBOMCalc">
    /// A Boolean value that determines if it is used for BOM calculation.
    /// </param>
    /// <returns>
    /// A <c>ReqRefType</c> enumeration value that represents the planned order type.
    /// </returns>
    /// <remarks>
    /// The <c>_derivedDirectly</c> parameter must be set to true if a sub order must be created directly to the issue.
    /// </remarks>
    public ReqRefType plannedOrderTypeReq(ReqIsDerivedDirectly _derivedDirectly = NoYes::No, boolean _isBOMCalc = false)
    {
        ReqRefType      reqRefType;

        if (reqItemTableGrouped
            && reqItemTableGrouped.ReqPOTypeActive
            && this.checkPlannedOrderType(reqItemTableGrouped.ReqPOType))
        {
            reqRefType = ReqPO::reqPoType2ReqRefType(reqItemTableGrouped.ReqPOType
                                                , reqSetup.isFormulaOrCoProduct()
                                                );
        }
        else if (this.refillActivated()
            && (!_isBOMCalc || this.inventLocationCache().InventSiteId != InventLocation::find(this.inventLocationCache().InventLocationIdReqMain).InventSiteId))
        {
            reqRefType = ReqRefType::TransferPlannedOrder;
        }
        else
        {
            reqRefType = reqSetup.defaultPlannedOrderReqRefType();
        }

        if (_derivedDirectly && reqRefType == ReqRefType::TransferPlannedOrder)
        {
            reqRefType = reqSetup.defaultPlannedOrderReqRefType();
        }

        return reqRefType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postponeMargin</Name>
				<Source><![CDATA[
    public Days  postponeMargin()
    {
        return reqGroup.ActionPostponeMargin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>primaryVendId</Name>
				<Source><![CDATA[
    public ItemPrimaryVendId primaryVendId()
    {
        if (reqItemTableGrouped.ItemCovFieldsActive && reqItemTableGrouped.VendId)
            return reqItemTableGrouped.VendId;

        return reqSetup.primaryVendId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchCalendarId</Name>
				<Source><![CDATA[
    public PurchCalendarId purchCalendarId(VendAccount _vendId)
    {
        CalendarId calendarId = _vendId ? reqSetup.vendTableCache(_vendId).PurchCalendarId : '';

        if (! calendarId)
            calendarId = this.reqCalendarId();

        return calendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchaseVendorShipCalendar</Name>
				<Source><![CDATA[
    internal PurchVendorShipCalendarId purchaseVendorShipCalendar(VendAccount _vendorAccountNumber)
    {
        CalendarId calendarId = _vendorAccountNumber ? reqSetup.vendTableCache(_vendorAccountNumber).PurchaseShipCalendarId : '';

        return calendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>quantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the multiple quantity that applies for orders.
    /// </summary>
    /// <param name="_reqRefType">
    /// A <c>ReqRefType</c> enumeration value that holds the requirement type.
    /// </param>
    /// <returns>
    /// A real value that holds the order multiple quantity.
    /// </returns>
    public QtyMultiples quantity(
        ReqRefType      _reqRefType     = ReqRefType::None)
    {
        InventQty       quantity;
        ReqRefType      reqRefType;

        reqRefType = _reqRefType == ReqRefType::None ? this.plannedOrderTypeReq() : _reqRefType;

        switch (reqRefType)
        {
            case ReqRefType::ItemPlannedOrder:
                if (reqSetup.inventUnitId() != reqSetup.purchUnitId())
                {
                    quantity = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(reqSetup.itemId(),
                                                                                                     this.inventDim().InventDimId,
                                                                                                     this.inventItemPurchSetupCache().MultipleQty,
                                                                                                     reqSetup.purchUnitId(),
                                                                                                     reqSetup.inventUnitId(),
                                                                                                     NoYes::Yes);
                }
                else
                {
                    quantity = this.inventItemPurchSetupCache().MultipleQty;
                }
                break;

            default:
                quantity = this.inventItemInventSetupCache().MultipleQty;
        }

        return decRound(quantity,reqSetup.inventDecimals());
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryReqItemTable</Name>
				<Source><![CDATA[
    protected Query queryReqItemTable()
    {
        if (! covInventDimId)
        {
            return null;
        }

        if (! inventDim.RecId)
        {
            this.inventDim();
        }

        Query query = new Query();

        QueryBuildDataSource qbds = query.addDataSource(tableNum(ReqItemTable));

        qbds.addRange(fieldNum(ReqItemTable,ItemId)).value(queryValue(reqSetup.itemId()));

        QueryBuildDataSource qbdsDim = qbds.addDataSource(tableNum(InventDim));

        qbdsDim.joinMode(JoinMode::InnerJoin);
        qbdsDim.relations(true);

        List sortedCovDimFields = InventDim::reverseDimFieldsList(InventDimMetaDataCache::dimCovDimEnabledFieldList());
        ListEnumerator enumerator = sortedCovDimFields.getEnumerator();

        while (enumerator.moveNext())
        {
            FieldId dimFieldId = enumerator.current();

            if (inventDim.(dimFieldId))
            {
                qbdsDim.addRange(dimFieldId).value(queryValue(inventDim.(dimFieldId)));
                qbdsDim.addSortField(dimFieldId,SortOrder::Descending);
            }

            qbdsDim.addRange(dimFieldId).value(queryValue(InventDim::emptyDimField(dimFieldId)));  // in order to secure that invalid records aren't selected and default records are selected
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refillActivated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether a refill is enabled on the coverage warehouse.
    /// </summary>
    /// <returns>
    ///    true if the refill is enabled for the warehouse; otherwise, false.
    /// </returns>
    public boolean refillActivated()
    {
        var localInventLocationCache = this.inventLocationCache();
        if (   localInventLocationCache
            && localInventLocationCache.ReqRefill
            && localInventLocationCache.InventLocationIdReqMain)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shippingCalendarId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the calendar for the shipping warehouse.
    /// </summary>
    /// <param name = "_shippingInventLocationId">The shipping warehouse to get the calendar from; optional.</param>
    /// <returns>The Id of the calendar.</returns>
    public ReqCalendarId shippingCalendarId(InventLocationIdReqMain _shippingInventLocationId = this.mainInventLocationId(ReqRefType::TransferPlannedOrder))
    {
        if (isShippingCalendarSet)
        {
            return shippingCalendarId;
        }
        
        if (_shippingInventLocationId)
        {
            shippingCalendarId = InventLocation::find(_shippingInventLocationId).ReqCalendarId;
        }
        
        if (!shippingCalendarId && reqGroup.CalendarId)
        {
            shippingCalendarId = reqGroup.CalendarId;
        }

        isShippingCalendarSet = true;
        return shippingCalendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transportCalendarId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the calendar used for transfers.
    /// </summary>
    /// <returns>The Id of the calendar.</returns>
    /// <remarks>
    /// Calendars are evaluated in the following order: 
    /// 1. Transportation calendar set for default mode of delivery.
    /// 2. Calendar set on coverage group.
    /// </remarks>
    public ReqCalendarId transportCalendarId()
    {
        if (isTansportCalendarSet)
        {
            return transportCalendarId;
        }
        
        InventLocationIdReqMain mainInventLocationId = this.mainInventLocationId(ReqRefType::TransferPlannedOrder);

        DlvModeId dlvModeId = CustVendTransportPointLine::defaultDeliveryMode(mainInventLocationId,
                                                                                  '',
                                                                                  '',
                                                                                  '',
                                                                                  '',
                                                                                  this.inventLocationCache().InventLocationId);

        transportCalendarId = CustVendTransportCalendarSetup::find(dlvModeId,mainInventLocationId).Calendar;

        if (!transportCalendarId && reqGroup.CalendarId)
        {
            transportCalendarId = reqGroup.CalendarId;
        }
                
        isTansportCalendarSet = true;
        return transportCalendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqCalendarId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the calendar based on the coverage group or requirement warehouse.
    /// </summary>
    /// <returns>The Id of the calendar.</returns>
    public ReqCalendarId reqCalendarId()
    {
        CalendarId calendarId;
        
        if (reqGroup.CalendarId)
        {
            calendarId = reqGroup.CalendarId;
        }

        if (!calendarId)
        {
            calendarId = this.inventLocationCache().ReqCalendarId;
        }

        return calendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqGroupId</Name>
				<Source><![CDATA[
    ReqGroupId reqGroupId()
    {
        return reqGroup.ReqGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqReduceForecastWithIntercompanyOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the flag that indicates whether to reduce forecast with intercompany orders.
    /// </summary>
    /// <returns>
    /// A <c>ReqReduceForecastWithIntercompanyOrders</c> value indicating whether to reduce forecast with intercompany orders.
    /// </returns>
    public ReqReduceForecastWithIntercompanyOrders reqReduceForecastWithIntercompanyOrders()
    {
        return reqGroup.ReduceForecastWithIntercompanyOrders;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqReduceKeyId</Name>
				<Source><![CDATA[
    public ReqReduceKeyId reqReduceKeyId()
    {
        return reqGroup.ReqReduceKeyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>routeVersionReq</Name>
				<Source><![CDATA[
    public boolean routeVersionReq()
    {
        return reqGroup.RouteVersionReq;
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchReceiptFromDate</Name>
				<Source><![CDATA[
    public TransDate searchReceiptFromDate(ReqTrans _reqTrans,ReqDate _reqDate, TransDate todaysDate)
    {
        TransDate       transDate;

        transDate =  _reqDate - this.maxPositiveDays();

        return transDate <= todaysDate ? dateNull() : transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchReceiptToDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the date up to which a receipt to cover the <paramref name="_reqTrans" /> issue is supposed to be looked for.
    /// </summary>
    /// <param name = "_reqTrans">The issue requirement.</param>
    /// <param name = "_reqDate">The issue requirement date.</param>
    /// <param name = "_todaysDate">The todays date calculated.</param>
    /// <param name = "_reqPlanData">The master planning settings.</param>
    /// <returns>A date up to which a receipt is to be looked for.</returns>
    public TransDate searchReceiptToDate(
        ReqTrans        _reqTrans,
        ReqDate         _reqDate,
        TransDate       _todaysDate,
        ReqPlanData     _reqPlanData)
    {
        TransDate   transDate;
        TransDate   tmpDate = dateNull();
        Days        days = this.maxNegativeDays(_reqDate,_todaysDate,_reqPlanData);

        transDate = _reqPlanData.schedMarginBackward(_reqDate, _reqPlanData.marginReceipt(this),this); // delivery date

        if ( transDate < _todaysDate ) // margin must be forwarded -> maximum delivery date = today + negative days  and maximum requirement date = maximum delivery date + receipt margin
        {
            transDate = _reqPlanData.schedMarginForward(_todaysDate, 0 ,this) + days; // the calculated reqdate + days
            transDate = _reqPlanData.schedMarginForward(transDate, _reqPlanData.marginReceipt(this), this);
        }
        else
        {
            transDate = _reqDate + days;
        }

        if (_reqPlanData.timeFenceLocking(this))
        {
            tmpDate = _reqPlanData.schedMarginForward(_todaysDate + _reqPlanData.timeFenceLocking(this), _reqPlanData.marginReceipt(this), this);
        }

        if (_reqPlanData.dynamicNegativeDays())
        {
            this.checkTradeAgreement(_reqPlanData, _reqTrans, _reqDate);

            TransDate plannedReceiptDate = this.calcPlannedReceiptDate(_reqPlanData);
            transDate = max(transDate, (plannedReceiptDate + days));
        }

        return max(transDate, tmpDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTradeAgreement</Name>
				<Source><![CDATA[
    private void checkTradeAgreement(ReqPlanData _reqPlanData, ReqTrans _reqTrans, ReqDate _reqDate)
    {
        this.tradeAgreementLeadTime = 0;
        this.tradeAgreementCalendarDays = NoYes::No;
        this.isTradeAgreementSet = false;
        if (_reqPlanData.searchTradeAgreement() && this.plannedOrderTypeReq() == ReqRefType::ItemPlannedOrder)
        {
            if (reqUseTradeAgreementLazyLoadPerOrderFlightEnabled)
            {
                container foundTradeAgreementData = this.retrieveCachedTradeAgreementLeadTime(_reqDate, -_reqTrans.Qty);
                if (foundTradeAgreementData != conNull())
                {
                    this.tradeAgreementLeadTime = conPeek(foundTradeAgreementData, 1);
                    this.tradeAgreementCalendarDays = conPeek(foundTradeAgreementData, 2);
                    this.isTradeAgreementSet = true;
                }
            }
            else
            {
                PriceDiscTable priceDiscTable = this.getTradeAgreement(_reqTrans, _reqDate, _reqPlanData.searchTradeMethod());
                if (priceDiscTable.RecId && !priceDiscTable.DisregardLeadTime && priceDiscTable.DeliveryTime >= 0)
                {
                    this.tradeAgreementLeadTime = priceDiscTable.DeliveryTime;
                    this.tradeAgreementCalendarDays = priceDiscTable.CalendarDays;
                    this.isTradeAgreementSet = true;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchMatchingTradeAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the trade agreement exists for the item.
    /// </summary>
    /// <param name = "_reqPlanData">The master planning data.</param>
    [Hookable(false)]
    internal void searchMatchingTradeAgreement(ReqPlanData _reqPlanData)
    {
        ReqTrans reqTrans;
        reqTrans.ItemId = this.setup().itemId();
        reqTrans.CovInventDimId = this.covInventDimId;
        reqTrans.Qty = - this.minInventOnHand();

        this.checkTradeAgreement(_reqPlanData, reqTrans, _reqPlanData.todaysdate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPlannedReceiptDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate receipt date of planned order based on session date by using the similar code logic from method ReqPO.setSchedFromDate().
    /// </summary>
    /// <param name="_reqPlanData">
    /// A <c>ReqPlanData</c> object that contains master scheduling settings.
    /// </param>
    /// <returns>
    /// Receipt date of planned order.
    /// </returns>
    protected TransDate calcPlannedReceiptDate(ReqPlanData _reqPlanData)
    {
        PurchCalendarId purchCalendarId = this.purchCalendarId(this.primaryVendId());
        ReqRefType reqRefType = this.plannedOrderTypeReq();
        TransDate plannedReceiptDate = _reqPlanData.workCalendarSched().schedDate(SchedDirection::Forward, _reqPlanData.todaysdate(), 0, 0, purchCalendarId);
        plannedReceiptDate = _reqPlanData.schedMarginForward(plannedReceiptDate, _reqPlanData.marginOrder(this), this, purchCalendarId);
        plannedReceiptDate = this.schedulePlannedReceiptDateLeadTime(_reqPlanData, plannedReceiptDate, reqRefType, purchCalendarId);
        return _reqPlanData.schedMarginForward(plannedReceiptDate, _reqPlanData.marginReceipt(this), this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedulePlannedReceiptDateLeadTime</Name>
				<Source><![CDATA[
    private TransDate schedulePlannedReceiptDateLeadTime(ReqPlanData _reqPlanData, TransDate _plannedReceiptDate, ReqRefType _reqRefType, PurchCalendarId _purchCalendarId)
    {
        LeadTime leadTime = this.isTradeAgreementSet ? this.tradeAgreementLeadTime : this.leadTime(_reqRefType);
        CalendarDays leadTimeCalendarDays = this.isTradeAgreementSet ? this.tradeAgreementCalendarDays : this.leadTimeCalendarDays(_reqRefType);
        return _reqPlanData
            .workCalendarSched()
            .schedDate(SchedDirection::Forward, _plannedReceiptDate, leadTime, leadTimeCalendarDays, this.reqCalendarId(), _purchCalendarId, SalesCheckForPickup::Never);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventItemInventSetup</Name>
				<Source><![CDATA[
    [SysObsolete('This method is deprecated, use setInventItemInventSetupCache() instead.', false, 31\03\2018)]
    protected InventItemInventSetup setInventItemInventSetup()
    {
        return InventItemInventSetup::find(reqSetup.inventTable().ItemId, covInventDimId,false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventItemInventSetupCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets an instance of the <c>ReqSetupDimInventItemInventSetupCacheObject</c> if needed, and returns it.
    /// </summary>
    /// <returns>An instance of the <c>ReqSetupDimInventItemInventSetupCacheObject</c></returns>
    protected ReqSetupDimInventItemInventSetupCacheObject setInventItemInventSetupCache()
    {
        if (!inventItemInventSetup.isCacheInitialized())
        {
            inventItemInventSetup.initFromRecord(InventItemInventSetup::find(reqSetup.inventTable().ItemId, covInventDimId,false));
        }

        return inventItemInventSetup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventItemPurchSetup</Name>
				<Source><![CDATA[
    [SysObsolete('This method is deprecated, use setInventItemPurchSetupCache() instead.', false, 31\03\2018)]
    protected InventItemPurchSetup setInventItemPurchSetup()
    {
        return InventItemPurchSetup::find(reqSetup.inventTable().ItemId, covInventDimId,false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventItemPurchSetupCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets an instance of the <c>ReqSetupDimInventItemPurchSetupCacheObject</c> if needed, and returns it.
    /// </summary>
    /// <returns>An instance of the <c>ReqSetupDimInventItemPurchSetupCacheObject</c></returns>
    protected ReqSetupDimInventItemPurchSetupCacheObject setInventItemPurchSetupCache()
    {
        if (!inventItemPurchSetup.isCacheInitialized())
        {
            inventItemPurchSetup.initFromRecord(InventItemPurchSetup::find(reqSetup.inventTable().ItemId, covInventDimId,false));
        }

        return inventItemPurchSetup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReqGroup</Name>
				<Source><![CDATA[
    protected void setReqGroup()
    {
        InventTable inventTable = reqSetup.inventTable();
        ReqGroup reqGroupLocal;
        ReqGroupId reqGroupId;

        if (#PmfEnabled
            && inventTable.PmfProductType == PmfProductType::Co_Product
            && !inventTable.ReqGroupId)
        {
            reqGroupId = InventTable::find(inventTable.PmfPlanningItemId).ReqGroupId;
        }
        else
        {
            reqGroupId = inventTable.ReqGroupId;
        }

        reqGroupLocal = ReqGroup::defaultTable(inventTable.ReqGroupId, reqItemTableGrouped.ItemCovFieldsActive ? reqItemTableGrouped.ReqGroupId : '');

        reqGroup.initFromRecord(reqGroupLocal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReqItemTableGrouped</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specific item coverage record and eventual default records.
    /// </summary>
    /// <param name = "_builder">A <c>ReqSetupDimBuilder</c> instance.</param>
    /// <remarks>
    ///    Based on these records a grouped item coverage record buffer is created.
    ///    The grouped item coverage
    ///    record contains specific settings and fallback settings.
    /// </remarks>
    protected void setReqItemTableGrouped(ReqSetupDimBuilder _builder = null)
    {
        InventDimSHA1HashHex getHash(ListEnumerator _fieldIdListListEnumerator)
        {
            if (_fieldIdListListEnumerator.moveNext())
            {
                List fieldIdList = _fieldIdListListEnumerator.current();
                InventDim filterDim = inventDim.copySelectedDimensions(fieldIdList);
                return filterDim.hashValue();
            }

            return '';
        }

        ReqItemTable                    reqItemTable;
        InventDim                       inventDimSearch;
        ReqItemTable                    reqItemTableGroupedLocal;

        #inventDimDevelop

        if (! covInventDimId)
        {
            return;
        }

        if (! inventDim.RecId)
        {
            this.inventDim();
        }

        List flagsList = _builder ? _builder.distinctInventDimFlagsList : null;
        boolean canUseFlagsOptimization = flagsList && flagsList.elements() <= 8 && flagsList.elements() > 0;

        
        // Inline x++ queries do not have a counter part of the "in" operator hence we cannot use an array of
        // hash keys as a filter. We do not expect to see more than 3 levels of item coverage records. Accounting
        // for 8 levels should cover the most extreme cases.
        InventDimSHA1HashHex dim1Hash, dim2Hash, dim3Hash, dim4Hash, dim5Hash, dim6Hash, dim7Hash, dim8Hash;

        if (canUseFlagsOptimization)
        {
            ListEnumerator flagsListEnumerator = flagsList.getEnumerator();
            
            dim1Hash = getHash(flagsListEnumerator);
            dim2Hash = getHash(flagsListEnumerator);
            dim3Hash = getHash(flagsListEnumerator);
            dim4Hash = getHash(flagsListEnumerator);
            dim5Hash = getHash(flagsListEnumerator);
            dim6Hash = getHash(flagsListEnumerator);
            dim7Hash = getHash(flagsListEnumerator);
            dim8Hash = getHash(flagsListEnumerator);
        }

        boolean itemCoverageRecordsMayExist = !flagsList || flagsList.elements() != 0;

        if (itemCoverageRecordsMayExist)
        {
            // Normally a query should be used to build up this select but the performance overhead was too high
            // The "order by" part determine a prioritized order of coverage dimensions
            // This hard coded order must be in sync with \Data Dictionary\Tables\InventDim\Field Groups\ReqDimensionsPrioritized
            while select forceplaceholders reqItemTable
                where reqItemTable.ItemId == reqSetup.itemId()
                join TableId from inventDimSearch
                order by
                    InventSiteId desc,
                    ConfigId desc,
                    InventSizeId desc,
                    InventColorId desc,
					InventVersionId desc,
                    InventStyleId desc,
                    InventLocationId desc,
                    InventBatchId desc,
                    WmsLocationId desc,
                    InventSerialId desc,
                    InventStatusId desc,
                    LicensePlateId desc,
                    InventOwnerId_RU desc,
                    InventProfileId_RU desc,
                    InventGtdId_RU desc,
                    InventDimension1 desc,
                    InventDimension2 desc,
                    InventDimension3 desc,
                    InventDimension4 desc,
                    InventDimension5 desc,
                    InventDimension6 desc,
                    InventDimension7 desc,
                    InventDimension8 desc,
                    InventDimension9 desc,
                    InventDimension10 desc,
                    InventDimension11 desc,
                    InventDimension12 desc
                where inventDimSearch.InventDimId == reqItemTable.CovInventDimId
                    && (
                        (canUseFlagsOptimization
                            &&  (
                                   (dim1Hash && inventDimSearch.SHA1HashHex == dim1Hash)
                                || (dim2Hash && inventDimSearch.SHA1HashHex == dim2Hash)
                                || (dim3Hash && inventDimSearch.SHA1HashHex == dim3Hash)
                                || (dim4Hash && inventDimSearch.SHA1HashHex == dim4Hash)
                                || (dim5Hash && inventDimSearch.SHA1HashHex == dim5Hash)
                                || (dim6Hash && inventDimSearch.SHA1HashHex == dim6Hash)
                                || (dim7Hash && inventDimSearch.SHA1HashHex == dim7Hash)
                                || (dim8Hash && inventDimSearch.SHA1HashHex == dim8Hash)
                            )
                        )
                        || 
                        (!canUseFlagsOptimization
                            && (inventDimSearch.InventSiteId      == '' || (inventDim.InventSiteId        && inventDimSearch.InventSiteId       == inventDim.InventSiteId      ))
                            && (inventDimSearch.ConfigId          == '' || (inventDim.ConfigId            && inventDimSearch.ConfigId           == inventDim.ConfigId          ))
                            && (inventDimSearch.InventSizeId      == '' || (inventDim.InventSizeId        && inventDimSearch.InventSizeId       == inventDim.InventSizeId      ))
                            && (inventDimSearch.InventColorId     == '' || (inventDim.InventColorId       && inventDimSearch.InventColorId      == inventDim.InventColorId     ))
                            && (inventDimSearch.InventVersionId   == '' || (inventDim.InventVersionId     && inventDimSearch.InventVersionId    == inventDim.InventVersionId   ))
                            && (inventDimSearch.InventStyleId     == '' || (inventDim.InventStyleId       && inventDimSearch.InventStyleId      == inventDim.InventStyleId     ))
                            && (inventDimSearch.InventLocationId  == '' || (inventDim.InventLocationId    && inventDimSearch.InventLocationId   == inventDim.InventLocationId  ))
                            && (inventDimSearch.InventBatchId     == '' || (inventDim.InventBatchId       && inventDimSearch.InventBatchId      == inventDim.InventBatchId     ))
                            && (inventDimSearch.WmsLocationId     == '' || (inventDim.WmsLocationId       && inventDimSearch.WmsLocationId      == inventDim.WmsLocationId     ))
                            && (inventDimSearch.InventSerialId    == '' || (inventDim.InventSerialId      && inventDimSearch.InventSerialId     == inventDim.InventSerialId    ))
                            && (inventDimSearch.InventStatusId    == '' || (inventDim.InventStatusId      && inventDimSearch.InventStatusId     == inventDim.InventStatusId    ))
                            && (inventDimSearch.LicensePlateId    == '' || (inventDim.LicensePlateId      && inventDimSearch.LicensePlateId     == inventDim.LicensePlateId    ))
                            // <GEERU>
                            && (inventDimSearch.InventOwnerId_RU  == '' || (inventDim.InventOwnerId_RU    && inventDimSearch.InventOwnerId_RU   == inventDim.InventOwnerId_RU  ))
                            && (inventDimSearch.InventProfileId_RU== '' || (inventDim.InventProfileId_RU  && inventDimSearch.InventProfileId_RU == inventDim.InventProfileId_RU))
                            && (inventDimSearch.InventGtdId_RU    == '' || (inventDim.InventGtdId_RU      && inventDimSearch.InventGtdId_RU     == inventDim.InventGtdId_RU    ))
                            // </GEERU>
                            && (inventDimSearch.InventDimension1  == '' || (inventDim.InventDimension1    && inventDimSearch.InventDimension1   == inventDim.InventDimension1  ))
                            && (inventDimSearch.InventDimension2  == '' || (inventDim.InventDimension2    && inventDimSearch.InventDimension2   == inventDim.InventDimension2  ))
                            && (inventDimSearch.InventDimension3  == '' || (inventDim.InventDimension3    && inventDimSearch.InventDimension3   == inventDim.InventDimension3  ))
                            && (inventDimSearch.InventDimension4  == '' || (inventDim.InventDimension4    && inventDimSearch.InventDimension4   == inventDim.InventDimension4  ))
                            && (inventDimSearch.InventDimension5  == '' || (inventDim.InventDimension5    && inventDimSearch.InventDimension5   == inventDim.InventDimension5  ))
                            && (inventDimSearch.InventDimension6  == '' || (inventDim.InventDimension6    && inventDimSearch.InventDimension6   == inventDim.InventDimension6  ))
                            && (inventDimSearch.InventDimension7  == '' || (inventDim.InventDimension7    && inventDimSearch.InventDimension7   == inventDim.InventDimension7  ))
                            && (inventDimSearch.InventDimension8  == '' || (inventDim.InventDimension8    && inventDimSearch.InventDimension8   == inventDim.InventDimension8  ))
                            && (inventDimSearch.InventDimension9  == utcDateTimeNull() || (inventDim.InventDimension9    && inventDimSearch.InventDimension9   == inventDim.InventDimension9  ))
                            && (inventDimSearch.InventDimension10 == 0  || (inventDim.InventDimension10   && inventDimSearch.InventDimension10  == inventDim.InventDimension10 ))
                            && (inventDimSearch.InventDimension11 == '' || (inventDim.InventDimension11   && inventDimSearch.InventDimension11  == inventDim.InventDimension11 ))
                            && (inventDimSearch.InventDimension12 == '' || (inventDim.InventDimension12   && inventDimSearch.InventDimension12  == inventDim.InventDimension12 ))
                        )
                )
            {

                if (! reqItemTableGroupedLocal.ItemId)
                {
                    // if min/max is used and not all coverage planned dimensions are specified, then consider this setup as invalid and ignore min/max values
                    if ((reqItemTable.MinInventOnhand || reqItemTable.MaxInventOnhand) &&
                        !reqItemTable.allCovDimSpecified(reqSetup.inventDimGroupSetup()))
                    {
                        reqItemTable.MinInventOnhand    = 0;
                        reqItemTable.MaxInventOnhand    = 0;

                        warning(strFmt("@SYS129512", reqItemTable.ItemId));
                    }

                    reqItemTableGroupedLocal.data(reqItemTable);
                }
                else
                {
                    reqItemTableGroupedLocal.initFromReqItemTable(reqItemTable);
                }
            }
        }

        reqItemTableGrouped.initFromRecord(reqItemTableGroupedLocal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setup</Name>
				<Source><![CDATA[
    public ReqSetup setup()
    {
        return reqSetup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showInfolog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows the Infolog messages that occurred during the initialization of this class.
    /// </summary>
    public void showInfolog()
    {
        if (!conLen(conInfolog))
        {
            return;
        }

        infolog.import(conInfolog);
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceAction</Name>
				<Source><![CDATA[
    public Days  timeFenceAction()
    {
        return reqGroup.ActionTimeFence;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceAuthorization</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the authorization time fence for the specified item ID and coverage dimension.
    /// </summary>
    /// <returns>
    ///    An integer value that holds the authorization time fence in days.
    /// </returns>
    public Days  timeFenceAuthorization()
    {
        if (reqItemTableGrouped.TimeFenceFieldsActive)
        {
            return reqItemTableGrouped.AuthorizationTimeFence;
        }

        return reqGroup.AuthorizationTimeFence;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceBackRequisition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Backward requisition time fence.
    /// </summary>
    /// <returns>
    /// Number of days in the past, during which demand from
    /// requisitions is included in master scheduling.
    /// </returns>
    public Days timeFenceBackRequisition()
    {
        if (reqItemTableGrouped.TimeFenceFieldsActive)
        {
            return reqItemTableGrouped.TimeFenceBackRequisition;
        }

        return reqGroup.TimeFenceBackRequisition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceCapacity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the capacity time fence for the specified item ID and coverage dimension.
    /// </summary>
    /// <returns>
    ///    An integer value that holds the capacity time fence in days.
    /// </returns>
    public Days timeFenceCapacity()
    {
        if (reqItemTableGrouped.TimeFenceFieldsActive)
        {
            return reqItemTableGrouped.CapacityTimeFence;
        }

        return reqGroup.CapacityTimeFence;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceCov</Name>
				<Source><![CDATA[
    public TimeFenceCoverage timeFenceCov()
    {
        if (reqItemTableGrouped.CovFieldsActive)
            return reqItemTableGrouped.CovTimeFence;

        return reqGroup.CovTimeFence;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceExplosion</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the explosion time fence for the specified item ID and coverage dimension.
    /// </summary>
    /// <returns>
    ///    An integer value that holds the explosion time fence in days.
    /// </returns>
    public Days timeFenceExplosion()
    {
        if (reqItemTableGrouped.TimeFenceFieldsActive)
        {
            return reqItemTableGrouped.ExplosionTimeFence;
        }

        return reqGroup.ExplosionTimeFence;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceForecast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the forecast time fence.
    /// </summary>
    /// <returns>
    ///    An integer that contains the number of days that determines the period in which forecast is
    ///    included.
    /// </returns>
    public Days timeFenceForecast()
    {
        return reqGroup.MasterPlanTimeFence;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceFutures</Name>
				<Source><![CDATA[
    public Days  timeFenceFutures()
    {
        return reqGroup.FuturesTimeFence;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceLocking</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the locking time fence for the specified item ID and coverage dimension.
    /// </summary>
    /// <returns>
    ///    An integer value that holds the locking time fence in days.
    /// </returns>
    public Days timeFenceLocking()
    {
        if (reqItemTableGrouped.TimeFenceFieldsActive)
        {
            return reqItemTableGrouped.LockingTimeFence;
        }

        return reqGroup.LockingTimeFence;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the current setup.
    /// </summary>
    /// <param name="_throwIfError">
    ///    A Boolean value that indicates if an error must be thrown on failure.
    /// </param>
    /// <returns>
    ///    true if the validation is successful; otherwise, false.
    /// </returns>
    public boolean validate(boolean _throwIfError = true)
    {
        return reqSetup.validate(_throwIfError);
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendorDlvMode</Name>
				<Source><![CDATA[
    public VendDlvModeId vendorDlvMode(VendAccount _vendId)
    {
        VendDlvModeId dlvMode = _vendId ? reqSetup.vendTableCache(_vendId).DlvMode : '';

        return dlvMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendorPostalAddress</Name>
				<Source><![CDATA[
    public LogisticsPostalAddress vendorPostalAddress(VendAccount _vendId)
    {
        LogisticsPostalAddressRecId postalAddressRecId = _vendId ? reqSetup.vendTableCache(_vendId).PostalAddressRecId : 0;

        return LogisticsPostalAddress::findRecId(postalAddressRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCovInventDimId</Name>
				<Source><![CDATA[
    public static ReqSetupDim newCovInventDimId(
        ReqSetup            _reqSetup,
        ReqCovInventDimId   _covInventDimId,
        InventDimGroupSetup _inventDimGroupSetup = null)
    {
        ReqSetupDimBuilder builder = new ReqSetupDimBuilder();

        builder.reqSetup(_reqSetup);
        builder.covInventDimId(_covInventDimId);

        return ReqSetupDim::newFromBuilder(builder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromBuilder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of <c>ReqSetupDim</c> from a <c>ReqSetupDimBuilder</c> instance.
    /// </summary>
    /// <param name = "_reqSetupDimBuilder">
    /// A <c>ReqSetupDimBuilder</c> instance that holds the data needed to create a <c>ReqSetupDim</c> instance.
    /// </param>
    /// <returns>
    /// A new instance of <c>ReqSetupDim</c>.
    /// </returns>
    public static ReqSetupDim newFromBuilder(ReqSetupDimBuilder _reqSetupDimBuilder)
    {
        ReqSetupDim reqSetupDim = new ReqSetupDim();

        reqSetupDim.init(_reqSetupDimBuilder);

        return reqSetupDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventTable</Name>
				<Source><![CDATA[
    public static ReqSetupDim newInventTable(
        InventTable         _inventTable,
        InventDimId         _inventDimId,
        InventDim           _inventDim = null)
    {

        ReqSetupDimBuilder builder = new ReqSetupDimBuilder();

        builder.inventTable(_inventTable);
        builder.inventDimId(_inventDimId);
        builder.inventDim(_inventDim);

        return ReqSetupDim::newFromBuilder(builder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLeanLocationCache</Name>
				<Source><![CDATA[
    public LeanLocationCache parmLeanLocationCache(LeanLocationCache _leanLocationCache = leanLocationCache)
    {
        leanLocationCache = _leanLocationCache;

        return leanLocationCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the item level associated with the current instance.
    /// </summary>
    /// <returns>
    /// The item level.
    /// </returns>
    public BOMLevel itemLevel()
    {
        return inventDistinctProduct.isCacheInitialized() ? inventDistinctProduct.Level : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the item number.
    /// </summary>
    /// <returns>The item number.</returns>
    public ItemId itemId()
    {
        return this.parmReqSetup() ? this.parmReqSetup().itemId() : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventDistinctProduct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the distinct product record for the current setup object.
    /// </summary>
    public void setInventDistinctProduct()
    {
        inventDistinctProduct.initFromRecord(
            InventDistinctProduct::find(reqSetup.itemId(), covInventDimId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTradeAgreement</Name>
				<Source><![CDATA[
    private PriceDiscTable getTradeAgreement(ReqTrans _issueReqTrans, ReqDate _reqDate, ReqSearchTradeMethod _reqSearchTradeMethod)
    {
        return ReqTrans::findPriceDiscTable(
            _issueReqTrans.ItemId,
            _issueReqTrans.CovInventDimId,
            -_issueReqTrans.Qty,
            _reqDate,
            _reqSearchTradeMethod,
            reqSetup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveCachedTradeAgreementLeadTime</Name>
				<Source><![CDATA[
    private container retrieveCachedTradeAgreementLeadTime(ReqDate _reqDate, InventQty _receiptQty)
    {
        if (!mapLeadTime)
        {
            this.initMapLeadTime();
        }

        container tradeAgreementLeadTimesKey = [_reqDate, _receiptQty];
        if (!mapLeadTime.exists(tradeAgreementLeadTimesKey))
        {
            mapLeadTime.insert(tradeAgreementLeadTimesKey, this.searchMatchingTradeAgreementForOrder(_reqDate, _receiptQty));
        }

        return mapLeadTime.lookup(tradeAgreementLeadTimesKey);
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchMatchingTradeAgreementForOrder</Name>
				<Source><![CDATA[
    private container searchMatchingTradeAgreementForOrder(ReqDate _reqDate, InventQty _receiptQty)
    {
        ReqParameters parameters = ReqParameters::find();
        
        if (parameters.ReqSearchTradeAgreement && this.plannedOrderTypeReq() == ReqRefType::ItemPlannedOrder)
        {
            PriceDiscTable priceDiscTable = ReqTrans::findPriceDiscTable(
                this.setup().itemId(),
                this.covInventDimId,
                _receiptQty,
                _reqDate,
                parameters.ReqSearchTradeMethod,
                this.reqSetup);
                
            if (priceDiscTable.RecId && !priceDiscTable.DisregardLeadTime && priceDiscTable.DeliveryTime >= 0)
            {
                return [priceDiscTable.DeliveryTime, priceDiscTable.CalendarDays];
            }
        }

        return conNull();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>