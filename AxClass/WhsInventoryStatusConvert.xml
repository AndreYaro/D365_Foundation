<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WhsInventoryStatusConvert</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///     This job will convert all inventory hit by the query to the chosen status.
/// </summary>
public class WhsInventoryStatusConvert extends RunBaseBatch implements BatchRetryable, SysErrorMessageHelpScopeIBatchProvider
{
    private const int MaxStatusChangesBeforeShowingInfoOnEstimate = 1000;
    QueryRun                         queryRun;
    DialogField                      dialogToStatus;
    WHSInventStatusTo                toStatus;
    WHSTmpStatusChange               tmpStatusChange;
    container                        errorLog;
    boolean                          throwOnError;
    private InventBlockingComplete   inventBlockingComplete;
    private InventDim                prevInventDim;
    private ItemId                   prevItemId;

    private TableName                conversionInventDimItemTablePhysicalName;
    internal WHSInstrumentationLogger logger;

    #LOCALMACRO.CurrentList11
        toStatus,
        throwOnError        
    #ENDMACRO

    #LOCALMACRO.CurrentList12
        toStatus,
        throwOnError,
        inventBlockingComplete
    #ENDMACRO

    #DEFINE.CurrentVersion(13)
    #LOCALMACRO.CurrentList
        toStatus,
        throwOnError,
        inventBlockingComplete,
        conversionInventDimItemTablePhysicalName
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addLocToDeleteList</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether a given location must be added to the list for pending deletion.
    /// </summary>
    /// <param name="_prevLocation">
    ///     The previous <c>WMSLocation</c> record.
    /// </param>
    /// <param name="_runningQty">
    ///     The total running quantity for the previous location.
    /// </param>
    /// <returns>
    ///     Returns a boolean value indicating whether or not the given location must be added to the list for deletion.
    /// </returns>
    protected boolean addLocToDeleteList(WMSLocation _prevLocation, InventQty _runningQty)
    {
        boolean     ret;

        WHSLocationProfile locationProfile = WHSLocationProfile::find(_prevLocation.LocProfileId);
        if (_prevLocation && locationProfile && !locationProfile.AllowMixedStatus)
        {
            InventDim inventDim;

            if (InventUpdateOnhandGlobal::instance().inventUpdateOnhand().mustAddAnyInventSumDeltaOnhand())
            {
                if (InventUseDimOfInventSumToggle::instance().isEnabled() && InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
                {
                    InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumWithDim;

                    select sum(PhysicalInvent) from inventSumWithDim
                        group by inventSumWithDim.InventSiteId, inventSumWithDim.InventLocationId, inventSumWithDim.InventStatusId, inventSumWithDim.wmsLocationId
                        where inventSumWithDim.PhysicalInvent > 0
                           && inventSumWithDim.InventLocationId   == _prevLocation.InventLocationId
                           && inventSumWithDim.wmsLocationId      == _prevLocation.wmsLocationId;

                    if (inventSumWithDim.PhysicalInvent > _runningQty)
                    {
                        ret = true;
                    }
                }
                else
                {
                    InventSumUnionDeltaPhysicalQty	inventSumUnionDeltaPhysicalQty;

                    select sum(PhysicalInvent) from inventSumUnionDeltaPhysicalQty
                        group by inventDim.InventSiteId, inventDim.InventLocationId, inventDim.InventStatusId, inventDim.wmsLocationId
                        where inventSumUnionDeltaPhysicalQty.PhysicalInvent > 0
                        join inventDim
                        where inventDim.InventDimId        == inventSumUnionDeltaPhysicalQty.InventDimId
                           && inventDim.InventLocationId   == _prevLocation.InventLocationId
                           && inventDim.wmsLocationId      == _prevLocation.wmsLocationId;

                    if (inventSumUnionDeltaPhysicalQty.PhysicalInvent > _runningQty)
                    {
                        ret = true;
                    }
                }
            }
			else
            {
                InventSum inventSum;

                if (InventUseDimOfInventSumToggle::instance().isEnabled())
                {
                    select sum(PhysicalInvent) from inventSum
                    group by inventSum.InventSiteId, inventSum.InventLocationId, inventSum.InventStatusId, inventSum.wmsLocationId
                    where inventSum.ClosedQty == NoYes::No
                       && inventSum.PhysicalInvent > 0
                       && inventSum.InventLocationId   == _prevLocation.InventLocationId
                       && inventSum.wmsLocationId      == _prevLocation.wmsLocationId;
                }
                else
                {
                    select sum(PhysicalInvent) from inventSum
                    group by inventDim.InventSiteId, inventDim.InventLocationId, inventDim.InventStatusId, inventDim.wmsLocationId
                    where inventSum.ClosedQty == NoYes::No
                       && inventSum.PhysicalInvent > 0
                    join inventDim
                    where inventDim.InventDimId        == inventSum.InventDimId
                       && inventDim.InventLocationId   == _prevLocation.InventLocationId
                       && inventDim.wmsLocationId      == _prevLocation.wmsLocationId;
                }

                if (inventSum.PhysicalInvent > _runningQty)
                {
                    ret = true;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLPToDeleteList</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether a given license plate must be added to the list for pending deletion.
    /// </summary>
    /// <param name="_prevLP">
    ///     The previous license plate identifier.
    /// </param>
    /// <param name="_runningQty">
    ///     The total running quantity for the previous license plate.
    /// </param>
    /// <returns>
    ///     Returns a boolean value indicating whether or not the given license plate must be added to the list for deletion.
    /// </returns>
    protected boolean addLPToDeleteList(WHSLicensePlateId _prevLP, InventQty _runningQty)
    {
        boolean ret;

        if (_prevLP)
        {
            InventDim inventDim;
            InventDimParm inventDimParmCriteria;
            
            if (prevInventDim)
            {
                inventDimParmCriteria = this.retrieveInventDimParmForQuarantine(prevInventDim);
            }

            if (InventUpdateOnhandGlobal::instance().inventUpdateOnhand().mustAddAnyInventSumDeltaOnhand())
            {
                if (InventUseDimOfInventSumToggle::instance().isEnabled() && InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
                {
                    InventSumWithInventDimUnionDeltaWithInventDimPhysicalQty inventSumWithDim;

                    select sum(PhysicalInvent) from inventSumWithDim
                        where inventSumWithDim.PhysicalInvent > 0
                            && inventSumWithDim.LicensePlateId == _prevLP
                            && (prevItemId == '' || inventSumWithDim.ItemId == prevItemId)
                            && (!prevInventDim || #InventDimFieldsFilter(inventSumWithDim, prevInventDim, inventDimParmCriteria));

                    if (inventSumWithDim.PhysicalInvent > _runningQty)
                    {
                        ret = true;
                    }
                }
                else
                {
                    InventSumUnionDeltaPhysicalQty  inventSumUnionDeltaPhysicalQty;

                    select sum(PhysicalInvent) from inventSumUnionDeltaPhysicalQty
                        group by inventDim.LicensePlateId
                        where inventSumUnionDeltaPhysicalQty.PhysicalInvent > 0
                           && (prevItemId == '' || inventSumUnionDeltaPhysicalQty.ItemId == prevItemId)
                        join TableId from inventDim
                            where inventDim.InventDimId     == inventSumUnionDeltaPhysicalQty.InventDimId
                               && inventDim.LicensePlateId == _prevLP
                               && (!prevInventDim || #InventDimFieldsFilter(inventDim, prevInventDim, inventDimParmCriteria));

                    if (inventSumUnionDeltaPhysicalQty.PhysicalInvent > _runningQty)
                    {
                        ret = true;
                    }
                }           
            }
			else
            {
                InventSum inventSum;
                
                if (InventUseDimOfInventSumToggle::instance().isEnabled())
                {
                    select sum(PhysicalInvent) from inventSum
                    where inventSum.ClosedQty == NoYes::No
                        && inventSum.PhysicalInvent > 0
                        && inventSum.LicensePlateId == _prevLP
                        && (prevItemId == '' || inventSum.ItemId == prevItemId)
                        && (!prevInventDim || #InventDimFieldsFilter(inventSum, prevInventDim, inventDimParmCriteria));
                }
                else
                {
                    select sum(PhysicalInvent) from inventSum
                    group by inventDim.LicensePlateId
                    where inventSum.ClosedQty == NoYes::No
                       && inventSum.PhysicalInvent > 0
                       && (prevItemId == '' || inventSum.ItemId == prevItemId)
                    join TableId from inventDim
                        where inventDim.InventDimId    == inventSum.InventDimId
                           && inventDim.LicensePlateId == _prevLP
                           && (!prevInventDim || #InventDimFieldsFilter(inventDim, prevInventDim, inventDimParmCriteria));
                }

                if (inventSum.PhysicalInvent > _runningQty)
                {
                    ret = true;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQuery</Name>
				<Source><![CDATA[
    Query buildQuery()
    {
        Query                query;
        QueryBuildRange      qbr;

        if (this.shouldUseDenormalizedInventSum())
        {
            query = new Query(queryStr(WHSInventStatusChangeDenormInventSum));
            if (WHSInventoryStatusConvertShowItemRangeDenormFlight::instance().isEnabled())
            {
                SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(InventSum)), fieldNum(InventSum, itemId)).status(RangeStatus::Open);
            }
            else
            {
                // we should hide the default range created from primary index, so that the ItemId becomes displayed by default.
                qbr   = SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(InventSum)), fieldNum(InventSum, Closed));
                qbr.status(RangeStatus::Hidden);
            }
        }
        else
        {
            query = new Query(queryStr(WHSInventStatusChange));
            // we should hide the default range created from primary index, so that the ItemId becomes displayed by default.
            qbr   = SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(InventSum)), fieldNum(InventSum, Closed));
            qbr.status(RangeStatus::Hidden);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isQueryDataSourcesEligible</Name>
				<Source><![CDATA[
    private boolean isQueryDataSourcesEligible(
        InventDim           _inventDim,
        InventSum           _inventSum,
        WHSLPControlled     _lpControlled)
    {
        boolean ret = _inventDim.wmsLocationId
            // dim provides a license plate or location is non-license plate controlled 
            && (_inventDim.LicensePlateId 
                || (!_inventDim.LicensePlateId
                    && !_lpControlled))
            // Catch weight items are enabled for status conversion if feature is enabled; tag tracked are enabled also only if the tag dimension tracking policy value is all storage dimensions
            // This code change must be made in addition to the query change to support existing customers who have not taken the latest query changes into existing batch job.
            && (!PdsGlobal::pdsIsCWItem(_inventSum.ItemId)
                || (WHSCatchWeightConfigurationKeyManager::instance().isEnabled()
                    && (!WHSInventTable::isCatchWeightTagTracked(_inventSum.ItemId)
                        || WHSInventTable::catchWeightTagDimensionTrackingMethod(_inventSum.ItemId) == WHSCatchWeightTagDimensionTrackingMethod::ProductTrackingAndAllStorageDimensions)));
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQtyReservedForWork</Name>
				<Source><![CDATA[
    private WhsItemQty getQtyReservedForWork(ItemId _itemId, InventDim _inventDim)
    {
        InventQty inventQty = 0;
        PdsCWQty pdsCWQty = 0;

        if (WHSInventoryTransactionConfigurationProvider::isWarehouseInventoryTransactionStackEnabled())
        {
            WHSInventoryTransactionReservationDescriptorEnumerator enumerator = WHSInventoryTransactionReservationQuery::construct()
                .setInventoryTransactionReferenceCategory(WHSInventoryTransactionReferenceCategoryEnum::Work)
                .setAllowBlankDimensions(WHSInventoryTransactionReservationQuery::inventDimParmToMimicWHSInventDimExistsJoin())
                .setBlankDimensionsInQueryWorkAsWildcards(false)
                .findReservations(
                    _itemId,
                    WHSInventoryStorageDimensions::newFromInventDim(_inventDim),
                    WHSInventoryProductTrackingDimensions::newFromInventDim(_inventDim))
                .getEnumerator();

            while (enumerator.moveNext())
            {
                WHSInventoryQuantityPair reservationQuantity = enumerator.current().getInventoryFormatQuantity();

                // The quantities here are always positive.
                // We use substraction since method is expected to return a negative number.
                pdsCWQty -= reservationQuantity.parmCwInventQty();
                inventQty -= reservationQuantity.parmInventQty();
            }
        }

        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;
        InventDim           inventDim;

        select sum(Qty), sum(PdsCWQty) from inventTrans
            where inventTrans.ItemId         == _itemId
                && inventTrans.StatusIssue   == StatusIssue::ReservPhysical
                && inventTrans.StatusReceipt == StatusReceipt::None
            exists join inventTransOrigin
                where inventTransOrigin.RecId               == inventTrans.InventTransOrigin
                    && inventTransOrigin.ReferenceCategory  == InventTransType::WHSWork
            #WHSInventDimExistsJoin(inventTrans.inventdimId, inventDim, _inventDim);

        // The quantities here are always negative.
        // We use addition since method is expected to return a negative number.
        inventQty += inventTrans.Qty;
        pdsCWQty += inventTrans.PdsCWQty;

        return WhsItemQty::newFromAllUnits(_itemId, inventQty, pdsCWQty, 0, '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildTmpTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Populates the <c>WHSTmpStatusChange</c> temporary table.
    /// </summary>
    protected void buildTmpTable()
    {
        InventDim           inventDim;
        InventSum           inventSum;
        InventQty           availQty;
        PdsCWInventQty      cwAvailQty;
        WHSLocationProfile  locProfile;        

        using (var inventStatusConvertActivityContext = logger.inventStatusConvertActivities().inventStatusConvertBuildTmpTable())
        {
            Counter tmpStatusChangeRecords;
            boolean isMustAddInventSumDeltaOnhandFlightEnabled = WHSInventoryStatusConvertMustAddInventSumDeltaOnhandFlight::instance().isEnabled();
            boolean includeDeltaRecords;

            List dimList = InventDim::dimEnabledFieldList();
            boolean shouldUseDenormalizedInventSum = this.shouldUseDenormalizedInventSum();

            while (queryRun.next())
            {
                inventSum   = queryRun.get(tableNum(InventSum));

                if (shouldUseDenormalizedInventSum)
                {
                    inventDim.clear();
                    inventDim.initFromInventSum(inventSum, dimList);
                    inventDim.inventDimId = inventSum.InventDimId;
                }
                else
                {
                    inventDim   = queryRun.get(tableNum(InventDim));
                }

                availQty    = 0;
                locProfile  = WHSLocationProfile::find(inventDim.wmsLocation().LocProfileId);

                // Don't try to convert if we hit records that are not eligible.
                if (!this.isQueryDataSourcesEligible(inventDim, inventSum, locProfile.LPControlled))
                {
                    continue;
                }

                includeDeltaRecords = isMustAddInventSumDeltaOnhandFlightEnabled ? InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(inventSum.ItemId) : true;
                
                boolean isCWItem;
                if (WHSCatchWeightConfigurationKeyManager::instance().isEnabled())
                {
                    isCWItem = PdsGlobal::pdsIsCWItem(inventSum.ItemId);
                }

                // If the inventory status is blocking, get the available physical quantity at location level.
                // There should be no way to reserve between status level and location level without affecting the above levels.
                if (WHSInventStatus::isBlockingStatus(inventDim.InventStatusId))
                {
                    availQty = WHSInventOnHand::getWorkPhysicalAvail(inventSum.ItemId, inventDim.InventDimId, false);

                    if (isCWItem)
                    {
                        cwAvailQty = WHSInventOnHand::getWorkPhysicalAvailHandlingQty(inventSum.ItemId, inventDim.inventDimId, false);
                    }
                }
                // If we allow to remove reservations then we will try to change status for the entire physical inventory.
                else if (InventLocation::find(inventDim.InventLocationId).AllowMarkingReservationRemoval >= WHSAllowMarkingReservationRemoval::Reservation)
                {
                    availQty = inventSum.PhysicalInvent;
                    cwAvailQty = inventSum.PdsCWPhysicalInvent;

                    // Exclude quantities reserved for work because they cannot be unreserved
                    if (!locProfile.AllowMixedStatus)
                    {
                        WhsItemQty qtyReservedForWork = this.getQtyReservedForWork(inventSum.ItemId, inventDim);
 
                        // Note: getQtyReservedForWork returns negative quantities
                        availQty += qtyReservedForWork.qtyInInventUnit();

                        if (isCWItem)
                        {
                            cwAvailQty += qtyReservedForWork.qtyInCWUnit();
                        }
                    }
                }
                else
                {
                    // If the item allows negative we may be changing status for a positive qty on a location that is affected by a negative quantities that bubble up to higher levels
                    // Therefore we check the available on the exact dimensions
                    if (!inventBlockingComplete
                        && InventTable::find(inventSum.ItemId).whsAllowPhysNeg())
                    {
                        //get avail on location and below
                        availQty = WHSInventOnHand::getWorkPhysicalAvail(inventSum.ItemId, inventDim.inventDimId, false);

                        if (availQty > 0)
                        {
                            if (isCWItem)
                            {
                                cwAvailQty = WHSInventOnHand::getWorkPhysicalAvailHandlingQty(inventSum.ItemId, inventDim.inventDimId, false);
                            }
                        }
                    }
                    else
                    {
                        availQty = WHSInventOnHand::getPhysicalAvailQty(inventSum.ItemId, inventDim, includeDeltaRecords);

                        if (isCWItem)
                        {
                            cwAvailQty = WHSInventOnHand::getPhysicalAvailHandlingQty(inventSum.ItemId, inventDim, includeDeltaRecords, false);
                        }
                    }
                }

                if (inventSum.PhysicalInvent > availQty)                    
                {
                    boolean isPhysicalInventNonnegative = includeDeltaRecords ? InventSumDelta::findSumDeltaDimId(inventSum.ItemId, inventSum.InventDimId).PhysicalInvent >= 0 : true;

                    if (isPhysicalInventNonnegative)
                    {
                        if (!locProfile.AllowMixedStatus
                        || inventBlockingComplete)
                        {
                            if ((!locProfile //if there is not a profile the warehouse is non-whs
                            || locProfile.AllowNegative)
                            && InventTable::find(inventSum.ItemId).whsAllowPhysNeg()
                            && this.negativeAvailablePhysicalQuantityExists(inventSum.ItemId))
                            {
                                errorLog += strFmt("@WAX:InventStatusNegativeQuantityNonLicensePlateError_Label", inventSum.ItemId);
                                continue;
                            }
                            else
                            {
                                // Can't create mix status in this location.
                                // Can't block the partial order line quantity.
                                errorLog += strFmt("@WAX3900", inventSum.ItemId, inventDim.wmsLocationId);
                                continue;
                            }
                        }

                        if (inventDim.LicensePlateId)
                        {
                            // Can't split lp status
                            errorLog += strFmt("@WAX3899", inventSum.ItemId, inventDim.LicensePlateId);
                            continue;
                        }
                        else if (!this.isNonLicensePlateLocationSupported())
                        {
                            errorLog += strFmt("@WAX3900", inventSum.ItemId, inventDim.wmsLocationId);
                            continue;
                        }
                    }                    
                }

                if (availQty > 0)
                {
                    // Create Quarantine work to change the status of inventory.
                    tmpStatusChange.clear();
                    tmpStatusChange.InventDimId = inventDim.InventDimId;
                    tmpStatusChange.ItemId = inventSum.ItemId;
                    tmpStatusChange.InventQty = availQty;

                    tmpStatusChange.InventLocationId = inventDim.InventLocationId;
                    tmpStatusChange.WMSLocationId = inventDim.wMSLocationId;

                    // For catch weight items, continue to store inventory quantity in the InventQty field as subsequent logic assumes that.
                    // Later when the actual quarantine order is created, the catch weight quantity will be used as the handling quantity.
                    if (isCWItem)
                    {
                        tmpStatusChange.PdsCWInventQty = cwAvailQty;
                    }

                    tmpStatusChange.insert();

                    tmpStatusChangeRecords++;
                }
            }

            logger.inventStatusConvertActivities().parmInventStatusTmpStatusChangeRecordsCount(inventStatusConvertActivityContext, tmpStatusChangeRecords);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNonLicensePlateLocationSupported</Name>
				<Source><![CDATA[
    protected boolean isNonLicensePlateLocationSupported()
    {
        return !WHSInventoryStatusConvertNonLPLocThrowErrorV3Flight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    public boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>negativeAvailablePhysicalQuantityExists</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the negative unclosed quantity exists for the item number.
    /// </summary>
    /// <param name="_itemId">
    ///     The item number to check.
    /// </param>
    /// <returns>
    ///     true if negative qty exists and false if no.
    /// </returns>
    private boolean negativeAvailablePhysicalQuantityExists(ItemId _itemId)
    {
        InventSum inventSumLocal;
        
        select firstonly RecId from inventSumLocal
            where inventSumLocal.ItemId         ==  _itemId
               && inventSumLocal.ClosedQty      ==  NoYes::No
               && inventSumLocal.AvailPhysical  <   0;

        return inventSumLocal.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMixStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the mix status for locations and license plates.
    /// </summary>
    protected void checkMixStatus()
    {
        InventDim           joinDim;
        InventQty           runningQty;
        WMSLocation         prevLocation;
        WHSLicensePlateId   prevLP;
        List                deleteList = new List(Types::Record);

        using (var inventStatusConvertActivityContext = logger.inventStatusConvertActivities().inventStatusConvertCheckMixStatus())
        {
            ttsbegin;

            // Sum up total amount being converted for each location and make sure if the location doesn't allow mix status that it converts the entire location
            while select tmpStatusChange
                order by joinDim.InventSiteId, joinDim.InventLocationId, joinDim.InventStatusId, joinDim.wmsLocationId
                join joinDim
                where joinDim.InventDimId == tmpStatusChange.InventDimId
            {
                if (prevLocation.RecId != joinDim.wmsLocation().RecId)
                {
                    if (this.addLocToDeleteList(prevLocation, runningQty))
                    {
                        deleteList.addEnd(prevLocation);
                    }

                    prevLocation = joinDim.wmsLocation();
                    runningQty = 0;
                }

                runningQty += tmpStatusChange.InventQty;
            }

            if (this.addLocToDeleteList(prevLocation, runningQty))
            {
                deleteList.addEnd(prevLocation);
            }

            // Delete temporary records for any locations that did not fully convert and do not allow mix status.
            this.deleteLocTmpRecords(deleteList);

            //Reset variables
            runningQty = 0;
            deleteList = new List(Types::String);
            prevInventDim = null;
            prevItemId = '';

            // Sum up total qty converted for an LP and make sure it fully converted
            while select tmpStatusChange
                order by joinDim.InventSiteId, joinDim.InventLocationId, joinDim.InventStatusId, joinDim.wmsLocationId, joinDim.LicensePlateId
                join joinDim
                where joinDim.InventDimId == tmpStatusChange.InventDimId
                    && joinDim.LicensePlateId
            {
                if (prevLP != joinDim.LicensePlateId
                    || (prevInventDim.RecId != joinDim.RecId)
                    || (prevItemId != tmpStatusChange.ItemId))
                {
                    if (this.addLPToDeleteList(prevLP, runningQty))
                    {
                        deleteList.addEnd(prevLP);
                    }

                    prevLP = joinDim.LicensePlateId;
                    prevInventDim.data(joinDim);
                    prevItemId = tmpStatusChange.ItemId;

                    runningQty = 0;
                }

                runningQty += tmpStatusChange.InventQty;
            }

            if (this.addLPToDeleteList(prevLP, runningQty))
            {
                deleteList.addEnd(prevLP);
            }

            // Delete temporary records associated to LPs that did not fully convert.
            this.deleteLPTmpRecords(deleteList);

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLocTmpRecords</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Deletes temporary records for any locations that did not fully convert and do not allow mix status.
    /// </summary>
    /// <param name="_deleteList">
    ///     The list of locations for which to delete records.
    /// </param>
    protected void deleteLocTmpRecords(List _deleteList)
    {
        ListEnumerator  listEnum;
        WMSLocation     curLoc;
        InventDim       inventDim;

        ttsbegin;

        listEnum = _deleteList.getEnumerator();

        // Delete tmp records for any locations that didn't fully convert and don't allow mix status.
        while (listEnum.moveNext())
        {
            curLoc = listEnum.current();

            errorLog += strFmt("@WAX3912", curLoc.wmsLocationId);

            delete_from tmpStatusChange
                exists join inventDim
                where inventDim.InventDimId         == tmpStatusChange.InventDimId
                    && inventDim.wmsLocationId      == curLoc.wmsLocationId
                    && inventDim.InventLocationId   == curLoc.InventLocationId;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLPTmpRecords</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Delete temporary records associated to LPs that did not fully convert.
    /// </summary>
    /// <param name="_deleteList">
    ///     The list of license plates for which to delete records.
    /// </param>
    protected void deleteLPTmpRecords(List _deleteList)
    {
        ListEnumerator      listEnum;
        WHSLicensePlateId   curLP;
        InventDim           inventDim;

        ttsbegin;

        listEnum = _deleteList.getEnumerator();

        while (listEnum.moveNext())
        {
            curLP = listEnum.current();

            errorLog += strFmt("@WAX3911", curLP);

            delete_from tmpStatusChange
                exists join inventDim
                where inventDim.InventDimId     == tmpStatusChange.InventDimId
                    && inventDim.LicensePlateId == curLP;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    public Object dialog()
    {
        #SysOperation
        
        DialogRunbase dialog = super();
        
        if (this.shouldShowObsoleteMessage())
        {
            dialog.addText("@WAX:WHSInventoryStatusConvertObsolete");
        }

        if (WHSCatchWeightConfigurationKeyManager::instance().isEnabled())
        {
            dialog.addText("@WAX:InventoryStatusChangeDialog_MassStatusChangeNotSupportedForTagCatchWeightItem");
        }
        
        dialogToStatus = dialog.addFieldValue(extendedTypeStr(WHSInventStatusTo), toStatus, "@WAX1313", "@WAX1314");
        dialog.allowUpdateOnSelectCtrl(true);
        
        dialog.addGroup("@SYS866");
        dialog.addText("@WAX:Warning_InventoryStatusConvertEstimateButton", 440);

        FormBuildButtonGroupControl buttonGroup = dialog.dialogForm().buildControl(#QueryToolBarButtonGroup);
        FormBuildButtonControl estimateButton = buttonGroup.addControl(FormControlType::Button, 'WHSInventoryStatusConvertEstimate');
        estimateButton.text("@WAX:EstimateButtonText");
        estimateButton.registerOverrideMethod(methodStr(FormButtonControl, clicked), methodStr(WHSInventoryStatusConvert, estimateInventoryStatus), this);
        
        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimateInventoryStatus</Name>
				<Source><![CDATA[
    private void estimateInventoryStatus(FormButtonControl _button)
    {
        using (var inventStatusConvertActivityContext = logger.inventStatusConvertActivities().inventStatusConvertEstimate())
        {                       
            this.prepareQuery();

            this.logAndCountInventSums();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetQueryRun</Name>
				<Source><![CDATA[
    private void resetQueryRun()
    {
        queryRun = new QueryRun(queryRun.query());
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareQuery</Name>
				<Source><![CDATA[
    private void prepareQuery()
    {
        if (!this.validate())
        {
            throw error("@SYS18447");
        }
        
        this.resetQueryRun();
    }

]]></Source>
			</Method>
			<Method>
				<Name>logAndCountInventSums</Name>
				<Source><![CDATA[
    private void logAndCountInventSums()
    {
        QueryRun countQueryRun = new QueryRun(queryRun.query());
        Query countQuery = countQueryRun.query();

        QueryBuildDataSource qbds = countQuery.dataSourceNo(1);
        qbds.addSelectionField(fieldNum(WHSInventEnabled, RecId), SelectionField::Count);
        
        WHSInventEnabled inventEnabled;

        if (countQueryRun.next())
        {
            inventEnabled  = countQueryRun.get(qbds.table());

            if (inventEnabled.RecId > MaxStatusChangesBeforeShowingInfoOnEstimate)
            {
                info(strFmt("@WAX:Info_ChangeInventoryStatusTextEstimate"));
            }
        }

        info(strFmt("@WAX:Info_ChangeInventoryStatusSelectedRecordsEstimate", inventEnabled.RecId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        toStatus = dialogToStatus.value();

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    public void getLast()
    {
        super();

        throwOnError = false;        

        if (InventQualityOrderValidateConvertUseDimIdV2Flight::instance().isEnabled())
        {
            conversionInventDimItemTablePhysicalName = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
        super();

        queryRun = new QueryRun(this.buildQuery());
        
        logger = WHSInstrumentationLogger::instance(classStr(WhsInventoryStatusConvert));
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, queryRun.pack(), #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQuery</Name>
				<Source><![CDATA[
    public Query parmQuery(Query _query = null)
    {
        if (!prmisDefault(_query))
        {
            queryRun = new QueryRun(_query);
        }

        return queryRun.query();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmThrowOnError</Name>
				<Source><![CDATA[
    public boolean parmThrowOnError(boolean _throwOnError = throwOnError)
    {
        throwOnError = _throwOnError;
        return throwOnError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventBlockingComplete</Name>
				<Source><![CDATA[
    public InventBlockingComplete parmInventBlockingComplete(InventBlockingComplete _inventBlockingComplete = inventBlockingComplete)
    {
        inventBlockingComplete = _inventBlockingComplete;
        return inventBlockingComplete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmToStatus</Name>
				<Source><![CDATA[
    public WHSInventStatusTo parmToStatus(WHSInventStatusTo _toStatus = toStatus)
    {
        toStatus = _toStatus;
        return toStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTmpTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates quarantine work for the records that are not converted yet.
    /// </summary>
    protected void processTmpTable()
    {
        if (WHSInventoryStatusConvertChangeTransactionScopeFlight::instance().isEnabled())
        {
            this.processTmpTableSortedByItemId();
            return;
        }

        InventDim               newDim;
        WHSLocationMixingConstraintValidator locationMixingValidator;

        using (var inventStatusConvertActivityContext = logger.inventStatusConvertActivities().inventStatusConvertProcessTmpTable())
        {
            Counter tmpStatusChangeInvStatusNoRecords;

            try
            {
                WHSWorkQuarantine       quarantineWork;
                InventDim prevDim;

                while select forupdate tmpStatusChange
                    order by tmpStatusChange.InventLocationId, tmpStatusChange.wMSLocationId
                    where tmpStatusChange.ConvertStatus == NoYes::No
                {
                    tmpStatusChangeInvStatusNoRecords++;

                    ttsbegin;

                    newDim.clear();
                    newDim.data(InventDim::find(tmpStatusChange.InventDimId));
                    newDim.InventStatusId = toStatus;
                    newDim = InventDim::findOrCreate(newDim);

                    ttscommit;

                
                    if (!prevDim)
                    {
                        ttsbegin;

                        prevDim.data(newDim);
                    }
                    else if (prevDim.wMSLocationId != newDim.wMSLocationId
                        || prevDim.InventLocationId != newDim.InventLocationId)
                    {
                        locationMixingValidator = WHSLocationMixingConstraintValidator::newFromReceiptItemDim(quarantineWork.ItemId, prevDim);

                        if (!locationMixingValidator.isStatusMixValid())
                        {
                            throw error("@WAX3389");
                        }

                        ttscommit;
                        ttsbegin;

                        prevDim.data(newDim);
                    }
       

                    quarantineWork.clear();
                    quarantineWork.setWorkId();
                    quarantineWork.ItemId = tmpStatusChange.ItemId;

                    if (PdsGlobal::pdsIsCWItem(tmpStatusChange.ItemId))
                    {
                        // Handling quantity is catch weight
                        quarantineWork.Qty = tmpStatusChange.PdsCWInventQty;
                        quarantineWork.InventQtyRemain = tmpStatusChange.PdsCWInventQty;

                        // Inventory quantity is the captured weight
                        quarantineWork.CapturedWeight = tmpStatusChange.InventQty;
                        quarantineWork.RemainingCapturedWeight = tmpStatusChange.InventQty;
                    }
                    else
                    {
                        quarantineWork.Qty = tmpStatusChange.InventQty;
                        quarantineWork.InventQtyRemain = tmpStatusChange.InventQty;
                    }

                    quarantineWork.TransDateTime = DateTimeUtil::utcNow();
                    quarantineWork.InventDimIdFrom = tmpStatusChange.InventDimId;
                    quarantineWork.InventDimIdTo = newDim.InventDimId;
                    quarantineWork.insert();

                    WHSWorkQuarantineExecutor::newWorkQuarantine(quarantineWork, quarantineWork.InventQtyRemain, true).execute();
                    tmpStatusChange.ConvertStatus = NoYes::Yes;
                    tmpStatusChange.update();
                }

                logger.inventStatusConvertActivities().parmInventStatusTmpStatusChangeInvStatusNoRecordsCount(inventStatusConvertActivityContext, tmpStatusChangeInvStatusNoRecords);

                if (quarantineWork.ItemId)
                {
                    locationMixingValidator = WHSLocationMixingConstraintValidator::newFromReceiptItemDim(quarantineWork.ItemId, prevDim);
            
                    if (!locationMixingValidator.isStatusMixValid())
                    {
                        throw error("@WAX3389");
                    }

                    ttscommit;
                }
            }
            catch (Exception::Error)
            {
                errorLog += strFmt("@WAX3916", tmpStatusChange.ItemId, InventDim::find(tmpStatusChange.InventDimId).wmsLocationId);
                exceptionTextFallThrough();
                ttsbegin;
                tmpStatusChange.delete();
                ttscommit;
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTmpTableSortedByItemId</Name>
				<Source><![CDATA[
    /// <summary>
	/// Creates quarantine work for the records that are not converted.
	/// </summary>
    private void processTmpTableSortedByItemId()
    {
        #OCCRetryCount

        WHSLocationMixingConstraintValidator locationMixingValidator;
        WMSLocationId   lastProcessedLocationId;
        WMSLocationId   lastProcessedWarehouseId;
        ItemId          lastProcessedItemId;

        void initLastProcessedVariables(WHSTmpStatusChange _tmpStatusChange)
        {
            lastProcessedItemId = _tmpStatusChange.ItemId;
            lastProcessedWarehouseId = _tmpStatusChange.InventLocationId;
            lastProcessedLocationId = _tmpStatusChange.WMSLocationId;
        }

        using (var inventStatusConvertActivityContext = logger.inventStatusConvertActivities().inventStatusConvertProcessTmpTableSortedByItemId())
        {
            Counter tmpStatusChangeNoOfRecordsProcessed;
            boolean mixedStatusValidationFailed;
            boolean commitPerItem;
            
            boolean allTmpStatusChangeRecordsProcessed;

            try
            {
                InventDim prevDim, newDim;

                while select forupdate tmpStatusChange
                    order by tmpStatusChange.InventLocationId, tmpStatusChange.WMSLocationId, tmpStatusChange.ItemId
                    where tmpStatusChange.ConvertStatus == NoYes::No
                {
                    tmpStatusChangeNoOfRecordsProcessed++;

                    newDim = this.inventDimWithToStatus(tmpStatusChange.InventDimId);
                
                    if (!prevDim)
                    {
                        ttsbegin;

                        prevDim.data(newDim);
                        initLastProcessedVariables(tmpStatusChange);
                        commitPerItem = WHSLocationProfile::find(WMSLocation::find(lastProcessedLocationId, lastProcessedWarehouseId).LocProfileId).AllowMixedStatus;
                    }
                    else if (prevDim.wMSLocationId != newDim.wMSLocationId
                            || prevDim.InventLocationId != newDim.InventLocationId)
                    {
                        locationMixingValidator = WHSLocationMixingConstraintValidator::newFromReceiptItemDim(lastProcessedItemId, prevDim);

                        if (!commitPerItem && !locationMixingValidator.isStatusMixValid())
                        {
                            mixedStatusValidationFailed = true;
                            throw error("@WAX3389");
                        }

                        this.commitAndRestartTransaction();
                        
                        prevDim.data(newDim);
                        initLastProcessedVariables(tmpStatusChange);
                        commitPerItem = WHSLocationProfile::find(WMSLocation::find(lastProcessedLocationId, lastProcessedWarehouseId).LocProfileId).AllowMixedStatus;
                    }
                    else if (tmpStatusChange.ItemId != lastProcessedItemId
                            && commitPerItem)
                    {
                        this.commitAndRestartTransaction();
                        
                        prevDim.data(newDim);
                        initLastProcessedVariables(tmpStatusChange);
                    }

                    WHSWorkQuarantine quarantineWork = this.createQuarantineWork(tmpStatusChange, newDim);
                    this.executeQuarantineWork(quarantineWork);
                    this.updateSingleTmpStatusChangeRecord(tmpStatusChange);
                }

                logger.inventStatusConvertActivities().parmTmpStatusChangeNoOfRecordsProcessed(inventStatusConvertActivityContext, tmpStatusChangeNoOfRecordsProcessed);

                if (lastProcessedItemId)
                {
                    allTmpStatusChangeRecordsProcessed = true;
                    locationMixingValidator = WHSLocationMixingConstraintValidator::newFromReceiptItemDim(lastProcessedItemId, prevDim);

                    if (!commitPerItem && !locationMixingValidator.isStatusMixValid())
                    {
                        mixedStatusValidationFailed = true;
                        throw error("@WAX3389");
                    }

                    ttscommit;
                }
            }
            catch (Exception::Error)
            {
                exceptionTextFallThrough();

                if (mixedStatusValidationFailed)
                {
                    mixedStatusValidationFailed = false;
                    errorLog += strFmt("@WAX:WHSInventoryStatusChangeLocationFailure", lastProcessedLocationId);
                }
                else
                {
                    errorLog += strFmt("@WAX3916", lastProcessedItemId, lastProcessedLocationId);

                    if (!commitPerItem)
                    {
                        errorLog += strFmt("@WAX:WHSInventoryStatusChangeLocationFailure", lastProcessedLocationId);
                    }
                }

                this.updateTmpStatusChange(tmpStatusChange, commitPerItem);
                lastProcessedLocationId = '';
                lastProcessedWarehouseId = '';
                lastProcessedItemId = '';

                if (!allTmpStatusChangeRecordsProcessed 
                    && xSession::currentRetryCount() <= #RetryNum)
                {
                    retry;
                }

                if (!allTmpStatusChangeRecordsProcessed)
                {
                    logger.inventStatusConvertActivities().maxNumberOfRetry(inventStatusConvertActivityContext, true);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeQuarantineWork</Name>
				<Source><![CDATA[
    private void executeQuarantineWork(WHSWorkQuarantine _quarantineWork)
    {
        WHSWorkQuarantineExecutor::newWorkQuarantine(_quarantineWork, _quarantineWork.InventQtyRemain, true).execute();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimWithToStatus</Name>
				<Source><![CDATA[
    private InventDim inventDimWithToStatus(InventDimId _inventDimId)
    {
        InventDim newDim;

        ttsbegin;
        newDim = InventDim::find(_inventDimId);
        newDim.InventStatusId = toStatus;
        newDim = InventDim::findOrCreate(newDim);
        ttscommit;

        return newDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>commitAndRestartTransaction</Name>
				<Source><![CDATA[
    private void commitAndRestartTransaction()
    {
        ttscommit;
        ttsbegin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSingleTmpStatusChangeRecord</Name>
				<Source><![CDATA[
    private void updateSingleTmpStatusChangeRecord(WHSTmpStatusChange _tmpStatusChange)
    {
        _tmpStatusChange.ConvertStatus = NoYes::Yes;
        _tmpStatusChange.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTmpStatusChange</Name>
				<Source><![CDATA[
    private void updateTmpStatusChange(WHSTmpStatusChange _tmpStatusChange, boolean _commitPerItem)
    {
        if (_commitPerItem)
        {
            this.updateTmpStatusChangePerItem(_tmpStatusChange);
        }
        else
        {
            this.updateTmpStatusChangePerLocation(_tmpStatusChange);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTmpStatusChangePerLocation</Name>
				<Source><![CDATA[
    private void updateTmpStatusChangePerLocation(WHSTmpStatusChange _tmpStatusChange)
    {
        ttsbegin;
        
        InventLocationId _warehouseId = _tmpStatusChange.InventLocationId;
        WMSLocationId _locationId = _tmpStatusChange.WMSLocationId;

        update_recordset _tmpStatusChange
            setting 
                ConvertStatus = NoYes::Yes
            where 
                _tmpStatusChange.InventLocationId == _warehouseId
                && _tmpStatusChange.WMSLocationId == _locationId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTmpStatusChangePerItem</Name>
				<Source><![CDATA[
    private void updateTmpStatusChangePerItem(WHSTmpStatusChange _tmpStatusChange)
    {
        ttsbegin;

        InventLocationId warehouseId = _tmpStatusChange.InventLocationId;
        WMSLocationId locationId = _tmpStatusChange.WMSLocationId;
        ItemId itemId = _tmpStatusChange.ItemId;
        
        update_recordset _tmpStatusChange
            setting
                ConvertStatus = NoYes::Yes
            where
                _tmpStatusChange.InventLocationId == warehouseId
                && _tmpStatusChange.WMSLocationId == locationId
                && _tmpStatusChange.ItemId == itemId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQuarantineWork</Name>
				<Source><![CDATA[
    private WHSWorkQuarantine createQuarantineWork(WHSTmpStatusChange _tmpStatusChange, InventDim _toInventDim)
    {
        WHSWorkQuarantine quarantineWork;

        quarantineWork.setWorkId();
        quarantineWork.ItemId = _tmpStatusChange.ItemId;

        if (PdsGlobal::pdsIsCWItem(_tmpStatusChange.ItemId))
        {
            // Handling quantity is catch weight
            quarantineWork.Qty = _tmpStatusChange.PdsCWInventQty;
            quarantineWork.InventQtyRemain = _tmpStatusChange.PdsCWInventQty;

            // Inventory quantity is the captured weight
            quarantineWork.CapturedWeight = _tmpStatusChange.InventQty;
            quarantineWork.RemainingCapturedWeight = _tmpStatusChange.InventQty;
        }
        else
        {
            quarantineWork.Qty = _tmpStatusChange.InventQty;
            quarantineWork.InventQtyRemain = _tmpStatusChange.InventQty;
        }

        quarantineWork.TransDateTime = DateTimeUtil::utcNow();
        quarantineWork.InventDimIdFrom = _tmpStatusChange.InventDimId;
        quarantineWork.InventDimIdTo = _toInventDim.InventDimId;
        quarantineWork.insert();

        return quarantineWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContextBatchServer(this))
        {
            QueryBuildRange     qbr;
            int                 i;

            if (!toStatus)
            {
                throw error("@WAX3893");
            }
        
            // Add Range to exclude the status you are converting to.
            if (this.shouldUseDenormalizedInventSum())
            {
                qbr = SysQuery::findOrCreateRange(queryRun.query().dataSourceTable(tableNum(InventSum)), fieldNum(InventSum, InventStatusId));
            }
            else
            {
                qbr = SysQuery::findOrCreateRange(queryRun.query().dataSourceTable(tableNum(InventDim)), fieldNum(InventDim, InventStatusId));
            }
            qbr.value(qbr.value() + ',' + SysQuery::valueNot(toStatus));

            this.addLinkBetweenInventBatchAndInventTable();
            this.adjustQueryBasedOnFeatureSelection();
        
            this.rebuildQueryBasedOnConversionTable();

            this.buildTmpTable();
            this.checkMixStatus();

            using (var explicitLocationFilterContext = WHSInventStatusChangeExplicitLocationFilterContext::newFromParameter(true))
            {
                this.processTmpTable();
            }

            if (conLen(errorLog) > 0)
            {
                for (i = 1; i <= conLen(errorLog); ++i)
                {
                    info(conPeek(errorLog, i));
                }

                if (throwOnError)
                {
                    throw error("@SYS4110684");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLinkBetweenInventBatchAndInventTable</Name>
				<Source><![CDATA[
    private void addLinkBetweenInventBatchAndInventTable()
    {
        QueryBuildDataSource inventBatchDS = queryRun.query().dataSourceTable(tableNum(InventBatch));
        QueryBuildDataSource inventTableDS = queryRun.query().dataSourceTable(tableNum(InventTable));

        if (inventBatchDS && inventTableDS)
        {
            inventBatchDS.addLink(fieldNum(InventTable, ItemId), fieldNum(InventBatch, itemId), inventTableDS.name());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustQueryBasedOnFeatureSelection</Name>
				<Source><![CDATA[
    private void adjustQueryBasedOnFeatureSelection()
    {
        QueryBuildDataSource dsCatchWeightItem = queryRun.query().dataSourceTable(tableNum(PdsCatchWeightItem));

        // Only update the query if it is the standard query that has a not exist join on PdsCatchWeightItem
        if (!dsCatchWeightItem || dsCatchWeightItem.joinMode() != JoinMode::NoExistsJoin)
        {
            return;
        }
        boolean shouldUseDenormalizedInventSum = this.shouldUseDenormalizedInventSum();

        QueryBuildDataSource dsWHSInventTable2 = shouldUseDenormalizedInventSum ?
            queryRun.query().dataSourceName(queryDatasourceStr(WHSInventStatusChangeDenormInventSum, WHSInventTable2)) :
            queryRun.query().dataSourceName(queryDatasourceStr(WHSInventStatusChange, WHSInventTable2));

        if (WHSCatchWeightConfigurationKeyManager::instance().isEnabled())
        {
            // An older version of the query that had been saved that doesn't have the data sources yet to limit the no-exist join to just Tagged catch weight items
            if (!dsWHSInventTable2)
            {
                dsWHSInventTable2 = shouldUseDenormalizedInventSum ?
                    dsCatchWeightItem.addDataSource(tableNum(WHSInventTable), queryDatasourceStr(WHSInventStatusChangeDenormInventSum, WHSInventTable2)) :
                    dsCatchWeightItem.addDataSource(tableNum(WHSInventTable), queryDatasourceStr(WHSInventStatusChange, WHSInventTable2));

                // Copy the data sources for WHSInventTable2 and below from the metadata query to the current query
                if (shouldUseDenormalizedInventSum)
                {
                    SysQuery::copyDataSource(this.buildQuery().dataSourceName(queryDatasourceStr(WHSInventStatusChangeDenormInventSum, WHSInventTable2)), dsWHSInventTable2, true);
                }
                else
                {
                    SysQuery::copyDataSource(this.buildQuery().dataSourceName(queryDatasourceStr(WHSInventStatusChange, WHSInventTable2)), dsWHSInventTable2, true);
                }
            }

            // Limit filter of tag tracked CW items to those that for which only inventory status storage dimension is tracked
            QueryBuildDataSource dsWHSCatchWeightItemHandlingPolicy = shouldUseDenormalizedInventSum ?
                queryRun.query().dataSourceName(queryDatasourceStr(WHSInventStatusChangeDenormInventSum, WHSCatchWeightItemHandlingPolicy)) :
                queryRun.query().dataSourceName(queryDatasourceStr(WHSInventStatusChange, WHSCatchWeightItemHandlingPolicy));

            SysQuery::findOrCreateRange(dsWHSCatchWeightItemHandlingPolicy, fieldNum(WHSCatchWeightItemHandlingPolicy, CatchWeightTagDimensionTrackingMethod)).value(queryValue(WHSCatchWeightTagDimensionTrackingMethod::ProductTrackingAndInventoryStatus));

            dsWHSInventTable2.enabled(true);
        }
        else if (dsWHSInventTable2)
        {
            dsWHSInventTable2.enabled(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQuerySelectButton</Name>
				<Source><![CDATA[
    /// <summary>
	/// Determines whether to show query select button or not.
	/// </summary>
	/// <returns>
	/// True if to show query select button.
	/// </returns>
    boolean showQuerySelectButton()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version     version = RunBase::getVersion(_packedClass);
        boolean     ret = true;
        container   packedQuery;

        switch (version)
        {
            case #CurrentVersion:
                [version, packedQuery, #CurrentList] = _packedClass;                
                break;
            case 12:
                [version, packedQuery, #CurrentList12] = _packedClass;
                break;
            case 11:
                [version, packedQuery, #CurrentList11] = _packedClass;                
                break;

            default:
                ret = false;
        }

        if (ret)
        {
            ret = this.checkPackedQuery(packedQuery);
        }
        
        return ret;        
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPackedQuery</Name>
				<Source><![CDATA[
    private boolean checkPackedQuery(container _packedQuery)
    {
        boolean ret;
        if (!_packedQuery)
        {
            ret = false;
        }
        else
        {
            ret = true;
            queryRun = new QueryRun(_packedQuery);
        }
        return ret;      
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static WHSInventoryStatusConvert construct()
    {
        if (WHSInventoryStatusConvertDontUseDenormalizedInventSumContext::isActive()
            || !WHSInventoryStatusConvertUseDenormalizedInventSumFlight::instance().isEnabled())
        {
            return new WHSInventoryStatusConvert();
        }

        return WhsInventoryStatusConvertDenormalizedInventSum::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static ClassDescription description()
    {
        return "@WAX3891";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    [SysObsolete("This method is deprecated in favor of another class 'WhsInventoryStatusConvertDenormalizedInventSum'.", false, 13\03\2024)]
    static void main(Args args)
    {
        WHSInventoryStatusConvert inventoryStatusConvert;

        using (var context = WHSInventoryStatusConvertDontUseDenormalizedInventSumContext::construct())
        {
            inventoryStatusConvert = WHSInventoryStatusConvert::construct();
        }

        using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContextBatchController(inventoryStatusConvert))
        {
            if (inventoryStatusConvert.prompt())
            {
                inventoryStatusConvert.runOperation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showIndexFields</Name>
				<Source><![CDATA[
    public boolean showIndexFields(TableId _id)
    {
        boolean ret;
    
        switch (_id)
        {
            case tableNum(PdsCatchWeightItem):
                ret = false;
                break;

            default:
                ret = super(_id);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveInventDimParmForQuarantine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves inventory dimensions criteria for inventory status update by active inventory dimensions.
    /// </summary>
    /// <param name = "_inventDim">Active inventory dimensions.</param>
    /// <returns>Inventory dimensions criteria for inventory status update.</returns>
    private InventDimParm retrieveInventDimParmForQuarantine(InventDim _inventDim)
    {
        InventDimParm inventDimParmCriteria;

        inventDimParmCriteria.initFromInventDim(_inventDim);
        inventDimParmCriteria.InventStatusFlag = NoYes::No;

        return inventDimParmCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmConversionInventDimItemTablePhysicalName</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public TableName parmConversionInventDimItemTablePhysicalName(TableName _conversionInventDimItemTablePhysicalName = conversionInventDimItemTablePhysicalName)
    {
        conversionInventDimItemTablePhysicalName = _conversionInventDimItemTablePhysicalName;

        return conversionInventDimItemTablePhysicalName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rebuildQueryBasedOnConversionTable</Name>
				<Source><![CDATA[
    private void rebuildQueryBasedOnConversionTable()
    {
        if (!conversionInventDimItemTablePhysicalName || !InventQualityOrderValidateConvertUseDimIdV2Flight::instance().isEnabled())
        {
            return;
        }

        InventDimItemTmp conversionInventDimItemTable;
        conversionInventDimItemTable.useExistingTempDBTable(conversionInventDimItemTablePhysicalName);
        conversionInventDimItemTable.takeOwnershipOfTempDBTable(false); // attach the table back to the pool manager to dispose of it after the session is done

        Query conversionTableQuery = new Query();
        
        QueryBuildDataSource qbdsConversionTable = conversionTableQuery.addDataSource(tableNum(InventDimItemTmp));

        QueryBuildDataSource qbdsInventSum = qbdsConversionTable.addDataSource(tableNum(InventSum));
        qbdsInventSum.joinMode(JoinMode::InnerJoin);
        qbdsInventSum.relations(false);
        qbdsInventSum.addLink(fieldNum(InventDimItemTmp, ItemId), fieldNum(InventSum, ItemId));
        qbdsInventSum.addLink(fieldNum(InventDimItemTmp, InventDimId), fieldNum(InventSum, InventDimId));        
       
        if (!this.shouldUseDenormalizedInventSum())
        {
            QueryBuildDataSource qbdsinventDim = qbdsInventSum.addDataSource(tableNum(InventDim));
            qbdsinventDim.joinMode(JoinMode::InnerJoin);
            qbdsInventDim.relations(true);
        }
        
        conversionTableQuery.forceSelectOrder(true);
        conversionTableQuery.forceNestedLoop(true);

        queryRun = new QueryRun(conversionTableQuery);
        queryRun.setRecord(conversionInventDimItemTable);        
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorMessageHelpScopeFormName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the form name used for the error context using a <c>SysErrorMessageHelpScope</c> class.
    /// </summary>
    /// <returns>The form name used for the error context.</returns>
    [Hookable(false)]
    public FormName errorMessageHelpScopeFormName()
    {
        return strFmt('%1_%2', formStr(Dialog), classStr(WhsInventoryStatusConvert));
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorMessageHelpScopeActionName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the action name used for the error context using a <c>SysErrorMessageHelpScope</c> class.
    /// </summary>
    /// <returns>The action name used for the error context.</returns>
    [Hookable(false)]
    public str errorMessageHelpScopeActionName()
    {
        return menuItemActionStr(WHSInventoryStatusConvert);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUseDenormalizedInventSum</Name>
				<Source><![CDATA[
    internal boolean shouldUseDenormalizedInventSum()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldShowObsoleteMessage</Name>
				<Source><![CDATA[
    internal boolean shouldShowObsoleteMessage()
    {
        return WHSInventoryStatusConvertUseDenormalizedInventSumFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>