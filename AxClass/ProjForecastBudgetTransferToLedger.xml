<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjForecastBudgetTransferToLedger</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ProjForecastBudgetTransferToLedger extends ProjForecastBudget implements BatchRetryable
{
    boolean         includeProfitAndloss;
    boolean         includeWIP;
    boolean         payrollAllocation;
    boolean         deleteExistingTrans;
    boolean         salesCurrency;

    ForecastModelId     fromForecastModel;
    BudgetModelHeadId   toForecastModel;

    DialogField dialogFromForecastModel;
    DialogField dialogToForecastModel;
    DialogField dialogProfitAndLoss;
    DialogField dialogWIP;
    DialogField dialogPayrollallocation;
    DialogField dialogDeleteExistingTrans;
    DialogField dialogTransferSalesCurrency;

    CurrencyCode    tmpCurrencyCode;
    AmountCur       tmpTransactionCurrencyAmount;
    real            tmpQuantity;
    PriceCur        tmpPrice;

    TransDate       budgetTransactionHeaderDate;

    BudgetTransactionCode           budgetTransactionCode;
    BudgetTransactionHeader         budgetTransactionHeader;
    BudgetTransactionReverseManager transactionReverseManager;
    Query                           transactionReverseQuery;
    QueryBuildRange                 transReverseTransactionStatuRange;
    QueryBuildRange                 transReverseProjTransIdRange;
    int                             numOfBudgetTransactionLines;
    NoYes                           isBudgetTransStatusCompleted;
    BudgetTransactionManager        budgetTransactionManager;
    BudgetTransactionPost           budgetTransactionPost;

    #define.CurrentVersion(3)

    #localmacro.CurrentList
        projectFromDate,
        projectToDate,
        ledgerFromDate,
        ledgerToDate,
        fromForecastModel,
        toForecastModel,
        includeProfitAndloss,
        includeWIP,
        payrollAllocation,
        deleteExistingTrans,
        salesCurrency
     #endmacro
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addBudgetTransactionLinesToReverse</Name>
				<Source><![CDATA[
    /// <summary>
///    Adds the record IDs in the <c>BudgetTransactionLine</c> table that are associated with the
///    <c>ProjTransBudget</c> record to the set of record IDs in the <c>BudgetTransactionLine</c> table to
///    reverse.
/// </summary>
/// <param name="_projTransBudget">
///    The <c>ProjTransBudget</c> table record from which to retrieve the associated record IDs in the
///    <c>BudgetTransactionLine</c> table to reverse.
/// </param>
protected void addBudgetTransactionLinesToReverse(ProjTransBudget _projTransBudget)
{
    QueryRun transactionReverseQueryRun;
    BudgetTransactionLine transLineProjTransBudget;

    if (transactionReverseQuery == null)
    {
        // Initialize the budget transaction reverse query.
        this.initBudgetTransactionLinesToReverseQuery();
    }

    // Set the ProjTransBudget restriction for the query.
    transReverseProjTransIdRange.value(SysQuery::value(_projTransBudget.TransId));

    // Set the BudgetTransactionStatus restriction for the query to completed.
    transReverseTransactionStatuRange.value(int2str(enum2int(BudgetTransactionStatus::Completed)));

    transactionReverseQueryRun = new QueryRun(transactionReverseQuery);

    while (transactionReverseQueryRun.next())
    {
        transLineProjTransBudget = transactionReverseQueryRun.get(tableNum(BudgetTransactionLine)) as BudgetTransactionLine;

        transactionReverseManager.addTransactionLineToReverse(transLineProjTransBudget.RecId);
    }
}

]]></Source>
			</Method>
			<Method>
				<Name>confirmDraftBudgetTransNoReverse</Name>
				<Source><![CDATA[
    /// <summary>
///    Confirms that the previously transferred draft budget transactions will not be reversed.
/// </summary>
/// <returns>
///    true if the transactions will not be reversed; otherwise, false.
/// </returns>
/// <remarks>
///    The prompt for confirmation is only made when the option to delete the previously transferred
///    budget has been selected.
/// </remarks>
protected boolean confirmDraftBudgetTransNoReverse()
{
    boolean ok = true;
    ProjTransBudget projTransBudget;
    QueryRun projTransBudgetQueryRun;
    QueryRun transactionReverseQueryRun;

    if (deleteExistingTrans == true)
    {
        // Check if previously transferred draft budget transactions exist.
        this.initQuery();

        projTransBudgetQueryRun = new QueryRun(queryRun.query());

        while (projTransBudgetQueryRun.next())
        {
            projTransBudget = projTransBudgetQueryRun.get(tableNum(ProjTransBudget)) as ProjTransBudget;

            if (transactionReverseQuery == null)
            {
                // Initialize the budget transaction reverse query.
                this.initBudgetTransactionLinesToReverseQuery();

                // Set the BudgetTransactionStatus restriction for the query to draft.
                transReverseTransactionStatuRange.value(int2str(enum2int(BudgetTransactionStatus::Draft)));
            }

            // Set the ProjTransBudget restriction for the query.
            transReverseProjTransIdRange.value(SysQuery::value(projTransBudget.TransId));

            transactionReverseQueryRun = new QueryRun(transactionReverseQuery);

            if (transactionReverseQueryRun.next())
            {
                // Confirm that the draft budget transactions will not be reversed.
                if (Box::yesNo(strFmt("@SYS132977", BudgetTransactionType::Project), DialogButton::Yes) == DialogButton::No)
                {
                    ok = false;
                }

                break;
            }
        }
    }

    return ok;
}

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetTransactionHeader</Name>
				<Source><![CDATA[
    /// <summary>
///    Creates the <c>BudgetTransactionHeader</c> record.
/// </summary>
/// <exception cref="M:Exception::Error">
///    There was an error during the creation process and it was not completed.
/// </exception>
protected void createBudgetTransactionHeader()
{
    NumberSeq numberSeq;

    ttsbegin;

    budgetTransactionHeader.clear();
    budgetTransactionHeader.initValue();

    if (budgetTransactionHeaderDate)
    {
        budgetTransactionHeader.Date = budgetTransactionHeaderDate;
    }

    if (BudgetTransactionManager::checkBudgetTransactionNumberSequence() == true)
    {
        // The number sequence for budget transactions is valid.
        // Get the next number in the sequence for the transfer.
        numberSeq = NumberSeq::newGetNum(BudgetParameters::numRefBudgetTransactionId());

        budgetTransactionHeader.TransactionNumber = numberSeq.num();

        budgetTransactionHeader.setBudgetTransactionCode(budgetTransactionCode.RecId);

        budgetTransactionHeader.editBudgetModel(true, toForecastModel);

        if (budgetTransactionHeader.validateWrite() == true)
        {
            budgetTransactionHeader.write();

            if (isBudgetTransStatusCompleted == NoYes::Yes)
            {
                // Option to create transferred budget as completed transactions is marked
                budgetTransactionPost = BudgetTransactionPost::construct(budgetTransactionHeader.TransactionNumber);
            }
        }
        else
        {
            // The budget transaction header must be created to complete the transfer.
            throw error("@SYS131643");
        }
    }
    else
    {
        // The number sequence check failed.
        throw error("@SYS131643");
    }

    ttscommit;
}

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetTransactionLine</Name>
				<Source><![CDATA[
/// <summary>
///    Creates a record in the <c>BudgetTransactionLine</c> table.
/// </summary>
/// <param name="_projTransBudget">
///    The record in the <c>ProjTransBudget</c> table that contains the information for the new record in
///    the <c>BudgetTransactionLine</c> table.
/// </param>
/// <remarks>
///    The <c>BudgetTransactionLineProjTransBudget</c> record will also be created to associate the
///    <c>BudgetTransactionLine</c> record with the <c>ProjTransBudget</c> record that generated it.
/// </remarks>
/// <exception cref="M:Exception::Error">
///    The creation process could not be completed.
/// </exception>
protected void createBudgetTransactionLine(ProjTransBudget _projTransBudget)
{
    ttsbegin;
    BudgetTransactionLine budgetTransactionLine = this.initializeBudgetTransactionLine(_projTransBudget);

    if (budgetTransactionLine.validateWrite() &&
    BudgetTransactionManager::validateLedgerDimension(budgetTransactionLine.LedgerDimension, budgetTransactionLine.Date))
    {
        budgetTransactionLine.write();
    }
    else
    {
        // The budget transaction line must be created to complete the transfer.
        throw error("@SYS131643");
    }

    ttscommit;
}

]]></Source>
			</Method>
			<Method>
				<Name>initializeBudgetTransactionLine</Name>
				<Source><![CDATA[
/// <summary>
///		Initializes values to <c>BudgetTransactionLine</c> table.
/// </summary>
/// <param name = "_projTransBudget">
///		The record in the <c>ProjTransBudget</c> table that contains the information for the new record in
///		the <c>BudgetTransactionLine</c> table.
/// </param>
/// <returns>
///		Return <c>BudgetTransactionLine</c> table.
/// </returns>
protected BudgetTransactionLine initializeBudgetTransactionLine(ProjTransBudget _projTransBudget)
{
    BudgetTransactionLine budgetTransactionLine;
    // Increment the number of budget transaction lines and assign the value to LineNumber.
    numOfBudgetTransactionLines += 1;
    budgetTransactionLine.LineNumber = numOfBudgetTransactionLines;

    budgetTransactionLine.BudgetTransactionHeader = budgetTransactionHeader.RecId;

    // Set the budget transaction line fields based on the proj trans budget information.
    budgetTransactionLine.Date = _projTransBudget.LedgerTransDate;
    budgetTransactionLine.Comment = strFmt("@SYS132976", _projTransBudget.TransId);

    budgetTransactionLine.LedgerDimension = budgetTransactionManager.getLedgerDimensionBudget(_projTransBudget.LedgerDimension, _projTransBudget.DefaultDimension, strFmt("@SYS300282", budgetTransactionCode.BudgetTransactionType));

    // Add any dimension attributes that are not enabled for budget to the cache.
    // This cache will be used at the end of the process to warn users that some dimension attributes
    // were not transferred to budget transactions.
    budgetTransactionManager.cacheDimAttributesNotBudgetEnabled(_projTransBudget.LedgerDimension);
    budgetTransactionManager.cacheDefaultDimAttribNotBudgetEnabled(_projTransBudget.DefaultDimension);

    budgetTransactionLine.TransactionCurrency = this.parmCurrency();
    budgetTransactionLine.TransactionCurrencyAmount = this.parmTransactionCurrencyAmount();
    budgetTransactionLine.AccountingCurrencyAmount = BudgetTransactionManager::calculateTransAmountToAccountingAmount(
                                                budgetTransactionLine.TransactionCurrencyAmount,
                                                budgetTransactionLine.TransactionCurrency,
                                                budgetTransactionLine.Date);
    budgetTransactionLine.Quantity = this.parmQuantity();
    budgetTransactionLine.Price = this.parmPrice();

    if (_projTransBudget.PaymentStatus == ProjPaymentStatus::Paid)
    {
        budgetTransactionLine.IncludeInCashFlowForecast = NoYes::Yes;
    }

    if (_projTransBudget.CostSales == ProjCostSales::Sales)
    {
        budgetTransactionLine.BudgetType = BudgetType::Revenue;
    }
    else
    {
        budgetTransactionLine.BudgetType = BudgetType::Expense;
    }

    // Set the budget transaction line assocation to project transaction budget
    budgetTransactionLine.ProjTransBudgetTransId = _projTransBudget.TransId;

    return budgetTransactionLine;
}

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
/// Returns a class that contains the methods that are described by the
/// <c>RunBaseDialogable</c>interface.
/// </summary>
/// <returns>
/// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
/// </returns>
/// <remarks>
/// A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
/// created in the AOT.
/// </remarks>
public Object dialog()
{
    Dialog      dialogRunBase;

    dialogRunBase = super();

    dialogRunBase.addGroup("@SYS86808");

    dialogFromForecastModel     = dialogRunBase.addFieldValue(extendedTypeStr(ForecastModelId), fromForecastModel, "@SYS86813", "@SYS90579");
    dialogToForecastModel       = dialogRunBase.addFieldValue(extendedTypeStr(BudgetModelHeadId), toForecastModel, "@SYS86827", "@SYS90582");
    dialogDeleteExistingTrans   = dialogRunBase.addFieldValue(enumStr(boolean), deleteExistingTrans,       "@SYS27037", "@SYS90581");
    dialogTransferSalesCurrency = dialogRunBase.addFieldValue(enumStr(boolean), salesCurrency,             "@SYS106793", "@SYS106794");

    return dialogRunBase;
}

]]></Source>
			</Method>
			<Method>
				<Name>dialogGroup1</Name>
				<Source><![CDATA[
    Dialog dialogGroup1(Dialog dialogRunBase)
{
    dialogRunBase.addGroup("@SYS86829");
    dialogProfitAndLoss         = dialogRunBase.addFieldValue(extendedTypeStr(ProjProfitLoss),        includeProfitAndloss,    "@SYS3418",   "@SYS90663");
    dialogWIP                   = dialogRunBase.addFieldValue(extendedTypeStr(ProjWIP),               includeWIP,              "@SYS50076",  "@SYS90664");
    dialogPayrollallocation     = dialogRunBase.addFieldValue(extendedTypeStr(ProjPayrollAllocation), payrollAllocation,       "@SYS14982",  "@SYS90665");

    return dialogRunBase;
}

]]></Source>
			</Method>
			<Method>
				<Name>fieldIdCategoryId</Name>
				<Source><![CDATA[
    public FieldId fieldIdCategoryId()
{
    return fieldNum(ProjTransBudget, CategoryId);
}

]]></Source>
			</Method>
			<Method>
				<Name>fieldIdItemId</Name>
				<Source><![CDATA[
    protected FieldId fieldIdItemId()
{
    return fieldNum(ProjTransBudget, EmplItemId);
}

]]></Source>
			</Method>
			<Method>
				<Name>fieldIdProjId</Name>
				<Source><![CDATA[
    public FieldId fieldIdProjId()
{
    return fieldNum(ProjTransBudget, ProjId);
}

]]></Source>
			</Method>
			<Method>
				<Name>fieldIdProjTransType</Name>
				<Source><![CDATA[
    public FieldId fieldIdProjTransType()
{
    return fieldNum(ProjTransBudget, ProjTransType);
}

]]></Source>
			</Method>
			<Method>
				<Name>fieldIdResource</Name>
				<Source><![CDATA[
    protected FieldId fieldIdResource()
{
    return fieldNum(ProjTransBudget, Resource);
}

]]></Source>
			</Method>
			<Method>
				<Name>fieldIdResourceCategory</Name>
				<Source><![CDATA[
    protected FieldId fieldIdResourceCategory()
{
    return fieldNum(ProjTransBudget, ResourceCategory);
}

]]></Source>
			</Method>
			<Method>
				<Name>fieldIdTransId</Name>
				<Source><![CDATA[
    public FieldId fieldIdTransId()
{
    return fieldNum(ProjTransBudget, TransId);
}

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
{
    boolean ret;

    ret = super();

    this.parmFromForecastModel(dialogFromForecastModel.value());
    this.parmToForecastModel(dialogToForecastModel.value());

    this.parmDeleteExistingTrans(dialogDeleteExistingTrans.value());
    this.parmIncludeProfitAndloss(dialogProfitAndLoss.value());
    this.parmPayrollAllocation(dialogPayrollallocation.value());
    this.parmIncludeWIP(dialogWIP.value());

    this.parmFromForecastModel(dialogFromForecastModel.value());
    this.parmToForecastModel(dialogToForecastModel.value());

    this.parmSalesCurrency(dialogTransferSalesCurrency.value());

    return ret;
}

]]></Source>
			</Method>
			<Method>
				<Name>initBudgetTransaction</Name>
				<Source><![CDATA[
    /// <summary>
///    Initializes the budget transaction code reference and the <c>BudgetTransactionReverseManager</c>
///    class.
/// </summary>
/// <remarks>
///    The <c>BudgetTransactionReverseManager</c> class is only initialized when the option to delete the
///    previously transferred budget has been selected.
/// </remarks>
protected void initBudgetTransaction()
{
    // Get the default budget transaction code for Project.
    budgetTransactionCode = BudgetTransactionCode::findDefaultByTransactionType(BudgetTransactionType::Project);

    if (deleteExistingTrans == true)
    {
        // Construct the budget transaction reverse manager when the option to delete
        // existing transferred budget has been chosen.
        transactionReverseManager = BudgetTransactionReverseManager::construct(budgetTransactionCode.Name, toForecastModel);
    }

    // Contruct an instance of the budget transaction manager to track the dimension attributes
    // that are not enabled for budget.
    budgetTransactionManager = BudgetTransactionManager::construct();

    // Get the parameter that determines whether the transferred budget is completed for project forecast.
    isBudgetTransStatusCompleted = BudgetParameters::find().IsProjectBudgetTransCreateAsCompleted;
}

]]></Source>
			</Method>
			<Method>
				<Name>initBudgetTransactionLinesToReverseQuery</Name>
				<Source><![CDATA[
    /// <summary>
///    Initializes the query that is used to retrieve the <c>BudgetTransactionLine</c> records that were
///    previously transferred.
/// </summary>
/// <remarks>
///    The range values for the <c>ProjTransBudgetTransId</c> and the <c>BudgetTransactionStatus</c>
///    values of the budget transactions are not set and should be set by the caller after the query is
///    initialized.
/// </remarks>
protected void initBudgetTransactionLinesToReverseQuery()
{
    QueryBuildDataSource transLineDS;
    QueryBuildDataSource transLineReversedDS;
    QueryBuildDataSource transLineReversingDS;
    QueryBuildDataSource transHeaderDS;

    QueryBuildRange transHeaderRange;

    DictRelation transLineReversedRelation;
    DictRelation transLineReversingRelation;

    transactionReverseQuery = new Query();

    // Add the BudgetTransactionLine table as a data source to get the transaction line details.
    transLineDS = transactionReverseQuery.addDataSource(tableNum(BudgetTransactionLine));
    transLineDS.relations(true);

    // Add the range for the trans ID of the ProjTransBudget record.
    // The range value will need be set before the caller runs the query.
    transReverseProjTransIdRange = transLineDS.addRange(fieldNum(BudgetTransactionLine, ProjTransBudgetTransId));

    // Add the BudgetTransactionLineReverse table as a data source to exclude reversed transaction lines
    // by doing a NoExists join with the BudgetTransactionLine data source.
    transLineReversedDS = transLineDS.addDataSource(tableNum(BudgetTransactionLineReverse));
    transLineReversedRelation = new DictRelation(tableNum(BudgetTransactionLineReverse), UtilElementType::Table, 1);
    transLineReversedRelation.loadFieldRelation(fieldNum(BudgetTransactionLineReverse, ReversedBudgetTransactionLine));
    transLineReversedDS.addRelation(transLineReversedRelation);
    transLineReversedDS.joinMode(JoinMode::NoExistsJoin);

    // Add the BudgetTransactionLineReverse table as a data source to exclude reversing transaction lines
    // by doing a NoExists join with the BudgetTransactionLine data source.
    transLineReversingDS = transLineDS.addDataSource(tableNum(BudgetTransactionLineReverse));
    transLineReversingRelation = new DictRelation(tableNum(BudgetTransactionLineReverse), UtilElementType::Table, 2);
    transLineReversingRelation.loadFieldRelation(fieldNum(BudgetTransactionLineReverse, ReversingBudgetTransactionLine));
    transLineReversingDS.addRelation(transLineReversingRelation);
    transLineReversingDS.joinMode(JoinMode::NoExistsJoin);

    // Add the BudgetTransactionHeader table as a data source to get the transaction header details.
    transHeaderDS = transLineDS.addDataSource(tableNum(BudgetTransactionHeader));
    transHeaderDS.relations(true);
    transHeaderDS.joinMode(JoinMode::ExistsJoin);

    // Restrict the BudgetTransactionHeader data source to only return records with
    // the correct budget model.
    transHeaderRange = transHeaderDS.addRange(fieldNum(BudgetTransactionHeader, BudgetModelId));
    transHeaderRange.value(SysQuery::value(toForecastModel));

    // Restrict the BudgetTransactionHeader data source to only return records with
    // the correct budget transaction type.
    transHeaderRange = transHeaderDS.addRange(fieldNum(BudgetTransactionHeader, BudgetTransactionType));
    transHeaderRange.value(int2str(enum2int(BudgetTransactionType::Project)));

    // Add the range for the BudgetTransactionStatus.
    // The range value will need be set before the caller runs the query.
    transReverseTransactionStatuRange = transHeaderDS.addRange(fieldNum(BudgetTransactionHeader, TransactionStatus));
}

]]></Source>
			</Method>
			<Method>
				<Name>initQuery</Name>
				<Source><![CDATA[
    void initQuery()
{
    str     tmpRangeStr;
    str     negWIP;
    str     negPayroll;
    boolean addWipRanges;
    boolean addPayrollRanges;

    this.setRange(tableNum(ProjTransBudget), fieldNum(ProjTransBudget, ModelId), fromForecastModel, RangeStatus::Locked);

    if (projectFromDate || projectToDate)
    {
        this.setRange(tableNum(ProjTransBudget)  ,fieldNum(ProjTransBudget,ProjTransDate)  , queryRange(projectFromDate, projectToDate), RangeStatus::Locked);
    }

    if (ledgerFromDate || ledgerToDate)
    {
        this.setRange(tableNum(ProjTransBudget)  ,fieldNum(ProjTransBudget,LedgerTransDate)  , queryRange(ledgerFromDate, ledgerToDate), RangeStatus::Locked);
    }

    // Payroll allocation is the one under addPayroll, WIP is the types listed under addWIPranges, ProfitLoss is the remaining
    // If profitLoss is included but payroll is not. The range is !projpayrollalltoction

    if (includeProfitAndloss)
    {
        if (!includeWIP)
        {
            addWipRanges    = true;
            negWIP          = '!';
        }
        if (!payrollAllocation)
        {
            addPayrollRanges    = true;
            negpayroll          = '!';
        }
    }

    if (!includeProfitAndloss)
    {
        if (includeWIP)
        {
            addWipRanges    = true;
            negWIP          = '';
        }
        if (payrollAllocation)
        {
            addPayrollRanges    = true;
            negpayroll          = '';
        }
    }

    if (addWipRanges)
    {
        tmpRangeStr = queryRangeConcat(tmpRangeStr, negWIP + queryValue(LedgerPostingType::ProdWIPValuation));
        tmpRangeStr = queryRangeConcat(tmpRangeStr, negWIP + queryValue(LedgerPostingType::ProdWIPIssue));
        tmpRangeStr = queryRangeConcat(tmpRangeStr, negWIP + queryValue(LedgerPostingType::ProdWIPIssue));
        tmpRangeStr = queryRangeConcat(tmpRangeStr, negWIP + queryValue(LedgerPostingType::ProjWIPCostvalue));
        tmpRangeStr = queryRangeConcat(tmpRangeStr, negWIP + queryValue(LedgerPostingType::ProjStatusAccountItem));
        tmpRangeStr = queryRangeConcat(tmpRangeStr, negWIP + queryValue(LedgerPostingType::ProjSalesvalueOffset));
        tmpRangeStr = queryRangeConcat(tmpRangeStr, negWIP + queryValue(LedgerPostingType::ProjWIPProduction));
        tmpRangeStr = queryRangeConcat(tmpRangeStr, negWIP + queryValue(LedgerPostingType::ProjWIPProfit));
        tmpRangeStr = queryRangeConcat(tmpRangeStr, negWIP + queryValue(LedgerPostingType::ProjWIPCost));
        tmpRangeStr = queryRangeConcat(tmpRangeStr, negWIP + queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
    }

    if (addPayrollRanges)
    {
        tmpRangeStr += queryRangeConcat(tmpRangeStr, negpayroll + queryValue(LedgerPostingType::ProjPayrollAllocation));
    }

    tmpRangeStr = queryRangeConcat(tmpRangeStr, SysQuery::valueNot(LedgerPostingType::ProjNeverLedger));
    tmpRangeStr = queryRangeConcat(tmpRangeStr, SysQuery::valueNot(LedgerPostingType::ProjNoLedger));

    this.setRange(tableNum(ProjTransBudget), fieldNum(ProjTransBudget,PostingType), tmpRangeStr, RangeStatus::Locked);

    this.checkAndDisableDatasource(queryRun.query(),queryRun.query().dataSourceNo(1));

    this.queryRun().query().dataSourceTable(tableNum(ProjTransBudget)).sortClear();
    this.queryRun().query().dataSourceTable(tableNum(ProjTransBudget)).addSortField(fieldNum(ProjTransBudget, ProjId));
    this.queryRun().query().dataSourceTable(tableNum(ProjTransBudget)).addSortField(fieldNum(ProjTransBudget, ProjTransType));
    this.queryRun().query().dataSourceTable(tableNum(ProjTransBudget)).addSortField(fieldNum(ProjTransBudget, TransId));
    this.queryRun().query().dataSourceTable(tableNum(ProjTransBudget)).orderMode(OrderMode::OrderBy);
}

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDates</Name>
				<Source><![CDATA[
    boolean ledgerDates()
{
    return true;
}

]]></Source>
			</Method>
			<Method>
				<Name>ledgerTransTxt</Name>
				<Source><![CDATA[
    protected TransactionTextLarge ledgerTransTxt(ProjTransBudget _projTransBudget, TransTxt _transTxt)
{
    TransactionTxt transactionTxt;
    transactionTxt = TransactionTxt::construct();

    transactionTxt.setType(LedgerTransTxt::ProjectBudgetingLedger);
    transactionTxt.setDate(_projTransBudget.ProjTransDate);
    transactionTxt.setFormLetter(_projTransBudget.TransId);

    switch (_projTransBudget.ProjTransType)
    {
    case ProjTransType::Revenue:
    case ProjTransType::Hour:
    case ProjTransType::Cost:
        transactionTxt.setKey1(_projTransBudget.displayResourceID());
        break;

    default:
        transactionTxt.setKey1(_projTransBudget.displayEmplItemId());
        break;
    }

    transactionTxt.setKey2(_projTransBudget.ProjId);
    transactionTxt.setKey3(_transTxt);

    return transactionTxt.txt();
}

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
{
    container pack = conNull();
    container ret;

    if (queryRun)
    {
        pack = queryRun.pack();
    }

    ret =  [#CurrentVersion, #CurrentList] + [pack];

    return ret;
}

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetTransactionHeaderDate</Name>
				<Source><![CDATA[
    TransDate parmBudgetTransactionHeaderDate(TransDate _budgetTransactionHeaderDate = budgetTransactionHeaderDate)
{
    budgetTransactionHeaderDate  = _budgetTransactionHeaderDate;
    return budgetTransactionHeaderDate;
}

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrency</Name>
				<Source><![CDATA[
    CurrencyCode parmCurrency(CurrencyCode _tmpCurrencyCode = tmpCurrencyCode)
{
    tmpCurrencyCode = _tmpCurrencyCode;

    return tmpCurrencyCode;
}

]]></Source>
			</Method>
			<Method>
				<Name>parmDeleteExistingTrans</Name>
				<Source><![CDATA[
    public boolean parmDeleteExistingTrans(boolean _deleteExistingTrans = deleteExistingTrans)
{
    deleteExistingTrans  = _deleteExistingTrans;

    return deleteExistingTrans;
}

]]></Source>
			</Method>
			<Method>
				<Name>parmFromForecastModel</Name>
				<Source><![CDATA[
    public ForecastModelId parmFromForecastModel(ForecastModelId _fromForecastModel = fromForecastModel)
{
    fromForecastModel  = _fromForecastModel;

    return fromForecastModel;
}

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeProfitAndloss</Name>
				<Source><![CDATA[
    public boolean parmIncludeProfitAndloss(boolean _includeProfitAndloss = includeProfitAndloss)
{
    includeProfitAndloss  = _includeProfitAndloss;

    return includeProfitAndloss;
}

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeWIP</Name>
				<Source><![CDATA[
    public boolean parmIncludeWIP(boolean _includeWIP = includeWIP)
{
    includeWIP  = _includeWIP;

    return includeWIP;
}

]]></Source>
			</Method>
			<Method>
				<Name>parmPayrollAllocation</Name>
				<Source><![CDATA[
    public boolean parmPayrollAllocation(boolean _payrollAllocation = payrollAllocation)
{
    payrollAllocation  = _payrollAllocation;

    return payrollAllocation;
}

]]></Source>
			</Method>
			<Method>
				<Name>parmPrice</Name>
				<Source><![CDATA[
    real parmPrice (real _tmpPrice = tmpPrice)
{
    tmpPrice = _tmpPrice;

    return tmpPrice;
}

]]></Source>
			</Method>
			<Method>
				<Name>parmQuantity</Name>
				<Source><![CDATA[
    real parmQuantity (real _tmpQuantity = tmpQuantity)
{
    tmpQuantity = _tmpQuantity;

    return tmpQuantity;
}

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesCurrency</Name>
				<Source><![CDATA[
    public boolean parmSalesCurrency(boolean _salesCurrency = salesCurrency)
{
    salesCurrency = _salesCurrency;

    return salesCurrency;
}

]]></Source>
			</Method>
			<Method>
				<Name>parmToForecastModel</Name>
				<Source><![CDATA[
    public BudgetModelHeadId parmToForecastModel(BudgetModelHeadId _toForecastModel = toForecastModel)
{
    toForecastModel  = _toForecastModel;

    return toForecastModel;
}

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionCurrencyAmount</Name>
				<Source><![CDATA[
    public AmountCur parmTransactionCurrencyAmount(AmountCur _tmpTransactionCurrencyAmount = tmpTransactionCurrencyAmount)
{
    tmpTransactionCurrencyAmount = _tmpTransactionCurrencyAmount;

    return tmpTransactionCurrencyAmount;
}

]]></Source>
			</Method>
			<Method>
				<Name>progressTitle</Name>
				<Source><![CDATA[
    str progressTitle()
{
    return "@SYS86830";
}

]]></Source>
			</Method>
			<Method>
				<Name>queryBuild</Name>
				<Source><![CDATA[
    protected QueryRun queryBuild()
{
    queryRun = new QueryRun(queryStr(projForecastbudgetTransfer));

    return queryRun;
}

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
/// Contains the code that does the actual job of the class.
/// </summary>
public void run()
{
    ProjTransBudget projTransBudget;
    Num lastTransId;

    this.progressInit(this.progressTitle(), QueryRun::getQueryRowCount(queryRun.query(), intMax()), #AviFormLetter);

    this.initQuery();

    // Initialize the budget transaction objects needed for the transfer.
    this.initBudgetTransaction();

    ttsbegin;

    while (queryRun.next())
    {
        projTransBudget = queryRun.get(tableNum(ProjTransBudget)) as ProjTransBudget;

        if (!projTransBudget.LedgerDimension)
        {
            throw error(strFmt("@SYS82707", projTransBudget.TransId, projTransBudget.ProjId, projTransBudget.ProjTransType));
        }

        this.progressUpdate(strFmt("@SYS82708", projTransBudget.ProjId, date2StrUsr(projTransBudget.LedgerTransDate, DateFlags::FormatAll)));

        // If "Delete Previously transferred" indicator is checked, reverse previously transferred completed
        // budget transactions that were transferred for the project transaction currently being transferred.
        if (deleteExistingTrans == true && projTransBudget.TransId != lastTransId)
        {
            // Reverse all budget transaction lines that are associated to the TransId for this record.
            // This will include the reversal of all records that share this TransId.
            this.addBudgetTransactionLinesToReverse(projTransBudget);
        }

        // Set the currency, quantity and price to the default values.
        this.parmCurrency(Ledger::accountingCurrency(CompanyInfo::current()));
        this.parmTransactionCurrencyAmount(CurrencyExchangeHelper::amount(projTransBudget.AmountMst, this.parmCurrency()));
        this.parmQuantity(projTransBudget.Qty);
        if (this.parmQuantity())
        {
            this.parmPrice(CurrencyExchangeHelper::price(this.parmTransactionCurrencyAmount() / this.parmQuantity(), this.parmCurrency()));
        }
        else
        {
            this.parmPrice(0);
        }

        // Check the value of the transfer sales currency
        if (salesCurrency)
        {
            // We need to check if the payment enum is Paid
            if (projTransBudget.PaymentStatus == ProjPaymentStatus::Paid)
            {
                // Check for the sales transactions only as the cost transactions are in the local currency
                if (projTransBudget.CostSales == ProjCostSales::Sales)
                {
                    // Set the currency, amount and quantity as per that in the trans tables
                    this.setAmountQuantityCurrency(projTransBudget.TransId, (projTransBudget.AmountMst < 0 ? -1 : 1));
                }
            }
        }

        if (budgetTransactionHeader.RecId == 0)
        {
            // Create the budget transaction header that will manage the transferred budget transaction lines.
            this.createBudgetTransactionHeader();
        }

        // Create the budget transaction line for the transfer.
        this.createBudgetTransactionLine(projTransBudget);

        lastTransId = projTransBudget.TransId;
    }

    if (budgetTransactionPost != null)
    {
        // The option to create completed budget transfers for project has been chosen.
        // Update budget balances for transaction created
        budgetTransactionPost.runOperation();
    }

    ttscommit;

    if (deleteExistingTrans == true)
    {
        // Process the reversal outside of the transfer tts to ensure any budget funds available checks
        // for the reversal are processed as confirmed.
        transactionReverseManager.reverseTransactionLines();
    }

    // Provide a warning for each dimension attribute in use in project that is
    // not enabled for budget.
    budgetTransactionManager.showWarningsDimAttsNotBudgetEnabled("@SYS300283");
}

]]></Source>
			</Method>
			<Method>
				<Name>setAmountQuantityCurrency</Name>
				<Source><![CDATA[
    void setAmountQuantityCurrency(str 20 _transId, int _signMultiplier)
    {
        CurrencyCode        curr = '';
        ProjForecastEmpl    projForecastEmpl;
        ProjForecastOnAcc   projForecastOnAcc;
        ProjForecastCost    projForecastCost;
        ProjForecastRevenue projForecastRevenue;
        ForecastSales       forecastSales;

        // Look in the 5 forecast tables
        while
        select firstonly CurrencyId, Qty, SalesPrice from projForecastEmpl where projForecastEmpl.TransId == _transId
        {
            if (this.parmCurrency() != projForecastEmpl.CurrencyId)
            {
                this.parmTransactionCurrencyAmount(CurrencyExchangeHelper::curAmount2CurAmount(this.parmTransactionCurrencyAmount(), this.parmCurrency(), projForecastEmpl.CurrencyId));
                this.parmCurrency(projForecastEmpl.CurrencyId);
            }
            if (this.parmQuantity())
            {
                this.parmPrice(CurrencyExchangeHelper::price(this.parmTransactionCurrencyAmount() / this.parmQuantity(), this.parmCurrency()));
            }
            return;
        }

        while
        select firstonly CurrencyId, SalesPrice from projForecastOnAcc where projForecastOnAcc.TransId == _transId
        {
            if (this.parmCurrency() != projForecastOnAcc.CurrencyId)
            {
                this.parmTransactionCurrencyAmount(CurrencyExchangeHelper::curAmount2CurAmount(this.parmTransactionCurrencyAmount(), this.parmCurrency(), projForecastOnAcc.CurrencyId));
                this.parmCurrency(projForecastOnAcc.CurrencyId);
            }
            if (this.parmQuantity())
            {
                this.parmPrice(CurrencyExchangeHelper::price(this.parmTransactionCurrencyAmount() / this.parmQuantity(), this.parmCurrency()));
            }
            return;
        }

        while
        select firstonly CurrencyId, Qty, SalesPrice from projForecastCost where projForecastCost.TransId == _transId
        {
            this.parmCurrency(projForecastCost.CurrencyId);
            this.parmTransactionCurrencyAmount(CurrencyExchangeHelper::amount(abs(projForecastCost.Qty * projForecastCost.SalesPrice) * _signMultiplier, this.parmCurrency()));
            if (this.parmQuantity())
            {
                this.parmPrice(CurrencyExchangeHelper::price(this.parmTransactionCurrencyAmount() / this.parmQuantity(), this.parmCurrency()));
            }
            return;
        }

        while
        select firstonly CurrencyId, Qty, SalesPrice from projForecastRevenue where projForecastRevenue.TransId == _transId
        {
            if (this.parmCurrency() != projForecastRevenue.CurrencyId)
            {
                this.parmTransactionCurrencyAmount(CurrencyExchangeHelper::curAmount2CurAmount(this.parmTransactionCurrencyAmount(), this.parmCurrency(), projForecastRevenue.CurrencyId));
                this.parmCurrency(projForecastRevenue.CurrencyId);
            }
            if (this.parmQuantity())
            {
                this.parmPrice(CurrencyExchangeHelper::price(this.parmTransactionCurrencyAmount() / this.parmQuantity(), this.parmCurrency()));
            }
            return;
        }

        while
        select firstonly Currency, SalesPrice from forecastSales where forecastSales.ProjTransId == _transId
        {
            if (this.parmCurrency() != forecastSales.Currency)
            {
                this.parmTransactionCurrencyAmount(CurrencyExchangeHelper::curAmount2CurAmount(this.parmTransactionCurrencyAmount(), this.parmCurrency(), forecastSales.Currency));
                this.parmCurrency(forecastSales.Currency);
            }
            if (this.parmQuantity())
            {
                this.parmPrice(CurrencyExchangeHelper::price(this.parmTransactionCurrencyAmount() / this.parmQuantity(), this.parmCurrency()));
            }
            return;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tableId</Name>
				<Source><![CDATA[
    public TableId tableId()
{
    return tableNum(ProjTransBudget);
}

]]></Source>
			</Method>
			<Method>
				<Name>title</Name>
				<Source><![CDATA[
    str title()
{
    return "@SYS342504";
}

]]></Source>
			</Method>
			<Method>
				<Name>transText</Name>
				<Source><![CDATA[
    public TransTxt transText(ProjTransBudget _projTransBudget)
{
    ProjForecastCost    projForecastCost;
    ProjForecastEmpl    projForecastEmpl;
    ProjForecastOnAcc   projForecastOnAcc;
    ProjForecastRevenue projForecastRevenue;
    ForecastSales       forecastSales;

    TransTxt            transTxt;

    switch (_projTransBudget.ProjTransType)
    {
        case ProjTransType::Revenue:
            projForecastRevenue = ProjForecastRevenue::find(_projTransBudget.TransId);
            transTxt            = projForecastRevenue.Txt;
            break;

        case ProjTransType::Hour:
            projForecastEmpl    = ProjForecastEmpl::find(_projTransBudget.TransId);
            transTxt            = projForecastEmpl.Txt;
            break;

        case ProjTransType::Cost:
            projForecastCost    = ProjForecastCost::find(_projTransBudget.TransId);
            transTxt            = projForecastCost.Txt;
            break;

        case ProjTransType::Item:
            forecastSales       = ForecastSales::findProjTransId(_projTransBudget.TransId);
            transTxt            = forecastSales.Comment;
            break;

        case ProjTransType::OnAccount:
            projForecastOnAcc   = ProjForecastOnAcc::find(_projTransBudget.TransId);
            transTxt            = projForecastOnAcc.Txt;
            break;
    }

    return transTxt;
}

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
{
    Integer         version         = RunBase::getVersion(packedClass);
    container       packedQuery;
    boolean         ret = true;

    switch (version)
    {
        case #CurrentVersion:
            [version,#CurrentList,packedQuery] = packedClass;

            if (SysQuery::isPackedOk(packedQuery))
            {
                queryRun = new QueryRun(packedQuery);
            }
            else
            {
                queryRun = this.queryBuild();
            }

            break;
        default:
            ret = false;
    }

    return ret;
}

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object _calledFrom = null)
{
    boolean ret;
    BudgetModel budgetModel;

    ret = super(_calledFrom);

    if (!(includeProfitAndloss || includeWIP || payrollAllocation))
    {
        ret = checkFailed("@SYS91231");
    }

    budgetModel = BudgetModel::find(HeadingSub::Heading, toForecastModel, toForecastModel);

    if (!toForecastModel || budgetModel.RecId == 0)
    {
        ret = checkFailed("@SYS82706");
    }

    if (budgetModel.Blocked == NoYes::Yes)
    {
        ret = checkFailed(strFmt("@SYS4829", toForecastModel));
    }

    if (BudgetTransactionCode::existDefaultByTransactionType(BudgetTransactionType::Project) == false)
    {
        ret = checkFailed(strFmt("@SYS132978", BudgetTransactionType::Project));
    }

    if (ret == true)
    {
        ret = this.confirmDraftBudgetTransNoReverse();
    }

    return ret;
}

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    protected static ClassDescription description()
{
    return "@SYS342504";
}

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
{
    ProjForecastBudgetTransferToLedger  pfct;

    pfct = new ProjForecastBudgetTransferToLedger();

    if (pfct.prompt())
    {
        pfct.runOperation();
    }
}

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable() 
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>