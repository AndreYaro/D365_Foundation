<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>MarkupAllocation</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class  MarkupAllocation extends RunBase
{
    AmountCur                   amountRemain;
    AmountCur                   amountHere;
    AmountCur                   allocateRemain;
    AmountCur                   allocateValue;
    AmountCur                   valueNow;

    Common                      source;
    MarkupTrans                 markupTransAllocate;
    MarkupTrans                 markupTrans;
    MarkupTmpAllocation         markupTmpAllocation;
    PurchId                     purchId;

    // <GEERU>
    #ISOcountryRegionCodes

    SalesId                     salesId;
    // </GEERU>
    InvoiceId                   invoiceId;

    MarkUpAllocateAfterType     allocateAfter;
    MarkupAllocateOnType        allocateOn;
    boolean                     allocateAll;
    boolean                     allocateOnlyReceived;
    boolean                     allocateInventoried;
    Set                         allocationRecIds;
    container                   packedAllocationRecIds;

    DlvDate                     postingDate;
    NoYes                       storno;

    CompanyId                   interCompanyCompanyId;
    InvoiceId                   interCompanyInvoiceId;
    InvoiceDate                 interCompanyInvoiceDate;
    boolean                     interCompanyDirectDelivery;
    boolean                     skipWarning;

    private const int currentVersion = 1;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allocateMarkup</Name>
				<Source><![CDATA[
    protected void  allocateMarkup()
    {
        QueryRun        queryTransact;
        Common          trans;
        boolean         wasAllocated;

        // <GIN>
        boolean         miscChargesParameterMarked = LedgerParameters::find().Miscellaneouscharges_IN;
        boolean         countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        // </GIN>
        // <GEERU>
        boolean         countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        queryTransact = this.queryBuild();

        while (queryTransact.next())
        {
            trans = this.queryGet(queryTransact);

            if (trans.RecId == 0)
            {
                continue;
            }
            // <GEERU>
            if (countryRegion_RU && ! this.checkCustomJournalPosted_RU(true))
            {
                continue;
            }
            if (countryRegion_RU && markupTransAllocate.markupTypeItem() && this.costAdjustmentLocked_RU())
            {
                continue;
            }
            if (countryRegion_RU && markupTransAllocate.isMarkupOfTypeCustVend() && this.markupCustVendLocked_RU())
            {
                continue;
            }
            // </GEERU>

            valueNow = this.calculateValueNow();

            if ((allocateOn == MarkupAllocateOn::AllLines      && valueNow != 0)
                || (allocateOn == MarkupAllocateOn::PositiveLine  && valueNow >  0)
                || (allocateOn == MarkupAllocateOn::NegativeLines && valueNow <  0))
            {
                valueNow = abs(valueNow);
                // <GIN>
                if (countryRegion_IN
                    && miscChargesParameterMarked
                    && allocateAfter == MarkupAllocateAfter::WholeAmount_IN)
                {
                    amountHere       = CurrencyExchangeHelper::amount(markupTransAllocate.Value, markupTransAllocate.CurrencyCode);
                }
                else
                {
                // </GIN>

                    if (markupTransAllocate.MarkupCategory == MarkupCategory::Fixed
                        || markupTransAllocate.MarkupCategory == MarkupCategory::Proportional)

                    {
                        if (valueNow >= allocateRemain)
                        {
                            amountHere = amountRemain;
                        }
                        else
                        {
                            if (markupTransAllocate.InterCompanyInvoiceId
                            &&  markupTransAllocate.InterCompanyMarkupUseValue)
                            {
                                amountHere = markupTransAllocate.InterCompanyMarkupValue * valueNow / allocateValue;
                            }
                            else
                            {
                                amountHere = markupTransAllocate.Value                   * valueNow / allocateValue;
                            }
                        }
                    }
                    else
                    {
                        if (markupTransAllocate.InterCompanyInvoiceId
                        &&  markupTransAllocate.InterCompanyMarkupUseValue)
                        {
                            amountHere  = markupTransAllocate.InterCompanyMarkupValue;
                            valueNow    = markupTransAllocate.InterCompanyMarkupValue;
                        }
                        else
                        {
                            amountHere  = markupTransAllocate.Value;
                            valueNow    = markupTransAllocate.Value;
                        }
                    }
                // <GIN>
                }
                // </GIN>

                // In case of MarkupCategeory::Percent the amountHere value is a percentage and not an actual amount, so don't round it.
                if (markupTransAllocate.MarkupCategory != MarkupCategory::Percent)
                {
                    allocateRemain  -= valueNow;
                    amountHere       = CurrencyExchangeHelper::amount(amountHere, markupTransAllocate.CurrencyCode);
                    amountRemain    -= amountHere;
                }

                wasAllocated     = true;

                this.createMarkupTrans();
                // <GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                {
                    this.recalcCustomJournal_RU();
                }
                // </GEERU>
            }
        }

        if (!wasAllocated)
        {
            if (allocateInventoried && interCompanyCompanyId)
            {
                allocateInventoried = NoYes::No;
                this.clear();
                this.sumValue();
                this.allocateMarkup();
            }
            else
            {
                throw error(strFmt("@SYS138671", markupTransAllocate.MarkupCode));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateValueNowDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for determining the current value of the allocation.
    /// </summary>
    /// <param name = "_markupAllocation">The instance of type <c>MarkupAllocation</c> that called that delegate.</param>
    /// <param name = "_result">An <c>EventHandlerResult</c> object where the current value of the allocation can be returned.</param>
    delegate void calculateValueNowDelegate(MarkupAllocation _markupAllocation, EventHandlerResult  _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateValueNow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current value of the allocation.
    /// </summary>
    /// <returns>The current value of the allocation.</returns>
    private AmountCur calculateValueNow()
    {
        switch (allocateAfter)
        {
            case MarkupAllocateAfter::NetAmount:
                return this.lineAmount();
            case MarkupAllocateAfter::Qty:
                return this.qty();
            case MarkupAllocateAfter::Line:
                return sign(this.qty());
            case MarkupAllocateAfter::Weight_RU:   
                return this.weight_RU();
            case MarkupAllocateAfter::Volume_RU:   
                return this.volume_RU();
            case MarkupAllocateAfter::WholeAmount_IN:
                if (LedgerParameters::find().Miscellaneouscharges_IN)
                {
                    return markupTransAllocate.Value;
                }
                break;
        }

        EventHandlerResult result = EventHandlerResult::newSingleResponse();
        this.calculateValueNowDelegate(this, result);
        
        if (result.hasResult())
        {
            return result.result();
        }

        return valueNow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAllocate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether allocation is possible for the given record.
    /// </summary>
    /// <returns>
    /// true if allocation is possible; otherwise, false.
    /// </returns>
    public boolean canAllocate()
    {
        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        if (countryRegion_RU)
        {
            this.initValues();
        }
        // </GEERU>
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCostAdjustmentLock_RU</Name>
				<Source><![CDATA[
    protected UnknownNoYes checkCostAdjustmentLock_RU()
    {
        boolean     found;
        boolean     existNonLocked;
        QueryRun    queryRunTrans;
        while select markupTransAllocate
              where markupTransAllocate.TransRecId   == source.RecId
              &&    markupTransAllocate.TransTableId == source.TableId
              &&    markupTransAllocate.Value
              &&  ((interCompanyInvoiceId &&  markupTransAllocate.InterCompanyInvoiceId == interCompanyInvoiceId)
               || (!interCompanyInvoiceId && !markupTransAllocate.InterCompanyInvoiceId)
               || (!interCompanyInvoiceId &&  markupTransAllocate.InterCompanyInvoiceId && !interCompanyDirectDelivery))
        {
            if (markupTransAllocate.markupTypeItem())
            {
                found = true;
                break;
            }
        }
        if (! found)
        {
            return UnknownNoYes::No;
        }

        found = false;

        queryRunTrans = this.queryBuild();
        while (queryRunTrans.next() && (!found || !existNonLocked))
        {
            this.queryGet(queryRunTrans);
            if (this.costAdjustmentLocked_RU())
            {
                found = true;
            }
            else
            {
                existNonLocked = true;
            }
        }

        if (found)
        {
            if (!existNonLocked)
            {
                warning("@GLS114811");
                return UnknownNoYes::Unknown;
            }
            warning("@GLS114813");
        }
        return found ? UnknownNoYes::Yes : UnknownNoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCustomJournal_RU</Name>
				<Source><![CDATA[
    protected boolean checkCustomJournal_RU()
    {
        boolean     foundOK = false;
        boolean     foundMarkup = false;
        QueryRun    queryRunTrans;

        queryRunTrans = this.queryBuild();

        while select forupdate markupTransAllocate
              group by MarkupCode
              where markupTransAllocate.TransRecId   == source.RecId
              &&    markupTransAllocate.TransTableId == source.TableId
              &&  ((interCompanyInvoiceId &&  markupTransAllocate.InterCompanyInvoiceId == interCompanyInvoiceId)
               || (!interCompanyInvoiceId && !markupTransAllocate.InterCompanyInvoiceId)
               || (!interCompanyInvoiceId &&  markupTransAllocate.InterCompanyInvoiceId && !interCompanyDirectDelivery))
        {
            foundMarkup = true;

            queryRunTrans.reset();
            while (queryRunTrans.next())
            {
                this.queryGet(queryRunTrans);
                if (this.checkCustomJournalPosted_RU(true))
                {
                    foundOK = true;
                }
            }
        }

        if (foundMarkup && !foundOK && SysQuery::countTotal(queryRunTrans) > 0)
        {
            throw error("@GLS114820");
        }

        return foundOK;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCustomJournalPosted_RU</Name>
				<Source><![CDATA[
    public boolean checkCustomJournalPosted_RU(boolean _showWarning = false)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCustVendAllocation_RU</Name>
				<Source><![CDATA[
    public boolean checkCustVendAllocation_RU(MarkupTrans _markupTrans)
    {
        QueryRun            queryRunTrans;
        InventProfile_RU    inventProfile;
        PostingProfile      postingProfile;
        container           key;
        boolean             allocNeeded;
        MarkupTrans         trans               = _markupTrans;
        Set                 postingProfileSet   = new Set(Types::Container);
        boolean             checkAllocNeed      = this.checkCustVendAllocNeed_RU();

        if (! trans.isMarkupOfTypeCustVend())
        {
            return true;
        }

        this.initValues();

        queryRunTrans = this.queryBuild();
        while (queryRunTrans.next())
        {
            SalesPurchLine          salesPurchLine  = this.queryGet(queryRunTrans);
            SalesPurchLineInterface salesPurchLineInterface = salesPurchLine.salesPurchLineInterface();

            inventProfile   = salesPurchLineInterface.inventDim().inventProfile_RU();

            if (inventProfile.LockMarkupCustVend)
            {
                return checkFailed("@GLS115688");
            }

            if (checkAllocNeed)
            {
                postingProfile = this.inventPostingProfile_RU(inventProfile.InventProfileId);
                key = [inventProfile.InventProfileType, postingProfile ?
                                                        postingProfile :
                                                        salesPurchLineInterface.parmPostingProfile_RU()];
                postingProfileSet.add(key);
                if (postingProfileSet.elements() > 1)
                {
                    allocNeeded = true;
                }
            }
        }

        if (checkAllocNeed && allocNeeded)
        {
            return checkFailed("@SYS25724");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCustVendAllocNeed_RU</Name>
				<Source><![CDATA[
    protected boolean checkCustVendAllocNeed_RU()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMarkupCustVendLock_RU</Name>
				<Source><![CDATA[
    protected UnknownNoYes checkMarkupCustVendLock_RU()
    {
        boolean     found;
        boolean     existNonLocked;
        QueryRun    queryRunTrans;

        while select markupTransAllocate
              where markupTransAllocate.TransRecId   == source.RecId
              &&    markupTransAllocate.TransTableId == source.TableId
              &&    markupTransAllocate.Value
              &&  ((interCompanyInvoiceId &&  markupTransAllocate.InterCompanyInvoiceId == interCompanyInvoiceId)
               || (!interCompanyInvoiceId && !markupTransAllocate.InterCompanyInvoiceId)
               || (!interCompanyInvoiceId &&  markupTransAllocate.InterCompanyInvoiceId && !interCompanyDirectDelivery))
        {
            if (markupTransAllocate.isMarkupOfTypeCustVend())
            {
                found = true;
                break;
            }
        }
        if (! found)
        {
            return UnknownNoYes::No;
        }

        found = false;

        queryRunTrans = this.queryBuild();
        while (queryRunTrans.next() && (!found || !existNonLocked))
        {
            this.queryGet(queryRunTrans);
            if (this.markupCustVendLocked_RU())
            {
                found = true;
            }
            else
            {
                existNonLocked = true;
            }
        }

        if (found)
        {
            if (!existNonLocked)
            {
                warning("@GLS114811");
                return UnknownNoYes::Unknown;
            }
            warning("@GLS114812");
        }
        return found ? UnknownNoYes::Yes : UnknownNoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clear</Name>
				<Source><![CDATA[
    protected void  clear()
    {
        amountRemain    = markupTransAllocate.Value;
        amountHere      = 0;
        allocateRemain  = 0;
        allocateValue   = 0;
        valueNow        = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAdjustmentLocked_RU</Name>
				<Source><![CDATA[
    protected boolean costAdjustmentLocked_RU()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMarkupTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>MarkupTrans</c> record.
    /// </summary>
    protected void createMarkupTrans()
    {
        markupTrans.clear();

        this.setMarkupTransFields();

        markupTrans.insert();
        // <GIN>
        if (LedgerParameters::isMiscellaneouscharges_IN())
        {
            if(markupTrans.NotionalCharges_IN == true || markupTrans.CustomsAssessableValue_IN == true)
            {
                markupTrans.updateAssessableValue_IN();
            }
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCode</Name>
				<Source><![CDATA[
    CurrencyCode currencyCode()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>MarkupAllocation</c> form.
    /// </summary>
    /// <returns>
    ///    An initialized <c>FormRun</c> object.
    /// </returns>
    Object  dialog()
    {
        FormRun  formRun;
        Args     args = new Args();

        args.name(formStr(MarkupAllocation));
        args.record(source);
        args.caller(this);
        formRun = classfactory.formRunClass(args);
        formRun.init();
        return formRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMarkupTransFromLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>MarkupTrans</c> record from the line to which it is allocated.
    /// </summary>
    abstract protected void initMarkupTransFromLine()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSetEnumerator</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the set enumerator by using a set of <c>allocationRecId</c> values.
    /// </summary>
    /// <param name="_se">
    ///    The set enumerator to initialize.
    /// </param>
    /// <returns>
    ///    The initialized set enumerator.
    /// </returns>
    public SetEnumerator initSetEnumerator(SetEnumerator _se)
    {
        _se = allocationRecIds.getEnumerator();
        return _se;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs initialization.
    /// </summary>
    abstract protected void initValues()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCategoryWeight_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns weight of the category based item.
    /// </summary>
    /// <returns>
    /// Always returns zero.
    /// </returns>
    protected ItemGrossWeight inventCategoryWeight_RU()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventPostingProfile_RU</Name>
				<Source><![CDATA[
    protected PostingProfile inventPostingProfile_RU(InventProfileId_RU _inventProfileId)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates qty.
    /// </summary>
    /// <returns>
    /// Qty in inventory units of measure.
    /// </returns>
    protected Qty inventQty()
    {
        return this.qty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTable_RU</Name>
				<Source><![CDATA[
    protected InventTable inventTable_RU()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmount</Name>
				<Source><![CDATA[
    AmountCur lineAmount()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>linkToIntercompanyInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>MarkupTrans</c> must be linked to intercompany invoices.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    protected boolean linkToIntercompanyInvoice()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupCustVendLocked_RU</Name>
				<Source><![CDATA[
    protected boolean markupCustVendLocked_RU()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        if (allocationRecIds == null)
        {
            allocationRecIds = new Set(typeName2Type(extendedTypeStr(RecId)));
        }
        packedAllocationRecIds = allocationRecIds.pack();
        return [currentVersion, 
            allocateafter,
            allocateOn,
            allocateAll,
            allocateOnlyReceived,
            allocateInventoried,
            packedAllocationRecIds];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllocateAfter</Name>
				<Source><![CDATA[
    public MarkUpAllocateAfterType parmAllocateAfter(MarkUpAllocateAfterType _allocateAfter = allocateAfter)
    {
        allocateAfter = _allocateAfter;
        return allocateAfter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkupTransAllocate</Name>
				<Source><![CDATA[
    public MarkupTrans getMarkupTransAllocate()
    {
        return markupTransAllocate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllocateAll</Name>
				<Source><![CDATA[
    public boolean parmAllocateAll(boolean _allocateAll = allocateAll)
    {
        allocateAll = _allocateAll;
        return allocateAll;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllocateInventoried</Name>
				<Source><![CDATA[
    public boolean parmAllocateInventoried(boolean _allocateInventoried = allocateInventoried)
    {
        allocateInventoried = _allocateInventoried;
        return allocateInventoried;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllocateOn</Name>
				<Source><![CDATA[
    public MarkupAllocateOn parmAllocateOn(MarkupAllocateOn _allocateOn = allocateOn)
    {
        allocateOn = _allocateOn;
        return allocateOn;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllocateOnlyReceived</Name>
				<Source><![CDATA[
    public boolean parmAllocateOnlyReceived(boolean _allocateOnlyReceived = allocateOnlyReceived)
    {
        allocateOnlyReceived = _allocateOnlyReceived;
        return allocateOnlyReceived;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllocationRecIds</Name>
				<Source><![CDATA[
    public Set parmAllocationRecIds(Set _allocationRecIDs = allocationRecIDs)
    {
        allocationRecIDs = _allocationRecIDs;
        return allocationRecIDs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyCompanyId</Name>
				<Source><![CDATA[
    public CompanyId parmInterCompanyCompanyId(CompanyId _interCompanyCompanyId = interCompanyCompanyId)
    {
        interCompanyCompanyId = _interCompanyCompanyId;
        return interCompanyCompanyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyDirectDelivery</Name>
				<Source><![CDATA[
    public boolean parmInterCompanyDirectDelivery(boolean _interCompanyDirectDelivery = interCompanyDirectDelivery)
    {
        interCompanyDirectDelivery = _interCompanyDirectDelivery;
        return interCompanyDirectDelivery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyInvoiceDate</Name>
				<Source><![CDATA[
    public InvoiceDate parmInterCompanyInvoiceDate(InvoiceDate _interCompanyInvoiceDate = interCompanyInvoiceDate)
    {
        interCompanyInvoiceDate = _interCompanyInvoiceDate;
        return interCompanyInvoiceDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyInvoiceId</Name>
				<Source><![CDATA[
    public InvoiceId parmInterCompanyInvoiceId(InvoiceId _interCompanyInvoiceId = interCompanyInvoiceId)
    {
        interCompanyInvoiceId = _interCompanyInvoiceId;
        return interCompanyInvoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowAllocateOnlyReceived</Name>
				<Source><![CDATA[
    protected boolean parmShowAllocateOnlyReceived()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipWarning</Name>
				<Source><![CDATA[
    public boolean parmSkipWarning(boolean _skipWarning = skipWarning)
    {
        skipWarning = _skipWarning;

        return skipWarning;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSource</Name>
				<Source><![CDATA[
    public Common parmSource(Common _source = source)
    {
        source = _source;

        return source;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateMarkupTmpAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Populates the <c>MarkupTmpAllocation</c> table with <c>RecId</c> values from the
    ///    <c>allocationRecIds</c> fields.
    /// </summary>
    public void populateMarkupTmpAllocation()
    {
        SetEnumerator               setEnumerator;

        setEnumerator = this.initSetEnumerator(setEnumerator);
        ttsbegin;
        markupTmpAllocation.clear();
        while (setEnumerator.moveNext())
        {
            markupTmpAllocation.MarkupAllocationRecId = setEnumerator.current();
            markupTmpAllocation.insert();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingDate</Name>
				<Source><![CDATA[
    DlvDate postingDate()
    {
        return postingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prompt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Displays the initialized <c>MarkupAllocation</c> form.
    /// </summary>
    /// <returns>
    ///    true if the user pressed the OK button on the <c>MarkupAllocation</c> form; otherwise, false.
    /// </returns>
    public boolean prompt()
    {
        boolean ret;

        xSysLastValue::deleteLast(this);
        ret = super();
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qty</Name>
				<Source><![CDATA[
    public Qty    qty()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuild</Name>
				<Source><![CDATA[
    abstract public QueryRun  queryBuild()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryGet</Name>
				<Source><![CDATA[
    abstract public Common  queryGet(QueryRun  transact)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalcCustomJournal_RU</Name>
				<Source><![CDATA[
    public void recalcCustomJournal_RU()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates and allocates the charge, then deletes the <c>MarkupTransAllocate</c> record.
    /// </summary>
    /// <param name = "_notAllowedMarkupCategorySet">
    /// A set contains the <c>MarkupCategory</c> values that are not allowed for charge allocation.
    /// </param>
    private void allocateCharge(Set _notAllowedMarkupCategorySet = null)
    {
        if (this.mustAllocateCharge(_notAllowedMarkupCategorySet))
        {
            if (this.validateTrans())
            {
                this.clear();
                this.sumValue();
                this.allocateMarkup();

                markupTransAllocate.delete();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustAllocateCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the charge must be allocated or not.
    /// </summary>
    /// <param name = "_notAllowedMarkupCategorySet">
    /// A set contains the <c>MarkupCategory</c> values that are not allowed for charge allocation.
    /// </param>
    /// <returns>
    /// true, if the charge must be allocated; otherwise, false.
    /// </returns>
    [Replaceable]
    protected boolean mustAllocateCharge(Set _notAllowedMarkupCategorySet)
    {
        return allocateAll || markupTransAllocate.markupTypeItem() || this.checkMarkupCategory(_notAllowedMarkupCategorySet);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMarkupCategory</Name>
				<Source><![CDATA[
    private boolean checkMarkupCategory(Set _notAllowedMarkupCategorySet)
    {
        if (_notAllowedMarkupCategorySet == null)
        {
            return true;
        }

        if (_notAllowedMarkupCategorySet.in(markupTransAllocate.MarkupCategory))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs allocation of <c>MarkupTrans</c> table records for a source table record.
    /// </summary>
    /// <param name="_callerDataSource">
    /// Identifies the data source that can be refreshed.
    /// </param>
    public void  run(Object _callerDataSource = null)
    {
        Object                  formDataSourceObject;
        boolean                 wasAllocated;
        boolean                 markupTransExist;

        // <GIN>
        boolean activateExtendedFeatures = LedgerParameters::isMiscellaneouscharges_IN();
        // </GIN>

        this.initValues();

        if (allocateAfter == MarkupAllocateAfter::Weight_RU || allocateAfter == MarkupAllocateAfter::Volume_RU)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00047, funcName());
        }

        ttsbegin;

        // <GIN>
        if (activateExtendedFeatures
            && source.TableId == tableNum(MarkupTrans))
        {
            select forupdate markupTransAllocate
                where markupTransAllocate.RecId   == source.RecId
                &&    markupTransAllocate.TableId == source.TableId
                &&   !markupTransAllocate.IsDeleted
                &&  ((interCompanyInvoiceId &&  markupTransAllocate.InterCompanyInvoiceId == interCompanyInvoiceId)
                || (!interCompanyInvoiceId && !markupTransAllocate.InterCompanyInvoiceId)
                || (!interCompanyInvoiceId &&  markupTransAllocate.InterCompanyInvoiceId && !interCompanyDirectDelivery));

            if (markupTransAllocate)
            {
                markupTransExist = true;
                markupTransAllocate.MarkUpAllocateAfter_IN = allocateAfter;
                markupTransAllocate.update();
                
                this.allocateCharge();
            }
        }
        else
        {
        // </GIN>
            while select forupdate markupTransAllocate
                  where markupTransAllocate.TransRecId   == source.RecId
                  &&    markupTransAllocate.TransTableId == source.TableId
                  &&   !markupTransAllocate.IsDeleted
                  &&  ((interCompanyInvoiceId &&  markupTransAllocate.InterCompanyInvoiceId == interCompanyInvoiceId)
                   || (!interCompanyInvoiceId && !markupTransAllocate.InterCompanyInvoiceId)
                   || (!interCompanyInvoiceId &&  markupTransAllocate.InterCompanyInvoiceId && !interCompanyDirectDelivery))
            {
                markupTransExist = true;
                // <GIN>
                if (activateExtendedFeatures)
                {
                    markupTransAllocate.MarkUpAllocateAfter_IN = allocateAfter;
                    markupTransAllocate.update();
                    this.allocateCharge();
                }
                else
                {
                // </GIN>
                    Set notAllowedMarkupCategorySet = new Set(Types::Enum);
                    notAllowedMarkupCategorySet.add(MarkupCategory::Fixed);
                    this.allocateCharge(notAllowedMarkupCategorySet);
                    wasAllocated = this.mustAllocateCharge(notAllowedMarkupCategorySet);
                // <GIN>
                }
                // </GIN>
            }
        // <GIN>
        }
        // </GIN>

        ttscommit;

        if (wasAllocated && _callerDataSource)
        {
            formDataSourceObject = _callerDataSource as FormDataSource;
            if (formDataSourceObject)
            {
                if (formDataSourceHasMethod(formDataSourceObject, identifierStr(setTouched)))
                {
                    formDataSourceObject.setTouched();
                }
                if (formDataSourceHasMethod(formDataSourceObject, identifierStr(markupTransMatchingChanged)))
                {
                    formDataSourceObject.markupTransMatchingChanged();
                }
            }
        }
        else if (!markupTransExist && !interCompanyInvoiceId && !skipWarning)
        {
            warning("@SYS309176");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMarkupTransFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the <c>MarkupTrans</c> fields before creating the record.
    /// </summary>
    protected void setMarkupTransFields()
    {
        markupTrans.initFromMarkupTrans(markupTransAllocate);
        this.initMarkupTransFromLine();

        markupTrans.CurrencyCode    = markupTransAllocate.CurrencyCode;
        markupTrans.Value           = amountHere;
        markupTrans.LineNum         = MarkupTrans::lastLineNum(markupTrans.TransTableId, markupTrans.TransRecId) + 1;
        markupTrans.CustomsAssessableValue_IN = markupTransAllocate.CustomsAssessableValue_IN;
        markupTrans.NotionalCharges_IN        = markupTransAllocate.NotionalCharges_IN;
        markupTrans.NotionalPct_IN = markupTransAllocate.NotionalPct_IN;

        if (markupTransAllocate.InterCompanyInvoiceId && this.linkToIntercompanyInvoice())
        {
            markupTrans.InterCompanyCompanyId      = markupTransAllocate.InterCompanyCompanyId;
            markupTrans.InterCompanyInvoiceId      = markupTransAllocate.InterCompanyInvoiceId;
            markupTrans.InterCompanyMarkupUseValue = markupTransAllocate.InterCompanyMarkupUseValue;
            markupTrans.InterCompanyMarkupValue    = markupTrans.Value;
            markupTrans.InterCompanyRefRecId       = markupTransAllocate.InterCompanyRefRecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setParameters</Name>
				<Source><![CDATA[
    void setParameters(MarkupAllocateAfter   _allocateAfter,
                       MarkupAllocateOn      _allocateOn,
                       DlvDate               _postingDate,
                       NoYes                 _storno,
                       boolean               _allocateInventoried)
    {
        allocateAfter       = _allocateAfter;
        allocateOn          = _allocateOn;
        postingDate         = _postingDate;
        storno              = _storno;
        allocateInventoried = _allocateInventoried;
    }

]]></Source>
			</Method>
			<Method>
				<Name>storno</Name>
				<Source><![CDATA[
    public NoYes storno()
    {
        return storno;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumValue</Name>
				<Source><![CDATA[
    public void  sumValue()
    {
        QueryRun        queryTransact;
        Common          trans;
        boolean         countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        queryTransact = this.queryBuild();

        while (queryTransact.next())
        {
            trans = this.queryGet(queryTransact);

            if (trans.RecId == 0)
            {
                continue;
            }
            // <GEERU>
            if (countryRegion_RU && ! this.checkCustomJournalPosted_RU())
            {
                continue;
            }
            if (countryRegion_RU && markupTransAllocate.markupTypeItem() && this.costAdjustmentLocked_RU())
            {
                continue;
            }
            if (countryRegion_RU && markupTransAllocate.isMarkupOfTypeCustVend() && this.markupCustVendLocked_RU())
            {
                continue;
            }
            // </GEERU>

            valueNow = this.calculateValueNow();

            if ((allocateOn == MarkupAllocateOn::AllLines)
                || (allocateOn == MarkupAllocateOn::PositiveLine  && valueNow > 0)
                || (allocateOn == MarkupAllocateOn::NegativeLines && valueNow < 0))
            {
                allocateValue += abs(valueNow);
            }
        }
        allocateRemain = allocateValue;
        if (! amountRemain)
        {
            throw error("@SYS15791");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean  unpack(container  _packedClass)
    {
        int         version = RunBase::getVersion(_packedClass);

        switch (version)
        {
            case currentVersion:
                [version, 
                allocateafter,
                allocateOn,
                allocateAll,
                allocateOnlyReceived,
                allocateInventoried,
                packedAllocationRecIds] = _packedClass;
                allocationRecIDs = Set::create(packedAllocationRecIds);
                break;

            default:
                return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTrans</Name>
				<Source><![CDATA[
    public boolean  validateTrans()
    {
        if (!markupTransAllocate.Value)
        {
            info("@SYS21491");
            return false;
        }

        if (!MarkupTable::exist(markupTransAllocate.ModuleType, markupTransAllocate.MarkupCode))
            throw error(strFmt("@SYS21413", markupTransAllocate.MarkupCode));

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>volume_RU</Name>
				<Source><![CDATA[
    protected Volume volume_RU()
    {
        InventTable inventTable = this.inventTable_RU();
        Volume      volume      = inventTable.grossVolume();

        if (!volume)
        {
            volume = inventTable.UnitVolume;
        }

        return volume * this.inventQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>weight_RU</Name>
				<Source><![CDATA[
    protected Weight weight_RU()
    {
        ItemGrossWeight ret;
        InventTable     inventTable = this.inventTable_RU();

        if (inventTable)
        {
            ret = this.inventTable_RU().grossWeight();
        }
        else
        {
            ret = this.inventCategoryWeight_RU();
        }

        return ret * this.inventQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static ClassDescription description()
    {
        return "@SYS6937";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void  main(Args  _args)
    {
        MarkupAllocation markupAllocation;

        markupAllocation = MarkupAllocation::newMarkupAllocation(_args.record());

        using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContext(_args))
        {
            if (markupAllocation.prompt())
            {
                if (markupAllocation.canAllocate())
                {
                    markupAllocation.runOperation();

                    // <GIN>
                    markupAllocation.refreshTransLines(_args.caller());
                    // </GIN>
                }
                else
                {
                    error("@SYS120636");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshTransLines</Name>
				<Source><![CDATA[
    private void refreshTransLines(Object _callerFormObject)
    {
        if (_callerFormObject && LedgerParameters::isMiscellaneouscharges_IN())
        {
            if (formHasMethod(_callerFormObject, identifierStr(refreshLinesAfterChargeAllocation)))
            {
                _callerFormObject.refreshLinesAfterChargeAllocation();
            }
            else if (formHasMethod(_callerFormObject, identifierStr(refreshPurchLine_IN)))
            {
                _callerFormObject.refreshPurchLine_IN();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMarkupAllocation</Name>
				<Source><![CDATA[
    public static MarkupAllocation newMarkupAllocation(Common _source)
    {
        MarkupAllocation markupAllocation;

        switch (_source.TableId)
        {
            case tableNum(MarkupTrans):
                boolean countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);

                if (countryRegion_IN && LedgerParameters::find().Miscellaneouscharges_IN)
                {
                    MarkupTrans markupTransLoc = _source;

                    MarkupAllocationTableNameFactoryAttribute attr = new MarkupAllocationTableNameFactoryAttribute(tableId2Name(markupTransLoc.TransTableId));
                    markupAllocation = SysExtensionAppClassFactory::getClassFromSysAttribute(classStr(MarkupAllocation), attr);
                }
                break;

            default:
                MarkupAllocationTableNameFactoryAttribute attr = new MarkupAllocationTableNameFactoryAttribute(tableId2Name(_source.TableId));
                markupAllocation = SysExtensionAppClassFactory::getClassFromSysAttribute(classStr(MarkupAllocation), attr);
                break;
        }

        if (!markupAllocation)
        {
            throw error(strFmt("@SYS19306", funcName()));
        }
        markupAllocation.parmSource(_source);

        return markupAllocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>