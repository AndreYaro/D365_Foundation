<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>VendAccruedPurchasesDP</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>VendAccruedPurchasesDP</c> class provides data for the <c>VendAccruedPurchases</c>
/// SQL Server Reporting Services report.
/// </summary>
[
    SRSReportQueryAttribute(queryStr(VendAccruedPurchases)),
    SRSReportParameterAttribute(classStr(VendAccruedPurchasesContract))
]
public class VendAccruedPurchasesDP extends SrsReportDataProviderPreProcessTempDB
{
    VendAccruedPurchasesTmp vendAccruedPurchasesTmp;
    NoYes physicalOnly;
    TransDate cutOffDate;
    PurchTable purchTable;
    PurchLine purchLine;
    VendPackingSlipTrans vendPackingSlipTrans;
    InventTable inventTable;

    VendCutOffDateOptions vendCutOffDateOption;

    DirPartyTable dirPartyTable;
    real accrual;

    VendAccruedPurchasesPurchTableTmp purchTableTmp;
    boolean hasRangesOrFilters;

    private VendAccruedPurchasesPackingSlipCorrectionsTmp vendAccruedPurchasesPackingSlipCorrectionsTmp;

    #define.PhysicalOnly('PhysicalOnly')

    // Local macros
    #LOCALMACRO.MainInsert
    insert_recordset vendAccruedPurchasesTmp
        (
            // Fields from VendPackingSlipTrans
            ReceivedQuantity,
            Qty, // Default the quantity to full received quantity, will reduce for partial invoicing later
            ValueMST,
            CostAmountPhysical,
            DatePhysical,
            UnitID,
            VoucherPhysical,
            PriceUnit,
            PhysicalOnly,
            InventTransId,
            PackingSlipSourceDocumentLine,

            // Fields from PurchLine
            ItemId,
            ItemName,
            ReferenceId,

            // Fields from PurchTable
            InvoiceAccount
        )
        select Qty, Qty, ValueMST, ValueMST, DeliveryDate, PurchUnit, CostLedgerVoucher, PriceUnit, PhysicalOnlyDescription, InventTransId, SourceDocumentLine from vendPackingSlipTrans
            join ItemId, Name, PurchId from purchLine order by PurchId, ItemId where
                purchLine.LineNumber == vendPackingSlipTrans.PurchaseLineLineNumber &&
                purchLine.PurchId == vendPackingSlipTrans.OrigPurchid
            join InvoiceAccount from purchTable where
                purchTable.PurchId == purchLine.PurchId
    ENDMACRO

    #LOCALMACRO.SourceDocLine
            exists join vendPackingSlipJour where
                vendPackingSlipJour.RecId == vendPackingSlipTrans.vendPackingSlipJour
    ENDMACRO

    #LOCALMACRO.OrigEvent
            exists join origEvent where
                origEvent.SourceDocumentHeader == vendPackingSlipJour.SourceDocumentHeader &&
                origEvent.Type == AccountingEventType::Original
    #ENDMACRO

    #LOCALMACRO.PhysicalOnly
           exists join accountingDistribution
               where accountingDistribution.SourceDocumentLine == vendPackingSlipTrans.SourceDocumentLine &&
                accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice
           exists join subledgerJournalAccountEntryDistribution
               where subledgerJournalAccountEntryDistribution.AccountingDistribution == accountingDistribution.RecId
    ENDMACRO

    #LOCALMACRO.RangesExist
            exists join purchTableTmp where
                purchTableTmp.PurchId == purchLine.PurchId &&
                purchTableTmp.LineNumber == purchLine.LineNumber
    ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmSkipReportTransaction</Name>
				<Source><![CDATA[
    public boolean parmSkipReportTransaction(boolean _skipReportTransaction = skipReportTransaction)
    {
        if (SsrsPreProcessReportSkipDefaultDatabaseTrxScope::instance().isEnabled())
        {
            skipReportTransaction = true;
        }

        return skipReportTransaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPhysicalOnlyVendAccruedPurchases</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records into <c>VendAccruedPurchasesTmp</c> table.
    /// </summary>
    /// <remarks>
    /// This method is called when the physicalOnly parameter is true.
    /// </remarks>
    private void buildPhysicalOnlyVendAccruedPurchases()
    {
        VendPackingSlipJour vendPackingSlipJour;
        AccountingEvent origEvent;
        PhysicalOnly physicalOnlyDescription = "@SYS95792";
        SubledgerJournalAccountEntryDistribution subledgerJournalAccountEntryDistribution;
        AccountingDistribution accountingDistribution;

        // Perform insert_recordset statments to populate
        // the report based on whether or not purchTableTmp
        // exists given physicalOnly was specified
        if (hasRangesOrFilters)
        {
            #MainInsert
            #RangesExist
            #SourceDocLine
            #PhysicalOnly
            #OrigEvent
            ;
        }
        else
        {
            #MainInsert
            #SourceDocLine
            #PhysicalOnly
            #OrigEvent
            ;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildVendAccruedPurchases</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records into <c>VendAccruedPurchasesTmp</c> table.
    /// </summary>
    /// <remarks>
    /// This method is called when the physicalOnly parameter is false.
    /// </remarks>
    private void buildVendAccruedPurchases()
    {
        VendPackingSlipJour vendPackingSlipJour;
        AccountingEvent origEvent;
        PhysicalOnly physicalOnlyDescription = "@SYS95793";

        // Perform insert_recordset statments to populate
        // the report based on whether or not purchTableTmp
        // exists given physicalOnly was not specified
        if (hasRangesOrFilters)
        {
            #MainInsert
            #RangesExist
            #SourceDocLine
            #OrigEvent
            ;
        }
        else
        {
            #MainInsert
            #SourceDocLine
            #OrigEvent
            ;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParametersFromContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes parameters from the contract class.
    /// </summary>
    private void getParametersFromContract()
    {
        VendAccruedPurchasesContract contract;

        contract = this.parmDataContract() as VendAccruedPurchasesContract;
        physicalOnly = contract.parmPhysicalOnly();
        cutOffDate = contract.parmCutOffDate();
        vendCutOffDateOption = contract.parmCutOffDateOptions();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendAccruedPurchasesTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the data from the <c>VendAccruedPurchasesTmp</c> temporary table.
    /// </summary>
    /// <returns>
    /// The data from the <c>VendAccruedPurchasesTmp</c> table.
    /// </returns>
    [
        SRSReportDataSetAttribute(tableStr(VendAccruedPurchasesTmp))
    ]
    public VendAccruedPurchasesTmp getVendAccruedPurchasesTmp()
    {
        select vendAccruedPurchasesTmp;
        return vendAccruedPurchasesTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the SQL Server Reporting Services report business logic.
    /// </summary>
    /// <remarks>
    /// This method provides the ability to write the report business logic. This method will be called by
    /// SQL Server Reporting Services (SSRS) at run time. The method should compute data and populate the
    /// data tables that will be returned to SSRS.
    /// </remarks>
    public void processReport()
    {
        VendInvoiceTrans vendInvoiceTrans, vendInvoiceTransNotExists;
        VendTable vendTable;

        VendInvoicePackingSlipQuantityMatch qtyMatched, qtyMatchedNotExists;
        VendAccruedPurchasesPartialInvoicedQty partialInvoiced, partialInvoicedBeforeCutOff;

        VendPackingSlipTransHistoryOrderByDate vendPackingSlipTransHistoryView;
        VendPackingSlipVersion vendPackingSlipVersionCorrection;
        VendPackingSlipMaxValidDateTmp vendPackingSlipMaxValidDateTmp;

        this.setUserConnection(vendAccruedPurchasesTmp);
        this.setUserConnection(purchTableTmp);
        this.setUserConnection(partialInvoiced);
        this.setUserConnection(partialInvoicedBeforeCutOff);
        this.setUserConnection(vendPackingSlipMaxValidDateTmp);
        this.setUserConnection(vendAccruedPurchasesPackingSlipCorrectionsTmp);

        this.getParametersFromContract();
        this.processReportQuery();

        // Set time value as '23:59:59' of the cutoffdate
        utcdatetime cutoffDateTime = DateTimeUtil::addSeconds(DateTimeUtil::newDateTime(cutOffDate + 1, 0), -1);

        if (VendAccruedPurchasesOptimizationFlight::instance().isEnabled())
        {
            // Prepare the packing slip corrections data first
            this.insertPackingSlipCorrectionsTmp(vendPackingSlipMaxValidDateTmp, cutoffDateTime);

            // Has to insert value without corrections first because the same selected column cannot be inserted into two different columns in destination table
            // i.e. insert_recordset vendAccruedPurchasesTmp (ReceivedQuantity, Qty, ValueMST, CostAmountPhysical) select Qty, Qty, ValueMST, ValueMST from vendPackingSlipTrans
            // will fail in QBDS implementation. Insert this first, leaving duplicate columns blank and update them after the insert is done.
            this.insertVendAccruedPurchasesTmp(false);

            this.insertVendAccruedPurchasesTmp(true);

            // Update the fixed value Physical only description when all data are inserted
            PhysicalOnly physicalOnlyDescription = physicalOnly ? "@SYS95792" : "@SYS95793";
            update_recordset vendAccruedPurchasesTmp setting
                PhysicalOnly = physicalOnlyDescription;

            // Copying old code logic here
            // Remove the product receipt records that don't have invoices and are after the cut-off date
            delete_from vendAccruedPurchasesTmp
            where vendAccruedPurchasesTmp.DatePhysical > cutOffDate
            notexists join qtyMatched where
                qtyMatched.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine;

            // Remove the records that have product receipts and invoices that are after the cut-off date and don't have
            // invoices that are prior to the cut-off date
            delete_from vendAccruedPurchasesTmp
            where vendAccruedPurchasesTmp.DatePhysical > cutOffDate
            exists join qtyMatched where
                qtyMatched.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine
            join vendInvoiceTrans where
                vendInvoiceTrans.SourceDocumentLine == qtyMatched.InvoiceSourceDocumentLIne
                && vendInvoiceTrans.InvoiceDate > cutOffDate
            notexists join qtyMatchedNotExists where
                qtyMatchedNotExists.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine
            join SourceDocumentLine, InvoiceDate from vendInvoiceTransNotExists where
                vendInvoiceTransNotExists.SourceDocumentLine == qtyMatchedNotExists.InvoiceSourceDocumentLIne
                && vendInvoiceTransNotExists.InvoiceDate <= cutOffDate;

            // Copying old logic here for common code after
            // Note that originally this could also take a lot of space and generate huge transaction log because the vendAccruedPurchasesTmp is huge
            // With new logic, vendAccruedPurcahsesTmp records now will have only necessary records and thus the space taken and transaction log are much smaller
            insert_recordset partialInvoiced (PackingSlipSourceDocumentLine, PartiallyInvoicedQuantity)
            select PackingSlipSourceDocumentLine from vendAccruedPurchasesTmp
                group by vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine
                where vendAccruedPurchasesTmp.DatePhysical <= cutOffDate
                        join sum(Quantity) from qtyMatched where
                            qtyMatched.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine
                        exists join vendInvoiceTrans where
                            vendInvoiceTrans.SourceDocumentLine == qtyMatched.InvoiceSourceDocumentLIne
                            && vendInvoiceTrans.InvoiceDate <= cutOffDate;
        }
        else
        {
            if (physicalOnly)
            {
                this.buildPhysicalOnlyVendAccruedPurchases();
            }
            else
            {
                this.buildVendAccruedPurchases();
            }

            // Now that all rows exist for the report, do set-based
            // updates to fill in the remaining columns

            // Update for any packing slip corrections/cancellations prior to the cut-off date
            // Note: If there are no corrections after the cut-off date, then the packing slip contains the correct data
            if (vendCutOffDateOption == VendCutOffDateOptions::AccountingDate)
            {
                this.setVendPackingSlipMaxValidDate(vendPackingSlipMaxValidDateTmp, cutoffDateTime);

                update_recordset vendAccruedPurchasesTmp setting
                ReceivedQuantity = vendPackingSlipTransHistoryView.ReceivedQty,
                Qty = vendPackingSlipTransHistoryView.Qty,
                CostAmountPhysical = vendPackingSlipTransHistoryView.CostAmountPhysical,
                ValueMST = vendPackingSlipTransHistoryView.ValueMST
                join vendPackingSlipTransHistoryView
                    where vendPackingSlipTransHistoryView.SourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine
                        && vendPackingSlipTransHistoryView.AccountingDate <= cutOffDate
                join vendPackingSlipMaxValidDateTmp
                    where vendPackingSlipMaxValidDateTmp.VendPackingSlipJour == vendPackingSlipTransHistoryView.VendPackingSlipJour
                        && vendPackingSlipMaxValidDateTmp.MaxValidTo == vendPackingSlipTransHistoryView.ValidTo
                exists join vendPackingSlipVersionCorrection
                    where vendPackingSlipVersionCorrection.VendPackingSlipJour == vendPackingSlipTransHistoryView.VendPackingSlipJour
                        && vendPackingSlipVersionCorrection.AccountingDate > cutOffDate;
            }
            else
            {
                update_recordset vendAccruedPurchasesTmp setting
                ReceivedQuantity = vendPackingSlipTransHistoryView.ReceivedQty,
                Qty = vendPackingSlipTransHistoryView.Qty,
                CostAmountPhysical = vendPackingSlipTransHistoryView.CostAmountPhysical,
                ValueMST = vendPackingSlipTransHistoryView.ValueMST
                join vendPackingSlipTransHistoryView
                    where vendPackingSlipTransHistoryView.SourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine
                        && vendPackingSlipTransHistoryView.AccountingDate <= cutOffDate
                exists join vendPackingSlipVersionCorrection
                    where vendPackingSlipVersionCorrection.VendPackingSlipJour == vendPackingSlipTransHistoryView.VendPackingSlipJour
                        && vendPackingSlipVersionCorrection.VersionDateTime > cutoffDateTime;
            }

            // Remove product receipts that have quantity of zero (cancellations completed prior to cut-off date)
            delete_from vendAccruedPurchasesTmp
            where vendAccruedPurchasesTmp.Qty == 0;

            // Remove the product receipt records that don't have invoices and are after the cut-off date
            delete_from vendAccruedPurchasesTmp
            where vendAccruedPurchasesTmp.DatePhysical > cutOffDate
            notexists join qtyMatched where
                qtyMatched.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine;

            // Remove the records that have product receipts and invoices that are after the cut-off date and don't have
            // invoices that are prior to the cut-off date
            delete_from vendAccruedPurchasesTmp
            where vendAccruedPurchasesTmp.DatePhysical > cutOffDate
            exists join qtyMatched where
                qtyMatched.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine
            join vendInvoiceTrans where
                vendInvoiceTrans.SourceDocumentLine == qtyMatched.InvoiceSourceDocumentLIne
                && vendInvoiceTrans.InvoiceDate > cutOffDate
            notexists join qtyMatchedNotExists where
                qtyMatchedNotExists.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine
            join SourceDocumentLine, InvoiceDate from vendInvoiceTransNotExists where
                vendInvoiceTransNotExists.SourceDocumentLine == qtyMatchedNotExists.InvoiceSourceDocumentLIne
                && vendInvoiceTransNotExists.InvoiceDate <= cutOffDate;

            // Summation of partial invoiced quantity cannot be done in the
            // original insert_recordset as it would change the cardinality of
            // the rows in the report. Similarly, it can't be done in a simple
            // update_recordset because update_recordset does not support summation..
            // Instead, do an insert_recordset with a sum into a staging table,
            // and then update out of that staging table.

            // At this point partialInvoiced may still contain quantities for the fully invoiced records.
            // We will delete them from vendAccruedPurchasesTmp in the next statement.

            insert_recordset partialInvoiced (PackingSlipSourceDocumentLine, PartiallyInvoicedQuantity)
            select PackingSlipSourceDocumentLine from vendAccruedPurchasesTmp
                group by vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine
                where vendAccruedPurchasesTmp.DatePhysical <= cutOffDate
                        join sum(Quantity) from qtyMatched where
                            qtyMatched.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine
                        exists join vendInvoiceTrans where
                            vendInvoiceTrans.SourceDocumentLine == qtyMatched.InvoiceSourceDocumentLIne
                            && vendInvoiceTrans.InvoiceDate <= cutOffDate;

            // Remove those records that have already been fully invoiced (Qty = InvoicedQty)
            delete_from vendAccruedPurchasesTmp
            exists join partialInvoiced where
                partialInvoiced.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine
                && vendAccruedPurchasesTmp.Qty == partialInvoiced.PartiallyInvoicedQuantity;
        }

        // Grab and sum up records that are invoiced prior to the cut-off date, but were received after the cut-off date
        insert_recordset partialInvoicedBeforeCutOff (PackingSlipSourceDocumentLine, PartiallyInvoicedQuantity)
            select PackingSlipSourceDocumentLine from vendAccruedPurchasesTmp
                group by vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine
                where vendAccruedPurchasesTmp.DatePhysical > cutOffDate
                        join sum(Quantity) from qtyMatched where
                            qtyMatched.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine
                        exists join vendInvoiceTrans where
                            vendInvoiceTrans.SourceDocumentLine == qtyMatched.InvoiceSourceDocumentLIne
                            && vendInvoiceTrans.InvoiceDate <= cutOffDate;

        // Date the invoice was posted
        update_recordset vendAccruedPurchasesTmp setting
            DateFinancial = vendInvoiceTrans.InvoiceDate,
            CostAmountPosted = (vendInvoiceTrans.LineAmountMST / vendInvoiceTrans.Qty) * vendAccruedPurchasesTmp.Qty
            join qtyMatched
                where qtyMatched.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine
            join maxOf(InvoiceDate), LineAmountMST, Qty from vendInvoiceTrans
                where vendInvoiceTrans.SourceDocumentLine == qtyMatched.InvoiceSourceDocumentLine;

        // Vendor name
        update_recordSet vendAccruedPurchasesTmp setting
            VendName = dirPartyTable.Name
            join dirPartyTable
            exists join vendTable where
                vendTable.AccountNum == vendAccruedPurchasesTmp.InvoiceAccount &&
                vendTable.Party == dirPartyTable.RecId;

        // Cost amount posted (has to be calculated *after* Qty is calculated for partial invoicing)
        update_recordSet vendAccruedPurchasesTmp setting
            CostAmountPhysical = (vendAccruedPurchasesTmp.ValueMST / vendAccruedPurchasesTmp.ReceivedQuantity) * (vendAccruedPurchasesTmp.ReceivedQuantity - partialInvoiced.PartiallyInvoicedQuantity),
            CostAmountPosted = 0,
            qty = (vendAccruedPurchasesTmp.ReceivedQuantity - partialInvoiced.PartiallyInvoicedQuantity),
            Voucher = ''
            where vendAccruedPurchasesTmp.ReceivedQuantity != 0
            join partialInvoiced where
                partialInvoiced.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine;

        // Any packing slip that is prior to the cut-off date and has invoices that are only after the cut-off date should be updated.
        // If there are invoices prior the cut-off date, then this update does not apply.
        update_recordSet vendAccruedPurchasesTmp setting
            CostAmountPosted = 0
            where vendAccruedPurchasesTmp.ReceivedQuantity != 0
            join qtyMatched where
                qtyMatched.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine
            join vendInvoiceTrans where
                vendInvoiceTrans.SourceDocumentLine == qtyMatched.InvoiceSourceDocumentLIne
                && vendInvoiceTrans.InvoiceDate > cutOffDate
            notExists join partialInvoiced where
                partialInvoiced.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine;

        // Any packing slip that is prior to the cut-off date and has invoices that are before the cut-off date should be updated.
        update_recordSet vendAccruedPurchasesTmp setting
            DateFinancial = dateNull()
            where vendAccruedPurchasesTmp.ReceivedQuantity != 0
            join partialInvoiced where
                partialInvoiced.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine;

        // Update Costs and quantities for packing slips that are after the cut-off, but invoices that are before the cut-off
        update_recordSet vendAccruedPurchasesTmp setting
            CostAmountPhysical = (vendAccruedPurchasesTmp.ValueMST / vendAccruedPurchasesTmp.ReceivedQuantity) * partialInvoicedBeforeCutOff.PartiallyInvoicedQuantity,
            CostAmountPosted = (vendAccruedPurchasesTmp.ValueMST / vendAccruedPurchasesTmp.ReceivedQuantity) * partialInvoicedBeforeCutOff.PartiallyInvoicedQuantity,
            qty = partialInvoicedBeforeCutOff.PartiallyInvoicedQuantity
            where vendAccruedPurchasesTmp.ReceivedQuantity != 0
            join partialInvoicedBeforeCutOff where
                partialInvoicedBeforeCutOff.PackingSlipSourceDocumentLine == vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine;

        // Accrual (has to be calculated *after* CostAmountPosted is populated)
        update_recordSet vendAccruedPurchasesTmp setting
            Accrual = vendAccruedPurchasesTmp.CostAmountPhysical - vendAccruedPurchasesTmp.CostAmountPosted
            where vendAccruedPurchasesTmp.DatePhysical <= cutOffDate;

        update_recordSet vendAccruedPurchasesTmp setting
            Accrual = 0 - vendAccruedPurchasesTmp.CostAmountPosted
            where vendAccruedPurchasesTmp.DatePhysical > cutOffDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReportQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the report query.
    /// </summary>
    private void processReportQuery()
    {
        Query query = this.parmQuery();

        // See if the user has added any ranges or filters
        // since the most common case is to run without
        // any ranges or filters
        for (int i = 1; i <= query.dataSourceCount(); i++)
        {
            if (query.hasRangeOrFilter(query.dataSourceNo(i)))
            {
                hasRangesOrFilters = true;
                break;
            }
        }

        if (hasRangesOrFilters)
        {
            query.clearAllFields();

            // Select by PurchId and LineNumber
            QueryBuildDataSource qbdsPurchLine = query.dataSourceTable(tableNum(PurchLine));
            qbdsPurchLine.addSelectionField(fieldNum(PurchLine, PurchId));
            qbdsPurchLine.addSelectionField(fieldNum(PurchLine, LineNumber));

            Map purchLineMap = new Map(Types::String, Types::Container);
            purchLineMap.insert(fieldStr(VendAccruedPurchasesPurchTableTmp, PurchId), [qbdsPurchLine.uniqueId(), fieldStr(PurchLine, PurchId)]);
            purchLineMap.insert(fieldStr(VendAccruedPurchasesPurchTableTmp, LineNumber), [qbdsPurchLine.uniqueId(), fieldStr(PurchLine, LineNumber)]);

            Query::insert_recordset(purchTableTmp, purchLineMap, query);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUserConnection</Name>
				<Source><![CDATA[
    private void setUserConnection(Common _common)
    {
        UserConnection con = this.parmUserConnection();
        if (con)
        {
            _common.setConnection(con);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVendPackingSlipMaxValidDate</Name>
				<Source><![CDATA[
    private void setVendPackingSlipMaxValidDate(VendPackingSlipMaxValidDateTmp _vendPackingSlipMaxValidDateTmp, utcdatetime _cutoffDateTime)
    {
        VendPackingSlipTransHistoryOrderByDate vendPackingSlipTransHistoryView;
        insert_recordset _vendPackingSlipMaxValidDateTmp (
            VendPackingSlipJour,
            MaxValidTo)
            select VendPackingSlipJour, maxof(ValidTo) from vendPackingSlipTransHistoryView
                group by VendPackingSlipJour
                where vendPackingSlipTransHistoryView.ValidTo >= _cutoffDateTime
                    && vendPackingSlipTransHistoryView.AccountingDate <= cutOffDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPackingSlipCorrectionsTmp</Name>
				<Source><![CDATA[
    private void insertPackingSlipCorrectionsTmp(VendPackingSlipMaxValidDateTmp _vendPackingSlipMaxValidDateTmp, utcdatetime _cutoffDateTime)
    {
        VendPackingSlipTransHistoryOrderByDate vendPackingSlipTransHistoryView;
        VendPackingSlipVersion vendPackingSlipVersionCorrection;

        if (vendCutOffDateOption == VendCutOffDateOptions::AccountingDate)
        {
            this.setVendPackingSlipMaxValidDate(_vendPackingSlipMaxValidDateTmp, _cutoffDateTime);

            insert_recordset vendAccruedPurchasesPackingSlipCorrectionsTmp
                (ReceivedQuantity, Qty, CostAmountPhysical, ValueMST, PackingSlipSourceDocumentLine)
            select
                ReceivedQty, Qty, CostAmountPhysical, ValueMST, SourceDocumentLine
            from vendPackingSlipTransHistoryView
                where vendPackingSlipTransHistoryView.AccountingDate <= cutOffDate
            join _vendPackingSlipMaxValidDateTmp
                where _vendPackingSlipMaxValidDateTmp.VendPackingSlipJour == vendPackingSlipTransHistoryView.VendPackingSlipJour
                    && _vendPackingSlipMaxValidDateTmp.MaxValidTo == vendPackingSlipTransHistoryView.ValidTo
            exists join vendPackingSlipVersionCorrection
                where vendPackingSlipVersionCorrection.VendPackingSlipJour == vendPackingSlipTransHistoryView.VendPackingSlipJour
                    && vendPackingSlipVersionCorrection.AccountingDate > cutOffDate;
        }
        else
        {
            insert_recordset vendAccruedPurchasesPackingSlipCorrectionsTmp
                (ReceivedQuantity, Qty, CostAmountPhysical, ValueMST, PackingSlipSourceDocumentLine)
            select
                ReceivedQty, Qty, CostAmountPhysical, ValueMST, SourceDocumentLine
            from vendPackingSlipTransHistoryView
                where vendPackingSlipTransHistoryView.AccountingDate <= cutOffDate
            exists join vendPackingSlipVersionCorrection
                where vendPackingSlipVersionCorrection.VendPackingSlipJour == vendPackingSlipTransHistoryView.VendPackingSlipJour
                    && vendPackingSlipVersionCorrection.VersionDateTime > _cutoffDateTime;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertVendAccruedPurchasesTmp</Name>
				<Source><![CDATA[
    private void insertVendAccruedPurchasesTmp(boolean _includeCorrections)
    {
        Query insertQuery = new Query();

        this.buildBaseQuery(insertQuery);
        if (_includeCorrections)
        {
            // build the query to select the qualified packing slips, only considering those with corrections prior to cut-off date
            this.buildIncludeCorrectionsPackingSlipOnlyQuery(insertQuery);
        }
        else
        {
            // build the query to select the qualified packing slips without corrections prior to cut-off date
            this.buildExcludeCorrectionsPackingSlipQuery(insertQuery);
        }
        this.buildFiltersQuery(insertQuery, _includeCorrections);

        QueryRun queryRun = new QueryRun(insertQuery);
        queryRun.setRecord(vendAccruedPurchasesPackingSlipCorrectionsTmp);
        insertQuery = queryRun.query();

        Map vendAccruedPurchasesTmpMap = new Map(Types::String, Types::Container);
        this.buildVendAccruedPurchasesTmpMapForInsert(vendAccruedPurchasesTmpMap, insertQuery, _includeCorrections);
        
        Query::insert_recordset(vendAccruedPurchasesTmp, vendAccruedPurchasesTmpMap, insertQuery);

        this.postInsertUpdate(_includeCorrections);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInsertUpdate</Name>
				<Source><![CDATA[
    private void postInsertUpdate(boolean _includeCorrections)
    {
        if (_includeCorrections)
        {
            // Reason for having this post-insert update is stated in buildVendAccruedPurchasesTmpMapForInsert function.
            // These fields are left as blank during the second insert. Update them here as a post-insert action.
            update_recordSet vendAccruedPurchasesTmp setting
                Qty = vendAccruedPurchasesPackingSlipCorrectionsTmp.Qty,
                ReceivedQuantity = vendAccruedPurchasesPackingSlipCorrectionsTmp.ReceivedQuantity,
                ValueMST = vendAccruedPurchasesPackingSlipCorrectionsTmp.ValueMST,
                CostAmountPhysical = vendAccruedPurchasesPackingSlipCorrectionsTmp.CostAmountPhysical
            join vendAccruedPurchasesPackingSlipCorrectionsTmp
                where vendAccruedPurchasesTmp.PackingSlipSourceDocumentLine == vendAccruedPurchasesPackingSlipCorrectionsTmp.PackingSlipSourceDocumentLine;
        }
        else
        {
            // Same selected column cannot be inserted into two different columns in destination table
            // i.e. insert_recordset vendAccruedPurchasesTmp (ReceivedQuantity, Qty, ValueMST, CostAmountPhysical) select Qty, Qty, ValueMST, ValueMST from vendPackingSlipTrans
            // will fail in QBDS implementation. These two columns are left as blank during the first insert. Update them here as a post-insert action.
            update_recordset vendAccruedPurchasesTmp setting
                ReceivedQuantity = vendAccruedPurchasesTmp.Qty,
                CostAmountPhysical = vendAccruedPurchasesTmp.ValueMST;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildBaseQuery</Name>
				<Source><![CDATA[
    private void buildBaseQuery(Query _query)
    {
        this.buildMainSelectQuery(_query);
        if (hasRangesOrFilters)
        {
            this.buildPurchTableTmpQuery(_query);
        }
        this.buildVendPackingSlipJourQuery(_query);
        if (physicalOnly)
        {
            this.buildAccountingDistributionQuery(_query);
        }
        this.buildAccountingEventQuery(_query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildMainSelectQuery</Name>
				<Source><![CDATA[
    private void buildMainSelectQuery(Query _query)
    {
        QueryBuildDataSource vendPackingSlipTransQbds = _query.addDataSource(tableNum(VendPackingSlipTrans));
        
        // Build the main part of the query
        QueryBuildDataSource purchLineQbds = vendPackingSlipTransQbds.addDataSource(tableNum(PurchLine));
        purchLineQbds.addLink(fieldNum(VendPackingSlipTrans, PurchaseLineLineNumber), fieldNum(PurchLine, LineNumber));
        purchLineQbds.addLink(fieldNum(VendPackingSlipTrans, OrigPurchId), fieldNum(PurchLine, PurchId));
        purchLineQbds.joinMode(JoinMode::InnerJoin);
        purchLineQbds.fetchMode(QueryFetchMode::One2One);
        purchLineQbds.addOrderByField(fieldNum(PurchLine, PurchId), SortOrder::Ascending);
        purchLineQbds.addOrderByField(fieldNum(PurchLine, ItemId), SortOrder::Ascending);

        QueryBuildDataSource purchTableQbds = purchLineQbds.addDataSource(tableNum(PurchTable));
        purchTableQbds.addLink(fieldNum(PurchLine, PurchId), fieldNum(PurchTable, PurchId));
        purchTableQbds.joinMode(JoinMode::InnerJoin);
        purchTableQbds.fetchMode(QueryFetchMode::One2One);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildVendPackingSlipJourQuery</Name>
				<Source><![CDATA[
    private void buildVendPackingSlipJourQuery(Query _query)
    {
        QueryBuildDataSource vendPackingSlipTransQbds = _query.dataSourceTable(tableNum(VendPackingSlipTrans));
        QueryBuildDataSource vendPackingSlipJourQbds = vendPackingSlipTransQbds.addDataSource(tableNum(VendPackingSlipJour));
        vendPackingSlipJourQbds.addLink(fieldNum(VendPackingSlipTrans, VendPackingSlipJour), fieldNum(VendPackingSlipJour, RecId));
        vendPackingSlipJourQbds.joinMode(JoinMode::ExistsJoin);
        vendPackingSlipJourQbds.fetchMode(QueryFetchMode::One2One);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildAccountingEventQuery</Name>
				<Source><![CDATA[
    private void buildAccountingEventQuery(Query _query)
    {
        QueryBuildDataSource vendPackingSlipJourQbds = _query.dataSourceTable(tableNum(VendPackingSlipJour));
        QueryBuildDataSource accountingEventQbds = vendPackingSlipJourQbds.addDataSource(tableNum(AccountingEvent));
        accountingEventQbds.addLink(fieldNum(VendPackingSlipJour, SourceDocumentHeader), fieldNum(AccountingEvent, SourceDocumentHeader));
        accountingEventQbds.addRange(fieldNum(AccountingEvent, Type)).value(SysQuery::value(AccountingEventType::Original));
        accountingEventQbds.joinMode(JoinMode::ExistsJoin);
        accountingEventQbds.fetchMode(QueryFetchMode::One2One);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildAccountingDistributionQuery</Name>
				<Source><![CDATA[
    private void buildAccountingDistributionQuery(Query _query)
    {
        QueryBuildDataSource vendPackingSlipTransQbds = _query.dataSourceTable(tableNum(VendPackingSlipTrans));
        QueryBuildDataSource accountingDistributionQbds = vendPackingSlipTransQbds.addDataSource(tableNum(AccountingDistribution));
        accountingDistributionQbds.addLink(fieldNum(VendPackingSlipTrans, SourceDocumentLine), fieldNum(AccountingDistribution, SourceDocumentLine));
        accountingDistributionQbds.addRange(fieldNum(AccountingDistribution, MonetaryAmount)).value(SysQuery::value(MonetaryAmount::ExtendedPrice));
        accountingDistributionQbds.joinMode(JoinMode::ExistsJoin);
        accountingDistributionQbds.fetchMode(QueryFetchMode::One2One);
        QueryBuildDataSource subledgerJournalAccountEntryDistributionQbds = accountingDistributionQbds.addDataSource(tableNum(SubledgerJournalAccountEntryDistribution));
        subledgerJournalAccountEntryDistributionQbds.addLink(fieldNum(AccountingDistribution, RecId), fieldNum(SubledgerJournalAccountEntryDistribution, AccountingDistribution));
        subledgerJournalAccountEntryDistributionQbds.joinMode(JoinMode::ExistsJoin);
        subledgerJournalAccountEntryDistributionQbds.fetchMode(QueryFetchMode::One2One);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPurchTableTmpQuery</Name>
				<Source><![CDATA[
    private void buildPurchTableTmpQuery(Query _query)
    {
        QueryBuildDataSource purchLineQbds = _query.dataSourceTable(tableNum(PurchLine));
        QueryBuildDataSource purchTableTmpQbds = purchLineQbds.addDataSource(tableNum(VendAccruedPurchasesPurchTableTmp));
        purchTableTmpQbds.addLink(fieldNum(PurchLine, PurchId), fieldNum(VendAccruedPurchasesPurchTableTmp, PurchId));
        purchTableTmpQbds.addLink(fieldNum(PurchLine, LineNumber), fieldNum(VendAccruedPurchasesPurchTableTmp, LineNumber));
        purchTableTmpQbds.joinMode(JoinMode::ExistsJoin);
        purchTableTmpQbds.fetchMode(QueryFetchMode::One2One);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildExcludeCorrectionsPackingSlipQuery</Name>
				<Source><![CDATA[
    // This is to exclude any record that has correction prior to the cut-off date 
    // so that the remaining records are all correct and up to date now
    private void buildExcludeCorrectionsPackingSlipQuery(Query _query)
    {
        QueryBuildDataSource vendPackingSlipTransQbds = _query.dataSourceTable(tableNum(VendPackingSlipTrans));
        QueryBuildDataSource vendPackingSlipCorrectionsTmpQbds = vendPackingSlipTransQbds.addDataSource(tableNum(VendAccruedPurchasesPackingSlipCorrectionsTmp));
        vendPackingSlipCorrectionsTmpQbds.addLink(fieldNum(VendPackingSlipTrans, SourceDocumentLine), fieldNum(VendAccruedPurchasesPackingSlipCorrectionsTmp, PackingSlipSourceDocumentLine));
        vendPackingSlipCorrectionsTmpQbds.joinMode(JoinMode::NoExistsJoin);
        vendPackingSlipCorrectionsTmpQbds.fetchMode(QueryFetchMode::One2One);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildIncludeCorrectionsPackingSlipOnlyQuery</Name>
				<Source><![CDATA[
    // This is to include records that have correction prior to the cut-off date only
    private void buildIncludeCorrectionsPackingSlipOnlyQuery(Query _query)
    {
        QueryBuildDataSource vendPackingSlipTransQbds = _query.dataSourceTable(tableNum(VendPackingSlipTrans));
        QueryBuildDataSource vendPackingSlipCorrectionsTmpQbds = vendPackingSlipTransQbds.addDataSource(tableNum(VendAccruedPurchasesPackingSlipCorrectionsTmp));
        vendPackingSlipCorrectionsTmpQbds.addLink(fieldNum(VendPackingSlipTrans, SourceDocumentLine), fieldNum(VendAccruedPurchasesPackingSlipCorrectionsTmp, PackingSlipSourceDocumentLine));
        vendPackingSlipCorrectionsTmpQbds.joinMode(JoinMode::InnerJoin);
        vendPackingSlipCorrectionsTmpQbds.fetchMode(QueryFetchMode::One2One);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFiltersQuery</Name>
				<Source><![CDATA[
    private void buildFiltersQuery(Query _query, boolean _includeCorrections)
    {
        this.buildExcludeFullyInvoicedPackingSlipQuery(_query);
        this.buildExcludeZeroQuantityPackingSlipQuery(_query, _includeCorrections);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildExcludeFullyInvoicedPackingSlipQuery</Name>
				<Source><![CDATA[
    private void buildExcludeFullyInvoicedPackingSlipQuery(Query _query)
    {
        QueryBuildDataSource vendPackingSlipTransQbds = _query.dataSourceTable(tableNum(VendPackingSlipTrans));
        QueryBuildDataSource vendPackingSlipQuantityQbds = vendPackingSlipTransQbds.addDataSource(tableNum(VendAccruedPurchasesInvoicedPackingSlipQuantity));
        vendPackingSlipQuantityQbds.addLink(fieldNum(VendPackingSlipTrans, SourceDocumentLine), fieldNum(VendAccruedPurchasesInvoicedPackingSlipQuantity, PackingSlipSourceDocumentLine));
        vendPackingSlipQuantityQbds.joinMode(JoinMode::NoExistsJoin);
        vendPackingSlipQuantityQbds.fetchMode(QueryFetchMode::One2One);

        QueryBuildRange invoiceDateRange = vendPackingSlipQuantityQbds.addRange(fieldNum(VendAccruedPurchasesInvoicedPackingSlipQuantity, InvoiceDate));
        invoiceDateRange.value(strFmt('(%1.%2<=%3)',
            vendPackingSlipQuantityQbds.name(),
            fieldStr(VendAccruedPurchasesInvoicedPackingSlipQuantity, InvoiceDate),
            date2StrXpp(cutoffDate)
        ));
        // Translation: VendAccruedPurchasesInvoicedPackingSlipQuantity.Quantity == VendPackingSlipTrans.QTY
        QueryBuildRange excludeFullyInvoicedRange = vendPackingSlipQuantityQbds.addRange(fieldNum(VendAccruedPurchasesInvoicedPackingSlipQuantity, Quantity));
        excludeFullyInvoicedRange.value(strFmt('(%1.%2=%3.%4)',
            vendPackingSlipQuantityQbds.name(),
            fieldStr(VendAccruedPurchasesInvoicedPackingSlipQuantity, Quantity),
            vendPackingSlipTransQbds.name(),
            fieldStr(VendPackingSlipTrans, Qty)
        ));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildExcludeZeroQuantityPackingSlipQuery</Name>
				<Source><![CDATA[
    private void buildExcludeZeroQuantityPackingSlipQuery(Query _query, boolean _includeCorrections)
    {
        if (_includeCorrections)
        {
            QueryBuildDataSource vendPackingSlipCorrectionsTmpQbds = _query.dataSourceTable(tableNum(VendAccruedPurchasesPackingSlipCorrectionsTmp));
            vendPackingSlipCorrectionsTmpQbds.addRange(fieldNum(VendAccruedPurchasesPackingSlipCorrectionsTmp, Qty)).value(SysQuery::valueNot(0));
        }
        else 
        {
            QueryBuildDataSource vendPackingSlipTransQbds = _query.dataSourceTable(tableNum(VendPackingSlipTrans));
            vendPackingSlipTransQbds.addRange(fieldNum(VendPackingSlipTrans, Qty)).value(SysQuery::valueNot(0));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildVendAccruedPurchasesTmpMapForInsert</Name>
				<Source><![CDATA[
    private void buildVendAccruedPurchasesTmpMapForInsert(Map _vendAccruedPurchasesTmpMap, Query _query, boolean _includeCorrections)
    {
        _query.clearAllFields();
        // Fields from VendPackingSlipTrans
        QueryBuildDataSource vendPackingSlipTransQbds = _query.dataSourceTable(tableNum(VendPackingSlipTrans));
        _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, DatePhysical), [vendPackingSlipTransQbds.uniqueId(), fieldStr(VendPackingSlipTrans, DeliveryDate)]);
        _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, UnitID), [vendPackingSlipTransQbds.uniqueId(), fieldStr(VendPackingSlipTrans, PurchUnit)]);
        _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, VoucherPhysical), [vendPackingSlipTransQbds.uniqueId(), fieldStr(VendPackingSlipTrans, CostLedgerVoucher)]);
        _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, PriceUnit), [vendPackingSlipTransQbds.uniqueId(), fieldStr(VendPackingSlipTrans, PriceUnit)]);
        _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, InventTransId), [vendPackingSlipTransQbds.uniqueId(), fieldStr(VendPackingSlipTrans, InventTransId)]);
        _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, PackingSlipSourceDocumentLine), [vendPackingSlipTransQbds.uniqueId(), fieldStr(VendPackingSlipTrans, SourceDocumentLine)]);
        
        QueryBuildFieldList vendPackingSlipTransFieldList = vendPackingSlipTransQbds.fields();
        vendPackingSlipTransFieldList.addField(fieldNum(VendPackingSlipTrans, DeliveryDate));
        vendPackingSlipTransFieldList.addField(fieldNum(VendPackingSlipTrans, PurchUnit));
        vendPackingSlipTransFieldList.addField(fieldNum(VendPackingSlipTrans, CostLedgerVoucher));
        vendPackingSlipTransFieldList.addField(fieldNum(VendPackingSlipTrans, PriceUnit));
        vendPackingSlipTransFieldList.addField(fieldNum(VendPackingSlipTrans, InventTransId));
        vendPackingSlipTransFieldList.addField(fieldNum(VendPackingSlipTrans, SourceDocumentLine));

        if (_includeCorrections)
        {
            // I have no idea why this doesn't work. Using this will get error: "Cannot insert multiple records in Accrued purchases (VendAccruedPurchasesTmp),
            // Stack trace: The parameter is incorrect" when inserting records into VendAccruedPurchasesTmp

            // As a workaround, these fields will be omitted now and updated later in post-insert actions.

            // Fields from VendAccruedPurchasesPackingSlipCorrectionsTmp
            // QueryBuildDataSource vendPackingSlipCorrectionsTmpQbds = _query.dataSourceTable(tableNum(VendAccruedPurchasesPackingSlipCorrectionsTmp));
            // _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, ReceivedQuantity), [vendPackingSlipCorrectionsTmpQbds.uniqueId(), fieldStr(VendAccruedPurchasesPackingSlipCorrectionsTmp, ReceivedQuantity)]);
            // _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, Qty), [vendPackingSlipCorrectionsTmpQbds.uniqueId(), fieldStr(VendAccruedPurchasesPackingSlipCorrectionsTmp, Qty)]);
            // _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, ValueMST), [vendPackingSlipCorrectionsTmpQbds.uniqueId(), fieldStr(VendAccruedPurchasesPackingSlipCorrectionsTmp, ValueMST)]);
            // _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, CostAmountPhysical), [vendPackingSlipCorrectionsTmpQbds.uniqueId(), fieldStr(VendAccruedPurchasesPackingSlipCorrectionsTmp, CostAmountPhysical)]);
            // 
            // QueryBuildFieldList vendPackingSlipCorrectionsTmpFieldList = vendPackingSlipCorrectionsTmpQbds.fields();
            // vendPackingSlipCorrectionsTmpFieldList.addField(fieldNum(VendAccruedPurchasesPackingSlipCorrectionsTmp, ReceivedQuantity));
            // vendPackingSlipCorrectionsTmpFieldList.addField(fieldNum(VendAccruedPurchasesPackingSlipCorrectionsTmp, Qty));
            // vendPackingSlipCorrectionsTmpFieldList.addField(fieldNum(VendAccruedPurchasesPackingSlipCorrectionsTmp, ValueMST));
            // vendPackingSlipCorrectionsTmpFieldList.addField(fieldNum(VendAccruedPurchasesPackingSlipCorrectionsTmp, CostAmountPhysical));
        }
        else 
        {
            // Fields from VendPackingSlipTrans
            _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, Qty), [vendPackingSlipTransQbds.uniqueId(), fieldStr(VendPackingSlipTrans, Qty)]);
            _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, ValueMST), [vendPackingSlipTransQbds.uniqueId(), fieldStr(VendPackingSlipTrans, ValueMST)]);

            vendPackingSlipTransFieldList.addField(fieldNum(VendPackingSlipTrans, Qty));
            vendPackingSlipTransFieldList.addField(fieldNum(VendPackingSlipTrans, ValueMST));
        }

        // Fields from PurchLine
        QueryBuildDataSource purchLineQbds = _query.dataSourceTable(tableNum(PurchLine));
        _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, ItemId), [purchLineQbds.uniqueId(), fieldStr(PurchLine, ItemId)]);
        _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, ItemName), [purchLineQbds.uniqueId(), fieldStr(PurchLine, Name)]);
        _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, ReferenceId), [purchLineQbds.uniqueId(), fieldStr(PurchLine, PurchId)]);

        QueryBuildFieldList purchLineFieldList = purchLineQbds.fields();
        purchLineFieldList.addField(fieldNum(PurchLine, ItemId));
        purchLineFieldList.addField(fieldNum(PurchLine, Name));
        purchLineFieldList.addField(fieldNum(PurchLine, PurchId));

        // Fields from PurchTable
        QueryBuildDataSource purchTableQbds = _query.dataSourceTable(tableNum(PurchTable));
        _vendAccruedPurchasesTmpMap.insert(fieldStr(VendAccruedPurchasesTmp, InvoiceAccount), [purchTableQbds.uniqueId(), fieldStr(PurchTable, InvoiceAccount)]);
        
        QueryBuildFieldList purchTableFieldList = purchTableQbds.fields();
        purchTableFieldList.addField(fieldNum(PurchTable, InvoiceAccount));
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>