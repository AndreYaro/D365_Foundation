<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventUpd_Physical</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>InventUpd_Physical</c> class is used to update the inventory physically.
/// </summary>
/// <remarks>
/// This class updates the inventory transaction to the <c>Received</c> status for purchase orders or
/// to the <c>Deducted</c> status for sales order updates. Physical updates in occur when you perform a
/// packing slip update. See the <c>SalesPackingSlipJournalPost.updateInventory</c> method for an
/// example of how the <c>InventUpd_Physical</c> class is used.
/// </remarks>
public class InventUpd_Physical extends InventUpdate implements WMSILocationLoadTrackingContext, WHSILocationLoadTrackingContext
{
    // new parameters
    InventQty                       physical;
    InventQty                       remainPhysical;
    UnitQty                         physicalUnit;
    UnitQty                         remainPhysicalUnit;
    PackingSlipId                   packingSlipId;
    Integer                         returnMode;
    boolean                         calledFromFinancial;
    boolean                         skipCWAutoAdjust;
    boolean                         preventAutoReservation;

    PdsCWInventQty                  cwPhysical;
    PdsCWInventQty                  cwRemainPhysical;

    // internal init
    InventQty                       estimated;
    UnitQty                         estimatedUnit;
    PdsCWInventQty                  cwEstimated;

    // update result
    InventQty                       updPhysical;
    UnitQty                         updPhysicalUnit;

    CostAmount                      updPhysicalAmountLedger;
    CostAmount                      updCostAmountInvent;
    AmountMSTPhysicalRevenue        updPhysicalRevenueAmountLedger;

    PdsCWInventQty                  cwUpdPhysical;

    //inventDim selection criteria
    InventDim                       inventDimCriteria;
    InventDimParm                   inventDimParmCriteria;

    NoYes                           activeQuarantineOrderFound;

    #ISOCountryRegionCodes
    InventQty                       updateParmUpdate;
    InventQty                       cwUpdateParmUpdate;
    WMSLocationLoadCreateManager    wmsLocationLoadCreateManager;
    WHSLocationLoadChangeTracker    whsLocationLoadChangeTracker;
    boolean                         adjustWMSLocationLoad;

    InventCostInputAmount           costInputAmount;

    InventCostOnhandCache           inventCostOnhandCache;

    // Variables needed to identify packing slip to reset
    Voucher                         voucherMatched;
    TransDate                       dateMatched;
    InventDim                       inventDimPhysicalMatched;

    InventQty                       remainBeforePhysical;
    UnitQty                         remainBeforePhysicalUnit;
    InventCostInputAmount           costInputAmountSecCur;

    Common                          physicalJournalLine; // contains journal line which cause the update

    WMSRouteId                      pickingRouteId;
    boolean                         onlyUpdateRegistered;
    private InventQty               trackingRegisterTransPhysicalQty;

    private boolean                 returnIssueTransFoundOnOtherDimension;

    private WHSLoadId               loadId;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmOnlyUpdateRegistered</Name>
				<Source><![CDATA[
    public boolean parmOnlyUpdateRegistered(NoYes _onlyUpdateRegistered = onlyUpdateRegistered)
    {
        onlyUpdateRegistered =  _onlyUpdateRegistered;
        
        return onlyUpdateRegistered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLoadID</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal protected WHSLoadId parmLoadID(WHSLoadId _loadId = loadId)
    {
        loadId = _loadId;

        return loadId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWHSLocationLoadChangeTracker</Name>
				<Source><![CDATA[
    public WHSLocationLoadChangeTracker parmWHSLocationLoadChangeTracker(WHSLocationLoadChangeTracker _whsLocationLoadChangeTracker = whsLocationLoadChangeTracker)
    {
        if (prmisDefault(_whsLocationLoadChangeTracker))
        {
            if (!whsLocationLoadChangeTracker)
            {
                whsLocationLoadChangeTracker = WHSLocationLoadChangeTracker::construct();
            }
        }
        else
        {
            whsLocationLoadChangeTracker = _whsLocationLoadChangeTracker;
        }

        return whsLocationLoadChangeTracker;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWMSLocationLoadCreateManager</Name>
				<Source><![CDATA[
    public WMSLocationLoadCreateManager parmWMSLocationLoadCreateManager(WMSLocationLoadCreateManager _wmsLocationLoadCreateManager = wmsLocationLoadCreateManager)
    {
        wmsLocationLoadCreateManager = _wmsLocationLoadCreateManager;

        return wmsLocationLoadCreateManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    public boolean check(TransDate _transDate)
    {
        boolean ok;

        ok = this.checkDate(_transDate);

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDate</Name>
				<Source><![CDATA[
    protected boolean checkDate(TransDate _transDate)
    {
        if (! this.checkUpdateMovement(_transDate))
        {
            return false;
        }

        if (returnMode)
        {
            return true;
        }

        return this.checkTransactions();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransactions</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal boolean checkTransactions()
    {
        if (!movement.mustCheckTransactionsOnPhysicalUpd())
        {
            return true;
        }

        InventTrans             inventTrans;
        InventOnHandQty         inventOnHandQty;
        InventQty               addQty;
        InventQty               qtyNow;
        WMSOrder                wmsOrder;
        WMSOrderTrans           wmsOrderTrans;
        int                     loopCount = 2;

        PdsCWInventQty          cwAddQty;
        PdsCWInventQty          cwNow = 0;

        InventJournalCheckConsolidatedQty   inventJournalCheckConsolidatedQty = movement.parmInventJournalCheckConsolidatedQty();
        InventDimParm                       inventDimParmActivePhysicalInvent;

        if (inventJournalCheckConsolidatedQty)
        {
            movement.inventDimGroupSetup().inventDimParmActivePhysicalInventory(inventDimParmActivePhysicalInvent);
            inventDimParmActivePhysicalInvent.setAllProductDimensions();
        }

        if (physical < 0)
        {
            if (movement.mustBePicked() && physical < movement.transIdSum().picked())
            {
                return checkFailed("@SYS54100");
            }

            addQty      = physical- movement.transIdSum().reservPhysical() - movement.transIdSum().picked() - estimated;
            cwAddQty    = cwPhysical - movement.transIdSum().pdsCWReservPhysical() - movement.transIdSum().pdsCWPicked() - cwEstimated;

            if (addQty < 0)
            {
                while (loopCount)
                {
                    if (loopCount == 2)
                    {
                        select inventTrans order by StatusIssue
                            where inventTrans.InventTransOrigin       == movement.inventTransOriginId()
                               && inventTrans.StatusReceipt           == StatusReceipt::None
                               && inventTrans.StatusIssue             >= StatusIssue::ReservOrdered
                               && inventTrans.StatusIssue             <= StatusIssue::OnOrder
                               && inventTrans.TransChildType          == movement.transChildType()
                               && inventTrans.TransChildRefId         == movement.transChildRefId();
                    }
                    else
                    {
                        select inventTrans order by StatusIssue
                            where inventTrans.InventTransOrigin       == movement.inventTransOriginId()
                               && inventTrans.StatusReceipt           == StatusReceipt::None
                               && inventTrans.StatusIssue             >= StatusIssue::ReservOrdered
                               && inventTrans.StatusIssue             <= StatusIssue::OnOrder
                                exists join wmsOrder
                                    where inventTrans.TransChildRefId        == wmsOrder.OrderId
                                       && inventTrans.TransChildType         == InventTransChildType::WMSOrder
                                       && wmsOrder.InventTransId             == movement.transId()
                                    exists join wmsOrderTrans
                                        where wmsOrder.OrderId                  == wmsOrderTrans.OrderId
                                           && wmsOrderTrans.InventTransId       == movement.transId()
                                           && wmsOrderTrans.InventTransType     == movement.transType()
                                           && wmsOrderTrans.InventTransRefId    == movement.transRefId();
                    }

                    while (inventTrans)
                    {
                        if (!movement.inventTable().checkRefInventTrans(inventTrans))
                        {
                            return false;
                        }

                        if (inventTrans.StatusIssue > StatusIssue::Picked   &&
                            !movement.checkCountingLocks(inventTrans.inventDim()))
                        {
                            return false;
                        }

                        if (!movement.checkDimPhysical(inventTrans.Qty,inventTrans.inventDim(),false))
                        {
                            return false;
                        }

                        if (!movement.whsCheckLocationAndLP(inventTrans))
                        {
                            return false;
                        }

                        qtyNow  = max(inventTrans.Qty, addQty);
                        cwNow   = max(inventTrans.PdsCWQty, cwAddQty);

                        if (this.parmPhysicalReduction() == InventPhysicalReduction::None)
                        {
                            InventDim inventDimPhysical;
                            InventQty qtyChecked;
                            PdsCWQty  cwQtyChecked;

                            if (inventJournalCheckConsolidatedQty)
                            {
                                inventDimPhysical = inventTrans.inventDim();
                                inventDimPhysical.clearNotSelectedDim(inventDimParmActivePhysicalInvent);
                                inventDimPhysical = InventDim::findOrCreate(inventDimPhysical);

                                [cwQtyChecked, qtyChecked] = inventJournalCheckConsolidatedQty.lookUp(inventTrans.ItemId, inventDimPhysical.inventDimId);
                            }

                            inventOnHandQty = InventOnHandQty::newPhysicalUpdate(movement,inventTrans.inventDim());
                            if (!inventOnHandQty.checkItemDraw(qtyNow + qtyChecked, allowNegativePhysical, true, cwNow + cwQtyChecked))
                            {
                                if (qtyChecked || cwQtyChecked)
                                {
                                    warning("@SCM:WarningOfConsolidatedInventJournalQuantityOnhandCheck");
                                }
                                return false;
                            }

                            if (inventJournalCheckConsolidatedQty)
                            {
                                inventJournalCheckConsolidatedQty.insert(inventTrans.ItemId, inventDimPhysical.inventDimId, cwNow + cwQtyChecked, qtyNow + qtyChecked, inventTrans.RecId);
                            }
                        }

                        addQty -= qtyNow;
                        cwAddQty  -= cwNow;
                        if (!addQty)
                        {
                            break;
                        }
                        next inventTrans;
                    }

                    loopCount--;
                }
            }

            if ((estimated < 0 || cwEstimated)
                && this.parmPhysicalReduction() == InventPhysicalReduction::None)
            {
                inventOnHandQty = InventOnHandQty::newPhysicalUpdate(movement,movement.inventdim());
                if (!inventOnHandQty.checkItemDraw(estimated,allowNegativePhysical, true, cwEstimated))
                {
                    return false;
                }
            }
        }
        else
        if (physical > 0)
        {
            if (movement.mustBeRegistered() && physical > movement.transIdSum().registered())
            {
                return checkFailed("@SYS54102");
            }

            addQty = physical- movement.transIdSum().registered() - estimated;
            cwAddQty = cwPhysical - movement.transIdSum().pdsCWRegistered() - cwEstimated;

            if (addQty > 0)
            {
                while select inventTrans
                    where inventTrans.InventTransOrigin == movement.inventTransOriginId()
                       && inventTrans.StatusIssue       == StatusIssue::None
                       && inventTrans.TransChildType    == movement.transChildType()
                       && inventTrans.TransChildRefId   == movement.transChildRefId()
                       &&
                         (inventTrans.StatusReceipt     == StatusReceipt::Ordered
                       || inventTrans.StatusReceipt     == StatusReceipt::Arrived)
                {
                    if (!movement.inventTable().checkRefInventTrans(inventTrans))
                    {
                        return false;
                    }

                    if (inventTrans.StatusReceipt > StatusReceipt::Registered   &&
                        !movement.checkCountingLocks(inventTrans.inventDim()))
                    {
                        return false;
                    }

                    if (!movement.checkDimPhysical(inventTrans.Qty,inventTrans.inventDim(),false))
                    {
                        return false;
                    }

                    if (!movement.whsCheckLocationAndLP(inventTrans))
                    {
                        return false;
                    }

                    qtyNow  = max(inventTrans.Qty, addQty);
                    cwNow   = max(inventTrans.PdsCWQty, cwAddQty);

                    addQty    -= qtyNow;
                    cwAddQty  -= cwNow;

                    if (inventJournalCheckConsolidatedQty)
                    {
                        InventDim inventDimPhysical = inventTrans.inventDim();
                        inventDimPhysical.clearNotSelectedDim(inventDimParmActivePhysicalInvent);
                        inventDimPhysical = InventDim::findOrCreate(inventDimPhysical);

                        InventQty qtyChecked;
                        PdsCWQty  cwQtyChecked;
                        [cwQtyChecked, qtyChecked] = inventJournalCheckConsolidatedQty.lookUp(inventTrans.ItemId, inventDimPhysical.inventDimId);
                        inventJournalCheckConsolidatedQty.insert(inventTrans.ItemId, inventDimPhysical.inventDimId, cwNow + cwQtyChecked, qtyNow  + qtyChecked, inventTrans.RecId);
                    }

                    if (! addQty)
                    {
                        break;
                    }
                }
            }
        }

        if (estimated && !movement.checkDimPhysical(physical,movement.inventdim(),false))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventDimPhysicalMatched</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether enough quantity has been matched for a specified <c>InventDim</c>
    /// </summary>
    /// <param name="_unmatchedQty">
    ///    The unmatched quantity to verify.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    Not enough quantity has been matched.
    /// </exception>
    protected void checkInventDimPhysicalMatched(InventQty _unmatchedQty)
    {
        if (_unmatchedQty && this.parmInventDimPhysicalMatched())
        {
            setPrefix(this.parmInventDimPhysicalMatched().preFix());
            throw error(strFmt("@SYS324401", _unmatchedQty - physical));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateMovement</Name>
				<Source><![CDATA[
    protected boolean checkUpdateMovement(TransDate transDate)
    {
        boolean             ok = true;

        if (!movement.checkUpdateStandard(transDate))
        {
            ok = false;
        }

        if (!movement.checkUpdatePhysical(this))
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctPhysicalTrackingRegister</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Corrects previously physically updated tracking register transactions.
    /// </summary>
    /// <param name="_correctedPhysicalQty">
    ///    The corrected physical quantity.
    /// </param>
    private void correctPhysicalTrackingRegister(InventQty _correctedPhysicalQty)
    {
        InventTrackingRegisterTrans::correctPhysicalJournalTrackingTrans(movement.inventTransOriginId(), physicalJournalLine, _correctedPhysicalQty, movement.inventDimGroupSetup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventTransPostingForReturn</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an <c>inventTransPosting</c> record for the return transaction.
    /// </summary>
    /// <param name="_inventTransPosting">
    ///    The <c>inventTransPosting</c> record that was used for the original posting.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher of the return transaction.
    /// </param>
    /// <param name="_transDate">
    ///    The date of the return transaction.
    /// </param>
    /// <param name="_inventTransPostingType">
    ///    The <c>inventTransPostingType</c> value, which must be set on the <c>inventTransPosting</c> record
    ///    for the return transaction.
    /// </param>
    /// <remarks>
    ///    This method will initialize the <c>inventTransPosting</c> record from the <c>inventTransPosting</c>
    ///    record that has been used for the original posting of a transaction.
    /// </remarks>
    protected void createInventTransPostingForReturn(
        InventTransPosting      _inventTransPosting,
        Voucher                 _voucher,
        TransDate               _transDate,
        InventTransPostingType  _inventTransPostingType)
    {
        InventTransPosting searchParameter;
        searchParameter.TransDate = _transDate;
        searchParameter.Voucher = _voucher;
        searchParameter.InventTransOrigin = _inventTransPosting.InventTransOrigin;
        searchParameter.InventTransPostingType = _inventTransPostingType;
        
        if (!InventTransPosting::existByNaturalKey(searchParameter))
        {
            InventTransPosting  inventTransPosting;

            inventTransPosting.data(_inventTransPosting);
            inventTransPosting.RecId                    = 0;
            inventTransPosting.TransDate                = _transDate;
            inventTransPosting.Voucher                  = _voucher;
            inventTransPosting.InventTransPostingType   = _inventTransPostingType;
            inventTransPosting.TransBeginTime           = InventCostUpdateGlobal::Instance().parmTransBeginTime();
            inventTransPosting.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>disableCacheForBufferCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the cache should be disabled for the buffer check in the
    /// <c>InventTrans.updateSumUp</c> method.
    /// </summary>
    /// <returns>
    /// true if the cache should be disabled; otherwise, false.
    /// </returns>
    /// <remarks>
    /// For best performance, the cache should be disabled if the item has serial numbers and the cache
    /// holds more than 1000 elements.The number of elements in the cache is equal to the number of
    /// elements in the <c>receiptList</c> list.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// The <c>receiptTransList</c> list is not initialized.
    /// </exception>
    protected boolean disableCacheForBufferCheck()
    {
        #define.disableAfterRecords(1000)

        if (!receiptTransList)
        {
            throw error(strFmt("@SYS19306", funcName()));
        }

        return movement.inventDimGroupSetup().getFieldSetup(fieldNum(InventDim,InventSerialId)).isActive() &&
               receiptTransList.elements() >= #disableAfterRecords;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    protected void init()
    {
        if (!returnMode)
        {
            UnitQty remainFinancialUnit = movement.remainFinancialUnit();
            if (physicalUnit != 0.0 && remainFinancialUnit != 0.0 && sign(physicalUnit) * sign(remainFinancialUnit) < 0)
            {
                returnMode = InventUpdate::physicalReturn();
            }
            else
            {
                UnitQty transQtyUnit = movement.transQtyUnit();
                if (physicalUnit != 0.0 && transQtyUnit != 0.0 && sign(physicalUnit) * sign(transQtyUnit) < 0)
                {
                    returnMode = InventUpdate::financialReturn();
                }
            }
        }

        if (!returnMode)
        {
            if (abs(movement.remainPhysical()) < abs(physical) && movement.inventMovSubType() == InventMovSubType::None)
            {
                estimated       = physical- movement.remainPhysical();
                estimatedUnit   = this.calcEstimatedUnit(estimated);
                cwEstimated     = cwPhysical - movement.pdsCWRemainPhysical();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransToReceiveList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the list of transactions for the receipt.
    /// </summary>
    /// <param name="_fromStatus">
    ///    The from range for the <c>statusReceipt</c> enumeration value to use to retrieve the transactions.
    /// </param>
    /// <param name="_toStatus">
    ///    The to range for the <c>statusReceipt</c> enumeration value to use to retrieve the transactions.
    /// </param>
    /// <param name="_inventDimId">
    ///    The inventory dimension ID to use to find the receipt transactions.
    /// </param>
    /// <param name="_inventDimCriteria">
    ///    The inventory dimension record to use to find the receipt transactions.
    /// </param>
    /// <param name="_inventDimParm">
    ///    The inventory dimension parameters to use to find the receipt transactions.
    /// </param>
    /// <param name="_inventTransChildType">
    ///    The inventory transaction child type to use to find the receipt transactions.
    /// </param>
    /// <param name="_inventTransChildRefId">
    ///    The inventory transaction child reference ID to use to find the receipt transactions.
    /// </param>
    /// <param name="_maxQty">
    ///    The maximum quantity that has to be received.
    /// </param>
    /// <param name="_addRecordsNotMatchingCriteria">
    ///    A Boolean flag that specifies whether to add records that do not match the criteria.
    /// </param>
    public void initInventTransToReceiveList(
        StatusReceipt           _fromStatus,
        StatusReceipt           _toStatus,
        InventDimId             _inventDimId,
        InventDim               _inventDimCriteria,
        InventDimParm           _inventDimParm,
        InventTransChildType    _inventTransChildType,
        InventTransChildRefId   _inventTransChildRefId,
        InventQty               _maxQty,
        boolean                 _addRecordsNotMatchingCriteria = false)
    {
        InventTrans     inventTransReceipt;

        super(_fromStatus,
              _toStatus,
              _inventDimId,
              _inventDimCriteria,
              _inventDimParm,
              _inventTransChildType,
              _inventTransChildRefId,
              _maxQty,
              _addRecordsNotMatchingCriteria);

        if (this.isMatchingInformationForReturnSpecified())
        {
            // Retrieve the inventTrans records that have been prepared for the return
            while select inventTransReceipt
            order by StatusReceipt,InventDimId, Qty // sort by quantity to minimize splitting of transactions
            where inventTransReceipt.InventTransOrigin  == movement.inventTransOriginId()
               && inventTransReceipt.PackingSlipId      == this.parmPackingSlipId()
               && inventTransReceipt.StatusReceipt      >= _fromStatus
               && inventTransReceipt.StatusReceipt      <= _toStatus
               && inventTransReceipt.StatusIssue        == StatusIssue::None
               && !inventTransReceipt.PackingSlipReturned
               && !inventTransReceipt.VoucherPhysical
               && !inventTransReceipt.DatePhysical
            {
                receiptTransList.addStart(inventTransReceipt);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventOnhandFinancialCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the financial inventory on-hand for an inventory dimension.
    /// </summary>
    /// <param name="_inventDim">
    /// An <c>InventDim</c> table record.
    /// </param>
    /// <returns>
    /// An <c>InventOnHand</c> class instance with the financial inventory.
    /// </returns>
    /// <remarks>
    /// The financial inventory on-hand is cached.
    /// </remarks>
    protected InventOnhand    inventOnhandFinancialCache(InventDim    _inventDim)
    {
        if (!inventCostOnhandCache)
        {
            inventCostOnhandCache = InventCostOnhandCache::construct();
        }

        return inventCostOnhandCache.getOnhand(movement, _inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventTransMarkedWithActiveQO</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether an <c>inventTrans</c> record is marked with an active quarantine order.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The <c>inventTrans</c> record to be examined.
    /// </param>
    /// <returns>
    ///    true if the <paramref name="_inventTrans" /> parameter is marked with an active quarantine order;
    ///    otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method is used to prevent the return of items currently being handled by quarantine orders.
    /// </remarks>
    protected boolean isInventTransMarkedWithActiveQO(InventTrans _inventTrans)
    {
        InventTransOrigin   inventTransOriginQO;
        InventTrans         inventTransQO;

        if (!_inventTrans.MarkingRefInventTransOrigin)
        {
            return false;
        }

        select firstonly RecId from inventTransQO
            where  inventTransQO.InventTransOrigin   == _inventTrans.MarkingRefInventTransOrigin
               && (inventTransQO.StatusIssue         > StatusIssue::Sold
               ||  inventTransQO.StatusReceipt       > StatusReceipt::Purchased)
            exists join inventTransOriginQO
                where inventTransOriginQO.RecId             == inventTransQO.InventTransOrigin
                   && inventTransOriginQO.ReferenceCategory == InventTransType::QuarantineOrder;

        return inventTransQO.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMatchingInformationForReturnSpecified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a matching voucher, date, and inventory dimension has been specified.
    /// </summary>
    /// <returns>
    ///    true if the matching voucher, date, and inventory dimension have been set; otherwise, false.
    /// </returns>
    protected boolean isMatchingInformationForReturnSpecified()
    {
        if (this.parmPackingSlipId()
         && this.parmVoucherMatched()
         && this.parmDateMatched())
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(InventMovement        _inventMovement)
    {
        adjustWMSLocationLoad = true;
        skipCWAutoAdjust = false;
        super(_inventMovement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjustWMSLocationLoad</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to adjust the load on a <c>wmsLocation</c> location when a physical transaction
    ///    occurs.
    /// </summary>
    /// <param name="_adjustWMSLocationLoad">
    ///    A Boolean value that determines whether to adjust the load on a <c>wmsLocation</c> location;
    ///    optional.
    /// </param>
    /// <returns>
    ///    true to adjust the load on a <c>wmsLocation</c> location; otherwise, false.
    /// </returns>
    public boolean parmAdjustWMSLocationLoad(boolean _adjustWMSLocationLoad = adjustWMSLocationLoad)
    {
        adjustWMSLocationLoad = _adjustWMSLocationLoad;
        return adjustWMSLocationLoad;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCalledFromFinancial</Name>
				<Source><![CDATA[
    public boolean parmCalledFromFinancial(boolean _calledFromFinancial = calledFromFinancial)
    {
        calledFromFinancial = _calledFromFinancial;
        return calledFromFinancial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCostInputAmount</Name>
				<Source><![CDATA[
    public InventCostInputAmount parmCostInputAmount(InventCostInputAmount _costInputAmount = costInputAmount)
    {
        costInputAmount = _costInputAmount;
        return costInputAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCostInputAmountSecCur_RU</Name>
				<Source><![CDATA[
    public InventCostInputAmount parmCostInputAmountSecCur_RU(InventCostInputAmount _costInputAmount = costInputAmountSecCur)
    {
        costInputAmountSecCur = _costInputAmount;
        return costInputAmountSecCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDateMatched</Name>
				<Source><![CDATA[
    public TransDate parmDateMatched(TransDate _dateMatched = dateMatched)
    {
        dateMatched = _dateMatched;
        return dateMatched;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventCostOnhandCache</Name>
				<Source><![CDATA[
    public InventCostOnhandCache parmInventCostOnhandCache(InventCostOnhandCache _inventCostOnhandCache = inventCostOnhandCache)
    {
        inventCostOnhandCache = _inventCostOnhandCache;
        return inventCostOnhandCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDim</Name>
				<Source><![CDATA[
    public InventDim parmInventDim(InventDim _inventDimCriteria  = inventDimCriteria)
    {
        inventDimCriteria = _inventDimCriteria;
        return inventDimCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimParm</Name>
				<Source><![CDATA[
    public InventDimParm parmInventDimParm(InventDimParm _inventDimParmCriteria = inventDimParmCriteria)
    {
        inventDimParmCriteria = _inventDimParmCriteria;
        return inventDimParmCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimPhysicalMatched</Name>
				<Source><![CDATA[
    public InventDim parmInventDimPhysicalMatched(InventDim _inventDimPhysicalMatched = inventDimPhysicalMatched)
    {
        inventDimPhysicalMatched = _inventDimPhysicalMatched;
        return inventDimPhysicalMatched;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPackingSlipId</Name>
				<Source><![CDATA[
    protected PackingSlipId parmPackingSlipId(PackingSlipId _packingSlipId = packingSlipId)
    {
        packingSlipId = _packingSlipId;
        return packingSlipId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPdsCWPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method gets or sets the cwPhysical parameter.
    /// </summary>
    /// <param name="_cwPhysical">
    /// Value to be set.
    /// </param>
    /// <returns>
    /// The cwPhsyical parameter.
    /// </returns>
    public PdsCWInventQty parmPdsCWPhysical(
        PdsCWInventQty _cwPhysical = cwPhysical)
    {
        cwPhysical = _cwPhysical;

        return cwPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPdsCWRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method gets or sets the cwRemainPhysical parameter.
    /// </summary>
    /// <param name="_cwRemainPhysical">
    /// Value to be set.
    /// </param>
    /// <returns>
    /// The cwRemainPhysical parameter.
    /// </returns>
    public PdsCWInventQty parmPdsCWRemainPhysical(
        PdsCWInventQty _cwRemainPhysical = cwRemainPhysical)
    {
        cwRemainPhysical = _cwRemainPhysical;

        return cwRemainPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPhysical</Name>
				<Source><![CDATA[
    public InventQty  parmPhysical(InventQty _physical = physical)
    {
        physical = _physical;
        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPhysicalJournalLine</Name>
				<Source><![CDATA[
    public Common parmPhysicalJournalLine(Common _physicalJournalLine = physicalJournalLine)
    {
        physicalJournalLine = _physicalJournalLine;

        return physicalJournalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPhysicalUnit</Name>
				<Source><![CDATA[
    public UnitQty  parmPhysicalUnit(UnitQty _physicalUnit = physicalUnit )
    {
        physicalUnit = _physicalUnit;
        return physicalUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPickingRouteId</Name>
				<Source><![CDATA[
    public WMSRouteId parmPickingRouteId(WMSRouteId _pickingRouteId = pickingRouteId)
    {
        pickingRouteId = _pickingRouteId;

        return pickingRouteId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreventAutoReservation</Name>
				<Source><![CDATA[
    public boolean parmPreventAutoReservation(boolean _preventAutoReservation = preventAutoReservation)
    {
        preventAutoReservation = _preventAutoReservation;

        return preventAutoReservation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRemainBeforePhysical_RU</Name>
				<Source><![CDATA[
    public InventQty parmRemainBeforePhysical_RU(InventQty _remainBeforePhysical = remainBeforePhysical)
    {
        remainBeforePhysical = _remainBeforePhysical;
        return remainBeforePhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRemainBeforePhysicalUnit_RU</Name>
				<Source><![CDATA[
    public UnitQty parmRemainBeforePhysicalUnit_RU(UnitQty _remainBeforePhysicalUnit = remainBeforePhysicalUnit)
    {
        remainBeforePhysicalUnit = _remainBeforePhysicalUnit;
        return remainBeforePhysicalUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRemainPhysical</Name>
				<Source><![CDATA[
    public InventQty  parmRemainPhysical(InventQty _remainPhysical = remainPhysical)
    {
        remainPhysical = _remainPhysical;
        return remainPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRemainPhysicalUnit</Name>
				<Source><![CDATA[
    public UnitQty  parmRemainPhysicalUnit(UnitQty _remainPhysicalUnit = remainPhysicalUnit)
    {
        remainPhysicalUnit = _remainPhysicalUnit;
        return remainPhysicalUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReturnMode</Name>
				<Source><![CDATA[
    public Integer parmReturnMode(Integer _returnMode = returnMode)
    {
        returnMode = _returnMode;
        return returnMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipCWAutoAdjust</Name>
				<Source><![CDATA[
    public boolean parmSkipCWAutoAdjust(boolean _skipCWAutoAdjust = skipCWAutoAdjust)
    {
        skipCWAutoAdjust = _skipCWAutoAdjust;
        return skipCWAutoAdjust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTrackingRegisterTransPhysicalQty</Name>
				<Source><![CDATA[
    public InventQty  parmTrackingRegisterTransPhysicalQty(InventQty _trackingRegisterTransPhysicalQty = trackingRegisterTransPhysicalQty)
    {
        trackingRegisterTransPhysicalQty = _trackingRegisterTransPhysicalQty;
        return trackingRegisterTransPhysicalQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucherMatched</Name>
				<Source><![CDATA[
    public Voucher parmVoucherMatched(Voucher _voucherMatched = voucherMatched)
    {
        voucherMatched = _voucherMatched;
        return voucherMatched;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWUpdateAutoAdjust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the catch weight auto adjust quantity.
    /// </summary>
    /// <param name="_allowNegativePhysical">
    /// A Boolean value that indicates whether a negative physical inventory is allowed.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> record that is used for the update.
    /// </param>
    /// <param name="_inventDimId">
    /// The dimensions that are used for the update.
    /// </param>
    public void pdsCWUpdateAutoAdjust(
        boolean         _allowNegativePhysical,
        LedgerVoucher   _ledgerVoucher,
        InventDimId     _inventDimId)
    {
        var inventOnHandQty = InventOnHandQty::newPhysicalInvent(movement, InventDim::find(_inventDimId));
        var inventCorrection = inventOnHandQty.pdsCWRequiredInventQtyCorrection();

        if (inventCorrection != 0)
        {
            var movement_Virtuel = PdsCW_InventMov_Vir_CWLoss::newParameters(
                                        movement.itemId(),
                                        _inventDimId,
                                        movement.transDate() ? movement.transDate() : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                        inventCorrection,
                                        0,
                                        movement.defaultDimension());
            var financial_Virtuel = InventUpd_Financial::newCWAutoAdjust(
                                        movement_Virtuel,
                                        _ledgerVoucher);
            financial_Virtuel.updateNow();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWUpdPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the value of the <c>PdsCWInventQty</c> parameter.
    /// </summary>
    /// <returns>
    /// The value of the <c>PdsCWInventQty</c> parameter.
    /// </returns>
    public PdsCWInventQty pdsCWUpdPhysical()
    {
        return cwUpdPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventOnhandFinancialCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the available financial cache.
    /// </summary>
    /// <param name="_inventTrans">
    /// The inventory transaction.
    /// </param>
    protected void updateInventOnhandFinancialCache(InventTrans _inventTrans)
    {
        InventSum   inventSum = this.inventOnhandFinancialCache(_inventTrans.inventDim()).inventSumWithoutAvailability(false);

        inventSum.checkInvalidFieldAccess(false);

        inventSum.addInventTransOnSum(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTransPosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>inventTransPosting</c> record for this inventory transaction.
    /// </summary>
    /// <param name="_transDate">
    ///    The current transaction date.
    /// </param>
    /// <param name="_voucher">
    ///    The current ledger voucher for the inventory cost posting.
    /// </param>
    protected void updateInventTransPosting(TransDate _transDate, Voucher _voucher)
    {
        if (returnMode && this. isMatchingInformationForReturnSpecified())
        {
            this.updateInventTransPostingReturn(_transDate, _voucher);
            return;
        }

        super(_transDate, _voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTransPostingReturn</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the <c>inventTransPosting</c> record for a return transaction.
    /// </summary>
    /// <param name="_transDate">
    ///    The current transaction date for the return transaction.
    /// </param>
    /// <param name="_voucher">
    ///    The current ledger voucher for the inventory cost posting of the return transaction.
    /// </param>
    protected void updateInventTransPostingReturn(
        TransDate       _transDate,
        Voucher         _voucher)
    {
        InventTransPosting  inventTransPosting;
        InventTrans         inventTrans;

        if (movement.createInventTransPosting())
        {
            // This is a packingSlip return, retrieve the posting information from the previous
            select firstonly inventTrans
            where inventTrans.InventTransOrigin == movement.inventTransOriginId()
               && inventTrans.PackingSlipId         == this.parmPackingSlipId()
               && inventTrans.VoucherPhysical       == this.parmVoucherMatched()
               && inventTrans.DatePhysical          == this.parmDateMatched();

            // When this method is called, the check if the matching information has been specified did already happen.
            // If the matching information was specified, the inventTrans record belonging to the voucherMatched and
            /// dateMatched had been found previously, so it needs to be found here as well.
            Debug::assert(inventTrans.RecId != 0);

            inventTransPosting = inventTrans.inventTransPostingPhysical();

            if (postingPhysical)
            {
                this.createInventTransPostingForReturn(inventTransPosting,
                                                       _voucher,
                                                       _transDate,
                                                       InventTransPostingType::Physical);
            }

            if (postingFinancial)
            {
                this.createInventTransPostingForReturn(inventTransPosting,
                                                       _voucher,
                                                       _transDate,
                                                       InventTransPostingType::Financial);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMovement</Name>
				<Source><![CDATA[
    protected void updateMovement()
    {
        // <GIN>
        boolean isStockTransfer_IN = false;
        // </GIN>

        if (updPhysical != physical && movement.mustBeUnitControlled())
        {
            if (updPhysical== 0)
            {
                updPhysicalUnit= 0;
            }
            else
            {
                updPhysicalUnit = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(movement.itemId(),
                                                                                                        movement.inventDimId(),
                                                                                                        updPhysical,
                                                                                                        movement.inventTableInvent().UnitId,
                                                                                                        movement.transUnitId(),
                                                                                                        NoYes::Yes);
            }
        }
        else
        {
            updPhysicalUnit= physicalUnit;
        }

        movement.addRemainFinancialUnit(updPhysicalUnit, updPhysical);
        movement.pdsCWAddRemainFinancial(cwUpdPhysical);

        if (!this.parmReturnMode())
        {
            if (movement.mustBeRemainControlled())
            {
                movement.addRemainPhysicalUnit(-updPhysicalUnit);

                // <GIN>
                if (movement.parmCompanyCountryRegion().isCountryRegionIN())
                {
                    if (movement.buffer() is InventTransferLine)
                    {
                        isStockTransfer_IN = InventTransferLine::findRecId(movement.buffer().RecId).inventTransferTable().TransferType_IN == TransferType_IN::StockTransfer;
                    }
                }

                if (movement.parmCompanyCountryRegion().isCountryRegionIN() && isStockTransfer_IN && updateParmUpdate)
                {
                    movement.addRemainPhysical(updateParmUpdate);
                }
                else
                {
                    movement.addRemainPhysical(-updPhysical);
                }
                if (movement.parmCompanyCountryRegion().isCountryRegionIN() && isStockTransfer_IN && cwUpdateParmUpdate)
                {
                    movement.pdsCWAddRemainPhysical(cwUpdateParmUpdate);
                }
                else
                {
                    movement.pdsCWAddRemainPhysical(-cwUpdPhysical);
                }
                // </GIN>
            }
        }

        if (!calledFromFinancial)
        {
            movement.updateDoBuffer();
        }

        if (movement.mustBeRemainControlled())
        {
            if (this.parmPhysicalReduction() != InventPhysicalReduction::ReduceAndClose)
            {
                remainPhysicalUnit += physicalUnit- updPhysicalUnit;
                remainPhysical     += physical    - updPhysical;
                cwRemainPhysical   += cwPhysical  - cwUpdPhysical;
            }

            if (movement.parmCompanyCountryRegion().isCountryRegionRU()
                && inventDimCriteria.InventOwnerId_RU)
            {
                movement.updateDoBuffer();
            }
            else

            if (remainPhysical != movement.remainPhysical() || remainPhysicalUnit != movement.remainPhysicalUnit())
            {
                if (calledFromFinancial)
                {
                    movement.updateDoBuffer();
                }
                movement.setRemainPhysicalUnit(remainPhysicalUnit);
                movement.setRemainPhysical(remainPhysical);
                movement.pdsCWSetRemainPhysical(cwRemainPhysical);

                movement.updateBuffer(!preventAutoReservation);
            }

            movement.pdsAdjustIntercompanyRemainInventoryQty();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the inventory transaction originator for the movement.
    /// </summary>
    protected void updateInventTransOrigin()
    {
        InventTransOrigin inventTransOrigin = InventTransOrigin::find(movement.inventTransOriginId(), true);

        if (!inventTransOrigin)
        {
            throw error("@SYS18738");
        }

        if (inventTransOrigin.IsExcludedFromInventoryValue != movement.mustExcludeFromInventoryValue())
        {
            inventTransOrigin.IsExcludedFromInventoryValue = movement.mustExcludeFromInventoryValue();
            inventTransOrigin.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    public void updateNow(LedgerVoucher _ledgerVoucher)
    {
        using (var telemetryTask = new InventUpdateInstrumentationTask(this))
        {
            InventInventoryDataServiceSoftReservationHelper::checkSoftReservation(movement);

            ttsbegin;

            using (var cache = movement.constructRecordViewCache())
            {
                movement.parmExchangeRateDate(this.parmExchangeRateDate());

                if (!_ledgerVoucher)
                {
                    throw error(strFmt("@SYS19386",funcName()));
                }

                if (!this.checkUpdateMovement(_ledgerVoucher.lastTransDate()))
                {
                    throw error("@SYS18447");
                }

                if (estimated)
                {
                    this.updateEstimated(estimated, estimatedUnit, cwEstimated);
                }

                if (movement.mustUpdateInventTransOrigin())
                {
                    this.updateInventTransOrigin();
                }

                if (adjustWMSLocationLoad)
                {
                    wmsLocationLoadCreateManager = WMSLocationLoadCreateManager::construct();
                }

                movement.calculateIndirectCost(_ledgerVoucher, physical, this.parmCostInputAmount());

                // Inventory status blocking synchronization is not required when ordered reservations are allowed
                // because ordered reservations for status blockings will be automatically promoted to physical reservations
                // during the physical update anyways
                InventBlockingInventStatusSync  inventBlockingInventStatusSync;

                boolean skipSyncBlocking = this.skipInventoryBlockingStatusSync();

                if (physical > 0)
                {
                    if (!skipSyncBlocking)
                    {
                        inventBlockingInventStatusSync = InventBlockingInventStatusSync::newStandardHandlingQuantities(movement, physical, cwPhysical, movement.inventdim(), inventDimCriteria ? inventDimCriteria : movement.inventdim());
                        inventBlockingInventStatusSync.preSync();
                    }
                    if (returnMode)
                    {
                        this.updatePhysicalReturnedReceipt(_ledgerVoucher);
                    }
                    else
                    {
                        this.updatePhysicalReceipt(_ledgerVoucher);
                    }
                }
                else if (physical < 0)
                {
                    if (!skipSyncBlocking)
                    {
                        inventBlockingInventStatusSync = this.createInventBlockingInventStatusSync();
                        inventBlockingInventStatusSync.preSync();
                    }
                    if (returnMode)
                    {
                        this.updatePhysicalReturnedIssue(_ledgerVoucher);
                    }
                    else
                    {
                        this.updatePhysicalIssue(_ledgerVoucher);
                    }
                }

                movement.processLedgerPhysicalAmountList(_ledgerVoucher);

                this.updateInventTransPosting(_ledgerVoucher.lastTransDate(), _ledgerVoucher.lastVoucher());

                if (physical && !skipSyncBlocking)
                {
                    inventBlockingInventStatusSync.postSync();
                }

                if (movement.isPrimaryMovement())
                {
                    this.updateMovement();
                }

                if (movement.mustDoAutoLossProfitPhysical())
                {
                    movement.updateAutoPhysical(this,_ledgerVoucher);
                }

                if (movement.mustDoProjPhysicalPosting())
                {
                    ProjPost::physicalInventPost(this, _ledgerVoucher);
                }

                if (adjustWMSLocationLoad)
                {
                    wmsLocationLoadCreateManager.insertRecords();
                }

                movement.updatePeggingRequirements();

                if (inventCostOnhandCache)
                {
                    inventCostOnhandCache.clearCache(movement);
                }
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventBlockingInventStatusSync</Name>
				<Source><![CDATA[
    private InventBlockingInventStatusSync createInventBlockingInventStatusSync()
    {
        if (returnMode && movement.shouldSyncInventoryBlockingStatusTransType())
        {
            InventDim fromInventDim = inventDimCriteria ? inventDimCriteria : movement.inventdim();
            InventDim toInventDim = movement.inventdim();

            if (WhsInventStatus::find(toInventDim.InventStatusId).InventStatusBlocking == NoYes::No)
            {
                WhsInventStatusId syncInventoryStatusId = this.findReturnInvenStatusIdFromInventTrans();
                                
                if (WhsInventStatus::find(syncInventoryStatusId).InventStatusBlocking == NoYes::Yes)
                {
                    fromInventDim.InventStatusId = syncInventoryStatusId;
                    fromInventDim = InventDim::findOrCreate(fromInventDim);

                    toInventDim.InventStatusId = syncInventoryStatusId;
                    toInventDim = InventDim::findOrCreate(toInventDim);

                    if (WHSInventoryBlockingStatusSyncReturnOrderFlight::instance().isEnabled())
                    {
                        movement.parmInventBlockingStatusSyncInventDim(fromInventDim);
                    }
                    else
                    {
                        InventMov_Purch purchaseMovement = movement as InventMov_Purch;
                        if (purchaseMovement)
                        {
                            purchaseMovement.parmInventBlockingStatusSyncInventDim(fromInventDim);
                        }
                    }
                }
            }

            return InventBlockingInventStatusSync::newStandardReturnHandlingQuantities(movement, physical, cwPhysical, fromInventDim, toInventDim, true);
        }

        return InventBlockingInventStatusSync::newStandardHandlingQuantities(movement, physical, cwPhysical, inventDimCriteria ? inventDimCriteria : movement.inventdim(), movement.inventdim(), true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findReturnInvenStatusIdFromInventTrans</Name>
				<Source><![CDATA[
    private WhsInventStatusId findReturnInvenStatusIdFromInventTrans()
    {
        Integer returnStatus = returnMode;

        WhsInventStatusId inventStatusSync;

        while (returnStatus < 3)
        {
            StatusReceipt statusReceipt = (returnMode == 1 ? StatusReceipt::Received : StatusReceipt::Purchased);

            InventTrans inventTrans;

            while select inventTrans
                order by ValueOpen desc, MarkingRefInventTransOrigin asc, InventDimId desc
                where inventTrans.InventTransOrigin     == movement.inventTransOriginId()
                    && inventTrans.StatusIssue          == StatusIssue::None
                    && inventTrans.StatusReceipt        == statusReceipt
                    && inventTrans.PackingSlipReturned  == 0
                    && inventTrans.InventTransOrigin    != inventTrans.ReturnInventTransOrigin
                    && ((inventTrans.PackingSlipId      == this.parmPackingSlipId()
                        && inventTrans.VoucherPhysical  == this.parmVoucherMatched()
                        && inventTrans.DatePhysical     == this.parmDateMatched())
                        || !this.isMatchingInformationForReturnSpecified())
                    && (inventTrans.VoucherPhysical  == this.parmTransferOrderVoucherMatched()
                        || !this.parmTransferOrderVoucherMatched())  
            {
                InventDim inventDim = inventTrans.inventDim();

                if (inventStatusSync
                    && inventStatusSync != inventDim.InventStatusId)
                {
                    return '';
                }

                inventStatusSync = inventDim.InventStatusId;
            }

            returnStatus+= 1;
        }

        return inventStatusSync;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipInventoryBlockingStatusSync</Name>
				<Source><![CDATA[
    private boolean skipInventoryBlockingStatusSync()
    {
        boolean skipSyncBlocking = !WHSInventEnabled::exist(movement.itemId()) || InventParameters::find().ReserveOnOrdered;

        if (physical < 0
            && returnMode 
            && movement.shouldSyncInventoryBlockingStatusTransType()
            && WHSInventEnabled::exist(movement.itemId()))
        {
            return false;
        }

        return skipSyncBlocking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreatePackingSlipBatchDispositionCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a packing slip should be created for a batch dispotion check.
    /// </summary>
    /// <param name = "_inventBatchId">The <c>InventBatchID</c> value of the batch to check.</param>
    /// <param name = "_itemId">The related <c>ItemId</c> value.</param>
    /// <param name = "_isItemBatchActivated">A boolean indicating if the item is batch activated.</param>
    /// <returns>true if a packing slip should be created; otherwise, false.</returns>
    protected boolean shouldCreatePackingSlipBatchDispositionCheck(InventBatchID _inventBatchId, ItemId _itemId, boolean _isItemBatchActivated)
    {
        return  _inventBatchId
                && #PdsEnabled
                && _isItemBatchActivated
                && InventBatch::pdsCheckUnavailable(_inventBatchId, _itemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCancelUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the <c>InventTrans</c> update should be canceled.
    /// </summary>
    /// <param name = "_inventDim">The related <c>InventDim</c> record.</param>
    /// <param name = "_inventTrans">The <c>InventTrans</c> record to be updated.</param>
    /// <param name = "_inventTable">The related <c>InventTable</c> record.</param>
    /// <returns>true if the update should be canceled; otherwise, false.</returns>
    protected boolean shouldCancelUpdate(InventDim _inventDim, InventTrans _inventTrans, InventTable _inventTable)
    {
        if (this.shouldCreatePackingSlipBatchDispositionCheck(_inventDim.InventBatchId, _inventTrans.ItemId, _inventTable.isItemBatchActivated()))
        {
            PdsBatchDispCheck_PackSlip pdsDispCheckPack = PdsBatchDispCheck_PackSlip::construct();
            if (!pdsDispCheckPack.validateTransCheck(_inventTrans))
            {
                return true;
            }
        }

        if (!_inventTable.checkRefInventTrans(_inventTrans)
            || !movement.checkDimPhysical(_inventTrans.Qty, _inventDim, true))
        {
            return true;
        }

        if (   movement.parmCompanyCountryRegion().isCountryRegionRU()
            && movement.inventTable().AlcoholProductionTypeId_RU
            && !EGAISHelper_RU::validateInventTrans(_inventTrans))
        {
            return true;
        }

        InventItemOrderSetupMap inventItemOrderSetupMap = movement.inventItemOrderSetupMap(_inventDim.InventDimId);

        if (!inventItemOrderSetupMap.checkInventLocationId(_inventDim.InventLocationId,!movement.canBeOnAllInventLocations(), true, _inventTable)
            ||!inventItemOrderSetupMap.checkInventSiteId(_inventDim.InventSiteId,!movement.canBeOnAllInventSites(), _inventTable))
        {
            return true;
        }

        if (_inventTrans.StatusIssue > StatusIssue::Picked
            && !movement.checkCountingLocks(_inventDim))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePhysicalQtysBasedOnInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the physical quantities based on the <c>InventTrans</c> record's quantities.
    /// </summary>
    /// <param name = "_inventTrans">The <c>InventTrans</c> record.</param>
    /// <param name = "_updCostAmountInvent">The updated <c>CostAmount</c> value.</param>
    /// <param name = "_updPhysical">The updated <c>InventQty</c> value.</param>
    /// <param name = "_cwUpdPhysical">The updated <c>PdsCWInventQty</c> value.</param>
    /// <returns>A container holding the [updCostAmountInvent, updPhysical, cwUpdPhysical] values.</returns>
    protected container updatePhysicalQtysBasedOnInventTrans(InventTrans _inventTrans, CostAmount _updCostAmountInvent, InventQty _updPhysical, PdsCWInventQty _cwUpdPhysical)
    {
        _updCostAmountInvent  += _inventTrans.CostAmountPhysical;
        _updPhysical          += _inventTrans.Qty;
        _cwUpdPhysical        += _inventTrans.PdsCWQty;

        return [_updCostAmountInvent, _updPhysical, _cwUpdPhysical];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePhysicalIssue</Name>
				<Source><![CDATA[
    protected  void updatePhysicalIssue(LedgerVoucher _ledgerVoucher)
    {
        this.updateReportFinished(_ledgerVoucher.lastTransDate());
        this.initInventTransToIssueListByStatusIssue();
        this.initializeInventCostFramework(_ledgerVoucher);

        Set set = new Set(Types::String);

        InventTable inventTable = movement.inventTable();
        InventTrans inventTrans;

        InventQty   issueQty, qtyNow, addQty = physical;
        PdsCWInventQty cwQtyNow, cwAddQty = cwPhysical;

        while (this.getNextInventTransToIssue(inventTrans))
        {
            if (movement.canInventTransBePhysicalUpdated(inventTrans)
                && (!pickingRouteId || pickingRouteId == inventTrans.PickingRouteID))
            {

                InventDim inventDim = inventTrans.inventDim();

                if (this.shouldCancelUpdate(inventDim, inventTrans, inventTable))
                {
                    throw error("@SYS18447");
                }

                qtyNow = this.transactionIssueQuantity(inventTrans, addQty);
                
                //add the check for quantity with the custom list
                if (this.parmCustomInventTransListInitialized())
                {
                    // Catch weight is not supported in the scenario where custom invent trans list is used.
                    issueQty += qtyNow;
                } 
                else
                {
                    issueQty += inventTrans.Qty;
                    cwQtyNow = (cwAddQty <= inventTrans.PdsCWQty ? inventTrans.PdsCWQty : cwAddQty);
                }
                
                InventOnhand inventOnhand = InventOnhand::newPhysicalUpdate(movement, inventDim);

                // If the issue movement allows blocking to be updated, we must remove the blocking prior to checking for availability.
                if (inventTrans.StatusIssue == StatusIssue::OnOrder)
                {
                    InventBlockingInventStatusSync::newStandardHandlingQuantities(movement, qtyNow, cwQtyNow, inventDim, inventDim, true).preSync();
                }

                [qtyNow, cwQtyNow] = this.updatePhysicalReduction(inventTrans, inventOnhand, qtyNow, cwQtyNow);

                if (qtyNow)
                {
                    [addQty, cwAddQty] = this.updateAddedQtyBasedOnPhysicalQty(inventTrans, qtyNow, cwQtyNow, addQty, cwAddQty);

                    this.updateMovementBasedOnPhysicalQuantity(_ledgerVoucher, inventTrans, inventDim, inventOnhand);

                    if (!skipCWAutoAdjust && movement.pdsCWItem() && !set.in(inventDim.InventDimId))
                    {
                        set.add(inventDim.InventDimId);
                    }

                    [updCostAmountInvent, updPhysical, cwUpdPhysical] = this.updatePhysicalQtysBasedOnInventTrans(inventTrans, updCostAmountInvent, updPhysical, cwUpdPhysical);

                    if (!addQty)
                    {
                        break;
                    }
                }
            }
        }

        this.verifyCustomInventTransUpdate(addQty);
        this.updateAutoAdjustForInventDimIds(_ledgerVoucher, set);
        this.displayErrorsIfIssueQuantityGreaterThanPhysical(issueQty);
        this.registerTrackingDimension();
        this.createCostTransactions(_ledgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>movementCaseStatusToFrom</Name>
				<Source><![CDATA[
    private container movementCaseStatusToFrom()
    {
        StatusIssue caseStatusIssueTo, caseStatusIssueFrom;

        if (movement.mustBePicked())
        {
            caseStatusIssueFrom = StatusIssue::Picked;
            caseStatusIssueTo = StatusIssue::Picked;
        }
        else
        {
            caseStatusIssueFrom  = StatusIssue::Picked;
            caseStatusIssueTo = StatusIssue::OnOrder;
        }

        return [caseStatusIssueTo, caseStatusIssueFrom];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransToIssueListByStatusIssue</Name>
				<Source><![CDATA[
    private void initInventTransToIssueListByStatusIssue()
    {
        StatusIssue caseStatusIssueTo, caseStatusIssueFrom;
        [caseStatusIssueTo, caseStatusIssueFrom] = this.movementCaseStatusToFrom();

        this.initInventTransToIssueList(caseStatusIssueFrom,
                                        caseStatusIssueTo,
                                        inventDimCriteria.InventDimId && inventDimParmCriteria.isAllFlagYes() ? inventDimCriteria.InventDimId : '',
                                        inventDimCriteria, inventDimParmCriteria, movement.transChildType(), movement.transChildRefId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventCostFramework</Name>
				<Source><![CDATA[
    private void initializeInventCostFramework(LedgerVoucher _ledgerVoucher)
    {
        if (movement.mustCreateCostTransactions())
        {
            movement.inventModelType().initCostTransVariance(movement, _ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate(), InventCostTransState::Physical);

            if (movement.parmCompanyCountryRegion().isCountryRegionRU())
            {
                movement.inventModelTypeSecCur_RU().initCostTransVariance(movement, _ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate(), InventCostTransState::Physical);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSkipUpdatePhysicalReduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the physical reduction of the transaction should be skipped from updating.
    /// </summary>
    /// <param name = "_inventTrans">An <c>InventTrans</c>.</param>
    /// <returns>true if the physical reduction of the transaction should be skipped from updating; otherwise, false.</returns>
    protected boolean mustSkipUpdatePhysicalReduction(InventTrans _inventTrans)
    {
        return (_inventTrans.StatusIssue == StatusIssue::ReservPhysical
                || _inventTrans.StatusIssue == StatusIssue::Picked);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePhysicalReduction</Name>
				<Source><![CDATA[
    private container updatePhysicalReduction(InventTrans _inventTrans, InventOnhand _inventOnhand, InventQty _qtyNow, PdsCWInventQty _cwQtyNow)
    {
        if (this.mustSkipUpdatePhysicalReduction(_inventTrans))
        {
            return [_qtyNow, _cwQtyNow];
        }

        if (this.parmPhysicalReduction() != InventPhysicalReduction::None)
        {
            if (!allowNegativePhysical)
            {
                if (movement.parmCompanyCountryRegion().isCountryRegionRU() && _inventOnhand.availPhysical() <= 0)
                {
                    throw error(strFmt("@SCM:CannotPickWithEnoughInventory", real2double(-_qtyNow).ToString(), real2double(_inventOnhand.availPhysical()).ToString(), _inventTrans.ItemId));
                }

                _qtyNow  = 0 - min(-_qtyNow, max(_inventOnhand.availPhysical(),0) );
                _cwQtyNow = 0 - min(-_cwQtyNow, max(_inventOnhand.pdsCWAvailPhysical(), 0)); 
            }
        }
        else if (movement.mustDoPhysicalOnHandCheck() && !_inventOnhand.checkItemDraw(_qtyNow, allowNegativePhysical, true, _cwQtyNow))
        {
            throw error("@SYS18447");
        }

        return [_qtyNow, _cwQtyNow];
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerTrackingDimension</Name>
				<Source><![CDATA[
    private void registerTrackingDimension()
    {
        if (movement.mustRegisterTrackingDimension())
        {
            if (trackingRegisterTransPhysicalQty)
            {
                this.updateTrackingRegisterPhysically(-trackingRegisterTransPhysicalQty);
            }
            else
            {
                this.updateTrackingRegisterPhysically(updPhysical);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCostTransactions</Name>
				<Source><![CDATA[
    private void createCostTransactions(LedgerVoucher _ledgerVoucher)
    {
        if (movement.mustCreateCostTransactions())
        {
            if (movement.parmCompanyCountryRegion().isCountryRegionRU())
            {
                boolean costOK = movement.inventModelType().finalizeCostTransVariance(movement, _ledgerVoucher, InventCostTransState::Physical);
                movement.inventModelTypeSecCur_RU().finalizeCostTransVarianceSecCur_RU(movement, _ledgerVoucher, InventCostTransState::Physical, costOK);
            }
            else
            {
                // Push the created variance to the inventCostUpdate class
                movement.inventModelType().finalizeCostTransVariance(movement, _ledgerVoucher, InventCostTransState::Physical);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoAdjustForInventDimIds</Name>
				<Source><![CDATA[
    private void updateAutoAdjustForInventDimIds(LedgerVoucher _ledgerVoucher, Set _inventDimIdSet)
    {
        SetEnumerator enumerator = _inventDimIdSet.getEnumerator();

        while (enumerator.moveNext())
        {
            this.pdsCWUpdateAutoAdjust(allowNegativePhysical, _ledgerVoucher, enumerator.current());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayErrorsIfIssueQuantityGreaterThanPhysical</Name>
				<Source><![CDATA[
    private void displayErrorsIfIssueQuantityGreaterThanPhysical(InventQty _issueQty)
    {
        if (_issueQty <= physical)
        {
            return;
        }

        error("@SYS13203");

        this.displayWrongIssueQuantityMessages();

        this.throwWrongIssueQuantityError();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayWrongIssueQuantityMessages</Name>
				<Source><![CDATA[
	private void displayWrongIssueQuantityMessages()
    {
        QueryRun queryRun = new  QueryRun(this.buildQueryForWrongIssueQuantityMessages());
        while (queryRun.next())
        {
            InventTrans inventTrans = queryRun.get(tableNum(InventTrans));

            if (inventTrans.Qty == 0)
            {
                continue;
            }

            if (inventTrans.TransChildType == InventTransChildType::None)
            {
                info(strFmt("@SYS66069", abs(inventTrans.Qty), movement.transType(), movement.transRefId()));
            }
            else
            {
                info(strFmt("@SYS66069", abs(inventTrans.Qty), inventTrans.TransChildType, inventTrans.TransChildRefId));
            }
        }
	}

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryForWrongIssueQuantityMessages</Name>
				<Source><![CDATA[
	/// <summary>
    /// Builds the query to use for displaying info messages when the issue quantity is wrong.
    /// </summary>
    /// <returns>The built <c>Query</c> object.</returns>
    protected Query buildQueryForWrongIssueQuantityMessages()
    {
        StatusIssue caseStatusIssueTo, caseStatusIssueFrom;
        [caseStatusIssueTo, caseStatusIssueFrom] = this.movementCaseStatusToFrom();

        Query query = new Query();
        QueryBuildDataSource qbdsInventTrans = query.addDataSource(tableNum(InventTrans));
        qbdsInventTrans.fields().clearFieldList();
        qbdsInventTrans.addSelectionField(fieldNum(InventTrans, Qty), SelectionField::Sum);
        qbdsInventTrans.fields().addField(fieldNum(InventTrans, TransChildType));
        qbdsInventTrans.fields().addField(fieldNum(InventTrans, TransChildRefId));

        qbdsInventTrans.addGroupByField(fieldNum(InventTrans, InventTransOrigin));
        qbdsInventTrans.addGroupByField(fieldNum(InventTrans, StatusReceipt));
        qbdsInventTrans.addGroupByField(fieldNum(InventTrans, StatusIssue));
        qbdsInventTrans.addGroupByField(fieldNum(InventTrans, TransChildType));
        qbdsInventTrans.addGroupByField(fieldNum(InventTrans, TransChildRefId));


        qbdsInventTrans.addRange(fieldNum(InventTrans, InventTransOrigin)).value(queryValue(movement.inventTransOriginId()));
        qbdsInventTrans.addRange(fieldNum(InventTrans, StatusReceipt)).value(queryValue(StatusReceipt::None));
        qbdsInventTrans.addRange(fieldNum(InventTrans, StatusIssue)).value(queryRange(caseStatusIssueFrom, caseStatusIssueTo));
        qbdsInventTrans.addRange(fieldNum(InventTrans, TransChildType)).value(SysQuery::valueNot(movement.transChildType()));

        return query;
	}

]]></Source>
			</Method>
			<Method>
				<Name>throwWrongIssueQuantityError</Name>
				<Source><![CDATA[
	/// <summary>
    /// Throws an error when the issue quantity is wrong.
    /// </summary>
    protected void throwWrongIssueQuantityError()
    {
        this.throwWrongIssueQuantityErrorBasedOnMovement();

		throw error(strFmt("@SYS56627",StatusIssue::OnOrder,StatusIssue::ReservOrdered,StatusIssue::ReservPhysical,StatusIssue::Picked));
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwWrongIssueQuantityErrorBasedOnMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Throws an error based on the movement when the issue quantity is wrong.
    /// </summary>
	protected void throwWrongIssueQuantityErrorBasedOnMovement()
    {
        if (movement.mustBePicked())
        {
            warning("@SCM:InventMovementMustBePicked");
            Info("@SCM:InventOrderPickingGeneralGuide");
            throw error(strFmt("@SYS54028",StatusIssue::Picked));
        }
	}

]]></Source>
			</Method>
			<Method>
				<Name>updateAddedQtyBasedOnPhysicalQty</Name>
				<Source><![CDATA[
    private container updateAddedQtyBasedOnPhysicalQty(InventTrans _inventTrans, InventQty _qtyNow, PdsCWInventQty _cwQtyNow, InventQty _addQty, PdsCWInventQty _cwAddQty)
    {
        if (_qtyNow > _inventTrans.Qty)
        {
            _inventTrans.updateSplit(_qtyNow, _cwQtyNow);
        }

        _addQty -= _inventTrans.Qty;
        _cwAddQty -= _inventTrans.PdsCWQty;

        return [_addQty, _cwAddQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMovementBasedOnPhysicalQuantity</Name>
				<Source><![CDATA[
	/// <summary>
    /// Updates the state of the <c>InventMovement</c> object based on the specified <c>InventTrans</c>.
    /// </summary>
    /// <param name="_ledgerVoucher">The <c>LedgerVoucher</c> record that is used for the update.</param>
    /// <param name = "_inventTrans">The <c>InventTrans</c> record.</param>
    /// <param name = "_inventDim">The related <c>InventDim</c> record.</param>
    /// <param name = "_inventOnhand">The inventory on-hand information.</param>
    protected void updateMovementBasedOnPhysicalQuantity(LedgerVoucher _ledgerVoucher, InventTrans _inventTrans, InventDim _inventDim, InventOnhand _inventOnhand)
    {
        movement.initInventTransPhysical(_inventTrans, _ledgerVoucher.lastTransDate(), packingSlipId);
        movement.transIdSum().setInventTransStatus(_inventTrans, StatusReceipt::None, StatusIssue::Deducted);

        // Pass the on-hand to InventMovement.estimatedFinancualValue(), which caches the cost for settled models
        InventOnhand inventOnhandFinancialCache = movement.inventModelType().cacheFinancialOnhandOnPhysicalUpdate() ? this.inventOnhandFinancialCache(_inventTrans.inventDim()) : null;
        movement.updateLedgerPhysical(_ledgerVoucher, _inventTrans, this, inventOnhandFinancialCache ? inventOnhandFinancialCache : _inventOnhand);

        this.createCostTranscation(_ledgerVoucher, _inventTrans, inventOnhandFinancialCache);
        this.removeInventTransChildRef(_inventTrans);
        this.updateBasedOnOriginalInventTrans(_inventTrans, _inventDim);
        
        if (movement.parmCompanyCountryRegion().isCountryRegionIN())
        {
            container qtyCon = movement.physicalUpdateIssueRemainQty_IN(_inventTrans);
            updateParmUpdate += conPeek(qtyCon, 1);
            cwUpdateParmUpdate += conPeek(qtyCon, 2);
        }

        if (movement.inventModelType().cacheFinancialOnhandOnPhysicalUpdate())
        {
            this.updateInventOnhandFinancialCache(_inventTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeInventTransChildRef</Name>
				<Source><![CDATA[
    private void removeInventTransChildRef(InventTrans _inventTrans)
    {
        _inventTrans.TransChildType = InventTransChildType::None;
        _inventTrans.TransChildRefId = '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCostTranscation</Name>
				<Source><![CDATA[
    private void createCostTranscation(LedgerVoucher _ledgerVoucher, InventTrans _inventTrans, InventOnhand _inventOnhandFinancialCache)
    {
        if (movement.mustCreateCostTransactions())
        {
            // Add each inventTrans record to the inventCost framework
            movement.inventModelType().addCostTransVariance(_inventTrans, movement, _ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate(), InventCostTransState::Physical);
            movement.inventModelType().postUpdatePhysical(movement, _ledgerVoucher, _inventTrans, _inventOnhandFinancialCache);

            if (movement.parmCompanyCountryRegion().isCountryRegionRU())
            {
                movement.inventModelTypeSecCur_RU().addCostTransVariance(_inventTrans, movement, _ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate(), InventCostTransState::Physical);
                movement.inventModelTypeSecCur_RU().postUpdatePhysical(movement, _ledgerVoucher, _inventTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBasedOnOriginalInventTrans</Name>
				<Source><![CDATA[
    private void updateBasedOnOriginalInventTrans(InventTrans _inventTrans, InventDim _inventDim)
    {
        InventTrans origInventTrans = _inventTrans.orig();

        movement.updateSerialNumIssue(_inventTrans, origInventTrans, _inventDim);

        this.raiseOnHandChangingOnPhysicalStatusUpd(_inventTrans, origInventTrans, _inventDim);
        _inventTrans.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePhysicalReceiptTrans</Name>
				<Source><![CDATA[
    protected container updatePhysicalReceiptTrans(
            InventTrans         _inventTrans,
            InventQty           _addQty,
            PdsCWInventQty      _cwAddQty,
            LedgerVoucher       _ledgerVoucher,
            boolean             _disableCacheForBufferCheck,
            set                 _setInventDimId)
    {
        if (_addQty < _inventTrans.Qty)
        {
            _inventTrans.updateSplit(_addQty, _cwAddQty);
        }

        _addQty   -= _inventTrans.Qty;
        _cwAddQty -= _inventTrans.PdsCWQty;

        movement.initInventTransPhysical(_inventTrans,_ledgerVoucher.lastTransDate(), packingSlipId);
        movement.transIdSum().setInventTransStatus(_inventTrans, StatusReceipt::Received, StatusIssue::None);

        if (movement.pdsCWItem() && this.parmCostInputAmount())
        {
            this.parmCostInputAmount().setCWLastTransBoxAmount(_cwAddQty == 0, _inventTrans.Qty);// this transaction ends the loop
        }

        movement.updateLedgerPhysical(_ledgerVoucher, _inventTrans, this, null);

        if (movement.mustCreateCostTransactions())
        {
            // Add each inventTrans record to the inventCost framework
            movement.inventModelType().addCostTransVariance(_inventTrans, movement, _ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate(), InventCostTransState::Physical,movement.isReturned(_inventTrans.Qty));
            movement.inventModelType().postUpdatePhysical(movement, _ledgerVoucher, _inventTrans, movement.inventModelType().cacheFinancialOnhandOnPhysicalUpdate()
                                                                                                ? this.inventOnhandFinancialCache(_inventTrans.inventDim())
                                                                                                : null);

            if (movement.parmCompanyCountryRegion().isCountryRegionRU())
            {
                movement.inventModelTypeSecCur_RU().addCostTransVariance(_inventTrans, movement, _ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate(), InventCostTransState::Physical,movement.isReturned(_inventTrans.Qty));
                movement.inventModelTypeSecCur_RU().postUpdatePhysical(movement, _ledgerVoucher, _inventTrans);
            }
        }

        if (movement.parmCompanyCountryRegion().isCountryRegionIN())
        {
            container qtyCon = movement.physicalUpdateReceiptRemainQty_IN(_inventTrans);
            updateParmUpdate += conPeek(qtyCon, 1);
            cwUpdateParmUpdate += conPeek(qtyCon, 2);
        }

        updPhysical += _inventTrans.Qty;
        cwUpdPhysical += _inventTrans.PdsCWQty;

        _inventTrans.TransChildType   = InventTransChildType::None;
        _inventTrans.TransChildRefId  = '';

        InventDim inventDim = _inventTrans.inventDim();
        InventTrans origInventTrans = _inventTrans.orig();

        this.raiseOnHandChangingOnPhysicalStatusUpd(_inventTrans, origInventTrans, inventDim);

        if (! movement.checkDimPhysical(_inventTrans.Qty, inventDim, false, true))
        {
            throw error("@SYS18447");
        }

        if (origInventTrans.StatusReceipt != StatusReceipt::Registered)
        {
            //this can update the dimensions on the inventtrans if auto numbering is used
            this.writeInventTransAutoDim(_inventTrans, origInventTrans, true);

            if (!movement.checkCountingLocks(_inventTrans.inventDim()))
            {
                throw error("@SYS18447");
            }
        }

        movement.updateInheritedBatchesPostRegistration(_inventTrans);

        if (! movement.checkDimPhysical(_inventTrans.Qty, _inventTrans.inventDim(), true, true))
        {
            throw error("@SYS18447");
        }

        _inventTrans.update();

        if (movement.inventModelType().cacheFinancialOnhandOnPhysicalUpdate())
        {
            this.updateInventOnhandFinancialCache(_inventTrans);
        }

        if (!this.parmSkipInventTransSumUp())
        {
            _inventTrans.updateSumUp(NoYes::No, _disableCacheForBufferCheck);
        }

        if (!skipCWAutoAdjust && movement.pdsCWItem())
        {
            if (!_setInventDimId.in(_inventTrans.InventDimId))
            {
                _setInventDimId.add(_inventTrans.InventDimId);
            }
        }

        return [_addQty, _cwAddQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePhysicalReceipt</Name>
				<Source><![CDATA[
    protected void updatePhysicalReceipt(LedgerVoucher _ledgerVoucher)
    {
        InventTrans             inventTrans;
        InventQty               addQty         = physical;
        PdsCWInventQty          cwAddQty       = cwPhysical;
        Set                     set;
        StatusReceipt           fromStatusReceipt;
        StatusReceipt           toStatusReceipt;
        boolean                 disableCacheForBufferCheck;
        boolean                 onlySearchForRegistered = this.parmOnlyUpdateRegistered() || movement.mustBeRegistered();

        if (onlySearchForRegistered)
        {
            fromStatusReceipt = StatusReceipt::Registered;
            toStatusReceipt   = StatusReceipt::Registered;
        }
        else
        {
            fromStatusReceipt = StatusReceipt::Registered;
            toStatusReceipt   = StatusReceipt::Ordered;
        }

        this.initInventTransToReceiveList(
                        fromStatusReceipt,
                        toStatusReceipt,
                        inventDimCriteria.InventDimId,
                        inventDimCriteria,
                        inventDimParmCriteria,
                        movement.transChildType(),
                        movement.transChildRefId(),
                        addQty);

        set = new Set(Types::String);

        if (movement.mustCreateCostTransactions())
        {
            // Initialize the inventCost framework
            movement.inventModelType().initCostTransVariance(movement, _ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate(), InventCostTransState::Physical, movement.isReturned(physical));

            disableCacheForBufferCheck = this.disableCacheForBufferCheck();
            if (movement.parmCompanyCountryRegion().isCountryRegionRU())
            {
                movement.inventModelTypeSecCur_RU().initCostTransVariance(movement, _ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate(), InventCostTransState::Physical, movement.isReturned(physical));
            }
        }

        while (this.getNextInventTransToReceive(inventTrans))
        {            
            if (this.skipInventTransForDifferentLoad(inventTrans))
            {
                continue;
            }

            if (this.skipInventTransForDifferentSites(InventTrans))
            {
                continue;
            }

            if (!movement.inventTable().checkRefInventTrans(inventTrans))
            {
                throw error("@SYS18447");
            }

            InventItemOrderSetupMap inventItemOrderSetupMap = movement.inventItemOrderSetupMap(inventTrans.inventDim().InventDimId);

            if (!inventItemOrderSetupMap.checkInventLocationId(inventTrans.inventDim().InventLocationId,!movement.canBeOnAllInventLocations())
            ||  !inventItemOrderSetupMap.checkInventSiteId(inventTrans.inventDim().InventSiteId,!movement.canBeOnAllInventSites()))
            {
                throw error("@SYS18447");
            }

            InventTransAutoNumberHandler inventTransAutoNumberHandler;

            //if the movement is whsEnabled we need to do auto number assignment as part of the actual update and not after the trans is updated to Received since it can then have a hole in the dimensions
            if (movement.isItemWHSEnabled() && inventTrans.isUpdatedEstimated())
            {
                inventTransAutoNumberHandler = InventTransAutoNumberHandler::newParameters(movement, inventTrans, inventTrans.inventDim(), true);
            }

            InventQty updateNowQuantity = this.transactionReceiptQuantity(inventTrans, addQty);

            if (this.parmCustomInventTransListInitialized() && (updateNowQuantity < inventTrans.Qty))
            {
                inventTrans.updateSplit(updateNowQuantity, cwAddQty);
            }

            if (inventTransAutoNumberHandler && inventTransAutoNumberHandler.useAutoNumbering())
            {
                inventTrans.DatePhysical = _ledgerVoucher.lastTransDate();
                ListEnumerator le = inventTransAutoNumberHandler.prepareInventTransForAutoNumberingTrackingDimensions(updateNowQuantity, cwAddQty).getEnumerator();

                while (le.moveNext())
                {
                    InventDimId             inventDimIdAutoNumber;
                    RecId                   inventTransRecId;

                    [inventTransRecId, inventDimIdAutoNumber] = le.current();
                    inventTrans = inventTrans::findRecId(inventTransRecId, true);
                    inventTrans.inventDimId = inventDimIdAutoNumber;
                    inventTrans.update();

                    [addQty, cwAddQty] = this.updatePhysicalReceiptTrans(inventTrans, addQty, cwAddQty, _ledgerVoucher, disableCacheForBufferCheck, set);

                    if (!addQty)
                    {
                        break;
                    }
                }
            }
            else
            {
                [addQty, cwAddQty] = this.updatePhysicalReceiptTrans(inventTrans, addQty, cwAddQty, _ledgerVoucher, disableCacheForBufferCheck, set);
            }

            if (!addQty)
            {
                break;
            }
        }

        SetEnumerator enum = set.getEnumerator();

        while (enum.moveNext())
        {
            InventDimId inventDimId = enum.current();

            this.pdsCWUpdateAutoAdjust(
                    allowNegativePhysical,
                    _ledgerVoucher,
                    inventDimId);
        }

        if (addQty)
        {
            if (onlySearchForRegistered)
            {
                throw error(strFmt("@SYS54027",addQty,StatusReceipt::Registered));
            }
            throw error(strFmt("@SYS54437",addQty,StatusReceipt::Ordered,StatusReceipt::Arrived,StatusReceipt::Registered));
        }

        this.validateCustomInventTransReceiptUpdate(addQty);

        if (movement.mustRegisterTrackingDimension())
        {
            this.updateTrackingRegisterPhysically(updPhysical);
        }

        if (movement.mustCreateCostTransactions())
        {
            this.finalizeCostTransVarianceForReceipt(movement, _ledgerVoucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipInventTransForDifferentLoad</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the inventory transaction must be skipped over because it belongs to a different load than the load specified.
    /// </summary>
    /// <param name = "_inventTrans">Inventory transaction to verify.</param>    
    /// <returns>True, if we should skip the InventTrans record; otherwise, false.</returns>
    private boolean skipInventTransForDifferentLoad(InventTrans _inventTrans)
    {
        return (loadId && _inventTrans.LoadId != loadId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeCostTransVarianceForReceipt</Name>
				<Source><![CDATA[
    private void finalizeCostTransVarianceForReceipt(
            InventMovement  _movement,
            LedgerVoucher   _ledgerVoucher)
    {
        // Push the created variance to the inventCostUpdate class
        boolean costOK = _movement.inventModelType().finalizeCostTransVariance(_movement, _ledgerVoucher, InventCostTransState::Physical, _movement.isReturned(physical));
    
        if (movement.parmCompanyCountryRegion().isCountryRegionRU())
        {
            movement.inventModelTypeSecCur_RU().finalizeCostTransVarianceSecCur_RU(_movement, _ledgerVoucher, InventCostTransState::Physical, costOK, _movement.isReturned(physical));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustomReceiptInventTrans</Name>
				<Source><![CDATA[
    internal boolean validateCustomReceiptInventTrans(InventUpdateCustomTransReceiptListItem _listItem, InventTransReceiveListParameters _parameters)
    {
        boolean result = super(_listItem, _parameters);
        if (returnMode)
        {
            result = result
                        &&  _listItem.inventTrans.PackingSlipReturned == 0
                        && _listItem.inventTrans.InventTransOrigin  != _listItem.inventTrans.ReturnInventTransOrigin
                        && ((_listItem.inventTrans.PackingSlipId    == this.parmPackingSlipId()
                        && _listItem.inventTrans.VoucherPhysical    == this.parmVoucherMatched()
                        && _listItem.inventTrans.DatePhysical       == this.parmDateMatched())
                        || !this.isMatchingInformationForReturnSpecified());
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPhysicalReturnedIssueInventTransWithDimensions</Name>
				<Source><![CDATA[
    private InventTrans findPhysicalReturnedIssueInventTransWithDimensions(StatusReceipt _statusReceipt, InventDim _inventDimCrit)
    {
        InventDimParm inventDimFlags;
        inventDimFlags.initFromInventDim(_inventDimCrit);

        InventTrans inventTrans;

        if (this.parmCustomInventTransListInitialized())
        {
            InventDimParm validationInventDimParm;
            if (this.parmInventDimPhysicalMatched())
            {
                validationInventDimParm = inventDimFlags;
            }

            InventTransReceiveListParameters parameters = InventTransReceiveListParameters::construct();
        
            parameters.fromStatus = StatusReceipt::Purchased;
            parameters.toStatus = StatusReceipt::Received;
            parameters.inventDimId = _inventDimCrit.inventDimId;
            parameters.inventDimCriteria = _inventDimCrit;
            parameters.inventDimParm = validationInventDimParm;
            parameters.inventTransChildType = movement.transChildType();
            parameters.inventTransChildRefId = movement.transChildRefId();

            this.initializeInventTransToReceiveListWithCustomInventTransList(parameters);

            this.getNextInventTransToReceive(inventTrans);

            return inventTrans;
        }

        InventDim inventDim;
        select forupdate forceplaceholders inventTrans
            order by ValueOpen desc, MarkingRefInventTransOrigin asc, InventDimId desc, DatePhysical asc
            where inventTrans.InventTransOrigin     == movement.inventTransOriginId()
                && inventTrans.StatusIssue          == StatusIssue::None
                && inventTrans.StatusReceipt        == _statusReceipt
                && inventTrans.PackingSlipReturned  == 0
                && inventTrans.InventTransOrigin    != inventTrans.ReturnInventTransOrigin
                && ((inventTrans.PackingSlipId    == this.parmPackingSlipId()
                    && inventTrans.VoucherPhysical  == this.parmVoucherMatched()
                    && inventTrans.DatePhysical     == this.parmDateMatched())
                    || !this.isMatchingInformationForReturnSpecified())
                && (inventTrans.VoucherPhysical  == this.parmTransferOrderVoucherMatched()
                    || !this.parmTransferOrderVoucherMatched())  
            #InventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCrit, inventDimFlags);

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPhysicalReturnedIssueInventTrans</Name>
				<Source><![CDATA[
    private InventTrans findPhysicalReturnedIssueInventTrans(StatusReceipt _statusReceipt)
    {
        InventTrans inventTrans;

        if (this.parmCustomInventTransListInitialized())
        {
            InventDimParm inventDimParmBlank;
            InventDim inventDimBlank;
            
            InventTransReceiveListParameters parameters = InventTransReceiveListParameters::construct();
        
            parameters.fromStatus = StatusReceipt::Purchased;
            parameters.toStatus = StatusReceipt::Received;
            parameters.inventDimId = '';
            parameters.inventDimCriteria = inventDimBlank;
            parameters.inventDimParm = inventDimParmBlank;
            parameters.inventTransChildType = movement.transChildType();
            parameters.inventTransChildRefId = movement.transChildRefId();

            this.initializeInventTransToReceiveListWithCustomInventTransList(parameters);

            this.getNextInventTransToReceive(inventTrans);

            return inventTrans;
        }

        select forupdate inventTrans
            order by ValueOpen desc, MarkingRefInventTransOrigin asc, InventDimId desc, DatePhysical asc
            where inventTrans.InventTransOrigin     == movement.inventTransOriginId()
                && inventTrans.StatusIssue          == StatusIssue::None
                && inventTrans.StatusReceipt        == _statusReceipt
                && inventTrans.PackingSlipReturned  == 0
                && inventTrans.InventTransOrigin    != inventTrans.ReturnInventTransOrigin
                && ((inventTrans.PackingSlipId      == this.parmPackingSlipId()
                    && inventTrans.VoucherPhysical  == this.parmVoucherMatched()
                    && inventTrans.DatePhysical     == this.parmDateMatched())
                    || !this.isMatchingInformationForReturnSpecified())
                && (inventTrans.VoucherPhysical  == this.parmTransferOrderVoucherMatched()
                    || !this.parmTransferOrderVoucherMatched())            ;

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInventTransBeUsedAsReturnedIssueTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified <c>InventTrans</c> can be used for the retuned issue physical update.
    /// </summary>
    /// <param name = "_inventTrans"><c>InventTrans</c> to check.</param>
    /// <param name = "_dimensionsSpecified">Whether one or more dimensions are specified.</param>
    /// <returns>true if the <c>InventTrans</c> can be used as a returned issue transaction; otherwise, false.</returns>
    protected boolean canInventTransBeUsedAsReturnedIssueTrans(InventTrans _inventTrans, boolean _dimensionsSpecified)
    {
        return this.isInventTransDimensionsMatchingMovement(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventTransDimensionsMatchingMovement</Name>
				<Source><![CDATA[
    private boolean isInventTransDimensionsMatchingMovement(InventTrans _inventTrans)
    {
        // if specified on movement they must be the same - note that not all updates have inventDimCriteria/inventDimParmCriteria specified
        return InventDim::isInventDimParmEqual(inventDimCriteria, _inventTrans.inventDim(), inventDimParmCriteria, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsIsValidInventTransBeUsedToSplit</Name>
				<Source><![CDATA[
    private boolean pdsIsValidInventTransBeUsedToSplit(InventTrans _inventTrans, InventQty addQty, PdsCWInventQty cwAddQty)
    {
        if (!movement.pdsCWItem())
        {
            return true;
        }

        if (abs(_inventTrans.PdsCWQty) >= abs(cwAddQty) && abs(_inventTrans.Qty) >= abs(addQty))
        {
            return true;
        }

        if (abs(_inventTrans.PdsCWQty) <= abs(cwAddQty) && abs(_inventTrans.Qty) <= abs(addQty))
        {
            return true;
        }

        return false;

    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePhysicalReturnedIssue</Name>
				<Source><![CDATA[
    protected void updatePhysicalReturnedIssue(LedgerVoucher _ledgerVoucher)
    {
        InventTrans     inventTrans;
        InventDim       inventDim;
        InventDim       inventDimBlank;
        InventDim       inventDimCrit;
        InventQty       addQty              = physical;
        PdsCWInventQty  cwAddQty            = cwPhysical;

        Integer         returnStatus        = returnMode;
        StatusReceipt   statusReceipt;

        boolean         costOK;

        if (this.parmInventDimPhysicalMatched())
        {
            inventDimCrit = this.parmInventDimPhysicalMatched();
        }
        else
        {
            inventDimCrit = movement.inventdim();
        }

        if (movement.projId())
        {
            movement.parmProjectReturnIssue(true);
        }

        if (movement.mustCreateCostTransactions())
        {
            movement.inventCostIndirectFinancial().setReturnQty(movement.inventTransOriginId(), _ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate(), physical);

            // Initialize the inventCost framework
            movement.inventModelType().initCostTransVariance(movement, _ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate(), InventCostTransState::Physical, true);

            if (movement.parmCompanyCountryRegion().isCountryRegionRU())
            {
                movement.inventModelTypeSecCur_RU().initCostTransVariance(movement, _ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate(), InventCostTransState::Physical, true);
            }
        }

        // update references like Asset, Projects etc.
        this.changeInventTransReferences();

        if (!InventDim::isInventDimEqual(inventDimCrit, inventDimBlank)) // only if one or more dimensions are specified
        {
            while (returnStatus < 3 && addQty)
            {
                statusReceipt = (returnStatus == 1 ? StatusReceipt::Received : StatusReceipt::Purchased);
                
                inventTrans = this.findPhysicalReturnedIssueInventTransWithDimensions(statusReceipt, inventDimCrit);
                
                [addQty, cwAddQty] = this.updatePhysicalReturnedIssueInventTrans(_ledgerVoucher, inventTrans, addQty, cwAddQty, true);

                returnStatus+= 1;
            }
        }

        returnStatus = returnMode;

        this.checkInventDimPhysicalMatched(addQty);

        while (returnStatus < 3 && addQty)
        {
            statusReceipt = (returnStatus== 1 ? StatusReceipt::Received : StatusReceipt::Purchased);
            
            inventTrans = this.findPhysicalReturnedIssueInventTrans(statusReceipt);

            [addQty, cwAddQty] = this.updatePhysicalReturnedIssueInventTrans(_ledgerVoucher, inventTrans, addQty, cwAddQty, false);

            returnStatus+= 1;
        }
        if (addQty)
        {
            if (activeQuarantineOrderFound)
            {
                throw error("@SYS112134");
            }

            if (returnIssueTransFoundOnOtherDimension)
            {
                error("@SYS112748");
                throw error("@SYS112844");
            }

            throw error(strFmt("@SYS15535",addQty));
        }

        if (movement.mustRegisterTrackingDimension())
        {
            this.correctPhysicalTrackingRegister(physical);
        }

        if (movement.mustCreateCostTransactions())
        {
            movement.inventCostIndirectFinancial().post(_ledgerVoucher);
            
            if (movement.parmCompanyCountryRegion().isCountryRegionRU())
            {
                costOK = movement.inventModelType().finalizeCostTransVariance         (movement, _ledgerVoucher, InventCostTransState::Physical, true);
                movement.inventModelTypeSecCur_RU().finalizeCostTransVarianceSecCur_RU(movement, _ledgerVoucher, InventCostTransState::Physical, costOK, true);
            }
            else
            {
                // Push the created variance to the inventCostUpdate class
                movement.inventModelType().finalizeCostTransVariance(movement, _ledgerVoucher, InventCostTransState::Physical, true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePhysicalReturnedIssueInventTrans</Name>
				<Source><![CDATA[
    private container updatePhysicalReturnedIssueInventTrans(
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventQty       _addQty,
        PdsCWInventQty  _cwAddQty,
        boolean         _dimensionsSpecified)
    {
        while (_inventTrans)
        {
            returnIssueTransFoundOnOtherDimension = returnIssueTransFoundOnOtherDimension || !this.isInventTransDimensionsMatchingMovement(_inventTrans);

            if (this.canInventTransBeUsedAsReturnedIssueTrans(_inventTrans, _dimensionsSpecified))
            {
                [_addQty, _cwAddQty] = this.updateTransPhysicalReturnedIssue(_ledgerVoucher, _inventTrans, _addQty, _cwAddQty);

                if (!_addQty)
                {
                    break;
                }
            }

            this.getNextInventTransToReceive(_inventTrans);
        }

        this.validateCustomInventTransReceiptUpdate(_addQty);

        return [_addQty, _cwAddQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipUpdatingTransPhysicalReturnedReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether to skip the <c>InventTrans</c> from processing.
    /// </summary>
    /// <param name = "_inventTrans">
    ///     The inventory transaction.
    /// </param>
    /// <returns>
    ///     true if the given <c>InventTrans</c> should be skipped from processing further; otherwise, false.
    /// </returns>
    protected boolean skipUpdatingTransPhysicalReturnedReceipt(InventTrans _inventTrans)
    {
        if (!movement.parmCompanyCountryRegion().isCountryRegionRU()
        ||  movement.returnedSpecialCheckUpdate_RU() != UnknownNoYes::Unknown)
        {
            if (_inventTrans.InvoiceReturned || !this.canUseAsReturnedTransPhysicalReturnedReceipt(_inventTrans))
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUseAsReturnedTransPhysicalReturnedReceipt</Name>
				<Source><![CDATA[
    private boolean canUseAsReturnedTransPhysicalReturnedReceipt(InventTrans _inventTrans)
    {
        // if specified on movement they must be the same - note that not all updates have inventDimCriteria/inventDimParmCriteria specified
        InventDimParm   inventDimParmCriteriaLocal;
        //exception is that changing non-financial storage dimensions is allowed on return
        inventDimParmCriteriaLocal.data(inventDimParmCriteria.data());
        if (movement.mustReturnToDimOnSourceDocumentLine())
        {
            inventDimParmCriteriaLocal.clearNonFinancialStorageDimensions(movement.inventDimGroupSetup());
        }

        if (physical > 0
            && returnMode == InventUpdate::financialReturn()
            && movement.transType() == InventTransType::TransferOrderShip)
        {
            inventDimParmCriteriaLocal.WMSLocationIdFlag = NoYes::No;
        }

        if (!InventDim::isInventDimParmEqual(inventDimCriteria, _inventTrans.inventDim(), inventDimParmCriteriaLocal, false))
        {
            return false;
        }
        
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustomIssueInventTrans</Name>
				<Source><![CDATA[
    internal boolean validateCustomIssueInventTrans(
        StatusIssue                             _fromStatus,
        StatusIssue                             _toStatus,
        InventDimId                             _inventDimId,
        InventDim                               _inventDimCriteria,
        InventDimParm                           _inventDimParm,
        InventTransChildType                    _inventTransChildType,
        InventTransChildRefId                   _inventTransChildRefId,
        InventUpdateCustomTransIssueListItem    _listItem)
    {
        boolean result = super(_fromStatus, _toStatus, _inventDimId, _inventDimCriteria, _inventDimParm, _inventTransChildType, _inventTransChildRefId, _listItem);
        if (returnMode)
        {
            result = result
                        &&  _listItem.inventTrans.PackingSlipReturned == 0
                        && !_listItem.inventTrans.ReturnInventTransOrigin
                        && ((_listItem.inventTrans.PackingSlipId  == this.parmPackingSlipId()
                        && _listItem.inventTrans.VoucherPhysical == this.parmVoucherMatched()
                        && _listItem.inventTrans.DatePhysical    == this.parmDateMatched())
                        || !this.isMatchingInformationForReturnSpecified());
        }

        return result && this.performCustomIssueInventTransExtraValidation(
                                _fromStatus, 
                                _toStatus, 
                                _inventDimId, 
                                _inventDimCriteria, 
                                _inventDimParm, 
                                _inventTransChildType, 
                                _inventTransChildRefId, 
                                _listItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>performCustomIssueInventTransExtraValidation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs extra validation on the specified <c>InventUpdateCustomTransIssueListItem</c> instance.
    /// </summary>
    /// <param name = "_fromStatus">The first valid <c>StatusIssue</c>.</param>
    /// <param name = "_toStatus">The last valid <c>StatusIssue</c>.</param>
    /// <param name = "_inventDimId">The inventory dimension id to use for validation.</param>
    /// <param name = "_inventDimCriteria">The specification of the inventory dimensions to include in the validation.</param>
    /// <param name = "_inventDimParm">The specification of which inventory dimensions to include in the validation.</param>
    /// <param name = "_inventTransChildType">The required child type on the inventory transactions.</param>
    /// <param name = "_inventTransChildRefId">The required child reference ID on the inventory transactions.</param>
    /// <param name = "_listItem">The <c>InventUpdateCustomTransIssueListItem</c> instance to validate.</param>
    /// <returns>true if the <c>InventTrans</c> is valid; otherwise, false.</returns>
    protected boolean performCustomIssueInventTransExtraValidation(
        StatusIssue                             _fromStatus,
        StatusIssue                             _toStatus,
        InventDimId                             _inventDimId,
        InventDim                               _inventDimCriteria,
        InventDimParm                           _inventDimParm,
        InventTransChildType                    _inventTransChildType,
        InventTransChildRefId                   _inventTransChildRefId,
        InventUpdateCustomTransIssueListItem    _listItem)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPhysicalReturnedReceiptInventTransWithDimensions</Name>
				<Source><![CDATA[
    private InventTrans findPhysicalReturnedReceiptInventTransWithDimensions(StatusIssue _statusIssue, InventDim _inventDimCrit)
    {
        InventDimParm inventDimFlags;
        inventDimFlags.initFromInventDim(_inventDimCrit);

        InventTrans inventTrans;

        if (this.parmCustomInventTransListInitialized())
        {
            InventDimParm validationInventDimParm;
            if (this.parmInventDimPhysicalMatched())
            {
                validationInventDimParm = inventDimFlags;
            }

            this.initializeInventTransToIssueListWithCustomInventTransList(StatusIssue::Sold,
                                                                           StatusIssue::Deducted,
                                                                           _inventDimCrit.inventDimId,
                                                                           _inventDimCrit,
                                                                           validationInventDimParm,
                                                                           movement.transChildType(),
                                                                           movement.transChildRefId());

            this.getNextInventTransToIssue(inventTrans);

            return inventTrans;
        }
            
        InventDim inventDim;
        select forupdate forceplaceholders inventTrans
            order by ValueOpen desc, InventDimId desc
            where inventTrans.InventTransOrigin     == movement.inventTransOriginId()
                &&  inventTrans.StatusIssue         == _statusIssue
                &&  inventTrans.StatusReceipt       == StatusReceipt::None
                &&  inventTrans.PackingSlipReturned == 0
                && !inventTrans.ReturnInventTransOrigin
                && ( ( inventTrans.PackingSlipId        == this.parmPackingSlipId()
                    &&  inventTrans.VoucherPhysical     == this.parmVoucherMatched()
                    &&  inventTrans.DatePhysical        == this.parmDateMatched() )
                ||  !this.isMatchingInformationForReturnSpecified() )
                && (inventTrans.VoucherPhysical  == this.parmTransferOrderVoucherMatched()
                    || !this.parmTransferOrderVoucherMatched())
                && ( !movement.parmCompanyCountryRegion().isCountryRegionRU()    ||
                    ((( needTransIDTransit && inventTrans.InventTransOriginTransit_RU) ||
                    (!needTransIDTransit && inventTrans.InventTransOriginTransit_RU == 0))
                &&  (! documentStornoId || (!inventTrans.InvoiceReturned && inventTrans.InvoiceId == documentStornoId))))
            #InventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCrit, inventDimFlags);

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPhysicalReturnedReceiptInventTrans</Name>
				<Source><![CDATA[
    private InventTrans findPhysicalReturnedReceiptInventTrans(StatusIssue _statusIssue)
    {
        InventTrans inventTrans;

        if (this.parmCustomInventTransListInitialized())
        {
            InventDimParm inventDimParmBlank;
            InventDim inventDimBlank;
            this.initializeInventTransToIssueListWithCustomInventTransList(StatusIssue::Sold,
                                                                           StatusIssue::Deducted,
                                                                           '',
                                                                           inventDimBlank,
                                                                           inventDimParmBlank,
                                                                           movement.transChildType(),
                                                                           movement.transChildRefId());

            this.getNextInventTransToIssue(inventTrans);

            return inventTrans;
        }

        select forupdate inventTrans
            order by ValueOpen desc, InventDimId desc
            where inventTrans.InventTransOrigin     == movement.inventTransOriginId()
                &&  inventTrans.StatusIssue               == _statusIssue
                &&  inventTrans.StatusReceipt             == StatusReceipt::None
                &&  inventTrans.PackingSlipReturned       == 0
                && !inventTrans.ReturnInventTransOrigin
                && ( ( inventTrans.PackingSlipId         == this.parmPackingSlipId()
                    &&  inventTrans.VoucherPhysical       == this.parmVoucherMatched()
                    &&  inventTrans.DatePhysical          == this.parmDateMatched() )
                ||  !this.isMatchingInformationForReturnSpecified() )
                && (inventTrans.VoucherPhysical  == this.parmTransferOrderVoucherMatched()
                    || !this.parmTransferOrderVoucherMatched())
                && ( !movement.parmCompanyCountryRegion().isCountryRegionRU()    ||
                    ((( needTransIDTransit && inventTrans.InventTransOriginTransit_RU) ||
                    (!needTransIDTransit && inventTrans.InventTransOriginTransit_RU == 0))
                &&  (! documentStornoId || (!inventTrans.InvoiceReturned && inventTrans.InvoiceId == documentStornoId))));

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePhysicalReturnedReceipt</Name>
				<Source><![CDATA[
    protected void updatePhysicalReturnedReceipt(LedgerVoucher _ledgerVoucher)
    {
        InventDim inventDimCrit;

        if (this.parmInventDimPhysicalMatched())
        {
            inventDimCrit = this.parmInventDimPhysicalMatched();
        }
        else
        {
            inventDimCrit = movement.inventdim();
        }

        if (movement.mustCreateCostTransactions())
        {
            // Initialize the inventCost framework
            movement.inventCostIndirectFinancial().setReturnQty(movement.inventTransOriginId(), _ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate(), physical);

            movement.inventModelType().initCostTransVariance(movement, _ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate(), InventCostTransState::Physical, true);

            if (movement.parmCompanyCountryRegion().isCountryRegionRU())
            {
                movement.inventModelTypeSecCur_RU().initCostTransVariance(movement, _ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate(), InventCostTransState::Physical, true);
            }
        }

        // update references like Asset, Projects etc.
        this.changeInventTransReferences();
                
        InventDim inventDimBlank;
        InventTrans inventTrans;
        InventQty addQty = physical;
        Integer returnStatus = returnMode;
        StatusIssue statusIssue;
        PdsCWInventQty cwAddQty = cwPhysical;

        if (!InventDim::isInventDimEqual(inventDimCrit, inventDimBlank)) // only if one or more dimensions are specified
        {
            while (returnStatus < 3 && addQty)
            {
                statusIssue  = (returnStatus == 1 ? StatusIssue::Deducted: StatusIssue::Sold);

                inventTrans = this.findPhysicalReturnedReceiptInventTransWithDimensions(statusIssue, inventDimCrit);

                [addQty,cwAddQty] = this.updatePhysicalReturnedReceiptInventTrans(_ledgerVoucher, inventTrans, addQty, cwAddQty);
                
                returnStatus += 1;
            }
        }

        returnStatus = returnMode;

        this.checkInventDimPhysicalMatched(addQty);

        while (returnStatus < 3 && addQty)
        {
            statusIssue  = (returnStatus== 1 ? StatusIssue::Deducted: StatusIssue::Sold);

            inventTrans = this.findPhysicalReturnedReceiptInventTrans(statusIssue);

            [addQty,cwAddQty] = this.updatePhysicalReturnedReceiptInventTrans(_ledgerVoucher, inventTrans, addQty, cwAddQty);
            
            returnStatus += 1;
        }

        if (addQty)
        {
            if (movement.parmCompanyCountryRegion().isCountryRegionRU() && documentStornoId)
            {
                throw error(strFmt("@GLS114836", addQty, documentStornoId));
            }
            else
            {
                if (inventDimParmCriteria.isAllFlagNo())
                {
                    throw error(strFmt("@SYS8255",addQty));
                }
                else
                {
                    throw error(strFmt("@SYS4001825",addQty));
                }
            }
        }

        if (movement.mustRegisterTrackingDimension())
        {
            this.correctPhysicalTrackingRegister(physical);
        }

        if (movement.mustCreateCostTransactions())
        {
            movement.inventCostIndirectFinancial().post(_ledgerVoucher);

            if (movement.parmCompanyCountryRegion().isCountryRegionRU())
            {
                boolean costOK = movement.inventModelType().finalizeCostTransVariance         (movement, _ledgerVoucher, InventCostTransState::Physical, true);
                movement.inventModelTypeSecCur_RU().finalizeCostTransVarianceSecCur_RU(movement, _ledgerVoucher, InventCostTransState::Physical, costOK, true);
            }
            else
            {
                // Push the created variance to the inventCostUpdate class
                movement.inventModelType().finalizeCostTransVariance(movement, _ledgerVoucher, InventCostTransState::Physical, true);
            }
        }

        // Update the marking on inventory transactions related to project purchase order when correct the product receipt.
        if (movement.projId() && this.parmPackingSlipId() && !addQty && ProjUpdateInvTransMarkingForReturnedProdRcptFlight::instance().isEnabled())
        {
            this.updateReturnedProductReceiptInventTransMarking();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePhysicalReturnedReceiptInventTrans</Name>
				<Source><![CDATA[
    private container updatePhysicalReturnedReceiptInventTrans(
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventQty       _addQty,
        PdsCWInventQty  _cwAddQty
        )
    {
        while (_inventTrans)
        {
            if (!this.skipUpdatingTransPhysicalReturnedReceipt(_inventTrans))
            {
                [_addQty, _cwAddQty] = this.updateTransPhysicalReturnedReceipt(_ledgerVoucher, _inventTrans, _addQty, _cwAddQty);
                    
                if (!_addQty)
                {
                    break;
                }
            }

            this.getNextInventTransToIssue(_inventTrans);
        }

        this.verifyCustomInventTransUpdate(_addQty);

        return [_addQty, _cwAddQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReportFinished</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reports the current item as finished.
    /// </summary>
    /// <param name="_transDate">
    /// Transaction date for report as finished.
    /// </param>
    protected void updateReportFinished(TransDate _transDate)
    {
        BOMReportFinish     reportFinished;

        if ( returnMode
         || !movement.inventTable().AutoReportFinished
         || !movement.canBeAutoRepAsFinished()
         || !movement.inventTable().isFormulaOrBOMAllowed())
        {
            return;
        }

        if (!InventParameters::find().bomJournalNameId)
        {
            throw error("@SYS28923");
        }

        reportFinished = BOMReportFinish::newAutoReportFinished(movement.itemId(),
                                                                movement.inventDimId(),
                                                                _transDate,
                                                                -this.parmPhysical(),
                                                                movement.defaultDimension());

        reportFinished.run();

        // reserve a demand once BOM report as finished supply is posted
        movement.updateReservation();

        InventJournalTable bomJournalHeader = reportFinished.journalTableData().journalTable();
        InventTransOrigin  bomJournalInventTransOrigin;
        InventJournalTrans bomJournalTrans;

        select firstonly RecId from bomJournalInventTransOrigin
            exists join bomJournalTrans
                    where bomJournalTrans.InventTransId == bomJournalInventTransOrigin.InventTransId
                        && bomJournalTrans.JournalId     == bomJournalHeader.JournalId
                        && bomJournalTrans.JournalType   == InventJournalType::BOM
                        && bomJournalTrans.ItemId        == movement.itemId()
                        && bomJournalTrans.BOMLine       == NoYes::No;

        if (bomJournalInventTransOrigin)
        {
            InventQty markedQty = InventTransOrigin::updateMarking(movement.inventTransOriginId(),
                                                                    bomJournalInventTransOrigin.RecId,
                                                                    this.parmPhysical(),
                                                                    '',
                                                                    SortOrder::Ascending,
                                                                    false,
                                                                    inventDimCriteria,
                                                                    inventDimParmCriteria);
            InventTransOrigin::updateMarking(bomJournalInventTransOrigin.RecId, movement.inventTransOriginId(), markedQty);
        }
        this.cleanupPostReportFinished();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupPostReportFinished</Name>
				<Source><![CDATA[
    /// <summary>
    ///    An extension point to clean the resources after posting auto report as finished BOM journal
    /// </summary>
    [Replaceable]
    protected void cleanupPostReportFinished()
    {
        if (BOMReportFinishCircularityFlight::instance().isEnabled())
        {
            str hashKey = BomReportFinishCircularityCheck::hashKey(movement.itemId(), movement.InventDimId());
            BomReportFinishCircularityCheck::removeFromCache(hashKey);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTrackingRegisterPhysically</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates tracking register transactions to the state of being physically updated.
    /// </summary>
    /// <param name="_physicalQty">
    ///    The quantity to physically update.
    /// </param>
    private void updateTrackingRegisterPhysically(InventQty _physicalQty)
    {
        InventTrackingRegisterTrans::associatePhysicalJournalTrackingTrans(movement.inventTransOriginId(), movement.itemId(), physicalJournalLine, _physicalQty, movement.inventDimGroupSetup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransPhysicalReturnedIssue</Name>
				<Source><![CDATA[
    protected container updateTransPhysicalReturnedIssue(
        LedgerVoucher       _ledgerVoucher,
        InventTrans         _inventTrans,
        InventQty           _addQty,
        PdsCWInventQty      _cwAddQty = 0
        )
    {
        InventTrans     localBuffer;
        InventOnhand    inventOnhand;
        
        boolean         countryRegion_RU = movement.parmCompanyCountryRegion().isCountryRegionRU();

        if (!movement.inventTable().checkRefInventTrans(_inventTrans)
          ||!movement.checkCountingLocks(_inventTrans.inventDim()))
        {
            throw error("@SYS18447");
        }

        if (this.isInventTransMarkedWithActiveQO(_inventTrans))
        {
            activeQuarantineOrderFound = NoYes::Yes;
            return [_addQty, _cwAddQty];
        }

        if (!this.pdsIsValidInventTransBeUsedToSplit(_inventTrans, _addQty, _cwAddQty))
        {
            return [_addQty, _cwAddQty];
        }

        InventQty updateNowQuantity = this.transactionReceiptQuantity(_inventTrans, -_addQty);
        if (updateNowQuantity < _inventTrans.Qty)
        {
            _inventTrans.updateSplit(updateNowQuantity, -_cwAddQty);
        }

        inventOnhand = InventOnhand::newPhysicalUpdate(movement,_inventTrans.inventDim());

        inventOnhand.cannotPickEnoughInventoryError += eventhandler(this.cannotPickEnoughInventoryError);
        
        if (! inventOnhand.checkItemDraw(-_inventTrans.Qty,allowNegativePhysical, true, -_inventTrans.PdsCWQty))
        {
            throw error("@SYS18447");
        }

        localBuffer.clear();
        movement.initInventTransFromBuffer(localBuffer,null);
        movement.initInventTransPhysical(localBuffer, _ledgerVoucher.lastTransDate(), packingSlipId);

        localBuffer.Qty         = -_inventTrans.Qty;
        localBuffer.PdsCWQty    = -_inventTrans.PdsCWQty;

        if (!countryRegion_RU
            ||  (countryRegion_RU
            &&  (movement.returnedSpecialCheckUpdate_RU() == UnknownNoYes::Unknown
            ||  movement.returnedSpecialCheckUpdate_RU() == UnknownNoYes::No)))
        {
            if (_inventTrans.MarkingRefInventTransOrigin)
            {
                this.setVirtuelProjReferenceTransOriginId(_inventTrans.MarkingRefInventTransOrigin);

                // Marking on invent transaction will be deleted with packing slip id check only when inventory transaction for purchase order is related to project 
                // and has no linkage to SO/ Item req (reference to virtual inventory trnasaction is checked)
                if (_inventTrans.ProjId && _inventTrans.PackingSlipId
                    && (!ProjDelInventMarkingForIssueTransPOLinkedToSOFlight::instance().isEnabled()
                        || (_inventTrans.inventTransOrigin().ReferenceCategory == InventTransType::Purch
                            && InventTransOrigin::find(_inventTrans.MarkingRefInventTransOrigin).ReferenceCategory == InventTransType::InventTransaction)))
                {
                    ProjProductReceiptCancellationMarkingUpdateContext context = ProjProductReceiptCancellationMarkingUpdateContext::current();
                    if (context && this.parmReturnMode())
                    {
                        context.parmRefInventTransOrigin(_inventTrans.MarkingRefInventTransOrigin);
                    }

                    using (InventTransOriginParameters insertParameters = InventTransOriginParameters::parmPackingSlipId(_inventTrans.PackingSlipId))
                    {
                        InventTransOrigin::deleteMarking(_inventTrans.MarkingRefInventTransOrigin, _inventTrans.InventTransOrigin,-_inventTrans.Qty,
                                                    false,
                                                    null,
                                                    null,
                                                    false,
                                                    false,
                                                    -_inventTrans.PdsCWQty
                                                    ); // before packing slip return flag
                    }
                }
                else
                {
                    InventTransOrigin::deleteMarking(_inventTrans.MarkingRefInventTransOrigin, _inventTrans.InventTransOrigin,-_inventTrans.Qty,
                                                    false,
                                                    null,
                                                    null,
                                                    false,
                                                    false,
                                                    -_inventTrans.PdsCWQty
                                                    );
                }
            }

            _inventTrans.clearMarking();
            localBuffer.clearMarking();
        }
        localBuffer.InventDimId      = _inventTrans.InventDimId;

        if (_inventTrans.StatusReceipt == StatusReceipt::Received)
        {
            movement.initInventTransFinancial(localBuffer, _ledgerVoucher.lastTransDate(), '', CompanyInfoHelper::standardCurrency());
            movement.initInventTransReceiptId(localBuffer, _inventTrans.ReceiptId);
            movement.initInventTransRegisteredLoad(localBuffer, _inventTrans.LoadId);

            movement.transIdSum().setInventTransStatus(localBuffer,StatusReceipt::None,StatusIssue::Deducted);

            _inventTrans.PackingSlipReturned    = NoYes::Yes;
            localBuffer.PackingSlipReturned     = NoYes::Yes;

            if (countryRegion_RU)
            {
                movement.inventModelTypeSecCur_RU().preUpdateFinancial(movement, _ledgerVoucher, _inventTrans);
            }
            if (countryRegion_RU)
            {
                localBuffer.CostAmountSecCurPhysical_RU = -_inventTrans.CostAmountSecCurPhysical_RU;
            }
            movement.inventModelType().preUpdateFinancial(movement, _ledgerVoucher, _inventTrans);
            localBuffer.CostAmountPhysical  = -_inventTrans.CostAmountPhysical;

            movement.initInventTransFinancial(_inventTrans,_ledgerVoucher.lastTransDate(), '', CompanyInfoHelper::standardCurrency());
            movement.transIdSum().setInventTransStatus(_inventTrans, StatusReceipt::Purchased, StatusIssue::None);
            movement.updateLedgerPhysical(_ledgerVoucher, _inventTrans, this, inventOnhand, localBuffer);

            _inventTrans.Voucher        = _ledgerVoucher.lastVoucher();
            localBuffer.Voucher         = _inventTrans.Voucher;
            localBuffer.VoucherPhysical = _inventTrans.Voucher;
            this.postingPhysical(true);
            this.raiseOnHandChangingOnPhysicalStatusUpd(localBuffer);
            localBuffer.insert();

            if (movement.mustCreateCostTransactions())
            {
                movement.inventCostIndirectPhysical().update(localBuffer);
                movement.inventCostIndirectFinancial().update(_inventTrans);
                movement.inventCostIndirectFinancial().update(localBuffer);

                // Add each inventTrans record to the inventCost framework
                movement.inventModelType().addCostTransVariance(localBuffer,
                                                                movement,
                                                                _ledgerVoucher.lastVoucher(),
                                                                _ledgerVoucher.lastTransDate(),
                                                                InventCostTransState::Physical,
                                                                true,
                                                                _inventTrans);

                if (countryRegion_RU)
                {
                    movement.inventModelTypeSecCur_RU().addCostTransVariance(localBuffer,
                                                                             movement,
                                                                             _ledgerVoucher.lastVoucher(),
                                                                             _ledgerVoucher.lastTransDate(),
                                                                             InventCostTransState::Physical,
                                                                             true,
                                                                             _inventTrans);
                    movement.inventModelTypeSecCur_RU().postUpdatePhysicalReturn(movement, _ledgerVoucher, localBuffer, _inventTrans);
                }

                movement.inventModelType().postUpdatePhysicalReturn(movement, _ledgerVoucher, localBuffer, _inventTrans);
            }
            movement.transIdSum().setInventTransStatus(localBuffer, StatusReceipt::None, StatusIssue::Sold);
        }
        else
        {
            _inventTrans.InvoiceReturned = NoYes::Yes;

            if (!countryRegion_RU
                || (countryRegion_RU
                && (movement.returnedSpecialCheckUpdate_RU() == UnknownNoYes::Unknown ||
                movement.returnedSpecialCheckUpdate_RU() == UnknownNoYes::No)))
            {
                _inventTrans.setMarking(_inventTrans.InventTransOrigin);
                localBuffer.setMarking(_inventTrans.InventTransOrigin);
            }
            else
            {
                InventTransOrigin::updateMarking(movement.markingRefInventTransOrigin(), localBuffer.InventTransOrigin, -localBuffer.Qty,  '', SortOrder::Descending);
                localBuffer.setMarking(movement.markingRefInventTransOrigin());
            }

            movement.transIdSum().setInventTransStatus(localBuffer,StatusReceipt::None,StatusIssue::Deducted);
            this.raiseOnHandChangingOnPhysicalStatusUpd(localBuffer);
            // Update InvenTrans with the return marking, so correct standard cost can be calculated in the posting
            _inventTrans.update();
            movement.updateLedgerPhysical(_ledgerVoucher, localBuffer, this, inventOnhand);
            localBuffer.insert();

            if (movement.mustCreateCostTransactions())
            {
                movement.inventCostIndirectPhysical().update(localBuffer);

                // Add each inventTrans record to the inventCost framework
                movement.inventModelType().addCostTransVariance(localBuffer,
                                                                movement,
                                                                _ledgerVoucher.lastVoucher(),
                                                                _ledgerVoucher.lastTransDate(),
                                                                InventCostTransState::Physical,
                                                                true);
                movement.inventModelType().postUpdatePhysical(movement, _ledgerVoucher, localBuffer);

                if (countryRegion_RU)
                {
                    movement.inventModelTypeSecCur_RU().addCostTransVariance(localBuffer,
                                                                             movement,
                                                                             _ledgerVoucher.lastVoucher(),
                                                                             _ledgerVoucher.lastTransDate(),
                                                                             InventCostTransState::Physical,
                                                                             true);
                    movement.inventModelTypeSecCur_RU().postUpdatePhysical(movement, _ledgerVoucher, localBuffer);
                }
            }
        }

        if (!countryRegion_RU
            || (countryRegion_RU
            && (movement.forceReturnLotInInventTrans_RU() || movement.returnedSpecialCheckUpdate_RU() == UnknownNoYes::Unknown ||
            movement.returnedSpecialCheckUpdate_RU() == UnknownNoYes::No)))
        {
            localBuffer.ReturnInventTransOrigin = _inventTrans.InventTransOrigin;
        }

        movement.updateSerialNumIssue(localBuffer,null);

        localBuffer.update();

        if (_inventTrans.ReturnInventTransOrigin && _inventTrans.ReturnInventTransOrigin != localBuffer.InventTransOrigin &&
           (! countryRegion_RU || ! _inventTrans.isGoodsInRouteTransit_RU()))
        {
            _inventTrans.forceDeleteReturnTransOrigin();
        }

        _inventTrans.ReturnInventTransOrigin = localBuffer.InventTransOrigin;
        InventCostTransCostList::flushCache();
        _inventTrans.update();

        updPhysical     -= _inventTrans.Qty;
        cwUpdPhysical   -= _inventTrans.PdsCWQty;

        return [_addQty + _inventTrans.Qty, _cwAddQty + _inventTrans.PdsCWQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>cannotPickEnoughInventoryError</Name>
				<Source><![CDATA[
    private void cannotPickEnoughInventoryError(InventOnHandQtyErrorParameters _errorParameters)
    {
        if (returnMode && 
            movement.transType() == InventTransType::Purch)
        {
            checkFailed(strFmt("@WAX:WHSCancelProductReceiptCannotPickWithEnoughInventory", _errorParameters.inventDimCriteria.wMSLocationId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransPhysicalReturnedReceipt</Name>
				<Source><![CDATA[
    protected container updateTransPhysicalReturnedReceipt(
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventQty       _addQty,
        PdsCWInventQty  _cwAddQty
        )

    {
        boolean countryRegion_RU = movement.parmCompanyCountryRegion().isCountryRegionRU();

        if (!movement.inventTable().checkRefInventTrans(_inventTrans)
          ||!movement.checkCountingLocks(_inventTrans.inventDim()))
        {
            throw error("@SYS18447");
        }

        InventQty updateNowQuantity = this.transactionIssueQuantity(_inventTrans, -_addQty);
        if (updateNowQuantity > _inventTrans.Qty)
        {
            _inventTrans.updateSplit(updateNowQuantity, -_cwAddQty);
        }

        this.updateDimReservePhysical(InventDim::find(_inventTrans.InventDimId), -_inventTrans.Qty, 0, -_inventTrans.PdsCWQty);
        
        InventTrans localBuffer;
        localBuffer.clear();
        movement.initInventTransFromBuffer(localBuffer,null);
        movement.initInventTransPhysical(localBuffer, _ledgerVoucher.lastTransDate(), packingSlipId);

        localBuffer.Qty         = -_inventTrans.Qty;
        localBuffer.PdsCWQty    = -_inventTrans.PdsCWQty;

        localBuffer.ReturnInventTransOrigin     = _inventTrans.InventTransOrigin;
        _inventTrans.ReturnInventTransOrigin    = localBuffer.InventTransOrigin;
        if (countryRegion_RU)
        {
            localBuffer.InventDimIdSales_RU          = _inventTrans.InventDimIdSales_RU;
            localBuffer.InventTransOriginSales_RU    = _inventTrans.InventTransOriginSales_RU;
            localBuffer.InventTransOriginTransit_RU  = _inventTrans.InventTransOriginTransit_RU;
            localBuffer.InventTransOriginDelivery_RU = _inventTrans.InventTransOriginDelivery_RU;
        }

        // update inventTrans because we select on ReturnInventTransOrigin later in the posting
        InventCostTransCostList::flushCache();
        _inventTrans.doUpdate();

        if (!countryRegion_RU
            || (countryRegion_RU && movement.returnedSpecialCheckUpdate_RU() == UnknownNoYes::Unknown))
        {
            if (_inventTrans.MarkingRefInventTransOrigin)
            {
                this.setVirtuelProjReferenceTransOriginId(_inventTrans.MarkingRefInventTransOrigin);

                if (_inventTrans.ProjId && _inventTrans.PackingSlipId
                    && (_inventTrans.inventTransOrigin().ReferenceCategory == InventTransType::Purch
                            && InventTransOrigin::find(_inventTrans.MarkingRefInventTransOrigin).ReferenceCategory == InventTransType::InventTransaction)
                    && ProjPartialProductReceiptCancelMarkingDeleteFlight::instance().isEnabled())
                {
                    ProjProductReceiptCancellationMarkingUpdateContext context = ProjProductReceiptCancellationMarkingUpdateContext::current();
                    if (context && this.parmReturnMode())
                    {
                        context.parmRefInventTransOrigin(_inventTrans.MarkingRefInventTransOrigin);
                    }

                    using (InventTransOriginParameters insertParameters = InventTransOriginParameters::parmPackingSlipId(_inventTrans.PackingSlipId))
                    {
                        InventTransOrigin::deleteMarking(_inventTrans.MarkingRefInventTransOrigin, _inventTrans.InventTransOrigin,-_inventTrans.Qty,
                                                false, null, null, false, false, //default parameters
                                                -_inventTrans.PdsCWQty
                                                ); // before packing slip return flag
                    }
                }
                else
                {
                    InventTransOrigin::deleteMarking(_inventTrans.MarkingRefInventTransOrigin, _inventTrans.InventTransOrigin,-_inventTrans.Qty,
                                                false, null, null, false, false, //default parameters
                                                -_inventTrans.PdsCWQty
                                                ); // before packing slip return flag
                }
            }

            _inventTrans.clearMarking();
        }
        localBuffer.clearMarking();
        localBuffer.InventDimId      = _inventTrans.InventDimId;

        InventDim inventDimNew = localBuffer.inventDim();
        if (movement.mustReturnToDimOnSourceDocumentLine() && localBuffer.InventDimId != movement.inventDimId())
        {
            // Allow non-financial storage dimension from the movement to override the issued dimensions.
            boolean anyDimensionChanged = false;
            InventDim inventDimMovement = movement.inventdim();

            ListEnumerator enumerator = EcoResStorageDimensionGroup::dimEnabledFieldList().getEnumerator();
            while (enumerator.moveNext())
            {
                FieldId inventDimFieldId = enumerator.current();
                if (inventDimMovement.(inventDimFieldId) && inventDimMovement.(inventDimFieldId) != inventDimNew.(inventDimFieldId))
                {
                    // Specified on movement, but different from issued dimension value
                    InventDimGroupFieldSetup inventDimGroupFieldSetup = movement.inventDimGroupSetup().getFieldSetup(inventDimFieldId);

                    if (inventDimGroupFieldSetup
                    &&  inventDimGroupFieldSetup.isActive()
                    && !inventDimGroupFieldSetup.isFinancialInventoryEnabled())
                    {
                        inventDimNew.(inventDimFieldId) = inventDimMovement.(inventDimFieldId);
                        anyDimensionChanged = true;
                    }
                }
            }
            if (anyDimensionChanged)
            {
                // Validate WMSlocation
                if (inventDimNew.wmsLocationId && !WMSLocation::exist(inventDimNew.wmsLocationId,inventDimNew.InventLocationId))
                {
                    throw error(strFmt("@SYS53781",inventDimNew.wmsLocationId,inventDimNew.InventLocationId));
                }

                //pallet must be on the To-wmsLocation
                localBuffer.InventDimId = InventDim::findOrCreate(inventDimNew).InventDimId;
            }
        }

        if (_inventTrans.StatusIssue == StatusIssue::Deducted)
        {
            movement.initInventTransFinancial(localBuffer, _ledgerVoucher.lastTransDate(), '', CompanyInfoHelper::standardCurrency());
            movement.initInventTransPicked(localBuffer, _inventTrans.PickingRouteID);

            // localBuffer must not be included in InventSum in cost calculations, so we set it to registered and insert and
            // then set it to received (StatusReceipt is used in cost calculations).
            movement.transIdSum().setInventTransStatus(localBuffer,StatusReceipt::Registered,StatusIssue::None);
            this.raiseOnHandChangingOnPhysicalStatusUpd(localBuffer);
            localBuffer.insert();
            movement.transIdSum().setInventTransStatus(localBuffer,StatusReceipt::Received,StatusIssue::None);

            _inventTrans.PackingSlipReturned    = NoYes::Yes;
            localBuffer.PackingSlipReturned     = NoYes::Yes;

            if (countryRegion_RU)
            {
                movement.inventModelTypeSecCur_RU().preUpdateFinancial(movement, _ledgerVoucher, _inventTrans);
            }
            if (countryRegion_RU)
            {
                localBuffer.CostAmountSecCurPhysical_RU = -_inventTrans.CostAmountSecCurPhysical_RU;
            }
            movement.inventModelType().preUpdateFinancial(movement, _ledgerVoucher, _inventTrans);
            localBuffer.CostAmountPhysical      = -_inventTrans.CostAmountPhysical;
            localBuffer.RevenueAmountPhysical   = -_inventTrans.RevenueAmountPhysical;

            movement.initInventTransFinancial(_inventTrans, _ledgerVoucher.lastTransDate(), '', CompanyInfoHelper::standardCurrency());
            movement.transIdSum().setInventTransStatus(_inventTrans,StatusReceipt::None,StatusIssue::Sold);
            movement.updateLedgerPhysical(_ledgerVoucher, _inventTrans, this, null, localBuffer);

            _inventTrans.Voucher        = _ledgerVoucher.lastVoucher();
            localBuffer.Voucher         = _inventTrans.Voucher;
            localBuffer.VoucherPhysical = _inventTrans.Voucher;
            this.postingPhysical(true);
            movement.updateSerialNumReceipt(localBuffer,null);

            // Store original date physical value
            DatePhysical datePhysical = localBuffer.DatePhysical;

            if (movement.mustCreateCostTransactions())
            {
                movement.inventCostIndirectPhysical().update(localBuffer);
                movement.inventCostIndirectFinancial().update(_inventTrans);
                movement.inventCostIndirectFinancial().update(localBuffer);

                // Add each inventTrans record to the inventCost framework
                movement.inventModelType().addCostTransVariance(localBuffer,
                                                                movement,
                                                                _ledgerVoucher.lastVoucher(),
                                                                _ledgerVoucher.lastTransDate(),
                                                                InventCostTransState::Physical,
                                                                true,
                                                                _inventTrans);

                if (countryRegion_RU)
                {
                    movement.inventModelTypeSecCur_RU().addCostTransVariance(localBuffer,
                                                                             movement,
                                                                             _ledgerVoucher.lastVoucher(),
                                                                             _ledgerVoucher.lastTransDate(),
                                                                             InventCostTransState::Physical,
                                                                             true,
                                                                             _inventTrans);
                    movement.inventModelTypeSecCur_RU().postUpdatePhysicalReturn(movement, _ledgerVoucher, localBuffer, _inventTrans);
                }
                movement.inventModelType().postUpdatePhysicalReturn(movement, _ledgerVoucher, localBuffer, _inventTrans);
            }

            movement.transIdSum().setInventTransStatus(localBuffer,StatusReceipt::Purchased,StatusIssue::None);

            this.initDatePhysical(localBuffer, datePhysical);

            localBuffer.update();

            this.restoreDatePhysical(localBuffer, datePhysical);

            if (movement.canItemReqBeCancelled())
            {
                movement.setProjAdjustRefId(localBuffer);
            }
        }
        else
        {
            _inventTrans.InvoiceReturned = NoYes::Yes;
            // localBuffer must not be included in InventSum in cost calculations, so we set it to registered and insert and
            // then set it to received (StatusReceipt is used in cost calculations).
            movement.transIdSum().setInventTransStatus(localBuffer,StatusReceipt::Registered,StatusIssue::None);
            this.raiseOnHandChangingOnPhysicalStatusUpd(localBuffer);
            localBuffer.insert();
            movement.transIdSum().setInventTransStatus(localBuffer,StatusReceipt::Received,StatusIssue::None);

            movement.updateLedgerPhysical(_ledgerVoucher, localBuffer, this, null);
            movement.updateSerialNumReceipt(localBuffer,null);

            if (movement.mustCreateCostTransactions())
            {
                // Add each inventTrans record to the inventCost framework
                movement.inventModelType().addCostTransVariance(localBuffer,
                                                                movement,
                                                                _ledgerVoucher.lastVoucher(),
                                                                _ledgerVoucher.lastTransDate(),
                                                                InventCostTransState::Physical,
                                                                true);
                movement.inventModelType().postUpdatePhysical(movement, _ledgerVoucher, localBuffer);

                if (countryRegion_RU)
                {
                    movement.inventModelTypeSecCur_RU().addCostTransVariance(localBuffer,
                                                                             movement,
                                                                             _ledgerVoucher.lastVoucher(),
                                                                             _ledgerVoucher.lastTransDate(),
                                                                             InventCostTransState::Physical,
                                                                             true);
                    movement.inventModelTypeSecCur_RU().postUpdatePhysical(movement, _ledgerVoucher, localBuffer);
                }
            }

            localBuffer.update();
        }

        _inventTrans.update();

        updPhysical     -= _inventTrans.Qty;
        cwUpdPhysical   -= _inventTrans.PdsCWQty;

        return [_addQty + _inventTrans.Qty, _cwAddQty + _inventTrans.PdsCWQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDatePhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the <c>DatePhysical</c> field under certain conditions.
    /// </summary>
    /// <param name = "_localBuffer">An <c>InventTrans</c> instance.</param>
    /// <param name = "_datePhysical">The original date physical value.</param>
    protected void initDatePhysical(InventTrans _localBuffer, DatePhysical _datePhysical)
    {
        // When specific movement type from InventUpd_Physical class isn't allowed to update physical date of on-hand invent,
        // inventSum.LastUpdDatePhysical will be used as physical date of transaction temporarily in order to avoid original
        // inventSum.LastUpDatePhysical will be modified on return mode, i.e., resetting production status.
        if (!movement.canUpdateOnHandDatePhysicalOnReturn())
        {
            InventSum inventSum = InventSum::find(_localBuffer.ItemId, _localBuffer.InventDimId);
            _localBuffer.DatePhysical = inventSum.LastUpdDatePhysical ?
                                            inventSum.LastUpdDatePhysical : 
                                            _datePhysical;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>restoreDatePhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Restores the <c>DatePhysical</c> field if it changed.
    /// </summary>
    /// <param name = "_localBuffer">An <c>InventTrans</c> instance.</param>
    /// <param name = "_datePhysical">The original date physical value.</param>
    protected void restoreDatePhysical(InventTrans _localBuffer, DatePhysical _datePhysical)
    {
        // Restore date physical on transaction.
        if (_localBuffer.DatePhysical != _datePhysical)
        {
            _localBuffer.DatePhysical = _datePhysical;
            _localBuffer.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updCostAmountInvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the value of issued inventory transactions after a physical update.
    /// </summary>
    /// <returns>
    /// The value of the issued inventory transactions.
    /// </returns>
    public CostAmount updCostAmountInvent()
    {
        return updCostAmountInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updPhysical</Name>
				<Source><![CDATA[
    public InventQty updPhysical()
    {
        return updPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updPhysicalAmountLedger</Name>
				<Source><![CDATA[
    public CostAmount updPhysicalAmountLedger(CostAmount _costAmount = updPhysicalAmountLedger)
    {
        updPhysicalAmountLedger = _costAmount;
        return updPhysicalAmountLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updPhysicalRevenueAmountLedger</Name>
				<Source><![CDATA[
    public CostAmount updPhysicalRevenueAmountLedger(AmountMSTPhysicalRevenue _amountMST = 0)
    {
        updPhysicalRevenueAmountLedger = _amountMST;
        return updPhysicalRevenueAmountLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updPhysicalUnit</Name>
				<Source><![CDATA[
    public UnitQty updPhysicalUnit()
    {
        return updPhysicalUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdQty</Name>
				<Source><![CDATA[
    public static boolean checkUpdQty(
        InventQty               _inventQty,
        UnitOfMeasureSymbol     _inventUnit,
        UnitQty                 _unitQty     = _inventQty,
        UnitOfMeasureSymbol     _unitUnit    = _inventUnit)
    {
        boolean         ok = true;

        if ((_unitQty != 0 && _inventQty == 0))
        {
            ok = checkFailed(strFmt("@SYS19585", _inventUnit));
            if (_inventUnit != _unitUnit)
            {
                ok = checkFailed(strFmt("@SCM:SourceQtyConvertedToZeroInventoryUnitQty", _unitQty, _unitUnit, _inventUnit));
            }
        }

        if ((_unitQty == 0 && _inventQty != 0))
        {
            ok = checkFailed(strFmt("@SYS19586", _unitUnit));
        }

        if (_unitQty != 0.0 && _inventQty != 0.0 && sign(_unitQty) * sign(_inventQty) < 0)
        {
            ok = checkFailed(strFmt("@SYS19587", _unitUnit, _inventUnit));
        }

        if (_inventQty != decRound(_inventQty, UnitOfMeasure::unitOfMeasureDecimalPrecision(
                UnitOfMeasure::unitOfMeasureIdBySymbol(_inventUnit))))
        {
            ok = checkFailed(strFmt("@SYS19588", _inventUnit));
        }

        if (_unitQty != decRound(_unitQty, UnitOfMeasure::unitOfMeasureDecimalPrecision(
                UnitOfMeasure::unitOfMeasureIdBySymbol(_unitUnit))))
        {
            ok = checkFailed(strFmt("@SYS19589", _unitUnit));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdRemainQty</Name>
				<Source><![CDATA[
    public static boolean  checkUpdRemainQty(
        InventQty               _remainInvent,
        UnitOfMeasureSymbol     _inventUnit,
        UnitQty                 _remainUnit     = _remainInvent,
        UnitOfMeasureSymbol     _unitUnit       = _inventUnit)
    {
        boolean         ok = true;

        if ((_remainUnit != 0 && _remainInvent== 0))
        {
            ok = checkFailed(strFmt("@SYS19590", _inventUnit));
        }

        if ((_remainUnit== 0 && _remainInvent != 0))
        {
            ok = checkFailed(strFmt("@SYS19591", _unitUnit));
        }

        if (_remainUnit * _remainInvent < 0)
        {
            ok = checkFailed(strFmt("@SYS19592", _unitUnit, _inventUnit));
        }

        if (_remainInvent != decRound(_remainInvent, UnitOfMeasure::unitOfMeasureDecimalPrecision(
                UnitOfMeasure::unitOfMeasureIdBySymbol(_inventUnit))))
        {
            ok = checkFailed(strFmt("@SYS19593", _inventUnit));
        }

        if (_remainUnit != decRound(_remainUnit, UnitOfMeasure::unitOfMeasureDecimalPrecision(
                UnitOfMeasure::unitOfMeasureIdBySymbol(_unitUnit))))
        {
            ok = checkFailed(strFmt("@SYS19594", _unitUnit));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>InventUpd_Physical</c> class.
    /// </summary>
    /// <param name="_movement">
    ///    A <c>InventMovement</c> variable required for instantiation of the class.
    /// </param>
    /// <returns>
    ///    A new instance of the <c>InventUpd_Physical</c> class.
    /// </returns>
    /// <remarks>
    ///    Use the following procedure to customize or extend the
    ///    <c>
    ///       InventUpd_Physical
    ///    </c>
    ///     class.
    ///    <list type="number">
    ///       <item>
    ///          <description>
    ///             Create a new class that derives from <c>InventUpd_Physical</c>.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             Overlayer the <c>construct</c> method on <c>InventUpd_Physical</c> so that it returns an instance
    ///             of the derived class.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             Override the methods from the <c>InventUpd_Physical</c> class that you want to customize or extend
    ///             in your derived class.
    ///          </description>
    ///       </item>
    ///    </list>
    ///     This procedure helps make sure that your customizations are maintained if the base version of the
    ///    <c>
    ///       InventUpd_Physical
    ///    </c>
    ///     class is changed, minimizing code conflicts during an upgrade. For more information, see <see cref="Best Practices for Static Construct Methods" />
    ///    .
    /// </remarks>
    protected static InventUpd_Physical construct(InventMovement _movement)
    {
        return new InventUpd_Physical(_movement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructForPurchPackingSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a purchase order packing slip
    /// </summary>
    /// <param name = "_inventMovement">An instance of the <c>InventMovement</c> class.</param>
    /// <param name = "_vendPackingSlipTrans">A <c>CustPackingSlipTrans</c> table buffer.</param>
    /// <param name = "_packingSlipId">The packing slip id</param>
    /// <param name = "_previousVendPackingSlipTransHistory">A <c>VendPackingSlipTransHistory</c> table buffer.</param>
    /// <param name = "_inventDimIdPhysicalMatched">The inventory dimension number.</param>
    /// <returns>An instance of the <c>InventUpd_Physical</c> class.</returns>
    protected static InventUpd_Physical constructForPurchPackingSlip(
        InventMovement                  _inventMovement,
        VendPackingSlipTrans            _vendPackingSlipTrans,
        PackingSlipId                   _packingSlipId,
        VendPackingSlipTransHistory     _previousVendPackingSlipTransHistory,
        InventDimId                     _inventDimIdPhysicalMatched)
    {
        InventUpd_Physical  physical            = InventUpd_Physical::construct(_inventMovement);
        RefRecId            sourceDocumentLine  = _vendPackingSlipTrans.SourceDocumentLine;
        Amount              amount;
        Amount              amountSecCur;
        CurrencyCode        currencyCodeSecCur;
        InventDimParm       inventDimParm;

        Debug::assert(sourceDocumentLine != 0);

        physical.setParmAllowDefault();

        // If specific dimensions have been chosen then we match against those.
        if (_inventDimIdPhysicalMatched && _inventDimIdPhysicalMatched != _inventMovement.inventDimId())
        {
            physical.parmInventDimPhysicalMatched(InventDim::find(_inventDimIdPhysicalMatched));
            physical.parmInventDim(physical.parmInventDimPhysicalMatched());
            inventDimParm.initPhysicalDimensionsFromInventDim(
                InventDimGroupSetup::newItemId(_inventMovement.itemId()),
                physical.parmInventDimPhysicalMatched());
            physical.parmInventDimParm(inventDimParm);
        }

        if (!_previousVendPackingSlipTransHistory.RecId)
        {
            physical.parmPhysical(_vendPackingSlipTrans.InventQty);
            physical.parmPhysicalUnit(_vendPackingSlipTrans.Qty);
            physical.parmPdsCWPhysical(_vendPackingSlipTrans.PdsCWQty);
        }
        else
        {
            physical.parmPhysical(_vendPackingSlipTrans.InventQty - _previousVendPackingSlipTransHistory.InventQty );
            physical.parmPhysicalUnit(_vendPackingSlipTrans.Qty - _previousVendPackingSlipTransHistory.Qty);
            physical.parmVoucherMatched(_vendPackingSlipTrans.CostLedgerVoucher);
            physical.parmDateMatched(_vendPackingSlipTrans.InventDate);
            physical.parmPdsCWPhysical(_vendPackingSlipTrans.PdsCWQty-_previousVendPackingSlipTransHistory.PdsCWQty);
        }

        physical.parmRemainPhysical(_vendPackingSlipTrans.RemainInvent);
        physical.parmRemainPhysicalUnit(_vendPackingSlipTrans.Remain);
        physical.parmPdsCWRemainPhysical(_vendPackingSlipTrans.PdsCWRemain);

        physical.parmPackingSlipId(_packingSlipId);

        if (_previousVendPackingSlipTransHistory)
        {
            amount = InventCostInputAmount::getInputAmountFromDistribution(sourceDocumentLine, _inventMovement, AccountingDistributionReferenceRole::Adjusting) +
                     InventCostInputAmount::getInputAmountFromDistribution(sourceDocumentLine, _inventMovement, AccountingDistributionReferenceRole::None) +
                     InventCostInputAmount::getInputAmountFromDistribution(sourceDocumentLine, _inventMovement, AccountingDistributionReferenceRole::Reversing);

            amount += CostProductReceiptMarkup::amountForCorrection(_vendPackingSlipTrans,
                                                                    _vendPackingSlipTrans.InventQty - _previousVendPackingSlipTransHistory.InventQty);
        }
        else
        {
            amount = InventCostInputAmount::getInputAmountFromDistribution(sourceDocumentLine, _inventMovement, AccountingDistributionReferenceRole::None);

            amount += CostProductReceiptMarkup::newVendPackingSlipTrans(_vendPackingSlipTrans).getProductReceiptAmount(_vendPackingSlipTrans.InventQty);
        }

        physical.parmCostInputAmount(InventCostInputAmount::construct(physical.parmPhysical(), amount));

        if (_inventMovement.projId() && _vendPackingSlipTrans.InventQty < 0)
        {
            physical.parmProjCostAmountMST(amount);
        }

        if (_inventMovement.parmCompanyCountryRegion().isCountryRegionRU())
        {
            currencyCodeSecCur = CompanyInfoHelper::secondaryCurrency_RU();
            if (_previousVendPackingSlipTransHistory)
            {
                amountSecCur = InventCostInputAmount::getInputAmountFromDistribution_RU(sourceDocumentLine, _inventMovement, AccountingDistributionReferenceRole::Adjusting, currencyCodeSecCur) +
                               InventCostInputAmount::getInputAmountFromDistribution_RU(sourceDocumentLine, _inventMovement, AccountingDistributionReferenceRole::None,      currencyCodeSecCur) +
                               InventCostInputAmount::getInputAmountFromDistribution_RU(sourceDocumentLine, _inventMovement, AccountingDistributionReferenceRole::Reversing, currencyCodeSecCur);
            }
            else
            {
                amountSecCur = InventCostInputAmount::getInputAmountFromDistribution_RU(sourceDocumentLine, _inventMovement, AccountingDistributionReferenceRole::None, currencyCodeSecCur);
            }

            physical.parmCostInputAmountSecCur_RU(InventCostInputAmount::construct(physical.parmPhysical(), amountSecCur));
        }

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructForSalesPackingSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a sales order packing slip.
    /// </summary>
    /// <param name = "_inventMovement">An instance of the <c>InventMovement</c> class.</param>
    /// <param name = "_custPackingSlipTrans">A <c>CustPackingSlipTrans</c> table buffer.</param>
    /// <param name = "_packingSlipId">The packing slip id.</param>
    /// <param name = "_physicalReduction">The level of physical reduction.</param>
    /// <param name = "_previousCustPackingSlipTransHistory">A <c>CustPackingSlipTransHistory</c> table buffer.</param>
    /// <param name = "_voucherMatched">The matched voucher.</param>
    /// <param name = "_inventDimIdPhysicalMatched">The inventory dimension number.</param>
    /// <returns>An instance of the <c>InventUpd_Physical</c> class.</returns>
    protected static InventUpd_Physical constructForSalesPackingSlip(
        InventMovement                  _inventMovement,
        CustPackingSlipTrans            _custPackingSlipTrans,
        PackingSlipId                   _packingSlipId,
        InventPhysicalReduction         _physicalReduction                      = InventPhysicalReduction::None,
        CustPackingSlipTransHistory     _previousCustPackingSlipTransHistory    = null,
        Voucher                         _voucherMatched                         = '',
        InventDimId                     _inventDimIdPhysicalMatched             = '')
    {
        InventUpd_Physical          physical = InventUpd_Physical::construct(_inventMovement);
        PdsBatchDispCheck_PackSlip  pdsDispCheckPack;

        if (#PdsEnabled && _inventMovement.inventTable().isItemBatchActivated())
        {
            if (InventBatch::pdsCheckUnavailable(
                    _inventMovement.inventdim().InventBatchId,
                    _inventMovement.itemId()))
            {
                pdsDispCheckPack = PdsBatchDispCheck_PackSlip::construct();
                if (_inventMovement.childBuffer() != null)
                {
                    if (!pdsDispCheckPack.validateCheck(_inventMovement.childBuffer()))
                    {
                        throw error("@PRO2138");
                    }
                }
                else
                {
                    if (!pdsDispCheckPack.validateCheck(_custPackingSlipTrans))
                    {
                        throw error("@PRO2138");
                    }
                }
            }
        }

        physical.setParmAllowDefault();

        if (!_previousCustPackingSlipTransHistory.RecId)
        {
            physical.parmPhysical(-_custPackingSlipTrans.InventQty);
            physical.parmPhysicalUnit(-_custPackingSlipTrans.Qty);
            physical.parmPdsCWPhysical(-_custPackingSlipTrans.PdsCWQty);
        }
        else
        {
            physical.parmPhysical(-_custPackingSlipTrans.InventQty + _previousCustPackingSlipTransHistory.InventQty);
            physical.parmPhysicalUnit(-_custPackingSlipTrans.Qty + _previousCustPackingSlipTransHistory.Qty);
            physical.parmPdsCWPhysical(-_custPackingSlipTrans.PdsCWQty + _previousCustPackingSlipTransHistory.PdsCWQty);
            physical.parmVoucherMatched(_voucherMatched);
            physical.parmDateMatched(_custPackingSlipTrans.DeliveryDate);

            // If specific dimensions have been chosen then we match against those.
            if (_inventDimIdPhysicalMatched != _inventMovement.inventDimId())
            {
                physical.parmInventDimPhysicalMatched(InventDim::find(_inventDimIdPhysicalMatched));
            }
        }
        physical.parmRemainPhysical(-_custPackingSlipTrans.RemainInvent);
        physical.parmRemainPhysicalUnit(-_custPackingSlipTrans.Remain);
        physical.parmPdsCWRemainPhysical(-_custPackingSlipTrans.PdsCWRemain);
        physical.parmPackingSlipId(_packingSlipId);
        physical.parmPhysicalReduction(_physicalReduction);
        physical.parmPhysicalJournalLine(_custPackingSlipTrans);

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newAutoLossProfit</Name>
				<Source><![CDATA[
    public static InventUpd_Physical newAutoLossProfit(
        InventMovement          _movement,
        InventUpd_Physical      _inventUpd_Physical,
        InventQty               _physical,
        UnitQty                 _physicalUnit,
        AmountMST               _amountMST)
    {
        InventUpd_Physical physical = InventUpd_Physical::construct(_movement);
        InventQty   remainPhysical,remainPhysical_mov;
        UnitQty     remainPhysicalUnit, remainPhysicalUnit_mov;
        InventTrans         inventTransPurchLine;
        InventTrans         inventTransQuarantineOrder;
        InventTransOrigin   inventTransOriginPurchLine;
        InventTransOrigin   inventTransOriginQuarantineOrder;

        remainPhysical_mov      =_physical-_inventUpd_Physical.parmRemainPhysical();
        remainPhysicalUnit_mov  =_physicalUnit-_inventUpd_Physical.parmRemainPhysicalUnit();
        remainPhysical          =-_inventUpd_Physical.parmRemainPhysical();
        remainPhysicalUnit      =-_inventUpd_Physical.parmRemainPhysicalUnit();

        physical.setParmAllowDefault();
        physical.parmAllowNegativePhysical(true);
        physical.parmPhysicalReduction(_inventUpd_Physical.parmPhysicalReduction());
        physical.parmAllowReserveOrdered(_inventUpd_Physical.parmAllowReserveOrdered());
        physical.parmReturnMode(_inventUpd_Physical.parmReturnMode());
        physical.parmPhysical(_physical);
        physical.parmRemainPhysical(remainPhysical);
        physical.movement().setRemainPhysicalUnit(remainPhysicalUnit_mov);
        physical.movement().setRemainPhysical(remainPhysical_mov);
        physical.parmPhysicalUnit(_physicalUnit);
        physical.parmRemainPhysicalUnit(remainPhysicalUnit);
        physical.movement().inventdim(_inventUpd_Physical.movement().inventdim());
        physical.parmInventDim(_inventUpd_Physical.parmInventDim());
        physical.parmInventDimParm(_inventUpd_Physical.parmInventDimParm());
        physical.parmPackingSlipId(_inventUpd_Physical.parmPackingSlipId());
        physical.parmVoucherMatched(_inventUpd_Physical.parmVoucherMatched());
        physical.parmDateMatched(_inventUpd_Physical.parmDateMatched());

        if (_inventUpd_Physical.movement() is InventMov_Quarantine)
        {
            select PackingSlipId
                from inventTransPurchLine
                where inventTransPurchLine.MarkingRefInventTransOrigin == _inventUpd_Physical.movement().inventTransOriginId()
                exists join inventTransOriginPurchLine
                    where inventTransOriginPurchLine.RecId == inventTransPurchLine.InventTransOrigin &&
                        inventTransOriginPurchLine.ReferenceCategory == InventTransType::Purch;
            physical.parmPackingSlipId(inventTransPurchLine.PackingSlipId);
        }

        if (_inventUpd_Physical.parmReturnMode() &&
            _inventUpd_Physical.movement().mustUpdateVoucherMatched())
        {
            select VoucherPhysical
                from inventTransQuarantineOrder
                    where inventTransQuarantineOrder.InventTransOrigin ==  _movement.inventTransOriginId() &&
                          inventTransQuarantineOrder.PackingSlipId  == _inventUpd_Physical.parmPackingSlipId()
                exists join inventTransOriginQuarantineOrder
                    where inventTransOriginQuarantineOrder.RecId == inventTransQuarantineOrder.MarkingRefInventTransOrigin &&
                          inventTransOriginQuarantineOrder.ReferenceCategory == InventTransType::QuarantineOrder;

            if (inventTransQuarantineOrder.VoucherPhysical)
            {
                physical.parmVoucherMatched(inventTransQuarantineOrder.VoucherPhysical);
            }
        }

        physical.parmCalledFromFinancial(_inventUpd_Physical.parmCalledFromFinancial());
        physical.parmAdjustWMSLocationLoad(_inventUpd_Physical.parmAdjustWMSLocationLoad());

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCheckPostProdJournalBOM</Name>
				<Source><![CDATA[
    public static InventUpd_Physical newCheckPostProdJournalBOM(
        ProdBOM             _prodBOM,
        ProdJournalBOM      _prodJournalBOM,
        ProdJournalTable    _prodJournalTable)
    {
        InventUpd_Physical  physical;
        InventMovement      inventMovement;
        InventDimParm       inventDimParm;

        inventMovement = InventMovement::construct(_prodBOM, InventMovSubType::None, _prodJournalBOM);

        if (inventMovement.parmCompanyCountryRegion().isCountryRegionRU())
        {
            inventMovement.parmStornoPhysical_RU(_prodJournalBOM.StornoPhysical_RU &&
                                                 ((_prodBOM.QtyInventStUp > 0 && _prodJournalBOM.InventConsump < 0) ||
                                                  (_prodBOM.QtyInventStUp < 0 && _prodJournalBOM.InventConsump > 0)));
            inventMovement.parmStornoPhysicalForced_RU(_prodBOM.QtyInventStUp < 0 && _prodJournalBOM.InventConsump > 0);
        }

        physical = InventUpd_Physical::construct(inventMovement);

        physical.setParmAllowDefault();

        physical.parmPhysicalReduction(_prodJournalTable.ReducePhysical ? InventPhysicalReduction::Reduce : InventPhysicalReduction::None);
        if (!physical.movement().inventTable().inventItemType().isServiceItem())
        {
            physical.parmAllowNegativePhysical(_prodJournalTable.DrawNegative && physical.parmAllowNegativePhysical());
        }

        physical.parmPhysical(-_prodJournalBOM.InventConsump);
        physical.parmRemainPhysical(-_prodJournalBOM.calcRemainInventPhysical(_prodBOM));
        physical.parmPhysicalUnit(-_prodJournalBOM.bomConsump);
        physical.parmRemainPhysicalUnit(-_prodJournalBOM.calcRemainBOMPhysical(_prodBOM));

        if (_prodJournalBOM.InventConsump < 0)
        {
            // Returning items
            physical.parmInventDim(_prodJournalBOM.inventDim());
            inventDimParm.initFromInventDim(physical.parmInventDim());
            physical.parmInventDimParm(inventDimParm);
        }

        if (!physical.parmRemainPhysical() &&   physical.parmRemainPhysicalUnit())
        {
            physical.parmRemainPhysicalUnit(0);
        }

        if (physical.parmRemainPhysical() && ! physical.parmRemainPhysicalUnit())
        {
            physical.parmRemainPhysical(0);
        }

        physical.parmPdsCWPhysical(-_prodJournalBOM.PdsCWInventConsump);
        physical.parmPdsCWRemainPhysical(-_prodJournalBOM.pdsCWCalcRemainPhysical(_prodBOM));

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCheckPostProdJournalProd</Name>
				<Source><![CDATA[
    public static InventUpd_Physical newCheckPostProdJournalProd(
        ProdTable           _prodTable,
        ProdJournalProd     _prodJournalProd)
    {
        InventUpd_Physical  physical;
        InventDim           inventDim;
        InventDimParm       inventDimParm;
        InventMovement      inventMovement;

        inventMovement = InventMovement::construct(_prodTable,InventMovSubType::None,_prodJournalProd);

        if (inventMovement.parmCompanyCountryRegion().isCountryRegionRU())
        {
            inventMovement.parmStornoPhysical_RU(_prodJournalProd.isInventReturn() && _prodJournalProd.StornoPhysical_RU);
        }

        physical = InventUpd_Physical::construct(inventMovement);

        physical.setParmAllowDefault();

        physical.parmPhysical(_prodJournalProd.QtyGood);
        physical.parmRemainPhysical(_prodJournalProd.calcRemainInventPhysical(_prodTable));
        physical.parmPhysicalUnit(physical.parmPhysical());
        physical.parmRemainPhysicalUnit(physical.parmRemainPhysical());

        physical.parmPdsCWPhysical(_prodJournalProd.PdsCWBatchGood);
        physical.parmPdsCWRemainPhysical(_prodJournalProd.pdsCalcRemainInventPhysical(_prodTable));

        if (_prodJournalProd.isInventReturn())
        {
            // if returning items they must match the dimensions specified on the journal line.
            inventDim = InventDim::find(_prodJournalProd.InventDimId);
            inventDimParm.initFromInventDim(inventDim);
            physical.parmInventDim(inventDim);
            physical.parmInventDimParm(inventDimParm);
        }

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newGoodsInRouteDelivery_RU</Name>
				<Source><![CDATA[
    public static InventUpd_Physical newGoodsInRouteDelivery_RU(InventMovement          _movement,
                                                                InventUpd_Financial     _financial)
    {
        InventUpd_Physical physical;

        physical = InventUpd_Physical::construct(_movement);

        physical.setParmAllowDefault();

        physical.parmAllowNegativePhysical(true);

        physical.parmPhysicalReduction(InventPhysicalReduction::None);
        physical.parmAllowReserveOrdered(false);
        physical.parmReturnMode(false);

        physical.parmPhysical(_movement.transQty());
        physical.parmPhysicalUnit(_movement.transQtyUnit());

        physical.parmPdsCWPhysical(_movement.pdsCWTransQty());
        physical.parmPdsCWRemainPhysical(_movement.pdsCWRemainPhysical());

        physical.parmRemainPhysical(0);
        physical.parmRemainPhysicalUnit(0);

        physical.parmCalledFromFinancial(false);

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventMovement</Name>
				<Source><![CDATA[
    public static InventUpd_Physical newInventMovement(InventMovement _inventMovement)
    {
        return InventUpd_Physical::construct(_inventMovement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newAdjustProjItemTrans</Name>
				<Source><![CDATA[
    public static InventUpd_Physical newAdjustProjItemTrans(InventMovement _inventMovement,
        ProjItemTrans _projItemTrans,
        InventPhysicalReduction _physicalReduction = InventPhysicalReduction::None)
    {
        InventUpd_Physical physical = InventUpd_Physical::construct(_inventMovement);
        physical.setParmAllowDefault();
        
        // When posting packing slip it is possible that the linked inventory transaction has been split due to multiple picking lists
        // This method is getting called per inventory transaction linked to project transaction
        // Hence the following code is added to post inventory physically with inventory quantity
        // When projItemTrans.Qty is used, the whole qty gets posted multiple times, once for each inventory transaction leading to qty and cost on project getting multiplied

        if (ProjAdjustItemReqWithMultiPickingListFlight::instance().isEnabled())
        {
            physical.parmPhysical(_inventMovement.transQty());
            physical.parmPhysicalUnit(_inventMovement.transQtyUnit());
            if (PdsGlobal::pdsIsCWItem(_projItemTrans.ItemId))
            {
                PdsCWInventQty cwQty = PdsCatchWeight::cwQty(_projItemTrans.ItemId, _inventMovement.transQty());
                physical.parmPdsCWPhysical(cwQty);
            }
        }
        else
        {
            physical.parmPhysical(-_projItemTrans.Qty);
            physical.parmPhysicalUnit(-_projItemTrans.Qty);
            if (PdsGlobal::pdsIsCWItem(_projItemTrans.ItemId))
            {
                PdsCWInventQty cwQty = PdsCatchWeight::cwQty(_projItemTrans.ItemId, -_projItemTrans.Qty);
                physical.parmPdsCWPhysical(cwQty);
            }
        }
        physical.parmPackingSlipId(_projItemTrans.PackingSlipId);
        physical.parmPhysicalReduction(_physicalReduction);

        physical.init();
        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventQualityOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>InventUpd_Physical</c> class to use to post physical updates for
    ///    quality orders.
    /// </summary>
    /// <param name="_movement">
    ///    The <c>InventMovement</c> object that wraps the quality order.
    /// </param>
    /// <param name="_qty">
    ///    The physical quantity to post.
    /// </param>
    /// <returns>
    ///    An instance of the <c>InventUpd_Physical</c> class.
    /// </returns>
    public static InventUpd_Physical newInventQualityOrder(
        InventMovement      _movement,
        InventQty           _qty)
    {
        InventUpd_Physical physical     = InventUpd_Physical::construct(_movement);

        physical.setParmAllowDefault();

        physical.parmPhysical(_qty);
        physical.parmRemainPhysical(0);
        physical.parmPhysicalUnit(_qty);
        physical.parmRemainPhysicalUnit(0);
        physical.parmPhysicalReduction(InventPhysicalReduction::None);

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventQuarantineOrderIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>InventUpd_Physical</c> class to use to post physical updates for a
    /// quarantine order issue.
    /// </summary>
    /// <param name="_movement">
    /// The <c>InventMovement</c> object that wraps the quarantine order.
    /// </param>
    /// <param name="_qty">
    /// The quantity to update.
    /// </param>
    /// <param name="_remainQty">
    /// The remaining quantity.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity to update.
    /// </param>
    /// <param name="_cwRemainQty">
    /// The catch weight remaining quantity.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventUpd_Physical</c> class.
    /// </returns>
    public static InventUpd_Physical newInventQuarantineOrderIssue(
        InventMovement      _movement,
        InventQty           _qty,
        InventQty           _remainQty,
        PdsCWInventQty      _cwQty = 0,
        PdsCWInventQty      _cwRemainQty = 0
        )
    {
        return InventUpd_Physical::newInventQuarantineOrderReceipt(_movement, _qty, _remainQty, 0.0, _cwQty,_cwRemainQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventQuarantineOrderReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>InventUpd_Physical</c> class to use to post physical updates for a
    /// quarantine order receipt.
    /// </summary>
    /// <param name="_movement">
    /// The <c>InventMovement</c> object that wraps the quarantine order.
    /// </param>
    /// <param name="_qty">
    /// The quantity to update.
    /// </param>
    /// <param name="_remainQty">
    /// The remaining quantity.
    /// </param>
    /// <param name="_amount">
    /// The cost of the receipt.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity to update.
    /// </param>
    /// <param name="_cwRemainQty">
    /// The catch weight remaining quantity.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventUpd_Physical</c> class.
    /// </returns>
    public static InventUpd_Physical newInventQuarantineOrderReceipt(
        InventMovement      _movement,
        InventQty           _qty,
        InventQty           _remainQty,
        CostAmount          _amount,
        PdsCWInventQty      _cwQty = 0,
        PdsCWInventQty      _cwRemainQty = 0
        )
    {
        InventUpd_Physical physical = InventUpd_Physical::construct(_movement);

        physical.setParmAllowDefault();

        physical.parmPhysical(_qty);
        physical.parmRemainPhysical(_remainQty);
        physical.parmPhysicalUnit(_qty);
        physical.parmRemainPhysicalUnit(_remainQty);
        physical.parmPhysicalReduction(InventPhysicalReduction::None);
        physical.parmCostInputAmount(InventCostInputAmount::construct(_qty, _amount));
        physical.parmPdsCWPhysical(_cwQty);
        physical.parmPdsCWRemainPhysical(_cwRemainQty);

        if (_movement.parmCompanyCountryRegion().isCountryRegionRU())
        {
            physical.parmCostInputAmountSecCur_RU(InventCostInputAmount::construct(_qty, CurrencyExchangeHelper::amountMST2MSTSecond_RU(_amount, _movement.transDate())));
        }

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventUpdFinancial</Name>
				<Source><![CDATA[
    public static InventUpd_Physical newInventUpdFinancial(
        InventMovement          _movement,
        InventUpd_Financial     _financial,
        InventQty               _physical,
        UnitQty                 _physicalUnit,
        AmountMST               _amountMST,
        PdsCWInventQty          _cwPhysical = 0
        , AmountMSTSecondary      _amountMSTSecCur = 0
        )
    {
        InventUpd_Physical physical = InventUpd_Physical::construct(_movement);

        physical.setParmAllowDefault();

        physical.parmPhysical(_physical);
        physical.parmRemainPhysical(_financial.parmRemainPhysical());
        physical.parmPhysicalUnit(_physicalUnit);
        physical.parmRemainPhysicalUnit(_financial.parmRemainPhysicalUnit());
        physical.parmProjCostAmountMST(_amountMST);
        physical.parmPhysicalJournalLine(_financial.parmFinancialJournalLine());

        if (_movement.parmCompanyCountryRegion().isCountryRegionRU())
        {
            physical.parmProjCostAmountMSTSecCur_RU(_financial.parmCostAmountCurSecCur_RU());
            physical.parmRemainBeforePhysical_RU(_financial.parmRemainBeforePhysical_RU());
            physical.parmRemainBeforePhysicalUnit_RU(_financial.parmRemainBeforePhysicalUnit_RU());
            physical.parmNeedTransIdTransit_RU(_financial.parmNeedTransIdTransit_RU());
            physical.parmDocumentStornoId_RU(_financial.parmDocumentStornoId_RU());
            physical.parmCostInputAmountSecCur_RU(InventCostInputAmount::construct(_physical, _amountMSTSecCur));
        }

        physical.parmCostInputAmount(InventCostInputAmount::construct(_physical, _amountMST));

        physical.parmPhysicalReduction(_financial.parmPhysicalReduction());
        physical.parmAllowNegativePhysical(_financial.parmAllowNegativePhysical());
        physical.parmReturnMode(_financial.returnMode());
        physical.parmCalledFromFinancial(true);
        physical.parmAllowReserveOrdered(_financial.parmAllowReserveOrdered());
        physical.parmAllowAutoReserveDim(_financial.parmAllowAutoReserveDim());
        physical.parmInventDim(_financial.parmInventDim());
        physical.parmInventDimParm(_financial.parmInventDimParm());
        physical.parmSkipInventTransSumUp(_financial.parmSkipInventTransSumUp());
        physical.parmWhsLocationMixingConstraintCheckSkip(_financial.parmWhsLocationMixingConstraintCheckSkip());

        physical.parmPdsCWPhysical(_cwPhysical);
        physical.parmPdsCWRemainPhysical(_financial.parmPdsCWRemainPhysical());
        physical.parmAdjustWMSLocationLoad(_financial.parmAdjustWMSLocationLoad());

        if (_movement.parmSalesPackingSlipJournalPostProj())
        {
            physical.parmPackingSlipId(_financial.parmInvoiceId());
        }

        if (_movement.parmCompanyCountryRegion().isCountryRegionRU() && (_movement.transInventRefType() == InventRefType::InventTransfer || _movement.transType() == InventTransType::TransferOrderScrap))
        {
            physical.parmTransferOrderVoucherMatched(_financial.parmTransferOrderVoucherMatched());
        }

        if (!_movement.parmCompanyCountryRegion().isCountryRegionRU() && 
            _movement.transType() == InventTransType::TransferOrderShip && 
            _financial.returnMode() == InventUpdate::financialReturn() &&
            InventUpdMatchVoucherWhenTransferOrderCancelFlight::instance().isEnabled())
        {
            physical.parmTransferOrderVoucherMatched(_financial.parmTransferOrderVoucherMatched());
        }

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newKanban</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a an instance of the <c>InventUpd_Physical</c> class to use to post physical updates for a
    ///    kanban.
    /// </summary>
    /// <param name="_kanban">
    ///    A <c>Kanban</c> record.
    /// </param>
    /// <returns>
    ///    An instance of the <c>InventUpd_Physical</c> class.
    /// </returns>
    public static InventUpd_Physical newKanban(Kanban _kanban)
    {
        InventUpd_Physical  physical = InventUpd_Physical::construct(InventMovement::construct(_kanban));

        physical.setParmAllowDefault();
        physical.parmPhysical(-_kanban.QuantityReceived);
        physical.parmRemainPhysical(0);
        physical.parmPhysicalUnit(-_kanban.QuantityReceived);
        physical.parmRemainPhysicalUnit(0);

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newKanbanJob</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>InventUpd_Physical</c> class to use to post physical updates for a
    ///    kanban job.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The instance of the <c>InventMovement</c> class that wraps the quality order.
    /// </param>
    /// <returns>
    ///    An instance of the <c>InventUpd_Physical</c> class.
    /// </returns>
    public static InventUpd_Physical newKanbanJob(InventMovement _inventMovement)
    {
        InventUpd_Physical  physical = InventUpd_Physical::construct(_inventMovement);
        KanbanJob           kanbanJob;

        kanbanJob = _inventMovement.buffer();

        physical.setParmAllowDefault();
        physical.parmPhysical(kanbanJob.QuantityReceived * _inventMovement.transSign());
        physical.parmRemainPhysical(0);
        physical.parmPhysicalUnit(kanbanJob.QuantityReceived * _inventMovement.transSign());
        physical.parmRemainPhysicalUnit(0);

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newKanbanJobPickingList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>InventUpd_Physical</c> class to use to post physical updates for a
    ///    kanban picking list.
    /// </summary>
    /// <param name="_kanbanJobPickingList">
    ///    A <c>KanbanJobPickingList</c> record.
    /// </param>
    /// <param name="_inventQty">
    ///    The quantity to update.
    /// </param>
    /// <returns>
    ///    An instance of the <c>InventUpd_Physical</c> class.
    /// </returns>
    public static InventUpd_Physical newKanbanJobPickingList(
        KanbanJobPickingList _kanbanJobPickingList,
        InventQty            _inventQty = _kanbanJobPickingList.Quantity)
    {
        InventUpd_Physical  physical = InventUpd_Physical::construct(_kanbanJobPickingList.inventMovement());

        physical.setParmAllowDefault();
        physical.parmPhysical(-_inventQty);
        physical.parmRemainPhysical(0);
        physical.parmPhysicalUnit(-_inventQty);
        physical.parmRemainPhysicalUnit(0);

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdAutoLossProfit</Name>
				<Source><![CDATA[
    public static InventUpd_Physical newProdAutoLossProfit(
        InventMovement  _movement,
        InventQty       _inventQty)
    {
        InventTransId           existingInventTransId_Virtuel;
        InventTransOriginId     existingInventTransOriginId_Virtuel;
        InventMov_Virtuel       movement_Virtuel;
        InventUpd_Physical      physical_Virtuel;

        existingInventTransOriginId_Virtuel = InventTransOrigin::findMarkingRefInventTransOrigin(_movement.inventTransOriginId(), _movement.itemId(), true);
        if (!existingInventTransOriginId_Virtuel)
        {
            return null;
        }
        existingInventTransId_Virtuel = InventTransOrigin::find(existingInventTransOriginId_Virtuel).InventTransId;

        movement_Virtuel = InventMov_Virtuel::newProdAutoLossProfitPhysical(_inventQty, _movement, existingInventTransId_Virtuel);

        physical_Virtuel = InventUpd_Physical::construct(movement_Virtuel);

        physical_Virtuel.setParmAllowDefault();
        physical_Virtuel.parmAllowNegativePhysical(true);

        physical_Virtuel.parmPhysical(_inventQty);
        physical_Virtuel.parmRemainPhysical(-_inventQty);
        physical_Virtuel.movement().setRemainPhysical(0);

        physical_Virtuel.parmPhysicalUnit(physical_Virtuel.parmPhysical());
        physical_Virtuel.parmRemainPhysicalUnit(physical_Virtuel.parmRemainPhysical());
        physical_Virtuel.movement().setRemainPhysicalUnit(0);

        physical_Virtuel.init();

        return physical_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdReleaseLossProfit_RU</Name>
				<Source><![CDATA[
    public static InventUpd_Physical newProdReleaseLossProfit_RU(InventMovement _movement,
                                                                 InventQty      _inventQty)
    {
        InventUpd_Physical physical = InventUpd_Physical::construct(_movement);

        physical.setParmAllowDefault();
        physical.parmPhysical(_inventQty);
        physical.parmRemainPhysical(0);
        physical.parmRemainPhysicalUnit(0);

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdReleaseTrans_RU</Name>
				<Source><![CDATA[
    public static InventUpd_Physical newProdReleaseTrans_RU(
        ProdReleaseTrans_RU _prodReleaseTrans,
        Sign                _sign       = 1,
        InventMovement      _movement   = InventMovement::construct(_prodReleaseTrans))
    {
        InventUpd_Physical  physical;
        InventDim           inventDim;
        InventDimParm       inventDimParm;

        _movement.parmStornoPhysical_RU(_prodReleaseTrans.ReleaseQty < 0 && _prodReleaseTrans.Storno);
        _movement.parmStornoPhysicalForced_RU(_prodReleaseTrans.ReleaseQty < 0 && _prodReleaseTrans.Storno);
        physical = InventUpd_Physical::construct(_movement);

        physical.setParmAllowDefault();

        physical.parmPhysical(_sign * _prodReleaseTrans.inventReleaseQty());
        physical.parmPhysicalUnit(_sign * _prodReleaseTrans.ReleaseQty);

        if (_prodReleaseTrans.ReleaseQty < 0)
        {
            // if returning items they must match the dimensions specified on the journal line.
            inventDim = InventDim::find(_prodReleaseTrans.InventDimId);
            inventDimParm.initFromInventDim(inventDim);
            physical.parmInventDim(inventDim);
            physical.parmInventDimParm(inventDimParm);
        }

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPurchPackingSlip</Name>
				<Source><![CDATA[
    public static InventUpd_Physical newPurchPackingSlip(
        InventMovement                  _inventMovement,
        VendPackingSlipTrans            _vendPackingSlipTrans,
        PackingSlipId                   _packingSlipId,
        VendPackingSlipTransHistory     _previousVendPackingSlipTransHistory = null,
        InventDimId                     _inventDimIdPhysicalMatched = '')
    {
        InventUpd_Physical physical = InventUpd_Physical::constructForPurchPackingSlip(
                                            _inventMovement,
                                            _vendPackingSlipTrans,
                                            _packingSlipId,
                                            _previousVendPackingSlipTransHistory,
                                            _inventDimIdPhysicalMatched); 

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPurchPackingSlipProforma</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes an instance of the <c>InventUpd_Physical</c> class to to be used for physical inventory update calculation.
    /// </summary>
    /// <param name="_inventMovement">
    /// An instance of the <c>InventMovement</c> class.
    /// </param>
    /// <param name="_vendPackingSlipTrans">
    /// A <c>VendPackingSlipTrans</c> table record.
    /// </param>
    /// <param name="_packingSlipId">
    /// A packing slip ID.
    /// </param>
    /// <param name="_previousVendPackingSlipTransHistory">
    /// A <c>VendPackingSlipTransHistory</c> table record.
    /// </param>
    /// <param name="_inventDimIdPhysicalMatched">
    /// An <c>InventDim</c> table record ID that specifies inventory dimensions that are matched against previous packing slip.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventUpd_Physical</c> class.
    /// </returns>
    public static InventUpd_Physical newPurchPackingSlipProforma(
        InventMovement                  _inventMovement,
        VendPackingSlipTrans            _vendPackingSlipTrans,
        PackingSlipId                   _packingSlipId,
        VendPackingSlipTransHistory     _previousVendPackingSlipTransHistory = null,
        InventDimId                     _inventDimIdPhysicalMatched = '')
    {
        InventUpd_Physical      physical            = InventUpd_Physical::construct(_inventMovement);

        physical.setParmAllowDefault();

        if (!_previousVendPackingSlipTransHistory.RecId)
        {
            physical.parmPhysical(_vendPackingSlipTrans.InventQty);
            physical.parmPhysicalUnit(_vendPackingSlipTrans.Qty);
            physical.parmPdsCWPhysical(_vendPackingSlipTrans.PdsCWQty);
        }
        else
        {
            physical.parmPhysical(_vendPackingSlipTrans.InventQty - _previousVendPackingSlipTransHistory.InventQty );
            physical.parmPhysicalUnit(_vendPackingSlipTrans.Qty - _previousVendPackingSlipTransHistory.Qty);
            physical.parmVoucherMatched(_vendPackingSlipTrans.CostLedgerVoucher);
            physical.parmDateMatched(_vendPackingSlipTrans.AccountingDate);

            // If specific dimensions have been chosen then we match against those.
            if (_inventDimIdPhysicalMatched != _inventMovement.inventDimId())
            {
                physical.parmInventDimPhysicalMatched(InventDim::find(_inventDimIdPhysicalMatched));
            }

            physical.parmPdsCWPhysical(_vendPackingSlipTrans.PdsCWQty-_previousVendPackingSlipTransHistory.PdsCWQty);
        }

        physical.parmRemainPhysical(_vendPackingSlipTrans.RemainInvent);
        physical.parmRemainPhysicalUnit(_vendPackingSlipTrans.Remain);
        physical.parmPdsCWRemainPhysical(_vendPackingSlipTrans.PdsCWRemain);

        physical.parmPackingSlipId(_packingSlipId);

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newRBOTransactionSalesTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>InventUpd_Physical</c> class when an update is performed for sales
    /// transactions.
    /// </summary>
    /// <param name="_inventMovement">
    /// An instance of <c>InventMovement</c> class.
    /// </param>
    /// <param name="_transactionSalesTrans">
    /// An instance of <c>RetailTransactionSalesTrans</c> table.
    /// </param>
    /// <returns>
    /// An instance of <c>InventUpd_Physical</c> class.
    /// </returns>
    public static InventUpd_Physical newRBOTransactionSalesTrans(InventMovement _inventMovement,
                                                                 RetailTransactionSalesTrans  _transactionSalesTrans)
    {
        InventUpd_Physical physical;

        physical = InventUpd_Physical::construct(_inventMovement);

        physical.setParmAllowDefault();

        physical.parmPhysical(_transactionSalesTrans.inventNow());
        physical.parmPhysicalUnit(_transactionSalesTrans.inventNow());

        physical.parmRemainPhysical(0);
        physical.parmRemainPhysicalUnit(0);

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newSalesPackingSlip</Name>
				<Source><![CDATA[
    public static InventUpd_Physical newSalesPackingSlip(
        InventMovement                  _inventMovement,
        CustPackingSlipTrans            _custPackingSlipTrans,
        PackingSlipId                   _packingSlipId,
        InventPhysicalReduction         _physicalReduction                      = InventPhysicalReduction::None,
        CustPackingSlipTransHistory     _previousCustPackingSlipTransHistory    = null,
        Voucher                         _voucherMatched                         = '',
        InventDimId                     _inventDimIdPhysicalMatched             = '')
    {
        InventUpd_Physical physical = InventUpd_Physical::constructForSalesPackingSlip(
                                            _inventMovement,
                                            _custPackingSlipTrans,
                                            _packingSlipId,
                                            _physicalReduction,
                                            _previousCustPackingSlipTransHistory,
                                            _voucherMatched,
                                            _inventDimIdPhysicalMatched);

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfNewCheckPostProdJournalCoBy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes new instance of the <c>InventUpd_Physical</c> class.
    /// </summary>
    /// <param name="_prodCoBy">
    /// A <c>PmfProdCoBy</c> record that is used to initialize the new instance of the class.
    /// </param>
    /// <param name="_prodJournalProd">
    /// A <c>ProdJournalProd</c> record that is used to initialize the new instance of class.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventUpd_Physical</c> class.
    /// </returns>
    public static InventUpd_Physical pmfNewCheckPostProdJournalCoBy(
        PmfProdCoBy         _prodCoBy,
        ProdJournalProd     _prodJournalProd)
    {
        InventUpd_Physical physical;

        physical = InventUpd_Physical::construct(
                            InventMovement::construct(
                                            _prodCoBy,
                                            InventMovSubType::None,
                                            _prodJournalProd));

        physical.setParmAllowDefault();

        physical.parmPhysicalReduction(InventPhysicalReduction::ReduceAndClose);

        if (!physical.movement().inventTable().inventItemType().isServiceItem())
        {
            physical.parmAllowNegativePhysical(true);
        }

        physical.parmPhysical(_prodJournalProd.QtyGood);
        physical.parmRemainPhysical(
                    _prodCoBy.RemainCoByPhysical - _prodJournalProd.QtyGood >= 0
                        ? _prodCoBy.RemainCoByPhysical - _prodJournalProd.QtyGood
                        : 0);
        physical.parmPhysicalUnit(_prodJournalProd.QtyGood);
        physical.parmRemainPhysicalUnit(physical.parmRemainPhysical());

        physical.parmPdsCWPhysical(_prodJournalProd.PdsCWBatchGood);
        physical.parmPdsCWRemainPhysical(_prodCoBy.PdsCWRemainPhysical - _prodJournalProd.PdsCWBatchGood >= 0 ? _prodCoBy.PdsCWRemainPhysical - _prodJournalProd.PdsCWBatchGood : 0);

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newKanbanJobPickingListReversal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>InventUpd_Physical</c> class to post physical updates for a
    ///    kanban picking list reversal.
    /// </summary>
    /// <param name="_kanbanJobPickingListReversal">
    ///    A <c>KanbanJobPickingListReversal</c> record.
    /// </param>
    /// <param name="_inventQty">
    ///    The quantity to update.
    /// </param>
    /// <returns>
    ///    An instance of the <c>InventUpd_Physical</c> class.
    /// </returns>
    public static InventUpd_Physical newKanbanJobPickingListReversal(
        KanbanJobPickingListReversal _kanbanJobPickingListReversal,
        InventQty                    _inventQty = _kanbanJobPickingListReversal.Quantity)
    {
        InventUpd_Physical  physical = InventUpd_Physical::construct(_kanbanJobPickingListReversal.inventMovement());

        physical.setParmAllowDefault();
        physical.parmPhysical(_inventQty);
        physical.parmRemainPhysical(0);
        physical.parmPhysicalUnit(_inventQty);
        physical.parmRemainPhysicalUnit(0);

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newConsignmentProductReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>InventUpd_Physical</c> class to post physical updates for a consignment product receipt journal line.
    /// </summary>
    /// <param name = "_inventMovement">The inventory movement for the physical update.</param>
    /// <param name = "_ledgerVoucher">The <c>LedgerVoucher</c> object to which the postings must be added.</param>
    /// <param name = "_productReceiptNumber">The product receipt number.</param>
    /// <param name = "_consignmentProductReceiptJournalLine">A <c>ConsignmentProductReceiptJournalLine</c> record.</param>
    /// <returns>An instance of the <c>InventUpd_Physical</c> class.</returns>
    public static InventUpd_Physical newConsignmentProductReceipt(
        InventMovement                          _movement,
        LedgerVoucher                           _ledgerVoucher,
        ConsignmentInternalProductReceiptNumber _productReceiptNumber,
        ConsignmentProductReceiptJournalLine    _consignmentProductReceiptJournalLine)
    {
        InventUpd_Physical physical = InventUpd_Physical::construct(_movement);

        physical.setParmAllowDefault();

        physical.parmPhysical(_consignmentProductReceiptJournalLine.calculateReplenishmentInventoryQuantity());
        physical.parmPhysicalUnit(_consignmentProductReceiptJournalLine.ReplenishmentQuantity);
        physical.parmRemainPhysical(_consignmentProductReceiptJournalLine.calculateReplenishmentInventoryQuantity(_consignmentProductReceiptJournalLine.RemainingReplenishmentQuantity));
        physical.parmRemainPhysicalUnit(_consignmentProductReceiptJournalLine.RemainingReplenishmentQuantity);

        physical.parmPackingSlipId(_productReceiptNumber);

        physical.parmCostInputAmount(InventCostInputAmount::construct(physical.parmPhysical(), 0));

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCheckPostInventJournalParameters</Name>
				<Source><![CDATA[
    protected void setCheckPostInventJournalParameters(InventMovement _movement)
    {
        this.setParmAllowDefault();

        this.parmPhysical(_movement.transQty());
        this.parmPhysicalUnit(_movement.transQty());
        this.parmPdsCWPhysical(_movement.pdsCWTransQty());

        this.parmRemainPhysical(0);
        this.parmRemainPhysicalUnit(0);
        this.parmPdsCWRemainPhysical(0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCheckPostInventJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>InventUpd_Physical</c> class to post physical updates for a inventory transfer journal line.
    /// </summary>
    /// <param name = "_movement">The inventory movement for the physical update.</param>
    /// <returns>An instance of the <c>InventUpd_Physical</c> class.</returns>
    public static InventUpd_Physical newCheckPostInventJournalTrans(InventMovement _movement)
    {
        InventUpd_Physical  physical = InventUpd_Physical::construct(_movement);
        physical.setCheckPostInventJournalParameters(_movement);
        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCheckPostOwnerEnabledInventJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>InventUpd_Physical</c> class to post physical updates for a inventory journal line with an owner enabled item.
    /// </summary>
    /// <param name = "_movement">The inventory movement for the physical update.</param>
    /// <returns>An instance of the <c>InventUpd_Physical</c> class.</returns>
    public static InventUpd_Physical newCheckPostOwnerEnabledInventJournalTrans(InventMovement _movement)
    {
        InventUpd_Physical physical = InventUpd_Physical::construct(_movement);

        physical.setCheckPostInventJournalParameters(_movement);
        physical.parmCostInputAmount(InventCostInputAmount::construct(physical.parmPhysical(), 0));

        physical.init();

        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newSalesPackingSlipCancel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes an instance of the <c>InventUpd_Physical</c> class to be used for physical inventory update calculation during packing slip cancellation.
    /// </summary>
    /// <param name = "_inventMovement">
    /// An instance of the <c>InventMovement</c> class.
    /// </param>
    /// <param name = "_custPackingSlipTrans">
    /// A <c>CustPackingSlipTrans</c> table record.
    /// </param>
    /// <param name = "_packingSlipId">
    /// A packing slip ID.
    /// </param>
    /// <param name = "_previousCustPackingSlipTransHistory">
    /// A <c>CustPackingSlipTransHistory</c> table record.
    /// </param>
    /// <param name = "_voucherMatched">
    /// The voucher to be matched against.
    /// </param>
    /// <param name = "_inventDimIdPhysicalMatched">
    /// An <c>InventDim</c> table record id that specifies inventory dimensions that are matched against previous packing slip.
    /// </param>
    /// <returns>
    /// An <c>InventDim</c> table record id that specifies inventory dimensions that are matched against previous packing slip.
    /// </returns>
    public static InventUpd_Physical newSalesPackingSlipCancel(
        InventMovement                  _inventMovement,
        CustPackingSlipTrans            _custPackingSlipTrans,
        PackingSlipId                   _packingSlipId,
        CustPackingSlipTransHistory     _previousCustPackingSlipTransHistory,
        Voucher                         _voucherMatched,
        InventDimId                     _inventDimIdPhysicalMatched
        )
    {
        InventUpd_Physical physical = InventUpd_Physical::construct(_inventMovement);
       
        physical.setParmAllowDefault();
        
        physical.parmPhysical(-_custPackingSlipTrans.InventQty + _previousCustPackingSlipTransHistory.InventQty);
        physical.parmPhysicalUnit(-_custPackingSlipTrans.Qty + _previousCustPackingSlipTransHistory.Qty);
        physical.parmPdsCWPhysical(-_custPackingSlipTrans.PdsCWQty + _previousCustPackingSlipTransHistory.PdsCWQty);
        physical.parmVoucherMatched(_voucherMatched);
        physical.parmDateMatched(_custPackingSlipTrans.DeliveryDate);
        
        // If specific dimensions have been chosen then we match against those.
        if (_inventDimIdPhysicalMatched != _inventMovement.inventDimId())
        {
            physical.parmInventDimPhysicalMatched(InventDim::find(_inventDimIdPhysicalMatched));
        }

        // Adjust the remaining quantities based on the what was updated in the earlier loop.
        InventQty      remainPhysical = _inventMovement.remainPhysical() - physical.parmPhysical();
        Qty            remainPhysicalUnit = _inventMovement.remainPhysicalUnit() - physical.parmPhysicalUnit();
        PdsCWRemainQty pdsCWRemainPhysical = _inventMovement.pdsCWRemainPhysical() - physical.parmPdsCWPhysical();
        
        physical.parmRemainPhysical(remainPhysical);
        physical.parmRemainPhysicalUnit(remainPhysicalUnit);
        physical.parmPdsCWRemainPhysical(pdsCWRemainPhysical);
        physical.parmPackingSlipId(_packingSlipId);
        physical.parmPhysicalJournalLine(_custPackingSlipTrans);
        physical.init();
        
        return physical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReturnedProductReceiptInventTransMarking</Name>
				<Source><![CDATA[
    private void updateReturnedProductReceiptInventTransMarking()
    {
        if (movement is InventMov_Virtuel && movement.inventTransOriginId() && movement.markingRefInventTransOrigin())
        {
            InventMov_Virtuel returnInventMovVirtuel = movement as InventMov_Virtuel;
            InventMov_Purch returnInventMovPurch = returnInventMovVirtuel.parmInventMovReference();
            PurchLineType_ProjectPurch returnProjectPurch = returnInventMovPurch.parmInventType();
            PurchLine purchLineloc = returnProjectPurch.parmPurchLine();

            if (purchLineloc.overDeliveryPct() || purchLineloc.underDeliveryPct())
            {
                ttsbegin;
                Query query = new Query();
                QueryBuildDataSource qbdsInventTrans;
                QueryRun queryRun;

                qbdsInventTrans = query.addDataSource(tableNum(InventTrans));
                qbdsInventTrans.update(true);
                qbdsInventTrans.addRange(fieldNum(InventTrans, InventTransOrigin)).value(strFmt("%1, %2", movement.inventTransOriginId(), movement.markingRefInventTransOrigin()));
                qbdsInventTrans.addRange(fieldNum(InventTrans, PackingSlipReturned)).value(queryValue(NoYes::No));
                qbdsInventTrans.addRange(fieldNum(InventTrans, ProjId)).value(SysQuery::valueNotEmptyString());

                queryRun = new QueryRun(query);
                while (queryRun.next())
                {
                    InventTrans inventTrans = queryRun.get(tableNum(InventTrans));

                    if (!inventTrans.MarkingRefInventTransOrigin
                      && ((inventTrans.StatusIssue == StatusIssue::Deducted || inventTrans.StatusIssue == StatusIssue::OnOrder)
                      || (inventTrans.StatusReceipt == StatusReceipt::Received || inventTrans.StatusReceipt == StatusReceipt::Ordered)))
                    {
                        if (inventTrans.InventTransOrigin == movement.markingRefInventTransOrigin())
                        {
                            inventTrans.setMarking(movement.inventTransOriginId());
                        }
                        else
                        {
                            inventTrans.setMarking(movement.markingRefInventTransOrigin());
                        }
                        
                        inventTrans.doUpdate();
                    }
                }
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>